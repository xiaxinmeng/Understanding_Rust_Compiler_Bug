{"sha": "fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRlOWIzMWI2MWFhMjgxYjUwMmU0ZjQ5MjAwZTMwOTBhYThhNGRkMQ==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2015-04-28T08:10:44Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2015-04-28T08:10:44Z"}, "message": "re PR target/63503 ([AArch64] A57 executes fused multiply-add poorly in some situations)\n\n2015-04-28  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    PR target/63503\n    * config.gcc: Add cortex-a57-fma-steering.o to extra_objs for\n    aarch64-*-*.\n    * config/aarch64/t-aarch64: Add a rule for cortex-a57-fma-steering.o.\n    * config/aarch64/aarch64.h (AARCH64_FL_USE_FMA_STEERING_PASS): Define.\n    (AARCH64_TUNE_FMA_STEERING): Likewise.\n    * config/aarch64/aarch64-cores.def: Set\n    AARCH64_FL_USE_FMA_STEERING_PASS for cores with dynamic steering of\n    FMUL/FMADD instructions.\n    * config/aarch64/aarch64.c (aarch64_register_fma_steering): Declare.\n    (aarch64_override_options): Include cortex-a57-fma-steering.h. Call\n    aarch64_register_fma_steering () if AARCH64_TUNE_FMA_STEERING is true.\n    * config/aarch64/cortex-a57-fma-steering.h: New file.\n    * config/aarch64/cortex-a57-fma-steering.c: Likewise.\n\nFrom-SVN: r222512", "tree": {"sha": "feebbec54d03722d68e3d93fcfbe99957828583a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/feebbec54d03722d68e3d93fcfbe99957828583a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0060d7d71ec248c1aadc82783d1a3ef29b30b6ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0060d7d71ec248c1aadc82783d1a3ef29b30b6ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0060d7d71ec248c1aadc82783d1a3ef29b30b6ba"}], "stats": {"total": 1150, "additions": 1147, "deletions": 3}, "files": [{"sha": "070a150b31d525eb7d616de6e787507fc8fbd269", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "patch": "@@ -1,3 +1,20 @@\n+2015-04-28  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR target/63503\n+\t* config.gcc: Add cortex-a57-fma-steering.o to extra_objs for\n+\taarch64-*-*.\n+\t* config/aarch64/t-aarch64: Add a rule for cortex-a57-fma-steering.o.\n+\t* config/aarch64/aarch64.h (AARCH64_FL_USE_FMA_STEERING_PASS): Define.\n+\t(AARCH64_TUNE_FMA_STEERING): Likewise.\n+\t* config/aarch64/aarch64-cores.def: Set\n+\tAARCH64_FL_USE_FMA_STEERING_PASS for cores with dynamic steering of\n+\tFMUL/FMADD instructions.\n+\t* config/aarch64/aarch64.c (aarch64_register_fma_steering): Declare.\n+\t(aarch64_override_options): Include cortex-a57-fma-steering.h.  Call\n+\taarch64_register_fma_steering () if AARCH64_TUNE_FMA_STEERING is true.\n+\t* config/aarch64/cortex-a57-fma-steering.h: New file.\n+\t* config/aarch64/cortex-a57-fma-steering.c: Likewise.\n+\n 2015-04-28  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gensupport.c (std_preds): Add missing codes to address_operand entry."}, {"sha": "f21421b16708b835f63f7312a3c6d41ef5d61f6e", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "patch": "@@ -302,7 +302,7 @@ m32c*-*-*)\n aarch64*-*-*)\n \tcpu_type=aarch64\n \textra_headers=\"arm_neon.h arm_acle.h\"\n-\textra_objs=\"aarch64-builtins.o aarch-common.o\"\n+\textra_objs=\"aarch64-builtins.o aarch-common.o cortex-a57-fma-steering.o\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/aarch64/aarch64-builtins.c\"\n \ttarget_has_targetm_common=yes\n \t;;"}, {"sha": "dfc9cc85413b7c01e4872c05e6be7ca192547198", "filename": "gcc/config/aarch64/aarch64-cores.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def?ref=fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "patch": "@@ -40,13 +40,13 @@\n /* V8 Architecture Processors.  */\n \n AARCH64_CORE(\"cortex-a53\",  cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa53, \"0x41\", \"0xd03\")\n-AARCH64_CORE(\"cortex-a57\",  cortexa57, cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd07\")\n+AARCH64_CORE(\"cortex-a57\",  cortexa57, cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_USE_FMA_STEERING_PASS, cortexa57, \"0x41\", \"0xd07\")\n AARCH64_CORE(\"cortex-a72\",  cortexa72, cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd08\")\n AARCH64_CORE(\"exynos-m1\",   exynosm1,  cortexa57, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, cortexa57, \"0x53\", \"0x001\")\n AARCH64_CORE(\"thunderx\",    thunderx,  thunderx,  8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  \"0x43\", \"0x0a1\")\n AARCH64_CORE(\"xgene1\",      xgene1,    xgene1,    8,  AARCH64_FL_FOR_ARCH8, xgene1, \"0x50\", \"0x000\")\n \n /* V8 big.LITTLE implementations.  */\n \n-AARCH64_CORE(\"cortex-a57.cortex-a53\",  cortexa57cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd07.0xd03\")\n+AARCH64_CORE(\"cortex-a57.cortex-a53\",  cortexa57cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_USE_FMA_STEERING_PASS, cortexa57, \"0x41\", \"0xd07.0xd03\")\n AARCH64_CORE(\"cortex-a72.cortex-a53\",  cortexa72cortexa53, cortexa53, 8,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd08.0xd03\")"}, {"sha": "b8a91dc8fe58df04a6a7b41f3b57dd2dc406cec0", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "patch": "@@ -95,6 +95,7 @@\n #include \"rtl-iter.h\"\n #include \"tm-constrs.h\"\n #include \"sched-int.h\"\n+#include \"cortex-a57-fma-steering.h\"\n \n /* Defined for convenience.  */\n #define POINTER_BYTES (POINTER_SIZE / BITS_PER_UNIT)\n@@ -6884,6 +6885,9 @@ aarch64_override_options (void)\n \talign_functions = aarch64_tune_params->function_align;\n     }\n \n+  if (AARCH64_TUNE_FMA_STEERING)\n+    aarch64_register_fma_steering ();\n+\n   aarch64_override_options_after_change ();\n }\n "}, {"sha": "3fd1b3f0d3296f43d7dfe8d570a3f3443dd22a67", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "patch": "@@ -200,6 +200,8 @@ extern unsigned aarch64_architecture_version;\n #define AARCH64_FL_CRYPTO     (1 << 2)\t/* Has crypto.  */\n #define AARCH64_FL_SLOWMUL    (1 << 3)\t/* A slow multiply core.  */\n #define AARCH64_FL_CRC        (1 << 4)\t/* Has CRC.  */\n+/* Has static dispatch of FMA.  */\n+#define AARCH64_FL_USE_FMA_STEERING_PASS (1 << 5)\n \n /* Has FP and SIMD.  */\n #define AARCH64_FL_FPSIMD     (AARCH64_FL_FP | AARCH64_FL_SIMD)\n@@ -220,6 +222,8 @@ extern unsigned long aarch64_isa_flags;\n /* Macros to test tuning flags.  */\n extern unsigned long aarch64_tune_flags;\n #define AARCH64_TUNE_SLOWMUL       (aarch64_tune_flags & AARCH64_FL_SLOWMUL)\n+#define AARCH64_TUNE_FMA_STEERING \\\n+  (aarch64_tune_flags & AARCH64_FL_USE_FMA_STEERING_PASS)\n \n /* Crypto is an optional extension to AdvSIMD.  */\n #define TARGET_CRYPTO (TARGET_SIMD && AARCH64_ISA_CRYPTO)"}, {"sha": "3d7557ac2b4d3f61e05a45714aaad3117a63ee5a", "filename": "gcc/config/aarch64/cortex-a57-fma-steering.c", "status": "added", "additions": 1088, "deletions": 0, "changes": 1088, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.c?ref=fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "patch": "@@ -0,0 +1,1088 @@\n+/* FMA steering optimization pass for Cortex-A57.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"regs.h\"\n+#include \"insn-config.h\"\n+#include \"hard-reg-set.h\"\n+#include \"dominance.h\"\n+#include \"cfg.h\"\n+#include \"cfganal.h\"\n+#include \"predict.h\"\n+#include \"basic-block.h\"\n+#include \"insn-attr.h\"\n+#include \"machmode.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+#include \"vec.h\"\n+#include \"hash-map.h\"\n+#include \"bitmap.h\"\n+#include \"obstack.h\"\n+#include \"df.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"context.h\"\n+#include \"tree-pass.h\"\n+#include \"regrename.h\"\n+#include \"cortex-a57-fma-steering.h\"\n+\n+#include <list>\n+\n+/* For better performance, the destination of FMADD/FMSUB instructions should\n+   have the same parity as their accumulator register if the accumulator\n+   contains the result of a previous FMUL or FMADD/FMSUB instruction if\n+   targetting Cortex-A57 processors.  Performance is also increased by\n+   otherwise keeping a good balance in the parity of the destination register\n+   of FMUL or FMADD/FMSUB.\n+\n+   This pass ensure that registers are renamed so that these conditions hold.\n+   We reuse the existing register renaming facility from regrename.c to build\n+   dependency chains and expose candidate registers for renaming.\n+\n+\n+   The algorithm has three steps:\n+\n+   First, the functions of the register renaming pass are called.  These\n+   analyze the instructions and produce a list of def/use chains of\n+   instructions.\n+\n+   Next, this information is used to build trees of multiply and\n+   multiply-accumulate instructions.  The roots of these trees are any\n+   multiply, or any multiply-accumulate whose accumulator is not dependent on\n+   a multiply or multiply-accumulate instruction.  A child is added to the\n+   tree where a dependency chain exists between the result of the parent\n+   instruction and the accumulator operand of the child, as in the diagram\n+   below:\n+\n+\t\t fmul s2, s0, s1\n+\t\t/\t\t\\\n+   fmadd s0, s1, s1, s2   fmadd s4, s1, s1 s2\n+\t    |\n+   fmadd s3, s1, s1, s0\n+\n+   Trees made of a single instruction are permitted.\n+\n+   Finally, renaming is performed.  The parity of the destination register at\n+   the root of a tree is checked against the current balance of multiply and\n+   multiply-accumulate on each pipeline.  If necessary, the root of a tree is\n+   renamed, in which case the rest of the tree is then renamed to keep the same\n+   parity in the destination registers of all instructions in the tree.  */\n+\n+\n+\n+/* Forward declarations.  */\n+class fma_node;\n+class fma_root_node;\n+class func_fma_steering;\n+\n+/* Dependencies between FMUL or FMADD/FMSUB instructions and subsequent\n+   FMADD/FMSUB instructions form a graph.  This is because alternatives can\n+   make a register be set by several FMUL or FMADD/FMSUB instructions in\n+   different basic blocks and because of loops.  For ease of browsing, the\n+   connected components of this graph are broken up into forests of trees.\n+   Forests are represented by fma_forest objects, contained in the fma_forests\n+   list.  Using a separate object for the forests allows for a better use of\n+   memory as there is some information that is global to each forest, such as\n+   the number of FMSUB and FMADD/FMSUB instructions currently scheduled on each\n+   floating-point execution pipelines.  */\n+\n+class fma_forest\n+{\n+public:\n+  fma_forest (func_fma_steering *, fma_root_node *, int);\n+  ~fma_forest ();\n+\n+  int get_id ();\n+  std::list<fma_root_node *> *get_roots ();\n+  func_fma_steering *get_globals ();\n+  int get_target_parity ();\n+  void fma_node_created (fma_node *);\n+  void merge_forest (fma_forest *);\n+  void dump_info ();\n+  void dispatch ();\n+\n+private:\n+  /* The list of roots that form this forest.  */\n+  std::list<fma_root_node *> *m_roots;\n+\n+  /* Target parity the destination register of all FMUL and FMADD/FMSUB\n+     instructions in this forest should have.  */\n+  int m_target_parity;\n+\n+  /* Link to the instance of func_fma_steering holding data related to the\n+     FMA steering of the current function (cfun).  */\n+  func_fma_steering *m_globals;\n+\n+  /* Identifier for the forest (used for dumps).  */\n+  int m_id;\n+\n+  /* Total number of nodes in the forest (for statistics).  */\n+  int m_nb_nodes;\n+};\n+\n+class fma_node\n+{\n+public:\n+  fma_node (fma_node *parent, du_chain *chain);\n+  ~fma_node ();\n+\n+  bool root_p ();\n+  fma_forest *get_forest ();\n+  std::list<fma_node *> *get_children ();\n+  rtx_insn *get_insn ();\n+  void add_child (fma_node *);\n+  int get_parity ();\n+  void set_head (du_head *);\n+  void rename (fma_forest *);\n+  void dump_info (fma_forest *);\n+\n+protected:\n+  /* Root node that lead to this node.  */\n+  fma_root_node *m_root;\n+\n+  /* The parent node of this node.  If the node belong to a chain with several\n+     parent nodes, the first one encountered in a depth-first search is chosen\n+     as canonical parent.  */\n+  fma_node *m_parent;\n+\n+  /* The list of child nodes.  If a chain contains several parent nodes, one is\n+     chosen as canonical parent and the others will have no children.  */\n+  std::list<fma_node *> *m_children;\n+\n+  /* The associated DU_HEAD chain that the insn represented by this object\n+     is (one of) the root of.  When a chain contains several roots, the non\n+     canonical ones have this field set to NULL.  */\n+  struct du_head *m_head;\n+\n+  /* The FMUL or FMADD/FMSUB instruction this object corresponds to.  */\n+  rtx_insn *m_insn;\n+};\n+\n+class fma_root_node : public fma_node\n+{\n+public:\n+  fma_root_node (func_fma_steering *, du_chain *, int);\n+\n+  fma_forest *get_forest ();\n+  void set_forest (fma_forest *);\n+  void dump_info (fma_forest *);\n+\n+private:\n+  /* The forest this node belonged to when it was created.  */\n+  fma_forest *m_forest;\n+};\n+\n+/* Class holding all data and methods relative to the FMA steering of a given\n+   function.  The FMA steering pass could then run in parallel for different\n+   functions.  */\n+\n+class func_fma_steering\n+{\n+public:\n+  func_fma_steering ();\n+  ~func_fma_steering ();\n+\n+  int get_fpu_balance ();\n+  void remove_forest (fma_forest *);\n+  bool put_node (fma_node *);\n+  void update_balance (int);\n+  fma_node *get_fma_node (rtx_insn *);\n+  void analyze_fma_fmul_insn (fma_forest *, du_chain *, du_head_p);\n+  void execute_fma_steering ();\n+\n+private:\n+  void dfs (void (*) (fma_forest *), void (*) (fma_forest *, fma_root_node *),\n+\t    void (*) (fma_forest *, fma_node *), bool);\n+  void analyze ();\n+  void rename_fma_trees ();\n+\n+  /* Mapping between FMUL or FMADD/FMSUB instructions and the associated\n+     fma_node object.  Used when analyzing an instruction that is a root of\n+     a chain to find if such an object was created because this instruction\n+     is also a use in another chain.  */\n+  hash_map<rtx_insn *, fma_node *> *m_insn_fma_head_map;\n+\n+  /* A list of all the forests in a given function.  */\n+  std::list<fma_forest *> m_fma_forests;\n+\n+  /* Balance of FMUL and FMADD/FMSUB instructions between the two FPU\n+     pipelines:\n+     < 0: more instruction dispatched to the first pipeline\n+     == 0: perfect balance\n+     > 0: more instruction dispatched to the second pipeline.  */\n+  int m_fpu_balance;\n+\n+  /* Identifier for the next forest created.  */\n+  int m_next_forest_id;\n+};\n+\n+/* Rename the register HEAD->regno in all the insns in the chain HEAD to any\n+   register not in the set UNAVAILABLE.  Adapted from rename_chains in\n+   regrename.c.  */\n+\n+static bool\n+rename_single_chain (du_head_p head, HARD_REG_SET *unavailable)\n+{\n+  int best_new_reg;\n+  int n_uses = 0;\n+  struct du_chain *tmp;\n+  int reg = head->regno;\n+  enum reg_class super_class = NO_REGS;\n+\n+  if (head->cannot_rename)\n+    return false;\n+\n+  if (fixed_regs[reg] || global_regs[reg]\n+      || (frame_pointer_needed && reg == HARD_FRAME_POINTER_REGNUM))\n+    return false;\n+\n+  /* Iterate over elements in the chain in order to:\n+     1. Count number of uses, and narrow the set of registers we can\n+\tuse for renaming.\n+     2. Compute the superunion of register classes in this chain.  */\n+  for (tmp = head->first; tmp; tmp = tmp->next_use)\n+    {\n+      if (DEBUG_INSN_P (tmp->insn))\n+\tcontinue;\n+      n_uses++;\n+      IOR_COMPL_HARD_REG_SET (*unavailable, reg_class_contents[tmp->cl]);\n+      super_class = reg_class_superunion[(int) super_class][(int) tmp->cl];\n+    }\n+\n+  if (n_uses < 1)\n+    return false;\n+\n+  best_new_reg = find_rename_reg (head, super_class, unavailable, reg,\n+\t\t\t\t  false);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Register %s in insn %d\", reg_names[reg],\n+\t       INSN_UID (head->first->insn));\n+      if (head->need_caller_save_reg)\n+\tfprintf (dump_file, \" crosses a call\");\n+    }\n+\n+  if (best_new_reg == reg)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"; no available better choice\\n\");\n+      return false;\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \", renamed as %s\\n\", reg_names[best_new_reg]);\n+\n+  regrename_do_replace (head, best_new_reg);\n+  df_set_regs_ever_live (best_new_reg, true);\n+  return true;\n+}\n+\n+/* Return whether T is the attribute of a FMADD/FMSUB-like instruction.  */\n+\n+static bool\n+is_fmac_op (enum attr_type t)\n+{\n+  return (t == TYPE_FMACS) || (t == TYPE_FMACD) || (t == TYPE_NEON_FP_MLA_S);\n+}\n+\n+/* Return whether T is the attribute of a FMUL instruction.  */\n+\n+static bool\n+is_fmul_op (enum attr_type t)\n+{\n+  return (t == TYPE_FMULS) || (t == TYPE_FMULD) || (t == TYPE_NEON_FP_MUL_S);\n+}\n+\n+/* Return whether INSN is an FMUL (if FMUL_OK is true) or FMADD/FMSUB\n+   instruction.  */\n+\n+static bool\n+is_fmul_fmac_insn (rtx_insn *insn, bool fmul_ok)\n+{\n+  enum attr_type t;\n+\n+  if (!NONDEBUG_INSN_P (insn))\n+    return false;\n+\n+  if (recog_memoized (insn) < 0)\n+    return false;\n+\n+  /* Only consider chain(s) this instruction is a root of if this is an FMUL or\n+     FMADD/FMSUB instruction.  This allows to avoid browsing chains of all\n+     instructions for FMUL or FMADD/FMSUB in them.  */\n+  t = get_attr_type (insn);\n+  return is_fmac_op (t) || (fmul_ok && is_fmul_op (t));\n+}\n+\n+\n+/*\n+ * Class fma_forest method definitions.\n+ */\n+\n+fma_forest::fma_forest (func_fma_steering *fma_steer, fma_root_node *fma_root,\n+\t\t\tint id)\n+{\n+      memset (this, 0, sizeof (*this));\n+      this->m_globals = fma_steer;\n+      this->m_roots = new std::list<fma_root_node *>;\n+      this->m_roots->push_back (fma_root);\n+      this->m_id = id;\n+}\n+\n+fma_forest::~fma_forest ()\n+{\n+  delete this->m_roots;\n+}\n+\n+int\n+fma_forest::get_id ()\n+{\n+  return this->m_id;\n+}\n+\n+std::list<fma_root_node *> *\n+fma_forest::get_roots ()\n+{\n+  return this->m_roots;\n+}\n+\n+func_fma_steering *\n+fma_forest::get_globals ()\n+{\n+  return this->m_globals;\n+}\n+\n+int\n+fma_forest::get_target_parity ()\n+{\n+  return this->m_target_parity;\n+}\n+\n+/* Act on the creation of NODE by updating statistics in FOREST and adding an\n+   entry for it in the func_fma_steering hashmap.  */\n+\n+void fma_forest::fma_node_created (fma_node *node)\n+{\n+  bool created = !this->m_globals->put_node (node);\n+\n+  gcc_assert (created);\n+  this->m_nb_nodes++;\n+}\n+\n+/* Merge REF_FOREST and OTHER_FOREST together, making REF_FOREST the canonical\n+   fma_forest object to represent both.  */\n+\n+void\n+fma_forest::merge_forest (fma_forest *other_forest)\n+{\n+  std::list<fma_root_node *> *other_roots;\n+  std::list<fma_root_node *>::iterator other_root_iter;\n+\n+  if (this == other_forest)\n+    return;\n+\n+  other_roots = other_forest->m_roots;\n+\n+  /* Update root nodes' pointer to forest.  */\n+  for (other_root_iter = other_roots->begin ();\n+       other_root_iter != other_roots->end (); other_root_iter++)\n+    (*other_root_iter)->set_forest (this);\n+\n+  /* Remove other_forest from the list of forests and move its tree roots in\n+     the list of tree roots of ref_forest.  */\n+  this->m_globals->remove_forest (other_forest);\n+  this->m_roots->splice (this->m_roots->begin (), *other_roots);\n+  delete other_forest;\n+\n+  this->m_nb_nodes += other_forest->m_nb_nodes;\n+}\n+\n+/* Dump information about the forest FOREST.  */\n+\n+void\n+fma_forest::dump_info ()\n+{\n+  gcc_assert (dump_file);\n+\n+  fprintf (dump_file, \"Forest #%d has %d nodes\\n\", this->m_id,\n+\t   this->m_nb_nodes);\n+}\n+\n+/* Wrapper around fma_forest::dump_info for use as parameter of function\n+   pointer type in func_fma_steering::dfs.  */\n+\n+static void\n+dump_forest_info (fma_forest *forest)\n+{\n+  forest->dump_info ();\n+}\n+\n+/* Dispatch forest to the least utilized pipeline.  */\n+\n+void\n+fma_forest::dispatch ()\n+{\n+  this->m_target_parity = this->m_roots->front ()->get_parity ();\n+  int fpu_balance = this->m_globals->get_fpu_balance ();\n+  if (fpu_balance != 0)\n+    this->m_target_parity = (fpu_balance < 0);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Target parity for forest #%d: %s\\n\", this->m_id,\n+\t     this->m_target_parity ? \"odd\" : \"even\");\n+}\n+\n+/* Wrapper around fma_forest::dispatch for use as parameter of function pointer\n+   type in func_fma_steering::dfs.  */\n+\n+static void\n+dispatch_forest (fma_forest *forest)\n+{\n+  forest->dispatch ();\n+}\n+\n+fma_node::fma_node (fma_node *parent, du_chain *chain)\n+{\n+  memset (this, 0, sizeof (*this));\n+  this->m_parent = parent;\n+  this->m_children = new std::list<fma_node *>;\n+  this->m_insn = chain->insn;\n+  /* root_p () cannot be used to check for root before root is set.  */\n+  if (this->m_parent == this)\n+    this->m_root = static_cast<fma_root_node *> (parent);\n+  else\n+    {\n+      this->m_root = parent->m_root;\n+      this->get_forest ()->fma_node_created (this);\n+    }\n+}\n+\n+fma_node::~fma_node ()\n+{\n+  delete this->m_children;\n+}\n+\n+std::list<fma_node *> *\n+fma_node::get_children ()\n+{\n+  return this->m_children;\n+}\n+\n+rtx_insn *\n+fma_node::get_insn ()\n+{\n+  return this->m_insn;\n+}\n+\n+void\n+fma_node::set_head (du_head *head)\n+{\n+  gcc_assert (!this->m_head);\n+  this->m_head = head;\n+}\n+\n+/* Add a child to this node in the list of children.  */\n+\n+void\n+fma_node::add_child (fma_node *child)\n+{\n+  this->m_children->push_back (child);\n+}\n+\n+/* Return the parity of the destination register of the instruction represented\n+   by this node.  */\n+\n+int\n+fma_node::get_parity ()\n+{\n+  return this->m_head->regno % 2;\n+}\n+\n+/* Get the actual forest associated with a non root node as the one the node\n+   points to might have been merged into another one.  In that case the pointer\n+   in the root nodes are updated so we return the forest pointer of a root node\n+   pointed to by the initial forest.  Despite being a oneliner, this method is\n+   defined here as it references a method from fma_root_node.  */\n+\n+fma_forest *\n+fma_node::get_forest ()\n+{\n+  return this->m_root->get_forest ();\n+}\n+\n+/* Return whether a node is a root node.  */\n+\n+bool\n+fma_node::root_p ()\n+{\n+  return this->m_root == this;\n+}\n+\n+/* Dump information about the children of node FMA_NODE in forest FOREST.  */\n+\n+void\n+fma_node::dump_info (ATTRIBUTE_UNUSED fma_forest *forest)\n+{\n+  struct du_chain *chain;\n+  std::list<fma_node *>::iterator fma_child;\n+\n+  gcc_assert (dump_file);\n+\n+  if (this->get_children ()->empty ())\n+    return;\n+\n+  fprintf (dump_file, \"Instruction(s)\");\n+  for (chain = this->m_head->first; chain; chain = chain->next_use)\n+    {\n+      if (!is_fmul_fmac_insn (chain->insn, true))\n+\tcontinue;\n+\n+      if (chain->loc != &SET_DEST (PATTERN (chain->insn)))\n+\tcontinue;\n+\n+      fprintf (dump_file, \" %d\", INSN_UID (chain->insn));\n+    }\n+\n+  fprintf (dump_file, \" is(are) accumulator dependency of instructions\");\n+  for (fma_child = this->get_children ()->begin ();\n+       fma_child != this->get_children ()->end (); fma_child++)\n+    fprintf (dump_file, \" %d\", INSN_UID ((*fma_child)->m_insn));\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Wrapper around fma_node::dump_info for use as parameter of function pointer\n+   type in func_fma_steering::dfs.  */\n+\n+static void\n+dump_tree_node_info (fma_forest *forest, fma_node *node)\n+{\n+  node->dump_info (forest);\n+}\n+\n+/* Rename the destination register of a single FMUL or FMADD/FMSUB instruction\n+   represented by FMA_NODE to a register that respect the target parity for\n+   FOREST or with same parity of the instruction represented by its parent node\n+   if it has one.  */\n+\n+void\n+fma_node::rename (fma_forest *forest)\n+{\n+  int cur_parity, target_parity;\n+\n+  /* This is alternate root of a chain and thus has no children.  It will be\n+     renamed when processing the canonical root for that chain.  */\n+  if (!this->m_head)\n+    return;\n+\n+  target_parity = forest->get_target_parity ();\n+  if (this->m_parent)\n+    target_parity = this->m_parent->get_parity ();\n+  cur_parity = this->get_parity ();\n+\n+  /* Rename if parity differs.  */\n+  if (cur_parity != target_parity)\n+    {\n+      rtx_insn *insn = this->m_insn;\n+      HARD_REG_SET unavailable;\n+      enum machine_mode mode;\n+      int reg;\n+\n+      if (dump_file)\n+\t{\n+\t  unsigned cur_dest_reg = this->m_head->regno;\n+\n+\t  fprintf (dump_file, \"FMA or FMUL at insn %d but destination \"\n+\t\t   \"register (%s) has different parity from expected to \"\n+\t\t   \"maximize FPU pipeline utilization\\n\", INSN_UID (insn),\n+\t\t   reg_names[cur_dest_reg]);\n+\t}\n+\n+      /* Don't clobber traceback for noreturn functions.  */\n+      CLEAR_HARD_REG_SET (unavailable);\n+      if (frame_pointer_needed)\n+\t{\n+\t  add_to_hard_reg_set (&unavailable, Pmode, FRAME_POINTER_REGNUM);\n+\t  add_to_hard_reg_set (&unavailable, Pmode, HARD_FRAME_POINTER_REGNUM);\n+\t}\n+\n+      /* Exclude registers with wrong parity.  */\n+      mode = GET_MODE (SET_DEST (PATTERN (insn)));\n+      for (reg = cur_parity; reg < FIRST_PSEUDO_REGISTER; reg += 2)\n+\tadd_to_hard_reg_set (&unavailable, mode, reg);\n+\n+      if (!rename_single_chain (this->m_head, &unavailable))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Destination register of insn %d could not be \"\n+\t\t     \"renamed. Dependent FMA insns will use this parity from \"\n+\t\t     \"there on.\\n\", INSN_UID (insn));\n+\t}\n+      else\n+\tcur_parity = target_parity;\n+    }\n+\n+  forest->get_globals ()->update_balance (cur_parity);\n+}\n+\n+/* Wrapper around fma_node::dump_info for use as parameter of function pointer\n+   type in func_fma_steering::dfs.  */\n+\n+static void\n+rename_fma_node (fma_forest *forest, fma_node *node)\n+{\n+  node->rename (forest);\n+}\n+\n+fma_root_node::fma_root_node (func_fma_steering *globals, du_chain *chain,\n+\t\t\t      int id) : fma_node (this, chain)\n+{\n+  this->m_forest = new fma_forest (globals, this, id);\n+  this->m_forest->fma_node_created (this);\n+}\n+\n+fma_forest *\n+fma_root_node::get_forest ()\n+{\n+  return this->m_forest;\n+}\n+\n+void\n+fma_root_node::set_forest (fma_forest *ref_forest)\n+{\n+  this->m_forest = ref_forest;\n+}\n+\n+/* Dump information about the roots of forest FOREST.  */\n+\n+void\n+fma_root_node::dump_info (fma_forest *forest)\n+{\n+  gcc_assert (dump_file);\n+\n+  if (this == forest->get_roots ()->front ())\n+    fprintf (dump_file, \"Instruction(s) at root of forest #%d:\",\n+\t     forest->get_id ());\n+  fprintf (dump_file, \" %d\", INSN_UID (this->m_insn));\n+  if (this == forest->get_roots ()->back ())\n+    fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Wrapper around fma_root_node::dump_info for use as parameter of function\n+   pointer type in func_fma_steering::dfs.  */\n+\n+static void\n+dump_tree_root_info (fma_forest *forest, fma_root_node *node)\n+{\n+  node->dump_info (forest);\n+}\n+\n+func_fma_steering::func_fma_steering () : m_fpu_balance (0)\n+{\n+  this->m_insn_fma_head_map = new hash_map<rtx_insn *, fma_node *>;\n+  this->m_fma_forests.clear ();\n+  this->m_next_forest_id = 0;\n+}\n+\n+func_fma_steering::~func_fma_steering ()\n+{\n+  delete this->m_insn_fma_head_map;\n+}\n+\n+int\n+func_fma_steering::get_fpu_balance ()\n+{\n+  return this->m_fpu_balance;\n+}\n+\n+void\n+func_fma_steering::remove_forest (fma_forest *forest)\n+{\n+  this->m_fma_forests.remove (forest);\n+}\n+\n+/* Memorize the mapping of this instruction to its fma_node object and return\n+   whether such a mapping existed.  */\n+\n+bool\n+func_fma_steering::put_node (fma_node *node)\n+{\n+  return this->m_insn_fma_head_map->put (node->get_insn (), node);\n+}\n+\n+/* Update the current balance considering a node with the given PARITY.  */\n+\n+void\n+func_fma_steering::update_balance (int parity)\n+{\n+  this->m_fpu_balance = parity ? this->m_fpu_balance + 1\n+\t\t\t       : this->m_fpu_balance - 1;\n+}\n+\n+/* Return whether an fma_node object exists for instruction INSN and, if not,\n+   allocate one in *RET.  */\n+\n+fma_node *\n+func_fma_steering::get_fma_node (rtx_insn *insn)\n+{\n+  fma_node **fma_slot;\n+\n+  fma_slot = this->m_insn_fma_head_map->get (insn);\n+  if (fma_slot)\n+    return *fma_slot;\n+  return NULL;\n+}\n+\n+/* Allocate and initialize fma_node objects for the FMUL or FMADD/FMSUB\n+   instruction in CHAIN->insn and its dependent FMADD/FMSUB instructions, all\n+   part of FOREST.  For the children, the associated head is left untouched\n+   (and thus null) as this function will be called again when considering the\n+   chain where they are def.  For the parent, the chain is given in HEAD.  */\n+\n+void\n+func_fma_steering::analyze_fma_fmul_insn (fma_forest *ref_forest,\n+\t\t\t\t\t  du_chain *chain, du_head_p head)\n+{\n+  fma_forest *forest;\n+  fma_node *node = this->get_fma_node (chain->insn);\n+\n+  /* This is a root node.  */\n+  if (!node)\n+    {\n+      fma_root_node *root_node;\n+\n+      root_node = new fma_root_node (this, chain, this->m_next_forest_id++);\n+      forest = root_node->get_forest ();\n+      node = root_node;\n+\n+      /* Until proved otherwise, assume this root is not part of an existing\n+\t forest and thus add its forest to the list of forests.  */\n+      this->m_fma_forests.push_back (forest);\n+    }\n+  else\n+    forest = node->get_forest ();\n+\n+  node->set_head (head);\n+\n+  /* fma_node is part of a chain with several defs, one of them having already\n+     been processed.  The root of that already processed def is the canonical\n+     one and the root of fma_node is added to its forest.  No need to process\n+     the children nodes as they were already processed when the other def was\n+     processed.  */\n+  if (ref_forest)\n+    {\n+      ref_forest->merge_forest (forest);\n+      return;\n+    }\n+\n+  for (chain = head->first; chain; chain = chain->next_use)\n+    {\n+      fma_node *child_fma;\n+      rtx fma_rtx, *accum_rtx_p;\n+\n+      if (!is_fmul_fmac_insn (chain->insn, false))\n+\tcontinue;\n+\n+      /* Get FMA rtx.  */\n+      fma_rtx = SET_SRC (PATTERN (chain->insn));\n+      /* FMA is negated.  */\n+      if (GET_CODE (fma_rtx) == NEG)\n+\tfma_rtx = XEXP (fma_rtx, 0);\n+      /* Get accumulator rtx.  */\n+      accum_rtx_p = &XEXP (fma_rtx, 2);\n+      /* Accumulator is negated.  */\n+      if (!REG_P (*accum_rtx_p))\n+\taccum_rtx_p = &XEXP (*accum_rtx_p, 0);\n+\n+      /* This du_chain structure is not for the accumulator register.  */\n+      if (accum_rtx_p != chain->loc)\n+\tcontinue;\n+\n+      /* If object already created, this is a loop carried dependency.  We\n+\t don't include this object in the children as we want trees for\n+\t rename_fma_trees to not be an infinite loop.  */\n+      if (this->get_fma_node (chain->insn))\n+\tcontinue;\n+\n+      child_fma = new fma_node (node, chain);\n+\n+      /* Memorize the mapping of this instruction to its fma_node object\n+\t as it will be processed for the chain starting at its destination\n+\t register later.  */\n+\n+      /* Link to siblings.  */\n+      node->add_child (child_fma);\n+    }\n+}\n+\n+/* Perform a depth-first search of the forests of fma_node in\n+   THIS->m_fma_forests, calling PROCESS_FOREST () on each fma_forest object in\n+   THIS->m_fma_forests list, PROCESS_ROOT () on each tree root and\n+   PROCESS_NODE () on each node.  If FREE is true, free all std::list in the\n+   same dfs.  */\n+\n+void\n+func_fma_steering::dfs (void (*process_forest) (fma_forest *),\n+\t\t\tvoid (*process_root) (fma_forest *, fma_root_node *),\n+\t\t\tvoid (*process_node) (fma_forest *, fma_node *),\n+\t\t\tbool free)\n+{\n+  vec<fma_node *> to_process;\n+  std::list<fma_forest *>::iterator forest_iter;\n+\n+  to_process.create (0);\n+\n+  /* For each forest.  */\n+  for (forest_iter = this->m_fma_forests.begin ();\n+       forest_iter != this->m_fma_forests.end (); forest_iter++)\n+    {\n+      std::list<fma_root_node *>::iterator root_iter;\n+\n+      if (process_forest)\n+\tprocess_forest (*forest_iter);\n+\n+      /* For each tree root in this forest.  */\n+      for (root_iter = (*forest_iter)->get_roots ()->begin ();\n+\t   root_iter != (*forest_iter)->get_roots ()->end (); root_iter++)\n+\t{\n+\t  if (process_root)\n+\t    process_root (*forest_iter, *root_iter);\n+\t  to_process.safe_push (*root_iter);\n+\t}\n+\n+      /* For each tree node in this forest.  */\n+      while (!to_process.is_empty ())\n+\t{\n+\t  fma_node *node;\n+\t  std::list<fma_node *>::iterator child_iter;\n+\n+\t  node = to_process.pop ();\n+\n+\t  if (process_node)\n+\t    process_node (*forest_iter, node);\n+\n+\t  /* Absence of children might indicate an alternate root of a *chain*.\n+\t     It's ok to skip it here as the chain will be renamed when\n+\t     processing the canonical root for that chain.  */\n+\t  if (node->get_children ()->empty ())\n+\t    continue;\n+\n+\t  for (child_iter = node->get_children ()->begin ();\n+\t       child_iter != node->get_children ()->end (); child_iter++)\n+\t    to_process.safe_push (*child_iter);\n+\t  if (free)\n+\t    {\n+\t      if (node->root_p ())\n+\t\tdelete static_cast<fma_root_node *> (node);\n+\t      else\n+\t\tdelete node;\n+\t    }\n+\t}\n+      if (free)\n+\tdelete *forest_iter;\n+    }\n+\n+  to_process.release ();\n+}\n+\n+/* Build the dependency trees of FMUL and FMADD/FMSUB instructions.  */\n+\n+void\n+func_fma_steering::analyze ()\n+{\n+  int i, n_blocks, *bb_dfs_preorder;\n+  basic_block bb;\n+  rtx_insn *insn;\n+\n+  bb_dfs_preorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  n_blocks = pre_and_rev_post_order_compute (bb_dfs_preorder, NULL, false);\n+\n+  /* Browse the graph of basic blocks looking for FMUL or FMADD/FMSUB\n+     instructions.  */\n+  for (i = 0; i < n_blocks; i++)\n+    {\n+      bb = BASIC_BLOCK_FOR_FN (cfun, bb_dfs_preorder[i]);\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  operand_rr_info *dest_op_info;\n+\t  struct du_chain *chain;\n+\t  unsigned dest_regno;\n+\t  fma_forest *forest;\n+\t  du_head_p head;\n+\t  int i;\n+\n+\t  if (!is_fmul_fmac_insn (insn, true))\n+\t    continue;\n+\n+\t  /* Search the chain where this instruction is (one of) the root.  */\n+\t  dest_op_info = insn_rr[INSN_UID (insn)].op_info;\n+\t  dest_regno = REGNO (SET_DEST (PATTERN (insn)));\n+\t  for (i = 0; i < dest_op_info->n_chains; i++)\n+\t    {\n+\t      /* The register tracked by this chain does not match the\n+\t\t destination register of insn.  */\n+\t      if (dest_op_info->heads[i]->regno != dest_regno)\n+\t\tcontinue;\n+\n+\t      head = dest_op_info->heads[i];\n+\t      /* The chain was merged in another, find the new head.  */\n+\t      if (!head->first)\n+\t\thead = regrename_chain_from_id (head->id);\n+\n+\t      /* Search the chain element for this instruction and, if another\n+\t\t FMUL or FMADD/FMSUB instruction was already processed, note\n+\t\t the forest of its tree.  */\n+\t      forest = NULL;\n+\t      for (chain = head->first; chain; chain = chain->next_use)\n+\t\t{\n+\t\t  fma_node **fma_slot;\n+\n+\t\t  if (!is_fmul_fmac_insn (chain->insn, true))\n+\t\t    continue;\n+\n+\t\t  /* This is a use, continue.  */\n+\t\t  if (chain->loc != &SET_DEST (PATTERN (chain->insn)))\n+\t\t    continue;\n+\n+\t\t  if (chain->insn == insn)\n+\t\t    break;\n+\n+\t\t  fma_slot = this->m_insn_fma_head_map->get (chain->insn);\n+\t\t  if (fma_slot && (*fma_slot)->get_children ())\n+\t\t    forest = (*fma_slot)->get_forest ();\n+\t\t}\n+\t      if (chain)\n+\t\tbreak;\n+\t    }\n+\n+\t  /* We didn't find a chain with a def for this instruction.  */\n+\t  gcc_assert (i < dest_op_info->n_chains);\n+\n+\t  this->analyze_fma_fmul_insn (forest, chain, head);\n+\t}\n+    }\n+  free (bb_dfs_preorder);\n+\n+  if (dump_file)\n+    this->dfs (dump_forest_info, dump_tree_root_info, dump_tree_node_info,\n+\t       false);\n+}\n+\n+/* Perform the renaming of all chains with FMUL or FMADD/FMSUB involved with\n+   the objective of keeping FPU pipeline balanced in term of instructions and\n+   having FMADD/FMSUB with dependencies on previous FMUL or FMADD/FMSUB be\n+   scheduled on the same pipeline.  */\n+\n+void\n+func_fma_steering::rename_fma_trees ()\n+{\n+  this->dfs (dispatch_forest, NULL, rename_fma_node, true);\n+\n+  if (dump_file && !this->m_fma_forests.empty ())\n+    {\n+      fprintf (dump_file, \"Function %s has \", current_function_name ());\n+      if (this->m_fpu_balance == 0)\n+\tfprintf (dump_file, \"perfect balance of FMUL/FMA chains between the \"\n+\t\t \"two FPU pipelines\\n\");\n+      else if (this->m_fpu_balance > 0)\n+\tfprintf (dump_file, \"%d more FMUL/FMA chains scheduled on the second \"\n+\t\t \"FPU pipeline\\n\", this->m_fpu_balance);\n+      else /* this->m_fpu_balance < 0 */\n+\tfprintf (dump_file, \"%d more FMUL/FMA chains scheduled on the first \"\n+\t\t \"FPU pipeline\\n\", - this->m_fpu_balance);\n+    }\n+}\n+\n+/* Execute FMA steering pass.  */\n+\n+void\n+func_fma_steering::execute_fma_steering ()\n+{\n+  df_set_flags (DF_LR_RUN_DCE);\n+  df_note_add_problem ();\n+  df_analyze ();\n+  df_set_flags (DF_DEFER_INSN_RESCAN);\n+\n+  regrename_init (true);\n+  regrename_analyze (NULL);\n+  this->analyze ();\n+  this->rename_fma_trees ();\n+  regrename_finish ();\n+}\n+\n+const pass_data pass_data_fma_steering =\n+{\n+  RTL_PASS, /* type */\n+  \"fma_steering\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_df_finish, /* todo_flags_finish */\n+};\n+\n+class pass_fma_steering : public rtl_opt_pass\n+{\n+public:\n+  pass_fma_steering (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_fma_steering, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return optimize >= 2;\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      func_fma_steering *fma_steering = new func_fma_steering;\n+      fma_steering->execute_fma_steering ();\n+      delete fma_steering;\n+      return 0;\n+    }\n+\n+}; // class pass_fma_steering\n+\n+/* Create a new fma steering pass instance.  */\n+\n+static rtl_opt_pass *\n+make_pass_fma_steering (gcc::context *ctxt)\n+{\n+  return new pass_fma_steering (ctxt);\n+}\n+\n+/* Register the FMA steering pass to the pass manager.  */\n+\n+void\n+aarch64_register_fma_steering ()\n+{\n+  opt_pass *pass_fma_steering = make_pass_fma_steering (g);\n+\n+  static struct register_pass_info fma_steering_info\n+    = { pass_fma_steering, \"rnreg\", 1, PASS_POS_INSERT_AFTER };\n+\n+  register_pass (&fma_steering_info);\n+}"}, {"sha": "e8915acb42396d08eb68cb18fbfc9a273b96c54c", "filename": "gcc/config/aarch64/cortex-a57-fma-steering.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fcortex-a57-fma-steering.h?ref=fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "patch": "@@ -0,0 +1,22 @@\n+/* This file contains declarations for the FMA steering optimization\n+   pass for Cortex-A57.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+void aarch64_register_fma_steering (void);"}, {"sha": "0371203f0a3490e10c45ec61b284dbf68f28ad1a", "filename": "gcc/config/aarch64/t-aarch64", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde9b31b61aa281b502e4f49200e3090aa8a4dd1/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ft-aarch64?ref=fde9b31b61aa281b502e4f49200e3090aa8a4dd1", "patch": "@@ -48,6 +48,15 @@ aarch-common.o: $(srcdir)/config/arm/aarch-common.c $(CONFIG_H) $(SYSTEM_H) \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/arm/aarch-common.c\n \n+cortex-a57-fma-steering.o: $(srcdir)/config/aarch64/cortex-a57-fma-steering.c \\\n+    $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(REGS_H) insn-config.h $(RTL_BASE_H) \\\n+    dominance.h cfg.h cfganal.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(RECOG_H) \\\n+    output.h hash-map.h $(DF_H) $(OBSTACK_H) $(TARGET_H) $(RTL_H) \\\n+    $(CONTEXT_H) $(TREE_PASS_H) regrename.h \\\n+    $(srcdir)/config/aarch64/cortex-a57-fma-steering.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/aarch64/cortex-a57-fma-steering.c\n+\n comma=,\n MULTILIB_OPTIONS    = $(subst $(comma),/, $(patsubst %, mabi=%, $(subst $(comma),$(comma)mabi=,$(TM_MULTILIB_CONFIG))))\n MULTILIB_DIRNAMES   = $(subst $(comma), ,$(TM_MULTILIB_CONFIG))"}]}