{"sha": "648ebe7bd0317b3615835d7733c2f637a5a065d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ4ZWJlN2JkMDMxN2IzNjE1ODM1ZDc3MzNjMmY2MzdhNWEwNjVkMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-14T22:43:01Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-14T22:43:01Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r982", "tree": {"sha": "2c5ab8a2ae8a0459e5e4be1708cfce3158a52dd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c5ab8a2ae8a0459e5e4be1708cfce3158a52dd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/648ebe7bd0317b3615835d7733c2f637a5a065d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/648ebe7bd0317b3615835d7733c2f637a5a065d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/648ebe7bd0317b3615835d7733c2f637a5a065d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/648ebe7bd0317b3615835d7733c2f637a5a065d1/comments", "author": null, "committer": null, "parents": [{"sha": "bec42276e00a9bfcb30169f36fa25551507ded96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec42276e00a9bfcb30169f36fa25551507ded96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bec42276e00a9bfcb30169f36fa25551507ded96"}], "stats": {"total": 340, "additions": 214, "deletions": 126}, "files": [{"sha": "0460699b44eb7860a3e94af49eca9e9bce9e7154", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648ebe7bd0317b3615835d7733c2f637a5a065d1/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648ebe7bd0317b3615835d7733c2f637a5a065d1/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=648ebe7bd0317b3615835d7733c2f637a5a065d1", "patch": "@@ -1589,7 +1589,7 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n #define IDENT_ASM_OP\t\t\"ident\"\n #define FILE_ASM_OP\t\t\"file\"\n #define SECTION_ASM_OP\t\t\"section\"\n-#define DEF_ASM_OP\t\t\"def\"\n+#define SET_ASM_OP\t\t\"def\"\n #define GLOBAL_ASM_OP\t\t\"global\"\n #define ALIGN_ASM_OP\t\t\"align\"\n #define SKIP_ASM_OP\t\t\"zero\""}, {"sha": "9aaed92de10803db1d4c59b0c2efa4906b9e8473", "filename": "gcc/config/sparc/sysv4.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648ebe7bd0317b3615835d7733c2f637a5a065d1/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648ebe7bd0317b3615835d7733c2f637a5a065d1/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=648ebe7bd0317b3615835d7733c2f637a5a065d1", "patch": "@@ -46,7 +46,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #undef STRING_ASM_OP\n #undef COMMON_ASM_OP\n #undef SKIP_ASM_OP\n-#undef DEF_ASM_OP\t/* Has no equivalent.  See ASM_OUTPUT_DEF below.  */\n \n /* Provide a set of pre-definitions and pre-assertions appropriate for\n    the Sparc running svr4.  __svr4__ is our extension.  */"}, {"sha": "4cd95e7cf512a5e19a158c83c36351db7d17c672", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 213, "deletions": 124, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648ebe7bd0317b3615835d7733c2f637a5a065d1/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648ebe7bd0317b3615835d7733c2f637a5a065d1/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=648ebe7bd0317b3615835d7733c2f637a5a065d1", "patch": "@@ -33,6 +33,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"output.h\"\n #include \"defaults.h\"\n \n+#ifndef DWARF_VERSION\n+#define DWARF_VERSION 1\n+#endif\n+\n /* #define NDEBUG 1 */\n #include <assert.h>\n \n@@ -314,16 +318,16 @@ static unsigned lookup_filename ();\n #ifndef ASM_BYTE_OP\n #define ASM_BYTE_OP\t\t\".byte\"\n #endif\n-#ifndef DEF_ASM_OP\n-#define DEF_ASM_OP\t\t\".set\"\n+#ifndef SET_ASM_OP\n+#define SET_ASM_OP\t\t\".set\"\n #endif\n \n /* Pseudo-ops for pushing the current section onto the section stack (and\n    simultaneously changing to a new section) and for poping back to the\n    section we were in immediately before this one.  Note that most svr4\n    assemblers only maintain a one level stack... you can push all the\n    sections you want, but you can only pop out one level.  (The sparc\n-   svr4 assembler might be an exception to this general rule.)  That's\n+   svr4 assembler is an exception to this general rule.)  That's\n    OK because we only use at most one level of the section stack herein.  */\n \n #ifndef PUSHSECTION_ASM_OP\n@@ -390,13 +394,14 @@ static unsigned lookup_filename ();\n    but typically, you should never need to override these.\n \n    These labels have been hacked (temporarily) so that they all begin with\n-   a `.L' sequence so as to appease the sparc/svr4 assmebler (which needs\n-   to see .L at the start of a label in order to prevent that label from\n-   going into the linker symbol table).  When I get time, I'll have to\n-   fix this the right way so that we use ASM_GENERATE_INTERNAL_LABEL and\n-   ASM_OUTPUT_INTERNAL_LABEL throughout dwarfout.c, but that will require\n-   a rather massive set of changes.  For the moment, the following definitions\n-   out to produce the right results for all svr4 and svr3 assemblers. -- rfg\n+   a `.L' sequence so as to appease the stock sparc/svr4 assembler and the\n+   stock m88k/svr4 assembler, both of which need to see .L at the start of\n+   a label in order to prevent that label from going into the linker symbol\n+   table).  When I get time, I'll have to fix this the right way so that we\n+   will use ASM_GENERATE_INTERNAL_LABEL and ASM_OUTPUT_INTERNAL_LABEL herein,\n+   but that will require a rather massive set of changes.  For the moment,\n+   the following definitions out to produce the right results for all svr4\n+   and svr3 assemblers. -- rfg\n */\n \n #ifndef TEXT_BEGIN_LABEL\n@@ -544,9 +549,9 @@ static unsigned lookup_filename ();\n    output operations.\n \n    If necessary, these may be overridden from within your tm.h file,\n-   but typically, you shouldn't need to override these.  Two known\n-   exceptions are the ASM_OUTPUT_PUSH_SECTION and ASM_OUTPUT_POP_SECTION\n-   definitions, which need to be somewhat special for a sparc running svr4.\n+   but typically, you shouldn't need to override these.  One known\n+   exception is ASM_OUTPUT_DEF which has to be different for stock\n+   sparc/svr4 assemblers.\n */\n \n #ifndef ASM_OUTPUT_PUSH_SECTION\n@@ -566,7 +571,7 @@ static unsigned lookup_filename ();\n \n #ifndef ASM_OUTPUT_DEF\n #define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)\t\t\t\t\\\n- do {\tfprintf ((FILE), \"\\t%s\\t\", DEF_ASM_OP);\t\t\t\t\\\n+ do {\tfprintf ((FILE), \"\\t%s\\t\", SET_ASM_OP);\t\t\t\t\\\n \tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n \tfprintf (FILE, \",\");\t\t\t\t\t\t\\\n \tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n@@ -621,7 +626,7 @@ static unsigned lookup_filename ();\n #ifndef ASM_OUTPUT_DWARF_STACK_OP\n #define ASM_OUTPUT_DWARF_STACK_OP(FILE,OP)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s\\t0x%x\", ASM_BYTE_OP, (unsigned) OP);\t\t\\\n+    fprintf ((FILE), \"\\t%s\\t0x%x\", ASM_BYTE_OP, (unsigned) OP);\t\t\\\n     if (flag_verbose_asm)\t\t\t\t\t\t\\\n       fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n \t\t       ASM_COMMENT_START, dwarf_stack_op_name (OP));\t\\\n@@ -644,7 +649,7 @@ static unsigned lookup_filename ();\n #ifndef ASM_OUTPUT_DWARF_FMT_BYTE\n #define ASM_OUTPUT_DWARF_FMT_BYTE(FILE,FMT)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s\\t0x%x\", ASM_BYTE_OP, (unsigned) FMT);\t\t\\\n+    fprintf ((FILE), \"\\t%s\\t0x%x\", ASM_BYTE_OP, (unsigned) FMT);\t\\\n     if (flag_verbose_asm)\t\t\t\t\t\t\\\n       fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n \t\t       ASM_COMMENT_START, dwarf_fmt_byte_name (FMT));\t\\\n@@ -655,7 +660,7 @@ static unsigned lookup_filename ();\n #ifndef ASM_OUTPUT_DWARF_TYPE_MODIFIER\n #define ASM_OUTPUT_DWARF_TYPE_MODIFIER(FILE,MOD)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s\\t0x%x\", ASM_BYTE_OP, (unsigned) MOD);\t\t\\\n+    fprintf ((FILE), \"\\t%s\\t0x%x\", ASM_BYTE_OP, (unsigned) MOD);\t\\\n     if (flag_verbose_asm)\t\t\t\t\t\t\\\n       fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n \t\t       ASM_COMMENT_START, dwarf_typemod_name (MOD));\t\\\n@@ -673,9 +678,11 @@ static unsigned lookup_filename ();\n \n #ifndef ASM_OUTPUT_DWARF_ADDR_CONST\n #define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)\t\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t\", UNALIGNED_INT_ASM_OP);\t\t\t\\\n-  output_addr_const ((FILE), (RTX));\t\t\t\t\t\\\n-  fputc ('\\n', (FILE))\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"\\t%s\\t\", UNALIGNED_INT_ASM_OP);\t\t\t\\\n+    output_addr_const ((FILE), (RTX));\t\t\t\t\t\\\n+    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n+  } while (0)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_REF\n@@ -688,7 +695,7 @@ static unsigned lookup_filename ();\n \n #ifndef ASM_OUTPUT_DWARF_DATA1\n #define ASM_OUTPUT_DWARF_DATA1(FILE,VALUE) \\\n-  fprintf ((FILE), \"%s\\t0x%x\\n\", ASM_BYTE_OP, VALUE)\n+  fprintf ((FILE), \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, VALUE)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_DATA2\n@@ -734,6 +741,15 @@ xstrdup (s)\n   return p;\n }\n \n+inline int\n+is_pseudo_reg (rtl)\n+     register rtx rtl;\n+{\n+  return (((GET_CODE (rtl) == REG) && (REGNO (rtl) >= FIRST_PSEUDO_REGISTER))\n+          || ((GET_CODE (rtl) == SUBREG)\n+\t      && (REGNO (XEXP (rtl, 0)) >= FIRST_PSEUDO_REGISTER)));\n+}\n+\n static char *\n dwarf_tag_name (tag)\n      register unsigned tag;\n@@ -1506,9 +1522,7 @@ location_attribute (rtl)\n      thing entirely different... i.e. that the DIE represents an object\n      declaration, but not a definition.  So sayeth the PLSIG.  */\n \n-  if (((GET_CODE (rtl) != REG) || (REGNO (rtl) < FIRST_PSEUDO_REGISTER))\n-      && ((GET_CODE (rtl) != SUBREG)\n-\t  || (REGNO (XEXP (rtl, 0)) < FIRST_PSEUDO_REGISTER)))\n+  if (! is_pseudo_reg (rtl))\n     output_loc_descriptor (eliminate_regs (rtl, 0, 0));\n \n   ASM_OUTPUT_LABEL (asm_out_file, end_label);\n@@ -1540,12 +1554,13 @@ data_member_location_attribute (decl)\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  register unsigned containing_object_size_in_bytes;\n-  register unsigned containing_object_size_in_bits;\n-  register unsigned member_offset_in_objects;\n-  register unsigned member_offset_in_bytes;\n+  register unsigned type_align_in_bytes;\n+  register unsigned type_align_in_bits;\n+  register unsigned offset_in_align_units;\n+  register unsigned offset_in_bytes;\n   register tree type;\n-  register tree bitpos = DECL_FIELD_BITPOS (decl);\n+  register tree bitpos_tree = DECL_FIELD_BITPOS (decl);\n+  register unsigned bitpos_int;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n@@ -1563,8 +1578,9 @@ data_member_location_attribute (decl)\n      it into a member-style AT_location descriptor, but that'll be\n      tough to do.  -- rfg  */\n \n-  if (TREE_CODE (bitpos) != INTEGER_CST)\n+  if (TREE_CODE (bitpos_tree) != INTEGER_CST)\n     return;\n+  bitpos_int = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n \n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_location);\n   sprintf (begin_label, LOC_BEGIN_LABEL_FMT, current_dienum);\n@@ -1577,47 +1593,100 @@ data_member_location_attribute (decl)\n   if (type == NULL)\n     type = TREE_TYPE (decl);\n \n-  containing_object_size_in_bytes = int_size_in_bytes (type);\n-  containing_object_size_in_bits\n-    = containing_object_size_in_bytes * BITS_PER_UNIT;\n+  type_align_in_bits = TYPE_ALIGN (type);\n+  type_align_in_bytes = type_align_in_bits / BITS_PER_UNIT;\n \n   /* WARNING!  Note that the GCC front-end doesn't make any attempt to\n      keep track of the starting bit offset (relative to the start of\n      the containing structure type) of the hypothetical \"containing\n      object\" for a bit-field.  (See the comments at the start of this\n-     function.)  Thus, when computing the  byte offset value for a\n+     function.)  Thus, when computing the byte offset value for a\n      bit-field, all we can do is to divide the starting bit offset of\n-     the bit-field by the size of the hypothetical \"containing object\"\n-     (which we can easily find).\n-\n-     This solution only works right as long as the alignment used by the\n-     compiler for the declared type of the bit-field is the same as the\n-     size of that type.\n-\n-     Since GCC allows type `long long' to be the declared type for a\n-     bit-field, and since some target configurations only align\n-     `long longs' to 4-byte boundaries, we have to check here to see\n-     that the alignment of the containing object is the same as the\n-     size of that object.  If it isn't, and if the field in question\n-     is a bit-field, then we may be about to generate bogus Dwarf\n-     output, so we need to warn the user about that.\n-\n-     Of course it would be nice to actually solve this problem, but\n-     that would require a lot of changes elsewhere in the compiler\n-     which could be quite painful, so for now we'll just live with\n-     this minor annoyance.\n+     the bit-field by the alignment of the hypothetical \"containing\n+     object\" (which we can easily find) and then multiply by the number\n+     of bytes of that alignment.\n+\n+     This solution only yields an unambiguously correct result when\n+     the size of the bit-field is strictly larger than the size of the\n+     declared type minus the alignment of the declared type.  When this\n+     condition is not satisfied, it means that there is at least an\n+     \"alignment unit's\" worth of other slop which co-resides within the\n+     hypothetical \"containing object\" with the bit field, and this other\n+     slop could be either to the left of the bit-field or to the right\n+     of the bit-field. (We have no way of knowing which.)\n+\n+     It also means that we cannot unambiguously tell exactly where the\n+     hypothetical \"containing object\" begins within the containing struct\n+     type.  We only know the precise position of the bit-field which is\n+     contained therein, and that the hypothetical containing object must\n+     be aligned as required for its type.  But when there is at least an\n+     alignment unit's worth of slop co-resident in the containing object\n+     with the actual bit-field, the actual start of the containing object\n+     is ambiguous and thus, we cannot unambiguously determine the \"correct\"\n+     byte offset to put into the AT_location attribute for the bit-field\n+     itself.\n+\n+     This whole thing is a non-issue for the majority of targets, because\n+     (for most GCC targets) the alignment of each supported integral type\n+     is the same as the size of that type, and thus (size - alignment) for\n+     the declared type of any bit-field yields zero, and the size (in bits)\n+     of any bit-field must be bigger than zero, so there is never any\n+     ambiguity about the starting positions of the containing objects of\n+     bit-fields for most GCC targets.\n+\n+     An exception arises however for some machines (e.g. i386) which have\n+     BIGGEST_ALIGNMENT set to something less than the size of type `long\n+     long' (i.e. 64) and when we are confronted with something like:\n+\n+\t\tstruct S {\n+\t\t\tint\t\tfield1;\n+\t\t\tlong long\tfield2:31;\n+\t\t};\n+\n+     Here it is ambiguous (going by DWARF rules anyway) whether the con-\n+     taining `long long' object for `field2' should be said to occupy the\n+     first and second (32-bit) words of the containing struct type, or\n+     whether it should be said to occupy the second and third words of\n+     the struct type.\n+\n+     Currently, GCC allocates 8 bytes (for an i386 target) for each object\n+     of the above type.  This is probably a bug however, and GCC should\n+     probably be allocating 12 bytes for each such structure (for the i386\n+     target).\n+\n+     Assuming this bug gets fixed, one would have a strong case for saying\n+     that the containing `long long' object for `field2' occupies the second\n+     and third words of the above structure type, and that `field2' itself\n+     occupies the first 31 bits of that containing object.  However consider:\n+\n+\t\tstruct S {\n+\t\t\tint\t\tfield1;\n+\t\t\tlong long\tfield2:31;\n+\t\t\tlong long\tfield3:2;\n+\t\t\tlong long\tfield4:31;\n+\t\t};\n+\n+     Even if the current \"member allocation\" bug in GCC is fixed, this ex-\n+     ample would still illustrate a case in which the starting point of the\n+     containing `long long' object for `field4' would be ambiguous, even\n+     though we know the exact starting bit offset (within the structure) of\n+     the `field4' bit-field itself.\n+\n+     We essentially just ignore this whole issue here and always act as if\n+     most of the slop which co-resides in a containing object along with a\n+     bit-field appears in that containing object *AFTER* the bit field.\n+     Thus, for the above example, we say that the containing object for\n+     `field4' occupies the third and fourth words of the structure type,\n+     even though objects of the type only occupy three words.  As long\n+     as the debugger understands that the compiler uses this disambiguation\n+     rule, the debugger should easily be able to do the Right Thing in all\n+     cases.\n   */\n \n-  if ((GET_MODE_ALIGNMENT (TYPE_MODE (type)) != containing_object_size_in_bits)\n-      && (DECL_BIT_FIELD_TYPE (type) != NULL))\n-    warning_with_decl (decl, \"debugging info won't necessarily be reliable\");\n+  offset_in_align_units = bitpos_int / type_align_in_bits;\n+  offset_in_bytes = offset_in_align_units * type_align_in_bytes;\n \n-  member_offset_in_objects\n-    = (unsigned) TREE_INT_CST_LOW (bitpos) / containing_object_size_in_bits;\n-  member_offset_in_bytes\n-    = member_offset_in_objects * containing_object_size_in_bytes;\n-\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, member_offset_in_bytes);\n+  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, offset_in_bytes);\n   ASM_OUTPUT_DWARF_STACK_OP (asm_out_file, OP_ADD);\n   ASM_OUTPUT_LABEL (asm_out_file, end_label);\n }\n@@ -1723,21 +1792,63 @@ location_or_const_value_attribute (decl)\n     abort ();\n \n   /* Existing Dwarf debuggers need and expect the location descriptors for\n-     formal parameters to reflect the place where the parameter are passed,\n-     as opposed to the places where they might reside during the execution\n-     of the function.  This isn't clearly spelled out in the current Dwarf\n+     formal parameters to reflect either the place where the parameters get\n+     passed (if they are passed on the stack and in memory) or else the\n+     (preserved) registers which the paramaters get copied to during the\n+     function prologue.\n+\n+     At least this is the way things are for most common CISC machines\n+     (e.g. x86 and m68k) where parameters are passed in the stack, and for\n+     most common RISC machines (e.g. i860 and m88k) where parameters are\n+     passed in registers.\n+\n+     The rules for Sparc are a little weird for some reason.  The DWARF\n+     generated by the USL C compiler for the Sparc/svr4 reference port says\n+     that the parameters are passed in the stack.  I haven't figured out\n+     how to duplicate that behavior here (for the Sparc) yet, or even if\n+     I really need to.\n+\n+     Note that none of this is clearly spelled out in the current Dwarf\n      version 1 specification, but it's obvious if you look at the output of\n      the CI5 compiler, or if you try to use the svr4 SDB debugger.  Hopefully,\n      a later version of the Dwarf specification will clarify this.  For now,\n      we just need to generate the right thing.  Note that Dwarf version 2\n      will provide us with a means to describe *all* of the locations in which\n      a given variable or parameter resides (and the PC ranges over which it\n-     occupies each one), but for now we can only describe the \"passing\"\n-     location.  */\n+     occupies each one), but for now we can only describe one \"location\"\n+     for each formal parameter passed, and so we just try to mimic existing\n+     practice as much as possible.\n+  */\n \n-  rtl = (TREE_CODE (decl) == PARM_DECL)\n-\t ? DECL_INCOMING_RTL (decl)\n-\t : DECL_RTL (decl);\n+  if (TREE_CODE (decl) != PARM_DECL)\n+    /*  If this decl is not a formal parameter, just use DECL_RTL.  */\n+    rtl = DECL_RTL (decl);\n+  else\n+    {\n+      if (GET_CODE (DECL_INCOMING_RTL (decl)) == MEM)\n+        /* Parameter was passed in memory, so say that's where it lives.  */\n+\trtl = DECL_INCOMING_RTL (decl);\n+      else\n+\t{\n+          /* Parameter was passed in a register, so say it lives in the\n+\t     register it will be copied to during the prologue.  */\n+          rtl = DECL_RTL (decl);\n+\n+\t  /* Note that in cases where the formal parameter is never used\n+\t     and where this compilation is done with -O, the copying of\n+\t     of an incoming register parameter to another register (in\n+\t     the prologue) can be totally optimized away.  (In such cases\n+\t     the DECL_RTL will indicate a pseudo-register.)  We could just\n+\t     use the DECL_RTL (as we normally do for register parameters)\n+\t     in these cases, but if we did that, we would end up generating\n+\t     a null location descriptor.  (See `location_attribute' above.)\n+\t     That would be acceptable (according to the DWARF spec) but it\n+\t     is probably more useful to say that the formal resides where\n+\t     it was passed instead of saying that it resides nowhere.  */\n+\t  if (is_pseudo_reg (rtl))\n+\t    rtl = DECL_INCOMING_RTL (decl);\n+\t}\n+    }\n \n   if (rtl == NULL)\n     return;\n@@ -2013,10 +2124,9 @@ bit_offset_attribute (decl)\n     register tree decl;\n {\n   register tree type = DECL_BIT_FIELD_TYPE (decl);\n-  register unsigned containing_object_size_in_bits;\n   register unsigned dwarf_bit_offset;\n   register tree bitpos_tree = DECL_FIELD_BITPOS (decl);\n-  register unsigned bitpos;\n+  register unsigned bitpos_int;\n \n   assert (TREE_CODE (decl) == FIELD_DECL);\t/* Must be a field.  */\n   assert (type);\t\t\t\t/* Must be a bit field.\t */\n@@ -2030,63 +2140,29 @@ bit_offset_attribute (decl)\n      given as the DECL_FIELD_BITPOS and see if we can factor out just\n      the (constant) bit offset part of that expression.  -- rfg  */\n \n-  if (TREE_CODE (bitpos_tree) != CONST_INT)\n+  if (TREE_CODE (bitpos_tree) != INTEGER_CST)\n     return;\n+  bitpos_int = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n \n-  containing_object_size_in_bits = int_size_in_bytes (type) * BITS_PER_UNIT;\n-\n-  /* WARNING!  Note that the GCC front-end doesn't make any attempt to\n-     keep track of the starting bit offset (relative to the start of\n-     the containing structure type) of the hypothetical \"containing\n-     object\" for a bit-field.  (See the comments at the start of this\n-     function.)  Thus, when computing the AT_bit_offset value for a\n-     bit-field, all we can do is to divide the starting bit offset of\n-     the bit-field by the size of the hypothetical \"containing object\"\n-     (which we can easily find) and then get the remainder.\n-\n-     This solution only works right as long as the alignment used by the\n-     compiler for the declared type of the bit-field is the same as the\n-     size of that type.\n-\n-     Since GCC allows type `long long' to be the declared type for a\n-     bit-field, and since some target configurations only align\n-     `long longs' to 4-byte boundaries, we really should check here\n-     to see that the alignment of the containing object is the same\n-     as the size of that object and issue a warning if it isn't but\n-     since we will also be generating an AT_location attribute for\n-     the bit-field, and sinec it will generat a warning for this\n-     condition we do not need to do it again here.  That would just\n-     cause the user to see two redundant warnings for the same single\n-     bit-field declaration.\n-\n-     Of course it would be nice to actually solve this problem, but\n-     that would require a lot of changes elsewhere in the compiler\n-     which could be quite painful, so for now we'll just live with\n-     this minor annoyance.\n-  */\n-\n-#if 0\n-  if (GET_MODE_ALIGNMENT (TYPE_MODE (type)) != containing_object_size_in_bits)\n-    warning_with_decl (decl, \"debugging info won't necessarily be reliable\");\n-#endif\n-\n-  bitpos = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n+  /* For a detailed description of how the AT_bit_offset attribute value\n+     is calculated, see the comments in `data_member_location_attribute'\n+     above.  */\n \n #if (BYTES_BIG_ENDIAN == 1)\n-  {\n-    register unsigned high_order_bitpos = bitpos;\n-\n-    dwarf_bit_offset = high_order_bitpos % containing_object_size_in_bits;\n-  }\n+  dwarf_bit_offset = bitpos_int % TYPE_ALIGN (type);\n #else\n   {\n-    register unsigned low_order_bitpos = bitpos;\n-    register unsigned field_width\n-      = (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl));\n-    register unsigned high_order_bitpos = low_order_bitpos + field_width;\n+    register unsigned high_order_bitpos\n+      = bitpos_int + (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl));\n+    register tree type_size_tree = TYPE_SIZE (type);\n+    register unsigned type_size_in_bits;\n+\n+    if (TREE_CODE (type_size_tree) != INTEGER_CST)\n+      abort ();\n+    type_size_in_bits = (unsigned) TREE_INT_CST_LOW (type_size_tree);\n \n-    dwarf_bit_offset = containing_object_size_in_bits\n-\t\t\t- (high_order_bitpos % containing_object_size_in_bits);\n+    dwarf_bit_offset = type_size_in_bits\n+\t\t\t- (high_order_bitpos % TYPE_ALIGN (type));\n   }\n #endif\n \n@@ -3666,10 +3742,15 @@ output_decl (decl, containing_scope)\n \n     case FUNCTION_DECL:\n       /* If we are in terse mode, don't output any DIEs to represent\n+\t mere external function declarations.  Also, if we are conforming\n+\t to the DWARF version 1 specification, don't output DIEs for\n \t mere external function declarations.  */\n \n-      if (TREE_EXTERNAL (decl) && debug_info_level <= DINFO_LEVEL_TERSE)\n-\tbreak;\n+      if (TREE_EXTERNAL (decl))\n+#if (DWARF_VERSION > 1)\n+\tif (debug_info_level <= DINFO_LEVEL_TERSE)\n+#endif\n+\t  break;\n \n       /* Before we describe the FUNCTION_DECL itself, make sure that we\n \t have described its return type.  */\n@@ -3927,6 +4008,14 @@ output_decl (decl, containing_scope)\n       break;\n \n     case VAR_DECL:\n+      /* If we are conforming to the DWARF version 1 specification, don't\n+\t generated any DIEs to represent mere external object declarations.  */\n+\n+#if (DWARF_VERSION <= 1)\n+      if (TREE_EXTERNAL (decl) && ! TREE_PUBLIC (decl))\n+\tbreak;\n+#endif\n+\n       /* If we are in terse mode, don't generate any DIEs to represent\n \t any variable declarations or definitions.  */\n "}]}