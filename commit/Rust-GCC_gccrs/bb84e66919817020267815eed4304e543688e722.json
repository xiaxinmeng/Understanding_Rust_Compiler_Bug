{"sha": "bb84e66919817020267815eed4304e543688e722", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI4NGU2NjkxOTgxNzAyMDI2NzgxNWVlZDQzMDRlNTQzNjg4ZTcyMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-11-02T20:28:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-11-02T20:28:22Z"}, "message": "Makefile.in (install): Some of HEADERS come from the stl dir now.\n\n\t* Makefile.in (install): Some of HEADERS come from the stl dir now.\n\t* algorithm, deque, functional, iterator, list, map, memory, numeric,\n \tqueue, set, stack, utility, vector: Now in stl dir.\n\nstl/:\n\t* algo.h, algobase.h, alloc.h, bvector.h, defalloc.h, deque.h,\n \tfunction.h, hash_map.h, hash_set.h, hashtable.h, heap.h, iterator.h,\n \tlist.h, map.h, multimap.h, multiset.h, pair.h, pthread_alloc.h,\n \trope.h, ropeimpl.h, set.h, slist.h, stack.h, stl_config.h, tempbuf.h,\n \ttree.h, type_traits.h, vector.h: Update to October 27 SGI snapshot.\n\t* algorithm, deque, functional, hash_map, hash_set, iterator, list,\n \tmap, memory, numeric, pthread_alloc, queue, rope, set, slist, stack,\n \tstl_algo.h, stl_algobase.h, stl_alloc.h, stl_bvector.h,\n \tstl_construct.h, stl_deque.h, stl_function.h, stl_hash_fun.h,\n \tstl_hash_map.h, stl_hash_set.h, stl_hashtable.h, stl_heap.h,\n \tstl_iterator.h, stl_list.h, stl_map.h, stl_multimap.h, stl_multiset.h,\n \tstl_numeric.h, stl_pair.h, stl_queue.h, stl_raw_storage_iter.h,\n \tstl_relops.h, stl_rope.h, stl_set.h, stl_slist.h, stl_stack.h,\n \tstl_tempbuf.h, stl_tree.h, stl_uninitialized.h, stl_vector.h,\n \tutility, vector: New files in October 27 SGI snapshot.\n\nFrom-SVN: r16277", "tree": {"sha": "42c53d65b7bbabaf962948c0b9586398a90ddf19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42c53d65b7bbabaf962948c0b9586398a90ddf19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb84e66919817020267815eed4304e543688e722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb84e66919817020267815eed4304e543688e722", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb84e66919817020267815eed4304e543688e722", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb84e66919817020267815eed4304e543688e722/comments", "author": null, "committer": null, "parents": [{"sha": "c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3bcf315fa71e2dd20d719a192f4dac3c25e8895"}], "stats": {"total": 33421, "additions": 17964, "deletions": 15457}, "files": [{"sha": "cf4d2eb61024a59f9bb00d51840adccd73b3c715", "filename": "libstdc++/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FChangeLog?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -1,7 +1,13 @@\n+Sun Nov  2 12:14:37 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* Makefile.in (install): Some of HEADERS come from the stl dir now.\n+\t* algorithm, deque, functional, iterator, list, map, memory, numeric,\n+ \tqueue, set, stack, utility, vector: Now in stl dir.\n+\n Fri Oct 10 00:40:00 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* std/bastring.h: Use ibegin internally.  Return passed iterator\n-\tinstead of recalculating it were appropriate.\n+\tinstead of recalculating it where appropriate.\n \t* std/bastring.cc: Adjust for erase.\n \n \tFrom Yotam Medini:"}, {"sha": "1cd2a6fc3160345d6d72877763146989ea141582", "filename": "libstdc++/Makefile.in", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FMakefile.in?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -248,7 +248,16 @@ install:\n \trootme=`pwd`/ ; export rootme ; \\\n \tif [ -z \"$(MULTISUBDIR)\" ]; then \\\n \t  cd $(srcdir); \\\n-\t  for FILE in $(HEADERS) *.h std/*.*; do \\\n+\t  for FILE in $(HEADERS); do \\\n+\t    rm -f $(gxx_includedir)/$$FILE ; \\\n+\t    if [ -f stl/$$FILE ]; then \\\n+\t      $(INSTALL_DATA) stl/$$FILE $(gxx_includedir)/$$FILE ; \\\n+\t    else \\\n+\t      $(INSTALL_DATA) $$FILE $(gxx_includedir)/$$FILE ; \\\n+\t    fi ; \\\n+\t    chmod a-x $(gxx_includedir)/$$FILE ; \\\n+\t  done ; \\\n+\t  for FILE in *.h std/*.*; do \\\n \t    rm -f $(gxx_includedir)/$$FILE ; \\\n \t    $(INSTALL_DATA) $$FILE $(gxx_includedir)/$$FILE ; \\\n \t    chmod a-x $(gxx_includedir)/$$FILE ; \\"}, {"sha": "472d241664016b605875618cd484e96ce07229e7", "filename": "libstdc++/algorithm", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Falgorithm?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __ALGORITHM__\n-#define __ALGORITHM__\n-#include <algo.h>\n-#endif"}, {"sha": "bdc14299a0451fb8afc213bac1f07a635320d4dc", "filename": "libstdc++/deque", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fdeque?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __DEQUE__\n-#define __DEQUE__\n-#include <deque.h>\n-#endif"}, {"sha": "ee8b7f20202e1bea7a6f4ffc0cf3681e6da353cd", "filename": "libstdc++/functional", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Ffunctional?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __FUNCTIONAL__\n-#define __FUNCTIONAL__\n-#include <function.h>\n-#endif"}, {"sha": "a0fa054c5ec6fd4c1748f6d1817ee5b25e98612e", "filename": "libstdc++/iterator", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fiterator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fiterator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fiterator?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __ITERATOR__\n-#define __ITERATOR__\n-#include <iterator.h>\n-#endif"}, {"sha": "475d8443d16779bbc03a8a0de8d657ef2c4143b6", "filename": "libstdc++/list", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Flist?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __LIST__\n-#define __LIST__\n-#include <list.h>\n-#endif"}, {"sha": "0127b9db250f1f2e80c6f904f683e89d4b0b739e", "filename": "libstdc++/map", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fmap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fmap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fmap?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __MAP__\n-#define __MAP__\n-#include <map.h>\n-#endif"}, {"sha": "8328720db6d5d62e75a6164c774289430497bbe7", "filename": "libstdc++/memory", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fmemory?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __MEMORY__\n-#define __MEMORY__\n-#include <defalloc.h>\n-#endif"}, {"sha": "dcb88737f171e4cf0685d657eb7991d5294335f7", "filename": "libstdc++/numeric", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fnumeric?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __NUMERIC__\n-#define __NUMERIC__\n-#include <algo.h>\n-#endif"}, {"sha": "e71ce343067c2080d4976e185ec173c8b74152f8", "filename": "libstdc++/queue", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fqueue", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fqueue", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fqueue?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __QUEUE__\n-#define __QUEUE__\n-#include <stack.h>\n-#endif"}, {"sha": "0353285fe502e59ec6c15c7bd54c912db06a3c4b", "filename": "libstdc++/set", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fset?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __SET__\n-#define __SET__\n-#include <set.h>\n-#endif"}, {"sha": "dfe0c51e181354cb1f3e908de44a9122d22f422f", "filename": "libstdc++/stack", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fstack", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fstack", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstack?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895", "patch": "@@ -1,7 +0,0 @@\n-// -*- C++ -*- forwarding header.\n-// This file is part of the GNU ANSI C++ Library.\n-\n-#ifndef __STACK__\n-#define __STACK__\n-#include <stack.h>\n-#endif"}, {"sha": "7d0c62ab462ebca75ef76bb48ca19d18b13042ce", "filename": "libstdc++/stl/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2FChangeLog?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -1,3 +1,21 @@\n+Sun Nov  2 12:14:56 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* algo.h, algobase.h, alloc.h, bvector.h, defalloc.h, deque.h,\n+ \tfunction.h, hash_map.h, hash_set.h, hashtable.h, heap.h, iterator.h,\n+ \tlist.h, map.h, multimap.h, multiset.h, pair.h, pthread_alloc.h,\n+ \trope.h, ropeimpl.h, set.h, slist.h, stack.h, stl_config.h, tempbuf.h,\n+ \ttree.h, type_traits.h, vector.h: Update to October 27 SGI snapshot.\n+\t* algorithm, deque, functional, hash_map, hash_set, iterator, list,\n+ \tmap, memory, numeric, pthread_alloc, queue, rope, set, slist, stack,\n+ \tstl_algo.h, stl_algobase.h, stl_alloc.h, stl_bvector.h,\n+ \tstl_construct.h, stl_deque.h, stl_function.h, stl_hash_fun.h,\n+ \tstl_hash_map.h, stl_hash_set.h, stl_hashtable.h, stl_heap.h,\n+ \tstl_iterator.h, stl_list.h, stl_map.h, stl_multimap.h, stl_multiset.h,\n+ \tstl_numeric.h, stl_pair.h, stl_queue.h, stl_raw_storage_iter.h,\n+ \tstl_relops.h, stl_rope.h, stl_set.h, stl_slist.h, stl_stack.h,\n+ \tstl_tempbuf.h, stl_tree.h, stl_uninitialized.h, stl_vector.h,\n+ \tutility, vector: New files in October 27 SGI snapshot.\n+\n Fri Oct 17 19:07:42 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* tree.h, vector.h: Fix accidental divergence from SGI release."}, {"sha": "1707868c7c43bb803c846e422f1f961c54087980", "filename": "libstdc++/stl/algo.h", "status": "modified", "additions": 82, "deletions": 2845, "changes": 2927, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Falgo.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -27,2851 +27,88 @@\n #ifndef __SGI_STL_ALGO_H\n #define __SGI_STL_ALGO_H\n \n-#include <stdlib.h>\n-#include <limits.h>\n #include <algobase.h>\n-#include <heap.h>\n #include <tempbuf.h>\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1209\n-#endif\n-\n-template <class T>\n-inline const T& __median(const T& a, const T& b, const T& c) {\n-    if (a < b)\n-\tif (b < c)\n-\t    return b;\n-\telse if (a < c)\n-\t    return c;\n-\telse\n-\t    return a;\n-    else if (a < c)\n-\treturn a;\n-    else if (b < c)\n-\treturn c;\n-    else\n-\treturn b;\n-}\n-\n-template <class T, class Compare>\n-inline const T& __median(const T& a, const T& b, const T& c, Compare comp) {\n-    if (comp(a, b))\n-\tif (comp(b, c))\n-\t    return b;\n-\telse if (comp(a, c))\n-\t    return c;\n-\telse\n-\t    return a;\n-    else if (comp(a, c))\n-\treturn a;\n-    else if (comp(b, c))\n-\treturn c;\n-    else\n-\treturn b;\n-}\n-\n-template <class InputIterator, class Function>\n-Function for_each(InputIterator first, InputIterator last, Function f) {\n-  for ( ; first != last; ++first)\n-    f(*first);\n-  return f;\n-}\n-\n-template <class InputIterator, class T>\n-InputIterator find(InputIterator first, InputIterator last, const T& value) {\n-    while (first != last && *first != value) ++first;\n-    return first;\n-}\n-\n-template <class InputIterator, class Predicate>\n-InputIterator find_if(InputIterator first, InputIterator last,\n-\t\t      Predicate pred) {\n-    while (first != last && !pred(*first)) ++first;\n-    return first;\n-}\n-\n-template <class ForwardIterator>\n-ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last) {\n-    if (first == last) return last;\n-    ForwardIterator next = first;\n-    while(++next != last) {\n-\tif (*first == *next) return first;\n-\tfirst = next;\n-    }\n-    return last;\n-}\n-\n-template <class ForwardIterator, class BinaryPredicate>\n-ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last,\n-\t\t\t      BinaryPredicate binary_pred) {\n-    if (first == last) return last;\n-    ForwardIterator next = first;\n-    while(++next != last) {\n-\tif (binary_pred(*first, *next)) return first;\n-\tfirst = next;\n-    }\n-    return last;\n-}\n-\n-template <class InputIterator, class T, class Size>\n-void count(InputIterator first, InputIterator last, const T& value,\n-\t   Size& n) {\n-  for ( ; first != last; ++first)\n-    if (*first == value)\n-      ++n;\n-}\n-\n-template <class InputIterator, class Predicate, class Size>\n-void count_if(InputIterator first, InputIterator last, Predicate pred,\n-\t      Size& n) {\n-  for ( ; first != last; ++first)\n-    if (pred(*first))\n-      ++n;\n-}\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class InputIterator, class T>\n-iterator_traits<InputIterator>::difference_type\n-count(InputIterator first, InputIterator last, const T& value) {\n-  iterator_traits<InputIterator>::difference_type n = 0;\n-  for ( ; first != last; ++first)\n-    if (*first == value)\n-      ++n;\n-  return n;\n-}\n-\n-template <class InputIterator, class Predicate>\n-iterator_traits<InputIterator>::difference_type\n-count_if(InputIterator first, InputIterator last, Predicate pred) {\n-  iterator_traits<InputIterator>::difference_type n = 0;\n-  for ( ; first != last; ++first)\n-    if (pred(*first))\n-      ++n;\n-  return n;\n-}\n-\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class ForwardIterator1, class ForwardIterator2, class Distance1,\n-          class Distance2>\n-ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,\n-                          ForwardIterator2 first2, ForwardIterator2 last2,\n-                          Distance1*, Distance2*) {\n-  Distance1 d1 = 0;\n-  distance(first1, last1, d1);\n-  Distance2 d2 = 0;\n-  distance(first2, last2, d2);\n-\n-  if (d1 < d2) return last1;\n-\n-  ForwardIterator1 current1 = first1;\n-  ForwardIterator2 current2 = first2;\n-\n-  while (current2 != last2) \n-    if (*current1 == *current2) {\n-      ++current1;\n-      ++current2;\n-    }\n-    else {\n-      if (d1 == d2)\n-        return last1;\n-      else {\n-        current1 = ++first1;\n-        current2 = first2;\n-        --d1;\n-      }\n-    }\n-  return first1;\n-}\n-\n-template <class ForwardIterator1, class ForwardIterator2>\n-inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,\n-\t\t\t       ForwardIterator2 first2, ForwardIterator2 last2)\n-{\n-    return __search(first1, last1, first2, last2, distance_type(first1),\n-\t\t    distance_type(first2));\n-}\n-\n-template <class ForwardIterator1, class ForwardIterator2,\n-          class BinaryPredicate, class Distance1, class Distance2>\n-ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,\n-                          ForwardIterator2 first2, ForwardIterator2 last2,\n-                          BinaryPredicate binary_pred, Distance1*, Distance2*) {\n-  Distance1 d1 = 0;\n-  distance(first1, last1, d1);\n-  Distance2 d2 = 0;\n-  distance(first2, last2, d2);\n-\n-  if (d1 < d2) return last1;\n-\n-  ForwardIterator1 current1 = first1;\n-  ForwardIterator2 current2 = first2;\n-\n-  while (current2 != last2)\n-    if (binary_pred(*current1, *current2)) {\n-      ++current1;\n-      ++current2;\n-    }\n-    else {\n-      if (d1 == d2)\n-        return last1;\n-      else {\n-        current1 = ++first1;\n-        current2 = first2;\n-        --d1;\n-      }\n-    }\n-  return first1;\n-}\n-\n-template <class ForwardIterator1, class ForwardIterator2,\n-\t  class BinaryPredicate>\n-inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,\n-\t\t\t       ForwardIterator2 first2, ForwardIterator2 last2,\n-\t\t\t       BinaryPredicate binary_pred) {\n-    return __search(first1, last1, first2, last2, binary_pred,\n-\t\t    distance_type(first1), distance_type(first2));\n-}\n-\n-template <class ForwardIterator, class Integer, class T>\n-ForwardIterator search_n(ForwardIterator first, ForwardIterator last,\n-                         Integer count, const T& value) {\n-  if (count <= 0)\n-    return first;\n-  else {\n-    first = find(first, last, value);\n-    while (first != last) {\n-      Integer n = count - 1;\n-      ForwardIterator i = first;\n-      ++i;\n-      while (i != last && n != 0 && *i == value) {\n-        ++i;\n-        --n;\n-      }\n-      if (n == 0)\n-        return first;\n-      else\n-        first = find(i, last, value);\n-    }\n-    return last;\n-  }\n-}\n-\n-template <class ForwardIterator, class Integer, class T, class BinaryPredicate>\n-ForwardIterator search_n(ForwardIterator first, ForwardIterator last,\n-                         Integer count, const T& value,\n-                         BinaryPredicate binary_pred) {\n-  if (count <= 0)\n-    return first;\n-  else {\n-    while (first != last) {\n-      if (binary_pred(*first, value)) break;\n-      ++first;\n-    }\n-    while (first != last) {\n-      Integer n = count - 1;\n-      ForwardIterator i = first;\n-      ++i;\n-      while (i != last && n != 0 && binary_pred(*i, value)) {\n-        ++i;\n-        --n;\n-      }\n-      if (n == 0)\n-        return first;\n-      else {\n-        while (i != last) {\n-          if (binary_pred(*i, value)) break;\n-          ++i;\n-        }\n-        first = i;\n-      }\n-    }\n-    return last;\n-  }\n-} \n-\n-template <class ForwardIterator1, class ForwardIterator2>\n-ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,\n-\t\t\t     ForwardIterator2 first2) {\n-  for ( ; first1 != last1; ++first1, ++first2)\n-    iter_swap(first1, first2);\n-  return first2;\n-}\n-\n-template <class InputIterator, class OutputIterator, class UnaryOperation>\n-OutputIterator transform(InputIterator first, InputIterator last,\n-\t\t\t OutputIterator result, UnaryOperation op) {\n-  for ( ; first != last; ++first, ++result)\n-    *result = op(*first);\n-  return result;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator,\n-\t  class BinaryOperation>\n-OutputIterator transform(InputIterator1 first1, InputIterator1 last1,\n-\t\t\t InputIterator2 first2, OutputIterator result,\n-\t\t\t BinaryOperation binary_op) {\n-  for ( ; first1 != last1; ++first1, ++first2, ++result)\n-    *result = binary_op(*first1, *first2);\n-  return result;\n-}\n-\n-template <class ForwardIterator, class T>\n-void replace(ForwardIterator first, ForwardIterator last, const T& old_value,\n-\t     const T& new_value) {\n-  for ( ; first != last; ++first)\n-    if (*first == old_value) *first = new_value;\n-}\n-\n-template <class ForwardIterator, class Predicate, class T>\n-void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred,\n-\t\tconst T& new_value) {\n-  for ( ; first != last; ++first)\n-    if (pred(*first)) *first = new_value;\n-}\n-\n-template <class InputIterator, class OutputIterator, class T>\n-OutputIterator replace_copy(InputIterator first, InputIterator last,\n-\t\t\t    OutputIterator result, const T& old_value,\n-\t\t\t    const T& new_value) {\n-  for ( ; first != last; ++first, ++result)\n-    *result = *first == old_value ? new_value : *first;\n-  return result;\n-}\n-\n-template <class Iterator, class OutputIterator, class Predicate, class T>\n-OutputIterator replace_copy_if(Iterator first, Iterator last,\n-\t\t\t       OutputIterator result, Predicate pred,\n-\t\t\t       const T& new_value) {\n-  for ( ; first != last; ++first, ++result)\n-    *result = pred(*first) ? new_value : *first;\n-  return result;\n-}\n-\n-template <class ForwardIterator, class Generator>\n-void generate(ForwardIterator first, ForwardIterator last, Generator gen) {\n-  for ( ; first != last; ++first)\n-    *first = gen();\n-}\n-\n-template <class OutputIterator, class Size, class Generator>\n-OutputIterator generate_n(OutputIterator first, Size n, Generator gen) {\n-  for ( ; n > 0; --n, ++first)\n-    *first = gen();\n-  return first;\n-}\n-\n-template <class InputIterator, class OutputIterator, class T>\n-OutputIterator remove_copy(InputIterator first, InputIterator last,\n-                           OutputIterator result, const T& value) {\n-  for ( ; first != last; ++first)\n-    if (*first != value) {\n-      *result = *first;\n-      ++result;\n-    }\n-  return result;\n-}\n-\n-template <class InputIterator, class OutputIterator, class Predicate>\n-OutputIterator remove_copy_if(InputIterator first, InputIterator last,\n-                              OutputIterator result, Predicate pred) {\n-  for ( ; first != last; ++first)\n-    if (!pred(*first)) {\n-      *result = *first;\n-      ++result;\n-    }\n-  return result;\n-}\n-\n-template <class ForwardIterator, class T>\n-ForwardIterator remove(ForwardIterator first, ForwardIterator last,\n-\t\t       const T& value) {\n-    first = find(first, last, value);\n-    ForwardIterator next = first;\n-    return first == last ? first : remove_copy(++next, last, first, value);\n-}\n-\n-template <class ForwardIterator, class Predicate>\n-ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,\n-\t\t\t  Predicate pred) {\n-    first = find_if(first, last, pred);\n-    ForwardIterator next = first;\n-    return first == last ? first : remove_copy_if(++next, last, first, pred);\n-}\n-\n-template <class InputIterator, class ForwardIterator>\n-ForwardIterator __unique_copy(InputIterator first, InputIterator last,\n-\t\t\t      ForwardIterator result, forward_iterator_tag) {\n-    *result = *first;\n-    while (++first != last)\n-        if (*result != *first) *++result = *first;\n-    return ++result;\n-}\n-\n-template <class InputIterator, class BidirectionalIterator>\n-inline BidirectionalIterator __unique_copy(InputIterator first, \n-\t\t\t\t\t   InputIterator last,\n-\t\t\t            \t   BidirectionalIterator result, \n-\t\t\t\t    \t   bidirectional_iterator_tag) {\n-    return __unique_copy(first, last, result, forward_iterator_tag());\n-}\n-\n-template <class InputIterator, class RandomAccessIterator>\n-inline RandomAccessIterator __unique_copy(InputIterator first, \n-\t\t\t\t\t  InputIterator last,\n-\t\t\t           \t  RandomAccessIterator result, \n-\t\t\t\t   \t  random_access_iterator_tag) {\n-    return __unique_copy(first, last, result, forward_iterator_tag());\n-}\n-\n-template <class InputIterator, class OutputIterator, class T>\n-OutputIterator __unique_copy(InputIterator first, InputIterator last,\n-\t\t\t     OutputIterator result, T*) {\n-    T value = *first;\n-    *result = value;\n-    while (++first != last)\n-\tif (value != *first) {\n-\t    value = *first;\n-\t    *++result = value;\n-\t}\n-    return ++result;\n-}\n-\n-template <class InputIterator, class OutputIterator>\n-inline OutputIterator __unique_copy(InputIterator first, InputIterator last,\n-                             \t    OutputIterator result, \n-\t\t\t\t    output_iterator_tag) {\n-    return __unique_copy(first, last, result, value_type(first));\n-}\n-\n-template <class InputIterator, class OutputIterator>\n-inline OutputIterator unique_copy(InputIterator first, InputIterator last,\n-\t\t\t   \t  OutputIterator result) {\n-    if (first == last) return result;\n-    return __unique_copy(first, last, result, iterator_category(result));\n-}\n-template <class InputIterator, class ForwardIterator, class BinaryPredicate>\n-ForwardIterator __unique_copy(InputIterator first, InputIterator last,\n-\t\t\t      ForwardIterator result, \n-\t\t\t      BinaryPredicate binary_pred,\n-\t\t\t      forward_iterator_tag) {\n-    *result = *first;\n-    while (++first != last)\n-        if (!binary_pred(*result, *first)) *++result = *first;\n-    return ++result;\n-}\n-\n-template <class InputIterator, class BidirectionalIterator,\n-          class BinaryPredicate>\n-inline BidirectionalIterator __unique_copy(InputIterator first, \n-\t\t\t\t\t   InputIterator last,\n-\t\t\t            \t   BidirectionalIterator result, \n-\t\t\t\t\t   BinaryPredicate binary_pred,\n-\t\t\t\t    \t   bidirectional_iterator_tag) {\n-    return __unique_copy(first, last, result, binary_pred,\n-\t\t\t forward_iterator_tag());\n-}\n-\n-template <class InputIterator, class RandomAccessIterator,\n-          class BinaryPredicate>\n-inline RandomAccessIterator __unique_copy(InputIterator first, \n-\t\t\t\t\t  InputIterator last,\n-\t\t\t           \t  RandomAccessIterator result, \n-\t\t\t\t\t  BinaryPredicate binary_pred,\n-\t\t\t\t   \t  random_access_iterator_tag) {\n-    return __unique_copy(first, last, result, binary_pred, \n-\t\t\t forward_iterator_tag());\n-}\n-\n-template <class InputIterator, class OutputIterator, class BinaryPredicate,\n-          class T>\n-OutputIterator __unique_copy(InputIterator first, InputIterator last,\n-\t\t\t     OutputIterator result,\n-\t\t\t     BinaryPredicate binary_pred, T*) {\n-    T value = *first;\n-    *result = value;\n-    while (++first != last)\n-\tif (!binary_pred(value, *first)) {\n-\t    value = *first;\n-\t    *++result = value;\n-\t}\n-    return ++result;\n-}\n-\n-template <class InputIterator, class OutputIterator, class BinaryPredicate>\n-inline OutputIterator __unique_copy(InputIterator first, InputIterator last,\n-                             \t    OutputIterator result,\n-\t\t\t\t    BinaryPredicate binary_pred,\n-\t\t\t\t    output_iterator_tag) {\n-    return __unique_copy(first, last, result, binary_pred, value_type(first));\n-}\n-\n-template <class InputIterator, class OutputIterator, class BinaryPredicate>\n-inline OutputIterator unique_copy(InputIterator first, InputIterator last,\n-\t\t\t   \t  OutputIterator result,\n-\t\t\t\t  BinaryPredicate binary_pred) {\n-    if (first == last) return result;\n-    return __unique_copy(first, last, result, binary_pred,\n-\t\t\t iterator_category(result));\n-}\n-\n-template <class ForwardIterator>\n-ForwardIterator unique(ForwardIterator first, ForwardIterator last) {\n-    first = adjacent_find(first, last);\n-    return unique_copy(first, last, first);\n-}\n-\n-template <class ForwardIterator, class BinaryPredicate>\n-ForwardIterator unique(ForwardIterator first, ForwardIterator last,\n-\t\t       BinaryPredicate binary_pred) {\n-    first = adjacent_find(first, last, binary_pred);\n-    return unique_copy(first, last, first, binary_pred);\n-}\n-\n-template <class BidirectionalIterator>\n-void __reverse(BidirectionalIterator first, BidirectionalIterator last, \n-\t       bidirectional_iterator_tag) {\n-    while (true)\n-        if (first == last || first == --last)\n-\t    return;\n-        else\n-\t    iter_swap(first++, last);\n-}\n-\n-template <class RandomAccessIterator>\n-void __reverse(RandomAccessIterator first, RandomAccessIterator last,\n-\t       random_access_iterator_tag) {\n-    while (first < last) iter_swap(first++, --last);\n-}\n-\n-template <class BidirectionalIterator>\n-inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {\n-    __reverse(first, last, iterator_category(first));\n-}\n-\n-template <class BidirectionalIterator, class OutputIterator>\n-OutputIterator reverse_copy(BidirectionalIterator first,\n-                            BidirectionalIterator last,\n-                            OutputIterator result) {\n-  while (first != last) {\n-    --last;\n-    *result = *last;\n-    ++result;\n-  }\n-  return result;\n-}\n-\n-template <class ForwardIterator, class Distance>\n-void __rotate(ForwardIterator first, ForwardIterator middle,\n-              ForwardIterator last, Distance*, forward_iterator_tag) {\n-  for (ForwardIterator i = middle; ;) {\n-    iter_swap(first, i);\n-    ++first;\n-    ++i;\n-    if (first == middle) {\n-      if (i == last) return;\n-      middle = i;\n-    }\n-    else if (i == last)\n-      i = middle;\n-  }\n-}\n-\n-template <class BidirectionalIterator, class Distance>\n-void __rotate(BidirectionalIterator first, BidirectionalIterator middle,\n-\t      BidirectionalIterator last, Distance*,\n-\t      bidirectional_iterator_tag) {\n-    reverse(first, middle);\n-    reverse(middle, last);\n-    reverse(first, last);\n-}\n-\n-template <class EuclideanRingElement>\n-EuclideanRingElement __gcd(EuclideanRingElement m, EuclideanRingElement n)\n-{\n-    while (n != 0) {\n-\tEuclideanRingElement t = m % n;\n-\tm = n;\n-\tn = t;\n-    }\n-    return m;\n-}\n-\n-template <class RandomAccessIterator, class Distance, class T>\n-void __rotate_cycle(RandomAccessIterator first, RandomAccessIterator last,\n-\t\t    RandomAccessIterator initial, Distance shift, T*) {\n-    T value = *initial;\n-    RandomAccessIterator ptr1 = initial;\n-    RandomAccessIterator ptr2 = ptr1 + shift;\n-    while (ptr2 != initial) {\n-\t*ptr1 = *ptr2;\n-\tptr1 = ptr2;\n-\tif (last - ptr2 > shift)\n-\t    ptr2 += shift;\n-\telse\n-\t    ptr2 = first + (shift - (last - ptr2));\n-    }\n-    *ptr1 = value;\n-}\n-\n-template <class RandomAccessIterator, class Distance>\n-void __rotate(RandomAccessIterator first, RandomAccessIterator middle,\n-\t      RandomAccessIterator last, Distance*,\n-\t      random_access_iterator_tag) {\n-    Distance n = __gcd(last - first, middle - first);\n-    while (n--)\n-\t__rotate_cycle(first, last, first + n, middle - first,\n-\t\t       value_type(first));\n-}\n-\n-template <class ForwardIterator>\n-inline void rotate(ForwardIterator first, ForwardIterator middle,\n-\t\t   ForwardIterator last) {\n-    if (first == middle || middle == last) return;\n-    __rotate(first, middle, last, distance_type(first),\n-\t     iterator_category(first));\n-}\n-\n-template <class ForwardIterator, class OutputIterator>\n-OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,\n-\t\t\t   ForwardIterator last, OutputIterator result) {\n-    return copy(first, middle, copy(middle, last, result));\n-}\n-\n-template <class RandomAccessIterator, class Distance>\n-void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n-\t\t      Distance*) {\n-    if (first == last) return;\n-    for (RandomAccessIterator i = first + 1; i != last; ++i) \n-#ifdef __STL_NO_DRAND48\n-      iter_swap(i, first + Distance(rand() % ((i - first) + 1)));\n-#else\n-      iter_swap(i, first + Distance(lrand48() % ((i - first) + 1)));\n-#endif\n-}\n-\n-template <class RandomAccessIterator>\n-inline void random_shuffle(RandomAccessIterator first,\n-\t\t\t   RandomAccessIterator last) {\n-    __random_shuffle(first, last, distance_type(first));\n-}\n-\n-template <class RandomAccessIterator, class RandomNumberGenerator>\n-void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n-\t\t    RandomNumberGenerator& rand) {\n-    if (first == last) return;\n-    for (RandomAccessIterator i = first + 1; i != last; ++i)\n-\titer_swap(i, first + rand((i - first) + 1));\n-}\n-\n-template <class ForwardIterator, class OutputIterator, class Distance>\n-OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,\n-                               OutputIterator out, const Distance n)\n-{\n-  Distance remaining = 0;\n-  distance(first, last, remaining);\n-  Distance m = min(n, remaining);\n-\n-  while (m > 0) {\n-#ifdef __STL_NO_DRAND48\n-    if (rand() % remaining < m) {\n-#else\n-    if (lrand48() % remaining < m) {\n-#endif\n-      *out = *first;\n-      ++out;\n-      --m;\n-    }\n-\n-    --remaining;\n-    ++first;\n-  }\n-  return out;\n-}\n-\n-template <class ForwardIterator, class OutputIterator, class Distance,\n-          class RandomNumberGenerator>\n-OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,\n-                               OutputIterator out, const Distance n,\n-                               RandomNumberGenerator& rand)\n-{\n-  Distance remaining = 0;\n-  distance(first, last, remaining);\n-  Distance m = min(n, remaining);\n-\n-  while (m > 0) {\n-    if (rand(remaining) < m) {\n-      *out = *first;\n-      ++out;\n-      --m;\n-    }\n-\n-    --remaining;\n-    ++first;\n-  }\n-  return out;\n-}\n-\n-template <class InputIterator, class RandomAccessIterator, class Distance>\n-RandomAccessIterator __random_sample(InputIterator first, InputIterator last,\n-                                     RandomAccessIterator out,\n-                                     const Distance n)\n-{\n-  Distance m = 0;\n-  Distance t = n;\n-  for ( ; first != last && m < n; ++m, ++first) \n-    out[m] = *first;\n-\n-  while (first != last) {\n-    ++t;\n-#ifdef __STL_NO_DRAND48\n-    Distance M = rand() % t;\n-#else\n-    Distance M = lrand48() % t;\n-#endif\n-    if (M < n)\n-      out[M] = *first;\n-    ++first;\n-  }\n-\n-  return out + m;\n-}\n-\n-template <class InputIterator, class RandomAccessIterator,\n-          class RandomNumberGenerator, class Distance>\n-RandomAccessIterator __random_sample(InputIterator first, InputIterator last,\n-                                     RandomAccessIterator out,\n-                                     RandomNumberGenerator& rand,\n-                                     const Distance n)\n-{\n-  Distance m = 0;\n-  Distance t = n;\n-  for ( ; first != last && m < n; ++m, ++first)\n-    out[m] = *first;\n-\n-  while (first != last) {\n-    ++t;\n-    Distance M = rand(t);\n-    if (M < n)\n-      out[M] = *first;\n-    ++first;\n-  }\n-\n-  return out + m;\n-}\n-\n-template <class InputIterator, class RandomAccessIterator>\n-inline RandomAccessIterator\n-random_sample(InputIterator first, InputIterator last,\n-              RandomAccessIterator out_first, RandomAccessIterator out_last) \n-{\n-  return __random_sample(first, last, out_first, out_last - out_first);\n-}\n-\n-template <class InputIterator, class RandomAccessIterator, \n-          class RandomNumberGenerator>\n-inline RandomAccessIterator\n-random_sample(InputIterator first, InputIterator last,\n-              RandomAccessIterator out_first, RandomAccessIterator out_last,\n-              RandomNumberGenerator& rand) \n-{\n-  return __random_sample(first, last, out_first, rand, out_last - out_first);\n-}\n-\n-\n-\n-template <class BidirectionalIterator, class Predicate>\n-BidirectionalIterator partition(BidirectionalIterator first,\n-\t\t\t\tBidirectionalIterator last, Predicate pred) {\n-    while (true) {\n-\twhile (true)\n-\t    if (first == last)\n-\t\treturn first;\n-\t    else if (pred(*first))\n-\t\t++first;\n-\t    else\n-\t\tbreak;\n-\t--last;\n-\twhile (true)\n-\t    if (first == last)\n-\t\treturn first;\n-\t    else if (!pred(*last))\n-\t\t--last;\n-\t    else\n-\t\tbreak;\n-\titer_swap(first, last);\n-\t++first;\n-    }\n-}\n-\n-template <class ForwardIterator, class Predicate, class Distance>\n-ForwardIterator __inplace_stable_partition(ForwardIterator first,\n-\t\t\t\t\t   ForwardIterator last,\n-\t\t\t\t\t   Predicate pred, Distance len) {\n-    if (len == 1) return pred(*first) ? last : first;\n-    ForwardIterator middle = first;\n-    advance(middle, len / 2);\n-    ForwardIterator \n-\tfirst_cut = __inplace_stable_partition(first, middle, pred, len / 2);\n-    ForwardIterator \n-\tsecond_cut = __inplace_stable_partition(middle, last, pred,\n-\t\t\t\t\t\tlen - len / 2);\n-    rotate(first_cut, middle, second_cut);\n-    len = 0;\n-    distance(middle, second_cut, len);\n-    advance(first_cut, len);\n-    return first_cut;\n-}\n-\n-template <class ForwardIterator, class Pointer, class Predicate, \n-          class Distance>\n-ForwardIterator __stable_partition_adaptive(ForwardIterator first,\n-                                            ForwardIterator last,\n-                                            Predicate pred, Distance len,\n-                                            Pointer buffer,\n-                                            Distance buffer_size) {\n-  if (len <= buffer_size) {\n-    ForwardIterator result1 = first;\n-    Pointer result2 = buffer;\n-    for ( ; first != last ; ++first)\n-      if (pred(*first)) {\n-        *result1 = *first;\n-        ++result1;\n-      }\n-      else {\n-        *result2 = *first;\n-        ++result2;\n-      }\n-    copy(buffer, result2, result1);\n-    return result1;\n-  }\n-  else {\n-    ForwardIterator middle = first;\n-    advance(middle, len / 2);\n-    ForwardIterator first_cut =\n-      __stable_partition_adaptive(first, middle, pred, len / 2,\n-                                  buffer, buffer_size);\n-    ForwardIterator second_cut =\n-      __stable_partition_adaptive(middle, last, pred, len - len / 2,\n-                                  buffer, buffer_size);\n-\n-    rotate(first_cut, middle, second_cut);\n-    len = 0;\n-    distance(middle, second_cut, len);\n-    advance(first_cut, len);\n-    return first_cut;\n-  }\n-}\n-\n-template <class ForwardIterator, class Predicate, class T, class Distance>\n-inline ForwardIterator __stable_partition_aux(ForwardIterator first,\n-                                              ForwardIterator last, \n-                                              Predicate pred, T*, Distance*) {\n-  temporary_buffer<ForwardIterator, T> buf(first, last);\n-  if (buf.size() > 0)\n-    return __stable_partition_adaptive(first, last, pred,\n-                                       Distance(buf.requested_size()),\n-                                       buf.begin(), buf.size());\n-  else\n-    return __inplace_stable_partition(first, last, pred, \n-                                      Distance(buf.requested_size()));\n-}\n-\n-template <class ForwardIterator, class Predicate>\n-inline ForwardIterator stable_partition(ForwardIterator first,\n-                                        ForwardIterator last, \n-                                        Predicate pred) {\n-  if (first == last)\n-    return first;\n-  else\n-    return __stable_partition_aux(first, last, pred,\n-                                  value_type(first), distance_type(first));\n-}\n-\n-template <class RandomAccessIterator, class T>\n-RandomAccessIterator __unguarded_partition(RandomAccessIterator first, \n-\t\t\t\t\t   RandomAccessIterator last, \n-\t\t\t\t\t   T pivot) {\n-    while (1) {\n-\twhile (*first < pivot) ++first;\n-\t--last;\n-\twhile (pivot < *last) --last;\n-\tif (!(first < last)) return first;\n-\titer_swap(first, last);\n-\t++first;\n-    }\n-}    \n-\n-template <class RandomAccessIterator, class T, class Compare>\n-RandomAccessIterator __unguarded_partition(RandomAccessIterator first, \n-\t\t\t\t\t   RandomAccessIterator last, \n-\t\t\t\t\t   T pivot, Compare comp) {\n-    while (1) {\n-\twhile (comp(*first, pivot)) ++first;\n-\t--last;\n-\twhile (comp(pivot, *last)) --last;\n-\tif (!(first < last)) return first;\n-\titer_swap(first, last);\n-\t++first;\n-    }\n-}\n-\n-const int __stl_threshold = 16;\n-\n-\n-template <class RandomAccessIterator, class T>\n-void __unguarded_linear_insert(RandomAccessIterator last, T value) {\n-    RandomAccessIterator next = last;\n-    --next;\n-    while (value < *next) {\n-\t*last = *next;\n-\tlast = next;\n-        --next;\n-    }\n-    *last = value;\n-}\n-\n-template <class RandomAccessIterator, class T, class Compare>\n-void __unguarded_linear_insert(RandomAccessIterator last, T value, \n-\t\t\t       Compare comp) {\n-    RandomAccessIterator next = last;\n-    --next;  \n-    while (comp(value , *next)) {\n-\t*last = *next;\n-\tlast = next;\n-        --next;\n-    }\n-    *last = value;\n-}\n-\n-template <class RandomAccessIterator, class T>\n-inline void __linear_insert(RandomAccessIterator first, \n-\t\t\t    RandomAccessIterator last, T*) {\n-    T value = *last;\n-    if (value < *first) {\n-\tcopy_backward(first, last, last + 1);\n-\t*first = value;\n-    } else\n-\t__unguarded_linear_insert(last, value);\n-}\n-\n-template <class RandomAccessIterator, class T, class Compare>\n-inline void __linear_insert(RandomAccessIterator first, \n-\t\t\t    RandomAccessIterator last, T*, Compare comp) {\n-    T value = *last;\n-    if (comp(value, *first)) {\n-\tcopy_backward(first, last, last + 1);\n-\t*first = value;\n-    } else\n-\t__unguarded_linear_insert(last, value, comp);\n-}\n-\n-template <class RandomAccessIterator>\n-void __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) {\n-    if (first == last) return; \n-    for (RandomAccessIterator i = first + 1; i != last; ++i)\n-\t__linear_insert(first, i, value_type(first));\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-void __insertion_sort(RandomAccessIterator first,\n-\t\t      RandomAccessIterator last, Compare comp) {\n-    if (first == last) return;\n-    for (RandomAccessIterator i = first + 1; i != last; ++i)\n-\t__linear_insert(first, i, value_type(first), comp);\n-}\n-\n-template <class RandomAccessIterator, class T>\n-void __unguarded_insertion_sort_aux(RandomAccessIterator first, \n-\t\t\t\t    RandomAccessIterator last, T*) {\n-    for (RandomAccessIterator i = first; i != last; ++i)\n-\t__unguarded_linear_insert(i, T(*i));\n-}\n-\n-template <class RandomAccessIterator>\n-inline void __unguarded_insertion_sort(RandomAccessIterator first, \n-\t\t\t\tRandomAccessIterator last) {\n-    __unguarded_insertion_sort_aux(first, last, value_type(first));\n-}\n-\n-template <class RandomAccessIterator, class T, class Compare>\n-void __unguarded_insertion_sort_aux(RandomAccessIterator first, \n-\t\t\t\t    RandomAccessIterator last,\n-\t\t\t\t    T*, Compare comp) {\n-    for (RandomAccessIterator i = first; i != last; ++i)\n-\t__unguarded_linear_insert(i, T(*i), comp);\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-inline void __unguarded_insertion_sort(RandomAccessIterator first, \n-\t\t\t\t       RandomAccessIterator last,\n-\t\t\t\t       Compare comp) {\n-    __unguarded_insertion_sort_aux(first, last, value_type(first), comp);\n-}\n-\n-template <class RandomAccessIterator>\n-void __final_insertion_sort(RandomAccessIterator first, \n-\t\t\t    RandomAccessIterator last) {\n-    if (last - first > __stl_threshold) {\n-\t__insertion_sort(first, first + __stl_threshold);\n-\t__unguarded_insertion_sort(first + __stl_threshold, last);\n-    } else\n-\t__insertion_sort(first, last);\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-void __final_insertion_sort(RandomAccessIterator first, \n-\t\t\t    RandomAccessIterator last, Compare comp) {\n-    if (last - first > __stl_threshold) {\n-\t__insertion_sort(first, first + __stl_threshold, comp);\n-\t__unguarded_insertion_sort(first + __stl_threshold, last, comp);\n-    } else\n-\t__insertion_sort(first, last, comp);\n-}\n-\n-template <class Size>\n-Size __lg(Size n) {\n-    Size k;\n-    for (k = 0; n != 1; n = n / 2) ++k;\n-    return k;\n-}\n-\n-template <class RandomAccessIterator, class T, class Size>\n-void __introsort_loop(RandomAccessIterator first,\n-                      RandomAccessIterator last, T*,\n-                      Size depth_limit) {\n-    while (last - first > __stl_threshold) {\n-      if (depth_limit == 0) {\n-\tpartial_sort(first, last, last);\n-\treturn;\n-      }\n-      --depth_limit;\n-      RandomAccessIterator cut = __unguarded_partition\n-\t(first, last, T(__median(*first, *(first + (last - first)/2),\n-\t\t\t\t *(last - 1))));\n-     __introsort_loop(cut, last, value_type(first), depth_limit);\n-     last = cut;\n-    }\n-}\n-\n-template <class RandomAccessIterator, class T, class Size, class Compare>\n-void __introsort_loop(RandomAccessIterator first,\n- \t\t      RandomAccessIterator last, T*,\n-\t\t      Size depth_limit, Compare comp) {\n-  while (last - first > __stl_threshold) {\n-    if (depth_limit == 0) {\n-      partial_sort(first, last, last, comp);\n-      return;\n-    }\n-    --depth_limit;\n-    RandomAccessIterator cut = __unguarded_partition\n-      (first, last, T(__median(*first, *(first + (last - first)/2),\n-\t\t\t       *(last - 1), comp)), comp);\n-    __introsort_loop(cut, last, value_type(first), depth_limit, comp);\n-    last = cut;\n-  }\n-}\n-\n-template <class RandomAccessIterator>\n-inline void sort(RandomAccessIterator first, RandomAccessIterator last) {\n-  if (first != last) {\n-    __introsort_loop(first, last, value_type(first), __lg(last - first) * 2);\n-    __final_insertion_sort(first, last);\n-  }\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-inline void sort(RandomAccessIterator first, RandomAccessIterator last,\n-                 Compare comp) {\n-  if (first != last) {\n-    __introsort_loop(first, last, value_type(first), __lg(last - first) * 2,\n-                     comp);\n-    __final_insertion_sort(first, last, comp);\n-  }\n-}\n-\n-\n-template <class RandomAccessIterator>\n-void __inplace_stable_sort(RandomAccessIterator first,\n-\t\t\t   RandomAccessIterator last) {\n-    if (last - first < 15) {\n-\t__insertion_sort(first, last);\n-\treturn;\n-    }\n-    RandomAccessIterator middle = first + (last - first) / 2;\n-    __inplace_stable_sort(first, middle);\n-    __inplace_stable_sort(middle, last);\n-    __merge_without_buffer(first, middle, last, middle - first, last - middle);\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-void __inplace_stable_sort(RandomAccessIterator first,\n-\t\t\t   RandomAccessIterator last, Compare comp) {\n-    if (last - first < 15) {\n-\t__insertion_sort(first, last, comp);\n-\treturn;\n-    }\n-    RandomAccessIterator middle = first + (last - first) / 2;\n-    __inplace_stable_sort(first, middle, comp);\n-    __inplace_stable_sort(middle, last, comp);\n-    __merge_without_buffer(first, middle, last, middle - first,\n-\t\t\t   last - middle, comp);\n-}\n-\n-template <class RandomAccessIterator1, class RandomAccessIterator2,\n-\t  class Distance>\n-void __merge_sort_loop(RandomAccessIterator1 first,\n-\t\t       RandomAccessIterator1 last, \n-\t\t       RandomAccessIterator2 result, Distance step_size) {\n-    Distance two_step = 2 * step_size;\n-\n-    while (last - first >= two_step) {\n-\tresult = merge(first, first + step_size,\n-\t\t       first + step_size, first + two_step, result);\n-\tfirst += two_step;\n-    }\n-\n-    step_size = min(Distance(last - first), step_size);\n-    merge(first, first + step_size, first + step_size, last, result);\n-}\n-\n-template <class RandomAccessIterator1, class RandomAccessIterator2,\n-\t  class Distance, class Compare>\n-void __merge_sort_loop(RandomAccessIterator1 first,\n-\t\t       RandomAccessIterator1 last, \n-\t\t       RandomAccessIterator2 result, Distance step_size,\n-\t\t       Compare comp) {\n-    Distance two_step = 2 * step_size;\n-\n-    while (last - first >= two_step) {\n-\tresult = merge(first, first + step_size,\n-\t\t       first + step_size, first + two_step, result, comp);\n-\tfirst += two_step;\n-    }\n-    step_size = min(Distance(last - first), step_size);\n-\n-    merge(first, first + step_size, first + step_size, last, result, comp);\n-}\n-\n-const int __stl_chunk_size = 7;\n-        \n-template <class RandomAccessIterator, class Distance>\n-void __chunk_insertion_sort(RandomAccessIterator first, \n-                            RandomAccessIterator last, Distance chunk_size) {\n-  while (last - first >= chunk_size) {\n-    __insertion_sort(first, first + chunk_size);\n-    first += chunk_size;\n-  }\n-  __insertion_sort(first, last);\n-}\n-\n-template <class RandomAccessIterator, class Distance, class Compare>\n-void __chunk_insertion_sort(RandomAccessIterator first, \n-                            RandomAccessIterator last,\n-                            Distance chunk_size, Compare comp) {\n-  while (last - first >= chunk_size) {\n-    __insertion_sort(first, first + chunk_size, comp);\n-    first += chunk_size;\n-  }\n-  __insertion_sort(first, last, comp);\n-}\n-\n-template <class RandomAccessIterator, class Pointer, class Distance>\n-void __merge_sort_with_buffer(RandomAccessIterator first, \n-                              RandomAccessIterator last,\n-                              Pointer buffer, Distance*) {\n-    Distance len = last - first;\n-    Pointer buffer_last = buffer + len;\n-\n-    Distance step_size = __stl_chunk_size;\n-    __chunk_insertion_sort(first, last, step_size);\n-\n-    while (step_size < len) {\n-\t__merge_sort_loop(first, last, buffer, step_size);\n-\tstep_size *= 2;\n-\t__merge_sort_loop(buffer, buffer_last, first, step_size);\n-\tstep_size *= 2;\n-    }\n-}\n-\n-template <class RandomAccessIterator, class Pointer, class Distance,\n-          class Compare>\n-void __merge_sort_with_buffer(RandomAccessIterator first, \n-                              RandomAccessIterator last, Pointer buffer,\n-                              Distance*, Compare comp) {\n-    Distance len = last - first;\n-    Pointer buffer_last = buffer + len;\n-\n-    Distance step_size = __stl_chunk_size;\n-    __chunk_insertion_sort(first, last, step_size, comp);\n-\n-    while (step_size < len) {\n-\t__merge_sort_loop(first, last, buffer, step_size, comp);\n-\tstep_size *= 2;\n-\t__merge_sort_loop(buffer, buffer_last, first, step_size, comp);\n-\tstep_size *= 2;\n-    }\n-}\n-\n-template <class RandomAccessIterator, class Pointer, class Distance>\n-void __stable_sort_adaptive(RandomAccessIterator first, \n-\t\t\t    RandomAccessIterator last, Pointer buffer,\n-\t\t\t    Distance buffer_size) {\n-    Distance len = (last - first + 1) / 2;\n-    RandomAccessIterator middle = first + len;\n-    if (len > buffer_size) {\n-\t__stable_sort_adaptive(first, middle, buffer, buffer_size);\n-\t__stable_sort_adaptive(middle, last, buffer, buffer_size);\n-    } else {\n-\t__merge_sort_with_buffer(first, middle, buffer, (Distance*)0);\n-\t__merge_sort_with_buffer(middle, last, buffer, (Distance*)0);\n-    }\n-    __merge_adaptive(first, middle, last, Distance(middle - first), \n-\t\t     Distance(last - middle), buffer, buffer_size);\n-}\n-\n-template <class RandomAccessIterator, class Pointer, class Distance, \n-          class Compare>\n-void __stable_sort_adaptive(RandomAccessIterator first, \n-                            RandomAccessIterator last, Pointer buffer,\n-                            Distance buffer_size, Compare comp) {\n-    Distance len = (last - first + 1) / 2;\n-    RandomAccessIterator middle = first + len;\n-    if (len > buffer_size) {\n-        __stable_sort_adaptive(first, middle, buffer, buffer_size, \n-                               comp);\n-        __stable_sort_adaptive(middle, last, buffer, buffer_size, \n-                               comp);\n-    } else {\n-        __merge_sort_with_buffer(first, middle, buffer, (Distance*)0, comp);\n-        __merge_sort_with_buffer(middle, last, buffer, (Distance*)0, comp);\n-    }\n-    __merge_adaptive(first, middle, last, Distance(middle - first), \n-                     Distance(last - middle), buffer, buffer_size,\n-                     comp);\n-}\n-\n-template <class RandomAccessIterator, class T, class Distance>\n-inline void __stable_sort_aux(RandomAccessIterator first,\n-\t\t\t      RandomAccessIterator last, T*, Distance*) {\n-  temporary_buffer<RandomAccessIterator, T> buf(first, last);\n-  if (buf.begin() == 0)\n-    __inplace_stable_sort(first, last);\n-  else \n-    __stable_sort_adaptive(first, last, buf.begin(), Distance(buf.size()));\n-}\n-\n-template <class RandomAccessIterator, class T, class Distance, class Compare>\n-inline void __stable_sort_aux(RandomAccessIterator first,\n-\t\t\t      RandomAccessIterator last, T*, Distance*,\n-\t\t\t      Compare comp) {\n-  temporary_buffer<RandomAccessIterator, T> buf(first, last);\n-  if (buf.begin() == 0)\n-    __inplace_stable_sort(first, last, comp);\n-  else \n-    __stable_sort_adaptive(first, last, buf.begin(), Distance(buf.size()),\n-                           comp);\n-}\n-\n-template <class RandomAccessIterator>\n-inline void stable_sort(RandomAccessIterator first,\n-\t\t\tRandomAccessIterator last) {\n-    __stable_sort_aux(first, last, value_type(first), distance_type(first));\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-inline void stable_sort(RandomAccessIterator first,\n-\t\t\tRandomAccessIterator last, Compare comp) {\n-    __stable_sort_aux(first, last, value_type(first), distance_type(first), \n-\t\t      comp);\n-}\n-\n-template <class RandomAccessIterator, class T>\n-void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,\n-\t\t    RandomAccessIterator last, T*) {\n-    make_heap(first, middle);\n-    for (RandomAccessIterator i = middle; i < last; ++i)\n-\tif (*i < *first) \n-\t  __pop_heap(first, middle, i, T(*i), distance_type(first));\n-    sort_heap(first, middle);\n-}\n-\n-template <class RandomAccessIterator>\n-inline void partial_sort(RandomAccessIterator first,\n-\t\t\t RandomAccessIterator middle,\n-\t\t\t RandomAccessIterator last) {\n-    __partial_sort(first, middle, last, value_type(first));\n-}\n-\n-template <class RandomAccessIterator, class T, class Compare>\n-void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,\n-\t\t    RandomAccessIterator last, T*, Compare comp) {\n-    make_heap(first, middle, comp);\n-    for (RandomAccessIterator i = middle; i < last; ++i)\n-\tif (comp(*i, *first))\n-\t  __pop_heap(first, middle, i, T(*i), comp, distance_type(first));\n-    sort_heap(first, middle, comp);\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-inline void partial_sort(RandomAccessIterator first,\n-\t\t\t RandomAccessIterator middle,\n-\t\t\t RandomAccessIterator last, Compare comp) {\n-    __partial_sort(first, middle, last, value_type(first), comp);\n-}\n-\n-template <class InputIterator, class RandomAccessIterator, class Distance,\n-          class T>\n-RandomAccessIterator __partial_sort_copy(InputIterator first,\n-\t\t\t\t\t InputIterator last,\n-\t\t\t\t\t RandomAccessIterator result_first,\n-\t\t\t\t\t RandomAccessIterator result_last, \n-\t\t\t\t\t Distance*, T*) {\n-    if (result_first == result_last) return result_last;\n-    RandomAccessIterator result_real_last = result_first;\n-    while(first != last && result_real_last != result_last) {\n-\t*result_real_last = *first;\n-        ++result_real_last;\n-        ++first;\n-    }\n-    make_heap(result_first, result_real_last);\n-    while (first != last) {\n-\tif (*first < *result_first) \n-\t    __adjust_heap(result_first, Distance(0),\n-\t\t\t  Distance(result_real_last - result_first), T(*first));\n-\t++first;\n-    }\n-    sort_heap(result_first, result_real_last);\n-    return result_real_last;\n-}\n-\n-template <class InputIterator, class RandomAccessIterator>\n-inline RandomAccessIterator\n-partial_sort_copy(InputIterator first, InputIterator last,\n-\t\t  RandomAccessIterator result_first,\n-\t\t  RandomAccessIterator result_last) {\n-    return __partial_sort_copy(first, last, result_first, result_last, \n-\t\t\t       distance_type(result_first), value_type(first));\n-}\n-\n-template <class InputIterator, class RandomAccessIterator, class Compare,\n-          class Distance, class T>\n-RandomAccessIterator __partial_sort_copy(InputIterator first,\n-\t\t\t\t\t InputIterator last,\n-\t\t\t\t\t RandomAccessIterator result_first,\n-\t\t\t\t\t RandomAccessIterator result_last,\n-\t\t\t\t\t Compare comp, Distance*, T*) {\n-    if (result_first == result_last) return result_last;\n-    RandomAccessIterator result_real_last = result_first;\n-    while(first != last && result_real_last != result_last) {\n-\t*result_real_last = *first;\n-        ++result_real_last;\n-        ++first;\n-    }\n-    make_heap(result_first, result_real_last, comp);\n-    while (first != last) {\n-\tif (comp(*first, *result_first))\n-\t    __adjust_heap(result_first, Distance(0),\n-\t\t\t  Distance(result_real_last - result_first), T(*first),\n-\t\t\t  comp);\n-\t++first;\n-    }\n-    sort_heap(result_first, result_real_last, comp);\n-    return result_real_last;\n-}\n-\n-template <class InputIterator, class RandomAccessIterator, class Compare>\n-inline RandomAccessIterator\n-partial_sort_copy(InputIterator first, InputIterator last,\n-\t\t  RandomAccessIterator result_first,\n-\t\t  RandomAccessIterator result_last, Compare comp) {\n-    return __partial_sort_copy(first, last, result_first, result_last, comp,\n-\t\t\t       distance_type(result_first), value_type(first));\n-}\n-\n-template <class RandomAccessIterator, class T>\n-void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,\n-\t\t   RandomAccessIterator last, T*) {\n-    while (last - first > 3) {\n-\tRandomAccessIterator cut = __unguarded_partition\n-\t    (first, last, T(__median(*first, *(first + (last - first)/2),\n-\t\t\t\t     *(last - 1))));\n-\tif (cut <= nth)\n-\t    first = cut;\n-\telse \n-\t    last = cut;\n-    }\n-    __insertion_sort(first, last);\n-}\n-\n-template <class RandomAccessIterator>\n-inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,\n-\t\t\tRandomAccessIterator last) {\n-    __nth_element(first, nth, last, value_type(first));\n-}\n-\n-template <class RandomAccessIterator, class T, class Compare>\n-void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,\n-\t\t   RandomAccessIterator last, T*, Compare comp) {\n-    while (last - first > 3) {\n-\tRandomAccessIterator cut = __unguarded_partition\n-\t    (first, last, T(__median(*first, *(first + (last - first)/2), \n-\t\t\t\t     *(last - 1), comp)), comp);\n-\tif (cut <= nth)\n-\t    first = cut;\n-\telse \n-\t    last = cut;\n-    }\n-    __insertion_sort(first, last, comp);\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,\n-\t\t RandomAccessIterator last, Compare comp) {\n-    __nth_element(first, nth, last, value_type(first), comp);\n-}\n-\n-template <class ForwardIterator, class T, class Distance>\n-ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,\n-\t\t\t      const T& value, Distance*,\n-\t\t\t      forward_iterator_tag) {\n-    Distance len = 0;\n-    distance(first, last, len);\n-    Distance half;\n-    ForwardIterator middle;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first;\n-\tadvance(middle, half);\n-\tif (*middle < value) {\n-\t    first = middle;\n-\t    ++first;\n-\t    len = len - half - 1;\n-\t} else\n-\t    len = half;\n-    }\n-    return first;\n-}\n-\n-template <class RandomAccessIterator, class T, class Distance>\n-RandomAccessIterator __lower_bound(RandomAccessIterator first,\n-\t\t\t\t   RandomAccessIterator last, const T& value,\n-\t\t\t\t   Distance*, random_access_iterator_tag) {\n-    Distance len = last - first;\n-    Distance half;\n-    RandomAccessIterator middle;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first + half;\n-\tif (*middle < value) {\n-\t    first = middle + 1;\n-\t    len = len - half - 1;\n-\t} else\n-\t    len = half;\n-    }\n-    return first;\n-}\n-\n-template <class ForwardIterator, class T>\n-inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,\n-\t\t\t\t   const T& value) {\n-    return __lower_bound(first, last, value, distance_type(first),\n-\t\t\t iterator_category(first));\n-}\n-\n-template <class ForwardIterator, class T, class Compare, class Distance>\n-ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,\n-\t\t\t      const T& value, Compare comp, Distance*,\n-\t\t\t      forward_iterator_tag) {\n-    Distance len = 0;\n-    distance(first, last, len);\n-    Distance half;\n-    ForwardIterator middle;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first;\n-\tadvance(middle, half);\n-\tif (comp(*middle, value)) {\n-\t    first = middle;\n-\t    ++first;\n-\t    len = len - half - 1;\n-\t} else\n-\t    len = half;\n-    }\n-    return first;\n-}\n-\n-template <class RandomAccessIterator, class T, class Compare, class Distance>\n-RandomAccessIterator __lower_bound(RandomAccessIterator first,\n-\t\t\t\t   RandomAccessIterator last,\n-\t\t\t\t   const T& value, Compare comp, Distance*,\n-\t\t\t\t   random_access_iterator_tag) {\n-    Distance len = last - first;\n-    Distance half;\n-    RandomAccessIterator middle;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first + half;\n-\tif (comp(*middle, value)) {\n-\t    first = middle + 1;\n-\t    len = len - half - 1;\n-\t} else\n-\t    len = half;\n-    }\n-    return first;\n-}\n-\n-template <class ForwardIterator, class T, class Compare>\n-inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,\n-\t\t\t\t   const T& value, Compare comp) {\n-    return __lower_bound(first, last, value, comp, distance_type(first),\n-\t\t\t iterator_category(first));\n-}\n-\n-template <class ForwardIterator, class T, class Distance>\n-ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,\n-\t\t\t      const T& value, Distance*,\n-\t\t\t      forward_iterator_tag) {\n-    Distance len = 0;\n-    distance(first, last, len);\n-    Distance half;\n-    ForwardIterator middle;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first;\n-\tadvance(middle, half);\n-\tif (value < *middle)\n-\t    len = half;\n-\telse {\n-\t    first = middle;\n-\t    ++first;\n-\t    len = len - half - 1;\n-\t}\n-    }\n-    return first;\n-}\n-\n-template <class RandomAccessIterator, class T, class Distance>\n-RandomAccessIterator __upper_bound(RandomAccessIterator first,\n-\t\t\t\t   RandomAccessIterator last, const T& value,\n-\t\t\t\t   Distance*, random_access_iterator_tag) {\n-    Distance len = last - first;\n-    Distance half;\n-    RandomAccessIterator middle;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first + half;\n-\tif (value < *middle)\n-\t    len = half;\n-\telse {\n-\t    first = middle + 1;\n-\t    len = len - half - 1;\n-\t}\n-    }\n-    return first;\n-}\n-\n-template <class ForwardIterator, class T>\n-inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,\n-\t\t\t\t   const T& value) {\n-    return __upper_bound(first, last, value, distance_type(first),\n-\t\t\t iterator_category(first));\n-}\n-\n-template <class ForwardIterator, class T, class Compare, class Distance>\n-ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,\n-\t\t\t      const T& value, Compare comp, Distance*,\n-\t\t\t      forward_iterator_tag) {\n-    Distance len = 0;\n-    distance(first, last, len);\n-    Distance half;\n-    ForwardIterator middle;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first;\n-\tadvance(middle, half);\n-\tif (comp(value, *middle))\n-\t    len = half;\n-\telse {\n-\t    first = middle;\n-\t    ++first;\n-\t    len = len - half - 1;\n-\t}\n-    }\n-    return first;\n-}\n-\n-template <class RandomAccessIterator, class T, class Compare, class Distance>\n-RandomAccessIterator __upper_bound(RandomAccessIterator first,\n-\t\t\t\t   RandomAccessIterator last,\n-\t\t\t\t   const T& value, Compare comp, Distance*,\n-\t\t\t\t   random_access_iterator_tag) {\n-    Distance len = last - first;\n-    Distance half;\n-    RandomAccessIterator middle;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first + half;\n-\tif (comp(value, *middle))\n-\t    len = half;\n-\telse {\n-\t    first = middle + 1;\n-\t    len = len - half - 1;\n-\t}\n-    }\n-    return first;\n-}\n-\n-template <class ForwardIterator, class T, class Compare>\n-inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,\n-\t\t\t\t   const T& value, Compare comp) {\n-    return __upper_bound(first, last, value, comp, distance_type(first),\n-\t\t\t iterator_category(first));\n-}\n-\n-template <class ForwardIterator, class T, class Distance>\n-pair<ForwardIterator, ForwardIterator>\n-__equal_range(ForwardIterator first, ForwardIterator last, const T& value,\n-\t      Distance*, forward_iterator_tag) {\n-    Distance len = 0;\n-    distance(first, last, len);\n-    Distance half;\n-    ForwardIterator middle, left, right;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first;\n-\tadvance(middle, half);\n-\tif (*middle < value) {\n-\t    first = middle;\n-\t    ++first;\n-\t    len = len - half - 1;\n-\t} else if (value < *middle)\n-\t    len = half;\n-\telse {\n-\t    left = lower_bound(first, middle, value);\n-\t    advance(first, len);\n-\t    right = upper_bound(++middle, first, value);\n-\t    return pair<ForwardIterator, ForwardIterator>(left, right);\n-\t}\n-    }\n-    return pair<ForwardIterator, ForwardIterator>(first, first);\n-}\n-\n-template <class RandomAccessIterator, class T, class Distance>\n-pair<RandomAccessIterator, RandomAccessIterator>\n-__equal_range(RandomAccessIterator first, RandomAccessIterator last,\n-\t      const T& value, Distance*, random_access_iterator_tag) {\n-    Distance len = last - first;\n-    Distance half;\n-    RandomAccessIterator middle, left, right;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first + half;\n-\tif (*middle < value) {\n-\t    first = middle + 1;\n-\t    len = len - half - 1;\n-\t} else if (value < *middle)\n-\t    len = half;\n-\telse {\n-\t    left = lower_bound(first, middle, value);\n-\t    right = upper_bound(++middle, first + len, value);\n-\t    return pair<RandomAccessIterator, RandomAccessIterator>(left,\n-\t\t\t\t\t\t\t\t    right);\n-\t}\n-    }\n-    return pair<RandomAccessIterator, RandomAccessIterator>(first, first);\n-}\n-\n-template <class ForwardIterator, class T>\n-inline pair<ForwardIterator, ForwardIterator>\n-equal_range(ForwardIterator first, ForwardIterator last, const T& value) {\n-    return __equal_range(first, last, value, distance_type(first),\n-\t\t\t iterator_category(first));\n-}\n-\n-template <class ForwardIterator, class T, class Compare, class Distance>\n-pair<ForwardIterator, ForwardIterator>\n-__equal_range(ForwardIterator first, ForwardIterator last, const T& value,\n-\t      Compare comp, Distance*, forward_iterator_tag) {\n-    Distance len = 0;\n-    distance(first, last, len);\n-    Distance half;\n-    ForwardIterator middle, left, right;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first;\n-\tadvance(middle, half);\n-\tif (comp(*middle, value)) {\n-\t    first = middle;\n-\t    ++first;\n-\t    len = len - half - 1;\n-\t} else if (comp(value, *middle))\n-\t    len = half;\n-\telse {\n-\t    left = lower_bound(first, middle, value, comp);\n-\t    advance(first, len);\n-\t    right = upper_bound(++middle, first, value, comp);\n-\t    return pair<ForwardIterator, ForwardIterator>(left, right);\n-\t}\n-    }\n-    return pair<ForwardIterator, ForwardIterator>(first, first);\n-}           \n-\n-template <class RandomAccessIterator, class T, class Compare, class Distance>\n-pair<RandomAccessIterator, RandomAccessIterator>\n-__equal_range(RandomAccessIterator first, RandomAccessIterator last,\n-\t      const T& value, Compare comp, Distance*,\n-\t      random_access_iterator_tag) {\n-    Distance len = last - first;\n-    Distance half;\n-    RandomAccessIterator middle, left, right;\n-\n-    while (len > 0) {\n-\thalf = len / 2;\n-\tmiddle = first + half;\n-\tif (comp(*middle, value)) {\n-\t    first = middle + 1;\n-\t    len = len - half - 1;\n-\t} else if (comp(value, *middle))\n-\t    len = half;\n-\telse {\n-\t    left = lower_bound(first, middle, value, comp);\n-\t    right = upper_bound(++middle, first + len, value, comp);\n-\t    return pair<RandomAccessIterator, RandomAccessIterator>(left,\n-\t\t\t\t\t\t\t\t    right);\n-\t}\n-    }\n-    return pair<RandomAccessIterator, RandomAccessIterator>(first, first);\n-}           \n-\n-template <class ForwardIterator, class T, class Compare>\n-inline pair<ForwardIterator, ForwardIterator>\n-equal_range(ForwardIterator first, ForwardIterator last, const T& value,\n-\t    Compare comp) {\n-    return __equal_range(first, last, value, comp, distance_type(first),\n-\t\t\t iterator_category(first));\n-}    \n-\n-template <class ForwardIterator, class T>\n-bool binary_search(ForwardIterator first, ForwardIterator last,\n-\t\t   const T& value) {\n-    ForwardIterator i = lower_bound(first, last, value);\n-    return i != last && !(value < *i);\n-}\n-\n-template <class ForwardIterator, class T, class Compare>\n-bool binary_search(ForwardIterator first, ForwardIterator last, const T& value,\n-\t\t   Compare comp) {\n-    ForwardIterator i = lower_bound(first, last, value, comp);\n-    return i != last && !comp(value, *i);\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator>\n-OutputIterator merge(InputIterator1 first1, InputIterator1 last1,\n-                     InputIterator2 first2, InputIterator2 last2,\n-                     OutputIterator result) {\n-  while (first1 != last1 && first2 != last2) {\n-    if (*first2 < *first1) {\n-      *result = *first2;\n-      ++first2;\n-    }\n-    else {\n-      *result = *first1;\n-      ++first1;\n-    }\n-    ++result;\n-  }\n-  return copy(first2, last2, copy(first1, last1, result));\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator,\n-          class Compare>\n-OutputIterator merge(InputIterator1 first1, InputIterator1 last1,\n-                     InputIterator2 first2, InputIterator2 last2,\n-                     OutputIterator result, Compare comp) {\n-  while (first1 != last1 && first2 != last2) {\n-    if (comp(*first2, *first1)) {\n-      *result = *first2;\n-      ++first2;\n-    }\n-    else {\n-      *result = *first1;\n-      ++first1;\n-    }\n-    ++result;\n-  }\n-  return copy(first2, last2, copy(first1, last1, result));\n-}\n-\n-template <class BidirectionalIterator, class Distance>\n-void __merge_without_buffer(BidirectionalIterator first,\n-\t\t\t    BidirectionalIterator middle,\n-\t\t\t    BidirectionalIterator last,\n-\t\t\t    Distance len1, Distance len2) {\n-    if (len1 == 0 || len2 == 0) return;\n-    if (len1 + len2 == 2) {\n-\tif (*middle < *first) iter_swap(first, middle);\n-\treturn;\n-    }\n-    BidirectionalIterator first_cut = first;\n-    BidirectionalIterator second_cut = middle;\n-    Distance len11 = 0;\n-    Distance len22 = 0;\n-    if (len1 > len2) {\n-\tlen11 = len1 / 2;\n-\tadvance(first_cut, len11);\n-\tsecond_cut = lower_bound(middle, last, *first_cut);\n-\tdistance(middle, second_cut, len22);\n-    } else {\n-\tlen22 = len2 / 2;\n-\tadvance(second_cut, len22);\n-\tfirst_cut = upper_bound(first, middle, *second_cut);\n-\tdistance(first, first_cut, len11);\n-    }\n-    rotate(first_cut, middle, second_cut);\n-    BidirectionalIterator new_middle = first_cut;\n-    advance(new_middle, len22);\n-    __merge_without_buffer(first, first_cut, new_middle, len11, len22);\n-    __merge_without_buffer(new_middle, second_cut, last, len1 - len11,\n-\t\t\t   len2 - len22);\n-}\n-\n-template <class BidirectionalIterator, class Distance, class Compare>\n-void __merge_without_buffer(BidirectionalIterator first,\n-\t\t\t    BidirectionalIterator middle,\n-\t\t\t    BidirectionalIterator last,\n-\t\t\t    Distance len1, Distance len2, Compare comp) {\n-    if (len1 == 0 || len2 == 0) return;\n-    if (len1 + len2 == 2) {\n-\tif (comp(*middle, *first)) iter_swap(first, middle);\n-\treturn;\n-    }\n-    BidirectionalIterator first_cut = first;\n-    BidirectionalIterator second_cut = middle;\n-    Distance len11 = 0;\n-    Distance len22 = 0;\n-    if (len1 > len2) {\n-\tlen11 = len1 / 2;\n-\tadvance(first_cut, len11);\n-\tsecond_cut = lower_bound(middle, last, *first_cut, comp);\n-\tdistance(middle, second_cut, len22);\n-    } else {\n-\tlen22 = len2 / 2;\n-\tadvance(second_cut, len22);\n-\tfirst_cut = upper_bound(first, middle, *second_cut, comp);\n-\tdistance(first, first_cut, len11);\n-    }\n-    rotate(first_cut, middle, second_cut);\n-    BidirectionalIterator new_middle = first_cut;\n-    advance(new_middle, len22);\n-    __merge_without_buffer(first, first_cut, new_middle, len11, len22, comp);\n-    __merge_without_buffer(new_middle, second_cut, last, len1 - len11,\n-\t\t\t   len2 - len22, comp);\n-}\n-\n-template <class BidirectionalIterator1, class BidirectionalIterator2,\n-\t  class Distance>\n-BidirectionalIterator1 __rotate_adaptive(BidirectionalIterator1 first,\n-\t\t\t\t\t BidirectionalIterator1 middle,\n-\t\t\t\t\t BidirectionalIterator1 last,\n-\t\t\t\t\t Distance len1, Distance len2,\n-\t\t\t\t\t BidirectionalIterator2 buffer,\n-\t\t\t\t\t Distance buffer_size) {\n-    BidirectionalIterator2 buffer_end;\n-    if (len1 > len2 && len2 <= buffer_size) {\n-\tbuffer_end = copy(middle, last, buffer);\n-\tcopy_backward(first, middle, last);\n-\treturn copy(buffer, buffer_end, first);\n-    } else if (len1 <= buffer_size) {\n-\tbuffer_end = copy(first, middle, buffer);\n-\tcopy(middle, last, first);\n-\treturn copy_backward(buffer, buffer_end, last);\n-    } else  {\n-\trotate(first, middle, last);\n-\tadvance(first, len2);\n-\treturn first;\n-    }\n-}\n-\n-template <class BidirectionalIterator1, class BidirectionalIterator2,\n-\t  class BidirectionalIterator3>\n-BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,\n-\t\t\t\t\tBidirectionalIterator1 last1,\n-\t\t\t\t\tBidirectionalIterator2 first2,\n-\t\t\t\t\tBidirectionalIterator2 last2,\n-\t\t\t\t\tBidirectionalIterator3 result) {\n-    if (first1 == last1) return copy_backward(first2, last2, result);\n-    if (first2 == last2) return copy_backward(first1, last1, result);\n-    --last1;\n-    --last2;\n-    while (true) {\n-\tif (*last2 < *last1) {\n-\t    *--result = *last1;\n-\t    if (first1 == last1) return copy_backward(first2, ++last2, result);\n-\t    --last1;\n-\t} else {\n-\t    *--result = *last2;\n-\t    if (first2 == last2) return copy_backward(first1, ++last1, result);\n-\t    --last2;\n-\t}\n-    }\n-}\n-\n-template <class BidirectionalIterator1, class BidirectionalIterator2,\n-\t  class BidirectionalIterator3, class Compare>\n-BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,\n-\t\t\t\t\tBidirectionalIterator1 last1,\n-\t\t\t\t\tBidirectionalIterator2 first2,\n-\t\t\t\t\tBidirectionalIterator2 last2,\n-\t\t\t\t\tBidirectionalIterator3 result,\n-\t\t\t\t\tCompare comp) {\n-    if (first1 == last1) return copy_backward(first2, last2, result);\n-    if (first2 == last2) return copy_backward(first1, last1, result);\n-    --last1;\n-    --last2;\n-    while (true) {\n-\tif (comp(*last2, *last1)) {\n-\t    *--result = *last1;\n-\t    if (first1 == last1) return copy_backward(first2, ++last2, result);\n-\t    --last1;\n-\t} else {\n-\t    *--result = *last2;\n-\t    if (first2 == last2) return copy_backward(first1, ++last1, result);\n-\t    --last2;\n-\t}\n-    }\n-}\n-\n-template <class BidirectionalIterator, class Distance, class Pointer>\n-void __merge_adaptive(BidirectionalIterator first, \n-\t\t      BidirectionalIterator middle, \n-\t\t      BidirectionalIterator last, Distance len1, Distance len2,\n-\t\t      Pointer buffer, Distance buffer_size) {\n-    if (len1 <= len2 && len1 <= buffer_size) {\n-        Pointer end_buffer = copy(first, middle, buffer);\n-        merge(buffer, end_buffer, middle, last, first);\n-    } else if (len2 <= buffer_size) {\n-        Pointer end_buffer = copy(middle, last, buffer);\n-        __merge_backward(first, middle, buffer, end_buffer, last);\n-    } else {\n-\tBidirectionalIterator first_cut = first;\n-\tBidirectionalIterator second_cut = middle;\n-\tDistance len11 = 0;\n-\tDistance len22 = 0;\n-\tif (len1 > len2) {\n-\t    len11 = len1 / 2;\n-\t    advance(first_cut, len11);\n-\t    second_cut = lower_bound(middle, last, *first_cut);\n-\t    distance(middle, second_cut, len22);   \n-\t} else {\n-\t    len22 = len2 / 2;\n-\t    advance(second_cut, len22);\n-\t    first_cut = upper_bound(first, middle, *second_cut);\n-\t    distance(first, first_cut, len11);\n-\t}\n-\tBidirectionalIterator new_middle =\n-\t    __rotate_adaptive(first_cut, middle, second_cut, len1 - len11,\n-\t\t\t      len22, buffer, buffer_size);\n-\t__merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,\n-\t\t\t buffer_size);\n-\t__merge_adaptive(new_middle, second_cut, last, len1 - len11,\n-\t\t\t len2 - len22, buffer, buffer_size);\n-    }\n-}\n-\n-template <class BidirectionalIterator, class Distance, class Pointer,\n-\t  class Compare>\n-void __merge_adaptive(BidirectionalIterator first, \n-\t\t      BidirectionalIterator middle, \n-\t\t      BidirectionalIterator last, Distance len1, Distance len2,\n-\t\t      Pointer buffer, Distance buffer_size, Compare comp) {\n-    if (len1 <= len2 && len1 <= buffer_size) {\n-\tPointer end_buffer = copy(first, middle, buffer);\n-\tmerge(buffer, end_buffer, middle, last, first, comp);\n-    } else if (len2 <= buffer_size) {\n-\tPointer end_buffer = copy(middle, last, buffer);\n-\t__merge_backward(first, middle, buffer, end_buffer, last, comp);\n-    } else {\n-\tBidirectionalIterator first_cut = first;\n-\tBidirectionalIterator second_cut = middle;\n-\tDistance len11 = 0;\n-\tDistance len22 = 0;\n-\tif (len1 > len2) {\n-\t    len11 = len1 / 2;\n-\t    advance(first_cut, len11);\n-\t    second_cut = lower_bound(middle, last, *first_cut, comp);\n-\t    distance(middle, second_cut, len22);   \n-\t} else {\n-\t    len22 = len2 / 2;\n-\t    advance(second_cut, len22);\n-\t    first_cut = upper_bound(first, middle, *second_cut, comp);\n-\t    distance(first, first_cut, len11);\n-\t}\n-\tBidirectionalIterator new_middle =\n-\t    __rotate_adaptive(first_cut, middle, second_cut, len1 - len11,\n-\t\t\t      len22, buffer, buffer_size);\n-\t__merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,\n-\t\t\t buffer_size, comp);\n-\t__merge_adaptive(new_middle, second_cut, last, len1 - len11,\n-\t\t\t len2 - len22, buffer, buffer_size, comp);\n-    }\n-}\n-\n-template <class BidirectionalIterator, class T, class Distance>\n-inline void __inplace_merge_aux(BidirectionalIterator first,\n-\t\t\t\tBidirectionalIterator middle,\n-\t\t\t\tBidirectionalIterator last, T*, Distance*) {\n-    Distance len1 = 0;\n-    distance(first, middle, len1);\n-    Distance len2 = 0;\n-    distance(middle, last, len2);\n-\n-    temporary_buffer<BidirectionalIterator, T> buf(first, last);\n-    if (buf.begin() == 0)\n-      __merge_without_buffer(first, middle, last, len1, len2);\n-    else\n-      __merge_adaptive(first, middle, last, len1, len2,\n-                       buf.begin(), Distance(buf.size()));\n-}\n-\n-template <class BidirectionalIterator, class T, class Distance, class Compare>\n-inline void __inplace_merge_aux(BidirectionalIterator first,\n-\t\t\t\tBidirectionalIterator middle,\n-\t\t\t\tBidirectionalIterator last, T*, Distance*,\n-\t\t\t\tCompare comp) {\n-    Distance len1 = 0;\n-    distance(first, middle, len1);\n-    Distance len2 = 0;\n-    distance(middle, last, len2);\n-\n-    temporary_buffer<BidirectionalIterator, T> buf(first, last);\n-    if (buf.begin() == 0)\n-      __merge_without_buffer(first, middle, last, len1, len2, comp);\n-    else\n-      __merge_adaptive(first, middle, last, len1, len2,\n-                       buf.begin(), Distance(buf.size()),\n-                       comp);\n-}\n-\n-template <class BidirectionalIterator>\n-inline void inplace_merge(BidirectionalIterator first,\n-\t\t\t  BidirectionalIterator middle,\n-\t\t\t  BidirectionalIterator last) {\n-    if (first == middle || middle == last) return;\n-    __inplace_merge_aux(first, middle, last, value_type(first),\n-\t\t\tdistance_type(first));\n-}\n-\n-template <class BidirectionalIterator, class Compare>\n-inline void inplace_merge(BidirectionalIterator first,\n-\t\t\t  BidirectionalIterator middle,\n-\t\t\t  BidirectionalIterator last, Compare comp) {\n-    if (first == middle || middle == last) return;\n-    __inplace_merge_aux(first, middle, last, value_type(first),\n-\t\t\tdistance_type(first), comp);\n-}\n-\n-template <class InputIterator1, class InputIterator2>\n-bool includes(InputIterator1 first1, InputIterator1 last1,\n-\t      InputIterator2 first2, InputIterator2 last2) {\n-    while (first1 != last1 && first2 != last2)\n-\tif (*first2 < *first1)\n-\t    return false;\n-\telse if(*first1 < *first2) \n-\t    ++first1;\n-\telse\n-\t    ++first1, ++first2;\n-\n-    return first2 == last2;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class Compare>\n-bool includes(InputIterator1 first1, InputIterator1 last1,\n-\t      InputIterator2 first2, InputIterator2 last2, Compare comp) {\n-    while (first1 != last1 && first2 != last2)\n-\tif (comp(*first2, *first1))\n-\t    return false;\n-\telse if(comp(*first1, *first2)) \n-\t    ++first1;\n-\telse\n-\t    ++first1, ++first2;\n-\n-    return first2 == last2;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator>\n-OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,\n-                         InputIterator2 first2, InputIterator2 last2,\n-                         OutputIterator result) {\n-  while (first1 != last1 && first2 != last2) {\n-    if (*first1 < *first2) {\n-      *result = *first1;\n-      ++first1;\n-    }\n-    else if (*first2 < *first1) {\n-      *result = *first2;\n-      ++first2;\n-    }\n-    else {\n-      *result = *first1;\n-      ++first1;\n-      ++first2;\n-    }\n-    ++result;\n-  }\n-  return copy(first2, last2, copy(first1, last1, result));\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator,\n-          class Compare>\n-OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,\n-                         InputIterator2 first2, InputIterator2 last2,\n-                         OutputIterator result, Compare comp) {\n-  while (first1 != last1 && first2 != last2) {\n-    if (comp(*first1, *first2)) {\n-      *result = *first1;\n-      ++first1;\n-    }\n-    else if (comp(*first2, *first1)) {\n-      *result = *first2;\n-      ++first2;\n-    }\n-    else {\n-      *result = *first1;\n-      ++first1;\n-      ++first2;\n-    }\n-    ++result;\n-  }\n-  return copy(first2, last2, copy(first1, last1, result));\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator>\n-OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,\n-                                InputIterator2 first2, InputIterator2 last2,\n-                                OutputIterator result) {\n-  while (first1 != last1 && first2 != last2) \n-    if (*first1 < *first2) \n-      ++first1;\n-    else if (*first2 < *first1) \n-      ++first2;\n-    else {\n-      *result = *first1;\n-      ++first1;\n-      ++first2;\n-      ++result;\n-    }\n-  return result;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator,\n-          class Compare>\n-OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,\n-                                InputIterator2 first2, InputIterator2 last2,\n-                                OutputIterator result, Compare comp) {\n-  while (first1 != last1 && first2 != last2)\n-    if (comp(*first1, *first2))\n-      ++first1;\n-    else if (comp(*first2, *first1))\n-      ++first2;\n-    else {\n-      *result = *first1;\n-      ++first1;\n-      ++first2;\n-      ++result;\n-    }\n-  return result;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator>\n-OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,\n-                              InputIterator2 first2, InputIterator2 last2,\n-                              OutputIterator result) {\n-  while (first1 != last1 && first2 != last2)\n-    if (*first1 < *first2) {\n-      *result = *first1;\n-      ++first1;\n-      ++result;\n-    }\n-    else if (*first2 < *first1)\n-      ++first2;\n-    else {\n-      ++first1;\n-      ++first2;\n-    }\n-  return copy(first1, last1, result);\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator, \n-          class Compare>\n-OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,\n-                              InputIterator2 first2, InputIterator2 last2, \n-                              OutputIterator result, Compare comp) {\n-  while (first1 != last1 && first2 != last2)\n-    if (comp(*first1, *first2)) {\n-      *result = *first1;\n-      ++first1;\n-      ++result;\n-    }\n-    else if (comp(*first2, *first1))\n-      ++first2;\n-    else {\n-      ++first1;\n-      ++first2;\n-    }\n-  return copy(first1, last1, result);\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator>\n-OutputIterator set_symmetric_difference(InputIterator1 first1,\n-                                        InputIterator1 last1,\n-                                        InputIterator2 first2,\n-                                        InputIterator2 last2,\n-                                        OutputIterator result) {\n-  while (first1 != last1 && first2 != last2)\n-    if (*first1 < *first2) {\n-      *result = *first1;\n-      ++first1;\n-      ++result;\n-    }\n-    else if (*first2 < *first1) {\n-      *result = *first2;\n-      ++first2;\n-      ++result;\n-    }\n-    else {\n-      ++first1;\n-      ++first2;\n-    }\n-  return copy(first2, last2, copy(first1, last1, result));\n-}\n-\n-template <class InputIterator1, class InputIterator2, class OutputIterator,\n-          class Compare>\n-OutputIterator set_symmetric_difference(InputIterator1 first1,\n-                                        InputIterator1 last1,\n-                                        InputIterator2 first2,\n-                                        InputIterator2 last2,\n-                                        OutputIterator result, Compare comp) {\n-  while (first1 != last1 && first2 != last2)\n-    if (comp(*first1, *first2)) {\n-      *result = *first1;\n-      ++first1;\n-      ++result;\n-    }\n-    else if (comp(*first2, *first1)) {\n-      *result = *first2;\n-      ++first2;\n-      ++result;\n-    }\n-    else {\n-      ++first1;\n-      ++first2;\n-    }\n-  return copy(first2, last2, copy(first1, last1, result));\n-}\n-\n-template <class ForwardIterator>\n-ForwardIterator max_element(ForwardIterator first, ForwardIterator last) {\n-    if (first == last) return first;\n-    ForwardIterator result = first;\n-    while (++first != last) \n-\tif (*result < *first) result = first;\n-    return result;\n-}\n-\n-template <class ForwardIterator, class Compare>\n-ForwardIterator max_element(ForwardIterator first, ForwardIterator last,\n-\t\t\t    Compare comp) {\n-    if (first == last) return first;\n-    ForwardIterator result = first;\n-    while (++first != last) \n-\tif (comp(*result, *first)) result = first;\n-    return result;\n-}\n-\n-template <class ForwardIterator>\n-ForwardIterator min_element(ForwardIterator first, ForwardIterator last) {\n-    if (first == last) return first;\n-    ForwardIterator result = first;\n-    while (++first != last) \n-\tif (*first < *result) result = first;\n-    return result;\n-}\n-\n-template <class ForwardIterator, class Compare>\n-ForwardIterator min_element(ForwardIterator first, ForwardIterator last,\n-\t\t\t    Compare comp) {\n-    if (first == last) return first;\n-    ForwardIterator result = first;\n-    while (++first != last) \n-\tif (comp(*first, *result)) result = first;\n-    return result;\n-}\n-\n-template <class BidirectionalIterator>\n-bool next_permutation(BidirectionalIterator first,\n-\t\t      BidirectionalIterator last) {\n-    if (first == last) return false;\n-    BidirectionalIterator i = first;\n-    ++i;\n-    if (i == last) return false;\n-    i = last;\n-    --i;\n-\n-    for(;;) {\n-\tBidirectionalIterator ii = i;\n-        --i;\n-\tif (*i < *ii) {\n-\t    BidirectionalIterator j = last;\n-\t    while (!(*i < *--j));\n-\t    iter_swap(i, j);\n-\t    reverse(ii, last);\n-\t    return true;\n-\t}\n-\tif (i == first) {\n-\t    reverse(first, last);\n-\t    return false;\n-\t}\n-    }\n-}\n-\n-template <class BidirectionalIterator, class Compare>\n-bool next_permutation(BidirectionalIterator first, BidirectionalIterator last,\n-\t\t      Compare comp) {\n-    if (first == last) return false;\n-    BidirectionalIterator i = first;\n-    ++i;\n-    if (i == last) return false;\n-    i = last;\n-    --i;\n-\n-    for(;;) {\n-\tBidirectionalIterator ii = i;\n-        --i;\n-\tif (comp(*i, *ii)) {\n-\t    BidirectionalIterator j = last;\n-\t    while (!comp(*i, *--j));\n-\t    iter_swap(i, j);\n-\t    reverse(ii, last);\n-\t    return true;\n-\t}\n-\tif (i == first) {\n-\t    reverse(first, last);\n-\t    return false;\n-\t}\n-    }\n-}\n-\n-template <class BidirectionalIterator>\n-bool prev_permutation(BidirectionalIterator first,\n-\t\t      BidirectionalIterator last) {\n-    if (first == last) return false;\n-    BidirectionalIterator i = first;\n-    ++i;\n-    if (i == last) return false;\n-    i = last;\n-    --i;\n-\n-    for(;;) {\n-\tBidirectionalIterator ii = i;\n-        --i;\n-\tif (*ii < *i) {\n-\t    BidirectionalIterator j = last;\n-\t    while (!(*--j < *i));\n-\t    iter_swap(i, j);\n-\t    reverse(ii, last);\n-\t    return true;\n-\t}\n-\tif (i == first) {\n-\t    reverse(first, last);\n-\t    return false;\n-\t}\n-    }\n-}\n-\n-template <class BidirectionalIterator, class Compare>\n-bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last,\n-\t\t      Compare comp) {\n-    if (first == last) return false;\n-    BidirectionalIterator i = first;\n-    ++i;\n-    if (i == last) return false;\n-    i = last;\n-    --i;\n-\n-    for(;;) {\n-\tBidirectionalIterator ii = i;\n-        --i;\n-\tif (comp(*ii, *i)) {\n-\t    BidirectionalIterator j = last;\n-\t    while (!comp(*--j, *i));\n-\t    iter_swap(i, j);\n-\t    reverse(ii, last);\n-\t    return true;\n-\t}\n-\tif (i == first) {\n-\t    reverse(first, last);\n-\t    return false;\n-\t}\n-    }\n-}\n-\n-template <class InputIterator, class T>\n-T accumulate(InputIterator first, InputIterator last, T init) {\n-  for ( ; first != last; ++first)\n-    init = init + *first;\n-  return init;\n-}\n-\n-template <class InputIterator, class T, class BinaryOperation>\n-T accumulate(InputIterator first, InputIterator last, T init,\n-             BinaryOperation binary_op) {\n-  for ( ; first != last; ++first)\n-    init = binary_op(init, *first);\n-  return init;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class T>\n-T inner_product(InputIterator1 first1, InputIterator1 last1,\n-                InputIterator2 first2, T init) {\n-  for ( ; first1 != last1; ++first1, ++first2)\n-    init = init + (*first1 * *first2);\n-  return init;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class T,\n-          class BinaryOperation1, class BinaryOperation2>\n-T inner_product(InputIterator1 first1, InputIterator1 last1,\n-                InputIterator2 first2, T init, BinaryOperation1 binary_op1,\n-                BinaryOperation2 binary_op2) {\n-  for ( ; first1 != last1; ++first1, ++first2)\n-    init = binary_op1(init, binary_op2(*first1, *first2));\n-  return init;\n-}\n-\n-template <class InputIterator, class OutputIterator, class T>\n-OutputIterator __partial_sum(InputIterator first, InputIterator last,\n-\t\t\t     OutputIterator result, T*) {\n-    T value = *first;\n-    while (++first != last) {\n-\tvalue = value + *first;\n-\t*++result = value;\n-    }\n-    return ++result;\n-}\n-\n-template <class InputIterator, class OutputIterator>\n-OutputIterator partial_sum(InputIterator first, InputIterator last,\n-\t\t\t   OutputIterator result) {\n-    if (first == last) return result;\n-    *result = *first;\n-    return __partial_sum(first, last, result, value_type(first));\n-}\n-\n-template <class InputIterator, class OutputIterator, class T,\n-\t  class BinaryOperation>\n-OutputIterator __partial_sum(InputIterator first, InputIterator last,\n-\t\t\t     OutputIterator result, T*,\n-\t\t\t     BinaryOperation binary_op) {\n-    T value = *first;\n-    while (++first != last) {\n-\tvalue = binary_op(value, *first);\n-\t*++result = value;\n-    }\n-    return ++result;\n-}\n-\n-template <class InputIterator, class OutputIterator, class BinaryOperation>\n-OutputIterator partial_sum(InputIterator first, InputIterator last,\n-\t\t\t   OutputIterator result, BinaryOperation binary_op) {\n-    if (first == last) return result;\n-    *result = *first;\n-    return __partial_sum(first, last, result, value_type(first), binary_op);\n-}\n-\n-template <class InputIterator, class OutputIterator, class T>\n-OutputIterator __adjacent_difference(InputIterator first, InputIterator last, \n-\t\t\t\t     OutputIterator result, T*) {\n-    T value = *first;\n-    while (++first != last) {\n-\tT tmp = *first;\n-\t*++result = tmp - value;\n-\tvalue = tmp;\n-    }\n-    return ++result;\n-}\n-\n-template <class InputIterator, class OutputIterator>\n-OutputIterator adjacent_difference(InputIterator first, InputIterator last, \n-\t\t\t\t   OutputIterator result) {\n-    if (first == last) return result;\n-    *result = *first;\n-    return __adjacent_difference(first, last, result, value_type(first));\n-}\n-\n-template <class InputIterator, class OutputIterator, class T, \n-\t  class BinaryOperation>\n-OutputIterator __adjacent_difference(InputIterator first, InputIterator last, \n-\t\t\t\t     OutputIterator result, T*,\n-\t\t\t\t     BinaryOperation binary_op) {\n-    T value = *first;\n-    while (++first != last) {\n-\tT tmp = *first;\n-\t*++result = binary_op(tmp, value);\n-\tvalue = tmp;\n-    }\n-    return ++result;\n-}\n-\n-template <class InputIterator, class OutputIterator, class BinaryOperation>\n-OutputIterator adjacent_difference(InputIterator first, InputIterator last,\n-\t\t\t\t   OutputIterator result,\n-\t\t\t\t   BinaryOperation binary_op) {\n-    if (first == last) return result;\n-    *result = *first;\n-    return __adjacent_difference(first, last, result, value_type(first),\n-\t\t\t\t binary_op);\n-}\n-\n-template <class InputIterator, class ForwardIterator>\n-InputIterator find_first_of(InputIterator first1, InputIterator last1,\n-                            ForwardIterator first2, ForwardIterator last2)\n-{\n-  for ( ; first1 != last1; ++first1) \n-    for (ForwardIterator iter = first2; iter != last2; ++iter)\n-      if (*first1 == *iter)\n-        return first1;\n-  return last1;\n-}\n-\n-template <class InputIterator, class ForwardIterator, class BinaryPredicate>\n-InputIterator find_first_of(InputIterator first1, InputIterator last1,\n-                            ForwardIterator first2, ForwardIterator last2,\n-                            BinaryPredicate comp)\n-{\n-  for ( ; first1 != last1; ++first1) \n-    for (ForwardIterator iter = first2; iter != last2; ++iter)\n-      if (comp(*first1, *iter))\n-        return first1;\n-  return last1;\n-}\n-\n-\n-// Search [first2, last2) as a subsequence in [first1, last1).\n-\n-// find_end for forward iterators. \n-template <class ForwardIterator1, class ForwardIterator2>\n-ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n-                            ForwardIterator2 first2, ForwardIterator2 last2,\n-                            forward_iterator_tag, forward_iterator_tag)\n-{\n-  if (first2 == last2)\n-    return last1;\n-  else {\n-    ForwardIterator1 result = last1;\n-    while (1) {\n-      ForwardIterator1 new_result = search(first1, last1, first2, last2);\n-      if (new_result == last1)\n-        return result;\n-      else {\n-        result = new_result;\n-        first1 = new_result;\n-        ++first1;\n-      }\n-    }\n-  }\n-}\n-\n-template <class ForwardIterator1, class ForwardIterator2,\n-          class BinaryPredicate>\n-ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n-                            ForwardIterator2 first2, ForwardIterator2 last2,\n-                            forward_iterator_tag, forward_iterator_tag,\n-                            BinaryPredicate comp)\n-{\n-  if (first2 == last2)\n-    return last1;\n-  else {\n-    ForwardIterator1 result = last1;\n-    while (1) {\n-      ForwardIterator1 new_result = search(first1, last1, first2, last2, comp);\n-      if (new_result == last1)\n-        return result;\n-      else {\n-        result = new_result;\n-        first1 = new_result;\n-        ++first1;\n-      }\n-    }\n-  }\n-}\n-\n-// find_end for bidirectional iterators.  Requires partial specialization.\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class BidirectionalIterator1, class BidirectionalIterator2>\n-BidirectionalIterator1\n-__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,\n-           BidirectionalIterator2 first2, BidirectionalIterator2 last2,\n-           bidirectional_iterator_tag, bidirectional_iterator_tag)\n-{\n-  typedef reverse_iterator<BidirectionalIterator1> reviter1;\n-  typedef reverse_iterator<BidirectionalIterator2> reviter2;\n-\n-  reviter1 rlast1(first1);\n-  reviter2 rlast2(first2);\n-  reviter1 rresult = search(reviter1(last1), rlast1, reviter2(last2), rlast2);\n-\n-  if (rresult == rlast1)\n-    return last1;\n-  else {\n-    BidirectionalIterator1 result = rresult.base();\n-    advance(result, -distance(first2, last2));\n-    return result;\n-  }\n-}\n-\n-template <class BidirectionalIterator1, class BidirectionalIterator2,\n-          class BinaryPredicate>\n-BidirectionalIterator1\n-__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,\n-           BidirectionalIterator2 first2, BidirectionalIterator2 last2,\n-           bidirectional_iterator_tag, bidirectional_iterator_tag, \n-           BinaryPredicate comp)\n-{\n-  typedef reverse_iterator<BidirectionalIterator1> reviter1;\n-  typedef reverse_iterator<BidirectionalIterator2> reviter2;\n-\n-  reviter1 rlast1(first1);\n-  reviter2 rlast2(first2);\n-  reviter1 rresult = search(reviter1(last1), rlast1, reviter2(last2), rlast2,\n-                            comp);\n-\n-  if (rresult == rlast1)\n-    return last1;\n-  else {\n-    BidirectionalIterator1 result = rresult.base();\n-    advance(result, -distance(first2, last2));\n-    return result;\n-  }\n-}\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-// Dispatching functions.\n-\n-template <class ForwardIterator, class BidirectionalIterator>\n-inline ForwardIterator \n-__find_end(ForwardIterator first1, ForwardIterator last1, \n-           BidirectionalIterator first2, BidirectionalIterator last2,\n-           forward_iterator_tag, bidirectional_iterator_tag)\n-{\n-  return __find_end(first1, last1, first2, last2,\n-                    forward_iterator_tag(), forward_iterator_tag());\n-}\n- \n-template <class BidirectionalIterator, class ForwardIterator>\n-inline BidirectionalIterator\n-__find_end(BidirectionalIterator first1, BidirectionalIterator last1, \n-           ForwardIterator first2, ForwardIterator last2,\n-           bidirectional_iterator_tag, forward_iterator_tag)\n-{\n-  return __find_end(first1, last1, first2, last2,\n-                    forward_iterator_tag(), forward_iterator_tag());\n-}\n-\n-template <class ForwardIterator, class BidirectionalIterator,\n-          class BinaryPredicate>\n-inline ForwardIterator \n-__find_end(ForwardIterator first1, ForwardIterator last1, \n-           BidirectionalIterator first2, BidirectionalIterator last2,\n-           forward_iterator_tag, bidirectional_iterator_tag,\n-           BinaryPredicate comp)\n-{\n-  return __find_end(first1, last1, first2, last2,\n-                    forward_iterator_tag(), forward_iterator_tag(),\n-                    comp);\n-\n-}\n- \n-template <class BidirectionalIterator, class ForwardIterator,\n-          class BinaryPredicate>\n-inline BidirectionalIterator\n-__find_end(BidirectionalIterator first1, BidirectionalIterator last1, \n-           ForwardIterator first2, ForwardIterator last2,\n-           bidirectional_iterator_tag, forward_iterator_tag, \n-           BinaryPredicate comp)\n-{\n-  return __find_end(first1, last1, first2, last2,\n-                    forward_iterator_tag(), forward_iterator_tag(),\n-                    comp);\n-}\n-\n-template <class ForwardIterator1, class ForwardIterator2>\n-inline ForwardIterator1 \n-find_end(ForwardIterator1 first1, ForwardIterator1 last1, \n-         ForwardIterator2 first2, ForwardIterator2 last2)\n-{\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-  return __find_end(first1, last1, first2, last2,\n-                    iterator_traits<ForwardIterator1>::iterator_category(),\n-                    iterator_traits<ForwardIterator2>::iterator_category());\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-  return __find_end(first1, last1, first2, last2,\n-                    forward_iterator_tag(), forward_iterator_tag());\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-}\n-\n-template <class ForwardIterator1, class ForwardIterator2, \n-          class BinaryPredicate>\n-inline ForwardIterator1 \n-find_end(ForwardIterator1 first1, ForwardIterator1 last1, \n-         ForwardIterator2 first2, ForwardIterator2 last2,\n-         BinaryPredicate comp)\n-{\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-  return __find_end(first1, last1, first2, last2,\n-                    iterator_traits<ForwardIterator1>::iterator_category(),\n-                    iterator_traits<ForwardIterator2>::iterator_category(),\n-                    comp);\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-  return __find_end(first1, last1, first2, last2,\n-                    forward_iterator_tag(), forward_iterator_tag(),\n-                    comp);\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-}\n-\n-// Returns x ** n, where n >= 0.  Note that \"multiplication\"\n-//  is required to be associative, but not necessarily commutative.\n-    \n-template <class T, class Integer, class MonoidOperation>\n-T power(T x, Integer n, MonoidOperation op) {\n-  if (n == 0)\n-    return identity_element(op);\n-  else {\n-    while ((n & 1) == 0) {\n-      n >>= 1;\n-      x = op(x, x);\n-    }\n-\n-    T result = x;\n-    n >>= 1;\n-    while (n != 0) {\n-      x = op(x, x);\n-      if ((n & 1) != 0)\n-        result = op(result, x);\n-      n >>= 1;\n-    }\n-    return result;\n-  }\n-}\n-\n-template <class T, class Integer>\n-inline T power(T x, Integer n) {\n-  return power(x, n, multiplies<T>());\n-}\n-\n-\n-template <class ForwardIterator, class T>\n-void iota(ForwardIterator first, ForwardIterator last, T value) {\n-    while (first != last) *first++ = value++;\n-}\n-\n-template <class RandomAccessIterator, class Distance>\n-bool __is_heap(RandomAccessIterator first, RandomAccessIterator last,\n-               Distance*)\n-{\n-  const Distance n = last - first;\n-\n-  Distance parent = 0;\n-  for (Distance child = 1; child < n; ++child) {\n-    if (first[parent] < first[child]) \n-      return false;\n-    if (child % 2 == 0)\n-      ++parent;\n-  }\n-  return true;\n-}\n-\n-template <class RandomAccessIterator>\n-inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last)\n-{\n-  return __is_heap(first, last, distance_type(first));\n-}\n-\n-\n-template <class RandomAccessIterator, class Distance, class StrictWeakOrdering>\n-bool __is_heap(RandomAccessIterator first, RandomAccessIterator last,\n-               StrictWeakOrdering comp,\n-               Distance*)\n-{\n-  const Distance n = last - first;\n-\n-  Distance parent = 0;\n-  for (Distance child = 1; child < n; ++child) {\n-    if (comp(first[parent], first[child]))\n-      return false;\n-    if (child % 2 == 0)\n-      ++parent;\n-  }\n-  return true;\n-}\n-\n-template <class RandomAccessIterator, class StrictWeakOrdering>\n-inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last,\n-                    StrictWeakOrdering comp)\n-{\n-  return __is_heap(first, last, comp, distance_type(first));\n-}\n-\n-\n-template <class ForwardIterator>\n-bool is_sorted(ForwardIterator first, ForwardIterator last)\n-{\n-  if (first == last)\n-    return true;\n-\n-  ForwardIterator next = first;\n-  for (++next; next != last; first = next, ++next) {\n-    if (*next < *first)\n-      return false;\n-  }\n-\n-  return true;\n-}\n-\n-template <class ForwardIterator, class StrictWeakOrdering>\n-bool is_sorted(ForwardIterator first, ForwardIterator last,\n-               StrictWeakOrdering comp)\n-{\n-  if (first == last)\n-    return true;\n-\n-  ForwardIterator next = first;\n-  for (++next; next != last; first = next, ++next) {\n-    if (comp(*next, *first))\n-      return false;\n-  }\n-\n-  return true;\n-}\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1209\n-#endif\n+#include <stl_algo.h>\n+#include <stl_numeric.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from <stl_algo.h>\n+using __STD::for_each; \n+using __STD::find; \n+using __STD::find_if; \n+using __STD::adjacent_find; \n+using __STD::count; \n+using __STD::count_if; \n+using __STD::search; \n+using __STD::search_n; \n+using __STD::swap_ranges; \n+using __STD::transform; \n+using __STD::replace; \n+using __STD::replace_if; \n+using __STD::replace_copy; \n+using __STD::replace_copy_if; \n+using __STD::generate; \n+using __STD::generate_n; \n+using __STD::remove; \n+using __STD::remove_if; \n+using __STD::remove_copy; \n+using __STD::remove_copy_if; \n+using __STD::unique; \n+using __STD::unique_copy; \n+using __STD::reverse; \n+using __STD::reverse_copy; \n+using __STD::rotate; \n+using __STD::rotate_copy; \n+using __STD::random_shuffle; \n+using __STD::random_sample; \n+using __STD::random_sample_n; \n+using __STD::partition; \n+using __STD::stable_partition; \n+using __STD::sort; \n+using __STD::stable_sort; \n+using __STD::partial_sort; \n+using __STD::partial_sort_copy; \n+using __STD::nth_element; \n+using __STD::lower_bound; \n+using __STD::upper_bound; \n+using __STD::equal_range; \n+using __STD::binary_search; \n+using __STD::merge; \n+using __STD::inplace_merge; \n+using __STD::includes; \n+using __STD::set_union; \n+using __STD::set_intersection; \n+using __STD::set_difference; \n+using __STD::set_symmetric_difference; \n+using __STD::min_element; \n+using __STD::max_element; \n+using __STD::next_permutation; \n+using __STD::prev_permutation; \n+using __STD::find_first_of; \n+using __STD::find_end; \n+using __STD::is_sorted; \n+using __STD::is_heap; \n+\n+// Names from stl_heap.h\n+using __STD::push_heap;\n+using __STD::pop_heap;\n+using __STD::make_heap;\n+using __STD::sort_heap;\n+\n+// Names from <stl_numeric.h>\n+using __STD::accumulate; \n+using __STD::inner_product; \n+using __STD::partial_sum; \n+using __STD::adjacent_difference; \n+using __STD::power; \n+using __STD::iota; \n+\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_ALGO_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "f35e7af4a97648b4c6d349ceb298f1bc06b7a343", "filename": "libstdc++/stl/algobase.h", "status": "modified", "additions": 40, "deletions": 735, "changes": 775, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Falgobase.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -11,8 +11,7 @@\n  * representations about the suitability of this software for any\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n- *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -24,743 +23,49 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n \n-#ifndef _SGI_STL_ALGOBASE_H\n-#define _SGI_STL_ALGOBASE_H\n+#ifndef __SGI_STL_ALGOBASE_H\n+#define __SGI_STL_ALGOBASE_H\n \n-#include <string.h>\n-#include <limits.h>\n-#include <function.h>\n+#ifndef __SGI_STL_PAIR_H\n #include <pair.h>\n+#endif\n+#ifndef __SGI_STL_ITERATOR_H\n #include <iterator.h>\n-#include <new.h>\n-#include <type_traits.h>\n-\n-template <class ForwardIterator1, class ForwardIterator2, class T>\n-inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) {\n-    T tmp = *a;\n-    *a = *b;\n-    *b = tmp;\n-}\n-\n-template <class ForwardIterator1, class ForwardIterator2>\n-inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {\n-    __iter_swap(a, b, value_type(a));\n-}\n-\n-template <class T>\n-inline void swap(T& a, T& b) {\n-    T tmp = a;\n-    a = b;\n-    b = tmp;\n-}\n-\n-#ifdef __BORLANDC__\n-#include <stdlib.h>\n-#else\n-\n-template <class T>\n-inline const T& min(const T& a, const T& b) {\n-    return b < a ? b : a;\n-}\n-\n-template <class T>\n-inline const T& max(const T& a, const T& b) {\n-    return  a < b ? b : a;\n-}\n-\n #endif\n-\n-template <class T, class Compare>\n-inline const T& min(const T& a, const T& b, Compare comp) {\n-    return comp(b, a) ? b : a;\n-}\n-\n-template <class T, class Compare>\n-inline const T& max(const T& a, const T& b, Compare comp) {\n-    return comp(a, b) ? b : a;\n-}\n-\n-template <class InputIterator, class Distance>\n-inline void __distance(InputIterator first, InputIterator last, Distance& n, \n-                       input_iterator_tag) {\n-    while (first != last) { ++first; ++n; }\n-}\n-\n-template <class RandomAccessIterator, class Distance>\n-inline void __distance(RandomAccessIterator first, RandomAccessIterator last, \n-\t\t       Distance& n, random_access_iterator_tag) {\n-    n += last - first;\n-}\n-\n-template <class InputIterator, class Distance>\n-inline void distance(InputIterator first, InputIterator last, Distance& n) {\n-    __distance(first, last, n, iterator_category(first));\n-}\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class InputIterator>\n-inline iterator_traits<InputIterator>::difference_type\n-__distance(InputIterator first, InputIterator last, input_iterator_tag) {\n-  iterator_traits<InputIterator>::difference_type n = 0;\n-  while (first != last) {\n-    ++first; ++n;\n-  }\n-  return n;\n-}\n-\n-template <class RandomAccessIterator>\n-inline iterator_traits<RandomAccessIterator>::difference_type\n-__distance(RandomAccessIterator first, RandomAccessIterator last,\n-           random_access_iterator_tag) {\n-  return last - first;\n-}\n-\n-template <class InputIterator>\n-inline iterator_traits<InputIterator>::difference_type\n-distance(InputIterator first, InputIterator last) {\n-  return __distance(first, last,\n-                    iterator_traits<InputIterator>::iterator_category());\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class InputIterator, class Distance>\n-inline void __advance(InputIterator& i, Distance n, input_iterator_tag) {\n-    while (n--) ++i;\n-}\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1183\n+#ifndef __SGI_STL_INTERNAL_ALGOBASE_H\n+#include <stl_algobase.h>\n #endif\n-\n-template <class BidirectionalIterator, class Distance>\n-inline void __advance(BidirectionalIterator& i, Distance n, \n-                      bidirectional_iterator_tag) {\n-    if (n >= 0)\n-\twhile (n--) ++i;\n-    else\n-\twhile (n++) --i;\n-}\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1183\n+#ifndef __SGI_STL_INTERNAL_UNINITIALIZED_H\n+#include <stl_uninitialized.h>\n #endif\n \n-template <class RandomAccessIterator, class Distance>\n-inline void __advance(RandomAccessIterator& i, Distance n, \n-\t\t      random_access_iterator_tag) {\n-    i += n;\n-}\n-\n-template <class InputIterator, class Distance>\n-inline void advance(InputIterator& i, Distance n) {\n-    __advance(i, n, iterator_category(i));\n-}\n-\n-template <class InputIterator, class OutputIterator>\n-inline OutputIterator __copy(InputIterator first, InputIterator last,\n-                             OutputIterator result, input_iterator_tag)\n-{\n-  for ( ; first != last; ++result, ++first)\n-    *result = *first;\n-  return result;\n-}\n-\n-template <class RandomAccessIterator, class OutputIterator, class Distance>\n-inline OutputIterator\n-__copy_d(RandomAccessIterator first, RandomAccessIterator last,\n-         OutputIterator result, Distance*)\n-{\n-  for (Distance n = last - first; n > 0; --n, ++result, ++first) \n-    *result = *first;\n-  return result;\n-}\n-\n-template <class RandomAccessIterator, class OutputIterator>\n-inline OutputIterator \n-__copy(RandomAccessIterator first, RandomAccessIterator last,\n-       OutputIterator result, random_access_iterator_tag)\n-{\n-  return __copy_d(first, last, result, distance_type(first));\n-}\n-\n-template <class InputIterator, class OutputIterator>\n-struct __copy_dispatch\n-{\n-  OutputIterator operator()(InputIterator first, InputIterator last,\n-                            OutputIterator result) {\n-    return __copy(first, last, result, iterator_category(first));\n-  }\n-};\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION \n-\n-template <class T>\n-inline T* __copy_t(const T* first, const T* last, T* result, __true_type) {\n-  memmove(result, first, sizeof(T) * (last - first));\n-  return result + (last - first);\n-}\n-\n-template <class T>\n-inline T* __copy_t(const T* first, const T* last, T* result, __false_type) {\n-  return __copy_d(first, last, result, (ptrdiff_t*) 0);\n-}\n-\n-template <class T>\n-struct __copy_dispatch<T*, T*>\n-{\n-  T* operator()(T* first, T* last, T* result) {\n-    return __copy_t(first, last, result,\n-                    __type_traits<T>::has_trivial_assignment_operator());\n-  }\n-};\n-\n-template <class T>\n-struct __copy_dispatch<const T*, T*>\n-{\n-  T* operator()(const T* first, const T* last, T* result) {\n-    return __copy_t(first, last, result, \n-                    __type_traits<T>::has_trivial_assignment_operator());\n-  }\n-};\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class InputIterator, class OutputIterator>\n-inline OutputIterator copy(InputIterator first, InputIterator last,\n-                           OutputIterator result)\n-{\n-  return __copy_dispatch<InputIterator,OutputIterator>()(first, last, result);\n-}\n-\n-inline char* copy(const char* first, const char* last, char* result) {\n-  memmove(result, first, last - first);\n-  return result + (last - first);\n-}\n-\n-inline wchar_t* copy(const wchar_t* first, const wchar_t* last,\n-                     wchar_t* result) {\n-  memmove(result, first, sizeof(wchar_t) * (last - first));\n-  return result + (last - first);\n-}\n-\n-template <class BidirectionalIterator1, class BidirectionalIterator2>\n-inline BidirectionalIterator2 __copy_backward(BidirectionalIterator1 first, \n-                                              BidirectionalIterator1 last, \n-                                              BidirectionalIterator2 result) {\n-  while (first != last) *--result = *--last;\n-  return result;\n-}\n-\n-\n-template <class BidirectionalIterator1, class BidirectionalIterator2>\n-struct __copy_backward_dispatch\n-{\n-  BidirectionalIterator2 operator()(BidirectionalIterator1 first, \n-                                    BidirectionalIterator1 last, \n-                                    BidirectionalIterator2 result) {\n-    return __copy_backward(first, last, result);\n-  }\n-};\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION \n-\n-template <class T>\n-inline T* __copy_backward_t(const T* first, const T* last, T* result,\n-                            __true_type) {\n-  const ptrdiff_t N = last - first;\n-  memmove(result - N, first, sizeof(T) * N);\n-  return result - N;\n-}\n-\n-template <class T>\n-inline T* __copy_backward_t(const T* first, const T* last, T* result,\n-                            __false_type) {\n-  return __copy_backward(first, last, result);\n-}\n-\n-template <class T>\n-struct __copy_backward_dispatch<T*, T*>\n-{\n-  T* operator()(T* first, T* last, T* result) {\n-    return\n-      __copy_backward_t(first, last, result,\n-                        __type_traits<T>::has_trivial_assignment_operator());\n-  }\n-};\n-\n-template <class T>\n-struct __copy_backward_dispatch<const T*, T*>\n-{\n-  T* operator()(const T* first, const T* last, T* result) {\n-    return\n-      __copy_backward_t(first, last, result,\n-                        __type_traits<T>::has_trivial_assignment_operator());\n-  }\n-};\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class BidirectionalIterator1, class BidirectionalIterator2>\n-inline BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, \n-                                            BidirectionalIterator1 last, \n-                                            BidirectionalIterator2 result) {\n-  return __copy_backward_dispatch<BidirectionalIterator1, \n-                                  BidirectionalIterator2>()(first, last, \n-                                                            result);\n-}\n-\n-template <class InputIterator, class Size, class OutputIterator>\n-OutputIterator __copy_n(InputIterator first, Size count,\n-                        OutputIterator result,\n-                        input_iterator_tag) {\n-  for ( ; count > 0; --count, ++first, ++result)\n-    *result = *first;\n-  return result;\n-}\n-\n-template <class RandomAccessIterator, class Size, class OutputIterator>\n-inline OutputIterator __copy_n(RandomAccessIterator first, Size count,\n-                               OutputIterator result,\n-                               random_access_iterator_tag) {\n-  return copy(first, first + count, result);\n-}\n-\n-template <class InputIterator, class Size, class OutputIterator>\n-inline OutputIterator copy_n(InputIterator first, Size count,\n-                             OutputIterator result) {\n-  return __copy_n(first, count, result, iterator_category(first));\n-}\n-\n-template <class ForwardIterator, class T>\n-void fill(ForwardIterator first, ForwardIterator last, const T& value) {\n-  for ( ; first != last; ++first)\n-    *first = value;\n-}\n-\n-template <class OutputIterator, class Size, class T>\n-OutputIterator fill_n(OutputIterator first, Size n, const T& value) {\n-  for ( ; n > 0; --n, ++first)\n-    *first = value;\n-  return first;\n-}\n-\n-template <class InputIterator1, class InputIterator2>\n-pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,\n-\t\t\t\t\t      InputIterator1 last1,\n-\t\t\t\t\t      InputIterator2 first2) {\n-    while (first1 != last1 && *first1 == *first2) {\n-\t++first1;\n-\t++first2;\n-    }\n-    return pair<InputIterator1, InputIterator2>(first1, first2);\n-}\n-\n-template <class InputIterator1, class InputIterator2, class BinaryPredicate>\n-pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,\n-\t\t\t\t\t      InputIterator1 last1,\n-\t\t\t\t\t      InputIterator2 first2,\n-\t\t\t\t\t      BinaryPredicate binary_pred) {\n-    while (first1 != last1 && binary_pred(*first1, *first2)) {\n-\t++first1;\n-\t++first2;\n-    }\n-    return pair<InputIterator1, InputIterator2>(first1, first2);\n-}\n-\n-template <class InputIterator1, class InputIterator2>\n-inline bool equal(InputIterator1 first1, InputIterator1 last1,\n-\t\t  InputIterator2 first2) {\n-  for ( ; first1 != last1; ++first1, ++first2)\n-    if (*first1 != *first2)\n-      return false;\n-  return true;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class BinaryPredicate>\n-inline bool equal(InputIterator1 first1, InputIterator1 last1,\n-\t\t  InputIterator2 first2, BinaryPredicate binary_pred) {\n-  for ( ; first1 != last1; ++first1, ++first2)\n-    if (!binary_pred(*first1, *first2))\n-      return false;\n-  return true;\n-}\n-\n-template <class InputIterator1, class InputIterator2>\n-bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n-\t\t\t     InputIterator2 first2, InputIterator2 last2) {\n-  for ( ; first1 != last1 && first2 != last2; ++first1, ++first2) {\n-    if (*first1 < *first2)\n-      return true;\n-    if (*first2 < *first1)\n-      return false;\n-  }\n-  return first1 == last1 && first2 != last2;\n-}\n-\n-template <class InputIterator1, class InputIterator2, class Compare>\n-bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n-\t\t\t     InputIterator2 first2, InputIterator2 last2,\n-\t\t\t     Compare comp) {\n-  for ( ; first1 != last1 && first2 != last2; ++first1, ++first2) {\n-    if (comp(*first1, *first2))\n-      return true;\n-    if (comp(*first2, *first1))\n-      return false;\n-  }\n-  return first1 == last1 && first2 != last2;\n-}\n-\n-inline bool \n-lexicographical_compare(const unsigned char* first1,\n-                        const unsigned char* last1,\n-                        const unsigned char* first2,\n-                        const unsigned char* last2)\n-{\n-  const size_t len1 = last1 - first1;\n-  const size_t len2 = last2 - first2;\n-  const int result = memcmp(first1, first2, min(len1, len2));\n-  return result != 0 ? result < 0 : len1 < len2;\n-}\n-\n-inline bool lexicographical_compare(const char* first1, const char* last1,\n-                                    const char* first2, const char* last2)\n-{\n-#if CHAR_MAX == SCHAR_MAX\n-  return lexicographical_compare((const signed char*) first1,\n-                                 (const signed char*) last1,\n-                                 (const signed char*) first2,\n-                                 (const signed char*) last2);\n-#else\n-  return lexicographical_compare((const unsigned char*) first1,\n-                                 (const unsigned char*) last1,\n-                                 (const unsigned char*) first2,\n-                                 (const unsigned char*) last2);\n-#endif\n-}\n-\n-template <class InputIterator1, class InputIterator2>\n-int lexicographical_compare_3way(InputIterator1 first1, InputIterator1 last1,\n-                                 InputIterator2 first2, InputIterator2 last2)\n-{\n-    while (first1 != last1 && first2 != last2) {\n-        if (*first1 < *first2) return -1;\n-        if (*first2 < *first1) return 1;\n-\t++first1; ++first2;\n-    }\n-    if (first2 == last2) {\n-\treturn !(first1 == last1);\n-    } else {\n-        return -1;\n-    }\n-}\n-\n-inline int\n-lexicographical_compare_3way(const unsigned char* first1,\n-                             const unsigned char* last1,\n-                             const unsigned char* first2,\n-                             const unsigned char* last2)\n-{\n-  const int len1 = last1 - first1;\n-  const int len2 = last2 - first2;\n-  const int result = memcmp(first1, first2, min(len1, len2));\n-  return result == 0 ?  len1 - len2 : result;\n-}\n-\n-inline int lexicographical_compare_3way(const char* first1, const char* last1,\n-                                        const char* first2, const char* last2)\n-{\n-#if CHAR_MAX == SCHAR_MAX\n-  return lexicographical_compare_3way(\n-\t\t\t\t(const signed char*) first1,\n-                                (const signed char*) last1,\n-                                (const signed char*) first2,\n-                                (const signed char*) last2);\n-#else\n-  return lexicographical_compare_3way((const unsigned char*) first1,\n-                                      (const unsigned char*) last1,\n-                                      (const unsigned char*) first2,\n-                                      (const unsigned char*) last2);\n-#endif\n-}\n-\n-template <class T>\n-inline void destroy(T* pointer) {\n-    pointer->~T();\n-}\n-\n-template <class T1, class T2>\n-inline void construct(T1* p, const T2& value) {\n-    new (p) T1(value);\n-}\n-\n-template <class ForwardIterator>\n-inline void\n-__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) {\n-  for ( ; first < last; ++first)\n-    destroy(&*first);\n-}\n-\n-template <class ForwardIterator> \n-inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {\n-}\n-\n-template <class ForwardIterator, class T>\n-inline void __destroy(ForwardIterator first, ForwardIterator last, T*) {\n-  __destroy_aux(first, last, __type_traits<T>::has_trivial_destructor());\n-}\n-\n-template <class ForwardIterator>\n-inline void destroy(ForwardIterator first, ForwardIterator last) {\n-  __destroy(first, last, value_type(first));\n-}\n-\n-inline void destroy(char*, char*) {}\n-inline void destroy(wchar_t*, wchar_t*) {}\n-\n-// Valid if copy construction is equivalent to assignment, and if the\n-//  destructor is trivial.\n-template <class InputIterator, class ForwardIterator>\n-inline ForwardIterator \n-__uninitialized_copy_aux(InputIterator first, InputIterator last,\n-                         ForwardIterator result,\n-                         __true_type) {\n-  return copy(first, last, result);\n-}\n-\n-template <class InputIterator, class ForwardIterator>\n-ForwardIterator \n-__uninitialized_copy_aux(InputIterator first, InputIterator last,\n-                         ForwardIterator result,\n-                         __false_type) {\n-  ForwardIterator cur = result;\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    for ( ; first != last; ++first, ++cur)\n-      construct(&*cur, *first);\n-    return cur;\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    destroy(result, cur);\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-\n-template <class InputIterator, class ForwardIterator, class T>\n-inline ForwardIterator\n-__uninitialized_copy(InputIterator first, InputIterator last,\n-                     ForwardIterator result, T*) {\n-  return __uninitialized_copy_aux(first, last, result,\n-                                  __type_traits<T>::is_POD_type());\n-}\n-\n-template <class InputIterator, class ForwardIterator>\n-inline ForwardIterator\n-  uninitialized_copy(InputIterator first, InputIterator last,\n-                     ForwardIterator result) {\n-  return __uninitialized_copy(first, last, result, value_type(result));\n-}\n-\n-inline char* uninitialized_copy(const char* first, const char* last,\n-                                char* result) {\n-  memmove(result, first, last - first);\n-  return result + (last - first);\n-}\n-\n-inline wchar_t* uninitialized_copy(const wchar_t* first, const wchar_t* last,\n-                                   wchar_t* result) {\n-  memmove(result, first, sizeof(wchar_t) * (last - first));\n-  return result + (last - first);\n-}\n-\n-template <class InputIterator, class Size, class ForwardIterator>\n-ForwardIterator __uninitialized_copy_n(InputIterator first, Size count,\n-                                       ForwardIterator result,\n-                                       input_iterator_tag) {\n-  ForwardIterator cur = result;\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    for ( ; count > 0 ; --count, ++first, ++cur) \n-      construct(&*cur, *first);\n-    return cur;\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    destroy(result, cur);\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-template <class RandomAccessIterator, class Size, class ForwardIterator>\n-inline ForwardIterator\n-__uninitialized_copy_n(RandomAccessIterator first, Size count,\n-                       ForwardIterator result,\n-                       random_access_iterator_tag) {\n-  return uninitialized_copy(first, first + count, result);\n-}\n-\n-template <class InputIterator, class Size, class ForwardIterator>\n-inline ForwardIterator uninitialized_copy_n(InputIterator first, Size count,\n-                                            ForwardIterator result) {\n-  return __uninitialized_copy_n(first, count, result,\n-                                iterator_category(first));\n-}\n-\n-// Valid if copy construction is equivalent to assignment, and if the\n-//  destructor is trivial.\n-template <class ForwardIterator, class T>\n-inline void\n-__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, \n-                         const T& x, __true_type)\n-{\n-  fill(first, last, x);\n-}\n-\n-template <class ForwardIterator, class T>\n-void\n-__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, \n-                         const T& x, __false_type)\n-{\n-  ForwardIterator cur = first;\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    for ( ; cur != last; ++cur)\n-      construct(&*cur, x);\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    destroy(first, cur);\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-template <class ForwardIterator, class T, class T1>\n-inline void __uninitialized_fill(ForwardIterator first, ForwardIterator last, \n-                                 const T& x, T1*) {\n-  __uninitialized_fill_aux(first, last, x,\n-                           __type_traits<T1>::is_POD_type());\n-}\n-\n-template <class ForwardIterator, class T>\n-inline void uninitialized_fill(ForwardIterator first, ForwardIterator last, \n-                               const T& x) {\n-  __uninitialized_fill(first, last, x, value_type(first));\n-}\n-\n-// Valid if copy construction is equivalent to assignment, and if the\n-//  destructor is trivial.\n-template <class ForwardIterator, class Size, class T>\n-inline ForwardIterator\n-__uninitialized_fill_n_aux(ForwardIterator first, Size n,\n-                           const T& x, __true_type) {\n-  return fill_n(first, n, x);\n-}\n-\n-template <class ForwardIterator, class Size, class T>\n-ForwardIterator\n-__uninitialized_fill_n_aux(ForwardIterator first, Size n,\n-                           const T& x, __false_type) {\n-  ForwardIterator cur = first;\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    for ( ; n > 0; --n, ++cur)\n-      construct(&*cur, x);\n-    return cur;\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    destroy(first, cur);\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-template <class ForwardIterator, class Size, class T, class T1>\n-inline ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n,\n-                                              const T& x, T1*) {\n-  return __uninitialized_fill_n_aux(first, n, x,\n-                                    __type_traits<T1>::is_POD_type());\n-}\n-\n-template <class ForwardIterator, class Size, class T>\n-inline ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n,\n-                                            const T& x) {\n-  return __uninitialized_fill_n(first, n, x, value_type(first));\n-}\n-\n-// Copies [first1, last1) into [result, result + (last1 - first1)), and\n-//  copies [first2, last2) into\n-//  [result, result + (last1 - first1) + (last2 - first2)).\n-\n-template <class InputIterator1, class InputIterator2, class ForwardIterator>\n-inline ForwardIterator\n-__uninitialized_copy_copy(InputIterator1 first1, InputIterator1 last1,\n-                          InputIterator2 first2, InputIterator2 last2,\n-                          ForwardIterator result) {\n-  ForwardIterator mid = uninitialized_copy(first1, last1, result);\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    return uninitialized_copy(first2, last2, mid);\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    destroy(result, mid);\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-// Fills [result, mid) with x, and copies [first, last) into\n-//  [mid, mid + (last - first)).\n-template <class ForwardIterator, class T, class InputIterator>\n-inline ForwardIterator \n-__uninitialized_fill_copy(ForwardIterator result, ForwardIterator mid,\n-                          const T& x,\n-                          InputIterator first, InputIterator last) {\n-  uninitialized_fill(result, mid, x);\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    return uninitialized_copy(first, last, mid);\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    destroy(result, mid);\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-// Copies [first1, last1) into [first2, first2 + (last1 - first1)), and\n-//  fills [first2 + (last1 - first1), last2) with x.\n-template <class InputIterator, class ForwardIterator, class T>\n-inline void\n-__uninitialized_copy_fill(InputIterator first1, InputIterator last1,\n-                          ForwardIterator first2, ForwardIterator last2,\n-                          const T& x) {\n-  ForwardIterator mid2 = uninitialized_copy(first1, last1, first2);\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    uninitialized_fill(mid2, last2, x);\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    destroy(first2, mid2);\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-#endif /* _SGI_STL_ALGOBASE_H */\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from stl_algobase.h\n+using __STD::iter_swap; \n+using __STD::swap; \n+using __STD::min; \n+using __STD::max; \n+using __STD::copy; \n+using __STD::copy_backward; \n+using __STD::copy_n; \n+using __STD::fill; \n+using __STD::fill_n; \n+using __STD::mismatch; \n+using __STD::equal; \n+using __STD::lexicographical_compare; \n+using __STD::lexicographical_compare_3way; \n+\n+// Names from stl_uninitialized.h\n+using __STD::uninitialized_copy;\n+using __STD::uninitialized_copy_n;\n+using __STD::uninitialized_fill;\n+using __STD::uninitialized_fill_n;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* __SGI_STL_ALGOBASE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "515e9bd25dac47f2b3839784144203ba73438453", "filename": "libstdc++/stl/algorithm", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Falgorithm?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,39 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_ALGORITHM\n+#define __SGI_STL_ALGORITHM\n+\n+#include <stl_algobase.h>\n+#include <stl_construct.h>\n+#include <stl_tempbuf.h>\n+#include <stl_algo.h>\n+\n+#endif /* __SGI_STL_ALGORITHM */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "7cc961006057af8469b213eb762fbf660f555d87", "filename": "libstdc++/stl/alloc.h", "status": "modified", "additions": 20, "deletions": 660, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Falloc.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -11,674 +11,34 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n \n-#ifndef __ALLOC_H\n-#define __ALLOC_H\n+#ifndef __SGI_STL_ALLOC_H\n+#define __SGI_STL_ALLOC_H\n \n+#ifndef __STL_CONFIG_H\n #include <stl_config.h>\n-\n-#ifdef __SUNPRO_CC\n-#  define __PRIVATE public\n-   // Extra access restrictions prevent us from really making some things\n-   // private.\n-#else\n-#  define __PRIVATE private\n-#endif\n-\n-#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n-#  define __USE_MALLOC\n-#endif\n-\n-\n-// This implements some standard node allocators.  These are\n-// NOT the same as the allocators in the C++ draft standard or in\n-// in the original STL.  They do not encapsulate different pointer\n-// types; indeed we assume that there is only one pointer type.\n-// The allocation primitives are intended to allocate individual objects,\n-// not larger arenas as with the original STL allocators.\n-\n-#if 0\n-#   include <new>\n-#   define __THROW_BAD_ALLOC throw bad_alloc\n-#elif !defined(__THROW_BAD_ALLOC)\n-#   include <iostream.h>\n-#   define __THROW_BAD_ALLOC cerr << \"out of memory\" << endl; exit(1)\n-#endif\n-\n-#ifndef __ALLOC\n-#   define __ALLOC alloc\n-#endif\n-#ifdef __STL_WIN32THREADS\n-#   include <windows.h>\n-#endif\n-\n-#include <stddef.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <assert.h>\n-#ifndef __RESTRICT\n-#  define __RESTRICT\n #endif\n-\n-#if !defined(_PTHREADS) && !defined(_NOTHREADS) \\\n- && !defined(__STL_SGI_THREADS) && !defined(__STL_WIN32THREADS)\n-#   define _NOTHREADS\n+#ifndef __SGI_STL_INTERNAL_ALLOC_H\n+#include <stl_alloc.h>\n #endif\n \n-# ifdef _PTHREADS\n-    // POSIX Threads\n-    // This is dubious, since this is likely to be a high contention\n-    // lock.   Performance may not be adequate.\n-#   include <pthread.h>\n-#   define __NODE_ALLOCATOR_LOCK \\\n-        if (threads) pthread_mutex_lock(&__node_allocator_lock)\n-#   define __NODE_ALLOCATOR_UNLOCK \\\n-        if (threads) pthread_mutex_unlock(&__node_allocator_lock)\n-#   define __NODE_ALLOCATOR_THREADS true\n-#   define __VOLATILE volatile  // Needed at -O3 on SGI\n-# endif\n-# ifdef __STL_WIN32THREADS\n-    // The lock needs to be initialized by constructing an allocator\n-    // objects of the right type.  We do that here explicitly for alloc.\n-#   define __NODE_ALLOCATOR_LOCK \\\n-        EnterCriticalSection(&__node_allocator_lock)\n-#   define __NODE_ALLOCATOR_UNLOCK \\\n-        LeaveCriticalSection(&__node_allocator_lock)\n-#   define __NODE_ALLOCATOR_THREADS true\n-#   define __VOLATILE volatile  // may not be needed\n-# endif /* WIN32THREADS */\n-# ifdef __STL_SGI_THREADS\n-    // This should work without threads, with sproc threads, or with\n-    // pthreads.  It is suboptimal in all cases.\n-    // It is unlikely to even compile on nonSGI machines.\n-\n-    extern int __us_rsthread_malloc;\n-\t// The above is copied from malloc.h.  Including <malloc.h>\n-\t// would be cleaner but fails with certain levels of standard\n-\t// conformance.\n-#   define __NODE_ALLOCATOR_LOCK if (threads && __us_rsthread_malloc) \\\n-                { __lock(&__node_allocator_lock); }\n-#   define __NODE_ALLOCATOR_UNLOCK if (threads && __us_rsthread_malloc) \\\n-                { __unlock(&__node_allocator_lock); }\n-#   define __NODE_ALLOCATOR_THREADS true\n-#   define __VOLATILE volatile  // Needed at -O3 on SGI\n-# endif\n-# ifdef _NOTHREADS\n-//  Thread-unsafe\n-#   define __NODE_ALLOCATOR_LOCK\n-#   define __NODE_ALLOCATOR_UNLOCK\n-#   define __NODE_ALLOCATOR_THREADS false\n-#   define __VOLATILE\n-# endif\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1174\n-#endif\n+#ifdef __STL_USE_NAMESPACES\n \n-// Malloc-based allocator.  Typically slower than default alloc below.\n-// Typically thread-safe and more storage efficient.\n+using __STD::__malloc_alloc_template; \n+using __STD::malloc_alloc; \n+using __STD::simple_alloc; \n+using __STD::debug_alloc; \n+using __STD::__default_alloc_template; \n+using __STD::alloc; \n+using __STD::single_client_alloc; \n #ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n-# ifdef __DECLARE_GLOBALS_HERE\n-    void (* __malloc_alloc_oom_handler)() = 0;\n-    // g++ 2.7.2 does not handle static template data members.\n-# else\n-    extern void (* __malloc_alloc_oom_handler)();\n-# endif\n-#endif\n-\n-template <int inst>\n-class __malloc_alloc_template {\n-\n-private:\n-\n-static void *oom_malloc(size_t);\n-\n-static void *oom_realloc(void *, size_t);\n-\n-#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n-    static void (* __malloc_alloc_oom_handler)();\n-#endif\n-\n-public:\n-\n-static void * allocate(size_t n)\n-{\n-    void *result = malloc(n);\n-    if (0 == result) result = oom_malloc(n);\n-    return result;\n-}\n-\n-static void deallocate(void *p, size_t /* n */)\n-{\n-    free(p);\n-}\n-\n-static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz)\n-{\n-    void * result = realloc(p, new_sz);\n-    if (0 == result) result = oom_realloc(p, new_sz);\n-    return result;\n-}\n-\n-static void (* set_malloc_handler(void (*f)()))()\n-{\n-    void (* old)() = __malloc_alloc_oom_handler;\n-    __malloc_alloc_oom_handler = f;\n-    return(old);\n-}\n-\n-};\n-\n-// malloc_alloc out-of-memory handling\n-\n-#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n-template <int inst>\n-void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;\n-#endif\n-\n-template <int inst>\n-void * __malloc_alloc_template<inst>::oom_malloc(size_t n)\n-{\n-    void (* my_malloc_handler)();\n-    void *result;\n-\n-    for (;;) {\n-        my_malloc_handler = __malloc_alloc_oom_handler;\n-        if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }\n-        (*my_malloc_handler)();\n-        result = malloc(n);\n-        if (result) return(result);\n-    }\n-}\n-\n-template <int inst>\n-void * __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n)\n-{\n-    void (* my_malloc_handler)();\n-    void *result;\n-\n-    for (;;) {\n-        my_malloc_handler = __malloc_alloc_oom_handler;\n-        if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }\n-        (*my_malloc_handler)();\n-        result = realloc(p, n);\n-        if (result) return(result);\n-    }\n-}\n-\n-typedef __malloc_alloc_template<0> malloc_alloc;\n-\n-template<class T, class Alloc>\n-class simple_alloc {\n-\n-public:\n-    static T *allocate(size_t n)\n-                { return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); }\n-    static T *allocate(void)\n-                { return (T*) Alloc::allocate(sizeof (T)); }\n-    static void deallocate(T *p, size_t n)\n-                { if (0 != n) Alloc::deallocate(p, n * sizeof (T)); }\n-    static void deallocate(T *p)\n-                { Alloc::deallocate(p, sizeof (T)); }\n-};\n-\n-// Allocator adaptor to check size arguments for debugging.\n-// Reports errors using assert.  Checking can be disabled with\n-// NDEBUG, but it's far better to just use the underlying allocator\n-// instead when no checking is desired.\n-// There is some evidence that this can confuse Purify.\n-template <class Alloc>\n-class debug_alloc {\n-\n-private:\n-\n-enum {extra = 8};       // Size of space used to store size.  Note\n-                        // that this must be large enough to preserve\n-                        // alignment.\n-\n-public:\n-\n-static void * allocate(size_t n)\n-{\n-    char *result = (char *)Alloc::allocate(n + extra);\n-    *(size_t *)result = n;\n-    return result + extra;\n-}\n-\n-static void deallocate(void *p, size_t n)\n-{\n-    char * real_p = (char *)p - extra;\n-    assert(*(size_t *)real_p == n);\n-    Alloc::deallocate(real_p, n + extra);\n-}\n-\n-static void * reallocate(void *p, size_t old_sz, size_t new_sz)\n-{\n-    char * real_p = (char *)p - extra;\n-    assert(*(size_t *)real_p == old_sz);\n-    char * result = (char *)\n-                  Alloc::reallocate(real_p, old_sz + extra, new_sz + extra);\n-    *(size_t *)result = new_sz;\n-    return result + extra;\n-}\n-\n-\n-};\n-\n-\n-# ifdef __USE_MALLOC\n-\n-typedef malloc_alloc alloc;\n-typedef malloc_alloc single_client_alloc;\n+using __STD::__malloc_alloc_oom_handler; \n+#endif /* __STL_STATIC_TEMPLATE_MEMBER_BUG */\n \n-# else\n \n+#endif /* __STL_USE_NAMESPACES */\n \n-// Default node allocator.\n-// With a reasonable compiler, this should be roughly as fast as the\n-// original STL class-specific allocators, but with less fragmentation.\n-// Default_alloc_template parameters are experimental and MAY\n-// DISAPPEAR in the future.  Clients should just use alloc for now.\n-//\n-// Important implementation properties:\n-// 1. If the client request an object of size > __MAX_BYTES, the resulting\n-//    object will be obtained directly from malloc.\n-// 2. In all other cases, we allocate an object of size exactly\n-//    ROUND_UP(requested_size).  Thus the client has enough size\n-//    information that we can return the object to the proper free list\n-//    without permanently losing part of the object.\n-//\n-\n-// The first template parameter specifies whether more than one thread\n-// may use this allocator.  It is safe to allocate an object from\n-// one instance of a default_alloc and deallocate it with another\n-// one.  This effectively transfers its ownership to the second one.\n-// This may have undesirable effects on reference locality.\n-// The second parameter is unreferenced and serves only to allow the\n-// creation of multiple default_alloc instances.\n-// Node that containers built on different allocator instances have\n-// different types, limiting the utility of this approach.\n-#ifdef __SUNPRO_CC\n-// breaks if we make these template class members:\n-  enum {__ALIGN = 8};\n-  enum {__MAX_BYTES = 128};\n-  enum {__NFREELISTS = __MAX_BYTES/__ALIGN};\n-#endif\n-\n-template <bool threads, int inst>\n-class __default_alloc_template {\n-\n-private:\n-  // Really we should use static const int x = N\n-  // instead of enum { x = N }, but few compilers accept the former.\n-# ifndef __SUNPRO_CC\n-    enum {__ALIGN = 8};\n-    enum {__MAX_BYTES = 128};\n-    enum {__NFREELISTS = __MAX_BYTES/__ALIGN};\n-# endif\n-  static size_t ROUND_UP(size_t bytes) {\n-        return (((bytes) + __ALIGN-1) & ~(__ALIGN - 1));\n-  }\n-__PRIVATE:\n-  union obj {\n-        union obj * free_list_link;\n-        char client_data[1];    /* The client sees this.        */\n-  };\n-private:\n-# ifdef __SUNPRO_CC\n-    static obj * __VOLATILE free_list[]; \n-        // Specifying a size results in duplicate def for 4.1\n-# else\n-    static obj * __VOLATILE free_list[__NFREELISTS]; \n-# endif\n-  static  size_t FREELIST_INDEX(size_t bytes) {\n-        return (((bytes) + __ALIGN-1)/__ALIGN - 1);\n-  }\n-\n-  // Returns an object of size n, and optionally adds to size n free list.\n-  static void *refill(size_t n);\n-  // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n-  // if it is inconvenient to allocate the requested number.\n-  static char *chunk_alloc(size_t size, int &nobjs);\n-\n-  // Chunk allocation state.\n-  static char *start_free;\n-  static char *end_free;\n-  static size_t heap_size;\n-\n-# ifdef __STL_SGI_THREADS\n-    static volatile unsigned long __node_allocator_lock;\n-    static void __lock(volatile unsigned long *); \n-    static inline void __unlock(volatile unsigned long *);\n-# endif\n-\n-# ifdef _PTHREADS\n-    static pthread_mutex_t __node_allocator_lock;\n-# endif\n-\n-# ifdef __STL_WIN32THREADS\n-    static CRITICAL_SECTION __node_allocator_lock;\n-    static bool __node_allocator_lock_initialized;\n-\n-  public:\n-    __default_alloc_template() {\n-\t// This assumes the first constructor is called before threads\n-\t// are started.\n-        if (!__node_allocator_lock_initialized) {\n-            InitializeCriticalSection(&__node_allocator_lock);\n-            __node_allocator_lock_initialized = true;\n-        }\n-    }\n-  private:\n-# endif\n-\n-    class lock {\n-        public:\n-            lock() { __NODE_ALLOCATOR_LOCK; }\n-            ~lock() { __NODE_ALLOCATOR_UNLOCK; }\n-    };\n-    friend class lock;\n-\n-public:\n-\n-  /* n must be > 0      */\n-  static void * allocate(size_t n)\n-  {\n-    obj * __VOLATILE * my_free_list;\n-    obj * __RESTRICT result;\n-\n-    if (n > (size_t) __MAX_BYTES) {\n-        return(malloc_alloc::allocate(n));\n-    }\n-    my_free_list = free_list + FREELIST_INDEX(n);\n-    // Acquire the lock here with a constructor call.\n-    // This ensures that it is released in exit or during stack\n-    // unwinding.\n-#       ifndef _NOTHREADS\n-        /*REFERENCED*/\n-        lock lock_instance;\n-#       endif\n-    result = *my_free_list;\n-    if (result == 0) {\n-        void *r = refill(ROUND_UP(n));\n-        return r;\n-    }\n-    *my_free_list = result -> free_list_link;\n-    return (result);\n-  };\n-\n-  /* p may not be 0 */\n-  static void deallocate(void *p, size_t n)\n-  {\n-    obj *q = (obj *)p;\n-    obj * __VOLATILE * my_free_list;\n-\n-    if (n > (size_t) __MAX_BYTES) {\n-        malloc_alloc::deallocate(p, n);\n-        return;\n-    }\n-    my_free_list = free_list + FREELIST_INDEX(n);\n-    // acquire lock\n-#       ifndef _NOTHREADS\n-        /*REFERENCED*/\n-        lock lock_instance;\n-#       endif /* _NOTHREADS */\n-    q -> free_list_link = *my_free_list;\n-    *my_free_list = q;\n-    // lock is released here\n-  }\n-\n-  static void * reallocate(void *p, size_t old_sz, size_t new_sz);\n-\n-} ;\n-\n-typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;\n-typedef __default_alloc_template<false, 0> single_client_alloc;\n-\n-\n-\n-/* We allocate memory in large chunks in order to avoid fragmenting     */\n-/* the malloc heap too much.                                            */\n-/* We assume that size is properly aligned.                             */\n-/* We hold the allocation lock.                                         */\n-template <bool threads, int inst>\n-char*\n-__default_alloc_template<threads, inst>::chunk_alloc(size_t size, int& nobjs)\n-{\n-    char * result;\n-    size_t total_bytes = size * nobjs;\n-    size_t bytes_left = end_free - start_free;\n-\n-    if (bytes_left >= total_bytes) {\n-        result = start_free;\n-        start_free += total_bytes;\n-        return(result);\n-    } else if (bytes_left >= size) {\n-        nobjs = bytes_left/size;\n-        total_bytes = size * nobjs;\n-        result = start_free;\n-        start_free += total_bytes;\n-        return(result);\n-    } else {\n-        size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size >> 4);\n-        // Try to make use of the left-over piece.\n-        if (bytes_left > 0) {\n-            obj * __VOLATILE * my_free_list =\n-                        free_list + FREELIST_INDEX(bytes_left);\n-\n-            ((obj *)start_free) -> free_list_link = *my_free_list;\n-            *my_free_list = (obj *)start_free;\n-        }\n-        start_free = (char *)malloc(bytes_to_get);\n-        if (0 == start_free) {\n-            int i;\n-            obj * __VOLATILE * my_free_list, *p;\n-            // Try to make do with what we have.  That can't\n-            // hurt.  We do not try smaller requests, since that tends\n-            // to result in disaster on multi-process machines.\n-            for (i = size; i <= __MAX_BYTES; i += __ALIGN) {\n-                my_free_list = free_list + FREELIST_INDEX(i);\n-                p = *my_free_list;\n-                if (0 != p) {\n-                    *my_free_list = p -> free_list_link;\n-                    start_free = (char *)p;\n-                    end_free = start_free + i;\n-                    return(chunk_alloc(size, nobjs));\n-                    // Any leftover piece will eventually make it to the\n-                    // right free list.\n-                }\n-            }\n-\t    end_free = 0;\t// In case of exception.\n-            start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n-            // This should either throw an\n-            // exception or remedy the situation.  Thus we assume it\n-            // succeeded.\n-        }\n-        heap_size += bytes_to_get;\n-        end_free = start_free + bytes_to_get;\n-        return(chunk_alloc(size, nobjs));\n-    }\n-}\n-\n-\n-/* Returns an object of size n, and optionally adds to size n free list.*/\n-/* We assume that n is properly aligned.                                */\n-/* We hold the allocation lock.                                         */\n-template <bool threads, int inst>\n-void* __default_alloc_template<threads, inst>::refill(size_t n)\n-{\n-    int nobjs = 20;\n-    char * chunk = chunk_alloc(n, nobjs);\n-    obj * __VOLATILE * my_free_list;\n-    obj * result;\n-    obj * current_obj, * next_obj;\n-    int i;\n-\n-    if (1 == nobjs) return(chunk);\n-    my_free_list = free_list + FREELIST_INDEX(n);\n-\n-    /* Build free list in chunk */\n-      result = (obj *)chunk;\n-      *my_free_list = next_obj = (obj *)(chunk + n);\n-      for (i = 1; ; i++) {\n-        current_obj = next_obj;\n-        next_obj = (obj *)((char *)next_obj + n);\n-        if (nobjs - 1 == i) {\n-            current_obj -> free_list_link = 0;\n-            break;\n-        } else {\n-            current_obj -> free_list_link = next_obj;\n-        }\n-      }\n-    return(result);\n-}\n-\n-template <bool threads, int inst>\n-void*\n-__default_alloc_template<threads, inst>::reallocate(void *p,\n-                                                    size_t old_sz,\n-                                                    size_t new_sz)\n-{\n-    void * result;\n-    size_t copy_sz;\n-\n-    if (old_sz > (size_t) __MAX_BYTES && new_sz > (size_t) __MAX_BYTES) {\n-        return(realloc(p, new_sz));\n-    }\n-    if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);\n-    result = allocate(new_sz);\n-    copy_sz = new_sz > old_sz? old_sz : new_sz;\n-    memcpy(result, p, copy_sz);\n-    deallocate(p, old_sz);\n-    return(result);\n-}\n-\n-#ifdef _PTHREADS\n-    template <bool threads, int inst>\n-    pthread_mutex_t\n-    __default_alloc_template<threads, inst>::__node_allocator_lock\n-        = PTHREAD_MUTEX_INITIALIZER;\n-#endif\n-\n-#ifdef __STL_WIN32THREADS\n-    template <bool threads, int inst> CRITICAL_SECTION\n-    __default_alloc_template<threads, inst>::__node_allocator_lock;\n-\n-    template <bool threads, int inst> bool\n-    __default_alloc_template<threads, inst>::__node_allocator_lock_initialized\n-\t= false;\n-#endif\n-\n-#ifdef __STL_SGI_THREADS\n-#include <mutex.h>\n-#include <time.h>\n-// Somewhat generic lock implementations.  We need only test-and-set\n-// and some way to sleep.  These should work with both SGI pthreads\n-// and sproc threads.  They may be useful on other systems.\n-template <bool threads, int inst>\n-volatile unsigned long\n-__default_alloc_template<threads, inst>::__node_allocator_lock = 0;\n-\n-#if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) || defined(__GNUC__)\n-#   define __test_and_set(l,v) test_and_set(l,v)\n-#endif\n-\n-template <bool threads, int inst>\n-void \n-__default_alloc_template<threads, inst>::__lock(volatile unsigned long *lock)\n-{\n-    const unsigned low_spin_max = 30;  // spin cycles if we suspect uniprocessor\n-    const unsigned high_spin_max = 1000; // spin cycles for multiprocessor\n-    static unsigned spin_max = low_spin_max;\n-    unsigned my_spin_max;\n-    static unsigned last_spins = 0;\n-    unsigned my_last_spins;\n-    static struct timespec ts = {0, 1000};\n-    unsigned junk;\n-#   define __ALLOC_PAUSE junk *= junk; junk *= junk; junk *= junk; junk *= junk\n-    int i;\n-\n-    if (!__test_and_set((unsigned long *)lock, 1)) {\n-        return;\n-    }\n-    my_spin_max = spin_max;\n-    my_last_spins = last_spins;\n-    for (i = 0; i < my_spin_max; i++) {\n-        if (i < my_last_spins/2 || *lock) {\n-            __ALLOC_PAUSE;\n-            continue;\n-        }\n-        if (!__test_and_set((unsigned long *)lock, 1)) {\n-            // got it!\n-            // Spinning worked.  Thus we're probably not being scheduled\n-            // against the other process with which we were contending.\n-            // Thus it makes sense to spin longer the next time.\n-            last_spins = i;\n-            spin_max = high_spin_max;\n-            return;\n-        }\n-    }\n-    // We are probably being scheduled against the other process.  Sleep.\n-    spin_max = low_spin_max;\n-    for (;;) {\n-        if (!__test_and_set((unsigned long *)lock, 1)) {\n-            return;\n-        }\n-        nanosleep(&ts, 0);\n-    }\n-}\n-\n-template <bool threads, int inst>\n-inline void\n-__default_alloc_template<threads, inst>::__unlock(volatile unsigned long *lock)\n-{\n-#   if defined(__GNUC__) && __mips >= 3\n-        asm(\"sync\");\n-        *lock = 0;\n-#   elif __mips >= 3 && (defined (_ABIN32) || defined(_ABI64))\n-        __lock_release(lock);\n-#   else \n-        *lock = 0;\n-        // This is not sufficient on many multiprocessors, since\n-        // writes to protected variables and the lock may be reordered.\n-#   endif\n-}\n-#endif\n-\n-template <bool threads, int inst>\n-char *__default_alloc_template<threads, inst>::start_free = 0;\n-\n-template <bool threads, int inst>\n-char *__default_alloc_template<threads, inst>::end_free = 0;\n-\n-template <bool threads, int inst>\n-size_t __default_alloc_template<threads, inst>::heap_size = 0;\n-\n-template <bool threads, int inst>\n-__default_alloc_template<threads, inst>::obj * __VOLATILE\n-__default_alloc_template<threads, inst> ::free_list[\n-# ifdef __SUNPRO_CC\n-    __NFREELISTS\n-# else\n-    __default_alloc_template<threads, inst>::__NFREELISTS\n-# endif\n-] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };\n-// The 16 zeros are necessary to make version 4.1 of the SunPro\n-// compiler happy.  Otherwise it appears to allocate too little\n-// space for the array.\n-\n-# ifdef __STL_WIN32THREADS\n-  // Create one to get critical section initialized.\n-  // We do this onece per file, but only the first constructor\n-  // does anything.\n-  static alloc __node_allocator_dummy_instance;\n-# endif\n-\n-#endif /* ! __USE_MALLOC */\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1174\n-#endif\n-\n-#undef __PRIVATE\n+#endif /* __SGI_STL_ALLOC_H */\n \n-#endif /* __ALLOC_H */\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "03a3fb1c7f2352dd856528412680ee5644501e03", "filename": "libstdc++/stl/bvector.h", "status": "modified", "additions": 12, "deletions": 525, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fbvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fbvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fbvector.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -24,541 +24,28 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n \n-// vector<bool> is replaced by bit_vector at present because partial \n-// specialization is not yet implemented.  \n-\n #ifndef __SGI_STL_BVECTOR_H\n #define __SGI_STL_BVECTOR_H\n \n-#include <stddef.h>\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+#include <vector.h>\n+#else\n #include <algobase.h>\n #include <alloc.h>\n+#endif \n \n+#include <stl_bvector.h>\n \n-#define __WORD_BIT (int(CHAR_BIT*sizeof(unsigned int)))\n-\n-class bit_vector {\n-public:\n-    typedef bool value_type;\n-    typedef size_t size_type;\n-    typedef ptrdiff_t difference_type; \n-\n-    class iterator;\n-    class const_iterator;\n-\n-    class reference {\n-      friend class iterator;\n-      friend class const_iterator;\n-    protected:\n-\tunsigned int* p;\n-\tunsigned int mask;\n-\treference(unsigned int* x, unsigned int y) : p(x), mask(y) {}\n-    public:\n-\treference() : p(0), mask(0) {}\n-\toperator bool() const { return !(!(*p & mask)); }\n-\treference& operator=(bool x) {\n-\t    if (x)      \n-\t\t*p |= mask;\n-\t    else \n-\t\t*p &= ~mask;\n-\t    return *this;\n-\t}\n-\treference& operator=(const reference& x) { return *this = bool(x); }\n-\tbool operator==(const reference& x) const {\n-\t    return bool(*this) == bool(x);\n-\t}\n-\tbool operator<(const reference& x) const {\n-\t    return bool(*this) < bool(x);\n-\t}\n-\tvoid flip() { *p ^= mask; }\n-    };\n-\n-    typedef bool const_reference;\n-\n-    typedef reference bit_reference;\n-    typedef const_reference bit_const_reference;\n-\n-    class iterator : public random_access_iterator<bool, difference_type> {\n-      friend class bit_vector;\n-      friend class const_iterator;\n-    public:\n-      typedef bit_reference  reference;\n-      typedef bit_reference* pointer;\n-    protected:\n-\tunsigned int* p;\n-\tunsigned int offset;\n-\tvoid bump_up() {\n-\t    if (offset++ == __WORD_BIT - 1) {\n-\t\toffset = 0;\n-\t\t++p;\n-\t    }\n-\t}\n-    void bump_down() {\n-\tif (offset-- == 0) {\n-\t    offset = __WORD_BIT - 1;\n-\t    --p;\n-\t}\n-    }\n-    public:\n-\titerator() : p(0), offset(0) {}\n-\titerator(unsigned int* x, unsigned int y) : p(x), offset(y) {}\n-\treference operator*() const { return reference(p, 1U << offset); }\n-\titerator& operator++() {\n-\t    bump_up();\n-\t    return *this;\n-\t}\n-\titerator operator++(int) {\n-\t    iterator tmp = *this;\n-\t    bump_up();\n-\t    return tmp;\n-\t}\n-\titerator& operator--() {\n-\t    bump_down();\n-\t    return *this;\n-\t}\n-\titerator operator--(int) {\n-\t    iterator tmp = *this;\n-\t    bump_down();\n-\t    return tmp;\n-\t}\n-\titerator& operator+=(difference_type i) {\n-\t    difference_type n = i + offset;\n-\t    p += n / __WORD_BIT;\n-\t    n = n % __WORD_BIT;\n-\t    if (n < 0) {\n-\t\toffset = n + __WORD_BIT;\n-\t\t--p;\n-\t    } else\n-\t\toffset = n;\n-\t    return *this;\n-\t}\n-\titerator& operator-=(difference_type i) {\n-\t    *this += -i;\n-\t    return *this;\n-\t}\n-\titerator operator+(difference_type i) const {\n-\t    iterator tmp = *this;\n-\t    return tmp += i;\n-\t}\n-\titerator operator-(difference_type i) const {\n-\t    iterator tmp = *this;\n-\t    return tmp -= i;\n-\t}\n-\tdifference_type operator-(iterator x) const {\n-\t    return __WORD_BIT * (p - x.p) + offset - x.offset;\n-\t}\n-\treference operator[](difference_type i) { return *(*this + i); }\n-\tbool operator==(const iterator& x) const {\n-\t    return p == x.p && offset == x.offset;\n-\t}\n-\tbool operator!=(const iterator& x) const {\n-\t    return p != x.p || offset != x.offset;\n-\t}\n-\tbool operator<(iterator x) const {\n-\t    return p < x.p || (p == x.p && offset < x.offset);\n-\t}\n-    };\n-\n-    class const_iterator : public random_access_iterator<bool, difference_type>\n-    {\n-      friend class bit_vector;\n-    public:\n-      typedef bit_const_reference reference;\n-      typedef const bool*         pointer;\n-    protected:\n-\tunsigned int* p;\n-\tunsigned int offset;\n-\tvoid bump_up() {\n-\t    if (offset++ == __WORD_BIT - 1) {\n-\t\toffset = 0;\n-\t\t++p;\n-\t    }\n-\t}\n-    void bump_down() {\n-\tif (offset-- == 0) {\n-\t    offset = __WORD_BIT - 1;\n-\t    --p;\n-\t}\n-    }\n-    public:\n-\tconst_iterator() : p(0), offset(0) {}\n-\tconst_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}\n-\tconst_iterator(const iterator& x) : p(x.p), offset(x.offset) {}\n-\tconst_reference operator*() const {\n-\t    return bit_vector::reference(p, 1U << offset);\n-\t}\n-\tconst_iterator& operator++() {\n-\t    bump_up();\n-\t    return *this;\n-\t}\n-\tconst_iterator operator++(int) {\n-\t    const_iterator tmp = *this;\n-\t    bump_up();\n-\t    return tmp;\n-\t}\n-\tconst_iterator& operator--() {\n-\t    bump_down();\n-\t    return *this;\n-\t}\n-\tconst_iterator operator--(int) {\n-\t    const_iterator tmp = *this;\n-\t    bump_down();\n-\t    return tmp;\n-\t}\n-\tconst_iterator& operator+=(difference_type i) {\n-\t    difference_type n = i + offset;\n-\t    p += n / __WORD_BIT;\n-\t    n = n % __WORD_BIT;\n-\t    if (n < 0) {\n-\t\toffset = n + __WORD_BIT;\n-\t\t--p;\n-\t    } else\n-\t\toffset = n;\n-\t    return *this;\n-\t}\n-\tconst_iterator& operator-=(difference_type i) {\n-\t    *this += -i;\n-\t    return *this;\n-\t}\n-\tconst_iterator operator+(difference_type i) const {\n-\t    const_iterator tmp = *this;\n-\t    return tmp += i;\n-\t}\n-\tconst_iterator operator-(difference_type i) const {\n-\t    const_iterator tmp = *this;\n-\t    return tmp -= i;\n-\t}\n-\tdifference_type operator-(const_iterator x) const {\n-\t    return __WORD_BIT * (p - x.p) + offset - x.offset;\n-\t}\n-\tconst_reference operator[](difference_type i) { \n-\t    return *(*this + i); \n-\t}\n-\tbool operator==(const const_iterator& x) const {\n-\t    return p == x.p && offset == x.offset;\n-\t}\n-\tbool operator!=(const const_iterator& x) const {\n-\t    return p != x.p || offset != x.offset;\n-\t}\n-\tbool operator<(const_iterator x) const {\n-\t    return p < x.p || (p == x.p && offset < x.offset);\n-\t}\n-    };\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-    typedef reverse_iterator<iterator> reverse_iterator;\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-    typedef reverse_iterator<const_iterator, value_type, const_reference, \n-                             difference_type> const_reverse_iterator;\n-    typedef reverse_iterator<iterator, value_type, reference, difference_type>\n-        reverse_iterator;\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-protected:\n-    typedef simple_alloc<unsigned int, alloc> data_allocator;\n-    iterator start;\n-    iterator finish;\n-    unsigned int* end_of_storage;\n-    unsigned int* bit_alloc(size_type n) {\n-\treturn data_allocator::allocate((n + __WORD_BIT - 1)/__WORD_BIT);\n-    }\n-    void deallocate() {\n-      if (start.p)\n-        data_allocator::deallocate(start.p, end_of_storage - start.p);\n-    }\n-    void initialize(size_type n) {\n-\tunsigned int* q = bit_alloc(n);\n-\tend_of_storage = q + (n + __WORD_BIT - 1)/__WORD_BIT;\n-\tstart = iterator(q, 0);\n-\tfinish = start + n;\n-    }\n-    void insert_aux(iterator position, bool x) {\n-      if (finish.p != end_of_storage) {\n-\tcopy_backward(position, finish, finish + 1);\n-\t*position = x;\n-\t++finish;\n-      } else {\n-\tsize_type len = size() ? 2 * size() : __WORD_BIT;\n-\tunsigned int* q = bit_alloc(len);\n-\titerator i = copy(begin(), position, iterator(q, 0));\n-\t*i++ = x;\n-\tfinish = copy(position, end(), i);\n-\tdeallocate();\n-\tend_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;\n-\tstart = iterator(q, 0);\n-      }\n-    }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-    template <class InputIterator>\n-    void initialize_range(InputIterator first, InputIterator last,\n-                          input_iterator_tag) {\n-      start = iterator();\n-      finish = iterator();\n-      end_of_storage = 0;\n-      for ( ; first != last; ++first) \n-        push_back(*first);\n-    }\n-\n-    template <class ForwardIterator>\n-    void initialize_range(ForwardIterator first, ForwardIterator last,\n-                          forward_iterator_tag) {\n-      size_type n = 0;\n-      distance(first, last, n);\n-      initialize(n);\n-      copy(first, last, start);\n-    }\n+#ifdef __STL_USE_NAMESPACES\n \n-    template <class InputIterator>\n-    void insert_range(iterator pos,\n-                      InputIterator first, InputIterator last,\n-                      input_iterator_tag) {\n-      for ( ; first != last; ++first) {\n-        pos = insert(pos, *first);\n-        ++pos;\n-      }\n-    }\n+using __STD::bit_vector;\n \n-    template <class ForwardIterator>\n-    void insert_range(iterator position,\n-                      ForwardIterator first, ForwardIterator last,\n-                      forward_iterator_tag) {\n-      if (first != last) {\n-        size_type n = 0;\n-        distance(first, last, n);\n-        if (capacity() - size() >= n) {\n-          copy_backward(position, end(), finish + n);\n-          copy(first, last, position);\n-          finish += n;\n-        }\n-        else {\n-          size_type len = size() + max(size(), n);\n-          unsigned int* q = bit_alloc(len);\n-          iterator i = copy(begin(), position, iterator(q, 0));\n-          i = copy(first, last, i);\n-          finish = copy(position, end(), i);\n-          deallocate();\n-          end_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;\n-          start = iterator(q, 0);\n-        }\n-      }\n-    }      \n+#endif /* __STL_USE_NAMESPACES */\n \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-    typedef bit_vector self;\n-public:\n-    iterator begin() { return start; }\n-    const_iterator begin() const { return start; }\n-    iterator end() { return finish; }\n-    const_iterator end() const { return finish; }\n-\n-    reverse_iterator rbegin() { return reverse_iterator(end()); }\n-    const_reverse_iterator rbegin() const { \n-        return const_reverse_iterator(end()); \n-    }\n-    reverse_iterator rend() { return reverse_iterator(begin()); }\n-    const_reverse_iterator rend() const { \n-        return const_reverse_iterator(begin()); \n-    }\n-\n-    size_type size() const { return size_type(end() - begin()); }\n-    size_type max_size() const { return size_type(-1); }\n-    size_type capacity() const {\n-\treturn size_type(const_iterator(end_of_storage, 0) - begin());\n-    }\n-    bool empty() const { return begin() == end(); }\n-    reference operator[](size_type n) { return *(begin() + n); }\n-    const_reference operator[](size_type n) const { return *(begin() + n); }\n-    bit_vector() : start(iterator()), finish(iterator()), end_of_storage(0) {}\n-    bit_vector(size_type n, bool value) {\n-        initialize(n);\n-        fill(start.p, end_of_storage, value ? ~0 : 0);\n-    }\n-    bit_vector(int n, bool value) {\n-        initialize(n);\n-        fill(start.p, end_of_storage, value ? ~0 : 0);\n-    }\n-    bit_vector(long n, bool value) {\n-        initialize(n);\n-        fill(start.p, end_of_storage, value ? ~0 : 0);\n-    }\n-    explicit bit_vector(size_type n) {\n-        initialize(n);\n-        fill(start.p, end_of_storage, 0);\n-    }\n-    bit_vector(const self& x) {\n-\tinitialize(x.size());\n-\tcopy(x.begin(), x.end(), start);\n-    }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-    template <class InputIterator>\n-    bit_vector(InputIterator first, InputIterator last) {\n-        initialize_range(first, last, iterator_category(first));\n-    }\n-#else /* __STL_MEMBER_TEMPLATES */\n-    bit_vector(const_iterator first, const_iterator last) {\n-\tsize_type n = 0;\n-\tdistance(first, last, n);\n-\tinitialize(n);\n-\tcopy(first, last, start);\n-    }\n-    bit_vector(const bool* first, const bool* last) {\n-\tsize_type n = 0;\n-\tdistance(first, last, n);\n-\tinitialize(n);\n-\tcopy(first, last, start);\n-    }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-    ~bit_vector() { deallocate(); }\n-    self& operator=(const self& x) {\n-\tif (&x == this) return *this;\n-\tif (x.size() > capacity()) {\n-\t    deallocate();\n-\t    initialize(x.size());\n-\t}\n-\tcopy(x.begin(), x.end(), begin());\n-\tfinish = begin() + x.size();\n-\treturn *this;\n-    }\n-    void reserve(size_type n) {\n-\tif (capacity() < n) {\n-\t    unsigned int* q = bit_alloc(n);\n-\t    finish = copy(begin(), end(), iterator(q, 0));\n-\t    deallocate();\n-\t    start = iterator(q, 0);\n-\t    end_of_storage = q + (n + __WORD_BIT - 1)/__WORD_BIT;\n-\t}\n-    }\n-    reference front() { return *begin(); }\n-    const_reference front() const { return *begin(); }\n-    reference back() { return *(end() - 1); }\n-    const_reference back() const { return *(end() - 1); }\n-    void push_back(bool x) {\n-\tif (finish.p != end_of_storage)\n-\t    *finish++ = x;\n-\telse\n-\t    insert_aux(end(), x);\n-    }\n-    void swap(bit_vector& x) {\n-\t::swap(start, x.start);\n-\t::swap(finish, x.finish);\n-\t::swap(end_of_storage, x.end_of_storage);\n-    }\n-    iterator insert(iterator position, bool x = bool()) {\n-\tsize_type n = position - begin();\n-\tif (finish.p != end_of_storage && position == end())\n-\t    *finish++ = x;\n-\telse\n-\t    insert_aux(position, x);\n-\treturn begin() + n;\n-    }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-    template <class InputIterator> void insert(iterator position,\n-                                               InputIterator first,\n-                                               InputIterator last) {\n-      insert_range(position, first, last, iterator_category(first));\n-    }\n-#else /* __STL_MEMBER_TEMPLATES */\n-    void insert(iterator position, const_iterator first, \n-\t\tconst_iterator last) {\n-      if (first == last) return;\n-      size_type n = 0;\n-      distance(first, last, n);\n-      if (capacity() - size() >= n) {\n-\tcopy_backward(position, end(), finish + n);\n-\tcopy(first, last, position);\n-\tfinish += n;\n-      } else {\n-\tsize_type len = size() + max(size(), n);\n-\tunsigned int* q = bit_alloc(len);\n-\titerator i = copy(begin(), position, iterator(q, 0));\n-\ti = copy(first, last, i);\n-\tfinish = copy(position, end(), i);\n-\tdeallocate();\n-\tend_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;\n-\tstart = iterator(q, 0);\n-      }\n-    }\n-\n-    void insert(iterator position, const bool* first, const bool* last) {\n-      if (first == last) return;\n-      size_type n = 0;\n-      distance(first, last, n);\n-      if (capacity() - size() >= n) {\n-\tcopy_backward(position, end(), finish + n);\n-\tcopy(first, last, position);\n-\tfinish += n;\n-      } else {\n-\tsize_type len = size() + max(size(), n);\n-\tunsigned int* q = bit_alloc(len);\n-\titerator i = copy(begin(), position, iterator(q, 0));\n-\ti = copy(first, last, i);\n-\tfinish = copy(position, end(), i);\n-\tdeallocate();\n-\tend_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;\n-\tstart = iterator(q, 0);\n-      }\n-    }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-  \n-    void insert(iterator position, size_type n, bool x) {\n-      if (n == 0) return;\n-      if (capacity() - size() >= n) {\n-\tcopy_backward(position, end(), finish + n);\n-\tfill(position, position + n, x);\n-\tfinish += n;\n-      } else {\n-\tsize_type len = size() + max(size(), n);\n-\tunsigned int* q = bit_alloc(len);\n-\titerator i = copy(begin(), position, iterator(q, 0));\n-\tfill_n(i, n, x);\n-\tfinish = copy(position, end(), i + n);\n-\tdeallocate();\n-\tend_of_storage = q + (len + __WORD_BIT - 1)/__WORD_BIT;\n-\tstart = iterator(q, 0);\n-      }\n-    }\n-\n-    void insert(iterator pos, int n, bool x)  { insert(pos, (size_type)n, x); }\n-    void insert(iterator pos, long n, bool x) { insert(pos, (size_type)n, x); }\n-\n-    void pop_back() { --finish; }\n-    void erase(iterator position) {\n-\tif (position + 1 != end())\n-\t    copy(position + 1, end(), position);\n-\t--finish;\n-    }\n-    void erase(iterator first, iterator last) {\n-\tfinish = copy(last, end(), first);\n-    }\n-    void resize(size_type new_size, bool x = bool()) {\n-      if (new_size < size()) \n-        erase(begin() + new_size, end());\n-      else\n-        insert(end(), new_size - size(), x);\n-    }\n-    void clear() { erase(begin(), end()); }\n-};\n-\n-inline bool operator==(const bit_vector& x, const bit_vector& y) {\n-    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());\n-}\n-\n-inline bool operator<(const bit_vector& x, const bit_vector& y) {\n-    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());\n-}\n+#endif /* __SGI_STL_BVECTOR_H */\n \n-inline void swap(bit_vector::reference x, bit_vector::reference y) {\n-    bool tmp = x;\n-    x = y;\n-    y = tmp;\n-}\n+// Local Variables:\n+// mode:C++\n+// End:\n \n-#undef __WORD_BIT\n \n-#endif /* __SGI_STL_BVECTOR_H */"}, {"sha": "49690f8d6e070347710146b8fc914b082a35f38f", "filename": "libstdc++/stl/defalloc.h", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fdefalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fdefalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fdefalloc.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -12,16 +12,15 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  */\n-//\n-//  Inclusion of this file is DEPRECATED.\n-//  This is the original HP default allocator.\n-//  DO NOT USE THIS FILE unless you have an old container implementation\n-//  that requires an allocator with the HP-style interface.\n-//  SGI STL uses a different allocator interface.\n-//  SGI-style allocators are not parametrized with respect to\n-//  the object type; they traffic in void * pointers.\n-//  This file is not included by any other SGI STL header.\n-//\n+\n+// Inclusion of this file is DEPRECATED.  This is the original HP\n+// default allocator.  It is provided only for backward compatibility.\n+// \n+// DO NOT USE THIS FILE unless you have an old container implementation\n+// that requires an allocator with the HP-style interface.  SGI STL\n+// uses a different allocator interface.  SGI-style allocators are not\n+// parametrized with respect to the object type; they traffic in void *\n+// pointers.  This file is not included by any other SGI STL header.\n \n #ifndef DEFALLOC_H\n #define DEFALLOC_H"}, {"sha": "61654acad5bb0e40e50d5eeb902a864d20b542b9", "filename": "libstdc++/stl/deque", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fdeque?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,40 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_DEQUE\n+#define __SGI_STL_DEQUE\n+\n+#include <stl_algobase.h>\n+#include <stl_alloc.h>\n+#include <stl_construct.h>\n+#include <stl_uninitialized.h>\n+#include <stl_deque.h>\n+\n+#endif /* __SGI_STL_DEQUE */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "ede38b1ceba81c92347d8dc2392f08cad8147834", "filename": "libstdc++/stl/deque.h", "status": "modified", "additions": 7, "deletions": 1404, "changes": 1411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fdeque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fdeque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fdeque.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -27,1413 +27,16 @@\n #ifndef __SGI_STL_DEQUE_H\n #define __SGI_STL_DEQUE_H\n \n-/* Class invariants:\n- *  For any nonsingular iterator i:\n- *    i.node is the address of an element in the map array.  The\n- *      contents of i.node is a pointer to the beginning of a node.\n- *    i.first == *(i.node) \n- *    i.last  == i.first + node_size\n- *    i.cur is a pointer in the range [i.first, i.last).  NOTE:\n- *      the implication of this is that i.cur is always a dereferenceable\n- *      pointer, even if i is a past-the-end iterator.\n- *  Start and Finish are always nonsingular iterators.  NOTE: this means\n- *    that an empty deque must have one node, and that a deque\n- *    with N elements, where N is the buffer size, must have two nodes.\n- *  For every node other than start.node and finish.node, every element\n- *    in the node is an initialized object.  If start.node == finish.node,\n- *    then [start.cur, finish.cur) are initialized objects, and\n- *    the elements outside that range are uninitialized storage.  Otherwise,\n- *    [start.cur, start.last) and [finish.first, finish.cur) are initialized\n- *    objects, and [start.first, start.cur) and [finish.cur, finish.last)\n- *    are uninitialized storage.\n- *  [map, map + map_size) is a valid, non-empty range.  \n- *  [start.node, finish.node] is a valid range contained within \n- *    [map, map + map_size).  \n- *  A pointer in the range [map, map + map_size) points to an allocated\n- *    node if and only if the pointer is in the range [start.node, finish.node].\n- */\n-\n-\n-/*\n- * In previous versions of deque, node_size was fixed by the \n- * implementation.  In this version, however, users can select\n- * the node size.  Deque has three template parameters; the third,\n- * a number of type size_t, is the number of elements per node.\n- * If the third template parameter is 0 (which is the default), \n- * then deque will use a default node size.\n- *\n- * The only reason for using an alternate node size is if your application\n- * requires a different performance tradeoff than the default.  If,\n- * for example, your program contains many deques each of which contains\n- * only a few elements, then you might want to save memory (possibly\n- * by sacrificing some speed) by using smaller nodes.\n- *\n- * Unfortunately, some compilers have trouble with non-type template \n- * parameters; stl_config.h defines __STL_NON_TYPE_TMPL_PARAM_BUG if\n- * that is the case.  If your compiler is one of them, then you will\n- * not be able to use alternate node sizes; you will have to use the\n- * default value.\n- */\n-\n-#include <stddef.h>\n #include <algobase.h>\n #include <alloc.h>\n+#include <stl_deque.h>\n \n-// Note: this function is simply a kludge to work around several compilers'\n-//  bugs in handling constant expressions.\n-inline size_t __deque_buf_size(size_t n, size_t sz)\n-{\n-  return n != 0 ? n : (sz < 512 ? size_t(512 / sz) : size_t(1));\n-}\n-\n-#ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-template <class T, class Ref, class Ptr, size_t BufSiz>\n-struct __deque_iterator {\n-  typedef __deque_iterator<T, T&, T*, BufSiz>             iterator;\n-  typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;\n-  static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }\n-#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-template <class T, class Ref, class Ptr>\n-struct __deque_iterator {\n-  typedef __deque_iterator<T, T&, T*>             iterator;\n-  typedef __deque_iterator<T, const T&, const T*> const_iterator;\n-  static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }\n-#endif\n-\n-  typedef random_access_iterator_tag iterator_category;\n-  typedef T value_type;\n-  typedef Ptr pointer;\n-  typedef Ref reference;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n-  typedef T** map_pointer;\n-\n-  typedef __deque_iterator self;\n-\n-  T* cur;\n-  T* first;\n-  T* last;\n-  map_pointer node;\n-\n-  __deque_iterator(T* x, map_pointer y) \n-    : cur(x), first(*y), last(*y + buffer_size()), node(y) {}\n-  __deque_iterator() : cur(0), first(0), last(0), node(0) {}\n-  __deque_iterator(const iterator& x)\n-    : cur(x.cur), first(x.first), last(x.last), node(x.node) {}\n-\n-  reference operator*() const { return *cur; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-\n-  difference_type operator-(const self& x) const {\n-    return buffer_size() * (node - x.node - 1) +\n-      (cur - first) + (x.last - x.cur);\n-  }\n-\n-  self& operator++() {\n-    ++cur;\n-    if (cur == last) {\n-      set_node(node + 1);\n-      cur = first;\n-    }\n-    return *this; \n-  }\n-  self operator++(int)  {\n-    self tmp = *this;\n-    ++*this;\n-    return tmp;\n-  }\n-\n-  self& operator--() {\n-    if (cur == first) {\n-      set_node(node - 1);\n-      cur = last;\n-    }\n-    --cur;\n-    return *this;\n-  }\n-  self operator--(int) {\n-    self tmp = *this;\n-    --*this;\n-    return tmp;\n-  }\n-\n-  self& operator+=(difference_type n) {\n-    difference_type offset = n + (cur - first);\n-    if (offset >= 0 && offset < buffer_size())\n-      cur += n;\n-    else {\n-      difference_type node_offset =\n-        offset > 0 ? offset / buffer_size()\n-                   : -difference_type((-offset - 1) / buffer_size()) - 1;\n-      set_node(node + node_offset);\n-      cur = first + (offset - node_offset * buffer_size());\n-    }\n-    return *this;\n-  }\n-\n-  self operator+(difference_type n) const {\n-    self tmp = *this;\n-    return tmp += n;\n-  }\n-\n-  self& operator-=(difference_type n) { return *this += -n; }\n- \n-  self operator-(difference_type n) const {\n-    self tmp = *this;\n-    return tmp -= n;\n-  }\n-\n-  reference operator[](difference_type n) const { return *(*this + n); }\n-\n-  bool operator==(const self& x) const { return cur == x.cur; }\n-  bool operator!=(const self& x) const { return !(*this == x); }\n-  bool operator<(const self& x) const {\n-    return (node == x.node) ? (cur < x.cur) : (node < x.node);\n-  }\n-\n-  void set_node(map_pointer new_node) {\n-    node = new_node;\n-    first = *new_node;\n-    last = first + buffer_size();\n-  }\n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-#ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-\n-template <class T, class Ref, class Ptr, size_t BufSiz>\n-inline random_access_iterator_tag\n-iterator_category(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {\n-  return random_access_iterator_tag();\n-}\n-\n-template <class T, class Ref, class Ptr, size_t BufSiz>\n-inline T* value_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {\n-  return 0;\n-}\n-\n-template <class T, class Ref, class Ptr, size_t BufSiz>\n-inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {\n-  return 0;\n-}\n-\n-#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-\n-template <class T, class Ref, class Ptr>\n-inline random_access_iterator_tag\n-iterator_category(const __deque_iterator<T, Ref, Ptr>&) {\n-  return random_access_iterator_tag();\n-}\n-\n-template <class T, class Ref, class Ptr>\n-inline T* value_type(const __deque_iterator<T, Ref, Ptr>&) { return 0; }\n-\n-template <class T, class Ref, class Ptr>\n-inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr>&) {\n-  return 0;\n-}\n-\n-#endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-// See __deque_buf_size().  The only reason that the default value is 0\n-//  is as a workaround for bugs in the way that some compilers handle\n-//  constant expressions.\n-template <class T, class Alloc = alloc, size_t BufSiz = 0> \n-class deque {\n-public:                         // Basic types\n-  typedef T value_type;\n-  typedef value_type* pointer;\n-  typedef value_type& reference;\n-  typedef const value_type& const_reference;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n-\n-public:                         // Iterators\n-#ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-  typedef __deque_iterator<T, T&, T*, BufSiz>              iterator;\n-  typedef __deque_iterator<T, const T&, const T&, BufSiz>  const_iterator;\n-#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-  typedef __deque_iterator<T, T&, T*>                      iterator;\n-  typedef __deque_iterator<T, const T&, const T*>          const_iterator;\n-#endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-  typedef reverse_iterator<iterator> reverse_iterator;\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-  typedef reverse_iterator<const_iterator, value_type, const_reference, \n-                           difference_type>  \n-          const_reverse_iterator;\n-  typedef reverse_iterator<iterator, value_type, reference, difference_type>\n-          reverse_iterator; \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-protected:                      // Internal typedefs\n-  typedef pointer* map_pointer;\n-  typedef simple_alloc<value_type, Alloc> data_allocator;\n-  typedef simple_alloc<pointer, Alloc> map_allocator;\n-\n-  static size_type buffer_size() {\n-    return __deque_buf_size(BufSiz, sizeof(value_type));\n-  }\n-  static size_type initial_map_size() { return 8; }\n-\n-protected:                      // Data members\n-  iterator start;\n-  iterator finish;\n-\n-  map_pointer map;\n-  size_type map_size;\n-\n-public:                         // Basic accessors\n-  iterator begin() { return start; }\n-  iterator end() { return finish; }\n-  const_iterator begin() const { return start; }\n-  const_iterator end() const { return finish; }\n-\n-  reverse_iterator rbegin() { return reverse_iterator(finish); }\n-  reverse_iterator rend() { return reverse_iterator(start); }\n-  const_reverse_iterator rbegin() const {\n-    return const_reverse_iterator(finish);\n-  }\n-  const_reverse_iterator rend() const {\n-    return const_reverse_iterator(start);\n-  }\n-\n-  reference operator[](size_type n) { return start[n]; }\n-  const_reference operator[](size_type n) const { return start[n]; }\n-\n-  reference front() { return *start; }\n-  reference back() {\n-    iterator tmp = finish;\n-    --tmp;\n-    return *tmp;\n-  }\n-  const_reference front() const { return *start; }\n-  const_reference back() const {\n-    const_iterator tmp = finish;\n-    --tmp;\n-    return *tmp;\n-  }\n-\n-  size_type size() const { return finish - start;; }\n-  size_type max_size() const { return size_type(-1); }\n-  bool empty() const { return finish == start; }\n-\n-public:                         // Constructor, destructor.\n-  deque()\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    create_map_and_nodes(0);\n-  }\n-\n-  deque(const deque& x)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    create_map_and_nodes(x.size());\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      uninitialized_copy(x.begin(), x.end(), start);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_map_and_nodes();\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-\n-  deque(size_type n, const value_type& value)\n-    : start(), finish(), map(0), map_size(0) {\n-      fill_initialize(n, value);\n-  }\n-\n-  deque(int n, const value_type& value)\n-    : start(), finish(), map(0), map_size(0) {\n-      fill_initialize(n, value);\n-  }\n- \n-  deque(long n, const value_type& value)\n-    : start(), finish(), map(0), map_size(0) {\n-      fill_initialize(n, value);\n-  }\n-\n-  explicit deque(size_type n)\n-    : start(), finish(), map(0), map_size(0) {\n-    fill_initialize(n, value_type());\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-  template <class InputIterator>\n-  deque(InputIterator first, InputIterator last)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    range_initialize(first, last, iterator_category(first));\n-  }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  deque(const value_type* first, const value_type* last)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    create_map_and_nodes(last - first);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      uninitialized_copy(first, last, start);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_map_and_nodes();\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-\n-  deque(const_iterator first, const_iterator last)\n-    : start(), finish(), map(0), map_size(0)\n-  {\n-    create_map_and_nodes(last - first);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      uninitialized_copy(first, last, start);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_map_and_nodes();\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  ~deque() {\n-    destroy(start, finish);\n-    destroy_map_and_nodes();\n-  }\n-\n-  deque& operator= (const deque& x) {\n-    const size_type len = size();\n-    if (&x != this) {\n-      if (len >= x.size())\n-        erase(copy(x.begin(), x.end(), start), finish);\n-      else {\n-        const_iterator mid = x.begin() + len;\n-        copy(x.begin(), mid, start);\n-        insert(finish, mid, x.end());\n-      }\n-    }\n-    return *this;\n-  }        \n-\n-  void swap(deque& x) {\n-    ::swap(start, x.start);\n-    ::swap(finish, x.finish);\n-    ::swap(map, x.map);\n-    ::swap(map_size, x.map_size);\n-  }\n-\n-public:                         // push_* and pop_*\n-  \n-  void push_back(const value_type& t) {\n-    if (finish.cur != finish.last - 1) {\n-      construct(finish.cur, t);\n-      ++finish.cur;\n-    }\n-    else\n-      push_back_aux(t);\n-  }\n-\n-  void push_front(const value_type& t) {\n-    if (start.cur != start.first) {\n-      construct(start.cur - 1, t);\n-      --start.cur;\n-    }\n-    else\n-      push_front_aux(t);\n-  }\n-\n-  void pop_back() {\n-    if (finish.cur != finish.first) {\n-      --finish.cur;\n-      destroy(finish.cur);\n-    }\n-    else\n-      pop_back_aux();\n-  }\n-\n-  void pop_front() {\n-    if (start.cur != start.last - 1) {\n-      destroy(start.cur);\n-      ++start.cur;\n-    }\n-    else \n-      pop_front_aux();\n-  }\n-\n-public:                         // Insert\n-\n-  iterator insert(iterator position, const value_type& x) {\n-    if (position.cur == start.cur) {\n-      push_front(x);\n-      return start;\n-    }\n-    else if (position.cur == finish.cur) {\n-      push_back(x);\n-      iterator tmp = finish;\n-      --tmp;\n-      return tmp;\n-    }\n-    else {\n-      return insert_aux(position, x);\n-    }\n-  }\n-\n-  iterator insert(iterator position) { return insert(position, value_type()); }\n-\n-  void insert(iterator pos, size_type n, const value_type& x); \n-\n-  void insert(iterator pos, int n, const value_type& x) {\n-    insert(pos, (size_type) n, x);\n-  }\n-  void insert(iterator pos, long n, const value_type& x) {\n-    insert(pos, (size_type) n, x);\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n-  template <class InputIterator>\n-  void insert(iterator pos, InputIterator first, InputIterator last) {\n-    insert(pos, first, last, iterator_category(first));\n-  }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-  void insert(iterator pos, const value_type* first, const value_type* last);\n-  void insert(iterator pos, const_iterator first, const_iterator last);\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  void resize(size_type new_size, const value_type& x) {\n-    const size_type len = size();\n-    if (new_size < len) \n-      erase(start + new_size, finish);\n-    else\n-      insert(finish, new_size - len, x);\n-  }\n-\n-  void resize(size_type new_size) { resize(new_size, value_type()); }\n-\n-public:                         // Erase\n-  void erase(iterator pos) {\n-    iterator next = pos;\n-    ++next;\n-    if (pos - start < size() / 2) {\n-      copy_backward(start, pos, next);\n-      pop_front();\n-    }\n-    else {\n-      copy(next, finish, pos);\n-      pop_back();\n-    }\n-  }\n-\n-  void erase(iterator first, iterator last);\n-  void clear(); \n-\n-protected:                        // Internal construction/destruction\n-\n-  void create_map_and_nodes(size_type num_elements);\n-  void destroy_map_and_nodes();\n-  void fill_initialize(size_type n, const value_type& value);\n-\n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n-  template <class InputIterator>\n-  void range_initialize(InputIterator first, InputIterator last,\n-                        input_iterator_tag);\n-\n-  template <class ForwardIterator>\n-  void range_initialize(ForwardIterator first, ForwardIterator last,\n-                        forward_iterator_tag);\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-protected:                        // Internal push_* and pop_*\n-\n-  void push_back_aux(const value_type& t);\n-  void push_front_aux(const value_type& t);\n-  void pop_back_aux();\n-  void pop_front_aux();\n-\n-protected:                        // Internal insert functions\n-\n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n-  template <class InputIterator>\n-  void insert(iterator pos, InputIterator first, InputIterator last,\n-              input_iterator_tag);\n-\n-  template <class ForwardIterator>\n-  void insert(iterator pos, ForwardIterator first, ForwardIterator last,\n-              forward_iterator_tag);\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  iterator insert_aux(iterator pos, const value_type& x);\n-  void insert_aux(iterator pos, size_type n, const value_type& x);\n-\n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n-  template <class ForwardIterator>\n-  void insert_aux(iterator pos, ForwardIterator first, ForwardIterator last,\n-                  size_type n);\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-  \n-  void insert_aux(iterator pos,\n-                  const value_type* first, const value_type* last,\n-                  size_type n);\n-\n-  void insert_aux(iterator pos, const_iterator first, const_iterator last,\n-                  size_type n);\n- \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  iterator reserve_elements_at_front(size_type n) {\n-    size_type vacancies = start.cur - start.first;\n-    if (n > vacancies) \n-      new_elements_at_front(n - vacancies);\n-    return start - n;\n-  }\n-\n-  iterator reserve_elements_at_back(size_type n) {\n-    size_type vacancies = (finish.last - finish.cur) - 1;\n-    if (n > vacancies)\n-      new_elements_at_back(n - vacancies);\n-    return finish + n;\n-  }\n-\n-  void new_elements_at_front(size_type new_elements);\n-  void new_elements_at_back(size_type new_elements);\n-\n-  void destroy_nodes_at_front(iterator before_start);\n-  void destroy_nodes_at_back(iterator after_finish);\n-\n-protected:                      // Allocation of map and nodes\n-\n-  // Makes sure the map has space for new nodes.  Does not actually\n-  //  add the nodes.  Can invalidate map pointers.  (And consequently, \n-  //  deque iterators.)\n-\n-  void reserve_map_at_back (size_type nodes_to_add = 1) {\n-    if (nodes_to_add + 1 > map_size - (finish.node - map))\n-      reallocate_map(nodes_to_add, false);\n-  }\n-\n-  void reserve_map_at_front (size_type nodes_to_add = 1) {\n-    if (nodes_to_add > start.node - map)\n-      reallocate_map(nodes_to_add, true);\n-  }\n-\n-  void reallocate_map(size_type nodes_to_add, bool add_at_front);\n-\n-  pointer allocate_node() { return data_allocator::allocate(buffer_size()); }\n-  void deallocate_node(pointer n) {\n-    data_allocator::deallocate(n, buffer_size());\n-  }\n-\n-#ifdef __STL_NON_TYPE_TMPL_PARAM_BUG\n-public:\n-  bool operator==(const deque<T, Alloc, 0>& x) const {\n-    return size() == x.size() && equal(begin(), end(), x.begin());\n-  }\n-  bool operator!=(const deque<T, Alloc, 0>& x) const {\n-    return size() != x.size() || !equal(begin(), end(), x.begin());\n-  }\n-  bool operator<(const deque<T, Alloc, 0>& x) const {\n-    return lexicographical_compare(begin(), end(), x.begin(), x.end());\n-  }\n-#endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-};\n-\n-// Non-inline member functions\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert(iterator pos,\n-                                      size_type n, const value_type& x) {\n-  if (pos.cur == start.cur) {\n-    iterator new_start = reserve_elements_at_front(n);\n-    uninitialized_fill(new_start, start, x);\n-    start = new_start;\n-  }\n-  else if (pos.cur == finish.cur) {\n-    iterator new_finish = reserve_elements_at_back(n);\n-    uninitialized_fill(finish, new_finish, x);\n-    finish = new_finish;\n-  }\n-  else \n-    insert_aux(pos, n, x);\n-}\n-\n-#ifndef __STL_MEMBER_TEMPLATES  \n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert(iterator pos,\n-                                      const value_type* first,\n-                                      const value_type* last) {\n-  size_type n = last - first;\n-  if (pos.cur == start.cur) {\n-    iterator new_start = reserve_elements_at_front(n);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif\n-      uninitialized_copy(first, last, new_start);\n-      start = new_start;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_front(new_start);\n-      throw;\n-    }\n-#       endif\n-  }\n-  else if (pos.cur == finish.cur) {\n-    iterator new_finish = reserve_elements_at_back(n);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif\n-      uninitialized_copy(first, last, finish);\n-      finish = new_finish;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_back(new_finish);\n-      throw;\n-    }\n-#       endif\n-  }\n-  else\n-    insert_aux(pos, first, last, n);\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert(iterator pos,\n-                                      const_iterator first,\n-                                      const_iterator last)\n-{\n-  size_type n = last - first;\n-  if (pos.cur == start.cur) {\n-    iterator new_start = reserve_elements_at_front(n);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif\n-      uninitialized_copy(first, last, new_start);\n-      start = new_start;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_front(new_start);\n-      throw;\n-    }\n-#       endif      \n-  }\n-  else if (pos.cur == finish.cur) {\n-    iterator new_finish = reserve_elements_at_back(n);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif\n-      uninitialized_copy(first, last, finish);\n-      finish = new_finish;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_back(new_finish);\n-      throw;\n-    }\n-#       endif\n-  }\n-  else\n-    insert_aux(pos, first, last, n);\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::erase(iterator first, iterator last) {\n-  if (first == start && last == finish)\n-    clear();\n-  else {\n-    difference_type n = last - first;\n-    difference_type elems_before = first - start;\n-    if (elems_before < (size() - n) / 2) {\n-      copy_backward(start, first, last);\n-      iterator new_start = start + n;\n-      destroy(start, new_start);\n-      for (map_pointer cur = start.node; cur < new_start.node; ++cur)\n-        data_allocator::deallocate(*cur, buffer_size());\n-      start = new_start;\n-    }\n-    else {\n-      copy(last, finish, first);\n-      iterator new_finish = finish - n;\n-      destroy(new_finish, finish);\n-      for (map_pointer cur = new_finish.node + 1; cur <= finish.node; ++cur)\n-        data_allocator::deallocate(*cur, buffer_size());\n-      finish = new_finish;\n-    }\n-  }\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::clear() {\n-  for (map_pointer node = start.node + 1; node < finish.node; ++node) {\n-    destroy(*node, *node + buffer_size());\n-    data_allocator::deallocate(*node, buffer_size());\n-  }\n-\n-  if (start.node != finish.node) {\n-    destroy(start.cur, start.last);\n-    destroy(finish.first, finish.cur);\n-    data_allocator::deallocate(finish.first, buffer_size());\n-  }\n-  else\n-    destroy(start.cur, finish.cur);\n-\n-  finish = start;\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::create_map_and_nodes(size_type num_elements) {\n-  size_type num_nodes = num_elements / buffer_size() + 1;\n-\n-  map_size = max(initial_map_size(), num_nodes + 2);\n-  map = map_allocator::allocate(map_size);\n-\n-  map_pointer nstart = map + (map_size - num_nodes) / 2;\n-  map_pointer nfinish = nstart + num_nodes - 1;\n-    \n-  map_pointer cur;\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    for (cur = nstart; cur <= nfinish; ++cur)\n-      *cur = allocate_node();\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    for (map_pointer n = nstart; n < cur; ++n)\n-      deallocate_node(*n);\n-    map_allocator::deallocate(map, map_size);\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-\n-  start.set_node(nstart);\n-  finish.set_node(nfinish);\n-  start.cur = start.first;\n-  finish.cur = finish.first + num_elements % buffer_size();\n-}\n-\n-// This is only used as a cleanup function in catch clauses.\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::destroy_map_and_nodes() {\n-  for (map_pointer cur = start.node; cur <= finish.node; ++cur)\n-    deallocate_node(*cur);\n-  map_allocator::deallocate(map, map_size);\n-}\n-  \n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::fill_initialize(size_type n,\n-                                               const value_type& value) {\n-  create_map_and_nodes(n);\n-  map_pointer cur;\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    for (cur = start.node; cur < finish.node; ++cur)\n-      uninitialized_fill(*cur, *cur + buffer_size(), value);\n-    uninitialized_fill(finish.first, finish.cur, value);\n-#       ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    for (map_pointer n = start.node; n < cur; ++n)\n-      destroy(*n, *n + buffer_size());\n-    destroy_map_and_nodes();\n-    throw;\n-  }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n-template <class T, class Alloc, size_t BufSize>\n-template <class InputIterator>\n-void deque<T, Alloc, BufSize>::range_initialize(InputIterator first,\n-                                                InputIterator last,\n-                                                input_iterator_tag) {\n-  create_map_and_nodes(0);\n-  for ( ; first != last; ++first)\n-    push_back(*first);\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-template <class ForwardIterator>\n-void deque<T, Alloc, BufSize>::range_initialize(ForwardIterator first,\n-                                                ForwardIterator last,\n-                                                forward_iterator_tag) {\n-  size_type n = 0;\n-  distance(first, last, n);\n-  create_map_and_nodes(n);\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    uninitialized_copy(first, last, start);\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    destroy_map_and_nodes();\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-// Called only if finish.cur == finish.last - 1.\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::push_back_aux(const value_type& t) {\n-  value_type t_copy = t;\n-  reserve_map_at_back();\n-  *(finish.node + 1) = allocate_node();\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    construct(finish.cur, t_copy);\n-    finish.set_node(finish.node + 1);\n-    finish.cur = finish.first;\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    deallocate_node(*(finish.node + 1));\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-// Called only if start.cur == start.first.\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::push_front_aux(const value_type& t) {\n-  value_type t_copy = t;\n-  reserve_map_at_front();\n-  *(start.node - 1) = allocate_node();\n-#     ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#     endif /* __STL_USE_EXCEPTIONS */\n-    start.set_node(start.node - 1);\n-    start.cur = start.last - 1;\n-    construct(start.cur, t_copy);\n-#     ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    start.set_node(start.node + 1);\n-    start.cur = start.first;\n-    deallocate_node(*(start.node - 1));\n-    throw;\n-  }\n-#     endif /* __STL_USE_EXCEPTIONS */\n-} \n-\n-// Called only if finish.cur == finish.first.\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>:: pop_back_aux() {\n-  deallocate_node(finish.first);\n-  finish.set_node(finish.node - 1);\n-  finish.cur = finish.last - 1;\n-  destroy(finish.cur);\n-}\n-\n-// Called only if start.cur == start.last - 1.  Note that if the deque\n-//  has at least one element (a necessary precondition for this member\n-//  function), and if start.cur == start.last, then the deque must have\n-//  at least two nodes.\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::pop_front_aux() {\n-  destroy(start.cur);\n-  deallocate_node(start.first);\n-  start.set_node(start.node + 1);\n-  start.cur = start.first;\n-}      \n-\n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n-template <class T, class Alloc, size_t BufSize>\n-template <class InputIterator>\n-void deque<T, Alloc, BufSize>::insert(iterator pos,\n-                                      InputIterator first, InputIterator last,\n-                                      input_iterator_tag) {\n-  copy(first, last, inserter(*this, pos));\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-template <class ForwardIterator>\n-void deque<T, Alloc, BufSize>::insert(iterator pos,\n-                                      ForwardIterator first,\n-                                      ForwardIterator last,\n-                                      forward_iterator_tag) {\n-  size_type n = 0;\n-  distance(first, last, n);\n-  if (pos.cur == start.cur) {\n-    iterator new_start = reserve_elements_at_front(n);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif\n-      uninitialized_copy(first, last, new_start);\n-      start = new_start;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_front(new_start);\n-      throw;\n-    }\n-#       endif\n-  }\n-  else if (pos.cur == finish.cur) {\n-    iterator new_finish = reserve_elements_at_back(n);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif\n-      uninitialized_copy(first, last, finish);\n-      finish = new_finish;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_back(new_finish);\n-      throw;\n-    }\n-#       endif\n-  }\n-  else\n-    insert_aux(pos, first, last, n);\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-template <class T, class Alloc, size_t BufSize>\n-deque<T, Alloc, BufSize>::iterator\n-deque<T, Alloc, BufSize>::insert_aux(iterator pos, const value_type& x) {\n-  difference_type index = pos - start;\n-  value_type x_copy = x;\n-  if (index < size() / 2) {\n-    push_front(front());\n-    iterator front1 = start;\n-    ++front1;\n-    iterator front2 = front1;\n-    ++front2;\n-    pos = start + index;\n-    iterator pos1 = pos;\n-    ++pos1;\n-    copy(front2, pos1, front1);\n-  }\n-  else {\n-    push_back(back());\n-    iterator back1 = finish;\n-    --back1;\n-    iterator back2 = back1;\n-    --back2;\n-    pos = start + index;\n-    copy_backward(pos, back2, back1);\n-  }\n-  *pos = x_copy;\n-  return pos;\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert_aux(iterator pos,\n-                                          size_type n, const value_type& x) {\n-  const difference_type elems_before = pos - start;\n-  size_type length = size();\n-  value_type x_copy = x;\n-  if (elems_before < length / 2) {\n-    iterator new_start = reserve_elements_at_front(n);\n-    iterator old_start = start;\n-    pos = start + elems_before;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      if (elems_before >= n) {\n-        iterator start_n = start + n;\n-        uninitialized_copy(start, start_n, new_start);\n-        start = new_start;\n-        copy(start_n, pos, old_start);\n-        fill(pos - n, pos, x_copy);\n-      }\n-      else {\n-        __uninitialized_copy_fill(start, pos, new_start, start, x_copy);\n-        start = new_start;\n-        fill(old_start, pos, x_copy);\n-      }\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_front(new_start);\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-  else {\n-    iterator new_finish = reserve_elements_at_back(n);\n-    iterator old_finish = finish;\n-    const difference_type elems_after = length - elems_before;\n-    pos = finish - elems_after;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      if (elems_after > n) {\n-        iterator finish_n = finish - n;\n-        uninitialized_copy(finish_n, finish, finish);\n-        finish = new_finish;\n-        copy_backward(pos, finish_n, old_finish);\n-        fill(pos, pos + n, x_copy);\n-      }\n-      else {\n-        __uninitialized_fill_copy(finish, pos + n, x_copy, pos, finish);\n-        finish = new_finish;\n-        fill(pos, old_finish, x_copy);\n-      }\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_back(new_finish);\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */    \n-  }\n-}\n-\n-#ifdef __STL_MEMBER_TEMPLATES  \n-\n-template <class T, class Alloc, size_t BufSize>\n-template <class ForwardIterator>\n-void deque<T, Alloc, BufSize>::insert_aux(iterator pos,\n-                                          ForwardIterator first,\n-                                          ForwardIterator last,\n-                                          size_type n)\n-{\n-  const difference_type elems_before = pos - start;\n-  size_type length = size();\n-  if (elems_before < length / 2) {\n-    iterator new_start = reserve_elements_at_front(n);\n-    iterator old_start = start;\n-    pos = start + elems_before;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      if (elems_before >= n) {\n-        iterator start_n = start + n;      \n-        uninitialized_copy(start, start_n, new_start);\n-        start = new_start;\n-        copy(start_n, pos, old_start);\n-        copy(first, last, pos - n);\n-      }\n-      else {\n-        ForwardIterator mid = first;\n-        advance(mid, n - elems_before);\n-        __uninitialized_copy_copy(start, pos, first, mid, new_start);\n-        start = new_start;\n-        copy(mid, last, old_start);\n-      }\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_front(new_start);\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-  else {\n-    iterator new_finish = reserve_elements_at_back(n);\n-    iterator old_finish = finish;\n-    const difference_type elems_after = length - elems_before;\n-    pos = finish - elems_after;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      if (elems_after > n) {\n-        iterator finish_n = finish - n;\n-        uninitialized_copy(finish_n, finish, finish);\n-        finish = new_finish;\n-        copy_backward(pos, finish_n, old_finish);\n-        copy(first, last, pos);\n-      }\n-      else {\n-        ForwardIterator mid = first;\n-        advance(mid, elems_after);\n-        __uninitialized_copy_copy(mid, last, pos, finish, finish);\n-        finish = new_finish;\n-        copy(first, mid, pos);\n-      }\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_back(new_finish);\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-}\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert_aux(iterator pos,\n-                                          const value_type* first,\n-                                          const value_type* last,\n-                                          size_type n)\n-{\n-  const difference_type elems_before = pos - start;\n-  size_type length = size();\n-  if (elems_before < length / 2) {\n-    iterator new_start = reserve_elements_at_front(n);\n-    iterator old_start = start;\n-    pos = start + elems_before;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      if (elems_before >= n) {\n-        iterator start_n = start + n;\n-        uninitialized_copy(start, start_n, new_start);\n-        start = new_start;\n-        copy(start_n, pos, old_start);\n-        copy(first, last, pos - n);\n-      }\n-      else {\n-        const value_type* mid = first + (n - elems_before);\n-        __uninitialized_copy_copy(start, pos, first, mid, new_start);\n-        start = new_start;\n-        copy(mid, last, old_start);\n-      }\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_front(new_start);\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-  else {\n-    iterator new_finish = reserve_elements_at_back(n);\n-    iterator old_finish = finish;\n-    const difference_type elems_after = length - elems_before;\n-    pos = finish - elems_after;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      if (elems_after > n) {\n-        iterator finish_n = finish - n;\n-        uninitialized_copy(finish_n, finish, finish);\n-        finish = new_finish;\n-        copy_backward(pos, finish_n, old_finish);\n-        copy(first, last, pos);\n-      }\n-      else {\n-        const value_type* mid = first + elems_after;\n-        __uninitialized_copy_copy(mid, last, pos, finish, finish);\n-        finish = new_finish;\n-        copy(first, mid, pos);\n-      }\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_back(new_finish);\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::insert_aux(iterator pos,\n-                                          const_iterator first,\n-                                          const_iterator last,\n-                                          size_type n)\n-{\n-  const difference_type elems_before = pos - start;\n-  size_type length = size();\n-  if (elems_before < length / 2) {\n-    iterator new_start = reserve_elements_at_front(n);\n-    iterator old_start = start;\n-    pos = start + elems_before;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      if (elems_before >= n) {\n-        iterator start_n = start + n;\n-        uninitialized_copy(start, start_n, new_start);\n-        start = new_start;\n-        copy(start_n, pos, old_start);\n-        copy(first, last, pos - n);\n-      }\n-      else {\n-        const_iterator mid = first + (n - elems_before);\n-        __uninitialized_copy_copy(start, pos, first, mid, new_start);\n-        start = new_start;\n-        copy(mid, last, old_start);\n-      }\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_front(new_start);\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-  else {\n-    iterator new_finish = reserve_elements_at_back(n);\n-    iterator old_finish = finish;\n-    const difference_type elems_after = length - elems_before;\n-    pos = finish - elems_after;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      if (elems_after > n) {\n-        iterator finish_n = finish - n;\n-        uninitialized_copy(finish_n, finish, finish);\n-        finish = new_finish;\n-        copy_backward(pos, finish_n, old_finish);\n-        copy(first, last, pos);\n-      }\n-      else {\n-        const_iterator mid = first + elems_after;\n-        __uninitialized_copy_copy(mid, last, pos, finish, finish);\n-        finish = new_finish;\n-        copy(first, mid, pos);\n-      }\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      destroy_nodes_at_back(new_finish);\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::new_elements_at_front(size_type new_elements) {\n-  size_type new_nodes = (new_elements + buffer_size() - 1) / buffer_size();\n-  reserve_map_at_front(new_nodes);\n-  size_type i;\n-#       ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-    for (i = 1; i <= new_nodes; ++i)\n-      *(start.node - i) = allocate_node();\n-#       ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    for (size_type j = 1; j < i; ++j)\n-      deallocate_node(*(start.node - j));      \n-    throw;\n-  }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::new_elements_at_back(size_type new_elements) {\n-  size_type new_nodes = (new_elements + buffer_size() - 1) / buffer_size();\n-  reserve_map_at_back(new_nodes);\n-  size_type i;\n-#       ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-    for (i = 1; i <= new_nodes; ++i)\n-      *(finish.node + i) = allocate_node();\n-#       ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    for (size_type j = 1; j < i; ++j)\n-      deallocate_node(*(finish.node + j));      \n-    throw;\n-  }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::destroy_nodes_at_front(iterator before_start) {\n-  for (map_pointer n = before_start.node; n < start.node; ++n)\n-    deallocate_node(*n);\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::destroy_nodes_at_back(iterator after_finish) {\n-  for (map_pointer n = after_finish.node; n > finish.node; --n)\n-    deallocate_node(*n);\n-}\n-\n-template <class T, class Alloc, size_t BufSize>\n-void deque<T, Alloc, BufSize>::reallocate_map(size_type nodes_to_add,\n-                                              bool add_at_front) {\n-  size_type old_num_nodes = finish.node - start.node + 1;\n-  size_type new_num_nodes = old_num_nodes + nodes_to_add;\n-\n-  map_pointer new_nstart;\n-  if (map_size > 2 * new_num_nodes) {\n-    new_nstart = map + (map_size - new_num_nodes) / 2 \n-                     + (add_at_front ? nodes_to_add : 0);\n-    if (new_nstart < start.node)\n-      copy(start.node, finish.node + 1, new_nstart);\n-    else\n-      copy_backward(start.node, finish.node + 1, new_nstart + old_num_nodes);\n-  }\n-  else {\n-    size_type new_map_size = map_size + max(map_size, nodes_to_add) + 2;\n-\n-    map_pointer new_map = map_allocator::allocate(new_map_size);\n-    new_nstart = new_map + (new_map_size - new_num_nodes) / 2\n-                         + (add_at_front ? nodes_to_add : 0);\n-    copy(start.node, finish.node + 1, new_nstart);\n-    map_allocator::deallocate(map, map_size);\n-\n-    map = new_map;\n-    map_size = new_map_size;\n-  }\n-\n-  start.set_node(new_nstart);\n-  finish.set_node(new_nstart + old_num_nodes - 1);\n-}\n-\n-\n-// Nonmember functions.\n-\n-#ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-\n-template <class T, class Alloc, size_t BufSiz>\n-bool operator==(const deque<T, Alloc, BufSiz>& x,\n-                const deque<T, Alloc, BufSiz>& y) {\n-  return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());\n-}\n-\n-template <class T, class Alloc, size_t BufSiz>\n-bool operator<(const deque<T, Alloc, BufSiz>& x,\n-               const deque<T, Alloc, BufSiz>& y) {\n-  return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());\n-}\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::deque;\n+#endif /* __STL_USE_NAMESPACES */\n \n-#endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-           \n-  \n #endif /* __SGI_STL_DEQUE_H */\n \n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "6474dd99fa2e0546c5bcf730389e653914b19949", "filename": "libstdc++/stl/function.h", "status": "modified", "additions": 84, "deletions": 600, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Ffunction.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -27,608 +27,92 @@\n #ifndef __SGI_STL_FUNCTION_H\n #define __SGI_STL_FUNCTION_H\n \n-#include <stddef.h>\n+#ifndef __STL_CONFIG_H\n #include <stl_config.h>\n-\n-template <class T>\n-inline bool operator!=(const T& x, const T& y) {\n-    return !(x == y);\n-}\n-\n-template <class T>\n-inline bool operator>(const T& x, const T& y) {\n-    return y < x;\n-}\n-\n-template <class T>\n-inline bool operator<=(const T& x, const T& y) {\n-    return !(y < x);\n-}\n-\n-template <class T>\n-inline bool operator>=(const T& x, const T& y) {\n-    return !(x < y);\n-}\n-\n-template <class Arg, class Result>\n-struct unary_function {\n-    typedef Arg argument_type;\n-    typedef Result result_type;\n-};\n-\n-template <class Arg1, class Arg2, class Result>\n-struct binary_function {\n-    typedef Arg1 first_argument_type;\n-    typedef Arg2 second_argument_type;\n-    typedef Result result_type;\n-};      \n-\n-template <class T>\n-struct plus : public binary_function<T, T, T> {\n-    T operator()(const T& x, const T& y) const { return x + y; }\n-};\n-\n-template <class T>\n-struct minus : public binary_function<T, T, T> {\n-    T operator()(const T& x, const T& y) const { return x - y; }\n-};\n-\n-template <class T>\n-struct multiplies : public binary_function<T, T, T> {\n-    T operator()(const T& x, const T& y) const { return x * y; }\n-};\n-\n-template <class T>\n-struct divides : public binary_function<T, T, T> {\n-    T operator()(const T& x, const T& y) const { return x / y; }\n-};\n-\n-template <class T> inline T identity_element(plus<T>) { return T(0); }\n-\n-template <class T> inline T identity_element(multiplies<T>) { return T(1); }\n-\n-template <class T>\n-struct modulus : public binary_function<T, T, T> {\n-    T operator()(const T& x, const T& y) const { return x % y; }\n-};\n-\n-template <class T>\n-struct negate : public unary_function<T, T> {\n-    T operator()(const T& x) const { return -x; }\n-};\n-\n-template <class T>\n-struct equal_to : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x == y; }\n-};\n-\n-template <class T>\n-struct not_equal_to : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x != y; }\n-};\n-\n-template <class T>\n-struct greater : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x > y; }\n-};\n-\n-template <class T>\n-struct less : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x < y; }\n-};\n-\n-template <class T>\n-struct greater_equal : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x >= y; }\n-};\n-\n-template <class T>\n-struct less_equal : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x <= y; }\n-};\n-\n-template <class T>\n-struct logical_and : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x && y; }\n-};\n-\n-template <class T>\n-struct logical_or : public binary_function<T, T, bool> {\n-    bool operator()(const T& x, const T& y) const { return x || y; }\n-};\n-\n-template <class T>\n-struct logical_not : public unary_function<T, bool> {\n-    bool operator()(const T& x) const { return !x; }\n-};\n-\n-template <class Predicate>\n-class unary_negate\n-  : public unary_function<typename Predicate::argument_type, bool> {\n-protected:\n-    Predicate pred;\n-public:\n-    explicit unary_negate(const Predicate& x) : pred(x) {}\n-    bool operator()(const argument_type& x) const { return !pred(x); }\n-};\n-\n-template <class Predicate>\n-inline unary_negate<Predicate> not1(const Predicate& pred) {\n-  return unary_negate<Predicate>(pred);\n-}\n-\n-template <class Predicate> \n-class binary_negate \n-    : public binary_function<typename Predicate::first_argument_type,\n-\t\t\t     typename Predicate::second_argument_type,\n-                             bool> {\n-protected:\n-    Predicate pred;\n-public:\n-    explicit binary_negate(const Predicate& x) : pred(x) {}\n-    bool operator()(const first_argument_type& x, \n-\t\t    const second_argument_type& y) const {\n-\treturn !pred(x, y); \n-    }\n-};\n-\n-template <class Predicate>\n-inline binary_negate<Predicate> not2(const Predicate& pred) {\n-  return binary_negate<Predicate>(pred);\n-}\n-\n-template <class Operation> \n-class binder1st\n-  : public unary_function<typename Operation::second_argument_type,\n-                          typename Operation::result_type> {\n-protected:\n-    Operation op;\n-    typename Operation::first_argument_type value;\n-public:\n-    binder1st(const Operation& x,\n-              const typename Operation::first_argument_type& y)\n-      : op(x), value(y) {}\n-    result_type operator()(const argument_type& x) const {\n-\treturn op(value, x); \n-    }\n-};\n-\n-template <class Operation, class T>\n-inline binder1st<Operation> bind1st(const Operation& op, const T& x) {\n-  typedef typename Operation::first_argument_type arg1_type;\n-  return binder1st<Operation>(op, arg1_type(x));\n-}\n-\n-template <class Operation> \n-class binder2nd\n-  : public unary_function<typename Operation::first_argument_type,\n-\t\t\t  typename Operation::result_type> {\n-protected:\n-    Operation op;\n-    typename Operation::second_argument_type value;\n-public:\n-    binder2nd(const Operation& x,\n-              const typename Operation::second_argument_type& y) \n-\t: op(x), value(y) {}\n-    result_type operator()(const argument_type& x) const {\n-\treturn op(x, value); \n-    }\n-};\n-\n-template <class Operation, class T>\n-inline binder2nd<Operation> bind2nd(const Operation& op, const T& x) {\n-  typedef typename Operation::second_argument_type arg2_type;\n-  return binder2nd<Operation>(op, arg2_type(x));\n-}\n-\n-template <class Operation1, class Operation2>\n-class unary_compose : public unary_function<typename Operation2::argument_type,\n-                                            typename Operation1::result_type> {\n-protected:\n-    Operation1 op1;\n-    Operation2 op2;\n-public:\n-    unary_compose(const Operation1& x, const Operation2& y) : op1(x), op2(y) {}\n-    result_type operator()(const argument_type& x) const {\n-\treturn op1(op2(x));\n-    }\n-};\n-\n-template <class Operation1, class Operation2>\n-inline unary_compose<Operation1, Operation2> compose1(const Operation1& op1, \n-                                                      const Operation2& op2) {\n-  return unary_compose<Operation1, Operation2>(op1, op2);\n-}\n-\n-template <class Operation1, class Operation2, class Operation3>\n-class binary_compose\n-  : public unary_function<typename Operation2::argument_type,\n-                          typename Operation1::result_type> {\n-protected:\n-    Operation1 op1;\n-    Operation2 op2;\n-    Operation3 op3;\n-public:\n-    binary_compose(const Operation1& x, const Operation2& y, \n-\t\t   const Operation3& z) : op1(x), op2(y), op3(z) { }\n-    result_type operator()(const argument_type& x) const {\n-\treturn op1(op2(x), op3(x));\n-    }\n-};\n-\n-template <class Operation1, class Operation2, class Operation3>\n-inline binary_compose<Operation1, Operation2, Operation3> \n-compose2(const Operation1& op1, const Operation2& op2, const Operation3& op3) {\n-  return binary_compose<Operation1, Operation2, Operation3>(op1, op2, op3);\n-}\n-\n-template <class Arg, class Result>\n-class pointer_to_unary_function : public unary_function<Arg, Result> {\n-protected:\n-    Result (*ptr)(Arg);\n-public:\n-    pointer_to_unary_function() {}\n-    explicit pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}\n-    Result operator()(Arg x) const { return ptr(x); }\n-};\n-\n-template <class Arg, class Result>\n-inline pointer_to_unary_function<Arg, Result> ptr_fun(Result (*x)(Arg)) {\n-  return pointer_to_unary_function<Arg, Result>(x);\n-}\n-\n-template <class Arg1, class Arg2, class Result>\n-class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result> {\n-protected:\n-    Result (*ptr)(Arg1, Arg2);\n-public:\n-    pointer_to_binary_function() {}\n-    explicit pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(x) {}\n-    Result operator()(Arg1 x, Arg2 y) const { return ptr(x, y); }\n-};\n-\n-template <class Arg1, class Arg2, class Result>\n-inline pointer_to_binary_function<Arg1, Arg2, Result> \n-ptr_fun(Result (*x)(Arg1, Arg2)) {\n-  return pointer_to_binary_function<Arg1, Arg2, Result>(x);\n-}\n-\n-template <class T>\n-struct identity : public unary_function<T, T> {\n-    const T& operator()(const T& x) const { return x; }\n-};\n-\n-template <class Pair>\n-struct select1st : public unary_function<Pair, typename Pair::first_type> {\n-  const typename Pair::first_type& operator()(const Pair& x) const\n-  {\n-    return x.first;\n-  }\n-};\n-\n-template <class Pair>\n-struct select2nd : public unary_function<Pair, typename Pair::second_type> {\n-  const typename Pair::second_type& operator()(const Pair& x) const\n-  {\n-    return x.second;\n-  }\n-};\n-\n-template <class Arg1, class Arg2>\n-struct project1st : public binary_function<Arg1, Arg2, Arg1> {\n-  Arg1 operator()(const Arg1& x, const Arg2&) const { return x; }\n-};\n-\n-template <class Arg1, class Arg2>\n-struct project2nd : public binary_function<Arg1, Arg2, Arg2> {\n-  Arg2 operator()(const Arg1&, const Arg2& y) const { return y; }\n-};\n-\n-template <class Result>\n-struct constant_void_fun\n-{\n-  typedef Result result_type;\n-  result_type val;\n-  constant_void_fun(const result_type& v) : val(v) {}\n-  const result_type& operator()() const { return val; }\n-};  \n-\n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Result, class Argument = Result>\n-#else\n-template <class Result, class Argument>\n #endif\n-struct constant_unary_fun : public unary_function<Argument, Result> {\n-  result_type val;\n-  constant_unary_fun(const result_type& v) : val(v) {}\n-  const result_type& operator()(const argument_type&) const { return val; }\n-};\n-\n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Result, class Arg1 = Result, class Arg2 = Arg1>\n-#else\n-template <class Result, class Arg1, class Arg2>\n+#ifndef __SGI_STL_INTERNAL_RELOPS\n+#include <stl_relops.h>\n+#endif\n+#include <stddef.h>\n+#ifndef __SGI_STL_INTERNAL_FUNCTION_H\n+#include <stl_function.h>\n #endif\n-struct constant_binary_fun : public binary_function<Arg1, Arg2, Result> {\n-  result_type val;\n-  constant_binary_fun(const result_type& v) : val(v) {}\n-  const result_type& operator()(const first_argument_type&, \n-                                const second_argument_type&) const {\n-    return val;\n-  }\n-};\n-\n-template <class Result>\n-inline constant_void_fun<Result> constant0(const Result& val)\n-{\n-  return constant_void_fun<Result>(val);\n-}\n-\n-template <class Result>\n-inline constant_unary_fun<Result,Result> constant1(const Result& val)\n-{\n-  return constant_unary_fun<Result,Result>(val);\n-}\n-\n-template <class Result>\n-inline constant_binary_fun<Result,Result,Result> constant2(const Result& val)\n-{\n-  return constant_binary_fun<Result,Result,Result>(val);\n-}\n-\n-// Note: this code assumes that int is 32 bits.\n-class subtractive_rng : public unary_function<unsigned int, unsigned int> {\n-private:\n-  unsigned int table[55];\n-  size_t index1;\n-  size_t index2;\n-public:\n-  unsigned int operator()(unsigned int limit) {\n-    index1 = (index1 + 1) % 55;\n-    index2 = (index2 + 1) % 55;\n-    table[index1] = table[index1] - table[index2];\n-    return table[index1] % limit;\n-  }\n-\n-  void initialize(unsigned int seed)\n-  {\n-    unsigned int k = 1;\n-    table[54] = seed;\n-    size_t i;\n-    for (i = 0; i < 54; i++) {\n-        size_t ii = (21 * (i + 1) % 55) - 1;\n-        table[ii] = k;\n-        k = seed - k;\n-        seed = table[ii];\n-    }\n-    for (int loop = 0; loop < 4; loop++) {\n-        for (i = 0; i < 55; i++)\n-            table[i] = table[i] - table[(1 + i + 30) % 55];\n-    }\n-    index1 = 0;\n-    index2 = 31;\n-  }\n-\n-  subtractive_rng(unsigned int seed) { initialize(seed); }\n-  subtractive_rng() { initialize(161803398u); }\n-};\n-\n-\n-// Adaptor function objects: pointers to member functions.\n-\n-// There are a total of 16 = 2^4 function objects in this family.\n-//  (1) Member functions taking no arguments vs member functions taking\n-//       one argument.\n-//  (2) Call through pointer vs call through reference.\n-//  (3) Member function with void return type vs member function with\n-//      non-void return type.\n-//  (4) Const vs non-const member function.\n-\n-// Note that choice (4) is not present in the 8/97 draft C++ standard, \n-//  which only allows these adaptors to be used with non-const functions.\n-//  This is likely to be recified before the standard becomes final.\n-// Note also that choice (3) is nothing more than a workaround: according\n-//  to the draft, compilers should handle void and non-void the same way.\n-//  This feature is not yet widely implemented, though.  You can only use\n-//  member functions returning void if your compiler supports partial\n-//  specialization.\n-\n-// All of this complexity is in the function objects themselves.  You can\n-//  ignore it by using the helper function mem_fun, mem_fun_ref,\n-//  mem_fun1, and mem_fun1_ref, which create whichever type of adaptor\n-//  is appropriate.\n-\n-\n-template <class S, class T>\n-class mem_fun_t : public unary_function<T*, S> {\n-public:\n-  explicit mem_fun_t(S (T::*pf)()) : f(pf) {}\n-  S operator()(T* p) const { return (p->*f)(); }\n-private:\n-  S (T::*f)();\n-};\n-\n-template <class S, class T>\n-class const_mem_fun_t : public unary_function<const T*, S> {\n-public:\n-  explicit const_mem_fun_t(S (T::*pf)() const) : f(pf) {}\n-  S operator()(const T* p) const { return (p->*f)(); }\n-private:\n-  S (T::*f)() const;\n-};\n-\n-\n-template <class S, class T>\n-class mem_fun_ref_t : public unary_function<T, S> {\n-public:\n-  explicit mem_fun_ref_t(S (T::*pf)()) : f(pf) {}\n-  S operator()(T& r) const { return (r.*f)(); }\n-private:\n-  S (T::*f)();\n-};\n-\n-template <class S, class T>\n-class const_mem_fun_ref_t : public unary_function<T, S> {\n-public:\n-  explicit const_mem_fun_ref_t(S (T::*pf)() const) : f(pf) {}\n-  S operator()(const T& r) const { return (r.*f)(); }\n-private:\n-  S (T::*f)() const;\n-};\n-\n-template <class S, class T, class A>\n-class mem_fun1_t : public binary_function<T*, A, S> {\n-public:\n-  explicit mem_fun1_t(S (T::*pf)(A)) : f(pf) {}\n-  S operator()(T* p, A x) const { return (p->*f)(x); }\n-private:\n-  S (T::*f)(A);\n-};\n-\n-template <class S, class T, class A>\n-class const_mem_fun1_t : public binary_function<const T*, A, S> {\n-public:\n-  explicit const_mem_fun1_t(S (T::*pf)(A) const) : f(pf) {}\n-  S operator()(const T* p, A x) const { return (p->*f)(x); }\n-private:\n-  S (T::*f)(A) const;\n-};\n-\n-template <class S, class T, class A>\n-class mem_fun1_ref_t : public binary_function<T, A, S> {\n-public:\n-  explicit mem_fun1_ref_t(S (T::*pf)(A)) : f(pf) {}\n-  S operator()(T& r, A x) const { return (r.*f)(x); }\n-private:\n-  S (T::*f)(A);\n-};\n-\n-template <class S, class T, class A>\n-class const_mem_fun1_ref_t : public binary_function<T, A, S> {\n-public:\n-  explicit const_mem_fun1_ref_t(S (T::*pf)(A) const) : f(pf) {}\n-  S operator()(const T& r, A x) const { return (r.*f)(x); }\n-private:\n-  S (T::*f)(A) const;\n-};\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class T>\n-class mem_fun_t<void, T> : public unary_function<T*, void> {\n-public:\n-  explicit mem_fun_t(void (T::*pf)()) : f(pf) {}\n-  void operator()(T* p) const { (p->*f)(); }\n-private:\n-  void (T::*f)();\n-};\n-\n-template <class T>\n-class const_mem_fun_t<void, T> : public unary_function<const T*, void> {\n-public:\n-  explicit const_mem_fun_t(void (T::*pf)() const) : f(pf) {}\n-  void operator()(const T* p) const { (p->*f)(); }\n-private:\n-  void (T::*f)() const;\n-};\n-\n-template <class T>\n-class mem_fun_ref_t<void, T> : public unary_function<T, void> {\n-public:\n-  explicit mem_fun_ref_t(void (T::*pf)()) : f(pf) {}\n-  void operator()(T& r) const { (r.*f)(); }\n-private:\n-  void (T::*f)();\n-};\n-\n-template <class T>\n-class const_mem_fun_ref_t<void, T> : public unary_function<T, void> {\n-public:\n-  explicit const_mem_fun_ref_t(void (T::*pf)() const) : f(pf) {}\n-  void operator()(const T& r) const { (r.*f)(); }\n-private:\n-  void (T::*f)() const;\n-};\n-\n-template <class T, class A>\n-class mem_fun1_t<void, T, A> : public binary_function<T*, A, void> {\n-public:\n-  explicit mem_fun1_t(void (T::*pf)(A)) : f(pf) {}\n-  void operator()(T* p, A x) const { (p->*f)(x); }\n-private:\n-  void (T::*f)(A);\n-};\n-\n-template <class T, class A>\n-class const_mem_fun1_t<void, T, A> : public binary_function<const T*, A, void> {\n-public:\n-  explicit const_mem_fun1_t(void (T::*pf)(A) const) : f(pf) {}\n-  void operator()(const T* p, A x) const { (p->*f)(x); }\n-private:\n-  void (T::*f)(A) const;\n-};\n-\n-template <class T, class A>\n-class mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {\n-public:\n-  explicit mem_fun1_ref_t(void (T::*pf)(A)) : f(pf) {}\n-  void operator()(T& r, A x) const { (r.*f)(x); }\n-private:\n-  void (T::*f)(A);\n-};\n-\n-template <class T, class A>\n-class const_mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {\n-public:\n-  explicit const_mem_fun1_ref_t(void (T::*pf)(A) const) : f(pf) {}\n-  void operator()(const T& r, A x) const { (r.*f)(x); }\n-private:\n-  void (T::*f)(A) const;\n-};\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-// Mem_fun adaptor helper functions.  There are only four:\n-//  mem_fun, mem_fun_ref, mem_fun1, mem_fun1_ref.\n-\n-template <class S, class T>\n-inline mem_fun_t<S,T> mem_fun(S (T::*f)()) { \n-  return mem_fun_t<S,T>(f);\n-}\n-\n-template <class S, class T>\n-inline const_mem_fun_t<S,T> mem_fun(S (T::*f)() const) {\n-  return const_mem_fun_t<S,T>(f);\n-}\n-\n-template <class S, class T>\n-inline mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)()) { \n-  return mem_fun_ref_t<S,T>(f);\n-}\n-\n-template <class S, class T>\n-inline const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const) {\n-  return const_mem_fun_ref_t<S,T>(f);\n-}\n-\n-template <class S, class T, class A>\n-inline mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A)) { \n-  return mem_fun1_t<S,T,A>(f);\n-}\n-\n-template <class S, class T, class A>\n-inline const_mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A) const) {\n-  return const_mem_fun1_t<S,T,A>(f);\n-}\n-\n-template <class S, class T, class A>\n-inline mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A)) { \n-  return mem_fun1_ref_t<S,T,A>(f);\n-}\n \n-template <class S, class T, class A>\n-inline const_mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A) const) {\n-  return const_mem_fun1_ref_t<S,T,A>(f);\n-}\n+#ifdef __STL_USE_NAMESPACE_FOR_RELOPS\n+\n+// Names from stl_relops.h\n+using __STD_RELOPS::operator!=;\n+using __STD_RELOPS::operator>;\n+using __STD_RELOPS::operator<=;\n+using __STD_RELOPS::operator>=;\n+\n+#endif /* __STL_USE_NAMESPACE_FOR_RELOPS */\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from stl_function.h\n+using __STD::unary_function; \n+using __STD::binary_function; \n+using __STD::plus; \n+using __STD::minus; \n+using __STD::multiplies; \n+using __STD::divides; \n+using __STD::identity_element; \n+using __STD::modulus; \n+using __STD::negate; \n+using __STD::equal_to; \n+using __STD::not_equal_to; \n+using __STD::greater; \n+using __STD::less; \n+using __STD::greater_equal; \n+using __STD::less_equal; \n+using __STD::logical_and; \n+using __STD::logical_or; \n+using __STD::logical_not; \n+using __STD::unary_negate; \n+using __STD::binary_negate; \n+using __STD::not1; \n+using __STD::not2; \n+using __STD::binder1st; \n+using __STD::binder2nd; \n+using __STD::bind1st; \n+using __STD::bind2nd; \n+using __STD::unary_compose; \n+using __STD::binary_compose; \n+using __STD::compose1; \n+using __STD::compose2; \n+using __STD::pointer_to_unary_function; \n+using __STD::pointer_to_binary_function; \n+using __STD::ptr_fun; \n+using __STD::identity; \n+using __STD::select1st; \n+using __STD::select2nd; \n+using __STD::project1st; \n+using __STD::project2nd; \n+using __STD::constant_void_fun; \n+using __STD::constant_unary_fun; \n+using __STD::constant_binary_fun; \n+using __STD::constant0; \n+using __STD::constant1; \n+using __STD::constant2; \n+using __STD::subtractive_rng; \n+using __STD::mem_fun_t; \n+using __STD::const_mem_fun_t; \n+using __STD::mem_fun_ref_t; \n+using __STD::const_mem_fun_ref_t; \n+using __STD::mem_fun1_t; \n+using __STD::const_mem_fun1_t; \n+using __STD::mem_fun1_ref_t; \n+using __STD::const_mem_fun1_ref_t; \n+using __STD::mem_fun; \n+using __STD::mem_fun_ref; \n+using __STD::mem_fun1; \n+using __STD::mem_fun1_ref; \n+\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_FUNCTION_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "d046dbb036d67c6667976640a11c73beb26ac471", "filename": "libstdc++/stl/functional", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Ffunctional?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef __SGI_STL_FUNCTIONAL\n+#define __SGI_STL_FUNCTIONAL\n+\n+#include <stl_config.h>\n+#include <stddef.h>\n+#include <stl_function.h>\n+\n+#endif /* __SGI_STL_FUNCTIONAL */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "f7421e026fab01b342cf2f347543e23a7cb9c5c5", "filename": "libstdc++/stl/hash_map", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fhash_map?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef __SGI_STL_HASH_MAP\n+#define __SGI_STL_HASH_MAP\n+\n+#ifndef __SGI_STL_INTERNAL_HASHTABLE_H\n+#include <stl_hashtable.h>\n+#endif \n+\n+#include <stl_hash_map.h>\n+\n+#endif /* __SGI_STL_HASH_MAP */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "81cb5784f4741c28d61d4d11fcf7aa329e80e644", "filename": "libstdc++/stl/hash_map.h", "status": "modified", "additions": 14, "deletions": 285, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fhash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fhash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fhash_map.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -27,293 +27,22 @@\n #ifndef __SGI_STL_HASH_MAP_H\n #define __SGI_STL_HASH_MAP_H\n \n-#ifndef __SGI_STL_HASHTABLE_H\n-#include <hashtable.h>\n-#endif /* __SGI_STL_HASHTABLE_H */\n+#ifndef __SGI_STL_INTERNAL_HASHTABLE_H\n+#include <stl_hashtable.h>\n+#endif \n \n+#include <stl_hash_map.h>\n \n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class T, class HashFcn = hash<Key>,\n-          class EqualKey = equal_to<Key>,\n-          class Alloc = alloc>\n-#else\n-template <class Key, class T, class HashFcn, class EqualKey, \n-          class Alloc = alloc>\n-#endif\n-class hash_map\n-{\n-private:\n-  typedef hashtable<pair<const Key, T>, Key, HashFcn,\n-                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;\n-  ht rep;\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::hash;\n+using __STD::hashtable;\n+using __STD::hash_map;\n+using __STD::hash_multimap;\n+#endif /* __STL_USE_NAMESPACES */\n \n-public:\n-  typedef ht::key_type key_type;\n-  typedef ht::value_type value_type;\n-  typedef ht::hasher hasher;\n-  typedef ht::key_equal key_equal;\n-  typedef T data_type;\n-\n-  typedef ht::size_type size_type;\n-  typedef ht::difference_type difference_type;\n-  typedef ht::pointer pointer;\n-  typedef ht::const_pointer const_pointer;\n-  typedef ht::reference reference;\n-  typedef ht::const_reference const_reference;\n-\n-  typedef ht::iterator iterator;\n-  typedef ht::const_iterator const_iterator;\n-\n-  hasher hash_funct() const { return rep.hash_funct(); }\n-  key_equal key_eq() const { return rep.key_eq(); }\n-\n-public:\n-  hash_map() : rep(100, hasher(), key_equal()) {}\n-  explicit hash_map(size_type n) : rep(n, hasher(), key_equal()) {}\n-  hash_map(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n-  hash_map(size_type n, const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  hash_map(InputIterator f, InputIterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_map(InputIterator f, InputIterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_map(InputIterator f, InputIterator l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_map(InputIterator f, InputIterator l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n-\n-#else\n-  hash_map(const value_type* f, const value_type* l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const value_type* f, const value_type* l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const value_type* f, const value_type* l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const value_type* f, const value_type* l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n-\n-  hash_map(const_iterator f, const_iterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const_iterator f, const_iterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const_iterator f, const_iterator l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  hash_map(const_iterator f, const_iterator l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n-public:\n-  size_type size() const { return rep.size(); }\n-  size_type max_size() const { return rep.max_size(); }\n-  bool empty() const { return rep.empty(); }\n-  void swap(hash_map& hs) { rep.swap(hs.rep); }\n-  friend bool operator==(const hash_map<Key,T,HashFcn,EqualKey,Alloc>&,\n-                         const hash_map<Key,T,HashFcn,EqualKey,Alloc>&);\n-\n-  iterator begin() { return rep.begin(); }\n-  iterator end() { return rep.end(); }\n-  const_iterator begin() const { return rep.begin(); }\n-  const_iterator end() const { return rep.end(); }\n-\n-public:\n-  pair<iterator, bool> insert(const value_type& obj)\n-    { return rep.insert_unique(obj); }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }\n-#else\n-  void insert(const value_type* f, const value_type* l) {\n-    rep.insert_unique(f,l);\n-  }\n-  void insert(const_iterator f, const_iterator l) { rep.insert_unique(f, l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-  pair<iterator, bool> insert_noresize(const value_type& obj)\n-    { return rep.insert_unique_noresize(obj); }    \n-\n-  iterator find(const key_type& key) { return rep.find(key); }\n-  const_iterator find(const key_type& key) const { return rep.find(key); }\n-\n-  T& operator[](const key_type& key)\n-  {\n-    return rep.find_or_insert(value_type(key, T())).second;\n-  }\n-\n-  size_type count(const key_type& key) const { return rep.count(key); }\n-  \n-  pair<iterator, iterator> equal_range(const key_type& key)\n-    { return rep.equal_range(key); }\n-  pair<const_iterator, const_iterator> equal_range(const key_type& key) const\n-    { return rep.equal_range(key); }\n-\n-  size_type erase(const key_type& key) {return rep.erase(key); }\n-  void erase(iterator it) { rep.erase(it); }\n-  void erase(iterator f, iterator l) { rep.erase(f, l); }\n-  void clear() { rep.clear(); }\n-\n-public:\n-  void resize(size_type hint) { rep.resize(hint); }\n-  size_type bucket_count() const { return rep.bucket_count(); }\n-  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type n) const\n-    { return rep.elems_in_bucket(n); }\n-};\n-\n-template <class Key, class T, class HashFcn, class EqualKey, class Alloc>\n-inline bool operator==(const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,\n-                       const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm2)\n-{\n-  return hm1.rep == hm2.rep;\n-}\n-\n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class T, class HashFcn = hash<Key>,\n-          class EqualKey = equal_to<Key>,\n-          class Alloc = alloc>\n-#else\n-template <class Key, class T, class HashFcn, class EqualKey,\n-          class Alloc = alloc>\n-#endif\n-class hash_multimap\n-{\n-private:\n-  typedef hashtable<pair<const Key, T>, Key, HashFcn,\n-                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;\n-  ht rep;\n-\n-public:\n-  typedef ht::key_type key_type;\n-  typedef ht::value_type value_type;\n-  typedef ht::hasher hasher;\n-  typedef ht::key_equal key_equal;\n-  typedef T data_type;\n-\n-  typedef ht::size_type size_type;\n-  typedef ht::difference_type difference_type;\n-  typedef ht::pointer pointer;\n-  typedef ht::const_pointer const_pointer;\n-  typedef ht::reference reference;\n-  typedef ht::const_reference const_reference;\n-\n-  typedef ht::iterator iterator;\n-  typedef ht::const_iterator const_iterator;\n-\n-  hasher hash_funct() const { return rep.hash_funct(); }\n-  key_equal key_eq() const { return rep.key_eq(); }\n-\n-public:\n-  hash_multimap() : rep(100, hasher(), key_equal()) {}\n-  explicit hash_multimap(size_type n) : rep(n, hasher(), key_equal()) {}\n-  hash_multimap(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n-  hash_multimap(size_type n, const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  hash_multimap(InputIterator f, InputIterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multimap(InputIterator f, InputIterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multimap(InputIterator f, InputIterator l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multimap(InputIterator f, InputIterator l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n-\n-#else\n-  hash_multimap(const value_type* f, const value_type* l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const value_type* f, const value_type* l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const value_type* f, const value_type* l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const value_type* f, const value_type* l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n-\n-  hash_multimap(const_iterator f, const_iterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const_iterator f, const_iterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const_iterator f, const_iterator l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  hash_multimap(const_iterator f, const_iterator l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n-public:\n-  size_type size() const { return rep.size(); }\n-  size_type max_size() const { return rep.max_size(); }\n-  bool empty() const { return rep.empty(); }\n-  void swap(hash_multimap& hs) { rep.swap(hs.rep); }\n-  friend bool operator==(const hash_multimap<Key,T,HashFcn,EqualKey,Alloc>&,\n-                         const hash_multimap<Key,T,HashFcn,EqualKey,Alloc>&);\n-\n-  iterator begin() { return rep.begin(); }\n-  iterator end() { return rep.end(); }\n-  const_iterator begin() const { return rep.begin(); }\n-  const_iterator end() const { return rep.end(); }\n-\n-public:\n-  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }\n-#else\n-  void insert(const value_type* f, const value_type* l) {\n-    rep.insert_equal(f,l);\n-  }\n-  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-  iterator insert_noresize(const value_type& obj)\n-    { return rep.insert_equal_noresize(obj); }    \n-\n-  iterator find(const key_type& key) { return rep.find(key); }\n-  const_iterator find(const key_type& key) const { return rep.find(key); }\n-\n-  size_type count(const key_type& key) const { return rep.count(key); }\n-  \n-  pair<iterator, iterator> equal_range(const key_type& key)\n-    { return rep.equal_range(key); }\n-  pair<const_iterator, const_iterator> equal_range(const key_type& key) const\n-    { return rep.equal_range(key); }\n-\n-  size_type erase(const key_type& key) {return rep.erase(key); }\n-  void erase(iterator it) { rep.erase(it); }\n-  void erase(iterator f, iterator l) { rep.erase(f, l); }\n-  void clear() { rep.clear(); }\n-\n-public:\n-  void resize(size_type hint) { rep.resize(hint); }\n-  size_type bucket_count() const { return rep.bucket_count(); }\n-  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type n) const\n-    { return rep.elems_in_bucket(n); }\n-};\n-\n-template <class Key, class T, class HF, class EqKey, class Alloc>\n-inline bool operator==(const hash_multimap<Key, T, HF, EqKey, Alloc>& hm1,\n-                       const hash_multimap<Key, T, HF, EqKey, Alloc>& hm2)\n-{\n-  return hm1.rep == hm2.rep;\n-}\n \n #endif /* __SGI_STL_HASH_MAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "2244f47cfa01a796e121212ecaa645e95453d3b7", "filename": "libstdc++/stl/hash_set", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fhash_set?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef __SGI_STL_HASH_SET\n+#define __SGI_STL_HASH_SET\n+\n+#ifndef __SGI_STL_INTERNAL_HASHTABLE_H\n+#include <stl_hashtable.h>\n+#endif \n+\n+#include <stl_hash_set.h>\n+\n+#endif /* __SGI_STL_HASH_SET */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "c938ccc467abae3649c15b672f22f48b9acc1e75", "filename": "libstdc++/stl/hash_set.h", "status": "modified", "additions": 12, "deletions": 275, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fhash_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fhash_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fhash_set.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -27,280 +27,17 @@\n #ifndef __SGI_STL_HASH_SET_H\n #define __SGI_STL_HASH_SET_H\n \n-#ifndef __SGI_STL_HASHTABLE_H\n-#include <hashtable.h>\n-#endif /* __SGI_STL_HASHTABLE_H */\n-\n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Value, class HashFcn = hash<Value>,\n-          class EqualKey = equal_to<Value>,\n-          class Alloc = alloc>\n-#else\n-template <class Value, class HashFcn, class EqualKey, class Alloc = alloc>\n-#endif\n-class hash_set\n-{\n-private:\n-  typedef hashtable<Value, Value, HashFcn, identity<Value>, \n-                    EqualKey, Alloc> ht;\n-  ht rep;\n-\n-public:\n-  typedef ht::key_type key_type;\n-  typedef ht::value_type value_type;\n-  typedef ht::hasher hasher;\n-  typedef ht::key_equal key_equal;\n-\n-  typedef ht::size_type size_type;\n-  typedef ht::difference_type difference_type;\n-  typedef ht::const_pointer pointer;\n-  typedef ht::const_pointer const_pointer;\n-  typedef ht::const_reference reference;\n-  typedef ht::const_reference const_reference;\n-\n-  typedef ht::const_iterator iterator;\n-  typedef ht::const_iterator const_iterator;\n-\n-  hasher hash_funct() const { return rep.hash_funct(); }\n-  key_equal key_eq() const { return rep.key_eq(); }\n-\n-public:\n-  hash_set() : rep(100, hasher(), key_equal()) {}\n-  explicit hash_set(size_type n) : rep(n, hasher(), key_equal()) {}\n-  hash_set(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n-  hash_set(size_type n, const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  hash_set(InputIterator f, InputIterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_set(InputIterator f, InputIterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_set(InputIterator f, InputIterator l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  template <class InputIterator>\n-  hash_set(InputIterator f, InputIterator l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n-#else\n-\n-  hash_set(const value_type* f, const value_type* l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const value_type* f, const value_type* l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const value_type* f, const value_type* l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const value_type* f, const value_type* l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n-\n-  hash_set(const_iterator f, const_iterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const_iterator f, const_iterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const_iterator f, const_iterator l, size_type n,\n-           const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n-  hash_set(const_iterator f, const_iterator l, size_type n,\n-           const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n-public:\n-  size_type size() const { return rep.size(); }\n-  size_type max_size() const { return rep.max_size(); }\n-  bool empty() const { return rep.empty(); }\n-  void swap(hash_set& hs) { rep.swap(hs.rep); }\n-  friend bool operator==(const hash_set<Value,HashFcn,EqualKey,Alloc>&,\n-                         const hash_set<Value,HashFcn,EqualKey,Alloc>&);\n-\n-  iterator begin() const { return rep.begin(); }\n-  iterator end() const { return rep.end(); }\n-\n-public:\n-  pair<iterator, bool> insert(const value_type& obj)\n-    {\n-      pair<ht::iterator, bool> p = rep.insert_unique(obj);\n-      return pair<iterator, bool>(p.first, p.second);\n-    }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }\n-#else\n-  void insert(const value_type* f, const value_type* l) {\n-    rep.insert_unique(f,l);\n-  }\n-  void insert(const_iterator f, const_iterator l) {rep.insert_unique(f, l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-  pair<iterator, bool> insert_noresize(const value_type& obj)\n-    {\n-      pair<ht::iterator, bool> p = rep.insert_unique_noresize(obj);\n-      return pair<iterator, bool>(p.first, p.second);\n-    }\n-\n-  iterator find(const key_type& key) const { return rep.find(key); }\n-\n-  size_type count(const key_type& key) const { return rep.count(key); }\n-  \n-  pair<iterator, iterator> equal_range(const key_type& key) const\n-    { return rep.equal_range(key); }\n-\n-  size_type erase(const key_type& key) {return rep.erase(key); }\n-  void erase(iterator it) { rep.erase(it); }\n-  void erase(iterator f, iterator l) { rep.erase(f, l); }\n-  void clear() { rep.clear(); }\n-\n-public:\n-  void resize(size_type hint) { rep.resize(hint); }\n-  size_type bucket_count() const { return rep.bucket_count(); }\n-  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type n) const\n-    { return rep.elems_in_bucket(n); }\n-};\n-\n-template <class Value, class HashFcn, class EqualKey, class Alloc>\n-inline bool operator==(const hash_set<Value, HashFcn, EqualKey, Alloc>& hs1,\n-                       const hash_set<Value, HashFcn, EqualKey, Alloc>& hs2)\n-{\n-  return hs1.rep == hs2.rep;\n-}\n-\n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Value, class HashFcn = hash<Value>,\n-          class EqualKey = equal_to<Value>,\n-          class Alloc = alloc>\n-#else\n-template <class Value, class HashFcn, class EqualKey, class Alloc = alloc>\n-#endif\n-class hash_multiset\n-{\n-private:\n-  typedef hashtable<Value, Value, HashFcn, identity<Value>, \n-                    EqualKey, Alloc> ht;\n-  ht rep;\n-\n-public:\n-  typedef ht::key_type key_type;\n-  typedef ht::value_type value_type;\n-  typedef ht::hasher hasher;\n-  typedef ht::key_equal key_equal;\n-\n-  typedef ht::size_type size_type;\n-  typedef ht::difference_type difference_type;\n-  typedef ht::const_pointer pointer;\n-  typedef ht::const_pointer const_pointer;\n-  typedef ht::const_reference reference;\n-  typedef ht::const_reference const_reference;\n-\n-  typedef ht::const_iterator iterator;\n-  typedef ht::const_iterator const_iterator;\n-\n-  hasher hash_funct() const { return rep.hash_funct(); }\n-  key_equal key_eq() const { return rep.key_eq(); }\n-\n-public:\n-  hash_multiset() : rep(100, hasher(), key_equal()) {}\n-  explicit hash_multiset(size_type n) : rep(n, hasher(), key_equal()) {}\n-  hash_multiset(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n-  hash_multiset(size_type n, const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  hash_multiset(InputIterator f, InputIterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multiset(InputIterator f, InputIterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multiset(InputIterator f, InputIterator l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  template <class InputIterator>\n-  hash_multiset(InputIterator f, InputIterator l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n-#else\n-\n-  hash_multiset(const value_type* f, const value_type* l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const value_type* f, const value_type* l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const value_type* f, const value_type* l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const value_type* f, const value_type* l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n-\n-  hash_multiset(const_iterator f, const_iterator l)\n-    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const_iterator f, const_iterator l, size_type n)\n-    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const_iterator f, const_iterator l, size_type n,\n-                const hasher& hf)\n-    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n-  hash_multiset(const_iterator f, const_iterator l, size_type n,\n-                const hasher& hf, const key_equal& eql)\n-    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n-public:\n-  size_type size() const { return rep.size(); }\n-  size_type max_size() const { return rep.max_size(); }\n-  bool empty() const { return rep.empty(); }\n-  void swap(hash_multiset& hs) { rep.swap(hs.rep); }\n-  friend bool operator==(const hash_multiset<Value,HashFcn,EqualKey,Alloc>&,\n-                         const hash_multiset<Value,HashFcn,EqualKey,Alloc>&);\n-\n-  iterator begin() const { return rep.begin(); }\n-  iterator end() const { return rep.end(); }\n-\n-public:\n-  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }\n-#else\n-  void insert(const value_type* f, const value_type* l) {\n-    rep.insert_equal(f,l);\n-  }\n-  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-  iterator insert_noresize(const value_type& obj)\n-    { return rep.insert_equal_noresize(obj); }    \n-\n-  iterator find(const key_type& key) const { return rep.find(key); }\n-\n-  size_type count(const key_type& key) const { return rep.count(key); }\n-  \n-  pair<iterator, iterator> equal_range(const key_type& key) const\n-    { return rep.equal_range(key); }\n-\n-  size_type erase(const key_type& key) {return rep.erase(key); }\n-  void erase(iterator it) { rep.erase(it); }\n-  void erase(iterator f, iterator l) { rep.erase(f, l); }\n-  void clear() { rep.clear(); }\n-\n-public:\n-  void resize(size_type hint) { rep.resize(hint); }\n-  size_type bucket_count() const { return rep.bucket_count(); }\n-  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type n) const\n-    { return rep.elems_in_bucket(n); }\n-};\n-\n-template <class Val, class HashFcn, class EqualKey, class Alloc>\n-inline bool operator==(const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1,\n-                       const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs2)\n-{\n-  return hs1.rep == hs2.rep;\n-}\n-\n+#ifndef __SGI_STL_INTERNAL_HASHTABLE_H\n+#include <stl_hashtable.h>\n+#endif \n+\n+#include <stl_hash_set.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::hash;\n+using __STD::hashtable;\n+using __STD::hash_set;\n+using __STD::hash_multiset;\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_HASH_SET_H */"}, {"sha": "15dbfc91644100934cd601b4115a85f72a084903", "filename": "libstdc++/stl/hashtable.h", "status": "modified", "additions": 15, "deletions": 959, "changes": 974, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fhashtable.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -24,969 +24,25 @@\n  *\n  */\n \n+/* NOTE: This is an internal header file, included by other STL headers.\n+ *   You should not attempt to use it directly.\n+ */\n+\n #ifndef __SGI_STL_HASHTABLE_H\n #define __SGI_STL_HASHTABLE_H\n \n-// Hashtable class, used to implement the hashed associative containers\n-// hash_set, hash_map, hash_multiset, and hash_multimap.\n-\n-\n-#include <stdlib.h>\n-#include <stddef.h>\n+#include <stl_hashtable.h>\n #include <algo.h>\n+#include <alloc.h>\n #include <vector.h>\n \n-\n-template <class Key> struct hash { };\n-\n-inline size_t __stl_hash_string(const char* s)\n-{\n-  unsigned long h = 0; \n-  for ( ; *s; ++s)\n-    h = 5*h + *s;\n-  \n-  return size_t(h);\n-}\n-\n-struct hash<char*>\n-{\n-  size_t operator()(const char* s) const { return __stl_hash_string(s); }\n-};\n-\n-struct hash<const char*>\n-{\n-  size_t operator()(const char* s) const { return __stl_hash_string(s); }\n-};\n-\n-struct hash<char> {\n-  size_t operator()(char x) const { return x; }\n-};\n-struct hash<unsigned char> {\n-  size_t operator()(unsigned char x) const { return x; }\n-};\n-struct hash<signed char> {\n-  size_t operator()(unsigned char x) const { return x; }\n-};\n-struct hash<short> {\n-  size_t operator()(short x) const { return x; }\n-};\n-struct hash<unsigned short> {\n-  size_t operator()(unsigned short x) const { return x; }\n-};\n-struct hash<int> {\n-  size_t operator()(int x) const { return x; }\n-};\n-struct hash<unsigned int> {\n-  size_t operator()(unsigned int x) const { return x; }\n-};\n-struct hash<long> {\n-  size_t operator()(long x) const { return x; }\n-};\n-struct hash<unsigned long> {\n-  size_t operator()(unsigned long x) const { return x; }\n-};\n-\n-template <class Value>\n-struct __hashtable_node\n-{\n-  __hashtable_node* next;\n-  Value val;\n-};  \n-\n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey, class Alloc = alloc>\n-class hashtable;\n-\n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey, class Alloc>\n-struct __hashtable_iterator;\n-\n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey, class Alloc>\n-struct __hashtable_const_iterator;\n-\n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey, class Alloc>\n-struct __hashtable_iterator {\n-  typedef hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>\n-          hashtable;\n-  typedef __hashtable_iterator<Value, Key, HashFcn, \n-                               ExtractKey, EqualKey, Alloc>\n-          iterator;\n-  typedef __hashtable_const_iterator<Value, Key, HashFcn, \n-                                     ExtractKey, EqualKey, Alloc>\n-          const_iterator;\n-  typedef __hashtable_node<Value> node;\n-\n-  typedef forward_iterator_tag iterator_category;\n-  typedef Value value_type;\n-  typedef ptrdiff_t difference_type;\n-  typedef size_t size_type;\n-  typedef Value& reference;\n-  typedef Value* pointer;\n-\n-  node* cur;\n-  hashtable* ht;\n-\n-  __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {}\n-  __hashtable_iterator() {}\n-  reference operator*() const { return cur->val; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-  iterator& operator++();\n-  iterator operator++(int);\n-  bool operator==(const iterator& it) const { return cur == it.cur; }\n-  bool operator!=(const iterator& it) const { return cur != it.cur; }\n-};\n-\n-\n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey, class Alloc>\n-struct __hashtable_const_iterator {\n-  typedef hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>\n-          hashtable;\n-  typedef __hashtable_iterator<Value, Key, HashFcn, \n-                               ExtractKey, EqualKey, Alloc>\n-          iterator;\n-  typedef __hashtable_const_iterator<Value, Key, HashFcn, \n-                                     ExtractKey, EqualKey, Alloc>\n-          const_iterator;\n-  typedef __hashtable_node<Value> node;\n-\n-  typedef forward_iterator_tag iterator_category;\n-  typedef Value value_type;\n-  typedef ptrdiff_t difference_type;\n-  typedef size_t size_type;\n-  typedef const Value& reference;\n-  typedef const Value* pointer;\n-\n-  const node* cur;\n-  const hashtable* ht;\n-\n-  __hashtable_const_iterator(const node* n, const hashtable* tab)\n-    : cur(n), ht(tab) {}\n-  __hashtable_const_iterator() {}\n-  __hashtable_const_iterator(const iterator& it) : cur(it.cur), ht(it.ht) {}\n-  reference operator*() const { return cur->val; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-  const_iterator& operator++();\n-  const_iterator operator++(int);\n-  bool operator==(const const_iterator& it) const { return cur == it.cur; }\n-  bool operator!=(const const_iterator& it) const { return cur != it.cur; }\n-};\n-\n-// Note: assumes long is at least 32 bits.\n-static const int __stl_num_primes = 28;\n-static const unsigned long __stl_prime_list[__stl_num_primes] =\n-{\n-  53,         97,         193,       389,       769,\n-  1543,       3079,       6151,      12289,     24593,\n-  49157,      98317,      196613,    393241,    786433,\n-  1572869,    3145739,    6291469,   12582917,  25165843,\n-  50331653,   100663319,  201326611, 402653189, 805306457, \n-  1610612741, 3221225473, 4294967291\n-};\n-\n-inline unsigned long __stl_next_prime(unsigned long n)\n-{\n-  const unsigned long* first = __stl_prime_list;\n-  const unsigned long* last = __stl_prime_list + __stl_num_primes;\n-  const unsigned long* pos = lower_bound(first, last, n);\n-  return pos == last ? *(last - 1) : *pos;\n-}\n-\n-\n-template <class Value, class Key, class HashFcn,\n-          class ExtractKey, class EqualKey,\n-          class Alloc>\n-class hashtable {\n-public:\n-  typedef Key key_type;\n-  typedef Value value_type;\n-  typedef HashFcn hasher;\n-  typedef EqualKey key_equal;\n-\n-  typedef size_t            size_type;\n-  typedef ptrdiff_t         difference_type;\n-  typedef value_type*       pointer;\n-  typedef const value_type* const_pointer;\n-  typedef value_type&       reference;\n-  typedef const value_type& const_reference;\n-\n-  hasher hash_funct() const { return hash; }\n-  key_equal key_eq() const { return equals; }\n-\n-private:\n-  hasher hash;\n-  key_equal equals;\n-  ExtractKey get_key;\n-\n-  typedef __hashtable_node<Value> node;\n-  typedef simple_alloc<node, Alloc> node_allocator;\n-\n-  vector<node*,Alloc> buckets;\n-  size_type num_elements;\n-\n-public:\n-  typedef __hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, \n-                               Alloc>\n-  iterator;\n-\n-  typedef __hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey,\n-                                     Alloc>\n-  const_iterator;\n-\n-  friend struct\n-  __hashtable_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>;\n-  friend struct\n-  __hashtable_const_iterator<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>;\n-\n-public:\n-  hashtable(size_type n,\n-            const HashFcn&    hf,\n-            const EqualKey&   eql,\n-            const ExtractKey& ext)\n-    : hash(hf), equals(eql), get_key(ext), num_elements(0)\n-  {\n-    initialize_buckets(n);\n-  }\n-\n-  hashtable(size_type n,\n-            const HashFcn&    hf,\n-            const EqualKey&   eql)\n-    : hash(hf), equals(eql), get_key(ExtractKey()), num_elements(0)\n-  {\n-    initialize_buckets(n);\n-  }\n-\n-  hashtable(const hashtable& ht)\n-    : hash(ht.hash), equals(ht.equals), get_key(ht.get_key), num_elements(0)\n-  {\n-    copy_from(ht);\n-  }\n-\n-  hashtable& operator= (const hashtable& ht)\n-  {\n-    if (&ht != this) {\n-      clear();\n-      hash = ht.hash;\n-      equals = ht.equals;\n-      get_key = ht.get_key;\n-      copy_from(ht);\n-    }\n-    return *this;\n-  }\n-\n-  ~hashtable() { clear(); }\n-\n-  size_type size() const { return num_elements; }\n-  size_type max_size() const { return size_type(-1); }\n-  bool empty() const { return size() == 0; }\n-\n-  void swap(hashtable& ht)\n-  {\n-    ::swap(hash, ht.hash);\n-    ::swap(equals, ht.equals);\n-    ::swap(get_key, ht.get_key);\n-    buckets.swap(ht.buckets);\n-    ::swap(num_elements, ht.num_elements);\n-  }\n-\n-  iterator begin()\n-  { \n-    for (size_type n = 0; n < buckets.size(); ++n)\n-      if (buckets[n])\n-        return iterator(buckets[n], this);\n-    return end();\n-  }\n-\n-  iterator end() { return iterator(0, this); }\n-\n-  const_iterator begin() const\n-  {\n-    for (size_type n = 0; n < buckets.size(); ++n)\n-      if (buckets[n])\n-        return const_iterator(buckets[n], this);\n-    return end();\n-  }\n-\n-  const_iterator end() const { return const_iterator(0, this); }\n-\n-  friend bool operator== (const hashtable<Value, Key,\n-                                          HashFcn, ExtractKey, EqualKey,\n-                                          Alloc>&,\n-                          const hashtable<Value, Key,\n-                                          HashFcn, ExtractKey, EqualKey,\n-                                          Alloc>&);\n-\n-public:\n-\n-  size_type bucket_count() const { return buckets.size(); }\n-\n-  size_type max_bucket_count() const\n-    { return __stl_prime_list[__stl_num_primes - 1]; } \n-\n-  size_type elems_in_bucket(size_type bucket) const\n-  {\n-    size_type result = 0;\n-    for (node* cur = buckets[bucket]; cur; cur = cur->next)\n-      result += 1;\n-    return result;\n-  }\n-\n-  pair<iterator, bool> insert_unique(const value_type& obj)\n-  {\n-    resize(num_elements + 1);\n-    return insert_unique_noresize(obj);\n-  }\n-\n-  iterator insert_equal(const value_type& obj)\n-  {\n-    resize(num_elements + 1);\n-    return insert_equal_noresize(obj);\n-  }\n-\n-  pair<iterator, bool> insert_unique_noresize(const value_type& obj);\n-  iterator insert_equal_noresize(const value_type& obj);\n- \n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert_unique(InputIterator f, InputIterator l)\n-  {\n-    insert_unique(f, l, iterator_category(f));\n-  }\n-\n-  template <class InputIterator>\n-  void insert_equal(InputIterator f, InputIterator l)\n-  {\n-    insert_equal(f, l, iterator_category(f));\n-  }\n-\n-  template <class InputIterator>\n-  void insert_unique(InputIterator f, InputIterator l,\n-                     input_iterator_tag)\n-  {\n-    for ( ; f != l; ++f)\n-      insert_unique(*f);\n-  }\n-\n-  template <class InputIterator>\n-  void insert_equal(InputIterator f, InputIterator l,\n-                    input_iterator_tag)\n-  {\n-    for ( ; f != l; ++f)\n-      insert_equal(*f);\n-  }\n-\n-  template <class ForwardIterator>\n-  void insert_unique(ForwardIterator f, ForwardIterator l,\n-                     forward_iterator_tag)\n-  {\n-    size_type n = 0;\n-    distance(f, l, n);\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_unique_noresize(*f);\n-  }\n-\n-  template <class ForwardIterator>\n-  void insert_equal(ForwardIterator f, ForwardIterator l,\n-                    forward_iterator_tag)\n-  {\n-    size_type n = 0;\n-    distance(f, l, n);\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_equal_noresize(*f);\n-  }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert_unique(const value_type* f, const value_type* l)\n-  {\n-    size_type n = l - f;\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_unique_noresize(*f);\n-  }\n-\n-  void insert_equal(const value_type* f, const value_type* l)\n-  {\n-    size_type n = l - f;\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_equal_noresize(*f);\n-  }\n-\n-  void insert_unique(const_iterator f, const_iterator l)\n-  {\n-    size_type n = 0;\n-    distance(f, l, n);\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_unique_noresize(*f);\n-  }\n-\n-  void insert_equal(const_iterator f, const_iterator l)\n-  {\n-    size_type n = 0;\n-    distance(f, l, n);\n-    resize(num_elements + n);\n-    for ( ; n > 0; --n, ++f)\n-      insert_equal_noresize(*f);\n-  }\n-#endif /*__STL_MEMBER_TEMPLATES */\n-\n-  reference find_or_insert(const value_type& obj);\n-\n-  iterator find(const key_type& key) \n-  {\n-    size_type n = bkt_num_key(key);\n-    node* first;\n-    for ( first = buckets[n];\n-          first && !equals(get_key(first->val), key);\n-          first = first->next)\n-      {}\n-    return iterator(first, this);\n-  } \n-\n-  const_iterator find(const key_type& key) const\n-  {\n-    size_type n = bkt_num_key(key);\n-    const node* first;\n-    for ( first = buckets[n];\n-          first && !equals(get_key(first->val), key);\n-          first = first->next)\n-      {}\n-    return const_iterator(first, this);\n-  } \n-\n-  size_type count(const key_type& key) const\n-  {\n-    const size_type n = bkt_num_key(key);\n-    size_type result = 0;\n-\n-    for (const node* cur = buckets[n]; cur; cur = cur->next)\n-      if (equals(get_key(cur->val), key))\n-        ++result;\n-    return result;\n-  }\n-\n-  pair<iterator, iterator> equal_range(const key_type& key);\n-  pair<const_iterator, const_iterator> equal_range(const key_type& key) const;\n-\n-  size_type erase(const key_type& key);\n-  void erase(const iterator& it);\n-  void erase(iterator first, iterator last);\n-\n-  void erase(const const_iterator& it);\n-  void erase(const_iterator first, const_iterator last);\n-\n-  void resize(size_type num_elements_hint);\n-  void clear();\n-\n-private:\n-  size_type next_size(size_type n) const { return __stl_next_prime(n); }\n-\n-  void initialize_buckets(size_type n)\n-  {\n-    const size_type n_buckets = next_size(n);\n-    buckets.reserve(n_buckets);\n-    buckets.insert(buckets.end(), n_buckets, (node*) 0);\n-    num_elements = 0;\n-  }\n-\n-  size_type bkt_num_key(const key_type& key) const\n-  {\n-    return bkt_num_key(key, buckets.size());\n-  }\n-\n-  size_type bkt_num(const value_type& obj) const\n-  {\n-    return bkt_num_key(get_key(obj));\n-  }\n-\n-  size_type bkt_num_key(const key_type& key, size_t n) const\n-  {\n-    return hash(key) % n;\n-  }\n-\n-  size_type bkt_num(const value_type& obj, size_t n) const\n-  {\n-    return bkt_num_key(get_key(obj), n);\n-  }\n-\n-  node* new_node(const value_type& obj)\n-  {\n-    node* n = node_allocator::allocate();\n-    n->next = 0;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      construct(&n->val, obj);\n-      return n;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      node_allocator::deallocate(n);\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-  \n-  void delete_node(node* n)\n-  {\n-    destroy(&n->val);\n-    node_allocator::deallocate(n);\n-  }\n-\n-  void erase_bucket(const size_type n, node* first, node* last);\n-  void erase_bucket(const size_type n, node* last);\n-\n-  void copy_from(const hashtable& ht);\n-\n-};\n-\n-template <class V, class K, class HF, class ExK, class EqK, class A>\n-__hashtable_iterator<V, K, HF, ExK, EqK, A>&\n-__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++()\n-{\n-  const node* old = cur;\n-  cur = cur->next;\n-  if (!cur) {\n-    size_type bucket = ht->bkt_num(old->val);\n-    while (!cur && ++bucket < ht->buckets.size())\n-      cur = ht->buckets[bucket];\n-  }\n-  return *this;\n-}\n-\n-template <class V, class K, class HF, class ExK, class EqK, class A>\n-inline __hashtable_iterator<V, K, HF, ExK, EqK, A>\n-__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++(int)\n-{\n-  iterator tmp = *this;\n-  ++*this;\n-  return tmp;\n-}\n-\n-template <class V, class K, class HF, class ExK, class EqK, class A>\n-__hashtable_const_iterator<V, K, HF, ExK, EqK, A>&\n-__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++()\n-{\n-  const node* old = cur;\n-  cur = cur->next;\n-  if (!cur) {\n-    size_type bucket = ht->bkt_num(old->val);\n-    while (!cur && ++bucket < ht->buckets.size())\n-      cur = ht->buckets[bucket];\n-  }\n-  return *this;\n-}\n-\n-template <class V, class K, class HF, class ExK, class EqK, class A>\n-inline __hashtable_const_iterator<V, K, HF, ExK, EqK, A>\n-__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++(int)\n-{\n-  const_iterator tmp = *this;\n-  ++*this;\n-  return tmp;\n-}\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class V, class K, class HF, class ExK, class EqK, class All>\n-inline forward_iterator_tag\n-iterator_category(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)\n-{\n-  return forward_iterator_tag();\n-}\n-\n-template <class V, class K, class HF, class ExK, class EqK, class All>\n-inline V* value_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)\n-{\n-  return (V*) 0;\n-}\n-\n-template <class V, class K, class HF, class ExK, class EqK, class All>\n-inline hashtable<V, K, HF, ExK, EqK, All>::difference_type*\n-distance_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)\n-{\n-  return (hashtable<V, K, HF, ExK, EqK, All>::difference_type*) 0;\n-}\n-\n-template <class V, class K, class HF, class ExK, class EqK, class All>\n-inline forward_iterator_tag\n-iterator_category(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)\n-{\n-  return forward_iterator_tag();\n-}\n-\n-template <class V, class K, class HF, class ExK, class EqK, class All>\n-inline V* \n-value_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)\n-{\n-  return (V*) 0;\n-}\n-\n-template <class V, class K, class HF, class ExK, class EqK, class All>\n-inline hashtable<V, K, HF, ExK, EqK, All>::difference_type*\n-distance_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)\n-{\n-  return (hashtable<V, K, HF, ExK, EqK, All>::difference_type*) 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-bool operator==(const hashtable<V, K, HF, Ex, Eq, A>& ht1,\n-                const hashtable<V, K, HF, Ex, Eq, A>& ht2)\n-{\n-  typedef hashtable<V, K, HF, Ex, Eq, A>::node node;\n-  if (ht1.buckets.size() != ht2.buckets.size())\n-    return false;\n-  for (int n = 0; n < ht1.buckets.size(); ++n) {\n-    node* cur1 = ht1.buckets[n];\n-    node* cur2 = ht2.buckets[n];\n-    for ( ; cur1 && cur2 && cur1->val == cur2->val;\n-          cur1 = cur1->next, cur2 = cur2->next)\n-      {}\n-    if (cur1 || cur2)\n-      return false;\n-  }\n-  return true;\n-}  \n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-pair<hashtable<V, K, HF, Ex, Eq, A>::iterator, bool> \n-hashtable<V, K, HF, Ex, Eq, A>::insert_unique_noresize(const value_type& obj)\n-{\n-  const size_type n = bkt_num(obj);\n-  node* first = buckets[n];\n-\n-  for (node* cur = first; cur; cur = cur->next) \n-    if (equals(get_key(cur->val), get_key(obj)))\n-      return pair<iterator, bool>(iterator(cur, this), false);\n-\n-  node* tmp = new_node(obj);\n-  tmp->next = first;\n-  buckets[n] = tmp;\n-  ++num_elements;\n-  return pair<iterator, bool>(iterator(tmp, this), true);\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-hashtable<V, K, HF, Ex, Eq, A>::iterator \n-hashtable<V, K, HF, Ex, Eq, A>::insert_equal_noresize(const value_type& obj)\n-{\n-  const size_type n = bkt_num(obj);\n-  node* first = buckets[n];\n-\n-  for (node* cur = first; cur; cur = cur->next) \n-    if (equals(get_key(cur->val), get_key(obj))) {\n-      node* tmp = new_node(obj);\n-      tmp->next = cur->next;\n-      cur->next = tmp;\n-      ++num_elements;\n-      return iterator(tmp, this);\n-    }\n-\n-  node* tmp = new_node(obj);\n-  tmp->next = first;\n-  buckets[n] = tmp;\n-  ++num_elements;\n-  return iterator(tmp, this);\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-hashtable<V, K, HF, Ex, Eq, A>::reference \n-hashtable<V, K, HF, Ex, Eq, A>::find_or_insert(const value_type& obj)\n-{\n-  resize(num_elements + 1);\n-\n-  size_type n = bkt_num(obj);\n-  node* first = buckets[n];\n-\n-  for (node* cur = first; cur; cur = cur->next)\n-    if (equals(get_key(cur->val), get_key(obj)))\n-      return cur->val;\n-\n-  node* tmp = new_node(obj);\n-  tmp->next = first;\n-  buckets[n] = tmp;\n-  ++num_elements;\n-  return tmp->val;\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-pair<hashtable<V, K, HF, Ex, Eq, A>::iterator,\n-     hashtable<V, K, HF, Ex, Eq, A>::iterator> \n-hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key)\n-{\n-  typedef pair<iterator, iterator> pii;\n-  const size_type n = bkt_num_key(key);\n-\n-  for (node* first = buckets[n]; first; first = first->next) {\n-    if (equals(get_key(first->val), key)) {\n-      for (node* cur = first->next; cur; cur = cur->next)\n-        if (!equals(get_key(cur->val), key))\n-          return pii(iterator(first, this), iterator(cur, this));\n-      for (size_type m = n + 1; m < buckets.size(); ++m)\n-        if (buckets[m])\n-          return pii(iterator(first, this),\n-                     iterator(buckets[m], this));\n-      return pii(iterator(first, this), end());\n-    }\n-  }\n-  return pii(end(), end());\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-pair<hashtable<V, K, HF, Ex, Eq, A>::const_iterator, \n-     hashtable<V, K, HF, Ex, Eq, A>::const_iterator> \n-hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key) const\n-{\n-  typedef pair<const_iterator, const_iterator> pii;\n-  const size_type n = bkt_num_key(key);\n-\n-  for (const node* first = buckets[n] ; first; first = first->next) {\n-    if (equals(get_key(first->val), key)) {\n-      for (const node* cur = first->next; cur; cur = cur->next)\n-        if (!equals(get_key(cur->val), key))\n-          return pii(const_iterator(first, this),\n-                     const_iterator(cur, this));\n-      for (size_type m = n + 1; m < buckets.size(); ++m)\n-        if (buckets[m])\n-          return pii(const_iterator(first, this),\n-                     const_iterator(buckets[m], this));\n-      return pii(const_iterator(first, this), end());\n-    }\n-  }\n-  return pii(end(), end());\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-hashtable<V, K, HF, Ex, Eq, A>::size_type \n-hashtable<V, K, HF, Ex, Eq, A>::erase(const key_type& key)\n-{\n-  const size_type n = bkt_num_key(key);\n-  node* first = buckets[n];\n-  size_type erased = 0;\n-\n-  if (first) {\n-    node* cur = first;\n-    node* next = cur->next;\n-    while (next) {\n-      if (equals(get_key(next->val), key)) {\n-        cur->next = next->next;\n-        delete_node(next);\n-        next = cur->next;\n-        ++erased;\n-        --num_elements;\n-      }\n-      else {\n-        cur = next;\n-        next = cur->next;\n-      }\n-    }\n-    if (equals(get_key(first->val), key)) {\n-      buckets[n] = first->next;\n-      delete_node(first);\n-      ++erased;\n-      --num_elements;\n-    }\n-  }\n-  return erased;\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::erase(const iterator& it)\n-{\n-  if (node* const p = it.cur) {\n-    const size_type n = bkt_num(p->val);\n-    node* cur = buckets[n];\n-\n-    if (cur == p) {\n-      buckets[n] = cur->next;\n-      delete_node(cur);\n-      --num_elements;\n-    }\n-    else {\n-      node* next = cur->next;\n-      while (next) {\n-        if (next == p) {\n-          cur->next = next->next;\n-          delete_node(next);\n-          --num_elements;\n-          break;\n-        }\n-        else {\n-          cur = next;\n-          next = cur->next;\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::erase(iterator first, iterator last)\n-{\n-  size_type f_bucket = first.cur ? bkt_num(first.cur->val) : buckets.size();\n-  size_type l_bucket = last.cur ? bkt_num(last.cur->val) : buckets.size();\n-\n-  if (first.cur == last.cur)\n-    return;\n-  else if (f_bucket == l_bucket)\n-    erase_bucket(f_bucket, first.cur, last.cur);\n-  else {\n-    erase_bucket(f_bucket, first.cur, 0);\n-    for (size_type n = f_bucket + 1; n < l_bucket; ++n)\n-      erase_bucket(n, 0);\n-    if (l_bucket != buckets.size())\n-      erase_bucket(l_bucket, last.cur);\n-  }\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-inline void\n-hashtable<V, K, HF, Ex, Eq, A>::erase(const_iterator first,\n-                                      const_iterator last)\n-{\n-  erase(iterator(const_cast<hashtable::node*>(first.cur),\n-                 const_cast<hashtable*>(first.ht)),\n-        iterator(const_cast<hashtable::node*>(last.cur),\n-                 const_cast<hashtable*>(last.ht)));\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-inline void\n-hashtable<V, K, HF, Ex, Eq, A>::erase(const const_iterator& it)\n-{\n-  erase(iterator(const_cast<hashtable::node*>(it.cur),\n-                 const_cast<hashtable*>(it.ht)));\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::resize(size_type num_elements_hint)\n-{\n-  const size_type old_n = buckets.size();\n-  if (num_elements_hint > old_n) {\n-    const size_type n = next_size(num_elements_hint);\n-    if (n > old_n) {\n-      vector<node*, A> tmp(n, (node*) 0);\n-#         ifdef __STL_USE_EXCEPTIONS\n-      try {\n-#         endif /* __STL_USE_EXCEPTIONS */\n-        for (size_type bucket = 0; bucket < old_n; ++bucket) {\n-          node* first = buckets[bucket];\n-          while (first) {\n-            size_type new_bucket = bkt_num(first->val, n);\n-            buckets[bucket] = first->next;\n-            first->next = tmp[new_bucket];\n-            tmp[new_bucket] = first;\n-            first = buckets[bucket];          \n-          }\n-        }\n-        buckets.swap(tmp);\n-#         ifdef __STL_USE_EXCEPTIONS\n-      }\n-      catch(...) {\n-        for (size_type bucket = 0; bucket < tmp.size(); ++bucket) {\n-          while (tmp[bucket]) {\n-            node* next = tmp[bucket]->next;\n-            delete_node(tmp[bucket]);\n-            tmp[bucket] = next;\n-          }\n-        }\n-        throw;\n-      }\n-#         endif /* __STL_USE_EXCEPTIONS */\n-    }\n-  }\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, \n-                                                  node* first, node* last)\n-{\n-  node* cur = buckets[n];\n-  if (cur == first)\n-    erase_bucket(n, last);\n-  else {\n-    node* next;\n-    for (next = cur->next; next != first; cur = next, next = cur->next)\n-      ;\n-    while (next) {\n-      cur->next = next->next;\n-      delete_node(next);\n-      next = cur->next;\n-      --num_elements;\n-    }\n-  }\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void \n-hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, node* last)\n-{\n-  node* cur = buckets[n];\n-  while (cur != last) {\n-    node* next = cur->next;\n-    delete_node(cur);\n-    cur = next;\n-    buckets[n] = cur;\n-    --num_elements;\n-  }\n-}\n-\n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::clear()\n-{\n-  for (size_type i = 0; i < buckets.size(); ++i) {\n-    node* cur = buckets[i];\n-    while (cur != 0) {\n-      node* next = cur->next;\n-      delete_node(cur);\n-      cur = next;\n-    }\n-    buckets[i] = 0;\n-  }\n-  num_elements = 0;\n-}\n-\n-    \n-template <class V, class K, class HF, class Ex, class Eq, class A>\n-void hashtable<V, K, HF, Ex, Eq, A>::copy_from(const hashtable& ht)\n-{\n-  buckets.clear();\n-  buckets.reserve(ht.buckets.size());\n-  buckets.insert(buckets.end(), ht.buckets.size(), (node*) 0);\n-#   ifdef __STL_USE_EXCEPTIONS\n-  try {\n-#   endif /* __STL_USE_EXCEPTIONS */\n-    for (size_type i = 0; i < ht.buckets.size(); ++i) {\n-      if (const node* cur = ht.buckets[i]) {\n-        node* copy = new_node(cur->val);\n-        buckets[i] = copy;\n-\n-        for (node* next = cur->next; next; cur = next, next = cur->next) {\n-          copy->next = new_node(next->val);\n-          copy = copy->next;\n-        }\n-      }\n-    }\n-    num_elements = ht.num_elements;\n-#   ifdef __STL_USE_EXCEPTIONS\n-  }\n-  catch(...) {\n-    clear();\n-    throw;\n-  }\n-#   endif /* __STL_USE_EXCEPTIONS */\n-}\n-\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::hash;\n+using __STD::hashtable;\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_HASHTABLE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "2ec93c07b765b826496466042ce9f49a19ee5bda", "filename": "libstdc++/stl/heap.h", "status": "modified", "additions": 22, "deletions": 180, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fheap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fheap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fheap.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -11,194 +11,36 @@\n  * representations about the suitability of this software for any\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n \n #ifndef __SGI_STL_HEAP_H\n #define __SGI_STL_HEAP_H\n \n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma set woff 1209\n-#endif\n-\n-template <class RandomAccessIterator, class Distance, class T>\n-void __push_heap(RandomAccessIterator first, Distance holeIndex,\n-\t\t Distance topIndex, T value) {\n-    Distance parent = (holeIndex - 1) / 2;\n-    while (holeIndex > topIndex && *(first + parent) < value) {\n-\t*(first + holeIndex) = *(first + parent);\n-\tholeIndex = parent;\n-\tparent = (holeIndex - 1) / 2;\n-    }    \n-    *(first + holeIndex) = value;\n-}\n-\n-template <class RandomAccessIterator, class Distance, class T>\n-inline void __push_heap_aux(RandomAccessIterator first,\n-\t\t\t    RandomAccessIterator last, Distance*, T*) {\n-    __push_heap(first, Distance((last - first) - 1), Distance(0), \n-\t\tT(*(last - 1)));\n-}\n-\n-template <class RandomAccessIterator>\n-inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) {\n-    __push_heap_aux(first, last, distance_type(first), value_type(first));\n-}\n-\n-template <class RandomAccessIterator, class Distance, class T, class Compare>\n-void __push_heap(RandomAccessIterator first, Distance holeIndex,\n-\t\t Distance topIndex, T value, Compare comp) {\n-    Distance parent = (holeIndex - 1) / 2;\n-    while (holeIndex > topIndex && comp(*(first + parent), value)) {\n-\t*(first + holeIndex) = *(first + parent);\n-\tholeIndex = parent;\n-\tparent = (holeIndex - 1) / 2;\n-    }\n-    *(first + holeIndex) = value;\n-}\n-\n-template <class RandomAccessIterator, class Compare, class Distance, class T>\n-inline void __push_heap_aux(RandomAccessIterator first,\n-\t\t\t    RandomAccessIterator last, Compare comp,\n-\t\t\t    Distance*, T*) {\n-    __push_heap(first, Distance((last - first) - 1), Distance(0), \n-\t\tT(*(last - 1)), comp);\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-inline void push_heap(RandomAccessIterator first, RandomAccessIterator last,\n-\t\t      Compare comp) {\n-    __push_heap_aux(first, last, comp, distance_type(first), value_type(first));\n-}\n+#include <stl_config.h>\n+#include <stl_heap.h>\n \n-template <class RandomAccessIterator, class Distance, class T>\n-void __adjust_heap(RandomAccessIterator first, Distance holeIndex,\n-\t\t   Distance len, T value) {\n-    Distance topIndex = holeIndex;\n-    Distance secondChild = 2 * holeIndex + 2;\n-    while (secondChild < len) {\n-\tif (*(first + secondChild) < *(first + (secondChild - 1)))\n-\t    secondChild--;\n-\t*(first + holeIndex) = *(first + secondChild);\n-\tholeIndex = secondChild;\n-\tsecondChild = 2 * (secondChild + 1);\n-    }\n-    if (secondChild == len) {\n-\t*(first + holeIndex) = *(first + (secondChild - 1));\n-\tholeIndex = secondChild - 1;\n-    }\n-    __push_heap(first, holeIndex, topIndex, value);\n-}\n+#ifdef __STL_USE_NAMESPACES\n \n-template <class RandomAccessIterator, class T, class Distance>\n-inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,\n-\t\t       RandomAccessIterator result, T value, Distance*) {\n-    *result = *first;\n-    __adjust_heap(first, Distance(0), Distance(last - first), value);\n-}\n+using __STD::push_heap;\n+using __STD::pop_heap;\n+using __STD::make_heap;\n+using __STD::sort_heap;\n \n-template <class RandomAccessIterator, class T>\n-inline void __pop_heap_aux(RandomAccessIterator first,\n-\t\t\t   RandomAccessIterator last, T*) {\n-    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), distance_type(first));\n-}\n+#endif /* __STL_USE_NAMESPACES */\n \n-template <class RandomAccessIterator>\n-inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) {\n-    __pop_heap_aux(first, last, value_type(first));\n-}\n-\n-template <class RandomAccessIterator, class Distance, class T, class Compare>\n-void __adjust_heap(RandomAccessIterator first, Distance holeIndex,\n-\t\t   Distance len, T value, Compare comp) {\n-    Distance topIndex = holeIndex;\n-    Distance secondChild = 2 * holeIndex + 2;\n-    while (secondChild < len) {\n-\tif (comp(*(first + secondChild), *(first + (secondChild - 1))))\n-\t    secondChild--;\n-\t*(first + holeIndex) = *(first + secondChild);\n-\tholeIndex = secondChild;\n-\tsecondChild = 2 * (secondChild + 1);\n-    }\n-    if (secondChild == len) {\n-\t*(first + holeIndex) = *(first + (secondChild - 1));\n-\tholeIndex = secondChild - 1;\n-    }\n-    __push_heap(first, holeIndex, topIndex, value, comp);\n-}\n-\n-template <class RandomAccessIterator, class T, class Compare, class Distance>\n-inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,\n-\t\t       RandomAccessIterator result, T value, Compare comp,\n-\t\t       Distance*) {\n-    *result = *first;\n-    __adjust_heap(first, Distance(0), Distance(last - first), value, comp);\n-}\n-\n-template <class RandomAccessIterator, class T, class Compare>\n-inline void __pop_heap_aux(RandomAccessIterator first,\n-\t\t\t   RandomAccessIterator last, T*, Compare comp) {\n-    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), comp,\n-\t       distance_type(first));\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last,\n-\t\t     Compare comp) {\n-    __pop_heap_aux(first, last, value_type(first), comp);\n-}\n-\n-template <class RandomAccessIterator, class T, class Distance>\n-void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,\n-\t\t Distance*) {\n-    if (last - first < 2) return;\n-    Distance len = last - first;\n-    Distance parent = (len - 2)/2;\n-    \n-    while (true) {\n-\t__adjust_heap(first, parent, len, T(*(first + parent)));\n-\tif (parent == 0) return;\n-\tparent--;\n-    }\n-}\n-\n-template <class RandomAccessIterator>\n-inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) {\n-    __make_heap(first, last, value_type(first), distance_type(first));\n-}\n-\n-template <class RandomAccessIterator, class Compare, class T, class Distance>\n-void __make_heap(RandomAccessIterator first, RandomAccessIterator last,\n-\t\t Compare comp, T*, Distance*) {\n-    if (last - first < 2) return;\n-    Distance len = last - first;\n-    Distance parent = (len - 2)/2;\n-    \n-    while (true) {\n-\t__adjust_heap(first, parent, len, T(*(first + parent)), comp);\n-\tif (parent == 0) return;\n-\tparent--;\n-    }\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-inline void make_heap(RandomAccessIterator first, RandomAccessIterator last,\n-\t\t      Compare comp) {\n-    __make_heap(first, last, comp, value_type(first), distance_type(first));\n-}\n-\n-template <class RandomAccessIterator>\n-void sort_heap(RandomAccessIterator first, RandomAccessIterator last) {\n-    while (last - first > 1) pop_heap(first, last--);\n-}\n-\n-template <class RandomAccessIterator, class Compare>\n-void sort_heap(RandomAccessIterator first, RandomAccessIterator last,\n-\t       Compare comp) {\n-    while (last - first > 1) pop_heap(first, last--, comp);\n-}\n-\n-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n-#pragma reset woff 1209\n-#endif\n \n #endif /* __SGI_STL_HEAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "90e6c9c8b680d96bc5625eaeb760b42e9d388f6a", "filename": "libstdc++/stl/iterator", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fiterator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fiterator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fiterator?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,40 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_ITERATOR\n+#define __SGI_STL_ITERATOR\n+\n+#include <stl_config.h>\n+#include <stl_relops.h>\n+#include <stddef.h>\n+#include <iostream.h>\n+#include <stl_iterator.h>\n+\n+#endif /* __SGI_STL_ITERATOR */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "f8a023774228f5aeece1c575a4ba6d1719de10c7", "filename": "libstdc++/stl/iterator.h", "status": "modified", "additions": 54, "deletions": 741, "changes": 795, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fiterator.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -27,765 +27,78 @@\n #ifndef __SGI_STL_ITERATOR_H\n #define __SGI_STL_ITERATOR_H\n \n+#ifndef __SGI_STL_FUNCTION_H\n+#include <function.h>\n+#endif\n #include <stddef.h>\n #include <iostream.h>\n-#include <function.h>\n-\n-struct input_iterator_tag {};\n-struct output_iterator_tag {};\n-struct forward_iterator_tag : public input_iterator_tag {};\n-struct bidirectional_iterator_tag : public forward_iterator_tag {};\n-struct random_access_iterator_tag : public bidirectional_iterator_tag {};\n-\n-template <class T, class Distance> struct input_iterator {\n-  typedef input_iterator_tag iterator_category;\n-  typedef T                  value_type;\n-  typedef Distance           difference_type;\n-  typedef T*                 pointer;\n-  typedef T&                 reference;\n-};\n-\n-struct output_iterator {\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-};\n-\n-template <class T, class Distance> struct forward_iterator {\n-  typedef forward_iterator_tag iterator_category;\n-  typedef T                    value_type;\n-  typedef Distance             difference_type;\n-  typedef T*                   pointer;\n-  typedef T&                   reference;\n-};\n-\n-\n-template <class T, class Distance> struct bidirectional_iterator {\n-  typedef bidirectional_iterator_tag iterator_category;\n-  typedef T                          value_type;\n-  typedef Distance                   difference_type;\n-  typedef T*                         pointer;\n-  typedef T&                         reference;\n-};\n-\n-template <class T, class Distance> struct random_access_iterator {\n-  typedef random_access_iterator_tag iterator_category;\n-  typedef T                          value_type;\n-  typedef Distance                   difference_type;\n-  typedef T*                         pointer;\n-  typedef T&                         reference;\n-};\n-\n-#if 0\n-template <class Category, class T, class Distance = ptrdiff_t,\n-          class Pointer = T*, class Reference = T&>\n-struct iterator {\n-  typedef Category  iterator_category;\n-  typedef T         value_type;\n-  typedef Distance  difference_type;\n-  typedef Pointer   pointer;\n-  typedef Reference reference;\n-};\n+#ifndef __SGI_STL_INTERNAL_ITERATOR_H\n+#include <stl_iterator.h>\n #endif\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class Iterator>\n-struct iterator_traits {\n-  typedef typename Iterator::iterator_category iterator_category;\n-  typedef typename Iterator::value_type        value_type;\n-  typedef typename Iterator::difference_type   difference_type;\n-  typedef typename Iterator::pointer           pointer;\n-  typedef typename Iterator::reference         reference;\n-};\n-\n-template <class T>\n-struct iterator_traits<T*> {\n-  typedef random_access_iterator_tag iterator_category;\n-  typedef T                          value_type;\n-  typedef ptrdiff_t                  difference_type;\n-  typedef T*                         pointer;\n-  typedef T&                         reference;\n-};\n-\n-template <class T>\n-struct iterator_traits<const T*> {\n-  typedef random_access_iterator_tag iterator_category;\n-  typedef T                          value_type;\n-  typedef ptrdiff_t                  difference_type;\n-  typedef const T*                   pointer;\n-  typedef const T&                   reference;\n-};\n-\n-template <class Iterator>\n-inline iterator_traits<Iterator>::iterator_category\n-iterator_category(const Iterator&) {\n-  return iterator_traits<Iterator>::iterator_category();\n-}\n-\n-template <class Iterator>\n-inline iterator_traits<Iterator>::difference_type*\n-distance_type(const Iterator&) {\n-  return static_cast<iterator_traits<Iterator>::difference_type*>(0);\n-}\n-\n-template <class Iterator>\n-inline iterator_traits<Iterator>::value_type*\n-value_type(const Iterator&) {\n-  return static_cast<iterator_traits<Iterator>::value_type*>(0);\n-}\n-\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class T, class Distance> \n-inline input_iterator_tag \n-iterator_category(const input_iterator<T, Distance>&) {\n-    return input_iterator_tag();\n-}\n-\n-inline output_iterator_tag iterator_category(const output_iterator&) {\n-    return output_iterator_tag();\n-}\n-\n-template <class T, class Distance> \n-inline forward_iterator_tag\n-iterator_category(const forward_iterator<T, Distance>&) {\n-    return forward_iterator_tag();\n-}\n-\n-template <class T, class Distance> \n-inline bidirectional_iterator_tag\n-iterator_category(const bidirectional_iterator<T, Distance>&) {\n-    return bidirectional_iterator_tag();\n-}\n-\n-template <class T, class Distance> \n-inline random_access_iterator_tag\n-iterator_category(const random_access_iterator<T, Distance>&) {\n-    return random_access_iterator_tag();\n-}\n-\n-template <class T>\n-inline random_access_iterator_tag iterator_category(const T*) {\n-    return random_access_iterator_tag();\n-}\n-\n-template <class T, class Distance> \n-inline T* value_type(const input_iterator<T, Distance>&) {\n-    return (T*)(0); \n-}\n-\n-template <class T, class Distance> \n-inline T* value_type(const forward_iterator<T, Distance>&) {\n-    return (T*)(0);\n-}\n-\n-template <class T, class Distance> \n-inline T* value_type(const bidirectional_iterator<T, Distance>&) {\n-    return (T*)(0);\n-}\n-\n-template <class T, class Distance> \n-inline T* value_type(const random_access_iterator<T, Distance>&) {\n-    return (T*)(0);\n-}\n-\n-template <class T>\n-inline T* value_type(const T*) { return (T*)(0); }\n-\n-template <class T, class Distance> \n-inline Distance* distance_type(const input_iterator<T, Distance>&) {\n-    return (Distance*)(0);\n-}\n-\n-template <class T, class Distance> \n-inline Distance* distance_type(const forward_iterator<T, Distance>&) {\n-    return (Distance*)(0);\n-}\n-\n-template <class T, class Distance> \n-inline Distance* \n-distance_type(const bidirectional_iterator<T, Distance>&) {\n-    return (Distance*)(0);\n-}\n-\n-template <class T, class Distance> \n-inline Distance* \n-distance_type(const random_access_iterator<T, Distance>&) {\n-    return (Distance*)(0);\n-}\n-\n-template <class T>\n-inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class Container>\n-class back_insert_iterator {\n-protected:\n-    Container* container;\n-public:\n-    typedef output_iterator_tag iterator_category;\n-    typedef void                value_type;\n-    typedef void                difference_type;\n-    typedef void                pointer;\n-    typedef void                reference;\n-\n-    explicit back_insert_iterator(Container& x) : container(&x) {}\n-    back_insert_iterator<Container>&\n-    operator=(const typename Container::value_type& value) { \n-        container->push_back(value);\n-        return *this;\n-    }\n-    back_insert_iterator<Container>& operator*() { return *this; }\n-    back_insert_iterator<Container>& operator++() { return *this; }\n-    back_insert_iterator<Container>& operator++(int) { return *this; }\n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class Container>\n-inline output_iterator_tag\n-iterator_category(const back_insert_iterator<Container>&)\n-{\n-  return output_iterator_tag();\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class Container>\n-inline back_insert_iterator<Container> back_inserter(Container& x) {\n-  return back_insert_iterator<Container>(x);\n-}\n-\n-template <class Container>\n-class front_insert_iterator {\n-protected:\n-    Container* container;\n-public:\n-    typedef output_iterator_tag iterator_category;\n-    typedef void                value_type;\n-    typedef void                difference_type;\n-    typedef void                pointer;\n-    typedef void                reference;\n-\n-    explicit front_insert_iterator(Container& x) : container(&x) {}\n-    front_insert_iterator<Container>&\n-    operator=(const typename Container::value_type& value) { \n-        container->push_front(value);\n-        return *this;\n-    }\n-    front_insert_iterator<Container>& operator*() { return *this; }\n-    front_insert_iterator<Container>& operator++() { return *this; }\n-    front_insert_iterator<Container>& operator++(int) { return *this; }\n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class Container>\n-inline output_iterator_tag\n-iterator_category(const front_insert_iterator<Container>&)\n-{\n-  return output_iterator_tag();\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class Container>\n-inline front_insert_iterator<Container> front_inserter(Container& x) {\n-  return front_insert_iterator<Container>(x);\n-}\n-\n-template <class Container>\n-class insert_iterator {\n-protected:\n-    Container* container;\n-    typename Container::iterator iter;\n-public:\n-    typedef output_iterator_tag iterator_category;\n-    typedef void                value_type;\n-    typedef void                difference_type;\n-    typedef void                pointer;\n-    typedef void                reference;\n-\n-    insert_iterator(Container& x, typename Container::iterator i) \n-        : container(&x), iter(i) {}\n-    insert_iterator<Container>&\n-    operator=(const typename Container::value_type& value) { \n-        iter = container->insert(iter, value);\n-        ++iter;\n-        return *this;\n-    }\n-    insert_iterator<Container>& operator*() { return *this; }\n-    insert_iterator<Container>& operator++() { return *this; }\n-    insert_iterator<Container>& operator++(int) { return *this; }\n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class Container>\n-inline output_iterator_tag\n-iterator_category(const insert_iterator<Container>&)\n-{\n-  return output_iterator_tag();\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class Container, class Iterator>\n-inline insert_iterator<Container> inserter(Container& x, Iterator i) {\n-  typedef typename Container::iterator iter;\n-  return insert_iterator<Container>(x, iter(i));\n-}\n-\n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class BidirectionalIterator, class T, class Reference = T&, \n-          class Distance = ptrdiff_t> \n-#else\n-template <class BidirectionalIterator, class T, class Reference, \n-          class Distance> \n+#ifndef __TYPE_TRAITS_H\n+#include <type_traits.h>\n+#endif\n+#ifndef __SGI_STL_INTERNAL_CONSTRUCT_H\n+#include <stl_construct.h>\n+#endif\n+#ifndef __SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H\n+#include <stl_raw_storage_iter.h>\n #endif\n-class reverse_bidirectional_iterator {\n-    typedef reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,\n-                                           Distance> self;\n-    friend bool operator==(const self& x, const self& y);\n-protected:\n-    BidirectionalIterator current;\n-public:\n-    typedef bidirectional_iterator_tag iterator_category;\n-    typedef T                          value_type;\n-    typedef Distance                   difference_type;\n-    typedef T*                         pointer;\n-    typedef Reference                  reference;\n-\n-    reverse_bidirectional_iterator() {}\n-    explicit reverse_bidirectional_iterator(BidirectionalIterator x)\n-      : current(x) {}\n-    BidirectionalIterator base() { return current; }\n-    Reference operator*() const {\n-        BidirectionalIterator tmp = current;\n-        return *--tmp;\n-    }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-    pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-    self& operator++() {\n-        --current;\n-        return *this;\n-    }\n-    self operator++(int) {\n-        self tmp = *this;\n-        --current;\n-        return tmp;\n-    }\n-    self& operator--() {\n-        ++current;\n-        return *this;\n-    }\n-    self operator--(int) {\n-        self tmp = *this;\n-        ++current;\n-        return tmp;\n-    }\n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class BidirectionalIterator, class T, class Reference, \n-          class Distance>\n-inline bidirectional_iterator_tag\n-iterator_category(const reverse_bidirectional_iterator<BidirectionalIterator,\n-                                                       T,\n-                                                       Reference, Distance>&) {\n-  return bidirectional_iterator_tag();\n-}\n \n-template <class BidirectionalIterator, class T, class Reference, \n-          class Distance>\n-inline T*\n-value_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,\n-                                               Reference, Distance>&) {\n-  return (T*) 0;\n-}\n+#ifdef __STL_USE_NAMESPACES\n \n-template <class BidirectionalIterator, class T, class Reference, \n-          class Distance>\n-inline Distance*\n-distance_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,\n-                                                  Reference, Distance>&) {\n-  return (Distance*) 0;\n-}\n+// Names from stl_iterator.h\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+using __STD::input_iterator_tag;\n+using __STD::output_iterator_tag;\n+using __STD::forward_iterator_tag;\n+using __STD::bidirectional_iterator_tag;\n+using __STD::random_access_iterator_tag;\n \n-template <class BidirectionalIterator, class T, class Reference,\n-          class Distance>\n-inline bool operator==(\n-    const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,\n-                                         Distance>& x, \n-    const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,\n-                                         Distance>& y) {\n-    return x.current == y.current;\n-}\n+#if 0\n+using __STD::iterator;\n+#endif\n+using __STD::input_iterator;\n+using __STD::output_iterator;\n+using __STD::forward_iterator;\n+using __STD::bidirectional_iterator;\n+using __STD::random_access_iterator;\n \n #ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-// This is the new version of reverse_iterator, as defined in the\n-//  draft C++ standard.  It relies on the iterator_traits template,\n-//  which in turn relies on partial specialization.  The class\n-//  reverse_bidirectional_iterator is no longer part of the draft\n-//  standard, but it is retained for backward compatibility.\n-\n-template <class Iterator>\n-class reverse_iterator : public iterator_traits<Iterator>\n-{\n-protected:\n-  Iterator current;\n-public:\n-  typedef Iterator iterator_type;\n-  typedef reverse_iterator<Iterator> self;\n-\n-public:\n-  reverse_iterator() {}\n-  explicit reverse_iterator(iterator_type x) : current(x) {}\n-\n-  reverse_iterator(const self& x) : current(x.current) {}\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class Iter>\n-  reverse_iterator(const reverse_iterator<Iter>& x) : current(x.current) {}\n-#endif /* __STL_MEMBER_TEMPLATES */\n-    \n-  iterator_type base() const { return current; }\n-  reference operator*() const {\n-    Iterator tmp = current;\n-    return *--tmp;\n-  }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-\n-  self& operator++() {\n-    --current;\n-    return *this;\n-  }\n-  self operator++(int) {\n-    self tmp = *this;\n-    --current;\n-    return tmp;\n-  }\n-  self& operator--() {\n-    ++current;\n-    return *this;\n-  }\n-  self operator--(int) {\n-    self tmp = *this;\n-    ++current;\n-    return tmp;\n-  }\n-\n-  self operator+(difference_type n) const {\n-    return self(current - n);\n-  }\n-  self& operator+=(difference_type n) {\n-    current -= n;\n-    return *this;\n-  }\n-  self operator-(difference_type n) const {\n-    return self(current + n);\n-  }\n-  self& operator-=(difference_type n) {\n-    current += n;\n-    return *this;\n-  }\n-  reference operator[](difference_type n) { return *(*this + n); }  \n-}; \n- \n-template <class Iterator>\n-inline bool operator==(const reverse_iterator<Iterator>& x, \n-                       const reverse_iterator<Iterator>& y) {\n-  return x.base() == y.base();\n-}\n-\n-template <class Iterator>\n-inline bool operator<(const reverse_iterator<Iterator>& x, \n-                      const reverse_iterator<Iterator>& y) {\n-  return y.base() < x.base();\n-}\n-\n-template <class Iterator>\n-inline reverse_iterator<Iterator>::difference_type\n-operator-(const reverse_iterator<Iterator>& x, \n-          const reverse_iterator<Iterator>& y) {\n-  return y.base() - x.base();\n-}\n-\n-template <class Iterator>\n-inline reverse_iterator<Iterator> \n-operator+(reverse_iterator<Iterator>::difference_type n,\n-          const reverse_iterator<Iterator>& x) {\n-  return reverse_iterator<Iterator>(x.base() - n);\n-}\n-\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-// This is the old version of reverse_iterator, as found in the original\n-//  HP STL.  It does not use partial specialization.\n-\n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class RandomAccessIterator, class T, class Reference = T&,\n-          class Distance = ptrdiff_t> \n-#else\n-template <class RandomAccessIterator, class T, class Reference,\n-          class Distance> \n+using __STD::iterator_traits;\n #endif\n-class reverse_iterator {\n-    typedef reverse_iterator<RandomAccessIterator, T, Reference, Distance>\n-        self;\n-    friend bool operator==(const self& x, const self& y);\n-    friend bool operator<(const self& x, const self& y);\n-    friend Distance operator-(const self& x, const self& y);\n-    friend self operator+(Distance n, const self& x);\n-protected:\n-    RandomAccessIterator current;\n-public:\n-    typedef random_access_iterator_tag iterator_category;\n-    typedef T                          value_type;\n-    typedef Distance                   difference_type;\n-    typedef T*                         pointer;\n-    typedef Reference                  reference;\n-\n-    reverse_iterator() {}\n-    explicit reverse_iterator(RandomAccessIterator x) : current(x) {}\n-    RandomAccessIterator base() { return current; }\n-    Reference operator*() const { return *(current - 1); }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-    pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-    self& operator++() {\n-        --current;\n-        return *this;\n-    }\n-    self operator++(int) {\n-        self tmp = *this;\n-        --current;\n-        return tmp;\n-    }\n-    self& operator--() {\n-        ++current;\n-        return *this;\n-    }\n-    self operator--(int) {\n-        self tmp = *this;\n-        ++current;\n-        return tmp;\n-    }\n-    self operator+(Distance n) const {\n-        return self(current - n);\n-    }\n-    self& operator+=(Distance n) {\n-        current -= n;\n-        return *this;\n-    }\n-    self operator-(Distance n) const {\n-        return self(current + n);\n-    }\n-    self& operator-=(Distance n) {\n-        current += n;\n-        return *this;\n-    }\n-    Reference operator[](Distance n) { return *(*this + n); }\n-};\n-\n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline random_access_iterator_tag\n-iterator_category(const reverse_iterator<RandomAccessIterator, T,\n-                                         Reference, Distance>&) {\n-  return random_access_iterator_tag();\n-}\n-\n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline T* value_type(const reverse_iterator<RandomAccessIterator, T,\n-                                            Reference, Distance>&) {\n-  return (T*) 0;\n-}\n-\n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline Distance* distance_type(const reverse_iterator<RandomAccessIterator, T,\n-                                                      Reference, Distance>&) {\n-  return (Distance*) 0;\n-}\n-\n-\n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline bool operator==(const reverse_iterator<RandomAccessIterator, T,\n-                                              Reference, Distance>& x, \n-                       const reverse_iterator<RandomAccessIterator, T,\n-                                              Reference, Distance>& y) {\n-    return x.current == y.current;\n-}\n-\n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline bool operator<(const reverse_iterator<RandomAccessIterator, T,\n-                                             Reference, Distance>& x, \n-                      const reverse_iterator<RandomAccessIterator, T,\n-                                             Reference, Distance>& y) {\n-    return y.current < x.current;\n-}\n-\n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline Distance operator-(const reverse_iterator<RandomAccessIterator, T,\n-                                                 Reference, Distance>& x, \n-                          const reverse_iterator<RandomAccessIterator, T,\n-                                                 Reference, Distance>& y) {\n-    return y.current - x.current;\n-}\n-\n-template <class RandomAccessIterator, class T, class Reference, class Distance>\n-inline reverse_iterator<RandomAccessIterator, T, Reference, Distance> \n-operator+(Distance n,\n-          const reverse_iterator<RandomAccessIterator, T, Reference,\n-                                 Distance>& x) {\n-    return reverse_iterator<RandomAccessIterator, T, Reference, Distance>\n-        (x.current - n);\n-}\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+using __STD::iterator_category;\n+using __STD::distance_type;\n+using __STD::value_type;\n \n-template <class ForwardIterator, class T>\n-class raw_storage_iterator {\n-protected:\n-    ForwardIterator iter;\n-public:\n-    typedef output_iterator_tag iterator_category;\n-    typedef void                value_type;\n-    typedef void                difference_type;\n-    typedef void                pointer;\n-    typedef void                reference;\n+using __STD::distance; \n+using __STD::advance; \n \n-    explicit raw_storage_iterator(ForwardIterator x) : iter(x) {}\n-    raw_storage_iterator<ForwardIterator, T>& operator*() { return *this; }\n-    raw_storage_iterator<ForwardIterator, T>& operator=(const T& element) {\n-        construct(&*iter, element);\n-        return *this;\n-    }        \n-    raw_storage_iterator<ForwardIterator, T>& operator++() {\n-        ++iter;\n-        return *this;\n-    }\n-    raw_storage_iterator<ForwardIterator, T> operator++(int) {\n-        raw_storage_iterator<ForwardIterator, T> tmp = *this;\n-        ++iter;\n-        return tmp;\n-    }\n-};\n+using __STD::insert_iterator;\n+using __STD::front_insert_iterator;\n+using __STD::back_insert_iterator;\n+using __STD::inserter;\n+using __STD::front_inserter;\n+using __STD::back_inserter;\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n+using __STD::reverse_iterator;\n+using __STD::reverse_bidirectional_iterator;\n \n-template <class ForwardIterator, class T>\n-inline output_iterator_tag\n-iterator_category(const raw_storage_iterator<ForwardIterator, T>&)\n-{\n-  return output_iterator_tag();\n-}\n+using __STD::istream_iterator;\n+using __STD::ostream_iterator;\n \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+// Names from stl_construct.h\n+using __STD::construct;\n+using __STD::destroy;\n \n-template <class T, class Distance = ptrdiff_t> \n-class istream_iterator {\n-friend bool operator==(const istream_iterator<T, Distance>& x,\n-                       const istream_iterator<T, Distance>& y);\n-protected:\n-    istream* stream;\n-    T value;\n-    bool end_marker;\n-    void read() {\n-        end_marker = (*stream) ? true : false;\n-        if (end_marker) *stream >> value;\n-        end_marker = (*stream) ? true : false;\n-    }\n-public:\n-    typedef input_iterator_tag iterator_category;\n-    typedef T                  value_type;\n-    typedef Distance           difference_type;\n-    typedef const T*           pointer;\n-    typedef const T&           reference;\n+// Names from stl_raw_storage_iter.h\n+using __STD::raw_storage_iterator;\n \n-    istream_iterator() : stream(&cin), end_marker(false) {}\n-    istream_iterator(istream& s) : stream(&s) { read(); }\n-    reference operator*() const { return value; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-    pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-    istream_iterator<T, Distance>& operator++() { \n-        read(); \n-        return *this;\n-    }\n-    istream_iterator<T, Distance> operator++(int)  {\n-        istream_iterator<T, Distance> tmp = *this;\n-        read();\n-        return tmp;\n-    }\n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class T, class Distance>\n-inline input_iterator_tag \n-iterator_category(const istream_iterator<T, Distance>&) {\n-  return input_iterator_tag();\n-}\n-\n-template <class T, class Distance>\n-inline T* value_type(const istream_iterator<T, Distance>&) { return (T*) 0; }\n-\n-template <class T, class Distance>\n-inline Distance* distance_type(const istream_iterator<T, Distance>&) {\n-  return (Distance*) 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class T, class Distance>\n-bool operator==(const istream_iterator<T, Distance>& x,\n-                const istream_iterator<T, Distance>& y) {\n-    return x.stream == y.stream && x.end_marker == y.end_marker ||\n-        x.end_marker == false && y.end_marker == false;\n-}\n-\n-template <class T>\n-class ostream_iterator {\n-protected:\n-    ostream* stream;\n-    const char* string;\n-public:\n-    typedef output_iterator_tag iterator_category;\n-    typedef void                value_type;\n-    typedef void                difference_type;\n-    typedef void                pointer;\n-    typedef void                reference;\n-\n-    ostream_iterator(ostream& s) : stream(&s), string(0) {}\n-    ostream_iterator(ostream& s, const char* c) : stream(&s), string(c)  {}\n-    ostream_iterator<T>& operator=(const T& value) { \n-        *stream << value;\n-        if (string) *stream << string;\n-        return *this;\n-    }\n-    ostream_iterator<T>& operator*() { return *this; }\n-    ostream_iterator<T>& operator++() { return *this; } \n-    ostream_iterator<T>& operator++(int) { return *this; } \n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class T>\n-inline output_iterator_tag \n-iterator_category(const ostream_iterator<T>&) {\n-  return output_iterator_tag();\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_ITERATOR_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "5294f39fea69f21431adaa99d40ed9e91c8db4e6", "filename": "libstdc++/stl/list", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Flist?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,40 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_LIST\n+#define __SGI_STL_LIST\n+\n+#include <stl_algobase.h>\n+#include <stl_alloc.h>\n+#include <stl_construct.h>\n+#include <stl_uninitialized.h>\n+#include <stl_list.h>\n+\n+#endif /* __SGI_STL_LIST */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "4e6ee0b4113b29adea95ed99844373e4d4f2d259", "filename": "libstdc++/stl/list.h", "status": "modified", "additions": 9, "deletions": 601, "changes": 610, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Flist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Flist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Flist.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -27,608 +27,16 @@\n #ifndef __SGI_STL_LIST_H\n #define __SGI_STL_LIST_H\n \n-#include <stddef.h>\n #include <algobase.h>\n-#include <iterator.h>\n #include <alloc.h>\n+#include <stl_list.h>\n \n-template <class T>\n-struct __list_node {\n-  typedef void* void_pointer;\n-  void_pointer next;\n-  void_pointer prev;\n-  T data;\n-};\n-\n-template<class T, class Ref, class Ptr>\n-struct __list_iterator {\n-  typedef __list_iterator<T, T&, T*>             iterator;\n-  typedef __list_iterator<T, const T&, const T*> const_iterator;\n-  typedef __list_iterator<T, Ref, Ptr>           self;\n-\n-  typedef bidirectional_iterator_tag iterator_category;\n-  typedef T value_type;\n-  typedef Ptr pointer;\n-  typedef Ref reference;\n-  typedef __list_node<T>* link_type;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n-\n-  link_type node;\n-\n-  __list_iterator(link_type x) : node(x) {}\n-  __list_iterator() {}\n-  __list_iterator(const iterator& x) : node(x.node) {}\n-\n-  bool operator==(const self& x) const { return node == x.node; }\n-  bool operator!=(const self& x) const { return node != x.node; }\n-  reference operator*() const { return (*node).data; }\n-\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-\n-  self& operator++() { \n-    node = (link_type)((*node).next);\n-    return *this;\n-  }\n-  self operator++(int) { \n-    self tmp = *this;\n-    ++*this;\n-    return tmp;\n-  }\n-  self& operator--() { \n-    node = (link_type)((*node).prev);\n-    return *this;\n-  }\n-  self operator--(int) { \n-    self tmp = *this;\n-    --*this;\n-    return tmp;\n-  }\n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class T, class Ref, class Ptr>\n-inline bidirectional_iterator_tag\n-iterator_category(const __list_iterator<T, Ref, Ptr>&) {\n-  return bidirectional_iterator_tag();\n-}\n-\n-template <class T, class Ref, class Ptr>\n-inline T*\n-value_type(const __list_iterator<T, Ref, Ptr>&) {\n-  return 0;\n-}\n-\n-template <class T, class Ref, class Ptr>\n-inline ptrdiff_t*\n-distance_type(const __list_iterator<T, Ref, Ptr>&) {\n-  return 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-template <class T, class Alloc = alloc>\n-class list {\n-protected:\n-    typedef void* void_pointer;\n-    typedef __list_node<T> list_node;\n-    typedef simple_alloc<list_node, Alloc> list_node_allocator;\n-public:      \n-    typedef T value_type;\n-    typedef value_type* pointer;\n-    typedef value_type& reference;\n-    typedef const value_type& const_reference;\n-    typedef list_node* link_type;\n-    typedef size_t size_type;\n-    typedef ptrdiff_t difference_type;\n-\n-public:\n-    typedef __list_iterator<T, T&, T*>             iterator;\n-    typedef __list_iterator<T, const T&, const T*> const_iterator;\n-\n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-    typedef reverse_iterator<iterator> reverse_iterator;\n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-    typedef reverse_bidirectional_iterator<const_iterator, value_type,\n-                                           const_reference, difference_type>\n-            const_reverse_iterator;\n-    typedef reverse_bidirectional_iterator<iterator, value_type, reference,\n-                                           difference_type>\n-            reverse_iterator; \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-protected:\n-    link_type get_node() { return list_node_allocator::allocate(); }\n-    void put_node(link_type p) { list_node_allocator::deallocate(p); }\n-\n-    link_type create_node(const T& x) {\n-      link_type p = get_node();\n-#         ifdef __STL_USE_EXCEPTIONS\n-      try {\n-#         endif /* __STL_USE_EXCEPTIONS */\n-        construct(&p->data, x);\n-        return p;\n-#         ifdef __STL_USE_EXCEPTIONS\n-      }\n-      catch(...) {\n-        put_node(p);\n-        throw;\n-      }\n-#         endif /* __STL_USE_EXCEPTIONS */\n-    }\n-    void destroy_node(link_type p) {\n-      destroy(&p->data);\n-      put_node(p);\n-    }\n-\n-protected:\n-    void empty_initialize() { \n-      node = get_node();\n-      node->next = node;\n-      node->prev = node;\n-    }\n-\n-    void fill_initialize(size_type n, const T& value) {\n-      empty_initialize();\n-#         ifdef __STL_USE_EXCEPTIONS\n-      try {\n-#         endif /* __STL_USE_EXCEPTIONS */\n-        insert(begin(), n, value);\n-#         ifdef __STL_USE_EXCEPTIONS\n-      }\n-      catch(...) {\n-        clear();\n-        put_node(node);\n-        throw;\n-      }\n-#         endif /* __STL_USE_EXCEPTIONS */\n-    }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-    template <class InputIterator>\n-    void range_initialize(InputIterator first, InputIterator last) {\n-      empty_initialize();\n-#         ifdef __STL_USE_EXCEPTIONS\n-      try {\n-#         endif /* __STL_USE_EXCEPTIONS */\n-        insert(begin(), first, last);\n-#         ifdef __STL_USE_EXCEPTIONS\n-      }\n-      catch(...) {\n-        clear();\n-        put_node(node);\n-        throw;\n-      }\n-#         endif /* __STL_USE_EXCEPTIONS */\n-    }\n-#else  /* __STL_MEMBER_TEMPLATES */\n-    void range_initialize(const T* first, const T* last) {\n-      empty_initialize();\n-#         ifdef __STL_USE_EXCEPTIONS\n-      try {\n-#         endif /* __STL_USE_EXCEPTIONS */\n-        insert(begin(), first, last);\n-#         ifdef __STL_USE_EXCEPTIONS\n-      }\n-      catch(...) {\n-        clear();\n-        put_node(node);\n-        throw;\n-      }\n-#         endif /* __STL_USE_EXCEPTIONS */\n-    }\n-    void range_initialize(const_iterator first, const_iterator last) {\n-      empty_initialize();\n-#         ifdef __STL_USE_EXCEPTIONS\n-      try {\n-#         endif /* __STL_USE_EXCEPTIONS */\n-        insert(begin(), first, last);\n-#         ifdef __STL_USE_EXCEPTIONS\n-      }\n-      catch(...) {\n-        clear();\n-        put_node(node);\n-        throw;\n-      }\n-#         endif /* __STL_USE_EXCEPTIONS */\n-    }  \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-protected:\n-    link_type node;\n-\n-public:\n-    list() { empty_initialize(); }\n-\n-    iterator begin() { return (link_type)((*node).next); }\n-    const_iterator begin() const { return (link_type)((*node).next); }\n-    iterator end() { return node; }\n-    const_iterator end() const { return node; }\n-    reverse_iterator rbegin() { return reverse_iterator(end()); }\n-    const_reverse_iterator rbegin() const { \n-        return const_reverse_iterator(end()); \n-    }\n-    reverse_iterator rend() { return reverse_iterator(begin()); }\n-    const_reverse_iterator rend() const { \n-        return const_reverse_iterator(begin());\n-    } \n-    bool empty() const { return node->next == node; }\n-    size_type size() const {\n-      size_type result = 0;\n-      distance(begin(), end(), result);\n-      return result;\n-    }\n-    size_type max_size() const { return size_type(-1); }\n-    reference front() { return *begin(); }\n-    const_reference front() const { return *begin(); }\n-    reference back() { return *(--end()); }\n-    const_reference back() const { return *(--end()); }\n-    void swap(list<T, Alloc>& x) { ::swap(node, x.node); }\n-    iterator insert(iterator position, const T& x) {\n-      link_type tmp = create_node(x);\n-      tmp->next = position.node;\n-      tmp->prev = position.node->prev;\n-      (link_type(position.node->prev))->next = tmp;\n-      position.node->prev = tmp;\n-      return tmp;\n-    }\n-    iterator insert(iterator position) { return insert(position, T()); }\n-#ifdef __STL_MEMBER_TEMPLATES\n-    template <class InputIterator>\n-    void insert(iterator position, InputIterator first, InputIterator last);\n-#else /* __STL_MEMBER_TEMPLATES */\n-    void insert(iterator position, const T* first, const T* last);\n-    void insert(iterator position,\n-                const_iterator first, const_iterator last);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-    void insert(iterator pos, size_type n, const T& x);\n-    void insert(iterator pos, int n, const T& x) {\n-      insert(pos, (size_type)n, x);\n-    }\n-    void insert(iterator pos, long n, const T& x) {\n-      insert(pos, (size_type)n, x);\n-    }\n-\n-    void push_front(const T& x) { insert(begin(), x); }\n-    void push_back(const T& x) { insert(end(), x); }\n-    void erase(iterator position) {\n-      (link_type(position.node->prev))->next = position.node->next;\n-      (link_type(position.node->next))->prev = position.node->prev;\n-      destroy_node(position.node);\n-    }\n-    void erase(iterator first, iterator last);\n-    void resize(size_type new_size, const T& x);\n-    void resize(size_type new_size) { resize(new_size, T()); }\n-    void clear();\n-\n-    void pop_front() { erase(begin()); }\n-    void pop_back() { \n-        iterator tmp = end();\n-        erase(--tmp);\n-    }\n-    list(size_type n, const T& value) { fill_initialize(n, value); }\n-    list(int n, const T& value) { fill_initialize(n, value); }\n-    list(long n, const T& value) { fill_initialize(n, value); }\n-    explicit list(size_type n) { fill_initialize(n, T()); }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-    template <class InputIterator>\n-    list(InputIterator first, InputIterator last) {\n-      range_initialize(first, last);\n-    }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-    list(const T* first, const T* last) { range_initialize(first, last); }\n-    list(const_iterator first, const_iterator last) {\n-      range_initialize(first, last);\n-    }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-    list(const list<T, Alloc>& x) {\n-      range_initialize(x.begin(), x.end());\n-    }\n-    ~list() {\n-        clear();\n-\tput_node(node);\n-    }\n-    list<T, Alloc>& operator=(const list<T, Alloc>& x);\n-\n-protected:\n-    void transfer(iterator position, iterator first, iterator last) {\n-      if (position != last) {\n-\t(*(link_type((*last.node).prev))).next = position.node;\n-\t(*(link_type((*first.node).prev))).next = last.node;\n-\t(*(link_type((*position.node).prev))).next = first.node;  \n-\tlink_type tmp = link_type((*position.node).prev);\n-\t(*position.node).prev = (*last.node).prev;\n-\t(*last.node).prev = (*first.node).prev; \n-\t(*first.node).prev = tmp;\n-      }\n-    }\n-\n-public:\n-    void splice(iterator position, list& x) {\n-      if (!x.empty()) \n-        transfer(position, x.begin(), x.end());\n-    }\n-    void splice(iterator position, list&, iterator i) {\n-      iterator j = i;\n-      ++j;\n-      if (position == i || position == j) return;\n-      transfer(position, i, j);\n-    }\n-    void splice(iterator position, list&, iterator first, iterator last) {\n-      if (first != last) \n-        transfer(position, first, last);\n-    }\n-    void remove(const T& value);\n-    void unique();\n-    void merge(list& x);\n-    void reverse();\n-    void sort();\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-    template <class Predicate> void remove_if(Predicate);\n-    template <class BinaryPredicate> void unique(BinaryPredicate);\n-    template <class StrictWeakOrdering> void merge(list&, StrictWeakOrdering);\n-    template <class StrictWeakOrdering> void sort(StrictWeakOrdering);\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-    friend bool operator== (const list& x, const list& y);\n-};\n-\n-template <class T, class Alloc>\n-inline bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y) {\n-  typedef list<T,Alloc>::link_type link_type;\n-  link_type e1 = x.node;\n-  link_type e2 = y.node;\n-  link_type n1 = (link_type) e1->next;\n-  link_type n2 = (link_type) e2->next;\n-  for ( ; n1 != e1 && n2 != e2 ;\n-          n1 = (link_type) n1->next, n2 = (link_type) n2->next)\n-    if (n1->data != n2->data)\n-      return false;\n-  return n1 == e1 && n2 == e2;\n-}\n-\n-template <class T, class Alloc>\n-inline bool operator<(const list<T, Alloc>& x, const list<T, Alloc>& y) {\n-    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());\n-}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-template <class T, class Alloc> template <class InputIterator>\n-void list<T, Alloc>::insert(iterator position,\n-                            InputIterator first, InputIterator last) {\n-  for ( ; first != last; ++first)\n-    insert(position, *first);\n-}\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-\n-template <class T, class Alloc>\n-void list<T, Alloc>::insert(iterator position, const T* first, const T* last) {\n-  for ( ; first != last; ++first)\n-    insert(position, *first);\n-}\n-\n-template <class T, class Alloc>\n-void list<T, Alloc>::insert(iterator position,\n-                            const_iterator first, const_iterator last) {\n-  for ( ; first != last; ++first)\n-    insert(position, *first);\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-template <class T, class Alloc>\n-void list<T, Alloc>::insert(iterator position, size_type n, const T& x) {\n-  for ( ; n > 0; --n)\n-    insert(position, x);\n-}\n-\n-template <class T, class Alloc>\n-void list<T, Alloc>::erase(iterator first, iterator last) {\n-    while (first != last) erase(first++);\n-}\n-\n-template <class T, class Alloc>\n-void list<T, Alloc>::resize(size_type new_size, const T& x)\n-{\n-  size_type len = size();\n-  if (new_size < len) {\n-    iterator f;\n-    if (new_size < len / 2) {\n-      f = begin();\n-      advance(f, new_size);\n-    }\n-    else {\n-      f = end();\n-      advance(f, difference_type(len) - difference_type(new_size));\n-    }\n-    erase(f, end());\n-  }\n-  else\n-    insert(end(), new_size - len, x);\n-}\n-\n-template <class T, class Alloc> \n-void list<T, Alloc>::clear()\n-{\n-  link_type cur = (link_type) node->next;\n-  while (cur != node) {\n-    link_type tmp = cur;\n-    cur = (link_type) cur->next;\n-    destroy_node(tmp);\n-  }\n-  node->next = node;\n-  node->prev = node;\n-}\n-\n-template <class T, class Alloc>\n-list<T, Alloc>& list<T, Alloc>::operator=(const list<T, Alloc>& x) {\n-    if (this != &x) {\n-\titerator first1 = begin();\n-\titerator last1 = end();\n-\tconst_iterator first2 = x.begin();\n-\tconst_iterator last2 = x.end();\n-\twhile (first1 != last1 && first2 != last2) *first1++ = *first2++;\n-\tif (first2 == last2)\n-\t    erase(first1, last1);\n-\telse\n-\t    insert(last1, first2, last2);\n-    }\n-    return *this;\n-}\n-\n-template <class T, class Alloc>\n-void list<T, Alloc>::remove(const T& value) {\n-  iterator first = begin();\n-  iterator last = end();\n-  while (first != last) {\n-    iterator next = first;\n-    ++next;\n-    if (*first == value) erase(first);\n-    first = next;\n-  }\n-}\n-\n-template <class T, class Alloc>\n-void list<T, Alloc>::unique() {\n-  iterator first = begin();\n-  iterator last = end();\n-  if (first == last) return;\n-  iterator next = first;\n-  while (++next != last) {\n-    if (*first == *next)\n-      erase(next);\n-    else\n-      first = next;\n-    next = first;\n-  }\n-}\n-\n-template <class T, class Alloc>\n-void list<T, Alloc>::merge(list<T, Alloc>& x) {\n-  iterator first1 = begin();\n-  iterator last1 = end();\n-  iterator first2 = x.begin();\n-  iterator last2 = x.end();\n-  while (first1 != last1 && first2 != last2)\n-    if (*first2 < *first1) {\n-      iterator next = first2;\n-      transfer(first1, first2, ++next);\n-      first2 = next;\n-    }\n-    else\n-      ++first1;\n-  if (first2 != last2) transfer(last1, first2, last2);\n-}\n-\n-template <class T, class Alloc>\n-void list<T, Alloc>::reverse() {\n-  if (node->next == node || link_type(node->next)->next == node) return;\n-  iterator first = begin();\n-  ++first;\n-  while (first != end()) {\n-    iterator old = first;\n-    ++first;\n-    transfer(begin(), old, first);\n-  }\n-}    \n-\n-template <class T, class Alloc>\n-void list<T, Alloc>::sort() {\n-  if (node->next == node || link_type(node->next)->next == node) return;\n-  list<T, Alloc> carry;\n-  list<T, Alloc> counter[64];\n-  int fill = 0;\n-  while (!empty()) {\n-    carry.splice(carry.begin(), *this, begin());\n-    int i = 0;\n-    while(i < fill && !counter[i].empty()) {\n-      counter[i].merge(carry);\n-      carry.swap(counter[i++]);\n-    }\n-    carry.swap(counter[i]);         \n-    if (i == fill) ++fill;\n-  } \n-\n-  for (int i = 1; i < fill; ++i) counter[i].merge(counter[i-1]);\n-  swap(counter[fill-1]);\n-}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-template <class T, class Alloc> template <class Predicate>\n-void list<T, Alloc>::remove_if(Predicate pred) {\n-  iterator first = begin();\n-  iterator last = end();\n-  while (first != last) {\n-    iterator next = first;\n-    ++next;\n-    if (pred(*first)) erase(first);\n-    first = next;\n-  }\n-}\n-\n-template <class T, class Alloc> template <class BinaryPredicate>\n-void list<T, Alloc>::unique(BinaryPredicate binary_pred) {\n-  iterator first = begin();\n-  iterator last = end();\n-  if (first == last) return;\n-  iterator next = first;\n-  while (++next != last) {\n-    if (binary_pred(*first, *next))\n-      erase(next);\n-    else\n-      first = next;\n-    next = first;\n-  }\n-}\n-\n-template <class T, class Alloc> template <class StrictWeakOrdering>\n-void list<T, Alloc>::merge(list<T, Alloc>& x, StrictWeakOrdering comp) {\n-  iterator first1 = begin();\n-  iterator last1 = end();\n-  iterator first2 = x.begin();\n-  iterator last2 = x.end();\n-  while (first1 != last1 && first2 != last2)\n-    if (comp(*first2, *first1)) {\n-      iterator next = first2;\n-      transfer(first1, first2, ++next);\n-      first2 = next;\n-    }\n-    else\n-      ++first1;\n-  if (first2 != last2) transfer(last1, first2, last2);\n-}\n-\n-template <class T, class Alloc> template <class StrictWeakOrdering>\n-void list<T, Alloc>::sort(StrictWeakOrdering comp) {\n-  if (node->next == node || link_type(node->next)->next == node) return;\n-  list<T, Alloc> carry;\n-  list<T, Alloc> counter[64];\n-  int fill = 0;\n-  while (!empty()) {\n-    carry.splice(carry.begin(), *this, begin());\n-    int i = 0;\n-    while(i < fill && !counter[i].empty()) {\n-      counter[i].merge(carry, comp);\n-      carry.swap(counter[i++]);\n-    }\n-    carry.swap(counter[i]);         \n-    if (i == fill) ++fill;\n-  } \n-\n-  for (int i = 1; i < fill; ++i) counter[i].merge(counter[i-1], comp);\n-  swap(counter[fill-1]);\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::list;\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_LIST_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "4cfb7652c54551d8f7152f88bfe17d16b564a78a", "filename": "libstdc++/stl/map", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fmap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fmap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fmap?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,40 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_MAP\n+#define __SGI_STL_MAP\n+\n+#ifndef __SGI_STL_INTERNAL_TREE_H\n+#include <stl_tree.h>\n+#endif\n+#include <stl_map.h>\n+#include <stl_multimap.h>\n+\n+#endif /* __SGI_STL_MAP */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "a89bd31e81cdeaa72d22568502ff516d7722c032", "filename": "libstdc++/stl/map.h", "status": "modified", "additions": 8, "deletions": 155, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fmap.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -28,161 +28,14 @@\n #define __SGI_STL_MAP_H\n \n #include <tree.h>\n+#include <stl_map.h>\n \n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class T, class Compare = less<Key>, class Alloc = alloc>\n-#else\n-template <class Key, class T, class Compare, class Alloc = alloc>\n-#endif\n-class map {\n-public:\n-\n-// typedefs:\n-\n-  typedef Key key_type;\n-  typedef T data_type;\n-  typedef pair<const Key, T> value_type;\n-  typedef Compare key_compare;\n-    \n-  class value_compare\n-        : public binary_function<value_type, value_type, bool> {\n-    friend class map<Key, T, Compare, Alloc>;\n-    protected :\n-        Compare comp;\n-        value_compare(Compare c) : comp(c) {}\n-    public:\n-        bool operator()(const value_type& x, const value_type& y) const {\n-            return comp(x.first, y.first);\n-        }\n-  };\n-\n-private:\n-  typedef rb_tree<key_type, value_type, \n-                  select1st<value_type>, key_compare, Alloc> rep_type;\n-  rep_type t;  // red-black tree representing map\n-public:\n-  typedef rep_type::pointer pointer;\n-  typedef rep_type::reference reference;\n-  typedef rep_type::const_reference const_reference;\n-  typedef rep_type::iterator iterator;\n-  typedef rep_type::const_iterator const_iterator;\n-  typedef rep_type::reverse_iterator reverse_iterator;\n-  typedef rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef rep_type::size_type size_type;\n-  typedef rep_type::difference_type difference_type;\n-\n-  // allocation/deallocation\n-\n-  map() : t(Compare()) {}\n-  explicit map(const Compare& comp) : t(comp) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  map(InputIterator first, InputIterator last)\n-    : t(Compare()) { t.insert_unique(first, last); }\n-\n-  template <class InputIterator>\n-  map(InputIterator first, InputIterator last, const Compare& comp)\n-    : t(comp) { t.insert_unique(first, last); }\n-#else\n-  map(const value_type* first, const value_type* last)\n-    : t(Compare()) { t.insert_unique(first, last); }\n-  map(const value_type* first, const value_type* last, const Compare& comp)\n-    : t(comp) { t.insert_unique(first, last); }\n-\n-  map(const_iterator first, const_iterator last)\n-    : t(Compare()) { t.insert_unique(first, last); }\n-  map(const_iterator first, const_iterator last, const Compare& comp)\n-    : t(comp) { t.insert_unique(first, last); }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  map(const map<Key, T, Compare, Alloc>& x) : t(x.t) {}\n-  map<Key, T, Compare, Alloc>& operator=(const map<Key, T, Compare, Alloc>& x)\n-  {\n-    t = x.t;\n-    return *this; \n-  }\n-\n-  // accessors:\n-\n-  key_compare key_comp() const { return t.key_comp(); }\n-  value_compare value_comp() const { return value_compare(t.key_comp()); }\n-  iterator begin() { return t.begin(); }\n-  const_iterator begin() const { return t.begin(); }\n-  iterator end() { return t.end(); }\n-  const_iterator end() const { return t.end(); }\n-  reverse_iterator rbegin() { return t.rbegin(); }\n-  const_reverse_iterator rbegin() const { return t.rbegin(); }\n-  reverse_iterator rend() { return t.rend(); }\n-  const_reverse_iterator rend() const { return t.rend(); }\n-  bool empty() const { return t.empty(); }\n-  size_type size() const { return t.size(); }\n-  size_type max_size() const { return t.max_size(); }\n-  T& operator[](const key_type& k) {\n-    return (*((insert(value_type(k, T()))).first)).second;\n-  }\n-  void swap(map<Key, T, Compare, Alloc>& x) { t.swap(x.t); }\n-\n-  // insert/erase\n-\n-  pair<iterator,bool> insert(const value_type& x) { return t.insert_unique(x); }\n-  iterator insert(iterator position, const value_type& x) {\n-    return t.insert_unique(position, x);\n-  }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator first, InputIterator last) {\n-    t.insert_unique(first, last);\n-  }\n-#else\n-  void insert(const value_type* first, const value_type* last) {\n-    t.insert_unique(first, last);\n-  }\n-  void insert(const_iterator first, const_iterator last) {\n-    t.insert_unique(first, last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  void erase(iterator position) { t.erase(position); }\n-  size_type erase(const key_type& x) { return t.erase(x); }\n-  void erase(iterator first, iterator last) { t.erase(first, last); }\n-  void clear() { t.clear(); }\n-\n-  // map operations:\n-\n-  iterator find(const key_type& x) { return t.find(x); }\n-  const_iterator find(const key_type& x) const { return t.find(x); }\n-  size_type count(const key_type& x) const { return t.count(x); }\n-  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }\n-  const_iterator lower_bound(const key_type& x) const {\n-    return t.lower_bound(x); \n-  }\n-  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }\n-  const_iterator upper_bound(const key_type& x) const {\n-    return t.upper_bound(x); \n-  }\n-  \n-  pair<iterator,iterator> equal_range(const key_type& x) {\n-    return t.equal_range(x);\n-  }\n-  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {\n-    return t.equal_range(x);\n-  }\n-  friend bool operator==(const map&, const map&);\n-  friend bool operator<(const map&, const map&);\n-};\n-\n-template <class Key, class T, class Compare, class Alloc>\n-inline bool operator==(const map<Key, T, Compare, Alloc>& x, \n-                       const map<Key, T, Compare, Alloc>& y) {\n-  return x.t == y.t;\n-}\n-\n-template <class Key, class T, class Compare, class Alloc>\n-inline bool operator<(const map<Key, T, Compare, Alloc>& x, \n-                      const map<Key, T, Compare, Alloc>& y) {\n-  return x.t < y.t;\n-}\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::map;\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_MAP_H */\n \n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "a80658875ee97c750c3fcd11034e83fd99b1da04", "filename": "libstdc++/stl/memory", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fmemory?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef __SGI_STL_MEMORY\n+#define __SGI_STL_MEMORY\n+\n+#include <stl_algobase.h>\n+#include <stl_alloc.h>\n+#include <stl_construct.h>\n+#include <stl_tempbuf.h>\n+#include <stl_uninitialized.h>\n+#include <stl_raw_storage_iter.h>\n+\n+// Note: auto_ptr is commented out in this release because the details\n+//  of the interface are still being discussed by the C++ standardization\n+//  committee.  It will be included once the iterface is finalized.\n+\n+#if 0\n+#if defined(_MUTABLE_IS_KEYWORD) && defined(_EXPLICIT_IS_KEYWORD) && \\\n+    defined(__STL_MEMBER_TEMPLATES)\n+\n+__STL_BEGIN_NAMESPACE\n+\n+template <class X> class auto_ptr {\n+private:\n+  X* ptr;\n+  mutable bool owns;\n+public:\n+  typedef X element_type;\n+  explicit auto_ptr(X* p = 0) __STL_NOTHROW : ptr(p), owns(p) {}\n+  auto_ptr(const auto_ptr& a) __STL_NOTHROW : ptr(a.ptr), owns(a.owns) {\n+    a.owns = 0;\n+  }\n+  template <class T> auto_ptr(const auto_ptr<T>& a) __STL_NOTHROW\n+    : ptr(a.ptr), owns(a.owns) {\n+      a.owns = 0;\n+  }\n+\n+  auto_ptr& operator=(const auto_ptr& a) __STL_NOTHROW {\n+    if (&a != this) {\n+      if (owns)\n+        delete ptr;\n+      owns = a.owns;\n+      ptr = a.ptr;\n+      a.owns = 0;\n+    }\n+  }\n+  template <class T> auto_ptr& operator=(const auto_ptr<T>& a) __STL_NOTHROW {\n+    if (&a != this) {\n+      if (owns)\n+        delete ptr;\n+      owns = a.owns;\n+      ptr = a.ptr;\n+      a.owns = 0;\n+    }\n+  }\n+  ~auto_ptr() {\n+    if (owns)\n+      delete ptr;\n+  }\n+\n+  X& operator*() const __STL_NOTHROW { return *ptr; }\n+  X* operator->() const __STL_NOTHROW { return ptr; }\n+  X* get() const __STL_NOTHROW { return ptr; }\n+  X* release const __STL_NOTHROW { owns = false; return ptr }\n+};\n+\n+__STL_END_NAMESPACE\n+#endif /* mutable && explicit && member templates */\n+#endif /* 0 */\n+\n+\n+#endif /* __SGI_STL_MEMORY */\n+\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "1a8ec4af4f945c20ca3c41e59e520ae23d058c1d", "filename": "libstdc++/stl/multimap.h", "status": "modified", "additions": 9, "deletions": 150, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fmultimap.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -28,155 +28,14 @@\n #define __SGI_STL_MULTIMAP_H\n \n #include <tree.h>\n+#include <stl_multimap.h>\n \n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class T, class Compare = less<Key>, class Alloc = alloc>\n-#else\n-template <class Key, class T, class Compare, class Alloc = alloc>\n-#endif\n-class multimap {\n-public:\n-\n-// typedefs:\n-\n-  typedef Key key_type;\n-  typedef T data_type;\n-  typedef pair<const Key, T> value_type;\n-  typedef Compare key_compare;\n-\n-  class value_compare : public binary_function<value_type, value_type, bool> {\n-    friend class multimap<Key, T, Compare, Alloc>;\n-    protected:\n-        Compare comp;\n-        value_compare(Compare c) : comp(c) {}\n-    public:\n-        bool operator()(const value_type& x, const value_type& y) const {\n-            return comp(x.first, y.first);\n-        }\n-  };\n-\n-private:\n-  typedef rb_tree<key_type, value_type, \n-                  select1st<value_type>, key_compare, Alloc> rep_type;\n-  rep_type t;  // red-black tree representing multimap\n-public:\n-  typedef rep_type::pointer pointer;\n-  typedef rep_type::reference reference;\n-  typedef rep_type::const_reference const_reference;\n-  typedef rep_type::iterator iterator;\n-  typedef rep_type::const_iterator const_iterator; \n-  typedef rep_type::reverse_iterator reverse_iterator;\n-  typedef rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef rep_type::size_type size_type;\n-  typedef rep_type::difference_type difference_type;\n-\n-// allocation/deallocation\n-\n-  multimap() : t(Compare()) { }\n-  explicit multimap(const Compare& comp) : t(comp) { }\n-\n-#ifdef __STL_MEMBER_TEMPLATES  \n-  template <class InputIterator>\n-  multimap(InputIterator first, InputIterator last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-\n-  template <class InputIterator>\n-  multimap(InputIterator first, InputIterator last, const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n-#else\n-  multimap(const value_type* first, const value_type* last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-  multimap(const value_type* first, const value_type* last,\n-           const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n-\n-  multimap(const_iterator first, const_iterator last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-  multimap(const_iterator first, const_iterator last, const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  multimap(const multimap<Key, T, Compare, Alloc>& x) : t(x.t) { }\n-  multimap<Key, T, Compare, Alloc>&\n-  operator=(const multimap<Key, T, Compare, Alloc>& x) {\n-    t = x.t;\n-    return *this; \n-  }\n-\n-  // accessors:\n-\n-  key_compare key_comp() const { return t.key_comp(); }\n-  value_compare value_comp() const { return value_compare(t.key_comp()); }\n-  iterator begin() { return t.begin(); }\n-  const_iterator begin() const { return t.begin(); }\n-  iterator end() { return t.end(); }\n-  const_iterator end() const { return t.end(); }\n-  reverse_iterator rbegin() { return t.rbegin(); }\n-  const_reverse_iterator rbegin() const { return t.rbegin(); }\n-  reverse_iterator rend() { return t.rend(); }\n-  const_reverse_iterator rend() const { return t.rend(); }\n-  bool empty() const { return t.empty(); }\n-  size_type size() const { return t.size(); }\n-  size_type max_size() const { return t.max_size(); }\n-  void swap(multimap<Key, T, Compare, Alloc>& x) { t.swap(x.t); }\n-\n-  // insert/erase\n-\n-  iterator insert(const value_type& x) { return t.insert_equal(x); }\n-  iterator insert(iterator position, const value_type& x) {\n-    return t.insert_equal(position, x);\n-  }\n-#ifdef __STL_MEMBER_TEMPLATES  \n-  template <class InputIterator>\n-  void insert(InputIterator first, InputIterator last) {\n-    t.insert_equal(first, last);\n-  }\n-#else\n-  void insert(const value_type* first, const value_type* last) {\n-    t.insert_equal(first, last);\n-  }\n-  void insert(const_iterator first, const_iterator last) {\n-    t.insert_equal(first, last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-  void erase(iterator position) { t.erase(position); }\n-  size_type erase(const key_type& x) { return t.erase(x); }\n-  void erase(iterator first, iterator last) { t.erase(first, last); }\n-  void clear() { t.clear(); }\n-\n-  // multimap operations:\n-\n-  iterator find(const key_type& x) { return t.find(x); }\n-  const_iterator find(const key_type& x) const { return t.find(x); }\n-  size_type count(const key_type& x) const { return t.count(x); }\n-  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }\n-  const_iterator lower_bound(const key_type& x) const {\n-    return t.lower_bound(x); \n-  }\n-  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }\n-  const_iterator upper_bound(const key_type& x) const {\n-    return t.upper_bound(x); \n-  }\n-   pair<iterator,iterator> equal_range(const key_type& x) {\n-    return t.equal_range(x);\n-  }\n-  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {\n-    return t.equal_range(x);\n-  }\n-  friend bool operator==(const multimap&, const multimap&);\n-  friend bool operator<(const multimap&, const multimap&);\n-};\n-\n-template <class Key, class T, class Compare, class Alloc>\n-inline bool operator==(const multimap<Key, T, Compare, Alloc>& x, \n-                       const multimap<Key, T, Compare, Alloc>& y) {\n-  return x.t == y.t;\n-}\n-\n-template <class Key, class T, class Compare, class Alloc>\n-inline bool operator<(const multimap<Key, T, Compare, Alloc>& x, \n-                      const multimap<Key, T, Compare, Alloc>& y) {\n-  return x.t < y.t;\n-}\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::multimap;\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_MULTIMAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "3024fd74c03d481855598a5fef510803468a9044", "filename": "libstdc++/stl/multiset.h", "status": "modified", "additions": 9, "deletions": 135, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fmultiset.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -28,140 +28,14 @@\n #define __SGI_STL_MULTISET_H\n \n #include <tree.h>\n+#include <stl_multiset.h>\n \n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class Compare = less<Key>, class Alloc = alloc>\n-#else\n-template <class Key, class Compare, class Alloc = alloc>\n-#endif\n-class multiset {\n-public:\n-  // typedefs:\n-\n-  typedef Key key_type;\n-  typedef Key value_type;\n-  typedef Compare key_compare;\n-  typedef Compare value_compare;\n-private:\n-  typedef rb_tree<key_type, value_type, \n-                  identity<value_type>, key_compare, Alloc> rep_type;\n-  rep_type t;  // red-black tree representing multiset\n-public:\n-  typedef rep_type::const_pointer pointer;\n-  typedef rep_type::const_reference reference;\n-  typedef rep_type::const_reference const_reference;\n-  typedef rep_type::const_iterator iterator;\n-  typedef rep_type::const_iterator const_iterator;\n-  typedef rep_type::const_reverse_iterator reverse_iterator;\n-  typedef rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef rep_type::size_type size_type;\n-  typedef rep_type::difference_type difference_type;\n-\n-  // allocation/deallocation\n-\n-  multiset() : t(Compare()) {}\n-  explicit multiset(const Compare& comp) : t(comp) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  multiset(InputIterator first, InputIterator last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-  template <class InputIterator>\n-  multiset(InputIterator first, InputIterator last, const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n-#else\n-  multiset(const value_type* first, const value_type* last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-  multiset(const value_type* first, const value_type* last,\n-           const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n-\n-  multiset(const_iterator first, const_iterator last)\n-    : t(Compare()) { t.insert_equal(first, last); }\n-  multiset(const_iterator first, const_iterator last, const Compare& comp)\n-    : t(comp) { t.insert_equal(first, last); }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  multiset(const multiset<Key, Compare, Alloc>& x) : t(x.t) {}\n-  multiset<Key, Compare, Alloc>&\n-  operator=(const multiset<Key, Compare, Alloc>& x) {\n-    t = x.t; \n-    return *this;\n-  }\n-\n-  // accessors:\n-\n-  key_compare key_comp() const { return t.key_comp(); }\n-  value_compare value_comp() const { return t.key_comp(); }\n-  iterator begin() const { return t.begin(); }\n-  iterator end() const { return t.end(); }\n-  reverse_iterator rbegin() const { return t.rbegin(); } \n-  reverse_iterator rend() const { return t.rend(); }\n-  bool empty() const { return t.empty(); }\n-  size_type size() const { return t.size(); }\n-  size_type max_size() const { return t.max_size(); }\n-  void swap(multiset<Key, Compare, Alloc>& x) { t.swap(x.t); }\n-\n-  // insert/erase\n-  iterator insert(const value_type& x) { \n-    return t.insert_equal(x);\n-  }\n-  iterator insert(iterator position, const value_type& x) {\n-    return t.insert_equal((rep_type::iterator&)position, x);\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES  \n-  template <class InputIterator>\n-  void insert(InputIterator first, InputIterator last) {\n-    t.insert_equal(first, last);\n-  }\n-#else\n-  void insert(const value_type* first, const value_type* last) {\n-    t.insert_equal(first, last);\n-  }\n-  void insert(const_iterator first, const_iterator last) {\n-    t.insert_equal(first, last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-  void erase(iterator position) { \n-    t.erase((rep_type::iterator&)position); \n-  }\n-  size_type erase(const key_type& x) { \n-    return t.erase(x); \n-  }\n-  void erase(iterator first, iterator last) { \n-    t.erase((rep_type::iterator&)first, \n-            (rep_type::iterator&)last); \n-  }\n-  void clear() { t.clear(); }\n-\n-  // multiset operations:\n-\n-  iterator find(const key_type& x) const { return t.find(x); }\n-  size_type count(const key_type& x) const { return t.count(x); }\n-  iterator lower_bound(const key_type& x) const {\n-    return t.lower_bound(x);\n-  }\n-  iterator upper_bound(const key_type& x) const {\n-    return t.upper_bound(x); \n-  }\n-  pair<iterator,iterator> equal_range(const key_type& x) const {\n-    return t.equal_range(x);\n-  }\n-  friend bool operator==(const multiset&, const multiset&);\n-  friend bool operator<(const multiset&, const multiset&);\n-};\n-\n-template <class Key, class Compare, class Alloc>\n-inline bool operator==(const multiset<Key, Compare, Alloc>& x, \n-                       const multiset<Key, Compare, Alloc>& y) {\n-  return x.t == y.t;\n-}\n-\n-template <class Key, class Compare, class Alloc>\n-inline bool operator<(const multiset<Key, Compare, Alloc>& x, \n-                      const multiset<Key, Compare, Alloc>& y) {\n-  return x.t < y.t;\n-}\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::multiset;\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_MULTISET_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "7f048e11b568e5ce3428b34c8ef414ac27612225", "filename": "libstdc++/stl/numeric", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fnumeric?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,42 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_NUMERIC\n+#define __SGI_STL_NUMERIC\n+\n+#include <stl_config.h>\n+#include <stl_relops.h>\n+#include <stddef.h>\n+#include <iostream.h>\n+#include <stl_iterator.h>\n+#include <stl_function.h>\n+#include <stl_numeric.h>\n+\n+#endif /* __SGI_STL_NUMERIC */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "00f5caddb61418b8f93bf2c0e34d27e23c6efe35", "filename": "libstdc++/stl/pair.h", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fpair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fpair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fpair.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -24,40 +24,28 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n \n-#ifndef PAIR_H\n-#define PAIR_H\n+#ifndef __SGI_STL_PAIR_H\n+#define __SGI_STL_PAIR_H\n \n+#ifndef __STL_CONFIG_H\n #include <stl_config.h>\n-\n-template <class T1, class T2>\n-struct pair {\n-    typedef T1 first_type;\n-    typedef T2 second_type;\n-\n-    T1 first;\n-    T2 second;\n-    pair() : first(T1()), second(T2()) {}\n-    pair(const T1& a, const T2& b) : first(a), second(b) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-    template <class U1, class U2>\n-    pair(const pair<U1, U2>& p) : first(p.first), second(p.second) {}\n #endif\n-};\n+#ifndef __SGI_STL_INTERNAL_RELOPS\n+#include <stl_relops.h>\n+#endif\n+#ifndef __SGI_STL_INTERNAL_PAIR_H\n+#include <stl_pair.h>\n+#endif\n \n-template <class T1, class T2>\n-inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y) { \n-    return x.first == y.first && x.second == y.second; \n-}\n+#ifdef __STL_USE_NAMESPACES\n \n-template <class T1, class T2>\n-inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y) { \n-    return x.first < y.first || (!(y.first < x.first) && x.second < y.second); \n-}\n+using __STD::pair;\n+using __STD::make_pair;\n \n-template <class T1, class T2>\n-inline pair<T1, T2> make_pair(const T1& x, const T2& y) {\n-    return pair<T1, T2>(x, y);\n-}\n+#endif /* __STL_USE_NAMESPACES */\n \n-#endif\n+#endif /* __SGI_STL_PAIR_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "71df3d3b54884df983b8fe835f7fa209549cdd7d", "filename": "libstdc++/stl/pthread_alloc", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fpthread_alloc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fpthread_alloc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fpthread_alloc?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,347 @@\n+/*\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_PTHREAD_ALLOC\n+#define __SGI_STL_PTHREAD_ALLOC\n+\n+// Pthread-specific node allocator.\n+// This is similar to the default allocator, except that free-list\n+// information is kept separately for each thread, avoiding locking.\n+// This should be reasonably fast even in the presence of threads.\n+// The down side is that storage may not be well-utilized.\n+// It is not an error to allocate memory in thread A and deallocate\n+// it n thread B.  But this effectively transfers ownership of the memory,\n+// so that it can only be reallocated by thread B.  Thus this can effectively\n+// result in a storage leak if it's done on a regular basis.\n+// It can also result in frequent sharing of\n+// cache lines among processors, with potentially serious performance\n+// consequences.\n+\n+#include <stl_config.h>\n+#include <stl_alloc.h>\n+#ifndef __RESTRICT\n+#  define __RESTRICT\n+#endif\n+\n+__STL_BEGIN_NAMESPACE\n+\n+// Note that this class has nonstatic members.  We instantiate it once\n+// per thread.\n+template <bool dummy>\n+class __pthread_alloc_template {\n+\n+private:\n+  enum {ALIGN = 8};\n+  enum {MAX_BYTES = 128};  // power of 2\n+  enum {NFREELISTS = MAX_BYTES/ALIGN};\n+\n+  union obj {\n+        union obj * free_list_link;\n+        char client_data[ALIGN];    /* The client sees this.        */\n+  };\n+\n+  // Per instance state\n+  obj* volatile free_list[NFREELISTS]; \n+  __pthread_alloc_template<dummy>* next; \t// Free list link\n+\n+  static size_t ROUND_UP(size_t bytes) {\n+\treturn (((bytes) + ALIGN-1) & ~(ALIGN - 1));\n+  }\n+  static size_t FREELIST_INDEX(size_t bytes) {\n+\treturn (((bytes) + ALIGN-1)/ALIGN - 1);\n+  }\n+\n+  // Returns an object of size n, and optionally adds to size n free list.\n+  void *refill(size_t n);\n+  // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n+  // if it is inconvenient to allocate the requested number.\n+  static char *chunk_alloc(size_t size, int &nobjs);\n+\n+  // Chunk allocation state. And other shared state.\n+  // Protected by chunk_allocator_lock.\n+  static pthread_mutex_t chunk_allocator_lock;\n+  static char *start_free;\n+  static char *end_free;\n+  static size_t heap_size;\n+  static __pthread_alloc_template<dummy>* free_allocators;\n+  static pthread_key_t key;\n+  static bool key_initialized;\n+\t// Pthread key under which allocator is stored. \n+\t// Allocator instances that are currently unclaimed by any thread.\n+  static void destructor(void *instance);\n+\t// Function to be called on thread exit to reclaim allocator\n+\t// instance.\n+  static __pthread_alloc_template<dummy> *new_allocator();\n+\t// Return a recycled or new allocator instance.\n+  static __pthread_alloc_template<dummy> *get_allocator_instance();\n+\t// ensure that the current thread has an associated\n+\t// allocator instance.\n+  class lock {\n+      public:\n+\tlock () { pthread_mutex_lock(&chunk_allocator_lock); }\n+\t~lock () { pthread_mutex_unlock(&chunk_allocator_lock); }\n+  };\n+  friend class lock;\n+\n+\n+public:\n+\n+  __pthread_alloc_template() : next(0)\n+  {\n+    memset((void *)free_list, 0, NFREELISTS * sizeof(obj *));\n+  }\n+\n+  /* n must be > 0\t*/\n+  static void * allocate(size_t n)\n+  {\n+    obj * volatile * my_free_list;\n+    obj * __RESTRICT result;\n+    __pthread_alloc_template<dummy>* a;\n+\n+    if (n > MAX_BYTES) {\n+\treturn(malloc(n));\n+    }\n+    if (!key_initialized ||\n+        !(a = (__pthread_alloc_template<dummy>*)\n+\t\tpthread_getspecific(key))) {\n+\ta = get_allocator_instance();\n+    }\n+    my_free_list = a -> free_list + FREELIST_INDEX(n);\n+    result = *my_free_list;\n+    if (result == 0) {\n+    \tvoid *r = a -> refill(ROUND_UP(n));\n+\treturn r;\n+    }\n+    *my_free_list = result -> free_list_link;\n+    return (result);\n+  };\n+\n+  /* p may not be 0 */\n+  static void deallocate(void *p, size_t n)\n+  {\n+    obj *q = (obj *)p;\n+    obj * volatile * my_free_list;\n+    __pthread_alloc_template<dummy>* a;\n+\n+    if (n > MAX_BYTES) {\n+\tfree(p);\n+\treturn;\n+    }\n+    if (!key_initialized ||\n+        !(a = (__pthread_alloc_template<dummy>*)\n+\t\tpthread_getspecific(key))) {\n+\ta = get_allocator_instance();\n+    }\n+    my_free_list = a->free_list + FREELIST_INDEX(n);\n+    q -> free_list_link = *my_free_list;\n+    *my_free_list = q;\n+  }\n+\n+  static void * reallocate(void *p, size_t old_sz, size_t new_sz);\n+\n+} ;\n+\n+typedef __pthread_alloc_template<false> pthread_alloc;\n+\n+\n+template <bool dummy>\n+void __pthread_alloc_template<dummy>::destructor(void * instance)\n+{\n+    __pthread_alloc_template<dummy>* a =\n+\t(__pthread_alloc_template<dummy>*)instance;\n+    a -> next = free_allocators;\n+    free_allocators = a;\n+}\n+\n+template <bool dummy>\n+__pthread_alloc_template<dummy>*\n+__pthread_alloc_template<dummy>::new_allocator()\n+{\n+    if (0 != free_allocators) {\n+\t__pthread_alloc_template<dummy>* result = free_allocators;\n+\tfree_allocators = free_allocators -> next;\n+\treturn result;\n+    } else {\n+\treturn new __pthread_alloc_template<dummy>;\n+    }\n+}\n+\n+template <bool dummy>\n+__pthread_alloc_template<dummy>*\n+__pthread_alloc_template<dummy>::get_allocator_instance()\n+{\n+    __pthread_alloc_template<dummy>* result;\n+    if (!key_initialized) {\n+    \t/*REFERENCED*/\n+\tlock lock_instance;\n+\tif (!key_initialized) {\n+\t    if (pthread_key_create(&key, destructor)) {\n+\t\tabort();  // failed\n+\t    }\n+\t    key_initialized = true;\n+\t}\n+    }\n+    result = new_allocator();\n+    if (pthread_setspecific(key, result)) abort();\n+    return result;\n+}\n+\n+/* We allocate memory in large chunks in order to avoid fragmenting\t*/\n+/* the malloc heap too much.\t\t\t\t\t\t*/\n+/* We assume that size is properly aligned.\t\t\t\t*/\n+template <bool dummy>\n+char *__pthread_alloc_template<dummy>\n+::chunk_alloc(size_t size, int &nobjs)\n+{\n+  {\n+    char * result;\n+    size_t total_bytes;\n+    size_t bytes_left;\n+    /*REFERENCED*/\n+    lock lock_instance;\t\t// Acquire lock for this routine\n+\n+    total_bytes = size * nobjs;\n+    bytes_left = end_free - start_free;\n+    if (bytes_left >= total_bytes) {\n+\tresult = start_free;\n+\tstart_free += total_bytes;\n+\treturn(result);\n+    } else if (bytes_left >= size) {\n+\tnobjs = bytes_left/size;\n+\ttotal_bytes = size * nobjs;\n+\tresult = start_free;\n+\tstart_free += total_bytes;\n+\treturn(result);\n+    } else {\n+\tsize_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size >> 4);\n+\t// Try to make use of the left-over piece.\n+\tif (bytes_left > 0) {\n+\t    __pthread_alloc_template<dummy>* a = \n+\t\t(__pthread_alloc_template<dummy>*)pthread_getspecific(key);\n+\t    obj * volatile * my_free_list =\n+\t\t\ta->free_list + FREELIST_INDEX(bytes_left);\n+\n+            ((obj *)start_free) -> free_list_link = *my_free_list;\n+            *my_free_list = (obj *)start_free;\n+\t}\n+#\tifdef _SGI_SOURCE\n+\t  // Try to get memory that's aligned on something like a\n+\t  // cache line boundary, so as to avoid parceling out\n+\t  // parts of the same line to different threads and thus\n+\t  // possibly different processors.\n+\t  {\n+\t    const int cache_line_size = 128;  // probable upper bound\n+\t    bytes_to_get &= ~(cache_line_size-1);\n+\t    start_free = (char *)memalign(cache_line_size, bytes_to_get); \n+\t    if (0 == start_free) {\n+\t      start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n+\t    }\n+\t  }\n+#\telse  /* !SGI_SOURCE */\n+\t  start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n+#       endif\n+\theap_size += bytes_to_get;\n+\tend_free = start_free + bytes_to_get;\n+    }\n+  }\n+  // lock is released here\n+  return(chunk_alloc(size, nobjs));\n+}\n+\n+\n+/* Returns an object of size n, and optionally adds to size n free list.*/\n+/* We assume that n is properly aligned.\t\t\t\t*/\n+/* We hold the allocation lock.\t\t\t\t\t\t*/\n+template <bool dummy>\n+void *__pthread_alloc_template<dummy>\n+::refill(size_t n)\n+{\n+    int nobjs = 128;\n+    char * chunk = chunk_alloc(n, nobjs);\n+    obj * volatile * my_free_list;\n+    obj * result;\n+    obj * current_obj, * next_obj;\n+    int i;\n+\n+    if (1 == nobjs)  {\n+\treturn(chunk);\n+    }\n+    my_free_list = free_list + FREELIST_INDEX(n);\n+\n+    /* Build free list in chunk */\n+      result = (obj *)chunk;\n+      *my_free_list = next_obj = (obj *)(chunk + n);\n+      for (i = 1; ; i++) {\n+\tcurrent_obj = next_obj;\n+\tnext_obj = (obj *)((char *)next_obj + n);\n+\tif (nobjs - 1 == i) {\n+\t    current_obj -> free_list_link = 0;\n+\t    break;\n+\t} else {\n+\t    current_obj -> free_list_link = next_obj;\n+\t}\n+      }\n+    return(result);\n+}\n+\n+template <bool dummy>\n+void *__pthread_alloc_template<dummy>\n+::reallocate(void *p, size_t old_sz, size_t new_sz)\n+{\n+    void * result;\n+    size_t copy_sz;\n+\n+    if (old_sz > MAX_BYTES && new_sz > MAX_BYTES) {\n+\treturn(realloc(p, new_sz));\n+    }\n+    if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);\n+    result = allocate(new_sz);\n+    copy_sz = new_sz > old_sz? old_sz : new_sz;\n+    memcpy(result, p, copy_sz);\n+    deallocate(p, old_sz);\n+    return(result);\n+}\n+\n+template <bool dummy>\n+__pthread_alloc_template<dummy> *\n+__pthread_alloc_template<dummy>::free_allocators = 0;\n+\n+template <bool dummy>\n+pthread_key_t __pthread_alloc_template<dummy>::key;\n+\n+template <bool dummy>\n+bool __pthread_alloc_template<dummy>::key_initialized = false;\n+\n+template <bool dummy>\n+pthread_mutex_t __pthread_alloc_template<dummy>::chunk_allocator_lock\n+= PTHREAD_MUTEX_INITIALIZER;\n+\n+template <bool dummy>\n+char *__pthread_alloc_template<dummy>\n+::start_free = 0;\n+\n+template <bool dummy>\n+char *__pthread_alloc_template<dummy>\n+::end_free = 0;\n+\n+template <bool dummy>\n+size_t __pthread_alloc_template<dummy>\n+::heap_size = 0;\n+\n+__STL_END_NAMESPACE\n+\n+#endif /* __SGI_STL_PTHREAD_ALLOC */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "0a2debb74bd5e98071ba31a91e654e2563ac290b", "filename": "libstdc++/stl/pthread_alloc.h", "status": "modified", "additions": 12, "deletions": 325, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fpthread_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fpthread_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fpthread_alloc.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 1996\n+ * Copyright (c) 1996-1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -11,334 +11,21 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n \n-#ifndef __PTHREAD_ALLOC_H\n-#define __PTHREAD_ALLOC_H\n+#ifndef __SGI_STL_PTHREAD_ALLOC_H\n+#define __SGI_STL_PTHREAD_ALLOC_H\n \n-// Pthread-specific node allocator.\n-// This is similar to the default allocator, except that free-list\n-// information is kept separately for each thread, avoiding locking.\n-// This should be reasonably fast even in the presence of threads.\n-// The down side is that storage may not be well-utilized.\n-// It is not an error to allocate memory in thread A and deallocate\n-// it n thread B.  But this effectively transfers ownership of the memory,\n-// so that it can only be reallocated by thread B.  Thus this can effectively\n-// result in a storage leak if it's done on a regular basis.\n-// It can also result in frequent sharing of\n-// cache lines among processors, with potentially serious performance\n-// consequences.\n+#include <pthread_alloc>\n \n+#ifdef __STL_USE_NAMESPACES\n \n-#include <stddef.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <pthread.h>\n-#include <alloc.h>\n-#ifndef __RESTRICT\n-#  define __RESTRICT\n-#endif\n+using __STD::__pthread_alloc_template;\n+using __STL::pthread_alloc;\n \n-// Note that this class has nonstatic members.  We instantiate it once\n-// per thread.\n-template <bool dummy>\n-class __pthread_alloc_template {\n+#endif /* __STL_USE_NAMESPACES */\n \n-private:\n-  enum {ALIGN = 8};\n-  enum {MAX_BYTES = 128};  // power of 2\n-  enum {NFREELISTS = MAX_BYTES/ALIGN};\n \n-  union obj {\n-        union obj * free_list_link;\n-        char client_data[ALIGN];    /* The client sees this.        */\n-  };\n+#endif /* __SGI_STL_PTHREAD_ALLOC_H */\n \n-  // Per instance state\n-  obj* volatile free_list[NFREELISTS]; \n-  __pthread_alloc_template<dummy>* next; \t// Free list link\n-\n-  static size_t ROUND_UP(size_t bytes) {\n-\treturn (((bytes) + ALIGN-1) & ~(ALIGN - 1));\n-  }\n-  static size_t FREELIST_INDEX(size_t bytes) {\n-\treturn (((bytes) + ALIGN-1)/ALIGN - 1);\n-  }\n-\n-  // Returns an object of size n, and optionally adds to size n free list.\n-  void *refill(size_t n);\n-  // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n-  // if it is inconvenient to allocate the requested number.\n-  static char *chunk_alloc(size_t size, int &nobjs);\n-\n-  // Chunk allocation state. And other shared state.\n-  // Protected by chunk_allocator_lock.\n-  static pthread_mutex_t chunk_allocator_lock;\n-  static char *start_free;\n-  static char *end_free;\n-  static size_t heap_size;\n-  static __pthread_alloc_template<dummy>* free_allocators;\n-  static pthread_key_t key;\n-  static bool key_initialized;\n-\t// Pthread key under which allocator is stored. \n-\t// Allocator instances that are currently unclaimed by any thread.\n-  static void destructor(void *instance);\n-\t// Function to be called on thread exit to reclaim allocator\n-\t// instance.\n-  static __pthread_alloc_template<dummy> *new_allocator();\n-\t// Return a recycled or new allocator instance.\n-  static __pthread_alloc_template<dummy> *get_allocator_instance();\n-\t// ensure that the current thread has an associated\n-\t// allocator instance.\n-  class lock {\n-      public:\n-\tlock () { pthread_mutex_lock(&chunk_allocator_lock); }\n-\t~lock () { pthread_mutex_unlock(&chunk_allocator_lock); }\n-  };\n-  friend class lock;\n-\n-\n-public:\n-\n-  __pthread_alloc_template() : next(0)\n-  {\n-    memset((void *)free_list, 0, NFREELISTS * sizeof(obj *));\n-  }\n-\n-  /* n must be > 0\t*/\n-  static void * allocate(size_t n)\n-  {\n-    obj * volatile * my_free_list;\n-    obj * __RESTRICT result;\n-    __pthread_alloc_template<dummy>* a;\n-\n-    if (n > MAX_BYTES) {\n-\treturn(malloc(n));\n-    }\n-    if (!key_initialized ||\n-        !(a = (__pthread_alloc_template<dummy>*)\n-\t\tpthread_getspecific(key))) {\n-\ta = get_allocator_instance();\n-    }\n-    my_free_list = a -> free_list + FREELIST_INDEX(n);\n-    result = *my_free_list;\n-    if (result == 0) {\n-    \tvoid *r = a -> refill(ROUND_UP(n));\n-\treturn r;\n-    }\n-    *my_free_list = result -> free_list_link;\n-    return (result);\n-  };\n-\n-  /* p may not be 0 */\n-  static void deallocate(void *p, size_t n)\n-  {\n-    obj *q = (obj *)p;\n-    obj * volatile * my_free_list;\n-    __pthread_alloc_template<dummy>* a;\n-\n-    if (n > MAX_BYTES) {\n-\tfree(p);\n-\treturn;\n-    }\n-    if (!key_initialized ||\n-        !(a = (__pthread_alloc_template<dummy>*)\n-\t\tpthread_getspecific(key))) {\n-\ta = get_allocator_instance();\n-    }\n-    my_free_list = a->free_list + FREELIST_INDEX(n);\n-    q -> free_list_link = *my_free_list;\n-    *my_free_list = q;\n-  }\n-\n-  static void * reallocate(void *p, size_t old_sz, size_t new_sz);\n-\n-} ;\n-\n-typedef __pthread_alloc_template<false> pthread_alloc;\n-\n-\n-template <bool dummy>\n-void __pthread_alloc_template<dummy>::destructor(void * instance)\n-{\n-    __pthread_alloc_template<dummy>* a =\n-\t(__pthread_alloc_template<dummy>*)instance;\n-    a -> next = free_allocators;\n-    free_allocators = a;\n-}\n-\n-template <bool dummy>\n-__pthread_alloc_template<dummy>*\n-__pthread_alloc_template<dummy>::new_allocator()\n-{\n-    if (0 != free_allocators) {\n-\t__pthread_alloc_template<dummy>* result = free_allocators;\n-\tfree_allocators = free_allocators -> next;\n-\treturn result;\n-    } else {\n-\treturn new __pthread_alloc_template<dummy>;\n-    }\n-}\n-\n-template <bool dummy>\n-__pthread_alloc_template<dummy>*\n-__pthread_alloc_template<dummy>::get_allocator_instance()\n-{\n-    __pthread_alloc_template<dummy>* result;\n-    if (!key_initialized) {\n-    \t/*REFERENCED*/\n-\tlock lock_instance;\n-\tif (!key_initialized) {\n-\t    if (pthread_key_create(&key, destructor)) {\n-\t\tabort();  // failed\n-\t    }\n-\t    key_initialized = true;\n-\t}\n-    }\n-    result = new_allocator();\n-    if (pthread_setspecific(key, result)) abort();\n-    return result;\n-}\n-\n-/* We allocate memory in large chunks in order to avoid fragmenting\t*/\n-/* the malloc heap too much.\t\t\t\t\t\t*/\n-/* We assume that size is properly aligned.\t\t\t\t*/\n-template <bool dummy>\n-char *__pthread_alloc_template<dummy>\n-::chunk_alloc(size_t size, int &nobjs)\n-{\n-  {\n-    char * result;\n-    size_t total_bytes;\n-    size_t bytes_left;\n-    /*REFERENCED*/\n-    lock lock_instance;\t\t// Acquire lock for this routine\n-\n-    total_bytes = size * nobjs;\n-    bytes_left = end_free - start_free;\n-    if (bytes_left >= total_bytes) {\n-\tresult = start_free;\n-\tstart_free += total_bytes;\n-\treturn(result);\n-    } else if (bytes_left >= size) {\n-\tnobjs = bytes_left/size;\n-\ttotal_bytes = size * nobjs;\n-\tresult = start_free;\n-\tstart_free += total_bytes;\n-\treturn(result);\n-    } else {\n-\tsize_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size >> 4);\n-\t// Try to make use of the left-over piece.\n-\tif (bytes_left > 0) {\n-\t    __pthread_alloc_template<dummy>* a = \n-\t\t(__pthread_alloc_template<dummy>*)pthread_getspecific(key);\n-\t    obj * volatile * my_free_list =\n-\t\t\ta->free_list + FREELIST_INDEX(bytes_left);\n-\n-            ((obj *)start_free) -> free_list_link = *my_free_list;\n-            *my_free_list = (obj *)start_free;\n-\t}\n-#\tifdef _SGI_SOURCE\n-\t  // Try to get memory that's aligned on something like a\n-\t  // cache line boundary, so as to avoid parceling out\n-\t  // parts of the same line to different threads and thus\n-\t  // possibly different processors.\n-\t  {\n-\t    const int cache_line_size = 128;  // probable upper bound\n-\t    bytes_to_get &= ~(cache_line_size-1);\n-\t    start_free = (char *)memalign(cache_line_size, bytes_to_get); \n-\t    if (0 == start_free) {\n-\t      start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n-\t    }\n-\t  }\n-#\telse  /* !SGI_SOURCE */\n-\t  start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n-#       endif\n-\theap_size += bytes_to_get;\n-\tend_free = start_free + bytes_to_get;\n-    }\n-  }\n-  // lock is released here\n-  return(chunk_alloc(size, nobjs));\n-}\n-\n-\n-/* Returns an object of size n, and optionally adds to size n free list.*/\n-/* We assume that n is properly aligned.\t\t\t\t*/\n-/* We hold the allocation lock.\t\t\t\t\t\t*/\n-template <bool dummy>\n-void *__pthread_alloc_template<dummy>\n-::refill(size_t n)\n-{\n-    int nobjs = 128;\n-    char * chunk = chunk_alloc(n, nobjs);\n-    obj * volatile * my_free_list;\n-    obj * result;\n-    obj * current_obj, * next_obj;\n-    int i;\n-\n-    if (1 == nobjs)  {\n-\treturn(chunk);\n-    }\n-    my_free_list = free_list + FREELIST_INDEX(n);\n-\n-    /* Build free list in chunk */\n-      result = (obj *)chunk;\n-      *my_free_list = next_obj = (obj *)(chunk + n);\n-      for (i = 1; ; i++) {\n-\tcurrent_obj = next_obj;\n-\tnext_obj = (obj *)((char *)next_obj + n);\n-\tif (nobjs - 1 == i) {\n-\t    current_obj -> free_list_link = 0;\n-\t    break;\n-\t} else {\n-\t    current_obj -> free_list_link = next_obj;\n-\t}\n-      }\n-    return(result);\n-}\n-\n-template <bool dummy>\n-void *__pthread_alloc_template<dummy>\n-::reallocate(void *p, size_t old_sz, size_t new_sz)\n-{\n-    void * result;\n-    size_t copy_sz;\n-\n-    if (old_sz > MAX_BYTES && new_sz > MAX_BYTES) {\n-\treturn(realloc(p, new_sz));\n-    }\n-    if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);\n-    result = allocate(new_sz);\n-    copy_sz = new_sz > old_sz? old_sz : new_sz;\n-    memcpy(result, p, copy_sz);\n-    deallocate(p, old_sz);\n-    return(result);\n-}\n-\n-template <bool dummy>\n-__pthread_alloc_template<dummy> *\n-__pthread_alloc_template<dummy>::free_allocators = 0;\n-\n-template <bool dummy>\n-pthread_key_t __pthread_alloc_template<dummy>::key;\n-\n-template <bool dummy>\n-bool __pthread_alloc_template<dummy>::key_initialized = false;\n-\n-template <bool dummy>\n-pthread_mutex_t __pthread_alloc_template<dummy>::chunk_allocator_lock\n-= PTHREAD_MUTEX_INITIALIZER;\n-\n-template <bool dummy>\n-char *__pthread_alloc_template<dummy>\n-::start_free = 0;\n-\n-template <bool dummy>\n-char *__pthread_alloc_template<dummy>\n-::end_free = 0;\n-\n-template <bool dummy>\n-size_t __pthread_alloc_template<dummy>\n-::heap_size = 0;\n-\n-\n-#endif /* __NODE_ALLOC_H */\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "f9417fb1fbb6231b5a665193c3bdb97994473341", "filename": "libstdc++/stl/queue", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fqueue", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fqueue", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fqueue?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,45 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_QUEUE\n+#define __SGI_STL_QUEUE\n+\n+#include <stl_algobase.h>\n+#include <stl_alloc.h>\n+#include <stl_construct.h>\n+#include <stl_uninitialized.h>\n+#include <stl_vector.h>\n+#include <stl_bvector.h>\n+#include <stl_heap.h>\n+#include <stl_deque.h>\n+#include <stl_function.h>\n+#include <stl_queue.h>\n+\n+#endif /* __SGI_STL_QUEUE */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "9ef738241d74a4a72961ac1c71b8cb87b786d187", "filename": "libstdc++/stl/rope", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Frope?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_ROPE\n+#define __SGI_STL_ROPE\n+\n+#include <stl_algobase.h>\n+#include <tempbuf.h>\n+#include <stl_algo.h>\n+#include <stl_function.h>\n+#include <stl_numeric.h>\n+#include <stl_alloc.h>\n+#include <stl_construct.h>\n+#include <stl_uninitialized.h>\n+#include <stl_hash_fun.h>\n+#include <stl_rope.h>\n+\n+#endif /* __SGI_STL_ROPE */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "d767fa32e7a2e69027a9e9aab6260bbbd32c55fa", "filename": "libstdc++/stl/rope.h", "status": "modified", "additions": 15, "deletions": 2057, "changes": 2072, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Frope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Frope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Frope.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -11,2066 +11,24 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n \n-#ifndef _ROPE_H\n-# define _ROPE_H\n+#ifndef __SGI_STL_ROPE_H\n+#define __SGI_STL_ROPE_H\n \n-# include <iterator.h>\n-# include <algobase.h>\n-# include <algo.h>\n-# include <function.h>\n-# include <stddef.h>\n-# include <alloc.h>\n-# include <hashtable.h>\n-# ifdef __GC\n-#   define __GC_CONST const\n-# else\n-#   define __GC_CONST   // constant except for deallocation\n-# endif\n-# ifdef __STL_SGI_THREADS\n-#    include <mutex.h>\n-# endif\n+#include <hashtable.h>\n+#include <stl_rope.h>\n \n-// The end-of-C-string character.\n-// This is what the draft standard says it should be.\n-template <class charT>\n-inline charT __eos(charT*) { return charT(); }\n+#ifdef __STL_USE_NAMESPACES\n \n-// Test for basic character types.\n-// For basic character types leaves having a trailing eos.\n-template <class charT>\n-inline bool __is_basic_char_type(charT *) { return false; }\n-template <class charT>\n-inline bool __is_one_byte_char_type(charT *) { return false; }\n+using __STD::char_producer; \n+using __STD::sequence_buffer; \n+using __STD::rope; \n+using __STD::crope; \n+using __STD::wrope; \n \n-inline bool __is_basic_char_type(char *) { return true; }\n-inline bool __is_one_byte_char_type(char *) { return true; }\n-inline bool __is_basic_char_type(wchar_t *) { return true; }\n+#endif /* __STL_USE_NAMESPACES */\n \n-// Store an eos iff charT is a basic character type.\n-// Do not reference __eos if it isn't.\n-template <class charT>\n-inline void __cond_store_eos(charT&) {}\n+#endif /* __SGI_STL_ROPE_H */\n \n-inline void __cond_store_eos(char& c) { c = 0; }\n-inline void __cond_store_eos(wchar_t& c) { c = 0; }\n-\t\n-\n-// rope<charT,Alloc> is a sequence of charT.\n-// Ropes appear to be mutable, but update operations\n-// really copy enough of the data structure to leave the original\n-// valid.  Thus ropes can be logically copied by just copying\n-// a pointer value.\n-// The __eos function is used for those functions that\n-// convert to/from C-like strings to detect the end of the string.\n-// __compare is used as the character comparison function.\n-template <class charT>\n-class char_producer {\n-    public:\n-\tvirtual ~char_producer() {};\n-\tvirtual void operator()(size_t start_pos, size_t len, charT* buffer)\n-\t\t= 0;\n-\t// Buffer should really be an arbitrary output iterator.\n-\t// That way we could flatten directly into an ostream, etc.\n-\t// This is thoroughly impossible, since iterator types don't\n-\t// have runtime descriptions.\n-};\n-\n-// Sequence buffers:\n-//\n-// Sequence must provide an append operation that appends an\n-// array to the sequence.  Sequence buffers are useful only if\n-// appending an entire array is cheaper than appending element by element.\n-// This is true for many string representations.\n-// This should  perhaps inherit from ostream<sequence::value_type>\n-// and be implemented correspondingly, so that they can be used\n-// for formatted.  For the sake of portability, we don't do this yet.\n-//\n-// For now, sequence buffers behave as output iterators.  But they also\n-// behave a little like basic_ostringstream<sequence::value_type> and a\n-// little like containers.\n-\n-template<class sequence, size_t buf_sz = 100\n-#   if defined(__sgi) && !defined(__GNUC__)\n-#\t define __TYPEDEF_WORKAROUND\n-         ,class v = typename sequence::value_type\n-#   endif\n-        >\n-// The 3rd parameter works around a common compiler bug.\n-class sequence_buffer : public output_iterator {\n-    public:\n-#       ifndef __TYPEDEF_WORKAROUND\n-\t    typedef typename sequence::value_type value_type;\n-#\telse\n-\t    typedef v value_type;\n-#\tendif\n-    protected:\n-\tsequence *prefix;\n-\tvalue_type buffer[buf_sz];\n-\tsize_t buf_count;\n-    public:\n-\tvoid flush() {\n-\t    prefix->append(buffer, buffer + buf_count);\n-\t    buf_count = 0;\n-\t}\n-\t~sequence_buffer() { flush(); }\n-\tsequence_buffer() : prefix(0), buf_count(0) {}\n-\tsequence_buffer(const sequence_buffer & x) {\n-\t    prefix = x.prefix;\n-            buf_count = x.buf_count;\n-            copy(x.buffer, x.buffer + x.buf_count, buffer);\n-\t}\n-\tsequence_buffer(sequence_buffer & x) {\n-\t    x.flush();\n-\t    prefix = x.prefix;\n-\t    buf_count = 0;\n-\t}\n-\tsequence_buffer(sequence& s) : prefix(&s), buf_count(0) {}\n-\tsequence_buffer& operator= (sequence_buffer& x) {\n-\t    x.flush();\n-\t    prefix = x.prefix;\n-\t    buf_count = 0;\n-\t    return *this;\n-\t}\n-\tsequence_buffer& operator= (const sequence_buffer& x) {\n-\t    prefix = x.prefix;\n-\t    buf_count = x.buf_count;\n-\t    copy(x.buffer, x.buffer + x.buf_count, buffer);\n-\t    return *this;\n-\t}\n-\tvoid push_back(value_type x)\n-\t{\n-\t    if (buf_count < buf_sz) {\n-\t\tbuffer[buf_count] = x;\n-\t\t++buf_count;\n-\t    } else {\n-\t\tflush();\n-\t\tbuffer[0] = x;\n-\t\tbuf_count = 1;\n-\t    }\n-\t}\n-\tvoid append(value_type *s, size_t len)\n-\t{\n-\t    if (len + buf_count <= buf_sz) {\n-\t\tsize_t i, j;\n-\t\tfor (i = buf_count, j = 0; j < len; i++, j++) {\n-\t\t    buffer[i] = s[j];\n-\t\t}\n-\t\tbuf_count += len;\n-\t    } else if (0 == buf_count) {\n-\t\tprefix->append(s, s + len);\n-\t    } else {\n-\t\tflush();\n-\t\tappend(s, len);\n-\t    }\n-\t}\n-\tsequence_buffer& write(value_type *s, size_t len)\n-\t{\n-\t    append(s, len);\n-\t    return *this;\n-\t}\n-\tsequence_buffer& put(value_type x)\n-\t{\n-\t    push_back(x);\n-\t    return *this;\n-\t}\n-\tsequence_buffer& operator=(const value_type& rhs)\n-\t{\n-\t    push_back(rhs);\n-\t    return *this;\n-\t}\n-\tsequence_buffer& operator*() { return *this; }\n-\tsequence_buffer& operator++() { return *this; }\n-\tsequence_buffer& operator++(int) { return *this; }\n-};\n-\n-// The following should be treated as private, at least for now.\n-template<class charT>\n-class __rope_char_consumer {\n-    public:\n-\t// If we had member templates, these should not be virtual.\n-\t// For now we need to use run-time parametrization where\n-\t// compile-time would do.  Hence this should all be private\n-\t// for now.\n-\t// The symmetry with char_producer is accidental and temporary.\n-\tvirtual ~__rope_char_consumer() {};\n-\tvirtual bool operator()(const charT* buffer, size_t len) = 0;\n-};\n-\n-//\n-// What follows should really be local to rope.  Unfortunately,\n-// that doesn't work, since it makes it impossible to define generic\n-// equality on rope iterators.  According to the draft standard, the\n-// template parameters for such an equality operator cannot be inferred\n-// from the occurence of a member class as a parameter.\n-// (SGI compilers in fact allow this, but the result wouldn't be\n-// portable.)\n-// Similarly, some of the static member functions are member functions\n-// only to avoid polluting the global namespace, and to circumvent\n-// restrictions on type inference for template functions.\n-//\n-\n-template<class CharT, class Alloc=__ALLOC> class rope;\n-template<class CharT, class Alloc> struct __rope_RopeConcatenation;\n-template<class CharT, class Alloc> struct __rope_RopeLeaf;\n-template<class CharT, class Alloc> struct __rope_RopeFunction;\n-template<class CharT, class Alloc> struct __rope_RopeSubstring;\n-template<class CharT, class Alloc> class __rope_iterator;\n-template<class CharT, class Alloc> class __rope_const_iterator;\n-template<class CharT, class Alloc> class __rope_charT_ref_proxy;\n-template<class CharT, class Alloc> class __rope_charT_ptr_proxy;\n-\n-//\n-// The internal data structure for representing a rope.  This is\n-// private to the implementation.  A rope is really just a pointer\n-// to one of these.\n-//\n-// A few basic functions for manipulating this data structure\n-// are members of RopeBase.  Most of the more complex algorithms\n-// are implemented as rope members.\n-//\n-// Some of the static member functions of RopeBase have identically\n-// named functions in rope that simply invoke the RopeBase versions.\n-//\n-\n-template<class charT, class Alloc>\n-struct __rope_RopeBase {\n-    typedef rope<charT,Alloc> my_rope;\n-    typedef simple_alloc<charT, Alloc> DataAlloc;\n-    typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;\n-    typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;\n-    typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;\n-    typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;\n-    public:\n-    enum { max_rope_depth = 45 };\n-    enum {leaf, concat, substringfn, function} tag:8;\n-    bool is_balanced:8;\n-    unsigned char depth;\n-    size_t size;\n-    __GC_CONST charT * c_string;\n-\t\t\t/* Flattened version of string, if needed.  */\n-\t\t\t/* typically 0.                             */\n-\t\t\t/* If it's not 0, then the memory is owned  */\n-\t\t\t/* by this node.                            */\n-\t\t\t/* In the case of a leaf, this may point to */\n-\t\t\t/* the same memory as the data field.\t    */\n-#   ifndef __GC\n-#       if defined(__STL_WIN32THREADS)\n-\t    long refcount;  \t// InterlockedIncrement wants a long *\n-#\telse\n-\t    size_t refcount;\n-#\tendif\n-\t// We count references from rope instances\n-\t// and references from other rope nodes.  We\n-\t// do not count const_iterator references.\n-\t// Iterator references are counted so that rope modifications\n-\t// can be detected after the fact.\n-\t// Generally function results are counted, i.e.\n-\t// a pointer returned by a function is included at the\n-\t// point at which the pointer is returned.\n-\t// The recipient should decrement the count if the\n-\t// result is not needed.\n-\t// Generally function arguments are not reflected\n-\t// in the reference count.  The callee should increment\n-\t// the count before saving the argument someplace that\n-\t// will outlive the call.\n-#   endif\n-#   ifndef __GC\n-#       ifdef __STL_SGI_THREADS\n-\t    // Reference counting with multiple threads and no\n-\t    // hardware or thread package support is pretty awful.\n-\t    // Mutexes are normally too expensive.\n-\t    // We'll assume a COMPARE_AND_SWAP(destp, old, new)\n-\t    // operation, which might be cheaper.\n-#           if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64))\n-#               define __add_and_fetch(l,v) add_then_test((unsigned long *)l,v)\n-#           endif\n-\t    void init_refcount_lock() {}\n-\t    void incr_refcount ()\n-\t    {\n-\t\t__add_and_fetch(&refcount, 1);\n-\t    }\n-\t    size_t decr_refcount ()\n-\t    {\n-\t\treturn __add_and_fetch(&refcount, (size_t)(-1));\n-\t    }\n-#       elif defined(__STL_WIN32THREADS)\n-\t    void init_refcount_lock() {}\n-            void incr_refcount ()\n-            {\n-                InterlockedIncrement(&refcount);\n-            }\n-            size_t decr_refcount ()\n-            {\n-                return InterlockedDecrement(&refcount);\n-            }\n-#\telif defined(_PTHREADS)\n-\t    // This should be portable, but performance is expected\n-\t    // to be quite awful.  This really needs platform specific\n-\t    // code.\n-\t    pthread_mutex_t refcount_lock;\n-\t    void init_refcount_lock() {\n-\t\tpthread_mutex_init(&refcount_lock, 0);\n-\t    }\n-\t    void incr_refcount ()\n-            {   \n-\t\tpthread_mutex_lock(&refcount_lock);\n-                ++refcount;\n-\t\tpthread_mutex_unlock(&refcount_lock);\n-            }\n-            size_t decr_refcount ()\n-            {   \n-\t\tsize_t result;\n-\t\tpthread_mutex_lock(&refcount_lock);\n-                result = --refcount;\n-\t\tpthread_mutex_unlock(&refcount_lock);\n-                return result;\n-            }\n-#\telse\n-\t    void init_refcount_lock() {}\n-\t    void incr_refcount ()\n-\t    {\n-\t\t++refcount;\n-\t    }\n-\t    size_t decr_refcount ()\n-\t    {\n-\t\t--refcount;\n-\t\treturn refcount;\n-\t    }\n-#       endif\n-#   else\n-\tvoid incr_refcount () {}\n-#   endif\n-\tstatic void free_string(charT *, size_t len);\n-\t\t\t// Deallocate data section of a leaf.\n-\t\t\t// This shouldn't be a member function.\n-\t\t\t// But its hard to do anything else at the\n-\t\t\t// moment, because it's templatized w.r.t.\n-\t\t\t// an allocator.\n-\t\t\t// Does nothing if __GC is defined.\n-#   ifndef __GC\n-\t  void free_c_string();\n-\t  void free_tree();\n-\t\t\t// Deallocate t. Assumes t is not 0.\n-\t  void unref_nonnil()\n-\t  {\n-\t      if (0 == decr_refcount()) free_tree();\n-\t  }\n-\t  void ref_nonnil()\n-\t  {\n-\t      incr_refcount();\n-\t  }\n-\t  static void unref(__rope_RopeBase* t)\n-\t  {\n-\t      if (0 != t) {\n-\t\t  t -> unref_nonnil();\n-\t      }\n-\t  }\n-\t  static void ref(__rope_RopeBase* t)\n-\t  {\n-\t      if (0 != t) t -> incr_refcount();\n-\t  }\n-\t  static void free_if_unref(__rope_RopeBase* t)\n- \t  {\n-\t      if (0 != t && 0 == t -> refcount) t -> free_tree();\n-\t  }\n-#   else /* __GC */\n-\t  void unref_nonnil() {}\n-\t  void ref_nonnil() {}\n-\t  static void unref(__rope_RopeBase* t) {}\n-\t  static void ref(__rope_RopeBase* t) {}\n-\t  static void fn_finalization_proc(void * tree, void *);\n-\t  static void free_if_unref(__rope_RopeBase* t) {}\n-#   endif\n-\n-    // The data fields of leaves are allocated with some\n-    // extra space, to accomodate future growth and for basic\n-    // character types, to hold a trailing eos character.\n-    enum { alloc_granularity = 8 };\n-    static size_t rounded_up_size(size_t n) {\n-        size_t size_with_eos;\n-\t     \n-        if (__is_basic_char_type((charT *)0)) {\n-    \t    size_with_eos = n + 1;\n-    \t} else {\n-  \t    size_with_eos = n;\n-\t}\n-#       ifdef __GC\n-   \t   return size_with_eos;\n-#\telse\n-\t   // Allow slop for in-place expansion.\n-\t   return (size_with_eos + alloc_granularity-1)\n-\t\t\t&~ (alloc_granularity-1);\n-#\tendif\n-    }\n-};\n-\n-template<class charT, class Alloc>\n-struct __rope_RopeLeaf : public __rope_RopeBase<charT,Alloc> {\n-  public:  // Apparently needed by VC++\n-    __GC_CONST charT* data;     /* Not necessarily 0 terminated. */\n-\t\t\t\t/* The allocated size is\t */\n-\t\t\t\t/* rounded_up_size(size), except */\n-\t\t\t\t/* in the GC case, in which it\t */\n-\t\t\t\t/* doesn't matter.\t\t */\n-};\n-\n-template<class charT, class Alloc>\n-struct __rope_RopeConcatenation : public __rope_RopeBase<charT,Alloc> {\n-  public:\n-    __rope_RopeBase<charT,Alloc>* left;\n-    __rope_RopeBase<charT,Alloc>* right;\n-};\n-\n-template<class charT, class Alloc>\n-struct __rope_RopeFunction : public __rope_RopeBase<charT,Alloc> {\n-  public:\n-    char_producer<charT>* fn;\n-#   ifndef __GC\n-      bool delete_when_done;\t// Char_producer is owned by the\n-\t\t\t\t// rope and should be explicitly\n-\t\t\t\t// deleted when the rope becomes\n-\t\t\t\t// inaccessible.\n-#   else\n-      // In the GC case, we either register the rope for\n-      // finalization, or not.  Thus the field is unnecessary;\n-      // the information is stored in the collector data structures.\n-#   endif\n-};\n-// Substring results are usually represented using just\n-// concatenation nodes.  But in the case of very long flat ropes\n-// or ropes with a functional representation that isn't practical.\n-// In that case, we represent the result as a special case of\n-// RopeFunction, whose char_producer points back to the rope itself.\n-// In all cases except repeated substring operations and\n-// deallocation, we treat the result as a RopeFunction.\n-template<class charT, class Alloc>\n-struct __rope_RopeSubstring: public __rope_RopeFunction<charT,Alloc>,\n-\t\t\t     public char_producer<charT> {\n-  public:\n-    __rope_RopeBase<charT,Alloc> * base;\t// not 0\n-    size_t start;\n-    virtual ~__rope_RopeSubstring() {}\n-    virtual void operator()(size_t start_pos, size_t req_len,\n-\t\t\t    charT *buffer) {\n-\tswitch(base -> tag) {\n-\t    case function:\n-\t    case substringfn:\n-\t      {\n-\t\tchar_producer<charT> *fn =\n-\t\t\t((__rope_RopeFunction<charT,Alloc> *)base) -> fn;\n-\t\t__stl_assert(start_pos + req_len <= size);\n-\t\t__stl_assert(start + size <= base -> size);\n-\t\t(*fn)(start_pos + start, req_len, buffer);\n-\t      }\n-\t      break;\n-\t    case leaf:\n-\t      {\n-\t\t__GC_CONST charT * s =\n-\t\t\t((__rope_RopeLeaf<charT,Alloc> *)base) -> data;\n-\t\tuninitialized_copy_n(s + start_pos + start, req_len,\n-\t\t\t\t     buffer);\n-\t      }\n-\t      break;\n-\t    default:\n-\t      __stl_assert(false);\n-\t}\n-    }\n-    __rope_RopeSubstring(__rope_RopeBase<charT,Alloc> * b, size_t s, size_t l) :\n-\tbase(b), start(s) {\n-#       ifndef __GC\n-\t    refcount = 1;\n-\t    init_refcount_lock();\n-\t    base -> ref_nonnil();\n-#       endif\n-\tsize = l;\n-\ttag = substringfn;\n-\tdepth = 0;\n-\tc_string = 0;\n-\tfn = this;\n-    }\n-};\n-\n-\n-// Self-destructing pointers to RopeBase.\n-// These are not conventional smart pointers.  Their\n-// only purpose in life is to ensure that unref is called\n-// on the pointer either at normal exit or if an exception\n-// is raised.  It is the caller's responsibility to\n-// adjust reference counts when these pointers are initialized\n-// or assigned to.  (This convention significantly reduces\n-// the number of potentially expensive reference count\n-// updates.)\n-#ifndef __GC\n-  template<class charT, class Alloc>\n-  struct __rope_self_destruct_ptr {\n-    __rope_RopeBase<charT,Alloc> * ptr;\n-    ~__rope_self_destruct_ptr() { __rope_RopeBase<charT,Alloc>::unref(ptr); }\n-#   ifdef __STL_USE_EXCEPTIONS\n-\t__rope_self_destruct_ptr() : ptr(0) {};\n-#   else\n-\t__rope_self_destruct_ptr() {};\n-#   endif\n-    __rope_self_destruct_ptr(__rope_RopeBase<charT,Alloc> * p) : ptr(p) {}\n-    __rope_RopeBase<charT,Alloc> & operator*() { return *ptr; }\n-    __rope_RopeBase<charT,Alloc> * operator->() { return ptr; }\n-    operator __rope_RopeBase<charT,Alloc> *() { return ptr; }\n-    __rope_self_destruct_ptr & operator= (__rope_RopeBase<charT,Alloc> * x)\n-\t{ ptr = x; return *this; }\n-  };\n-#endif\n-\n-// unwind-protect\n-#\tifdef __STL_USE_EXCEPTIONS\n-#\t    define __STL_TRY try {\n-#\t    define __STL_UNWIND(action) } catch(...) { action; throw; }\n-#           define __STL_ALWAYS(action) action; } catch(...) { action; throw; }\n-#       else\n-#\t    define __STL_TRY {\n-#\t    define __STL_UNWIND(action) }\n-#           define __STL_ALWAYS(action) action; }\n-#\tendif\n-// Dereferencing a nonconst iterator has to return something\n-// that behaves almost like a reference.  It's not possible to\n-// return an actual reference since assignment requires extra\n-// work.  And we would get into the same problems as with the\n-// CD2 version of basic_string.\n-template<class charT, class Alloc>\n-class __rope_charT_ref_proxy {\n-    friend class rope<charT,Alloc>;\n-    friend class __rope_iterator<charT,Alloc>;\n-    friend class __rope_charT_ptr_proxy<charT,Alloc>;\n-#   ifdef __GC\n-\ttypedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;\n-#   else\n-    \ttypedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;\n-#   endif\n-    typedef __rope_RopeBase<charT,Alloc> RopeBase;\n-    typedef rope<charT,Alloc> my_rope;\n-    size_t pos;\n-    charT current;\n-    bool current_valid;\n-    my_rope * root;     // The whole rope.\n-  public:\n-    __rope_charT_ref_proxy(my_rope * r, size_t p) :\n-\tpos(p), root(r), current_valid(false) {}\n-    __rope_charT_ref_proxy(my_rope * r, size_t p,\n-\t\t    charT c) :\n-\tpos(p), root(r), current(c), current_valid(true) {}\n-    operator charT () const;\n-    __rope_charT_ref_proxy& operator= (charT c);\n-    __rope_charT_ptr_proxy<charT,Alloc> operator& () const;\n-    __rope_charT_ref_proxy& operator= (const __rope_charT_ref_proxy& c) {\n-\treturn operator=((charT)c); \n-    }\n-};\n-\n-template<class charT, class Alloc>\n-class __rope_charT_ptr_proxy {\n-    friend class __rope_charT_ref_proxy<charT,Alloc>;\n-    size_t pos;\n-    charT current;\n-    bool current_valid;\n-    rope<charT,Alloc> * root;     // The whole rope.\n-  public:\n-    __rope_charT_ptr_proxy(const __rope_charT_ref_proxy<charT,Alloc> & x) :\n-\tpos(x.pos), root(x.root), current_valid(x.current_valid),\n-\tcurrent(x.current) {}\n-    __rope_charT_ptr_proxy(const __rope_charT_ptr_proxy & x) :\n-\tpos(x.pos), root(x.root), current_valid(x.current_valid),\n-\tcurrent(x.current) {}\n-    __rope_charT_ptr_proxy() {}\n-    __rope_charT_ptr_proxy(charT * x) : root(0), pos(0) {\n-\t__stl_assert(0 == x);\n-    }\n-    __rope_charT_ptr_proxy& operator= (const __rope_charT_ptr_proxy& x) {\n-\tpos = x.pos;\n-\tcurrent = x.current;\n-\tcurrent_valid = x.current_valid;\n-\troot = x.root;\n-\treturn *this;\n-    }\n-    friend bool operator==\n-                (const __rope_charT_ptr_proxy<charT,Alloc> & x,\n-                 const __rope_charT_ptr_proxy<charT,Alloc> & y);\n-    __rope_charT_ref_proxy<charT,Alloc> operator *() const {\n-\tif (current_valid) {\n-\t    return __rope_charT_ref_proxy<charT,Alloc>(root, pos, current);\n-\t} else {\n-\t    return __rope_charT_ref_proxy<charT,Alloc>(root, pos);\n-\t}\n-    }\n-};\n-\n-// Rope iterators:\n-// Unlike in the C version, we cache only part of the stack\n-// for rope iterators, since they must be efficiently copyable.\n-// When we run out of cache, we have to reconstruct the iterator\n-// value.\n-// Pointers from iterators are not included in reference counts.\n-// Iterators are assumed to be thread private.  Ropes can\n-// be shared.\n-\n-template<class charT, class Alloc>\n-class __rope_iterator_base:\n-  public random_access_iterator<charT, ptrdiff_t> {\n-  friend class rope<charT, Alloc>;\n-  public:\n-    typedef __rope_RopeBase<charT,Alloc> RopeBase;\n-\t// Borland doesnt want this to be protected.\n-  protected:\n-    enum { path_cache_len = 4 }; // Must be <= 9.\n-    enum { iterator_buf_len = 15 };\n-    size_t current_pos;\n-    RopeBase * root;     // The whole rope.\n-    size_t leaf_pos;    // Starting position for current leaf\n-    __GC_CONST charT * buf_start;\n-\t\t\t// Buffer possibly\n-\t\t\t// containing current char.\n-    __GC_CONST charT * buf_ptr;\n-\t\t\t// Pointer to current char in buffer.\n-\t\t\t// != 0 ==> buffer valid.\n-    __GC_CONST charT * buf_end;\n-\t\t\t// One past last valid char in buffer.\n-    // What follows is the path cache.  We go out of our\n-    // way to make this compact.\n-    // Path_end contains the bottom section of the path from\n-    // the root to the current leaf.\n-    const RopeBase * path_end[path_cache_len];\n-    int leaf_index;     // Last valid pos in path_end;\n-    \t\t\t// path_end[0] ... path_end[leaf_index-1]\n-\t\t\t// point to concatenation nodes.\n-    unsigned char path_directions;\n-\t\t\t  // (path_directions >> i) & 1 is 1\n-\t\t\t  // iff we got from path_end[leaf_index - i - 1]\n-\t\t\t  // to path_end[leaf_index - i] by going to the\n-\t\t\t  // right. Assumes path_cache_len <= 9.\n-    charT tmp_buf[iterator_buf_len];\n-\t\t\t// Short buffer for surrounding chars.\n-\t\t\t// This is useful primarily for \n-\t\t\t// RopeFunctions.  We put the buffer\n-\t\t\t// here to avoid locking in the\n-\t\t\t// multithreaded case.\n-    // The cached path is generally assumed to be valid\n-    // only if the buffer is valid.\n-    static void setbuf(__rope_iterator_base &x);\n-\t\t\t\t\t// Set buffer contents given\n-\t\t\t\t\t// path cache.\n-    static void setcache(__rope_iterator_base &x);\n-\t\t\t\t\t// Set buffer contents and\n-\t\t\t\t\t// path cache.\n-    static void setcache_for_incr(__rope_iterator_base &x);\n-\t\t\t\t\t// As above, but assumes path\n-\t\t\t\t\t// cache is valid for previous posn.\n-    __rope_iterator_base() {}\n-    __rope_iterator_base(RopeBase * root, size_t pos):\n-\t\t   root(root), current_pos(pos), buf_ptr(0) {}\n-    __rope_iterator_base(const __rope_iterator_base& x) {\n-\tif (0 != x.buf_ptr) {\n-\t    *this = x;\n-\t} else {\n-\t    current_pos = x.current_pos;\n-\t    root = x.root;\n-\t    buf_ptr = 0;\n-\t}\n-    }\n-    void incr(size_t n);\n-    void decr(size_t n);\n-  public:\n-    size_t index() const { return current_pos; }\n-};\n-\n-template<class charT, class Alloc> class __rope_iterator;\n-\n-template<class charT, class Alloc>\n-class __rope_const_iterator : public __rope_iterator_base<charT,Alloc> {\n-    friend class rope<charT,Alloc>;\n-  protected:\n-    __rope_const_iterator(const RopeBase * root, size_t pos):\n-\t\t   __rope_iterator_base<charT,Alloc>(\n-\t\t     const_cast<RopeBase *>(root), pos)\n-\t\t   // Only nonconst iterators modify root ref count\n-    {}\n-  public:\n-    typedef charT reference;    // Really a value.  Returning a reference\n-\t\t\t\t// Would be a mess, since it would have\n-\t\t\t\t// to be included in refcount.\n-    typedef const charT* pointer;\n-\n-  public:\n-    __rope_const_iterator() {};\n-    __rope_const_iterator(const __rope_const_iterator & x) :\n-\t\t\t\t__rope_iterator_base<charT,Alloc>(x) { }\n-    __rope_const_iterator(const __rope_iterator<charT,Alloc> & x);\n-    __rope_const_iterator(const rope<charT,Alloc> &r, size_t pos) :\n-\t__rope_iterator_base<charT,Alloc>(r.tree_ptr, pos) {}\n-    __rope_const_iterator& operator= (const __rope_const_iterator & x) {\n-\tif (0 != x.buf_ptr) {\n-\t    *this = x;\n-\t} else {\n-\t    current_pos = x.current_pos;\n-\t    root = x.root;\n-\t    buf_ptr = 0;\n-\t}\n-\treturn(*this);\n-    }\n-    reference operator*() {\n-\tif (0 == buf_ptr) setcache(*this);\n-\treturn *buf_ptr;\n-    }\n-    __rope_const_iterator& operator++() {\n-\t__GC_CONST charT * next;\n-\tif (0 != buf_ptr && (next = buf_ptr + 1) < buf_end) {\n-\t    buf_ptr = next;\n-\t    ++current_pos;\n-\t} else {\n-\t    incr(1);\n-\t}\n-\treturn *this;\n-    }\n-    __rope_const_iterator& operator+=(ptrdiff_t n) {\n-\tif (n >= 0) {\n-\t    incr(n);\n-\t} else {\n-\t    decr(-n);\n-\t}\n-\treturn *this;\n-    }\n-    __rope_const_iterator& operator--() {\n-\tdecr(1);\n-\treturn *this;\n-    }\n-    __rope_const_iterator& operator-=(ptrdiff_t n) {\n-\tif (n >= 0) {\n-\t    decr(n);\n-\t} else {\n-\t    incr(-n);\n-\t}\n-\treturn *this;\n-    }\n-    __rope_const_iterator operator++(int) {\n-\tsize_t old_pos = current_pos;\n-\tincr(1);\n-\treturn __rope_const_iterator<charT,Alloc>(root, old_pos);\n-\t// This makes a subsequent dereference expensive.\n-\t// Perhaps we should instead copy the iterator\n-\t// if it has a valid cache?\n-    }\n-    __rope_const_iterator operator--(int) {\n-\tsize_t old_pos = current_pos;\n-\tdecr(1);\n-\treturn __rope_const_iterator<charT,Alloc>(root, old_pos);\n-    }\n-    friend __rope_const_iterator<charT,Alloc> operator-\n-\t(const __rope_const_iterator<charT,Alloc> & x,\n-\t ptrdiff_t n);\n-    friend __rope_const_iterator<charT,Alloc> operator+\n-\t(const __rope_const_iterator<charT,Alloc> & x,\n-\t ptrdiff_t n);\n-    friend __rope_const_iterator<charT,Alloc> operator+\n-\t(ptrdiff_t n,\n-\t const __rope_const_iterator<charT,Alloc> & x);\n-    reference operator[](size_t n) {\n-\treturn rope<charT,Alloc>::fetch(root, current_pos + n);\n-    }\n-    friend bool operator==\n-\t(const __rope_const_iterator<charT,Alloc> & x,\n-\t const __rope_const_iterator<charT,Alloc> & y);\n-    friend bool operator<\n-\t(const __rope_const_iterator<charT,Alloc> & x,\n-\t const __rope_const_iterator<charT,Alloc> & y);\n-    friend ptrdiff_t operator-\n-\t(const __rope_const_iterator<charT,Alloc> & x,\n-\t const __rope_const_iterator<charT,Alloc> & y);\n-};\n-\n-template<class charT, class Alloc>\n-class __rope_iterator : public __rope_iterator_base<charT,Alloc> {\n-    friend class rope<charT,Alloc>;\n-  protected:\n-    rope<charT,Alloc> * root_rope;\n-\t// root is treated as a cached version of this,\n-\t// and is used to detect changes to the underlying\n-\t// rope.\n-\t// Root is included in the reference count.\n-\t// This is necessary so that we can detect changes reliably.\n-\t// Unfortunately, it requires careful bookkeeping for the\n-\t// nonGC case.\n-    __rope_iterator(rope<charT,Alloc> * r, size_t pos):\n-\t     __rope_iterator_base<charT,Alloc>(r -> tree_ptr, pos),\n-\t     root_rope(r) {\n-\t\tRopeBase::ref(root);\n-\t     }\n-    void check();\n-  public:\n-    typedef __rope_charT_ref_proxy<charT,Alloc>  reference;\n-    typedef __rope_charT_ref_proxy<charT,Alloc>* pointer;\n-\n-  public:\n-    rope<charT,Alloc>& container() { return *root_rope; }\n-    __rope_iterator() {\n-\troot = 0;  // Needed for reference counting.\n-    };\n-    __rope_iterator(const __rope_iterator & x) :\n-\t__rope_iterator_base<charT,Alloc>(x) {\n-\troot_rope = x.root_rope;\n-\tRopeBase::ref(root);\n-    }\n-    __rope_iterator(rope<charT,Alloc>& r, size_t pos);\n-    ~__rope_iterator() {\n-\tRopeBase::unref(root);\n-    }\n-    __rope_iterator& operator= (const __rope_iterator & x) {\n-\tRopeBase *old = root;\n-\n-\tRopeBase::ref(x.root);\n-\tif (0 != x.buf_ptr) {\n-\t    *this = x;\n-\t} else {\n-\t    current_pos = x.current_pos;\n-\t    root = x.root;\n-\t    root_rope = x.root_rope;\n-\t    buf_ptr = 0;\n-\t}\n-\tRopeBase::unref(old);\n-\treturn(*this);\n-    }\n-    reference operator*() {\n-\tcheck();\n-\tif (0 == buf_ptr) {\n-\t    return __rope_charT_ref_proxy<charT,Alloc>(root_rope, current_pos);\n-\t} else {\n-\t    return __rope_charT_ref_proxy<charT,Alloc>(root_rope,\n-\t\t\t\t\t\t       current_pos, *buf_ptr);\n-\t}\n-    }\n-    __rope_iterator& operator++() {\n-\tincr(1);\n-\treturn *this;\n-    }\n-    __rope_iterator& operator+=(difference_type n) {\n-\tif (n >= 0) {\n-\t    incr(n);\n-\t} else {\n-\t    decr(-n);\n-\t}\n-\treturn *this;\n-    }\n-    __rope_iterator& operator--() {\n-\tdecr(1);\n-\treturn *this;\n-    }\n-    __rope_iterator& operator-=(difference_type n) {\n-\tif (n >= 0) {\n-\t    decr(n);\n-\t} else {\n-\t    incr(-n);\n-\t}\n-\treturn *this;\n-    }\n-    __rope_iterator operator++(int) {\n-\tsize_t old_pos = current_pos;\n-\tincr(1);\n-\treturn __rope_iterator<charT,Alloc>(root_rope, old_pos);\n-    }\n-    __rope_iterator operator--(int) {\n-\tsize_t old_pos = current_pos;\n-\tdecr(1);\n-\treturn __rope_iterator<charT,Alloc>(root_rope, old_pos);\n-    }\n-    reference operator[](ptrdiff_t n) {\n-\treturn __rope_charT_ref_proxy<charT,Alloc>(root_rope, current_pos + n);\n-    }\n-    friend bool operator==\n-\t(const __rope_iterator<charT,Alloc> & x,\n-\t const __rope_iterator<charT,Alloc> & y);\n-    friend bool operator<\n-\t(const __rope_iterator<charT,Alloc> & x,\n-\t const __rope_iterator<charT,Alloc> & y);\n-    friend ptrdiff_t operator-\n-\t(const __rope_iterator<charT,Alloc> & x,\n-\t const __rope_iterator<charT,Alloc> & y);\n-    friend __rope_iterator<charT,Alloc> operator-\n-\t(const __rope_iterator<charT,Alloc> & x,\n-\t ptrdiff_t n);\n-    friend __rope_iterator<charT,Alloc> operator+\n-\t(const __rope_iterator<charT,Alloc> & x,\n-\t ptrdiff_t n);\n-    friend __rope_iterator<charT,Alloc> operator+\n-\t(ptrdiff_t n,\n-\t const __rope_iterator<charT,Alloc> & x);\n-\n-};\n-\n-template <class charT, class Alloc>\n-class rope {\n-    public:\n-\ttypedef charT value_type;\n-\ttypedef ptrdiff_t difference_type;\n-\ttypedef size_t size_type;\n-\ttypedef charT const_reference;\n-\ttypedef const charT* const_pointer;\n-\ttypedef __rope_iterator<charT,Alloc> iterator;\n-\ttypedef __rope_const_iterator<charT,Alloc> const_iterator;\n-\ttypedef __rope_charT_ref_proxy<charT,Alloc> reference;\n-\ttypedef __rope_charT_ptr_proxy<charT,Alloc> pointer;\n-\n-\tfriend class __rope_iterator<charT,Alloc>;\n-\tfriend class __rope_const_iterator<charT,Alloc>;\n-\tfriend struct __rope_RopeBase<charT,Alloc>;\n-\tfriend class __rope_iterator_base<charT,Alloc>;\n-\tfriend class __rope_charT_ptr_proxy<charT,Alloc>;\n-\tfriend class __rope_charT_ref_proxy<charT,Alloc>;\n-\tfriend struct __rope_RopeSubstring<charT,Alloc>;\n-\n-    protected:\n-\ttypedef __GC_CONST charT * cstrptr;\n-#       ifdef __STL_SGI_THREADS\n-\t    static cstrptr atomic_swap(cstrptr *p, cstrptr q) {\n-#               if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64))\n-                    return (cstrptr) test_and_set((unsigned long *)p,\n-\t\t\t   \t\t          (unsigned long)q);\n-#\t\telse\n-                    return (cstrptr) __test_and_set((unsigned long *)p,\n-\t\t\t   \t\t            (unsigned long)q);\n-#\t\tendif\n-            }\n-#       elif defined(__STL_WIN32THREADS)\n-\t    static cstrptr atomic_swap(cstrptr *p, cstrptr q) {\n-\t\treturn (cstrptr) InterlockedExchange((LPLONG)p, (LONG)q);\n-\t    }\n-#\telif defined(_PTHREADS)\n-\t    // This should be portable, but performance is expected\n-\t    // to be quite awful.  This really needs platform specific\n-\t    // code.\n-\t    static pthread_mutex_t swap_lock;\n-\t    static cstrptr atomic_swap(cstrptr *p, cstrptr q) {\n-\t\tpthread_mutex_lock(&swap_lock);\n-\t\tcstrptr result = *p;\n-\t\t*p = q;\n-\t\tpthread_mutex_unlock(&swap_lock);\n-\t\treturn result;\n-            }\n-#\telse\n-\t    static cstrptr atomic_swap(cstrptr *p, cstrptr q) {\n-                cstrptr result = *p;\n-                *p = q;\n-\t\treturn result;\n-\t    }\n-#       endif\n-\n-\tstatic charT empty_c_str[1];\n-\n-    \ttypedef simple_alloc<charT, Alloc> DataAlloc;\n-    \ttypedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;\n-    \ttypedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;\n-    \ttypedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;\n-    \ttypedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;\n-\tstatic bool is0(charT c) { return c == __eos((charT *)0); }\n-\tenum { copy_max = 23 };\n-\t\t// For strings shorter than copy_max, we copy to\n-\t\t// concatenate.\n-\n-\ttypedef __rope_RopeBase<charT,Alloc> RopeBase;\n-\ttypedef __rope_RopeConcatenation<charT,Alloc> RopeConcatenation;\n-\ttypedef __rope_RopeLeaf<charT,Alloc> RopeLeaf;\n-\ttypedef __rope_RopeFunction<charT,Alloc> RopeFunction;\n-\ttypedef __rope_RopeSubstring<charT,Alloc> RopeSubstring;\n-\n-\t// The only data member of a rope:\n-\tRopeBase *tree_ptr;\n-\n-\t// Retrieve a character at the indicated position.\n-\tstatic charT fetch(RopeBase * r, size_type pos);\n-\n-#\tifndef __GC\n-\t    // Obtain a pointer to the character at the indicated position.\n-\t    // The pointer can be used to change the character.\n-\t    // If such a pointer cannot be produced, as is frequently the\n-\t    // case, 0 is returned instead.\n-\t    // (Returns nonzero only if all nodes in the path have a refcount\n-\t    // of 1.)\n-\t    static charT * fetch_ptr(RopeBase * r, size_type pos);\n-#\tendif\n-\n-\tstatic bool apply_to_pieces(\n-\t\t\t\t// should be template parameter\n-\t\t\t\t__rope_char_consumer<charT>& c,\n-\t\t\t\tconst RopeBase * r,\n-\t\t\t\tsize_t begin, size_t end);\n-\t\t\t\t// begin and end are assumed to be in range.\n-\n-#\tifndef __GC\n-\t  static void unref(RopeBase* t)\n-\t  {\n-\t      RopeBase::unref(t);\n-\t  }\n-\t  static void ref(RopeBase* t)\n-\t  {\n-\t      RopeBase::ref(t);\n-\t  }\n-#       else /* __GC */\n-\t  static void unref(RopeBase* t) {}\n-\t  static void ref(RopeBase* t) {}\n-#       endif\n-\n-\n-#       ifdef __GC\n-\t    typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;\n-#   \telse\n-\t    typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;\n-#\tendif\n-\n-\t// Result is counted in refcount.\n-\tstatic RopeBase * substring(RopeBase * base,\n-\t\t\t\t    size_t start, size_t endp1);\n-\n-\tstatic RopeBase * concat_char_iter(RopeBase * r,\n-\t\t\t\t\t  const charT *iter, size_t slen);\n-\t\t// Concatenate rope and char ptr, copying s.\n-\t\t// Should really take an arbitrary iterator.\n-\t\t// Result is counted in refcount.\n-\tstatic RopeBase * destr_concat_char_iter(RopeBase * r,\n-\t\t\t\t\t\t const charT *iter, size_t slen)\n-\t\t// As above, but one reference to r is about to be\n-\t\t// destroyed.  Thus the pieces may be recycled if all\n-\t\t// relevent reference counts are 1.\n-#\t    ifdef __GC\n-\t\t// We can't really do anything since refcounts are unavailable.\n-\t\t{ return concat_char_iter(r, iter, slen); }\n-#\t    else\n-\t\t;\n-#\t    endif\n-\n-\tstatic RopeBase * concat(RopeBase *left, RopeBase *right);\n-\t\t// General concatenation on RopeBase.  Result\n-\t\t// has refcount of 1.  Adjusts argument refcounts.\n-\n-   public:\n-\tvoid apply_to_pieces( size_t begin, size_t end,\n-\t\t\t      __rope_char_consumer<charT>& c) const {\n-\t    apply_to_pieces(c, tree_ptr, begin, end);\n-\t}\n-\n-\n-   protected:\n-\n-\tstatic size_t rounded_up_size(size_t n) {\n-\t    return RopeBase::rounded_up_size(n);\n-\t}\n-\n-\tstatic size_t allocated_capacity(size_t n) {\n-\t    if (__is_basic_char_type((charT *)0)) {\n-\t\treturn rounded_up_size(n) - 1;\n-\t    } else {\n-\t\treturn rounded_up_size(n);\n-\t    }\n-\t}\n-\t\t\n-\t// s should really be an arbitrary input iterator.\n-\t// Adds a trailing NULL for basic char types.\n-\tstatic charT * alloc_copy(const charT *s, size_t size)\n-\t{\n-\t    charT * result = DataAlloc::allocate(rounded_up_size(size));\n-\n-\t    uninitialized_copy_n(s, size, result);\n-\t    __cond_store_eos(result[size]);\n-\t    return(result);\n-\t}\n-\n-\t// Basic constructors for rope tree nodes.\n-\t// These return tree nodes with a 0 reference count.\n-\tstatic RopeLeaf * RopeLeaf_from_char_ptr(__GC_CONST charT *s,\n-\t\t\t\t\t\t size_t size);\n-\t\t// Takes ownership of its argument.\n-\t\t// Result has refcount 1.\n-\t\t// In the nonGC, basic_char_type  case it assumes that s\n-\t\t// is eos-terminated.\n-\t\t// In the nonGC case, it was allocated from Alloc with\n-\t\t// rounded_up_size(size).\n-\n-\tstatic RopeLeaf * RopeLeaf_from_unowned_char_ptr(const charT *s,\n-\t\t\t\t\t\t         size_t size) {\n-\t    charT * buf = alloc_copy(s, size);\n-            __STL_TRY\n-              return RopeLeaf_from_char_ptr(buf, size);\n-            __STL_UNWIND(RopeBase::free_string(buf, size))\n-\t}\n-\t    \n-\n-\t// Concatenation of nonempty strings.\n-\t// Always builds a concatenation node.\n-\t// Rebalances if the result is too deep.\n-\t// Result has refcount 1.\n-\t// Does not increment left and right ref counts even though\n-\t// they are referenced.\n-\tstatic RopeBase * tree_concat(RopeBase * left, RopeBase * right);\n-\n-\t// Result has refcount 1.\n-\t// If delete_fn is true, then fn is deleted when the rope\n-\t// becomes inaccessible.\n-\tstatic RopeFunction * RopeFunction_from_fn\n-\t\t\t(char_producer<charT> *fn, size_t size,\n-\t\t\t bool delete_fn);\n-\n-\t// Concatenation helper functions\n-\tstatic RopeLeaf * leaf_concat_char_iter\n-\t\t\t(RopeLeaf * r, const charT * iter, size_t slen);\n-\t\t// Concatenate by copying leaf.\n-\t\t// should take an arbitrary iterator\n-\t\t// result has refcount 1.\n-#\tifndef __GC\n-\t  static RopeLeaf * destr_leaf_concat_char_iter\n-\t\t\t(RopeLeaf * r, const charT * iter, size_t slen);\n-\t  // A version that potentially clobbers r if r -> refcount == 1.\n-#       endif\n-\n-\t// A helper function for exponentiating strings.\n-\t// This uses a nonstandard refcount convention.\n-\t// The result has refcount 0.\n-\tstruct concat_fn;\n-\tfriend struct rope<charT,Alloc>::concat_fn;\n-\n-\tstruct concat_fn\n-\t\t: binary_function<rope<charT,Alloc>, rope<charT,Alloc>,\n-\t\t\t\t  rope<charT,Alloc> > {\n-\t\trope operator() (const rope& x, const rope& y) {\n-\t\t    return x + y;\n-\t\t}\n-\t};\n-\n-        friend rope identity_element(concat_fn) { return rope<charT,Alloc>(); }\n-\n-\tstatic size_t char_ptr_len(const charT * s);\n-\t\t\t// slightly generalized strlen\n-\n-\trope(RopeBase *t) : tree_ptr(t) { }\n-\n-\n-\t// Copy r to the CharT buffer.\n-\t// Returns buffer + r -> size.\n-\t// Assumes that buffer is uninitialized.\n-\tstatic charT * flatten(RopeBase * r, charT * buffer);\n-\n-\t// Again, with explicit starting position and length.\n-\t// Assumes that buffer is uninitialized.\n-\tstatic charT * flatten(RopeBase * r,\n-\t\t\t       size_t start, size_t len,\n-\t\t\t       charT * buffer);\n-\n-\tstatic const unsigned long min_len[RopeBase::max_rope_depth + 1];\n-\n-\tstatic bool is_balanced(RopeBase *r)\n-\t\t{ return (r -> size >= min_len[r -> depth]); }\n-\n-\tstatic bool is_almost_balanced(RopeBase *r)\n-\t\t{ return (r -> depth == 0 ||\n-\t\t\t  r -> size >= min_len[r -> depth - 1]); }\n-\n-\tstatic bool is_roughly_balanced(RopeBase *r)\n-\t\t{ return (r -> depth <= 1 ||\n-\t\t\t  r -> size >= min_len[r -> depth - 2]); }\n-\n-\t// Assumes the result is not empty.\n-\tstatic RopeBase * concat_and_set_balanced(RopeBase *left,\n-\t\t\t\t\t\t  RopeBase *right)\n-\t{\n-\t    RopeBase * result = concat(left, right);\n-\t    if (is_balanced(result)) result -> is_balanced = true;\n-\t    return result;\n-\t}\n-\n-\t// The basic rebalancing operation.  Logically copies the\n-\t// rope.  The result has refcount of 1.  The client will\n-\t// usually decrement the reference count of r.\n-\t// The result isd within height 2 of balanced by the above\n-\t// definition.\n-\tstatic RopeBase * balance(RopeBase * r);\n-\n-\t// Add all unbalanced subtrees to the forest of balanceed trees.\n-\t// Used only by balance.\n-\tstatic void add_to_forest(RopeBase *r, RopeBase **forest);\n-\t\n-\t// Add r to forest, assuming r is already balanced.\n-\tstatic void add_leaf_to_forest(RopeBase *r, RopeBase **forest);\n-\n-\t// Print to stdout, exposing structure\n-\tstatic void dump(RopeBase * r, int indent = 0);\n-\n-\t// Return -1, 0, or 1 if x < y, x == y, or x > y resp.\n-\tstatic int compare(const RopeBase *x, const RopeBase *y);\n-\n-   public:\n-\tbool empty() const { return 0 == tree_ptr; }\n-\n-\t// Comparison member function.  This is public only for those\n-\t// clients that need a ternary comparison.  Others\n-\t// should use the comparison operators below.\n-\tint compare(const rope &y) const {\n-\t    return compare(tree_ptr, y.tree_ptr);\n-\t}\n-\n-\trope(const charT *s)\n-\t{\n-\t    size_t len = char_ptr_len(s);\n-\n-\t    if (0 == len) {\n-\t\ttree_ptr = 0;\n-\t    } else {\n-\t\ttree_ptr = RopeLeaf_from_unowned_char_ptr(s, len);\n-#\t\tifndef __GC\n-\t\t  __stl_assert(1 == tree_ptr -> refcount);\n-#\t\tendif\n-\t    }\n-\t}\n-\n-\trope(const charT *s, size_t len)\n-\t{\n-\t    if (0 == len) {\n-\t\ttree_ptr = 0;\n-\t    } else {\n-\t\ttree_ptr = RopeLeaf_from_unowned_char_ptr(s, len);\n-\t    }\n-\t}\n-\n-\trope(const charT *s, charT *e)\n-\t{\n-\t    size_t len = e - s;\n-\n-\t    if (0 == len) {\n-\t\ttree_ptr = 0;\n-\t    } else {\n-\t\ttree_ptr = RopeLeaf_from_unowned_char_ptr(s, len);\n-\t    }\n-\t}\n-\n-\trope(const const_iterator& s, const const_iterator& e)\n-\t{\n-\t    tree_ptr = substring(s.root, s.current_pos, e.current_pos);\n-\t}\n-\n-\trope(const iterator& s, const iterator& e)\n-\t{\n-\t    tree_ptr = substring(s.root, s.current_pos, e.current_pos);\n-\t}\n-\n-\trope(charT c)\n-\t{\n-\t    charT * buf = DataAlloc::allocate(rounded_up_size(1));\n-\n-\t    construct(buf, c);\n-\t    __STL_TRY\n-\t        tree_ptr = RopeLeaf_from_char_ptr(buf, 1);\n-            __STL_UNWIND(RopeBase::free_string(buf, 1))\n-\t}\n-\n-\trope(size_t n, charT c);\n-\n-\t// Should really be templatized with respect to the iterator type\n-\t// and use sequence_buffer.  (It should perhaps use sequence_buffer\n-\t// even now.)\n-\trope(const charT *i, const charT *j)\n-\t{\n-\t    if (i == j) {\n-\t\ttree_ptr = 0;\n-\t    } else {\n-\t\tsize_t len = j - i;\n-\t\ttree_ptr = RopeLeaf_from_unowned_char_ptr(i, len);\n-\t    }\n-\t}\n-\n-\trope()\n-\t{\n-\t    tree_ptr = 0;\n-\t}\n-\n-\t// Construct a rope from a function that can compute its members\n-\trope(char_producer<charT> *fn, size_t len, bool delete_fn)\n-\t{\n-\t    tree_ptr = RopeFunction_from_fn(fn, len, delete_fn);\n-\t}\n-\n-\trope(const rope &x)\n-\t{\n-\t    tree_ptr = x.tree_ptr;\n-\t    ref(tree_ptr);\n-\t}\n-\n-\t~rope()\n-\t{\n-\t    unref(tree_ptr);\n-\t}\n-\n-\trope& operator=(const rope& x)\n-\t{\n-\t    RopeBase *old = tree_ptr;\n-\t    tree_ptr = x.tree_ptr;\n-\t    ref(tree_ptr);\n-\t    unref(old);\n-\t    return(*this);\n-\t}\n-\n-\tvoid push_back(charT x)\n-\t{\n-\t    RopeBase *old = tree_ptr;\n-\t    tree_ptr = concat_char_iter(tree_ptr, &x, 1);\n-\t    unref(old);\n-\t}\n-\n-\tvoid pop_back()\n-\t{\n-\t    RopeBase *old = tree_ptr;\n-\t    tree_ptr = substring(tree_ptr, 0, tree_ptr -> size - 1);\n-\t    unref(old);\n-\t}\n-\n-\tcharT back() const\n-\t{\n-\t    return fetch(tree_ptr, tree_ptr -> size - 1);\n-\t}\n-\n-\tvoid push_front(charT x)\n-\t{\n-\t    RopeBase *old = tree_ptr;\n-\t    RopeBase *left;\n-\n-\t    left = RopeLeaf_from_unowned_char_ptr(&x, 1);\n-\t    __STL_TRY\n-\t      tree_ptr = concat(left, tree_ptr);\n-\t      unref(old);\n-\t    __STL_ALWAYS(unref(left))\n-\t}\n-\n-\tvoid pop_front()\n-\t{\n-\t    RopeBase *old = tree_ptr;\n-\t    tree_ptr = substring(tree_ptr, 1, tree_ptr -> size);\n-\t    unref(old);\n-\t}\n-\n-\tcharT front() const\n-\t{\n-\t    return fetch(tree_ptr, 0);\n-\t}\n-\n-\tvoid balance()\n-\t{\n-\t    RopeBase *old = tree_ptr;\n-\t    tree_ptr = balance(tree_ptr);\n-\t    unref(old);\n-\t}\n-\n-\tvoid copy(charT * buffer) const {\n-\t    destroy(buffer, buffer + size());\n-\t    flatten(tree_ptr, buffer);\n-\t}\n-\n-\t// This is the copy function from the standard, but\n-\t// with the arguments reordered to make it consistent with the\n-\t// rest of the interface.\n-\t// Note that this guaranteed not to compile if the draft standard\n-\t// order is assumed.\n-\tsize_type copy(size_type pos, size_type n, charT *buffer) const {\n-\t    size_t sz = size();\n-\t    size_t len = (pos + n > sz? sz - pos : n);\n-\n-\t    destroy(buffer, buffer + len);\n-\t    flatten(tree_ptr, pos, len, buffer);\n-\t    return len;\n-\t}\n-\n-\t// Print to stdout, exposing structure.  May be useful for\n-\t// performance debugging.\n-\tvoid dump() {\n-\t    dump(tree_ptr);\n-\t}\n-\n-\t// Convert to 0 terminated string in new allocated memory.\n-\t// Embedded 0s in the input do not terminate the copy.\n-\tconst charT * c_str() const;\n-\n-\t// As above, but lso use the flattened representation as the\n-\t// the new rope representation.\n-\tconst charT * replace_with_c_str();\n-\n-\t// Reclaim memory for the c_str generated flattened string.\n-\t// Intentionally undocumented, since it's hard to say when this\n-\t// is safe for multiple threads.\n-\tvoid delete_c_str () {\n-\t    if (0 == tree_ptr) return;\n-\t    if (RopeBase::leaf == tree_ptr -> tag\n-\t\t&& ((RopeLeaf *)tree_ptr) -> data == tree_ptr -> c_string) {\n-\t\t// Representation shared\n-\t\treturn;\n-\t    }\n-#\t    ifndef __GC\n-\t      tree_ptr -> free_c_string();\n-#\t    endif\n-\t    tree_ptr -> c_string = 0;\n-\t}\n-\n-\tcharT operator[] (size_type pos) const {\n-\t    return fetch(tree_ptr, pos);\n-\t}\n-\n-\tcharT at(size_type pos) const {\n-\t   // if (pos >= size()) throw out_of_range;\n-\t   return (*this)[pos];\n-\t}\n-\n-\tconst_iterator begin() const {\n-\t    return(const_iterator(tree_ptr, 0));\n-\t}\n-\n-\t// An easy way to get a const iterator from a non-const container.\n-\tconst_iterator const_begin() const {\n-\t    return(const_iterator(tree_ptr, 0));\n-\t}\n-\n-\tconst_iterator end() const {\n-\t    return(const_iterator(tree_ptr, size()));\n-\t}\n-\n-\tconst_iterator const_end() const {\n-\t    return(const_iterator(tree_ptr, size()));\n-\t}\n-\n-\tsize_type size() const { \n-\t    return(0 == tree_ptr? 0 : tree_ptr -> size);\n-\t}\n-\n-\tsize_type length() const {\n-\t    return size();\n-\t}\n-\n-\tsize_type max_size() const {\n-\t    return min_len[RopeBase::max_rope_depth-1] - 1;\n-\t    //  Guarantees that the result can be sufficirntly\n-\t    //  balanced.  Longer ropes will probably still work,\n-\t    //  but it's harder to make guarantees.\n-\t}\n-\n-#     ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-        typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-#     else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\ttypedef reverse_iterator<const_iterator, value_type, const_reference,\n-\t\t\t\t difference_type>  const_reverse_iterator;\n-#     endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ \n-\n-\tconst_reverse_iterator rbegin() const {\n-\t    return const_reverse_iterator(end());\n-\t}\n-\n-\tconst_reverse_iterator const_rbegin() const {\n-\t    return const_reverse_iterator(end());\n-\t}\n-\n-\tconst_reverse_iterator rend() const {\n-\t    return const_reverse_iterator(begin());\n-\t}\n-\n-\tconst_reverse_iterator const_rend() const {\n-\t    return const_reverse_iterator(begin());\n-\t}\n-\n-\tfriend rope<charT,Alloc> operator+ (const rope<charT,Alloc> &left,\n-\t\t\t\t\t    const rope<charT,Alloc> &right);\n-\t\n-\tfriend rope<charT,Alloc> operator+ (const rope<charT,Alloc> &left,\n-\t\t\t\t\t    const charT* right);\n-\t\n-\tfriend rope<charT,Alloc> operator+ (const rope<charT,Alloc> &left,\n-\t\t\t\t\t    charT right);\n-\t\n-\t// The symmetric cases are intentionally omitted, since they're presumed\n-\t// to be less common, and we don't handle them as well.\n-\n-\t// The following should really be templatized.\n-\t// The first argument should be an input iterator or\n-\t// forward iterator with value_type charT.\n-\trope& append(const charT* iter, size_t n) {\n-\t    RopeBase* result = destr_concat_char_iter(tree_ptr, iter, n);\n-\t    unref(tree_ptr);\n-\t    tree_ptr = result;\n-\t    return *this;\n-\t}\n-\n-\trope& append(const charT* c_string) {\n-\t    size_t len = char_ptr_len(c_string);\n-\t    append(c_string, len);\n-\t    return(*this);\n-\t}\n-\n-\trope& append(const charT* s, const charT* e) {\n-\t    RopeBase* result =\n-\t\t\tdestr_concat_char_iter(tree_ptr, s, e - s);\n-\t    unref(tree_ptr);\n-\t    tree_ptr = result;\n-\t    return *this;\n-\t}\n-\n-\trope& append(const_iterator s, const_iterator e) {\n-\t    __stl_assert(s.root == e.root);\n-\t    self_destruct_ptr appendee(substring(s.root, s.current_pos,\n-\t\t\t\t\t\t e.current_pos));\n-\t    RopeBase* result = concat(tree_ptr, (RopeBase *)appendee);\n-\t    unref(tree_ptr);\n-\t    tree_ptr = result;\n-\t    return *this;\n-\t}\n-\n-\trope& append(charT c) {\n-\t    RopeBase* result = destr_concat_char_iter(tree_ptr, &c, 1);\n-\t    unref(tree_ptr);\n-\t    tree_ptr = result;\n-\t    return *this;\n-\t}\n-\n-\trope& append() { return append(charT()); }\n-\n-\trope& append(const rope& y) {\n-\t    RopeBase* result = concat(tree_ptr, y.tree_ptr);\n-\t    unref(tree_ptr);\n-\t    tree_ptr = result;\n-\t    return *this;\n-\t}\n-\n-\trope& append(size_t n, charT c) {\n-\t    rope<charT,Alloc> last(n, c);\n-\t    return append(last);\n-\t}\n-\n-\tvoid swap(rope& b) {\n-\t    RopeBase * tmp = tree_ptr;\n-\t    tree_ptr = b.tree_ptr;\n-\t    b.tree_ptr = tmp;\n-\t}\n-\n-\n-    protected:\n-\t// Result is included in refcount.\n-\tstatic RopeBase * replace(RopeBase *old, size_t pos1,\n-\t\t\t\t  size_t pos2, RopeBase *r) {\n-\t    if (0 == old) { ref(r); return r; }\n-\t    self_destruct_ptr left(substring(old, 0, pos1));\n-\t    self_destruct_ptr right(substring(old, pos2, old -> size));\n-\t    RopeBase * result;\n-\n-\t    if (0 == r) {\n-\t\tresult = concat(left, right);\n-\t    } else {\n-\t\tself_destruct_ptr left_result(concat(left, r));\n-\t\tresult = concat(left_result, right);\n-\t    }\n-\t    return result;\n-\t}\n-\n-    public:\n-\tvoid insert(size_t p, const rope& r) {\n-\t    RopeBase * result = replace(tree_ptr, p, p,\n-\t\t\t\t\t       r.tree_ptr);\n-\t    unref(tree_ptr);\n-\t    tree_ptr = result;\n-\t}\n-\n-\tvoid insert(size_t p, size_t n, charT c) {\n-\t    rope<charT,Alloc> r(n,c);\n-\t    insert(p, r);\n-\t}\n-\n-\tvoid insert(size_t p, const charT * i, size_t n) {\n-\t    self_destruct_ptr left(substring(tree_ptr, 0, p));\n-\t    self_destruct_ptr right(substring(tree_ptr, p, size()));\n-\t    self_destruct_ptr left_result(concat_char_iter(left, i, n));\n-\t    RopeBase * result =\n-\t\t\t\tconcat(left_result, right);\n-\t    unref(tree_ptr);\n-\t    tree_ptr = result;\n-\t}\n-\n-\tvoid insert(size_t p, const charT * c_string) {\n-\t    insert(p, c_string, char_ptr_len(c_string));\n-\t}\n-\n-\tvoid insert(size_t p, charT c) {\n-\t    insert(p, &c, 1);\n-\t}\n-\n-\tvoid insert(size_t p) {\n-\t    charT c = charT();\n-\t    insert(p, &c, 1);\n-\t}\n-\n-\tvoid insert(size_t p, const charT *i, const charT *j) {\n-\t    rope r(i, j);\n-\t    insert(p, r);\n-\t}\n-\n-\tvoid insert(size_t p, const const_iterator& i,\n-\t\t\t      const const_iterator& j) {\n-\t    rope r(i, j);\n-\t    insert(p, r);\n-\t}\n-\n-\tvoid insert(size_t p, const iterator& i,\n-\t\t\t      const iterator& j) {\n-\t    rope r(i, j);\n-\t    insert(p, r);\n-\t}\n-\n-\t// (position, length) versions of replace operations:\n-\n-\tvoid replace(size_t p, size_t n, const rope& r) {\n-\t    RopeBase * result = replace(tree_ptr, p, p + n,\n-\t\t\t\t\t       r.tree_ptr);\n-\t    unref(tree_ptr);\n-\t    tree_ptr = result;\n-\t}\n-\n-\tvoid replace(size_t p, size_t n, const charT *i, size_t i_len) {\n-\t    rope r(i, i_len);\n-\t    replace(p, n, r);\n-\t}\n-\n-\tvoid replace(size_t p, size_t n, charT c) {\n-\t    rope r(c);\n-\t    replace(p, n, r);\n-\t}\n-\n-\tvoid replace(size_t p, size_t n, const charT *c_string) {\n-\t    rope r(c_string);\n-\t    replace(p, n, r);\n-\t}\n-\n-\tvoid replace(size_t p, size_t n, const charT *i, const charT *j) {\n-\t    rope r(i, j);\n-\t    replace(p, n, r);\n-\t}\n-\n-\tvoid replace(size_t p, size_t n,\n-\t\t     const const_iterator& i, const const_iterator& j) {\n-\t    rope r(i, j);\n-\t    replace(p, n, r);\n-\t}\n-\n-\tvoid replace(size_t p, size_t n,\n-\t\t     const iterator& i, const iterator& j) {\n-\t    rope r(i, j);\n-\t    replace(p, n, r);\n-\t}\n-\n-\t// Single character variants:\n-\tvoid replace(size_t p, charT c) {\n-\t    iterator i(this, p);\n-\t    *i = c;\n-\t}\n-\n-\tvoid replace(size_t p, const rope& r) {\n-\t    replace(p, 1, r);\n-\t}\n-\n-\tvoid replace(size_t p, const charT *i, size_t i_len) {\n-\t    replace(p, 1, i, i_len);\n-\t}\n-\n-\tvoid replace(size_t p, const charT *c_string) {\n-\t    replace(p, 1, c_string);\n-\t}\n-\n-\tvoid replace(size_t p, const charT *i, const charT *j) {\n-\t    replace(p, 1, i, j);\n-\t}\n-\n-\tvoid replace(size_t p, const const_iterator& i,\n-\t\t\t       const const_iterator& j) {\n-\t    replace(p, 1, i, j);\n-\t}\n-\n-\tvoid replace(size_t p, const iterator& i,\n-\t\t\t       const iterator& j) {\n-\t    replace(p, 1, i, j);\n-\t}\n-\n-\t// Erase, (position, size) variant.\n-\tvoid erase(size_t p, size_t n) {\n-\t    RopeBase * result = replace(tree_ptr, p, p + n, 0);\n-\t    unref(tree_ptr);\n-\t    tree_ptr = result;\n-\t}\n-\n-\t// Erase, single character\n-\tvoid erase(size_t p) {\n-\t    erase(p, p + 1);\n-\t}\n-\n-\t// Insert, iterator variants.  \n-\titerator insert(const iterator& p, const rope& r)\n-\t\t{ insert(p.index(), r); return p; }\n-\titerator insert(const iterator& p, size_t n, charT c)\n-\t\t{ insert(p.index(), n, c); return p; }\n-\titerator insert(const iterator& p, charT c) \n-\t\t{ insert(p.index(), c); return p; }\n-\titerator insert(const iterator& p ) \n-\t\t{ insert(p.index()); return p; }\n-\titerator insert(const iterator& p, const charT *c_string) \n-\t\t{ insert(p.index(), c_string); return p; }\n-\titerator insert(const iterator& p, const charT *i, size_t n)\n-\t\t{ insert(p.index(), i, n); return p; }\n-\titerator insert(const iterator& p, const charT *i, const charT *j)\n-\t\t{ insert(p.index(), i, j);  return p; }\n-\titerator insert(const iterator& p,\n-\t\t\tconst const_iterator& i, const const_iterator& j)\n-\t\t{ insert(p.index(), i, j); return p; }\n-\titerator insert(const iterator& p,\n-\t\t\tconst iterator& i, const iterator& j)\n-\t\t{ insert(p.index(), i, j); return p; }\n-\n-\t// Replace, range variants.\n-\tvoid replace(const iterator& p, const iterator& q,\n-\t\t     const rope& r)\n-\t\t{ replace(p.index(), q.index() - p.index(), r); }\n-\tvoid replace(const iterator& p, const iterator& q, charT c)\n-\t\t{ replace(p.index(), q.index() - p.index(), c); }\n-\tvoid replace(const iterator& p, const iterator& q,\n-\t\t     const charT * c_string)\n-\t\t{ replace(p.index(), q.index() - p.index(), c_string); }\n-\tvoid replace(const iterator& p, const iterator& q,\n-\t\t     const charT *i, size_t n)\n-\t\t{ replace(p.index(), q.index() - p.index(), i, n); }\n-\tvoid replace(const iterator& p, const iterator& q,\n-\t\t     const charT *i, const charT *j)\n-\t\t{ replace(p.index(), q.index() - p.index(), i, j); }\n-\tvoid replace(const iterator& p, const iterator& q,\n-\t\t     const const_iterator& i, const const_iterator& j)\n-\t\t{ replace(p.index(), q.index() - p.index(), i, j); }\n-\tvoid replace(const iterator& p, const iterator& q,\n-\t\t     const iterator& i, const iterator& j)\n-\t\t{ replace(p.index(), q.index() - p.index(), i, j); }\n-\n-\t// Replace, iterator variants.\n-\tvoid replace(const iterator& p, const rope& r)\n-\t\t{ replace(p.index(), r); }\n-\tvoid replace(const iterator& p, charT c)\n-\t\t{ replace(p.index(), c); }\n-\tvoid replace(const iterator& p, const charT * c_string)\n-\t\t{ replace(p.index(), c_string); }\n-\tvoid replace(const iterator& p, const charT *i, size_t n)\n-\t\t{ replace(p.index(), i, n); }\n-\tvoid replace(const iterator& p, const charT *i, const charT *j)\n-\t\t{ replace(p.index(), i, j); }\n-\tvoid replace(const iterator& p, const_iterator i, const_iterator j)\n-\t\t{ replace(p.index(), i, j); }\n-\tvoid replace(const iterator& p, iterator i, iterator j)\n-\t\t{ replace(p.index(), i, j); }\n-\n-\t// Iterator and range variants of erase\n-\tvoid erase(const iterator &p, const iterator &q)\n-\t\t{ erase(p.index(), q.index() - p.index()); }\n-\tvoid erase(const iterator &p)\n-\t\t{ erase(p.index(), 1); }\n-\n-\trope substr(size_t start, size_t len = 1) const {\n-\t    return rope<charT,Alloc>(\n-\t\t\tsubstring(tree_ptr, start, start + len));\n-\t}\n-\n-\trope substr(iterator start, iterator end) const {\n-\t    return rope<charT,Alloc>(\n-\t\t\tsubstring(tree_ptr, start.index(), end.index()));\n-\t}\n-\t\n-\trope substr(iterator start) const {\n-\t    size_t pos = start.index();\n-\t    return rope<charT,Alloc>(\n-\t\t\tsubstring(tree_ptr, pos, pos + 1));\n-\t}\n-\t\n-\trope substr(const_iterator start, const_iterator end) const {\n-\t    // This might eventually take advantage of the cache in the\n-\t    // iterator.\n-\t    return rope<charT,Alloc>\n-\t\t(substring(tree_ptr, start.index(), end.index()));\n-\t}\n-\n-\trope<charT,Alloc> substr(const_iterator start) {\n-\t    size_t pos = start.index();\n-\t    return rope<charT,Alloc>(substring(tree_ptr, pos, pos + 1));\n-\t}\n-\n-\tsize_type find(charT c, size_type pos = 0) const;\n-\tsize_type find(charT *s, size_type pos = 0) const {\n-\t    const_iterator result = search(const_begin() + pos, const_end(),\n-\t\t\t\t\t   s, s + char_ptr_len(s));\n-\t    return result.index();\n-\t}\n-\n-\titerator mutable_begin() {\n-\t    return(iterator(this, 0));\n-\t}\n-\n-\titerator mutable_end() {\n-\t    return(iterator(this, size()));\n-\t}\n-\n-#     ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-        typedef reverse_iterator<iterator> reverse_iterator;\n-#     else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\ttypedef reverse_iterator<iterator, value_type, reference,\n-\t\t\t\t difference_type>  reverse_iterator;\n-#     endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ \n-\n-\treverse_iterator mutable_rbegin() {\n-\t    return reverse_iterator(mutable_end());\n-\t}\n-\n-\treverse_iterator mutable_rend() {\n-\t    return reverse_iterator(mutable_begin());\n-\t}\n-\n-\treference mutable_reference_at(size_type pos) {\n-\t    return reference(this, pos);\n-\t}\n-\n-#\tifdef __STD_STUFF\n-\t    reference operator[] (size_type pos) {\n-\t\treturn charT_ref_proxy(this, pos);\n-\t    }\n-\n-\t    reference at(size_type pos) {\n-\t\t// if (pos >= size()) throw out_of_range;\n-\t\treturn (*this)[pos];\n-\t    }\n-\n-\t    void resize(size_type n, charT c) {}\n-\t    void resize(size_type n) {}\n-\t    void reserve(size_type res_arg = 0) {}\n-\t    size_type capacity() const {\n-\t\treturn max_size();\n-\t    }\n-\n-\t  // Stuff below this line is dangerous because it's error prone.\n-\t  // I would really like to get rid of it.\n-\t    // copy function with funny arg ordering.\n-\t      size_type copy(charT *buffer, size_type n, size_type pos = 0)\n-\t\t\t\t\t\t\t\tconst {\n-\t\treturn copy(pos, n, buffer);\n-\t      }\n-\n-\t    iterator end() { return mutable_end(); }\n-\n-\t    iterator begin() { return mutable_begin(); }\n-\n-\t    reverse_iterator rend() { return mutable_rend(); }\n-\n-\t    reverse_iterator rbegin() { return mutable_rbegin(); }\n-\n-#\telse\n-\n-\t    const_iterator end() { return const_end(); }\n-\n-\t    const_iterator begin() { return const_begin(); }\n-\n-\t    const_reverse_iterator rend() { return const_rend(); }\n-  \n-\t    const_reverse_iterator rbegin() { return const_rbegin(); }\n-\n-#\tendif\n-\t\n-};\n-\n-template <class charT, class Alloc>\n-inline bool operator== (const __rope_const_iterator<charT,Alloc> & x,\n-\t\t\tconst __rope_const_iterator<charT,Alloc> & y) {\n-\treturn (x.current_pos == y.current_pos && x.root == y.root);\n-}\n-\n-template <class charT, class Alloc>\n-inline bool operator< (const __rope_const_iterator<charT,Alloc> & x,\n-\t\t       const __rope_const_iterator<charT,Alloc> & y) {\n-\treturn (x.current_pos < y.current_pos);\n-}\n-\n-template <class charT, class Alloc>\n-inline ptrdiff_t operator-(const __rope_const_iterator<charT,Alloc> & x,\n-\t\t\t   const __rope_const_iterator<charT,Alloc> & y) {\n-\treturn x.current_pos - y.current_pos;\n-}\n-\n-template <class charT, class Alloc>\n-inline __rope_const_iterator<charT,Alloc>\n-operator-(const __rope_const_iterator<charT,Alloc> & x,\n-\t  ptrdiff_t n) {\n-\treturn __rope_const_iterator<charT,Alloc>(x.root, x.current_pos - n);\n-}\n-\n-template <class charT, class Alloc>\n-inline __rope_const_iterator<charT,Alloc>\n-operator+(const __rope_const_iterator<charT,Alloc> & x,\n-\t  ptrdiff_t n) {\n-\treturn __rope_const_iterator<charT,Alloc>(x.root, x.current_pos + n);\n-}\n-\n-template <class charT, class Alloc>\n-inline __rope_const_iterator<charT,Alloc>\n-operator+(ptrdiff_t n,\n-\t  const __rope_const_iterator<charT,Alloc> & x) {\n-\treturn __rope_const_iterator<charT,Alloc>(x.root, x.current_pos + n);\n-}\n-\n-template <class charT, class Alloc>\n-inline bool operator== (const __rope_iterator<charT,Alloc> & x,\n-\t\t\tconst __rope_iterator<charT,Alloc> & y) {\n-\treturn (x.current_pos == y.current_pos && x.root_rope == y.root_rope);\n-}\n-\n-template <class charT, class Alloc>\n-inline bool operator< (const __rope_iterator<charT,Alloc> & x,\n-\t\t\tconst __rope_iterator<charT,Alloc> & y) {\n-\treturn (x.current_pos < y.current_pos);\n-}\n-\n-template <class charT, class Alloc>\n-inline ptrdiff_t operator-(const __rope_iterator<charT,Alloc> & x,\n-\t\t\t   const __rope_iterator<charT,Alloc> & y) {\n-\treturn x.current_pos - y.current_pos;\n-}\n-\n-template <class charT, class Alloc>\n-inline __rope_iterator<charT,Alloc>\n-operator-(const __rope_iterator<charT,Alloc> & x,\n-\t  ptrdiff_t n) {\n-\treturn __rope_iterator<charT,Alloc>(x.root_rope, x.current_pos - n);\n-}\n-\n-template <class charT, class Alloc>\n-inline __rope_iterator<charT,Alloc>\n-operator+(const __rope_iterator<charT,Alloc> & x,\n-\t  ptrdiff_t n) {\n-\treturn __rope_iterator<charT,Alloc>(x.root_rope, x.current_pos + n);\n-}\n-\n-template <class charT, class Alloc>\n-inline __rope_iterator<charT,Alloc>\n-operator+(ptrdiff_t n,\n-\t  const __rope_iterator<charT,Alloc> & x) {\n-\treturn __rope_iterator<charT,Alloc>(x.root_rope, x.current_pos + n);\n-}\n-\n-template <class charT, class Alloc>\n-inline\n-rope<charT,Alloc>\n-operator+ (const rope<charT,Alloc> &left,\n-\t   const rope<charT,Alloc> &right)\n-{\n-    return rope<charT,Alloc>\n-\t\t(rope<charT,Alloc>::concat(left.tree_ptr, right.tree_ptr));\n-    // Inlining this should make it possible to keep left and\n-    // right in registers.\n-}\n-\n-template <class charT, class Alloc>\n-inline\n-rope<charT,Alloc>&\n-operator+= (rope<charT,Alloc> &left,\n-\t    const rope<charT,Alloc> &right)\n-{\n-    left.append(right);\n-    return left;\n-}\n-\n-template <class charT, class Alloc>\n-inline\n-rope<charT,Alloc>\n-operator+ (const rope<charT,Alloc> &left,\n-\t   const charT* right) {\n-    size_t rlen = rope<charT,Alloc>::char_ptr_len(right);\n-    return rope<charT,Alloc>\n-\t   (rope<charT,Alloc>::concat_char_iter(left.tree_ptr, right, rlen)); \n-}\n-\n-template <class charT, class Alloc>\n-inline\n-rope<charT,Alloc>&\n-operator+= (rope<charT,Alloc> &left,\n-\t    const charT* right) {\n-    left.append(right);\n-    return left;\n-}\n-\n-template <class charT, class Alloc>\n-inline\n-rope<charT,Alloc>\n-operator+ (const rope<charT,Alloc> &left, charT right) {\n-    return rope<charT,Alloc>\n-\t\t(rope<charT,Alloc>::concat_char_iter(left.tree_ptr, &right, 1));\n-}\n-\n-template <class charT, class Alloc>\n-inline\n-rope<charT,Alloc>&\n-operator+= (rope<charT,Alloc> &left, charT right) {\n-    left.append(right);\n-    return left;\n-}\n-\n-template <class charT, class Alloc>\n-bool\n-operator< (const rope<charT,Alloc> &left, const rope<charT,Alloc> &right) {\n-    return left.compare(right) < 0;\n-}\n-\t\n-template <class charT, class Alloc>\n-bool\n-operator== (const rope<charT,Alloc> &left, const rope<charT,Alloc> &right) {\n-    return left.compare(right) == 0;\n-}\n-\n-template <class charT, class Alloc>\n-inline bool operator== (const __rope_charT_ptr_proxy<charT,Alloc> & x,\n-\t\t\tconst __rope_charT_ptr_proxy<charT,Alloc> & y) {\n-\treturn (x.pos == y.pos && x.root == y.root);\n-}\n-\n-template<class charT, class Alloc>\n-ostream& operator<< (ostream& o, const rope<charT, Alloc>& r);        \n-\t\n-typedef rope<char, __ALLOC> crope;\n-typedef rope<wchar_t, __ALLOC> wrope;\n-\n-inline crope::reference __mutable_reference_at(crope& c, size_t i)\n-{\n-    return c.mutable_reference_at(i);\n-}\n-\n-inline wrope::reference __mutable_reference_at(wrope& c, size_t i)\n-{\n-    return c.mutable_reference_at(i);\n-}\n-\n-inline void swap(crope x, crope y) { x.swap(y); }\n-inline void swap(wrope x, wrope y) { x.swap(y); }\n-\n-// Hash functions should probably be revisited later:\n-struct hash<crope>\n-{\n-  size_t operator()(const crope& str) const\n-  {\n-    size_t sz = str.size();\n-\n-    if (0 == sz) return 0;\n-    return 13*str[0] + 5*str[sz - 1] + sz;\n-  }\n-};\n-\n-struct hash<wrope>\n-{\n-  size_t operator()(const wrope& str) const\n-  {\n-    size_t sz = str.size();\n-\n-    if (0 == sz) return 0;\n-    return 13*str[0] + 5*str[sz - 1] + sz;\n-  }\n-};\n-\n-# include <ropeimpl.h>\n-# endif /* _ROPE_H */\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "dcd6bfd511760036a1cee2b17121d5a40204376a", "filename": "libstdc++/stl/ropeimpl.h", "status": "modified", "additions": 54, "deletions": 18, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fropeimpl.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -11,9 +11,19 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n \n+/* NOTE: This is an internal header file, included by other STL headers.\n+ *   You should not attempt to use it directly.\n+ */\n+\n # include <stdio.h>\n # include <iostream.h>\n \n+__STL_BEGIN_NAMESPACE\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma set woff 1174\n+#endif\n+\n // Set buf_start, buf_end, and buf_ptr appropriately, filling tmp_buf\n // if necessary.  Assumes path_end[leaf_index] and leaf_pos are correct.\n // Results in a valid buf_ptr if the iterator can be legitimately\n@@ -416,8 +426,9 @@ rope<charT,Alloc>::leaf_concat_char_iter\n     uninitialized_copy_n(r -> data, old_len, new_data);\n     uninitialized_copy_n(iter, len, new_data + old_len);\n     __cond_store_eos(new_data[old_len + len]);\n-    __STL_TRY\n+    __STL_TRY {\n \tresult = RopeLeaf_from_char_ptr(new_data, old_len + len);\n+    }\n     __STL_UNWIND(RopeBase::free_string(new_data, old_len + len));\n     return result;\n }\n@@ -482,7 +493,7 @@ rope<charT,Alloc>::tree_concat (RopeBase * left, RopeBase * right)\n     if (depth > 20 && (rsize < 1000 || depth > RopeBase::max_rope_depth)) {\n \tRopeBase * balanced;\n \n-\t__STL_TRY\n+\t__STL_TRY {\n \t   balanced = balance(result);\n #          ifndef __GC\n \t     if (result != balanced) {\n@@ -491,6 +502,7 @@ rope<charT,Alloc>::tree_concat (RopeBase * left, RopeBase * right)\n \t     }\n #          endif\n \t   result -> unref_nonnil();\n+        }\n \t__STL_UNWIND(CAlloc::deallocate(result));\n \t\t// In case of exception, we need to deallocate\n \t\t// otherwise dangling result node.  But caller\n@@ -526,8 +538,9 @@ rope<charT,Alloc>::RopeBase * rope<charT,Alloc>::concat_char_iter\n \t  RopeBase * left = ((RopeConcatenation *)r) -> left;\n \t  RopeBase * nright = leaf_concat_char_iter((RopeLeaf *)right, s, slen);\n \t  left -> ref_nonnil();\n-\t  __STL_TRY\n+\t  __STL_TRY {\n \t    result = tree_concat(left, nright);\n+          }\n \t  __STL_UNWIND(unref(left); unref(nright));\n #         ifndef __GC\n \t    __stl_assert(1 == result -> refcount);\n@@ -536,9 +549,10 @@ rope<charT,Alloc>::RopeBase * rope<charT,Alloc>::concat_char_iter\n \t}\n     }\n     RopeBase * nright = RopeLeaf_from_unowned_char_ptr(s, slen);\n-    __STL_TRY\n+    __STL_TRY {\n       r -> ref_nonnil();\n       result = tree_concat(r, nright);\n+    }\n     __STL_UNWIND(unref(r); unref(nright));\n #   ifndef __GC\n       __stl_assert(1 == result -> refcount);\n@@ -591,8 +605,9 @@ ::destr_concat_char_iter\n     }\n     RopeBase *right = RopeLeaf_from_unowned_char_ptr(s, slen);\n     r -> ref_nonnil();\n-    __STL_TRY\n+    __STL_TRY {\n       result = tree_concat(r, right);\n+    }\n     __STL_UNWIND(unref(r); unref(right))\n     __stl_assert(1 == result -> refcount);\n     return result;\n@@ -629,16 +644,18 @@ rope<charT,Alloc>::concat(RopeBase * left, RopeBase * right)\n \t\t\t\t\t   ((RopeLeaf *)right) -> data,\n \t\t\t\t\t   right -> size);\n \t    leftleft -> ref_nonnil();\n-\t    __STL_TRY\n+\t    __STL_TRY {\n \t      return(tree_concat(leftleft, rest));\n+            }\n \t    __STL_UNWIND(unref(leftleft); unref(rest))\n \t  }\n \t}\n     }\n     left -> ref_nonnil();\n     right -> ref_nonnil();\n-    __STL_TRY\n+    __STL_TRY {\n       return(tree_concat(left, right));\n+    }\n     __STL_UNWIND(unref(left); unref(right));\n }\n \n@@ -732,8 +749,9 @@ rope<charT,Alloc>::substring(RopeBase * base, size_t start, size_t endp1)\n \t\tif (result_len > lazy_threshold) goto lazy;\n \t\tsection = (charT *)\n \t\t\tDataAlloc::allocate(rounded_up_size(result_len));\n-\t\t__STL_TRY\n+\t\t__STL_TRY {\n \t\t  (*(f -> fn))(start, result_len, section);\n+                }\n \t\t__STL_UNWIND(RopeBase::free_string(section, result_len));\n \t\t__cond_store_eos(section[result_len]);\n \t\treturn RopeLeaf_from_char_ptr(section, result_len);\n@@ -872,10 +890,12 @@ bool rope<charT, Alloc>::apply_to_pieces(\n \t\tsize_t len = end - begin;\n \t\tbool result;\n \t\tcharT * buffer = DataAlloc::allocate(len);\n-\t\t__STL_TRY\n+\t\t__STL_TRY {\n \t\t  (*(f -> fn))(begin, end, buffer);\n \t\t  result = c(buffer, len);\n-\t\t__STL_ALWAYS(DataAlloc::deallocate(buffer, len))\n+                  DataAlloc::deallocate(buffer, len);\n+                }\n+\t\t__STL_UNWIND(DataAlloc::deallocate(buffer, len))\n \t\treturn result;\n \t    }\n \tdefault:\n@@ -915,15 +935,18 @@ ostream& operator<< (ostream& o, const rope<charT, Alloc>& r)\n \tpad_len = 0;\n     }\n     if (!is_simple) o.width(w/rope_len);\n-    __STL_TRY\n+    __STL_TRY {\n       if (is_simple && !left && pad_len > 0) {\n \t__rope_fill(o, pad_len);\n       }\n       r.apply_to_pieces(0, r.size(), c);\n       if (is_simple && left && pad_len > 0) {\n \t__rope_fill(o, pad_len);\n       }\n-    __STL_ALWAYS(if (!is_simple) o.width(w))\n+      if (!is_simple)\n+        o.width(w);\n+    }\n+    __STL_UNWIND(if (!is_simple) o.width(w))\n     return o;\n }\n \n@@ -964,7 +987,7 @@ rope<charT,Alloc>::flatten(RopeBase * r, charT * buffer)\n \tcase RopeBase::leaf:\n \t    {\n \t\tRopeLeaf * l = (RopeLeaf *)r;\n-\t\treturn copy_n(l -> data, l -> size, buffer);\n+\t\treturn copy_n(l -> data, l -> size, buffer).second;\n \t    }\n \tcase RopeBase::function:\n \tcase RopeBase::substringfn:\n@@ -1076,7 +1099,7 @@ rope<charT,Alloc>::balance(RopeBase *r)\n     // References from forest are included in refcount.\n \n     for (i = 0; i <= RopeBase::max_rope_depth; ++i) forest[i] = 0;\n-    __STL_TRY\n+    __STL_TRY {\n       add_to_forest(r, forest);\n       for (i = 0; i <= RopeBase::max_rope_depth; ++i) if (0 != forest[i]) {\n #\tifndef __GC\n@@ -1088,6 +1111,7 @@ rope<charT,Alloc>::balance(RopeBase *r)\n \t  forest[i] = 0;\n #\tendif\n       }\n+    }\n     __STL_UNWIND(for(i = 0; i <= RopeBase::max_rope_depth; i++)\n \t\t unref(forest[i]))\n     if (result -> depth > RopeBase::max_rope_depth) abort();\n@@ -1366,8 +1390,9 @@ rope<charT, Alloc>::rope(size_t n, charT c)\n \trest_buffer = DataAlloc::allocate(rounded_up_size(rest));\n \tuninitialized_fill_n(rest_buffer, rest, c);\n \t__cond_store_eos(rest_buffer[rest]);\n-\t__STL_TRY\n+\t__STL_TRY {\n \t    remainder = RopeLeaf_from_char_ptr(rest_buffer, rest);\n+        }\n \t__STL_UNWIND(RopeBase::free_string(rest_buffer, rest))\n     }\n     remainder_rope.tree_ptr = remainder;\n@@ -1378,9 +1403,10 @@ rope<charT, Alloc>::rope(size_t n, charT c)\n \trope base_rope;\n \tuninitialized_fill_n(base_buffer, exponentiate_threshold, c);\n \t__cond_store_eos(base_buffer[exponentiate_threshold]);\n-\t__STL_TRY\n-\tbase_leaf = RopeLeaf_from_char_ptr(base_buffer,\n-\t\t\t\t\t   exponentiate_threshold);\n+\t__STL_TRY {\n+          base_leaf = RopeLeaf_from_char_ptr(base_buffer,\n+                                             exponentiate_threshold);\n+        }\n \t__STL_UNWIND(RopeBase::free_string(base_buffer, exponentiate_threshold))\n \tbase_rope.tree_ptr = base_leaf;\n  \tif (1 == exponent) {\n@@ -1499,3 +1525,13 @@ inline void rotate(__rope_iterator<wchar_t,__ALLOC> first,\n }\n # endif\n #endif /* _MSC_VER */\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma reset woff 1174\n+#endif\n+\n+__STL_END_NAMESPACE\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "c836c4596d28f0cedb1215d29025675e2c5e2255", "filename": "libstdc++/stl/set", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fset?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,40 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_SET\n+#define __SGI_STL_SET\n+\n+#ifndef __SGI_STL_INTERNAL_TREE_H\n+#include <stl_tree.h>\n+#endif\n+#include <stl_set.h>\n+#include <stl_multiset.h>\n+\n+#endif /* __SGI_STL_SET */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "9004d2e04770baab18243b9bff924b27102f9c5d", "filename": "libstdc++/stl/set.h", "status": "modified", "additions": 9, "deletions": 135, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fset.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -28,140 +28,14 @@\n #define __SGI_STL_SET_H\n \n #include <tree.h>\n+#include <stl_set.h>\n \n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class Key, class Compare = less<Key>, class Alloc = alloc>\n-#else\n-template <class Key, class Compare, class Alloc = alloc>\n-#endif\n-class set {\n-public:\n-  // typedefs:\n-\n-  typedef Key key_type;\n-  typedef Key value_type;\n-  typedef Compare key_compare;\n-  typedef Compare value_compare;\n-private:\n-  typedef rb_tree<key_type, value_type, \n-                  identity<value_type>, key_compare, Alloc> rep_type;\n-  rep_type t;  // red-black tree representing set\n-public:\n-  typedef rep_type::const_pointer pointer;\n-  typedef rep_type::const_reference reference;\n-  typedef rep_type::const_reference const_reference;\n-  typedef rep_type::const_iterator iterator;\n-  typedef rep_type::const_iterator const_iterator;\n-  typedef rep_type::const_reverse_iterator reverse_iterator;\n-  typedef rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef rep_type::size_type size_type;\n-  typedef rep_type::difference_type difference_type;\n-\n-  // allocation/deallocation\n-\n-  set() : t(Compare()) {}\n-  explicit set(const Compare& comp) : t(comp) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  set(InputIterator first, InputIterator last)\n-    : t(Compare()) { t.insert_unique(first, last); }\n-\n-  template <class InputIterator>\n-  set(InputIterator first, InputIterator last, const Compare& comp)\n-    : t(comp) { t.insert_unique(first, last); }\n-#else\n-  set(const value_type* first, const value_type* last) \n-    : t(Compare()) { t.insert_unique(first, last); }\n-  set(const value_type* first, const value_type* last, const Compare& comp)\n-    : t(comp) { t.insert_unique(first, last); }\n-\n-  set(const_iterator first, const_iterator last)\n-    : t(Compare()) { t.insert_unique(first, last); }\n-  set(const_iterator first, const_iterator last, const Compare& comp)\n-    : t(comp) { t.insert_unique(first, last); }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  set(const set<Key, Compare, Alloc>& x) : t(x.t) {}\n-  set<Key, Compare, Alloc>& operator=(const set<Key, Compare, Alloc>& x) { \n-    t = x.t; \n-    return *this;\n-  }\n-\n-  // accessors:\n-\n-  key_compare key_comp() const { return t.key_comp(); }\n-  value_compare value_comp() const { return t.key_comp(); }\n-  iterator begin() const { return t.begin(); }\n-  iterator end() const { return t.end(); }\n-  reverse_iterator rbegin() const { return t.rbegin(); } \n-  reverse_iterator rend() const { return t.rend(); }\n-  bool empty() const { return t.empty(); }\n-  size_type size() const { return t.size(); }\n-  size_type max_size() const { return t.max_size(); }\n-  void swap(set<Key, Compare, Alloc>& x) { t.swap(x.t); }\n-\n-  // insert/erase\n-  typedef  pair<iterator, bool> pair_iterator_bool; \n-  pair<iterator,bool> insert(const value_type& x) { \n-    pair<rep_type::iterator, bool> p = t.insert_unique(x); \n-    return pair<iterator, bool>(p.first, p.second);\n-  }\n-  iterator insert(iterator position, const value_type& x) {\n-    return t.insert_unique((rep_type::iterator&)position, x);\n-  }\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void insert(InputIterator first, InputIterator last) {\n-    t.insert_unique(first, last);\n-  }\n-#else\n-  void insert(const_iterator first, const_iterator last) {\n-    t.insert_unique(first, last);\n-  }\n-  void insert(const value_type* first, const value_type* last) {\n-    t.insert_unique(first, last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-  void erase(iterator position) { \n-    t.erase((rep_type::iterator&)position); \n-  }\n-  size_type erase(const key_type& x) { \n-    return t.erase(x); \n-  }\n-  void erase(iterator first, iterator last) { \n-    t.erase((rep_type::iterator&)first, \n-            (rep_type::iterator&)last); \n-  }\n-  void clear() { t.clear(); }\n-\n-  // set operations:\n-\n-  iterator find(const key_type& x) const { return t.find(x); }\n-  size_type count(const key_type& x) const { return t.count(x); }\n-  iterator lower_bound(const key_type& x) const {\n-    return t.lower_bound(x);\n-  }\n-  iterator upper_bound(const key_type& x) const {\n-    return t.upper_bound(x); \n-  }\n-  pair<iterator,iterator> equal_range(const key_type& x) const {\n-    return t.equal_range(x);\n-  }\n-  friend bool operator==(const set&, const set&);\n-  friend bool operator<(const set&, const set&);\n-};\n-\n-template <class Key, class Compare, class Alloc>\n-inline bool operator==(const set<Key, Compare, Alloc>& x, \n-                       const set<Key, Compare, Alloc>& y) {\n-  return x.t == y.t;\n-}\n-\n-template <class Key, class Compare, class Alloc>\n-inline bool operator<(const set<Key, Compare, Alloc>& x, \n-                      const set<Key, Compare, Alloc>& y) {\n-  return x.t < y.t;\n-}\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::set;\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_SET_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "c3ec74204c55d073b6fd48b536dd6325d1f63347", "filename": "libstdc++/stl/slist", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fslist?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef __SGI_STL_SLIST\n+#define __SGI_STL_SLIST\n+\n+#include <stl_algobase.h>\n+#include <stl_alloc.h>\n+#include <stl_construct.h>\n+#include <stl_uninitialized.h>\n+#include <stl_slist.h>\n+\n+#endif /* __SGI_STL_SLIST */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "d2377b0cf5aef6b8e9446349316f3fdd7f346cca", "filename": "libstdc++/stl/slist.h", "status": "modified", "additions": 8, "deletions": 714, "changes": 722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fslist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fslist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fslist.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -17,720 +17,14 @@\n \n #include <algobase.h>\n #include <alloc.h>\n+#include <stl_slist.h>\n \n-struct __slist_node_base\n-{\n-  __slist_node_base* next;\n-};\n-\n-inline __slist_node_base* __slist_make_link(__slist_node_base* prev_node,\n-                                            __slist_node_base* new_node)\n-{\n-  new_node->next = prev_node->next;\n-  prev_node->next = new_node;\n-  return new_node;\n-}\n-\n-inline __slist_node_base* __slist_previous(__slist_node_base* head,\n-                                           const __slist_node_base* node)\n-{\n-  while (head && head->next != node)\n-    head = head->next;\n-  return head;\n-}\n-\n-inline const __slist_node_base* __slist_previous(const __slist_node_base* head,\n-                                                 const __slist_node_base* node)\n-{\n-  while (head && head->next != node)\n-    head = head->next;\n-  return head;\n-}\n-\n-inline void __slist_splice_after(__slist_node_base* pos,\n-                                 __slist_node_base* before_first,\n-                                 __slist_node_base* before_last)\n-{\n-  if (pos != before_first && pos != before_last) {\n-    __slist_node_base* first = before_first->next;\n-    __slist_node_base* after = pos->next;\n-    before_first->next = before_last->next;\n-    pos->next = first;\n-    before_last->next = after;\n-  }\n-}\n-\n-inline __slist_node_base* __slist_reverse(__slist_node_base* node)\n-{\n-  __slist_node_base* result = node;\n-  node = node->next;\n-  result->next = 0;\n-  while(node) {\n-    __slist_node_base* next = node->next;\n-    node->next = result;\n-    result = node;\n-    node = next;\n-  }\n-  return result;\n-}\n-\n-template <class T>\n-struct __slist_node : public __slist_node_base\n-{\n-  T data;\n-};\n-\n-struct __slist_iterator_base\n-{\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n-  typedef forward_iterator_tag iterator_category;\n-\n-  __slist_node_base* node;\n-\n-  __slist_iterator_base(__slist_node_base* x) : node(x) {}\n-  void incr() { node = node->next; }\n-\n-  bool operator==(const __slist_iterator_base& x) const {\n-    return node == x.node;\n-  }\n-  bool operator!=(const __slist_iterator_base& x) const {\n-    return node != x.node;\n-  }\n-};\n-\n-template <class T, class Ref, class Ptr>\n-struct __slist_iterator : public __slist_iterator_base\n-{\n-  typedef __slist_iterator<T, T&, T*>             iterator;\n-  typedef __slist_iterator<T, const T&, const T*> const_iterator;\n-  typedef __slist_iterator<T, Ref, Ptr>           self;\n-\n-  typedef T value_type;\n-  typedef Ptr pointer;\n-  typedef Ref reference;\n-  typedef __slist_node<T> list_node;\n-\n-  __slist_iterator(list_node* x) : __slist_iterator_base(x) {}\n-  __slist_iterator() : __slist_iterator_base(0) {}\n-  __slist_iterator(const iterator& x) : __slist_iterator_base(x.node) {}\n-\n-  reference operator*() const { return ((list_node*) node)->data; }\n-#ifndef __SGI_STL_NO_ARROW_OPERATOR\n-  pointer operator->() const { return &(operator*()); }\n-#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n-\n-  self& operator++()\n-  {\n-    incr();\n-    return *this;\n-  }\n-  self operator++(int)\n-  {\n-    self tmp = *this;\n-    incr();\n-    return tmp;\n-  }\n-};\n-\n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-inline ptrdiff_t*\n-distance_type(const __slist_iterator_base&)\n-{\n-  return 0;\n-}\n-\n-inline forward_iterator_tag\n-iterator_category(const __slist_iterator_base&)\n-{\n-  return forward_iterator_tag();\n-}\n-\n-template <class T, class Ref, class Ptr> \n-inline T* \n-value_type(const __slist_iterator<T, Ref, Ptr>&) {\n-  return 0;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n-\n-inline size_t __slist_size(__slist_node_base* node)\n-{\n-  size_t result = 0;\n-  for ( ; node != 0; node = node->next)\n-    ++result;\n-  return result;\n-}\n-\n-template <class T, class Alloc = alloc>\n-class slist\n-{\n-public:\n-  typedef T value_type;\n-  typedef value_type* pointer;\n-  typedef value_type& reference;\n-  typedef const value_type& const_reference;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n-\n-  typedef __slist_iterator<T, T&, T*>             iterator;\n-  typedef __slist_iterator<T, const T&, const T*> const_iterator;\n-\n-private:\n-  typedef __slist_node<T> list_node;\n-  typedef __slist_node_base list_node_base;\n-  typedef __slist_iterator_base iterator_base;\n-  typedef simple_alloc<list_node, Alloc> list_node_allocator;\n-\n-  static list_node* create_node(const value_type& x) {\n-    list_node* node = list_node_allocator::allocate();\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      construct(&node->data, x);\n-      node->next = 0;\n-      return node;\n-#       ifdef __STL_USE_EXCEPTIONS \n-    }\n-    catch(...) {\n-      list_node_allocator::deallocate(node);\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */\n-  }\n-  \n-  static void destroy_node(list_node* node) {\n-    destroy(&node->data);\n-    list_node_allocator::deallocate(node);\n-  }\n-\n-  void fill_initialize(size_type n, const value_type& x) {\n-    head.next = 0;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      _insert_after_fill(&head, n, x);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      clear();\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */ \n-  }    \n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  void range_initialize(InputIterator first, InputIterator last) {\n-    head.next = 0;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      _insert_after_range(&head, first, last);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      clear();\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */ \n-  } \n-#else /* __STL_MEMBER_TEMPLATES */\n-  void range_initialize(const value_type* first, const value_type* last) {\n-    head.next = 0;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      _insert_after_range(&head, first, last);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      clear();\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */ \n-  } \n-  void range_initialize(const_iterator first, const_iterator last) {\n-    head.next = 0;\n-#       ifdef __STL_USE_EXCEPTIONS\n-    try {\n-#       endif /* __STL_USE_EXCEPTIONS */\n-      _insert_after_range(&head, first, last);\n-#       ifdef __STL_USE_EXCEPTIONS\n-    }\n-    catch(...) {\n-      clear();\n-      throw;\n-    }\n-#       endif /* __STL_USE_EXCEPTIONS */ \n-  } \n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-private:\n-  list_node_base head;\n-\n-public:\n-  slist() { head.next = 0; }\n-\n-  slist(size_type n, const value_type& x) { fill_initialize(n, x); }\n-  slist(int n, const value_type& x) { fill_initialize(n, x); }\n-  slist(long n, const value_type& x) { fill_initialize(n, x); }\n-  explicit slist(size_type n) { fill_initialize(n, value_type()); }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InputIterator>\n-  slist(InputIterator first, InputIterator last) {\n-    range_initialize(first, last);\n-  }\n-\n-#else /* __STL_MEMBER_TEMPLATES */\n-  slist(const_iterator first, const_iterator last) {\n-    range_initialize(first, last);\n-  }\n-  slist(const value_type* first, const value_type* last) {\n-    range_initialize(first, last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  slist(const slist& L) { range_initialize(L.begin(), L.end()); }\n-\n-  slist& operator= (const slist& L);\n-\n-  ~slist() { clear(); }\n-\n-public:\n-\n-  iterator begin() { return iterator((list_node*)head.next); }\n-  const_iterator begin() const { return const_iterator((list_node*)head.next);}\n-\n-  iterator end() { return iterator(0); }\n-  const_iterator end() const { return const_iterator(0); }\n-\n-  size_type size() const { return __slist_size(head.next); }\n-  \n-  size_type max_size() const { return size_type(-1); }\n-\n-  bool empty() const { return head.next == 0; }\n-\n-  void swap(slist& L)\n-  {\n-    list_node_base* tmp = head.next;\n-    head.next = L.head.next;\n-    L.head.next = tmp;\n-  }\n-\n-public:\n-  friend bool operator==(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2);\n-\n-public:\n-\n-  reference front() { return ((list_node*) head.next)->data; }\n-  const_reference front() const { return ((list_node*) head.next)->data; }\n-  void push_front(const value_type& x)   {\n-    __slist_make_link(&head, create_node(x));\n-  }\n-  void pop_front() {\n-    list_node* node = (list_node*) head.next;\n-    head.next = node->next;\n-    destroy_node(node);\n-  }\n-\n-  iterator previous(const_iterator pos) {\n-    return iterator((list_node*) __slist_previous(&head, pos.node));\n-  }\n-  const_iterator previous(const_iterator pos) const {\n-    return const_iterator((list_node*) __slist_previous(&head, pos.node));\n-  }\n-\n-private:\n-  list_node* _insert_after(list_node_base* pos, const value_type& x) {\n-    return (list_node*) (__slist_make_link(pos, create_node(x)));\n-  }\n-\n-  void _insert_after_fill(list_node_base* pos,\n-                          size_type n, const value_type& x) {\n-    for (size_type i = 0; i < n; ++i)\n-      pos = __slist_make_link(pos, create_node(x));\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InIter>\n-  void _insert_after_range(list_node_base* pos, InIter first, InIter last) {\n-    while (first != last) {\n-      pos = __slist_make_link(pos, create_node(*first));\n-      ++first;\n-    }\n-  }\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void _insert_after_range(list_node_base* pos,\n-                           const_iterator first, const_iterator last) {\n-    while (first != last) {\n-      pos = __slist_make_link(pos, create_node(*first));\n-      ++first;\n-    }\n-  }\n-  void _insert_after_range(list_node_base* pos,\n-                           const value_type* first, const value_type* last) {\n-    while (first != last) {\n-      pos = __slist_make_link(pos, create_node(*first));\n-      ++first;\n-    }\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  void erase_after(list_node_base* pos) {\n-    list_node* next = (list_node*) (pos->next);\n-    pos->next = next->next;\n-    destroy_node(next);\n-  }\n-   \n-  void erase_after(list_node_base* before_first, list_node_base* last_node) {\n-    list_node* cur = (list_node*) (before_first->next);\n-    while (cur != last_node) {\n-      list_node* tmp = cur;\n-      cur = (list_node*) cur->next;\n-      destroy_node(tmp);\n-    }\n-    before_first->next = last_node;\n-  }\n-\n-\n-public:\n-\n-  iterator insert_after(iterator pos, const value_type& x) {\n-    return iterator(_insert_after(pos.node, x));\n-  }\n-\n-  iterator insert_after(iterator pos) {\n-    return insert_after(pos, value_type());\n-  }\n-\n-  void insert_after(iterator pos, size_type n, const value_type& x) {\n-    _insert_after_fill(pos.node, n, x);\n-  }\n-  void insert_after(iterator pos, int n, const value_type& x) {\n-    _insert_after_fill(pos.node, (size_type) n, x);\n-  }\n-  void insert_after(iterator pos, long n, const value_type& x) {\n-    _insert_after_fill(pos.node, (size_type) n, x);\n-  }\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InIter>\n-  void insert_after(iterator pos, InIter first, InIter last) {\n-    _insert_after_range(pos.node, first, last);\n-  }\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert_after(iterator pos, const_iterator first, const_iterator last) {\n-    _insert_after_range(pos.node, first, last);\n-  }\n-  void insert_after(iterator pos,\n-                    const value_type* first, const value_type* last) {\n-    _insert_after_range(pos.node, first, last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-  iterator insert(iterator pos, const value_type& x) {\n-    return iterator(_insert_after(__slist_previous(&head, pos.node), x));\n-  }\n-\n-  iterator insert(iterator pos) {\n-    return iterator(_insert_after(__slist_previous(&head, pos.node),\n-                                  value_type()));\n-  }\n-\n-  void insert(iterator pos, size_type n, const value_type& x) {\n-    _insert_after_fill(__slist_previous(&head, pos.node), n, x);\n-  } \n-  void insert(iterator pos, int n, const value_type& x) {\n-    _insert_after_fill(__slist_previous(&head, pos.node), (size_type) n, x);\n-  } \n-  void insert(iterator pos, long n, const value_type& x) {\n-    _insert_after_fill(__slist_previous(&head, pos.node), (size_type) n, x);\n-  } \n-    \n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class InIter>\n-  void insert(iterator pos, InIter first, InIter last) {\n-    _insert_after_range(__slist_previous(&head, pos.node), first, last);\n-  }\n-#else /* __STL_MEMBER_TEMPLATES */\n-  void insert(iterator pos, const_iterator first, const_iterator last) {\n-    _insert_after_range(__slist_previous(&head, pos.node), first, last);\n-  }\n-  void insert(iterator pos, const value_type* first, const value_type* last) {\n-    _insert_after_range(__slist_previous(&head, pos.node), first, last);\n-  }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-\n-public:\n-  void erase_after(iterator pos) { erase_after(pos.node); }\n-  void erase_after(iterator before_first, iterator last) {\n-    erase_after(before_first.node, last.node);\n-  }\n-\n-  void erase(iterator pos) { erase_after(__slist_previous(&head, pos.node)); }\n-  void erase(iterator first, iterator last) {\n-    erase_after(__slist_previous(&head, first.node), last.node);\n-  }\n-\n-  void resize(size_type new_size, const T& x);\n-  void resize(size_type new_size) { resize(new_size, T()); }\n-  void clear() { erase_after(&head, 0); }\n-\n-public:\n-  // Moves the range [before_first + 1, before_last + 1) to *this,\n-  //  inserting it immediately after pos.  This is constant time.\n-  void splice_after(iterator pos, \n-                    iterator before_first, iterator before_last)\n-  {\n-    if (before_first != before_last) \n-      __slist_splice_after(pos.node, before_first.node, before_last.node);\n-  }\n-\n-  // Moves the element that follows prev to *this, inserting it immediately\n-  //  after pos.  This is constant time.\n-  void splice_after(iterator pos, iterator prev)\n-  {\n-    __slist_splice_after(pos.node, prev.node, prev.node->next);\n-  }\n-\n-\n-  // Linear in distance(begin(), pos), and linear in L.size().\n-  void splice(iterator pos, slist& L) {\n-    if (L.head.next)\n-      __slist_splice_after(__slist_previous(&head, pos.node),\n-                           &L.head,\n-                           __slist_previous(&L.head, 0));\n-  }\n-\n-  // Linear in distance(begin(), pos), and in distance(L.begin(), i).\n-  void splice(iterator pos, slist& L, iterator i) {\n-    __slist_splice_after(__slist_previous(&head, pos.node),\n-                         __slist_previous(&L.head, i.node),\n-                         i.node);\n-  }\n-\n-  // Linear in distance(begin(), pos), in distance(L.begin(), first),\n-  // and in distance(first, last).\n-  void splice(iterator pos, slist& L, iterator first, iterator last)\n-  {\n-    if (first != last)\n-      __slist_splice_after(__slist_previous(&head, pos.node),\n-                           __slist_previous(&L.head, first.node),\n-                           __slist_previous(first.node, last.node));\n-  }\n-\n-public:\n-  void reverse() { if (head.next) head.next = __slist_reverse(head.next); }\n-\n-  void remove(const T& val); \n-  void unique(); \n-  void merge(slist& L);\n-  void sort();     \n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-  template <class Predicate> void remove_if(Predicate pred);\n-  template <class BinaryPredicate> void unique(BinaryPredicate pred); \n-  template <class StrictWeakOrdering> void merge(slist&, StrictWeakOrdering); \n-  template <class StrictWeakOrdering> void sort(StrictWeakOrdering comp); \n-#endif /* __STL_MEMBER_TEMPLATES */\n-};\n-\n-template <class T, class Alloc>\n-slist<T, Alloc>& slist<T,Alloc>::operator=(const slist<T, Alloc>& L)\n-{\n-  if (&L != this) {\n-    list_node_base* p1 = &head;\n-    list_node* n1 = (list_node*) head.next;\n-    const list_node* n2 = (const list_node*) L.head.next;\n-    while (n1 && n2) {\n-      n1->data = n2->data;\n-      p1 = n1;\n-      n1 = (list_node*) n1->next;\n-      n2 = (const list_node*) n2->next;\n-    }\n-    if (n2 == 0)\n-      erase_after(p1, 0);\n-    else\n-      _insert_after_range(p1,\n-                          const_iterator((list_node*)n2), const_iterator(0));\n-  }\n-  return *this;\n-} \n-\n-template <class T, class Alloc>\n-bool operator==(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)\n-{\n-  typedef typename slist<T,Alloc>::list_node list_node;\n-  list_node* n1 = (list_node*) L1.head.next;\n-  list_node* n2 = (list_node*) L2.head.next;\n-  while (n1 && n2 && n1->data == n2->data) {\n-    n1 = (list_node*) n1->next;\n-    n2 = (list_node*) n2->next;\n-  }\n-  return n1 == 0 && n2 == 0;\n-}\n-\n-template <class T, class Alloc>\n-inline bool operator<(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)\n-{\n-  return lexicographical_compare(L1.begin(), L1.end(), L2.begin(), L2.end());\n-}\n-\n-template <class T, class Alloc>\n-void slist<T, Alloc>::resize(size_type len, const T& x)\n-{\n-  list_node_base* cur = &head;\n-  while (cur->next != 0 && len > 0) {\n-    --len;\n-    cur = cur->next;\n-  }\n-  if (cur->next) \n-    erase_after(cur, 0);\n-  else\n-    _insert_after_fill(cur, len, x);\n-}\n-\n-template <class T, class Alloc>\n-void slist<T,Alloc>::remove(const T& val)\n-{\n-  list_node_base* cur = &head;\n-  while (cur && cur->next) {\n-    if (((list_node*) cur->next)->data == val)\n-      erase_after(cur);\n-    else\n-      cur = cur->next;\n-  }\n-}\n-\n-template <class T, class Alloc> \n-void slist<T,Alloc>::unique()\n-{\n-  list_node_base* cur = head.next;\n-  if (cur) {\n-    while (cur->next) {\n-      if (((list_node*)cur)->data == ((list_node*)(cur->next))->data)\n-        erase_after(cur);\n-      else\n-        cur = cur->next;\n-    }\n-  }\n-}\n-\n-template <class T, class Alloc>\n-void slist<T,Alloc>::merge(slist<T,Alloc>& L)\n-{\n-  list_node_base* n1 = &head;\n-  while (n1->next && L.head.next) {\n-    if (((list_node*) L.head.next)->data < ((list_node*) n1->next)->data) \n-      __slist_splice_after(n1, &L.head, L.head.next);\n-    n1 = n1->next;\n-  }\n-  if (L.head.next) {\n-    n1->next = L.head.next;\n-    L.head.next = 0;\n-  }\n-}\n-\n-template <class T, class Alloc>\n-void slist<T,Alloc>::sort()\n-{\n-  if (head.next && head.next->next) {\n-    slist carry;\n-    slist counter[64];\n-    int fill = 0;\n-    while (!empty()) {\n-      __slist_splice_after(&carry.head, &head, head.next);\n-      int i = 0;\n-      while (i < fill && !counter[i].empty()) {\n-        counter[i].merge(carry);\n-        carry.swap(counter[i]);\n-        ++i;\n-      }\n-      carry.swap(counter[i]);\n-      if (i == fill)\n-        ++fill;\n-    }\n-\n-    for (int i = 1; i < fill; ++i)\n-      counter[i].merge(counter[i-1]);\n-    this->swap(counter[fill-1]);\n-  }\n-}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-\n-template <class T, class Alloc> \n-template <class Predicate> void slist<T,Alloc>::remove_if(Predicate pred)\n-{\n-  list_node_base* cur = &head;\n-  while (cur->next) {\n-    if (pred(((list_node*) cur->next)->data))\n-      erase_after(cur);\n-    else\n-      cur = cur->next;\n-  }\n-}\n-\n-template <class T, class Alloc> template <class BinaryPredicate> \n-void slist<T,Alloc>::unique(BinaryPredicate pred)\n-{\n-  list_node* cur = (list_node*) head.next;\n-  if (cur) {\n-    while (cur->next) {\n-      if (pred(((list_node*)cur)->data, ((list_node*)(cur->next))->data))\n-        erase_after(cur);\n-      else\n-        cur = (list_node*) cur->next;\n-    }\n-  }\n-}\n-\n-template <class T, class Alloc> template <class StrictWeakOrdering>\n-void slist<T,Alloc>::merge(slist<T,Alloc>& L, StrictWeakOrdering comp)\n-{\n-  list_node_base* n1 = &head;\n-  while (n1->next && L.head.next) {\n-    if (comp(((list_node*) L.head.next)->data,\n-             ((list_node*) n1->next)->data))\n-      __slist_splice_after(n1, &L.head, L.head.next);\n-    n1 = n1->next;\n-  }\n-  if (L.head.next) {\n-    n1->next = L.head.next;\n-    L.head.next = 0;\n-  }\n-}\n-\n-template <class T, class Alloc> template <class StrictWeakOrdering> \n-void slist<T,Alloc>::sort(StrictWeakOrdering comp)\n-{\n-  if (head.next && head.next->next) {\n-    slist carry;\n-    slist counter[64];\n-    int fill = 0;\n-    while (!empty()) {\n-      __slist_splice_after(&carry.head, &head, head.next);\n-      int i = 0;\n-      while (i < fill && !counter[i].empty()) {\n-        counter[i].merge(carry, comp);\n-        carry.swap(counter[i]);\n-        ++i;\n-      }\n-      carry.swap(counter[i]);\n-      if (i == fill)\n-        ++fill;\n-    }\n-\n-    for (int i = 1; i < fill; ++i)\n-      counter[i].merge(counter[i-1], comp);\n-    this->swap(counter[fill-1]);\n-  }\n-}\n-\n-#endif /* __STL_MEMBER_TEMPLATES */\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::slist;\n+#endif /* __STL_USE_NAMESPACES */\n \n #endif /* __SGI_STL_SLIST_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "36461d95b8c46373cd1f59f3f2c9160d89e985d2", "filename": "libstdc++/stl/stack", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstack", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstack", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstack?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __SGI_STL_STACK\n+#define __SGI_STL_STACK\n+\n+#include <stl_algobase.h>\n+#include <stl_alloc.h>\n+#include <stl_construct.h>\n+#include <stl_uninitialized.h>\n+#include <stl_deque.h>\n+#include <stl_stack.h>\n+\n+#endif /* __SGI_STL_STACK */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "89beca82f1288e35fa4b9c1149f837c76d85ce38", "filename": "libstdc++/stl/stack.h", "status": "modified", "additions": 15, "deletions": 140, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstack.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996\n+ * Copyright (c) 1996,1997\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -24,148 +24,23 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n \n-#ifndef STACK_H\n-#define STACK_H\n+#ifndef __SGI_STL_STACK_H\n+#define __SGI_STL_STACK_H\n \n-#include <function.h>\n-#include <heap.h>\n #include <vector.h>\n #include <deque.h>\n+#include <heap.h>\n+#include <stl_stack.h>\n+#include <stl_queue.h>\n \n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class T, class Sequence = deque<T> >\n-#else\n-template <class T, class Sequence>\n-#endif\n-class stack {\n-  friend bool operator==(const stack<T, Sequence>& x,\n-                         const stack<T, Sequence>& y);\n-  friend bool operator<(const stack<T, Sequence>& x,\n-                        const stack<T, Sequence>& y);\n-public:\n-    typedef typename Sequence::value_type value_type;\n-    typedef typename Sequence::size_type size_type;\n-protected:\n-    Sequence c;\n-public:\n-    bool empty() const { return c.empty(); }\n-    size_type size() const { return c.size(); }\n-    value_type& top() { return c.back(); }\n-    const value_type& top() const { return c.back(); }\n-    void push(const value_type& x) { c.push_back(x); }\n-    void pop() { c.pop_back(); }\n-};\n-\n-template <class T, class Sequence>\n-bool operator==(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {\n-    return x.c == y.c;\n-}\n-\n-template <class T, class Sequence>\n-bool operator<(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {\n-    return x.c < y.c;\n-}\n-\n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class T, class Sequence = deque<T> >\n-#else\n-template <class T, class Sequence>\n-#endif\n-class queue {\n-friend bool operator==(const queue<T, Sequence>& x, const queue<T, Sequence>& y);\n-friend bool operator<(const queue<T, Sequence>& x, const queue<T, Sequence>& y);\n-public:\n-    typedef typename Sequence::value_type value_type;\n-    typedef typename Sequence::size_type size_type;\n-protected:\n-    Sequence c;\n-public:\n-    bool empty() const { return c.empty(); }\n-    size_type size() const { return c.size(); }\n-    value_type& front() { return c.front(); }\n-    const value_type& front() const { return c.front(); }\n-    value_type& back() { return c.back(); }\n-    const value_type& back() const { return c.back(); }\n-    void push(const value_type& x) { c.push_back(x); }\n-    void pop() { c.pop_front(); }\n-};\n-\n-template <class T, class Sequence>\n-bool operator==(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {\n-    return x.c == y.c;\n-}\n-\n-template <class T, class Sequence>\n-bool operator<(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {\n-    return x.c < y.c;\n-}\n-\n-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n-template <class T, class Sequence = vector<T>, \n-          class Compare = less<typename Sequence::value_type> >\n-#else\n-template <class T, class Sequence, class Compare>\n-#endif\n-class  priority_queue {\n-public:\n-    typedef typename Sequence::value_type value_type;\n-    typedef typename Sequence::size_type size_type;\n-protected:\n-    Sequence c;\n-    Compare comp;\n-public:\n-    priority_queue() : c() {}\n-    explicit priority_queue(const Compare& x) :  c(), comp(x) {}\n-\n-#ifdef __STL_MEMBER_TEMPLATES\n-    template <class InputIterator>\n-    priority_queue(InputIterator first, InputIterator last, const Compare& x)\n-      : c(first, last), comp(x) { make_heap(c.begin(), c.end(), comp); }\n-    template <class InputIterator>\n-    priority_queue(InputIterator first, InputIterator last) \n-      : c(first, last) { make_heap(c.begin(), c.end(), comp); }\n-#else /* __STL_MEMBER_TEMPLATES */\n-    priority_queue(const value_type* first, const value_type* last, \n-                   const Compare& x) : c(first, last), comp(x) {\n-        make_heap(c.begin(), c.end(), comp);\n-    }\n-    priority_queue(const value_type* first, const value_type* last) \n-      : c(first, last) { make_heap(c.begin(), c.end(), comp); }\n-#endif /* __STL_MEMBER_TEMPLATES */\n-\n-    bool empty() const { return c.empty(); }\n-    size_type size() const { return c.size(); }\n-    const value_type& top() const { return c.front(); }\n-    void push(const value_type& x) {\n-#         ifdef __STL_USE_EXCEPTIONS\n-      try {\n-#         endif /* __STL_USE_EXCEPTIONS */\n-        c.push_back(x); \n-        push_heap(c.begin(), c.end(), comp);\n-#         ifdef __STL_USE_EXCEPTIONS\n-      }\n-      catch(...) {\n-        c.clear();\n-        throw;\n-      }\n-#         endif /* __STL_USE_EXCEPTIONS */\n-    }\n-    void pop() {\n-#         ifdef __STL_USE_EXCEPTIONS\n-      try {\n-#         endif /* __STL_USE_EXCEPTIONS */\n-        pop_heap(c.begin(), c.end(), comp);\n-        c.pop_back();\n-#         ifdef __STL_USE_EXCEPTIONS\n-      }\n-      catch(...) {\n-        c.clear();\n-        throw;\n-      }\n-#         endif /* __STL_USE_EXCEPTIONS */\n-    }\n-};\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::stack;\n+using __STD::queue;\n+using __STD::priority_queue;\n+#endif /* __STL_USE_NAMESPACES */\n \n-// no equality is provided\n+#endif /* __SGI_STL_STACK_H */\n \n-#endif\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "6703c2aa7a8eca380c9058f207adc7266b73339b", "filename": "libstdc++/stl/stl_algo.h", "status": "added", "additions": 2674, "deletions": 0, "changes": 2674, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_algo.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,2674 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/* NOTE: This is an internal header file, included by other STL headers.\n+ *   You should not attempt to use it directly.\n+ */\n+\n+#ifndef __SGI_STL_INTERNAL_ALGO_H\n+#define __SGI_STL_INTERNAL_ALGO_H\n+\n+#include <stl_heap.h>\n+\n+__STL_BEGIN_NAMESPACE\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma set woff 1209\n+#endif\n+\n+template <class T>\n+inline const T& __median(const T& a, const T& b, const T& c) {\n+  if (a < b)\n+    if (b < c)\n+      return b;\n+    else if (a < c)\n+      return c;\n+    else\n+      return a;\n+  else if (a < c)\n+    return a;\n+  else if (b < c)\n+    return c;\n+  else\n+    return b;\n+}\n+\n+template <class T, class Compare>\n+inline const T& __median(const T& a, const T& b, const T& c, Compare comp) {\n+  if (comp(a, b))\n+    if (comp(b, c))\n+      return b;\n+    else if (comp(a, c))\n+      return c;\n+    else\n+      return a;\n+  else if (comp(a, c))\n+    return a;\n+  else if (comp(b, c))\n+    return c;\n+  else\n+    return b;\n+}\n+\n+template <class InputIterator, class Function>\n+Function for_each(InputIterator first, InputIterator last, Function f) {\n+  for ( ; first != last; ++first)\n+    f(*first);\n+  return f;\n+}\n+\n+template <class InputIterator, class T>\n+InputIterator find(InputIterator first, InputIterator last, const T& value) {\n+  while (first != last && *first != value) ++first;\n+  return first;\n+}\n+\n+template <class InputIterator, class Predicate>\n+InputIterator find_if(InputIterator first, InputIterator last,\n+                      Predicate pred) {\n+  while (first != last && !pred(*first)) ++first;\n+  return first;\n+}\n+\n+template <class ForwardIterator>\n+ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last) {\n+  if (first == last) return last;\n+  ForwardIterator next = first;\n+  while(++next != last) {\n+    if (*first == *next) return first;\n+    first = next;\n+  }\n+  return last;\n+}\n+\n+template <class ForwardIterator, class BinaryPredicate>\n+ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last,\n+                              BinaryPredicate binary_pred) {\n+  if (first == last) return last;\n+  ForwardIterator next = first;\n+  while(++next != last) {\n+    if (binary_pred(*first, *next)) return first;\n+    first = next;\n+  }\n+  return last;\n+}\n+\n+template <class InputIterator, class T, class Size>\n+void count(InputIterator first, InputIterator last, const T& value,\n+           Size& n) {\n+  for ( ; first != last; ++first)\n+    if (*first == value)\n+      ++n;\n+}\n+\n+template <class InputIterator, class Predicate, class Size>\n+void count_if(InputIterator first, InputIterator last, Predicate pred,\n+              Size& n) {\n+  for ( ; first != last; ++first)\n+    if (pred(*first))\n+      ++n;\n+}\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n+template <class InputIterator, class T>\n+typename iterator_traits<InputIterator>::difference_type\n+count(InputIterator first, InputIterator last, const T& value) {\n+  typename iterator_traits<InputIterator>::difference_type n = 0;\n+  for ( ; first != last; ++first)\n+    if (*first == value)\n+      ++n;\n+  return n;\n+}\n+\n+template <class InputIterator, class Predicate>\n+typename iterator_traits<InputIterator>::difference_type\n+count_if(InputIterator first, InputIterator last, Predicate pred) {\n+  typename iterator_traits<InputIterator>::difference_type n = 0;\n+  for ( ; first != last; ++first)\n+    if (pred(*first))\n+      ++n;\n+  return n;\n+}\n+\n+\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n+template <class ForwardIterator1, class ForwardIterator2, class Distance1,\n+          class Distance2>\n+ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,\n+                          ForwardIterator2 first2, ForwardIterator2 last2,\n+                          Distance1*, Distance2*) {\n+  Distance1 d1 = 0;\n+  distance(first1, last1, d1);\n+  Distance2 d2 = 0;\n+  distance(first2, last2, d2);\n+\n+  if (d1 < d2) return last1;\n+\n+  ForwardIterator1 current1 = first1;\n+  ForwardIterator2 current2 = first2;\n+\n+  while (current2 != last2) \n+    if (*current1 == *current2) {\n+      ++current1;\n+      ++current2;\n+    }\n+    else {\n+      if (d1 == d2)\n+        return last1;\n+      else {\n+        current1 = ++first1;\n+        current2 = first2;\n+        --d1;\n+      }\n+    }\n+  return first1;\n+}\n+\n+template <class ForwardIterator1, class ForwardIterator2>\n+inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,\n+                               ForwardIterator2 first2, ForwardIterator2 last2)\n+{\n+  return __search(first1, last1, first2, last2, distance_type(first1),\n+                  distance_type(first2));\n+}\n+\n+template <class ForwardIterator1, class ForwardIterator2,\n+          class BinaryPredicate, class Distance1, class Distance2>\n+ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,\n+                          ForwardIterator2 first2, ForwardIterator2 last2,\n+                          BinaryPredicate binary_pred, Distance1*, Distance2*) {\n+  Distance1 d1 = 0;\n+  distance(first1, last1, d1);\n+  Distance2 d2 = 0;\n+  distance(first2, last2, d2);\n+\n+  if (d1 < d2) return last1;\n+\n+  ForwardIterator1 current1 = first1;\n+  ForwardIterator2 current2 = first2;\n+\n+  while (current2 != last2)\n+    if (binary_pred(*current1, *current2)) {\n+      ++current1;\n+      ++current2;\n+    }\n+    else {\n+      if (d1 == d2)\n+        return last1;\n+      else {\n+        current1 = ++first1;\n+        current2 = first2;\n+        --d1;\n+      }\n+    }\n+  return first1;\n+}\n+\n+template <class ForwardIterator1, class ForwardIterator2,\n+          class BinaryPredicate>\n+inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,\n+                               ForwardIterator2 first2, ForwardIterator2 last2,\n+                               BinaryPredicate binary_pred) {\n+  return __search(first1, last1, first2, last2, binary_pred,\n+                  distance_type(first1), distance_type(first2));\n+}\n+\n+template <class ForwardIterator, class Integer, class T>\n+ForwardIterator search_n(ForwardIterator first, ForwardIterator last,\n+                         Integer count, const T& value) {\n+  if (count <= 0)\n+    return first;\n+  else {\n+    first = find(first, last, value);\n+    while (first != last) {\n+      Integer n = count - 1;\n+      ForwardIterator i = first;\n+      ++i;\n+      while (i != last && n != 0 && *i == value) {\n+        ++i;\n+        --n;\n+      }\n+      if (n == 0)\n+        return first;\n+      else\n+        first = find(i, last, value);\n+    }\n+    return last;\n+  }\n+}\n+\n+template <class ForwardIterator, class Integer, class T, class BinaryPredicate>\n+ForwardIterator search_n(ForwardIterator first, ForwardIterator last,\n+                         Integer count, const T& value,\n+                         BinaryPredicate binary_pred) {\n+  if (count <= 0)\n+    return first;\n+  else {\n+    while (first != last) {\n+      if (binary_pred(*first, value)) break;\n+      ++first;\n+    }\n+    while (first != last) {\n+      Integer n = count - 1;\n+      ForwardIterator i = first;\n+      ++i;\n+      while (i != last && n != 0 && binary_pred(*i, value)) {\n+        ++i;\n+        --n;\n+      }\n+      if (n == 0)\n+        return first;\n+      else {\n+        while (i != last) {\n+          if (binary_pred(*i, value)) break;\n+          ++i;\n+        }\n+        first = i;\n+      }\n+    }\n+    return last;\n+  }\n+} \n+\n+template <class ForwardIterator1, class ForwardIterator2>\n+ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,\n+                             ForwardIterator2 first2) {\n+  for ( ; first1 != last1; ++first1, ++first2)\n+    iter_swap(first1, first2);\n+  return first2;\n+}\n+\n+template <class InputIterator, class OutputIterator, class UnaryOperation>\n+OutputIterator transform(InputIterator first, InputIterator last,\n+                         OutputIterator result, UnaryOperation op) {\n+  for ( ; first != last; ++first, ++result)\n+    *result = op(*first);\n+  return result;\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator,\n+          class BinaryOperation>\n+OutputIterator transform(InputIterator1 first1, InputIterator1 last1,\n+                         InputIterator2 first2, OutputIterator result,\n+                         BinaryOperation binary_op) {\n+  for ( ; first1 != last1; ++first1, ++first2, ++result)\n+    *result = binary_op(*first1, *first2);\n+  return result;\n+}\n+\n+template <class ForwardIterator, class T>\n+void replace(ForwardIterator first, ForwardIterator last, const T& old_value,\n+             const T& new_value) {\n+  for ( ; first != last; ++first)\n+    if (*first == old_value) *first = new_value;\n+}\n+\n+template <class ForwardIterator, class Predicate, class T>\n+void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred,\n+                const T& new_value) {\n+  for ( ; first != last; ++first)\n+    if (pred(*first)) *first = new_value;\n+}\n+\n+template <class InputIterator, class OutputIterator, class T>\n+OutputIterator replace_copy(InputIterator first, InputIterator last,\n+                            OutputIterator result, const T& old_value,\n+                            const T& new_value) {\n+  for ( ; first != last; ++first, ++result)\n+    *result = *first == old_value ? new_value : *first;\n+  return result;\n+}\n+\n+template <class Iterator, class OutputIterator, class Predicate, class T>\n+OutputIterator replace_copy_if(Iterator first, Iterator last,\n+                               OutputIterator result, Predicate pred,\n+                               const T& new_value) {\n+  for ( ; first != last; ++first, ++result)\n+    *result = pred(*first) ? new_value : *first;\n+  return result;\n+}\n+\n+template <class ForwardIterator, class Generator>\n+void generate(ForwardIterator first, ForwardIterator last, Generator gen) {\n+  for ( ; first != last; ++first)\n+    *first = gen();\n+}\n+\n+template <class OutputIterator, class Size, class Generator>\n+OutputIterator generate_n(OutputIterator first, Size n, Generator gen) {\n+  for ( ; n > 0; --n, ++first)\n+    *first = gen();\n+  return first;\n+}\n+\n+template <class InputIterator, class OutputIterator, class T>\n+OutputIterator remove_copy(InputIterator first, InputIterator last,\n+                           OutputIterator result, const T& value) {\n+  for ( ; first != last; ++first)\n+    if (*first != value) {\n+      *result = *first;\n+      ++result;\n+    }\n+  return result;\n+}\n+\n+template <class InputIterator, class OutputIterator, class Predicate>\n+OutputIterator remove_copy_if(InputIterator first, InputIterator last,\n+                              OutputIterator result, Predicate pred) {\n+  for ( ; first != last; ++first)\n+    if (!pred(*first)) {\n+      *result = *first;\n+      ++result;\n+    }\n+  return result;\n+}\n+\n+template <class ForwardIterator, class T>\n+ForwardIterator remove(ForwardIterator first, ForwardIterator last,\n+                       const T& value) {\n+  first = find(first, last, value);\n+  ForwardIterator next = first;\n+  return first == last ? first : remove_copy(++next, last, first, value);\n+}\n+\n+template <class ForwardIterator, class Predicate>\n+ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,\n+                          Predicate pred) {\n+  first = find_if(first, last, pred);\n+  ForwardIterator next = first;\n+  return first == last ? first : remove_copy_if(++next, last, first, pred);\n+}\n+\n+template <class InputIterator, class ForwardIterator>\n+ForwardIterator __unique_copy(InputIterator first, InputIterator last,\n+                              ForwardIterator result, forward_iterator_tag) {\n+  *result = *first;\n+  while (++first != last)\n+    if (*result != *first) *++result = *first;\n+  return ++result;\n+}\n+\n+\n+template <class InputIterator, class OutputIterator, class T>\n+OutputIterator __unique_copy(InputIterator first, InputIterator last,\n+                             OutputIterator result, T*) {\n+  T value = *first;\n+  *result = value;\n+  while (++first != last)\n+    if (value != *first) {\n+      value = *first;\n+      *++result = value;\n+    }\n+  return ++result;\n+}\n+\n+template <class InputIterator, class OutputIterator>\n+inline OutputIterator __unique_copy(InputIterator first, InputIterator last,\n+                                    OutputIterator result, \n+                                    output_iterator_tag) {\n+  return __unique_copy(first, last, result, value_type(first));\n+}\n+\n+template <class InputIterator, class OutputIterator>\n+inline OutputIterator unique_copy(InputIterator first, InputIterator last,\n+                                  OutputIterator result) {\n+  if (first == last) return result;\n+  return __unique_copy(first, last, result, iterator_category(result));\n+}\n+template <class InputIterator, class ForwardIterator, class BinaryPredicate>\n+ForwardIterator __unique_copy(InputIterator first, InputIterator last,\n+                              ForwardIterator result, \n+                              BinaryPredicate binary_pred,\n+                              forward_iterator_tag) {\n+  *result = *first;\n+  while (++first != last)\n+    if (!binary_pred(*result, *first)) *++result = *first;\n+  return ++result;\n+}\n+\n+template <class InputIterator, class OutputIterator, class BinaryPredicate,\n+          class T>\n+OutputIterator __unique_copy(InputIterator first, InputIterator last,\n+                             OutputIterator result,\n+                             BinaryPredicate binary_pred, T*) {\n+  T value = *first;\n+  *result = value;\n+  while (++first != last)\n+    if (!binary_pred(value, *first)) {\n+      value = *first;\n+      *++result = value;\n+    }\n+  return ++result;\n+}\n+\n+template <class InputIterator, class OutputIterator, class BinaryPredicate>\n+inline OutputIterator __unique_copy(InputIterator first, InputIterator last,\n+                                    OutputIterator result,\n+                                    BinaryPredicate binary_pred,\n+                                    output_iterator_tag) {\n+  return __unique_copy(first, last, result, binary_pred, value_type(first));\n+}\n+\n+template <class InputIterator, class OutputIterator, class BinaryPredicate>\n+inline OutputIterator unique_copy(InputIterator first, InputIterator last,\n+                                  OutputIterator result,\n+                                  BinaryPredicate binary_pred) {\n+  if (first == last) return result;\n+  return __unique_copy(first, last, result, binary_pred,\n+                       iterator_category(result));\n+}\n+\n+template <class ForwardIterator>\n+ForwardIterator unique(ForwardIterator first, ForwardIterator last) {\n+  first = adjacent_find(first, last);\n+  return unique_copy(first, last, first);\n+}\n+\n+template <class ForwardIterator, class BinaryPredicate>\n+ForwardIterator unique(ForwardIterator first, ForwardIterator last,\n+                       BinaryPredicate binary_pred) {\n+  first = adjacent_find(first, last, binary_pred);\n+  return unique_copy(first, last, first, binary_pred);\n+}\n+\n+template <class BidirectionalIterator>\n+void __reverse(BidirectionalIterator first, BidirectionalIterator last, \n+               bidirectional_iterator_tag) {\n+  while (true)\n+    if (first == last || first == --last)\n+      return;\n+    else\n+      iter_swap(first++, last);\n+}\n+\n+template <class RandomAccessIterator>\n+void __reverse(RandomAccessIterator first, RandomAccessIterator last,\n+               random_access_iterator_tag) {\n+  while (first < last) iter_swap(first++, --last);\n+}\n+\n+template <class BidirectionalIterator>\n+inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {\n+  __reverse(first, last, iterator_category(first));\n+}\n+\n+template <class BidirectionalIterator, class OutputIterator>\n+OutputIterator reverse_copy(BidirectionalIterator first,\n+                            BidirectionalIterator last,\n+                            OutputIterator result) {\n+  while (first != last) {\n+    --last;\n+    *result = *last;\n+    ++result;\n+  }\n+  return result;\n+}\n+\n+template <class ForwardIterator, class Distance>\n+void __rotate(ForwardIterator first, ForwardIterator middle,\n+              ForwardIterator last, Distance*, forward_iterator_tag) {\n+  for (ForwardIterator i = middle; ;) {\n+    iter_swap(first, i);\n+    ++first;\n+    ++i;\n+    if (first == middle) {\n+      if (i == last) return;\n+      middle = i;\n+    }\n+    else if (i == last)\n+      i = middle;\n+  }\n+}\n+\n+template <class BidirectionalIterator, class Distance>\n+void __rotate(BidirectionalIterator first, BidirectionalIterator middle,\n+              BidirectionalIterator last, Distance*,\n+              bidirectional_iterator_tag) {\n+  reverse(first, middle);\n+  reverse(middle, last);\n+  reverse(first, last);\n+}\n+\n+template <class EuclideanRingElement>\n+EuclideanRingElement __gcd(EuclideanRingElement m, EuclideanRingElement n)\n+{\n+  while (n != 0) {\n+    EuclideanRingElement t = m % n;\n+    m = n;\n+    n = t;\n+  }\n+  return m;\n+}\n+\n+template <class RandomAccessIterator, class Distance, class T>\n+void __rotate_cycle(RandomAccessIterator first, RandomAccessIterator last,\n+                    RandomAccessIterator initial, Distance shift, T*) {\n+  T value = *initial;\n+  RandomAccessIterator ptr1 = initial;\n+  RandomAccessIterator ptr2 = ptr1 + shift;\n+  while (ptr2 != initial) {\n+    *ptr1 = *ptr2;\n+    ptr1 = ptr2;\n+    if (last - ptr2 > shift)\n+      ptr2 += shift;\n+    else\n+      ptr2 = first + (shift - (last - ptr2));\n+  }\n+  *ptr1 = value;\n+}\n+\n+template <class RandomAccessIterator, class Distance>\n+void __rotate(RandomAccessIterator first, RandomAccessIterator middle,\n+              RandomAccessIterator last, Distance*,\n+              random_access_iterator_tag) {\n+  Distance n = __gcd(last - first, middle - first);\n+  while (n--)\n+    __rotate_cycle(first, last, first + n, middle - first,\n+                   value_type(first));\n+}\n+\n+template <class ForwardIterator>\n+inline void rotate(ForwardIterator first, ForwardIterator middle,\n+                   ForwardIterator last) {\n+  if (first == middle || middle == last) return;\n+  __rotate(first, middle, last, distance_type(first),\n+           iterator_category(first));\n+}\n+\n+template <class ForwardIterator, class OutputIterator>\n+OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,\n+                           ForwardIterator last, OutputIterator result) {\n+  return copy(first, middle, copy(middle, last, result));\n+}\n+\n+template <class RandomAccessIterator, class Distance>\n+void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n+                      Distance*) {\n+  if (first == last) return;\n+  for (RandomAccessIterator i = first + 1; i != last; ++i) \n+#ifdef __STL_NO_DRAND48\n+    iter_swap(i, first + Distance(rand() % ((i - first) + 1)));\n+#else\n+  iter_swap(i, first + Distance(lrand48() % ((i - first) + 1)));\n+#endif\n+}\n+\n+template <class RandomAccessIterator>\n+inline void random_shuffle(RandomAccessIterator first,\n+                           RandomAccessIterator last) {\n+  __random_shuffle(first, last, distance_type(first));\n+}\n+\n+template <class RandomAccessIterator, class RandomNumberGenerator>\n+void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n+                    RandomNumberGenerator& rand) {\n+  if (first == last) return;\n+  for (RandomAccessIterator i = first + 1; i != last; ++i)\n+    iter_swap(i, first + rand((i - first) + 1));\n+}\n+\n+template <class ForwardIterator, class OutputIterator, class Distance>\n+OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,\n+                               OutputIterator out, const Distance n)\n+{\n+  Distance remaining = 0;\n+  distance(first, last, remaining);\n+  Distance m = min(n, remaining);\n+\n+  while (m > 0) {\n+#ifdef __STL_NO_DRAND48\n+    if (rand() % remaining < m) {\n+#else\n+    if (lrand48() % remaining < m) {\n+#endif\n+      *out = *first;\n+      ++out;\n+      --m;\n+    }\n+\n+    --remaining;\n+    ++first;\n+  }\n+  return out;\n+}\n+\n+template <class ForwardIterator, class OutputIterator, class Distance,\n+          class RandomNumberGenerator>\n+OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,\n+                               OutputIterator out, const Distance n,\n+                               RandomNumberGenerator& rand)\n+{\n+  Distance remaining = 0;\n+  distance(first, last, remaining);\n+  Distance m = min(n, remaining);\n+\n+  while (m > 0) {\n+    if (rand(remaining) < m) {\n+      *out = *first;\n+      ++out;\n+      --m;\n+    }\n+\n+    --remaining;\n+    ++first;\n+  }\n+  return out;\n+}\n+\n+template <class InputIterator, class RandomAccessIterator, class Distance>\n+RandomAccessIterator __random_sample(InputIterator first, InputIterator last,\n+                                     RandomAccessIterator out,\n+                                     const Distance n)\n+{\n+  Distance m = 0;\n+  Distance t = n;\n+  for ( ; first != last && m < n; ++m, ++first) \n+    out[m] = *first;\n+\n+  while (first != last) {\n+    ++t;\n+#ifdef __STL_NO_DRAND48\n+    Distance M = rand() % t;\n+#else\n+    Distance M = lrand48() % t;\n+#endif\n+    if (M < n)\n+      out[M] = *first;\n+    ++first;\n+  }\n+\n+  return out + m;\n+}\n+\n+template <class InputIterator, class RandomAccessIterator,\n+          class RandomNumberGenerator, class Distance>\n+RandomAccessIterator __random_sample(InputIterator first, InputIterator last,\n+                                     RandomAccessIterator out,\n+                                     RandomNumberGenerator& rand,\n+                                     const Distance n)\n+{\n+  Distance m = 0;\n+  Distance t = n;\n+  for ( ; first != last && m < n; ++m, ++first)\n+    out[m] = *first;\n+\n+  while (first != last) {\n+    ++t;\n+    Distance M = rand(t);\n+    if (M < n)\n+      out[M] = *first;\n+    ++first;\n+  }\n+\n+  return out + m;\n+}\n+\n+template <class InputIterator, class RandomAccessIterator>\n+inline RandomAccessIterator\n+random_sample(InputIterator first, InputIterator last,\n+              RandomAccessIterator out_first, RandomAccessIterator out_last) \n+{\n+  return __random_sample(first, last, out_first, out_last - out_first);\n+}\n+\n+template <class InputIterator, class RandomAccessIterator, \n+          class RandomNumberGenerator>\n+inline RandomAccessIterator\n+random_sample(InputIterator first, InputIterator last,\n+              RandomAccessIterator out_first, RandomAccessIterator out_last,\n+              RandomNumberGenerator& rand) \n+{\n+  return __random_sample(first, last, out_first, rand, out_last - out_first);\n+}\n+\n+\n+\n+template <class BidirectionalIterator, class Predicate>\n+BidirectionalIterator partition(BidirectionalIterator first,\n+                                BidirectionalIterator last, Predicate pred) {\n+  while (true) {\n+    while (true)\n+      if (first == last)\n+        return first;\n+      else if (pred(*first))\n+        ++first;\n+      else\n+        break;\n+    --last;\n+    while (true)\n+      if (first == last)\n+        return first;\n+      else if (!pred(*last))\n+        --last;\n+      else\n+        break;\n+    iter_swap(first, last);\n+    ++first;\n+  }\n+}\n+\n+template <class ForwardIterator, class Predicate, class Distance>\n+ForwardIterator __inplace_stable_partition(ForwardIterator first,\n+                                           ForwardIterator last,\n+                                           Predicate pred, Distance len) {\n+  if (len == 1) return pred(*first) ? last : first;\n+  ForwardIterator middle = first;\n+  advance(middle, len / 2);\n+  ForwardIterator \n+    first_cut = __inplace_stable_partition(first, middle, pred, len / 2);\n+  ForwardIterator \n+    second_cut = __inplace_stable_partition(middle, last, pred,\n+                                            len - len / 2);\n+  rotate(first_cut, middle, second_cut);\n+  len = 0;\n+  distance(middle, second_cut, len);\n+  advance(first_cut, len);\n+  return first_cut;\n+}\n+\n+template <class ForwardIterator, class Pointer, class Predicate, \n+          class Distance>\n+ForwardIterator __stable_partition_adaptive(ForwardIterator first,\n+                                            ForwardIterator last,\n+                                            Predicate pred, Distance len,\n+                                            Pointer buffer,\n+                                            Distance buffer_size) {\n+  if (len <= buffer_size) {\n+    ForwardIterator result1 = first;\n+    Pointer result2 = buffer;\n+    for ( ; first != last ; ++first)\n+      if (pred(*first)) {\n+        *result1 = *first;\n+        ++result1;\n+      }\n+      else {\n+        *result2 = *first;\n+        ++result2;\n+      }\n+    copy(buffer, result2, result1);\n+    return result1;\n+  }\n+  else {\n+    ForwardIterator middle = first;\n+    advance(middle, len / 2);\n+    ForwardIterator first_cut =\n+      __stable_partition_adaptive(first, middle, pred, len / 2,\n+                                  buffer, buffer_size);\n+    ForwardIterator second_cut =\n+      __stable_partition_adaptive(middle, last, pred, len - len / 2,\n+                                  buffer, buffer_size);\n+\n+    rotate(first_cut, middle, second_cut);\n+    len = 0;\n+    distance(middle, second_cut, len);\n+    advance(first_cut, len);\n+    return first_cut;\n+  }\n+}\n+\n+template <class ForwardIterator, class Predicate, class T, class Distance>\n+inline ForwardIterator __stable_partition_aux(ForwardIterator first,\n+                                              ForwardIterator last, \n+                                              Predicate pred, T*, Distance*) {\n+  temporary_buffer<ForwardIterator, T> buf(first, last);\n+  if (buf.size() > 0)\n+    return __stable_partition_adaptive(first, last, pred,\n+                                       Distance(buf.requested_size()),\n+                                       buf.begin(), buf.size());\n+  else\n+    return __inplace_stable_partition(first, last, pred, \n+                                      Distance(buf.requested_size()));\n+}\n+\n+template <class ForwardIterator, class Predicate>\n+inline ForwardIterator stable_partition(ForwardIterator first,\n+                                        ForwardIterator last, \n+                                        Predicate pred) {\n+  if (first == last)\n+    return first;\n+  else\n+    return __stable_partition_aux(first, last, pred,\n+                                  value_type(first), distance_type(first));\n+}\n+\n+template <class RandomAccessIterator, class T>\n+RandomAccessIterator __unguarded_partition(RandomAccessIterator first, \n+                                           RandomAccessIterator last, \n+                                           T pivot) {\n+  while (true) {\n+    while (*first < pivot) ++first;\n+    --last;\n+    while (pivot < *last) --last;\n+    if (!(first < last)) return first;\n+    iter_swap(first, last);\n+    ++first;\n+  }\n+}    \n+\n+template <class RandomAccessIterator, class T, class Compare>\n+RandomAccessIterator __unguarded_partition(RandomAccessIterator first, \n+                                           RandomAccessIterator last, \n+                                           T pivot, Compare comp) {\n+  while (1) {\n+    while (comp(*first, pivot)) ++first;\n+    --last;\n+    while (comp(pivot, *last)) --last;\n+    if (!(first < last)) return first;\n+    iter_swap(first, last);\n+    ++first;\n+  }\n+}\n+\n+const int __stl_threshold = 16;\n+\n+\n+template <class RandomAccessIterator, class T>\n+void __unguarded_linear_insert(RandomAccessIterator last, T value) {\n+  RandomAccessIterator next = last;\n+  --next;\n+  while (value < *next) {\n+    *last = *next;\n+    last = next;\n+    --next;\n+  }\n+  *last = value;\n+}\n+\n+template <class RandomAccessIterator, class T, class Compare>\n+void __unguarded_linear_insert(RandomAccessIterator last, T value, \n+                               Compare comp) {\n+  RandomAccessIterator next = last;\n+  --next;  \n+  while (comp(value , *next)) {\n+    *last = *next;\n+    last = next;\n+    --next;\n+  }\n+  *last = value;\n+}\n+\n+template <class RandomAccessIterator, class T>\n+inline void __linear_insert(RandomAccessIterator first, \n+                            RandomAccessIterator last, T*) {\n+  T value = *last;\n+  if (value < *first) {\n+    copy_backward(first, last, last + 1);\n+    *first = value;\n+  }\n+  else\n+    __unguarded_linear_insert(last, value);\n+}\n+\n+template <class RandomAccessIterator, class T, class Compare>\n+inline void __linear_insert(RandomAccessIterator first, \n+                            RandomAccessIterator last, T*, Compare comp) {\n+  T value = *last;\n+  if (comp(value, *first)) {\n+    copy_backward(first, last, last + 1);\n+    *first = value;\n+  }\n+  else\n+    __unguarded_linear_insert(last, value, comp);\n+}\n+\n+template <class RandomAccessIterator>\n+void __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) {\n+  if (first == last) return; \n+  for (RandomAccessIterator i = first + 1; i != last; ++i)\n+    __linear_insert(first, i, value_type(first));\n+}\n+\n+template <class RandomAccessIterator, class Compare>\n+void __insertion_sort(RandomAccessIterator first,\n+                      RandomAccessIterator last, Compare comp) {\n+  if (first == last) return;\n+  for (RandomAccessIterator i = first + 1; i != last; ++i)\n+    __linear_insert(first, i, value_type(first), comp);\n+}\n+\n+template <class RandomAccessIterator, class T>\n+void __unguarded_insertion_sort_aux(RandomAccessIterator first, \n+                                    RandomAccessIterator last, T*) {\n+  for (RandomAccessIterator i = first; i != last; ++i)\n+    __unguarded_linear_insert(i, T(*i));\n+}\n+\n+template <class RandomAccessIterator>\n+inline void __unguarded_insertion_sort(RandomAccessIterator first, \n+                                RandomAccessIterator last) {\n+  __unguarded_insertion_sort_aux(first, last, value_type(first));\n+}\n+\n+template <class RandomAccessIterator, class T, class Compare>\n+void __unguarded_insertion_sort_aux(RandomAccessIterator first, \n+                                    RandomAccessIterator last,\n+                                    T*, Compare comp) {\n+  for (RandomAccessIterator i = first; i != last; ++i)\n+    __unguarded_linear_insert(i, T(*i), comp);\n+}\n+\n+template <class RandomAccessIterator, class Compare>\n+inline void __unguarded_insertion_sort(RandomAccessIterator first, \n+                                       RandomAccessIterator last,\n+                                       Compare comp) {\n+  __unguarded_insertion_sort_aux(first, last, value_type(first), comp);\n+}\n+\n+template <class RandomAccessIterator>\n+void __final_insertion_sort(RandomAccessIterator first, \n+                            RandomAccessIterator last) {\n+  if (last - first > __stl_threshold) {\n+    __insertion_sort(first, first + __stl_threshold);\n+    __unguarded_insertion_sort(first + __stl_threshold, last);\n+  }\n+  else\n+    __insertion_sort(first, last);\n+}\n+\n+template <class RandomAccessIterator, class Compare>\n+void __final_insertion_sort(RandomAccessIterator first, \n+                            RandomAccessIterator last, Compare comp) {\n+  if (last - first > __stl_threshold) {\n+    __insertion_sort(first, first + __stl_threshold, comp);\n+    __unguarded_insertion_sort(first + __stl_threshold, last, comp);\n+  }\n+  else\n+    __insertion_sort(first, last, comp);\n+}\n+\n+template <class Size>\n+inline Size __lg(Size n) {\n+  Size k;\n+  for (k = 0; n != 1; n >>= 1) ++k;\n+  return k;\n+}\n+\n+template <class RandomAccessIterator, class T, class Size>\n+void __introsort_loop(RandomAccessIterator first,\n+                      RandomAccessIterator last, T*,\n+                      Size depth_limit) {\n+  while (last - first > __stl_threshold) {\n+    if (depth_limit == 0) {\n+      partial_sort(first, last, last);\n+      return;\n+    }\n+    --depth_limit;\n+    RandomAccessIterator cut = __unguarded_partition\n+      (first, last, T(__median(*first, *(first + (last - first)/2),\n+                               *(last - 1))));\n+    __introsort_loop(cut, last, value_type(first), depth_limit);\n+    last = cut;\n+  }\n+}\n+\n+template <class RandomAccessIterator, class T, class Size, class Compare>\n+void __introsort_loop(RandomAccessIterator first,\n+                      RandomAccessIterator last, T*,\n+                      Size depth_limit, Compare comp) {\n+  while (last - first > __stl_threshold) {\n+    if (depth_limit == 0) {\n+      partial_sort(first, last, last, comp);\n+      return;\n+    }\n+    --depth_limit;\n+    RandomAccessIterator cut = __unguarded_partition\n+      (first, last, T(__median(*first, *(first + (last - first)/2),\n+                               *(last - 1), comp)), comp);\n+    __introsort_loop(cut, last, value_type(first), depth_limit, comp);\n+    last = cut;\n+  }\n+}\n+\n+template <class RandomAccessIterator>\n+inline void sort(RandomAccessIterator first, RandomAccessIterator last) {\n+  if (first != last) {\n+    __introsort_loop(first, last, value_type(first), __lg(last - first) * 2);\n+    __final_insertion_sort(first, last);\n+  }\n+}\n+\n+template <class RandomAccessIterator, class Compare>\n+inline void sort(RandomAccessIterator first, RandomAccessIterator last,\n+                 Compare comp) {\n+  if (first != last) {\n+    __introsort_loop(first, last, value_type(first), __lg(last - first) * 2,\n+                     comp);\n+    __final_insertion_sort(first, last, comp);\n+  }\n+}\n+\n+\n+template <class RandomAccessIterator>\n+void __inplace_stable_sort(RandomAccessIterator first,\n+                           RandomAccessIterator last) {\n+  if (last - first < 15) {\n+    __insertion_sort(first, last);\n+    return;\n+  }\n+  RandomAccessIterator middle = first + (last - first) / 2;\n+  __inplace_stable_sort(first, middle);\n+  __inplace_stable_sort(middle, last);\n+  __merge_without_buffer(first, middle, last, middle - first, last - middle);\n+}\n+\n+template <class RandomAccessIterator, class Compare>\n+void __inplace_stable_sort(RandomAccessIterator first,\n+                           RandomAccessIterator last, Compare comp) {\n+  if (last - first < 15) {\n+    __insertion_sort(first, last, comp);\n+    return;\n+  }\n+  RandomAccessIterator middle = first + (last - first) / 2;\n+  __inplace_stable_sort(first, middle, comp);\n+  __inplace_stable_sort(middle, last, comp);\n+  __merge_without_buffer(first, middle, last, middle - first,\n+                         last - middle, comp);\n+}\n+\n+template <class RandomAccessIterator1, class RandomAccessIterator2,\n+          class Distance>\n+void __merge_sort_loop(RandomAccessIterator1 first,\n+                       RandomAccessIterator1 last, \n+                       RandomAccessIterator2 result, Distance step_size) {\n+  Distance two_step = 2 * step_size;\n+\n+  while (last - first >= two_step) {\n+    result = merge(first, first + step_size,\n+                   first + step_size, first + two_step, result);\n+    first += two_step;\n+  }\n+\n+  step_size = min(Distance(last - first), step_size);\n+  merge(first, first + step_size, first + step_size, last, result);\n+}\n+\n+template <class RandomAccessIterator1, class RandomAccessIterator2,\n+          class Distance, class Compare>\n+void __merge_sort_loop(RandomAccessIterator1 first,\n+                       RandomAccessIterator1 last, \n+                       RandomAccessIterator2 result, Distance step_size,\n+                       Compare comp) {\n+  Distance two_step = 2 * step_size;\n+\n+  while (last - first >= two_step) {\n+    result = merge(first, first + step_size,\n+                   first + step_size, first + two_step, result, comp);\n+    first += two_step;\n+  }\n+  step_size = min(Distance(last - first), step_size);\n+\n+  merge(first, first + step_size, first + step_size, last, result, comp);\n+}\n+\n+const int __stl_chunk_size = 7;\n+        \n+template <class RandomAccessIterator, class Distance>\n+void __chunk_insertion_sort(RandomAccessIterator first, \n+                            RandomAccessIterator last, Distance chunk_size) {\n+  while (last - first >= chunk_size) {\n+    __insertion_sort(first, first + chunk_size);\n+    first += chunk_size;\n+  }\n+  __insertion_sort(first, last);\n+}\n+\n+template <class RandomAccessIterator, class Distance, class Compare>\n+void __chunk_insertion_sort(RandomAccessIterator first, \n+                            RandomAccessIterator last,\n+                            Distance chunk_size, Compare comp) {\n+  while (last - first >= chunk_size) {\n+    __insertion_sort(first, first + chunk_size, comp);\n+    first += chunk_size;\n+  }\n+  __insertion_sort(first, last, comp);\n+}\n+\n+template <class RandomAccessIterator, class Pointer, class Distance>\n+void __merge_sort_with_buffer(RandomAccessIterator first, \n+                              RandomAccessIterator last,\n+                              Pointer buffer, Distance*) {\n+  Distance len = last - first;\n+  Pointer buffer_last = buffer + len;\n+\n+  Distance step_size = __stl_chunk_size;\n+  __chunk_insertion_sort(first, last, step_size);\n+\n+  while (step_size < len) {\n+    __merge_sort_loop(first, last, buffer, step_size);\n+    step_size *= 2;\n+    __merge_sort_loop(buffer, buffer_last, first, step_size);\n+    step_size *= 2;\n+  }\n+}\n+\n+template <class RandomAccessIterator, class Pointer, class Distance,\n+          class Compare>\n+void __merge_sort_with_buffer(RandomAccessIterator first, \n+                              RandomAccessIterator last, Pointer buffer,\n+                              Distance*, Compare comp) {\n+  Distance len = last - first;\n+  Pointer buffer_last = buffer + len;\n+\n+  Distance step_size = __stl_chunk_size;\n+  __chunk_insertion_sort(first, last, step_size, comp);\n+\n+  while (step_size < len) {\n+    __merge_sort_loop(first, last, buffer, step_size, comp);\n+    step_size *= 2;\n+    __merge_sort_loop(buffer, buffer_last, first, step_size, comp);\n+    step_size *= 2;\n+  }\n+}\n+\n+template <class RandomAccessIterator, class Pointer, class Distance>\n+void __stable_sort_adaptive(RandomAccessIterator first, \n+                            RandomAccessIterator last, Pointer buffer,\n+                            Distance buffer_size) {\n+  Distance len = (last - first + 1) / 2;\n+  RandomAccessIterator middle = first + len;\n+  if (len > buffer_size) {\n+    __stable_sort_adaptive(first, middle, buffer, buffer_size);\n+    __stable_sort_adaptive(middle, last, buffer, buffer_size);\n+  } else {\n+    __merge_sort_with_buffer(first, middle, buffer, (Distance*)0);\n+    __merge_sort_with_buffer(middle, last, buffer, (Distance*)0);\n+  }\n+  __merge_adaptive(first, middle, last, Distance(middle - first), \n+                   Distance(last - middle), buffer, buffer_size);\n+}\n+\n+template <class RandomAccessIterator, class Pointer, class Distance, \n+          class Compare>\n+void __stable_sort_adaptive(RandomAccessIterator first, \n+                            RandomAccessIterator last, Pointer buffer,\n+                            Distance buffer_size, Compare comp) {\n+  Distance len = (last - first + 1) / 2;\n+  RandomAccessIterator middle = first + len;\n+  if (len > buffer_size) {\n+    __stable_sort_adaptive(first, middle, buffer, buffer_size, \n+                           comp);\n+    __stable_sort_adaptive(middle, last, buffer, buffer_size, \n+                           comp);\n+  } else {\n+    __merge_sort_with_buffer(first, middle, buffer, (Distance*)0, comp);\n+    __merge_sort_with_buffer(middle, last, buffer, (Distance*)0, comp);\n+  }\n+  __merge_adaptive(first, middle, last, Distance(middle - first), \n+                   Distance(last - middle), buffer, buffer_size,\n+                   comp);\n+}\n+\n+template <class RandomAccessIterator, class T, class Distance>\n+inline void __stable_sort_aux(RandomAccessIterator first,\n+                              RandomAccessIterator last, T*, Distance*) {\n+  temporary_buffer<RandomAccessIterator, T> buf(first, last);\n+  if (buf.begin() == 0)\n+    __inplace_stable_sort(first, last);\n+  else \n+    __stable_sort_adaptive(first, last, buf.begin(), Distance(buf.size()));\n+}\n+\n+template <class RandomAccessIterator, class T, class Distance, class Compare>\n+inline void __stable_sort_aux(RandomAccessIterator first,\n+                              RandomAccessIterator last, T*, Distance*,\n+                              Compare comp) {\n+  temporary_buffer<RandomAccessIterator, T> buf(first, last);\n+  if (buf.begin() == 0)\n+    __inplace_stable_sort(first, last, comp);\n+  else \n+    __stable_sort_adaptive(first, last, buf.begin(), Distance(buf.size()),\n+                           comp);\n+}\n+\n+template <class RandomAccessIterator>\n+inline void stable_sort(RandomAccessIterator first,\n+                        RandomAccessIterator last) {\n+  __stable_sort_aux(first, last, value_type(first), distance_type(first));\n+}\n+\n+template <class RandomAccessIterator, class Compare>\n+inline void stable_sort(RandomAccessIterator first,\n+                        RandomAccessIterator last, Compare comp) {\n+  __stable_sort_aux(first, last, value_type(first), distance_type(first), \n+                    comp);\n+}\n+\n+template <class RandomAccessIterator, class T>\n+void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,\n+                    RandomAccessIterator last, T*) {\n+  make_heap(first, middle);\n+  for (RandomAccessIterator i = middle; i < last; ++i)\n+    if (*i < *first) \n+      __pop_heap(first, middle, i, T(*i), distance_type(first));\n+  sort_heap(first, middle);\n+}\n+\n+template <class RandomAccessIterator>\n+inline void partial_sort(RandomAccessIterator first,\n+                         RandomAccessIterator middle,\n+                         RandomAccessIterator last) {\n+  __partial_sort(first, middle, last, value_type(first));\n+}\n+\n+template <class RandomAccessIterator, class T, class Compare>\n+void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,\n+                    RandomAccessIterator last, T*, Compare comp) {\n+  make_heap(first, middle, comp);\n+  for (RandomAccessIterator i = middle; i < last; ++i)\n+    if (comp(*i, *first))\n+      __pop_heap(first, middle, i, T(*i), comp, distance_type(first));\n+  sort_heap(first, middle, comp);\n+}\n+\n+template <class RandomAccessIterator, class Compare>\n+inline void partial_sort(RandomAccessIterator first,\n+                         RandomAccessIterator middle,\n+                         RandomAccessIterator last, Compare comp) {\n+  __partial_sort(first, middle, last, value_type(first), comp);\n+}\n+\n+template <class InputIterator, class RandomAccessIterator, class Distance,\n+          class T>\n+RandomAccessIterator __partial_sort_copy(InputIterator first,\n+                                         InputIterator last,\n+                                         RandomAccessIterator result_first,\n+                                         RandomAccessIterator result_last, \n+                                         Distance*, T*) {\n+  if (result_first == result_last) return result_last;\n+  RandomAccessIterator result_real_last = result_first;\n+  while(first != last && result_real_last != result_last) {\n+    *result_real_last = *first;\n+    ++result_real_last;\n+    ++first;\n+  }\n+  make_heap(result_first, result_real_last);\n+  while (first != last) {\n+    if (*first < *result_first) \n+      __adjust_heap(result_first, Distance(0),\n+                    Distance(result_real_last - result_first), T(*first));\n+    ++first;\n+  }\n+  sort_heap(result_first, result_real_last);\n+  return result_real_last;\n+}\n+\n+template <class InputIterator, class RandomAccessIterator>\n+inline RandomAccessIterator\n+partial_sort_copy(InputIterator first, InputIterator last,\n+                  RandomAccessIterator result_first,\n+                  RandomAccessIterator result_last) {\n+  return __partial_sort_copy(first, last, result_first, result_last, \n+                             distance_type(result_first), value_type(first));\n+}\n+\n+template <class InputIterator, class RandomAccessIterator, class Compare,\n+          class Distance, class T>\n+RandomAccessIterator __partial_sort_copy(InputIterator first,\n+                                         InputIterator last,\n+                                         RandomAccessIterator result_first,\n+                                         RandomAccessIterator result_last,\n+                                         Compare comp, Distance*, T*) {\n+  if (result_first == result_last) return result_last;\n+  RandomAccessIterator result_real_last = result_first;\n+  while(first != last && result_real_last != result_last) {\n+    *result_real_last = *first;\n+    ++result_real_last;\n+    ++first;\n+  }\n+  make_heap(result_first, result_real_last, comp);\n+  while (first != last) {\n+    if (comp(*first, *result_first))\n+      __adjust_heap(result_first, Distance(0),\n+                    Distance(result_real_last - result_first), T(*first),\n+                    comp);\n+    ++first;\n+  }\n+  sort_heap(result_first, result_real_last, comp);\n+  return result_real_last;\n+}\n+\n+template <class InputIterator, class RandomAccessIterator, class Compare>\n+inline RandomAccessIterator\n+partial_sort_copy(InputIterator first, InputIterator last,\n+                  RandomAccessIterator result_first,\n+                  RandomAccessIterator result_last, Compare comp) {\n+  return __partial_sort_copy(first, last, result_first, result_last, comp,\n+                             distance_type(result_first), value_type(first));\n+}\n+\n+template <class RandomAccessIterator, class T>\n+void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,\n+                   RandomAccessIterator last, T*) {\n+  while (last - first > 3) {\n+    RandomAccessIterator cut = __unguarded_partition\n+      (first, last, T(__median(*first, *(first + (last - first)/2),\n+                               *(last - 1))));\n+    if (cut <= nth)\n+      first = cut;\n+    else \n+      last = cut;\n+  }\n+  __insertion_sort(first, last);\n+}\n+\n+template <class RandomAccessIterator>\n+inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,\n+                        RandomAccessIterator last) {\n+  __nth_element(first, nth, last, value_type(first));\n+}\n+\n+template <class RandomAccessIterator, class T, class Compare>\n+void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,\n+                   RandomAccessIterator last, T*, Compare comp) {\n+  while (last - first > 3) {\n+    RandomAccessIterator cut = __unguarded_partition\n+      (first, last, T(__median(*first, *(first + (last - first)/2), \n+                               *(last - 1), comp)), comp);\n+    if (cut <= nth)\n+      first = cut;\n+    else \n+      last = cut;\n+  }\n+  __insertion_sort(first, last, comp);\n+}\n+\n+template <class RandomAccessIterator, class Compare>\n+inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,\n+                 RandomAccessIterator last, Compare comp) {\n+  __nth_element(first, nth, last, value_type(first), comp);\n+}\n+\n+template <class ForwardIterator, class T, class Distance>\n+ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,\n+                              const T& value, Distance*,\n+                              forward_iterator_tag) {\n+  Distance len = 0;\n+  distance(first, last, len);\n+  Distance half;\n+  ForwardIterator middle;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first;\n+    advance(middle, half);\n+    if (*middle < value) {\n+      first = middle;\n+      ++first;\n+      len = len - half - 1;\n+    }\n+    else\n+      len = half;\n+  }\n+  return first;\n+}\n+\n+template <class RandomAccessIterator, class T, class Distance>\n+RandomAccessIterator __lower_bound(RandomAccessIterator first,\n+                                   RandomAccessIterator last, const T& value,\n+                                   Distance*, random_access_iterator_tag) {\n+  Distance len = last - first;\n+  Distance half;\n+  RandomAccessIterator middle;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first + half;\n+    if (*middle < value) {\n+      first = middle + 1;\n+      len = len - half - 1;\n+    }\n+    else\n+      len = half;\n+  }\n+  return first;\n+}\n+\n+template <class ForwardIterator, class T>\n+inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,\n+                                   const T& value) {\n+  return __lower_bound(first, last, value, distance_type(first),\n+                       iterator_category(first));\n+}\n+\n+template <class ForwardIterator, class T, class Compare, class Distance>\n+ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,\n+                              const T& value, Compare comp, Distance*,\n+                              forward_iterator_tag) {\n+  Distance len = 0;\n+  distance(first, last, len);\n+  Distance half;\n+  ForwardIterator middle;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first;\n+    advance(middle, half);\n+    if (comp(*middle, value)) {\n+      first = middle;\n+      ++first;\n+      len = len - half - 1;\n+    }\n+    else\n+      len = half;\n+  }\n+  return first;\n+}\n+\n+template <class RandomAccessIterator, class T, class Compare, class Distance>\n+RandomAccessIterator __lower_bound(RandomAccessIterator first,\n+                                   RandomAccessIterator last,\n+                                   const T& value, Compare comp, Distance*,\n+                                   random_access_iterator_tag) {\n+  Distance len = last - first;\n+  Distance half;\n+  RandomAccessIterator middle;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first + half;\n+    if (comp(*middle, value)) {\n+      first = middle + 1;\n+      len = len - half - 1;\n+    }\n+    else\n+      len = half;\n+  }\n+  return first;\n+}\n+\n+template <class ForwardIterator, class T, class Compare>\n+inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,\n+                                   const T& value, Compare comp) {\n+  return __lower_bound(first, last, value, comp, distance_type(first),\n+                       iterator_category(first));\n+}\n+\n+template <class ForwardIterator, class T, class Distance>\n+ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,\n+                              const T& value, Distance*,\n+                              forward_iterator_tag) {\n+  Distance len = 0;\n+  distance(first, last, len);\n+  Distance half;\n+  ForwardIterator middle;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first;\n+    advance(middle, half);\n+    if (value < *middle)\n+      len = half;\n+    else {\n+      first = middle;\n+      ++first;\n+      len = len - half - 1;\n+    }\n+  }\n+  return first;\n+}\n+\n+template <class RandomAccessIterator, class T, class Distance>\n+RandomAccessIterator __upper_bound(RandomAccessIterator first,\n+                                   RandomAccessIterator last, const T& value,\n+                                   Distance*, random_access_iterator_tag) {\n+  Distance len = last - first;\n+  Distance half;\n+  RandomAccessIterator middle;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first + half;\n+    if (value < *middle)\n+      len = half;\n+    else {\n+      first = middle + 1;\n+      len = len - half - 1;\n+    }\n+  }\n+  return first;\n+}\n+\n+template <class ForwardIterator, class T>\n+inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,\n+                                   const T& value) {\n+  return __upper_bound(first, last, value, distance_type(first),\n+                       iterator_category(first));\n+}\n+\n+template <class ForwardIterator, class T, class Compare, class Distance>\n+ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,\n+                              const T& value, Compare comp, Distance*,\n+                              forward_iterator_tag) {\n+  Distance len = 0;\n+  distance(first, last, len);\n+  Distance half;\n+  ForwardIterator middle;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first;\n+    advance(middle, half);\n+    if (comp(value, *middle))\n+      len = half;\n+    else {\n+      first = middle;\n+      ++first;\n+      len = len - half - 1;\n+    }\n+  }\n+  return first;\n+}\n+\n+template <class RandomAccessIterator, class T, class Compare, class Distance>\n+RandomAccessIterator __upper_bound(RandomAccessIterator first,\n+                                   RandomAccessIterator last,\n+                                   const T& value, Compare comp, Distance*,\n+                                   random_access_iterator_tag) {\n+  Distance len = last - first;\n+  Distance half;\n+  RandomAccessIterator middle;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first + half;\n+    if (comp(value, *middle))\n+      len = half;\n+    else {\n+      first = middle + 1;\n+      len = len - half - 1;\n+    }\n+  }\n+  return first;\n+}\n+\n+template <class ForwardIterator, class T, class Compare>\n+inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,\n+                                   const T& value, Compare comp) {\n+  return __upper_bound(first, last, value, comp, distance_type(first),\n+                       iterator_category(first));\n+}\n+\n+template <class ForwardIterator, class T, class Distance>\n+pair<ForwardIterator, ForwardIterator>\n+__equal_range(ForwardIterator first, ForwardIterator last, const T& value,\n+              Distance*, forward_iterator_tag) {\n+  Distance len = 0;\n+  distance(first, last, len);\n+  Distance half;\n+  ForwardIterator middle, left, right;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first;\n+    advance(middle, half);\n+    if (*middle < value) {\n+      first = middle;\n+      ++first;\n+      len = len - half - 1;\n+    }\n+    else if (value < *middle)\n+      len = half;\n+    else {\n+      left = lower_bound(first, middle, value);\n+      advance(first, len);\n+      right = upper_bound(++middle, first, value);\n+      return pair<ForwardIterator, ForwardIterator>(left, right);\n+    }\n+  }\n+  return pair<ForwardIterator, ForwardIterator>(first, first);\n+}\n+\n+template <class RandomAccessIterator, class T, class Distance>\n+pair<RandomAccessIterator, RandomAccessIterator>\n+__equal_range(RandomAccessIterator first, RandomAccessIterator last,\n+              const T& value, Distance*, random_access_iterator_tag) {\n+  Distance len = last - first;\n+  Distance half;\n+  RandomAccessIterator middle, left, right;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first + half;\n+    if (*middle < value) {\n+      first = middle + 1;\n+      len = len - half - 1;\n+    }\n+    else if (value < *middle)\n+      len = half;\n+    else {\n+      left = lower_bound(first, middle, value);\n+      right = upper_bound(++middle, first + len, value);\n+      return pair<RandomAccessIterator, RandomAccessIterator>(left,\n+                                                              right);\n+    }\n+  }\n+  return pair<RandomAccessIterator, RandomAccessIterator>(first, first);\n+}\n+\n+template <class ForwardIterator, class T>\n+inline pair<ForwardIterator, ForwardIterator>\n+equal_range(ForwardIterator first, ForwardIterator last, const T& value) {\n+  return __equal_range(first, last, value, distance_type(first),\n+                       iterator_category(first));\n+}\n+\n+template <class ForwardIterator, class T, class Compare, class Distance>\n+pair<ForwardIterator, ForwardIterator>\n+__equal_range(ForwardIterator first, ForwardIterator last, const T& value,\n+              Compare comp, Distance*, forward_iterator_tag) {\n+  Distance len = 0;\n+  distance(first, last, len);\n+  Distance half;\n+  ForwardIterator middle, left, right;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first;\n+    advance(middle, half);\n+    if (comp(*middle, value)) {\n+      first = middle;\n+      ++first;\n+      len = len - half - 1;\n+    }\n+    else if (comp(value, *middle))\n+      len = half;\n+    else {\n+      left = lower_bound(first, middle, value, comp);\n+      advance(first, len);\n+      right = upper_bound(++middle, first, value, comp);\n+      return pair<ForwardIterator, ForwardIterator>(left, right);\n+    }\n+  }\n+  return pair<ForwardIterator, ForwardIterator>(first, first);\n+}           \n+\n+template <class RandomAccessIterator, class T, class Compare, class Distance>\n+pair<RandomAccessIterator, RandomAccessIterator>\n+__equal_range(RandomAccessIterator first, RandomAccessIterator last,\n+              const T& value, Compare comp, Distance*,\n+              random_access_iterator_tag) {\n+  Distance len = last - first;\n+  Distance half;\n+  RandomAccessIterator middle, left, right;\n+\n+  while (len > 0) {\n+    half = len >> 1;\n+    middle = first + half;\n+    if (comp(*middle, value)) {\n+      first = middle + 1;\n+      len = len - half - 1;\n+    }\n+    else if (comp(value, *middle))\n+      len = half;\n+    else {\n+      left = lower_bound(first, middle, value, comp);\n+      right = upper_bound(++middle, first + len, value, comp);\n+      return pair<RandomAccessIterator, RandomAccessIterator>(left,\n+                                                              right);\n+    }\n+  }\n+  return pair<RandomAccessIterator, RandomAccessIterator>(first, first);\n+}           \n+\n+template <class ForwardIterator, class T, class Compare>\n+inline pair<ForwardIterator, ForwardIterator>\n+equal_range(ForwardIterator first, ForwardIterator last, const T& value,\n+            Compare comp) {\n+  return __equal_range(first, last, value, comp, distance_type(first),\n+                       iterator_category(first));\n+}    \n+\n+template <class ForwardIterator, class T>\n+bool binary_search(ForwardIterator first, ForwardIterator last,\n+                   const T& value) {\n+  ForwardIterator i = lower_bound(first, last, value);\n+  return i != last && !(value < *i);\n+}\n+\n+template <class ForwardIterator, class T, class Compare>\n+bool binary_search(ForwardIterator first, ForwardIterator last, const T& value,\n+                   Compare comp) {\n+  ForwardIterator i = lower_bound(first, last, value, comp);\n+  return i != last && !comp(value, *i);\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator>\n+OutputIterator merge(InputIterator1 first1, InputIterator1 last1,\n+                     InputIterator2 first2, InputIterator2 last2,\n+                     OutputIterator result) {\n+  while (first1 != last1 && first2 != last2) {\n+    if (*first2 < *first1) {\n+      *result = *first2;\n+      ++first2;\n+    }\n+    else {\n+      *result = *first1;\n+      ++first1;\n+    }\n+    ++result;\n+  }\n+  return copy(first2, last2, copy(first1, last1, result));\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator,\n+          class Compare>\n+OutputIterator merge(InputIterator1 first1, InputIterator1 last1,\n+                     InputIterator2 first2, InputIterator2 last2,\n+                     OutputIterator result, Compare comp) {\n+  while (first1 != last1 && first2 != last2) {\n+    if (comp(*first2, *first1)) {\n+      *result = *first2;\n+      ++first2;\n+    }\n+    else {\n+      *result = *first1;\n+      ++first1;\n+    }\n+    ++result;\n+  }\n+  return copy(first2, last2, copy(first1, last1, result));\n+}\n+\n+template <class BidirectionalIterator, class Distance>\n+void __merge_without_buffer(BidirectionalIterator first,\n+                            BidirectionalIterator middle,\n+                            BidirectionalIterator last,\n+                            Distance len1, Distance len2) {\n+  if (len1 == 0 || len2 == 0) return;\n+  if (len1 + len2 == 2) {\n+    if (*middle < *first) iter_swap(first, middle);\n+    return;\n+  }\n+  BidirectionalIterator first_cut = first;\n+  BidirectionalIterator second_cut = middle;\n+  Distance len11 = 0;\n+  Distance len22 = 0;\n+  if (len1 > len2) {\n+    len11 = len1 / 2;\n+    advance(first_cut, len11);\n+    second_cut = lower_bound(middle, last, *first_cut);\n+    distance(middle, second_cut, len22);\n+  }\n+  else {\n+    len22 = len2 / 2;\n+    advance(second_cut, len22);\n+    first_cut = upper_bound(first, middle, *second_cut);\n+    distance(first, first_cut, len11);\n+  }\n+  rotate(first_cut, middle, second_cut);\n+  BidirectionalIterator new_middle = first_cut;\n+  advance(new_middle, len22);\n+  __merge_without_buffer(first, first_cut, new_middle, len11, len22);\n+  __merge_without_buffer(new_middle, second_cut, last, len1 - len11,\n+                         len2 - len22);\n+}\n+\n+template <class BidirectionalIterator, class Distance, class Compare>\n+void __merge_without_buffer(BidirectionalIterator first,\n+                            BidirectionalIterator middle,\n+                            BidirectionalIterator last,\n+                            Distance len1, Distance len2, Compare comp) {\n+  if (len1 == 0 || len2 == 0) return;\n+  if (len1 + len2 == 2) {\n+    if (comp(*middle, *first)) iter_swap(first, middle);\n+    return;\n+  }\n+  BidirectionalIterator first_cut = first;\n+  BidirectionalIterator second_cut = middle;\n+  Distance len11 = 0;\n+  Distance len22 = 0;\n+  if (len1 > len2) {\n+    len11 = len1 / 2;\n+    advance(first_cut, len11);\n+    second_cut = lower_bound(middle, last, *first_cut, comp);\n+    distance(middle, second_cut, len22);\n+  }\n+  else {\n+    len22 = len2 / 2;\n+    advance(second_cut, len22);\n+    first_cut = upper_bound(first, middle, *second_cut, comp);\n+    distance(first, first_cut, len11);\n+  }\n+  rotate(first_cut, middle, second_cut);\n+  BidirectionalIterator new_middle = first_cut;\n+  advance(new_middle, len22);\n+  __merge_without_buffer(first, first_cut, new_middle, len11, len22, comp);\n+  __merge_without_buffer(new_middle, second_cut, last, len1 - len11,\n+                         len2 - len22, comp);\n+}\n+\n+template <class BidirectionalIterator1, class BidirectionalIterator2,\n+          class Distance>\n+BidirectionalIterator1 __rotate_adaptive(BidirectionalIterator1 first,\n+                                         BidirectionalIterator1 middle,\n+                                         BidirectionalIterator1 last,\n+                                         Distance len1, Distance len2,\n+                                         BidirectionalIterator2 buffer,\n+                                         Distance buffer_size) {\n+  BidirectionalIterator2 buffer_end;\n+  if (len1 > len2 && len2 <= buffer_size) {\n+    buffer_end = copy(middle, last, buffer);\n+    copy_backward(first, middle, last);\n+    return copy(buffer, buffer_end, first);\n+  } else if (len1 <= buffer_size) {\n+    buffer_end = copy(first, middle, buffer);\n+    copy(middle, last, first);\n+    return copy_backward(buffer, buffer_end, last);\n+  } else  {\n+    rotate(first, middle, last);\n+    advance(first, len2);\n+    return first;\n+  }\n+}\n+\n+template <class BidirectionalIterator1, class BidirectionalIterator2,\n+          class BidirectionalIterator3>\n+BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,\n+                                        BidirectionalIterator1 last1,\n+                                        BidirectionalIterator2 first2,\n+                                        BidirectionalIterator2 last2,\n+                                        BidirectionalIterator3 result) {\n+  if (first1 == last1) return copy_backward(first2, last2, result);\n+  if (first2 == last2) return copy_backward(first1, last1, result);\n+  --last1;\n+  --last2;\n+  while (true) {\n+    if (*last2 < *last1) {\n+      *--result = *last1;\n+      if (first1 == last1) return copy_backward(first2, ++last2, result);\n+      --last1;\n+    }\n+    else {\n+      *--result = *last2;\n+      if (first2 == last2) return copy_backward(first1, ++last1, result);\n+      --last2;\n+    }\n+  }\n+}\n+\n+template <class BidirectionalIterator1, class BidirectionalIterator2,\n+          class BidirectionalIterator3, class Compare>\n+BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,\n+                                        BidirectionalIterator1 last1,\n+                                        BidirectionalIterator2 first2,\n+                                        BidirectionalIterator2 last2,\n+                                        BidirectionalIterator3 result,\n+                                        Compare comp) {\n+  if (first1 == last1) return copy_backward(first2, last2, result);\n+  if (first2 == last2) return copy_backward(first1, last1, result);\n+  --last1;\n+  --last2;\n+  while (true) {\n+    if (comp(*last2, *last1)) {\n+      *--result = *last1;\n+      if (first1 == last1) return copy_backward(first2, ++last2, result);\n+      --last1;\n+    }\n+    else {\n+      *--result = *last2;\n+      if (first2 == last2) return copy_backward(first1, ++last1, result);\n+      --last2;\n+    }\n+  }\n+}\n+\n+template <class BidirectionalIterator, class Distance, class Pointer>\n+void __merge_adaptive(BidirectionalIterator first, \n+                      BidirectionalIterator middle, \n+                      BidirectionalIterator last, Distance len1, Distance len2,\n+                      Pointer buffer, Distance buffer_size) {\n+  if (len1 <= len2 && len1 <= buffer_size) {\n+    Pointer end_buffer = copy(first, middle, buffer);\n+    merge(buffer, end_buffer, middle, last, first);\n+  }\n+  else if (len2 <= buffer_size) {\n+    Pointer end_buffer = copy(middle, last, buffer);\n+    __merge_backward(first, middle, buffer, end_buffer, last);\n+  }\n+  else {\n+    BidirectionalIterator first_cut = first;\n+    BidirectionalIterator second_cut = middle;\n+    Distance len11 = 0;\n+    Distance len22 = 0;\n+    if (len1 > len2) {\n+      len11 = len1 / 2;\n+      advance(first_cut, len11);\n+      second_cut = lower_bound(middle, last, *first_cut);\n+      distance(middle, second_cut, len22);   \n+    }\n+    else {\n+      len22 = len2 / 2;\n+      advance(second_cut, len22);\n+      first_cut = upper_bound(first, middle, *second_cut);\n+      distance(first, first_cut, len11);\n+    }\n+    BidirectionalIterator new_middle =\n+      __rotate_adaptive(first_cut, middle, second_cut, len1 - len11,\n+                        len22, buffer, buffer_size);\n+    __merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,\n+                     buffer_size);\n+    __merge_adaptive(new_middle, second_cut, last, len1 - len11,\n+                     len2 - len22, buffer, buffer_size);\n+  }\n+}\n+\n+template <class BidirectionalIterator, class Distance, class Pointer,\n+          class Compare>\n+void __merge_adaptive(BidirectionalIterator first, \n+                      BidirectionalIterator middle, \n+                      BidirectionalIterator last, Distance len1, Distance len2,\n+                      Pointer buffer, Distance buffer_size, Compare comp) {\n+  if (len1 <= len2 && len1 <= buffer_size) {\n+    Pointer end_buffer = copy(first, middle, buffer);\n+    merge(buffer, end_buffer, middle, last, first, comp);\n+  }\n+  else if (len2 <= buffer_size) {\n+    Pointer end_buffer = copy(middle, last, buffer);\n+    __merge_backward(first, middle, buffer, end_buffer, last, comp);\n+  }\n+  else {\n+    BidirectionalIterator first_cut = first;\n+    BidirectionalIterator second_cut = middle;\n+    Distance len11 = 0;\n+    Distance len22 = 0;\n+    if (len1 > len2) {\n+      len11 = len1 / 2;\n+      advance(first_cut, len11);\n+      second_cut = lower_bound(middle, last, *first_cut, comp);\n+      distance(middle, second_cut, len22);   \n+    }\n+    else {\n+      len22 = len2 / 2;\n+      advance(second_cut, len22);\n+      first_cut = upper_bound(first, middle, *second_cut, comp);\n+      distance(first, first_cut, len11);\n+    }\n+    BidirectionalIterator new_middle =\n+      __rotate_adaptive(first_cut, middle, second_cut, len1 - len11,\n+                        len22, buffer, buffer_size);\n+    __merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,\n+                     buffer_size, comp);\n+    __merge_adaptive(new_middle, second_cut, last, len1 - len11,\n+                     len2 - len22, buffer, buffer_size, comp);\n+  }\n+}\n+\n+template <class BidirectionalIterator, class T, class Distance>\n+inline void __inplace_merge_aux(BidirectionalIterator first,\n+                                BidirectionalIterator middle,\n+                                BidirectionalIterator last, T*, Distance*) {\n+  Distance len1 = 0;\n+  distance(first, middle, len1);\n+  Distance len2 = 0;\n+  distance(middle, last, len2);\n+\n+  temporary_buffer<BidirectionalIterator, T> buf(first, last);\n+  if (buf.begin() == 0)\n+    __merge_without_buffer(first, middle, last, len1, len2);\n+  else\n+    __merge_adaptive(first, middle, last, len1, len2,\n+                     buf.begin(), Distance(buf.size()));\n+}\n+\n+template <class BidirectionalIterator, class T, class Distance, class Compare>\n+inline void __inplace_merge_aux(BidirectionalIterator first,\n+                                BidirectionalIterator middle,\n+                                BidirectionalIterator last, T*, Distance*,\n+                                Compare comp) {\n+  Distance len1 = 0;\n+  distance(first, middle, len1);\n+  Distance len2 = 0;\n+  distance(middle, last, len2);\n+\n+  temporary_buffer<BidirectionalIterator, T> buf(first, last);\n+  if (buf.begin() == 0)\n+    __merge_without_buffer(first, middle, last, len1, len2, comp);\n+  else\n+    __merge_adaptive(first, middle, last, len1, len2,\n+                     buf.begin(), Distance(buf.size()),\n+                     comp);\n+}\n+\n+template <class BidirectionalIterator>\n+inline void inplace_merge(BidirectionalIterator first,\n+                          BidirectionalIterator middle,\n+                          BidirectionalIterator last) {\n+  if (first == middle || middle == last) return;\n+  __inplace_merge_aux(first, middle, last, value_type(first),\n+                      distance_type(first));\n+}\n+\n+template <class BidirectionalIterator, class Compare>\n+inline void inplace_merge(BidirectionalIterator first,\n+                          BidirectionalIterator middle,\n+                          BidirectionalIterator last, Compare comp) {\n+  if (first == middle || middle == last) return;\n+  __inplace_merge_aux(first, middle, last, value_type(first),\n+                      distance_type(first), comp);\n+}\n+\n+template <class InputIterator1, class InputIterator2>\n+bool includes(InputIterator1 first1, InputIterator1 last1,\n+              InputIterator2 first2, InputIterator2 last2) {\n+  while (first1 != last1 && first2 != last2)\n+    if (*first2 < *first1)\n+      return false;\n+    else if(*first1 < *first2) \n+      ++first1;\n+    else\n+      ++first1, ++first2;\n+\n+  return first2 == last2;\n+}\n+\n+template <class InputIterator1, class InputIterator2, class Compare>\n+bool includes(InputIterator1 first1, InputIterator1 last1,\n+              InputIterator2 first2, InputIterator2 last2, Compare comp) {\n+  while (first1 != last1 && first2 != last2)\n+    if (comp(*first2, *first1))\n+      return false;\n+    else if(comp(*first1, *first2)) \n+      ++first1;\n+    else\n+      ++first1, ++first2;\n+\n+  return first2 == last2;\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator>\n+OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,\n+                         InputIterator2 first2, InputIterator2 last2,\n+                         OutputIterator result) {\n+  while (first1 != last1 && first2 != last2) {\n+    if (*first1 < *first2) {\n+      *result = *first1;\n+      ++first1;\n+    }\n+    else if (*first2 < *first1) {\n+      *result = *first2;\n+      ++first2;\n+    }\n+    else {\n+      *result = *first1;\n+      ++first1;\n+      ++first2;\n+    }\n+    ++result;\n+  }\n+  return copy(first2, last2, copy(first1, last1, result));\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator,\n+          class Compare>\n+OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,\n+                         InputIterator2 first2, InputIterator2 last2,\n+                         OutputIterator result, Compare comp) {\n+  while (first1 != last1 && first2 != last2) {\n+    if (comp(*first1, *first2)) {\n+      *result = *first1;\n+      ++first1;\n+    }\n+    else if (comp(*first2, *first1)) {\n+      *result = *first2;\n+      ++first2;\n+    }\n+    else {\n+      *result = *first1;\n+      ++first1;\n+      ++first2;\n+    }\n+    ++result;\n+  }\n+  return copy(first2, last2, copy(first1, last1, result));\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator>\n+OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,\n+                                InputIterator2 first2, InputIterator2 last2,\n+                                OutputIterator result) {\n+  while (first1 != last1 && first2 != last2) \n+    if (*first1 < *first2) \n+      ++first1;\n+    else if (*first2 < *first1) \n+      ++first2;\n+    else {\n+      *result = *first1;\n+      ++first1;\n+      ++first2;\n+      ++result;\n+    }\n+  return result;\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator,\n+          class Compare>\n+OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,\n+                                InputIterator2 first2, InputIterator2 last2,\n+                                OutputIterator result, Compare comp) {\n+  while (first1 != last1 && first2 != last2)\n+    if (comp(*first1, *first2))\n+      ++first1;\n+    else if (comp(*first2, *first1))\n+      ++first2;\n+    else {\n+      *result = *first1;\n+      ++first1;\n+      ++first2;\n+      ++result;\n+    }\n+  return result;\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator>\n+OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,\n+                              InputIterator2 first2, InputIterator2 last2,\n+                              OutputIterator result) {\n+  while (first1 != last1 && first2 != last2)\n+    if (*first1 < *first2) {\n+      *result = *first1;\n+      ++first1;\n+      ++result;\n+    }\n+    else if (*first2 < *first1)\n+      ++first2;\n+    else {\n+      ++first1;\n+      ++first2;\n+    }\n+  return copy(first1, last1, result);\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator, \n+          class Compare>\n+OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,\n+                              InputIterator2 first2, InputIterator2 last2, \n+                              OutputIterator result, Compare comp) {\n+  while (first1 != last1 && first2 != last2)\n+    if (comp(*first1, *first2)) {\n+      *result = *first1;\n+      ++first1;\n+      ++result;\n+    }\n+    else if (comp(*first2, *first1))\n+      ++first2;\n+    else {\n+      ++first1;\n+      ++first2;\n+    }\n+  return copy(first1, last1, result);\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator>\n+OutputIterator set_symmetric_difference(InputIterator1 first1,\n+                                        InputIterator1 last1,\n+                                        InputIterator2 first2,\n+                                        InputIterator2 last2,\n+                                        OutputIterator result) {\n+  while (first1 != last1 && first2 != last2)\n+    if (*first1 < *first2) {\n+      *result = *first1;\n+      ++first1;\n+      ++result;\n+    }\n+    else if (*first2 < *first1) {\n+      *result = *first2;\n+      ++first2;\n+      ++result;\n+    }\n+    else {\n+      ++first1;\n+      ++first2;\n+    }\n+  return copy(first2, last2, copy(first1, last1, result));\n+}\n+\n+template <class InputIterator1, class InputIterator2, class OutputIterator,\n+          class Compare>\n+OutputIterator set_symmetric_difference(InputIterator1 first1,\n+                                        InputIterator1 last1,\n+                                        InputIterator2 first2,\n+                                        InputIterator2 last2,\n+                                        OutputIterator result, Compare comp) {\n+  while (first1 != last1 && first2 != last2)\n+    if (comp(*first1, *first2)) {\n+      *result = *first1;\n+      ++first1;\n+      ++result;\n+    }\n+    else if (comp(*first2, *first1)) {\n+      *result = *first2;\n+      ++first2;\n+      ++result;\n+    }\n+    else {\n+      ++first1;\n+      ++first2;\n+    }\n+  return copy(first2, last2, copy(first1, last1, result));\n+}\n+\n+template <class ForwardIterator>\n+ForwardIterator max_element(ForwardIterator first, ForwardIterator last) {\n+  if (first == last) return first;\n+  ForwardIterator result = first;\n+  while (++first != last) \n+    if (*result < *first) result = first;\n+  return result;\n+}\n+\n+template <class ForwardIterator, class Compare>\n+ForwardIterator max_element(ForwardIterator first, ForwardIterator last,\n+                            Compare comp) {\n+  if (first == last) return first;\n+  ForwardIterator result = first;\n+  while (++first != last) \n+    if (comp(*result, *first)) result = first;\n+  return result;\n+}\n+\n+template <class ForwardIterator>\n+ForwardIterator min_element(ForwardIterator first, ForwardIterator last) {\n+  if (first == last) return first;\n+  ForwardIterator result = first;\n+  while (++first != last) \n+    if (*first < *result) result = first;\n+  return result;\n+}\n+\n+template <class ForwardIterator, class Compare>\n+ForwardIterator min_element(ForwardIterator first, ForwardIterator last,\n+                            Compare comp) {\n+  if (first == last) return first;\n+  ForwardIterator result = first;\n+  while (++first != last) \n+    if (comp(*first, *result)) result = first;\n+  return result;\n+}\n+\n+template <class BidirectionalIterator>\n+bool next_permutation(BidirectionalIterator first,\n+                      BidirectionalIterator last) {\n+  if (first == last) return false;\n+  BidirectionalIterator i = first;\n+  ++i;\n+  if (i == last) return false;\n+  i = last;\n+  --i;\n+\n+  for(;;) {\n+    BidirectionalIterator ii = i;\n+    --i;\n+    if (*i < *ii) {\n+      BidirectionalIterator j = last;\n+      while (!(*i < *--j));\n+      iter_swap(i, j);\n+      reverse(ii, last);\n+      return true;\n+    }\n+    if (i == first) {\n+      reverse(first, last);\n+      return false;\n+    }\n+  }\n+}\n+\n+template <class BidirectionalIterator, class Compare>\n+bool next_permutation(BidirectionalIterator first, BidirectionalIterator last,\n+                      Compare comp) {\n+  if (first == last) return false;\n+  BidirectionalIterator i = first;\n+  ++i;\n+  if (i == last) return false;\n+  i = last;\n+  --i;\n+\n+  for(;;) {\n+    BidirectionalIterator ii = i;\n+    --i;\n+    if (comp(*i, *ii)) {\n+      BidirectionalIterator j = last;\n+      while (!comp(*i, *--j));\n+      iter_swap(i, j);\n+      reverse(ii, last);\n+      return true;\n+    }\n+    if (i == first) {\n+      reverse(first, last);\n+      return false;\n+    }\n+  }\n+}\n+\n+template <class BidirectionalIterator>\n+bool prev_permutation(BidirectionalIterator first,\n+                      BidirectionalIterator last) {\n+  if (first == last) return false;\n+  BidirectionalIterator i = first;\n+  ++i;\n+  if (i == last) return false;\n+  i = last;\n+  --i;\n+\n+  for(;;) {\n+    BidirectionalIterator ii = i;\n+    --i;\n+    if (*ii < *i) {\n+      BidirectionalIterator j = last;\n+      while (!(*--j < *i));\n+      iter_swap(i, j);\n+      reverse(ii, last);\n+      return true;\n+    }\n+    if (i == first) {\n+      reverse(first, last);\n+      return false;\n+    }\n+  }\n+}\n+\n+template <class BidirectionalIterator, class Compare>\n+bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last,\n+                      Compare comp) {\n+  if (first == last) return false;\n+  BidirectionalIterator i = first;\n+  ++i;\n+  if (i == last) return false;\n+  i = last;\n+  --i;\n+\n+  for(;;) {\n+    BidirectionalIterator ii = i;\n+    --i;\n+    if (comp(*ii, *i)) {\n+      BidirectionalIterator j = last;\n+      while (!comp(*--j, *i));\n+      iter_swap(i, j);\n+      reverse(ii, last);\n+      return true;\n+    }\n+    if (i == first) {\n+      reverse(first, last);\n+      return false;\n+    }\n+  }\n+}\n+\n+template <class InputIterator, class ForwardIterator>\n+InputIterator find_first_of(InputIterator first1, InputIterator last1,\n+                            ForwardIterator first2, ForwardIterator last2)\n+{\n+  for ( ; first1 != last1; ++first1) \n+    for (ForwardIterator iter = first2; iter != last2; ++iter)\n+      if (*first1 == *iter)\n+        return first1;\n+  return last1;\n+}\n+\n+template <class InputIterator, class ForwardIterator, class BinaryPredicate>\n+InputIterator find_first_of(InputIterator first1, InputIterator last1,\n+                            ForwardIterator first2, ForwardIterator last2,\n+                            BinaryPredicate comp)\n+{\n+  for ( ; first1 != last1; ++first1) \n+    for (ForwardIterator iter = first2; iter != last2; ++iter)\n+      if (comp(*first1, *iter))\n+        return first1;\n+  return last1;\n+}\n+\n+\n+// Search [first2, last2) as a subsequence in [first1, last1).\n+\n+// find_end for forward iterators. \n+template <class ForwardIterator1, class ForwardIterator2>\n+ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n+                            ForwardIterator2 first2, ForwardIterator2 last2,\n+                            forward_iterator_tag, forward_iterator_tag)\n+{\n+  if (first2 == last2)\n+    return last1;\n+  else {\n+    ForwardIterator1 result = last1;\n+    while (1) {\n+      ForwardIterator1 new_result = search(first1, last1, first2, last2);\n+      if (new_result == last1)\n+        return result;\n+      else {\n+        result = new_result;\n+        first1 = new_result;\n+        ++first1;\n+      }\n+    }\n+  }\n+}\n+\n+template <class ForwardIterator1, class ForwardIterator2,\n+          class BinaryPredicate>\n+ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n+                            ForwardIterator2 first2, ForwardIterator2 last2,\n+                            forward_iterator_tag, forward_iterator_tag,\n+                            BinaryPredicate comp)\n+{\n+  if (first2 == last2)\n+    return last1;\n+  else {\n+    ForwardIterator1 result = last1;\n+    while (1) {\n+      ForwardIterator1 new_result = search(first1, last1, first2, last2, comp);\n+      if (new_result == last1)\n+        return result;\n+      else {\n+        result = new_result;\n+        first1 = new_result;\n+        ++first1;\n+      }\n+    }\n+  }\n+}\n+\n+// find_end for bidirectional iterators.  Requires partial specialization.\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+\n+template <class BidirectionalIterator1, class BidirectionalIterator2>\n+BidirectionalIterator1\n+__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,\n+           BidirectionalIterator2 first2, BidirectionalIterator2 last2,\n+           bidirectional_iterator_tag, bidirectional_iterator_tag)\n+{\n+  typedef reverse_iterator<BidirectionalIterator1> reviter1;\n+  typedef reverse_iterator<BidirectionalIterator2> reviter2;\n+\n+  reviter1 rlast1(first1);\n+  reviter2 rlast2(first2);\n+  reviter1 rresult = search(reviter1(last1), rlast1, reviter2(last2), rlast2);\n+\n+  if (rresult == rlast1)\n+    return last1;\n+  else {\n+    BidirectionalIterator1 result = rresult.base();\n+    advance(result, -distance(first2, last2));\n+    return result;\n+  }\n+}\n+\n+template <class BidirectionalIterator1, class BidirectionalIterator2,\n+          class BinaryPredicate>\n+BidirectionalIterator1\n+__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,\n+           BidirectionalIterator2 first2, BidirectionalIterator2 last2,\n+           bidirectional_iterator_tag, bidirectional_iterator_tag, \n+           BinaryPredicate comp)\n+{\n+  typedef reverse_iterator<BidirectionalIterator1> reviter1;\n+  typedef reverse_iterator<BidirectionalIterator2> reviter2;\n+\n+  reviter1 rlast1(first1);\n+  reviter2 rlast2(first2);\n+  reviter1 rresult = search(reviter1(last1), rlast1, reviter2(last2), rlast2,\n+                            comp);\n+\n+  if (rresult == rlast1)\n+    return last1;\n+  else {\n+    BidirectionalIterator1 result = rresult.base();\n+    advance(result, -distance(first2, last2));\n+    return result;\n+  }\n+}\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n+// Dispatching functions.\n+\n+template <class ForwardIterator1, class ForwardIterator2>\n+inline ForwardIterator1 \n+find_end(ForwardIterator1 first1, ForwardIterator1 last1, \n+         ForwardIterator2 first2, ForwardIterator2 last2)\n+{\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+  typedef typename iterator_traits<ForwardIterator1>::iterator_category\n+          category1;\n+  typedef typename iterator_traits<ForwardIterator2>::iterator_category\n+          category2;\n+  return __find_end(first1, last1, first2, last2, category1(), category2());\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+  return __find_end(first1, last1, first2, last2,\n+                    forward_iterator_tag(), forward_iterator_tag());\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+}\n+\n+template <class ForwardIterator1, class ForwardIterator2, \n+          class BinaryPredicate>\n+inline ForwardIterator1 \n+find_end(ForwardIterator1 first1, ForwardIterator1 last1, \n+         ForwardIterator2 first2, ForwardIterator2 last2,\n+         BinaryPredicate comp)\n+{\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+  typedef typename iterator_traits<ForwardIterator1>::iterator_category\n+          category1;\n+  typedef typename iterator_traits<ForwardIterator2>::iterator_category\n+          category2;\n+  return __find_end(first1, last1, first2, last2, category1(), category2(),\n+                    comp);\n+#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+  return __find_end(first1, last1, first2, last2,\n+                    forward_iterator_tag(), forward_iterator_tag(),\n+                    comp);\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+}\n+\n+template <class RandomAccessIterator, class Distance>\n+bool __is_heap(RandomAccessIterator first, RandomAccessIterator last,\n+               Distance*)\n+{\n+  const Distance n = last - first;\n+\n+  Distance parent = 0;\n+  for (Distance child = 1; child < n; ++child) {\n+    if (first[parent] < first[child]) \n+      return false;\n+    if (child & 1 == 0)\n+      ++parent;\n+  }\n+  return true;\n+}\n+\n+template <class RandomAccessIterator>\n+inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last)\n+{\n+  return __is_heap(first, last, distance_type(first));\n+}\n+\n+\n+template <class RandomAccessIterator, class Distance, class StrictWeakOrdering>\n+bool __is_heap(RandomAccessIterator first, RandomAccessIterator last,\n+               StrictWeakOrdering comp,\n+               Distance*)\n+{\n+  const Distance n = last - first;\n+\n+  Distance parent = 0;\n+  for (Distance child = 1; child < n; ++child) {\n+    if (comp(first[parent], first[child]))\n+      return false;\n+    if (child & 1 == 0)\n+      ++parent;\n+  }\n+  return true;\n+}\n+\n+template <class RandomAccessIterator, class StrictWeakOrdering>\n+inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last,\n+                    StrictWeakOrdering comp)\n+{\n+  return __is_heap(first, last, comp, distance_type(first));\n+}\n+\n+\n+template <class ForwardIterator>\n+bool is_sorted(ForwardIterator first, ForwardIterator last)\n+{\n+  if (first == last)\n+    return true;\n+\n+  ForwardIterator next = first;\n+  for (++next; next != last; first = next, ++next) {\n+    if (*next < *first)\n+      return false;\n+  }\n+\n+  return true;\n+}\n+\n+template <class ForwardIterator, class StrictWeakOrdering>\n+bool is_sorted(ForwardIterator first, ForwardIterator last,\n+               StrictWeakOrdering comp)\n+{\n+  if (first == last)\n+    return true;\n+\n+  ForwardIterator next = first;\n+  for (++next; next != last; first = next, ++next) {\n+    if (comp(*next, *first))\n+      return false;\n+  }\n+\n+  return true;\n+}\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma reset woff 1209\n+#endif\n+\n+__STL_END_NAMESPACE\n+\n+#endif /* __SGI_STL_INTERNAL_ALGO_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "668baad8d6b6ebfe11eb931976f683a893336f82", "filename": "libstdc++/stl/stl_algobase.h", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_algobase.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,439 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/* NOTE: This is an internal header file, included by other STL headers.\n+ *   You should not attempt to use it directly.\n+ */\n+\n+\n+#ifndef __SGI_STL_INTERNAL_ALGOBASE_H\n+#define __SGI_STL_INTERNAL_ALGOBASE_H\n+\n+#ifndef __STL_CONFIG_H\n+#include <stl_config.h>\n+#endif\n+#ifndef __SGI_STL_INTERNAL_RELOPS\n+#include <stl_relops.h>\n+#endif\n+#ifndef __SGI_STL_INTERNAL_PAIR_H\n+#include <stl_pair.h>\n+#endif\n+#ifndef __TYPE_TRAITS_H_\n+#include <type_traits.h>\n+#endif\n+\n+#include <string.h>\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <new.h>\n+#include <iostream.h>\n+\n+#ifndef __SGI_STL_INTERNAL_ITERATOR_H\n+#include <stl_iterator.h>\n+#endif\n+\n+__STL_BEGIN_NAMESPACE\n+\n+template <class ForwardIterator1, class ForwardIterator2, class T>\n+inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) {\n+  T tmp = *a;\n+  *a = *b;\n+  *b = tmp;\n+}\n+\n+template <class ForwardIterator1, class ForwardIterator2>\n+inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {\n+  __iter_swap(a, b, value_type(a));\n+}\n+\n+template <class T>\n+inline void swap(T& a, T& b) {\n+  T tmp = a;\n+  a = b;\n+  b = tmp;\n+}\n+\n+#ifndef __BORLANDC__\n+\n+template <class T>\n+inline const T& min(const T& a, const T& b) {\n+  return b < a ? b : a;\n+}\n+\n+template <class T>\n+inline const T& max(const T& a, const T& b) {\n+  return  a < b ? b : a;\n+}\n+\n+#endif /* __BORLANDC__ */\n+\n+template <class T, class Compare>\n+inline const T& min(const T& a, const T& b, Compare comp) {\n+  return comp(b, a) ? b : a;\n+}\n+\n+template <class T, class Compare>\n+inline const T& max(const T& a, const T& b, Compare comp) {\n+  return comp(a, b) ? b : a;\n+}\n+\n+template <class InputIterator, class OutputIterator>\n+inline OutputIterator __copy(InputIterator first, InputIterator last,\n+                             OutputIterator result, input_iterator_tag)\n+{\n+  for ( ; first != last; ++result, ++first)\n+    *result = *first;\n+  return result;\n+}\n+\n+template <class RandomAccessIterator, class OutputIterator, class Distance>\n+inline OutputIterator\n+__copy_d(RandomAccessIterator first, RandomAccessIterator last,\n+         OutputIterator result, Distance*)\n+{\n+  for (Distance n = last - first; n > 0; --n, ++result, ++first) \n+    *result = *first;\n+  return result;\n+}\n+\n+template <class RandomAccessIterator, class OutputIterator>\n+inline OutputIterator \n+__copy(RandomAccessIterator first, RandomAccessIterator last,\n+       OutputIterator result, random_access_iterator_tag)\n+{\n+  return __copy_d(first, last, result, distance_type(first));\n+}\n+\n+template <class InputIterator, class OutputIterator>\n+struct __copy_dispatch\n+{\n+  OutputIterator operator()(InputIterator first, InputIterator last,\n+                            OutputIterator result) {\n+    return __copy(first, last, result, iterator_category(first));\n+  }\n+};\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION \n+\n+template <class T>\n+inline T* __copy_t(const T* first, const T* last, T* result, __true_type) {\n+  memmove(result, first, sizeof(T) * (last - first));\n+  return result + (last - first);\n+}\n+\n+template <class T>\n+inline T* __copy_t(const T* first, const T* last, T* result, __false_type) {\n+  return __copy_d(first, last, result, (ptrdiff_t*) 0);\n+}\n+\n+template <class T>\n+struct __copy_dispatch<T*, T*>\n+{\n+  T* operator()(T* first, T* last, T* result) {\n+    typedef typename __type_traits<T>::has_trivial_assignment_operator t; \n+    return __copy_t(first, last, result, t());\n+  }\n+};\n+\n+template <class T>\n+struct __copy_dispatch<const T*, T*>\n+{\n+  T* operator()(const T* first, const T* last, T* result) {\n+    typedef typename __type_traits<T>::has_trivial_assignment_operator t; \n+    return __copy_t(first, last, result, t());\n+  }\n+};\n+\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n+template <class InputIterator, class OutputIterator>\n+inline OutputIterator copy(InputIterator first, InputIterator last,\n+                           OutputIterator result)\n+{\n+  return __copy_dispatch<InputIterator,OutputIterator>()(first, last, result);\n+}\n+\n+inline char* copy(const char* first, const char* last, char* result) {\n+  memmove(result, first, last - first);\n+  return result + (last - first);\n+}\n+\n+inline wchar_t* copy(const wchar_t* first, const wchar_t* last,\n+                     wchar_t* result) {\n+  memmove(result, first, sizeof(wchar_t) * (last - first));\n+  return result + (last - first);\n+}\n+\n+template <class BidirectionalIterator1, class BidirectionalIterator2>\n+inline BidirectionalIterator2 __copy_backward(BidirectionalIterator1 first, \n+                                              BidirectionalIterator1 last, \n+                                              BidirectionalIterator2 result) {\n+  while (first != last) *--result = *--last;\n+  return result;\n+}\n+\n+\n+template <class BidirectionalIterator1, class BidirectionalIterator2>\n+struct __copy_backward_dispatch\n+{\n+  BidirectionalIterator2 operator()(BidirectionalIterator1 first, \n+                                    BidirectionalIterator1 last, \n+                                    BidirectionalIterator2 result) {\n+    return __copy_backward(first, last, result);\n+  }\n+};\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION \n+\n+template <class T>\n+inline T* __copy_backward_t(const T* first, const T* last, T* result,\n+                            __true_type) {\n+  const ptrdiff_t N = last - first;\n+  memmove(result - N, first, sizeof(T) * N);\n+  return result - N;\n+}\n+\n+template <class T>\n+inline T* __copy_backward_t(const T* first, const T* last, T* result,\n+                            __false_type) {\n+  return __copy_backward(first, last, result);\n+}\n+\n+template <class T>\n+struct __copy_backward_dispatch<T*, T*>\n+{\n+  T* operator()(T* first, T* last, T* result) {\n+    typedef typename __type_traits<T>::has_trivial_assignment_operator t; \n+    return __copy_backward_t(first, last, result, t());\n+  }\n+};\n+\n+template <class T>\n+struct __copy_backward_dispatch<const T*, T*>\n+{\n+  T* operator()(const T* first, const T* last, T* result) {\n+    typedef typename __type_traits<T>::has_trivial_assignment_operator t; \n+    return __copy_backward_t(first, last, result, t());\n+  }\n+};\n+\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n+template <class BidirectionalIterator1, class BidirectionalIterator2>\n+inline BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, \n+                                            BidirectionalIterator1 last, \n+                                            BidirectionalIterator2 result) {\n+  return __copy_backward_dispatch<BidirectionalIterator1, \n+                                  BidirectionalIterator2>()(first, last, \n+                                                            result);\n+}\n+\n+template <class InputIterator, class Size, class OutputIterator>\n+pair<InputIterator, OutputIterator> __copy_n(InputIterator first, Size count,\n+                                             OutputIterator result,\n+                                             input_iterator_tag) {\n+  for ( ; count > 0; --count, ++first, ++result)\n+    *result = *first;\n+  return pair<InputIterator, OutputIterator>(first, result);\n+}\n+\n+template <class RandomAccessIterator, class Size, class OutputIterator>\n+inline pair<RandomAccessIterator, OutputIterator>\n+__copy_n(RandomAccessIterator first, Size count,\n+         OutputIterator result,\n+         random_access_iterator_tag) {\n+  RandomAccessIterator last = first + count;\n+  return pair<RandomAccessIterator, OutputIterator>(last,\n+                                                    copy(first, last, result));\n+}\n+\n+template <class InputIterator, class Size, class OutputIterator>\n+inline pair<InputIterator, OutputIterator>\n+copy_n(InputIterator first, Size count,\n+       OutputIterator result) {\n+  return __copy_n(first, count, result, iterator_category(first));\n+}\n+\n+template <class ForwardIterator, class T>\n+void fill(ForwardIterator first, ForwardIterator last, const T& value) {\n+  for ( ; first != last; ++first)\n+    *first = value;\n+}\n+\n+template <class OutputIterator, class Size, class T>\n+OutputIterator fill_n(OutputIterator first, Size n, const T& value) {\n+  for ( ; n > 0; --n, ++first)\n+    *first = value;\n+  return first;\n+}\n+\n+template <class InputIterator1, class InputIterator2>\n+pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,\n+\t\t\t\t\t      InputIterator1 last1,\n+\t\t\t\t\t      InputIterator2 first2) {\n+  while (first1 != last1 && *first1 == *first2) {\n+    ++first1;\n+    ++first2;\n+  }\n+  return pair<InputIterator1, InputIterator2>(first1, first2);\n+}\n+\n+template <class InputIterator1, class InputIterator2, class BinaryPredicate>\n+pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,\n+\t\t\t\t\t      InputIterator1 last1,\n+\t\t\t\t\t      InputIterator2 first2,\n+\t\t\t\t\t      BinaryPredicate binary_pred) {\n+  while (first1 != last1 && binary_pred(*first1, *first2)) {\n+    ++first1;\n+    ++first2;\n+  }\n+  return pair<InputIterator1, InputIterator2>(first1, first2);\n+}\n+\n+template <class InputIterator1, class InputIterator2>\n+inline bool equal(InputIterator1 first1, InputIterator1 last1,\n+\t\t  InputIterator2 first2) {\n+  for ( ; first1 != last1; ++first1, ++first2)\n+    if (*first1 != *first2)\n+      return false;\n+  return true;\n+}\n+\n+template <class InputIterator1, class InputIterator2, class BinaryPredicate>\n+inline bool equal(InputIterator1 first1, InputIterator1 last1,\n+\t\t  InputIterator2 first2, BinaryPredicate binary_pred) {\n+  for ( ; first1 != last1; ++first1, ++first2)\n+    if (!binary_pred(*first1, *first2))\n+      return false;\n+  return true;\n+}\n+\n+template <class InputIterator1, class InputIterator2>\n+bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n+\t\t\t     InputIterator2 first2, InputIterator2 last2) {\n+  for ( ; first1 != last1 && first2 != last2; ++first1, ++first2) {\n+    if (*first1 < *first2)\n+      return true;\n+    if (*first2 < *first1)\n+      return false;\n+  }\n+  return first1 == last1 && first2 != last2;\n+}\n+\n+template <class InputIterator1, class InputIterator2, class Compare>\n+bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n+\t\t\t     InputIterator2 first2, InputIterator2 last2,\n+\t\t\t     Compare comp) {\n+  for ( ; first1 != last1 && first2 != last2; ++first1, ++first2) {\n+    if (comp(*first1, *first2))\n+      return true;\n+    if (comp(*first2, *first1))\n+      return false;\n+  }\n+  return first1 == last1 && first2 != last2;\n+}\n+\n+inline bool \n+lexicographical_compare(const unsigned char* first1,\n+                        const unsigned char* last1,\n+                        const unsigned char* first2,\n+                        const unsigned char* last2)\n+{\n+  const size_t len1 = last1 - first1;\n+  const size_t len2 = last2 - first2;\n+  const int result = memcmp(first1, first2, min(len1, len2));\n+  return result != 0 ? result < 0 : len1 < len2;\n+}\n+\n+inline bool lexicographical_compare(const char* first1, const char* last1,\n+                                    const char* first2, const char* last2)\n+{\n+#if CHAR_MAX == SCHAR_MAX\n+  return lexicographical_compare((const signed char*) first1,\n+                                 (const signed char*) last1,\n+                                 (const signed char*) first2,\n+                                 (const signed char*) last2);\n+#else\n+  return lexicographical_compare((const unsigned char*) first1,\n+                                 (const unsigned char*) last1,\n+                                 (const unsigned char*) first2,\n+                                 (const unsigned char*) last2);\n+#endif\n+}\n+\n+template <class InputIterator1, class InputIterator2>\n+int lexicographical_compare_3way(InputIterator1 first1, InputIterator1 last1,\n+                                 InputIterator2 first2, InputIterator2 last2)\n+{\n+  while (first1 != last1 && first2 != last2) {\n+    if (*first1 < *first2) return -1;\n+    if (*first2 < *first1) return 1;\n+    ++first1; ++first2;\n+  }\n+  if (first2 == last2) {\n+    return !(first1 == last1);\n+  } else {\n+    return -1;\n+  }\n+}\n+\n+inline int\n+lexicographical_compare_3way(const unsigned char* first1,\n+                             const unsigned char* last1,\n+                             const unsigned char* first2,\n+                             const unsigned char* last2)\n+{\n+  const ptrdiff_t len1 = last1 - first1;\n+  const ptrdiff_t len2 = last2 - first2;\n+  const int result = memcmp(first1, first2, min(len1, len2));\n+  return result != 0 ? result : (len1 == len2 ? 0 : (len1 < len2 ? -1 : 1));\n+}\n+\n+inline int lexicographical_compare_3way(const char* first1, const char* last1,\n+                                        const char* first2, const char* last2)\n+{\n+#if CHAR_MAX == SCHAR_MAX\n+  return lexicographical_compare_3way(\n+\t\t\t\t(const signed char*) first1,\n+                                (const signed char*) last1,\n+                                (const signed char*) first2,\n+                                (const signed char*) last2);\n+#else\n+  return lexicographical_compare_3way((const unsigned char*) first1,\n+                                      (const unsigned char*) last1,\n+                                      (const unsigned char*) first2,\n+                                      (const unsigned char*) last2);\n+#endif\n+}\n+\n+__STL_END_NAMESPACE\n+\n+#endif /* __SGI_STL_INTERNAL_ALGOBASE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "a6d41437bd4f495729218f96306a16173e979ba7", "filename": "libstdc++/stl/stl_alloc.h", "status": "added", "additions": 698, "deletions": 0, "changes": 698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_alloc.h?ref=bb84e66919817020267815eed4304e543688e722", "patch": "@@ -0,0 +1,698 @@\n+/*\n+ * Copyright (c) 1996-1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/* NOTE: This is an internal header file, included by other STL headers.\n+ *   You should not attempt to use it directly.\n+ */\n+\n+#ifndef __SGI_STL_INTERNAL_ALLOC_H\n+#define __SGI_STL_INTERNAL_ALLOC_H\n+\n+#ifdef __SUNPRO_CC\n+#  define __PRIVATE public\n+   // Extra access restrictions prevent us from really making some things\n+   // private.\n+#else\n+#  define __PRIVATE private\n+#endif\n+\n+#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n+#  define __USE_MALLOC\n+#endif\n+\n+\n+// This implements some standard node allocators.  These are\n+// NOT the same as the allocators in the C++ draft standard or in\n+// in the original STL.  They do not encapsulate different pointer\n+// types; indeed we assume that there is only one pointer type.\n+// The allocation primitives are intended to allocate individual objects,\n+// not larger arenas as with the original STL allocators.\n+\n+#if 0\n+#   include <new>\n+#   define __THROW_BAD_ALLOC throw bad_alloc\n+#elif !defined(__THROW_BAD_ALLOC)\n+#   include <iostream.h>\n+#   define __THROW_BAD_ALLOC cerr << \"out of memory\" << endl; exit(1)\n+#endif\n+\n+#ifndef __ALLOC\n+#   define __ALLOC alloc\n+#endif\n+#ifdef __STL_WIN32THREADS\n+#   include <windows.h>\n+#endif\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#ifndef __RESTRICT\n+#  define __RESTRICT\n+#endif\n+\n+#if !defined(_PTHREADS) && !defined(_NOTHREADS) \\\n+ && !defined(__STL_SGI_THREADS) && !defined(__STL_WIN32THREADS)\n+#   define _NOTHREADS\n+#endif\n+\n+# ifdef _PTHREADS\n+    // POSIX Threads\n+    // This is dubious, since this is likely to be a high contention\n+    // lock.   Performance may not be adequate.\n+#   include <pthread.h>\n+#   define __NODE_ALLOCATOR_LOCK \\\n+        if (threads) pthread_mutex_lock(&__node_allocator_lock)\n+#   define __NODE_ALLOCATOR_UNLOCK \\\n+        if (threads) pthread_mutex_unlock(&__node_allocator_lock)\n+#   define __NODE_ALLOCATOR_THREADS true\n+#   define __VOLATILE volatile  // Needed at -O3 on SGI\n+# endif\n+# ifdef __STL_WIN32THREADS\n+    // The lock needs to be initialized by constructing an allocator\n+    // objects of the right type.  We do that here explicitly for alloc.\n+#   define __NODE_ALLOCATOR_LOCK \\\n+        EnterCriticalSection(&__node_allocator_lock)\n+#   define __NODE_ALLOCATOR_UNLOCK \\\n+        LeaveCriticalSection(&__node_allocator_lock)\n+#   define __NODE_ALLOCATOR_THREADS true\n+#   define __VOLATILE volatile  // may not be needed\n+# endif /* WIN32THREADS */\n+# ifdef __STL_SGI_THREADS\n+    // This should work without threads, with sproc threads, or with\n+    // pthreads.  It is suboptimal in all cases.\n+    // It is unlikely to even compile on nonSGI machines.\n+\n+    extern \"C\" {\n+      extern int __us_rsthread_malloc;\n+    }\n+\t// The above is copied from malloc.h.  Including <malloc.h>\n+\t// would be cleaner but fails with certain levels of standard\n+\t// conformance.\n+#   define __NODE_ALLOCATOR_LOCK if (threads && __us_rsthread_malloc) \\\n+                { __lock(&__node_allocator_lock); }\n+#   define __NODE_ALLOCATOR_UNLOCK if (threads && __us_rsthread_malloc) \\\n+                { __unlock(&__node_allocator_lock); }\n+#   define __NODE_ALLOCATOR_THREADS true\n+#   define __VOLATILE volatile  // Needed at -O3 on SGI\n+# endif\n+# ifdef _NOTHREADS\n+//  Thread-unsafe\n+#   define __NODE_ALLOCATOR_LOCK\n+#   define __NODE_ALLOCATOR_UNLOCK\n+#   define __NODE_ALLOCATOR_THREADS false\n+#   define __VOLATILE\n+# endif\n+\n+__STL_BEGIN_NAMESPACE\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma set woff 1174\n+#endif\n+\n+// Malloc-based allocator.  Typically slower than default alloc below.\n+// Typically thread-safe and more storage efficient.\n+#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n+# ifdef __DECLARE_GLOBALS_HERE\n+    void (* __malloc_alloc_oom_handler)() = 0;\n+    // g++ 2.7.2 does not handle static template data members.\n+# else\n+    extern void (* __malloc_alloc_oom_handler)();\n+# endif\n+#endif\n+\n+template <int inst>\n+class __malloc_alloc_template {\n+\n+private:\n+\n+static void *oom_malloc(size_t);\n+\n+static void *oom_realloc(void *, size_t);\n+\n+#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n+    static void (* __malloc_alloc_oom_handler)();\n+#endif\n+\n+public:\n+\n+static void * allocate(size_t n)\n+{\n+    void *result = malloc(n);\n+    if (0 == result) result = oom_malloc(n);\n+    return result;\n+}\n+\n+static void deallocate(void *p, size_t /* n */)\n+{\n+    free(p);\n+}\n+\n+static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz)\n+{\n+    void * result = realloc(p, new_sz);\n+    if (0 == result) result = oom_realloc(p, new_sz);\n+    return result;\n+}\n+\n+static void (* set_malloc_handler(void (*f)()))()\n+{\n+    void (* old)() = __malloc_alloc_oom_handler;\n+    __malloc_alloc_oom_handler = f;\n+    return(old);\n+}\n+\n+};\n+\n+// malloc_alloc out-of-memory handling\n+\n+#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n+template <int inst>\n+void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;\n+#endif\n+\n+template <int inst>\n+void * __malloc_alloc_template<inst>::oom_malloc(size_t n)\n+{\n+    void (* my_malloc_handler)();\n+    void *result;\n+\n+    for (;;) {\n+        my_malloc_handler = __malloc_alloc_oom_handler;\n+        if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }\n+        (*my_malloc_handler)();\n+        result = malloc(n);\n+        if (result) return(result);\n+    }\n+}\n+\n+template <int inst>\n+void * __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n)\n+{\n+    void (* my_malloc_handler)();\n+    void *result;\n+\n+    for (;;) {\n+        my_malloc_handler = __malloc_alloc_oom_handler;\n+        if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }\n+        (*my_malloc_handler)();\n+        result = realloc(p, n);\n+        if (result) return(result);\n+    }\n+}\n+\n+typedef __malloc_alloc_template<0> malloc_alloc;\n+\n+template<class T, class Alloc>\n+class simple_alloc {\n+\n+public:\n+    static T *allocate(size_t n)\n+                { return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); }\n+    static T *allocate(void)\n+                { return (T*) Alloc::allocate(sizeof (T)); }\n+    static void deallocate(T *p, size_t n)\n+                { if (0 != n) Alloc::deallocate(p, n * sizeof (T)); }\n+    static void deallocate(T *p)\n+                { Alloc::deallocate(p, sizeof (T)); }\n+};\n+\n+// Allocator adaptor to check size arguments for debugging.\n+// Reports errors using assert.  Checking can be disabled with\n+// NDEBUG, but it's far better to just use the underlying allocator\n+// instead when no checking is desired.\n+// There is some evidence that this can confuse Purify.\n+template <class Alloc>\n+class debug_alloc {\n+\n+private:\n+\n+enum {extra = 8};       // Size of space used to store size.  Note\n+                        // that this must be large enough to preserve\n+                        // alignment.\n+\n+public:\n+\n+static void * allocate(size_t n)\n+{\n+    char *result = (char *)Alloc::allocate(n + extra);\n+    *(size_t *)result = n;\n+    return result + extra;\n+}\n+\n+static void deallocate(void *p, size_t n)\n+{\n+    char * real_p = (char *)p - extra;\n+    assert(*(size_t *)real_p == n);\n+    Alloc::deallocate(real_p, n + extra);\n+}\n+\n+static void * reallocate(void *p, size_t old_sz, size_t new_sz)\n+{\n+    char * real_p = (char *)p - extra;\n+    assert(*(size_t *)real_p == old_sz);\n+    char * result = (char *)\n+                  Alloc::reallocate(real_p, old_sz + extra, new_sz + extra);\n+    *(size_t *)result = new_sz;\n+    return result + extra;\n+}\n+\n+\n+};\n+\n+\n+# ifdef __USE_MALLOC\n+\n+typedef malloc_alloc alloc;\n+typedef malloc_alloc single_client_alloc;\n+\n+# else\n+\n+\n+// Default node allocator.\n+// With a reasonable compiler, this should be roughly as fast as the\n+// original STL class-specific allocators, but with less fragmentation.\n+// Default_alloc_template parameters are experimental and MAY\n+// DISAPPEAR in the future.  Clients should just use alloc for now.\n+//\n+// Important implementation properties:\n+// 1. If the client request an object of size > __MAX_BYTES, the resulting\n+//    object will be obtained directly from malloc.\n+// 2. In all other cases, we allocate an object of size exactly\n+//    ROUND_UP(requested_size).  Thus the client has enough size\n+//    information that we can return the object to the proper free list\n+//    without permanently losing part of the object.\n+//\n+\n+// The first template parameter specifies whether more than one thread\n+// may use this allocator.  It is safe to allocate an object from\n+// one instance of a default_alloc and deallocate it with another\n+// one.  This effectively transfers its ownership to the second one.\n+// This may have undesirable effects on reference locality.\n+// The second parameter is unreferenced and serves only to allow the\n+// creation of multiple default_alloc instances.\n+// Node that containers built on different allocator instances have\n+// different types, limiting the utility of this approach.\n+#ifdef __SUNPRO_CC\n+// breaks if we make these template class members:\n+  enum {__ALIGN = 8};\n+  enum {__MAX_BYTES = 128};\n+  enum {__NFREELISTS = __MAX_BYTES/__ALIGN};\n+#endif\n+\n+template <bool threads, int inst>\n+class __default_alloc_template {\n+\n+private:\n+  // Really we should use static const int x = N\n+  // instead of enum { x = N }, but few compilers accept the former.\n+# ifndef __SUNPRO_CC\n+    enum {__ALIGN = 8};\n+    enum {__MAX_BYTES = 128};\n+    enum {__NFREELISTS = __MAX_BYTES/__ALIGN};\n+# endif\n+  static size_t ROUND_UP(size_t bytes) {\n+        return (((bytes) + __ALIGN-1) & ~(__ALIGN - 1));\n+  }\n+__PRIVATE:\n+  union obj {\n+        union obj * free_list_link;\n+        char client_data[1];    /* The client sees this.        */\n+  };\n+private:\n+# ifdef __SUNPRO_CC\n+    static obj * __VOLATILE free_list[]; \n+        // Specifying a size results in duplicate def for 4.1\n+# else\n+    static obj * __VOLATILE free_list[__NFREELISTS]; \n+# endif\n+  static  size_t FREELIST_INDEX(size_t bytes) {\n+        return (((bytes) + __ALIGN-1)/__ALIGN - 1);\n+  }\n+\n+  // Returns an object of size n, and optionally adds to size n free list.\n+  static void *refill(size_t n);\n+  // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n+  // if it is inconvenient to allocate the requested number.\n+  static char *chunk_alloc(size_t size, int &nobjs);\n+\n+  // Chunk allocation state.\n+  static char *start_free;\n+  static char *end_free;\n+  static size_t heap_size;\n+\n+# ifdef __STL_SGI_THREADS\n+    static volatile unsigned long __node_allocator_lock;\n+    static void __lock(volatile unsigned long *); \n+    static inline void __unlock(volatile unsigned long *);\n+# endif\n+\n+# ifdef _PTHREADS\n+    static pthread_mutex_t __node_allocator_lock;\n+# endif\n+\n+# ifdef __STL_WIN32THREADS\n+    static CRITICAL_SECTION __node_allocator_lock;\n+    static bool __node_allocator_lock_initialized;\n+\n+  public:\n+    __default_alloc_template() {\n+\t// This assumes the first constructor is called before threads\n+\t// are started.\n+        if (!__node_allocator_lock_initialized) {\n+            InitializeCriticalSection(&__node_allocator_lock);\n+            __node_allocator_lock_initialized = true;\n+        }\n+    }\n+  private:\n+# endif\n+\n+    class lock {\n+        public:\n+            lock() { __NODE_ALLOCATOR_LOCK; }\n+            ~lock() { __NODE_ALLOCATOR_UNLOCK; }\n+    };\n+    friend class lock;\n+\n+public:\n+\n+  /* n must be > 0      */\n+  static void * allocate(size_t n)\n+  {\n+    obj * __VOLATILE * my_free_list;\n+    obj * __RESTRICT result;\n+\n+    if (n > (size_t) __MAX_BYTES) {\n+        return(malloc_alloc::allocate(n));\n+    }\n+    my_free_list = free_list + FREELIST_INDEX(n);\n+    // Acquire the lock here with a constructor call.\n+    // This ensures that it is released in exit or during stack\n+    // unwinding.\n+#       ifndef _NOTHREADS\n+        /*REFERENCED*/\n+        lock lock_instance;\n+#       endif\n+    result = *my_free_list;\n+    if (result == 0) {\n+        void *r = refill(ROUND_UP(n));\n+        return r;\n+    }\n+    *my_free_list = result -> free_list_link;\n+    return (result);\n+  };\n+\n+  /* p may not be 0 */\n+  static void deallocate(void *p, size_t n)\n+  {\n+    obj *q = (obj *)p;\n+    obj * __VOLATILE * my_free_list;\n+\n+    if (n > (size_t) __MAX_BYTES) {\n+        malloc_alloc::deallocate(p, n);\n+        return;\n+    }\n+    my_free_list = free_list + FREELIST_INDEX(n);\n+    // acquire lock\n+#       ifndef _NOTHREADS\n+        /*REFERENCED*/\n+        lock lock_instance;\n+#       endif /* _NOTHREADS */\n+    q -> free_list_link = *my_free_list;\n+    *my_free_list = q;\n+    // lock is released here\n+  }\n+\n+  static void * reallocate(void *p, size_t old_sz, size_t new_sz);\n+\n+} ;\n+\n+typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;\n+typedef __default_alloc_template<false, 0> single_client_alloc;\n+\n+\n+\n+/* We allocate memory in large chunks in order to avoid fragmenting     */\n+/* the malloc heap too much.                                            */\n+/* We assume that size is properly aligned.                             */\n+/* We hold the allocation lock.                                         */\n+template <bool threads, int inst>\n+char*\n+__default_alloc_template<threads, inst>::chunk_alloc(size_t size, int& nobjs)\n+{\n+    char * result;\n+    size_t total_bytes = size * nobjs;\n+    size_t bytes_left = end_free - start_free;\n+\n+    if (bytes_left >= total_bytes) {\n+        result = start_free;\n+        start_free += total_bytes;\n+        return(result);\n+    } else if (bytes_left >= size) {\n+        nobjs = bytes_left/size;\n+        total_bytes = size * nobjs;\n+        result = start_free;\n+        start_free += total_bytes;\n+        return(result);\n+    } else {\n+        size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size >> 4);\n+        // Try to make use of the left-over piece.\n+        if (bytes_left > 0) {\n+            obj * __VOLATILE * my_free_list =\n+                        free_list + FREELIST_INDEX(bytes_left);\n+\n+            ((obj *)start_free) -> free_list_link = *my_free_list;\n+            *my_free_list = (obj *)start_free;\n+        }\n+        start_free = (char *)malloc(bytes_to_get);\n+        if (0 == start_free) {\n+            int i;\n+            obj * __VOLATILE * my_free_list, *p;\n+            // Try to make do with what we have.  That can't\n+            // hurt.  We do not try smaller requests, since that tends\n+            // to result in disaster on multi-process machines.\n+            for (i = size; i <= __MAX_BYTES; i += __ALIGN) {\n+                my_free_list = free_list + FREELIST_INDEX(i);\n+                p = *my_free_list;\n+                if (0 != p) {\n+                    *my_free_list = p -> free_list_link;\n+                    start_free = (char *)p;\n+                    end_free = start_free + i;\n+                    return(chunk_alloc(size, nobjs));\n+                    // Any leftover piece will eventually make it to the\n+                    // right free list.\n+                }\n+            }\n+\t    end_free = 0;\t// In case of exception.\n+            start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n+            // This should either throw an\n+            // exception or remedy the situation.  Thus we assume it\n+            // succeeded.\n+        }\n+        heap_size += bytes_to_get;\n+        end_free = start_free + bytes_to_get;\n+        return(chunk_alloc(size, nobjs));\n+    }\n+}\n+\n+\n+/* Returns an object of size n, and optionally adds to size n free list.*/\n+/* We assume that n is properly aligned.                                */\n+/* We hold the allocation lock.                                         */\n+template <bool threads, int inst>\n+void* __default_alloc_template<threads, inst>::refill(size_t n)\n+{\n+    int nobjs = 20;\n+    char * chunk = chunk_alloc(n, nobjs);\n+    obj * __VOLATILE * my_free_list;\n+    obj * result;\n+    obj * current_obj, * next_obj;\n+    int i;\n+\n+    if (1 == nobjs) return(chunk);\n+    my_free_list = free_list + FREELIST_INDEX(n);\n+\n+    /* Build free list in chunk */\n+      result = (obj *)chunk;\n+      *my_free_list = next_obj = (obj *)(chunk + n);\n+      for (i = 1; ; i++) {\n+        current_obj = next_obj;\n+        next_obj = (obj *)((char *)next_obj + n);\n+        if (nobjs - 1 == i) {\n+            current_obj -> free_list_link = 0;\n+            break;\n+        } else {\n+            current_obj -> free_list_link = next_obj;\n+        }\n+      }\n+    return(result);\n+}\n+\n+template <bool threads, int inst>\n+void*\n+__default_alloc_template<threads, inst>::reallocate(void *p,\n+                                                    size_t old_sz,\n+                                                    size_t new_sz)\n+{\n+    void * result;\n+    size_t copy_sz;\n+\n+    if (old_sz > (size_t) __MAX_BYTES && new_sz > (size_t) __MAX_BYTES) {\n+        return(realloc(p, new_sz));\n+    }\n+    if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);\n+    result = allocate(new_sz);\n+    copy_sz = new_sz > old_sz? old_sz : new_sz;\n+    memcpy(result, p, copy_sz);\n+    deallocate(p, old_sz);\n+    return(result);\n+}\n+\n+#ifdef _PTHREADS\n+    template <bool threads, int inst>\n+    pthread_mutex_t\n+    __default_alloc_template<threads, inst>::__node_allocator_lock\n+        = PTHREAD_MUTEX_INITIALIZER;\n+#endif\n+\n+#ifdef __STL_WIN32THREADS\n+    template <bool threads, int inst> CRITICAL_SECTION\n+    __default_alloc_template<threads, inst>::__node_allocator_lock;\n+\n+    template <bool threads, int inst> bool\n+    __default_alloc_template<threads, inst>::__node_allocator_lock_initialized\n+\t= false;\n+#endif\n+\n+#ifdef __STL_SGI_THREADS\n+__STL_END_NAMESPACE\n+#include <mutex.h>\n+#include <time.h>\n+__STL_BEGIN_NAMESPACE\n+// Somewhat generic lock implementations.  We need only test-and-set\n+// and some way to sleep.  These should work with both SGI pthreads\n+// and sproc threads.  They may be useful on other systems.\n+template <bool threads, int inst>\n+volatile unsigned long\n+__default_alloc_template<threads, inst>::__node_allocator_lock = 0;\n+\n+#if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) || defined(__GNUC__)\n+#   define __test_and_set(l,v) test_and_set(l,v)\n+#endif\n+\n+template <bool threads, int inst>\n+void \n+__default_alloc_template<threads, inst>::__lock(volatile unsigned long *lock)\n+{\n+    const unsigned low_spin_max = 30;  // spin cycles if we suspect uniprocessor\n+    const unsigned high_spin_max = 1000; // spin cycles for multiprocessor\n+    static unsigned spin_max = low_spin_max;\n+    unsigned my_spin_max;\n+    static unsigned last_spins = 0;\n+    unsigned my_last_spins;\n+    static struct timespec ts = {0, 1000};\n+    unsigned junk;\n+#   define __ALLOC_PAUSE junk *= junk; junk *= junk; junk *= junk; junk *= junk\n+    int i;\n+\n+    if (!__test_and_set((unsigned long *)lock, 1)) {\n+        return;\n+    }\n+    my_spin_max = spin_max;\n+    my_last_spins = last_spins;\n+    for (i = 0; i < my_spin_max; i++) {\n+        if (i < my_last_spins/2 || *lock) {\n+            __ALLOC_PAUSE;\n+            continue;\n+        }\n+        if (!__test_and_set((unsigned long *)lock, 1)) {\n+            // got it!\n+            // Spinning worked.  Thus we're probably not being scheduled\n+            // against the other process with which we were contending.\n+            // Thus it makes sense to spin longer the next time.\n+            last_spins = i;\n+            spin_max = high_spin_max;\n+            return;\n+        }\n+    }\n+    // We are probably being scheduled against the other process.  Sleep.\n+    spin_max = low_spin_max;\n+    for (;;) {\n+        if (!__test_and_set((unsigned long *)lock, 1)) {\n+            return;\n+        }\n+        nanosleep(&ts, 0);\n+    }\n+}\n+\n+template <bool threads, int inst>\n+inline void\n+__default_alloc_template<threads, inst>::__unlock(volatile unsigned long *lock)\n+{\n+#   if defined(__GNUC__) && __mips >= 3\n+        asm(\"sync\");\n+        *lock = 0;\n+#   elif __mips >= 3 && (defined (_ABIN32) || defined(_ABI64))\n+        __lock_release(lock);\n+#   else \n+        *lock = 0;\n+        // This is not sufficient on many multiprocessors, since\n+        // writes to protected variables and the lock may be reordered.\n+#   endif\n+}\n+#endif\n+\n+template <bool threads, int inst>\n+char *__default_alloc_template<threads, inst>::start_free = 0;\n+\n+template <bool threads, int inst>\n+char *__default_alloc_template<threads, inst>::end_free = 0;\n+\n+template <bool threads, int inst>\n+size_t __default_alloc_template<threads, inst>::heap_size = 0;\n+\n+template <bool threads, int inst>\n+__default_alloc_template<threads, inst>::obj * __VOLATILE\n+__default_alloc_template<threads, inst> ::free_list[\n+# ifdef __SUNPRO_CC\n+    __NFREELISTS\n+# else\n+    __default_alloc_template<threads, inst>::__NFREELISTS\n+# endif\n+] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };\n+// The 16 zeros are necessary to make version 4.1 of the SunPro\n+// compiler happy.  Otherwise it appears to allocate too little\n+// space for the array.\n+\n+# ifdef __STL_WIN32THREADS\n+  // Create one to get critical section initialized.\n+  // We do this onece per file, but only the first constructor\n+  // does anything.\n+  static alloc __node_allocator_dummy_instance;\n+# endif\n+\n+#endif /* ! __USE_MALLOC */\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma reset woff 1174\n+#endif\n+\n+__STL_END_NAMESPACE\n+\n+#undef __PRIVATE\n+\n+#endif /* __SGI_STL_INTERNAL_ALLOC_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "db02251facdb01efde60e0f0fba3ce0b22b0b044", "filename": "libstdc++/stl/stl_bvector.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_bvector.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "c6546667a93fe62d4bff8f0869f287af1a5b6fde", "filename": "libstdc++/stl/stl_config.h", "status": "modified", "additions": 92, "deletions": 27, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_config.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "46876353da6a11cf56491bdb7d07efa001d8f0be", "filename": "libstdc++/stl/stl_construct.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_construct.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "79d40082f768aad4b58a2625d8d2a7c11ad6332c", "filename": "libstdc++/stl/stl_deque.h", "status": "added", "additions": 1335, "deletions": 0, "changes": 1335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_deque.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "c0d785d6a60c70e4c39d32007a674af1e0c2e535", "filename": "libstdc++/stl/stl_function.h", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_function.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "3afa9dc554dd37f955ac6e57fbc31092880f229f", "filename": "libstdc++/stl/stl_hash_fun.h", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_hash_fun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_hash_fun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_hash_fun.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "9999e9a401b756ac4ef1ac4ab7581196c675d463", "filename": "libstdc++/stl/stl_hash_map.h", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_hash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_hash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_hash_map.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "80159dab59f63a171d11ddd94b9823b33fc15793", "filename": "libstdc++/stl/stl_hash_set.h", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_hash_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_hash_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_hash_set.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "2452f625d3db52a68241628a2093d45902a4d2c3", "filename": "libstdc++/stl/stl_hashtable.h", "status": "added", "additions": 948, "deletions": 0, "changes": 948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_hashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_hashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_hashtable.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "3fe24f833fcdc2992d69ac063290bd9e24b70557", "filename": "libstdc++/stl/stl_heap.h", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_heap.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "892db3e3dbb34604cf3273268de4186884ec2f20", "filename": "libstdc++/stl/stl_iterator.h", "status": "added", "additions": 843, "deletions": 0, "changes": 843, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_iterator.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "ac836b6fcf97798806c2f9f212e24dcb34e9f4d5", "filename": "libstdc++/stl/stl_list.h", "status": "added", "additions": 617, "deletions": 0, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_list.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "2a830cc65f222e78c2d9a215d366468549023c14", "filename": "libstdc++/stl/stl_map.h", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_map.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "b82159b648e5733d18a7ad14e498f95bdb044143", "filename": "libstdc++/stl/stl_multimap.h", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_multimap.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "ff5947e14905ed62c22c33535944b19c6e118fb7", "filename": "libstdc++/stl/stl_multiset.h", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_multiset.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "57fee2b1b5cb488c74f368dace0c9dff256cc2eb", "filename": "libstdc++/stl/stl_numeric.h", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_numeric.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "10a9cb08e3b7c6c282b4435062f913ade880ad11", "filename": "libstdc++/stl/stl_pair.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_pair.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "ff6eedeb701706da33b853340d2bffed189dae53", "filename": "libstdc++/stl/stl_queue.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_queue.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "5d3d0747b5ef314dfe824e65bafd40856e4dadc8", "filename": "libstdc++/stl/stl_raw_storage_iter.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_raw_storage_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_raw_storage_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_raw_storage_iter.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "01a0c7cdfcb1cbafc16f1799be9a436c2ede514d", "filename": "libstdc++/stl/stl_relops.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_relops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_relops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_relops.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "620db6ffbc5ffc8e49ccc9b76d4e7e0e14997630", "filename": "libstdc++/stl/stl_rope.h", "status": "added", "additions": 2112, "deletions": 0, "changes": 2112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_rope.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "9ffeaa799a764651693d4ce6d3193fd561ef1428", "filename": "libstdc++/stl/stl_set.h", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_set.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "f31ea9e15e540386ef496f9a9f6b9179e2fbc01b", "filename": "libstdc++/stl/stl_slist.h", "status": "added", "additions": 740, "deletions": 0, "changes": 740, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_slist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_slist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_slist.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "d380e81dd1f4518b77078d7749562cb263e63090", "filename": "libstdc++/stl/stl_stack.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_stack.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "5c971e6208a80df79455c87735f19e0fc68e4a2b", "filename": "libstdc++/stl/stl_tempbuf.h", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_tempbuf.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "55a6c0e53b2551c2cc55d258e14505c1982bdd97", "filename": "libstdc++/stl/stl_tree.h", "status": "added", "additions": 1099, "deletions": 0, "changes": 1099, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_tree.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "661bbe998e4836976af5dea5c431695ce3d4942f", "filename": "libstdc++/stl/stl_uninitialized.h", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_uninitialized.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "cfa7fdb62d303870c188e6729c6c1caec769f545", "filename": "libstdc++/stl/stl_vector.h", "status": "added", "additions": 534, "deletions": 0, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fstl_vector.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "8799393f39f120ac86b5f3904e86edf84e733ecc", "filename": "libstdc++/stl/tempbuf.h", "status": "modified", "additions": 20, "deletions": 83, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Ftempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Ftempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Ftempbuf.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "77c57cbbba1f4f16cb8c74a32608e9a8b38268ad", "filename": "libstdc++/stl/tree.h", "status": "modified", "additions": 11, "deletions": 1062, "changes": 1073, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Ftree.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "a7b977cc06b9bf070319cb054fa2387e7678ec58", "filename": "libstdc++/stl/type_traits.h", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Ftype_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Ftype_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Ftype_traits.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "df8c224388dba3599c92e6c58cfde7e308bb25d3", "filename": "libstdc++/stl/utility", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Futility?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "4bcdebcc1861002889e95b6a77b28b36660ba310", "filename": "libstdc++/stl/vector", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fvector?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "231a227b7e3a04647a05f0a365150d144216a571", "filename": "libstdc++/stl/vector.h", "status": "modified", "additions": 8, "deletions": 499, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb84e66919817020267815eed4304e543688e722/libstdc%2B%2B%2Fstl%2Fvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fvector.h?ref=bb84e66919817020267815eed4304e543688e722"}, {"sha": "fb79aa78274655ccc437a4dec0f9d5a9ef7093ab", "filename": "libstdc++/utility", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Futility?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895"}, {"sha": "79f735937517f815d054eb9fa921f2c665388e8d", "filename": "libstdc++/vector", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bcf315fa71e2dd20d719a192f4dac3c25e8895/libstdc%2B%2B%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fvector?ref=c3bcf315fa71e2dd20d719a192f4dac3c25e8895"}]}