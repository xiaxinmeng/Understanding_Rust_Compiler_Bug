{"sha": "e0e08ac26c828bca4b9323d3139eba9293f3ecf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBlMDhhYzI2YzgyOGJjYTRiOTMyM2QzMTM5ZWJhOTI5M2YzZWNmNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-04T14:52:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-04T14:52:14Z"}, "message": "simplify_rtx.c (simplify_subreg): Keep subregs on return values...\n\n\t* simplify_rtx.c (simplify_subreg): Keep subregs on return values,\n\tcheck CLASS_CANNOT_CHANGE_MODE before avoiding subreg on hard reg,\n\tin case register wasn't OK previously, accept it now; allow\n\tsubregs of frame pointer if reload completed and frame pointer\n\tis not needed.\n\n\t* combine.c (sombine_simplify_rtx): Fix comment;\n\tuse subreg_lowpart_offset instead of subreg_lowpart_p\n\t(gen_lowpart_for_combine): Use subreg_lowpart_offset.\n\t* rtl.h (subreg_lowpart_parts_p): Kill.\n\t(subreg_lowpart_offset, subreg_highpart_offset): Declare.\n\t* simplify-rtx.c (simplify_subreg): Use subreg_lowpart_offset.\n\t* emit-rtl.c (gen_lowpart_SUBREG): Use subreg_lowpart_offset;\n\t(gen_lowpart_common): Likewise.\n\t(subreg_lowpart_p): Likewise.\n\t(subreg_lowpart_parts_p): Kill.\n\t(subreg_lowpart_offset, subreg_highpart_offset): New function.\n\n\t* emit-rtl.c (gen_lowpart_common): Use simplify_gen_subreg\n\tto simplify SUBREG and REG.\n\t(gen_highpart): Use simplify_gen_subreg for all simplifications.\n\n\t* emit-rtl.c (gen_realpart, gen_imagpart): Do not handle\n\tCONCAT specially.\n\n\t* rtlanal.c (replace_regs):  Use simplify_gen_subreg\n\nFrom-SVN: r42850", "tree": {"sha": "d351d9b0c5c56ead3c8dc57fbda5329e9a5df46f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d351d9b0c5c56ead3c8dc57fbda5329e9a5df46f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0e08ac26c828bca4b9323d3139eba9293f3ecf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0e08ac26c828bca4b9323d3139eba9293f3ecf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0e08ac26c828bca4b9323d3139eba9293f3ecf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/comments", "author": null, "committer": null, "parents": [{"sha": "95307c8e0167e5460471eecb7056913b63d6043a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95307c8e0167e5460471eecb7056913b63d6043a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95307c8e0167e5460471eecb7056913b63d6043a"}], "stats": {"total": 327, "additions": 107, "deletions": 220}, "files": [{"sha": "d387b24eaad76e9fcf4b818d76cb0e3368fd16d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0e08ac26c828bca4b9323d3139eba9293f3ecf4", "patch": "@@ -1,3 +1,32 @@\n+Mon Jun  4 16:50:33 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* simplify_rtx.c (simplify_subreg): Keep subregs on return values,\n+\tcheck CLASS_CANNOT_CHANGE_MODE before avoiding subreg on hard reg,\n+\tin case register wasn't OK previously, accept it now; allow\n+\tsubregs of frame pointer if reload completed and frame pointer\n+\tis not needed.\n+\n+\t* combine.c (sombine_simplify_rtx): Fix comment;\n+\tuse subreg_lowpart_offset instead of subreg_lowpart_p\n+\t(gen_lowpart_for_combine): Use subreg_lowpart_offset.\n+\t* rtl.h (subreg_lowpart_parts_p): Kill.\n+\t(subreg_lowpart_offset, subreg_highpart_offset): Declare.\n+\t* simplify-rtx.c (simplify_subreg): Use subreg_lowpart_offset.\n+\t* emit-rtl.c (gen_lowpart_SUBREG): Use subreg_lowpart_offset;\n+\t(gen_lowpart_common): Likewise.\n+\t(subreg_lowpart_p): Likewise.\n+\t(subreg_lowpart_parts_p): Kill.\n+\t(subreg_lowpart_offset, subreg_highpart_offset): New function.\n+\n+\t* emit-rtl.c (gen_lowpart_common): Use simplify_gen_subreg\n+\tto simplify SUBREG and REG.\n+\t(gen_highpart): Use simplify_gen_subreg for all simplifications.\n+\n+\t* emit-rtl.c (gen_realpart, gen_imagpart): Do not handle\n+\tCONCAT specially.\n+\n+\t* rtlanal.c (replace_regs):  Use simplify_gen_subreg\n+\n Mon Jun  4 09:21:19 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* tree.def (ARRAY_RANGE_REF): New code."}, {"sha": "e34ab2f3820b64d9964149ca0776291357e9ee9b", "filename": "gcc/combine.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e0e08ac26c828bca4b9323d3139eba9293f3ecf4", "patch": "@@ -3715,7 +3715,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \n   /* If CODE is an associative operation not otherwise handled, see if we\n      can associate some operands.  This can win if they are constants or\n-     if they are logically related (i.e. (a & b) & a.  */\n+     if they are logically related (i.e. (a & b) & a).  */\n   if ((code == PLUS || code == MINUS\n        || code == MULT || code == AND || code == IOR || code == XOR\n        || code == DIV || code == UDIV\n@@ -3774,7 +3774,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \n       /* simplify_subreg can't use gen_lowpart_for_combine.  */\n       if (CONSTANT_P (SUBREG_REG (x))\n-\t  && subreg_lowpart_parts_p (mode, op0_mode, SUBREG_BYTE (x)))\n+\t  && subreg_lowpart_offset (mode, op0_mode) == SUBREG_BYTE (x))\n \treturn gen_lowpart_for_combine (mode, SUBREG_REG (x));\n \n       {\n@@ -9765,18 +9765,13 @@ gen_lowpart_for_combine (mode, x)\n   else\n     {\n       int offset = 0;\n+      rtx res;\n \n-      if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n-\t  && GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (mode))\n-\t{\n-\t  int difference = (GET_MODE_SIZE (GET_MODE (x))\n-\t\t\t    - GET_MODE_SIZE (mode));\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    offset += difference % UNITS_PER_WORD;\n-\t}\n-      return gen_rtx_SUBREG (mode, x, offset);\n+      offset = subreg_lowpart_offset (mode, GET_MODE (x));\n+      res = simplify_gen_subreg (mode, x, GET_MODE (x), offset);\n+      if (res)\n+\treturn res;\n+      return gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n     }\n }\n \f"}, {"sha": "6c72a99902b5b63ad2b1d048517324be74de5f36", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 43, "deletions": 166, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e0e08ac26c828bca4b9323d3139eba9293f3ecf4", "patch": "@@ -381,22 +381,12 @@ gen_lowpart_SUBREG (mode, reg)\n      rtx reg;\n {\n   enum machine_mode inmode;\n-  int offset;\n \n   inmode = GET_MODE (reg);\n   if (inmode == VOIDmode)\n     inmode = mode;\n-  offset = 0;\n-  if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (inmode)\n-      && (WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN))\n-    {\n-      offset = GET_MODE_SIZE (inmode) - GET_MODE_SIZE (mode);\n-      if (! BYTES_BIG_ENDIAN)\n-\toffset = (offset / UNITS_PER_WORD) * UNITS_PER_WORD;\n-      else if (! WORDS_BIG_ENDIAN)\n-\toffset %= UNITS_PER_WORD;\n-    }\n-  return gen_rtx_SUBREG (mode, reg, offset);\n+  return gen_rtx_SUBREG (mode, reg,\n+\t\t\t subreg_lowpart_offset (mode, inmode));\n }\n \f\n /* rtx gen_rtx (code, mode, [element1, ..., elementn])\n@@ -761,16 +751,7 @@ gen_lowpart_common (mode, x)\n \t  > ((xsize + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)))\n     return 0;\n \n-  if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n-      && xsize > msize)\n-    {\n-      int difference = xsize - msize;\n-\n-      if (WORDS_BIG_ENDIAN)\n-\toffset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-      if (BYTES_BIG_ENDIAN)\n-\toffset += difference % UNITS_PER_WORD;\n-    }\n+  offset = subreg_lowpart_offset (mode, GET_MODE (x));\n \n   if ((GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND)\n       && (GET_MODE_CLASS (mode) == MODE_INT\n@@ -791,61 +772,8 @@ gen_lowpart_common (mode, x)\n       else if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x)))\n \treturn gen_rtx_fmt_e (GET_CODE (x), mode, XEXP (x, 0));\n     }\n-  else if (GET_CODE (x) == SUBREG\n-\t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n-\t       || GET_MODE_SIZE (mode) == GET_MODE_UNIT_SIZE (GET_MODE (x))))\n-    {\n-      int final_offset;\n-\n-      if (GET_MODE (SUBREG_REG (x)) == mode && subreg_lowpart_p (x))\n-\treturn SUBREG_REG (x);\n-\n-      /* When working with SUBREGs the rule is that the byte\n-\t offset must be a multiple of the SUBREG's mode.  */\n-      final_offset = SUBREG_BYTE (x) + offset;\n-      final_offset = (final_offset / GET_MODE_SIZE (mode));\n-      final_offset = (final_offset * GET_MODE_SIZE (mode));\n-      return gen_rtx_SUBREG (mode, SUBREG_REG (x), final_offset);   \n-    }\n-  else if (GET_CODE (x) == REG)\n-    {\n-      /* Hard registers are done specially in certain cases.  */  \n-      if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n-        {\n-\t  int final_regno = REGNO (x) +\n-\t\t\t    subreg_regno_offset (REGNO (x), GET_MODE (x), \n-\t\t\t\t\t\t offset, mode);\n-\n-\t  /* If the final regno is not valid for MODE, punt.  */\n-\t  /* ??? We do allow it if the current REG is not valid for\n-\t     ??? it's mode.  It is a kludge to work around how float/complex\n-\t     ??? arguments are passed on 32-bit Sparc and should be fixed.  */\n-\t  if (! HARD_REGNO_MODE_OK (final_regno, mode)\n-\t      && HARD_REGNO_MODE_OK (REGNO (x), GET_MODE (x)))\n-\t    return 0;\n-\n-\t       /* integrate.c can't handle parts of a return value register. */\n-\t  if ((! REG_FUNCTION_VALUE_P (x)\n-\t\t   || ! rtx_equal_function_value_matters)\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-\t       && ! (CLASS_CANNOT_CHANGE_MODE_P (mode, GET_MODE (x))\n-\t\t     && GET_MODE_CLASS (GET_MODE (x)) != MODE_COMPLEX_INT\n-\t\t     && GET_MODE_CLASS (GET_MODE (x)) != MODE_COMPLEX_FLOAT\n-\t\t     && (TEST_HARD_REG_BIT\n-\t\t\t (reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE],\n-\t\t\t  REGNO (x))))\n-#endif\n-\t       /* We want to keep the stack, frame, and arg pointers\n-\t\t  special.  */\n-\t       && x != frame_pointer_rtx\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t       && x != arg_pointer_rtx\n-#endif\n-\t       && x != stack_pointer_rtx)\n-\t    return gen_rtx_REG (mode, final_regno);\n-\t  }\n-      return gen_rtx_SUBREG (mode, x, offset);\n-    }\n+  else if (GET_CODE (x) == SUBREG || GET_CODE (x) == REG || GET_CODE (x) == CONCAT)\n+    return simplify_gen_subreg (mode, x, GET_MODE (x), offset);\n   /* If X is a CONST_INT or a CONST_DOUBLE, extract the appropriate bits\n      from the low-order part of the constant.  */\n   else if ((GET_MODE_CLASS (mode) == MODE_INT\n@@ -1088,12 +1016,10 @@ gen_realpart (mode, x)\n      enum machine_mode mode;\n      register rtx x;\n {\n-  if (GET_CODE (x) == CONCAT && GET_MODE (XEXP (x, 0)) == mode)\n-    return XEXP (x, 0);\n-  else if (WORDS_BIG_ENDIAN\n-\t   && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n-\t   && REG_P (x)\n-\t   && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+  if (WORDS_BIG_ENDIAN\n+      && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n+      && REG_P (x)\n+      && REGNO (x) < FIRST_PSEUDO_REGISTER)\n     internal_error\n       (\"Can't access real part of complex value in hard register\");\n   else if (WORDS_BIG_ENDIAN)\n@@ -1110,9 +1036,7 @@ gen_imagpart (mode, x)\n      enum machine_mode mode;\n      register rtx x;\n {\n-  if (GET_CODE (x) == CONCAT && GET_MODE (XEXP (x, 0)) == mode)\n-    return XEXP (x, 1);\n-  else if (WORDS_BIG_ENDIAN)\n+  if (WORDS_BIG_ENDIAN)\n     return gen_lowpart (mode, x);\n   else if (! WORDS_BIG_ENDIAN\n \t   && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n@@ -1195,109 +1119,62 @@ gen_highpart (mode, x)\n      register rtx x;\n {\n   unsigned int msize = GET_MODE_SIZE (mode);\n-  unsigned int xsize = GET_MODE_SIZE (GET_MODE (x));\n+  rtx result;\n \n   /* This case loses if X is a subreg.  To catch bugs early,\n      complain if an invalid MODE is used even in other cases.  */\n   if (msize > UNITS_PER_WORD\n       && msize != GET_MODE_UNIT_SIZE (GET_MODE (x)))\n     abort ();\n-  if (GET_CODE (x) == CONST_DOUBLE\n-#if !(TARGET_FLOAT_FORMAT != HOST_FLOAT_FORMAT || defined (REAL_IS_NOT_DOUBLE))\n-      && GET_MODE_CLASS (GET_MODE (x)) != MODE_FLOAT\n-#endif\n-      )\n-    return GEN_INT (CONST_DOUBLE_HIGH (x) & GET_MODE_MASK (mode));\n-  else if (GET_CODE (x) == CONST_INT)\n-    {\n-      if (HOST_BITS_PER_WIDE_INT <= BITS_PER_WORD)\n-\treturn const0_rtx;\n-      return GEN_INT (INTVAL (x) >> (HOST_BITS_PER_WIDE_INT - BITS_PER_WORD));\n-    }\n-  else if (GET_CODE (x) == MEM)\n-    {\n-      register int offset = 0;\n \n-      if (! WORDS_BIG_ENDIAN)\n-\toffset = (MAX (xsize, UNITS_PER_WORD)\n-\t\t  - MAX (msize, UNITS_PER_WORD));\n+  result = simplify_gen_subreg (mode, x, GET_MODE (x),\n+\t\t\t\tsubreg_highpart_offset (mode, GET_MODE (x)));\n+  if (!result)\n+    abort ();\n+  return result;\n+}\n+/* Return offset in bytes to get OUTERMODE low part\n+   of the value in mode INNERMODE stored in memory in target format.  */\n \n-      if (! BYTES_BIG_ENDIAN\n-\t  && msize < UNITS_PER_WORD)\n-\toffset -= (msize - MIN (UNITS_PER_WORD, xsize));\n+unsigned int\n+subreg_lowpart_offset (outermode, innermode)\n+     enum machine_mode outermode, innermode;\n+{\n+  unsigned int offset = 0;\n+  int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n \n-      return change_address (x, mode, plus_constant (XEXP (x, 0), offset));\n-    }\n-  else if (GET_CODE (x) == SUBREG)\n+  if (difference > 0)\n     {\n-      /* The only time this should occur is when we are looking at a\n-\t multi-word item with a SUBREG whose mode is the same as that of the\n-\t item.  It isn't clear what we would do if it wasn't.  */\n-      if (SUBREG_BYTE (x) != 0)\n-\tabort ();\n-      return gen_highpart (mode, SUBREG_REG (x));\n+      if (WORDS_BIG_ENDIAN)\n+\toffset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n+      if (BYTES_BIG_ENDIAN)\n+\toffset += difference % UNITS_PER_WORD;\n     }\n-  else if (GET_CODE (x) == REG)\n-    {\n-      int offset = 0;\n-\n-      if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode))\n-\tabort ();\n-\n-      if ((! WORDS_BIG_ENDIAN || ! BYTES_BIG_ENDIAN)\n-\t  && xsize > msize)\n-\t{\n-\t  int difference = xsize - msize;\n \n-\t  if (! WORDS_BIG_ENDIAN)\n-\t    offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t  if (! BYTES_BIG_ENDIAN)\n-\t    offset += difference % UNITS_PER_WORD;\n-\t}\n-      if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  int final_regno = REGNO (x) +\n-\t    subreg_regno_offset (REGNO (x), GET_MODE (x), offset, mode);\n-\n-\t  /* integrate.c can't handle parts of a return value register.\n-\t     ??? Then integrate.c should be fixed!\n-\t     ??? What about CLASS_CANNOT_CHANGE_SIZE?  */\n-\t  if ((! REG_FUNCTION_VALUE_P (x)\n-\t       || ! rtx_equal_function_value_matters)\n-\t  /* We want to keep the stack, frame, and arg pointers special.  */\n-\t      && x != frame_pointer_rtx\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\t\n-\t      && x != arg_pointer_rtx\n-#endif\n-\t      && x != stack_pointer_rtx)\n-\t    return gen_rtx_REG (mode, final_regno);\n-\t}\n-      /* Just generate a normal SUBREG.  */\n-      return gen_rtx_SUBREG (mode, x, offset); \n-    }\n-  else\n-    abort ();\n+  return offset;\n }\n-/* Return 1 iff (SUBREG:outermode (OP:innermode) byte)\n-   refers to the least significant part of its containing reg.  */\n \n-int\n-subreg_lowpart_parts_p (outermode, innermode, byte)\n+/* Return offset in bytes to get OUTERMODE high part\n+   of the value in mode INNERMODE stored in memory in target format.  */\n+unsigned int\n+subreg_highpart_offset (outermode, innermode)\n      enum machine_mode outermode, innermode;\n-     unsigned int byte;\n {\n   unsigned int offset = 0;\n   int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n \n+  if (GET_MODE_SIZE (innermode) < GET_MODE_SIZE (outermode))\n+     abort ();\n+\n   if (difference > 0)\n     {\n-      if (WORDS_BIG_ENDIAN)\n+      if (! WORDS_BIG_ENDIAN)\n \toffset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-      if (BYTES_BIG_ENDIAN)\n+      if (! BYTES_BIG_ENDIAN)\n \toffset += difference % UNITS_PER_WORD;\n     }\n \n-  return byte == offset;\n+  return offset;\n }\n \n /* Return 1 iff X, assumed to be a SUBREG,\n@@ -1313,8 +1190,8 @@ subreg_lowpart_p (x)\n   else if (GET_MODE (SUBREG_REG (x)) == VOIDmode)\n     return 0;\n \n-  return subreg_lowpart_parts_p (GET_MODE (x), GET_MODE (SUBREG_REG (x)),\n-\t\t \t\t SUBREG_BYTE (x));\n+  return (subreg_lowpart_offset (GET_MODE (x), GET_MODE (SUBREG_REG (x)))\n+\t  == SUBREG_BYTE (x));\n }\n \f\n "}, {"sha": "1cc0d7391e9bc21240f57020a36825f2a15a6951", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e0e08ac26c828bca4b9323d3139eba9293f3ecf4", "patch": "@@ -1198,9 +1198,10 @@ extern rtx constant_subword\t\tPARAMS ((rtx, int,\n extern rtx operand_subword_force\tPARAMS ((rtx, unsigned int,\n \t\t\t\t\t\t enum machine_mode));\n extern int subreg_lowpart_p\t\tPARAMS ((rtx));\n-extern int subreg_lowpart_parts_p\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t unsigned int));\n+extern unsigned int subreg_lowpart_offset PARAMS ((enum machine_mode,\n+\t\t\t\t\t\t   enum machine_mode));\n+extern unsigned int subreg_highpart_offset PARAMS ((enum machine_mode,\n+\t\t\t\t\t\t    enum machine_mode));\n extern rtx make_safe_from\t\tPARAMS ((rtx, rtx));\n extern rtx convert_memory_address\tPARAMS ((enum machine_mode, rtx));\n extern rtx get_insns\t\t\tPARAMS ((void));"}, {"sha": "0f0f6cd1fc54643e7f7a27a2f2b3c06d931605c2", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e0e08ac26c828bca4b9323d3139eba9293f3ecf4", "patch": "@@ -2258,40 +2258,9 @@ replace_regs (x, reg_map, nregs, replace_dest)\n \t  && GET_CODE (reg_map[REGNO (SUBREG_REG (x))]) == SUBREG)\n \t{\n \t  rtx map_val = reg_map[REGNO (SUBREG_REG (x))];\n-\t  rtx map_inner = SUBREG_REG (map_val);\n-\n-\t  if (GET_MODE (x) == GET_MODE (map_inner))\n-\t    return map_inner;\n-\t  else\n-\t    {\n-\t      int final_offset = SUBREG_BYTE (x) + SUBREG_BYTE (map_val);\n-\n-\t      /* When working with REG SUBREGs the rule is that the byte\n-\t\t offset must be a multiple of the SUBREG's mode.  */\n-\t      final_offset = (final_offset / GET_MODE_SIZE (GET_MODE (x)));\n-\t      final_offset = (final_offset * GET_MODE_SIZE (GET_MODE (x)));\n-\n-\t      /* We cannot call gen_rtx here since we may be linked with\n-\t\t genattrtab.c.  */\n-\t      /* Let's try clobbering the incoming SUBREG and see\n-\t\t if this is really safe.  */\n-\t      SUBREG_REG (x) = map_inner;\n-\t      SUBREG_BYTE (x) = final_offset;\n-\t      return x;\n-#if 0\n-\t      rtx new = rtx_alloc (SUBREG);\n-\t      int final_offset = SUBREG_BYTE (x) + SUBREG_BYTE (map_val);\n-\n-\t      /* When working with REG SUBREGs the rule is that the byte\n-\t\t offset must be a multiple of the SUBREG's mode.  */\n-\t      final_offset = (final_offset / GET_MODE_SIZE (GET_MODE (x)));\n-\t      final_offset = (final_offset * GET_MODE_SIZE (GET_MODE (x)));\n-\n-\t      PUT_MODE (new, GET_MODE (x));\n-\t      SUBREG_REG (new) = map_inner;\n-\t      SUBREG_BYTE (new) = final_offset;\n-#endif\n-\t    }\n+\t  return simplify_gen_subreg (GET_MODE (x), map_val,\n+\t\t\t\t      GET_MODE (SUBREG_REG (x)), \n+\t\t\t\t      SUBREG_BYTE (x));\n \t}\n       break;\n "}, {"sha": "aef9b55e20706d81e921daacd376ba1ead85182d", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e08ac26c828bca4b9323d3139eba9293f3ecf4/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=e0e08ac26c828bca4b9323d3139eba9293f3ecf4", "patch": "@@ -2215,7 +2215,7 @@ simplify_subreg (outermode, op, innermode, byte)\n \t Later it we should move all simplification code here and rewrite\n \t GEN_LOWPART_IF_POSSIBLE, GEN_HIGHPART, OPERAND_SUBWORD and friends\n \t using SIMPLIFY_SUBREG.  */\n-      if (subreg_lowpart_parts_p (outermode, innermode, byte))\n+      if (subreg_lowpart_offset (outermode, innermode) == byte)\n \t{\n \t  rtx new = gen_lowpart_if_possible (outermode, op);\n \t  if (new)\n@@ -2347,11 +2347,23 @@ simplify_subreg (outermode, op, innermode, byte)\n      frame, or argument pointer, leave this as a SUBREG.  */\n \n   if (REG_P (op)\n+      && (! REG_FUNCTION_VALUE_P (op)\n+\t  || ! rtx_equal_function_value_matters)\n+#ifdef CLASS_CANNOT_CHANGE_MODE\n+      && ! (CLASS_CANNOT_CHANGE_MODE_P (outermode, innermode)\n+\t    && GET_MODE_CLASS (innermode) != MODE_COMPLEX_INT\n+\t    && GET_MODE_CLASS (innermode) != MODE_COMPLEX_FLOAT\n+\t    && (TEST_HARD_REG_BIT\n+\t\t(reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE],\n+\t\t REGNO (op))))\n+#endif\n       && REGNO (op) < FIRST_PSEUDO_REGISTER\n-      && REGNO (op) != FRAME_POINTER_REGNUM\n+      && ((reload_completed && !frame_pointer_needed)\n+\t  || (REGNO (op) != FRAME_POINTER_REGNUM\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-      && REGNO (op) != HARD_FRAME_POINTER_REGNUM\n+\t      && REGNO (op) != HARD_FRAME_POINTER_REGNUM\n #endif\n+\t     ))\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n       && REGNO (op) != ARG_POINTER_REGNUM\n #endif\n@@ -2360,7 +2372,11 @@ simplify_subreg (outermode, op, innermode, byte)\n       int final_regno = subreg_hard_regno (gen_rtx_SUBREG (outermode, op, byte),\n \t\t\t\t\t   0);\n \n-      if (HARD_REGNO_MODE_OK (final_regno, outermode))\n+      /* ??? We do allow it if the current REG is not valid for\n+\t its mode.  This is a kludge to work around how float/complex\n+\t arguments are passed on 32-bit Sparc and should be fixed.  */\n+      if (HARD_REGNO_MODE_OK (final_regno, outermode)\n+\t  || ! HARD_REGNO_MODE_OK (REGNO (op), innermode))\n \treturn gen_rtx_REG (outermode, final_regno);\n     }\n "}]}