{"sha": "be384c108068d1adfa0ee38aee0052e24ad0ca30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUzODRjMTA4MDY4ZDFhZGZhMGVlMzhhZWUwMDUyZTI0YWQwY2EzMA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2012-10-26T16:13:00Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2012-10-26T16:13:00Z"}, "message": "re PR debug/54971 (SRA pessimizes debug info by not creating debug stmts for fields without replacements)\n\n2012-10-26  Martin Jambor  <mjambor@suse.cz>\n\n\tPR debug/54971\n\t* tree-sra.c (struct access): New flag grp_to_be_debug_replaced.\n\t(dump_access): Dump the new flag.\n\t(analyze_access_subtree): Set the new flag when appropriate.\n\t(create_access_replacement): Handle debug replacements differently.\n\t(generate_subtree_copies): Handle the grp_to_be_debug_replaced flag.\n\t(init_subtree_with_zero): Likewise.\n\t(sra_modify_expr): Likewise.\n\t(load_assign_lhs_subreplacements): Likewise.\n\t(sra_modify_assign): Likewise.\n\nFrom-SVN: r192848", "tree": {"sha": "2a22a1751741421348dda229ac94c51378fe7c49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a22a1751741421348dda229ac94c51378fe7c49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be384c108068d1adfa0ee38aee0052e24ad0ca30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be384c108068d1adfa0ee38aee0052e24ad0ca30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be384c108068d1adfa0ee38aee0052e24ad0ca30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be384c108068d1adfa0ee38aee0052e24ad0ca30/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a4bbf9102beb453e35cbe49e644129a7e111da2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4bbf9102beb453e35cbe49e644129a7e111da2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4bbf9102beb453e35cbe49e644129a7e111da2f"}], "stats": {"total": 180, "additions": 166, "deletions": 14}, "files": [{"sha": "fcd9f5c6fdc606cc5aec30eff4afd0df04329b5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be384c108068d1adfa0ee38aee0052e24ad0ca30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be384c108068d1adfa0ee38aee0052e24ad0ca30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be384c108068d1adfa0ee38aee0052e24ad0ca30", "patch": "@@ -1,3 +1,16 @@\n+2012-10-26  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR debug/54971\n+\t* tree-sra.c (struct access): New flag grp_to_be_debug_replaced.\n+\t(dump_access): Dump the new flag.\n+\t(analyze_access_subtree): Set the new flag when appropriate.\n+\t(create_access_replacement): Handle debug replacements differently.\n+\t(generate_subtree_copies): Handle the grp_to_be_debug_replaced flag.\n+\t(init_subtree_with_zero): Likewise.\n+\t(sra_modify_expr): Likewise.\n+\t(load_assign_lhs_subreplacements): Likewise.\n+\t(sra_modify_assign): Likewise.\n+\n 2012-10-23  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \t* config/i386/i386.c (insn_is_function_arg) : Add check on CALL"}, {"sha": "65b5ef59e151c9344c249f64baa292c762eb7a3b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 153, "deletions": 14, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be384c108068d1adfa0ee38aee0052e24ad0ca30/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be384c108068d1adfa0ee38aee0052e24ad0ca30/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=be384c108068d1adfa0ee38aee0052e24ad0ca30", "patch": "@@ -227,6 +227,10 @@ struct access\n   /* Set when a scalar replacement should be created for this variable.  */\n   unsigned grp_to_be_replaced : 1;\n \n+  /* Set when we want a replacement for the sole purpose of having it in\n+     generated debug statements.  */\n+  unsigned grp_to_be_debug_replaced : 1;\n+\n   /* Should TREE_NO_WARNING of a replacement be set?  */\n   unsigned grp_no_warning : 1;\n \n@@ -390,15 +394,15 @@ dump_access (FILE *f, struct access *access, bool grp)\n \t     \"grp_hint = %d, grp_covered = %d, \"\n \t     \"grp_unscalarizable_region = %d, grp_unscalarized_data = %d, \"\n \t     \"grp_partial_lhs = %d, grp_to_be_replaced = %d, \"\n-\t     \"grp_maybe_modified = %d, \"\n+\t     \"grp_to_be_debug_replaced = %d, grp_maybe_modified = %d, \"\n \t     \"grp_not_necessarilly_dereferenced = %d\\n\",\n \t     access->grp_read, access->grp_write, access->grp_assignment_read,\n \t     access->grp_assignment_write, access->grp_scalar_read,\n \t     access->grp_scalar_write, access->grp_total_scalarization,\n \t     access->grp_hint, access->grp_covered,\n \t     access->grp_unscalarizable_region, access->grp_unscalarized_data,\n \t     access->grp_partial_lhs, access->grp_to_be_replaced,\n-\t     access->grp_maybe_modified,\n+\t     access->grp_to_be_debug_replaced, access->grp_maybe_modified,\n \t     access->grp_not_necessarilly_dereferenced);\n   else\n     fprintf (f, \", write = %d, grp_total_scalarization = %d, \"\n@@ -1528,6 +1532,43 @@ build_ref_for_model (location_t loc, tree base, HOST_WIDE_INT offset,\n \t\t\t\t gsi, insert_after);\n }\n \n+/* Attempt to build a memory reference that we could but into a gimple\n+   debug_bind statement.  Similar to build_ref_for_model but punts if it has to\n+   create statements and return s NULL instead.  This function also ignores\n+   alignment issues and so its results should never end up in non-debug\n+   statements.  */\n+\n+static tree\n+build_debug_ref_for_model (location_t loc, tree base, HOST_WIDE_INT offset,\n+\t\t\t   struct access *model)\n+{\n+  HOST_WIDE_INT base_offset;\n+  tree off;\n+\n+  if (TREE_CODE (model->expr) == COMPONENT_REF\n+      && DECL_BIT_FIELD (TREE_OPERAND (model->expr, 1)))\n+    return NULL_TREE;\n+\n+  base = get_addr_base_and_unit_offset (base, &base_offset);\n+  if (!base)\n+    return NULL_TREE;\n+  if (TREE_CODE (base) == MEM_REF)\n+    {\n+      off = build_int_cst (TREE_TYPE (TREE_OPERAND (base, 1)),\n+\t\t\t   base_offset + offset / BITS_PER_UNIT);\n+      off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1), off);\n+      base = unshare_expr (TREE_OPERAND (base, 0));\n+    }\n+  else\n+    {\n+      off = build_int_cst (reference_alias_ptr_type (base),\n+\t\t\t   base_offset + offset / BITS_PER_UNIT);\n+      base = build_fold_addr_expr (unshare_expr (base));\n+    }\n+\n+  return fold_build2_loc (loc, MEM_REF, model->type, base, off);\n+}\n+\n /* Construct a memory reference consisting of component_refs and array_refs to\n    a part of an aggregate *RES (which is of type TYPE).  The requested part\n    should have type EXP_TYPE at be the given OFFSET.  This function might not\n@@ -1861,7 +1902,13 @@ create_access_replacement (struct access *access)\n {\n   tree repl;\n \n-  repl = create_tmp_var (access->type, \"SR\");\n+  if (access->grp_to_be_debug_replaced)\n+    {\n+      repl = create_tmp_var_raw (access->type, NULL);\n+      DECL_CONTEXT (repl) = current_function_decl;\n+    }\n+  else\n+    repl = create_tmp_var (access->type, \"SR\");\n   if (TREE_CODE (access->type) == COMPLEX_TYPE\n       || TREE_CODE (access->type) == VECTOR_TYPE)\n     {\n@@ -1930,12 +1977,22 @@ create_access_replacement (struct access *access)\n \n   if (dump_file)\n     {\n-      fprintf (dump_file, \"Created a replacement for \");\n-      print_generic_expr (dump_file, access->base, 0);\n-      fprintf (dump_file, \" offset: %u, size: %u: \",\n-\t       (unsigned) access->offset, (unsigned) access->size);\n-      print_generic_expr (dump_file, repl, 0);\n-      fprintf (dump_file, \"\\n\");\n+      if (access->grp_to_be_debug_replaced)\n+\t{\n+\t  fprintf (dump_file, \"Created a debug-only replacement for \");\n+\t  print_generic_expr (dump_file, access->base, 0);\n+\t  fprintf (dump_file, \" offset: %u, size: %u\\n\",\n+\t\t   (unsigned) access->offset, (unsigned) access->size);\n+\t}\n+      else\n+\t{\n+\t  fprintf (dump_file, \"Created a replacement for \");\n+\t  print_generic_expr (dump_file, access->base, 0);\n+\t  fprintf (dump_file, \" offset: %u, size: %u: \",\n+\t\t   (unsigned) access->offset, (unsigned) access->size);\n+\t  print_generic_expr (dump_file, repl, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n     }\n   sra_stats.replacements++;\n \n@@ -2144,6 +2201,23 @@ analyze_access_subtree (struct access *root, struct access *parent,\n     }\n   else\n     {\n+      if (MAY_HAVE_DEBUG_STMTS && allow_replacements\n+\t  && scalar && !root->first_child\n+\t  && (root->grp_scalar_write || root->grp_assignment_write))\n+\t{\n+\t  gcc_checking_assert (!root->grp_scalar_read\n+\t\t\t       && !root->grp_assignment_read);\n+\t  root->grp_to_be_debug_replaced = 1;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Marking \");\n+\t      print_generic_expr (dump_file, root->base, 0);\n+\t      fprintf (dump_file, \" offset: %u, size: %u \",\n+\t\t       (unsigned) root->offset, (unsigned) root->size);\n+\t      fprintf (dump_file, \" to be replaced with debug statements.\\n\");\n+\t    }\n+\t}\n+\n       if (covered_to < limit)\n \thole = true;\n       if (scalar)\n@@ -2504,6 +2578,22 @@ generate_subtree_copies (struct access *access, tree agg,\n \t  update_stmt (stmt);\n \t  sra_stats.subtree_copies++;\n \t}\n+      else if (write\n+\t       && access->grp_to_be_debug_replaced\n+\t       && (chunk_size == 0\n+\t\t   || access->offset + access->size > start_offset))\n+\t{\n+\t  gimple ds;\n+\t  tree drhs = build_debug_ref_for_model (loc, agg,\n+\t\t\t\t\t\t access->offset - top_offset,\n+\t\t\t\t\t\t access);\n+\t  ds = gimple_build_debug_bind (get_access_replacement (access),\n+\t\t\t\t\tdrhs, gsi_stmt (*gsi));\n+\t  if (insert_after)\n+\t    gsi_insert_after (gsi, ds, GSI_NEW_STMT);\n+\t  else\n+\t    gsi_insert_before (gsi, ds, GSI_SAME_STMT);\n+\t}\n \n       if (access->first_child)\n \tgenerate_subtree_copies (access->first_child, agg, top_offset,\n@@ -2540,6 +2630,16 @@ init_subtree_with_zero (struct access *access, gimple_stmt_iterator *gsi,\n       update_stmt (stmt);\n       gimple_set_location (stmt, loc);\n     }\n+  else if (access->grp_to_be_debug_replaced)\n+    {\n+      gimple ds = gimple_build_debug_bind (get_access_replacement (access),\n+\t\t\t\t\t   build_zero_cst (access->type),\n+\t\t\t\t\t   gsi_stmt (*gsi));\n+      if (insert_after)\n+\tgsi_insert_after (gsi, ds, GSI_NEW_STMT);\n+      else\n+\tgsi_insert_before (gsi, ds, GSI_SAME_STMT);\n+    }\n \n   for (child = access->first_child; child; child = child->next_sibling)\n     init_subtree_with_zero (child, gsi, insert_after, loc);\n@@ -2646,6 +2746,13 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n \t*expr = repl;\n       sra_stats.exprs++;\n     }\n+  else if (write && access->grp_to_be_debug_replaced)\n+    {\n+      gimple ds = gimple_build_debug_bind (get_access_replacement (access),\n+\t\t\t\t\t   NULL_TREE,\n+\t\t\t\t\t   gsi_stmt (*gsi));\n+      gsi_insert_after (gsi, ds, GSI_NEW_STMT);\n+    }\n \n   if (access->first_child)\n     {\n@@ -2721,10 +2828,11 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n   location_t loc = gimple_location (gsi_stmt (*old_gsi));\n   for (lacc = lacc->first_child; lacc; lacc = lacc->next_sibling)\n     {\n+      HOST_WIDE_INT offset = lacc->offset - left_offset + top_racc->offset;\n+\n       if (lacc->grp_to_be_replaced)\n \t{\n \t  struct access *racc;\n-\t  HOST_WIDE_INT offset = lacc->offset - left_offset + top_racc->offset;\n \t  gimple stmt;\n \t  tree rhs;\n \n@@ -2764,10 +2872,34 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t  update_stmt (stmt);\n \t  sra_stats.subreplacements++;\n \t}\n-      else if (*refreshed == SRA_UDH_NONE\n-\t       && lacc->grp_read && !lacc->grp_covered)\n-\t*refreshed = handle_unscalarized_data_in_subtree (top_racc,\n-\t\t\t\t\t\t\t  old_gsi);\n+      else\n+\t{\n+\t  if (*refreshed == SRA_UDH_NONE\n+\t      && lacc->grp_read && !lacc->grp_covered)\n+\t    *refreshed = handle_unscalarized_data_in_subtree (top_racc,\n+\t\t\t\t\t\t\t      old_gsi);\n+\t  if (lacc && lacc->grp_to_be_debug_replaced)\n+\t    {\n+\t      gimple ds;\n+\t      tree drhs;\n+\t      struct access *racc = find_access_in_subtree (top_racc, offset,\n+\t\t\t\t\t\t\t    lacc->size);\n+\n+\t      if (racc && racc->grp_to_be_replaced)\n+\t\tdrhs = get_access_replacement (racc);\n+\t      else if (*refreshed == SRA_UDH_LEFT)\n+\t\tdrhs = build_debug_ref_for_model (loc, lacc->base, lacc->offset,\n+\t\t\t\t\t\t  lacc);\n+\t      else if (*refreshed == SRA_UDH_RIGHT)\n+\t\tdrhs = build_debug_ref_for_model (loc, top_racc->base, offset,\n+\t\t\t\t\t\t  lacc);\n+\t      else\n+\t\tdrhs = NULL_TREE;\n+\t      ds = gimple_build_debug_bind (get_access_replacement (lacc),\n+\t\t\t\t\t    drhs, gsi_stmt (*old_gsi));\n+\t      gsi_insert_after (new_gsi, ds, GSI_NEW_STMT);\n+\t    }\n+\t}\n \n       if (lacc->first_child)\n \tload_assign_lhs_subreplacements (lacc, top_racc, left_offset,\n@@ -2982,6 +3114,13 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \t}\n     }\n \n+  if (lacc && lacc->grp_to_be_debug_replaced)\n+    {\n+      gimple ds = gimple_build_debug_bind (get_access_replacement (lacc),\n+\t\t\t\t\t   unshare_expr (rhs), *stmt);\n+      gsi_insert_before (gsi, ds, GSI_SAME_STMT);\n+    }\n+\n   /* From this point on, the function deals with assignments in between\n      aggregates when at least one has scalar reductions of some of its\n      components.  There are three possible scenarios: Both the LHS and RHS have"}]}