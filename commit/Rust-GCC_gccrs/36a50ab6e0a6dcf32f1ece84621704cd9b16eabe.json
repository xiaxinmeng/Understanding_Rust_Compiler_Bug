{"sha": "36a50ab6e0a6dcf32f1ece84621704cd9b16eabe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZhNTBhYjZlMGE2ZGNmMzJmMWVjZTg0NjIxNzA0Y2Q5YjE2ZWFiZQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-10-04T08:23:03Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-10-04T08:23:03Z"}, "message": "re PR target/50566 ([avr]: Add support for better logging similar to -mdeb)\n\n\tPR target/50566\n\t* config/avr/avr-protos.h (avr_legitimize_reload_address): New\n\tprototype.\n\t* config/avr/avr.h (LEGITIMIZE_RELOAD_ADDRESS): Copy worker code\n\tfrom here...\n\t* config/avr/avr.c (avr_legitimize_reload_address) ...to this new\n\tfunction.  Log if avr_log.legitimize_reload_address.\n\nFrom-SVN: r179494", "tree": {"sha": "d08dc1bd52e3e3783e18340ff55d3876a8ec106c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d08dc1bd52e3e3783e18340ff55d3876a8ec106c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "437bcafa1adcc9693a6437b410c98e17b1f78dbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437bcafa1adcc9693a6437b410c98e17b1f78dbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/437bcafa1adcc9693a6437b410c98e17b1f78dbe"}], "stats": {"total": 148, "additions": 103, "deletions": 45}, "files": [{"sha": "eddcd1ce251d4cb01c93ba866aeb24ec2f56ccfe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36a50ab6e0a6dcf32f1ece84621704cd9b16eabe", "patch": "@@ -1,3 +1,13 @@\n+2011-10-04  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/50566\n+\t* config/avr/avr-protos.h (avr_legitimize_reload_address): New\n+\tprototype.\n+\t* config/avr/avr.h (LEGITIMIZE_RELOAD_ADDRESS): Copy worker code\n+\tfrom here...\n+\t* config/avr/avr.c (avr_legitimize_reload_address) ...to this new\n+\tfunction.  Log if avr_log.legitimize_reload_address.\n+\n 2011-10-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc.c (sparc_fold_builtin): Use a sequence of tests."}, {"sha": "7ad0f1c04a3b01ee55b017f2724271ba6ab6f487", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=36a50ab6e0a6dcf32f1ece84621704cd9b16eabe", "patch": "@@ -106,6 +106,7 @@ extern RTX_CODE avr_normalize_condition (RTX_CODE condition);\n extern void out_shift_with_cnt (const char *templ, rtx insn,\n \t\t\t\trtx operands[], int *len, int t_len);\n extern rtx avr_incoming_return_addr_rtx (void);\n+extern rtx avr_legitimize_reload_address (rtx, enum machine_mode, int, int, int, int, rtx (*)(rtx,int));\n #endif /* RTX_CODE */\n \n #ifdef REAL_VALUE_TYPE"}, {"sha": "e6cb2140924bde912270432876ed61709453f56b", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=36a50ab6e0a6dcf32f1ece84621704cd9b16eabe", "patch": "@@ -1290,6 +1290,87 @@ avr_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n }\n \n \n+/* Implement `LEGITIMIZE_RELOAD_ADDRESS'.  */\n+/* This will allow register R26/27 to be used where it is no worse than normal\n+   base pointers R28/29 or R30/31.  For example, if base offset is greater\n+   than 63 bytes or for R++ or --R addressing.  */\n+\n+rtx\n+avr_legitimize_reload_address (rtx x, enum machine_mode mode,\n+                               int opnum, int type, int addr_type,\n+                               int ind_levels ATTRIBUTE_UNUSED,\n+                               rtx (*mk_memloc)(rtx,int))\n+{\n+  if (avr_log.legitimize_reload_address)\n+    avr_edump (\"\\n%?:%m %r\\n\", mode, x);\n+  \n+  if (1 && (GET_CODE (x) == POST_INC\n+            || GET_CODE (x) == PRE_DEC))\n+    {\n+      push_reload (XEXP (x, 0), XEXP (x, 0), &XEXP (x, 0), &XEXP (x, 0),\n+                   POINTER_REGS, GET_MODE (x), GET_MODE (x), 0, 0,\n+                   opnum, RELOAD_OTHER);\n+      \n+      if (avr_log.legitimize_reload_address)\n+        avr_edump (\" RCLASS = %R\\n IN = %r\\n OUT = %r\\n\",\n+                   POINTER_REGS, XEXP (x, 0), XEXP (x, 0));\n+      \n+      return x;\n+    }\n+  \n+  if (GET_CODE (x) == PLUS\n+      && REG_P (XEXP (x, 0))\n+      && 0 == reg_equiv_constant (REGNO (XEXP (x, 0)))\n+      && CONST_INT_P (XEXP (x, 1))\n+      && INTVAL (XEXP (x, 1)) >= 1)\n+    {\n+      bool fit = INTVAL (XEXP (x, 1)) <= MAX_LD_OFFSET (mode);\n+      \n+      if (fit)\n+        {\n+          if (reg_equiv_address (REGNO (XEXP (x, 0))) != 0)\n+            {\n+              int regno = REGNO (XEXP (x, 0));\n+              rtx mem = mk_memloc (x, regno);\n+              \n+              push_reload (XEXP (mem, 0), NULL_RTX, &XEXP (mem, 0), NULL,\n+                           POINTER_REGS, Pmode, VOIDmode, 0, 0,\n+                           1, addr_type);\n+              \n+              if (avr_log.legitimize_reload_address)\n+                avr_edump (\" RCLASS = %R\\n IN = %r\\n OUT = %r\\n\",\n+                           POINTER_REGS, XEXP (mem, 0), NULL_RTX);\n+              \n+              push_reload (mem, NULL_RTX, &XEXP (x, 0), NULL,\n+                           BASE_POINTER_REGS, GET_MODE (x), VOIDmode, 0, 0,\n+                           opnum, type);\n+              \n+              if (avr_log.legitimize_reload_address)\n+                avr_edump (\" RCLASS = %R\\n IN = %r\\n OUT = %r\\n\",\n+                           BASE_POINTER_REGS, mem, NULL_RTX);\n+              \n+              return x;\n+            }\n+        }\n+      else if (! (frame_pointer_needed\n+                  && XEXP (x, 0) == frame_pointer_rtx))\n+        {\n+          push_reload (x, NULL_RTX, &x, NULL,\n+                       POINTER_REGS, GET_MODE (x), VOIDmode, 0, 0,\n+                       opnum, type);\n+          \n+          if (avr_log.legitimize_reload_address)\n+            avr_edump (\" RCLASS = %R\\n IN = %r\\n OUT = %r\\n\",\n+                       POINTER_REGS, x, NULL_RTX);\n+          \n+          return x;\n+        }\n+    }\n+  \n+  return NULL_RTX;\n+}\n+\n+\n /* Helper function to print assembler resp. track instruction\n    sequence lengths.\n    "}, {"sha": "51bd942cf56e97723d4149ff2e558a7741a0b705", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 11, "deletions": 45, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a50ab6e0a6dcf32f1ece84621704cd9b16eabe/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=36a50ab6e0a6dcf32f1ece84621704cd9b16eabe", "patch": "@@ -385,51 +385,17 @@ typedef struct avr_args {\n   (REGNO (X) >= FIRST_PSEUDO_REGISTER || REG_OK_FOR_BASE_STRICT_P(X))\n \n #define REG_OK_FOR_BASE_STRICT_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-/* LEGITIMIZE_RELOAD_ADDRESS will allow register R26/27 to be used, where it\n-   is no worse than normal base pointers R28/29 and R30/31. For example:\n-   If base offset is greater than 63 bytes or for R++ or --R addressing.  */\n-   \n-#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)    \\\n-do {\t\t\t\t\t\t\t\t\t    \\\n-  if (1&&(GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC))\t    \\\n-    {\t\t\t\t\t\t\t\t\t    \\\n-      push_reload (XEXP (X,0), XEXP (X,0), &XEXP (X,0), &XEXP (X,0),\t    \\\n-\t           POINTER_REGS, GET_MODE (X),GET_MODE (X) , 0, 0,\t    \\\n-\t\t   OPNUM, RELOAD_OTHER);\t\t\t\t    \\\n-      goto WIN;\t\t\t\t\t\t\t\t    \\\n-    }\t\t\t\t\t\t\t\t\t    \\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t    \\\n-      && REG_P (XEXP (X, 0))\t\t\t\t\t\t    \\\n-      && (reg_equiv_constant (REGNO (XEXP (X, 0))) == 0)\t\t    \\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t    \\\n-      && INTVAL (XEXP (X, 1)) >= 1)\t\t\t\t\t    \\\n-    {\t\t\t\t\t\t\t\t\t    \\\n-      int fit = INTVAL (XEXP (X, 1)) <= (64 - GET_MODE_SIZE (MODE));\t    \\\n-      if (fit)\t\t\t\t\t\t\t\t    \\\n-\t{\t\t\t\t\t\t\t\t    \\\n-          if (reg_equiv_address (REGNO (XEXP (X, 0))) != 0)\t\t    \\\n-\t    {\t\t\t\t\t\t\t\t    \\\n-\t      int regno = REGNO (XEXP (X, 0));\t\t\t\t    \\\n-\t      rtx mem = make_memloc (X, regno);\t\t\t\t    \\\n-\t      push_reload (XEXP (mem,0), NULL, &XEXP (mem,0), NULL,         \\\n-\t\t           POINTER_REGS, Pmode, VOIDmode, 0, 0,\t\t    \\\n-\t\t           1, ADDR_TYPE (TYPE));\t\t\t    \\\n-\t      push_reload (mem, NULL_RTX, &XEXP (X, 0), NULL,\t\t    \\\n-\t\t           BASE_POINTER_REGS, GET_MODE (X), VOIDmode, 0, 0, \\\n-\t\t           OPNUM, TYPE);\t\t\t\t    \\\n-\t      goto WIN;\t\t\t\t\t\t\t    \\\n-\t    }\t\t\t\t\t\t\t\t    \\\n-\t}\t\t\t\t\t\t\t\t    \\\n-      else if (! (frame_pointer_needed && XEXP (X,0) == frame_pointer_rtx)) \\\n-\t{\t\t\t\t\t\t\t\t    \\\n-\t  push_reload (X, NULL_RTX, &X, NULL,\t\t\t\t    \\\n-\t\t       POINTER_REGS, GET_MODE (X), VOIDmode, 0, 0,\t    \\\n-\t\t       OPNUM, TYPE);\t\t\t\t\t    \\\n-          goto WIN;\t\t\t\t\t\t\t    \\\n-\t}\t\t\t\t\t\t\t\t    \\\n-    }\t\t\t\t\t\t\t\t\t    \\\n-} while(0)\n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_L,WIN)          \\\n+  do {                                                                  \\\n+    rtx new_x = avr_legitimize_reload_address (X, MODE, OPNUM, TYPE,    \\\n+                                               ADDR_TYPE (TYPE),        \\\n+                                               IND_L, make_memloc);     \\\n+    if (new_x)                                                          \\\n+      {                                                                 \\\n+        X = new_x;                                                      \\\n+        goto WIN;                                                       \\\n+      }                                                                 \\\n+  } while (0)\n \n #define BRANCH_COST(speed_p, predictable_p) 0\n "}]}