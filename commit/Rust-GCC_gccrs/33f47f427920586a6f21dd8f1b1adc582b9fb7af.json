{"sha": "33f47f427920586a6f21dd8f1b1adc582b9fb7af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNmNDdmNDI3OTIwNTg2YTZmMjFkZDhmMWIxYWRjNTgyYjlmYjdhZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2015-11-18T13:49:17Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-18T13:49:17Z"}, "message": "nvptx.c (global_lock_var): New.\n\n\tgcc/\n\t* config/nvptx/nvptx.c (global_lock_var): New.\n\t(nvptx_global_lock_addr): New.\n\t(nvptx_lockless_update): Recomment and adjust for clarity.\n\t(nvptx_lockfull_update): New.\n\t(nvptx_reduction_update): New.\n\t(nvptx_goacc_reduction_fini): Call it.\n\n\tlibgcc/\n\t* config/nvptx/reduction.c: New.\n\t* config/nvptx/t-nvptx (LIB2ADD): Add it.\n\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/reduction-cplx-flt.c: Add\n\tworker & gang cases.\n\t* testsuite/libgomp.oacc-c-c++-common/reduction-cplx-dbl.c: Likewise.\n\nFrom-SVN: r230545", "tree": {"sha": "91925ad53ac42a3a444905c3ffb894e6ec7c3a18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91925ad53ac42a3a444905c3ffb894e6ec7c3a18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33f47f427920586a6f21dd8f1b1adc582b9fb7af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f47f427920586a6f21dd8f1b1adc582b9fb7af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33f47f427920586a6f21dd8f1b1adc582b9fb7af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f47f427920586a6f21dd8f1b1adc582b9fb7af/comments", "author": null, "committer": null, "parents": [{"sha": "d085c468179245fdd31c1014d3029ddd9e116e01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d085c468179245fdd31c1014d3029ddd9e116e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d085c468179245fdd31c1014d3029ddd9e116e01"}], "stats": {"total": 486, "additions": 412, "deletions": 74}, "files": [{"sha": "d569816265c8d816956d48c1ade7ae470379a1d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f47f427920586a6f21dd8f1b1adc582b9fb7af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f47f427920586a6f21dd8f1b1adc582b9fb7af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33f47f427920586a6f21dd8f1b1adc582b9fb7af", "patch": "@@ -1,3 +1,12 @@\n+2015-11-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/nvptx/nvptx.c (global_lock_var): New.\n+\t(nvptx_global_lock_addr): New.\n+\t(nvptx_lockless_update): Recomment and adjust for clarity.\n+\t(nvptx_lockfull_update): New.\n+\t(nvptx_reduction_update): New.\n+\t(nvptx_goacc_reduction_fini): Call it.\n+\n 2015-11-18  Bernd Schmidt  <bschmidt@redhat.com>\n \n \t* regrename.h (struct du_head): Add target_data_1 and target_data_2"}, {"sha": "4436ac4de94efaed4f2f9d1638b2cad0b7327a84", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 201, "deletions": 39, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f47f427920586a6f21dd8f1b1adc582b9fb7af/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f47f427920586a6f21dd8f1b1adc582b9fb7af/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=33f47f427920586a6f21dd8f1b1adc582b9fb7af", "patch": "@@ -114,6 +114,9 @@ static unsigned worker_red_align;\n #define worker_red_name \"__worker_red\"\n static GTY(()) rtx worker_red_sym;\n \n+/* Global lock variable, needed for 128bit worker & gang reductions.  */\n+static GTY(()) tree global_lock_var;\n+\n /* Allocate a new, cleared machine_function structure.  */\n \n static struct machine_function *\n@@ -3681,55 +3684,76 @@ nvptx_generate_vector_shuffle (location_t loc,\n   gimplify_assign (dest_var, expr, seq);\n }\n \n-/* Insert code to locklessly update  *PTR with *PTR OP VAR just before\n-   GSI.  */\n+/* Lazily generate the global lock var decl and return its address.  */\n+\n+static tree\n+nvptx_global_lock_addr ()\n+{\n+  tree v = global_lock_var;\n+  \n+  if (!v)\n+    {\n+      tree name = get_identifier (\"__reduction_lock\");\n+      tree type = build_qualified_type (unsigned_type_node,\n+\t\t\t\t\tTYPE_QUAL_VOLATILE);\n+      v = build_decl (BUILTINS_LOCATION, VAR_DECL, name, type);\n+      global_lock_var = v;\n+      DECL_ARTIFICIAL (v) = 1;\n+      DECL_EXTERNAL (v) = 1;\n+      TREE_STATIC (v) = 1;\n+      TREE_PUBLIC (v) = 1;\n+      TREE_USED (v) = 1;\n+      mark_addressable (v);\n+      mark_decl_referenced (v);\n+    }\n+\n+  return build_fold_addr_expr (v);\n+}\n+\n+/* Insert code to locklessly update *PTR with *PTR OP VAR just before\n+   GSI.  We use a lockless scheme for nearly all case, which looks\n+   like:\n+     actual = initval(OP);\n+     do {\n+       guess = actual;\n+       write = guess OP myval;\n+       actual = cmp&swap (ptr, guess, write)\n+     } while (actual bit-different-to guess);\n+   return write;\n+\n+   This relies on a cmp&swap instruction, which is available for 32-\n+   and 64-bit types.  Larger types must use a locking scheme.  */\n \n static tree\n nvptx_lockless_update (location_t loc, gimple_stmt_iterator *gsi,\n \t\t       tree ptr, tree var, tree_code op)\n {\n   unsigned fn = NVPTX_BUILTIN_CMP_SWAP;\n   tree_code code = NOP_EXPR;\n-  tree type = unsigned_type_node;\n-\n-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (var));\n+  tree arg_type = unsigned_type_node;\n+  tree var_type = TREE_TYPE (var);\n \n-  if (!INTEGRAL_MODE_P (mode))\n+  if (TREE_CODE (var_type) == COMPLEX_TYPE\n+      || TREE_CODE (var_type) == REAL_TYPE)\n     code = VIEW_CONVERT_EXPR;\n-  if (GET_MODE_SIZE (mode) == GET_MODE_SIZE (DImode))\n+\n+  if (TYPE_SIZE (var_type) == TYPE_SIZE (long_long_unsigned_type_node))\n     {\n+      arg_type = long_long_unsigned_type_node;\n       fn = NVPTX_BUILTIN_CMP_SWAPLL;\n-      type = long_long_unsigned_type_node;\n     }\n \n+  tree swap_fn = nvptx_builtin_decl (fn, true);\n+\n   gimple_seq init_seq = NULL;\n-  tree init_var = make_ssa_name (type);\n-  tree init_expr = omp_reduction_init_op (loc, op, TREE_TYPE (var));\n-  init_expr = fold_build1 (code, type, init_expr);\n+  tree init_var = make_ssa_name (arg_type);\n+  tree init_expr = omp_reduction_init_op (loc, op, var_type);\n+  init_expr = fold_build1 (code, arg_type, init_expr);\n   gimplify_assign (init_var, init_expr, &init_seq);\n   gimple *init_end = gimple_seq_last (init_seq);\n \n   gsi_insert_seq_before (gsi, init_seq, GSI_SAME_STMT);\n   \n-  gimple_seq loop_seq = NULL;\n-  tree expect_var = make_ssa_name (type);\n-  tree actual_var = make_ssa_name (type);\n-  tree write_var = make_ssa_name (type);\n-  \n-  tree write_expr = fold_build1 (code, TREE_TYPE (var), expect_var);\n-  write_expr = fold_build2 (op, TREE_TYPE (var), write_expr, var);\n-  write_expr = fold_build1 (code, type, write_expr);\n-  gimplify_assign (write_var, write_expr, &loop_seq);\n-\n-  tree swap_expr = nvptx_builtin_decl (fn, true);\n-  swap_expr = build_call_expr_loc (loc, swap_expr, 3,\n-\t\t\t\t   ptr, expect_var, write_var);\n-  gimplify_assign (actual_var, swap_expr, &loop_seq);\n-\n-  gcond *cond = gimple_build_cond (EQ_EXPR, actual_var, expect_var,\n-\t\t\t\t   NULL_TREE, NULL_TREE);\n-  gimple_seq_add_stmt (&loop_seq, cond);\n-\n   /* Split the block just after the init stmts.  */\n   basic_block pre_bb = gsi_bb (*gsi);\n   edge pre_edge = split_block (pre_bb, init_end);\n@@ -3738,12 +3762,34 @@ nvptx_lockless_update (location_t loc, gimple_stmt_iterator *gsi,\n   /* Reset the iterator.  */\n   *gsi = gsi_for_stmt (gsi_stmt (*gsi));\n \n-  /* Insert the loop statements.  */\n-  gimple *loop_end = gimple_seq_last (loop_seq);\n-  gsi_insert_seq_before (gsi, loop_seq, GSI_SAME_STMT);\n+  tree expect_var = make_ssa_name (arg_type);\n+  tree actual_var = make_ssa_name (arg_type);\n+  tree write_var = make_ssa_name (arg_type);\n+  \n+  /* Build and insert the reduction calculation.  */\n+  gimple_seq red_seq = NULL;\n+  tree write_expr = fold_build1 (code, var_type, expect_var);\n+  write_expr = fold_build2 (op, var_type, write_expr, var);\n+  write_expr = fold_build1 (code, arg_type, write_expr);\n+  gimplify_assign (write_var, write_expr, &red_seq);\n+\n+  gsi_insert_seq_before (gsi, red_seq, GSI_SAME_STMT);\n+\n+  /* Build & insert the cmp&swap sequence.  */\n+  gimple_seq latch_seq = NULL;\n+  tree swap_expr = build_call_expr_loc (loc, swap_fn, 3,\n+\t\t\t\t\tptr, expect_var, write_var);\n+  gimplify_assign (actual_var, swap_expr, &latch_seq);\n+\n+  gcond *cond = gimple_build_cond (EQ_EXPR, actual_var, expect_var,\n+\t\t\t\t   NULL_TREE, NULL_TREE);\n+  gimple_seq_add_stmt (&latch_seq, cond);\n+\n+  gimple *latch_end = gimple_seq_last (latch_seq);\n+  gsi_insert_seq_before (gsi, latch_seq, GSI_SAME_STMT);\n \n-  /* Split the block just after the loop stmts.  */\n-  edge post_edge = split_block (loop_bb, loop_end);\n+  /* Split the block just after the latch stmts.  */\n+  edge post_edge = split_block (loop_bb, latch_end);\n   basic_block post_bb = post_edge->dest;\n   loop_bb = post_edge->src;\n   *gsi = gsi_for_stmt (gsi_stmt (*gsi));\n@@ -3762,7 +3808,123 @@ nvptx_lockless_update (location_t loc, gimple_stmt_iterator *gsi,\n   loop->latch = loop_bb;\n   add_loop (loop, loop_bb->loop_father);\n \n-  return fold_build1 (code, TREE_TYPE (var), write_var);\n+  return fold_build1 (code, var_type, write_var);\n+}\n+\n+/* Insert code to lockfully update *PTR with *PTR OP VAR just before\n+   GSI.  This is necessary for types larger than 64 bits, where there\n+   is no cmp&swap instruction to implement a lockless scheme.  We use\n+   a lock variable in global memory.\n+\n+   while (cmp&swap (&lock_var, 0, 1))\n+     continue;\n+   T accum = *ptr;\n+   accum = accum OP var;\n+   *ptr = accum;\n+   cmp&swap (&lock_var, 1, 0);\n+   return accum;\n+\n+   A lock in global memory is necessary to force execution engine\n+   descheduling and avoid resource starvation that can occur if the\n+   lock is in .shared memory.  */\n+\n+static tree\n+nvptx_lockfull_update (location_t loc, gimple_stmt_iterator *gsi,\n+\t\t       tree ptr, tree var, tree_code op)\n+{\n+  tree var_type = TREE_TYPE (var);\n+  tree swap_fn = nvptx_builtin_decl (NVPTX_BUILTIN_CMP_SWAP, true);\n+  tree uns_unlocked = build_int_cst (unsigned_type_node, 0);\n+  tree uns_locked = build_int_cst (unsigned_type_node, 1);\n+\n+  /* Split the block just before the gsi.  Insert a gimple nop to make\n+     this easier.  */\n+  gimple *nop = gimple_build_nop ();\n+  gsi_insert_before (gsi, nop, GSI_SAME_STMT);\n+  basic_block entry_bb = gsi_bb (*gsi);\n+  edge entry_edge = split_block (entry_bb, nop);\n+  basic_block lock_bb = entry_edge->dest;\n+  /* Reset the iterator.  */\n+  *gsi = gsi_for_stmt (gsi_stmt (*gsi));\n+\n+  /* Build and insert the locking sequence.  */\n+  gimple_seq lock_seq = NULL;\n+  tree lock_var = make_ssa_name (unsigned_type_node);\n+  tree lock_expr = nvptx_global_lock_addr ();\n+  lock_expr = build_call_expr_loc (loc, swap_fn, 3, lock_expr,\n+\t\t\t\t   uns_unlocked, uns_locked);\n+  gimplify_assign (lock_var, lock_expr, &lock_seq);\n+  gcond *cond = gimple_build_cond (EQ_EXPR, lock_var, uns_unlocked,\n+\t\t\t\t   NULL_TREE, NULL_TREE);\n+  gimple_seq_add_stmt (&lock_seq, cond);\n+  gimple *lock_end = gimple_seq_last (lock_seq);\n+  gsi_insert_seq_before (gsi, lock_seq, GSI_SAME_STMT);\n+\n+  /* Split the block just after the lock sequence.  */\n+  edge locked_edge = split_block (lock_bb, lock_end);\n+  basic_block update_bb = locked_edge->dest;\n+  lock_bb = locked_edge->src;\n+  *gsi = gsi_for_stmt (gsi_stmt (*gsi));\n+  \n+  /* Create the lock loop ... */\n+  locked_edge->flags ^= EDGE_TRUE_VALUE | EDGE_FALLTHRU;\n+  make_edge (lock_bb, lock_bb, EDGE_FALSE_VALUE);\n+  set_immediate_dominator (CDI_DOMINATORS, lock_bb, entry_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, update_bb, lock_bb);\n+\n+  /* ... and the loop structure.  */\n+  loop *lock_loop = alloc_loop ();\n+  lock_loop->header = lock_bb;\n+  lock_loop->latch = lock_bb;\n+  lock_loop->nb_iterations_estimate = 1;\n+  lock_loop->any_estimate = true;\n+  add_loop (lock_loop, entry_bb->loop_father);\n+\n+  /* Build and insert the reduction calculation.  */\n+  gimple_seq red_seq = NULL;\n+  tree acc_in = make_ssa_name (var_type);\n+  tree ref_in = build_simple_mem_ref (ptr);\n+  TREE_THIS_VOLATILE (ref_in) = 1;\n+  gimplify_assign (acc_in, ref_in, &red_seq);\n+  \n+  tree acc_out = make_ssa_name (var_type);\n+  tree update_expr = fold_build2 (op, var_type, ref_in, var);\n+  gimplify_assign (acc_out, update_expr, &red_seq);\n+  \n+  tree ref_out = build_simple_mem_ref (ptr);\n+  TREE_THIS_VOLATILE (ref_out) = 1;\n+  gimplify_assign (ref_out, acc_out, &red_seq);\n+\n+  gsi_insert_seq_before (gsi, red_seq, GSI_SAME_STMT);\n+\n+  /* Build & insert the unlock sequence.  */\n+  gimple_seq unlock_seq = NULL;\n+  tree unlock_expr = nvptx_global_lock_addr ();\n+  unlock_expr = build_call_expr_loc (loc, swap_fn, 3, unlock_expr,\n+\t\t\t\t     uns_locked, uns_unlocked);\n+  gimplify_and_add (unlock_expr, &unlock_seq);\n+  gsi_insert_seq_before (gsi, unlock_seq, GSI_SAME_STMT);\n+\n+  return acc_out;\n+}\n+\n+/* Emit a sequence to update a reduction accumlator at *PTR with the\n+   value held in VAR using operator OP.  Return the updated value.\n+\n+   TODO: optimize for atomic ops and indepedent complex ops.  */\n+\n+static tree\n+nvptx_reduction_update (location_t loc, gimple_stmt_iterator *gsi,\n+\t\t\ttree ptr, tree var, tree_code op)\n+{\n+  tree type = TREE_TYPE (var);\n+  tree size = TYPE_SIZE (type);\n+\n+  if (size == TYPE_SIZE (unsigned_type_node)\n+      || size == TYPE_SIZE (long_long_unsigned_type_node))\n+    return nvptx_lockless_update (loc, gsi, ptr, var, op);\n+  else\n+    return nvptx_lockfull_update (loc, gsi, ptr, var, op);\n }\n \n /* NVPTX implementation of GOACC_REDUCTION_SETUP.  */\n@@ -3944,11 +4106,11 @@ nvptx_goacc_reduction_fini (gcall *call)\n \n       if (accum)\n \t{\n-\t  /* Locklessly update the accumulator.  */\n+\t  /* UPDATE the accumulator.  */\n \t  gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n \t  seq = NULL;\n-\t  r = nvptx_lockless_update (gimple_location (call), &gsi,\n-\t\t\t\t     accum, var, op);\n+\t  r = nvptx_reduction_update (gimple_location (call), &gsi,\n+\t\t\t\t      accum, var, op);\n \t}\n     }\n "}, {"sha": "8ab02ab3f080b8d6403fda2c822255790872643e", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=33f47f427920586a6f21dd8f1b1adc582b9fb7af", "patch": "@@ -1,3 +1,8 @@\n+2015-11-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/nvptx/reduction.c: New.\n+\t* config/nvptx/t-nvptx (LIB2ADD): Add it.\n+\n 2015-11-15  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* config/rs6000/on_exit.c: New file."}, {"sha": "11bad4c33069ac8d5e20e42ae5c609fb1eaeacbe", "filename": "libgcc/config/nvptx/reduction.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgcc%2Fconfig%2Fnvptx%2Freduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgcc%2Fconfig%2Fnvptx%2Freduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Freduction.c?ref=33f47f427920586a6f21dd8f1b1adc582b9fb7af", "patch": "@@ -0,0 +1,31 @@\n+/* Oversized reductions lock  variable\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by Mentor Graphics.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* We use a global lock variable for reductions on objects larger than\n+   64 bits.  Until and unless proven that lock contention for\n+   different reduction is a problem, a single lock will suffice.  */\n+\n+unsigned volatile __reduction_lock = 0;"}, {"sha": "e66188f87225e7c2d095c38970436b344d118cbc", "filename": "libgcc/config/nvptx/t-nvptx", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgcc%2Fconfig%2Fnvptx%2Ft-nvptx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgcc%2Fconfig%2Fnvptx%2Ft-nvptx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Ft-nvptx?ref=33f47f427920586a6f21dd8f1b1adc582b9fb7af", "patch": "@@ -1,6 +1,7 @@\n LIB2ADD=$(srcdir)/config/nvptx/malloc.asm \\\n \t$(srcdir)/config/nvptx/free.asm \\\n-\t$(srcdir)/config/nvptx/realloc.c\n+\t$(srcdir)/config/nvptx/realloc.c \\\n+\t$(srcdir)/config/nvptx/reduction.c\n \n LIB2ADDEH=\n LIB2FUNCS_EXCLUDE=__main"}, {"sha": "d3a5f47e7cbf8332fcc19d5b1199bbefa30400f1", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=33f47f427920586a6f21dd8f1b1adc582b9fb7af", "patch": "@@ -1,3 +1,9 @@\n+2015-11-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* testsuite/libgomp.oacc-c-c++-common/reduction-cplx-flt.c: Add\n+\tworker & gang cases.\n+\t* testsuite/libgomp.oacc-c-c++-common/reduction-cplx-dbl.c: Likewise.\n+\n 2015-11-17  Cesar Philippidis  <cesar@codesourcery.com>\n \n \t* config/nvptx/priority_queue.c: New file."}, {"sha": "94b29b55925050404ddbaf737042f148ddc35130", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/reduction-cplx-dbl.c", "status": "modified", "additions": 79, "deletions": 17, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Freduction-cplx-dbl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Freduction-cplx-dbl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Freduction-cplx-dbl.c?ref=33f47f427920586a6f21dd8f1b1adc582b9fb7af", "patch": "@@ -14,28 +14,41 @@ int close_enough (double _Complex a, double _Complex b)\n   return mag2_diff / mag2_a < (FRAC * FRAC);\n }\n \n-int main (void)\n-{\n #define N 100\n-  double _Complex ary[N], sum, prod, tsum, tprod;\n-  int ix;\n \n-  sum = tsum = 0;\n-  prod = tprod = 1;\n-  \n-  for (ix = 0; ix < N;  ix++)\n-    {\n-      double frac = ix * (1.0 / 1024) + 1.0;\n-      \n-      ary[ix] = frac + frac * 2.0i - 1.0i;\n-      sum += ary[ix];\n-      prod *= ary[ix];\n-    }\n+static int __attribute__ ((noinline))\n+vector (double _Complex ary[N], double _Complex sum, double _Complex prod)\n+{\n+  double _Complex tsum = 0, tprod = 1;\n \n-#pragma acc parallel vector_length(32) copyin(ary) copy (tsum, tprod)\n+#pragma acc parallel vector_length(32) copyin(ary[0:N]) copy (tsum, tprod)\n   {\n #pragma acc loop vector reduction(+:tsum) reduction (*:tprod)\n-    for (ix = 0; ix < N; ix++)\n+    for (int ix = 0; ix < N; ix++)\n+      {\n+\ttsum += ary[ix];\n+\ttprod *= ary[ix];\n+      }\n+  }\n+\n+  if (!close_enough (sum, tsum))\n+    return 1;\n+\n+  if (!close_enough (prod, tprod))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+static int __attribute__ ((noinline))\n+worker (double _Complex ary[N], double _Complex sum, double _Complex prod)\n+{\n+  double _Complex tsum = 0, tprod = 1;\n+\n+#pragma acc parallel num_workers(32) copyin(ary[0:N]) copy (tsum, tprod)\n+  {\n+#pragma acc loop worker reduction(+:tsum) reduction (*:tprod)\n+    for (int ix = 0; ix < N; ix++)\n       {\n \ttsum += ary[ix];\n \ttprod *= ary[ix];\n@@ -50,3 +63,52 @@ int main (void)\n \n   return 0;\n }\n+\n+static int __attribute__ ((noinline))\n+gang (double _Complex ary[N], double _Complex sum, double _Complex prod)\n+{\n+  double _Complex tsum = 0, tprod = 1;\n+\n+#pragma acc parallel num_gangs (32) copyin(ary[0:N]) copy (tsum, tprod)\n+  {\n+#pragma acc loop gang reduction(+:tsum) reduction (*:tprod)\n+    for (int ix = 0; ix < N; ix++)\n+      {\n+\ttsum += ary[ix];\n+\ttprod *= ary[ix];\n+      }\n+  }\n+\n+  if (!close_enough (sum, tsum))\n+    return 1;\n+\n+  if (!close_enough (prod, tprod))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  double _Complex ary[N], sum = 0, prod = 1;\n+\n+  for (int ix = 0; ix < N;  ix++)\n+    {\n+      double frac = ix * (1.0 / 1024) + 1.0;\n+      \n+      ary[ix] = frac + frac * 2.0i - 1.0i;\n+      sum += ary[ix];\n+      prod *= ary[ix];\n+    }\n+\n+  if (vector (ary, sum, prod))\n+    return 1;\n+  \n+  if (worker (ary, sum, prod))\n+    return 1;\n+\n+  if (gang (ary, sum, prod))\n+    return 1;\n+\n+  return 0;\n+}"}, {"sha": "d76bf6b8de62fc0af9417fa32f73f7e0a9cb6d18", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/reduction-cplx-flt.c", "status": "modified", "additions": 79, "deletions": 17, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Freduction-cplx-flt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f47f427920586a6f21dd8f1b1adc582b9fb7af/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Freduction-cplx-flt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Freduction-cplx-flt.c?ref=33f47f427920586a6f21dd8f1b1adc582b9fb7af", "patch": "@@ -14,28 +14,41 @@ int close_enough (float _Complex a, float _Complex b)\n   return mag2_diff / mag2_a < (FRAC * FRAC);\n }\n \n-int main (void)\n-{\n #define N 100\n-  float _Complex ary[N], sum, prod, tsum, tprod;\n-  int ix;\n \n-  sum = tsum = 0;\n-  prod = tprod = 1;\n-  \n-  for (ix = 0; ix < N;  ix++)\n-    {\n-      float frac = ix * (1.0f / 1024) + 1.0f;\n-      \n-      ary[ix] = frac + frac * 2.0i - 1.0i;\n-      sum += ary[ix];\n-      prod *= ary[ix];\n-    }\n+static int __attribute__ ((noinline))\n+vector (float _Complex ary[N], float _Complex sum, float _Complex prod)\n+{\n+  float _Complex tsum = 0, tprod = 1;\n \n-#pragma acc parallel vector_length(32) copyin(ary) copy (tsum, tprod)\n+#pragma acc parallel vector_length(32) copyin(ary[0:N]) copy (tsum, tprod)\n   {\n #pragma acc loop vector reduction(+:tsum) reduction (*:tprod)\n-    for (ix = 0; ix < N; ix++)\n+    for (int ix = 0; ix < N; ix++)\n+      {\n+\ttsum += ary[ix];\n+\ttprod *= ary[ix];\n+      }\n+  }\n+\n+  if (!close_enough (sum, tsum))\n+    return 1;\n+\n+  if (!close_enough (prod, tprod))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+static int __attribute__ ((noinline))\n+worker (float _Complex ary[N], float _Complex sum, float _Complex prod)\n+{\n+  float _Complex tsum = 0, tprod = 1;\n+\n+#pragma acc parallel num_workers(32) copyin(ary[0:N]) copy (tsum, tprod)\n+  {\n+#pragma acc loop worker reduction(+:tsum) reduction (*:tprod)\n+    for (int ix = 0; ix < N; ix++)\n       {\n \ttsum += ary[ix];\n \ttprod *= ary[ix];\n@@ -50,3 +63,52 @@ int main (void)\n \n   return 0;\n }\n+\n+static int __attribute__ ((noinline))\n+gang (float _Complex ary[N], float _Complex sum, float _Complex prod)\n+{\n+  float _Complex tsum = 0, tprod = 1;\n+\n+#pragma acc parallel num_gangs (32) copyin(ary[0:N]) copy (tsum, tprod)\n+  {\n+#pragma acc loop gang reduction(+:tsum) reduction (*:tprod)\n+    for (int ix = 0; ix < N; ix++)\n+      {\n+\ttsum += ary[ix];\n+\ttprod *= ary[ix];\n+      }\n+  }\n+\n+  if (!close_enough (sum, tsum))\n+    return 1;\n+\n+  if (!close_enough (prod, tprod))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  float _Complex ary[N], sum = 0, prod = 1;\n+\n+  for (int ix = 0; ix < N;  ix++)\n+    {\n+      float frac = ix * (1.0f / 1024) + 1.0f;\n+      \n+      ary[ix] = frac + frac * 2.0i - 1.0i;\n+      sum += ary[ix];\n+      prod *= ary[ix];\n+    }\n+\n+  if (vector (ary, sum, prod))\n+    return 1;\n+  \n+  if (worker (ary, sum, prod))\n+    return 1;\n+\n+  if (gang (ary, sum, prod))\n+    return 1;\n+\n+  return 0;\n+}"}]}