{"sha": "f6f704fd104b79fc88914978772737cd05423059", "node_id": "C_kwDOANBUbNoAKGY2ZjcwNGZkMTA0Yjc5ZmM4ODkxNDk3ODc3MjczN2NkMDU0MjMwNTk", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-07T17:20:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-07T17:20:45Z"}, "message": "Fix inter-procedural EAF flags propagation with respect to !binds_to_current_def_p\n\nWhile proofreading the code for handling EAF flags of !binds_to_current_def_p I\nnoticed that the interprocedural dataflow actually ignores the flag possibly\nintroducing wrong code on quite complex interposable functions in non-trivial\nrecursion cycles (or at ltrans partition boundary).\n\nThis patch unifies the flags changes to single place (remove_useless_eaf_flags)\nand does extend modref_merge_call_site_flags to do the right thing.\n\nlto-bootstrapped/regtested x86_64-linux.  Plan to commit it today after bit\nmore testing (firefox/clang build).\n\ngcc/ChangeLog:\n\n\t* gimple.c (gimple_call_arg_flags): Use interposable_eaf_flags.\n\t(gimple_call_retslot_flags): Likewise.\n\t(gimple_call_static_chain_flags): Likewise.\n\t* ipa-modref.c (remove_useless_eaf_flags): Do not remove everything for\n\tNOVOPS.\n\t(modref_summary::useful_p): Likewise.\n\t(modref_summary_lto::useful_p): Likewise.\n\t(analyze_parms): Do not give up on NOVOPS.\n\t(analyze_function): When dumping report chnages in EAF flags\n\tbetween IPA and local pass.\n\t(modref_merge_call_site_flags): Compute implicit eaf flags\n\tbased on callee ecf_flags and fnspec; if the function does not\n\tbind to current defs use interposable_eaf_flags.\n\t(modref_propagate_flags_in_scc): Update.\n\t* ipa-modref.h (interposable_eaf_flags): New function.", "tree": {"sha": "39f3fbf1a4711497619b6406f66320e7d76b839c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39f3fbf1a4711497619b6406f66320e7d76b839c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6f704fd104b79fc88914978772737cd05423059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f704fd104b79fc88914978772737cd05423059", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6f704fd104b79fc88914978772737cd05423059", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f704fd104b79fc88914978772737cd05423059/comments", "author": null, "committer": null, "parents": [{"sha": "a28cfe49203705ff9675b79fce88d6087b11d098", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28cfe49203705ff9675b79fce88d6087b11d098", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a28cfe49203705ff9675b79fce88d6087b11d098"}], "stats": {"total": 258, "additions": 203, "deletions": 55}, "files": [{"sha": "3d1d3a15b2c62887a465084685d79219532ca759", "filename": "gcc/gimple.c", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f704fd104b79fc88914978772737cd05423059/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f704fd104b79fc88914978772737cd05423059/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=f6f704fd104b79fc88914978772737cd05423059", "patch": "@@ -1595,17 +1595,7 @@ gimple_call_arg_flags (const gcall *stmt, unsigned arg)\n \n \t  /* We have possibly optimized out load.  Be conservative here.  */\n \t  if (!node->binds_to_current_def_p ())\n-\t    {\n-\t      if ((modref_flags & EAF_UNUSED) && !(flags & EAF_UNUSED))\n-\t\t{\n-\t\t  modref_flags &= ~EAF_UNUSED;\n-\t\t  modref_flags |= EAF_NOESCAPE;\n-\t\t}\n-\t      if ((modref_flags & EAF_NOREAD) && !(flags & EAF_NOREAD))\n-\t\tmodref_flags &= ~EAF_NOREAD;\n-\t      if ((modref_flags & EAF_DIRECT) && !(flags & EAF_DIRECT))\n-\t\tmodref_flags &= ~EAF_DIRECT;\n-\t    }\n+\t    modref_flags = interposable_eaf_flags (modref_flags, flags);\n \t  if (dbg_cnt (ipa_mod_ref_pta))\n \t    flags |= modref_flags;\n \t}\n@@ -1633,13 +1623,7 @@ gimple_call_retslot_flags (const gcall *stmt)\n \n \t  /* We have possibly optimized out load.  Be conservative here.  */\n \t  if (!node->binds_to_current_def_p ())\n-\t    {\n-\t      if ((modref_flags & EAF_UNUSED) && !(flags & EAF_UNUSED))\n-\t\t{\n-\t\t  modref_flags &= ~EAF_UNUSED;\n-\t\t  modref_flags |= EAF_NOESCAPE;\n-\t\t}\n-\t    }\n+\t    modref_flags = interposable_eaf_flags (modref_flags, flags);\n \t  if (dbg_cnt (ipa_mod_ref_pta))\n \t    flags |= modref_flags;\n \t}\n@@ -1665,19 +1649,9 @@ gimple_call_static_chain_flags (const gcall *stmt)\n \t{\n \t  int modref_flags = summary->static_chain_flags;\n \n-\t  /* We have possibly optimized out load.  Be conservative here.  */\n+\t  /* ??? Nested functions should always bind to current def.  */\n \t  if (!node->binds_to_current_def_p ())\n-\t    {\n-\t      if ((modref_flags & EAF_UNUSED) && !(flags & EAF_UNUSED))\n-\t\t{\n-\t\t  modref_flags &= ~EAF_UNUSED;\n-\t\t  modref_flags |= EAF_NOESCAPE;\n-\t\t}\n-\t      if ((modref_flags & EAF_NOREAD) && !(flags & EAF_NOREAD))\n-\t\tmodref_flags &= ~EAF_NOREAD;\n-\t      if ((modref_flags & EAF_DIRECT) && !(flags & EAF_DIRECT))\n-\t\tmodref_flags &= ~EAF_DIRECT;\n-\t    }\n+\t    modref_flags = interposable_eaf_flags (modref_flags, flags);\n \t  if (dbg_cnt (ipa_mod_ref_pta))\n \t    flags |= modref_flags;\n \t}"}, {"sha": "4e64ee5d9fd4ab320ca59f04fbc0763aa5202da3", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 170, "deletions": 25, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f704fd104b79fc88914978772737cd05423059/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f704fd104b79fc88914978772737cd05423059/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=f6f704fd104b79fc88914978772737cd05423059", "patch": "@@ -291,9 +291,7 @@ modref_summary::~modref_summary ()\n static int\n remove_useless_eaf_flags (int eaf_flags, int ecf_flags, bool returns_void)\n {\n-  if (ecf_flags & ECF_NOVOPS)\n-    return 0;\n-  if (ecf_flags & ECF_CONST)\n+  if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n     eaf_flags &= ~implicit_const_eaf_flags;\n   else if (ecf_flags & ECF_PURE)\n     eaf_flags &= ~implicit_pure_eaf_flags;\n@@ -319,8 +317,6 @@ eaf_flags_useful_p (vec <eaf_flags_t> &flags, int ecf_flags)\n bool\n modref_summary::useful_p (int ecf_flags, bool check_flags)\n {\n-  if (ecf_flags & ECF_NOVOPS)\n-    return false;\n   if (arg_flags.length () && !check_flags)\n     return true;\n   if (check_flags && eaf_flags_useful_p (arg_flags, ecf_flags))\n@@ -331,7 +327,7 @@ modref_summary::useful_p (int ecf_flags, bool check_flags)\n   if (check_flags\n       && remove_useless_eaf_flags (static_chain_flags, ecf_flags, false))\n     return true;\n-  if (ecf_flags & ECF_CONST)\n+  if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n     return false;\n   if (loads && !loads->every_base)\n     return true;\n@@ -405,8 +401,6 @@ modref_summary_lto::~modref_summary_lto ()\n bool\n modref_summary_lto::useful_p (int ecf_flags, bool check_flags)\n {\n-  if (ecf_flags & ECF_NOVOPS)\n-    return false;\n   if (arg_flags.length () && !check_flags)\n     return true;\n   if (check_flags && eaf_flags_useful_p (arg_flags, ecf_flags))\n@@ -417,7 +411,7 @@ modref_summary_lto::useful_p (int ecf_flags, bool check_flags)\n   if (check_flags\n       && remove_useless_eaf_flags (static_chain_flags, ecf_flags, false))\n     return true;\n-  if (ecf_flags & ECF_CONST)\n+  if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n     return false;\n   if (loads && !loads->every_base)\n     return true;\n@@ -2321,10 +2315,6 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n   tree retslot = NULL;\n   tree static_chain = NULL;\n \n-  /* For novops functions we have nothing to gain by EAF flags.  */\n-  if (ecf_flags & ECF_NOVOPS)\n-    return;\n-\n   /* If there is return slot, look up its SSA name.  */\n   if (DECL_RESULT (current_function_decl)\n       && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n@@ -2471,6 +2461,11 @@ analyze_function (function *f, bool ipa)\n   modref_summary *summary = NULL;\n   modref_summary_lto *summary_lto = NULL;\n \n+  bool past_flags_known = false;\n+  auto_vec <eaf_flags_t> past_flags;\n+  int past_retslot_flags = 0;\n+  int past_static_chain_flags = 0;\n+\n   /* Initialize the summary.\n      If we run in local mode there is possibly pre-existing summary from\n      IPA pass.  Dump it so it is easy to compare if mod-ref info has\n@@ -2490,6 +2485,11 @@ analyze_function (function *f, bool ipa)\n \t      fprintf (dump_file, \"Past summary:\\n\");\n \t      optimization_summaries->get\n \t\t (cgraph_node::get (f->decl))->dump (dump_file);\n+\t      past_flags.reserve_exact (summary->arg_flags.length ());\n+\t      past_flags.splice (summary->arg_flags);\n+\t      past_retslot_flags = summary->retslot_flags;\n+\t      past_static_chain_flags = summary->static_chain_flags;\n+\t      past_flags_known = true;\n \t    }\n \t  optimization_summaries->remove (cgraph_node::get (f->decl));\n \t}\n@@ -2630,6 +2630,108 @@ analyze_function (function *f, bool ipa)\n       if (summary_lto)\n \tsummary_lto->dump (dump_file);\n       dump_modref_edge_summaries (dump_file, fnode, 2);\n+      /* To simplify debugging, compare IPA and local solutions.  */\n+      if (past_flags_known && summary)\n+\t{\n+\t  size_t len = summary->arg_flags.length ();\n+\n+\t  if (past_flags.length () > len)\n+\t    len = past_flags.length ();\n+\t  for (size_t i = 0; i < len; i++)\n+\t    {\n+\t      int old_flags = i < past_flags.length () ? past_flags[i] : 0;\n+\t      int new_flags = i < summary->arg_flags.length ()\n+\t\t\t      ? summary->arg_flags[i] : 0;\n+\t      old_flags = remove_useless_eaf_flags\n+\t\t(old_flags, flags_from_decl_or_type (current_function_decl),\n+\t\t VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))));\n+\t      if (old_flags != new_flags)\n+\t\t{\n+\t\t  if ((old_flags & ~new_flags) == 0)\n+\t\t    fprintf (dump_file, \"  Flags for param %i improved:\",\n+\t\t\t     (int)i);\n+\t\t  else if ((new_flags & ~old_flags) == 0)\n+\t\t    fprintf (dump_file, \"  Flags for param %i worsened:\",\n+\t\t\t     (int)i);\n+\t\t  else\n+\t\t    fprintf (dump_file, \"  Flags for param %i changed:\",\n+\t\t\t     (int)i);\n+\t\t  dump_eaf_flags (dump_file, old_flags, false);\n+\t\t  fprintf (dump_file, \" -> \");\n+\t\t  dump_eaf_flags (dump_file, new_flags, true);\n+\t\t}\n+\t    }\n+\t  past_retslot_flags = remove_useless_eaf_flags\n+\t\t(past_retslot_flags,\n+\t\t flags_from_decl_or_type (current_function_decl),\n+\t\t VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))));\n+\t  if (past_retslot_flags != summary->retslot_flags)\n+\t    {\n+\t      if ((past_retslot_flags & ~summary->retslot_flags) == 0)\n+\t\tfprintf (dump_file, \"  Flags for retslot improved:\");\n+\t      else if ((summary->retslot_flags & ~past_retslot_flags) == 0)\n+\t\tfprintf (dump_file, \"  Flags for retslot worsened:\");\n+\t      else\n+\t\tfprintf (dump_file, \"  Flags for retslot changed:\");\n+\t      dump_eaf_flags (dump_file, past_retslot_flags, false);\n+\t      fprintf (dump_file, \" -> \");\n+\t      dump_eaf_flags (dump_file, summary->retslot_flags, true);\n+\t    }\n+\t  past_static_chain_flags = remove_useless_eaf_flags\n+\t\t(past_static_chain_flags,\n+\t\t flags_from_decl_or_type (current_function_decl),\n+\t\t VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))));\n+\t  if (past_static_chain_flags != summary->static_chain_flags)\n+\t    {\n+\t      if ((past_static_chain_flags & ~summary->static_chain_flags) == 0)\n+\t\tfprintf (dump_file, \"  Flags for static chain improved:\");\n+\t      else if ((summary->static_chain_flags\n+\t\t\t& ~past_static_chain_flags) == 0)\n+\t\tfprintf (dump_file, \"  Flags for static chain worsened:\");\n+\t      else\n+\t\tfprintf (dump_file, \"  Flags for static chain changed:\");\n+\t      dump_eaf_flags (dump_file, past_static_chain_flags, false);\n+\t      fprintf (dump_file, \" -> \");\n+\t      dump_eaf_flags (dump_file, summary->static_chain_flags, true);\n+\t    }\n+\t}\n+      else if (past_flags_known && !summary)\n+\t{\n+\t  for (size_t i = 0; i < past_flags.length (); i++)\n+\t    {\n+\t      int old_flags = past_flags[i];\n+\t      old_flags = remove_useless_eaf_flags\n+\t\t(old_flags, flags_from_decl_or_type (current_function_decl),\n+\t\t VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))));\n+\t      if (old_flags)\n+\t\t{\n+\t\t  fprintf (dump_file, \"  Flags for param %i worsened:\",\n+\t\t\t   (int)i);\n+\t\t  dump_eaf_flags (dump_file, old_flags, false);\n+\t\t  fprintf (dump_file, \" -> \\n\");\n+\t\t}\n+\t    }\n+\t  past_retslot_flags = remove_useless_eaf_flags\n+\t\t(past_retslot_flags,\n+\t\t flags_from_decl_or_type (current_function_decl),\n+\t\t VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))));\n+\t  if (past_retslot_flags)\n+\t    {\n+\t      fprintf (dump_file, \"  Flags for retslot worsened:\");\n+\t      dump_eaf_flags (dump_file, past_retslot_flags, false);\n+\t      fprintf (dump_file, \" ->\\n\");\n+\t    }\n+\t  past_static_chain_flags = remove_useless_eaf_flags\n+\t\t(past_static_chain_flags,\n+\t\t flags_from_decl_or_type (current_function_decl),\n+\t\t VOID_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))));\n+\t  if (past_static_chain_flags)\n+\t    {\n+\t      fprintf (dump_file, \"  Flags for static chain worsened:\");\n+\t      dump_eaf_flags (dump_file, past_static_chain_flags, false);\n+\t      fprintf (dump_file, \" ->\\n\");\n+\t    }\n+\t}\n     }\n }\n \n@@ -4039,12 +4141,15 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t\t\t      modref_summary *summary,\n \t\t\t      modref_summary_lto *summary_lto,\n \t\t\t      tree caller,\n-\t\t\t      int ecf_flags)\n+\t\t\t      cgraph_edge *e,\n+\t\t\t      int caller_ecf_flags,\n+\t\t\t      int callee_ecf_flags,\n+\t\t\t      bool binds_to_current_def)\n {\n   escape_entry *ee;\n   unsigned int i;\n   bool changed = false;\n-  bool ignore_stores = ignore_stores_p (caller, ecf_flags);\n+  bool ignore_stores = ignore_stores_p (caller, callee_ecf_flags);\n \n   /* If we have no useful info to propagate.  */\n   if ((!cur_summary || !cur_summary->arg_flags.length ())\n@@ -4055,6 +4160,8 @@ modref_merge_call_site_flags (escape_summary *sum,\n     {\n       int flags = 0;\n       int flags_lto = 0;\n+      /* Returning the value is already accounted to at local propagation.  */\n+      int implicit_flags = EAF_NOT_RETURNED | EAF_NOT_RETURNED_DIRECTLY;\n \n       if (summary && ee->arg < summary->arg_flags.length ())\n \tflags = summary->arg_flags[ee->arg];\n@@ -4066,14 +4173,43 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t  flags = deref_flags (flags, ignore_stores);\n \t  flags_lto = deref_flags (flags_lto, ignore_stores);\n \t}\n-      else if (ignore_stores)\n+      if (ignore_stores)\n+\t implicit_flags |= ignore_stores_eaf_flags;\n+      if (callee_ecf_flags & ECF_PURE)\n+\timplicit_flags |= implicit_pure_eaf_flags;\n+      if (callee_ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+\timplicit_flags |= implicit_const_eaf_flags;\n+      class fnspec_summary *fnspec_sum = fnspec_summaries->get (e);\n+      if (fnspec_sum)\n \t{\n-\t  flags |= ignore_stores_eaf_flags;\n-\t  flags_lto |= ignore_stores_eaf_flags;\n+\t  attr_fnspec fnspec (fnspec_sum->fnspec);\n+\t  int fnspec_flags = 0;\n+\n+\t  if (fnspec.arg_specified_p (ee->arg))\n+\t    {\n+\t      if (!fnspec.arg_used_p (ee->arg))\n+\t\tfnspec_flags = EAF_UNUSED;\n+\t      else\n+\t\t{\n+\t\t  if (fnspec.arg_direct_p (ee->arg))\n+\t\t    fnspec_flags |= EAF_DIRECT;\n+\t\t  if (fnspec.arg_noescape_p (ee->arg))\n+\t\t    fnspec_flags |= EAF_NOESCAPE | EAF_NODIRECTESCAPE;\n+\t\t  if (fnspec.arg_readonly_p (ee->arg))\n+\t\t    fnspec_flags |= EAF_NOCLOBBER;\n+\t\t}\n+\t    }\n+\t  implicit_flags |= fnspec_flags;\n+\t}\n+      if (!ee->direct)\n+\timplicit_flags = deref_flags (implicit_flags, ignore_stores);\n+      flags |= implicit_flags;\n+      flags_lto |= implicit_flags;\n+      if (!binds_to_current_def && (flags || flags_lto))\n+\t{\n+\t  flags = interposable_eaf_flags (flags, implicit_flags);\n+\t  flags_lto = interposable_eaf_flags (flags_lto, implicit_flags);\n \t}\n-      /* Returning the value is already accounted to at local propagation.  */\n-      flags |= ee->min_flags | EAF_NOT_RETURNED | EAF_NOT_RETURNED_DIRECTLY;\n-      flags_lto |= ee->min_flags | EAF_NOT_RETURNED | EAF_NOT_RETURNED_DIRECTLY;\n       /* Noescape implies that value also does not escape directly.\n \t Fnspec machinery does set both so compensate for this.  */\n       if (flags & EAF_NOESCAPE)\n@@ -4095,7 +4231,7 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t  if ((f & flags) != f)\n \t    {\n \t      f = remove_useless_eaf_flags\n-\t\t\t (f & flags, ecf_flags,\n+\t\t\t (f & flags, caller_ecf_flags,\n \t\t\t  VOID_TYPE_P (TREE_TYPE (TREE_TYPE (caller))));\n \t      changed = true;\n \t    }\n@@ -4112,7 +4248,7 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t  if ((f & flags_lto) != f)\n \t    {\n \t      f = remove_useless_eaf_flags\n-\t\t\t (f & flags_lto, ecf_flags,\n+\t\t\t (f & flags_lto, caller_ecf_flags,\n \t\t\t  VOID_TYPE_P (TREE_TYPE (TREE_TYPE (caller))));\n \t      changed = true;\n \t    }\n@@ -4146,6 +4282,7 @@ modref_propagate_flags_in_scc (cgraph_node *component_node)\n \n \t  if (!cur_summary && !cur_summary_lto)\n \t    continue;\n+\t  int caller_ecf_flags = flags_from_decl_or_type (cur->decl);\n \n \t  if (dump_file)\n \t    fprintf (dump_file, \"  Processing %s%s%s\\n\",\n@@ -4164,7 +4301,11 @@ modref_propagate_flags_in_scc (cgraph_node *component_node)\n \t      changed |= modref_merge_call_site_flags\n \t\t\t\t(sum, cur_summary, cur_summary_lto,\n \t\t\t\t NULL, NULL,\n-\t\t\t\t node->decl, e->indirect_info->ecf_flags);\n+\t\t\t\t node->decl,\n+\t\t\t\t e,\n+\t\t\t\t caller_ecf_flags,\n+\t\t\t\t e->indirect_info->ecf_flags,\n+\t\t\t\t false);\n \t    }\n \n \t  if (!cur_summary && !cur_summary_lto)\n@@ -4216,7 +4357,11 @@ modref_propagate_flags_in_scc (cgraph_node *component_node)\n \t      changed |= modref_merge_call_site_flags\n \t\t\t\t(sum, cur_summary, cur_summary_lto,\n \t\t\t\t callee_summary, callee_summary_lto,\n-\t\t\t\t node->decl, ecf_flags);\n+\t\t\t\t node->decl,\n+\t\t\t\t callee_edge,\n+\t\t\t\t caller_ecf_flags,\n+\t\t\t\t ecf_flags,\n+\t\t\t\t callee->binds_to_current_def_p ());\n \t      if (dump_file && changed)\n \t\t{\n \t\t  if (cur_summary)"}, {"sha": "20170a65ded73d14463d59b94111effd00ac77b1", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6f704fd104b79fc88914978772737cd05423059/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6f704fd104b79fc88914978772737cd05423059/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=f6f704fd104b79fc88914978772737cd05423059", "patch": "@@ -58,4 +58,33 @@ static const int implicit_pure_eaf_flags = EAF_NOCLOBBER | EAF_NOESCAPE\n static const int ignore_stores_eaf_flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE\n \t\t\t\t    | EAF_NODIRECTESCAPE;\n \n+/* If function does not bind to current def (i.e. it is inline in comdat\n+   section), the modref analysis may not match the behaviour of function\n+   which will be later symbol interposed to.  All side effects must match\n+   however it is possible that the other function body contains more loads\n+   which may trap.\n+   MODREF_FLAGS are flags determined by analysis of function body while\n+   FLAGS are flags known otherwise (i.e. by fnspec, pure/const attributes\n+   etc.)  */\n+static inline int\n+interposable_eaf_flags (int modref_flags, int flags)\n+{\n+  /* If parameter was previously unused, we know it is only read\n+     and its value is not used.  */\n+  if ((modref_flags & EAF_UNUSED) && !(flags & EAF_UNUSED))\n+    {\n+      modref_flags &= ~EAF_UNUSED;\n+      modref_flags |= EAF_NOESCAPE | EAF_NOT_RETURNED\n+\t\t      | EAF_NOT_RETURNED_DIRECTLY | EAF_NOCLOBBER;\n+    }\n+  /* We can not deterine that value is not read at all.  */\n+  if ((modref_flags & EAF_NOREAD) && !(flags & EAF_NOREAD))\n+    modref_flags &= ~EAF_NOREAD;\n+  /* Clear direct flags so we also know that value is possibly read\n+     indirectly.  */\n+  if ((modref_flags & EAF_DIRECT) && !(flags & EAF_DIRECT))\n+    modref_flags &= ~EAF_DIRECT;\n+  return modref_flags;\n+}\n+\n #endif"}]}