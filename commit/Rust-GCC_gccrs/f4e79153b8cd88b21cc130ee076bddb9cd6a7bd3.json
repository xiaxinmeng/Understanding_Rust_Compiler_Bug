{"sha": "f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRlNzkxNTNiOGNkODhiMjFjYzEzMGVlMDc2YmRkYjljZDZhN2JkMw==", "commit": {"author": {"name": "Jason Eckhardt", "email": "jle@cygnus.com", "date": "2000-05-03T00:20:24Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2000-05-03T00:20:24Z"}, "message": "bb-reorder.c (struct reorder_block_def): Remove members end, block_begin, and block_end.\n\nTue May  2 19:18:43 2000  Jason Eckhardt  <jle@cygnus.com>\n\n        * bb-reorder.c (struct reorder_block_def): Remove members end,\n        block_begin, and block_end.\n        (REORDER_BLOCK_OLD_END): Delete.\n        (REORDER_BLOCK_BEGIN): Delete.\n        (REORDER_BLOCK_END): Delete.\n        (chain_reorder_blocks): Remove dead code.\n\nFrom-SVN: r33620", "tree": {"sha": "4694af4f0d4753b6aa53a919f03cfb03880409c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4694af4f0d4753b6aa53a919f03cfb03880409c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3/comments", "author": null, "committer": null, "parents": [{"sha": "eb6f82f7cf7575a603f86cb1b8de3909b6167ec7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6f82f7cf7575a603f86cb1b8de3909b6167ec7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6f82f7cf7575a603f86cb1b8de3909b6167ec7"}], "stats": {"total": 95, "additions": 10, "deletions": 85}, "files": [{"sha": "dd1b243e6e26bfa2de58064c9e583ac73f300c47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3", "patch": "@@ -1,3 +1,12 @@\n+Tue May  2 19:18:43 2000  Jason Eckhardt  <jle@cygnus.com>\n+\n+        * bb-reorder.c (struct reorder_block_def): Remove members end,\n+        block_begin, and block_end.\n+        (REORDER_BLOCK_OLD_END): Delete.\n+        (REORDER_BLOCK_BEGIN): Delete.\n+        (REORDER_BLOCK_END): Delete.\n+        (chain_reorder_blocks): Remove dead code.\n+\n Tue May  2 17:06:53 2000  Jason Eckhardt  <jle@cygnus.com>\n \n \t* bb-reorder.c (remove_scope_notes): Check for both types of scope"}, {"sha": "c941d7410384e936f27330be9179a8ba1d5846f2", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 85, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=f4e79153b8cd88b21cc130ee076bddb9cd6a7bd3", "patch": "@@ -104,9 +104,6 @@ typedef struct reorder_block_def {\n   int index;\n   basic_block add_jump;\n   edge succ;\n-  rtx end;\n-  int block_begin;\n-  int block_end;\n   rtx eff_head;\n   rtx eff_end;\n   scope scope;\n@@ -118,9 +115,6 @@ static struct reorder_block_def rbd_init\n     0,\t\t\t/* index */\n     NULL,\t\t/* add_jump */\n     NULL,\t\t/* succ */\n-    NULL_RTX,\t\t/* end */\n-    0,\t\t\t/* block_begin */\n-    0,\t\t\t/* block_end */\n     NULL_RTX,\t\t/* eff_head */\n     NULL_RTX,\t\t/* eff_end */\n     NULL\t\t/* scope */\n@@ -142,15 +136,6 @@ static struct reorder_block_def rbd_init\n #define REORDER_BLOCK_SUCC(bb) \\\n   ((reorder_block_def) (bb)->aux)->succ\n \n-#define REORDER_BLOCK_OLD_END(bb) \\\n-  ((reorder_block_def) (bb)->aux)->end\n-\n-#define REORDER_BLOCK_BEGIN(bb) \\\n-  ((reorder_block_def) (bb)->aux)->block_begin\n-\n-#define REORDER_BLOCK_END(bb) \\\n-  ((reorder_block_def) (bb)->aux)->block_end\n-\n #define REORDER_BLOCK_EFF_HEAD(bb) \\\n   ((reorder_block_def) (bb)->aux)->eff_head\n \n@@ -336,7 +321,7 @@ chain_reorder_blocks (e, ceb)\n {\n   basic_block sb = e->src;\n   basic_block db = e->dest;\n-  rtx cebe_insn, cebbe_insn, dbh_insn, dbe_insn;\n+  rtx cebe_insn, dbh_insn, dbe_insn;\n   edge ee, last_edge;\n \n   enum cond_types {NO_COND, PREDICT_THEN_WITH_ELSE, PREDICT_ELSE,\n@@ -350,45 +335,7 @@ chain_reorder_blocks (e, ceb)\n     fprintf (rtl_dump_file,\n \t     \"Edge from basic block %d to basic block %d last visited %d\\n\",\n \t     sb->index, db->index, ceb->index);\n-\n-  dbh_insn = REORDER_BLOCK_EFF_HEAD (db);\n   cebe_insn = REORDER_BLOCK_EFF_END (ceb);\n-  cebbe_insn = skip_insns_between_block (ceb, REORDER_SKIP_BLOCK_END);\n-\n-  {\n-    int block_begins = 0;\n-    rtx insn;\n-\n-    for (insn = dbh_insn; insn && insn != db->end; insn = NEXT_INSN (insn))\n-      {\n-\tif (GET_CODE (insn) == NOTE\n-\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n-\t  {\n-\t    block_begins += 1;\n-\t    break;\n-\t  }\n-      }\n-    REORDER_BLOCK_BEGIN (sb) = block_begins;\n-  }\n-\n-  if (cebbe_insn)\n-    {\n-      int block_ends = 0;\n-      rtx insn;\n-\n-      for (insn = cebe_insn; insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (PREV_INSN (insn) == cebbe_insn)\n-\t    break;\n-\t  if (GET_CODE (insn) == NOTE\n-\t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n-\t    {\n-\t      block_ends += 1;\n-\t      continue;\n-\t    }\n-\t}\n-      REORDER_BLOCK_END (ceb) = block_ends;\n-    }\n \n   /* Blocks are in original order.  */\n   if (sb->index == ceb->index\n@@ -540,41 +487,10 @@ chain_reorder_blocks (e, ceb)\n   cebe_insn = REORDER_BLOCK_EFF_END (ceb);\n   dbe_insn = REORDER_BLOCK_EFF_END (db);\n \n-  /* Leave behind any lexical block markers.  */\n-  if (0 && debug_info_level > DINFO_LEVEL_TERSE\n-      && ceb->index + 1 < db->index)\n-    {\n-      rtx insn, last_insn = get_last_insn ();\n-      insn = NEXT_INSN (ceb->end);\n-      if (! insn)\n-\tinsn = REORDER_BLOCK_OLD_END (ceb);\n-\n-      if (NEXT_INSN (cebe_insn) == 0)\n-\t  set_last_insn (cebe_insn);\n-      for (; insn && insn != db->head/*dbh_insn*/;\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == NOTE\n-\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG))\n-\t    {\n-\t      cebe_insn = emit_note_after (NOTE_INSN_BLOCK_BEG, cebe_insn);\n-\t      delete_insn (insn);\n-\t    }\n-\t  if (GET_CODE (insn) == NOTE\n-\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n-\t    {\n-\t      cebe_insn = emit_note_after (NOTE_INSN_BLOCK_END, cebe_insn);\n-\t      delete_insn (insn);\n-\t    }      \n-\t}\n-      set_last_insn (last_insn);\n-    }\n-\n   /* Rechain predicted block.  */\n   NEXT_INSN (cebe_insn) = dbh_insn;\n   PREV_INSN (dbh_insn) = cebe_insn;\n \n-  REORDER_BLOCK_OLD_END (db) = NEXT_INSN (dbe_insn);\n   if (db->index != n_basic_blocks - 1)\n     NEXT_INSN (dbe_insn) = 0;\n "}]}