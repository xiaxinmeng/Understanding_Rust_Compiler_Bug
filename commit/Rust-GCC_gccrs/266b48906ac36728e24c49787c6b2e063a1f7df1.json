{"sha": "266b48906ac36728e24c49787c6b2e063a1f7df1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY2YjQ4OTA2YWMzNjcyOGUyNGM0OTc4N2M2YjJlMDYzYTFmN2RmMQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "andrew_pinski@playstation.sony.com", "date": "2008-10-01T19:06:58Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2008-10-01T19:06:58Z"}, "message": "rs6000-c.c (altivec_resolve_overloaded_builtin): Handle ALTIVEC_BUILTIN_VEC_SPLATS...\n\n2008-10-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        * config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n        Handle ALTIVEC_BUILTIN_VEC_SPLATS, ALTIVEC_BUILTIN_VEC_PROMOTE,\n        ALTIVEC_BUILTIN_VEC_EXTRACT, and ALTIVEC_BUILTIN_VEC_INSERT specially,\n        they translate to non builtins.\n        * config/rs6000/rs6000.c (altivec_init_builtins): Add new variable\n        opaque_ftype_opaque.  Define builtins __builtin_vec_splats,\n        __builtin_vec_promote, __builtin_vec_extract, and\n        __builtin_vec_insert.\n        * config/rs6000/rs6000.h (enum rs6000_builtins): Add\n        ALTIVEC_BUILTIN_VEC_EXTRACT, ALTIVEC_BUILTIN_VEC_PROMOTE,\n        ALTIVEC_BUILTIN_VEC_INSERT, and ALTIVEC_BUILTIN_VEC_SPLATS.\n        * config/rs6000/altivec.h (vec_extract): Define\n        (vec_insert): Define.\n        (vec_splats): Define.\n        (vec_promote): Define.\n\n2008-10-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        * gcc.target/powerpc/altivec-cell-1.c: New test.\n        * gcc.target/powerpc/altivec-cell-2.c: New test.\n        * gcc.target/powerpc/altivec-cell-3.c: New test.\n        * gcc.target/powerpc/altivec-cell-4.c: New test.\n        * gcc.target/powerpc/altivec-cell-5.c: New test.\n        * g++.dg/ext/altivec-cell-1.C: New test.\n        * g++.dg/ext/altivec-cell-2.C: New test.\n        * g++.dg/ext/altivec-cell-3.C: New test.\n        * g++.dg/ext/altivec-cell-4.C: New test.\n        * g++.dg/ext/altivec-cell-5.C: New test.\n\n2008-10-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        * tree.c (lvalue_p_1): COMPOUND_LITERAL_EXPR is also an lvalue.\n\nFrom-SVN: r140821", "tree": {"sha": "5084dd423fee0d3e3b356167376d3d9cc667e938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5084dd423fee0d3e3b356167376d3d9cc667e938"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/266b48906ac36728e24c49787c6b2e063a1f7df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266b48906ac36728e24c49787c6b2e063a1f7df1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266b48906ac36728e24c49787c6b2e063a1f7df1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266b48906ac36728e24c49787c6b2e063a1f7df1/comments", "author": null, "committer": null, "parents": [{"sha": "0b61703ca6adde635f58c71763a524b8fd922009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b61703ca6adde635f58c71763a524b8fd922009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b61703ca6adde635f58c71763a524b8fd922009"}], "stats": {"total": 871, "additions": 869, "deletions": 2}, "files": [{"sha": "0a9fc83c69349617177ee3922e617662cebad458", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -1,3 +1,21 @@\n+2008-10-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n+\tHandle ALTIVEC_BUILTIN_VEC_SPLATS, ALTIVEC_BUILTIN_VEC_PROMOTE,\n+\tALTIVEC_BUILTIN_VEC_EXTRACT, and ALTIVEC_BUILTIN_VEC_INSERT specially,\n+\tthey translate to non builtins.\n+\t* config/rs6000/rs6000.c (altivec_init_builtins): Add new variable\n+\topaque_ftype_opaque.  Define builtins __builtin_vec_splats,\n+\t__builtin_vec_promote, __builtin_vec_extract, and\n+\t__builtin_vec_insert.\n+\t* config/rs6000/rs6000.h (enum rs6000_builtins): Add\n+\tALTIVEC_BUILTIN_VEC_EXTRACT, ALTIVEC_BUILTIN_VEC_PROMOTE,\n+\tALTIVEC_BUILTIN_VEC_INSERT, and ALTIVEC_BUILTIN_VEC_SPLATS.\n+\t* config/rs6000/altivec.h (vec_extract): Define\n+\t(vec_insert): Define.\n+\t(vec_splats): Define.\n+\t(vec_promote): Define.\n+\n 2008-10-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n             Yukishige Shibata  <shibata@rd.scei.sony.co.jp>\n             Trevor Smigiel  <Trevor_Smigiel@playstation.sony.com>"}, {"sha": "cfe384c27c6cc019571c6855cc319c9e1f2e1d59", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -304,6 +304,11 @@\n #define vec_vsubuws __builtin_vec_vsubuws\n #define vec_xor __builtin_vec_xor\n \n+#define vec_extract __builtin_vec_extract\n+#define vec_insert __builtin_vec_insert\n+#define vec_splats __builtin_vec_splats\n+#define vec_promote __builtin_vec_promote\n+\n /* Predicates.\n    For C++, we use templates in order to allow non-parenthesized arguments.\n    For C, instead, we use macros since non-parenthesized arguments were"}, {"sha": "ed9b6c036835d1ca55f9fe326e2791d40300beaa", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -2973,6 +2973,198 @@ altivec_resolve_overloaded_builtin (tree fndecl, tree arglist)\n       || fcode > ALTIVEC_BUILTIN_OVERLOADED_LAST)\n     return NULL_TREE;\n \n+  /* For now treat vec_splats and vec_promote as the same.  */\n+  if (fcode == ALTIVEC_BUILTIN_VEC_SPLATS\n+      || fcode == ALTIVEC_BUILTIN_VEC_PROMOTE)\n+    {\n+      tree type, arg;\n+      int size;\n+      int i;\n+      bool unsigned_p;\n+      VEC(constructor_elt,gc) *vec;\n+      const char *name = fcode == ALTIVEC_BUILTIN_VEC_SPLATS ? \"vec_splats\": \"vec_promote\";\n+\n+      if (!arglist)\n+\t{\n+\t  error (\"%s only accepts %d arguments\", name, (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE)+1 );\n+\t  return error_mark_node;\n+\t}\n+      if (fcode == ALTIVEC_BUILTIN_VEC_SPLATS && TREE_CHAIN (arglist))\n+\t{\n+\t  error (\"%s only accepts 1 argument\", name);\n+\t  return error_mark_node;\n+\t}\n+      if (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE && !TREE_CHAIN (arglist))\n+\t{\n+\t  error (\"%s only accepts 2 arguments\", name);\n+\t  return error_mark_node;\n+\t}\n+      /* Ignore promote's element argument.  */\n+      if (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE\n+\t  && TREE_CHAIN (TREE_CHAIN (arglist)))\n+\t{\n+\t  error (\"%s only accepts 2 arguments\", name);\n+\t  return error_mark_node;\n+\t}\n+      if (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE\n+\t  && !INTEGRAL_TYPE_P (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))))\n+\tgoto bad;\n+\n+      arg = TREE_VALUE (arglist);\n+      type = TREE_TYPE (arg);\n+      if (!SCALAR_FLOAT_TYPE_P (type)\n+\t  && !INTEGRAL_TYPE_P (type))\n+\tgoto bad;\n+      unsigned_p = TYPE_UNSIGNED (type);\n+      if (type == long_long_unsigned_type_node\n+          || type == long_long_integer_type_node)\n+\tgoto bad;\n+      switch (TYPE_MODE (type))\n+\t{\n+\t  case SImode:\n+\t    type = (unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node);\n+\t    size = 4;\n+\t    break;\n+\t  case HImode:\n+\t    type = (unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node);\n+\t    size = 8;\n+\t    break;\n+\t  case QImode:\n+\t    type = (unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node);\n+\t    size = 16;\n+\t    break;\n+\t  case SFmode: type = V4SF_type_node; size = 4; break;\n+\t  default:\n+\t    goto bad;\n+\t}\n+      arg = save_expr (fold_convert (TREE_TYPE (type), arg));\n+      vec = VEC_alloc (constructor_elt, gc, size);\n+      for(i = 0; i < size; i++)\n+\t{\n+\t  constructor_elt *elt;\n+\n+\t  elt = VEC_quick_push (constructor_elt, vec, NULL);\n+\t  elt->index = NULL_TREE;\n+\t  elt->value = arg;\n+\t}\n+\treturn build_constructor (type, vec);\n+    }\n+\n+  /* For now use pointer tricks to do the extaction.  */\n+  if (fcode == ALTIVEC_BUILTIN_VEC_EXTRACT)\n+    {\n+      tree arg1;\n+      tree arg1_type;\n+      tree arg2;\n+      tree arg1_inner_type;\n+      tree decl, stmt;\n+      tree innerptrtype;\n+\n+      /* No second argument. */\n+      if (!arglist || !TREE_CHAIN (arglist)\n+\t  || TREE_CHAIN (TREE_CHAIN (arglist)))\n+\t{\n+\t  error (\"vec_extract only accepts 2 arguments\");\n+\t  return error_mark_node;\n+\t}\n+\n+      arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg1 = TREE_VALUE (arglist);\n+      arg1_type = TREE_TYPE (arg1);\n+\n+      if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n+\tgoto bad; \n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (arg2)))\n+\tgoto bad; \n+      /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2). */\n+      arg1_inner_type = TREE_TYPE (arg1_type);\n+      arg2 = build_binary_op (input_location, BIT_AND_EXPR, arg2,\n+\t\t\t      build_int_cst (TREE_TYPE (arg2),\n+\t\t\t\t\t     TYPE_VECTOR_SUBPARTS (arg1_type)\n+\t\t\t\t\t     - 1), 0);\n+      decl = build_decl (VAR_DECL, NULL_TREE, arg1_type);\n+      DECL_EXTERNAL (decl) = 0;\n+      TREE_PUBLIC (decl) = 0;\n+      DECL_CONTEXT (decl) = current_function_decl;\n+      TREE_USED (decl) = 1;\n+      TREE_TYPE (decl) = arg1_type;\n+      TREE_READONLY (decl) = TYPE_READONLY (arg1_type);\n+      DECL_INITIAL (decl) = arg1;\n+      stmt = build1 (DECL_EXPR, arg1_type, decl);\n+      TREE_ADDRESSABLE (decl) = 1;\n+      SET_EXPR_LOCATION (stmt, input_location);\n+      stmt = build1 (COMPOUND_LITERAL_EXPR, arg1_type, stmt);\n+\n+      innerptrtype = build_pointer_type (arg1_inner_type);\n+\n+      stmt = build_unary_op (ADDR_EXPR, stmt, 0);\n+      stmt = convert (innerptrtype, stmt);\n+      stmt = build_binary_op (input_location, PLUS_EXPR, stmt, arg2, 1);\n+      stmt = build_indirect_ref (stmt, NULL, input_location);\n+\n+      return stmt;\n+    }\n+\n+  /* For now use pointer tricks to do the insertation.  */\n+  if (fcode == ALTIVEC_BUILTIN_VEC_INSERT)\n+    {\n+      tree arg0;\n+      tree arg1;\n+      tree arg2;\n+      tree arg1_type;\n+      tree arg1_inner_type;\n+      tree decl, stmt;\n+      tree innerptrtype;\n+      \n+      /* No second or third arguments. */\n+      if (!arglist || !TREE_CHAIN (arglist)\n+\t  || !TREE_CHAIN (TREE_CHAIN (arglist))\n+\t  || TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))))\n+\t{\n+\t  error (\"vec_insert only accepts 3 arguments\");\n+\t  return error_mark_node;\n+\t}\n+\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg1_type = TREE_TYPE (arg1);\n+      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+      if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n+\tgoto bad; \n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (arg2)))\n+\tgoto bad; \n+      /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2) = arg0. */\n+      arg1_inner_type = TREE_TYPE (arg1_type);\n+      arg2 = build_binary_op (input_location, BIT_AND_EXPR, arg2,\n+\t\t\t      build_int_cst (TREE_TYPE (arg2),\n+\t\t\t\t\t     TYPE_VECTOR_SUBPARTS (arg1_type)\n+\t\t\t\t\t     - 1), 0);\n+      decl = build_decl (VAR_DECL, NULL_TREE, arg1_type);\n+      DECL_EXTERNAL (decl) = 0;\n+      TREE_PUBLIC (decl) = 0;\n+      DECL_CONTEXT (decl) = current_function_decl;\n+      TREE_USED (decl) = 1;\n+      TREE_TYPE (decl) = arg1_type;\n+      TREE_READONLY (decl) = TYPE_READONLY (arg1_type);\n+      DECL_INITIAL (decl) = arg1;\n+      stmt = build1 (DECL_EXPR, arg1_type, decl);\n+      TREE_ADDRESSABLE (decl) = 1;\n+      SET_EXPR_LOCATION (stmt, input_location);\n+      stmt = build1 (COMPOUND_LITERAL_EXPR, arg1_type, stmt);\n+\n+      innerptrtype = build_pointer_type (arg1_inner_type);\n+\n+      stmt = build_unary_op (ADDR_EXPR, stmt, 0);\n+      stmt = convert (innerptrtype, stmt);\n+      stmt = build_binary_op (input_location, PLUS_EXPR, stmt, arg2, 1);\n+      stmt = build_indirect_ref (stmt, NULL, input_location);\n+      stmt = build2 (MODIFY_EXPR, TREE_TYPE (stmt), stmt,\n+\t\t     convert (TREE_TYPE (stmt), arg0));\n+      stmt = build2 (COMPOUND_EXPR, arg1_type, stmt, decl);\n+      return stmt;\n+    }\n+\n   for (n = 0;\n        !VOID_TYPE_P (TREE_VALUE (fnargs)) && arglist;\n        fnargs = TREE_CHAIN (fnargs), arglist = TREE_CHAIN (arglist), n++)"}, {"sha": "6b9367b15708604c3df88f6b53ed2c987ecee594", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -9784,7 +9784,9 @@ altivec_init_builtins (void)\n   tree int_ftype_opaque\n     = build_function_type_list (integer_type_node,\n \t\t\t\topaque_V4SI_type_node, NULL_TREE);\n-\n+  tree opaque_ftype_opaque\n+    = build_function_type (integer_type_node,\n+\t\t\t\tNULL_TREE);\n   tree opaque_ftype_opaque_int\n     = build_function_type_list (opaque_V4SI_type_node,\n \t\t\t\topaque_V4SI_type_node, integer_type_node, NULL_TREE);\n@@ -9953,9 +9955,13 @@ altivec_init_builtins (void)\n       def_builtin (MASK_ALTIVEC, \"__builtin_vec_stvrxl\", void_ftype_v16qi_long_pvoid, ALTIVEC_BUILTIN_VEC_STVRXL);\n     }\n   def_builtin (MASK_ALTIVEC, \"__builtin_vec_step\", int_ftype_opaque, ALTIVEC_BUILTIN_VEC_STEP);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_splats\", opaque_ftype_opaque, ALTIVEC_BUILTIN_VEC_SPLATS);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_promote\", opaque_ftype_opaque, ALTIVEC_BUILTIN_VEC_PROMOTE);\n \n   def_builtin (MASK_ALTIVEC, \"__builtin_vec_sld\", opaque_ftype_opaque_opaque_int, ALTIVEC_BUILTIN_VEC_SLD);\n   def_builtin (MASK_ALTIVEC, \"__builtin_vec_splat\", opaque_ftype_opaque_int, ALTIVEC_BUILTIN_VEC_SPLAT);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_extract\", opaque_ftype_opaque_int, ALTIVEC_BUILTIN_VEC_EXTRACT);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_insert\", opaque_ftype_opaque_opaque_int, ALTIVEC_BUILTIN_VEC_INSERT);\n   def_builtin (MASK_ALTIVEC, \"__builtin_vec_vspltw\", opaque_ftype_opaque_int, ALTIVEC_BUILTIN_VEC_VSPLTW);\n   def_builtin (MASK_ALTIVEC, \"__builtin_vec_vsplth\", opaque_ftype_opaque_int, ALTIVEC_BUILTIN_VEC_VSPLTH);\n   def_builtin (MASK_ALTIVEC, \"__builtin_vec_vspltb\", opaque_ftype_opaque_int, ALTIVEC_BUILTIN_VEC_VSPLTB);"}, {"sha": "e1023daa0224285efb9e4519b77b1179dcbe4479", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -2603,6 +2603,7 @@ enum rs6000_builtins\n   ALTIVEC_BUILTIN_VEC_AND,\n   ALTIVEC_BUILTIN_VEC_ANDC,\n   ALTIVEC_BUILTIN_VEC_AVG,\n+  ALTIVEC_BUILTIN_VEC_EXTRACT,\n   ALTIVEC_BUILTIN_VEC_CEIL,\n   ALTIVEC_BUILTIN_VEC_CMPB,\n   ALTIVEC_BUILTIN_VEC_CMPEQ,\n@@ -2812,7 +2813,10 @@ enum rs6000_builtins\n   ALTIVEC_BUILTIN_VEC_VUPKLSH,\n   ALTIVEC_BUILTIN_VEC_XOR,\n   ALTIVEC_BUILTIN_VEC_STEP,\n-  ALTIVEC_BUILTIN_OVERLOADED_LAST = ALTIVEC_BUILTIN_VEC_STEP,\n+  ALTIVEC_BUILTIN_VEC_PROMOTE,\n+  ALTIVEC_BUILTIN_VEC_INSERT,\n+  ALTIVEC_BUILTIN_VEC_SPLATS,\n+  ALTIVEC_BUILTIN_OVERLOADED_LAST = ALTIVEC_BUILTIN_VEC_SPLATS,\n \n   /* SPE builtins.  */\n   SPE_BUILTIN_EVADDW,"}, {"sha": "ea319f31aaa0d2be4e6589ea07479ee7c6686455", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -1,3 +1,7 @@\n+2008-10-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree.c (lvalue_p_1): COMPOUND_LITERAL_EXPR is also an lvalue.\n+\n 2008-09-30  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c++/37683"}, {"sha": "2ae65431c7be868090e5d9d11ba1851790e8e28c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -129,6 +129,7 @@ lvalue_p_1 (const_tree ref,\n       return op1_lvalue_kind;\n \n     case STRING_CST:\n+    case COMPOUND_LITERAL_EXPR:\n       return clk_ordinary;\n \n     case CONST_DECL:"}, {"sha": "c7c09d4185d67777f35b410a3014aaac19e6f9b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -1,3 +1,16 @@\n+2008-10-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* gcc.target/powerpc/altivec-cell-1.c: New test.\n+\t* gcc.target/powerpc/altivec-cell-2.c: New test.\n+\t* gcc.target/powerpc/altivec-cell-3.c: New test.\n+\t* gcc.target/powerpc/altivec-cell-4.c: New test.\n+\t* gcc.target/powerpc/altivec-cell-5.c: New test.\n+\t* g++.dg/ext/altivec-cell-1.C: New test.\n+\t* g++.dg/ext/altivec-cell-2.C: New test.\n+\t* g++.dg/ext/altivec-cell-3.C: New test.\n+\t* g++.dg/ext/altivec-cell-4.C: New test.\n+\t* g++.dg/ext/altivec-cell-5.C: New test.\n+\n 2008-10-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* gcc.target/powerpc/altivec_check.h (altivec_cell_check): New function."}, {"sha": "16d311c3bef5cc5b22cf2aacca8fd402647d6867", "filename": "gcc/testsuite/g++.dg/ext/altivec-cell-1.C", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-1.C?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* Basic test for the new VMX intrinsics.  */\n+#include <altivec.h>\n+\n+int f(vector int a, int b)\n+{\n+  return vec_extract (a, b);\n+}\n+short f1(vector short a, int b)\n+{\n+  return vec_extract (a, b);\n+}\n+vector short f2(vector short a, int b)\n+{\n+  return vec_insert (b, a, b);\n+}\n+vector float f3(vector float a, int b)\n+{\n+  return vec_insert (b, a, b);\n+}\n+\n+float g(void);\n+\n+vector float f4(float b, int t)\n+{\n+  return vec_promote (g(), t);\n+}\n+vector float f5(float b)\n+{\n+  return vec_splats (g());\n+}\n+\n+\n+\n+\n+template <int> \n+int tf(vector int a, int b)\n+{\n+  return vec_extract (a, b);\n+}\n+template <int> \n+short tf1(vector short a, int b)\n+{\n+  return vec_extract (a, b);\n+}\n+template <int> \n+vector short tf2(vector short a, int b)\n+{\n+  return vec_insert (b, a, b);\n+}\n+template <int> \n+vector float tf3(vector float a, int b)\n+{\n+  return vec_insert (b, a, b);\n+}\n+\n+template <int> \n+vector float tf4(float b, int t)\n+{\n+  return vec_promote (g(), t);\n+}\n+template <int> \n+vector float tf5(float b)\n+{\n+  return vec_splats (g());\n+}\n+\n+int t(vector int a, int b)\n+{\n+  return tf<1>(a, b);\n+}\n+short t1(vector short a, int b)\n+{\n+  return tf1<1>(a, b);\n+}\n+vector short t2(vector short a, int b)\n+{\n+  return tf2<1>(a, b);\n+}\n+vector float t3(vector float a, int b)\n+{\n+  return tf3<1>(a, b);\n+}\n+vector float t4(float b, int t)\n+{\n+  return tf4<1>(b, t);\n+}\n+vector float t5(float b)\n+{\n+  return tf5<1>(b);\n+}"}, {"sha": "969cc97aa8a6d4224953acd118f78433fd8995f4", "filename": "gcc/testsuite/g++.dg/ext/altivec-cell-2.C", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-2.C?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -0,0 +1,142 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+/* Test the vec_extract VMX intrinsics.  */\n+#include <altivec.h>\n+#include \"altivec_check.h\"\n+\n+extern \"C\" void abort (void);\n+\n+vector int a = {0, 1, 2, 3};\n+vector short b = {0, 1, 2, 3, 4, 5, 6, 7};\n+\n+int f(vector int a, int b)\n+{\n+  return vec_extract (a, b);\n+}\n+\n+int f0 (vector int a)\n+{\n+  return vec_extract (a, 0);\n+}\n+int f1 (vector int a)\n+{\n+  return vec_extract (a, 1);\n+}\n+int f2 (vector int a)\n+{\n+  return vec_extract (a, 2);\n+}\n+int f3 (vector int a)\n+{\n+  return vec_extract (a, 3);\n+}\n+int f4 (vector int a)\n+{\n+  return vec_extract (a, 4);\n+}\n+\n+int g(vector short a, int b)\n+{\n+  return vec_extract (a, b);\n+}\n+\n+int g0 (vector short a)\n+{\n+  return vec_extract (a, 0);\n+}\n+int g1 (vector short a)\n+{\n+  return vec_extract (a, 1);\n+}\n+int g2 (vector short a)\n+{\n+  return vec_extract (a, 2);\n+}\n+int g3 (vector short a)\n+{\n+  return vec_extract (a, 3);\n+}\n+\n+int g4 (vector short a)\n+{ \n+  return vec_extract (a, 4);\n+}\n+int g5 (vector short a)\n+{ \n+  return vec_extract (a, 5);\n+}\n+int g6 (vector short a)\n+{ \n+  return vec_extract (a, 6);\n+}\n+int g7 (vector short a)\n+{ \n+  return vec_extract (a, 7);\n+}\n+int g8 (vector short a)\n+{ \n+  return vec_extract (a, 8);\n+}\n+int main1(void) __attribute__((noinline));\n+int main1(void)\n+{ \n+  int i;\n+  /* Check vec_extract with a non constant element numbering */\n+  for(i=0;i<10;i++)\n+    { \n+      if (f(a, i) != (i&0x3))\n+        abort ();\n+    }\n+  \n+  /* Check vec_extract with a constant element numbering */\n+  if (f0(a) != 0)\n+    abort ();\n+  if (f1(a) != 1)\n+    abort ();\n+  if (f2(a) != 2)\n+    abort ();\n+  if (f3(a) != 3)\n+    abort ();\n+  /* Check that vec_extract works with a constant element higher than\n+     the number of elements.  */\n+  if (f4(a) != 0)\n+    abort ();\n+\n+  /* Check vec_extract with a non constant element numbering */\n+  for(i=0;i<10;i++)\n+    {\n+      if (g(b, i) != (i&0x7))\n+        abort ();\n+    }\n+  \n+  /* Check vec_extract with a constant element numbering */\n+  if (g0(b) != 0)\n+    abort ();\n+  if (g1(b) != 1)\n+    abort ();\n+  if (g2(b) != 2)\n+    abort ();\n+  if (g3(b) != 3)\n+    abort ();\n+  if (g4(b) != 4)\n+    abort ();\n+  if (g5(b) != 5)\n+    abort ();\n+  if (g6(b) != 6)\n+    abort ();\n+  if (g7(b) != 7)\n+    abort ();\n+  /* Check that vec_extract works with a constant element higher than\n+     the number of elements.  */\n+  if (g8(b) != 0)\n+    abort ();\n+  \n+  return 0;\n+}\n+\n+int main(void)\n+{ \n+  altivec_check();  /* Exits if AltiVec not supported */\n+  return main1 ();\n+}"}, {"sha": "f7ebcae054ea9bb3b4eafcc6d1b1413ca2f3f133", "filename": "gcc/testsuite/g++.dg/ext/altivec-cell-3.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-3.C?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+/* Test the vec_splats and vec_promote VMX intrinsics.  */\n+#include <altivec.h>\n+#include \"altivec_check.h\"\n+    \n+extern \"C\" void abort (void);\n+        \n+vector int a = {0, 0, 0, 0};\n+int main1(int t) __attribute__((noinline));\n+int main1(int t)\n+{ \n+  int i;\n+  vector int b = vec_splats(0);\n+  if (__builtin_memcmp (&a, &b, sizeof(vector int)))\n+    abort ();\n+  \n+  b = vec_splats(t);\n+  if (__builtin_memcmp (&a, &b, sizeof(vector int)))\n+    abort ();\n+  \n+  b = vec_promote(0, 1);\n+  if (vec_extract (b, 1) != 0)\n+    abort ();\n+  \n+  b = vec_promote(t, t);\n+  if (vec_extract (b, t) != 0)\n+    abort ();\n+  \n+  return 0;\n+} \n+    \n+int main(void)\n+{ \n+  altivec_check();  /* Exits if AltiVec not supported */\n+  return main1 (0);\n+}"}, {"sha": "10ab162dad2ea3034614dd6f810fb8ee706bbc0d", "filename": "gcc/testsuite/g++.dg/ext/altivec-cell-4.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-4.C?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* Test the vec_splats and vec_promote VMX intrinsics.  */\n+#include <altivec.h>\n+#include \"altivec_check.h\"\n+    \n+extern \"C\" void abort (void);\n+        \n+vector int a[] = {{0, 0, 0, 0}, {1,0,0,0}, {1,2,0,0},{1,2,3,0},{1,2,3,4},{5,2,3,4},{5,6,3,4}};\n+vector int c = {0,6,3,4};\n+vector int d = {0,0,3,4};\n+int main1(int t) __attribute__((noinline));\n+int main1(int t)\n+{ \n+  int i;\n+  vector int b = vec_splats(0);\n+  for(i = 0;i<sizeof(a)/sizeof(a[0])-1;i++)\n+    { \n+        if (__builtin_memcmp (&b, &a[i], sizeof(vector int)))\n+          abort ();\n+        b = vec_insert(i+1, b, i);\n+    } \n+  if (__builtin_memcmp (&b, &a[i], sizeof(vector int)))\n+    abort ();\n+  \n+  b = vec_insert(0, b, 0);\n+  if (__builtin_memcmp (&b, &c, sizeof(vector int)))\n+    abort ();\n+  \n+  b = vec_insert(0, b, 1);\n+  if (__builtin_memcmp (&b, &d, sizeof(vector int)))\n+    abort ();\n+  \n+  return 0;\n+} \n+  \n+int main(void)\n+{\n+  altivec_check();  /* Exits if AltiVec not supported */\n+  return main1 (0);\n+}"}, {"sha": "95f109d1abeffddace062b8cedf215a66fc8ee93", "filename": "gcc/testsuite/g++.dg/ext/altivec-cell-5.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Faltivec-cell-5.C?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* Basic test for the new VMX intrinsics and error messages.  */\n+#include <altivec.h>\n+\n+int main(int argc, char **argv)\n+{\n+vector float t;\n+    vec_promote();                      /* { dg-error \"vec_promote only accepts 2\" } */\n+    vec_promote(1.0f);                  /* { dg-error \"vec_promote only accepts 2\" } */\n+    vec_promote(1.0f, 2, 3);            /* { dg-error \"vec_promote only accepts 2\" } */\n+    vec_extract ();                     /* { dg-error \"vec_extract only accepts 2\" } */\n+    vec_extract (t);                    /* { dg-error \"vec_extract only accepts 2\" } */\n+    vec_extract (t, 2);\n+    vec_extract (t, 2, 5, 6);           /* { dg-error \"vec_extract only accepts 2\" } */\n+    vec_splats ();                      /* { dg-error \"vec_splats only accepts 1\" } */\n+    vec_splats (t, 3);                  /* { dg-error \"vec_splats only accepts 1\" } */\n+    vec_insert ();                      /* { dg-error \"vec_insert only accepts 3\" } */\n+    vec_insert (t);                     /* { dg-error \"vec_insert only accepts 3\" } */\n+    vec_insert (t, 3);                  /* { dg-error \"vec_insert only accepts 3\" } */\n+    vec_insert (t, 3, 2, 4, 6, 6);      /* { dg-error \"vec_insert only accepts 3\" } */\n+    return 0;\n+}  "}, {"sha": "20d29bf05291adfb0b4e5796c75b874a9b42da2b", "filename": "gcc/testsuite/gcc.target/powerpc/altivec-cell-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-1.c?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* Basic test for the new VMX intrinsics.  */\n+#include <altivec.h>\n+\n+int f(vector int a, int b)\n+{\n+  return vec_extract (a, b);\n+}\n+short f1(vector short a, int b)\n+{\n+  return vec_extract (a, b);\n+}\n+vector short f2(vector short a, int b)\n+{\n+  return vec_insert (b, a, b);\n+}\n+vector float f3(vector float a, int b)\n+{\n+  return vec_insert (b, a, b);\n+}\n+\n+float g(void);\n+\n+vector float f4(float b, int t)\n+{\n+  return vec_promote (g(), t);\n+}\n+vector float f5(float b)\n+{\n+  return vec_splats (g());\n+}"}, {"sha": "b9c7c90b30394335955baed9de8da9125a331f3d", "filename": "gcc/testsuite/gcc.target/powerpc/altivec-cell-2.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-2.c?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -0,0 +1,142 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+/* Test the vec_extract VMX intrinsics.  */\n+#include <altivec.h>\n+#include \"altivec_check.h\"\n+\n+extern void abort (void);\n+\n+vector int a = {0, 1, 2, 3};\n+vector short b = {0, 1, 2, 3, 4, 5, 6, 7};\n+\n+int f(vector int a, int b)\n+{\n+  return vec_extract (a, b);\n+}\n+\n+int f0 (vector int a)\n+{\n+  return vec_extract (a, 0);\n+}\n+int f1 (vector int a)\n+{\n+  return vec_extract (a, 1);\n+}\n+int f2 (vector int a)\n+{\n+  return vec_extract (a, 2);\n+}\n+int f3 (vector int a)\n+{\n+  return vec_extract (a, 3);\n+}\n+int f4 (vector int a)\n+{\n+  return vec_extract (a, 4);\n+}\n+\n+int g(vector short a, int b)\n+{\n+  return vec_extract (a, b);\n+}\n+\n+int g0 (vector short a)\n+{\n+  return vec_extract (a, 0);\n+}\n+int g1 (vector short a)\n+{\n+  return vec_extract (a, 1);\n+}\n+int g2 (vector short a)\n+{\n+  return vec_extract (a, 2);\n+}\n+int g3 (vector short a)\n+{\n+  return vec_extract (a, 3);\n+}\n+\n+int g4 (vector short a)\n+{ \n+  return vec_extract (a, 4);\n+}\n+int g5 (vector short a)\n+{ \n+  return vec_extract (a, 5);\n+}\n+int g6 (vector short a)\n+{ \n+  return vec_extract (a, 6);\n+}\n+int g7 (vector short a)\n+{ \n+  return vec_extract (a, 7);\n+}\n+int g8 (vector short a)\n+{ \n+  return vec_extract (a, 8);\n+}\n+int main1(void) __attribute__((noinline));\n+int main1(void)\n+{ \n+  int i;\n+  /* Check vec_extract with a non constant element numbering */\n+  for(i=0;i<10;i++)\n+    { \n+      if (f(a, i) != (i&0x3))\n+        abort ();\n+    }\n+  \n+  /* Check vec_extract with a constant element numbering */\n+  if (f0(a) != 0)\n+    abort ();\n+  if (f1(a) != 1)\n+    abort ();\n+  if (f2(a) != 2)\n+    abort ();\n+  if (f3(a) != 3)\n+    abort ();\n+  /* Check that vec_extract works with a constant element higher than\n+     the number of elements.  */\n+  if (f4(a) != 0)\n+    abort ();\n+\n+  /* Check vec_extract with a non constant element numbering */\n+  for(i=0;i<10;i++)\n+    {\n+      if (g(b, i) != (i&0x7))\n+        abort ();\n+    }\n+  \n+  /* Check vec_extract with a constant element numbering */\n+  if (g0(b) != 0)\n+    abort ();\n+  if (g1(b) != 1)\n+    abort ();\n+  if (g2(b) != 2)\n+    abort ();\n+  if (g3(b) != 3)\n+    abort ();\n+  if (g4(b) != 4)\n+    abort ();\n+  if (g5(b) != 5)\n+    abort ();\n+  if (g6(b) != 6)\n+    abort ();\n+  if (g7(b) != 7)\n+    abort ();\n+  /* Check that vec_extract works with a constant element higher than\n+     the number of elements.  */\n+  if (g8(b) != 0)\n+    abort ();\n+  \n+  return 0;\n+}\n+\n+int main(void)\n+{ \n+  altivec_check();  /* Exits if AltiVec not supported */\n+  return main1 ();\n+}"}, {"sha": "abaf56f2770bb4ff011020e89c64c7eef0ad3bc8", "filename": "gcc/testsuite/gcc.target/powerpc/altivec-cell-3.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-3.c?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+/* Test the vec_splats and vec_promote VMX intrinsics.  */\n+#include <altivec.h>\n+#include \"altivec_check.h\"\n+    \n+extern void abort (void);\n+        \n+vector int a = {0, 0, 0, 0};\n+int main1(int t) __attribute__((noinline));\n+int main1(int t)\n+{ \n+  int i;\n+  vector int b = vec_splats(0);\n+  if (__builtin_memcmp (&a, &b, sizeof(vector int)))\n+    abort ();\n+  \n+  b = vec_splats(t);\n+  if (__builtin_memcmp (&a, &b, sizeof(vector int)))\n+    abort ();\n+  \n+  b = vec_promote(0, 1);\n+  if (vec_extract (b, 1) != 0)\n+    abort ();\n+  \n+  b = vec_promote(t, t);\n+  if (vec_extract (b, t) != 0)\n+    abort ();\n+  \n+  return 0;\n+} \n+    \n+int main(void)\n+{ \n+  altivec_check();  /* Exits if AltiVec not supported */\n+  return main1 (0);\n+}"}, {"sha": "b800ea5110519cb6568e5590c1630b7102aafdd0", "filename": "gcc/testsuite/gcc.target/powerpc/altivec-cell-4.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-4.c?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* Test the vec_splats and vec_promote VMX intrinsics.  */\n+#include <altivec.h>\n+#include \"altivec_check.h\"\n+    \n+extern void abort (void);\n+        \n+vector int a[] = {{0, 0, 0, 0}, {1,0,0,0}, {1,2,0,0},{1,2,3,0},{1,2,3,4},{5,2,3,4},{5,6,3,4}};\n+vector int c = {0,6,3,4};\n+vector int d = {0,0,3,4};\n+int main1(int t) __attribute__((noinline));\n+int main1(int t)\n+{ \n+  int i;\n+  vector int b = vec_splats(0);\n+  for(i = 0;i<sizeof(a)/sizeof(a[0])-1;i++)\n+    { \n+\tif (__builtin_memcmp (&b, &a[i], sizeof(vector int)))\n+          abort ();\n+        b = vec_insert(i+1, b, i);\n+    } \n+  if (__builtin_memcmp (&b, &a[i], sizeof(vector int)))\n+    abort ();\n+  \n+  b = vec_insert(0, b, 0);\n+  if (__builtin_memcmp (&b, &c, sizeof(vector int)))\n+    abort ();\n+  \n+  b = vec_insert(0, b, 1);\n+  if (__builtin_memcmp (&b, &d, sizeof(vector int)))\n+    abort ();\n+  \n+  return 0;\n+} \n+  \n+int main(void)\n+{\n+  altivec_check();  /* Exits if AltiVec not supported */\n+  return main1 (0);\n+}"}, {"sha": "95f109d1abeffddace062b8cedf215a66fc8ee93", "filename": "gcc/testsuite/gcc.target/powerpc/altivec-cell-5.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266b48906ac36728e24c49787c6b2e063a1f7df1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-cell-5.c?ref=266b48906ac36728e24c49787c6b2e063a1f7df1", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* Basic test for the new VMX intrinsics and error messages.  */\n+#include <altivec.h>\n+\n+int main(int argc, char **argv)\n+{\n+vector float t;\n+    vec_promote();                      /* { dg-error \"vec_promote only accepts 2\" } */\n+    vec_promote(1.0f);                  /* { dg-error \"vec_promote only accepts 2\" } */\n+    vec_promote(1.0f, 2, 3);            /* { dg-error \"vec_promote only accepts 2\" } */\n+    vec_extract ();                     /* { dg-error \"vec_extract only accepts 2\" } */\n+    vec_extract (t);                    /* { dg-error \"vec_extract only accepts 2\" } */\n+    vec_extract (t, 2);\n+    vec_extract (t, 2, 5, 6);           /* { dg-error \"vec_extract only accepts 2\" } */\n+    vec_splats ();                      /* { dg-error \"vec_splats only accepts 1\" } */\n+    vec_splats (t, 3);                  /* { dg-error \"vec_splats only accepts 1\" } */\n+    vec_insert ();                      /* { dg-error \"vec_insert only accepts 3\" } */\n+    vec_insert (t);                     /* { dg-error \"vec_insert only accepts 3\" } */\n+    vec_insert (t, 3);                  /* { dg-error \"vec_insert only accepts 3\" } */\n+    vec_insert (t, 3, 2, 4, 6, 6);      /* { dg-error \"vec_insert only accepts 3\" } */\n+    return 0;\n+}  "}]}