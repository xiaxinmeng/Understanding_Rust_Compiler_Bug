{"sha": "ef5638186202daac03feed7a20eb975991965403", "node_id": "C_kwDOANBUbNoAKGVmNTYzODE4NjIwMmRhYWMwM2ZlZWQ3YTIwZWI5NzU5OTE5NjU0MDM", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-21T16:27:05Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-22T15:00:30Z"}, "message": "parser: Add better restrictions around semicolons in statements\n\nWhen parsing macro invocations, rustc does not actually consume the\nstatement's trailing semicolon.\n\nLet's take the following example:\n```rust\nmacro_rules! one_stmt {\n    ($s:stmt) => {};\n}\n\nmacro_rules! one_or_more_stmt {\n    ($($s:stmt)*) => {};\n}\n\none_stmt!(let a = 1);\none_stmt!(let b = 2;); // error\n\none_or_more_stmt!(;); // valid\none_or_more_stmt!(let a = 15;); // valid, two statements!\none_or_more_stmt!(let a = 15 let b = 13); // valid, two statements again\n```\n\nA semicolon can count as a valid empty statement, but cannot be part of\na statement (in macro invocations). This commit adds more restrictions\nthat allow the parser to not always expect a semicolon token after the\nstatement. Furthermore, this fixes a test that was previously accepted\nby the compiler but not by rustc.", "tree": {"sha": "247ff565c1d06636f05afbd5cd7af555e6d160bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/247ff565c1d06636f05afbd5cd7af555e6d160bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef5638186202daac03feed7a20eb975991965403", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef5638186202daac03feed7a20eb975991965403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef5638186202daac03feed7a20eb975991965403", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef5638186202daac03feed7a20eb975991965403/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc6e405912c83aee41efd3015d9157cdbe9134fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc6e405912c83aee41efd3015d9157cdbe9134fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc6e405912c83aee41efd3015d9157cdbe9134fe"}], "stats": {"total": 87, "additions": 53, "deletions": 34}, "files": [{"sha": "8294008ec4e2026dbcbf72d1e0fabc00d67522ba", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef5638186202daac03feed7a20eb975991965403/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef5638186202daac03feed7a20eb975991965403/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=ef5638186202daac03feed7a20eb975991965403", "patch": "@@ -477,9 +477,12 @@ MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n       parser.parse_visibility ();\n       break;\n \n-    case AST::MacroFragSpec::STMT:\n-      parser.parse_stmt (/* allow_no_semi */ true);\n-      break;\n+      case AST::MacroFragSpec::STMT: {\n+\tauto restrictions = ParseRestrictions ();\n+\trestrictions.consume_semi = false;\n+\tparser.parse_stmt (restrictions);\n+\tbreak;\n+      }\n \n     case AST::MacroFragSpec::LIFETIME:\n       parser.parse_lifetime_params ();\n@@ -887,11 +890,14 @@ transcribe_many_trait_impl_items (Parser<MacroInvocLexer> &parser,\n static std::vector<AST::SingleASTNode>\n transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n {\n+  auto restrictions = ParseRestrictions ();\n+  restrictions.consume_semi = false;\n+\n   // FIXME: This is invalid! It needs to also handle cases where the macro\n   // transcriber is an expression, but since the macro call is followed by\n   // a semicolon, it's a valid ExprStmt\n-  return parse_many (parser, delimiter, [&parser] () {\n-    auto stmt = parser.parse_stmt (/* allow_no_semi */ true);\n+  return parse_many (parser, delimiter, [&parser, restrictions] () {\n+    auto stmt = parser.parse_stmt (restrictions);\n     return AST::SingleASTNode (std::move (stmt));\n   });\n }"}, {"sha": "a34f3d4d6ebe53c5737fca9a647a8998d0799518", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef5638186202daac03feed7a20eb975991965403/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef5638186202daac03feed7a20eb975991965403/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=ef5638186202daac03feed7a20eb975991965403", "patch": "@@ -6091,7 +6091,7 @@ Parser<ManagedTokenSource>::parse_named_function_param (\n // Parses a statement (will further disambiguate any statement).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Stmt>\n-Parser<ManagedTokenSource>::parse_stmt (bool allow_no_semi)\n+Parser<ManagedTokenSource>::parse_stmt (ParseRestrictions restrictions)\n {\n   // quick exit for empty statement\n   // FIXME: Can we have empty statements without semicolons? Just nothing?\n@@ -6116,7 +6116,7 @@ Parser<ManagedTokenSource>::parse_stmt (bool allow_no_semi)\n     {\n     case LET:\n       // let statement\n-      return parse_let_stmt (std::move (outer_attrs), allow_no_semi);\n+      return parse_let_stmt (std::move (outer_attrs), restrictions);\n     case PUB:\n     case MOD:\n     case EXTERN_TOK:\n@@ -6171,7 +6171,7 @@ Parser<ManagedTokenSource>::parse_stmt (bool allow_no_semi)\n       // TODO: find out how to disable gcc \"implicit fallthrough\" warning\n     default:\n       // fallback: expression statement\n-      return parse_expr_stmt (std::move (outer_attrs), allow_no_semi);\n+      return parse_expr_stmt (std::move (outer_attrs), restrictions);\n       break;\n     }\n }\n@@ -6180,7 +6180,7 @@ Parser<ManagedTokenSource>::parse_stmt (bool allow_no_semi)\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::LetStmt>\n Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs,\n-\t\t\t\t\t    bool allow_no_semi)\n+\t\t\t\t\t    ParseRestrictions restrictions)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (LET);\n@@ -6235,13 +6235,9 @@ Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs,\n \t}\n     }\n \n-  if (!maybe_skip_token (SEMICOLON) && !allow_no_semi)\n-    {\n-      // skip after somewhere\n+  if (restrictions.consume_semi)\n+    if (!skip_token (SEMICOLON))\n       return nullptr;\n-      /* TODO: how wise is it to ditch a mostly-valid let statement just\n-       * because a semicolon is missing? */\n-    }\n \n   return std::unique_ptr<AST::LetStmt> (\n     new AST::LetStmt (std::move (pattern), std::move (expr), std::move (type),\n@@ -7076,7 +7072,7 @@ Parser<ManagedTokenSource>::parse_method ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmt>\n Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n-\t\t\t\t\t     bool allow_no_semi)\n+\t\t\t\t\t     ParseRestrictions restrictions)\n {\n   /* potential thoughts - define new virtual method \"has_block()\" on expr. parse\n    * expr and then determine whether semicolon is needed as a result of this\n@@ -7116,7 +7112,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n \telse\n \t  {\n \t    return parse_expr_stmt_without_block (std::move (outer_attrs),\n-\t\t\t\t\t\t  allow_no_semi);\n+\t\t\t\t\t\t  restrictions);\n \t  }\n       }\n       case UNSAFE: {\n@@ -7130,7 +7126,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n \telse\n \t  {\n \t    return parse_expr_stmt_without_block (std::move (outer_attrs),\n-\t\t\t\t\t\t  allow_no_semi);\n+\t\t\t\t\t\t  restrictions);\n \t  }\n       }\n     default:\n@@ -7139,7 +7135,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n        * initial tokens in order to prevent more syntactical errors at parse\n        * time. */\n       return parse_expr_stmt_without_block (std::move (outer_attrs),\n-\t\t\t\t\t    allow_no_semi);\n+\t\t\t\t\t    restrictions);\n     }\n }\n \n@@ -7255,7 +7251,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt_with_block (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmtWithoutBlock>\n Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n-  AST::AttrVec outer_attrs, bool allow_no_semi)\n+  AST::AttrVec outer_attrs, ParseRestrictions restrictions)\n {\n   /* TODO: maybe move more logic for expr without block in here for better error\n    * handling */\n@@ -7264,7 +7260,6 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n   std::unique_ptr<AST::ExprWithoutBlock> expr = nullptr;\n   Location locus = lexer.peek_token ()->get_locus ();\n \n-  auto restrictions = ParseRestrictions ();\n   restrictions.expr_can_be_stmt = true;\n \n   expr = parse_expr_without_block (std::move (outer_attrs), restrictions);\n@@ -7279,12 +7274,9 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n       return nullptr;\n     }\n \n-  // skip semicolon at end that is required\n-  if (!maybe_skip_token (SEMICOLON) && !allow_no_semi)\n-    {\n-      // skip somewhere?\n+  if (restrictions.consume_semi)\n+    if (!skip_token (SEMICOLON))\n       return nullptr;\n-    }\n \n   return std::unique_ptr<AST::ExprStmtWithoutBlock> (\n     new AST::ExprStmtWithoutBlock (std::move (expr), locus));"}, {"sha": "c00dc11d6bb77dffd19b14a6aec1c32378ab6fa4", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef5638186202daac03feed7a20eb975991965403/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef5638186202daac03feed7a20eb975991965403/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=ef5638186202daac03feed7a20eb975991965403", "patch": "@@ -81,6 +81,7 @@ struct ParseRestrictions\n   bool entered_from_unary = false;\n   bool expr_can_be_null = false;\n   bool expr_can_be_stmt = false;\n+  bool consume_semi = true;\n };\n \n // Parser implementation for gccrs.\n@@ -129,11 +130,9 @@ template <typename ManagedTokenSource> class Parser\n    *    | LetStatement\n    *    | ExpressionStatement\n    *    | MacroInvocationSemi\n-   *\n-   * @param allow_no_semi Allow the parser to not parse a semicolon after\n-   * \t\tthe statement without erroring out\n    */\n-  std::unique_ptr<AST::Stmt> parse_stmt (bool allow_no_semi = false);\n+  std::unique_ptr<AST::Stmt> parse_stmt (ParseRestrictions restrictions\n+\t\t\t\t\t = ParseRestrictions ());\n   std::unique_ptr<AST::Type> parse_type ();\n   std::unique_ptr<AST::ExternalItem> parse_external_item ();\n   std::unique_ptr<AST::TraitItem> parse_trait_item ();\n@@ -616,14 +615,17 @@ template <typename ManagedTokenSource> class Parser\n    * \t\tsemicolon to follow it\n    */\n   std::unique_ptr<AST::LetStmt> parse_let_stmt (AST::AttrVec outer_attrs,\n-\t\t\t\t\t\tbool allow_no_semi = false);\n+\t\t\t\t\t\tParseRestrictions restrictions\n+\t\t\t\t\t\t= ParseRestrictions ());\n   std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs,\n-\t\t\t\t\t\t  bool allow_no_semi = false);\n+\t\t\t\t\t\t  ParseRestrictions restrictions\n+\t\t\t\t\t\t  = ParseRestrictions ());\n   std::unique_ptr<AST::ExprStmtWithBlock>\n   parse_expr_stmt_with_block (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprStmtWithoutBlock>\n   parse_expr_stmt_without_block (AST::AttrVec outer_attrs,\n-\t\t\t\t bool allow_no_semi = false);\n+\t\t\t\t ParseRestrictions restrictions\n+\t\t\t\t = ParseRestrictions ());\n   ExprOrStmt parse_stmt_or_expr_without_block ();\n   ExprOrStmt parse_stmt_or_expr_with_block (AST::AttrVec outer_attrs);\n   ExprOrStmt parse_macro_invocation_maybe_semi (AST::AttrVec outer_attrs);"}, {"sha": "5418725b619cd0e708fc2f24d935e8c7ad83e4f4", "filename": "gcc/testsuite/rust/compile/macro18.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef5638186202daac03feed7a20eb975991965403/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef5638186202daac03feed7a20eb975991965403/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs?ref=ef5638186202daac03feed7a20eb975991965403", "patch": "@@ -7,7 +7,7 @@ macro_rules! take_stmt {\n }\n \n fn main() -> i32 {\n-    take_stmt!(let complete = 15;);\n+    take_stmt!(let complete = 15;); // { dg-error \"Failed to match any rule within macro\" }\n     take_stmt!(let lacking = 14);\n \n     0"}, {"sha": "d1d6305e6bdd005a0a696037926389ae9767c85b", "filename": "gcc/testsuite/rust/compile/macro32.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef5638186202daac03feed7a20eb975991965403/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro32.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef5638186202daac03feed7a20eb975991965403/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro32.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro32.rs?ref=ef5638186202daac03feed7a20eb975991965403", "patch": "@@ -0,0 +1,19 @@\n+macro_rules! s {\n+    ($s:stmt) => {{}};\n+}\n+\n+macro_rules! multi_s {\n+    ($($s:stmt)+) => {{}};\n+}\n+\n+fn main() -> i32 {\n+    s!(let a = 15);\n+    s!(;); // Empty statement\n+    s!(let a = 15;); // { dg-error \"Failed to match any rule within macro\" }\n+    multi_s!(let a = 15;);\n+    // ^ this actually gets parsed as two statements - one LetStmt and one\n+    // empty statement. This is the same behavior as rustc, which you can\n+    // see using a count!() macro\n+\n+    32\n+}"}]}