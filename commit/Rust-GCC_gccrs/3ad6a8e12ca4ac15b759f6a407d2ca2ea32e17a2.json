{"sha": "3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FkNmE4ZTEyY2E0YWMxNWI3NTlmNmE0MDdkMmNhMmVhMzJlMTdhMg==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2007-07-27T17:43:05Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-07-27T17:43:05Z"}, "message": "typeck.c (structural_comptypes): Compare DECLTYPE_TYPE nodes.\n\n2007-07-27  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* typeck.c (structural_comptypes): Compare DECLTYPE_TYPE nodes.\n\t* cp-tree.def (DECLTYPE_TYPE): New.\n\t* error.c (dump_type): Dump DECLTYPE_TYPE nodes.\n\t(dump_type_prefix): Ditto.\n\t(dump_type_suffix): Ditto.\n\t* tree.c (DECLTYPE_TYPE): Walk DECLTYPE_TYPE nodes.\n\t* mangle.c (write_type): Handle DECLTYPE_TYPE.\n\t* cp-tree.h (IS_AGGR_TYPE): DECLTYPE_TYPE nodes can be aggregate\n\ttypes.\n\t(DECLTYPE_TYPE_EXPR): New.\n\t(DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P): New.\n\t(finish_declared_type): Declare.\n\t* cxx-pretty-print.c (pp_cxx_type_specifier_seq): Print\n\tDECLTYPE_TYPE nodes.\n\t(pp_cxx_type_id): Ditto.\n\t* pt.c (for_each_template_parm_r): Walk DECLTYPE_TYPE children.\n\t(tsubst): Substitute into a DECLTYPE_TYPE node.\n\t(tsubst_copy): Ditto.\n\t(unify): Cannot deduce anything from TYPEOF_TYPE or DECLTYPE_TYPE\n\tnodes.\n\t(dependent_type_p_r): DECLTYPE_TYPE types are always dependent.\n\t* semantics.c (finish_typeof): TYPEOF_TYPE types need to use\n\tstructural equality (because we can't hash the expressions).\n\t(finish_declared_type): New.\n\t* lex.c (reswords): Add \"decltype\" keyword.\n\t* parser.c cp_lexer_next_token_is_decl_specifier_keyword\n\t(cp_parser_postfix_expression): Add member_access_only_p to\n\trestrict postfix expression to member access expressions.\n\t(cp_parser_unary_expression): Update call to\n\tcp_parser_postfix_expression to reflect new parameter.\n\t(cp_parser_declared_type): New.\n\t(cp_parser_simple_type_specifier): Parse decltype types.\n\n2007-07-27  Douglas Gregor  <doug.gregor@gmail.com>\n\t\n       * c-common.h (enum rid): Add RID_DECLTYPE, update RID_LAST_CXX0X.\n\n2007-07-27  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* g++.dg/cpp0x/decltype1.C: New.\n\t* g++.dg/cpp0x/decltype2.C: New.\n\t* g++.dg/cpp0x/decltype3.C: New.\n\t* g++.dg/cpp0x/decltype4.C: New.\n\t* g++.dg/cpp0x/decltype5.C: New.\n\t* g++.dg/cpp0x/decltype6.C: New.\n\nFrom-SVN: r126991", "tree": {"sha": "1fd8c965b4122258e1d88e04db3ecb09a3757908", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fd8c965b4122258e1d88e04db3ecb09a3757908"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a67955f0815ecf2892c635ca4128a5f414eb507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a67955f0815ecf2892c635ca4128a5f414eb507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a67955f0815ecf2892c635ca4128a5f414eb507"}], "stats": {"total": 829, "additions": 819, "deletions": 10}, "files": [{"sha": "283c3430c4e221b521ed82e0f335258a6b3f7ddc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -1,3 +1,7 @@\n+2007-07-27  Douglas Gregor  <doug.gregor@gmail.com>\n+\t\n+       * c-common.h (enum rid): Add RID_DECLTYPE, update RID_LAST_CXX0X.\n+\n 2007-07-26  Kenneth Zadeck <zadeck@naturalbridge.com>\n \n \tPR middle-end/32749"}, {"sha": "cb2c56bf5b86a3ea03000e5151b1509292ffd55c", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -101,7 +101,7 @@ enum rid\n   RID_IS_UNION,\n \n   /* C++0x */\n-  RID_STATIC_ASSERT,\n+  RID_STATIC_ASSERT, RID_DECLTYPE,\n \n   /* Objective-C */\n   RID_AT_ENCODE,   RID_AT_END,\n@@ -119,7 +119,7 @@ enum rid\n   RID_LAST_MODIFIER = RID_ONEWAY,\n \n   RID_FIRST_CXX0X = RID_STATIC_ASSERT,\n-  RID_LAST_CXX0X = RID_STATIC_ASSERT,\n+  RID_LAST_CXX0X = RID_DECLTYPE,\n   RID_FIRST_AT = RID_AT_ENCODE,\n   RID_LAST_AT = RID_AT_IMPLEMENTATION,\n   RID_FIRST_PQ = RID_IN,"}, {"sha": "51412983ee0d5aa5562da87bafe4b9d1e02aa314", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -1,3 +1,38 @@\n+2007-07-27  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* typeck.c (structural_comptypes): Compare DECLTYPE_TYPE nodes.\n+\t* cp-tree.def (DECLTYPE_TYPE): New.\n+\t* error.c (dump_type): Dump DECLTYPE_TYPE nodes.\n+\t(dump_type_prefix): Ditto.\n+\t(dump_type_suffix): Ditto.\n+\t* tree.c (DECLTYPE_TYPE): Walk DECLTYPE_TYPE nodes.\n+\t* mangle.c (write_type): Handle DECLTYPE_TYPE.\n+\t* cp-tree.h (IS_AGGR_TYPE): DECLTYPE_TYPE nodes can be aggregate\n+\ttypes.\n+\t(DECLTYPE_TYPE_EXPR): New.\n+\t(DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P): New.\n+\t(finish_declared_type): Declare.\n+\t* cxx-pretty-print.c (pp_cxx_type_specifier_seq): Print\n+\tDECLTYPE_TYPE nodes.\n+\t(pp_cxx_type_id): Ditto.\n+\t* pt.c (for_each_template_parm_r): Walk DECLTYPE_TYPE children.\n+\t(tsubst): Substitute into a DECLTYPE_TYPE node.\n+\t(tsubst_copy): Ditto.\n+\t(unify): Cannot deduce anything from TYPEOF_TYPE or DECLTYPE_TYPE\n+\tnodes.\n+\t(dependent_type_p_r): DECLTYPE_TYPE types are always dependent.\n+\t* semantics.c (finish_typeof): TYPEOF_TYPE types need to use\n+\tstructural equality (because we can't hash the expressions).\n+\t(finish_declared_type): New.\n+\t* lex.c (reswords): Add \"decltype\" keyword.\n+\t* parser.c cp_lexer_next_token_is_decl_specifier_keyword\n+\t(cp_parser_postfix_expression): Add member_access_only_p to\n+\trestrict postfix expression to member access expressions.\n+\t(cp_parser_unary_expression): Update call to\n+\tcp_parser_postfix_expression to reflect new parameter.\n+\t(cp_parser_declared_type): New.\n+\t(cp_parser_simple_type_specifier): Parse decltype types.\n+\n 2007-07-27  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/32346"}, {"sha": "3dd6646efc806382ea9f55ccc2e6d30114730db6", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -427,6 +427,13 @@ DEFTREECODE (ARGUMENT_PACK_SELECT, \"argument_pack_select\", tcc_exceptional, 0)\n /* Represents a trait expression during template expansion.  */\n DEFTREECODE (TRAIT_EXPR, \"trait_expr\", tcc_exceptional, 0)\n \n+/* The declared type of an expression.  This is a C++0x extension.\n+   DECLTYPE_TYPE_EXPR is the expression whose type we are computing.\n+   DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P states whether the\n+   expression was parsed as an id-expression or a member access\n+   expression. When false, it was parsed as a full expression.  */\n+DEFTREECODE (DECLTYPE_TYPE, \"decltype_type\", tcc_type, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "52cd6ae6d9c177c9f6628c6755ea5b6d58ffbaf0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -977,6 +977,7 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n    || TREE_CODE (T) == TYPENAME_TYPE\t\t\t\\\n    || TREE_CODE (T) == TYPEOF_TYPE\t\t\t\\\n    || TREE_CODE (T) == BOUND_TEMPLATE_TEMPLATE_PARM\t\\\n+   || TREE_CODE (T) == DECLTYPE_TYPE\t\t\t\\\n    || TYPE_LANG_FLAG_5 (T))\n \n /* Set IS_AGGR_TYPE for T to VAL.  T must be a class, struct, or\n@@ -2921,6 +2922,15 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n /* The expression in question for a TYPEOF_TYPE.  */\n #define TYPEOF_TYPE_EXPR(NODE) (TYPEOF_TYPE_CHECK (NODE))->type.values\n \n+/* The expression in question for a DECLTYPE_TYPE.  */\n+#define DECLTYPE_TYPE_EXPR(NODE) (DECLTYPE_TYPE_CHECK (NODE))->type.values\n+\n+/* Whether the DECLTYPE_TYPE_EXPR of NODE was originally parsed as an\n+   id-expression or a member-access expression. When false, it was\n+   parsed as a full expression.  */\n+#define DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P(NODE) \\\n+  (DECLTYPE_TYPE_CHECK (NODE))->type.string_flag\n+\n /* Nonzero for VAR_DECL and FUNCTION_DECL node means that `extern' was\n    specified in its declaration.  This can also be set for an\n    erroneously declared PARM_DECL.  */\n@@ -4657,6 +4667,7 @@ extern bool cxx_omp_privatize_by_reference\t(tree);\n extern tree baselink_for_fns                    (tree);\n extern void finish_static_assert                (tree, tree, location_t,\n                                                  bool);\n+extern tree finish_decltype_type                (tree, bool);\n extern tree finish_trait_expr\t\t\t(enum cp_trait_kind, tree, tree);\n \n /* in tree.c */"}, {"sha": "9717969639f10c8f1ee461def3fc43750676bcf0", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -1198,6 +1198,13 @@ pp_cxx_type_specifier_seq (cxx_pretty_printer *pp, tree t)\n       pp_cxx_nested_name_specifier (pp, TYPE_METHOD_BASETYPE (t));\n       break;\n \n+    case DECLTYPE_TYPE:\n+      pp_cxx_identifier (pp, \"decltype\");\n+      pp_cxx_left_paren (pp);\n+      pp_cxx_expression (pp, DECLTYPE_TYPE_EXPR (t));\n+      pp_cxx_right_paren (pp);\n+      break;\n+\n     default:\n       if (!(TREE_CODE (t) == FUNCTION_DECL && DECL_CONSTRUCTOR_P (t)))\n \tpp_c_specifier_qualifier_list (pp_c_base (pp), t);\n@@ -1581,6 +1588,7 @@ pp_cxx_type_id (cxx_pretty_printer *pp, tree t)\n     case TEMPLATE_PARM_INDEX:\n     case TEMPLATE_DECL:\n     case TYPEOF_TYPE:\n+    case DECLTYPE_TYPE:\n     case TEMPLATE_ID_EXPR:\n       pp_cxx_type_specifier_seq (pp, t);\n       break;"}, {"sha": "7df92561d7828a09f4c34d47cfc35fb14c9affb4", "filename": "gcc/cp/error.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -408,6 +408,14 @@ dump_type (tree t, int flags)\n       }\n       break;\n \n+    case DECLTYPE_TYPE:\n+      pp_cxx_identifier (cxx_pp, \"decltype\");\n+      pp_cxx_whitespace (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n+      dump_expr (DECLTYPE_TYPE_EXPR (t), flags & ~TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_paren (cxx_pp);\n+      break;\n+\n     default:\n       pp_unsupported_tree (cxx_pp, t);\n       /* Fall through to error.  */\n@@ -611,6 +619,7 @@ dump_type_prefix (tree t, int flags)\n     case COMPLEX_TYPE:\n     case VECTOR_TYPE:\n     case TYPEOF_TYPE:\n+    case DECLTYPE_TYPE:\n       dump_type (t, flags);\n       pp_base (cxx_pp)->padding = pp_before;\n       break;\n@@ -707,6 +716,7 @@ dump_type_suffix (tree t, int flags)\n     case COMPLEX_TYPE:\n     case VECTOR_TYPE:\n     case TYPEOF_TYPE:\n+    case DECLTYPE_TYPE:\n       break;\n \n     default:"}, {"sha": "6aefb4729bb84f211a845ae6a2397548d32c9afc", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -197,6 +197,7 @@ static const struct resword reswords[] =\n   { \"__complex__\",\tRID_COMPLEX,\t0 },\n   { \"__const\",\t\tRID_CONST,\t0 },\n   { \"__const__\",\tRID_CONST,\t0 },\n+  { \"__decltype\",       RID_DECLTYPE,   0 },\n   { \"__extension__\",\tRID_EXTENSION,\t0 },\n   { \"__func__\",\t\tRID_C99_FUNCTION_NAME,\t0 },\n   { \"__has_nothrow_assign\", RID_HAS_NOTHROW_ASSIGN, 0 },\n@@ -244,6 +245,7 @@ static const struct resword reswords[] =\n   { \"const\",\t\tRID_CONST,\t0 },\n   { \"const_cast\",\tRID_CONSTCAST,\t0 },\n   { \"continue\",\t\tRID_CONTINUE,\t0 },\n+  { \"decltype\",         RID_DECLTYPE,   D_CXX0X },\n   { \"default\",\t\tRID_DEFAULT,\t0 },\n   { \"delete\",\t\tRID_DELETE,\t0 },\n   { \"do\",\t\tRID_DO,\t\t0 },"}, {"sha": "7318f493cf3f47f269f00a10680e35aba49a60d7", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -1544,6 +1544,9 @@ write_local_name (const tree function, const tree local_entity,\n    C++0x extensions\n \n      <type> ::= RR <type>   # rvalue reference-to\n+     <type> ::= Dt <expression> # decltype of an id-expression or \n+                                # class member access\n+     <type> ::= DT <expression> # decltype of an expression\n \n    TYPE is a type node.  */\n \n@@ -1674,6 +1677,16 @@ write_type (tree type)\n               write_type (PACK_EXPANSION_PATTERN (type));\n               break;\n \n+            case DECLTYPE_TYPE:\n+              write_char ('D');\n+              if (DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (type))\n+                write_char ('t');\n+              else\n+                write_char ('T');\n+              write_expression (DECLTYPE_TYPE_EXPR (type));\n+              write_char ('E');\n+              break;\n+\n \t    default:\n \t      gcc_unreachable ();\n \t    }"}, {"sha": "a7190cb884ba6058a04d098aaa528466ed9efcbf", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 197, "deletions": 4, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -577,6 +577,8 @@ cp_lexer_next_token_is_decl_specifier_keyword (cp_lexer *lexer)\n       /* GNU extensions.  */ \n     case RID_ATTRIBUTE:\n     case RID_TYPEOF:\n+      /* C++0x extensions.  */\n+    case RID_DECLTYPE:\n       return true;\n \n     default:\n@@ -1582,7 +1584,7 @@ static tree cp_parser_nested_name_specifier\n static tree cp_parser_class_or_namespace_name\n   (cp_parser *, bool, bool, bool, bool, bool);\n static tree cp_parser_postfix_expression\n-  (cp_parser *, bool, bool);\n+  (cp_parser *, bool, bool, bool);\n static tree cp_parser_postfix_open_square_expression\n   (cp_parser *, tree, bool);\n static tree cp_parser_postfix_dot_deref_expression\n@@ -1707,6 +1709,8 @@ static void cp_parser_linkage_specification\n   (cp_parser *);\n static void cp_parser_static_assert\n   (cp_parser *, bool);\n+static tree cp_parser_decltype\n+  (cp_parser *);\n \n /* Declarators [gram.dcl.decl] */\n \n@@ -4254,15 +4258,20 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n    `&' operator.  CAST_P is true if this expression is the target of a\n    cast.\n \n+   If MEMBER_ACCESS_ONLY_P, we only allow postfix expressions that are\n+   class member access expressions [expr.ref].\n+\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n+cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n+                              bool member_access_only_p)\n {\n   cp_token *token;\n   enum rid keyword;\n   cp_id_kind idk = CP_ID_KIND_NONE;\n   tree postfix_expression = NULL_TREE;\n+  bool is_member_access = false;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -4513,6 +4522,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t\t\t\t\t\t\tpostfix_expression,\n \t\t\t\t\t\t\tfalse);\n \t  idk = CP_ID_KIND_NONE;\n+          is_member_access = false;\n \t  break;\n \n \tcase CPP_OPEN_PAREN:\n@@ -4524,6 +4534,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t    bool saved_non_integral_constant_expression_p = false;\n \t    tree args;\n \n+            is_member_access = false;\n+\n \t    is_builtin_constant_p\n \t      = DECL_IS_BUILTIN_CONSTANT_P (postfix_expression);\n \t    if (is_builtin_constant_p)\n@@ -4669,6 +4681,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t    = cp_parser_postfix_dot_deref_expression (parser, token->type,\n \t\t\t\t\t\t      postfix_expression,\n \t\t\t\t\t\t      false, &idk);\n+\n+          is_member_access = true;\n \t  break;\n \n \tcase CPP_PLUS_PLUS:\n@@ -4684,6 +4698,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t\t\t\t\t\t\t  \"an increment\"))\n \t    postfix_expression = error_mark_node;\n \t  idk = CP_ID_KIND_NONE;\n+          is_member_access = false;\n \t  break;\n \n \tcase CPP_MINUS_MINUS:\n@@ -4699,10 +4714,14 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t\t\t\t\t\t\t  \"a decrement\"))\n \t    postfix_expression = error_mark_node;\n \t  idk = CP_ID_KIND_NONE;\n+          is_member_access = false;\n \t  break;\n \n \tdefault:\n-\t  return postfix_expression;\n+          if (member_access_only_p)\n+            return is_member_access? postfix_expression : error_mark_node;\n+          else\n+            return postfix_expression;\n \t}\n     }\n \n@@ -5341,7 +5360,8 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p)\n       return expression;\n     }\n \n-  return cp_parser_postfix_expression (parser, address_p, cast_p);\n+  return cp_parser_postfix_expression (parser, address_p, cast_p,\n+                                       /*member_access_only_p=*/false);\n }\n \n /* Returns ERROR_MARK if TOKEN is not a unary-operator.  If TOKEN is a\n@@ -8371,6 +8391,164 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n   finish_static_assert (condition, message, saved_loc, member_p);\n }\n \n+/* Parse a `decltype' type. Returns the type. \n+\n+   simple-type-specifier:\n+     decltype ( expression )  */\n+\n+static tree\n+cp_parser_decltype (cp_parser *parser)\n+{\n+  tree expr;\n+  bool id_expression_or_member_access_p = false;\n+  const char *saved_message;\n+  bool saved_integral_constant_expression_p;\n+  bool saved_non_integral_constant_expression_p;\n+\n+  /* Look for the `decltype' token.  */\n+  if (!cp_parser_require_keyword (parser, RID_DECLTYPE, \"`decltype'\"))\n+    return error_mark_node;\n+\n+  /* Types cannot be defined in a `decltype' expression.  Save away the\n+     old message.  */\n+  saved_message = parser->type_definition_forbidden_message;\n+\n+  /* And create the new one.  */\n+  parser->type_definition_forbidden_message\n+    = \"types may not be defined in `decltype' expressions\";\n+\n+  /* The restrictions on constant-expressions do not apply inside\n+     decltype expressions.  */\n+  saved_integral_constant_expression_p\n+    = parser->integral_constant_expression_p;\n+  saved_non_integral_constant_expression_p\n+    = parser->non_integral_constant_expression_p;\n+  parser->integral_constant_expression_p = false;\n+\n+  /* Do not actually evaluate the expression.  */\n+  ++skip_evaluation;\n+\n+  /* Parse the opening `('.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  \n+  /* First, try parsing an id-expression.  */\n+  cp_parser_parse_tentatively (parser);\n+  expr = cp_parser_id_expression (parser,\n+                                  /*template_keyword_p=*/false,\n+                                  /*check_dependency_p=*/true,\n+                                  /*template_p=*/NULL,\n+                                  /*declarator_p=*/false,\n+                                  /*optional_p=*/false);\n+\n+  if (!cp_parser_error_occurred (parser) && expr != error_mark_node)\n+    {\n+      bool non_integral_constant_expression_p = false;\n+      tree id_expression = expr;\n+      cp_id_kind idk;\n+      const char *error_msg;\n+\n+      /* Lookup the name we got back from the id-expression.  */\n+      expr = cp_parser_lookup_name (parser, expr,\n+                                    none_type,\n+                                    /*is_template=*/false,\n+                                    /*is_namespace=*/false,\n+                                    /*check_dependency=*/true,\n+                                    /*ambiguous_decls=*/NULL);\n+      \n+      if (expr \n+          && expr != error_mark_node\n+          && TREE_CODE (expr) != TEMPLATE_ID_EXPR\n+          && TREE_CODE (expr) != TYPE_DECL\n+          && cp_lexer_peek_token (parser->lexer)->type == CPP_CLOSE_PAREN)\n+        {\n+          /* Complete lookup of the id-expression.  */\n+          expr = (finish_id_expression\n+                  (id_expression, expr, parser->scope, &idk,\n+                   /*integral_constant_expression_p=*/false,\n+                   /*allow_non_integral_constant_expression_p=*/true,\n+                   &non_integral_constant_expression_p,\n+                   /*template_p=*/false,\n+                   /*done=*/true,\n+                   /*address_p=*/false,\n+                   /*template_arg_p=*/false,\n+                   &error_msg));\n+\n+          if (expr == error_mark_node)\n+            /* We found an id-expression, but it was something that we\n+               should not have found. This is an error, not something\n+               we can recover from, so note that we found an\n+               id-expression and we'll recover as gracefully as\n+               possible.  */\n+            id_expression_or_member_access_p = true;\n+        }\n+\n+      if (expr \n+          && expr != error_mark_node\n+          && cp_lexer_peek_token (parser->lexer)->type == CPP_CLOSE_PAREN)\n+        /* We have an id-expression.  */\n+        id_expression_or_member_access_p = true;\n+    }\n+\n+  if (!id_expression_or_member_access_p)\n+    {\n+      /* Abort the id-expression parse.  */\n+      cp_parser_abort_tentative_parse (parser);\n+\n+      /* Parsing tentatively, again.  */\n+      cp_parser_parse_tentatively (parser);\n+\n+      /* Parse a class member access.  */\n+      expr = cp_parser_postfix_expression (parser, /*address_p=*/false,\n+                                           /*cast_p=*/false,\n+                                           /*member_access_only_p=*/true);\n+\n+      if (expr \n+          && expr != error_mark_node\n+          && cp_lexer_peek_token (parser->lexer)->type == CPP_CLOSE_PAREN)\n+        /* We have an id-expression.  */\n+        id_expression_or_member_access_p = true;\n+    }\n+\n+  if (id_expression_or_member_access_p)\n+    /* We have parsed the complete id-expression or member access.  */\n+    cp_parser_parse_definitely (parser);\n+  else\n+    {\n+      /* Abort our attempt to parse an id-expression or member access\n+         expression.  */\n+      cp_parser_abort_tentative_parse (parser);\n+\n+      /* Parse a full expression.  */\n+      expr = cp_parser_expression (parser, /*cast_p=*/false);\n+    }\n+\n+  /* Go back to evaluating expressions.  */\n+  --skip_evaluation;\n+\n+  /* Restore the old message and the integral constant expression\n+     flags.  */\n+  parser->type_definition_forbidden_message = saved_message;\n+  parser->integral_constant_expression_p\n+    = saved_integral_constant_expression_p;\n+  parser->non_integral_constant_expression_p\n+    = saved_non_integral_constant_expression_p;\n+\n+  if (expr == error_mark_node)\n+    {\n+      /* Skip everything up to the closing `)'.  */\n+      cp_parser_skip_to_closing_parenthesis (parser, true, false,\n+                                             /*consume_paren=*/true);\n+      return error_mark_node;\n+    }\n+  \n+  /* Parse to the closing `)'.  */\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+    cp_parser_skip_to_closing_parenthesis (parser, true, false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  return finish_decltype_type (expr, id_expression_or_member_access_p);\n+}\n+\n /* Special member functions [gram.special] */\n \n /* Parse a conversion-function-id.\n@@ -10438,6 +10616,11 @@ cp_parser_type_specifier (cp_parser* parser,\n      double\n      void\n \n+   C++0x Extension:\n+\n+   simple-type-specifier:\n+     decltype ( expression )   \n+\n    GNU Extension:\n \n    simple-type-specifier:\n@@ -10507,6 +10690,16 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       type = void_type_node;\n       break;\n \n+    case RID_DECLTYPE:\n+      /* Parse the `decltype' type.  */\n+      type = cp_parser_decltype (parser);\n+\n+      if (decl_specs)\n+\tcp_parser_set_decl_spec_type (decl_specs, type,\n+\t\t\t\t      /*user_defined_p=*/true);\n+\n+      return type;\n+\n     case RID_TYPEOF:\n       /* Consume the `typeof' token.  */\n       cp_lexer_consume_token (parser->lexer);"}, {"sha": "d05bfd29e37f7d994ab33a605860ba18bc5a2219", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -9058,6 +9058,22 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t\t     complain);\n       }\n \n+    case DECLTYPE_TYPE:\n+      {\n+\ttree type;\n+\n+\ttype = \n+          finish_decltype_type (tsubst_expr \n+                                (DECLTYPE_TYPE_EXPR (t), args,\n+                                 complain, in_decl,\n+                                 /*integral_constant_expression_p=*/false),\n+                                DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t));\n+\treturn cp_build_qualified_type_real (type,\n+\t\t\t\t\t     cp_type_quals (t)\n+\t\t\t\t\t     | cp_type_quals (type),\n+\t\t\t\t\t     complain);\n+      }\n+\n     case TYPE_ARGUMENT_PACK:\n     case NONTYPE_ARGUMENT_PACK:\n       {\n@@ -9621,6 +9637,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case TYPENAME_TYPE:\n     case UNBOUND_CLASS_TEMPLATE:\n     case TYPEOF_TYPE:\n+    case DECLTYPE_TYPE:\n     case TYPE_DECL:\n       return tsubst (t, args, complain, in_decl);\n \n@@ -12824,6 +12841,12 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n       break;\n \n+    case TYPEOF_TYPE:\n+    case DECLTYPE_TYPE:\n+      /* Cannot deduce anything from TYPEOF_TYPE or DECLTYPE_TYPE\n+         nodes.  */\n+      return 0;\n+\n     default:\n       gcc_assert (EXPR_P (parm));\n \n@@ -14888,10 +14911,11 @@ dependent_type_p_r (tree type)\n \t       (INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type)))))\n     return true;\n \n-  /* All TYPEOF_TYPEs are dependent; if the argument of the `typeof'\n-     expression is not type-dependent, then it should already been\n-     have resolved.  */\n-  if (TREE_CODE (type) == TYPEOF_TYPE)\n+  /* All TYPEOF_TYPEs and DECLTYPE_TYPEs are dependent; if the\n+     argument of the `typeof' expression is not type-dependent, then\n+     it should already been have resolved.  */\n+  if (TREE_CODE (type) == TYPEOF_TYPE\n+      || TREE_CODE (type) == DECLTYPE_TYPE)\n     return true;\n \n   /* A template argument pack is dependent if any of its packed"}, {"sha": "b03ec2f59ae9861394a45935a1d63b4753a80c77", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -2935,6 +2935,7 @@ finish_typeof (tree expr)\n     {\n       type = make_aggr_type (TYPEOF_TYPE);\n       TYPEOF_TYPE_EXPR (type) = expr;\n+      SET_TYPE_STRUCTURAL_EQUALITY (type);\n \n       return type;\n     }\n@@ -4036,6 +4037,169 @@ finish_static_assert (tree condition, tree message, location_t location,\n       input_location = saved_loc;\n     }\n }\n+\f\n+/* Implements the C++0x decltype keyword. Returns the type of EXPR,\n+   suitable for use as a type-specifier.\n+\n+   ID_EXPRESSION_OR_MEMBER_ACCESS_P is true when EXPR was parsed as an\n+   id-expression or a class member access, FALSE when it was parsed as\n+   a full expression.  */\n+tree\n+finish_decltype_type (tree expr, bool id_expression_or_member_access_p)\n+{\n+  tree orig_expr = expr;\n+  tree type;\n+\n+  if (type_dependent_expression_p (expr))\n+    {\n+      type = make_aggr_type (DECLTYPE_TYPE);\n+      DECLTYPE_TYPE_EXPR (type) = expr;\n+      DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (type)\n+        = id_expression_or_member_access_p;\n+      SET_TYPE_STRUCTURAL_EQUALITY (type);\n+\n+      return type;\n+    }\n+\n+  /* The type denoted by decltype(e) is defined as follows:  */\n+\n+  if (id_expression_or_member_access_p)\n+    {\n+      /* If e is an id-expression or a class member access (5.2.5\n+         [expr.ref]), decltype(e) is defined as the type of the entity\n+         named by e. If there is no such entity, or e names a set of\n+         overloaded functions, the program is ill-formed.  */\n+      if (TREE_CODE (expr) == IDENTIFIER_NODE)\n+        expr = lookup_name (expr);\n+\n+      if (TREE_CODE (expr) == INDIRECT_REF)\n+        /* This can happen when the expression is, e.g., \"a.b\". Just\n+           look at the underlying operand.  */\n+        expr = TREE_OPERAND (expr, 0);\n+\n+      if (TREE_CODE (expr) == OFFSET_REF\n+          || TREE_CODE (expr) == MEMBER_REF)\n+        /* We're only interested in the field itself. If it is a\n+           BASELINK, we will need to see through it in the next\n+           step.  */\n+        expr = TREE_OPERAND (expr, 1);\n+\n+      if (TREE_CODE (expr) == BASELINK)\n+        /* See through BASELINK nodes to the underlying functions.  */\n+        expr = BASELINK_FUNCTIONS (expr);\n+\n+      if (TREE_CODE (expr) == OVERLOAD)\n+        {\n+          if (OVL_CHAIN (expr))\n+            {\n+              error (\"%qE refers to a set of overloaded functions\", orig_expr);\n+              return error_mark_node;\n+            }\n+          else\n+            /* An overload set containing only one function: just look\n+               at that function.  */\n+            expr = OVL_FUNCTION (expr);\n+        }\n+\n+      switch (TREE_CODE (expr))\n+        {\n+        case FIELD_DECL:\n+          if (DECL_C_BIT_FIELD (expr))\n+            {\n+              type = DECL_BIT_FIELD_TYPE (expr);\n+              break;\n+            }\n+          /* Fall through for fields that aren't bitfields.  */\n+\n+        case FUNCTION_DECL:\n+        case VAR_DECL:\n+        case CONST_DECL:\n+        case PARM_DECL:\n+        case RESULT_DECL:\n+          type = TREE_TYPE (expr);\n+          break;\n+\n+        case ERROR_MARK:\n+          type = error_mark_node;\n+          break;\n+\n+        case COMPONENT_REF:\n+          type = is_bitfield_expr_with_lowered_type (expr);\n+          if (!type)\n+            type = TREE_TYPE (TREE_OPERAND (expr, 1));\n+          break;\n+\n+        case BIT_FIELD_REF:\n+          gcc_unreachable ();\n+\n+        case INTEGER_CST:\n+          /* We can get here when the id-expression refers to an\n+             enumerator.  */\n+          type = TREE_TYPE (expr);\n+          break;\n+\n+        default:\n+          gcc_assert (TYPE_P (expr) || DECL_P (expr));\n+          error (\"argument to decltype must be an expression\");\n+          return error_mark_node;\n+        }\n+    }\n+  else\n+    {\n+      tree fndecl;\n+\n+      if (TREE_CODE (expr) == CALL_EXPR\n+          && (fndecl = get_callee_fndecl (expr))\n+          && (fndecl != error_mark_node))\n+        /* If e is a function call (5.2.2 [expr.call]) or an\n+           invocation of an overloaded operator (parentheses around e\n+           are ignored), decltype(e) is defined as the return type of\n+           that function.  */\n+        type = TREE_TYPE (TREE_TYPE (fndecl));\n+      else \n+        {\n+          type = is_bitfield_expr_with_lowered_type (expr);\n+          if (type)\n+            {\n+              /* Bitfields are special, because their type encodes the\n+                 number of bits they store.  If the expression referenced a\n+                 bitfield, TYPE now has the declared type of that\n+                 bitfield.  */\n+              type = cp_build_qualified_type (type, \n+                                              cp_type_quals (TREE_TYPE (expr)));\n+              \n+              if (real_lvalue_p (expr))\n+                type = build_reference_type (type);\n+            }\n+          else\n+            {\n+              /* Otherwise, where T is the type of e, if e is an lvalue,\n+                 decltype(e) is defined as T&, otherwise decltype(e) is\n+                 defined as T.  */\n+              type = TREE_TYPE (expr);\n+              if (expr == current_class_ptr)\n+                /* If the expression is just \"this\", we want the\n+                   cv-unqualified pointer for the \"this\" type.  */\n+                type = TYPE_MAIN_VARIANT (type);\n+              else if (real_lvalue_p (expr))\n+                {\n+                  if (TREE_CODE (type) != REFERENCE_TYPE)\n+                    type = build_reference_type (type);\n+                }\n+              else\n+                type = non_reference (type);\n+            }\n+        }\n+    }\n+\n+  if (!type || type == unknown_type_node)\n+    {\n+      error (\"type of %qE is unknown\", expr);\n+      return error_mark_node;\n+    }\n+\n+  return type;\n+}\n \n /* Called from trait_expr_value to evaluate either __has_nothrow_assign or \n    __has_nothrow_copy, depending on assign_p.  */"}, {"sha": "97573638a8fb619dda8d12d290b67a65b1eca040", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -2380,6 +2380,12 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n       *walk_subtrees_p = 0;\n       break;\n \n+    case DECLTYPE_TYPE:\n+      WALK_SUBTREE (DECLTYPE_TYPE_EXPR (*tp));\n+      *walk_subtrees_p = 0;\n+      break;\n+ \n+\n     default:\n       return NULL_TREE;\n     }"}, {"sha": "65371c766705056bbdcb1a377005e565f9040673", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -1080,6 +1080,14 @@ structural_comptypes (tree t1, tree t2, int strict)\n       return same_type_p (PACK_EXPANSION_PATTERN (t1), \n                           PACK_EXPANSION_PATTERN (t2));\n \n+    case DECLTYPE_TYPE:\n+      if (DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t1)\n+          != DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t2)\n+          || !cp_tree_equal (DECLTYPE_TYPE_EXPR (t1), \n+                             DECLTYPE_TYPE_EXPR (t2)))\n+        return false;\n+      break;\n+\n     default:\n       return false;\n     }"}, {"sha": "c37bd1d5b0005eda2a78121cfd30dee8b2097f8a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -1,3 +1,12 @@\n+2007-07-27  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* g++.dg/cpp0x/decltype1.C: New.\n+\t* g++.dg/cpp0x/decltype2.C: New.\n+\t* g++.dg/cpp0x/decltype3.C: New.\n+\t* g++.dg/cpp0x/decltype4.C: New.\n+\t* g++.dg/cpp0x/decltype5.C: New.\n+\t* g++.dg/cpp0x/decltype6.C: New.\n+\n 2007-07-27  Rask Ingemann Lambertsen  <rask@sygehus.dk>\n \n \t* gcc.dg/torture/pr27743.c (bar): Use an integer of exactly 32 bits"}, {"sha": "447af540dc25df8b396abb9b9746194f6ce58fc2", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype1.C?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+template<typename T, typename U> \n+struct is_same \n+{\n+  static const bool value = false;\n+};\n+\n+template<typename T>\n+struct is_same<T, T>\n+{\n+  static const bool value = true;\n+};\n+\n+const int& foo(); \n+int i; \n+struct A { double x; };\n+const A* a = new A(); \n+\n+static_assert(is_same<decltype(foo()), const int&>::value,\n+              \"type should be const int&\");\n+static_assert(is_same<decltype(i), int>::value,\n+              \"type should be int\");\n+static_assert(is_same<decltype(a->x), double>::value,\n+              \"type should be double\");\n+static_assert(is_same<decltype((a->x)), const double&>::value,\n+              \"type should be const double&\");"}, {"sha": "65549b4e9b367ddb38365513bc579389f1025b6c", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype2.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype2.C?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -0,0 +1,59 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+template<typename T, typename U> \n+struct is_same \n+{\n+  static const bool value = false;\n+};\n+\n+template<typename T>\n+struct is_same<T, T>\n+{\n+  static const bool value = true;\n+};\n+\n+#define CHECK_DECLTYPE(DECLTYPE,RESULT) \\\n+  static_assert(is_same< DECLTYPE , RESULT >::value, #RESULT)\n+\n+struct A {};\n+\n+int a; \n+int& b = a; \n+const int& c = a; \n+const int d = 5; \n+const A e = A(); \n+CHECK_DECLTYPE(decltype(a), int);\n+CHECK_DECLTYPE(decltype(b), int&); \n+CHECK_DECLTYPE(decltype(c), const int&); \n+CHECK_DECLTYPE(decltype(d), const int); \n+CHECK_DECLTYPE(decltype(e), const A); \n+\n+CHECK_DECLTYPE(decltype(a), int);\n+CHECK_DECLTYPE(decltype((a)), int&);\n+\n+void foo_check(int a, int& b, float& c, int* d) \n+{ \n+  CHECK_DECLTYPE(decltype(a), int);\n+  CHECK_DECLTYPE(decltype(b), int&); \n+  CHECK_DECLTYPE(decltype(c), float&);\n+  CHECK_DECLTYPE(decltype(d), int*);\n+} \n+\n+int foo(char); \n+int bar(char); \n+int bar(int); \n+CHECK_DECLTYPE(decltype(foo), int(char));\n+\n+decltype(bar) z; // { dg-error \"overload\" }\n+// { dg-error \"invalid type\" \"\" { target *-*-* } 48 }\n+\n+CHECK_DECLTYPE(decltype(&foo), int(*)(char));\n+CHECK_DECLTYPE(decltype(*&foo), int(&)(char));\n+\n+void array_types()\n+{\n+  int a[10]; \n+  CHECK_DECLTYPE(decltype(a), int[10]);\n+}\n+"}, {"sha": "556ae700320904b3b7f2530e825a68746112d2db", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype3.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype3.C?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -0,0 +1,72 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+template<typename T, typename U> \n+struct is_same \n+{\n+  static const bool value = false;\n+};\n+\n+template<typename T>\n+struct is_same<T, T>\n+{\n+  static const bool value = true;\n+};\n+\n+#define CHECK_DECLTYPE(DECLTYPE,RESULT) \\\n+  static_assert(is_same< DECLTYPE , RESULT >::value, #DECLTYPE \" should be \" #RESULT)\n+\n+class A { \n+public:\n+  int a; \n+  int& b; \n+  static int c; \n+\n+  A(int& b) : b(b) { }\n+\n+  void foo() { \n+    CHECK_DECLTYPE(decltype(a), int);\n+    CHECK_DECLTYPE(decltype(this->a), int);\n+    CHECK_DECLTYPE(decltype((*this).a), int);\n+    CHECK_DECLTYPE(decltype(b), int&);\n+    CHECK_DECLTYPE(decltype(c), int);\n+  } \n+  void bar() const {\n+    CHECK_DECLTYPE(decltype(a), int);\n+    CHECK_DECLTYPE(decltype(b), int&);\n+    CHECK_DECLTYPE(decltype(c), int);\n+  } \n+}; \n+\n+int b;\n+A aa(b); \n+const A& caa = aa; \n+CHECK_DECLTYPE(decltype(aa.a), int);\n+CHECK_DECLTYPE(decltype(aa.b), int&);\n+CHECK_DECLTYPE(decltype(caa.a), int);\n+\n+class B { \n+public:\n+  int a;  // { dg-error \"invalid use\" }\n+  enum B_enum { b }; \n+  decltype(a) c; // { dg-error \"from this location\" }\n+  decltype(a) foo() { } // { dg-error \"from this location\" }\n+  decltype(b) enums_are_in_scope() { return b; } // ok \n+}; \n+\n+CHECK_DECLTYPE(decltype(aa.*&A::a), int&);\n+decltype(aa.*&A::b) zz; // { dg-error \"cannot create pointer to reference member\" }\n+// { dg-error \"invalid type\" \"\" { target *-*-* } 58 }\n+CHECK_DECLTYPE(decltype(caa.*&A::a), const int&);\n+\n+class X { \n+  void foo() { \n+    CHECK_DECLTYPE(decltype(this), X*);\n+    CHECK_DECLTYPE(decltype(*this), X&);\n+  } \n+  void bar() const { \n+    CHECK_DECLTYPE(decltype(this), const X*);\n+    CHECK_DECLTYPE(decltype(*this), const X&);\n+  } \n+};\n+"}, {"sha": "18f2734681195cdc736c8aeb3b9aa3f1f6456804", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype4.C", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype4.C?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -0,0 +1,82 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+template<typename T, typename U> \n+struct is_same \n+{\n+  static const bool value = false;\n+};\n+\n+template<typename T>\n+struct is_same<T, T>\n+{\n+  static const bool value = true;\n+};\n+\n+#define CHECK_DECLTYPE(DECLTYPE,RESULT) \\\n+  static_assert(is_same< DECLTYPE , RESULT >::value, #DECLTYPE \" should be \" #RESULT)\n+\n+struct A {\n+  int x; \n+  int& y; \n+  int foo(char); \n+  int& bar() const; \n+}; \n+\n+CHECK_DECLTYPE(decltype(&A::x), int A::*);\n+decltype(&A::y) Ay; // { dg-error \"cannot create pointer to reference member|invalid type\" }\n+CHECK_DECLTYPE(decltype(&A::foo), int (A::*) (char));\n+CHECK_DECLTYPE(decltype(&A::bar), int& (A::*) () const);\n+\n+CHECK_DECLTYPE(decltype(\"decltype\"), const char(&)[9]);\n+CHECK_DECLTYPE(decltype(1), int);\n+\n+int an_int = 5;\n+int& i = an_int; \n+const int j = an_int; \n+\n+CHECK_DECLTYPE(decltype(i)&, int&);\n+CHECK_DECLTYPE(const decltype(j), const int);\n+\n+int foo(); \n+CHECK_DECLTYPE(decltype(foo()), int);\n+float& bar(int); \n+CHECK_DECLTYPE(decltype (bar(1)), float&);\n+const A bar(); \n+CHECK_DECLTYPE(decltype (bar()), const A);\n+const A& bar2(); \n+CHECK_DECLTYPE(decltype (bar2()), const A&);\n+\n+void wibble() {\n+  CHECK_DECLTYPE(decltype(1+2), int);\n+  int* p; \n+  CHECK_DECLTYPE(decltype(*p), int&);\n+  int a[10]; \n+  CHECK_DECLTYPE(decltype(a[3]), int&);\n+  int i; int& j = i; \n+  CHECK_DECLTYPE(decltype (i = 5), int&);\n+  CHECK_DECLTYPE(decltype (j = 5), int&);\n+\n+  CHECK_DECLTYPE(decltype (++i), int&); \n+  CHECK_DECLTYPE(decltype (i++), int);\n+}\n+\n+struct B {\n+  int bit : 2;\n+  const int cbit : 3;\n+\n+  void foo()\n+  {\n+    CHECK_DECLTYPE(decltype(bit), int);\n+    CHECK_DECLTYPE(decltype((bit)), int&);\n+    CHECK_DECLTYPE(decltype(cbit), const int);\n+    CHECK_DECLTYPE(decltype((cbit)), const int&); // { dg-bogus \"static assertion failed\" \"GCC gets the actual type of this expression wrong\" { xfail *-*-* } 73 }\n+  }\n+};\n+\n+B b;\n+const B& bc = b;\n+CHECK_DECLTYPE(decltype(b.bit), int);\n+CHECK_DECLTYPE(decltype(bc.bit), int);\n+CHECK_DECLTYPE(decltype((b.bit)), int&);\n+CHECK_DECLTYPE(decltype((bc.bit)), const int&);"}, {"sha": "4e8e64b130a9e3af9572a502a388525132f637e9", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype5.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype5.C?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+template<typename T, typename U> \n+struct is_same \n+{\n+  static const bool value = false;\n+};\n+\n+template<typename T>\n+struct is_same<T, T>\n+{\n+  static const bool value = true;\n+};\n+\n+#define CHECK_DECLTYPE(DECLTYPE,RESULT) \\\n+  static_assert(is_same< DECLTYPE , RESULT >::value, #RESULT)\n+\n+template<typename F> F create_a();\n+\n+template<typename F, typename T1>\n+decltype(create_a<F&>()(create_a<const T1&>())) forward(F f, const T1& a1)\n+{\n+  return f(a1);\n+}\n+\n+struct identity {\n+  template<typename T>\n+  const T& operator()(const T& x) { return x; }\n+};\n+\n+\n+identity id;\n+int i;\n+float f;\n+\n+CHECK_DECLTYPE(decltype(forward(id, i)), const int&);\n+CHECK_DECLTYPE(decltype(forward(id, f)), const float&);"}, {"sha": "c407c182c86ecbbee7254a5aa1e1b1c400facd6e", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype6.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype6.C?ref=3ad6a8e12ca4ac15b759f6a407d2ca2ea32e17a2", "patch": "@@ -0,0 +1,36 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+template<typename T, typename U> \n+struct is_same \n+{\n+  static const bool value = false;\n+};\n+\n+template<typename T>\n+struct is_same<T, T>\n+{\n+  static const bool value = true;\n+};\n+\n+template<typename T> const T& foo(); \n+\n+\n+int i; \n+\n+template<typename T>\n+struct A \n+{ \n+  double x; \n+};\n+\n+const A<double>* a = new A<double>(); \n+\n+static_assert(is_same<decltype(foo<int>()), const int&>::value,\n+              \"type should be const int&\");\n+static_assert(is_same<decltype(i), int>::value,\n+              \"type should be int\");\n+static_assert(is_same<decltype(a->x), double>::value,\n+              \"type should be double\");\n+static_assert(is_same<decltype((a->x)), const double&>::value,\n+              \"type should be const double&\");"}]}