{"sha": "4c521bad98510915b9bae91033f03a525a7fe5bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM1MjFiYWQ5ODUxMDkxNWI5YmFlOTEwMzNmMDNhNTI1YTdmZTViZA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@cat.daikokuya.demon.co.uk", "date": "2001-05-16T06:22:15Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-05-16T06:22:15Z"}, "message": "c-common.h (RID_FIRST_PQ): New.\n\n\t* c-common.h (RID_FIRST_PQ): New.\n\t* c-parse.in (objc_pq_context): New.\n\t(objc parser): Set objc_pq_context rather than calling\n\tremember_protocol_qualifiers and forget_protocol_qualifiers.\n\tDon't call save_and_forget_protocol_qualifiers.\n\t(yylexname): Handle objc protocol qualifiers here.\n\t* stringpool.c (struct str_header): Replace with sp_hashnode.\n\t(SP_EMPTY, SP_LEN, SP_TREE, SP_STR, SP_VALID): New.\n\t(alloc_string): Rename alloc_ident.  Use the SP_ accessors.\n\tAllocate an IDENTIFIER_NODE for each identifier.\n\t(FORALL_STRINGS, set_identifier): Delete.\n\t(FORALL_IDS, expand_string_table, stringpool_statistics): Update.\n\t(ggc_alloc_string): Use an obstack.\n\t(get_identifier, maybe_get_identifier, mark_string_hash): Update.\n\t* tree.h: Update comments.\n\t(set_identifier): Delete.\n\t* objc/objc-act.c (N_PQ, saved_pq, saved_not_pq,\n\tsave_and_forget_protocol_qualifiers, forget_protocol_qualifiers,\n\tremember_protocol_qualifiers): Delete.\n\nFrom-SVN: r42132", "tree": {"sha": "1e5d0fbc2d1d0260932b68eec0147527bb4f696d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e5d0fbc2d1d0260932b68eec0147527bb4f696d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c521bad98510915b9bae91033f03a525a7fe5bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c521bad98510915b9bae91033f03a525a7fe5bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c521bad98510915b9bae91033f03a525a7fe5bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c521bad98510915b9bae91033f03a525a7fe5bd/comments", "author": null, "committer": null, "parents": [{"sha": "fca790eb60478652025f6604d5b57152cb5160c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fca790eb60478652025f6604d5b57152cb5160c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fca790eb60478652025f6604d5b57152cb5160c9"}], "stats": {"total": 319, "additions": 127, "deletions": 192}, "files": [{"sha": "b44b60af1306f905530252c12580d06759ba8b2d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c521bad98510915b9bae91033f03a525a7fe5bd", "patch": "@@ -1,3 +1,25 @@\n+2001-05-16  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\t* c-common.h (RID_FIRST_PQ): New.\n+\t* c-parse.in (objc_pq_context): New.\n+\t(objc parser): Set objc_pq_context rather than calling\n+\tremember_protocol_qualifiers and forget_protocol_qualifiers.\n+\tDon't call save_and_forget_protocol_qualifiers.\n+\t(yylexname): Handle objc protocol qualifiers here.\n+\t* stringpool.c (struct str_header): Replace with sp_hashnode.\n+\t(SP_EMPTY, SP_LEN, SP_TREE, SP_STR, SP_VALID): New.\n+\t(alloc_string): Rename alloc_ident.  Use the SP_ accessors.\n+\tAllocate an IDENTIFIER_NODE for each identifier.\n+\t(FORALL_STRINGS, set_identifier): Delete.\n+\t(FORALL_IDS, expand_string_table, stringpool_statistics): Update.\n+\t(ggc_alloc_string): Use an obstack.\n+\t(get_identifier, maybe_get_identifier, mark_string_hash): Update.\n+\t* tree.h: Update comments.\n+\t(set_identifier): Delete.\n+\t* objc/objc-act.c (N_PQ, saved_pq, saved_not_pq,\n+\tsave_and_forget_protocol_qualifiers, forget_protocol_qualifiers,\n+\tremember_protocol_qualifiers): Delete.\n+\n Tue May 15 22:14:09 2001  Jeffrey A Law  (law@cygnus.com)\n \n \t* flow.c (life_analysis): After life analysis is complete, do"}, {"sha": "78a7a086a0fd947ef1631ae63d4592c69611a2c6", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=4c521bad98510915b9bae91033f03a525a7fe5bd", "patch": "@@ -61,7 +61,7 @@ enum rid\n   RID_FRIEND, RID_VIRTUAL, RID_EXPLICIT, RID_EXPORT, RID_MUTABLE,\n \n   /* ObjC */\n-  RID_IN, RID_OUT, RID_INOUT, RID_BYCOPY, RID_BYREF, RID_ONEWAY,\n+  RID_FIRST_PQ, RID_IN = RID_FIRST_PQ, RID_OUT, RID_INOUT, RID_BYCOPY, RID_BYREF, RID_ONEWAY,\n \n   /* C */\n   RID_INT,     RID_CHAR,   RID_FLOAT,    RID_DOUBLE, RID_VOID,"}, {"sha": "cee2637e89fcccf8e13b54e40dcb9c6fb7703aed", "filename": "gcc/c-parse.in", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=4c521bad98510915b9bae91033f03a525a7fe5bd", "patch": "@@ -271,6 +271,7 @@ tree objc_ivar_context;\n enum tree_code objc_inherit_code;\n int objc_receiver_context;\n int objc_public_flag;\n+int objc_pq_context;\n \n end ifobjc\n \n@@ -2837,13 +2838,13 @@ classdef:\n protocoldef:\n \t  PROTOCOL identifier protocolrefs\n \t\t{\n-\t\t  remember_protocol_qualifiers ();\n+\t\t  objc_pq_context = 1;\n \t\t  objc_interface_context\n \t\t    = start_protocol(PROTOCOL_INTERFACE_TYPE, $2, $3);\n \t\t}\n \t  methodprotolist END\n \t\t{\n-\t\t  forget_protocol_qualifiers();\n+\t\t  objc_pq_context = 0;\n \t\t  finish_protocol(objc_interface_context);\n \t\t  objc_interface_context = NULL_TREE;\n \t\t}\n@@ -2949,15 +2950,15 @@ ivar_declarator:\n methoddef:\n \t  '+'\n \t\t{\n-\t\t  remember_protocol_qualifiers ();\n+\t\t  objc_pq_context = 1;\n \t\t  if (objc_implementation_context)\n \t\t    objc_inherit_code = CLASS_METHOD_DECL;\n                   else\n \t\t    fatal_error (\"method definition not in class context\");\n \t\t}\n \t  methoddecl\n \t\t{\n-\t\t  forget_protocol_qualifiers ();\n+\t\t  objc_pq_context = 0;\n \t\t  add_class_method (objc_implementation_context, $3);\n \t\t  start_method_def ($3);\n \t\t  objc_method_context = $3;\n@@ -2974,15 +2975,15 @@ methoddef:\n \n \t| '-'\n \t\t{\n-\t\t  remember_protocol_qualifiers ();\n+\t\t  objc_pq_context = 1;\n \t\t  if (objc_implementation_context)\n \t\t    objc_inherit_code = INSTANCE_METHOD_DECL;\n                   else\n \t\t    fatal_error (\"method definition not in class context\");\n \t\t}\n \t  methoddecl\n \t\t{\n-\t\t  forget_protocol_qualifiers ();\n+\t\t  objc_pq_context = 0;\n \t\t  add_instance_method (objc_implementation_context, $3);\n \t\t  start_method_def ($3);\n \t\t  objc_method_context = $3;\n@@ -3023,27 +3024,27 @@ methodproto:\n \t  '+'\n \t\t{\n \t\t  /* Remember protocol qualifiers in prototypes.  */\n-\t\t  remember_protocol_qualifiers ();\n+\t\t  objc_pq_context = 1;\n \t\t  objc_inherit_code = CLASS_METHOD_DECL;\n \t\t}\n \t  methoddecl\n \t\t{\n \t\t  /* Forget protocol qualifiers here.  */\n-\t\t  forget_protocol_qualifiers ();\n+\t\t  objc_pq_context = 0;\n \t\t  add_class_method (objc_interface_context, $3);\n \t\t}\n \t  semi_or_error\n \n \t| '-'\n \t\t{\n \t\t  /* Remember protocol qualifiers in prototypes.  */\n-\t\t  remember_protocol_qualifiers ();\n+\t\t  objc_pq_context = 1;\n \t\t  objc_inherit_code = INSTANCE_METHOD_DECL;\n \t\t}\n \t  methoddecl\n \t\t{\n \t\t  /* Forget protocol qualifiers here.  */\n-\t\t  forget_protocol_qualifiers ();\n+\t\t  objc_pq_context = 0;\n \t\t  add_instance_method (objc_interface_context, $3);\n \t\t}\n \t  semi_or_error\n@@ -3615,9 +3616,6 @@ ifobjc\n \t  = get_identifier (reswords[i].word + 1);\n end ifobjc\n     }\n-ifobjc\n-  save_and_forget_protocol_qualifiers ();\n-end ifobjc\n }\n \n const char *\n@@ -3683,22 +3681,28 @@ yylexname ()\n   if (C_IS_RESERVED_WORD (yylval.ttype))\n     {\n       enum rid rid_code = C_RID_CODE (yylval.ttype);\n-      int yycode = rid_to_yy[(int) rid_code];\n \n-      if (yycode == STRING_FUNC_NAME)\n-\t{\n-\t   /* __FUNCTION__ and __PRETTY_FUNCTION__ get converted\n-\t      to string constants.  */\n-\t  const char *name = fname_string (rid_code);\n+ifobjc\n+      if (!((unsigned int) rid_code - (unsigned int) RID_FIRST_PQ < 6)\n+\t  || objc_pq_context)\n+end ifobjc\n+      {\n+\tint yycode = rid_to_yy[(int) rid_code];\n+\tif (yycode == STRING_FUNC_NAME)\n+\t  {\n+\t    /* __FUNCTION__ and __PRETTY_FUNCTION__ get converted\n+\t       to string constants.  */\n+\t    const char *name = fname_string (rid_code);\n \t  \n-\t  yylval.ttype = build_string (strlen (name) + 1, name);\n-\t  last_token = CPP_STRING;  /* so yyerror won't choke */\n-\t  return STRING;\n-\t}\n+\t    yylval.ttype = build_string (strlen (name) + 1, name);\n+\t    last_token = CPP_STRING;  /* so yyerror won't choke */\n+\t    return STRING;\n+\t  }\n       \n-      /* Return the canonical spelling for this keyword.  */\n-      yylval.ttype = ridpointers[(int) rid_code];\n-      return yycode;\n+\t/* Return the canonical spelling for this keyword.  */\n+\tyylval.ttype = ridpointers[(int) rid_code];\n+\treturn yycode;\n+      }\n     }\n \n   decl = lookup_name (yylval.ttype);"}, {"sha": "6f04357efc7ddc07984c9635d8c87e22f3d55aa9", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=4c521bad98510915b9bae91033f03a525a7fe5bd", "patch": "@@ -8661,46 +8661,3 @@ lookup_objc_ivar (id)\n   else\n     return 0;\n }\n-\n-/* Parser callbacks.\n-   Some ObjC keywords are reserved only in a particular context:\n-   in out inout bycopy byref oneway.\n-   We have to save and restore the IDENTIFIER_NODEs that describe\n-   them as keywords, when appropriate.  */\n-\n-#define N_PQ 6\n-static tree saved_pq[N_PQ];\n-static tree saved_not_pq[N_PQ];\n-static const char *const pq_strings[N_PQ] = {\n-  \"bycopy\", \"byref\", \"in\", \"inout\", \"oneway\", \"out\"\n-};\n-\n-void\n-save_and_forget_protocol_qualifiers ()\n-{\n-  int i;\n-  for (i = 0; i < N_PQ; i++)\n-    saved_pq[i] = set_identifier (pq_strings[i], NULL_TREE);\n-\n-  ggc_add_tree_root (saved_pq, N_PQ);\n-  ggc_add_tree_root (saved_not_pq, N_PQ);\n-}\n-\n-void\n-forget_protocol_qualifiers ()\n-{\n-  int i;\n-  for (i = 0; i < N_PQ; i++)\n-    {\n-      set_identifier (pq_strings[i], saved_not_pq[i]);\n-      saved_not_pq[i] = NULL_TREE;\n-    }\n-}\n-\n-void\n-remember_protocol_qualifiers ()\n-{\n-  int i;\n-  for (i = 0; i < N_PQ; i++)\n-    saved_not_pq[i] = set_identifier (pq_strings[i], saved_pq[i]);\n-}"}, {"sha": "0346dcfe34cba3bc9128cac72bd4f80dd9e45c6d", "filename": "gcc/stringpool.c", "status": "modified", "additions": 70, "deletions": 112, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=4c521bad98510915b9bae91033f03a525a7fe5bd", "patch": "@@ -49,21 +49,19 @@ const char digit_vector[] = {\n \n static struct obstack string_stack;\n \n-/* This is the hash entry associated with each string.  It lives in\n-   the hash table; only the string lives in the obstack.  Note that\n-   the string is not necessarily NUL terminated.  */\n+/* Each hashnode is just a pointer to a TREE_IDENTIFIER.  */\n+typedef struct tree_identifier *sp_hashnode;\n \n-struct str_header\n-{\n-  const char *ptr;\n-  tree data;\t/* for get_identifier */\n-  unsigned int len;\n-};\n+#define SP_EMPTY(NODE) ((NODE) == NULL)\n+#define SP_LEN(NODE) ((NODE)->length)\n+#define SP_TREE(NODE) ((tree) NODE)\n+#define SP_STR(NODE) ((NODE)->pointer)\n+#define SP_VALID(NODE) (TREE_CODE (SP_TREE (NODE)) == IDENTIFIER_NODE)\n \n /* This is the hash table structure.  There's only one.  */\n struct str_hash\n {\n-  struct str_header *entries;\n+  sp_hashnode *entries;\n   size_t nslots;\t/* total slots in the entries array */\n   size_t nelements;\t/* number of live elements */\n \n@@ -77,24 +75,17 @@ static struct str_hash string_hash = { 0, INITIAL_HASHSIZE, 0, 0, 0 };\n \n enum insert_option { INSERT, NO_INSERT };\n \n-static struct str_header *alloc_string PARAMS ((const char *, size_t,\n-\t\t\t\t\t\tenum insert_option));\n+static sp_hashnode alloc_ident PARAMS ((const char *, size_t,\n+\t\t\t\t\tenum insert_option));\n static inline unsigned int calc_hash PARAMS ((const unsigned char *, size_t));\n static void mark_string_hash PARAMS ((void *));\n-static struct str_header *expand_string_table PARAMS ((struct str_header *));\n+static void expand_string_table PARAMS ((void));\n \n /* Convenience macro for iterating over the hash table.  E is set to\n    each live entry in turn.  */\n-#define FORALL_STRINGS(E) \\\n-for (E = string_hash.entries; E < string_hash.entries+string_hash.nslots; E++) \\\n-  if (E->ptr != NULL)\n-    /* block here */\n-\n-/* Likewise, but tests ->data instead of ->ptr (for cases where we only\n-   care about entries with ->data set)  */\n #define FORALL_IDS(E) \\\n for (E = string_hash.entries; E < string_hash.entries+string_hash.nslots; E++) \\\n-  if (E->data != NULL)\n+  if (!SP_EMPTY (*E) && SP_VALID (*E))\n \n /* 0 while creating built-in identifiers.  */\n static int do_identifier_warnings;\n@@ -109,8 +100,8 @@ init_stringpool ()\n   /* Strings need no alignment.  */\n   obstack_alignment_mask (&string_stack) = 0;\n \n-  string_hash.entries = (struct str_header *)\n-    xcalloc (string_hash.nslots, sizeof (struct str_header));\n+  string_hash.entries = (sp_hashnode *)\n+    xcalloc (string_hash.nslots, sizeof (sp_hashnode));\n }\n \n /* Enable warnings on similar identifiers (if requested).\n@@ -150,13 +141,13 @@ calc_hash (str, len)\n #undef HASHSTEP\n }\n \n-/* Internal primitive: returns the header structure for the string of\n-   length LENGTH, containing CONTENTS.  If that string already exists\n-   in the table, returns the existing entry.  If the string hasn't\n-   been seen before and the last argument is INSERT, inserts and returns\n-   a new entry. Otherwise returns NULL.  */\n-static struct str_header *\n-alloc_string (contents, length, insert)\n+/* Internal primitive: returns the header structure for the identifier\n+   of length LENGTH, containing CONTENTS.  If that identifier already\n+   exists in the table, returns the existing entry.  If the identifier\n+   hasn't been seen before and the last argument is INSERT, inserts\n+   and returns a new entry. Otherwise returns NULL.  */\n+static sp_hashnode\n+alloc_ident (contents, length, insert)\n      const char *contents;\n      size_t length;\n      enum insert_option insert;\n@@ -165,8 +156,7 @@ alloc_string (contents, length, insert)\n   unsigned int hash2;\n   unsigned int index;\n   size_t sizemask;\n-  struct str_header *entry;\n-  struct str_header *entries = string_hash.entries;\n+  sp_hashnode entry;\n \n   sizemask = string_hash.nslots - 1;\n   index = hash & sizemask;\n@@ -178,13 +168,13 @@ alloc_string (contents, length, insert)\n \n   for (;;)\n     {\n-      entry = entries + index;\n+      entry = string_hash.entries[index];\n \n-      if (entry->ptr == NULL)\n+      if (SP_EMPTY (entry))\n \tbreak;\n \n-      if (entry->len == length\n-\t  && !memcmp (entry->ptr, contents, length))\n+      if ((size_t) SP_LEN (entry) == length\n+\t  && !memcmp (SP_STR (entry), contents, length))\n \treturn entry;\n \n       index = (index + hash2) & sizemask;\n@@ -194,50 +184,47 @@ alloc_string (contents, length, insert)\n   if (insert == NO_INSERT)\n     return NULL;\n \n-  obstack_grow0 (&string_stack, contents, length);\n-  entry->ptr = (const char *) obstack_finish (&string_stack);\n-  entry->len = length;\n-  entry->data = NULL;\n+  entry = (sp_hashnode) make_node (IDENTIFIER_NODE);\n+  string_hash.entries[index] = entry;\n+  SP_STR (entry) = ggc_alloc_string (contents, length);\n+  SP_LEN (entry) = length;\n+  /* This is not yet an identifier.  */\n+  TREE_SET_CODE (entry, ERROR_MARK);\n \n-  if (++string_hash.nelements * 4 < string_hash.nslots * 3)\n-    return entry;\n+  if (++string_hash.nelements * 4 >= string_hash.nslots * 3)\n+    /* Must expand the string table.  */\n+    expand_string_table ();\n \n-  /* Must expand the string table.  */\n-  return expand_string_table (entry);\n+  return entry;\n }\n \n-/* Subroutine of alloc_string which doubles the size of the hash table\n+/* Subroutine of alloc_ident which doubles the size of the hash table\n    and rehashes all the strings into the new table.  Returns the entry\n    in the new table corresponding to ENTRY.  */\n-static struct str_header *\n-expand_string_table (entry)\n-     struct str_header *entry;\n+static void\n+expand_string_table ()\n {\n-  struct str_header *nentries;\n-  struct str_header *e, *nentry = NULL;\n+  sp_hashnode *nentries;\n+  sp_hashnode *e;\n   size_t size, sizemask;\n \n   size = string_hash.nslots * 2;\n-  nentries = (struct str_header *) xcalloc (size, sizeof (struct str_header));\n+  nentries = (sp_hashnode *) xcalloc (size, sizeof (sp_hashnode));\n   sizemask = size - 1;\n \n-  FORALL_STRINGS (e)\n+  FORALL_IDS (e)\n     {\n       unsigned int index, hash, hash2;\n \n-      hash = calc_hash ((const unsigned char *) e->ptr, e->len);\n+      hash = calc_hash ((const unsigned char *) SP_STR (*e), SP_LEN (*e));\n       hash2 = ((hash * 17) & sizemask) | 1;\n       index = hash & sizemask;\n \n       for (;;)\n \t{\n-\t  if (nentries[index].ptr == NULL)\n+\t  if (SP_EMPTY (nentries[index]))\n \t    {\n-\t      nentries[index].ptr = e->ptr;\n-\t      nentries[index].len = e->len;\n-\t      nentries[index].data = e->data;\n-\t      if (e == entry)\n-\t\tnentry = nentries + index;\n+\t      nentries[index] = *e;\n \t      break;\n \t    }\n \n@@ -248,7 +235,6 @@ expand_string_table (entry)\n   free (string_hash.entries);\n   string_hash.entries = nentries;\n   string_hash.nslots = size;\n-  return nentry;\n }\n \n /* Allocate and return a string constant of length LENGTH, containing\n@@ -262,8 +248,6 @@ ggc_alloc_string (contents, length)\n      const char *contents;\n      int length;\n {\n-  struct str_header *str;\n-\n   if (length == -1)\n     length = strlen (contents);\n \n@@ -272,8 +256,8 @@ ggc_alloc_string (contents, length)\n   if (length == 1 && contents[0] >= '0' && contents[0] <= '9')\n     return digit_string (contents[0] - '0');\n \n-  str = alloc_string (contents, length, INSERT);\n-  return str->ptr;\n+  obstack_grow0 (&string_stack, contents, length);\n+  return obstack_finish (&string_stack);\n }\n \n /* Return an IDENTIFIER_NODE whose name is TEXT (a null-terminated string).\n@@ -283,43 +267,36 @@ tree\n get_identifier (text)\n      const char *text;\n {\n-  tree idp;\n-  struct str_header *str;\n+  sp_hashnode node;\n   size_t length = strlen (text);\n \n-  str = alloc_string (text, length, INSERT);\n-  idp = str->data;\n-  if (idp == NULL)\n+  node = alloc_ident (text, length, INSERT);\n+  if (!SP_VALID (node))\n     {\n-      if (TREE_CODE_LENGTH (IDENTIFIER_NODE) < 0)\n-\tabort ();\t/* set_identifier_size hasn't been called.  */\n-\n       /* If this identifier is longer than the clash-warning length,\n \t do a brute force search of the entire table for clashes.  */\n       if (warn_id_clash && do_identifier_warnings && length >= (size_t) id_clash_len)\n \t{\n-\t  struct str_header *e;\n+\t  sp_hashnode *e;\n \t  FORALL_IDS (e)\n \t    {\n-\t      if (e->len >= (size_t)id_clash_len\n-\t\t  && !strncmp (e->ptr, text, id_clash_len))\n+\t      if (SP_LEN (*e) >= id_clash_len\n+\t\t  && !strncmp (SP_STR (*e), text, id_clash_len))\n \t\t{\n \t\t  warning (\"\\\"%s\\\" and \\\"%s\\\" identical in first %d characters\",\n-\t\t\t   text, e->ptr, id_clash_len);\n+\t\t\t   text, SP_STR (*e), id_clash_len);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n \n-      idp = make_node (IDENTIFIER_NODE);\n-      IDENTIFIER_LENGTH (idp) = length;\n-      IDENTIFIER_POINTER (idp) = str->ptr;\n+      TREE_SET_CODE (node, IDENTIFIER_NODE);\n #ifdef GATHER_STATISTICS\n       id_string_size += length;\n #endif\n-      str->data = idp;\n     }\n-  return idp;\n+\n+  return SP_TREE (node);\n }\n \n /* If an identifier with the name TEXT (a null-terminated string) has\n@@ -330,33 +307,14 @@ tree\n maybe_get_identifier (text)\n      const char *text;\n {\n-  struct str_header *str;\n+  sp_hashnode node;\n   size_t length = strlen (text);\n \n-  str = alloc_string (text, length, NO_INSERT);\n-  if (str)\n-    return str->data;  /* N.B. str->data might be null here, if the\n-\t\t\t  string has been used but not as an identifier.  */\n-  return NULL_TREE;\n-}\n+  node = alloc_ident (text, length, NO_INSERT);\n+  if (!SP_EMPTY (node) && SP_VALID (node))\n+    return SP_TREE (node);\n \n-/* Look up an identifier with the name TEXT, replace its identifier\n-   node with NODE, and return the old identifier node.  This is used\n-   by languages which need to enable and disable keywords based on\n-   context; e.g. see remember_protocol_qualifiers in objc/objc-act.c.  */\n-tree\n-set_identifier (text, node)\n-     const char *text;\n-     tree node;\n-{\n-  struct str_header *str;\n-  tree old;\n-  size_t length = strlen (text);\n-\n-  str = alloc_string (text, length, INSERT);\n-  old = str->data;\t/* might be null */\n-  str->data = node;\n-  return old;\n+  return NULL_TREE;\n }\n \n /* Report some basic statistics about the string pool.  */\n@@ -367,7 +325,7 @@ stringpool_statistics ()\n   size_t nelts, nids, overhead, headers;\n   size_t total_bytes, longest, sum_of_squares;\n   double exp_len, exp_len2, exp2_len;\n-  struct str_header *e;\n+  sp_hashnode *e;\n #define SCALE(x) ((unsigned long) ((x) < 1024*10 \\\n \t\t  ? (x) \\\n \t\t  : ((x) < 1024*1024*10 \\\n@@ -376,21 +334,21 @@ stringpool_statistics ()\n #define LABEL(x) ((x) < 1024*10 ? ' ' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n \n   total_bytes = longest = sum_of_squares = nids = 0;\n-  FORALL_STRINGS (e)\n+  FORALL_IDS (e)\n     {\n-      size_t n = e->len;\n+      size_t n = SP_LEN (*e);\n \n       total_bytes += n;\n       sum_of_squares += n*n;\n       if (n > longest)\n \tlongest = n;\n-      if (e->data)\n+      if (SP_VALID (*e))\n \tnids++;\n     }\n       \n   nelts = string_hash.nelements;\n   overhead = obstack_memory_used (&string_stack) - total_bytes;\n-  headers = string_hash.nslots * sizeof (struct str_header);\n+  headers = string_hash.nslots * sizeof (sp_hashnode);\n \n   fprintf (stderr,\n \"\\nString pool\\n\\\n@@ -429,10 +387,10 @@ static void\n mark_string_hash (arg)\n      void *arg ATTRIBUTE_UNUSED;\n {\n-  struct str_header *h;\n+  sp_hashnode *h;\n \n   FORALL_IDS (h)\n     {\n-      ggc_mark_tree (h->data);\n+      ggc_mark_tree (SP_TREE (*h));\n     }\n }"}, {"sha": "91328c4b03f58367fe8bfe46e64fbb9960f25d99", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c521bad98510915b9bae91033f03a525a7fe5bd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4c521bad98510915b9bae91033f03a525a7fe5bd", "patch": "@@ -188,7 +188,7 @@ struct tree_common\n        TREE_OVERFLOW in\n            INTEGER_CST, REAL_CST, COMPLEX_CST\n        TREE_PUBLIC in\n-           VAR_DECL or FUNCTION_DECL\n+           VAR_DECL or FUNCTION_DECL or IDENTIFIER_NODE\n        TREE_VIA_PUBLIC in\n            TREE_LIST or TREE_VEC\n        EXPR_WFL_EMIT_LINE_NOTE in\n@@ -261,7 +261,8 @@ struct tree_common\n    bounded_flag:\n \n        TREE_BOUNDED in\n-\t   expressions, VAR_DECL, PARM_DECL, FIELD_DECL, FUNCTION_DECL\n+\t   expressions, VAR_DECL, PARM_DECL, FIELD_DECL, FUNCTION_DECL,\n+\t   IDENTIFIER_NODE\n        TYPE_BOUNDED in\n \t   ..._TYPE\n */\n@@ -517,7 +518,7 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n \n /* In a VAR_DECL or FUNCTION_DECL,\n    nonzero means name is to be accessible from outside this module.\n-   In an identifier node, nonzero means an external declaration\n+   In an IDENTIFIER_NODE, nonzero means an external declaration\n    accessible from outside this module was previously seen\n    for this name in an inner scope.  */\n #define TREE_PUBLIC(NODE) ((NODE)->common.public_flag)\n@@ -1952,13 +1953,6 @@ extern tree get_identifier\t\tPARAMS ((const char *));\n \n extern tree maybe_get_identifier\tPARAMS ((const char *));\n \n-/* Look up an identifier with the name TEXT, replace its identifier\n-   node with NODE, and return the old identifier node.  This is used\n-   by languages which need to enable and disable keywords based on\n-   context; e.g. see remember_protocol_qualifiers in objc/objc-act.c.  */\n-\n-extern tree set_identifier\t\tPARAMS ((const char *, tree));\n-\n /* Construct various types of nodes.  */\n \n #define build_int_2(LO,HI)  \\"}]}