{"sha": "b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ2ODBjYTFlYzIyYjdjOGIzMTZmYjFjY2Y4YWJlMzA2YWQzOThmOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-21T17:05:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-21T17:05:09Z"}, "message": "ada-tree.h (TYPE_RM_SIZE_NUM): Delete.\n\n\t* ada-tree.h (TYPE_RM_SIZE_NUM): Delete.\n\t(TYPE_RM_SIZE): Access TYPE_LANG_SLOT_1 directly for integral types.\n\t* decl.c (gnat_to_gnu_entity) <E_Modular_Integer_Type>: Remove useless\n\tsupport code for packed array types and assert its uselessness.\n\t<E_Signed_Integer_Subtype>: Reuse entity identifier in more places and\n\tadjust for TYPE_RM_SIZE change.\n\t<all> Fix nits in comments.  Use Original_Array_Type accessor instead\n\tof Associated_Node_For_Itype accessor for packed array types.\n\t(make_packable_type): Likewise.\n\t(maybe_pad_type): Likewise.\n\t(set_rm_size): Likewise.  Rework conditional statement.  Adjust for\n\tTYPE_RM_SIZE change.\n\t(make_type_from_size): Adjust for TYPE_RM_SIZE change.\n\t(rm_size): Fix nits in comments.  Rework conditional statements.\n\t* misc.c (gnat_print_type): Adjust for TYPE_RM_SIZE change.\n\t* trans.c (Attribute_to_gnu): Fix nits in comments.\n\t* utils.c (gnat_init_decl_processing): Use more appropriate function\n\tto initialize the size_type_node.  Adjust for TYPE_RM_SIZE change.\n\nFrom-SVN: r146530", "tree": {"sha": "ba7bd7f71baab2ae605732799c219e06e9ac1bbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba7bd7f71baab2ae605732799c219e06e9ac1bbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/comments", "author": null, "committer": null, "parents": [{"sha": "350916301fe8afa02464e3ca84c70015ce2cf74b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350916301fe8afa02464e3ca84c70015ce2cf74b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/350916301fe8afa02464e3ca84c70015ce2cf74b"}], "stats": {"total": 167, "additions": 89, "deletions": 78}, "files": [{"sha": "eaf53b8e6fbd5efeedb9c1229e5cf8782388865d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9", "patch": "@@ -1,3 +1,24 @@\n+2009-04-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* ada-tree.h (TYPE_RM_SIZE_NUM): Delete.\n+\t(TYPE_RM_SIZE): Access TYPE_LANG_SLOT_1 directly for integral types.\n+\t* decl.c (gnat_to_gnu_entity) <E_Modular_Integer_Type>: Remove useless\n+\tsupport code for packed array types and assert its uselessness.\n+\t<E_Signed_Integer_Subtype>: Reuse entity identifier in more places and\n+\tadjust for TYPE_RM_SIZE change.\n+\t<all> Fix nits in comments.  Use Original_Array_Type accessor instead\n+\tof Associated_Node_For_Itype accessor for packed array types.\n+\t(make_packable_type): Likewise.\n+\t(maybe_pad_type): Likewise.\n+\t(set_rm_size): Likewise.  Rework conditional statement.  Adjust for\n+\tTYPE_RM_SIZE change.\n+\t(make_type_from_size): Adjust for TYPE_RM_SIZE change.\n+\t(rm_size): Fix nits in comments.  Rework conditional statements.\n+\t* misc.c (gnat_print_type): Adjust for TYPE_RM_SIZE change.\n+\t* trans.c (Attribute_to_gnu): Fix nits in comments.\n+\t* utils.c (gnat_init_decl_processing): Use more appropriate function\n+\tto initialize the size_type_node.  Adjust for TYPE_RM_SIZE change.\n+\n 2009-04-21  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity): Do not set force_global"}, {"sha": "8d1f6a87c9d7f56c38f98547b0cf99411a7d0e92", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2009, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -162,6 +162,10 @@ struct lang_type GTY(()) {tree t; };\n    cico parameter passing mechanism refer to the routine gnat_to_gnu_entity. */\n #define TYPE_CI_CO_LIST(NODE)  TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n \n+/* For integral types, this is the RM Size of the type.  */\n+#define TYPE_RM_SIZE(NODE)  \\\n+  TYPE_LANG_SLOT_1 (TREE_CHECK3 (NODE, ENUMERAL_TYPE, BOOLEAN_TYPE, INTEGER_TYPE))\n+\n /* For an INTEGER_TYPE with TYPE_MODULAR_P, this is the value of the\n    modulus. */\n #define TYPE_MODULUS(NODE) GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n@@ -182,13 +186,6 @@ struct lang_type GTY(()) {tree t; };\n #define SET_TYPE_DIGITS_VALUE(NODE, X)  \\\n   SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n-/* For numeric types, stores the RM_Size of the type.  */\n-#define TYPE_RM_SIZE_NUM(NODE)\tTYPE_LANG_SLOT_1 (NUMERICAL_TYPE_CHECK (NODE))\n-\n-#define TYPE_RM_SIZE(NODE)\t\t\t\t\t\\\n-  (INTEGRAL_TYPE_P (NODE) || TREE_CODE (NODE) == REAL_TYPE\t\\\n-   ? TYPE_RM_SIZE_NUM (NODE) : 0)\n-\n /* For a RECORD_TYPE that is a fat pointer, point to the type for the\n    unconstrained object.  Likewise for a RECORD_TYPE that is pointed\n    to by a thin pointer.  */"}, {"sha": "224b342412e5d521cfd79033bd42ee311c7e76d8", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 51, "deletions": 57, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9", "patch": "@@ -310,7 +310,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      || kind == E_Anonymous_Access_Protected_Subprogram_Type\n \t\t      || kind == E_Access_Subtype)));\n \n-  /* RM_Size must be specified for all discrete and fixed-point types.  */\n+  /* The RM size must be specified for all discrete and fixed-point types.  */\n   gcc_assert (!IN (kind, Discrete_Or_Fixed_Point_Kind)\n \t      || !Unknown_RM_Size (gnat_entity));\n \n@@ -1465,28 +1465,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       break;\n \n     case E_Modular_Integer_Type:\n-      /* For modular types, make the unsigned type of the proper number of\n-\t bits and then set up the modulus, if required.  */\n       {\n+\t/* For modular types, make the unsigned type of the proper number\n+\t   of bits and then set up the modulus, if required.  */\n+\ttree gnu_modulus, gnu_high = NULL_TREE;\n \tenum machine_mode mode;\n-\ttree gnu_modulus;\n-\ttree gnu_high = 0;\n \n-\tif (Is_Packed_Array_Type (gnat_entity))\n-\t  esize = UI_To_Int (RM_Size (gnat_entity));\n+\t/* Packed array types are supposed to be subtypes only.  */\n+\tgcc_assert (!Is_Packed_Array_Type (gnat_entity));\n \n \t/* Find the smallest mode at least ESIZE bits wide and make a class\n \t   using that mode.  */\n-\n \tfor (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t     GET_MODE_BITSIZE (mode) < esize;\n \t     mode = GET_MODE_WIDER_MODE (mode))\n \t  ;\n \n \tgnu_type = make_unsigned_type (GET_MODE_BITSIZE (mode));\n-\tTYPE_PACKED_ARRAY_TYPE_P (gnu_type)\n-\t  = (Is_Packed_Array_Type (gnat_entity)\n-\t     && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)));\n \n \t/* Get the modulus in this type.  If it overflows, assume it is because\n \t   it is equal to 2**Esize.  Note that there is no overflow checking\n@@ -1510,7 +1505,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t&& !tree_int_cst_equal (TYPE_MAX_VALUE (gnu_type), gnu_high)))\n \t  {\n \t    tree gnu_subtype = make_node (INTEGER_TYPE);\n-\n \t    TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"UMT\");\n \t    TREE_TYPE (gnu_subtype) = gnu_type;\n \t    TYPE_MIN_VALUE (gnu_subtype) = TYPE_MIN_VALUE (gnu_type);\n@@ -1520,11 +1514,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    TYPE_PRECISION (gnu_subtype) = esize;\n \t    TYPE_UNSIGNED (gnu_subtype) = 1;\n \t    TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n-\t    TYPE_PACKED_ARRAY_TYPE_P (gnu_subtype)\n-\t      = (Is_Packed_Array_Type (gnat_entity)\n-\t\t && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)));\n \t    layout_type (gnu_subtype);\n-\n \t    gnu_type = gnu_subtype;\n \t  }\n       }\n@@ -1556,8 +1546,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  && !In_Extended_Main_Code_Unit (Ancestor_Subtype (gnat_entity))\n \t  && (!Compile_Time_Known_Value (Type_Low_Bound (gnat_entity))\n \t      || !Compile_Time_Known_Value (Type_High_Bound (gnat_entity))))\n-\tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity),\n-\t\t\t    gnu_expr, 0);\n+\tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity), gnu_expr, 0);\n \n       gnu_type = make_node (INTEGER_TYPE);\n       TREE_TYPE (gnu_type) = get_unpadded_type (Etype (gnat_entity));\n@@ -1627,7 +1616,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  tree gnu_field_type, gnu_field;\n \n \t  /* Set the RM size before wrapping up the type.  */\n-\t  TYPE_RM_SIZE_NUM (gnu_type)\n+\t  TYPE_RM_SIZE (gnu_type)\n \t    = UI_To_gnu (RM_Size (gnat_entity), bitsizetype);\n \t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type) = 1;\n \t  gnu_field_type = gnu_type;\n@@ -1644,8 +1633,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  /* Create a stripped-down declaration of the original type, mainly\n \t     for debugging.  */\n-\t  create_type_decl (get_entity_name (gnat_entity), gnu_field_type,\n-\t\t\t    NULL, true, debug_info_p, gnat_entity);\n+\t  create_type_decl (gnu_entity_id, gnu_field_type, NULL, true,\n+\t\t\t    debug_info_p, gnat_entity);\n \n \t  /* Don't notify the field as \"addressable\", since we won't be taking\n \t     it's address and it would prevent create_field_decl from making a\n@@ -1670,7 +1659,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  tree gnu_field_type, gnu_field;\n \n \t  /* Set the RM size before wrapping up the type.  */\n-\t  TYPE_RM_SIZE_NUM (gnu_type)\n+\t  TYPE_RM_SIZE (gnu_type)\n \t    = UI_To_gnu (RM_Size (gnat_entity), bitsizetype);\n \t  gnu_field_type = gnu_type;\n \n@@ -1682,8 +1671,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  /* Create a stripped-down declaration of the original type, mainly\n \t     for debugging.  */\n-\t  create_type_decl (get_entity_name (gnat_entity), gnu_field_type,\n-\t\t\t    NULL, true, debug_info_p, gnat_entity);\n+\t  create_type_decl (gnu_entity_id, gnu_field_type, NULL, true,\n+\t\t\t    debug_info_p, gnat_entity);\n \n \t  /* Don't notify the field as \"addressable\", since we won't be taking\n \t     it's address and it would prevent create_field_decl from making a\n@@ -4750,11 +4739,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   if (this_global)\n     force_global--;\n \n+  /* If this is a packed array type whose original array type is itself\n+     an Itype without freeze node, make sure the latter is processed.  */\n   if (Is_Packed_Array_Type (gnat_entity)\n-      && Is_Itype (Associated_Node_For_Itype (gnat_entity))\n-      && No (Freeze_Node (Associated_Node_For_Itype (gnat_entity)))\n-      && !present_gnu_tree (Associated_Node_For_Itype (gnat_entity)))\n-    gnat_to_gnu_entity (Associated_Node_For_Itype (gnat_entity), NULL_TREE, 0);\n+      && Is_Itype (Original_Array_Type (gnat_entity))\n+      && No (Freeze_Node (Original_Array_Type (gnat_entity)))\n+      && !present_gnu_tree (Original_Array_Type (gnat_entity)))\n+    gnat_to_gnu_entity (Original_Array_Type (gnat_entity), NULL_TREE, 0);\n \n   return gnu_decl;\n }\n@@ -5818,7 +5809,7 @@ make_packable_type (tree type, bool in_record)\n \tnew_field_type = make_packable_type (new_field_type, true);\n \n       /* However, for the last field in a not already packed record type\n-\t that is of an aggregate type, we need to use the RM_Size in the\n+\t that is of an aggregate type, we need to use the RM size in the\n \t packable version of the record type, see finish_record_type.  */\n       if (!TREE_CHAIN (old_field)\n \t  && !TYPE_PACKED (type)\n@@ -5895,8 +5886,8 @@ make_packable_type (tree type, bool in_record)\n \n    DEFINITION is true if this type is being defined.\n \n-   SAME_RM_SIZE is true if the RM_Size of the resulting type is to be set\n-   to SIZE too; otherwise, it's set to the RM_Size of the original type.  */\n+   SAME_RM_SIZE is true if the RM size of the resulting type is to be set\n+   to SIZE too; otherwise, it's set to the RM size of the original type.  */\n \n tree\n maybe_pad_type (tree type, tree size, unsigned int align,\n@@ -6017,8 +6008,8 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   /* Do not finalize it until after the auxiliary record is built.  */\n   finish_record_type (record, field, 1, true);\n \n-  /* Set the same size for its RM_size if requested; otherwise reuse\n-     the RM_size of the original type.  */\n+  /* Set the same size for its RM size if requested; otherwise reuse\n+     the RM size of the original type.  */\n   SET_TYPE_ADA_SIZE (record, same_rm_size ? size : orig_rm_size);\n \n   /* Unless debugging information isn't being written for the input type,\n@@ -7256,7 +7247,7 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n   return size;\n }\n \f\n-/* Similarly, but both validate and process a value of RM_Size.  This\n+/* Similarly, but both validate and process a value of RM size.  This\n    routine is only called for types.  */\n \n static void\n@@ -7270,7 +7261,7 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n   tree size;\n \n   /* Get the size as a tree.  Do nothing if none was specified, either\n-     because RM_Size was not Present or if the specified size was zero.\n+     because RM size was not Present or if the specified size was zero.\n      Give an error if a size was specified, but cannot be represented as\n      in sizetype.  */\n   if (No (uint_size) || uint_size == No_Uint)\n@@ -7315,13 +7306,14 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n       return;\n     }\n \n-  /* Otherwise, set the RM_Size.  */\n-  if (TREE_CODE (gnu_type) == INTEGER_TYPE\n-      && Is_Discrete_Or_Fixed_Point_Type (gnat_entity))\n-    TYPE_RM_SIZE_NUM (gnu_type) = size;\n-  else if (TREE_CODE (gnu_type) == ENUMERAL_TYPE\n-\t   || TREE_CODE (gnu_type) == BOOLEAN_TYPE)\n-    TYPE_RM_SIZE_NUM (gnu_type) = size;\n+  /* Otherwise, set the RM size proper for numerical types...  */\n+  if ((TREE_CODE (gnu_type) == INTEGER_TYPE\n+       && Is_Discrete_Or_Fixed_Point_Type (gnat_entity))\n+      || (TREE_CODE (gnu_type) == ENUMERAL_TYPE\n+\t  || TREE_CODE (gnu_type) == BOOLEAN_TYPE))\n+    TYPE_RM_SIZE (gnu_type) = size;\n+\n+  /* ...or the Ada size for record and union types.  */\n   else if ((TREE_CODE (gnu_type) == RECORD_TYPE\n \t    || TREE_CODE (gnu_type) == UNION_TYPE\n \t    || TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n@@ -7383,7 +7375,7 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n \t    TYPE_NAME (new_type) = TYPE_NAME (type);\n \t}\n       TYPE_BIASED_REPRESENTATION_P (new_type) = biased_p;\n-      TYPE_RM_SIZE_NUM (new_type) = bitsize_int (size);\n+      TYPE_RM_SIZE (new_type) = bitsize_int (size);\n       return new_type;\n \n     case RECORD_TYPE:\n@@ -7727,32 +7719,34 @@ substitute_in_type (tree t, tree f, tree r)\n     }\n }\n \f\n-/* Return the \"RM size\" of GNU_TYPE.  This is the actual number of bits\n+/* Return the RM size of GNU_TYPE.  This is the actual number of bits\n    needed to represent the object.  */\n \n tree\n rm_size (tree gnu_type)\n {\n-  /* For integer types, this is the precision.  For record types, we store\n-     the size explicitly.  For other types, this is just the size.  */\n-\n+  /* For integer types, this is the precision.  */\n   if (INTEGRAL_TYPE_P (gnu_type) && TYPE_RM_SIZE (gnu_type))\n     return TYPE_RM_SIZE (gnu_type);\n-  else if (TREE_CODE (gnu_type) == RECORD_TYPE\n-\t   && TYPE_CONTAINS_TEMPLATE_P (gnu_type))\n-    /* Return the rm_size of the actual data plus the size of the template.  */\n+\n+  /* Return the RM size of the actual data plus the size of the template.  */\n+  if (TREE_CODE (gnu_type) == RECORD_TYPE\n+      && TYPE_CONTAINS_TEMPLATE_P (gnu_type))\n     return\n       size_binop (PLUS_EXPR,\n \t\t  rm_size (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type)))),\n \t\t  DECL_SIZE (TYPE_FIELDS (gnu_type)));\n-  else if ((TREE_CODE (gnu_type) == RECORD_TYPE\n-\t    || TREE_CODE (gnu_type) == UNION_TYPE\n-\t    || TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n-\t   && !TYPE_IS_FAT_POINTER_P (gnu_type)\n-\t   && TYPE_ADA_SIZE (gnu_type))\n+\n+  /* For record types, we store the size explicitly.  */\n+  if ((TREE_CODE (gnu_type) == RECORD_TYPE\n+       || TREE_CODE (gnu_type) == UNION_TYPE\n+       || TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n+      && !TYPE_IS_FAT_POINTER_P (gnu_type)\n+      && TYPE_ADA_SIZE (gnu_type))\n     return TYPE_ADA_SIZE (gnu_type);\n-  else\n-    return TYPE_SIZE (gnu_type);\n+\n+  /* For other types, this is just the size.  */\n+  return TYPE_SIZE (gnu_type);\n }\n \f\n /* Return an identifier representing the external name to be used for"}, {"sha": "6edf7f49bb79acc9baf3259e4dd0a62e9bd95daa", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9", "patch": "@@ -544,7 +544,7 @@ gnat_print_type (FILE *file, tree node, int indent)\n \n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n-      print_node (file, \"RM size\", TYPE_RM_SIZE_NUM (node), indent + 4);\n+      print_node (file, \"RM size\", TYPE_RM_SIZE (node), indent + 4);\n       break;\n \n     case INTEGER_TYPE:\n@@ -558,7 +558,7 @@ gnat_print_type (FILE *file, tree node, int indent)\n       else\n \tprint_node (file, \"index type\", TYPE_INDEX_TYPE (node), indent + 4);\n \n-      print_node (file, \"RM size\", TYPE_RM_SIZE_NUM (node), indent + 4);\n+      print_node (file, \"RM size\", TYPE_RM_SIZE (node), indent + 4);\n       break;\n \n     case ARRAY_TYPE:"}, {"sha": "50e3fca20e19aadd2c667f641c8c7ff9712b0c19", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9", "patch": "@@ -1297,7 +1297,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       /* If we're looking for the size of a field, return the field size.\n \t Otherwise, if the prefix is an object, or if 'Object_Size or\n \t 'Max_Size_In_Storage_Elements has been specified, the result is the\n-\t GCC size of the type.  Otherwise, the result is the RM_Size of the\n+\t GCC size of the type.  Otherwise, the result is the RM size of the\n \t type.  */\n       if (TREE_CODE (gnu_prefix) == COMPONENT_REF)\n \tgnu_result = DECL_SIZE (TREE_OPERAND (gnu_prefix, 1));\n@@ -1306,7 +1306,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t       || attribute == Attr_Max_Size_In_Storage_Elements)\n \t{\n \t  /* If this is a padded type, the GCC size isn't relevant to the\n-\t     programmer.  Normally, what we want is the RM_Size, which was set\n+\t     programmer.  Normally, what we want is the RM size, which was set\n \t     from the specified size, but if it was not set, we want the size\n \t     of the relevant field.  Using the MAX of those two produces the\n \t     right result in all case.  Don't use the size of the field if it's"}, {"sha": "3375c40a8651711e8a54f2873da55e27bc57736c", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=b4680ca1ec22b7c8b316fb1ccf8abe306ad398f9", "patch": "@@ -515,18 +515,17 @@ gnat_init_decl_processing (void)\n   build_common_tree_nodes (true, true);\n \n   /* In Ada, we use a signed type for SIZETYPE.  Use the signed type\n-     corresponding to the size of Pmode.  In most cases when ptr_mode and\n-     Pmode differ, C will use the width of ptr_mode as sizetype.  But we get\n-     far better code using the width of Pmode.  Make this here since we need\n-     this before we can expand the GNAT types.  */\n-  size_type_node = gnat_type_for_size (GET_MODE_BITSIZE (Pmode), 0);\n+     corresponding to the width of Pmode.  In most cases when ptr_mode\n+     and Pmode differ, C will use the width of ptr_mode for SIZETYPE.\n+     But we get far better code using the width of Pmode.  */\n+  size_type_node = gnat_type_for_mode (Pmode, 0);\n   set_sizetype (size_type_node);\n \n   /* In Ada, we use an unsigned 8-bit type for the default boolean type.  */\n   boolean_type_node = make_node (BOOLEAN_TYPE);\n   TYPE_PRECISION (boolean_type_node) = 1;\n   fixup_unsigned_type (boolean_type_node);\n-  TYPE_RM_SIZE_NUM (boolean_type_node) = bitsize_int (1);\n+  TYPE_RM_SIZE (boolean_type_node) = bitsize_int (1);\n \n   build_common_tree_nodes_2 (0);\n \n@@ -2230,7 +2229,7 @@ gnat_types_compatible_p (tree t1, tree t2)\n       && TREE_TYPE (t1) == TREE_TYPE (t2)\n       && (TYPE_DOMAIN (t1) == TYPE_DOMAIN (t2)\n \t  || (TYPE_DOMAIN (t1)\n-\t      && TYPE_DOMAIN (t2)      \n+\t      && TYPE_DOMAIN (t2)\n \t      && tree_int_cst_equal (TYPE_MIN_VALUE (TYPE_DOMAIN (t1)),\n \t\t\t\t     TYPE_MIN_VALUE (TYPE_DOMAIN (t2)))\n \t      && tree_int_cst_equal (TYPE_MAX_VALUE (TYPE_DOMAIN (t1)),\n@@ -5176,10 +5175,10 @@ handle_type_generic_attribute (tree *node, tree ARG_UNUSED (name),\n \t\t\t       bool * ARG_UNUSED (no_add_attrs))\n {\n   tree params;\n-  \n+\n   /* Ensure we have a function type.  */\n   gcc_assert (TREE_CODE (*node) == FUNCTION_TYPE);\n-  \n+\n   params = TYPE_ARG_TYPES (*node);\n   while (params && ! VOID_TYPE_P (TREE_VALUE (params)))\n     params = TREE_CHAIN (params);"}]}