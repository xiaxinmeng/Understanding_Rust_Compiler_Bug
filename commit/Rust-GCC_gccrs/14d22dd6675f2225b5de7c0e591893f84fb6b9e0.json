{"sha": "14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRkMjJkZDY2NzVmMjIyNWI1ZGU3YzBlNTkxODkzZjg0ZmI2YjllMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-01-30T07:24:02Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-01-30T07:24:02Z"}, "message": "c-common.c (builtin_define_float_constants): Define __<TYPE>_HAS_INFINITY__ and __<TYPE>_HAS_QUIET_NAN__.\n\n\t* c-common.c (builtin_define_float_constants): Define\n\t__<TYPE>_HAS_INFINITY__ and __<TYPE>_HAS_QUIET_NAN__.\n\n\t* call.c (build_field_call): Use build_new_op, not build_opfncall.\n\t(prep_operand): New function.\n\t(build_new_op): Use it.  Remove dead code.\n\t* class.c (pushclass): Change \"modify\" parameter type from int to\n\tbool.\n\t(currently_open_class): Use same_type_p, not pointer equality.\n\t(push_nested_class): Adjust calls to pushclass, remove modify\n\tparameter.\n\t* cp-tree.h (INTEGRAL_OR_ENUMERATION_TYPE_P): New macro.\n\t(pushclass): Change prototype.\n\t(push_nested_class): Likewise.\n\t(grokoptypename): Remove.\n\t(build_opfncall): Remove.\n\t(value_dependent_expression_p): Declare.\n\t(resolve_typename_type): Likewise.\n\t(resolve_typename_type_in_current_instantiation): Likewise.\n\t(enter_scope_of): Remove.\n\t(tsubst): Remove.\n\t(tsubst_expr): Likewise.\n\t(tsubst_copy): Likewise.\n\t(tsubst_copy_and_build): Likewise.\n\t* decl.c (warn_about_implicit_typename_lookup): Remove.\n\t(finish_case_label): Return error_mark_node for erroneous labels.\n\t(start_decl): Adjust calls to push_nested_class.\n\t(grokfndecl): Call push_scope/pop_scope around call to\n\tduplicate_decls.\n\t(grokdeclarator): Do not call tsubst.\n\t(start_function): Adjust calls to push_nested_class.\n\t* decl2.c (grok_array_decl): Use build_new_op, not build_opfncall.\n\t(check_classfn): Use push_scope/pop_scope around type comparisions.\n\t(grokoptypename): Remove.\n\t(push_sscope): Adjust call to push_nested_class.\n\t* error.c (dump_type): Show cv-qualification of typename types.\n\t* init.c (build_member_call): Use build_new_op, not\n\tbuild_opfncall.\n\t* method.c (build_opfncall): Remove.\n\t* parser.c (cp_parser): Add allow_non_constant_expression_p and\n\tnon_constant_expression_p.\n\t(cp_parser_constant_expression): Adjust prototype.\n\t(cp_parser_resolve_typename_type): Remove.\n\t(cp_parser_non_constant_expression): New function.\n\t(cp_parser_non_constant_id_expression): Likewise.\n\t(cp_parser_new): Set allow_non_constant_expression_p and\n\tnon_constant_expression_p.\n\t(cp_parser_primary_expression): Reject `this' and `va_arg' in\n\tconstant-expressions.  Note that dependent names aren't really\n\tconstant.\n\t(cp_parser_postfix_expression): Reject conversions to non-integral\n\ttypes in constant-expressions.  Neither are increments or\n\tdecrements.\n\t(cp_parser_unary_expression): Reject increments and decrements in\n\tconstant-expressions.\n\t(cp_parser_direct_new_declarator): Adjust call to\n\tcp_parser_constant_expression.\n\t(cp_parser_cast_expression): Reject conversions to non-integral\n\ttypes in constant-expressions.\n\t(cp_parser_assignment_expression): Rejects assignments in\n\tconstant-expressions.\n\t(cp_parser_expression): Reject commas in constant-expressions.\n\t(cp_parser_labeled_statement): Adjust call to\n\tcp_parser_constant_expression.\n\t(cp_parser_direct_declarator): Simplify array bounds, even in\n\ttemplates, when they are non-dependent.  Use\n\tresolve_typename_type, not cp_parser_resolve_typename_type.\n\t(cp_parser_class_head): Use resolve_typename_type, not\n\tcp_parser_resolve_typename_type.\n\t(cp_parser_member_declaration): Adjust call to\n\tcp_parser_constant_expression.\n\t(cp_parser_constant_initializer): Likewise.\n\t(cp_parser_constructor_declarator): Use resolve_typename_type, not\n\tcp_parser_resolve_typename_type.\n\t(cp_parser_late_parsing_default_args): Adjust call to\n\tpush_nested_class.\n\t* pt.c (tsubst): Give it internal linkage.\n\t(tsubst_expr): Likewise.\n\t(tsubst_copy): Likewise.\n\t(tsubst_copy_and_build): Likewise.\n\t(push_access_scope_real): Likewise.\n\t(tsubst_friend_class): Likewise.\n\t(instantiate_class_template): Adjust call to pushclass.\n\t(value_dependent_expression_p): Give it external linkage.\n\tRobustify.\n\t(resolve_typename_type): New function.\n\t* semantics.c (finish_call_expr): Use build_new_op, not\n\tbuild_opfncall.\n\t(begin_constructor_declarator): Remove.\n\t(begin_class_definition): Adjust call to pushclass.\n\t(enter_scope_of): Remove.\n\t* typeck.c (comptypes): Resolve typename types as appropriate.\n\t(build_x_indirect_ref): Use build_new_op, not build_opfncall.\n\t(build_x_compound_expr): Likewise.\n\t(build_modify_expr): Likewise.\n\t(build_x_modify_expr): Likewise.\n\t* typeck2.c (build_x_arrow): Likewise.\n\n\t* g++.dg/parser/constant1.C: New test.\n\n\t* include/std/std_limits.h (numeric_limits<float>::has_infinity):\n\tUse __FLT_HAS_INIFINITY__ to initialize.\n\t(numeric_limits<float>::has_quiet_NaN): Likewise.\n\t(numeric_limits<double>::has_infinity): Use __DBL_HAS_INIFINITY__\n\tto initialize.\n\t(numeric_limits<double>::has_quiet_NaN): Likewise.\n\t(numeric_limits<long double>::has_infinity): Use\n\t__LDBL_HAS_INIFINITY__ to initialize.\n\t(numeric_limits<long_double>::has_quiet_NaN): Likewise.\n\nFrom-SVN: r62130", "tree": {"sha": "9b52cc234bf9b52b7127dba18c43be2715c995b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b52cc234bf9b52b7127dba18c43be2715c995b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/comments", "author": null, "committer": null, "parents": [{"sha": "825db093dfec43ee507e96de62db43f896047702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825db093dfec43ee507e96de62db43f896047702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825db093dfec43ee507e96de62db43f896047702"}], "stats": {"total": 1154, "additions": 795, "deletions": 359}, "files": [{"sha": "54129c4ee3ff38e6185d818dc23f296f6678b71a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -1,3 +1,8 @@\n+2003-01-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-common.c (builtin_define_float_constants): Define\n+\t__<TYPE>_HAS_INFINITY__ and __<TYPE>_HAS_QUIET_NAN__.\n+\n 2003-01-30  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/sh/lib1funcs.asm: Fix comment typos."}, {"sha": "7c6fc7889fcae937fae9cb9fe376dc8660d0c0d7", "filename": "gcc/c-common.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -4896,6 +4896,18 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n       sprintf (buf, \"0.0%s\", fp_suffix);\n       builtin_define_with_value (name, buf, 0);\n     }\n+\n+  /* For C++ std::numeric_limits<T>::has_infinity.  */\n+  sprintf (name, \"__%s_HAS_INFINITY__\", name_prefix);\n+  builtin_define_with_int_value (name, \n+\t\t\t\t MODE_HAS_INFINITIES (TYPE_MODE (type)));\n+  /* For C++ std::numeric_limits<T>::has_quiet_NaN.  We do not have a\n+     predicate to distinguish a target that has both quiet and\n+     signalling NaNs from a target that has only quiet NaNs or only\n+     signalling NaNs, so we assume that a target that has any kind of\n+     NaN has quiet NaNs.  */\n+  sprintf (name, \"__%s_HAS_QUIET_NAN__\", name_prefix);\n+  builtin_define_with_int_value (name, MODE_HAS_NANS (TYPE_MODE (type)));\n }\n \n /* Hook that registers front end and target-specific built-ins.  */"}, {"sha": "1b00808fa834066b9577b47ea6a9691db95650e3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -1,3 +1,100 @@\n+2003-01-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (build_field_call): Use build_new_op, not build_opfncall.\n+\t(prep_operand): New function.\n+\t(build_new_op): Use it.  Remove dead code.\n+\t* class.c (pushclass): Change \"modify\" parameter type from int to\n+\tbool.\n+\t(currently_open_class): Use same_type_p, not pointer equality.\n+\t(push_nested_class): Adjust calls to pushclass, remove modify\n+\tparameter.\n+\t* cp-tree.h (INTEGRAL_OR_ENUMERATION_TYPE_P): New macro.\n+\t(pushclass): Change prototype.\n+\t(push_nested_class): Likewise.\n+\t(grokoptypename): Remove.\n+\t(build_opfncall): Remove.\n+\t(value_dependent_expression_p): Declare.\n+\t(resolve_typename_type): Likewise.\n+\t(resolve_typename_type_in_current_instantiation): Likewise.\n+\t(enter_scope_of): Remove.\n+\t(tsubst): Remove.\n+\t(tsubst_expr): Likewise.\n+\t(tsubst_copy): Likewise.\n+\t(tsubst_copy_and_build): Likewise.\n+\t* decl.c (warn_about_implicit_typename_lookup): Remove.\n+\t(finish_case_label): Return error_mark_node for erroneous labels.\n+\t(start_decl): Adjust calls to push_nested_class.\n+\t(grokfndecl): Call push_scope/pop_scope around call to\n+\tduplicate_decls.\n+\t(grokdeclarator): Do not call tsubst.\n+\t(start_function): Adjust calls to push_nested_class.\n+\t* decl2.c (grok_array_decl): Use build_new_op, not build_opfncall.\n+\t(check_classfn): Use push_scope/pop_scope around type comparisions.\n+\t(grokoptypename): Remove.\n+\t(push_sscope): Adjust call to push_nested_class.\n+\t* error.c (dump_type): Show cv-qualification of typename types.\n+\t* init.c (build_member_call): Use build_new_op, not\n+\tbuild_opfncall.\n+\t* method.c (build_opfncall): Remove.\n+\t* parser.c (cp_parser): Add allow_non_constant_expression_p and\n+\tnon_constant_expression_p.\n+\t(cp_parser_constant_expression): Adjust prototype.\n+\t(cp_parser_resolve_typename_type): Remove.\n+\t(cp_parser_non_constant_expression): New function.\n+\t(cp_parser_non_constant_id_expression): Likewise.\n+\t(cp_parser_new): Set allow_non_constant_expression_p and\n+\tnon_constant_expression_p.\n+\t(cp_parser_primary_expression): Reject `this' and `va_arg' in\n+\tconstant-expressions.  Note that dependent names aren't really\n+\tconstant.\n+\t(cp_parser_postfix_expression): Reject conversions to non-integral\n+\ttypes in constant-expressions.  Neither are increments or\n+\tdecrements.\n+\t(cp_parser_unary_expression): Reject increments and decrements in\n+\tconstant-expressions.\n+\t(cp_parser_direct_new_declarator): Adjust call to\n+\tcp_parser_constant_expression.\n+\t(cp_parser_cast_expression): Reject conversions to non-integral\n+\ttypes in constant-expressions.\n+\t(cp_parser_assignment_expression): Rejects assignments in\n+\tconstant-expressions.\n+\t(cp_parser_expression): Reject commas in constant-expressions.\n+\t(cp_parser_labeled_statement): Adjust call to\n+\tcp_parser_constant_expression.\n+\t(cp_parser_direct_declarator): Simplify array bounds, even in\n+\ttemplates, when they are non-dependent.  Use\n+\tresolve_typename_type, not cp_parser_resolve_typename_type.\n+\t(cp_parser_class_head): Use resolve_typename_type, not\n+\tcp_parser_resolve_typename_type.\n+\t(cp_parser_member_declaration): Adjust call to\n+\tcp_parser_constant_expression.\n+\t(cp_parser_constant_initializer): Likewise.\n+\t(cp_parser_constructor_declarator): Use resolve_typename_type, not\n+\tcp_parser_resolve_typename_type.\n+\t(cp_parser_late_parsing_default_args): Adjust call to\n+\tpush_nested_class.\n+\t* pt.c (tsubst): Give it internal linkage.\n+\t(tsubst_expr): Likewise.\n+\t(tsubst_copy): Likewise.\n+\t(tsubst_copy_and_build): Likewise.\n+\t(push_access_scope_real): Likewise.\n+\t(tsubst_friend_class): Likewise.\n+\t(instantiate_class_template): Adjust call to pushclass.\n+\t(value_dependent_expression_p): Give it external linkage.\n+\tRobustify.\n+\t(resolve_typename_type): New function.\n+\t* semantics.c (finish_call_expr): Use build_new_op, not\n+\tbuild_opfncall.\n+\t(begin_constructor_declarator): Remove.\n+\t(begin_class_definition): Adjust call to pushclass.\n+\t(enter_scope_of): Remove.\n+\t* typeck.c (comptypes): Resolve typename types as appropriate.\n+\t(build_x_indirect_ref): Use build_new_op, not build_opfncall.\n+\t(build_x_compound_expr): Likewise.\n+\t(build_modify_expr): Likewise.\n+\t(build_x_modify_expr): Likewise.\n+\t* typeck2.c (build_x_arrow): Likewise.\n+\t\n 2003-01-29  Fariborz Jahanian  <fjahanian@apple.com>\n \n         * pt.c (last_pending_template) Declare GTY()."}, {"sha": "440d58a0a22e90b6221264077711bac67811fc6f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -103,6 +103,7 @@ static bool promoted_arithmetic_type_p (tree);\n static tree conditional_conversion (tree, tree);\n static char *name_as_c_string (tree, tree, bool *);\n static tree call_builtin_trap (void);\n+static tree prep_operand (tree);\n \n tree\n build_vfield_ref (tree datum, tree type)\n@@ -145,8 +146,8 @@ build_field_call (tree instance_ptr, tree decl, tree parms)\n \treturn error_mark_node;\n \n       if (IS_AGGR_TYPE (TREE_TYPE (instance)))\n-\treturn build_opfncall (CALL_EXPR, LOOKUP_NORMAL,\n-\t\t\t       instance, parms, NULL_TREE);\n+\treturn build_new_op (CALL_EXPR, LOOKUP_NORMAL,\n+\t\t\t     instance, parms, NULL_TREE);\n       else if (TREE_CODE (TREE_TYPE (instance)) == FUNCTION_TYPE\n \t       || (TREE_CODE (TREE_TYPE (instance)) == POINTER_TYPE\n \t\t   && (TREE_CODE (TREE_TYPE (TREE_TYPE (instance)))\n@@ -3295,6 +3296,27 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n   return result;\n }\n \n+/* OPERAND is an operand to an expression.  Perform necessary steps\n+   required before using it.  If OPERAND is NULL_TREE, NULL_TREE is\n+   returned.  */\n+\n+static tree\n+prep_operand (tree operand)\n+{\n+  if (operand)\n+    {\n+      if (TREE_CODE (operand) == OFFSET_REF)\n+\toperand = resolve_offset_ref (operand);\n+      operand = convert_from_reference (operand);\n+      if (CLASS_TYPE_P (TREE_TYPE (operand))\n+\t  && CLASSTYPE_TEMPLATE_INSTANTIATION (TREE_TYPE (operand)))\n+\t/* Make sure the template type is instantiated now.  */\n+\tinstantiate_class_template (TYPE_MAIN_VARIANT (TREE_TYPE (operand)));\n+    }\n+\n+  return operand;\n+}\n+\n tree\n build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n {\n@@ -3310,14 +3332,6 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n       || error_operand_p (arg3))\n     return error_mark_node;\n \n-  /* This can happen if a template takes all non-type parameters, e.g.\n-     undeclared_template<1, 5, 72>a;  */\n-  if (code == LT_EXPR && TREE_CODE (arg1) == TEMPLATE_DECL)\n-    {\n-      error (\"`%D' must be declared before use\", arg1);\n-      return error_mark_node;\n-    }\n-\n   if (code == MODIFY_EXPR)\n     {\n       code2 = TREE_CODE (arg3);\n@@ -3327,13 +3341,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n   else\n     fnname = ansi_opname (code);\n \n-  if (TREE_CODE (arg1) == OFFSET_REF)\n-    arg1 = resolve_offset_ref (arg1);\n-  arg1 = convert_from_reference (arg1);\n-  if (CLASS_TYPE_P (TREE_TYPE (arg1))\n-      && CLASSTYPE_TEMPLATE_INSTANTIATION (TREE_TYPE (arg1)))\n-    /* Make sure the template type is instantiated now.  */\n-    instantiate_class_template (TYPE_MAIN_VARIANT (TREE_TYPE (arg1)));\n+  arg1 = prep_operand (arg1);\n   \n   switch (code)\n     {\n@@ -3351,24 +3359,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n       break;\n     }\n \n-  if (arg2)\n-    {\n-      if (TREE_CODE (arg2) == OFFSET_REF)\n-\targ2 = resolve_offset_ref (arg2);\n-      arg2 = convert_from_reference (arg2);\n-      if (CLASS_TYPE_P (TREE_TYPE (arg2))\n-\t  && CLASSTYPE_TEMPLATE_INSTANTIATION (TREE_TYPE (arg2)))\n-\tinstantiate_class_template (TYPE_MAIN_VARIANT (TREE_TYPE (arg2)));\n-    }\n-  if (arg3)\n-    {\n-      if (TREE_CODE (arg3) == OFFSET_REF)\n-\targ3 = resolve_offset_ref (arg3);\n-      arg3 = convert_from_reference (arg3);\n-      if (CLASS_TYPE_P (TREE_TYPE (arg3))\n-\t  && CLASSTYPE_TEMPLATE_INSTANTIATION (TREE_TYPE (arg3)))\n-\tinstantiate_class_template (TYPE_MAIN_VARIANT (TREE_TYPE (arg3)));\n-    }\n+  arg2 = prep_operand (arg2);\n+  arg3 = prep_operand (arg3);\n   \n   if (code == COND_EXPR)\n     {\n@@ -3553,7 +3545,6 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n \n   if (TREE_CODE (cand->fn) == FUNCTION_DECL)\n     {\n-      extern int warn_synth;\n       if (warn_synth\n \t  && fnname == ansi_assopname (NOP_EXPR)\n \t  && DECL_ARTIFICIAL (cand->fn)"}, {"sha": "378c637a60d428ae3a7110a6129c842bb5f3503a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -5758,7 +5758,7 @@ init_class_processing (void)\n    that name becomes `error_mark_node'.  */\n \n void\n-pushclass (tree type, int modify)\n+pushclass (tree type, bool modify)\n {\n   type = TYPE_MAIN_VARIANT (type);\n \n@@ -5880,10 +5880,11 @@ int\n currently_open_class (tree t)\n {\n   int i;\n-  if (t == current_class_type)\n+  if (current_class_type && same_type_p (t, current_class_type))\n     return 1;\n   for (i = 1; i < current_class_depth; ++i)\n-    if (current_class_stack [i].type == t)\n+    if (current_class_stack[i].type\n+\t&& same_type_p (current_class_stack [i].type, t))\n       return 1;\n   return 0;\n }\n@@ -5912,14 +5913,13 @@ currently_open_derived_class (tree t)\n }\n \n /* When entering a class scope, all enclosing class scopes' names with\n-   static meaning (static variables, static functions, types and enumerators)\n-   have to be visible.  This recursive function calls pushclass for all\n-   enclosing class contexts until global or a local scope is reached.\n-   TYPE is the enclosed class and MODIFY is equivalent with the pushclass\n-   formal of the same name.  */\n+   static meaning (static variables, static functions, types and\n+   enumerators) have to be visible.  This recursive function calls\n+   pushclass for all enclosing class contexts until global or a local\n+   scope is reached.  TYPE is the enclosed class.  */\n \n void\n-push_nested_class (tree type, int modify)\n+push_nested_class (tree type)\n {\n   tree context;\n \n@@ -5935,8 +5935,8 @@ push_nested_class (tree type, int modify)\n   context = DECL_CONTEXT (TYPE_MAIN_DECL (type));\n \n   if (context && CLASS_TYPE_P (context))\n-    push_nested_class (context, 2);\n-  pushclass (type, modify);\n+    push_nested_class (context);\n+  pushclass (type, true);\n }\n \n /* Undoes a push_nested_class call.  */"}, {"sha": "e8d8acff0cf23b31674c3bfea1325fc9182f009b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -2477,6 +2477,10 @@ struct lang_decl GTY(())\n   (TREE_CODE (TYPE) == BOOLEAN_TYPE\t\t\\\n    || TREE_CODE (TYPE) == INTEGER_TYPE)\n \n+/* Returns true if TYPE is an integral or enumeration name.  */\n+#define INTEGRAL_OR_ENUMERATION_TYPE_P(TYPE) \\\n+  (CP_INTEGRAL_TYPE_P (TYPE) || TREE_CODE (TYPE) == ENUMERAL_TYPE)\n+\n /* [basic.fundamental]\n \n    Integral and floating types are collectively called arithmetic\n@@ -3642,9 +3646,9 @@ extern void finish_struct_1\t\t\t(tree);\n extern int resolves_to_fixed_type_p\t\t(tree, int *);\n extern void init_class_processing\t\t(void);\n extern int is_empty_class\t\t\t(tree);\n-extern void pushclass\t\t\t\t(tree, int);\n+extern void pushclass\t\t\t\t(tree, bool);\n extern void popclass\t\t\t\t(void);\n-extern void push_nested_class\t\t\t(tree, int);\n+extern void push_nested_class\t\t\t(tree);\n extern void pop_nested_class\t\t\t(void);\n extern int current_lang_depth\t\t\t(void);\n extern void push_lang_context\t\t\t(tree);\n@@ -3854,7 +3858,6 @@ extern void check_member_template (tree);\n extern tree grokfield (tree, tree, tree, tree, tree);\n extern tree grokbitfield (tree, tree, tree);\n extern tree groktypefield\t\t\t(tree, tree);\n-extern tree grokoptypename (tree, tree, tree);\n extern void cplus_decl_attributes (tree *, tree, int);\n extern tree constructor_name_full\t\t(tree);\n extern tree constructor_name (tree);\n@@ -4009,7 +4012,6 @@ extern void cxx_init_options (void);\n /* in method.c */\n extern void init_method\t(void);\n extern void set_mangled_name_for_decl (tree);\n-extern tree build_opfncall (enum tree_code, int, tree, tree, tree);\n extern tree hack_identifier (tree, tree);\n extern tree make_thunk (tree, bool, tree, tree);\n extern void finish_thunk (tree);\n@@ -4026,10 +4028,6 @@ extern bool maybe_clone_body (tree);\n /* in pt.c */\n extern void check_template_shadow\t\t(tree);\n extern tree get_innermost_template_args         (tree, int);\n-extern tree tsubst\t\t\t\t(tree, tree, tsubst_flags_t, tree);\n-extern tree tsubst_expr\t\t\t\t(tree, tree, tsubst_flags_t, tree);\n-extern tree tsubst_copy\t\t\t\t(tree, tree, tsubst_flags_t, tree);\n-extern tree tsubst_copy_and_build\t\t(tree, tree, tsubst_flags_t, tree);\n extern void maybe_begin_member_template_processing (tree);\n extern void maybe_end_member_template_processing (void);\n extern tree finish_member_template_decl         (tree);\n@@ -4086,6 +4084,9 @@ extern bool dependent_type_p                    (tree);\n extern bool dependent_template_arg_p            (tree);\n extern bool dependent_template_p                (tree);\n extern bool type_dependent_expression_p         (tree);\n+extern bool value_dependent_expression_p        (tree);\n+extern tree resolve_typename_type               (tree, bool);\n+extern tree resolve_typename_type_in_current_instantiation (tree);\n \n /* in repo.c */\n extern void repo_template_used (tree);\n@@ -4226,7 +4227,6 @@ extern tree finish_unary_op_expr                (enum tree_code, tree);\n extern tree finish_compound_literal             (tree, tree);\n extern tree finish_fname                        (tree);\n extern int begin_function_definition            (tree, tree, tree);\n-extern tree begin_constructor_declarator        (tree, tree);\n extern tree finish_declarator                   (tree, tree, tree, tree, int);\n extern void finish_translation_unit             (void);\n extern tree finish_template_type_parm           (tree, tree);\n@@ -4238,7 +4238,6 @@ extern void finish_default_args                 (void);\n extern tree finish_member_class_template        (tree);\n extern void finish_template_decl                (tree);\n extern tree finish_template_type                (tree, tree, int);\n-extern void enter_scope_of                      (tree);\n extern tree finish_base_specifier               (tree, tree);\n extern void finish_member_declaration           (tree);\n extern void check_multiple_declarators          (void);"}, {"sha": "9078da64ed1961d39a4f5505ee1c45e7f8101b44", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 59, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -105,7 +105,6 @@ static tree record_builtin_java_type (const char *, int);\n static const char *tag_name (enum tag_types code);\n static void find_class_binding_level (void);\n static struct cp_binding_level *innermost_nonclass_level (void);\n-static void warn_about_implicit_typename_lookup (tree, tree);\n static int walk_namespaces_r (tree, walk_namespaces_fn, void *);\n static int walk_globals_r (tree, void*);\n static int walk_vtables_r (tree, void*);\n@@ -5072,8 +5071,6 @@ finish_case_label (tree low_value, tree high_value)\n     cond = TREE_VALUE (cond);\n \n   r = c_add_case_label (switch_stack->cases, cond, low_value, high_value);\n-  if (r == error_mark_node)\n-    r = NULL_TREE;\n \n   check_switch_goto (switch_stack->level);\n \n@@ -5785,30 +5782,6 @@ qualify_lookup (tree val, int flags)\n   return val;\n }\n \n-/* Any other BINDING overrides an implicit TYPENAME.  Warn about\n-   that.  */\n-\n-static void\n-warn_about_implicit_typename_lookup (tree typename, tree binding)\n-{\n-  tree subtype = TREE_TYPE (TREE_TYPE (typename));\n-  tree name = DECL_NAME (typename);\n-\n-  if (! (TREE_CODE (binding) == TEMPLATE_DECL\n-\t && CLASSTYPE_TEMPLATE_INFO (subtype)\n-\t && CLASSTYPE_TI_TEMPLATE (subtype) == binding)\n-      && ! (TREE_CODE (binding) == TYPE_DECL\n-\t    && same_type_p (TREE_TYPE (binding), subtype)))\n-    {\n-      warning (\"lookup of `%D' finds `%#D'\",\n-\t\t  name, binding);\n-      warning (\"  instead of `%D' from dependent base class\",\n-\t\t  typename);\n-      warning (\"  (use `typename %T::%D' if that's what you meant)\",\n-\t\t  constructor_name (current_class_type), name);\n-    }\n-}\n-\n /* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL\n    or a class TYPE).  If IS_TYPE_P is TRUE, then ignore non-type\n    bindings.  \n@@ -7078,7 +7051,7 @@ start_decl (tree declarator,\n \n   if (context && COMPLETE_TYPE_P (complete_type (context)))\n     {\n-      push_nested_class (context, 2);\n+      push_nested_class (context);\n \n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n@@ -9086,9 +9059,11 @@ grokfndecl (tree ctype,\n \n \t  /* Attempt to merge the declarations.  This can fail, in\n \t     the case of some invalid specialization declarations.  */\n+\t  push_scope (ctype);\n \t  if (!duplicate_decls (decl, old_decl))\n \t    error (\"no `%#D' member function declared in class `%T'\",\n \t\t      decl, ctype);\n+\t  pop_scope (ctype);\n \t  return old_decl;\n \t}\n     }\n@@ -11055,35 +11030,6 @@ grokdeclarator (tree declarator,\n \tattrlist = &returned_attrs;\n     }\n \n-  /* Resolve any TYPENAME_TYPEs from the decl-specifier-seq that refer\n-     to ctype.  They couldn't be resolved earlier because we hadn't\n-     pushed into the class yet.  \n-\n-     For example, consider:\n-\n-       template <typename T>\n-       struct S {\n-         typedef T X;\n-         X f();\n-       };\n-\n-       template <typename T>\n-       typename S<T>::X f() {}\n-\n-       When parsing the decl-specifier-seq for the definition of `f',\n-       we construct a TYPENAME_TYPE for `S<T>::X'.  By substituting\n-       here, we resolve it to the correct type.  */\n-  if (scope && CLASS_TYPE_P (scope)\n-      && current_template_parms\n-      && uses_template_parms (scope))\n-    {\n-      tree args = current_template_args ();\n-      push_scope (scope);\n-      type = tsubst (type, args, tf_error | tf_warning,\n-\t\t     NULL_TREE);\n-      pop_scope (scope);\n-    }\n-\n   /* Now TYPE has the actual type.  */\n \n   /* Did array size calculations overflow?  */\n@@ -13470,9 +13416,9 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n   /* Set up current_class_type, and enter the scope of the class, if\n      appropriate.  */\n   if (ctype)\n-    push_nested_class (ctype, 1);\n+    push_nested_class (ctype);\n   else if (DECL_STATIC_FUNCTION_P (decl1))\n-    push_nested_class (DECL_CONTEXT (decl1), 2);\n+    push_nested_class (DECL_CONTEXT (decl1));\n \n   /* Now that we have entered the scope of the class, we must restore\n      the bindings for any template parameters surrounding DECL1, if it"}, {"sha": "63240dd7f587a3d3c1b464fa50bd268381c4a3d7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -423,8 +423,8 @@ grok_array_decl (tree array_expr, tree index_exp)\n \n   /* If they have an `operator[]', use that.  */\n   if (IS_AGGR_TYPE (type) || IS_AGGR_TYPE (TREE_TYPE (index_exp)))\n-    return build_opfncall (ARRAY_REF, LOOKUP_NORMAL,\n-\t\t\t   array_expr, index_exp, NULL_TREE);\n+    return build_new_op (ARRAY_REF, LOOKUP_NORMAL,\n+\t\t\t array_expr, index_exp, NULL_TREE);\n \n   /* Otherwise, create an ARRAY_REF for a pointer or array type.  It\n      is a little-known fact that, if `a' is an array and `i' is an\n@@ -685,6 +685,7 @@ check_classfn (tree ctype, tree function)\n       bool is_conv_op;\n       const char *format = NULL;\n       \n+      push_scope (ctype);\n       for (fndecls = TREE_VEC_ELT (methods, ix);\n \t   fndecls; fndecls = OVL_NEXT (fndecls))\n \t{\n@@ -713,8 +714,11 @@ check_classfn (tree ctype, tree function)\n \t      && (!DECL_TEMPLATE_SPECIALIZATION (function)\n \t\t  || (DECL_TI_TEMPLATE (function) \n \t\t      == DECL_TI_TEMPLATE (fndecl))))\n-\t    return fndecl;\n+\t    break;\n \t}\n+      pop_scope (ctype);\n+      if (fndecls)\n+\treturn OVL_CURRENT (fndecls);\n       error (\"prototype for `%#D' does not match any in class `%T'\",\n \t     function, ctype);\n       is_conv_op = DECL_CONV_FN_P (fndecl);\n@@ -1071,30 +1075,6 @@ grokbitfield (tree declarator, tree declspecs, tree width)\n   return value;\n }\n \n-/* Convert a conversion operator name to an identifier. SCOPE is the\n-   scope of the conversion operator, if explicit.  */\n-\n-tree\n-grokoptypename (tree declspecs, tree declarator, tree scope)\n-{\n-  tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0, NULL);\n-\n-  /* Resolve any TYPENAME_TYPEs that refer to SCOPE, before mangling\n-     the name, so that we mangle the right thing.  */\n-  if (scope && current_template_parms\n-      && uses_template_parms (t)\n-      && uses_template_parms (scope))\n-    {\n-      tree args = current_template_args ();\n-      \n-      push_scope (scope);\n-      t = tsubst (t, args, tf_error | tf_warning, NULL_TREE);\n-      pop_scope (scope);\n-    }\n-  \n-  return mangle_conv_op_name_for_type (t);\n-}\n-\n /* When a function is declared with an initializer,\n    do the right thing.  Currently, there are two possibilities:\n \n@@ -3749,7 +3729,7 @@ push_scope (tree t)\n   if (TREE_CODE (t) == NAMESPACE_DECL)\n     push_decl_namespace (t);\n   else if CLASS_TYPE_P (t)\n-    push_nested_class (t, 2);\n+    push_nested_class (t);\n }\n \n /* Leave scope pushed by push_scope.  */"}, {"sha": "9fe4167483e8d3da28ebfba122fd8f23268fb2d9", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -454,6 +454,7 @@ dump_type (t, flags)\n       break;\n     }\n     case TYPENAME_TYPE:\n+      dump_qualifiers (t, after);\n       output_add_string (scratch_buffer, \"typename \");\n       dump_typename (t, flags);\n       break;"}, {"sha": "c2661e8fa1fd0541d0373c481736bf339f051912", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -1511,8 +1511,8 @@ build_member_call (type, name, parmlist)\n \t  return error_mark_node;\n \t}\n       if (TYPE_LANG_SPECIFIC (TREE_TYPE (decl)))\n-\treturn build_opfncall (CALL_EXPR, LOOKUP_NORMAL, decl,\n-\t\t\t       parmlist, NULL_TREE);\n+\treturn build_new_op (CALL_EXPR, LOOKUP_NORMAL, decl,\n+\t\t\t     parmlist, NULL_TREE);\n       return build_function_call (decl, parmlist);\n     }\n   else"}, {"sha": "a60b75f1cbfd499fbc047a7ba43291c4a1800823", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -84,36 +84,6 @@ set_mangled_name_for_decl (tree decl)\n   mangle_decl (decl);\n }\n \n-\f\n-/* Given a tree_code CODE, and some arguments (at least one),\n-   attempt to use an overloaded operator on the arguments.\n-\n-   For unary operators, only the first argument need be checked.\n-   For binary operators, both arguments may need to be checked.\n-\n-   Member functions can convert class references to class pointers,\n-   for one-level deep indirection.  More than that is not supported.\n-   Operators [](), ()(), and ->() must be member functions.\n-\n-   We call function call building calls with LOOKUP_COMPLAIN if they\n-   are our only hope.  This is true when we see a vanilla operator\n-   applied to something of aggregate type.  If this fails, we are free\n-   to return `error_mark_node', because we will have reported the\n-   error.\n-\n-   Operators NEW and DELETE overload in funny ways: operator new takes\n-   a single `size' parameter, and operator delete takes a pointer to the\n-   storage being deleted.  When overloading these operators, success is\n-   assumed.  If there is a failure, report an error message and return\n-   `error_mark_node'.  */\n-\n-/* NOSTRICT */\n-tree\n-build_opfncall (enum tree_code code, int flags,\n-                tree xarg1, tree xarg2, tree arg3)\n-{\n-  return build_new_op (code, flags, xarg1, xarg2, arg3);\n-}\n \f\n /* This function takes an identifier, ID, and attempts to figure out what\n    it means. There are a number of possible scenarios, presented in increasing"}, {"sha": "fab1ef4760b5d9cde4ca35435f6df17a573d8ce9", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 279, "deletions": 101, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -1275,9 +1275,18 @@ typedef struct cp_parser GTY(())\n   \n   /* TRUE if we are parsing an integral constant-expression.  See\n      [expr.const] for a precise definition.  */\n-  /* FIXME: Need to implement code that checks this flag.  */\n   bool constant_expression_p;\n \n+  /* TRUE if we are parsing an integral constant-expression -- but a\n+     non-constant expression should be permitted as well.  This flag\n+     is used when parsing an array bound so that GNU variable-length\n+     arrays are tolerated.  */\n+  bool allow_non_constant_expression_p;\n+\n+  /* TRUE if ALLOW_NON_CONSTANT_EXPRESSION_P is TRUE and something has\n+     been seen that makes the expression non-constant.  */\n+  bool non_constant_expression_p;\n+\n   /* TRUE if local variable names and `this' are forbidden in the\n      current context.  */\n   bool local_variables_forbidden_p;\n@@ -1422,7 +1431,7 @@ static enum tree_code cp_parser_assignment_operator_opt\n static tree cp_parser_expression\n   (cp_parser *);\n static tree cp_parser_constant_expression\n-  (cp_parser *);\n+  (cp_parser *, bool, bool *);\n \n /* Statements [gram.stmt.stmt]  */\n \n@@ -1658,8 +1667,6 @@ static tree cp_parser_lookup_name\n   (cp_parser *, tree, bool, bool, bool, bool);\n static tree cp_parser_lookup_name_simple\n   (cp_parser *, tree);\n-static tree cp_parser_resolve_typename_type\n-  (cp_parser *, tree);\n static tree cp_parser_maybe_treat_template_as_class\n   (tree, bool);\n static bool cp_parser_check_declarator_template_parameters\n@@ -1728,6 +1735,10 @@ static bool cp_parser_simulate_error\n   (cp_parser *);\n static void cp_parser_check_type_definition\n   (cp_parser *);\n+static tree cp_parser_non_constant_expression\n+  (const char *);\n+static tree cp_parser_non_constant_id_expression\n+  (tree);\n static bool cp_parser_diagnose_invalid_type_name\n   (cp_parser *);\n static bool cp_parser_skip_to_closing_parenthesis\n@@ -1875,6 +1886,26 @@ cp_parser_check_type_definition (cp_parser* parser)\n     error (\"%s\", parser->type_definition_forbidden_message);\n }\n \n+/* Issue an eror message about the fact that THING appeared in a\n+   constant-expression.  Returns ERROR_MARK_NODE.  */\n+\n+static tree\n+cp_parser_non_constant_expression (const char *thing)\n+{\n+  error (\"%s cannot appear in a constant-expression\", thing);\n+  return error_mark_node;\n+}\n+\n+/* Issue an eror message about the fact that DECL appeared in a\n+   constant-expression.  Returns ERROR_MARK_NODE.  */\n+\n+static tree\n+cp_parser_non_constant_id_expression (tree decl)\n+{\n+  error (\"`%D' cannot appear in a constant-expression\", decl);\n+  return error_mark_node;\n+}\n+\n /* Check for a common situation where a type-name should be present,\n    but is not, and issue a sensible error message.  Returns true if an\n    invalid type-name was detected.  */\n@@ -2182,6 +2213,8 @@ cp_parser_new (void)\n   \n   /* We are not parsing a constant-expression.  */\n   parser->constant_expression_p = false;\n+  parser->allow_non_constant_expression_p = false;\n+  parser->non_constant_expression_p = false;\n \n   /* Local variable names are not forbidden.  */\n   parser->local_variables_forbidden_p = false;\n@@ -2395,6 +2428,13 @@ cp_parser_primary_expression (cp_parser *parser,\n \t      error (\"`this' may not be used in this context\");\n \t      return error_mark_node;\n \t    }\n+\t  /* Pointers cannot appear in constant-expressions.  */\n+\t  if (parser->constant_expression_p)\n+\t    {\n+\t      if (!parser->allow_non_constant_expression_p)\n+\t\treturn cp_parser_non_constant_expression (\"`this'\");\n+\t      parser->non_constant_expression_p = true;\n+\t    }\n \t  return finish_this_expr ();\n \n \t  /* The `operator' keyword can be the beginning of an\n@@ -2434,7 +2474,14 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    type = cp_parser_type_id (parser);\n \t    /* Look for the closing `)'.  */\n \t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-\n+\t    /* Using `va_arg' in a constant-expression is not\n+\t       allowed.  */\n+\t    if (parser->constant_expression_p)\n+\t      {\n+\t\tif (!parser->allow_non_constant_expression_p)\n+\t\t  return cp_parser_non_constant_expression (\"`va_arg'\");\n+\t\tparser->non_constant_expression_p = true;\n+\t      }\n \t    return build_x_va_arg (expression, type);\n \t  }\n \n@@ -2481,6 +2528,11 @@ cp_parser_primary_expression (cp_parser *parser,\n \t      {\n \t\tif (TYPE_P (TREE_OPERAND (decl, 0)))\n \t\t  *qualifying_class = TREE_OPERAND (decl, 0);\n+\t\t/* Since this name was dependent, the expression isn't\n+\t\t   constant -- yet.  No error is issued because it\n+\t\t   might be constant when things are instantiated.  */\n+\t\tif (parser->constant_expression_p)\n+\t\t  parser->non_constant_expression_p = true;\n \t\treturn decl;\n \t      }\n \t    /* Check to see if DECL is a local variable in a context\n@@ -2704,6 +2756,11 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t  {\n \t\t    if (TYPE_P (parser->scope))\n \t\t      *qualifying_class = parser->scope;\n+\t\t    /* Since this name was dependent, the expression isn't\n+\t\t       constant -- yet.  No error is issued because it\n+\t\t       might be constant when things are instantiated.  */\n+\t\t    if (parser->constant_expression_p)\n+\t\t      parser->non_constant_expression_p = true;\n \t\t    return build_nt (SCOPE_REF, \n \t\t\t\t     parser->scope, \n \t\t\t\t     id_expression);\n@@ -2712,10 +2769,36 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t   we need.  */\n \t\tif (TREE_CODE (id_expression) == TEMPLATE_ID_EXPR)\n \t\t  return id_expression;\n+\t\t/* Since this name was dependent, the expression isn't\n+\t\t   constant -- yet.  No error is issued because it\n+\t\t   might be constant when things are instantiated.  */\n+\t\tif (parser->constant_expression_p)\n+\t\t  parser->non_constant_expression_p = true;\n \t\t/* Create a LOOKUP_EXPR for other unqualified names.  */\n \t\treturn build_min_nt (LOOKUP_EXPR, id_expression);\n \t      }\n \n+\t    /* Only certain kinds of names are allowed in constant\n+\t       expression.  Enumerators have already been handled\n+\t       above.  */\n+\t    if (parser->constant_expression_p\n+\t\t/* Non-type template parameters of integral or\n+\t\t   enumeration type.  */\n+\t\t&& !(TREE_CODE (decl) == TEMPLATE_PARM_INDEX\n+\t\t     && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl)))\n+\t\t/* Const variables or static data members of integral\n+\t\t   or enumeration types initialized with constant\n+\t\t   expressions.  */\n+\t\t&& !(TREE_CODE (decl) == VAR_DECL\n+\t\t     && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl))\n+\t\t     && DECL_INITIAL (decl)\n+\t\t     && TREE_CONSTANT (DECL_INITIAL (decl))))\n+\t      {\n+\t\tif (!parser->allow_non_constant_expression_p)\n+\t\t  return cp_parser_non_constant_id_expression (decl);\n+\t\tparser->non_constant_expression_p = true;\n+\t      }\n+\n \t    if (parser->scope)\n \t      {\n \t\tdecl = (adjust_result_of_qualified_name_lookup \n@@ -3520,6 +3603,19 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \texpression = cp_parser_expression (parser);\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \n+\t/* Only type conversions to integral or enumeration types\n+\t   can be used in constant-expressions.  */\n+\tif (parser->constant_expression_p\n+\t    && !dependent_type_p (type)\n+\t    && !INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n+\t  {\n+\t    if (!parser->allow_non_constant_expression_p)\n+\t      return (cp_parser_non_constant_expression \n+\t\t      (\"a cast to a type other than an integral or \"\n+\t\t       \"enumeration type\"));\n+\t    parser->non_constant_expression_p = true;\n+\t  }\n+\n \tswitch (keyword)\n \t  {\n \t  case RID_DYNCAST:\n@@ -3645,32 +3741,32 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \n \t/* If the functional-cast didn't work out, try a\n \t   compound-literal.  */\n-\tif (cp_parser_allow_gnu_extensions_p (parser))\n+\tif (cp_parser_allow_gnu_extensions_p (parser)\n+\t    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n \t  {\n \t    tree initializer_list = NULL_TREE;\n \n \t    cp_parser_parse_tentatively (parser);\n-\t    /* Look for the `('.  */\n-\t    if (cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+\t    /* Consume the `('.  */\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t    /* Parse the type.  */\n+\t    type = cp_parser_type_id (parser);\n+\t    /* Look for the `)'.  */\n+\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\t    /* Look for the `{'.  */\n+\t    cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\");\n+\t    /* If things aren't going well, there's no need to\n+\t       keep going.  */\n+\t    if (!cp_parser_error_occurred (parser))\n \t      {\n-\t\ttype = cp_parser_type_id (parser);\n-\t\t/* Look for the `)'.  */\n-\t\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-\t\t/* Look for the `{'.  */\n-\t\tcp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\");\n-\t\t/* If things aren't going well, there's no need to\n-\t\t   keep going.  */\n-\t\tif (!cp_parser_error_occurred (parser))\n-\t\t  {\n-\t\t    /* Parse the initializer-list.  */\n-\t\t    initializer_list \n-\t\t      = cp_parser_initializer_list (parser);\n-\t\t    /* Allow a trailing `,'.  */\n-\t\t    if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\t\t      cp_lexer_consume_token (parser->lexer);\n-\t\t    /* Look for the final `}'.  */\n-\t\t    cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n-\t\t  }\n+\t\t/* Parse the initializer-list.  */\n+\t\tinitializer_list \n+\t\t  = cp_parser_initializer_list (parser);\n+\t\t/* Allow a trailing `,'.  */\n+\t\tif (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t/* Look for the final `}'.  */\n+\t\tcp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n \t      }\n \t    /* If that worked, we're definitely looking at a\n \t       compound-literal expression.  */\n@@ -3806,6 +3902,14 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t      args = NULL_TREE;\n \t    /* Look for the closing `)'.  */\n \t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\t    /* Function calls are not permitted in\n+\t       constant-expressions.  */\n+\t    if (parser->constant_expression_p)\n+\t      {\n+\t\tif (!parser->allow_non_constant_expression_p)\n+\t\t  return cp_parser_non_constant_expression (\"a function call\");\n+\t\tparser->non_constant_expression_p = true;\n+\t      }\n \n \t    if (idk == CP_PARSER_ID_KIND_UNQUALIFIED\n \t\t&& (is_overloaded_fn (postfix_expression)\n@@ -4029,6 +4133,13 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t  /* postfix-expression ++  */\n \t  /* Consume the `++' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n+\t  /* Increments may not appear in constant-expressions.  */\n+\t  if (parser->constant_expression_p)\n+\t    {\n+\t      if (!parser->allow_non_constant_expression_p)\n+\t\treturn cp_parser_non_constant_expression (\"an increment\");\n+\t      parser->non_constant_expression_p = true;\n+\t    }\n \t  /* Generate a reprsentation for the complete expression.  */\n \t  postfix_expression \n \t    = finish_increment_expr (postfix_expression, \n@@ -4040,6 +4151,13 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t  /* postfix-expression -- */\n \t  /* Consume the `--' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n+\t  /* Decrements may not appear in constant-expressions.  */\n+\t  if (parser->constant_expression_p)\n+\t    {\n+\t      if (!parser->allow_non_constant_expression_p)\n+\t\treturn cp_parser_non_constant_expression (\"a decrement\");\n+\t      parser->non_constant_expression_p = true;\n+\t    }\n \t  /* Generate a reprsentation for the complete expression.  */\n \t  postfix_expression \n \t    = finish_increment_expr (postfix_expression, \n@@ -4341,11 +4459,20 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \tcase ADDR_EXPR:\n \t  return build_x_unary_op (ADDR_EXPR, cast_expression);\n \t  \n+\tcase PREINCREMENT_EXPR:\n+\tcase PREDECREMENT_EXPR:\n+\t  if (parser->constant_expression_p)\n+\t    {\n+\t      if (!parser->allow_non_constant_expression_p)\n+\t\treturn cp_parser_non_constant_expression (PREINCREMENT_EXPR\n+\t\t\t\t\t\t\t  ? \"an increment\"\n+\t\t\t\t\t\t\t  : \"a decrement\");\n+\t      parser->non_constant_expression_p = true;\n+\t    }\n+\t  /* Fall through.  */\n \tcase CONVERT_EXPR:\n \tcase NEGATE_EXPR:\n \tcase TRUTH_NOT_EXPR:\n-\tcase PREINCREMENT_EXPR:\n-\tcase PREDECREMENT_EXPR:\n \t  return finish_unary_op_expr (unary_operator, cast_expression);\n \n \tcase BIT_NOT_EXPR:\n@@ -4597,7 +4724,10 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n \t}\n       /* But all the other expressions must be.  */\n       else\n-\texpression = cp_parser_constant_expression (parser);\n+\texpression \n+\t  = cp_parser_constant_expression (parser, \n+\t\t\t\t\t   /*allow_non_constant=*/false,\n+\t\t\t\t\t   NULL);\n       /* Look for the closing `]'.  */\n       cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n \n@@ -4766,7 +4896,19 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n \t      && !VOID_TYPE_P (type) \n \t      && current_lang_name != lang_name_c)\n \t    warning (\"use of old-style cast\");\n-\t  \n+\n+\t  /* Only type conversions to integral or enumeration types\n+\t     can be used in constant-expressions.  */\n+\t  if (parser->constant_expression_p\n+\t      && !dependent_type_p (type)\n+\t      && !INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n+\t    {\n+\t      if (!parser->allow_non_constant_expression_p)\n+\t\treturn (cp_parser_non_constant_expression \n+\t\t\t(\"a casts to a type other than an integral or \"\n+\t\t\t \"enumeration type\"));\n+\t      parser->non_constant_expression_p = true;\n+\t    }\n \t  /* Perform the cast.  */\n \t  expr = build_c_cast (type, expr);\n \t  return expr;\n@@ -5176,6 +5318,14 @@ cp_parser_assignment_expression (cp_parser* parser)\n \n \t      /* Parse the right-hand side of the assignment.  */\n \t      rhs = cp_parser_assignment_expression (parser);\n+\t      /* An assignment may not appear in a\n+\t\t constant-expression.  */\n+\t      if (parser->constant_expression_p)\n+\t\t{\n+\t\t  if (!parser->allow_non_constant_expression_p)\n+\t\t    return cp_parser_non_constant_expression (\"an assignment\");\n+\t\t  parser->non_constant_expression_p = true;\n+\t\t}\n \t      /* Build the asignment expression.  */\n \t      expr = build_x_modify_expr (expr, \n \t\t\t\t\t  assignment_operator, \n@@ -5334,20 +5484,37 @@ cp_parser_expression (cp_parser* parser)\n      necessary.  We built up the list in reverse order, so we must\n      straighten it out here.  */\n   if (saw_comma_p)\n-    expression = build_x_compound_expr (nreverse (expression));\n+    {\n+      /* A comma operator cannot appear in a constant-expression.  */\n+      if (parser->constant_expression_p)\n+\t{\n+\t  if (!parser->allow_non_constant_expression_p)\n+\t    return cp_parser_non_constant_expression (\"a comma operator\");\n+\t  parser->non_constant_expression_p = true;\n+\t}\n+      expression = build_x_compound_expr (nreverse (expression));\n+    }\n \n   return expression;\n }\n \n /* Parse a constant-expression. \n \n    constant-expression:\n-     conditional-expression  */\n+     conditional-expression  \n+\n+  If ALLOW_NON_CONSTANT_P a non-constant expression is silently\n+  accepted.  In that case *NON_CONSTANT_P is set to TRUE.  If\n+  ALLOW_NON_CONSTANT_P is false, NON_CONSTANT_P should be NULL.  */\n \n static tree\n-cp_parser_constant_expression (cp_parser* parser)\n+cp_parser_constant_expression (cp_parser* parser, \n+\t\t\t       bool allow_non_constant_p,\n+\t\t\t       bool *non_constant_p)\n {\n   bool saved_constant_expression_p;\n+  bool saved_allow_non_constant_expression_p;\n+  bool saved_non_constant_expression_p;\n   tree expression;\n \n   /* It might seem that we could simply parse the\n@@ -5367,14 +5534,24 @@ cp_parser_constant_expression (cp_parser* parser)\n      constant-expression.  However, GCC's constant-folding machinery\n      will fold this operation to an INTEGER_CST for `3'.  */\n \n-  /* Save the old setting of CONSTANT_EXPRESSION_P.  */\n+  /* Save the old settings.  */\n   saved_constant_expression_p = parser->constant_expression_p;\n+  saved_allow_non_constant_expression_p \n+    = parser->allow_non_constant_expression_p;\n+  saved_non_constant_expression_p = parser->non_constant_expression_p;\n   /* We are now parsing a constant-expression.  */\n   parser->constant_expression_p = true;\n+  parser->allow_non_constant_expression_p = allow_non_constant_p;\n+  parser->non_constant_expression_p = false;\n   /* Parse the conditional-expression.  */\n   expression = cp_parser_conditional_expression (parser);\n-  /* Restore the old setting of CONSTANT_EXPRESSION_P.  */\n+  /* Restore the old settings.  */\n   parser->constant_expression_p = saved_constant_expression_p;\n+  parser->allow_non_constant_expression_p \n+    = saved_allow_non_constant_expression_p;\n+  if (allow_non_constant_p)\n+    *non_constant_p = parser->non_constant_expression_p;\n+  parser->non_constant_expression_p = saved_non_constant_expression_p;\n \n   return expression;\n }\n@@ -5517,7 +5694,9 @@ cp_parser_labeled_statement (cp_parser* parser)\n \t/* Consume the `case' token.  */\n \tcp_lexer_consume_token (parser->lexer);\n \t/* Parse the constant-expression.  */\n-\texpr = cp_parser_constant_expression (parser);\n+\texpr = cp_parser_constant_expression (parser, \n+\t\t\t\t\t      /*allow_non_constant=*/false,\n+\t\t\t\t\t      NULL);\n \t/* Create the label.  */\n \tstatement = finish_case_label (expr, NULL_TREE);\n       }\n@@ -8875,7 +9054,9 @@ cp_parser_enumerator_definition (cp_parser* parser, tree type)\n       /* Consume the `=' token.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Parse the value.  */\n-      value = cp_parser_constant_expression (parser);\n+      value = cp_parser_constant_expression (parser, \n+\t\t\t\t\t     /*allow_non_constant=*/false,\n+\t\t\t\t\t     NULL);\n     }\n   else\n     value = NULL_TREE;\n@@ -9870,7 +10051,34 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  /* If the next token is `]', then there is no\n \t     constant-expression.  */\n \t  if (token->type != CPP_CLOSE_SQUARE)\n-\t    bounds = cp_parser_constant_expression (parser);\n+\t    {\n+\t      bool non_constant_p;\n+\n+\t      bounds \n+\t\t= cp_parser_constant_expression (parser,\n+\t\t\t\t\t\t /*allow_non_constant=*/true,\n+\t\t\t\t\t\t &non_constant_p);\n+\t      /* If we're in a template, but the constant-expression\n+\t\t isn't value dependent, simplify it.  We're supposed\n+\t\t to treat:\n+\n+\t\t   template <typename T> void f(T[1 + 1]);\n+\t\t   template <typename T> void f(T[2]);\n+\t\t   \n+\t\t as two declarations of the same function, for\n+\t\t example.  */\n+\t      if (processing_template_decl\n+\t\t  && !non_constant_p\n+\t\t  && !value_dependent_expression_p (bounds))\n+\t\t{\n+\t\t  HOST_WIDE_INT saved_processing_template_decl;\n+\n+\t\t  saved_processing_template_decl = processing_template_decl;\n+\t\t  processing_template_decl = 0;\n+\t\t  bounds = build_expr_from_tree (bounds);\n+\t\t  processing_template_decl = saved_processing_template_decl;\n+\t\t}\n+\t    }\n \t  else\n \t    bounds = NULL_TREE;\n \t  /* Look for the closing `]'.  */\n@@ -9924,11 +10132,14 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t     \t is no harm in resolving the types here.  */\n \t      if (TREE_CODE (scope) == TYPENAME_TYPE)\n \t\t{\n+\t\t  tree type;\n+\n \t\t  /* Resolve the TYPENAME_TYPE.  */\n-\t\t  scope = cp_parser_resolve_typename_type (parser, scope);\n+\t\t  type = resolve_typename_type (scope,\n+\t\t\t\t\t\t /*only_current_p=*/false);\n \t\t  /* If that failed, the declarator is invalid.  */\n-\t\t  if (scope == error_mark_node)\n-\t\t    return error_mark_node;\n+\t\t  if (type != error_mark_node)\n+\t\t    scope = type;\n \t\t  /* Build a new DECLARATOR.  */\n \t\t  declarator = build_nt (SCOPE_REF, \n \t\t\t\t\t scope,\n@@ -11549,16 +11760,22 @@ cp_parser_class_head (cp_parser* parser,\n       /* Given:\n \n \t    template <typename T> struct S { struct T };\n-\t    template <typename T> struct S::T { };\n+\t    template <typename T> struct S<T>::T { };\n \n \t we will get a TYPENAME_TYPE when processing the definition of\n \t `S::T'.  We need to resolve it to the actual type before we\n \t try to define it.  */\n       if (TREE_CODE (TREE_TYPE (type)) == TYPENAME_TYPE)\n \t{\n-\t  type = cp_parser_resolve_typename_type (parser, TREE_TYPE (type));\n-\t  if (type != error_mark_node)\n-\t    type = TYPE_NAME (type);\n+\t  class_type = resolve_typename_type (TREE_TYPE (type),\n+\t\t\t\t\t      /*only_current_p=*/false);\n+\t  if (class_type != error_mark_node)\n+\t    type = TYPE_NAME (class_type);\n+\t  else\n+\t    {\n+\t      cp_parser_error (parser, \"could not resolve typename type\");\n+\t      type = error_mark_node;\n+\t    }\n \t}\n \n       maybe_process_partial_specialization (TREE_TYPE (type));\n@@ -11889,7 +12106,10 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      /* Consume the `:' token.  */\n \t      cp_lexer_consume_token (parser->lexer);\n \t      /* Get the width of the bitfield.  */\n-\t      width = cp_parser_constant_expression (parser);\n+\t      width \n+\t\t= cp_parser_constant_expression (parser,\n+\t\t\t\t\t\t /*allow_non_constant=*/false,\n+\t\t\t\t\t\t NULL);\n \n \t      /* Look for attributes that apply to the bitfield.  */\n \t      attributes = cp_parser_attributes_opt (parser);\n@@ -12112,7 +12332,9 @@ cp_parser_constant_initializer (cp_parser* parser)\n       return error_mark_node;\n     }\n \n-  return cp_parser_constant_expression (parser);\n+  return cp_parser_constant_expression (parser, \n+\t\t\t\t\t/*allow_non_constant=*/false,\n+\t\t\t\t\tNULL);\n }\n \n /* Derived classes [gram.class.derived] */\n@@ -13148,58 +13370,6 @@ cp_parser_lookup_name_simple (cp_parser* parser, tree name)\n \t\t\t\t/*check_dependency=*/true);\n }\n \n-/* TYPE is a TYPENAME_TYPE.  Returns the ordinary TYPE to which the\n-   TYPENAME_TYPE corresponds.  Note that this function peers inside\n-   uninstantiated templates and therefore should be used only in\n-   extremely limited situations.  */\n-\n-static tree\n-cp_parser_resolve_typename_type (cp_parser* parser, tree type)\n-{\n-  tree scope;\n-  tree name;\n-  tree decl;\n-\n-  my_friendly_assert (TREE_CODE (type) == TYPENAME_TYPE,\n-\t\t      20010702);\n-\n-  scope = TYPE_CONTEXT (type);\n-  name = TYPE_IDENTIFIER (type);\n-\n-  /* If the SCOPE is itself a TYPENAME_TYPE, then we need to resolve\n-     it first before we can figure out what NAME refers to.  */\n-  if (TREE_CODE (scope) == TYPENAME_TYPE)\n-    scope = cp_parser_resolve_typename_type (parser, scope);\n-  /* If we don't know what SCOPE refers to, then we cannot resolve the\n-     TYPENAME_TYPE.  */\n-  if (scope == error_mark_node || TREE_CODE (scope) == TYPENAME_TYPE)\n-    return error_mark_node;\n-  /* If the SCOPE is a template type parameter, we have no way of\n-     resolving the name.  */\n-  if (TREE_CODE (scope) == TEMPLATE_TYPE_PARM)\n-    return type;\n-  /* Enter the SCOPE so that name lookup will be resolved as if we\n-     were in the class definition.  In particular, SCOPE will no\n-     longer be considered a dependent type.  */\n-  push_scope (scope);\n-  /* Look up the declaration.  */\n-  decl = lookup_member (scope, name, /*protect=*/0, /*want_type=*/1);\n-  /* If all went well, we got a TYPE_DECL for a non-typename.  */\n-  if (!decl \n-      || TREE_CODE (decl) != TYPE_DECL \n-      || TREE_CODE (TREE_TYPE (decl)) == TYPENAME_TYPE)\n-    {\n-      cp_parser_error (parser, \"could not resolve typename type\");\n-      type = error_mark_node;\n-    }\n-  else\n-    type = TREE_TYPE (decl);\n-  /* Leave the SCOPE.  */\n-  pop_scope (scope);\n-\n-  return type;\n-}\n-\n /* If DECL is a TEMPLATE_DECL that can be treated like a TYPE_DECL in\n    the current context, return the TYPE_DECL.  If TAG_NAME_P is\n    true, the DECL indicates the class being defined in a class-head,\n@@ -13547,7 +13717,15 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t    {\n \t      type = TREE_TYPE (type_decl);\n \t      if (TREE_CODE (type) == TYPENAME_TYPE)\n-\t\ttype = cp_parser_resolve_typename_type (parser, type);\n+\t\t{\n+\t\t  type = resolve_typename_type (type, \n+\t\t\t\t\t\t/*only_current_p=*/false);\n+\t\t  if (type == error_mark_node)\n+\t\t    {\n+\t\t      cp_parser_abort_tentative_parse (parser);\n+\t\t      return false;\n+\t\t    }\n+\t\t}\n \t      push_scope (type);\n \t    }\n \t  /* Look for the type-specifier.  */\n@@ -13978,7 +14156,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n       parser->local_variables_forbidden_p = true;\n        /* Parse the assignment-expression.  */\n       if (DECL_CONTEXT (fn))\n-\tpush_nested_class (DECL_CONTEXT (fn), 1);\n+\tpush_nested_class (DECL_CONTEXT (fn));\n       TREE_PURPOSE (parameters) = cp_parser_assignment_expression (parser);\n       if (DECL_CONTEXT (fn))\n \tpop_nested_class ();"}, {"sha": "2429f7f788ecab5441c9d6a24c8adafbb85cf01d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 107, "deletions": 16, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -171,8 +171,11 @@ static void copy_default_args_to_explicit_spec PARAMS ((tree));\n static int invalid_nontype_parm_type_p PARAMS ((tree, tsubst_flags_t));\n static int eq_local_specializations (const void *, const void *);\n static tree template_for_substitution (tree);\n-static bool value_dependent_expression_p (tree);\n static bool dependent_template_id_p (tree, tree);\n+static tree tsubst (tree, tree, tsubst_flags_t, tree);\n+static tree tsubst_expr\t(tree, tree, tsubst_flags_t, tree);\n+static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n+static tree tsubst_copy_and_build (tree, tree, tsubst_flags_t, tree);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -215,7 +218,7 @@ push_access_scope_real (t, args, context)\n   if (!context)\n     context = DECL_CONTEXT (t);\n   if (context && TYPE_P (context))\n-    push_nested_class (context, 2);\n+    push_nested_class (context);\n   else\n     push_to_top_level ();\n     \n@@ -5043,7 +5046,7 @@ tsubst_friend_class (friend_tmpl, args)\n       if (TREE_CODE (context) == NAMESPACE_DECL)\n \tpush_nested_namespace (context);\n       else\n-\tpush_nested_class (tsubst (context, args, tf_none, NULL_TREE), 2);\n+\tpush_nested_class (tsubst (context, args, tf_none, NULL_TREE)); \n     }\n \n   /* First, we look for a class template.  */\n@@ -5328,7 +5331,7 @@ instantiate_class_template (type)\n      correctly.  This is precisely analogous to what we do in\n      begin_class_definition when defining an ordinary non-template\n      class.  */\n-  pushclass (type, 1);\n+  pushclass (type, true);\n \n   /* Now members are processed in the order of declaration.  */\n   for (member = CLASSTYPE_DECL_LIST (pattern); member; member = TREE_CHAIN (member))\n@@ -6467,7 +6470,7 @@ tsubst_call_declarator_parms (parms, args, complain, in_decl)\n    This function is used for dealing with types, decls and the like;\n    for expressions, use tsubst_expr or tsubst_copy.  */\n \n-tree\n+static tree\n tsubst (t, args, complain, in_decl)\n      tree t, args;\n      tsubst_flags_t complain;\n@@ -7103,7 +7106,7 @@ tsubst (t, args, complain, in_decl)\n    template parms; to finish processing the resultant expression, use\n    tsubst_expr.  */\n \n-tree\n+static tree\n tsubst_copy (t, args, complain, in_decl)\n      tree t, args;\n      tsubst_flags_t complain;\n@@ -7505,7 +7508,7 @@ tsubst_copy (t, args, complain, in_decl)\n /* Like tsubst_copy for expressions, etc. but also does semantic\n    processing.  */\n \n-tree\n+static tree\n tsubst_expr (t, args, complain, in_decl)\n      tree t, args;\n      tsubst_flags_t complain;\n@@ -7832,7 +7835,7 @@ tsubst_expr (t, args, complain, in_decl)\n /* Like tsubst but deals with expressions and performs semantic\n    analysis.  */\n \n-tree\n+static tree\n tsubst_copy_and_build (t, args, complain, in_decl)\n      tree t, args;\n      tsubst_flags_t complain;\n@@ -11314,15 +11317,16 @@ dependent_type_p (type)\n \n /* Returns TRUE if the EXPRESSION is value-dependent.  */\n \n-static bool\n+bool\n value_dependent_expression_p (tree expression)\n {\n   if (!processing_template_decl)\n     return false;\n \n   /* A name declared with a dependent type.  */\n-  if (DECL_P (expression)\n-      && dependent_type_p (TREE_TYPE (expression)))\n+  if (TREE_CODE (expression) == LOOKUP_EXPR\n+      || (DECL_P (expression)\n+\t  && dependent_type_p (TREE_TYPE (expression))))\n     return true;\n   /* A non-type template parameter.  */\n   if ((TREE_CODE (expression) == CONST_DECL\n@@ -11370,11 +11374,14 @@ value_dependent_expression_p (tree expression)\n \tcase 'e':\n \t  {\n \t    int i;\n-\t    for (i = 0; \n-\t\t i < TREE_CODE_LENGTH (TREE_CODE (expression));\n-\t\t ++i)\n-\t      if (value_dependent_expression_p\n-\t\t  (TREE_OPERAND (expression, i)))\n+\t    for (i = 0; i < first_rtl_op (TREE_CODE (expression)); ++i)\n+\t      /* In some cases, some of the operands may be missing.\n+\t\t (For example, in the case of PREDECREMENT_EXPR, the\n+\t\t amount to increment by may be missing.)  That doesn't\n+\t\t make the expression dependent.  */\n+\t      if (TREE_OPERAND (expression, i)\n+\t\t  && (value_dependent_expression_p\n+\t\t      (TREE_OPERAND (expression, i))))\n \t\treturn true;\n \t    return false;\n \t  }\n@@ -11478,4 +11485,88 @@ dependent_template_p (tree tmpl)\n   return false;\n }\n \n+/* TYPE is a TYPENAME_TYPE.  Returns the ordinary TYPE to which the\n+   TYPENAME_TYPE corresponds.  Returns ERROR_MARK_NODE if no such TYPE\n+   can be found.  Note that this function peers inside uninstantiated\n+   templates and therefore should be used only in extremely limited\n+   situations.  */\n+\n+tree\n+resolve_typename_type (tree type, bool only_current_p)\n+{\n+  tree scope;\n+  tree name;\n+  tree decl;\n+  int quals;\n+\n+  my_friendly_assert (TREE_CODE (type) == TYPENAME_TYPE,\n+\t\t      20010702);\n+\n+  scope = TYPE_CONTEXT (type);\n+  name = TYPE_IDENTIFIER (type);\n+\n+  /* If the SCOPE is itself a TYPENAME_TYPE, then we need to resolve\n+     it first before we can figure out what NAME refers to.  */\n+  if (TREE_CODE (scope) == TYPENAME_TYPE)\n+    scope = resolve_typename_type (scope, only_current_p);\n+  /* If we don't know what SCOPE refers to, then we cannot resolve the\n+     TYPENAME_TYPE.  */\n+  if (scope == error_mark_node || TREE_CODE (scope) == TYPENAME_TYPE)\n+    return error_mark_node;\n+  /* If the SCOPE is a template type parameter, we have no way of\n+     resolving the name.  */\n+  if (TREE_CODE (scope) == TEMPLATE_TYPE_PARM)\n+    return type;\n+  /* If the SCOPE is not the current instantiation, there's no reason\n+     to look inside it.  */\n+  if (only_current_p && !currently_open_class (scope))\n+    return error_mark_node;\n+  /* Enter the SCOPE so that name lookup will be resolved as if we\n+     were in the class definition.  In particular, SCOPE will no\n+     longer be considered a dependent type.  */\n+  push_scope (scope);\n+  /* Look up the declaration.  */\n+  decl = lookup_member (scope, name, /*protect=*/0, /*want_type=*/1);\n+  /* Obtain the set of qualifiers applied to the TYPE.  */\n+  quals = cp_type_quals (type);\n+  /* For a TYPENAME_TYPE like \"typename X::template Y<T>\", we want to\n+     find a TEMPLATE_DECL.  Otherwise, we want to find a TYPE_DECL.  */\n+  if (!decl)\n+    type = error_mark_node;\n+  else if (TREE_CODE (TYPENAME_TYPE_FULLNAME (type)) == IDENTIFIER_NODE\n+\t   && TREE_CODE (decl) == TYPE_DECL)\n+    type = TREE_TYPE (decl);\n+  else if (TREE_CODE (TYPENAME_TYPE_FULLNAME (type)) == TEMPLATE_ID_EXPR\n+\t   && DECL_CLASS_TEMPLATE_P (decl))\n+    {\n+      tree tmpl;\n+      tree args;\n+      /* Obtain the template and the arguments.  */\n+      tmpl = TREE_OPERAND (TYPENAME_TYPE_FULLNAME (type), 0);\n+      args = TREE_OPERAND (TYPENAME_TYPE_FULLNAME (type), 1);\n+      /* Instantiate the template.  */\n+      type = lookup_template_class (tmpl, args, NULL_TREE, NULL_TREE,\n+\t\t\t\t    /*entering_scope=*/0, \n+\t\t\t\t    tf_error);\n+    }\n+  else\n+    type = error_mark_node;\n+  /* Qualify the resulting type.  */\n+  if (type != error_mark_node && quals)\n+    type = cp_build_qualified_type (type, quals);\n+  /* Leave the SCOPE.  */\n+  pop_scope (scope);\n+\n+  return type;\n+}\n+\n+tree\n+resolve_typename_type_in_current_instantiation (tree type)\n+{\n+  tree t;\n+\n+  t = resolve_typename_type (type, /*only_current_p=*/true);\n+  return (t != error_mark_node) ? t : type;\n+}\n+\n #include \"gt-cp-pt.h\""}, {"sha": "9c0b28b6b13fd54acc2d9e6017ee29359a1fbfb8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -1434,7 +1434,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual)\n       /* If the \"function\" is really an object of class type, it might\n \t have an overloaded `operator ()'.  */\n       tree result;\n-      result = build_opfncall (CALL_EXPR, LOOKUP_NORMAL, fn, args, NULL_TREE);\n+      result = build_new_op (CALL_EXPR, LOOKUP_NORMAL, fn, args, NULL_TREE);\n       if (result)\n \treturn result;\n     }\n@@ -1665,19 +1665,6 @@ begin_function_definition (decl_specs, attributes, declarator)\n   return 1;\n }\n \n-/* Begin a constructor declarator of the form `SCOPE::NAME'.  Returns\n-   a SCOPE_REF.  */\n-\n-tree \n-begin_constructor_declarator (scope, name)\n-     tree scope;\n-     tree name;\n-{\n-  tree result = build_nt (SCOPE_REF, scope, name);\n-  enter_scope_of (result);\n-  return result;\n-}\n-\n /* Finish an init-declarator.  Returns a DECL.  */\n \n tree\n@@ -1831,7 +1818,7 @@ begin_class_definition (t)\n       pushtag (TYPE_IDENTIFIER (t), t, 0);\n     }\n   maybe_process_partial_specialization (t);\n-  pushclass (t, 1);\n+  pushclass (t, true);\n   TYPE_BEING_DEFINED (t) = 1;\n   TYPE_PACKED (t) = flag_pack_struct;\n   /* Reset the interface data, at the earliest possible\n@@ -2044,34 +2031,6 @@ finish_template_type (name, args, entering_scope)\n   return decl;\n }\n \n-/* SR is a SCOPE_REF node.  Enter the scope of SR, whether it is a\n-   namespace scope or a class scope.  */\n-\n-void\n-enter_scope_of (sr)\n-     tree sr;\n-{\n-  tree scope = TREE_OPERAND (sr, 0);\n-\n-  if (TREE_CODE (scope) == NAMESPACE_DECL)\n-    {\n-      push_decl_namespace (scope);\n-      TREE_COMPLEXITY (sr) = -1;\n-    }\n-  else if (scope != current_class_type)\n-    {\n-      if (TREE_CODE (scope) == TYPENAME_TYPE)\n-\t{\n-\t  /* In a declarator for a template class member, the scope will\n-\t     get here as an implicit typename, a TYPENAME_TYPE with a type.  */\n-\t  scope = TREE_TYPE (scope);\n-\t  TREE_OPERAND (sr, 0) = scope;\n-\t}\n-      push_nested_class (scope, 3);\n-      TREE_COMPLEXITY (sr) = current_class_depth;\n-    }\n-}\n-\n /* Finish processing a BASE_CLASS with the indicated ACCESS_SPECIFIER.\n    Return a TREE_LIST containing the ACCESS_SPECIFIER and the\n    BASE_CLASS, or NULL_TREE if an error occurred.  The"}, {"sha": "9d11262b88c7f6ab94267bdead2ac37b3c2e47a5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 192, "deletions": 8, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -946,6 +946,13 @@ comptypes (t1, t2, strict)\n   if (TYPE_PTRMEMFUNC_P (t2))\n     t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n \n+  /* TYPENAME_TYPEs should be resolved if the qualifying scope is the\n+     current instantiation.  */\n+  if (TREE_CODE (t1) == TYPENAME_TYPE)\n+    t1 = resolve_typename_type_in_current_instantiation (t1);\n+  if (TREE_CODE (t2) == TYPENAME_TYPE)\n+    t2 = resolve_typename_type_in_current_instantiation (t2);\n+\n   /* Different classes of types can't be compatible.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return 0;\n@@ -2301,8 +2308,8 @@ build_x_indirect_ref (ptr, errorstring)\n   if (processing_template_decl)\n     return build_min_nt (INDIRECT_REF, ptr);\n \n-  rval = build_opfncall (INDIRECT_REF, LOOKUP_NORMAL, ptr, NULL_TREE,\n-\t\t\t NULL_TREE);\n+  rval = build_new_op (INDIRECT_REF, LOOKUP_NORMAL, ptr, NULL_TREE,\n+\t\t       NULL_TREE);\n   if (rval)\n     return rval;\n   return build_indirect_ref (ptr, errorstring);\n@@ -2973,6 +2980,183 @@ build_x_binary_op (code, arg1, arg2)\n   return build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n }\n \n+#if 0\n+\n+tree\n+build_template_expr (enum tree_code code, tree op0, tree op1, tree op2)\n+{\n+  tree type;\n+\n+  /* If any of the operands is erroneous the result is erroneous too.  */\n+  if (error_operand_p (op0)\n+      || (op1 && error_operand_p (op1))\n+      || (op2 && error_operand_p (op2)))\n+    return error_mark_node;\n+      \n+  if (dependent_type_p (TREE_TYPE (op0))\n+      || (op1 && dependent_type_p (TREE_TYPE (op1)))\n+      || (op2 && dependent_type_p (TREE_TYPE (op2))))\n+    /* If at least one operand has a dependent type, we cannot\n+       determine the type of the expression until instantiation time.  */\n+    type = NULL_TREE;\n+  else\n+    {\n+      struct z_candidate *cand;\n+      tree op0_type;\n+      tree op1_type;\n+      tree op2_type;\n+\n+      /* None of the operands is dependent, so we can compute the type\n+\t of the expression at this point.  We must compute the type so\n+\t that in things like:\n+\n+\t   template <int I>\n+\t   void f() { S<sizeof(I + 3)> s; ... }\n+\n+\t we can tell that the type of \"s\" is non-dependent.\n+\n+\t If we're processing a template argument, we do not want to\n+\t actually change the operands in any way.  Adding conversions,\n+\t performing constant folding, etc., would all change mangled\n+\t names.  For example, in:\n+\t \n+\t   template <int I>\n+\t   void f(S<sizeof(3 + 4 + I)>);\n+\t \n+\t we need to determine that \"3 + 4 + I\" has type \"int\", without\n+\t actually turning the expression into \"7 + I\".  */\n+      cand = find_overloaded_op (code, op0, op1, op2);\n+      if (cand) \n+\t/* If an overloaded operator was found, the expression will\n+\t   have the type returned by the function.  */\n+\ttype = non_reference (TREE_TYPE (cand->fn));\n+      else\n+\t{\n+\t  /* There is no overloaded operator so we can just use the\n+\t     default rules for determining the type of the operand.  */\n+\t  op0_type = TREE_TYPE (op0);\n+\t  op1_type = op1 ? TREE_TYPE (op1) : NULL_TREE;\n+\t  op2_type = op2 ? TREE_TYPE (op2) : NULL_TREE;\n+\t  type = NULL_TREE;\n+\n+\t  switch (code)\n+\t    {\n+\t    case MODIFY_EXPR:\n+\t      /* [expr.ass]\n+\n+\t\t The result of the assignment operation is the value\n+\t\t stored in the left operand.  */\n+\t      type = op0_type;\n+\t      break;\n+\t    case COMPONENT_REF:\n+\t      /* Implement this case.  */\n+\t      break;\n+\t    case POSTINCREMENT_EXPR:\n+\t    case POSTDECREMENT_EXPR:\n+\t      /* [expr.post.incr]\n+\n+\t\t The type of the result is the cv-unqualified version\n+\t\t of the type of the operand.  */\n+\t      type = TYPE_MAIN_VARIANT (op0_type);\n+\t      break;\n+\t    case PREINCREMENT_EXPR:\n+\t    case PREDECREMENT_EXPR:\n+\t      /* [expr.pre.incr]\n+\n+\t\t The value is the new value of the operand.  */\n+\t      type = op0_type;\n+\t      break;\n+\t    case INDIRECT_REF:\n+\t      /* [expr.unary.op]\n+\n+\t\t If the type of the expression is \"pointer to T\", the\n+\t\t type of the result is \"T\".  */\n+\t      type = TREE_TYPE (op0_type);\n+\t      break;\n+\t    case ADDR_EXPR:\n+\t      /* [expr.unary.op]\n+\n+\t\t If the type of the expression is \"T\", the type of the\n+\t\t result is \"pointer to T\".  */\n+\t      /* FIXME: Handle the pointer-to-member case.  */\n+\t      break;\n+\t    case MEMBER_REF:\n+\t      /* FIXME: Implement this case.  */\n+\t      break;\n+\t    case LSHIFT_EXPR:\n+\t    case RSHIFT_EXPR:\n+\t      /* [expr.shift]\n+\n+\t\t The type of the result is that of the promoted left\n+\t\t operand.  */\n+\t      break;\n+\t    case PLUS_EXPR:\n+\t    case MINUS_EXPR:\n+\t      /* FIXME: Be careful of special pointer-arithmetic\n+\t\t cases.  */\n+\t      /* Fall through. */\n+\t    case MAX_EXPR:\n+\t    case MIN_EXPR:\n+\t      /* These are GNU extensions; the result type is computed\n+\t\t as it would be for other arithmetic operators.  */\n+\t      /* Fall through. */\n+\t    case BIT_AND_EXPR:\n+\t    case BIT_XOR_EXPR:\n+\t    case BIT_IOR_EXPR:\n+\t    case MULT_EXPR:\n+\t    case TRUNC_DIV_EXPR:\n+\t    case TRUNC_MOD_EXPR:\n+\t      /* [expr.bit.and], [expr.xor], [expr.or], [expr.mul]\n+\n+\t\t The usual arithmetic conversions are performed on the\n+\t\t operands and determine the type of the result.  */\n+\t      /* FIXME: Check that this is possible.  */\n+\t      type = type_after_usual_arithmetic_conversions (t1, t2);\n+\t      break;\n+\t    case GT_EXPR:\n+\t    case LT_EXPR:\n+\t    case GE_EXPR:\n+\t    case LE_EXPR:\n+\t    case EQ_EXPR:\n+\t    case NE_EXPR:\n+\t      /* [expr.rel]\n+\n+\t\t The type of the result is bool.  */\n+\t      type = boolean_type_node;\n+\t      break;\n+\t    case TRUTH_ANDIF_EXPR:\n+\t    case TRUTH_ORIF_EXPR:\n+\t      /* [expr.log.and], [expr.log.org]\n+\t\t \n+\t\t The result is a bool.  */\n+\t      type = boolean_type_node;\n+\t      break;\n+\t    case COND_EXPR:\n+\t      /* FIXME: Handle special rules for conditioanl\n+\t\t expressions.  */\n+\t      break;\n+\t    case COMPOUND_EXPR:\n+\t      type = op1_type;\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n+\t  /* If the type of the expression could not be determined,\n+\t     something is wrong.  */\n+\t  if (!type)\n+\t    abort ();\n+\t  /* If the type is erroneous, the expression is erroneous\n+\t     too.  */\n+\t  if (type == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n+    }\n+  \n+  return build_min (code, type, op0, op1, op2, NULL_TREE);\n+}\n+\n+#endif\n+\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n    This function differs from `build' in several ways:\n@@ -4602,8 +4786,8 @@ build_x_compound_expr (list)\n   if (rest == NULL_TREE)\n     return build_compound_expr (list);\n \n-  result = build_opfncall (COMPOUND_EXPR, LOOKUP_NORMAL,\n-\t\t\t   TREE_VALUE (list), TREE_VALUE (rest), NULL_TREE);\n+  result = build_new_op (COMPOUND_EXPR, LOOKUP_NORMAL,\n+\t\t\t TREE_VALUE (list), TREE_VALUE (rest), NULL_TREE);\n   if (result)\n     return build_x_compound_expr (tree_cons (NULL_TREE, result,\n \t\t\t\t\t\t  TREE_CHAIN (rest)));\n@@ -5235,8 +5419,8 @@ build_modify_expr (lhs, modifycode, rhs)\n \t    /* Do the default thing */;\n \t  else\n \t    {\n-\t      result = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,\n-\t\t\t\t       lhs, rhs, make_node (NOP_EXPR));\n+\t      result = build_new_op (MODIFY_EXPR, LOOKUP_NORMAL,\n+\t\t\t\t     lhs, rhs, make_node (NOP_EXPR));\n \t      if (result == NULL_TREE)\n \t\treturn error_mark_node;\n \t      return result;\n@@ -5488,8 +5672,8 @@ build_x_modify_expr (lhs, modifycode, rhs)\n \n   if (modifycode != NOP_EXPR)\n     {\n-      tree rval = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL, lhs, rhs,\n-\t\t\t\t  make_node (modifycode));\n+      tree rval = build_new_op (MODIFY_EXPR, LOOKUP_NORMAL, lhs, rhs,\n+\t\t\t\tmake_node (modifycode));\n       if (rval)\n \treturn rval;\n     }"}, {"sha": "c7dcb527b82e8f043dbc7c08ed6ce64090e8790f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -1044,8 +1044,8 @@ build_x_arrow (datum)\n \n   if (IS_AGGR_TYPE (type))\n     {\n-      while ((rval = build_opfncall (COMPONENT_REF, LOOKUP_NORMAL, rval,\n-\t\t\t\t     NULL_TREE, NULL_TREE)))\n+      while ((rval = build_new_op (COMPONENT_REF, LOOKUP_NORMAL, rval,\n+\t\t\t\t   NULL_TREE, NULL_TREE)))\n \t{\n \t  if (rval == error_mark_node)\n \t    return error_mark_node;"}, {"sha": "8704a8df8eed683020d2854574a25384fba91ca2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -1,3 +1,7 @@\n+2003-01-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/parser/constant1.C: New test.\n+\n 2003-01-29  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/8591"}, {"sha": "0a889289b72a8b7c6c2a3f03929b72363d8c9a48", "filename": "gcc/testsuite/g++.dg/parse/constant1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant1.C?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -0,0 +1,13 @@\n+void f () {\n+  switch (0) {\n+  case (3, 0): // { dg-error \"\" }\n+    break;\n+  }\n+}\n+\n+int g ();\n+\n+struct S {\n+  int i : (false ? g () : 1); // { dg-error \"\" }\n+};\n+"}, {"sha": "fd0d93fa2e7e0c6c5fe4b71aae74a41d2e666224", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -1,3 +1,15 @@\n+2003-01-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* include/std/std_limits.h (numeric_limits<float>::has_infinity):\n+\tUse __FLT_HAS_INIFINITY__ to initialize.\n+\t(numeric_limits<float>::has_quiet_NaN): Likewise.\n+\t(numeric_limits<double>::has_infinity): Use __DBL_HAS_INIFINITY__\n+\tto initialize.\n+\t(numeric_limits<double>::has_quiet_NaN): Likewise.\n+\t(numeric_limits<long double>::has_infinity): Use\n+\t__LDBL_HAS_INIFINITY__ to initialize.\n+\t(numeric_limits<long_double>::has_quiet_NaN): Likewise.\n+\n 2003-01-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/9433"}, {"sha": "2248071bc09015a0146da3cd3638ff93896a1268", "filename": "libstdc++-v3/include/std/std_limits.h", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_limits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14d22dd6675f2225b5de7c0e591893f84fb6b9e0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_limits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_limits.h?ref=14d22dd6675f2225b5de7c0e591893f84fb6b9e0", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- numeric_limits classes.\n \n-// Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -893,10 +893,8 @@ namespace std\n       static const int max_exponent = __FLT_MAX_EXP__;\n       static const int max_exponent10 = __FLT_MAX_10_EXP__;\n \n-      static const bool has_infinity\n-\t= __builtin_huge_valf () / 2 == __builtin_huge_valf ();\n-      static const bool has_quiet_NaN\n-\t= __builtin_nanf (\"\") != __builtin_nanf (\"\");\n+      static const bool has_infinity = __FLT_HAS_INFINITY__;\n+      static const bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;\n       static const bool has_signaling_NaN = has_quiet_NaN;\n       static const float_denorm_style has_denorm\n \t= __FLT_DENORM_MIN__ ? denorm_present : denorm_absent;\n@@ -951,10 +949,8 @@ namespace std\n       static const int max_exponent = __DBL_MAX_EXP__;\n       static const int max_exponent10 = __DBL_MAX_10_EXP__;\n \n-      static const bool has_infinity\n-\t= __builtin_huge_val () / 2 == __builtin_huge_val ();\n-      static const bool has_quiet_NaN\n-\t= __builtin_nan (\"\") != __builtin_nan (\"\");\n+      static const bool has_infinity = __DBL_HAS_INFINITY__;\n+      static const bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;\n       static const bool has_signaling_NaN = has_quiet_NaN;\n       static const float_denorm_style has_denorm\n \t= __DBL_DENORM_MIN__ ? denorm_present : denorm_absent;\n@@ -1009,10 +1005,8 @@ namespace std\n       static const int max_exponent = __LDBL_MAX_EXP__;\n       static const int max_exponent10 = __LDBL_MAX_10_EXP__;\n \n-      static const bool has_infinity\n-\t= __builtin_huge_vall () / 2 == __builtin_huge_vall ();\n-      static const bool has_quiet_NaN\n-\t= __builtin_nanl (\"\") != __builtin_nanl (\"\");\n+      static const bool has_infinity = __LDBL_HAS_INFINITY__;\n+      static const bool has_quiet_NaN = __LDBL_HAS_QUIET_NAN__;\n       static const bool has_signaling_NaN = has_quiet_NaN;\n       static const float_denorm_style has_denorm\n \t= __LDBL_DENORM_MIN__ ? denorm_present : denorm_absent;"}]}