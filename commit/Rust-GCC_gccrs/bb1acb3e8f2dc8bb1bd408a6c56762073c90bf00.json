{"sha": "bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIxYWNiM2U4ZjJkYzhiYjFiZDQwOGE2YzU2NzYyMDczYzkwYmYwMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-03-25T00:58:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-03-25T00:58:57Z"}, "message": "alias.c (alias_invariant, [...]): Mark GTY.\n\n        * alias.c (alias_invariant, alias_invariant_size): Mark GTY.\n        (reg_known_value, reg_known_value_size): Likewise; make static.\n        (reg_known_equiv_p): Make static.\n        (clear_reg_alias_info): Update for new indexing.\n        (get_reg_known_value, set_reg_known_value): New.\n        (get_reg_known_equiv_p, set_reg_known_equiv_p): New.\n        (canon_rtx): Use them.\n        (init_alias_analysis): Likewise.  Allocate reg_known_value with gc.\n        Don't play queer offsetting games with reg_known_value and\n        reg_known_equiv_p.\n        (end_alias_analysis): Free reg_known_value with gc.\n        * rtl.h (get_reg_known_value, get_reg_known_equiv_p): Declare.\n        * sched-deps.c (reg_known_equiv_p, reg_known_value): Remove.\n        (deps_may_trap_p, sched_analyze_1, sched_analyze_2): Use the new\n        functions instead.\n\nFrom-SVN: r79945", "tree": {"sha": "8cdddee725800b5e9dccac42180f7f908c632294", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cdddee725800b5e9dccac42180f7f908c632294"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00/comments", "author": null, "committer": null, "parents": [{"sha": "bbcb76f2641a4bd47d0dd090d12857d88743175d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbcb76f2641a4bd47d0dd090d12857d88743175d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbcb76f2641a4bd47d0dd090d12857d88743175d"}], "stats": {"total": 189, "additions": 136, "deletions": 53}, "files": [{"sha": "f82691862eeeeacab77f7bc9a5afe9b78e238914", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00", "patch": "@@ -1,3 +1,21 @@\n+2004-03-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* alias.c (alias_invariant, alias_invariant_size): Mark GTY.\n+\t(reg_known_value, reg_known_value_size): Likewise; make static.\n+\t(reg_known_equiv_p): Make static.\n+\t(clear_reg_alias_info): Update for new indexing.\n+\t(get_reg_known_value, set_reg_known_value): New.\n+\t(get_reg_known_equiv_p, set_reg_known_equiv_p): New.\n+\t(canon_rtx): Use them.\n+\t(init_alias_analysis): Likewise.  Allocate reg_known_value with gc.\n+\tDon't play queer offsetting games with reg_known_value and\n+\treg_known_equiv_p.\n+\t(end_alias_analysis): Free reg_known_value with gc.\n+\t* rtl.h (get_reg_known_value, get_reg_known_equiv_p): Declare.\n+\t* sched-deps.c (reg_known_equiv_p, reg_known_value): Remove.\n+\t(deps_may_trap_p, sched_analyze_1, sched_analyze_2): Use the new\n+\tfunctions instead.\n+\n 2004-03-24  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* dwarf2asm.c, loop.h, pretty-print.c, pretty-print.h,"}, {"sha": "f2bf80661f6001fb88f7bdc30facfede9fa5c7fa", "filename": "gcc/alias.c", "status": "modified", "additions": 98, "deletions": 39, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00", "patch": "@@ -181,17 +181,16 @@ static GTY (()) rtx static_reg_base_value[FIRST_PSEUDO_REGISTER];\n \n    Because this array contains only pseudo registers it has no effect\n    after reload.  */\n-static rtx *alias_invariant;\n-unsigned int alias_invariant_size;\n+static GTY((length(\"alias_invariant_size\"))) rtx *alias_invariant;\n+unsigned GTY(()) int alias_invariant_size;\n \n /* Vector indexed by N giving the initial (unchanging) value known for\n-   pseudo-register N.  This array is initialized in\n-   init_alias_analysis, and does not change until end_alias_analysis\n-   is called.  */\n-rtx *reg_known_value;\n+   pseudo-register N.  This array is initialized in init_alias_analysis,\n+   and does not change until end_alias_analysis is called.  */\n+static GTY((length(\"reg_known_value_size\"))) rtx *reg_known_value;\n \n /* Indicates number of valid entries in reg_known_value.  */\n-static unsigned int reg_known_value_size;\n+static GTY(()) unsigned int reg_known_value_size;\n \n /* Vector recording for each reg_known_value whether it is due to a\n    REG_EQUIV note.  Future passes (viz., reload) may replace the\n@@ -205,7 +204,7 @@ static unsigned int reg_known_value_size;\n    REG_EQUIV notes.  One could argue that the REG_EQUIV notes are\n    wrong, but solving the problem in the scheduler will likely give\n    better code, so we do it here.  */\n-char *reg_known_equiv_p;\n+static bool *reg_known_equiv_p;\n \n /* True when scanning insns from the start of the rtl to the\n    NOTE_INSN_FUNCTION_BEG note.  */\n@@ -1075,10 +1074,70 @@ clear_reg_alias_info (rtx reg)\n {\n   unsigned int regno = REGNO (reg);\n \n-  if (regno < reg_known_value_size && regno >= FIRST_PSEUDO_REGISTER)\n-    reg_known_value[regno] = reg;\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      regno -= FIRST_PSEUDO_REGISTER;\n+      if (regno < reg_known_value_size)\n+\t{\n+\t  reg_known_value[regno] = reg;\n+\t  reg_known_equiv_p[regno] = false;\n+\t}\n+    }\n+}\n+\n+/* If a value is known for REGNO, return it.  */\n+\n+rtx \n+get_reg_known_value (unsigned int regno)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      regno -= FIRST_PSEUDO_REGISTER;\n+      if (regno < reg_known_value_size)\n+\treturn reg_known_value[regno];\n+    }\n+  return NULL;\n }\n \n+/* Set it.  */\n+\n+static void\n+set_reg_known_value (unsigned int regno, rtx val)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      regno -= FIRST_PSEUDO_REGISTER;\n+      if (regno < reg_known_value_size)\n+\treg_known_value[regno] = val;\n+    }\n+}\n+\n+/* Similarly for reg_known_equiv_p.  */\n+\n+bool\n+get_reg_known_equiv_p (unsigned int regno)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      regno -= FIRST_PSEUDO_REGISTER;\n+      if (regno < reg_known_value_size)\n+\treturn reg_known_equiv_p[regno];\n+    }\n+  return false;\n+}\n+\n+static void\n+set_reg_known_equiv_p (unsigned int regno, bool val)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      regno -= FIRST_PSEUDO_REGISTER;\n+      if (regno < reg_known_value_size)\n+\treg_known_equiv_p[regno] = val;\n+    }\n+}\n+\n+\n /* Returns a canonical version of X, from the point of view alias\n    analysis.  (For example, if X is a MEM whose address is a register,\n    and the register has a known value (say a SYMBOL_REF), then a MEM\n@@ -1088,11 +1147,16 @@ rtx\n canon_rtx (rtx x)\n {\n   /* Recursively look for equivalences.  */\n-  if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER\n-      && REGNO (x) < reg_known_value_size)\n-    return reg_known_value[REGNO (x)] == x\n-      ? x : canon_rtx (reg_known_value[REGNO (x)]);\n-  else if (GET_CODE (x) == PLUS)\n+  if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+    {\n+      rtx t = get_reg_known_value (REGNO (x));\n+      if (t == x)\n+\treturn x;\n+      if (t)\n+\treturn canon_rtx (t);\n+    }\n+\n+  if (GET_CODE (x) == PLUS)\n     {\n       rtx x0 = canon_rtx (XEXP (x, 0));\n       rtx x1 = canon_rtx (XEXP (x, 1));\n@@ -2736,14 +2800,9 @@ init_alias_analysis (void)\n \n   timevar_push (TV_ALIAS_ANALYSIS);\n \n-  reg_known_value_size = maxreg;\n-\n-  reg_known_value\n-    = (rtx *) xcalloc ((maxreg - FIRST_PSEUDO_REGISTER), sizeof (rtx))\n-    - FIRST_PSEUDO_REGISTER;\n-  reg_known_equiv_p\n-    = (char*) xcalloc ((maxreg - FIRST_PSEUDO_REGISTER), sizeof (char))\n-    - FIRST_PSEUDO_REGISTER;\n+  reg_known_value_size = maxreg - FIRST_PSEUDO_REGISTER;\n+  reg_known_value = ggc_calloc (reg_known_value_size, sizeof (rtx));\n+  reg_known_equiv_p = xcalloc (reg_known_value_size, sizeof (bool));\n \n   /* Overallocate reg_base_value to allow some growth during loop\n      optimization.  Loop unrolling can create a large number of\n@@ -2861,36 +2920,36 @@ init_alias_analysis (void)\n \t\t{\n \t\t  unsigned int regno = REGNO (SET_DEST (set));\n \t\t  rtx src = SET_SRC (set);\n+\t\t  rtx t;\n \n \t\t  if (REG_NOTES (insn) != 0\n \t\t      && (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n \t\t\t   && REG_N_SETS (regno) == 1)\n \t\t\t  || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n \t\t      && GET_CODE (XEXP (note, 0)) != EXPR_LIST\n \t\t      && ! rtx_varies_p (XEXP (note, 0), 1)\n-\t\t      && ! reg_overlap_mentioned_p (SET_DEST (set), XEXP (note, 0)))\n+\t\t      && ! reg_overlap_mentioned_p (SET_DEST (set),\n+\t\t\t\t\t\t    XEXP (note, 0)))\n \t\t    {\n-\t\t      reg_known_value[regno] = XEXP (note, 0);\n-\t\t      reg_known_equiv_p[regno] = REG_NOTE_KIND (note) == REG_EQUIV;\n+\t\t      set_reg_known_value (regno, XEXP (note, 0));\n+\t\t      set_reg_known_equiv_p (regno,\n+\t\t\tREG_NOTE_KIND (note) == REG_EQUIV);\n \t\t    }\n \t\t  else if (REG_N_SETS (regno) == 1\n \t\t\t   && GET_CODE (src) == PLUS\n \t\t\t   && GET_CODE (XEXP (src, 0)) == REG\n-\t\t\t   && REGNO (XEXP (src, 0)) >= FIRST_PSEUDO_REGISTER\n-\t\t\t   && (reg_known_value[REGNO (XEXP (src, 0))])\n+\t\t\t   && (t = get_reg_known_value (REGNO (XEXP (src, 0))))\n \t\t\t   && GET_CODE (XEXP (src, 1)) == CONST_INT)\n \t\t    {\n-\t\t      rtx op0 = XEXP (src, 0);\n-\t\t      op0 = reg_known_value[REGNO (op0)];\n-\t\t      reg_known_value[regno]\n-\t\t\t= plus_constant (op0, INTVAL (XEXP (src, 1)));\n-\t\t      reg_known_equiv_p[regno] = 0;\n+\t\t      t = plus_constant (t, INTVAL (XEXP (src, 1)));\n+\t\t      set_reg_known_value (regno, t);\n+\t\t      set_reg_known_equiv_p (regno, 0);\n \t\t    }\n \t\t  else if (REG_N_SETS (regno) == 1\n \t\t\t   && ! rtx_varies_p (src, 1))\n \t\t    {\n-\t\t      reg_known_value[regno] = src;\n-\t\t      reg_known_equiv_p[regno] = 0;\n+\t\t      set_reg_known_value (regno, src);\n+\t\t      set_reg_known_equiv_p (regno, 0);\n \t\t    }\n \t\t}\n \t    }\n@@ -2917,9 +2976,9 @@ init_alias_analysis (void)\n   while (changed && ++pass < MAX_ALIAS_LOOP_PASSES);\n \n   /* Fill in the remaining entries.  */\n-  for (i = FIRST_PSEUDO_REGISTER; i < (int)maxreg; i++)\n+  for (i = 0; i < (int)reg_known_value_size; i++)\n     if (reg_known_value[i] == 0)\n-      reg_known_value[i] = regno_reg_rtx[i];\n+      reg_known_value[i] = regno_reg_rtx[i + FIRST_PSEUDO_REGISTER];\n \n   /* Simplify the reg_base_value array so that no register refers to\n      another register, except to special registers indirectly through\n@@ -2965,10 +3024,10 @@ void\n end_alias_analysis (void)\n {\n   old_reg_base_value = reg_base_value;\n-  free (reg_known_value + FIRST_PSEUDO_REGISTER);\n+  ggc_free (reg_known_value);\n   reg_known_value = 0;\n   reg_known_value_size = 0;\n-  free (reg_known_equiv_p + FIRST_PSEUDO_REGISTER);\n+  free (reg_known_equiv_p);\n   reg_known_equiv_p = 0;\n   if (alias_invariant)\n     {"}, {"sha": "d17325c2b9d1895f7f0e381aa2ffe9609430bdf9", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00", "patch": "@@ -2423,6 +2423,8 @@ extern rtx addr_side_effect_eval (rtx, int, int);\n extern bool memory_modified_in_insn_p (rtx, rtx);\n extern rtx find_base_term (rtx);\n extern rtx gen_hard_reg_clobber (enum machine_mode, unsigned int);\n+extern rtx get_reg_known_value (unsigned int);\n+extern bool get_reg_known_equiv_p (unsigned int);\n \n /* In sibcall.c */\n typedef enum {"}, {"sha": "7802bf23e61cbdbe5e4a783dd7db032a5d690c6a", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=bb1acb3e8f2dc8bb1bd408a6c56762073c90bf00", "patch": "@@ -44,8 +44,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cselib.h\"\n #include \"df.h\"\n \n-extern char *reg_known_equiv_p;\n-extern rtx *reg_known_value;\n \n static regset_head reg_pending_sets_head;\n static regset_head reg_pending_clobbers_head;\n@@ -113,10 +111,12 @@ deps_may_trap_p (rtx mem)\n {\n   rtx addr = XEXP (mem, 0);\n \n-  if (REG_P (addr)\n-      && REGNO (addr) >= FIRST_PSEUDO_REGISTER\n-      && reg_known_value[REGNO (addr)])\n-    addr = reg_known_value[REGNO (addr)];\n+  if (REG_P (addr) && REGNO (addr) >= FIRST_PSEUDO_REGISTER)\n+    {\n+      rtx t = get_reg_known_value (REGNO (addr));\n+      if (t)\n+\taddr = t;\n+    }\n   return rtx_addr_can_trap_p (addr);\n }\n \f\n@@ -523,10 +523,12 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \t  /* Pseudos that are REG_EQUIV to something may be replaced\n \t     by that during reloading.  We need only add dependencies for\n \t     the address in the REG_EQUIV note.  */\n-\t  if (!reload_completed\n-\t      && reg_known_equiv_p[regno]\n-\t      && GET_CODE (reg_known_value[regno]) == MEM)\n-\t    sched_analyze_2 (deps, XEXP (reg_known_value[regno], 0), insn);\n+\t  if (!reload_completed && get_reg_known_equiv_p (regno))\n+\t    {\n+\t      rtx t = get_reg_known_value (regno);\n+\t      if (GET_CODE (t) == MEM)\n+\t        sched_analyze_2 (deps, XEXP (t, 0), insn);\n+\t    }\n \n \t  /* Don't let it cross a call after scheduling if it doesn't\n \t     already cross one.  */\n@@ -659,10 +661,12 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \t    /* Pseudos that are REG_EQUIV to something may be replaced\n \t       by that during reloading.  We need only add dependencies for\n \t       the address in the REG_EQUIV note.  */\n-\t    if (!reload_completed\n-\t\t&& reg_known_equiv_p[regno]\n-\t\t&& GET_CODE (reg_known_value[regno]) == MEM)\n-\t      sched_analyze_2 (deps, XEXP (reg_known_value[regno], 0), insn);\n+\t    if (!reload_completed && get_reg_known_equiv_p (regno))\n+\t      {\n+\t\trtx t = get_reg_known_value (regno);\n+\t\tif (GET_CODE (t) == MEM)\n+\t\t  sched_analyze_2 (deps, XEXP (t, 0), insn);\n+\t      }\n \n \t    /* If the register does not already cross any calls, then add this\n \t       insn to the sched_before_next_call list so that it will still"}]}