{"sha": "42ceec0607f3235904c68d3ede1aaddb70eb06aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJjZWVjMDYwN2YzMjM1OTA0YzY4ZDNlZGUxYWFkZGI3MGViMDZhYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-10-30T11:58:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-30T11:58:03Z"}, "message": "cp-tree.h (omp_declare_variant_finalize, [...]): Declare.\n\n\t* cp-tree.h (omp_declare_variant_finalize, build_local_temp): Declare.\n\t* decl.c: Include omp-general.h.\n\t(declare_simd_adjust_this): Add forward declaration.\n\t(omp_declare_variant_finalize_one, omp_declare_variant_finalize): New\n\tfunction.\n\t(cp_finish_decl, finish_function): Call omp_declare_variant_finalize.\n\t* parser.c (cp_finish_omp_declare_variant): Adjust parsing of the\n\tvariant id-expression and propagate enough information to\n\tomp_declare_variant_finalize_one in the attribute so that it can\n\tfinalize it.\n\t* class.c (finish_struct): Call omp_declare_variant_finalize.\n\t* tree.c (build_local_temp): No longer static, remove forward\n\tdeclaration.\n\n\t* c-c++-common/gomp/declare-variant-2.c: Add a test with , before\n\tmatch clause.\n\t* c-c++-common/gomp/declare-variant-6.c: Expect diagnostics also from\n\tC++ FE and adjust regexp so that it handles C++ pretty printing of\n\tfunction names.\n\t* g++.dg/gomp/declare-variant-1.C: New test.\n\t* g++.dg/gomp/declare-variant-2.C: New test.\n\t* g++.dg/gomp/declare-variant-3.C: New test.\n\t* g++.dg/gomp/declare-variant-4.C: New test.\n\t* g++.dg/gomp/declare-variant-5.C: New test.\n\nFrom-SVN: r277613", "tree": {"sha": "313194a2ff9eb15d51d4ebe286f26d7fc0e7899b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/313194a2ff9eb15d51d4ebe286f26d7fc0e7899b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42ceec0607f3235904c68d3ede1aaddb70eb06aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ceec0607f3235904c68d3ede1aaddb70eb06aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42ceec0607f3235904c68d3ede1aaddb70eb06aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ceec0607f3235904c68d3ede1aaddb70eb06aa/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "96e05bf5aece312bb35736bf3b6bd59560b312a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e05bf5aece312bb35736bf3b6bd59560b312a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e05bf5aece312bb35736bf3b6bd59560b312a1"}], "stats": {"total": 715, "additions": 691, "deletions": 24}, "files": [{"sha": "55c3f0babe7709b54f7000a564ed8ca3fc53548a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -1,3 +1,19 @@\n+2019-10-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-tree.h (omp_declare_variant_finalize, build_local_temp): Declare.\n+\t* decl.c: Include omp-general.h.\n+\t(declare_simd_adjust_this): Add forward declaration.\n+\t(omp_declare_variant_finalize_one, omp_declare_variant_finalize): New\n+\tfunction.\n+\t(cp_finish_decl, finish_function): Call omp_declare_variant_finalize.\n+\t* parser.c (cp_finish_omp_declare_variant): Adjust parsing of the\n+\tvariant id-expression and propagate enough information to\n+\tomp_declare_variant_finalize_one in the attribute so that it can\n+\tfinalize it.\n+\t* class.c (finish_struct): Call omp_declare_variant_finalize.\n+\t* tree.c (build_local_temp): No longer static, remove forward\n+\tdeclaration.\n+\n 2019-10-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* typeck.c (cp_build_modify_expr): Prefer error + inform to"}, {"sha": "045b2e33dbb94c99f73f12f733a7dd692700916f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -7378,6 +7378,14 @@ finish_struct (tree t, tree attributes)\n   else\n     error (\"trying to finish struct, but kicked out due to previous parse errors\");\n \n+  if (flag_openmp)\n+    for (tree decl = TYPE_FIELDS (t); decl; decl = DECL_CHAIN (decl))\n+      if (TREE_CODE (decl) == FUNCTION_DECL\n+\t  && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n+\tif (tree attr = lookup_attribute (\"omp declare variant base\",\n+\t\t\t\t\t  DECL_ATTRIBUTES (decl)))\n+\t  omp_declare_variant_finalize (decl, attr);\n+\n   if (processing_template_decl && at_function_scope_p ()\n       /* Lambdas are defined by the LAMBDA_EXPR.  */\n       && !LAMBDA_TYPE_P (t))"}, {"sha": "42e03a31e20a2b23c9c7a8e03d519512e235c5c6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -6435,6 +6435,7 @@ extern tree groktypename\t\t\t(cp_decl_specifier_seq *, const cp_declarator *, bool\n extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int, tree, tree, tree *);\n extern void start_decl_1\t\t\t(tree, bool);\n extern bool check_array_initializer\t\t(tree, tree, tree);\n+extern void omp_declare_variant_finalize\t(tree, tree);\n extern void cp_finish_decl\t\t\t(tree, tree, bool, tree, int);\n extern tree lookup_decomp_type\t\t\t(tree);\n extern void cp_maybe_mangle_decomp\t\t(tree, tree, unsigned int);\n@@ -7293,6 +7294,7 @@ extern tree build_min_nt_call_vec (tree, vec<tree, va_gc> *);\n extern tree build_min_non_dep_call_vec\t\t(tree, tree, vec<tree, va_gc> *);\n extern vec<tree, va_gc>* vec_copy_and_insert    (vec<tree, va_gc>*, tree, unsigned);\n extern tree build_cplus_new\t\t\t(tree, tree, tsubst_flags_t);\n+extern tree build_local_temp\t\t\t(tree);\n extern tree build_aggr_init_expr\t\t(tree, tree);\n extern tree get_target_expr\t\t\t(tree);\n extern tree get_target_expr_sfinae\t\t(tree, tsubst_flags_t);"}, {"sha": "8320597c10884e82b9f98aa19bb84af0ac9b9993", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"asan.h\"\n #include \"gcc-rich-location.h\"\n #include \"langhooks.h\"\n+#include \"omp-general.h\"\n \n /* Possible cases of bad specifiers type used by bad_specifiers. */\n enum bad_spec_place {\n@@ -7070,6 +7071,195 @@ decl_maybe_constant_destruction (tree decl, tree type)\n \t      && type_has_constexpr_destructor (strip_array_types (type))));\n }\n \n+static tree declare_simd_adjust_this (tree *, int *, void *);\n+\n+/* Helper function of omp_declare_variant_finalize.  Finalize one\n+   \"omp declare variant base\" attribute.  Return true if it should be\n+   removed.  */\n+\n+static bool\n+omp_declare_variant_finalize_one (tree decl, tree attr)\n+{\n+  if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n+    walk_tree (&TREE_VALUE (TREE_VALUE (attr)), declare_simd_adjust_this,\n+\t       DECL_ARGUMENTS (decl), NULL);\n+\n+  tree ctx = TREE_VALUE (TREE_VALUE (attr));\n+  tree simd = c_omp_get_context_selector (ctx, \"construct\", \"simd\");\n+  if (simd)\n+    {\n+      TREE_VALUE (simd)\n+\t= c_omp_declare_simd_clauses_to_numbers (DECL_ARGUMENTS (decl),\n+\t\t\t\t\t\t TREE_VALUE (simd));\n+      /* FIXME, adjusting simd args unimplemented.  */\n+      return true;\n+    }\n+\n+  tree chain = TREE_CHAIN (TREE_VALUE (attr));\n+  location_t varid_loc\n+    = cp_expr_loc_or_input_loc (TREE_PURPOSE (TREE_CHAIN (chain)));\n+  location_t match_loc = cp_expr_loc_or_input_loc (TREE_PURPOSE (chain));\n+  cp_id_kind idk = (cp_id_kind) tree_to_uhwi (TREE_VALUE (chain));\n+  tree variant = TREE_PURPOSE (TREE_VALUE (attr));\n+\n+  location_t save_loc = input_location;\n+  input_location = varid_loc;\n+\n+  releasing_vec args;\n+  tree parm = DECL_ARGUMENTS (decl);\n+  if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n+    parm = DECL_CHAIN (parm);\n+  for (; parm; parm = DECL_CHAIN (parm))\n+    if (type_dependent_expression_p (parm))\n+      vec_safe_push (args, build_constructor (TREE_TYPE (parm), NULL));\n+    else if (MAYBE_CLASS_TYPE_P (TREE_TYPE (parm)))\n+      vec_safe_push (args, build_local_temp (TREE_TYPE (parm)));\n+    else\n+      vec_safe_push (args, build_zero_cst (TREE_TYPE (parm)));\n+\n+  bool koenig_p = false;\n+  if (idk == CP_ID_KIND_UNQUALIFIED || idk == CP_ID_KIND_TEMPLATE_ID)\n+    {\n+      if (identifier_p (variant)\n+\t  /* In C++2A, we may need to perform ADL for a template\n+\t     name.  */\n+\t  || (TREE_CODE (variant) == TEMPLATE_ID_EXPR\n+\t      && identifier_p (TREE_OPERAND (variant, 0))))\n+\t{\n+\t  if (!args->is_empty ())\n+\t    {\n+\t      koenig_p = true;\n+\t      if (!any_type_dependent_arguments_p (args))\n+\t\tvariant = perform_koenig_lookup (variant, args,\n+\t\t\t\t\t\t tf_warning_or_error);\n+\t    }\n+\t  else\n+\t    variant = unqualified_fn_lookup_error (variant);\n+\t}\n+      else if (!args->is_empty () && is_overloaded_fn (variant))\n+\t{\n+\t  tree fn = get_first_fn (variant);\n+\t  fn = STRIP_TEMPLATE (fn);\n+\t  if (!((TREE_CODE (fn) == USING_DECL && DECL_DEPENDENT_P (fn))\n+\t\t || DECL_FUNCTION_MEMBER_P (fn)\n+\t\t || DECL_LOCAL_FUNCTION_P (fn)))\n+\t    {\n+\t      koenig_p = true;\n+\t      if (!any_type_dependent_arguments_p (args))\n+\t\tvariant = perform_koenig_lookup (variant, args,\n+\t\t\t\t\t\t tf_warning_or_error);\n+\t    }\n+\t}\n+    }\n+\n+  if (idk == CP_ID_KIND_QUALIFIED)\n+    variant = finish_call_expr (variant, &args, /*disallow_virtual=*/true,\n+\t\t\t\tkoenig_p, tf_warning_or_error);\n+  else\n+    variant = finish_call_expr (variant, &args, /*disallow_virtual=*/false,\n+\t\t\t\tkoenig_p, tf_warning_or_error);\n+  if (variant == error_mark_node && !processing_template_decl)\n+    return true;\n+\n+  variant = cp_get_callee_fndecl_nofold (variant);\n+\n+  input_location = save_loc;\n+\n+  if (variant)\n+    {\n+      const char *varname = IDENTIFIER_POINTER (DECL_NAME (variant));\n+      if (!comptypes (TREE_TYPE (decl), TREE_TYPE (variant), 0))\n+\t{\n+\t  error_at (varid_loc, \"variant %qD and base %qD have incompatible \"\n+\t\t\t       \"types\", variant, decl);\n+\t  return true;\n+\t}\n+      if (fndecl_built_in_p (variant)\n+\t  && (strncmp (varname, \"__builtin_\", strlen (\"__builtin_\")) == 0\n+\t      || strncmp (varname, \"__sync_\", strlen (\"__sync_\")) == 0\n+\t      || strncmp (varname, \"__atomic_\", strlen (\"__atomic_\")) == 0))\n+\t{\n+\t  error_at (varid_loc, \"variant %qD is a built-in\", variant);\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  tree construct = c_omp_get_context_selector (ctx, \"construct\", NULL);\n+\t  c_omp_mark_declare_variant (match_loc, variant, construct);\n+\t  if (!omp_context_selector_matches (ctx))\n+\t    return true;\n+\t  TREE_PURPOSE (TREE_VALUE (attr)) = variant;\n+\t}\n+    }\n+  else if (!processing_template_decl)\n+    {\n+      error_at (varid_loc, \"could not find variant %qD declaration\", variant);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Helper function, finish up \"omp declare variant base\" attribute\n+   now that there is a DECL.  ATTR is the first \"omp declare variant base\"\n+   attribute.  */\n+\n+void\n+omp_declare_variant_finalize (tree decl, tree attr)\n+{\n+  size_t attr_len = strlen (\"omp declare variant base\");\n+  tree *list = &DECL_ATTRIBUTES (decl);\n+  bool remove_all = false;\n+  location_t match_loc = DECL_SOURCE_LOCATION (decl);\n+  if (TREE_CHAIN (TREE_VALUE (attr))\n+      && TREE_PURPOSE (TREE_CHAIN (TREE_VALUE (attr)))\n+      && EXPR_HAS_LOCATION (TREE_PURPOSE (TREE_CHAIN (TREE_VALUE (attr)))))\n+    match_loc = EXPR_LOCATION (TREE_PURPOSE (TREE_CHAIN (TREE_VALUE (attr))));\n+  if (DECL_CONSTRUCTOR_P (decl))\n+    {\n+      error_at (match_loc, \"%<declare variant%> on constructor %qD\", decl);\n+      remove_all = true;\n+    }\n+  else if (DECL_DESTRUCTOR_P (decl))\n+    {\n+      error_at (match_loc, \"%<declare variant%> on destructor %qD\", decl);\n+      remove_all = true;\n+    }\n+  else if (DECL_DEFAULTED_FN (decl))\n+    {\n+      error_at (match_loc, \"%<declare variant%> on defaulted %qD\", decl);\n+      remove_all = true;\n+    }\n+  else if (DECL_DELETED_FN (decl))\n+    {\n+      error_at (match_loc, \"%<declare variant%> on deleted %qD\", decl);\n+      remove_all = true;\n+    }\n+  else if (DECL_VIRTUAL_P (decl))\n+    {\n+      error_at (match_loc, \"%<declare variant%> on virtual %qD\", decl);\n+      remove_all = true;\n+    }\n+  /* This loop is like private_lookup_attribute, except that it works\n+     with tree * rather than tree, as we might want to remove the\n+     attributes that are diagnosed as errorneous.  */\n+  while (*list)\n+    {\n+      tree attr = get_attribute_name (*list);\n+      size_t ident_len = IDENTIFIER_LENGTH (attr);\n+      if (cmp_attribs (\"omp declare variant base\", attr_len,\n+\t\t       IDENTIFIER_POINTER (attr), ident_len))\n+\t{\n+\t  if (remove_all || omp_declare_variant_finalize_one (decl, *list))\n+\t    {\n+\t      *list = TREE_CHAIN (*list);\n+\t      continue;\n+\t    }\n+\t}\n+      list = &TREE_CHAIN (*list);\n+    }\n+}\n+\n /* Finish processing of a declaration;\n    install its line number and initial value.\n    If the length of an array type is not known before,\n@@ -7235,6 +7425,16 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t}\n     }\n \n+  if (flag_openmp\n+      && TREE_CODE (decl) == FUNCTION_DECL\n+      /* #pragma omp declare variant on methods handled in finish_struct\n+\t instead.  */\n+      && (!DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n+\t  || COMPLETE_TYPE_P (DECL_CONTEXT (decl))))\n+    if (tree attr = lookup_attribute (\"omp declare variant base\",\n+\t\t\t\t      DECL_ATTRIBUTES (decl)))\n+      omp_declare_variant_finalize (decl, attr);\n+\n   if (processing_template_decl)\n     {\n       bool type_dependent_p;\n@@ -16475,6 +16675,11 @@ finish_function (bool inline_p)\n   if (DECL_DECLARED_CONCEPT_P (fndecl))\n     check_function_concept (fndecl);\n \n+  if (flag_openmp)\n+    if (tree attr = lookup_attribute (\"omp declare variant base\",\n+\t\t\t\t      DECL_ATTRIBUTES (fndecl)))\n+      omp_declare_variant_finalize (fndecl, attr);\n+\n   /* Lambda closure members are implicitly constexpr if possible.  */\n   if (cxx_dialect >= cxx17\n       && LAMBDA_TYPE_P (CP_DECL_CONTEXT (fndecl)))"}, {"sha": "e29e99f418be40fc00677a6079bc6410ddda05fa", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -40666,25 +40666,53 @@ cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n       return attrs;\n     }\n \n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  bool template_p;\n+  cp_id_kind idk = CP_ID_KIND_NONE;\n+  cp_token *varid_token = cp_lexer_peek_token (parser->lexer);\n+  cp_expr varid\n+    = cp_parser_id_expression (parser, /*template_keyword_p=*/false,\n+\t\t\t       /*check_dependency_p=*/true,\n+\t\t\t       /*template_p=*/&template_p,\n+\t\t\t       /*declarator_p=*/false,\n+\t\t\t       /*optional_p=*/false);\n+  parens.require_close (parser);\n+\n   tree variant;\n-  tree name = cp_parser_id_expression (parser, /*template_p=*/false,\n-\t\t\t\t       /*check_dependency_p=*/true,\n-\t\t\t\t       /*template_p=*/NULL,\n-\t\t\t\t       /*declarator_p=*/false,\n-\t\t\t\t       /*optional_p=*/false);\n-  if (identifier_p (name))\n-    variant = cp_parser_lookup_name_simple (parser, name, token->location);\n+  if (TREE_CODE (varid) == TEMPLATE_ID_EXPR\n+      || TREE_CODE (varid) == TYPE_DECL\n+      || varid == error_mark_node)\n+    variant = varid;\n+  else if (varid_token->type == CPP_NAME && varid_token->error_reported)\n+    variant = NULL_TREE;\n   else\n-    variant = name;\n-  if (variant == error_mark_node)\n     {\n-      cp_parser_name_lookup_error (parser, name, variant, NLE_NULL,\n-\t\t\t\t   token->location);\n-      variant = error_mark_node;\n+      tree ambiguous_decls;\n+      variant = cp_parser_lookup_name (parser, varid, none_type,\n+\t\t\t\t       template_p, /*is_namespace=*/false,\n+\t\t\t\t       /*check_dependency=*/true,\n+\t\t\t\t       &ambiguous_decls,\n+\t\t\t\t       varid.get_location ());\n+      if (ambiguous_decls)\n+\tvariant = NULL_TREE;\n     }\n-\n-  parens.require_close (parser);\n+  if (variant == NULL_TREE)\n+    variant = error_mark_node;\n+  else if (TREE_CODE (variant) != SCOPE_REF)\n+    {\n+      const char *error_msg;\n+      variant\n+\t= finish_id_expression (varid, variant, parser->scope,\n+\t\t\t\t&idk, false, true,\n+\t\t\t\t&parser->non_integral_constant_expression_p,\n+\t\t\t\ttemplate_p, true, false, false, &error_msg,\n+\t\t\t\tvarid.get_location ());\n+      if (error_msg)\n+\tcp_parser_error (parser, error_msg);\n+    }\n+  location_t caret_loc = get_pure_location (varid.get_location ());\n+  location_t start_loc = get_start (varid_token->location);\n+  location_t finish_loc = get_finish (varid.get_location ());\n+  location_t varid_loc = make_location (caret_loc, start_loc, finish_loc);\n \n   const char *clause = \"\";\n   location_t match_loc = cp_lexer_peek_token (parser->lexer)->location;\n@@ -40707,8 +40735,14 @@ cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n   ctx = c_omp_check_context_selector (match_loc, ctx);\n   if (ctx != error_mark_node && variant != error_mark_node)\n     {\n+      tree match_loc_node = maybe_wrap_with_location (integer_zero_node,\n+\t\t\t\t\t\t      match_loc);\n+      tree loc_node = maybe_wrap_with_location (integer_zero_node, varid_loc);\n+      loc_node = tree_cons (match_loc_node,\n+\t\t\t    build_int_cst (integer_type_node, idk),\n+\t\t\t    build_tree_list (loc_node, integer_zero_node));\n       attrs = tree_cons (get_identifier (\"omp declare variant base\"),\n-\t\t\t build_tree_list (variant, ctx), attrs);\n+\t\t\t tree_cons (variant, ctx, loc_node), attrs);\n       if (processing_template_decl)\n \tATTR_IS_DEPENDENT (attrs) = 1;\n     }"}, {"sha": "ca4d3e2a48bad424b4981fbbf6a1a1d0d2df3540", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -43,7 +43,6 @@ static hashval_t list_hash_pieces (tree, tree, tree);\n static tree build_target_expr (tree, tree, tsubst_flags_t);\n static tree count_trees_r (tree *, int *, void *);\n static tree verify_stmt_tree_r (tree *, int *, void *);\n-static tree build_local_temp (tree);\n \n static tree handle_init_priority_attribute (tree *, tree, tree, int, bool *);\n static tree handle_abi_tag_attribute (tree *, tree, tree, int, bool *);\n@@ -525,7 +524,7 @@ build_target_expr (tree decl, tree value, tsubst_flags_t complain)\n /* Return an undeclared local temporary of type TYPE for use in building a\n    TARGET_EXPR.  */\n \n-static tree\n+tree\n build_local_temp (tree type)\n {\n   tree slot = build_decl (input_location,"}, {"sha": "9bee47b692e556cf841dd14f9d27750b38996ea3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -1,3 +1,16 @@\n+2019-10-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/declare-variant-2.c: Add a test with , before\n+\tmatch clause.\n+\t* c-c++-common/gomp/declare-variant-6.c: Expect diagnostics also from\n+\tC++ FE and adjust regexp so that it handles C++ pretty printing of\n+\tfunction names.\n+\t* g++.dg/gomp/declare-variant-1.C: New test.\n+\t* g++.dg/gomp/declare-variant-2.C: New test.\n+\t* g++.dg/gomp/declare-variant-3.C: New test.\n+\t* g++.dg/gomp/declare-variant-4.C: New test.\n+\t* g++.dg/gomp/declare-variant-5.C: New test.\n+\n 2019-10-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/conversion/ptrmem2.C: Adjust for error + inform."}, {"sha": "1a16a9904e3ada4eb14d4728e119a5007208ad93", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-2.c?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -149,3 +149,5 @@ void f72 (void);\n void f73 (void);\n #pragma omp declare variant (f1) match(construct={requires})\t/* { dg-error \"selector 'requires' not allowed for context selector set 'construct'\" } */\n void f74 (void);\n+#pragma omp declare variant (f1),match(construct={parallel})\t/* { dg-error \"expected 'match' before ','\" } */\n+void f75 (void);"}, {"sha": "9ccfd0f39acf6f61454a232135240e32d9ee2069", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-6.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-6.c?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -7,29 +7,29 @@ double f4 (int, long, float);\n double f5 (int, long, float);\n #pragma omp declare variant (f5) match (user={condition(0)})\n double f6 (int, long, float);\n-#pragma omp declare variant (f5) match (construct={parallel},user={condition(score(1):1)})\t/* { dg-error \"'f5' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f5) match (construct={parallel},user={condition(score(1):1)})\t/* { dg-error \"'\\[^'\\n\\r]*f5\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n double f7 (int, long, float);\n double f8 (int, long, float);\n #pragma omp declare variant (f8) match (user={condition(0)},construct={for})\n double f9 (int, long, float);\n-#pragma omp declare variant (f8) match (user={condition(1)})\t\t\t\t\t/* { dg-error \"'f8' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f8) match (user={condition(1)})\t\t\t\t\t/* { dg-error \"'\\[^'\\n\\r]*f8\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n double f10 (int, long, float);\n double f11 (int, long, float);\n #pragma omp declare variant (f11) match (construct={target,teams,parallel,for})\n double f12 (int, long, float);\n #pragma omp declare variant (f11) match (user={condition(score(1):1)},construct={target,teams,parallel,for})\n double f13 (int, long, float);\n-#pragma omp declare variant (f11) match (implementation={vendor(gnu)},construct={target,teams,parallel})\t/* { dg-error \"'f11' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f11) match (implementation={vendor(gnu)},construct={target,teams,parallel})\t/* { dg-error \"'\\[^'\\n\\r]*f11\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n double f14 (int, long, float);\n-#pragma omp declare variant (f11) match (device={kind(any)},construct={teams,parallel})\t\t/* { dg-error \"'f11' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f11) match (device={kind(any)},construct={teams,parallel})\t\t/* { dg-error \"'\\[^'\\n\\r]*f11\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n double f15 (int, long, float);\n double f16 (int, long, float);\n #pragma omp declare variant (f16) match (construct={teams,parallel})\n double f17 (int, long, float);\n-#pragma omp declare variant (f16) match(construct={teams,parallel,for})\t\t\t\t/* { dg-error \"'f16' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f16) match(construct={teams,parallel,for})\t\t\t\t/* { dg-error \"'\\[^'\\n\\r]*f16\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n double f18 (int, long, float);\n double f19 (int, long, float);\n #pragma omp declare variant (f19) match (construct={parallel})\n double f20 (int, long, float);\n-#pragma omp declare variant (f19) match (construct={for},implementation={vendor(gnu,llvm)})\t/* { dg-error \"'f19' used as a variant with incompatible 'constructor' selector sets\" \"\" { target c } } */\n+#pragma omp declare variant (f19) match (construct={for},implementation={vendor(gnu,llvm)})\t/* { dg-error \"'\\[^'\\n\\r]*f19\\[^'\\n\\r]*' used as a variant with incompatible 'constructor' selector sets\" } */\n double f21 (int, long, float);"}, {"sha": "ece80d35dd72b6ada6aeefd5ac53174dc9c5dd5b", "filename": "gcc/testsuite/g++.dg/gomp/declare-variant-1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-1.C?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -0,0 +1,28 @@\n+struct S\n+{\n+  void foo ();\n+  void bar (const S &x);\n+#if __cplusplus >= 201103L\n+  S &baz (const S &x);\n+  S &qux (S &&x);\n+#endif\n+  void quux (int x);\n+  #pragma omp declare variant (foo) match (user={condition(0)})\t// { dg-error \"'declare variant' on constructor\" }\n+  S ();\n+  #pragma omp declare variant (foo) match (user={condition(0)})\t// { dg-error \"'declare variant' on destructor\" }\n+  ~S ();\n+  #pragma omp declare variant (bar) match (user={condition(0)})\t// { dg-error \"'declare variant' on constructor\" }\n+  S (const S &x);\n+  #pragma omp declare variant (quux) match (user={condition(0)})\t// { dg-error \"'declare variant' on constructor\" }\n+  S (int x);\n+#if __cplusplus >= 201103L\n+  #pragma omp declare variant (baz) match (user={condition(0)})\t// { dg-error \"'declare variant' on defaulted\" \"\" { target c++11 } }\n+  S &operator= (const S &x) = default;\n+  #pragma omp declare variant (qux) match (user={condition(0)})\t// { dg-error \"'declare variant' on deleted\" \"\" { target c++11 } }\n+  S &operator= (S &&) = delete;\n+#endif\n+  int s;\n+};\n+void corge (int);\n+#pragma omp declare variant (corge) match (user={condition(0)})\n+void grault (int x);"}, {"sha": "c6ec8d2be4436172d477aa58f005491a2f6b3330", "filename": "gcc/testsuite/g++.dg/gomp/declare-variant-2.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-2.C?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -0,0 +1,45 @@\n+struct S { int a, b, c, d; };\n+void f1 (int);\n+void f1 (double);\n+template <typename T> void f2 (T);\n+void f3 (int);\n+#pragma omp declare variant (f1) match (user={condition(false)})\n+void f4 (int);\n+#pragma omp declare variant (::f1) match (user={condition(false)})\n+void f5 (const double);\n+#pragma omp declare variant (f2) match (user={condition(false)})\n+void f6 (int);\n+#pragma omp declare variant (f2) match (user={condition(false)})\n+void f6 (double);\n+#pragma omp declare variant (f2<long>) match (user={condition(false)})\n+void f6 (long);\n+#pragma omp declare variant (f3) match (user={condition(false)})\n+void f7 (int);\n+void f8 (int);\n+namespace N\n+{\n+  void f8 (int);\n+  #pragma omp declare variant (f3) match (user={condition(false)})\n+  void f9 (int);\n+  #pragma omp declare variant (f8) match (user={condition(false)})\n+  void f10 (int);\n+}\n+#pragma omp declare variant (f8) match (user={condition(false)})\n+void f11 (int);\n+void f12 (S, S &, int);\n+#pragma omp declare variant (f12) match (implementation={vendor(gnu)})\n+void f13 (const S, S &, const int);\n+// Try ADL\n+namespace M\n+{\n+  struct T { int a; };\n+  void f14 (T &, int);\n+}\n+#pragma omp declare variant (f14) match (implementation={vendor(gnu)})\n+void f15 (M::T &, int);\n+struct U\n+{\n+  void f16 (int, long);\n+  #pragma omp declare variant (f16) match (user={condition(false)})\n+  void f17 (int, long);\n+};"}, {"sha": "8044cef91f20b7ff2f9a361694d344af246e4281", "filename": "gcc/testsuite/g++.dg/gomp/declare-variant-3.C", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-3.C?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -0,0 +1,139 @@\n+// Test parsing of #pragma omp declare variant\n+// { dg-do compile }\n+\n+int fn0 (int);\n+int fn20 (int);\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+int a;\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+int fn1 (int a), fn2 (int a);\t// { dg-error \"not immediately followed by a single function declaration or definition\" }\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+int b, fn3 (int a);\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+int fn4 (int a), c;\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+extern \"C\"\t\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+{\n+  int fn5 (int a);\n+}\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)}) // { dg-error \"not immediately followed by function declaration or definition\" }\n+namespace N1\n+{\n+  int fn6 (int a);\n+}\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+struct A\n+{\t\t\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+  int fn7 (int a);\n+};\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+template <typename T>\n+struct B\n+{\t\t\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+  int fn8 (int a);\n+};\n+\n+struct C\n+{\n+#pragma omp declare variant (fn0) match (user={condition(0)}) // { dg-error \"not immediately followed by function declaration or definition\" }\n+  public:\t\t // { dg-error \"expected unqualified-id before\" }\n+    int fn9 (int a);\n+};\n+\n+int t;\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+#pragma omp declare variant (fn20) match (implementation={vendor(unknown)})\n+#pragma omp threadprivate(t)\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+int fn10 (int a);\n+\n+struct D\n+{\n+  int d;\n+  int fn11 (int a);\n+  #pragma omp declare variant (fn11) match (user={condition(sizeof (e) == sizeof (this->e))}) // { dg-error \"has no member named\" }\n+  template <int N>\t// { dg-error \"was not declared\" \"\" { target *-*-* } .-1 }\n+  int fn12 (int a);\n+  int e;\n+};\n+\n+#pragma omp declare variant (1 + 2) match (user={condition(0)}) // { dg-error \"before numeric constant\" }\n+int fn13 (int);\n+\n+#pragma omp declare variant (t) match (user={condition(0)})\t// { dg-error \"'t' cannot be used as a function\" }\n+int fn14 (int);\n+\n+long fn15 (char, short);\n+\n+#pragma omp declare variant (fn15) match (implementation={vendor(unknown)})      // { dg-error \"variant 'long int fn15\\\\\\(char, short int\\\\\\)' and base 'int fn16\\\\\\(int, long long int\\\\\\)' have incompatible types\" }\n+int fn16 (int, long long);\n+\n+#pragma omp declare variant (memcpy) match (implementation={vendor(llvm)})      // { dg-error \"'memcpy' was not declared in this scope\" }\n+void *fn17 (void *, const void *, __SIZE_TYPE__);\n+\n+#pragma omp declare variant (__builtin_memmove) match (implementation={vendor(gnu)})    // { dg-error \"variant '\\[^'\\n\\r]*' is a built-in\" }\n+void *fn18 (void *, const void *, __SIZE_TYPE__);\n+\n+struct E { int e; };\n+\n+void fn19 (E, int);\n+\n+#pragma omp declare variant (fn19)match(user={condition(0)})\t// { dg-error \"could not convert '0' from 'int' to 'E'\" }\n+void fn20 (int, E);\n+\n+struct F { operator int () const { return 42; } int f; };\n+void fn21 (int, F);\n+\n+#pragma omp declare variant ( fn21 ) match (user = { condition ( 1 - 1 ) } )\t// { dg-error \"variant 'void fn21\\\\\\(int, F\\\\\\)' and base 'void fn22\\\\\\(F, F\\\\\\)' have incompatible types\" }\n+void fn22 (F, F);\n+\n+#pragma omp declare variant (fn19) match (user={condition(0)})\t\t// { dg-error \"could not convert '<anonymous>' from 'F' to 'E'\" }\n+void fn23 (F, int);\n+\n+void fn24 (int);\n+struct U { int u; };\n+struct T\n+{\n+  void fn25 (int);\n+  int t;\n+};\n+struct S : public U, T\n+{\n+  #pragma omp declare variant (fn25) match (user={condition(true)})\t// { dg-error \"variant 'void T::fn25\\\\\\(int\\\\\\)' and base 'void S::fn26\\\\\\(int\\\\\\)' have incompatible types\" }\n+  void fn26 (int);\n+  #pragma omp declare variant (fn24) match (user={condition(true)})\t// { dg-error \"variant 'void fn24\\\\\\(int\\\\\\)' and base 'void S::fn27\\\\\\(int\\\\\\)' have incompatible types\" }\n+  void fn27 (int);\n+  struct s;\n+};\n+\n+void fn30 (int) throw ();\n+#pragma omp declare variant (fn30) match (user={condition(true)})\t// { dg-error \"variant 'void fn30\\\\\\(int\\\\\\)' and base 'void fn31\\\\\\(int\\\\\\)' have incompatible types\" \"\" { target c++17 } }\n+void fn31 (int);\n+\n+struct W\n+{\n+  int fn32 (int) const;\n+  #pragma omp declare variant (fn32) match (user={condition(true)})\t// { dg-error \"variant 'int W::fn32\\\\\\(int\\\\\\) const' and base 'int W::fn33\\\\\\(int\\\\\\)' have incompatible types\" }\n+  int fn33 (int);\n+  int fn34 (int) volatile;\n+  #pragma omp declare variant (fn34) match (user={condition(true)})\t// { dg-error \"variant 'int W::fn34\\\\\\(int\\\\\\) volatile' and base 'int W::fn35\\\\\\(int\\\\\\) const volatile' have incompatible types\" }\n+  int fn35 (int) const volatile;\t\t\t\t\t// { dg-error \"passing 'const volatile W' as 'this' argument discards qualifiers\" \"\" { target *-*-* } .-1 }\n+  int fn36 (int);\n+  #pragma omp declare variant (fn36) match (user={condition(true)})\t// { dg-error \"variant 'int W::fn36\\\\\\(int\\\\\\)' and base 'int W::fn37\\\\\\(int\\\\\\) volatile' have incompatible types\" }\n+  int fn37 (int) volatile;\t\t\t\t\t\t// { dg-error \"passing 'volatile W' as 'this' argument discards qualifiers\" \"\" { target *-*-* } .-1 }\n+  int fn38 (int) throw ();\n+  #pragma omp declare variant (fn38) match (user={condition(true)})\t// { dg-error \"variant 'int W::fn38\\\\\\(int\\\\\\)' and base 'int W::fn39\\\\\\(int\\\\\\)' have incompatible types\" \"\" { target c++17 } }\n+\n+  int fn39 (int);\n+  int fn40 (int);\n+  #pragma omp declare variant (fn40) match (user={condition(true)})\t// { dg-error \"variant 'int W::fn40\\\\\\(int\\\\\\)' and base 'int W::fn41\\\\\\(int\\\\\\)' have incompatible types\" \"\" { target c++17 } }\n+  int fn41 (int) throw ();\n+};"}, {"sha": "8a2e8181a0c474b14b9ad9e6600ce8b20a72082a", "filename": "gcc/testsuite/g++.dg/gomp/declare-variant-4.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-4.C?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -0,0 +1,45 @@\n+struct S { int a, b, c, d; };\n+void f1 (int) {}\n+void f1 (double) {}\n+template <typename T> void f2 (T) {}\n+void f3 (int) {}\n+#pragma omp declare variant (f1) match (user={condition(false)})\n+void f4 (int) {}\n+#pragma omp declare variant (::f1) match (user={condition(false)})\n+void f5 (const double) {}\n+#pragma omp declare variant (f2) match (user={condition(false)})\n+void f6 (int) {}\n+#pragma omp declare variant (f2) match (user={condition(false)})\n+void f6 (double) {}\n+#pragma omp declare variant (f2<long>) match (user={condition(false)})\n+void f6 (long) {}\n+#pragma omp declare variant (f3) match (user={condition(false)})\n+void f7 (int) {}\n+void f8 (int) {}\n+namespace N\n+{\n+  void f8 (int) {}\n+  #pragma omp declare variant (f3) match (user={condition(false)})\n+  void f9 (int) {}\n+  #pragma omp declare variant (f8) match (user={condition(false)})\n+  void f10 (int) {}\n+}\n+#pragma omp declare variant (f8) match (user={condition(false)})\n+void f11 (int) {}\n+void f12 (S, S &, int) {}\n+#pragma omp declare variant (f12) match (implementation={vendor(gnu)})\n+void f13 (const S, S &, const int) {}\n+// Try ADL\n+namespace M\n+{\n+  struct T { int a; };\n+  void f14 (T &, int) {}\n+}\n+#pragma omp declare variant (f14) match (implementation={vendor(gnu)})\n+void f15 (M::T &, int) {}\n+struct U\n+{\n+  void f16 (int, long) {}\n+  #pragma omp declare variant (f16) match (user={condition(false)})\n+  void f17 (int, long) {}\n+};"}, {"sha": "fa80c255c81460540c7c087eb0888d8561c563d3", "filename": "gcc/testsuite/g++.dg/gomp/declare-variant-5.C", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ceec0607f3235904c68d3ede1aaddb70eb06aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-variant-5.C?ref=42ceec0607f3235904c68d3ede1aaddb70eb06aa", "patch": "@@ -0,0 +1,131 @@\n+// Test parsing of #pragma omp declare variant\n+// { dg-do compile }\n+\n+int fn0 (int) { return 0; }\n+int fn20 (int) { return 0; }\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+extern \"C\"\t\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+{\n+  int fn5 (int a) { return 0; }\n+}\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)}) // { dg-error \"not immediately followed by function declaration or definition\" }\n+namespace N1\n+{\n+  int fn6 (int a) { return 0; }\n+}\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+struct A\n+{\t\t\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+  int fn7 (int a) { return 0; }\n+};\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+template <typename T>\n+struct B\n+{\t\t\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+  int fn8 (int a) { return 0; }\n+};\n+\n+struct C\n+{\n+#pragma omp declare variant (fn0) match (user={condition(0)}) // { dg-error \"not immediately followed by function declaration or definition\" }\n+  public:\t\t // { dg-error \"expected unqualified-id before\" }\n+    int fn9 (int a) { return 0; }\n+};\n+\n+int t;\n+\n+#pragma omp declare variant (fn0) match (user={condition(0)})\n+#pragma omp declare variant (fn20) match (implementation={vendor(unknown)})\n+#pragma omp threadprivate(t)\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+int fn10 (int a) { return 0; }\n+\n+struct D\n+{\n+  int d;\n+  int fn11 (int a) { return 0; }\n+  #pragma omp declare variant (fn11) match (user={condition(sizeof (e) == sizeof (this->e))}) // { dg-error \"has no member named\" }\n+  template <int N>\t// { dg-error \"was not declared\" \"\" { target *-*-* } .-1 }\n+  int fn12 (int a) { return 0; }\n+  int e;\n+};\n+\n+#pragma omp declare variant (1 + 2) match (user={condition(0)}) // { dg-error \"before numeric constant\" }\n+int fn13 (int) { return 0; }\n+\n+#pragma omp declare variant (t) match (user={condition(0)})\t// { dg-error \"'t' cannot be used as a function\" }\n+int fn14 (int) { return 0; }\n+\n+long fn15 (char, short) { return 0; }\n+\n+#pragma omp declare variant (fn15) match (implementation={vendor(unknown)})      // { dg-error \"variant 'long int fn15\\\\\\(char, short int\\\\\\)' and base 'int fn16\\\\\\(int, long long int\\\\\\)' have incompatible types\" }\n+int fn16 (int, long long) { return 0; }\n+\n+#pragma omp declare variant (memcpy) match (implementation={vendor(llvm)})      // { dg-error \"'memcpy' was not declared in this scope\" }\n+void *fn17 (void *, const void *, __SIZE_TYPE__) { return (void *) 0; }\n+\n+#pragma omp declare variant (__builtin_memmove) match (implementation={vendor(gnu)})    // { dg-error \"variant '\\[^'\\n\\r]*' is a built-in\" }\n+void *fn18 (void *, const void *, __SIZE_TYPE__) { return (void *) 0; }\n+\n+struct E { int e; };\n+\n+void fn19 (E, int) {}\n+\n+#pragma omp declare variant (fn19)match(user={condition(0)})\t// { dg-error \"could not convert '0' from 'int' to 'E'\" }\n+void fn20 (int, E) {}\n+\n+struct F { operator int () const { return 42; } int f; };\n+void fn21 (int, F) {}\n+\n+#pragma omp declare variant ( fn21 ) match (user = { condition ( 1 - 1 ) } )\t// { dg-error \"variant 'void fn21\\\\\\(int, F\\\\\\)' and base 'void fn22\\\\\\(F, F\\\\\\)' have incompatible types\" }\n+void fn22 (F, F) {}\n+\n+#pragma omp declare variant (fn19) match (user={condition(0)})\t\t// { dg-error \"could not convert '<anonymous>' from 'F' to 'E'\" }\n+void fn23 (F, int) {}\n+\n+void fn24 (int);\n+struct U { int u; };\n+struct T\n+{\n+  void fn25 (int) {}\n+  int t;\n+};\n+struct S : public U, T\n+{\n+  #pragma omp declare variant (fn25) match (user={condition(true)})\t// { dg-error \"variant 'void T::fn25\\\\\\(int\\\\\\)' and base 'void S::fn26\\\\\\(int\\\\\\)' have incompatible types\" }\n+  void fn26 (int) {}\n+  #pragma omp declare variant (fn24) match (user={condition(true)})\t// { dg-error \"variant 'void fn24\\\\\\(int\\\\\\)' and base 'void S::fn27\\\\\\(int\\\\\\)' have incompatible types\" }\n+  void fn27 (int) {}\n+  void fn28 (int);\n+  struct s;\n+};\n+#pragma omp declare variant (fn25) match (user={condition(true)})\t// { dg-error \"variant 'void T::fn25\\\\\\(int\\\\\\)' and base 'void S::fn28\\\\\\(int\\\\\\)' have incompatible types\" }\n+void S::fn28 (int)\n+{\n+}\n+\n+void fn30 (int) throw () {}\n+#pragma omp declare variant (fn30) match (user={condition(true)})\t// { dg-error \"variant 'void fn30\\\\\\(int\\\\\\)' and base 'void fn31\\\\\\(int\\\\\\)' have incompatible types\" \"\" { target c++17 } }\n+void fn31 (int) {}\n+\n+struct W\n+{\n+  int fn32 (int) const { return 0; }\n+  #pragma omp declare variant (fn32) match (user={condition(true)})\t// { dg-error \"variant 'int W::fn32\\\\\\(int\\\\\\) const' and base 'int W::fn33\\\\\\(int\\\\\\)' have incompatible types\" }\n+  int fn33 (int) { return 0; }\n+  int fn34 (int) volatile { return 0; }\n+  #pragma omp declare variant (fn34) match (user={condition(true)})\t// { dg-error \"variant 'int W::fn34\\\\\\(int\\\\\\) volatile' and base 'int W::fn35\\\\\\(int\\\\\\) const volatile' have incompatible types\" }\n+  int fn35 (int) const volatile { return 0; }\t\t\t\t// { dg-error \"passing 'const volatile W' as 'this' argument discards qualifiers\" \"\" { target *-*-* } .-1 }\n+  int fn36 (int) { return 0; }\n+  #pragma omp declare variant (fn36) match (user={condition(true)})\t// { dg-error \"variant 'int W::fn36\\\\\\(int\\\\\\)' and base 'int W::fn37\\\\\\(int\\\\\\) volatile' have incompatible types\" }\n+  int fn37 (int) volatile { return 0; }\t\t\t\t\t// { dg-error \"passing 'volatile W' as 'this' argument discards qualifiers\" \"\" { target *-*-* } .-1 }\n+  int fn38 (int) throw () { return 0; }\n+  #pragma omp declare variant (fn38) match (user={condition(true)})\t// { dg-error \"variant 'int W::fn38\\\\\\(int\\\\\\)' and base 'int W::fn39\\\\\\(int\\\\\\)' have incompatible types\" \"\" { target c++17 } }\n+  int fn39 (int) { return 0; }\n+  int fn40 (int) { return 0; }\n+  #pragma omp declare variant (fn40) match (user={condition(true)})\t// { dg-error \"variant 'int W::fn40\\\\\\(int\\\\\\)' and base 'int W::fn41\\\\\\(int\\\\\\)' have incompatible types\" \"\" { target c++17 } }\n+  int fn41 (int) throw () { return 0; }\n+};"}]}