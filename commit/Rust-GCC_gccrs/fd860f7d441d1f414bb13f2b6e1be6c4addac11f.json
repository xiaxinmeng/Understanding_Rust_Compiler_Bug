{"sha": "fd860f7d441d1f414bb13f2b6e1be6c4addac11f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ4NjBmN2Q0NDFkMWY0MTRiYjEzZjJiNmUxYmU2YzRhZGRhYzExZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-07-16T08:50:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-07-16T08:50:16Z"}, "message": "Simplify type-specifier parsing.\n\nPreviously, the tentative parses for optional type-specifier and to support\nclass template argument deduction were combined awkwardly.  This\nreorganization was motivated by the new concepts branch.\n\n\t* parser.c (cp_parser_simple_type_specifier): Separate tentative\n\tparses for optional type-spec and CTAD.\n\nFrom-SVN: r273514", "tree": {"sha": "879aac09f15f3495f2ee6bbbf0d639594b7a112f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/879aac09f15f3495f2ee6bbbf0d639594b7a112f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd860f7d441d1f414bb13f2b6e1be6c4addac11f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd860f7d441d1f414bb13f2b6e1be6c4addac11f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd860f7d441d1f414bb13f2b6e1be6c4addac11f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd860f7d441d1f414bb13f2b6e1be6c4addac11f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "19bd90282641da569f3da6c26eac3fd248296cb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19bd90282641da569f3da6c26eac3fd248296cb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19bd90282641da569f3da6c26eac3fd248296cb2"}], "stats": {"total": 60, "additions": 31, "deletions": 29}, "files": [{"sha": "ad7f4a3ae1f0edb2a2e04b35e93461cb640f9393", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd860f7d441d1f414bb13f2b6e1be6c4addac11f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd860f7d441d1f414bb13f2b6e1be6c4addac11f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fd860f7d441d1f414bb13f2b6e1be6c4addac11f", "patch": "@@ -1,5 +1,8 @@\n 2019-07-16  Jason Merrill  <jason@redhat.com>\n \n+\t* parser.c (cp_parser_simple_type_specifier): Separate tentative\n+\tparses for optional type-spec and CTAD.\n+\n \t* parser.c (cp_parser_nested_name_specifier_opt): If the token is\n \talready CPP_NESTED_NAME_SPECIFIER, leave it alone.\n "}, {"sha": "5e4b45391d5be44f22f78cb3a0f9e7dd70ee86a6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd860f7d441d1f414bb13f2b6e1be6c4addac11f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd860f7d441d1f414bb13f2b6e1be6c4addac11f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=fd860f7d441d1f414bb13f2b6e1be6c4addac11f", "patch": "@@ -17833,7 +17833,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \n       /* Don't gobble tokens or issue error messages if this is an\n \t optional type-specifier.  */\n-      if ((flags & CP_PARSER_FLAGS_OPTIONAL) || cxx_dialect >= cxx17)\n+      if (flags & CP_PARSER_FLAGS_OPTIONAL)\n \tcp_parser_parse_tentatively (parser);\n \n       token = cp_lexer_peek_token (parser->lexer);\n@@ -17873,37 +17873,26 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t      else\n \t\t{\n \t\t  cp_parser_error (parser, \"expected template-id for type\");\n-\t\t  type = NULL_TREE;\n+\t\t  type = error_mark_node;\n \t\t}\n \t    }\n \t}\n-      /* Otherwise, look for a type-name.  */\n-      else\n-\ttype = cp_parser_type_name (parser, (qualified_p && typename_p));\n \n-      /* Keep track of all name-lookups performed in class scopes.  */\n-      if (type\n-\t  && !global_p\n-\t  && !qualified_p\n-\t  && TREE_CODE (type) == TYPE_DECL\n-\t  && identifier_p (DECL_NAME (type)))\n-\tmaybe_note_name_used_in_class (DECL_NAME (type), type);\n-      /* If it didn't work out, we don't have a TYPE.  */\n-      if (((flags & CP_PARSER_FLAGS_OPTIONAL) || cxx_dialect >= cxx17)\n-\t  && !cp_parser_parse_definitely (parser))\n-\ttype = NULL_TREE;\n-      if (!type && cxx_dialect >= cxx17)\n+      /* Otherwise, look for a type-name.  */\n+      if (!type)\n \t{\n-\t  if (flags & CP_PARSER_FLAGS_OPTIONAL)\n+\t  if (cxx_dialect >= cxx17)\n \t    cp_parser_parse_tentatively (parser);\n \n-\t  cp_parser_global_scope_opt (parser,\n-\t\t\t\t      /*current_scope_valid_p=*/false);\n-\t  cp_parser_nested_name_specifier_opt (parser,\n-\t\t\t\t\t       /*typename_keyword_p=*/false,\n-\t\t\t\t\t       /*check_dependency_p=*/true,\n-\t\t\t\t\t       /*type_p=*/false,\n-\t\t\t\t\t       /*is_declaration=*/false);\n+\t  type = cp_parser_type_name (parser, (qualified_p && typename_p));\n+\n+\t  if (cxx_dialect >= cxx17 && !cp_parser_parse_definitely (parser))\n+\t    type = NULL_TREE;\n+\t}\n+\n+      if (!type && cxx_dialect >= cxx17)\n+\t{\n+\t  /* Try class template argument deduction.  */\n \t  tree name = cp_parser_identifier (parser);\n \t  if (name && TREE_CODE (name) == IDENTIFIER_NODE\n \t      && parser->scope != error_mark_node)\n@@ -17929,11 +17918,21 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t    }\n \t  else\n \t    type = error_mark_node;\n-\n-\t  if ((flags & CP_PARSER_FLAGS_OPTIONAL)\n-\t      && !cp_parser_parse_definitely (parser))\n-\t    type = NULL_TREE;\n \t}\n+\n+      /* If it didn't work out, we don't have a TYPE.  */\n+      if ((flags & CP_PARSER_FLAGS_OPTIONAL)\n+\t  && !cp_parser_parse_definitely (parser))\n+\ttype = NULL_TREE;\n+\n+      /* Keep track of all name-lookups performed in class scopes.  */\n+      if (type\n+\t  && !global_p\n+\t  && !qualified_p\n+\t  && TREE_CODE (type) == TYPE_DECL\n+\t  && identifier_p (DECL_NAME (type)))\n+\tmaybe_note_name_used_in_class (DECL_NAME (type), type);\n+\n       if (type && decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n \t\t\t\t      token,"}]}