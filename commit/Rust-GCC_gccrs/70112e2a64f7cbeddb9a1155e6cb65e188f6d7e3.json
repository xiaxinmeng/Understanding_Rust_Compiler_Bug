{"sha": "70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAxMTJlMmE2NGY3Y2JlZGRiOWExMTU1ZTZjYjY1ZTE4OGY2ZDdlMw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-03-12T13:59:10Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-03-12T13:59:10Z"}, "message": "re PR fortran/70031 (Error in recursive module subroutine declaration if declared as \"module recursive\")\n\n2016-03-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/70031\n\t* decl.c (gfc_match_prefix): Treat the 'module' prefix in the\n\tsame way as the others, rather than fixing it to come last.\n\t(gfc_match_function_decl, gfc_match_subroutine): After errors\n\tin 'copy_prefix', emit them immediately in the case of module\n\tprocedures to prevent a later ICE.\n\n\tPR fortran/69524\n\t* decl.c (gfc_match_submod_proc): Permit 'module procedure'\n\tdeclarations within the contains section of modules as well as\n\tsubmodules.\n\t* resolve.c (resolve_fl_procedure): Likewise.\n\t*trans-decl.c (build_function_decl): Change the gcc_assert to\n\tallow all forms of module procedure declarations within module\n\tcontains sections.\n\n2016-03-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/70031\n\t* gfortran.dg/submodule_14.f08: New test\n\n\tPR fortran/69524\n\t* gfortran.dg/submodule_15.f08: New test\n\nFrom-SVN: r234161", "tree": {"sha": "2dd68bc74cb9cafbd9ed771b20bddc58b2da0a21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dd68bc74cb9cafbd9ed771b20bddc58b2da0a21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/comments", "author": null, "committer": null, "parents": [{"sha": "0529235de5d3a6015a1031f2761d1580cc8c20fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0529235de5d3a6015a1031f2761d1580cc8c20fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0529235de5d3a6015a1031f2761d1580cc8c20fa"}], "stats": {"total": 244, "additions": 197, "deletions": 47}, "files": [{"sha": "cf0cb6d09c0e3eb30af95592d85bf38e90818f9d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "patch": "@@ -1,3 +1,21 @@\n+2016-03-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/70031\n+\t* decl.c (gfc_match_prefix): Treat the 'module' prefix in the\n+\tsame way as the others, rather than fixing it to come last.\n+\t(gfc_match_function_decl, gfc_match_subroutine): After errors\n+\tin 'copy_prefix', emit them immediately in the case of module\n+\tprocedures to prevent a later ICE.\n+\n+\tPR fortran/69524\n+\t* decl.c (gfc_match_submod_proc): Permit 'module procedure'\n+\tdeclarations within the contains section of modules as well as\n+\tsubmodules.\n+\t* resolve.c (resolve_fl_procedure): Likewise.\n+\t*trans-decl.c (build_function_decl): Change the gcc_assert to\n+\tallow all forms of module procedure declarations within module\n+\tcontains sections.\n+\n 2016-02-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/68147"}, {"sha": "80ec39cb86b4869d1ef9da27306c0fd317544df8", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 57, "deletions": 45, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "patch": "@@ -764,7 +764,7 @@ char_len_param_value (gfc_expr **expr, bool *deferred)\n       gfc_reduce_init_expr (e);\n \n       if ((e->ref && e->ref->type == REF_ARRAY\n-\t   && e->ref->u.ar.type != AR_ELEMENT) \n+\t   && e->ref->u.ar.type != AR_ELEMENT)\n \t  || (!e->ref && e->expr_type == EXPR_ARRAY))\n \t{\n \t  gfc_free_expr (e);\n@@ -1183,8 +1183,8 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t  else if (sym->attr.optional == 1\n \t\t   && !gfc_notify_std (GFC_STD_F2008_TS, \"Variable %qs \"\n \t\t\t\t       \"at %L with OPTIONAL attribute in \"\n-\t\t\t\t       \"procedure %qs which is BIND(C)\", \n-\t\t\t\t       sym->name, &(sym->declared_at), \n+\t\t\t\t       \"procedure %qs which is BIND(C)\",\n+\t\t\t\t       sym->name, &(sym->declared_at),\n \t\t\t\t       sym->ns->proc_name->name))\n \t    retval = false;\n \n@@ -1195,8 +1195,8 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t      && !gfc_notify_std (GFC_STD_F2008_TS, \"Assumed-shape array %qs \"\n \t\t\t\t  \"at %L as dummy argument to the BIND(C) \"\n \t\t\t\t  \"procedure %qs at %L\", sym->name,\n-\t\t\t\t  &(sym->declared_at), \n-\t\t\t\t  sym->ns->proc_name->name, \n+\t\t\t\t  &(sym->declared_at),\n+\t\t\t\t  sym->ns->proc_name->name,\n \t\t\t\t  &(sym->ns->proc_name->declared_at)))\n \t    retval = false;\n \t}\n@@ -1286,7 +1286,7 @@ build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n         {\n \t  /* Set the binding label and verify that if a NAME= was specified\n \t     then only one identifier was in the entity-decl-list.  */\n-\t  if (!set_binding_label (&sym->binding_label, sym->name, \n+\t  if (!set_binding_label (&sym->binding_label, sym->name,\n \t\t\t\t  num_idents_on_line))\n             return false;\n         }\n@@ -1505,7 +1505,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t\t      else if (init->value.constructor)\n \t\t\t{\n \t\t\t  gfc_constructor *c;\n-\t                  c = gfc_constructor_first (init->value.constructor); \t \n+\t                  c = gfc_constructor_first (init->value.constructor);\n \t                  clen = c->expr->value.character.length;\n \t\t\t}\n \t\t      else\n@@ -1570,7 +1570,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \n \t      lower = sym->as->lower[dim];\n \n-\t      /* If the lower bound is an array element from another \n+\t      /* If the lower bound is an array element from another\n \t\t parameterized array, then it is marked with EXPR_VARIABLE and\n \t\t is an initialization expression.  Try to reduce it.  */\n \t      if (lower->expr_type == EXPR_VARIABLE)\n@@ -1998,7 +1998,7 @@ variable_decl (int elem)\n \tas->type = AS_IMPLIED_SHAPE;\n \n       if (as->type == AS_IMPLIED_SHAPE\n-\t  && !gfc_notify_std (GFC_STD_F2008, \"Implied-shape array at %L\", \n+\t  && !gfc_notify_std (GFC_STD_F2008, \"Implied-shape array at %L\",\n \t\t\t      &var_locus))\n \t{\n \t  m = MATCH_ERROR;\n@@ -2314,8 +2314,8 @@ gfc_match_old_kind_spec (gfc_typespec *ts)\n       return MATCH_ERROR;\n     }\n \n-  if (!gfc_notify_std (GFC_STD_GNU, \n-\t\t       \"Nonstandard type declaration %s*%d at %C\", \n+  if (!gfc_notify_std (GFC_STD_GNU,\n+\t\t       \"Nonstandard type declaration %s*%d at %C\",\n \t\t       gfc_basic_typename(ts->type), original_kind))\n     return MATCH_ERROR;\n \n@@ -2918,7 +2918,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t      /* This is essential to force the construction of\n \t\t unlimited polymorphic component class containers.  */\n \t      upe->attr.zero_comp = 1;\n-\t      if (!gfc_add_flavor (&upe->attr, FL_DERIVED, NULL, \n+\t      if (!gfc_add_flavor (&upe->attr, FL_DERIVED, NULL,\n \t\t\t\t   &gfc_current_locus))\n \t  return MATCH_ERROR;\n \t}\n@@ -3938,7 +3938,7 @@ match_attr_spec (void)\n \t      && gfc_state_stack->previous->state == COMP_MODULE)\n \t    {\n \t      if (!gfc_notify_std (GFC_STD_F2003, \"Attribute %s \"\n-\t\t\t\t   \"at %L in a TYPE definition\", attr, \n+\t\t\t\t   \"at %L in a TYPE definition\", attr,\n \t\t\t\t   &seen_at[d]))\n \t\t{\n \t\t  m = MATCH_ERROR;\n@@ -4345,7 +4345,7 @@ set_verify_bind_c_com_block (gfc_common_head *com_block, int num_idents)\n   bool retval = true;\n \n   /* destLabel, common name, typespec (which may have binding label).  */\n-  if (!set_binding_label (&com_block->binding_label, com_block->name, \n+  if (!set_binding_label (&com_block->binding_label, com_block->name,\n \t\t\t  num_idents))\n     return false;\n \n@@ -4606,6 +4606,19 @@ gfc_match_prefix (gfc_typespec *ts)\n     {\n       found_prefix = false;\n \n+      /* MODULE is a prefix like PURE, ELEMENTAL, etc., having a\n+\t corresponding attribute seems natural and distinguishes these\n+\t procedures from procedure types of PROC_MODULE, which these are\n+\t as well.  */\n+      if (gfc_match (\"module% \") == MATCH_YES)\n+\t{\n+\t  if (!gfc_notify_std (GFC_STD_F2008, \"MODULE prefix at %C\"))\n+\t    goto error;\n+\n+\t  current_attr.module_procedure = 1;\n+\t  found_prefix = true;\n+\t}\n+\n       if (!seen_type && ts != NULL\n \t  && gfc_match_decl_type_spec (ts, 0) == MATCH_YES\n \t  && gfc_match_space () == MATCH_YES)\n@@ -4670,21 +4683,6 @@ gfc_match_prefix (gfc_typespec *ts)\n   /* At this point, the next item is not a prefix.  */\n   gcc_assert (gfc_matching_prefix);\n \n-  /* MODULE should be the last prefix before FUNCTION or SUBROUTINE.\n-     Since this is a prefix like PURE, ELEMENTAL, etc., having a\n-     corresponding attribute seems natural and distinguishes these\n-     procedures from procedure types of PROC_MODULE, which these are\n-     as well.  */\n-  if ((gfc_current_state () == COMP_INTERFACE\n-       || gfc_current_state () == COMP_CONTAINS)\n-      && gfc_match (\"module% \") == MATCH_YES)\n-    {\n-      if (!gfc_notify_std (GFC_STD_F2008, \"MODULE prefix at %C\"))\n-\tgoto error;\n-      else\n-\tcurrent_attr.module_procedure = 1;\n-    }\n-\n   gfc_matching_prefix = false;\n   return MATCH_YES;\n \n@@ -5142,7 +5140,7 @@ match_procedure_interface (gfc_symbol **proc_if)\n \n       if ((*proc_if)->attr.flavor == FL_UNKNOWN\n \t  && (*proc_if)->ts.type == BT_UNKNOWN\n-\t  && !gfc_add_flavor (&(*proc_if)->attr, FL_PROCEDURE, \n+\t  && !gfc_add_flavor (&(*proc_if)->attr, FL_PROCEDURE,\n \t\t\t      (*proc_if)->name, NULL))\n \treturn MATCH_ERROR;\n     }\n@@ -5639,10 +5637,17 @@ gfc_match_function_decl (void)\n       if (!gfc_add_function (&sym->attr, sym->name, NULL))\n \tgoto cleanup;\n \n-      if (!gfc_missing_attr (&sym->attr, NULL)\n-\t  || !copy_prefix (&sym->attr, &sym->declared_at))\n+      if (!gfc_missing_attr (&sym->attr, NULL))\n \tgoto cleanup;\n \n+      if (!copy_prefix (&sym->attr, &sym->declared_at))\n+\t{\n+\t  if(!sym->attr.module_procedure)\n+\tgoto cleanup;\n+\t  else\n+\t    gfc_error_check ();\n+\t}\n+\n       /* Delay matching the function characteristics until after the\n \t specification block by signalling kind=-1.  */\n       sym->declared_at = old_loc;\n@@ -5666,6 +5671,7 @@ gfc_match_function_decl (void)\n \t  sym->result = result;\n \t}\n \n+\n       /* Warn if this procedure has the same name as an intrinsic.  */\n       do_warn_intrinsic_shadow (sym, true);\n \n@@ -5890,7 +5896,7 @@ gfc_match_entry (void)\n \t      gfc_error (\"Missing required parentheses before BIND(C) at %C\");\n \t      return MATCH_ERROR;\n \t    }\n-\t    if (!gfc_add_is_bind_c (&(entry->attr), entry->name, \n+\t    if (!gfc_add_is_bind_c (&(entry->attr), entry->name,\n \t\t\t\t    &(entry->declared_at), 1))\n \t      return MATCH_ERROR;\n \t}\n@@ -6096,7 +6102,7 @@ gfc_match_subroutine (void)\n           gfc_error (\"Missing required parentheses before BIND(C) at %C\");\n           return MATCH_ERROR;\n         }\n-      if (!gfc_add_is_bind_c (&(sym->attr), sym->name, \n+      if (!gfc_add_is_bind_c (&(sym->attr), sym->name,\n \t\t\t      &(sym->declared_at), 1))\n         return MATCH_ERROR;\n     }\n@@ -6108,7 +6114,12 @@ gfc_match_subroutine (void)\n     }\n \n   if (!copy_prefix (&sym->attr, &sym->declared_at))\n-    return MATCH_ERROR;\n+    {\n+      if(!sym->attr.module_procedure)\n+\treturn MATCH_ERROR;\n+      else\n+\tgfc_error_check ();\n+    }\n \n   /* Warn if it has the same name as an intrinsic.  */\n   do_warn_intrinsic_shadow (sym, false);\n@@ -6516,7 +6527,7 @@ gfc_match_end (gfc_statement *st)\n       if (!eos_ok && (*st == ST_END_SUBROUTINE || *st == ST_END_FUNCTION))\n \t{\n \t  if (!gfc_notify_std (GFC_STD_F2008, \"END statement \"\n-\t\t\t       \"instead of %s statement at %L\", \n+\t\t\t       \"instead of %s statement at %L\",\n \t\t\t       abreviated_modproc_decl ? \"END PROCEDURE\"\n \t\t\t       : gfc_ascii_statement(*st), &old_loc))\n \t    goto cleanup;\n@@ -7148,16 +7159,16 @@ access_attr_decl (gfc_statement st)\n \t  if (gfc_get_symbol (name, NULL, &sym))\n \t    goto done;\n \n-\t  if (!gfc_add_access (&sym->attr, \n-\t\t\t       (st == ST_PUBLIC) \n-\t\t\t       ? ACCESS_PUBLIC : ACCESS_PRIVATE, \n+\t  if (!gfc_add_access (&sym->attr,\n+\t\t\t       (st == ST_PUBLIC)\n+\t\t\t       ? ACCESS_PUBLIC : ACCESS_PRIVATE,\n \t\t\t       sym->name, NULL))\n \t    return MATCH_ERROR;\n \n \t  if (sym->attr.generic && (dt_sym = gfc_find_dt_in_generic (sym))\n-\t      && !gfc_add_access (&dt_sym->attr, \n-\t\t\t\t  (st == ST_PUBLIC) \n-\t\t\t\t  ? ACCESS_PUBLIC : ACCESS_PRIVATE, \n+\t      && !gfc_add_access (&dt_sym->attr,\n+\t\t\t\t  (st == ST_PUBLIC)\n+\t\t\t\t  ? ACCESS_PUBLIC : ACCESS_PRIVATE,\n \t\t\t\t  sym->name, NULL))\n \t    return MATCH_ERROR;\n \n@@ -7481,7 +7492,7 @@ gfc_match_save (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (!gfc_add_save (&sym->attr, SAVE_EXPLICIT, sym->name, \n+\t  if (!gfc_add_save (&sym->attr, SAVE_EXPLICIT, sym->name,\n \t\t\t     &gfc_current_locus))\n \t    return MATCH_ERROR;\n \t  goto next_item;\n@@ -7697,7 +7708,8 @@ gfc_match_submod_proc (void)\n \n   if (gfc_current_state () != COMP_CONTAINS\n       || !(gfc_state_stack->previous\n-\t   && gfc_state_stack->previous->state == COMP_SUBMODULE))\n+\t   && (gfc_state_stack->previous->state == COMP_SUBMODULE\n+\t       || gfc_state_stack->previous->state == COMP_MODULE)))\n     return MATCH_NO;\n \n   m = gfc_match (\" module% procedure% %n\", name);\n@@ -8127,7 +8139,7 @@ gfc_match_derived_decl (void)\n     return MATCH_ERROR;\n   else if (sym->attr.access == ACCESS_UNKNOWN\n \t   && gensym->attr.access != ACCESS_UNKNOWN\n-\t   && !gfc_add_access (&sym->attr, gensym->attr.access, \n+\t   && !gfc_add_access (&sym->attr, gensym->attr.access,\n \t\t\t       sym->name, NULL))\n     return MATCH_ERROR;\n "}, {"sha": "55ab2ecfcebec3ac8a1ce44b387df56cd1980047", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "patch": "@@ -11905,7 +11905,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t\t     \"in %qs at %L\", sym->name, &sym->declared_at);\n \t  return false;\n \t}\n-      if (sym->attr.external && sym->attr.function\n+      if (sym->attr.external && sym->attr.function && !sym->attr.module_procedure\n \t  && ((sym->attr.if_source == IFSRC_DECL && !sym->attr.procedure)\n \t      || sym->attr.contained))\n \t{"}, {"sha": "4bd7dc4e85313b9d08eef62f2b1173b72692c0c2", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "patch": "@@ -2062,7 +2062,12 @@ build_function_decl (gfc_symbol * sym, bool global)\n   tree result_decl;\n   gfc_formal_arglist *f;\n \n-  gcc_assert (!sym->attr.external);\n+  bool module_procedure = sym->attr.module_procedure\n+\t\t\t  && sym->ns\n+\t\t\t  && sym->ns->proc_name\n+\t\t\t  && sym->ns->proc_name->attr.flavor == FL_MODULE;\n+\n+  gcc_assert (!sym->attr.external || module_procedure);\n \n   if (sym->backend_decl)\n     return;"}, {"sha": "dd470c3a1b8c71ae49c0864925705b984d1b7188", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "patch": "@@ -1,3 +1,11 @@\n+2016-03-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/70031\n+\t* gfortran.dg/submodule_14.f08: New test\n+\n+\tPR fortran/69524\n+\t* gfortran.dg/submodule_15.f08: New test\n+\n 2016-03-12  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c++/70106"}, {"sha": "0d0806d686db4c015ecb44fe4bef36be391ee3ff", "filename": "gcc/testsuite/gfortran.dg/submodule_14.f08", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_14.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_14.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_14.f08?ref=70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do compile }\n+!\n+! Check the fix for PR70031, where the 'module' prefix had to preceed\n+! 'function/subroutine' in the interface (or in the CONTAINS section.\n+!\n+! As reported by \"Bulova\" on\n+! https://groups.google.com/forum/#!topic/comp.lang.fortran/hE8LkVMhghQ\n+!\n+module test\n+  Interface\n+    Module Recursive Subroutine sub1 (x)\n+      Integer, Intent (InOut) :: x\n+    End Subroutine sub1\n+    module recursive function fcn1 (x) result(res)\n+      integer, intent (inout) :: x\n+      integer :: res\n+    end function\n+  End Interface\n+end module test\n+\n+submodule(test) testson\n+  integer :: n = 10\n+contains\n+  Module Procedure sub1\n+    If (x < n) Then\n+        x = x + 1\n+        Call sub1 (x)\n+    End If\n+  End Procedure sub1\n+  module function fcn1 (x) result(res)\n+    integer, intent (inout) :: x\n+    integer :: res\n+    res = x - 1\n+    if (x > 0) then\n+      x = fcn1 (res)\n+    else\n+      res = x\n+    end if\n+  end function\n+end submodule testson\n+\n+  use test\n+  integer :: x = 5\n+  call sub1(x)\n+  if (x .ne. 10) call abort\n+  x = 10\n+  if (fcn1 (x) .ne. 0) call abort\n+end\n+"}, {"sha": "499bc66d5ac4cc84e90255cdf7ee1a2a297904c2", "filename": "gcc/testsuite/gfortran.dg/submodule_15.f08", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_15.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_15.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_15.f08?ref=70112e2a64f7cbeddb9a1155e6cb65e188f6d7e3", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+!\n+! Check the fix for PR69524, where module procedures were not permitted\n+! in a module CONTAINS section.\n+!\n+! Reorted by Kirill Yukhin  <kyukhin@gcc.gnu.org>\n+!\n+module A\n+  implicit none\n+  interface\n+     module subroutine A1(i)\n+       integer, intent(inout) :: i\n+     end subroutine A1\n+     module subroutine A2(i)\n+       integer, intent(inout) :: i\n+     end subroutine A2\n+     integer module function A3(i)\n+       integer, intent(inout) :: i\n+     end function A3\n+     module subroutine B1(i)\n+       integer, intent(inout) :: i\n+     end subroutine B1\n+  end interface\n+  integer :: incr         ! Make sure that everybody can access a module variable\n+contains\n+  module subroutine A1(i) ! Full declaration\n+    integer, intent(inout) :: i\n+    call b1 (i)           ! Call the submodule procedure\n+    incr = incr + 1\n+  end subroutine A1\n+\n+  module PROCEDURE A2     ! Abreviated declaration\n+    call b1 (i)           ! Call the submodule procedure\n+    incr = incr + 1\n+  end procedure A2\n+\n+  module PROCEDURE A3     ! Abreviated declaration\n+    call a1 (i)           ! Call the module procedure in the module\n+    call a2 (i)           !            ditto\n+    call b1 (i)           ! Call the submodule procedure\n+    incr = incr + 1\n+    a3 = i + incr\n+  end procedure A3\n+end module A\n+\n+submodule (A) a_son\n+  implicit none\n+contains\n+  module procedure b1\n+    i = i + incr\n+  end procedure\n+end submodule\n+\n+  use A\n+  integer :: i = 1\n+  incr = 1\n+  if (a3(i) .ne. 11) call abort\n+end"}]}