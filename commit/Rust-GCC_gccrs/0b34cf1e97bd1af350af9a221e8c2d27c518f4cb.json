{"sha": "0b34cf1e97bd1af350af9a221e8c2d27c518f4cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIzNGNmMWU5N2JkMWFmMzUwYWY5YTIyMWU4YzJkMjdjNTE4ZjRjYg==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@redhat.com", "date": "2000-11-26T19:12:18Z"}, "committer": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "2000-11-26T19:12:18Z"}, "message": "dwarf2out.c (output_file_names): New function.\n\n        * dwarf2out.c (output_file_names): New function.  Compute minimal\n        combination of directory and file name table and emit them.\n        (output_line_info): Remove code to emit directory and file name\n        table and call output_file_names instead.\n        (file_info_cmp): Helper function to sort directory names.\n\nFrom-SVN: r37762", "tree": {"sha": "186929e96d17ec6ec621cbc75226997e0d7ade48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/186929e96d17ec6ec621cbc75226997e0d7ade48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b34cf1e97bd1af350af9a221e8c2d27c518f4cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b34cf1e97bd1af350af9a221e8c2d27c518f4cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b34cf1e97bd1af350af9a221e8c2d27c518f4cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b34cf1e97bd1af350af9a221e8c2d27c518f4cb/comments", "author": null, "committer": null, "parents": [{"sha": "bdb05a7b49ee8569b9efa1b0e0401b3026e1034e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb05a7b49ee8569b9efa1b0e0401b3026e1034e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb05a7b49ee8569b9efa1b0e0401b3026e1034e"}], "stats": {"total": 385, "additions": 331, "deletions": 54}, "files": [{"sha": "ea766663de8f3a1baa4a6a3d52cea0ba21034475", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b34cf1e97bd1af350af9a221e8c2d27c518f4cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b34cf1e97bd1af350af9a221e8c2d27c518f4cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b34cf1e97bd1af350af9a221e8c2d27c518f4cb", "patch": "@@ -1,3 +1,11 @@\n+2000-11-26  Ulrich Drepper  <drepper@redhat.com>\n+\n+\t* dwarf2out.c (output_file_names): New function.  Compute minimal\n+\tcombination of directory and file name table and emit them.\n+\t(output_line_info): Remove code to emit directory and file name\n+\ttable and call output_file_names instead.\n+\t(file_info_cmp): Helper function to sort directory names.\n+\n 2000-11-26  Neil Booth  <neilb@earthling.net>\n \n         * cpplib.h (struct cpp_reader): Remove lang_asm."}, {"sha": "cb4f6f7764001a3c7e06c7e5029b1f26e10c5b91", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 323, "deletions": 54, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b34cf1e97bd1af350af9a221e8c2d27c518f4cb/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b34cf1e97bd1af350af9a221e8c2d27c518f4cb/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0b34cf1e97bd1af350af9a221e8c2d27c518f4cb", "patch": "@@ -529,10 +529,10 @@ static void def_cfa_1\t\t \tPARAMS ((const char *, dw_cfa_location *));\n /* This is similar to the default ASM_OUTPUT_ASCII, except that no trailing\n    newline is produced.  When flag_debug_asm is asserted, we add commentary\n    at the end of the line, so we must avoid output of a newline here.  */\n-#ifndef ASM_OUTPUT_DWARF_STRING\n-#define ASM_OUTPUT_DWARF_STRING(FILE,P) \\\n+#ifndef ASM_OUTPUT_DWARF_NSTRING\n+#define ASM_OUTPUT_DWARF_NSTRING(FILE,P,SLEN) \\\n   do {\t\t\t\t\t\t\t\t\t      \\\n-    register int slen = strlen(P);                                            \\\n+    register int slen = (SLEN);                                               \\\n     register const char *p = (P);  \t                                      \\\n     register int i;\t\t\t\t\t                      \\\n     fprintf (FILE, \"\\t.ascii \\\"\");\t\t\t\t              \\\n@@ -552,6 +552,8 @@ static void def_cfa_1\t\t \tPARAMS ((const char *, dw_cfa_location *));\n   }\t\t\t\t\t\t\t\t\t      \\\n   while (0)\n #endif\n+#define ASM_OUTPUT_DWARF_STRING(FILE,P) \\\n+  ASM_OUTPUT_DWARF_NSTRING (FILE, P, strlen (P))\n \n /* The DWARF 2 CFA column which tracks the return address.  Normally this\n    is the column for PC, or the first column after all of the hard\n@@ -1207,7 +1209,7 @@ dwarf2out_stack_adjust (insn)\n     }\n   else\n     return;\n-  \n+\n   if (offset == 0)\n     return;\n \n@@ -3440,6 +3442,7 @@ static void output_pubnames\t\tPARAMS ((void));\n static void add_arange\t\t\tPARAMS ((tree, dw_die_ref));\n static void output_aranges\t\tPARAMS ((void));\n static void output_line_info\t\tPARAMS ((void));\n+static void output_file_names           PARAMS ((void));\n static dw_die_ref base_type_die\t\tPARAMS ((tree));\n static tree root_type\t\t\tPARAMS ((tree));\n static int is_base_type\t\t\tPARAMS ((tree));\n@@ -4645,7 +4648,7 @@ free_AT (a)\n     case dw_val_class_float:\n       free (a->dw_attr_val.v.val_float.array);\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -5392,7 +5395,7 @@ break_out_includes (die)\n \n #if 0\n   /* We can only use this in debugging, since the frontend doesn't check\n-     to make sure that we leave every include file we enter.  */     \n+     to make sure that we leave every include file we enter.  */\n   if (unit != NULL)\n     abort ();\n #endif\n@@ -6393,6 +6396,314 @@ output_aranges ()\n   fputc ('\\n', asm_out_file);\n }\n \n+\n+/* Data structure containing information about input files.  */\n+struct file_info\n+{\n+  char *path;\t\t/* Complete file name.  */\n+  char *fname;\t\t/* File name part.  */\n+  int length;\t\t/* Length of entire string.  */\n+  int file_idx;\t\t/* Index in input file table.  */\n+  int dir_idx;\t\t/* Index in directory table.  */\n+};\n+\n+/* Data structure containing information about directories with source\n+   files.  */\n+struct dir_info\n+{\n+  char *path;\t\t/* Path including directory name.  */\n+  int length;\t\t/* Path length.  */\n+  int prefix;\t\t/* Index of directory entry which is a prefix.  */\n+  int nbytes;\t\t/* Total number of bytes in all file names excluding\n+\t\t\t   paths.  */\n+  int count;\t\t/* Number of files in this directory.  */\n+  int dir_idx;\t\t/* Index of directory used as base.  */\n+  int used;\t\t/* Used in the end?  */\n+};\n+\n+/* Callback function for file_info comparison.  We sort by looking at\n+   the directories in the path.  */\n+static int\n+file_info_cmp (p1, p2)\n+     const void *p1;\n+     const void *p2;\n+{\n+  const struct file_info *s1 = p1;\n+  const struct file_info *s2 = p2;\n+  unsigned char *cp1;\n+  unsigned char *cp2;\n+\n+  /* Take care of file names without directories.  */\n+  if (s1->path == s1->fname)\n+    return -1;\n+  else if (s2->path == s2->fname)\n+    return 1;\n+\n+  cp1 = (unsigned char *) s1->path;\n+  cp2 = (unsigned char *) s2->path;\n+\n+  while (1)\n+    {\n+      ++cp1;\n+      ++cp2;\n+      /* Reached the end of the first path?  */\n+      if (cp1 == (unsigned char *) s1->fname)\n+\t/* It doesn't really matter in which order files from the\n+\t   same directory are sorted in.  Therefore don't test for\n+\t   the second path reaching the end.  */\n+\treturn -1;\n+      else if (cp2 == (unsigned char *) s2->fname)\n+\treturn 1;\n+\n+      /* Character of current path component the same?  */\n+      if (*cp1 != *cp2)\n+\treturn *cp1 - *cp2;\n+    }\n+}\n+\n+/* Output the directory table and the file name table.  We try to minimize\n+   the total amount of memory needed.  A heuristic is used to avoid large\n+   slowdowns with many input files.  */\n+static void\n+output_file_names ()\n+{\n+  struct file_info *files;\n+  struct dir_info *dirs;\n+  int *saved;\n+  int *savehere;\n+  int *backmap;\n+  int ndirs;\n+  int idx_offset;\n+  int i;\n+  int idx;\n+\n+  /* Allocate the various arrays we need.  */\n+  files = (struct file_info *) alloca (line_file_table.in_use\n+\t\t\t\t       * sizeof (struct file_info));\n+  dirs = (struct dir_info *) alloca (line_file_table.in_use\n+\t\t\t\t     * sizeof (struct dir_info));\n+\n+  /* Sort the file names.  */\n+   for (i = 1; i < (int) line_file_table.in_use; ++i)\n+    {\n+      char *f;\n+\n+      /* Skip all leading \"./\".  */\n+      f = line_file_table.table[i];\n+      while (f[0] == '.' && f[1] == '/')\n+\tf += 2;\n+\n+      /* Create a new array entry.  */\n+      files[i].path = f;\n+      files[i].length = strlen (f);\n+      files[i].file_idx = i;\n+\n+      /* Search for the file name part.  */\n+      f = strrchr (f, '/');\n+      files[i].fname = f == NULL ? files[i].path : f + 1;\n+    }\n+  qsort (files + 1, line_file_table.in_use - 1, sizeof (files[0]),\n+\t file_info_cmp);\n+\n+  /* Find all the different directories used.  */\n+  dirs[0].path = files[1].path;\n+  dirs[0].length = files[1].fname - files[1].path;\n+  dirs[0].prefix = -1;\n+  dirs[0].nbytes = files[1].length - dirs[1].length + 1;\n+  dirs[0].count = 1;\n+  dirs[0].dir_idx = 0;\n+  dirs[0].used = 0;\n+  files[1].dir_idx = 0;\n+  ndirs = 1;\n+\n+  for (i = 2; i < (int) line_file_table.in_use; ++i)\n+    if (files[i].fname - files[i].path == dirs[ndirs - 1].length\n+\t&& memcmp (dirs[ndirs - 1].path, files[i].path,\n+\t\t   dirs[ndirs - 1].length) == 0)\n+      {\n+\t/* Same directory as last entry.  */\n+\tfiles[i].dir_idx = ndirs - 1;\n+\tdirs[ndirs - 1].nbytes += files[i].length - dirs[ndirs - 1].length + 1;\n+\t++dirs[ndirs - 1].count;\n+      }\n+    else\n+      {\n+\tint j;\n+\n+\t/* This is a new directory.  */\n+\tdirs[ndirs].path = files[i].path;\n+\tdirs[ndirs].length = files[i].fname - files[i].path;\n+\tdirs[ndirs].nbytes = files[i].length - dirs[i].length + 1;\n+\tdirs[ndirs].count = 1;\n+\tdirs[ndirs].dir_idx = ndirs;\n+\tdirs[ndirs].used = 0;\n+\tfiles[i].dir_idx = ndirs;\n+\n+\t/* Search for a prefix.  */\n+\tdirs[ndirs].prefix = -1;\n+\tfor (j = 0; j < ndirs; ++j)\n+\t  if (dirs[j].length < dirs[ndirs].length\n+\t      && dirs[j].length != 0\n+\t      && memcmp (dirs[j].path, dirs[ndirs].path, dirs[j].length) == 0)\n+\t    dirs[ndirs].prefix = j;\n+\n+\t++ndirs;\n+      }\n+\n+  /* Now to the actual work.  We have to find a subset of the\n+     directories which allow expressing the file name using references\n+     to the directory table with the least amount of characters.  We\n+     do not do an exhaustive search where we would have to check out\n+     every combination of every single possible prefix.  Instead we\n+     use a heuristic which provides nearly optimal results in most\n+     cases and never is much off.  */\n+  saved = (int *) alloca (ndirs * sizeof (int));\n+  savehere = (int *) alloca (ndirs * sizeof (int));\n+\n+  memset (saved, '\\0', ndirs * sizeof (saved[0]));\n+  for (i = 0; i < ndirs; ++i)\n+    {\n+      int j;\n+      int total;\n+\n+      /* We can always safe some space for the current directory.  But\n+\t this does not mean it will be enough to justify adding the\n+\t directory.  */\n+      savehere[i] = dirs[i].length;\n+      total = (savehere[i] - saved[i]) * dirs[i].count;\n+\n+      for (j = i + 1; j < ndirs; ++j)\n+\t{\n+\t  savehere[j] = 0;\n+\n+\t  if (saved[j] < dirs[i].length)\n+\t    {\n+\t      /* Determine whether the dirs[i] path is a prefix of the\n+\t\t dirs[j] path.  */\n+\t      int k;\n+\n+\t       k = dirs[j].prefix;\n+\t       while (k != -1 && k != i)\n+\t\t k = dirs[k].prefix;\n+\n+\t       if (k == i)\n+\t\t {\n+\t\t   /* Yes it is.  We can possibly safe some memory but\n+\t\t      writing the filenames in dirs[j] relative to\n+\t\t      dirs[i].  */\n+\t\t   savehere[j] = dirs[i].length;\n+\t\t   total += (savehere[j] - saved[j]) * dirs[j].count;\n+\t\t }\n+\t    }\n+\t}\n+\n+      /* Check whether we can safe enough to justify adding the dirs[i]\n+\t directory.  */\n+      if (total > dirs[i].length + 1)\n+\t{\n+\t   /* It's worthwhile adding.  */\n+          for (j = i; j < ndirs; ++j)\n+\t    if (savehere[j] > 0)\n+\t      {\n+\t\t/* Remember how much we saved for this directory so far.  */\n+\t\tsaved[j] = savehere[j];\n+\n+\t\t/* Remember the prefix directory.  */\n+\t\tdirs[j].dir_idx = i;\n+\t      }\n+\t}\n+    }\n+\n+  /* We have to emit them in the order they appear in the line_file_table\n+     array since the index is used in the debug info generation.  To\n+     do this efficiently we generate a back-mapping of the indices\n+     first.  */\n+  backmap = (int *) alloca (line_file_table.in_use * sizeof (int));\n+  for (i = 1; i < (int) line_file_table.in_use; ++i)\n+    {\n+      backmap[files[i].file_idx] = i;\n+      /* Mark this directory as used.  */\n+      dirs[dirs[files[i].dir_idx].dir_idx].used = 1;\n+    }\n+\n+  /* That was it.  We are ready to emit the information.  First the\n+     directory name table.  Here we have to make sure that the first\n+     actually emitted directory name has the index one.  Zero is\n+     reserved for the current working directory.  Make sure we do not\n+     confuse these indices with the one for the constructed table\n+     (even though most of the time they are identical).  */\n+  idx = 1;\n+  idx_offset = dirs[0].path[0] == '/' ? 1 : 0;\n+  for (i = 1 - idx_offset; i < ndirs; ++i)\n+    if (dirs[i].used != 0)\n+      {\n+\tdirs[i].used = idx++;\n+\n+\tif (flag_debug_asm)\n+\t  {\n+\t    ASM_OUTPUT_DWARF_NSTRING (asm_out_file,\n+\t\t\t\t      dirs[i].path, dirs[i].length - 1);\n+\t    fprintf (asm_out_file, \"%s Directory Entry: 0x%x\\n\",\n+\t\t     ASM_COMMENT_START, dirs[i].used);\n+\t  }\n+\telse\n+\t  {\n+\t    ASM_OUTPUT_ASCII (asm_out_file, dirs[i].path, dirs[i].length - 1);\n+\t    ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+\t    fputc ('\\n', asm_out_file);\n+\t  }\n+      }\n+  /* Correct the index for the current working directory entry if it\n+     exists.  */\n+  if (idx_offset == 0)\n+    dirs[0].used = 0;\n+  /* Terminate the directory name array.  */\n+  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+  if (flag_debug_asm)\n+    fprintf (asm_out_file, \"\\t%s End directory table\", ASM_COMMENT_START);\n+  fputc ('\\n', asm_out_file);\n+\n+  /* Now write all the file names.  */\n+  for (i = 1; i < (int) line_file_table.in_use; ++i)\n+    {\n+      int file_idx = backmap[i];\n+      int dir_idx = dirs[files[file_idx].dir_idx].dir_idx;\n+\n+      if (flag_debug_asm)\n+\t{\n+\t  ASM_OUTPUT_DWARF_STRING (asm_out_file,\n+\t\t\t\t   files[file_idx].path\n+\t\t\t\t   + dirs[dir_idx].length);\n+\t  fprintf (asm_out_file, \"%s File Entry: 0x%x\\n\",\n+\t\t   ASM_COMMENT_START, i);\n+\t}\n+      else\n+\tASM_OUTPUT_ASCII (asm_out_file,\n+\t\t\t  files[file_idx].path + dirs[dir_idx].length,\n+\t\t\t  (files[file_idx].length\n+\t\t\t   - dirs[dir_idx].length) + 1);\n+\n+      /* Include directory index.  */\n+      output_uleb128 (dirs[dir_idx].used);\n+      fputc ('\\n', asm_out_file);\n+\n+      /* Modification time.  */\n+      output_uleb128 (0);\n+      fputc ('\\n', asm_out_file);\n+\n+      /* File length in bytes.  */\n+      output_uleb128 (0);\n+      fputc ('\\n', asm_out_file);\n+    }\n+\n+  /* Terminate the file name table */\n+  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+  if (flag_debug_asm)\n+    fprintf (asm_out_file, \"\\t%s End file name table\", ASM_COMMENT_START);\n+  fputc ('\\n', asm_out_file);\n+}\n+\n+\n /* Output the source line number correspondence information.  This\n    information goes into the .debug_line section.  */\n \n@@ -6403,7 +6714,6 @@ output_line_info ()\n   char prev_line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   register unsigned opc;\n   register unsigned n_op_args;\n-  register unsigned long ft_index;\n   register unsigned long lt_index;\n   register unsigned long current_line;\n   register long line_offset;\n@@ -6479,49 +6789,8 @@ output_line_info ()\n       fputc ('\\n', asm_out_file);\n     }\n \n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"%s Include Directory Table\\n\", ASM_COMMENT_START);\n-\n-  /* Include directory table is empty, at present */\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-  fputc ('\\n', asm_out_file);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"%s File Name Table\\n\", ASM_COMMENT_START);\n-\n-  for (ft_index = 1; ft_index < line_file_table.in_use; ++ft_index)\n-    {\n-      if (flag_debug_asm)\n-\t{\n-\t  ASM_OUTPUT_DWARF_STRING (asm_out_file,\n-\t\t\t\t   line_file_table.table[ft_index]);\n-\t  fprintf (asm_out_file, \"%s File Entry: 0x%lx\",\n-\t\t   ASM_COMMENT_START, ft_index);\n-\t}\n-      else\n-\t{\n-\t  ASM_OUTPUT_ASCII (asm_out_file,\n-\t\t\t    line_file_table.table[ft_index],\n-\t\t\t    (int) strlen (line_file_table.table[ft_index]) + 1);\n-\t}\n-\n-      fputc ('\\n', asm_out_file);\n-\n-      /* Include directory index */\n-      output_uleb128 (0);\n-      fputc ('\\n', asm_out_file);\n-\n-      /* Modification time */\n-      output_uleb128 (0);\n-      fputc ('\\n', asm_out_file);\n-\n-      /* File length in bytes */\n-      output_uleb128 (0);\n-      fputc ('\\n', asm_out_file);\n-    }\n-\n-  /* Terminate the file name table */\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-  fputc ('\\n', asm_out_file);\n+  /* Write out the information about the files we use.  */\n+  output_file_names ();\n \n   /* We used to set the address register to the first location in the text\n      section here, but that didn't accomplish anything since we already\n@@ -8349,7 +8618,7 @@ tree_add_const_value_attribute (var_die, decl)\n     default:;\n     }\n }\n-     \n+\n /* Generate an DW_AT_name attribute given some string value to be included as\n    the value of the attribute.  */\n \n@@ -8463,7 +8732,7 @@ add_bound_info (subrange_die, bound_attr, bound)\n \t/* ??? Can this happen, or should the variable have been bound\n \t   first?  Probably it can, since I imagine that we try to create\n \t   the types of parameters in the order in which they exist in\n-\t   the list, and won't have created a forward reference to a \n+\t   the list, and won't have created a forward reference to a\n \t   later parameter.  */\n \tif (decl_die != NULL)\n \t  add_AT_die_ref (subrange_die, bound_attr, decl_die);\n@@ -11053,7 +11322,7 @@ dwarf2out_line (filename, line)\n \n \t  /* Emit the .file and .loc directives understood by GNU as.  */\n #if 0\n-\t  /* ??? As of 2000-11-25, gas has a bug in which it doesn't \n+\t  /* ??? As of 2000-11-25, gas has a bug in which it doesn't\n \t     actually use the file number argument.  It merely remembers\n \t     the last .file directive emitted.  */\n \t  if (file_num >= old_in_use)\n@@ -11158,7 +11427,7 @@ dwarf2out_end_source_file ()\n     {\n       /* Record the end of the file for break_out_includes.  */\n       new_die (DW_TAG_GNU_EINCL, comp_unit_die);\n-    }      \n+    }\n }\n \n /* Called from check_newline in c-parse.y.  The `buffer' parameter contains"}]}