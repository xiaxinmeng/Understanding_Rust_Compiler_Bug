{"sha": "159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU5YjNiZTFmM2Y3ZjQzZDM3Y2JlNjBiNGU4YzQ2YTExMzc1NWI3Mw==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-06-29T12:07:06Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-29T12:07:06Z"}, "message": "collect2.h: Convert prototypes to ISO C90.\n\n\t* collect2.h: Convert prototypes to ISO C90.\n\t* collect2.c: Likewise.\n\t* conflict.c: Likewise.\n\t* coverage.c: Likewise.\n\t* convert.h: Likewise.\n\t* convert.c: Likewise.\n\nFrom-SVN: r68669", "tree": {"sha": "cf833e6b9db343195cfc4ac6c4146564b79f13e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf833e6b9db343195cfc4ac6c4146564b79f13e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4e3f84b7ca86d5bd9d90572fbcfdc03bca4f78ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e3f84b7ca86d5bd9d90572fbcfdc03bca4f78ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e3f84b7ca86d5bd9d90572fbcfdc03bca4f78ac"}], "stats": {"total": 680, "additions": 281, "deletions": 399}, "files": [{"sha": "53e4b67af47bfe25ae32950e7e21c9eeec4aa747", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "patch": "@@ -1,3 +1,12 @@\n+2003-06-29  Andreas Jaeger  <aj@suse.de>\n+\n+\t* collect2.h: Convert prototypes to ISO C90.\n+\t* collect2.c: Likewise.\n+\t* conflict.c: Likewise.\n+\t* coverage.c: Likewise.\n+\t* convert.h: Likewise.\n+\t* convert.c: Likewise.\n+\n 2003-06-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* c-decl.c (c_init_decl_processing): Use a location_t. Set input"}, {"sha": "85d2843237c4335a74def1f06d7960f35f923948", "filename": "gcc/collect2.c", "status": "modified", "additions": 139, "deletions": 222, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "patch": "@@ -104,7 +104,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Some systems have an ISCOFF macro, but others do not.  In some cases\n    the macro may be wrong.  MY_ISCOFF is defined in tm.h files for machines\n-   that either do not have an ISCOFF macro in /usr/include or for those \n+   that either do not have an ISCOFF macro in /usr/include or for those\n    where it is wrong.  */\n \n #ifndef MY_ISCOFF\n@@ -175,7 +175,7 @@ int no_demangle;\n \f\n /* Linked lists of constructor and destructor names.  */\n \n-struct id \n+struct id\n {\n   struct id *next;\n   int sequence;\n@@ -264,58 +264,55 @@ static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,\n static const char *const libexts[3] = {\"a\", \"so\", NULL};  /* possible library extensions */\n #endif\n \n-static void handler\t\tPARAMS ((int));\n-static int is_ctor_dtor\t\tPARAMS ((const char *));\n-static char *find_a_file\tPARAMS ((struct path_prefix *, const char *));\n-static void add_prefix\t\tPARAMS ((struct path_prefix *, const char *));\n-static void prefix_from_env\tPARAMS ((const char *, struct path_prefix *));\n-static void prefix_from_string\tPARAMS ((const char *, struct path_prefix *));\n-static void do_wait\t\tPARAMS ((const char *));\n-static void fork_execute\tPARAMS ((const char *, char **));\n-static void maybe_unlink\tPARAMS ((const char *));\n-static void add_to_list\t\tPARAMS ((struct head *, const char *));\n-static int extract_init_priority PARAMS ((const char *));\n-static void sort_ids\t\tPARAMS ((struct head *));\n-static void write_list\t\tPARAMS ((FILE *, const char *, struct id *));\n+static void handler (int);\n+static int is_ctor_dtor (const char *);\n+static char *find_a_file (struct path_prefix *, const char *);\n+static void add_prefix (struct path_prefix *, const char *);\n+static void prefix_from_env (const char *, struct path_prefix *);\n+static void prefix_from_string (const char *, struct path_prefix *);\n+static void do_wait (const char *);\n+static void fork_execute (const char *, char **);\n+static void maybe_unlink (const char *);\n+static void add_to_list (struct head *, const char *);\n+static int extract_init_priority (const char *);\n+static void sort_ids (struct head *);\n+static void write_list (FILE *, const char *, struct id *);\n #ifdef COLLECT_EXPORT_LIST\n-static void dump_list\t\tPARAMS ((FILE *, const char *, struct id *));\n+static void dump_list (FILE *, const char *, struct id *);\n #endif\n #if 0\n-static void dump_prefix_list\tPARAMS ((FILE *, const char *, struct prefix_list *));\n+static void dump_prefix_list (FILE *, const char *, struct prefix_list *);\n #endif\n-static void write_list_with_asm PARAMS ((FILE *, const char *, struct id *));\n-static void write_c_file\tPARAMS ((FILE *, const char *));\n-static void write_c_file_stat\tPARAMS ((FILE *, const char *));\n+static void write_list_with_asm (FILE *, const char *, struct id *);\n+static void write_c_file (FILE *, const char *);\n+static void write_c_file_stat (FILE *, const char *);\n #ifndef LD_INIT_SWITCH\n-static void write_c_file_glob\tPARAMS ((FILE *, const char *));\n+static void write_c_file_glob (FILE *, const char *);\n #endif\n-static void scan_prog_file\tPARAMS ((const char *, enum pass));\n+static void scan_prog_file (const char *, enum pass);\n #ifdef SCAN_LIBRARIES\n-static void scan_libraries\tPARAMS ((const char *));\n+static void scan_libraries (const char *);\n #endif\n #if LINK_ELIMINATE_DUPLICATE_LDIRECTORIES\n-static int is_in_args\t\tPARAMS ((const char *, const char **, const char **));\n+static int is_in_args (const char *, const char **, const char **);\n #endif\n #ifdef COLLECT_EXPORT_LIST\n #if 0\n-static int is_in_list\t\tPARAMS ((const char *, struct id *));\n+static int is_in_list (const char *, struct id *);\n #endif\n-static void write_aix_file\tPARAMS ((FILE *, struct id *));\n-static char *resolve_lib_name\tPARAMS ((const char *));\n+static void write_aix_file (FILE *, struct id *);\n+static char *resolve_lib_name (const char *);\n #endif\n-static char *extract_string\tPARAMS ((const char **));\n+static char *extract_string (const char **);\n \f\n #ifndef HAVE_DUP2\n-static int dup2 PARAMS ((int, int));\n static int\n-dup2 (oldfd, newfd)\n-     int oldfd;\n-     int newfd;\n+dup2 (int oldfd, int newfd)\n {\n   int fdtmp[256];\n   int fdx = 0;\n   int fd;\n- \n+\n   if (oldfd == newfd)\n     return oldfd;\n   close (newfd);\n@@ -331,8 +328,7 @@ dup2 (oldfd, newfd)\n /* Delete tempfiles and exit function.  */\n \n void\n-collect_exit (status)\n-     int status;\n+collect_exit (int status)\n {\n   if (c_file != 0 && c_file[0])\n     maybe_unlink (c_file);\n@@ -363,7 +359,7 @@ void\n notice (const char *msgid, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n   vfprintf (stderr, _(msgid), ap);\n   va_end (ap);\n@@ -376,7 +372,7 @@ fatal_perror (const char * msgid, ...)\n {\n   int e = errno;\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n   fprintf (stderr, \"collect2: \");\n   vfprintf (stderr, _(msgid), ap);\n@@ -392,7 +388,7 @@ void\n fatal (const char * msgid, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n   fprintf (stderr, \"collect2: \");\n   vfprintf (stderr, _(msgid), ap);\n@@ -408,7 +404,7 @@ void\n error (const char * msgid, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n   fprintf (stderr, \"collect2: \");\n   vfprintf (stderr, _(msgid), ap);\n@@ -420,14 +416,13 @@ error (const char * msgid, ...)\n    provide a default entry.  */\n \n void\n-fancy_abort ()\n+fancy_abort (void)\n {\n   fatal (\"internal error\");\n }\n \f\n static void\n-handler (signo)\n-     int signo;\n+handler (int signo)\n {\n   if (c_file != 0 && c_file[0])\n     maybe_unlink (c_file);\n@@ -449,17 +444,15 @@ handler (signo)\n \n \f\n int\n-file_exists (name)\n-     const char *name;\n+file_exists (const char *name)\n {\n   return access (name, R_OK) == 0;\n }\n \n /* Parse a reasonable subset of shell quoting syntax.  */\n \n static char *\n-extract_string (pp)\n-     const char **pp;\n+extract_string (const char **pp)\n {\n   const char *p = *pp;\n   int backquote = 0;\n@@ -489,8 +482,7 @@ extract_string (pp)\n }\n \f\n void\n-dump_file (name)\n-     const char *name;\n+dump_file (const char *name)\n {\n   FILE *stream = fopen (name, \"r\");\n \n@@ -552,8 +544,7 @@ dump_file (name)\n    nothing special (0).  */\n \n static int\n-is_ctor_dtor (s)\n-     const char *s;\n+is_ctor_dtor (const char *s)\n {\n   struct names { const char *const name; const int len; const int ret;\n     const int two_underscores; };\n@@ -611,22 +602,20 @@ static const char *const target_machine = TARGET_MACHINE;\n #endif\n \n /* Search for NAME using prefix list PPREFIX.  We only look for executable\n-   files. \n+   files.\n \n    Return 0 if not found, otherwise return its name, allocated with malloc.  */\n \n static char *\n-find_a_file (pprefix, name)\n-     struct path_prefix *pprefix;\n-     const char *name;\n+find_a_file (struct path_prefix *pprefix, const char *name)\n {\n   char *temp;\n   struct prefix_list *pl;\n   int len = pprefix->max_len + strlen (name) + 1;\n \n   if (debug)\n     fprintf (stderr, \"Looking for '%s'\\n\", name);\n-  \n+\n #ifdef HOST_EXECUTABLE_SUFFIX\n   len += strlen (HOST_EXECUTABLE_SUFFIX);\n #endif\n@@ -647,7 +636,7 @@ find_a_file (pprefix, name)\n \n \t  if (debug)\n \t    fprintf (stderr, \"  - found: absolute path\\n\");\n-\t  \n+\n \t  return temp;\n \t}\n \n@@ -656,7 +645,7 @@ find_a_file (pprefix, name)\n \t   So try appending that.  */\n       strcpy (temp, name);\n \tstrcat (temp, HOST_EXECUTABLE_SUFFIX);\n-\t\n+\n \tif (access (temp, X_OK) == 0)\n \t  return temp;\n #endif\n@@ -671,7 +660,7 @@ find_a_file (pprefix, name)\n \n \tstrcpy (temp, pl->prefix);\n \tstrcat (temp, name);\n-\t\n+\n \tif (stat (temp, &st) >= 0\n \t    && ! S_ISDIR (st.st_mode)\n \t    && access (temp, X_OK) == 0)\n@@ -681,7 +670,7 @@ find_a_file (pprefix, name)\n \t/* Some systems have a suffix for executable files.\n \t   So try appending that.  */\n \tstrcat (temp, HOST_EXECUTABLE_SUFFIX);\n-\t\n+\n \tif (stat (temp, &st) >= 0\n \t    && ! S_ISDIR (st.st_mode)\n \t    && access (temp, X_OK) == 0)\n@@ -699,9 +688,7 @@ find_a_file (pprefix, name)\n /* Add an entry for PREFIX to prefix list PPREFIX.  */\n \n static void\n-add_prefix (pprefix, prefix)\n-     struct path_prefix *pprefix;\n-     const char *prefix;\n+add_prefix (struct path_prefix *pprefix, const char *prefix)\n {\n   struct prefix_list *pl, **prev;\n   int len;\n@@ -735,9 +722,7 @@ add_prefix (pprefix, prefix)\n    add of the entries to PPREFIX.  */\n \n static void\n-prefix_from_env (env, pprefix)\n-     const char *env;\n-     struct path_prefix *pprefix;\n+prefix_from_env (const char *env, struct path_prefix *pprefix)\n {\n   const char *p;\n   GET_ENVIRONMENT (p, env);\n@@ -747,16 +732,14 @@ prefix_from_env (env, pprefix)\n }\n \n static void\n-prefix_from_string (p, pprefix)\n-     const char *p;\n-     struct path_prefix *pprefix;\n+prefix_from_string (const char *p, struct path_prefix *pprefix)\n {\n   const char *startp, *endp;\n   char *nstore = (char *) xmalloc (strlen (p) + 3);\n \n   if (debug)\n     fprintf (stderr, \"Convert string '%s' into prefixes, separator = '%c'\\n\", p, PATH_SEPARATOR);\n-  \n+\n   startp = endp = p;\n   while (1)\n     {\n@@ -777,7 +760,7 @@ prefix_from_string (p, pprefix)\n \n \t  if (debug)\n \t    fprintf (stderr, \"  - add prefix: %s\\n\", nstore);\n-\t  \n+\n \t  add_prefix (pprefix, nstore);\n \t  if (*endp == 0)\n \t    break;\n@@ -790,11 +773,8 @@ prefix_from_string (p, pprefix)\n \f\n /* Main program.  */\n \n-int main \t\tPARAMS ((int, char *[]));\n int\n-main (argc, argv)\n-     int argc;\n-     char *argv[];\n+main (int argc, char **argv)\n {\n   static const char *const ld_suffix\t= \"ld\";\n   static const char *const real_ld_suffix = \"real-ld\";\n@@ -890,7 +870,7 @@ main (argc, argv)\n      are called.  */\n   {\n     int i;\n-    \n+\n     for (i = 1; argv[i] != NULL; i ++)\n       if (! strcmp (argv[i], \"-debug\"))\n \tdebug = 1;\n@@ -1053,7 +1033,7 @@ main (argc, argv)\n   add_prefix (&libpath_lib_dirs, \"/usr/lib\");\n #endif\n \n-  /* Get any options that the upper GCC wants to pass to the sub-GCC.  \n+  /* Get any options that the upper GCC wants to pass to the sub-GCC.\n \n      AIX support needs to know if -shared has been specified before\n      parsing commandline arguments.  */\n@@ -1143,10 +1123,10 @@ main (argc, argv)\n \n #ifdef COLLECT_EXPORT_LIST\n \t    /* Saving directories where to search for libraries.  */\n-       \t    case 'L':\n+\t    case 'L':\n \t      add_prefix (&cmdline_lib_dirs, arg+2);\n \t      break;\n-#else \n+#else\n #if LINK_ELIMINATE_DUPLICATE_LDIRECTORIES\n \t    case 'L':\n \t      if (is_in_args (arg, (const char **) ld1_argv, ld1-1))\n@@ -1211,8 +1191,8 @@ main (argc, argv)\n \t    *object++ = arg;\n #ifdef COLLECT_EXPORT_LIST\n \t  /* libraries can be specified directly, i.e. without -l flag.  */\n-       \t  else\n-       \t    { \n+\t  else\n+\t    {\n \t      /* Saving a full library name.  */\n               add_to_list (&libs, arg);\n             }\n@@ -1246,7 +1226,7 @@ main (argc, argv)\n   if (exports.first)\n     {\n       char *buf = concat (\"-bE:\", export_file, NULL);\n-      \n+\n       *ld1++ = buf;\n       *ld2++ = buf;\n \n@@ -1378,7 +1358,7 @@ main (argc, argv)\n \t{\n \t  char **real_strip_argv = (char **) xcalloc (sizeof (char *), 3);\n \t  const char ** strip_argv = (const char **) real_strip_argv;\n-\t  \n+\n \t  strip_argv[0] = strip_file_name;\n \t  strip_argv[1] = output_file;\n \t  strip_argv[2] = (char *) 0;\n@@ -1470,7 +1450,7 @@ main (argc, argv)\n   /* Let scan_prog_file do any final mods (OSF/rose needs this for\n      constructors/destructors in shared libraries.  */\n   scan_prog_file (output_file, PASS_SECOND);\n-#endif \n+#endif\n \n   maybe_unlink (c_file);\n   maybe_unlink (o_file);\n@@ -1486,8 +1466,7 @@ main (argc, argv)\n /* Wait for a process to finish, and exit if a nonzero status is found.  */\n \n int\n-collect_wait (prog)\n-     const char *prog;\n+collect_wait (const char *prog)\n {\n   int status;\n \n@@ -1510,8 +1489,7 @@ collect_wait (prog)\n }\n \n static void\n-do_wait (prog)\n-     const char *prog;\n+do_wait (const char *prog)\n {\n   int ret = collect_wait (prog);\n   if (ret != 0)\n@@ -1525,10 +1503,7 @@ do_wait (prog)\n /* Execute a program, and wait for the reply.  */\n \n void\n-collect_execute (prog, argv, redir)\n-     const char *prog;\n-     char **argv;\n-     const char *redir;\n+collect_execute (const char *prog, char **argv, const char *redir)\n {\n   char *errmsg_fmt;\n   char *errmsg_arg;\n@@ -1598,9 +1573,7 @@ collect_execute (prog, argv, redir)\n }\n \n static void\n-fork_execute (prog, argv)\n-     const char *prog;\n-     char **argv;\n+fork_execute (const char *prog, char **argv)\n {\n   collect_execute (prog, argv, NULL);\n   do_wait (prog);\n@@ -1609,8 +1582,7 @@ fork_execute (prog, argv)\n /* Unlink a file unless we are debugging.  */\n \n static void\n-maybe_unlink (file)\n-     const char *file;\n+maybe_unlink (const char *file)\n {\n   if (!debug)\n     unlink (file);\n@@ -1624,9 +1596,7 @@ static long sequence_number = 0;\n /* Add a name to a linked list.  */\n \n static void\n-add_to_list (head_ptr, name)\n-     struct head *head_ptr;\n-     const char *name;\n+add_to_list (struct head *head_ptr, const char *name)\n {\n   struct id *newid\n     = (struct id *) xcalloc (sizeof (struct id) + strlen (name), 1);\n@@ -1659,8 +1629,7 @@ add_to_list (head_ptr, name)\n    looks like \"_GLOBAL_.I.12345.foo\".  */\n \n static int\n-extract_init_priority (name)\n-     const char *name;\n+extract_init_priority (const char *name)\n {\n   int pos = 0, pri;\n \n@@ -1677,8 +1646,7 @@ extract_init_priority (name)\n    ctors will be run from right to left, dtors from left to right.  */\n \n static void\n-sort_ids (head_ptr)\n-     struct head *head_ptr;\n+sort_ids (struct head *head_ptr)\n {\n   /* id holds the current element to insert.  id_next holds the next\n      element to insert.  id_ptr iterates through the already sorted elements\n@@ -1719,10 +1687,7 @@ sort_ids (head_ptr)\n /* Write: `prefix', the names on list LIST, `suffix'.  */\n \n static void\n-write_list (stream, prefix, list)\n-     FILE *stream;\n-     const char *prefix;\n-     struct id *list;\n+write_list (FILE *stream, const char *prefix, struct id *list)\n {\n   while (list)\n     {\n@@ -1736,10 +1701,8 @@ write_list (stream, prefix, list)\n    [ARGS_BEGIN,ARGS_END).  */\n \n static int\n-is_in_args (string, args_begin, args_end)\n-     const char *string;\n-     const char **args_begin;\n-     const char **args_end;\n+is_in_args (const char *string, const char **args_begin,\n+\t    const char **args_end)\n {\n   const char **args_pointer;\n   for (args_pointer = args_begin; args_pointer != args_end; ++args_pointer)\n@@ -1753,9 +1716,7 @@ is_in_args (string, args_begin, args_end)\n /* This function is really used only on AIX, but may be useful.  */\n #if 0\n static int\n-is_in_list (prefix, list)\n-     const char *prefix;\n-     struct id *list;\n+is_in_list (const char *prefix, struct id *list)\n {\n   while (list)\n     {\n@@ -1770,10 +1731,7 @@ is_in_list (prefix, list)\n /* Added for debugging purpose.  */\n #ifdef COLLECT_EXPORT_LIST\n static void\n-dump_list (stream, prefix, list)\n-     FILE *stream;\n-     const char *prefix;\n-     struct id *list;\n+dump_list (FILE *stream, const char *prefix, struct id *list)\n {\n   while (list)\n     {\n@@ -1785,10 +1743,7 @@ dump_list (stream, prefix, list)\n \n #if 0\n static void\n-dump_prefix_list (stream, prefix, list)\n-     FILE *stream;\n-     const char *prefix;\n-     struct prefix_list *list;\n+dump_prefix_list (FILE *stream, const char *prefix, struct prefix_list *list)\n {\n   while (list)\n     {\n@@ -1799,10 +1754,7 @@ dump_prefix_list (stream, prefix, list)\n #endif\n \n static void\n-write_list_with_asm (stream, prefix, list)\n-     FILE *stream;\n-     const char *prefix;\n-     struct id *list;\n+write_list_with_asm (FILE *stream, const char *prefix, struct id *list)\n {\n   while (list)\n     {\n@@ -1816,9 +1768,7 @@ write_list_with_asm (stream, prefix, list)\n    object), along with the functions to execute them.  */\n \n static void\n-write_c_file_stat (stream, name)\n-     FILE *stream;\n-     const char *name ATTRIBUTE_UNUSED;\n+write_c_file_stat (FILE *stream, const char *name ATTRIBUTE_UNUSED)\n {\n   const char *p, *q;\n   char *prefix, *r;\n@@ -1947,16 +1897,14 @@ write_c_file_stat (stream, name)\n \n #ifndef LD_INIT_SWITCH\n static void\n-write_c_file_glob (stream, name)\n-     FILE *stream;\n-     const char *name ATTRIBUTE_UNUSED;\n+write_c_file_glob (FILE *stream, const char *name ATTRIBUTE_UNUSED)\n {\n   /* Write the tables as C code  */\n \n   int frames = (frame_tables.number > 0);\n \n   fprintf (stream, \"typedef void entry_pt();\\n\\n\");\n-    \n+\n   write_list_with_asm (stream, \"extern entry_pt \", constructors.first);\n \n   if (frames)\n@@ -2012,9 +1960,7 @@ write_c_file_glob (stream, name)\n #endif /* ! LD_INIT_SWITCH */\n \n static void\n-write_c_file (stream, name)\n-     FILE *stream;\n-     const char *name;\n+write_c_file (FILE *stream, const char *name)\n {\n   fprintf (stream, \"#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\");\n #ifndef LD_INIT_SWITCH\n@@ -2028,9 +1974,7 @@ write_c_file (stream, name)\n \n #ifdef COLLECT_EXPORT_LIST\n static void\n-write_aix_file (stream, list)\n-     FILE *stream;\n-     struct id *list;\n+write_aix_file (FILE *stream, struct id *list)\n {\n   for (; list; list = list->next)\n     {\n@@ -2052,12 +1996,10 @@ write_aix_file (stream, list)\n    destructor table has the same format, and begins at __DTOR_LIST__.  */\n \n static void\n-scan_prog_file (prog_name, which_pass)\n-     const char *prog_name;\n-     enum pass which_pass;\n+scan_prog_file (const char *prog_name, enum pass which_pass)\n {\n-  void (*int_handler) PARAMS ((int));\n-  void (*quit_handler) PARAMS ((int));\n+  void (*int_handler) (int);\n+  void (*quit_handler) (int);\n   char *real_nm_argv[4];\n   const char **nm_argv = (const char **) real_nm_argv;\n   int argc = 0;\n@@ -2123,9 +2065,9 @@ scan_prog_file (prog_name, which_pass)\n     }\n \n   /* Parent context from here on.  */\n-  int_handler  = (void (*) PARAMS ((int))) signal (SIGINT,  SIG_IGN);\n+  int_handler  = (void (*) (int)) signal (SIGINT,  SIG_IGN);\n #ifdef SIGQUIT\n-  quit_handler = (void (*) PARAMS ((int))) signal (SIGQUIT, SIG_IGN);\n+  quit_handler = (void (*) (int)) signal (SIGQUIT, SIG_IGN);\n #endif\n \n   if (close (pipe_fd[1]) < 0)\n@@ -2149,7 +2091,7 @@ scan_prog_file (prog_name, which_pass)\n \n       if (ch != '_')\n \tcontinue;\n-  \n+\n       name = p;\n       /* Find the end of the symbol name.\n \t Do not include `|', because Encore nm can tack that on the end.  */\n@@ -2229,8 +2171,8 @@ scan_prog_file (prog_name, which_pass)\n #include <sys/dir.h>\n \n /* pointers to the object file */\n-unsigned object;    \t/* address of memory mapped file */\n-unsigned objsize;    \t/* size of memory mapped to file */\n+unsigned object;\t/* address of memory mapped file */\n+unsigned objsize;\t/* size of memory mapped to file */\n char * code;\t\t/* pointer to code segment */\n char * data;\t\t/* pointer to data segment */\n struct nlist *symtab;\t/* pointer to symbol table */\n@@ -2240,11 +2182,8 @@ struct head libraries;\n \n /* Map the file indicated by NAME into memory and store its address.  */\n \n-static void mapfile\t\t\tPARAMS ((const char *));\n-\n static void\n-mapfile (name)\n-     const char *name;\n+mapfile (const char *name)\n {\n   int fp;\n   struct stat s;\n@@ -2266,11 +2205,8 @@ mapfile (name)\n \n static const char *libname;\n \n-static int libselect\t\t\tPARAMS ((struct direct *));\n-\n static int\n-libselect (d)\n-     struct direct *d;\n+libselect (struct direct *d)\n {\n   return (strncmp (libname, d->d_name, strlen (libname)) == 0);\n }\n@@ -2282,11 +2218,9 @@ libselect (d)\n    We must verify that the extension is numeric, because Sun saves the\n    original versions of patched libraries with a .FCS extension.  Files with\n    invalid extensions must go last in the sort, so that they will not be used.  */\n-static int libcompare\t\tPARAMS ((struct direct **, struct direct **));\n \n static int\n-libcompare (d1, d2)\n-     struct direct **d1, **d2;\n+libcompare (struct direct **d1, struct direct **d2)\n {\n   int i1, i2 = strlen (libname);\n   char *e1 = (*d1)->d_name + i2;\n@@ -2327,11 +2261,9 @@ libcompare (d1, d2)\n \n /* Given the name NAME of a dynamic dependency, find its pathname and add\n    it to the list of libraries.  */\n-static void locatelib\t\t\tPARAMS ((const char *));\n \n static void\n-locatelib (name)\n-     const char *name;\n+locatelib (const char *name)\n {\n   static const char **l;\n   static int cnt;\n@@ -2344,7 +2276,7 @@ locatelib (name)\n       char *ld_rules;\n       char *ldr = 0;\n       /* counting elements in array, need 1 extra for null */\n-      cnt = 1;  \n+      cnt = 1;\n       ld_rules = (char *) (ld_2->ld_rules + code);\n       if (ld_rules)\n \t{\n@@ -2370,7 +2302,7 @@ locatelib (name)\n       if (ldr)\n \t{\n \t  *pp++ = ldr;\n-\t  for (; *ldr != 0; ldr++) \n+\t  for (; *ldr != 0; ldr++)\n \t    if (*ldr == ':')\n \t      {\n \t\t*ldr++ = 0;\n@@ -2380,7 +2312,7 @@ locatelib (name)\n       if (q)\n \t{\n \t  *pp++ = q;\n-\t  for (; *q != 0; q++) \n+\t  for (; *q != 0; q++)\n \t    if (*q == ':')\n \t      {\n \t\t*q++ = 0;\n@@ -2419,9 +2351,8 @@ locatelib (name)\n /* Scan the _DYNAMIC structure of the output file to find shared libraries\n    that it depends upon and any constructors or destructors they contain.  */\n \n-static void \n-scan_libraries (prog_name)\n-     const char *prog_name;\n+static void\n+scan_libraries (const char *prog_name)\n {\n   struct exec *header;\n   char *base;\n@@ -2494,14 +2425,13 @@ scan_libraries (prog_name)\n    the output file depends upon and their initialization/finalization\n    routines, if any.  */\n \n-static void \n-scan_libraries (prog_name)\n-     const char *prog_name;\n+static void\n+scan_libraries (const char *prog_name)\n {\n   static struct head libraries;\t\t/* list of shared libraries found */\n   struct id *list;\n-  void (*int_handler) PARAMS ((int));\n-  void (*quit_handler) PARAMS ((int));\n+  void (*int_handler) (int);\n+  void (*quit_handler) (int);\n   char *real_ldd_argv[4];\n   const char **ldd_argv = (const char **) real_ldd_argv;\n   int argc = 0;\n@@ -2564,9 +2494,9 @@ scan_libraries (prog_name)\n     }\n \n   /* Parent context from here on.  */\n-  int_handler  = (void (*) PARAMS ((int))) signal (SIGINT,  SIG_IGN);\n+  int_handler  = (void (*) (int))) signal (SIGINT,  SIG_IGN;\n #ifdef SIGQUIT\n-  quit_handler = (void (*) PARAMS ((int))) signal (SIGQUIT, SIG_IGN);\n+  quit_handler = (void (*) (int))) signal (SIGQUIT, SIG_IGN;\n #endif\n \n   if (close (pipe_fd[1]) < 0)\n@@ -2591,7 +2521,7 @@ scan_libraries (prog_name)\n \tfatal (\"dynamic dependency %s not found\", buf);\n \n       /* Find the end of the symbol name.  */\n-      for (end = p; \n+      for (end = p;\n \t   (ch2 = *end) != '\\0' && ch2 != '\\n' && !ISSPACE (ch2) && ch2 != '|';\n \t   end++)\n \tcontinue;\n@@ -2696,10 +2626,9 @@ static const char *const aix_std_libs[] = {\n \n /* This function checks the filename and returns 1\n    if this name matches the location of a standard AIX library.  */\n-static int ignore_library\tPARAMS ((const char *));\n+static int ignore_library (const char *);\n static int\n-ignore_library (name)\n-     const char *name;\n+ignore_library (const char *name)\n {\n   const char *const *p = &aix_std_libs[0];\n   while (*p++ != NULL)\n@@ -2709,7 +2638,7 @@ ignore_library (name)\n #endif /* COLLECT_EXPORT_LIST */\n \n #if defined (HAVE_DECL_LDGETNAME) && !HAVE_DECL_LDGETNAME\n-extern char *ldgetname PARAMS ((LDFILE *, GCC_SYMENT *));\n+extern char *ldgetname (LDFILE *, GCC_SYMENT *);\n #endif\n \n /* COFF version to scan the name list of the loaded program for\n@@ -2722,9 +2651,7 @@ extern char *ldgetname PARAMS ((LDFILE *, GCC_SYMENT *));\n    destructor table has the same format, and begins at __DTOR_LIST__.  */\n \n static void\n-scan_prog_file (prog_name, which_pass)\n-     const char *prog_name;\n-     enum pass which_pass;\n+scan_prog_file (const char *prog_name, enum pass which_pass)\n {\n   LDFILE *ldptr = NULL;\n   int sym_index, sym_count;\n@@ -2834,7 +2761,7 @@ scan_prog_file (prog_name, which_pass)\n #ifdef COLLECT_EXPORT_LIST\n \t\t\t  /* If we are building a shared object on AIX we need\n \t\t\t     to explicitly export all global symbols.  */\n-\t\t\t  if (shared_obj) \n+\t\t\t  if (shared_obj)\n \t\t\t    {\n \t\t\t      if (which_pass == PASS_OBJ && (! export_flag))\n \t\t\t\tadd_to_list (&exports, name);\n@@ -2887,8 +2814,7 @@ scan_prog_file (prog_name, which_pass)\n /* Given a library name without \"lib\" prefix, this function\n    returns a full library name including a path.  */\n static char *\n-resolve_lib_name (name)\n-     const char *name;\n+resolve_lib_name (const char *name)\n {\n   char *lib_buf;\n   int i, j, l = 0;\n@@ -2912,7 +2838,7 @@ resolve_lib_name (name)\n \t    p = \"/\";\n \t  for (j = 0; libexts[j]; j++)\n \t    {\n-       \t      sprintf (lib_buf, \"%s%slib%s.%s\",\n+\t      sprintf (lib_buf, \"%s%slib%s.%s\",\n \t\t       list->prefix, p, name, libexts[j]);\n if (debug) fprintf (stderr, \"searching for: %s\\n\", lib_buf);\n \t      if (file_exists (lib_buf))\n@@ -2976,16 +2902,16 @@ struct file_info\n   int\tuse_mmap;\t\t\t/* != 0 if mmap'ed */\n };\n \n-extern int decode_mach_o_hdr ();\n-extern int encode_mach_o_hdr ();\n+extern int decode_mach_o_hdr (void);\n+extern int encode_mach_o_hdr (void);\n \n-static void add_func_table\tPARAMS ((mo_header_t *, load_all_t *,\n-\t\t\t\t       symbol_info_t *, int));\n-static void print_header\tPARAMS ((mo_header_t *));\n-static void print_load_command\tPARAMS ((load_union_t *, size_t, int));\n-static void bad_header\t\tPARAMS ((int));\n-static struct file_info\t*read_file  PARAMS ((const char *, int, int));\n-static void end_file\t\tPARAMS ((struct file_info *));\n+static void add_func_table (mo_header_t *, load_all_t *, symbol_info_t *,\n+\t\t\t    int);\n+static void print_header (mo_header_t *);\n+static void print_load_command (load_union_t *, size_t, int);\n+static void bad_header (int);\n+static struct file_info\t*read_file (const char *, int, int);\n+static void end_file (struct file_info *);\n \f\n /* OSF/rose specific version to scan the name list of the loaded\n    program for the symbols g++ uses for static constructors and\n@@ -2998,9 +2924,7 @@ static void end_file\t\tPARAMS ((struct file_info *));\n    destructor table has the same format, and begins at __DTOR_LIST__.  */\n \n static void\n-scan_prog_file (prog_name, which_pass)\n-     const char *prog_name;\n-     enum pass which_pass;\n+scan_prog_file (const char *prog_name, enum pass which_pass)\n {\n   char *obj;\n   mo_header_t hdr;\n@@ -3267,15 +3191,15 @@ scan_prog_file (prog_name, which_pass)\n }\n \n \f\n-/* Add a function table to the load commands to call a function\n-   on initiation or termination of the process.  */\n+/* Add a function table to the load commands to call a function on\n+   initiation or termination of the process.  The function takes HDR_P\n+   as pointer to the global header, LOAD_ARRAY as array of pointers to\n+   load commands, SYM as pointer to symbol entry and the fntc_type\n+   value TYPE.  */\n \n static void\n-add_func_table (hdr_p, load_array, sym, type)\n-     mo_header_t *hdr_p;\t\t/* pointer to global header */\n-     load_all_t *load_array;\t\t/* array of ptrs to load cmds */\n-     symbol_info_t *sym;\t\t/* pointer to symbol entry */\n-     int type;\t\t\t\t/* fntc_type value */\n+add_func_table (mo_header_t *hdr_p, load_all_t *load_array,\n+\t\tsymbol_info_t *sym, int type)\n {\n   /* Add a new load command.  */\n   int num_cmds = ++hdr_p->moh_n_load_cmds;\n@@ -3350,8 +3274,7 @@ add_func_table (hdr_p, load_array, sym, type)\n /* Print the global header for an OSF/rose object.  */\n \n static void\n-print_header (hdr_ptr)\n-     mo_header_t *hdr_ptr;\n+print_header (mo_header_t *hdr_ptr)\n {\n   fprintf (stderr, \"\\nglobal header:\\n\");\n   fprintf (stderr, \"\\tmoh_magic            = 0x%.8lx\\n\", hdr_ptr->moh_magic);\n@@ -3393,10 +3316,7 @@ print_header (hdr_ptr)\n /* Print a short summary of a load command.  */\n \n static void\n-print_load_command (load_hdr, offset, number)\n-     load_union_t *load_hdr;\n-     size_t offset;\n-     int number;\n+print_load_command (load_union_t *load_hdr, size_t offset, int number)\n {\n   mo_long_t type = load_hdr->hdr.ldci_cmd_type;\n   const char *type_str = (char *) 0;\n@@ -3460,8 +3380,7 @@ print_load_command (load_hdr, offset, number)\n /* Fatal error when {en,de}code_mach_o_header fails.  */\n \n static void\n-bad_header (status)\n-     int status;\n+bad_header (int status)\n {\n   switch (status)\n     {\n@@ -3477,13 +3396,12 @@ bad_header (status)\n }\n \n \f\n-/* Read a file into a memory buffer.  */\n+/* Read a file into a memory buffer. The file has filename NAME and is\n+   opened with the file descriptor FD for read or write according to\n+   RW.  */\n \n static struct file_info *\n-read_file (name, fd, rw)\n-     const char *name;\t\t/* filename */\n-     int fd;\t\t\t/* file descriptor */\n-     int rw;\t\t\t/* read/write */\n+read_file (const char *name, int fd, int rw)\n {\n   struct stat stat_pkt;\n   struct file_info *p = (struct file_info *) xcalloc (sizeof (struct file_info), 1);\n@@ -3545,8 +3463,7 @@ read_file (name, fd, rw)\n /* Do anything necessary to write a file back from memory.  */\n \n static void\n-end_file (ptr)\n-     struct file_info *ptr;\t/* file information block */\n+end_file (struct file_info *pt)\n {\n #ifdef USE_MMAP\n   if (ptr->use_mmap)"}, {"sha": "2434f169be5f76dce60489ed2e1cff4f2b305028", "filename": "gcc/collect2.h", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fcollect2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fcollect2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.h?ref=159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "patch": "@@ -1,5 +1,5 @@\n-/* Header file for collect/tlink routines.  \n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+/* Header file for collect/tlink routines.\n+   Copyright (C) 1998, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -21,30 +21,29 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_COLLECT2_H\n #define GCC_COLLECT2_H\n \n-extern void do_tlink PARAMS ((char **, char **));\n+extern void do_tlink (char **, char **);\n \n-extern void collect_execute PARAMS ((const char *, char **, const char *));\n+extern void collect_execute (const char *, char **, const char *);\n \n-extern void collect_exit PARAMS ((int)) ATTRIBUTE_NORETURN;\n+extern void collect_exit (int) ATTRIBUTE_NORETURN;\n \n-extern int collect_wait PARAMS ((const char *));\n+extern int collect_wait (const char *);\n \n-extern void dump_file PARAMS ((const char *));\n+extern void dump_file (const char *);\n \n-extern int file_exists PARAMS ((const char *));\n+extern int file_exists (const char *);\n \n extern const char *ldout;\n extern const char *c_file_name;\n extern struct obstack temporary_obstack;\n extern char *temporary_firstobj;\n extern int vflag, debug;\n \n-extern void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n-extern void error PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-extern void notice PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-extern void fatal PARAMS ((const char *, ...)) \n-  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void fatal_perror PARAMS ((const char *, ...))\n+extern void fancy_abort (void) ATTRIBUTE_NORETURN;\n+extern void error (const char *, ...) ATTRIBUTE_PRINTF_1;\n+extern void notice (const char *, ...) ATTRIBUTE_PRINTF_1;\n+extern void fatal (const char *, ...) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+extern void fatal_perror (const char *, ...)\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n \n #endif /* ! GCC_COLLECT2_H */"}, {"sha": "0aec9273b0ebaafa19a3604e3fd5ce019d8a8fd0", "filename": "gcc/conflict.c", "status": "modified", "additions": 18, "deletions": 45, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "patch": "@@ -1,5 +1,5 @@\n /* Register conflict graph computation routines.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2003 Free Software Foundation, Inc.\n    Contributed by CodeSourcery, LLC\n \n This file is part of GCC.\n@@ -114,17 +114,16 @@ struct conflict_graph_def\n    R1 and R2.  R1 is assumed to be smaller or equal to R2.  */\n #define CONFLICT_HASH_FN(R1, R2) ((R2) * ((R2) - 1) / 2 + (R1))\n \n-static hashval_t arc_hash\tPARAMS ((const void *));\n-static int arc_eq\t\tPARAMS ((const void *, const void *));\n-static int print_conflict\tPARAMS ((int, int, void *));\n-static void mark_reg\t\tPARAMS ((rtx, rtx, void *));\n+static hashval_t arc_hash (const void *);\n+static int arc_eq (const void *, const void *);\n+static int print_conflict (int, int, void *);\n+static void mark_reg (rtx, rtx, void *);\n \f\n /* Callback function to compute the hash value of an arc.  Uses\n    current_graph to locate the graph to which the arc belongs.  */\n \n static hashval_t\n-arc_hash (arcp)\n-     const void *arcp;\n+arc_hash (const void *arcp)\n {\n   const_conflict_graph_arc arc = (const_conflict_graph_arc) arcp;\n \n@@ -135,9 +134,7 @@ arc_hash (arcp)\n    table.  */\n \n static int\n-arc_eq (arcp1, arcp2)\n-     const void *arcp1;\n-     const void *arcp2;\n+arc_eq (const void *arcp1, const void *arcp2)\n {\n   const_conflict_graph_arc arc1 = (const_conflict_graph_arc) arcp1;\n   const_conflict_graph_arc arc2 = (const_conflict_graph_arc) arcp2;\n@@ -149,8 +146,7 @@ arc_eq (arcp1, arcp2)\n    registers.  */\n \n conflict_graph\n-conflict_graph_new (num_regs)\n-     int num_regs;\n+conflict_graph_new (int num_regs)\n {\n   conflict_graph graph\n     = (conflict_graph) xmalloc (sizeof (struct conflict_graph_def));\n@@ -175,8 +171,7 @@ conflict_graph_new (num_regs)\n /* Deletes a conflict graph.  */\n \n void\n-conflict_graph_delete (graph)\n-     conflict_graph graph;\n+conflict_graph_delete (conflict_graph graph)\n {\n   obstack_free (&graph->arc_obstack, NULL);\n   htab_delete (graph->arc_hash_table);\n@@ -189,10 +184,7 @@ conflict_graph_delete (graph)\n    in GRAPH, in which case it does nothing and returns zero.  */\n \n int\n-conflict_graph_add (graph, reg1, reg2)\n-     conflict_graph graph;\n-     int reg1;\n-     int reg2;\n+conflict_graph_add (conflict_graph graph, int reg1, int reg2)\n {\n   int smaller = MIN (reg1, reg2);\n   int larger = MAX (reg1, reg2);\n@@ -238,10 +230,7 @@ conflict_graph_add (graph, reg1, reg2)\n    and REG2.  */\n \n int\n-conflict_graph_conflict_p (graph, reg1, reg2)\n-     conflict_graph graph;\n-     int reg1;\n-     int reg2;\n+conflict_graph_conflict_p (conflict_graph graph, int reg1, int reg2)\n {\n   /* Build an arc to search for.  */\n   struct conflict_graph_arc_def arc;\n@@ -255,11 +244,8 @@ conflict_graph_conflict_p (graph, reg1, reg2)\n    passed back to ENUM_FN.  */\n \n void\n-conflict_graph_enum (graph, reg, enum_fn, extra)\n-     conflict_graph graph;\n-     int reg;\n-     conflict_graph_enum_fn enum_fn;\n-     void *extra;\n+conflict_graph_enum (conflict_graph graph, int reg,\n+\t\t     conflict_graph_enum_fn enum_fn, void *extra)\n {\n   conflict_graph_arc arc = graph->neighbor_heads[reg];\n   while (arc != NULL)\n@@ -282,10 +268,7 @@ conflict_graph_enum (graph, reg, enum_fn, extra)\n    conflict to GRAPH between x and TARGET.  */\n \n void\n-conflict_graph_merge_regs (graph, target, src)\n-     conflict_graph graph;\n-     int target;\n-     int src;\n+conflict_graph_merge_regs (conflict_graph graph, int target, int src)\n {\n   conflict_graph_arc arc = graph->neighbor_heads[src];\n \n@@ -328,10 +311,7 @@ struct print_context\n /* Callback function when enumerating conflicts during printing.  */\n \n static int\n-print_conflict (reg1, reg2, contextp)\n-     int reg1;\n-     int reg2;\n-     void *contextp;\n+print_conflict (int reg1, int reg2, void *contextp)\n {\n   struct print_context *context = (struct print_context *) contextp;\n   int reg;\n@@ -363,9 +343,7 @@ print_conflict (reg1, reg2, contextp)\n /* Prints the conflicts in GRAPH to FP.  */\n \n void\n-conflict_graph_print (graph, fp)\n-     conflict_graph graph;\n-     FILE *fp;\n+conflict_graph_print (conflict_graph graph, FILE *fp)\n {\n   int reg;\n   struct print_context context;\n@@ -394,10 +372,7 @@ conflict_graph_print (graph, fp)\n /* Callback function for note_stores.  */\n \n static void\n-mark_reg (reg, setter, data)\n-     rtx reg;\n-     rtx setter ATTRIBUTE_UNUSED;\n-     void *data;\n+mark_reg (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *data)\n {\n   regset set = (regset) data;\n \n@@ -441,9 +416,7 @@ mark_reg (reg, setter, data)\n    canonical regs instead.  */\n \n conflict_graph\n-conflict_graph_compute (regs, p)\n-     regset regs;\n-     partition p;\n+conflict_graph_compute (regset regs, partition p)\n {\n   conflict_graph graph = conflict_graph_new (max_reg_num ());\n   regset_head live_head;"}, {"sha": "a268f3e1146548fdc7ebffeb1865e9dc6ad89f32", "filename": "gcc/convert.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "patch": "@@ -39,8 +39,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    in other cases error is called.  */\n \n tree\n-convert_to_pointer (type, expr)\n-     tree type, expr;\n+convert_to_pointer (tree type, tree expr)\n {\n   if (integer_zerop (expr))\n     {\n@@ -75,8 +74,7 @@ convert_to_pointer (type, expr)\n \n /* Avoid any floating point extensions from EXP.  */\n tree\n-strip_float_extensions (exp)\n-     tree exp;\n+strip_float_extensions (tree exp)\n {\n   tree sub, expt, subt;\n \n@@ -124,8 +122,7 @@ strip_float_extensions (exp)\n    in other cases error is called.  */\n \n tree\n-convert_to_real (type, expr)\n-     tree type, expr;\n+convert_to_real (tree type, tree expr)\n {\n   enum built_in_function fcode = builtin_mathfn_code (expr);\n   tree itype = TREE_TYPE (expr);\n@@ -194,9 +191,9 @@ convert_to_real (type, expr)\n       if (fn)\n \t{\n \t  tree arg0 = strip_float_extensions (TREE_VALUE (TREE_OPERAND (expr,\n-\t\t\t\t\t  \t\t\t\t1)));\n+\t\t\t\t\t\t\t\t\t1)));\n \t  tree arglist = build_tree_list (NULL_TREE,\n-\t\t\t  \t\t  fold (convert_to_real (type, arg0)));\n+\t\t\t\t\t  fold (convert_to_real (type, arg0)));\n \n \t  return build_function_call_expr (fn, arglist);\n \t}\n@@ -285,8 +282,7 @@ convert_to_real (type, expr)\n    not in use in any existing structure.  */\n \n tree\n-convert_to_integer (type, expr)\n-     tree type, expr;\n+convert_to_integer (tree type, tree expr)\n {\n   enum tree_code ex_form = TREE_CODE (expr);\n   tree intype = TREE_TYPE (expr);\n@@ -483,7 +479,7 @@ convert_to_integer (type, expr)\n \t\t    /* Don't do unsigned arithmetic where signed was wanted,\n \t\t       or vice versa.\n \t\t       Exception: if both of the original operands were\n- \t\t       unsigned then we can safely do the work as unsigned.\n+\t\t       unsigned then we can safely do the work as unsigned.\n \t\t       Exception: shift operations take their type solely\n \t\t       from the first argument.\n \t\t       Exception: the LSHIFT_EXPR case above requires that\n@@ -558,7 +554,7 @@ convert_to_integer (type, expr)\n \t  /* It is sometimes worthwhile to push the narrowing down through\n \t     the conditional and never loses.  */\n \t  return fold (build (COND_EXPR, type, TREE_OPERAND (expr, 0),\n-\t\t\t      convert (type, TREE_OPERAND (expr, 1)), \n+\t\t\t      convert (type, TREE_OPERAND (expr, 1)),\n \t\t\t      convert (type, TREE_OPERAND (expr, 2))));\n \n \tdefault:\n@@ -593,11 +589,10 @@ convert_to_integer (type, expr)\n /* Convert EXPR to the complex type TYPE in the usual ways.  */\n \n tree\n-convert_to_complex (type, expr)\n-     tree type, expr;\n+convert_to_complex (tree type, tree expr)\n {\n   tree subtype = TREE_TYPE (type);\n-  \n+\n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {\n     case REAL_TYPE:\n@@ -649,8 +644,7 @@ convert_to_complex (type, expr)\n /* Convert EXPR to the vector type TYPE in the usual ways.  */\n \n tree\n-convert_to_vector (type, expr)\n-     tree type, expr;\n+convert_to_vector (tree type, tree expr)\n {\n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {"}, {"sha": "fe3bcbb8441b9aec923e04fde0ee1027aa01b30c", "filename": "gcc/convert.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fconvert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fconvert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.h?ref=159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "patch": "@@ -1,5 +1,5 @@\n /* Definition of functions in convert.c.\n-   Copyright (C) 1993, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -18,8 +18,8 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-extern tree convert_to_integer PARAMS ((tree, tree));\n-extern tree convert_to_pointer PARAMS ((tree, tree));\n-extern tree convert_to_real PARAMS ((tree, tree));\n-extern tree convert_to_complex PARAMS ((tree, tree));\n-extern tree convert_to_vector PARAMS ((tree, tree));\n+extern tree convert_to_integer (tree, tree);\n+extern tree convert_to_pointer (tree, tree);\n+extern tree convert_to_real (tree, tree);\n+extern tree convert_to_complex (tree, tree);\n+extern tree convert_to_vector (tree, tree);"}, {"sha": "7f0aa8da0128115cecbb3873598283e251bd2cd1", "filename": "gcc/coverage.c", "status": "modified", "additions": 85, "deletions": 95, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/159b3be1f3f7f43d37cbe60b4e8c46a113755b73/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=159b3be1f3f7f43d37cbe60b4e8c46a113755b73", "patch": "@@ -49,8 +49,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n struct function_list\n {\n-  struct function_list *next; \t /* next function */\n-  unsigned ident; \t\t /* function ident */\n+  struct function_list *next;\t /* next function */\n+  unsigned ident;\t\t /* function ident */\n   unsigned checksum;\t         /* function checksum */\n   unsigned n_ctrs[GCOV_COUNTERS];/* number of counters.  */\n };\n@@ -61,15 +61,15 @@ typedef struct counts_entry\n   /* We hash by  */\n   unsigned ident;\n   unsigned ctr;\n-  \n+\n   /* Store  */\n   unsigned checksum;\n   gcov_type *counts;\n   struct gcov_ctr_summary summary;\n \n   /* Workspace */\n   struct counts_entry *chain;\n-  \n+\n } counts_entry_t;\n \n static struct function_list *functions_head = 0;\n@@ -104,33 +104,30 @@ static const char *const ctr_merge_functions[GCOV_COUNTERS] = GCOV_MERGE_FUNCTIO\n static const char *const ctr_names[GCOV_COUNTERS] = GCOV_COUNTER_NAMES;\n \n /* Forward declarations.  */\n-static hashval_t htab_counts_entry_hash PARAMS ((const void *));\n-static int htab_counts_entry_eq PARAMS ((const void *, const void *));\n-static void htab_counts_entry_del PARAMS ((void *));\n-static void read_counts_file PARAMS ((void));\n-static unsigned compute_checksum PARAMS ((void));\n-static unsigned checksum_string PARAMS ((unsigned, const char *));\n-static tree build_fn_info_type PARAMS ((unsigned));\n-static tree build_fn_info_value PARAMS ((const struct function_list *, tree));\n-static tree build_ctr_info_type PARAMS ((void));\n-static tree build_ctr_info_value PARAMS ((unsigned, tree));\n-static tree build_gcov_info PARAMS ((void));\n-static void create_coverage PARAMS ((void));\n+static hashval_t htab_counts_entry_hash (const void *);\n+static int htab_counts_entry_eq (const void *, const void *);\n+static void htab_counts_entry_del (void *);\n+static void read_counts_file (void);\n+static unsigned compute_checksum (void);\n+static unsigned checksum_string (unsigned, const char *);\n+static tree build_fn_info_type (unsigned);\n+static tree build_fn_info_value (const struct function_list *, tree);\n+static tree build_ctr_info_type (void);\n+static tree build_ctr_info_value (unsigned, tree);\n+static tree build_gcov_info (void);\n+static void create_coverage (void);\n \n \f\n static hashval_t\n-htab_counts_entry_hash (of)\n-     const void *of;\n+htab_counts_entry_hash (const void *of)\n {\n   const counts_entry_t *entry = of;\n \n   return entry->ident * GCOV_COUNTERS + entry->ctr;\n }\n \n static int\n-htab_counts_entry_eq (of1, of2)\n-     const void *of1;\n-     const void *of2;\n+htab_counts_entry_eq (const void *of1, const void *of2)\n {\n   const counts_entry_t *entry1 = of1;\n   const counts_entry_t *entry2 = of2;\n@@ -139,8 +136,7 @@ htab_counts_entry_eq (of1, of2)\n }\n \n static void\n-htab_counts_entry_del (of)\n-     void *of;\n+htab_counts_entry_del (void *of)\n {\n   counts_entry_t *entry = of;\n \n@@ -151,7 +147,7 @@ htab_counts_entry_del (of)\n /* Read in the counts file, if available.  */\n \n static void\n-read_counts_file ()\n+read_counts_file (void)\n {\n   gcov_unsigned_t fn_ident = 0;\n   gcov_unsigned_t version, checksum = -1;\n@@ -163,7 +159,7 @@ read_counts_file ()\n \n   if (!gcov_open (da_file_name, 1))\n     return;\n-  \n+\n   if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n     {\n       warning (\"`%s' is not a gcov data file\", da_file_name);\n@@ -174,7 +170,7 @@ read_counts_file ()\n     {\n       char v[4], e[4];\n       gcov_unsigned_t required = GCOV_VERSION;\n-      \n+\n       for (ix = 4; ix--; required >>= 8, version >>= 8)\n \t{\n \t  v[ix] = version;\n@@ -185,15 +181,15 @@ read_counts_file ()\n       gcov_close ();\n       return;\n     }\n-  \n+\n   counts_hash = htab_create (10,\n \t\t\t     htab_counts_entry_hash, htab_counts_entry_eq,\n \t\t\t     htab_counts_entry_del);\n   while ((tag = gcov_read_unsigned ()))\n     {\n       gcov_unsigned_t length;\n       gcov_position_t offset;\n-      \n+\n       length = gcov_read_unsigned ();\n       offset = gcov_position ();\n       if (tag == GCOV_TAG_FUNCTION)\n@@ -206,7 +202,7 @@ read_counts_file ()\n \t\t new function begins a new set of program runs. We\n \t\t must unlink the summaried chain.  */\n \t      counts_entry_t *entry, *chain;\n-\t      \n+\n \t      for (entry = summaried; entry; entry = chain)\n \t\t{\n \t\t  chain = entry->chain;\n@@ -220,13 +216,13 @@ read_counts_file ()\n \t{\n \t  counts_entry_t *entry;\n \t  struct gcov_summary summary;\n-\t  \n+\n \t  gcov_read_summary (&summary);\n \t  seen_summary = 1;\n \t  for (entry = summaried; entry; entry = entry->chain)\n \t    {\n \t      struct gcov_ctr_summary *csum = &summary.ctrs[entry->ctr];\n-\t      \n+\n \t      entry->summary.runs += csum->runs;\n \t      entry->summary.sum_all += csum->sum_all;\n \t      if (entry->summary.run_max < csum->run_max)\n@@ -271,8 +267,8 @@ read_counts_file ()\n \n \t  if (elt.ctr < GCOV_COUNTERS_SUMMABLE\n \t      /* This should always be true for a just allocated entry,\n-\t     \t and always false for an existing one. Check this way, in\n-\t     \t case the gcov file is corrupt.  */\n+\t\t and always false for an existing one. Check this way, in\n+\t\t case the gcov file is corrupt.  */\n \t      && (!entry->chain || summaried != entry))\n \t    {\n \t      entry->chain = summaried;\n@@ -293,7 +289,7 @@ read_counts_file ()\n \t       da_file_name);\n       htab_delete (counts_hash);\n     }\n-  \n+\n   gcov_close ();\n }\n \n@@ -325,15 +321,15 @@ get_coverage_counts (unsigned counter, unsigned expected,\n \t       (DECL_ASSEMBLER_NAME (current_function_decl)));\n       return 0;\n     }\n-  \n+\n   if (expected != entry->summary.num\n       || compute_checksum () != entry->checksum)\n     {\n       warning (\"coverage mismatch for `%s'\", IDENTIFIER_POINTER\n \t       (DECL_ASSEMBLER_NAME (current_function_decl)));\n       return NULL;\n     }\n-  \n+\n   if (summary)\n     *summary = &entry->summary;\n \n@@ -348,15 +344,15 @@ coverage_counter_alloc (unsigned counter, unsigned num)\n {\n   if (no_coverage)\n     return 0;\n-  \n+\n   if (!num)\n     return 1;\n-  \n+\n   if (!ctr_labels[counter])\n     {\n       /* Generate and save a copy of this so it can be shared.  */\n       char buf[20];\n-      \n+\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", counter + 1);\n       ctr_labels[counter] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n     }\n@@ -399,21 +395,21 @@ checksum_string (unsigned chksum, const char *string)\n       for (ix = 8; ix--; value <<= 1)\n \t{\n \t  unsigned feedback;\n-\t  \n+\n \t  feedback = (value ^ chksum) & 0x80000000 ? 0x04c11db7 : 0;\n \t  chksum <<= 1;\n \t  chksum ^= feedback;\n \t}\n     }\n   while (*string++);\n-  \n+\n   return chksum;\n }\n \n /* Compute checksum for the current function.  We generate a CRC32.  */\n \n static unsigned\n-compute_checksum ()\n+compute_checksum (void)\n {\n   unsigned chksum = DECL_SOURCE_LINE (current_function_decl);\n \n@@ -430,17 +426,17 @@ compute_checksum ()\n    should be output.  */\n \n int\n-coverage_begin_output ()\n+coverage_begin_output (void)\n {\n   if (no_coverage)\n     return 0;\n-  \n+\n   if (!bbg_function_announced)\n     {\n       const char *file = DECL_SOURCE_FILE (current_function_decl);\n       unsigned line = DECL_SOURCE_LINE (current_function_decl);\n       unsigned long offset;\n-      \n+\n       if (!bbg_file_opened)\n \t{\n \t  if (!gcov_open (bbg_file_name, -1))\n@@ -452,7 +448,7 @@ coverage_begin_output ()\n \t    }\n \t  bbg_file_opened = 1;\n \t}\n-      \n+\n       /* Announce function */\n       offset = gcov_write_tag (GCOV_TAG_FUNCTION);\n       gcov_write_unsigned (current_function_funcdef_no + 1);\n@@ -472,25 +468,25 @@ coverage_begin_output ()\n    error has occurred.  Save function coverage counts.  */\n \n void\n-coverage_end_function ()\n+coverage_end_function (void)\n {\n   unsigned i;\n-  \n+\n   if (bbg_file_opened > 1 && gcov_is_error ())\n-    {\t\n+    {\n       warning (\"error writing `%s'\", bbg_file_name);\n       bbg_file_opened = -1;\n     }\n \n   if (fn_ctr_mask)\n     {\n       struct function_list *item;\n-      \n+\n       item = xmalloc (sizeof (struct function_list));\n-      \n+\n       *functions_tail = item;\n       functions_tail = &item->next;\n-\t\n+\n       item->next = 0;\n       item->ident = current_function_funcdef_no + 1;\n       item->checksum = compute_checksum ();\n@@ -509,13 +505,12 @@ coverage_end_function ()\n /* Creates the gcov_fn_info RECORD_TYPE.  */\n \n static tree\n-build_fn_info_type (counters)\n-     unsigned counters;\n+build_fn_info_type (unsigned int counters)\n {\n   tree type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n   tree field, fields;\n   tree array_type;\n-  \n+\n   /* ident */\n   fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n \n@@ -526,7 +521,7 @@ build_fn_info_type (counters)\n \n   array_type = build_index_type (build_int_2 (counters - 1, 0));\n   array_type = build_array_type (unsigned_type_node, array_type);\n-  \n+\n   /* counters */\n   field = build_decl (FIELD_DECL, NULL_TREE, array_type);\n   TREE_CHAIN (field) = fields;\n@@ -542,51 +537,49 @@ build_fn_info_type (counters)\n    RECORD_TYPE.  */\n \n static tree\n-build_fn_info_value (function, type)\n-     const struct function_list *function;\n-     tree type;\n+build_fn_info_value (const struct function_list *function, tree type)\n {\n   tree value = NULL_TREE;\n   tree fields = TYPE_FIELDS (type);\n   unsigned ix;\n   tree array_value = NULL_TREE;\n-  \n+\n   /* ident */\n   value = tree_cons (fields,\n \t\t     convert (unsigned_intSI_type_node,\n \t\t\t      build_int_2 (function->ident, 0)),\n \t\t     value);\n   fields = TREE_CHAIN (fields);\n-  \n+\n   /* checksum */\n   value = tree_cons (fields,\n \t\t     convert (unsigned_intSI_type_node,\n \t\t\t      build_int_2 (function->checksum, 0)),\n \t\t     value);\n   fields = TREE_CHAIN (fields);\n-  \n+\n   /* counters */\n   for (ix = 0; ix != GCOV_COUNTERS; ix++)\n     if (prg_ctr_mask & (1 << ix))\n       {\n \ttree counters = convert (unsigned_type_node,\n \t\t\t\t build_int_2 (function->n_ctrs[ix], 0));\n-\t\n+\n \tarray_value = tree_cons (NULL_TREE, counters, array_value);\n       }\n-  \n+\n   array_value = build_constructor (TREE_TYPE (fields), nreverse (array_value));\n   value = tree_cons (fields, array_value, value);\n \n   value = build_constructor (type, nreverse (value));\n-  \n+\n   return value;\n }\n \n /* Creates the gcov_ctr_info RECORD_TYPE.  */\n \n static tree\n-build_ctr_info_type ()\n+build_ctr_info_type (void)\n {\n   tree type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n   tree field, fields = NULL_TREE;\n@@ -623,9 +616,7 @@ build_ctr_info_type ()\n    RECORD_TYPE.  */\n \n static tree\n-build_ctr_info_value (counter, type)\n-     unsigned counter;\n-     tree type;\n+build_ctr_info_value (unsigned int counter, tree type)\n {\n   tree value = NULL_TREE;\n   tree fields = TYPE_FIELDS (type);\n@@ -641,16 +632,16 @@ build_ctr_info_value (counter, type)\n   if (prg_n_ctrs[counter])\n     {\n       tree array_type, array;\n-      \n+\n       array_type = build_index_type (build_int_2 (prg_n_ctrs[counter] - 1, 0));\n       array_type = build_array_type (TREE_TYPE (TREE_TYPE (fields)),\n \t\t\t\t     array_type);\n-      \n+\n       array = build (VAR_DECL, array_type, NULL_TREE, NULL_TREE);\n       TREE_STATIC (array) = 1;\n       DECL_NAME (array) = get_identifier (XSTR (ctr_labels[counter], 0));\n       assemble_variable (array, 0, 0, 0);\n-      \n+\n       value = tree_cons (fields,\n \t\t\t build1 (ADDR_EXPR, TREE_TYPE (fields), array),\n \t\t\t value);\n@@ -671,15 +662,15 @@ build_ctr_info_value (counter, type)\n \t\t     value);\n \n   value = build_constructor (type, nreverse (value));\n-  \n+\n   return value;\n }\n \n /* Creates the gcov_info RECORD_TYPE and initializer for it. Returns a\n    CONSTRUCTOR.  */\n \n static tree\n-build_gcov_info ()\n+build_gcov_info (void)\n {\n   unsigned n_ctr_types, ix;\n   tree type, const_type;\n@@ -694,29 +685,29 @@ build_gcov_info ()\n   unsigned n_fns;\n   const struct function_list *fn;\n   tree string_type;\n-  \n+\n   /* Count the number of active counters.  */\n   for (n_ctr_types = 0, ix = 0; ix != GCOV_COUNTERS; ix++)\n     if (prg_ctr_mask & (1 << ix))\n       n_ctr_types++;\n-  \n+\n   type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n   const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n-  \n+\n   /* Version ident */\n   field = build_decl (FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field, convert (unsigned_intSI_type_node,\n \t\t\t\t     build_int_2 (GCOV_VERSION, 0)),\n \t\t     value);\n-  \n+\n   /* next -- NULL */\n   field = build_decl (FIELD_DECL, NULL_TREE, build_pointer_type (const_type));\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field, null_pointer_node, value);\n-  \n+\n   /* Filename */\n   string_type = build_pointer_type (build_qualified_type (char_type_node,\n \t\t\t\t\t\t    TYPE_QUAL_CONST));\n@@ -736,7 +727,7 @@ build_gcov_info ()\n \t\t\t    build_index_type (build_int_2 (filename_len, 0)));\n   value = tree_cons (field, build1 (ADDR_EXPR, string_type, filename_string),\n \t\t     value);\n-  \n+\n   /* Build the fn_info type and initializer.  */\n   fn_info_type = build_fn_info_type (n_ctr_types);\n   fn_info_ptr_type = build_pointer_type (build_qualified_type\n@@ -751,21 +742,21 @@ build_gcov_info ()\n \n       array_type = build_index_type (build_int_2 (n_fns - 1, 0));\n       array_type = build_array_type (fn_info_type, array_type);\n-      \n+\n       fn_info_value = build_constructor (array_type, nreverse (fn_info_value));\n       fn_info_value = build1 (ADDR_EXPR, fn_info_ptr_type, fn_info_value);\n     }\n   else\n     fn_info_value = null_pointer_node;\n-  \n+\n   /* number of functions */\n   field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field,\n \t\t     convert (unsigned_type_node, build_int_2 (n_fns, 0)),\n \t\t     value);\n-  \n+\n   /* fn_info table */\n   field = build_decl (FIELD_DECL, NULL_TREE, fn_info_ptr_type);\n   TREE_CHAIN (field) = fields;\n@@ -780,7 +771,7 @@ build_gcov_info ()\n \t\t     convert (unsigned_type_node,\n \t\t\t      build_int_2 (prg_ctr_mask, 0)),\n \t\t     value);\n-  \n+\n   /* counters */\n   ctr_info_type = build_ctr_info_type ();\n   ctr_info_ary_type = build_index_type (build_int_2 (n_ctr_types, 0));\n@@ -797,11 +788,11 @@ build_gcov_info ()\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field, ctr_info_value, value);\n-  \n+\n   finish_builtin_struct (type, \"__gcov_info\", fields, NULL_TREE);\n \n   value = build_constructor (type, nreverse (value));\n-  \n+\n   return value;\n }\n \n@@ -810,7 +801,7 @@ build_gcov_info ()\n    gcov-io.h.  Write out the constructor to call __gcov_init.  */\n \n static void\n-create_coverage ()\n+create_coverage (void)\n {\n   tree gcov_info, gcov_info_value;\n   char name[20];\n@@ -819,10 +810,10 @@ create_coverage ()\n   rtx gcov_info_address;\n \n   no_coverage = 1; /* Disable any further coverage.  */\n-  \n+\n   if (!prg_ctr_mask)\n     return;\n-  \n+\n   gcov_info_value = build_gcov_info ();\n \n   gcov_info = build (VAR_DECL, TREE_TYPE (gcov_info_value),\n@@ -832,7 +823,7 @@ create_coverage ()\n   TREE_STATIC (gcov_info) = 1;\n   ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n   DECL_NAME (gcov_info) = get_identifier (name);\n-  \n+\n   /* Build structure.  */\n   assemble_variable (gcov_info, 0, 0, 0);\n \n@@ -884,16 +875,15 @@ create_coverage ()\n    of graph file.  */\n \n void\n-coverage_init (filename)\n-  const char *filename;\n+coverage_init (const char *filename)\n {\n   int len = strlen (filename);\n \n   /* Name of da file.  */\n   da_file_name = (char *) xmalloc (len + strlen (GCOV_DATA_SUFFIX) + 1);\n   strcpy (da_file_name, filename);\n   strcat (da_file_name, GCOV_DATA_SUFFIX);\n-  \n+\n   /* Name of bbg file.  */\n   bbg_file_name = (char *) xmalloc (len + strlen (GCOV_GRAPH_SUFFIX) + 1);\n   strcpy (bbg_file_name, filename);\n@@ -906,13 +896,13 @@ coverage_init (filename)\n    variables and constructor.  */\n \n void\n-coverage_finish ()\n+coverage_finish (void)\n {\n   create_coverage ();\n   if (bbg_file_opened)\n     {\n       int error = gcov_close ();\n-      \n+\n       if (error)\n \tunlink (bbg_file_name);\n #if SELF_COVERAGE"}]}