{"sha": "2c3fcba6dc56f848a07332ff005e2db9054dca26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMzZmNiYTZkYzU2Zjg0OGEwNzMzMmZmMDA1ZTJkYjkwNTRkY2EyNg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-09-10T22:34:03Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-09-10T22:34:03Z"}, "message": "cpplex.c (parse_identifier): Fast-path optimize.\n\n\t* cpplex.c (parse_identifier): Fast-path optimize.  Avoid\n\tcopying identifier when we're just going to throw it away.\n\t(parse_identifier_slow): New routine to handle abnormal cases.\n\t(_cpp_lex_token): Update call site.\n\n\t* hashtable.c (ht_lookup): Don't assume that the string we've\n\tbeen given is NUL-terminated.\n\t* system.h: #define __builtin_expect(a, b) to (a) if not\n\tGCC >=3.0.\n\nFrom-SVN: r45529", "tree": {"sha": "68c8a29210b56a578f8917368423b34eaeea5d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68c8a29210b56a578f8917368423b34eaeea5d60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c3fcba6dc56f848a07332ff005e2db9054dca26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c3fcba6dc56f848a07332ff005e2db9054dca26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c3fcba6dc56f848a07332ff005e2db9054dca26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c3fcba6dc56f848a07332ff005e2db9054dca26/comments", "author": null, "committer": null, "parents": [{"sha": "b210ec460ed82323e4a8fea320bf7a2c241e4369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b210ec460ed82323e4a8fea320bf7a2c241e4369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b210ec460ed82323e4a8fea320bf7a2c241e4369"}], "stats": {"total": 155, "additions": 111, "deletions": 44}, "files": [{"sha": "fed56b5f5d368fdf0a66d158f46a4e57eaa87ce5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c3fcba6dc56f848a07332ff005e2db9054dca26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c3fcba6dc56f848a07332ff005e2db9054dca26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c3fcba6dc56f848a07332ff005e2db9054dca26", "patch": "@@ -1,3 +1,15 @@\n+2001-09-10  Zack Weinberg  <zackw@panix.com>\n+\n+\t* cpplex.c (parse_identifier): Fast-path optimize.  Avoid\n+\tcopying identifier when we're just going to throw it away.\n+\t(parse_identifier_slow): New routine to handle abnormal cases.\n+\t(_cpp_lex_token): Update call site.\n+\n+\t* hashtable.c (ht_lookup): Don't assume that the string we've\n+\tbeen given is NUL-terminated.\n+\t* system.h: #define __builtin_expect(a, b) to (a) if not\n+\tGCC >=3.0.\n+\n 2001-09-10  Michael Meissner  <meissner@redhat.com>\n \n \t* config.gcc (sparc64-*-solaris2): Add alias to be compatible with\n@@ -16,7 +28,7 @@ Mon Sep 10 16:26:44 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* dwarf2out.c (incomplete_types, decl_scope_table): Make them\n \tinto varray's and register them as roots with the garbage\n-\tcollector so they are not collected too soon.  \n+\tcollector so they are not collected too soon.\n \n Mon Sep 10 14:21:26 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n@@ -31,7 +43,7 @@ Mon Sep 10 14:21:26 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \t(basic_block_for_insn, label_value_list): Move from flow.c; make global.\n \t(n_basic_blocks, n_edges, basic_block_info, entry_exit_blocks,\n \tinit_flow, clear_edges, can_delete_note_p, can_delete_label_p,\n-\tflow_delete_insn, flow_delete_insn_chain, create_basic_block, \n+\tflow_delete_insn, flow_delete_insn_chain, create_basic_block,\n \texpunge_block, flow_delete_block, compute_bb_for_insn,\n \tupdate_bb_for_insn, set_block_for_insn, set_block_for_new_insns,\n \tmake_edge, remove_edge, redirect_edge_succ, redirect_edge_succ_nodup,\n@@ -40,7 +52,7 @@ Mon Sep 10 14:21:26 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \tredirect_edge_and_branch, redirect_edge_and_branch_force,\n \ttidy_fallthru_edge, tidy_fallthru_edges, back_edge_of_syntactic_loop_p,\n \tsplit_edge, insert_insn_on_edge, commit_one_edge_insertion,\n-\tcommit_edge_insertions, dump_flow_info, debug_flow_info, \n+\tcommit_edge_insertions, dump_flow_info, debug_flow_info,\n \tdump_edge_info, dump_bb, debug_bb, debug_bb_n, print_rtl_with_bb,\n \tverify_flow_info, purge_dead_edges, purge_all_dead_edges):\n \tMove here from flow.c"}, {"sha": "071cdca0c4dcfbe52d51ae2d985cf4cf90c4bd53", "filename": "gcc/cpplex.c", "status": "modified", "additions": 88, "deletions": 40, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c3fcba6dc56f848a07332ff005e2db9054dca26/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c3fcba6dc56f848a07332ff005e2db9054dca26/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=2c3fcba6dc56f848a07332ff005e2db9054dca26", "patch": "@@ -88,7 +88,9 @@ static int skip_block_comment PARAMS ((cpp_reader *));\n static int skip_line_comment PARAMS ((cpp_reader *));\n static void adjust_column PARAMS ((cpp_reader *));\n static void skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n-static cpp_hashnode *parse_identifier PARAMS ((cpp_reader *, cppchar_t));\n+static cpp_hashnode *parse_identifier PARAMS ((cpp_reader *));\n+static cpp_hashnode *parse_identifier_slow PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t    const U_CHAR *));\n static void parse_number PARAMS ((cpp_reader *, cpp_string *, cppchar_t, int));\n static int unescaped_terminator_p PARAMS ((cpp_reader *, const U_CHAR *));\n static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n@@ -470,40 +472,101 @@ name_p (pfile, string)\n   return 1;  \n }\n \n-/* Parse an identifier, skipping embedded backslash-newlines.\n-   Calculate the hash value of the token while parsing, for improved\n-   performance.  The hashing algorithm *must* match cpp_lookup().  */\n+/* Parse an identifier, skipping embedded backslash-newlines.  This is\n+   a critical inner loop.  The common case is an identifier which has\n+   not been split by backslash-newline, does not contain a dollar\n+   sign, and has already been scanned (roughly 10:1 ratio of\n+   seen:unseen identifiers in normal code; the distribution is\n+   Poisson-like).  Second most common case is a new identifier, not\n+   split and no dollar sign.  The other possibilities are rare and\n+   have been relegated to parse_identifier_slow.  */\n \n static cpp_hashnode *\n-parse_identifier (pfile, c)\n+parse_identifier (pfile)\n      cpp_reader *pfile;\n-     cppchar_t c;\n {\n   cpp_hashnode *result;\n+  const U_CHAR *cur, *rlimit;\n+\n+  /* Fast-path loop.  Skim over a normal identifier.\n+     N.B. ISIDNUM does not include $.  */\n+  cur    = pfile->buffer->cur - 1;\n+  rlimit = pfile->buffer->rlimit;\n+  do\n+    cur++;\n+  while (cur < rlimit && ISIDNUM (*cur));\n+\n+  /* Check for slow-path cases.  */\n+  if (cur < rlimit && (*cur == '?' || *cur == '\\\\' || *cur == '$'))\n+    result = parse_identifier_slow (pfile, cur);\n+  else\n+    {\n+      const U_CHAR *base = pfile->buffer->cur - 1;\n+      result = (cpp_hashnode *)\n+\tht_lookup (pfile->hash_table, base, cur - base, HT_ALLOC);\n+      pfile->buffer->cur = cur;\n+    }\n+\n+  /* Rarely, identifiers require diagnostics when lexed.\n+     XXX Has to be forced out of the fast path.  */\n+  if (__builtin_expect ((result->flags & NODE_DIAGNOSTIC)\n+\t\t\t&& !pfile->state.skipping, 0))\n+    {\n+      /* It is allowed to poison the same identifier twice.  */\n+      if ((result->flags & NODE_POISONED) && !pfile->state.poisoned_ok)\n+\tcpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\",\n+\t\t   NODE_NAME (result));\n+\n+      /* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n+\t replacement list of a variadic macro.  */\n+      if (result == pfile->spec_nodes.n__VA_ARGS__\n+\t  && !pfile->state.va_args_ok)\n+\tcpp_pedwarn (pfile,\n+\t\"__VA_ARGS__ can only appear in the expansion of a C99 variadic macro\");\n+    }\n+\n+  return result;\n+}\n+\n+/* Slow path.  This handles identifiers which have been split, and\n+   identifiers which contain dollar signs.  The part of the identifier\n+   from PFILE->buffer->cur-1 to CUR has already been scanned.  */\n+static cpp_hashnode *\n+parse_identifier_slow (pfile, cur)\n+     cpp_reader *pfile;\n+     const U_CHAR *cur;\n+{\n   cpp_buffer *buffer = pfile->buffer;\n-  unsigned int saw_dollar = 0, len;\n+  const U_CHAR *base = buffer->cur - 1;\n   struct obstack *stack = &pfile->hash_table->stack;\n+  unsigned int c, saw_dollar = 0, len;\n+\n+  /* Copy the part of the token which is known to be okay.  */\n+  obstack_grow (stack, base, cur - base);\n \n+  /* Now process the part which isn't.  We are looking at one of\n+     '$', '\\\\', or '?' on entry to this loop.  */\n+  c = *cur++;\n+  buffer->cur = cur;\n   do\n     {\n-      do\n-\t{\n-\t  obstack_1grow (stack, c);\n+      while (is_idchar (c))\n+        {\n+          obstack_1grow (stack, c);\n \n-\t  if (c == '$')\n-\t    saw_dollar++;\n+          if (c == '$')\n+            saw_dollar++;\n \n-\t  c = EOF;\n-\t  if (buffer->cur == buffer->rlimit)\n-\t    break;\n+          c = EOF;\n+          if (buffer->cur == buffer->rlimit)\n+            break;\n \n-\t  c = *buffer->cur++;\n-\t}\n-      while (is_idchar (c));\n+          c = *buffer->cur++;\n+        }\n \n       /* Potential escaped newline?  */\n       if (c != '?' && c != '\\\\')\n-\tbreak;\n+        break;\n       c = skip_escaped_newlines (pfile, c);\n     }\n   while (is_idchar (c));\n@@ -521,26 +584,8 @@ parse_identifier (pfile, c)\n   len = obstack_object_size (stack);\n   obstack_1grow (stack, '\\0');\n \n-  /* This routine commits the memory if necessary.  */\n-  result = (cpp_hashnode *)\n+  return (cpp_hashnode *)\n     ht_lookup (pfile->hash_table, obstack_finish (stack), len, HT_ALLOCED);\n-\n-  /* Some identifiers require diagnostics when lexed.  */\n-  if (result->flags & NODE_DIAGNOSTIC && !pfile->state.skipping)\n-    {\n-      /* It is allowed to poison the same identifier twice.  */\n-      if ((result->flags & NODE_POISONED) && !pfile->state.poisoned_ok)\n-\tcpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\",\n-\t\t   NODE_NAME (result));\n-\n-      /* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n-\t replacement list of a variadic macro.  */\n-      if (result == pfile->spec_nodes.n__VA_ARGS__\n-\t  && !pfile->state.va_args_ok)\n-\tcpp_pedwarn (pfile, \"__VA_ARGS__ can only appear in the expansion of a C99 variadic macro\");\n-    }\n-\n-  return result;\n }\n \n /* Parse a number, skipping embedded backslash-newlines.  */\n@@ -1003,14 +1048,17 @@ _cpp_lex_token (pfile, result)\n     case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n     case 'Y': case 'Z':\n       result->type = CPP_NAME;\n-      result->val.node = parse_identifier (pfile, c);\n+      result->val.node = parse_identifier (pfile);\n \n       /* 'L' may introduce wide characters or strings.  */\n       if (result->val.node == pfile->spec_nodes.n_L)\n \t{\n-\t  c = buffer->read_ahead; /* For make_string.  */\n+\t  c = buffer->read_ahead;\n+\t  if (c == EOF && buffer->cur < buffer->rlimit)\n+\t    c = *buffer->cur;\n \t  if (c == '\\'' || c == '\"')\n \t    {\n+\t      buffer->cur++;\n \t      ACCEPT_CHAR (c == '\"' ? CPP_WSTRING: CPP_WCHAR);\n \t      goto make_string;\n \t    }"}, {"sha": "bd2b13727bb84dadb7edb6d2cc30949ebbe2bc9f", "filename": "gcc/hashtable.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c3fcba6dc56f848a07332ff005e2db9054dca26/gcc%2Fhashtable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c3fcba6dc56f848a07332ff005e2db9054dca26/gcc%2Fhashtable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.c?ref=2c3fcba6dc56f848a07332ff005e2db9054dca26", "patch": "@@ -162,7 +162,7 @@ ht_lookup (table, str, len, insert)\n \n   HT_LEN (node) = len;\n   if (insert == HT_ALLOC)\n-    HT_STR (node) = obstack_copy (&table->stack, str, len + 1);\n+    HT_STR (node) = obstack_copy0 (&table->stack, str, len);\n   else\n     HT_STR (node) = str;\n "}, {"sha": "7938fb6bdf29efcba8446e8bf6d7205183201c48", "filename": "gcc/system.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c3fcba6dc56f848a07332ff005e2db9054dca26/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c3fcba6dc56f848a07332ff005e2db9054dca26/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=2c3fcba6dc56f848a07332ff005e2db9054dca26", "patch": "@@ -490,6 +490,13 @@ extern void abort PARAMS ((void));\n #endif /* ! __FUNCTION__ */\n #endif\n \n+/* __builtin_expect(A, B) evaluates to A, but notifies the compiler that\n+   the most likely value of A is B.  This feature was added at some point\n+   between 2.95 and 3.0.  Let's use 3.0 as the lower bound for now.  */\n+#if (GCC_VERSION < 3000)\n+#define __builtin_expect(a, b) (a)\n+#endif\n+\n /* Provide some sort of boolean type.  We use stdbool.h if it's\n   available.  This must be after all inclusion of system headers,\n   as some of them will mess us up.  */"}]}