{"sha": "6b02a4997be30a1cb81a573ea3abc68802f10b2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIwMmE0OTk3YmUzMGExY2I4MWE1NzNlYTNhYmM2ODgwMmYxMGIyYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-06-02T19:41:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-06-02T19:41:31Z"}, "message": "cgraph.c (cgraph_node): Maintain master clones.\n\n\n\t* cgraph.c (cgraph_node): Maintain master clones.\n\t(cgraph_remove_node): Likewise.\n\t(availability_names): New static variable.\n\t(dump_cgraph_node): Dump availability.\n\t(dump_cgraph_varpool_node): Likewise.\n\t(cgraph_is_master_clone, cgraph_master_clone,\n\tcgraph_function_body_availability,\n\tcgraph_variable_initializer_availability): New functions.\n\t* cgraph.h (availability): New enum.\n\t(struct cgraph_node): Add master_clone.\n\t(cgraph_is_master_clone, cgraph_master_clone,\n\tcgraph_function_body_availability,\n\tcgraph_variable_initializer_availability): Declare.\n\t* cgraphunit.c (cgraph_expand_function): Setcgraph_function_flags_ready.\n\t(cgraph_remove_unreachable_nodes): Remove unreachable nodes.\n\t* ipa-inline.c (cgraph_decide_inlining): Do not call\n\tcgraph_remove_unreachable_nodes.\n\nFrom-SVN: r100507", "tree": {"sha": "581a728808f9ec389dc440901acdffc5a28d346f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/581a728808f9ec389dc440901acdffc5a28d346f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b02a4997be30a1cb81a573ea3abc68802f10b2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b02a4997be30a1cb81a573ea3abc68802f10b2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b02a4997be30a1cb81a573ea3abc68802f10b2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b02a4997be30a1cb81a573ea3abc68802f10b2a/comments", "author": null, "committer": null, "parents": [{"sha": "04b0eed045fd952d1e8889dd06f07563ce16160b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04b0eed045fd952d1e8889dd06f07563ce16160b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04b0eed045fd952d1e8889dd06f07563ce16160b"}], "stats": {"total": 173, "additions": 164, "deletions": 9}, "files": [{"sha": "407911ec2f7cd98dc262fa825b1da510aadc188e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b02a4997be30a1cb81a573ea3abc68802f10b2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b02a4997be30a1cb81a573ea3abc68802f10b2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b02a4997be30a1cb81a573ea3abc68802f10b2a", "patch": "@@ -1,5 +1,23 @@\n 2005-06-02  Jan Hubicka  <jh@suse.cz>\n \n+\t* cgraph.c (cgraph_node): Maintain master clones.\n+\t(cgraph_remove_node): Likewise.\n+\t(availability_names): New static variable.\n+\t(dump_cgraph_node): Dump availability.\n+\t(dump_cgraph_varpool_node): Likewise.\n+\t(cgraph_is_master_clone, cgraph_master_clone,\n+\tcgraph_function_body_availability,\n+\tcgraph_variable_initializer_availability): New functions.\n+\t* cgraph.h (availability): New enum.\n+\t(struct cgraph_node): Add master_clone.\n+\t(cgraph_is_master_clone, cgraph_master_clone,\n+\tcgraph_function_body_availability,\n+\tcgraph_variable_initializer_availability): Declare.\n+\t* cgraphunit.c (cgraph_expand_function): Setcgraph_function_flags_ready.\n+\t(cgraph_remove_unreachable_nodes): Remove unreachable nodes.\n+\t* ipa-inline.c (cgraph_decide_inlining): Do not call\n+\tcgraph_remove_unreachable_nodes.\n+\n \t* cgraphunit.c (cgraph_function_and_variable_visibility): Fix typo in\n \tprevious patch.\n "}, {"sha": "6af75e12dcffe3ca28b109494ab8b6dfe67624c1", "filename": "gcc/cgraph.c", "status": "modified", "additions": 109, "deletions": 2, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b02a4997be30a1cb81a573ea3abc68802f10b2a/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b02a4997be30a1cb81a573ea3abc68802f10b2a/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6b02a4997be30a1cb81a573ea3abc68802f10b2a", "patch": "@@ -192,7 +192,12 @@ cgraph_node (tree decl)\n   slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key, INSERT);\n \n   if (*slot)\n-    return *slot;\n+    {\n+      node = *slot;\n+      if (!node->master_clone)\n+\tnode->master_clone = node;\n+      return node;\n+    }\n \n   node = cgraph_create_node ();\n   node->decl = decl;\n@@ -202,6 +207,7 @@ cgraph_node (tree decl)\n       node->origin = cgraph_node (DECL_CONTEXT (decl));\n       node->next_nested = node->origin->nested;\n       node->origin->nested = node;\n+      node->master_clone = node;\n     }\n   return node;\n }\n@@ -436,7 +442,14 @@ cgraph_remove_node (struct cgraph_node *node)\n     {\n       if (node->next_clone)\n       {\n-\t*slot = node->next_clone;\n+\tstruct cgraph_node *new_node = node->next_clone;\n+\tstruct cgraph_node *n;\n+\n+\t/* Make the next clone be the master clone */\n+\tfor (n = new_node; n; n = n->next_clone) \n+\t  n->master_clone = new_node;\n+\t\n+\t*slot = new_node;\n \tnode->next_clone->prev_clone = NULL;\n       }\n       else\n@@ -553,6 +566,10 @@ cgraph_varpool_node_name (struct cgraph_varpool_node *node)\n   return lang_hooks.decl_printable_name (node->decl, 2);\n }\n \n+/* Names used to print out the availability enum.  */\n+static const char * const availability_names[] = \n+  {\"unset\", \"not_available\", \"overwrittable\", \"available\", \"local\"};\n+\n /* Dump given cgraph node.  */\n void\n dump_cgraph_node (FILE *f, struct cgraph_node *node)\n@@ -563,6 +580,11 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" (inline copy in %s/%i)\",\n \t     cgraph_node_name (node->global.inlined_to),\n \t     node->global.inlined_to->uid);\n+  if (cgraph_function_flags_ready)\n+    fprintf (f, \" availability:%s\", \n+\t     availability_names [cgraph_function_body_availability (node)]);\n+  if (node->master_clone && node->master_clone->uid != node->uid)\n+    fprintf (f, \"(%i)\", node->master_clone->uid);\n   if (node->count)\n     fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\",\n \t     (HOST_WIDEST_INT)node->count);\n@@ -614,6 +636,11 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t       edge->callee->uid);\n       if (!edge->inline_failed)\n \tfprintf(f, \"(inlined) \");\n+      if (edge->count)\n+\tfprintf (f, \"(\"HOST_WIDEST_INT_PRINT_DEC\"x) \",\n+\t\t (HOST_WIDEST_INT)edge->count);\n+      if (edge->loop_nest)\n+\tfprintf (f, \"(nested in %i loops) \", edge->loop_nest);\n     }\n   fprintf (f, \"\\n\");\n }\n@@ -635,6 +662,7 @@ void\n dump_cgraph_varpool_node (FILE *f, struct cgraph_varpool_node *node)\n {\n   fprintf (f, \"%s:\", cgraph_varpool_node_name (node));\n+  fprintf (f, \" availability:%s\", availability_names [cgraph_variable_initializer_availability (node)]);\n   if (DECL_INITIAL (node->decl))\n     fprintf (f, \" initialized\");\n   if (node->needed)\n@@ -886,6 +914,7 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int loop_nest)\n   new->local = n->local;\n   new->global = n->global;\n   new->rtl = n->rtl;\n+  new->master_clone = n->master_clone;\n   new->count = count;\n   if (n->count)\n     count_scale = new->count * REG_BR_PROB_BASE / n->count;\n@@ -905,6 +934,28 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int loop_nest)\n   return new;\n }\n \n+/* Return true if N is an master_clone, (see cgraph_master_clone).  */\n+\n+bool\n+cgraph_is_master_clone (struct cgraph_node *n)\n+{\n+  return (n == cgraph_master_clone (n));\n+}\n+\n+struct cgraph_node *\n+cgraph_master_clone (struct cgraph_node *n)\n+{\n+  enum availability avail = cgraph_function_body_availability (n);\n+   \n+  if (avail == AVAIL_NOT_AVAILABLE || avail == AVAIL_OVERWRITABLE)\n+    return NULL;\n+\n+  if (!n->master_clone) \n+    n->master_clone = cgraph_node (n->decl);\n+  \n+  return n->master_clone;\n+}\n+\n /* NODE is no longer nested function; update cgraph accordingly.  */\n void\n cgraph_unnest_node (struct cgraph_node *node)\n@@ -917,4 +968,60 @@ cgraph_unnest_node (struct cgraph_node *node)\n   *node2 = node->next_nested;\n   node->origin = NULL;\n }\n+\n+/* Return function availability.  See cgraph.h for description of individual\n+   return values.  */\n+enum availability\n+cgraph_function_body_availability (struct cgraph_node *node)\n+{\n+  enum availability avail;\n+  gcc_assert (cgraph_function_flags_ready);\n+  if (!node->local.finalized)\n+    avail = AVAIL_NOT_AVAILABLE;\n+  else if (node->local.local)\n+    avail = AVAIL_LOCAL;\n+  else if (node->local.externally_visible)\n+    avail = AVAIL_AVAILABLE;\n+\n+  /* If the function can be overwritten, return OVERWRITABLE.  Take\n+     care at least of two notable extensions - the COMDAT functions\n+     used to share template instantiations in C++ (this is symmetric\n+     to code cp_cannot_inline_tree_fn and probably shall be shared and\n+     the inlinability hooks completelly elliminated).\n+\n+     ??? Does the C++ one definition rule allow us to always return\n+     AVAIL_AVAILABLE here?  That would be good reason to preserve this\n+     hook Similarly deal with extern inline functions - this is again\n+     neccesary to get C++ shared functions having keyed templates\n+     right and in the C extension documentation we probably should\n+     document the requirement of both versions of function (extern\n+     inline and offline) having same side effect characteristics as\n+     good optimization is what this optimization is about.  */\n+  \n+  else if (!(*targetm.binds_local_p) (node->decl)\n+\t   && !DECL_COMDAT (node->decl) && !DECL_EXTERNAL (node->decl))\n+    avail = AVAIL_OVERWRITABLE;\n+  else avail = AVAIL_AVAILABLE;\n+\n+  return avail;\n+}\n+\n+/* Return variable availability.  See cgraph.h for description of individual\n+   return values.  */\n+enum availability\n+cgraph_variable_initializer_availability (struct cgraph_varpool_node *node)\n+{\n+  gcc_assert (cgraph_function_flags_ready);\n+  if (!node->finalized)\n+    return AVAIL_NOT_AVAILABLE;\n+  if (!TREE_PUBLIC (node->decl))\n+    return AVAIL_AVAILABLE;\n+  /* If the variable can be overwritted, return OVERWRITABLE.  Takes\n+     care of at least two notable extensions - the COMDAT variables\n+     used to share template instantiations in C++.  */\n+  if (!(*targetm.binds_local_p) (node->decl) && !DECL_COMDAT (node->decl))\n+    return AVAIL_OVERWRITABLE;\n+  return AVAIL_AVAILABLE;\n+}\n+\n #include \"gt-cgraph.h\""}, {"sha": "9406e090f332bf8a6c1904ea397fb2ac78922db6", "filename": "gcc/cgraph.h", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b02a4997be30a1cb81a573ea3abc68802f10b2a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b02a4997be30a1cb81a573ea3abc68802f10b2a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6b02a4997be30a1cb81a573ea3abc68802f10b2a", "patch": "@@ -24,6 +24,28 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree.h\"\n #include \"basic-block.h\"\n \n+enum availability\n+{\n+  /* Not yet set by cgraph_function_body_availability.  */\n+  AVAIL_UNSET,\n+  /* Function body/variable initializer is unknown.  */\n+  AVAIL_NOT_AVAILABLE,\n+  /* Function body/variable initializer is known but might be replaced\n+     by a different one from other compilation unit and thus needs to\n+     be dealt with a care.  Like AVAIL_NOT_AVAILABLE it can have\n+     arbitrary side effects on escaping variables and functions, while\n+     like AVAILABLE it might access static variables.  */\n+  AVAIL_OVERWRITABLE,\n+  /* Function body/variable initializer is known and will be used in final\n+     program.  */\n+  AVAIL_AVAILABLE,\n+  /* Function body/variable initializer is known and all it's uses are explicitly\n+     visible within current unit (ie it's address is never taken and it is not\n+     exported to other units).\n+     Currently used only for functions.  */\n+  AVAIL_LOCAL\n+};\n+\n /* Information about the function collected locally.\n    Available after function is analyzed.  */\n \n@@ -110,6 +132,10 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   /* Pointer to the next clone.  */\n   struct cgraph_node *next_clone;\n   struct cgraph_node *prev_clone;\n+  /* Pointer to a single unique cgraph node for this function.  If the\n+     function is to be output, this is the copy that will survive.  */\n+  struct cgraph_node *master_clone;\n+ \n   PTR GTY ((skip)) aux;\n \n   struct cgraph_local_info local;\n@@ -178,7 +204,7 @@ struct cgraph_varpool_node GTY(())\n   bool analyzed;\n   /* Set once it has been finalized so we consider it to be output.  */\n   bool finalized;\n-  /* Set when function is scheduled to be assembled.  */\n+  /* Set when variable is scheduled to be assembled.  */\n   bool output;\n   /* Set when function is visible by other units.  */\n   bool externally_visible;\n@@ -229,6 +255,11 @@ void cgraph_varpool_enqueue_needed_node (struct cgraph_varpool_node *);\n void cgraph_varpool_reset_queue (void);\n bool decide_is_variable_needed (struct cgraph_varpool_node *, tree);\n \n+enum availability cgraph_function_body_availability (struct cgraph_node *);\n+enum availability cgraph_variable_initializer_availability (struct cgraph_varpool_node *);\n+bool cgraph_is_master_clone (struct cgraph_node *);\n+struct cgraph_node *cgraph_master_clone (struct cgraph_node *);\n+\n /* In cgraphunit.c  */\n bool cgraph_assemble_pending_functions (void);\n bool cgraph_varpool_assemble_pending_decls (void);"}, {"sha": "ee859f7167b7772145cb7c58a2f54fab511f9147", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b02a4997be30a1cb81a573ea3abc68802f10b2a/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b02a4997be30a1cb81a573ea3abc68802f10b2a/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6b02a4997be30a1cb81a573ea3abc68802f10b2a", "patch": "@@ -967,6 +967,8 @@ cgraph_expand_function (struct cgraph_node *node)\n \t points to the dead function body.  */\n       cgraph_node_remove_callees (node);\n     }\n+\n+  cgraph_function_flags_ready = true;\n }\n \n /* Return true when CALLER_DECL should be inlined into CALLEE_DECL.  */\n@@ -1128,6 +1130,9 @@ cgraph_optimize (void)\n       dump_cgraph (cgraph_dump_file);\n     }\n   ipa_passes ();\n+  /* This pass remove bodies of extern inline functions we never inlined.\n+     Do this later so other IPA passes see what is really going on.  */\n+  cgraph_remove_unreachable_nodes (false, dump_file);\n   cgraph_global_info_ready = true;\n   if (cgraph_dump_file)\n     {"}, {"sha": "5a336ff1b1b3ba2e575ea19527288b92512c37d5", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b02a4997be30a1cb81a573ea3abc68802f10b2a/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b02a4997be30a1cb81a573ea3abc68802f10b2a/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=6b02a4997be30a1cb81a573ea3abc68802f10b2a", "patch": "@@ -857,12 +857,6 @@ cgraph_decide_inlining (void)\n \t}\n     }\n \n-  /* We will never output extern functions we didn't inline. \n-     ??? Perhaps we can prevent accounting of growth of external\n-     inline functions.  */\n-\n-  cgraph_remove_unreachable_nodes (false, dump_file);\n-\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"\\nInlined %i calls, eliminated %i functions, \""}]}