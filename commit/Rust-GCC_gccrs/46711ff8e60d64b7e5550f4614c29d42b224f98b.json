{"sha": "46711ff8e60d64b7e5550f4614c29d42b224f98b", "node_id": "C_kwDOANBUbNoAKDQ2NzExZmY4ZTYwZDY0YjdlNTU1MGY0NjE0YzI5ZDQyYjIyNGY5OGI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-16T16:12:19Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-16T16:12:19Z"}, "message": "c++: TYPENAME_TYPE lookup ignoring non-types [PR107773]\n\nCurrently when resolving a TYPENAME_TYPE for 'typename T::m' via\nmake_typename_type, we consider only type bindings of 'm' and ignore\nnon-type ones.  But [temp.res.general]/3 says, in a note, \"the usual\nqualified name lookup ([basic.lookup.qual]) applies even in the presence\nof 'typename'\", and qualified name lookup doesn't discriminate between\ntype and non-type bindings.  So when resolving such a TYPENAME_TYPE\nwe want the lookup to consider all bindings.\n\nAn exception is when we have a TYPENAME_TYPE corresponding to the\nqualifying scope of the :: scope resolution operator, such as 'T::type'\nin 'T::type::m'.  In that case, [basic.lookup.qual]/1 applies, and\nlookup for such a TYPENAME_TYPE must ignore non-type bindings.  So in\norder to correctly handle all cases, make_typename_type needs an\nadditional flag controlling whether to restrict the lookup.\n\nTo that end this patch adds a new tsubst flag tf_qualifying_scope\ndenoting whether we're substituting the LHS of the :: operator,\nwhich make_typename_type will look for to conditionally restrict the\nlookup to type bindings (by default we want to consider all bindings).\nSo in contexts such as substituting into the scope of TYPENAME_TYPE,\nSCOPE_REF or USING_DECL we simply pass tf_qualifying_scope to the\nrelevant tsubst / tsubst_copy call, and if that scope is a TYPENAME_TYPE\nthen make_typename_type will restrict the lookup accordingly.  This flag\nis intended to apply only to overall scope (TYPENAME_TYPE or not) so we\nmust be careful to clear the flag to avoid propagating it when recursing\ninto sub-trees of the scope.\n\n\tPR c++/107773\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (enum tsubst_flags): New flag tf_qualifying_scope.\n\t* decl.cc (make_typename_type): Use lookup_member instead of\n\tlookup_field.  If tf_qualifying_scope is set, pass want_type=true\n\tinstead of =false to lookup_member.  Generalize format specifier\n\tin diagnostic to handle both type and non-type bindings.\n\t* pt.cc (tsubst_aggr_type_1): Clear tf_qualifying_scope.  Tidy\n\tthe function.\n\t(tsubst_decl) <case USING_DECL>: Set tf_qualifying_scope when\n\tsubstituting USING_DECL_SCOPE.\n\t(tsubst): Clear tf_qualifying_scope right away and remember if\n\tit was set.  Do the same for tf_tst_ok sooner.\n\t<case TYPENAME_TYPE>: Set tf_qualifying_scope when substituting\n\tTYPE_CONTEXT.  Pass tf_qualifying_scope to make_typename_type\n\tif it was set.\n\t(tsubst_qualified_id): Set tf_qualifying_scope when substituting\n\tthe scope.\n\t(tsubst_copy): Clear tf_qualifying_scope and remember if it was\n\tset.\n\t<case SCOPE_REF>: Set tf_qualifying_scope when substituting the\n\tscope.\n\t<case *_TYPE>: Pass tf_qualifying_scope to tsubst if it was set.\n\t* search.cc (lookup_member): Document default argument.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/typename24.C: New test.\n\t* g++.dg/template/typename25.C: New test.\n\t* g++.dg/template/typename25a.C: New test.\n\t* g++.dg/template/typename26.C: New test.", "tree": {"sha": "47042bc49951757931c34ef14290549c91882ae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47042bc49951757931c34ef14290549c91882ae8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46711ff8e60d64b7e5550f4614c29d42b224f98b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46711ff8e60d64b7e5550f4614c29d42b224f98b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46711ff8e60d64b7e5550f4614c29d42b224f98b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46711ff8e60d64b7e5550f4614c29d42b224f98b/comments", "author": null, "committer": null, "parents": [{"sha": "bb3aee20cdeeb6399ca77ac05cd8093d66256df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb3aee20cdeeb6399ca77ac05cd8093d66256df3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb3aee20cdeeb6399ca77ac05cd8093d66256df3"}], "stats": {"total": 179, "additions": 149, "deletions": 30}, "files": [{"sha": "4ecd9c7f21f9af703e60e6d5e9b114502769c44f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=46711ff8e60d64b7e5550f4614c29d42b224f98b", "patch": "@@ -5597,6 +5597,9 @@ enum tsubst_flags {\n   tf_tst_ok = 1 << 12,\t\t /* Allow a typename-specifier to name\n \t\t\t\t    a template (C++17 or later).  */\n   tf_dguide = 1 << 13,\t\t/* Building a deduction guide from a ctor.  */\n+  tf_qualifying_scope = 1 << 14, /* Substituting the LHS of the :: operator.\n+\t\t\t\t    Affects TYPENAME_TYPE resolution from\n+\t\t\t\t    make_typename_type.  */\n   /* Convenient substitution flags combinations.  */\n   tf_warning_or_error = tf_warning | tf_error\n };"}, {"sha": "2f6412d04e65d42912c7bcb2d0f2f842da8f46a1", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=46711ff8e60d64b7e5550f4614c29d42b224f98b", "patch": "@@ -4305,9 +4305,10 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n      member of the current instantiation or a non-dependent base;\n      lookup will stop when we hit a dependent base.  */\n   if (!dependent_scope_p (context))\n-    /* We should only set WANT_TYPE when we're a nested typename type.\n-       Then we can give better diagnostics if we find a non-type.  */\n-    t = lookup_field (context, name, 2, /*want_type=*/true);\n+    {\n+      bool want_type = (complain & tf_qualifying_scope);\n+      t = lookup_member (context, name, /*protect=*/2, want_type, complain);\n+    }\n   else\n     t = NULL_TREE;\n \n@@ -4359,7 +4360,7 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n       else\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"%<typename %T::%D%> names %q#T, which is not a type\",\n+\t    error (\"%<typename %T::%D%> names %q#D, which is not a type\",\n \t\t   context, name, t);\n \t  return error_mark_node;\n \t}"}, {"sha": "d11d540ab443b20fd4eec5b55dca76f148418531", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=46711ff8e60d64b7e5550f4614c29d42b224f98b", "patch": "@@ -13919,8 +13919,7 @@ tsubst_aggr_type_1 (tree t,\n {\n   if (TYPE_TEMPLATE_INFO (t) && uses_template_parms (t))\n     {\n-      tree argvec;\n-      tree r;\n+      complain &= ~tf_qualifying_scope;\n \n       /* Figure out what arguments are appropriate for the\n \t type we are trying to find.  For example, given:\n@@ -13931,18 +13930,14 @@ tsubst_aggr_type_1 (tree t,\n \t and supposing that we are instantiating f<int, double>,\n \t then our ARGS will be {int, double}, but, when looking up\n \t S we only want {double}.  */\n-      argvec = tsubst_template_args (TYPE_TI_ARGS (t), args,\n-\t\t\t\t     complain, in_decl);\n+      tree argvec = tsubst_template_args (TYPE_TI_ARGS (t), args,\n+\t\t\t\t\t  complain, in_decl);\n       if (argvec == error_mark_node)\n-\tr = error_mark_node;\n-      else\n-\t{\n-\t  r = lookup_template_class (t, argvec, in_decl, NULL_TREE,\n-\t\t\t\t     entering_scope, complain);\n-\t  r = cp_build_qualified_type (r, cp_type_quals (t), complain);\n-\t}\n+\treturn error_mark_node;\n \n-      return r;\n+      tree r = lookup_template_class (t, argvec, in_decl, NULL_TREE,\n+\t\t\t\t      entering_scope, complain);\n+      return cp_build_qualified_type (r, cp_type_quals (t), complain);\n     }\n   else\n     /* This is not a template type, so there's nothing to do.  */\n@@ -15003,11 +14998,15 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  tree scope = USING_DECL_SCOPE (t);\n \t  if (PACK_EXPANSION_P (scope))\n \t    {\n-\t      scope = tsubst_pack_expansion (scope, args, complain, in_decl);\n+\t      scope = tsubst_pack_expansion (scope, args,\n+\t\t\t\t\t     complain | tf_qualifying_scope,\n+\t\t\t\t\t     in_decl);\n \t      variadic_p = true;\n \t    }\n \t  else\n-\t    scope = tsubst_copy (scope, args, complain, in_decl);\n+\t    scope = tsubst_copy (scope, args,\n+\t\t\t\t complain | tf_qualifying_scope,\n+\t\t\t\t in_decl);\n \n \t  tree name = DECL_NAME (t);\n \t  if (IDENTIFIER_CONV_OP_P (name)\n@@ -15821,6 +15820,12 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       || TREE_CODE (t) == TRANSLATION_UNIT_DECL)\n     return t;\n \n+  tsubst_flags_t tst_ok_flag = (complain & tf_tst_ok);\n+  complain &= ~tf_tst_ok;\n+\n+  tsubst_flags_t qualifying_scope_flag = (complain & tf_qualifying_scope);\n+  complain &= ~tf_qualifying_scope;\n+\n   if (DECL_P (t))\n     return tsubst_decl (t, args, complain);\n \n@@ -15889,9 +15894,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   bool fndecl_type = (complain & tf_fndecl_type);\n   complain &= ~tf_fndecl_type;\n \n-  bool tst_ok = (complain & tf_tst_ok);\n-  complain &= ~tf_tst_ok;\n-\n   if (type\n       && code != TYPENAME_TYPE\n       && code != TEMPLATE_TYPE_PARM\n@@ -16428,7 +16430,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \ttree ctx = TYPE_CONTEXT (t);\n \tif (TREE_CODE (ctx) == TYPE_PACK_EXPANSION)\n \t  {\n-\t    ctx = tsubst_pack_expansion (ctx, args, complain, in_decl);\n+\t    ctx = tsubst_pack_expansion (ctx, args,\n+\t\t\t\t\t complain | tf_qualifying_scope,\n+\t\t\t\t\t in_decl);\n \t    if (ctx == error_mark_node\n \t\t|| TREE_VEC_LENGTH (ctx) > 1)\n \t      return error_mark_node;\n@@ -16442,8 +16446,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    ctx = TREE_VEC_ELT (ctx, 0);\n \t  }\n \telse\n-\t  ctx = tsubst_aggr_type (ctx, args, complain, in_decl,\n-\t\t\t\t  /*entering_scope=*/1);\n+\t  ctx = tsubst_aggr_type (ctx, args,\n+\t\t\t\t  complain | tf_qualifying_scope,\n+\t\t\t\t  in_decl, /*entering_scope=*/1);\n \tif (ctx == error_mark_node)\n \t  return error_mark_node;\n \n@@ -16473,8 +16478,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  }\n \n \ttsubst_flags_t tcomplain = complain | tf_keep_type_decl;\n-\tif (tst_ok)\n-\t  tcomplain |= tf_tst_ok;\n+\ttcomplain |= tst_ok_flag | qualifying_scope_flag;\n \tf = make_typename_type (ctx, f, typename_type, tcomplain);\n \tif (f == error_mark_node)\n \t  return f;\n@@ -16879,7 +16883,7 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   scope = TREE_OPERAND (qualified_id, 0);\n   if (args)\n     {\n-      scope = tsubst (scope, args, complain, in_decl);\n+      scope = tsubst (scope, args, complain | tf_qualifying_scope, in_decl);\n       expr = tsubst_copy (name, args, complain, in_decl);\n     }\n   else\n@@ -17125,6 +17129,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   if (t == NULL_TREE || t == error_mark_node || args == NULL_TREE)\n     return t;\n \n+  tsubst_flags_t qualifying_scope_flag = (complain & tf_qualifying_scope);\n+  complain &= ~tf_qualifying_scope;\n+\n   if (tree d = maybe_dependent_member_ref (t, args, complain, in_decl))\n     return d;\n \n@@ -17598,7 +17605,8 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n     case SCOPE_REF:\n       {\n-\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args,\n+\t\t\t\tcomplain | tf_qualifying_scope, in_decl);\n \ttree op1 = tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl);\n \treturn build_qualified_name (/*type=*/NULL_TREE, op0, op1,\n \t\t\t\t     QUALIFIED_NAME_IS_TEMPLATE (t));\n@@ -17713,7 +17721,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case TYPEOF_TYPE:\n     case DECLTYPE_TYPE:\n     case TYPE_DECL:\n-      return tsubst (t, args, complain, in_decl);\n+      return tsubst (t, args, complain | qualifying_scope_flag, in_decl);\n \n     case USING_DECL:\n       t = DECL_NAME (t);"}, {"sha": "e472a97679dce36ec862a3430551e694655a6fe2", "filename": "gcc/cp/search.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Fcp%2Fsearch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Fcp%2Fsearch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.cc?ref=46711ff8e60d64b7e5550f4614c29d42b224f98b", "patch": "@@ -1109,7 +1109,7 @@ build_baselink (tree binfo, tree access_binfo, tree functions, tree optype)\n \n tree\n lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n-\t       tsubst_flags_t complain, access_failure_info *afi)\n+\t       tsubst_flags_t complain, access_failure_info *afi /* = NULL */)\n {\n   tree rval, rval_binfo = NULL_TREE;\n   tree type = NULL_TREE, basetype_path = NULL_TREE;"}, {"sha": "8b2b37184425c0ea42294fdd5d7391559fb0f387", "filename": "gcc/testsuite/g++.dg/template/typename24.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename24.C?ref=46711ff8e60d64b7e5550f4614c29d42b224f98b", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/107773\n+// Verify lookup for a non-neste TYPENAME_TYPE correctly considers\n+// non-types.\n+\n+struct a {\n+  typedef void get;\n+};\n+\n+struct b : a {\n+  int get(int i) const;\n+};\n+\n+template<class T>\n+void f() {\n+  typedef typename T::get type; // { dg-error \"'int b::get\\\\(int\\\\) const', which is not a type\" }\n+}\n+\n+template void f<b>();"}, {"sha": "04e48e1172461887c20e18927b49575f06c1f860", "filename": "gcc/testsuite/g++.dg/template/typename25.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename25.C?ref=46711ff8e60d64b7e5550f4614c29d42b224f98b", "patch": "@@ -0,0 +1,33 @@\n+// PR c++/107773\n+// Verify lookup for TYPENAME_TYPE appearing to the left of the ::\n+// scope resolution operator correctly ignores non-types.\n+\n+struct a {\n+  typedef void type;\n+};\n+\n+struct c {\n+  struct b : a {\n+    typedef b self;\n+    static int m;\n+  };\n+  int b;\n+};\n+\n+template<class T>\n+void f() {\n+  // A TYPENAME_TYPE whose TYPE_CONTEXT is a nested TYPENAME_TYPE.\n+  typedef typename T::b::type type;\n+  // A SCOPE_REF whose first operand is a TYPENAME_TYPE.\n+  int m = T::b::m;\n+}\n+\n+template void f<c>();\n+\n+template<class T>\n+struct d : T::b::self {\n+  // A USING_DECL whose USING_DECL_SCOPE is a TYPENAME_TYPE.\n+  using typename T::b::type;\n+};\n+\n+template struct d<c>;"}, {"sha": "ecb34aada342940389751dd3e634e3d68695e982", "filename": "gcc/testsuite/g++.dg/template/typename25a.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename25a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename25a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename25a.C?ref=46711ff8e60d64b7e5550f4614c29d42b224f98b", "patch": "@@ -0,0 +1,37 @@\n+// PR c++/107773\n+// A variadic version of typename25.C\n+// { dg-do compile { target c++11 } }\n+\n+struct a {\n+  typedef void type;\n+};\n+\n+struct c {\n+  struct b : a {\n+    typedef b self;\n+    static int m;\n+  };\n+  int b;\n+};\n+\n+template<class...> void sink(...);\n+\n+template<class... Ts>\n+void f() {\n+  // A TYPENAME_TYPE whose TYPE_CONTEXT is a nested TYPENAME_TYPE.\n+  sink<typename Ts::b::type...>();\n+  // A SCOPE_REF whose first operand is a TYPENAME_TYPE.\n+  sink(Ts::b::m...);\n+}\n+\n+template void f<c>();\n+\n+template<class... Ts>\n+struct d : Ts::b::self... {\n+#if __cpp_variadic_using\n+  // A USING_DECL whose USING_DECL_SCOPE is a TYPENAME_TYPE.\n+  using typename Ts::b::type...;\n+#endif\n+};\n+\n+template struct d<c>;"}, {"sha": "f4b8bb28318576b6ce2a768db92a596c6f49b8de", "filename": "gcc/testsuite/g++.dg/template/typename26.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46711ff8e60d64b7e5550f4614c29d42b224f98b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename26.C?ref=46711ff8e60d64b7e5550f4614c29d42b224f98b", "patch": "@@ -0,0 +1,19 @@\n+// Example 4 from [temp.res.general]/3.\n+\n+struct A {\n+  struct X { };\n+  int X;\n+};\n+struct B {\n+  struct X { };\n+};\n+template<class T> void f(T t) {\n+  typename T::X x; // { dg-error \"'int A::X', which is not a type\" }\n+}\n+void foo() {\n+  A a;\n+  B b;\n+  f(b); // OK, T::X refers to B::X\n+  f(a); // error: T::X refers to the data member A::X not the struct A::X\n+  // { dg-message \"required from here\" \"\" { target *-*-* } .-1 }\n+}"}]}