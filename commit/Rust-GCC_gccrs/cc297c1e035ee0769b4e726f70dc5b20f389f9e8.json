{"sha": "cc297c1e035ee0769b4e726f70dc5b20f389f9e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MyOTdjMWUwMzVlZTA3NjliNGU3MjZmNzBkYzViMjBmMzg5ZjllOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2007-02-12T14:39:44Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2007-02-12T14:39:44Z"}, "message": "VMTimeZone.java: Rewrite to handle both the old 'TZif\\0' format and the new one.\n\n2007-02-09  Jakub Jelinek  <jakub@redhat.com>\n\n\t* java/util/VMTimeZone.java: Rewrite to handle both the old\n\t'TZif\\0' format and the new one.\n\nFrom-SVN: r121845", "tree": {"sha": "4d042b8590f85b258a5838f9aef9fff696f318fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d042b8590f85b258a5838f9aef9fff696f318fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc297c1e035ee0769b4e726f70dc5b20f389f9e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc297c1e035ee0769b4e726f70dc5b20f389f9e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc297c1e035ee0769b4e726f70dc5b20f389f9e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc297c1e035ee0769b4e726f70dc5b20f389f9e8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b3ffe5f7a7adb9d541c976e36e1e0da94506506", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b3ffe5f7a7adb9d541c976e36e1e0da94506506", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b3ffe5f7a7adb9d541c976e36e1e0da94506506"}], "stats": {"total": 462, "additions": 407, "deletions": 55}, "files": [{"sha": "39a5902710853c530d57c177957683ddfc0b9826", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc297c1e035ee0769b4e726f70dc5b20f389f9e8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc297c1e035ee0769b4e726f70dc5b20f389f9e8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=cc297c1e035ee0769b4e726f70dc5b20f389f9e8", "patch": "@@ -1,3 +1,8 @@\n+2007-02-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* java/util/VMTimeZone.java: Rewrite to handle both the old\n+\t'TZif\\0' format and the new one.\n+\t\n 2007-02-10  Andrew Haley  <aph@redhat.com>\n \n \tPR java/30742"}, {"sha": "a175a44d286d5d69c034fec81d61539d74eaf2ee", "filename": "libjava/classpath/lib/java/util/VMTimeZone.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc297c1e035ee0769b4e726f70dc5b20f389f9e8/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FVMTimeZone.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc297c1e035ee0769b4e726f70dc5b20f389f9e8/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FVMTimeZone.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FVMTimeZone.class?ref=cc297c1e035ee0769b4e726f70dc5b20f389f9e8"}, {"sha": "27bab939166a99190b4722f96c594a0d95d71231", "filename": "libjava/java/util/VMTimeZone.java", "status": "modified", "additions": 402, "deletions": 55, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc297c1e035ee0769b4e726f70dc5b20f389f9e8/libjava%2Fjava%2Futil%2FVMTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc297c1e035ee0769b4e726f70dc5b20f389f9e8/libjava%2Fjava%2Futil%2FVMTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FVMTimeZone.java?ref=cc297c1e035ee0769b4e726f70dc5b20f389f9e8", "patch": "@@ -1,5 +1,5 @@\n /* java.util.VMTimeZone\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -40,6 +40,9 @@\n package java.util;\n \n import gnu.classpath.Configuration;\n+import java.util.TimeZone;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n \n import java.io.*;\n \n@@ -206,71 +209,152 @@ private static String readtzFile(String file)\n     File f = new File(file);\n     if (!f.exists())\n       return null;\n-    \n+\n     DataInputStream dis = null;\n     try\n       {\n-        FileInputStream fis = new FileInputStream(f);\n-        BufferedInputStream bis = new BufferedInputStream(fis);\n-        dis = new DataInputStream(bis);\n-\t\n-        // Make sure we are reading a tzfile.\n-        byte[] tzif = new byte[4];\n-        dis.readFully(tzif);\n-        if (tzif[0] == 'T' && tzif[1] == 'Z'\n-            && tzif[2] == 'i' && tzif[3] == 'f')\n-\t  // Reserved bytes, ttisgmtcnt, ttisstdcnt and leapcnt\n-\t  skipFully(dis, 16 + 3 * 4);\n+\tFileInputStream fis = new FileInputStream(f);\n+\tBufferedInputStream bis = new BufferedInputStream(fis);\n+\tdis = new DataInputStream(bis);\n+\n+\t// Make sure we are reading a tzfile.\n+\tbyte[] tzif = new byte[5];\n+\tdis.readFully(tzif);\n+\tint tzif2 = 4;\n+\tif (tzif[0] == 'T' && tzif[1] == 'Z'\n+\t    && tzif[2] == 'i' && tzif[3] == 'f')\n+\t  {\n+\t    if (tzif[4] >= '2')\n+\t      tzif2 = 8;\n+\t    // Reserved bytes\n+\t    skipFully(dis, 16 - 1);\n+\t  }\n \telse\n \t  // Darwin has tzdata files that don't start with the TZif marker\n-\t  skipFully(dis, 16 + 3 * 4 - 4);\n-\t\n+\t  skipFully(dis, 16 - 5);\n+\n+\tString id = null;\n+\tint ttisgmtcnt = dis.readInt();\n+\tint ttisstdcnt = dis.readInt();\n+\tint leapcnt = dis.readInt();\n \tint timecnt = dis.readInt();\n \tint typecnt = dis.readInt();\n+\tint charcnt = dis.readInt();\n+\tif (tzif2 == 8)\n+\t  {\n+\t    skipFully(dis, timecnt * (4 + 1) + typecnt * (4 + 1 + 1) + charcnt\n+\t\t\t   + leapcnt * (4 + 4) + ttisgmtcnt + ttisstdcnt);\n+\n+\t    dis.readFully(tzif);\n+\t    if (tzif[0] != 'T' || tzif[1] != 'Z' || tzif[2] != 'i'\n+\t\t|| tzif[3] != 'f' || tzif[4] < '2')\n+\t      return null;\n+\n+\t    // Reserved bytes\n+\t    skipFully(dis, 16 - 1);\n+\t    ttisgmtcnt = dis.readInt();\n+\t    ttisstdcnt = dis.readInt();\n+\t    leapcnt = dis.readInt();\n+\t    timecnt = dis.readInt();\n+\t    typecnt = dis.readInt();\n+\t    charcnt = dis.readInt();\n+\t  }\n \tif (typecnt > 0)\n \t  {\n-\t    int charcnt = dis.readInt();\n-\t    // Transition times plus indexed transition times.\n-\t    skipFully(dis, timecnt * (4 + 1));\n-\t    \n-\t    // Get last gmt_offset and dst/non-dst time zone names.\n-\t    int abbrind = -1;\n+\t    int seltimecnt = timecnt;\n+\t    if (seltimecnt > 16)\n+\t      seltimecnt = 16;\n+\n+\t    long[] times = new long[seltimecnt];\n+\t    int[] types = new int[seltimecnt];\n+\n+\t    // Transition times\n+\t    skipFully(dis, (timecnt - seltimecnt) * tzif2);\n+\n+\t    for (int i = 0; i < seltimecnt; i++)\n+\t      if (tzif2 == 8)\n+\t\ttimes[i] = dis.readLong();\n+\t      else\n+\t\ttimes[i] = (long) dis.readInt();\n+\n+\t    // Transition types\n+\t    skipFully(dis, timecnt - seltimecnt);\n+\t    for (int i = 0; i < seltimecnt; i++)\n+\t      {\n+\t\ttypes[i] = dis.readByte();\n+\t\tif (types[i] < 0)\n+\t\t  types[i] += 256;\n+\t      }\n+\n+\t    // Get std/dst_offset and dst/non-dst time zone names.\n+\t    int std_abbrind = -1;\n \t    int dst_abbrind = -1;\n-\t    int gmt_offset = 0;\n-\t    while (typecnt-- > 0)\n+\t    int std_offset = 0;\n+\t    int dst_offset = 0;\n+\t    int std_ind = -1;\n+\t    int dst_ind = -1;\n+\n+\t    int alternation = 0;\n+\t    if (seltimecnt >= 4 && types[0] != types[1]\n+\t\t&& types[0] < typecnt && types[1] < typecnt)\n+\t      {\n+\t\t// Verify only two types are involved\n+\t\t// in the transitions and they alternate.\n+\t\talternation = 1;\n+\t\tfor (int i = 2; i < seltimecnt; i++)\n+\t\t  if (types[i] != types[i % 2])\n+\t\t    alternation = 0;\n+\t      }\n+\n+\t    // If a timezone previously used DST, but no longer does\n+\t    // (or no longer will in the near future, say 5 years),\n+\t    // then always pick only the std zone type corresponding\n+\t    // to latest applicable transition.\n+\t    if (seltimecnt > 0\n+\t\t&& times[seltimecnt - 1]\n+\t\t   < System.currentTimeMillis() / 1000 + 5 * 365 * 86400)\n+\t      alternation = -1;\n+\n+\t    for (int i = 0; i < typecnt; i++)\n \t      {\n \t\t// gmtoff\n \t\tint offset = dis.readInt();\n \t\tint dst = dis.readByte();\n+\t\tint abbrind = dis.readByte();\n \t\tif (dst == 0)\n \t\t  {\n-\t\t    abbrind = dis.readByte();\n-\t\t    gmt_offset = offset;\n+\t\t    if (alternation == 0\n+\t\t\t|| (alternation == 1\n+\t\t\t    && (i == types[0] || i == types[1]))\n+\t\t\t|| (alternation == -1 && i == types[seltimecnt - 1]))\n+\t\t      {\n+\t\t\tstd_abbrind = abbrind;\n+\t\t\tstd_offset = offset * -1;\n+\t\t\tstd_ind = i;\n+\t\t      }\n+\t\t  }\n+\t\telse if (alternation >= 0)\n+\t\t  {\n+\t\t    if (alternation == 0 || i == types[0] || i == types[1])\n+\t\t      {\n+\t\t\tdst_abbrind = abbrind;\n+\t\t\tdst_offset = offset * -1;\n+\t\t\tdst_ind = i;\n+\t\t      }\n \t\t  }\n-\t\telse\n-\t\t  dst_abbrind = dis.readByte();\n \t      }\n-\t    \n-\t    // gmt_offset is the offset you must add to UTC/GMT to\n-\t    // get the local time, we need the offset to add to\n-\t    // the local time to get UTC/GMT.\n-\t    gmt_offset *= -1;\n-\t    \n-\t    // Turn into hours if possible.\n-\t    if (gmt_offset % 3600 == 0)\n-\t      gmt_offset /= 3600;\n-\t    \n-\t    if (abbrind >= 0)\n+\n+\t    if (std_abbrind >= 0)\n \t      {\n \t\tbyte[] names = new byte[charcnt];\n \t\tdis.readFully(names);\n-\t\tint j = abbrind;\n+\t\tint j = std_abbrind;\n \t\twhile (j < charcnt && names[j] != 0)\n \t\t  j++;\n-\t\t\n-\t\tString zonename = new String(names, abbrind, j - abbrind,\n-\t\t\t\t\t     \"ASCII\");\n-\t\t\n+\n+\t\tString zonename = new String(names, std_abbrind,\n+\t\t\t\t\t     j - std_abbrind, \"ASCII\");\n+\n \t\tString dst_zonename;\n \t\tif (dst_abbrind >= 0)\n \t\t  {\n@@ -282,26 +366,289 @@ private static String readtzFile(String file)\n \t\t  }\n \t\telse\n \t\t  dst_zonename = \"\";\n-\t\t\n+\n+\t\tString[] change_spec = { null, null };\n+\t\tif (dst_abbrind >= 0 && alternation > 0)\n+\t\t  {\n+\t\t    // Guess rules for the std->dst and dst->std transitions\n+\t\t    // from the transition times since Epoch.\n+\t\t    // tzdata actually uses only 3 forms of rules:\n+\t\t    // fixed date within a month, e.g. change on April, 5th\n+\t\t    // 1st weekday on or after Nth: change on Sun>=15 in April\n+\t\t    // last weekday in a month: change on lastSun in April\n+\t\t    GregorianCalendar cal\n+\t\t      = new GregorianCalendar (TimeZone.getTimeZone(\"GMT\"));\n+\n+\t\t    int[] values = new int[2 * 11];\n+\t\t    int i;\n+\t\t    for (i = seltimecnt - 1; i >= 0; i--)\n+\t\t      {\n+\t\t\tint base = (i % 2) * 11;\n+\t\t\tint offset = types[i] == dst_ind ? std_offset : dst_offset;\n+\t\t\tcal.setTimeInMillis((times[i] - offset) * 1000);\n+\t\t\tif (i >= seltimecnt - 2)\n+\t\t\t  {\n+\t\t\t    values[base + 0] = cal.get(Calendar.YEAR);\n+\t\t\t    values[base + 1] = cal.get(Calendar.MONTH);\n+\t\t\t    values[base + 2] = cal.get(Calendar.DAY_OF_MONTH);\n+\t\t\t    values[base + 3]\n+\t\t\t      = cal.getActualMaximum(Calendar.DAY_OF_MONTH);\n+\t\t\t    values[base + 4] = cal.get(Calendar.DAY_OF_WEEK);\n+\t\t\t    values[base + 5] = cal.get(Calendar.HOUR_OF_DAY);\n+\t\t\t    values[base + 6] = cal.get(Calendar.MINUTE);\n+\t\t\t    values[base + 7] = cal.get(Calendar.SECOND);\n+\t\t\t    values[base + 8] = values[base + 2]; // Range start\n+\t\t\t    values[base + 9] = values[base + 2]; // Range end\n+\t\t\t    values[base + 10] = 0; // Determined type\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    int year = cal.get(Calendar.YEAR);\n+\t\t\t    int month = cal.get(Calendar.MONTH);\n+\t\t\t    int day_of_month = cal.get(Calendar.DAY_OF_MONTH);\n+\t\t\t    int month_days\n+\t\t\t      = cal.getActualMaximum(Calendar.DAY_OF_MONTH);\n+\t\t\t    int day_of_week = cal.get(Calendar.DAY_OF_WEEK);\n+\t\t\t    int hour = cal.get(Calendar.HOUR_OF_DAY);\n+\t\t\t    int minute = cal.get(Calendar.MINUTE);\n+\t\t\t    int second = cal.get(Calendar.SECOND);\n+\t\t\t    if (year != values[base + 0] - 1\n+\t\t\t\t|| month != values[base + 1]\n+\t\t\t\t|| hour != values[base + 5]\n+\t\t\t\t|| minute != values[base + 6]\n+\t\t\t\t|| second != values[base + 7])\n+\t\t\t      break;\n+\t\t\t    if (day_of_week == values[base + 4])\n+\t\t\t      {\n+\t\t\t\t// Either a Sun>=8 or lastSun rule.\n+\t\t\t\tif (day_of_month < values[base + 8])\n+\t\t\t\t  values[base + 8] = day_of_month;\n+\t\t\t\tif (day_of_month > values[base + 9])\n+\t\t\t\t  values[base + 9] = day_of_month;\n+\t\t\t\tif (values[base + 10] < 0)\n+\t\t\t\t  break;\n+\t\t\t\tif (values[base + 10] == 0)\n+\t\t\t\t  {\n+\t\t\t\t    values[base + 10] = 1;\n+\t\t\t\t    // If day of month > 28, this is\n+\t\t\t\t    // certainly lastSun rule.\n+\t\t\t\t    if (values[base + 2] > 28)\n+\t\t\t\t      values[base + 2] = 3;\n+\t\t\t\t    // If day of month isn't in the last\n+\t\t\t\t    // week, it can't be lastSun rule.\n+\t\t\t\t    else if (values[base + 2]\n+\t\t\t\t\t     <= values[base + 3] - 7)\n+\t\t\t\t      values[base + 3] = 2;\n+\t\t\t\t  }\n+\t\t\t\tif (values[base + 10] == 1)\n+\t\t\t\t  {\n+\t\t\t\t    // If day of month is > 28, this is\n+\t\t\t\t    // certainly lastSun rule.\n+\t\t\t\t    if (day_of_month > 28)\n+\t\t\t\t      values[base + 10] = 3;\n+\t\t\t\t    // If day of month isn't in the last\n+\t\t\t\t    // week, it can't be lastSun rule.\n+\t\t\t\t    else if (day_of_month <= month_days - 7)\n+\t\t\t\t      values[base + 10] = 2;\n+\t\t\t\t  }\n+\t\t\t\telse if ((values[base + 10] == 2\n+\t\t\t\t\t  && day_of_month > 28)\n+\t\t\t\t\t || (values[base + 10] == 3\n+\t\t\t\t\t     && day_of_month\n+\t\t\t\t\t\t<= month_days - 7))\n+\t\t\t\t  break;\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      {\n+\t\t\t\t// Must be fixed day in month rule.\n+\t\t\t\tif (day_of_month != values[base + 2]\n+\t\t\t\t    || values[base + 10] > 0)\n+\t\t\t\t  break;\n+\t\t\t\tvalues[base + 4] = day_of_week;\n+\t\t\t\tvalues[base + 10] = -1;\n+\t\t\t      }\n+\t\t\t    values[base + 0] -= 1;\n+\t\t\t  }\n+\t\t      }\n+\t\t    if (i < 0)\n+\t\t      {\n+\t\t\tfor (i = 0; i < 2; i++)\n+\t\t\t  {\n+\t\t\t    int base = 11 * i;\n+\t\t\t    if (values[base + 10] == 0)\n+\t\t\t      continue;\n+\t\t\t    if (values[base + 10] == -1)\n+\t\t\t      {\n+\t\t\t\tint[] dayCount\n+\t\t\t\t  = { 0, 31, 59, 90, 120, 151,\n+\t\t\t\t      181, 212, 243, 273, 304, 334 };\n+\t\t\t\tint d = dayCount[values[base + 1]\n+\t\t\t\t\t\t - Calendar.JANUARY];\n+\t\t\t\td += values[base + 2];\n+\t\t\t\tchange_spec[i] = \",J\" + Integer.toString(d);\n+\t\t\t      }\n+\t\t\t    else if (values[base + 10] == 2)\n+\t\t\t      {\n+\t\t\t\t// If we haven't seen all days of the week,\n+\t\t\t\t// we can't be sure what the rule really is.\n+\t\t\t\tif (values[base + 8] + 6 != values[base + 9])\n+\t\t\t\t  continue;\n+\n+\t\t\t\t// FIXME: Sun >= 5 is representable in\n+\t\t\t\t// SimpleTimeZone, but not in POSIX TZ env\n+\t\t\t\t// strings.  Should we change readtzFile\n+\t\t\t\t// to actually return a SimpleTimeZone\n+\t\t\t\t// rather than POSIX TZ string?\n+\t\t\t\tif ((values[base + 8] % 7) != 1)\n+\t\t\t\t  continue;\n+\n+\t\t\t\tint d;\n+\t\t\t\td = values[base + 1] - Calendar.JANUARY + 1;\n+\t\t\t\tchange_spec[i] = \",M\" + Integer.toString(d);\n+\t\t\t\td = (values[base + 8] + 6) / 7;\n+\t\t\t\tchange_spec[i] += \".\" + Integer.toString(d);\n+\t\t\t\td = values[base + 4] - Calendar.SUNDAY;\n+\t\t\t\tchange_spec[i] += \".\" + Integer.toString(d);\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      {\n+\t\t\t\t// If we don't know whether this is lastSun or\n+\t\t\t\t// Sun >= 22 rule.  That can be either because\n+\t\t\t\t// there was insufficient number of\n+\t\t\t\t// transitions, or February, where it is quite\n+\t\t\t\t// probable we haven't seen any 29th dates.\n+\t\t\t\t// For February, assume lastSun rule, otherwise\n+\t\t\t\t// punt.\n+\t\t\t\tif (values[base + 10] == 1\n+\t\t\t\t    && values[base + 1] != Calendar.FEBRUARY)\n+\t\t\t\t  continue;\n+\n+\t\t\t\tint d;\n+\t\t\t\td = values[base + 1] - Calendar.JANUARY + 1;\n+\t\t\t\tchange_spec[i] = \",M\" + Integer.toString(d);\n+\t\t\t\td = values[base + 4] - Calendar.SUNDAY;\n+\t\t\t\tchange_spec[i] += \".5.\" + Integer.toString(d);\n+\t\t\t      }\n+\n+\t\t\t    // Don't add time specification if time is\n+\t\t\t    // 02:00:00.\n+\t\t\t    if (values[base + 5] != 2\n+\t\t\t\t|| values[base + 6] != 0\n+\t\t\t\t|| values[base + 7] != 0)\n+\t\t\t      {\n+\t\t\t\tint d = values[base + 5];\n+\t\t\t\tchange_spec[i] += \"/\" + Integer.toString(d);\n+\t\t\t\tif (values[base + 6] != 0\n+\t\t\t\t    || values[base + 7] != 0)\n+\t\t\t\t  {\n+\t\t\t\t    d = values[base + 6];\n+\t\t\t\t    if (d < 10)\n+\t\t\t\t      change_spec[i]\n+\t\t\t\t\t+= \":0\" + Integer.toString(d);\n+\t\t\t\t    else\n+\t\t\t\t      change_spec[i]\n+\t\t\t\t\t+= \":\" + Integer.toString(d);\n+\t\t\t\t    d = values[base + 7];\n+\t\t\t\t    if (d >= 10)\n+\t\t\t\t      change_spec[i]\n+\t\t\t\t\t+= \":\" + Integer.toString(d);\n+\t\t\t\t    else if (d > 0)\n+\t\t\t\t      change_spec[i]\n+\t\t\t\t\t+= \":0\" + Integer.toString(d);\n+\t\t\t\t  }\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\tif (types[0] == std_ind)\n+\t\t\t  {\n+\t\t\t    String tmp = change_spec[0];\n+\t\t\t    change_spec[0] = change_spec[1];\n+\t\t\t    change_spec[1] = tmp;\n+\t\t\t  }\n+\t\t      }\n+\t\t  }\n+\n \t\t// Only use gmt offset when necessary.\n \t\t// Also special case GMT+/- timezones.\n-\t\tString offset_string;\n-\t\tif (\"\".equals(dst_zonename)\n-\t\t    && (gmt_offset == 0\n+\t\tString offset_string, dst_offset_string = \"\";\n+\t\tif (dst_abbrind < 0\n+\t\t    && (std_offset == 0\n \t\t\t|| zonename.startsWith(\"GMT+\")\n \t\t\t|| zonename.startsWith(\"GMT-\")))\n \t\t  offset_string = \"\";\n \t\telse\n-\t\t  offset_string = Integer.toString(gmt_offset);\n-\t\t\n-\t\tString id = zonename + offset_string + dst_zonename;\n-\t\t\n-\t\treturn id;\n+\t\t  {\n+\t\t    offset_string = Integer.toString(std_offset / 3600);\n+\t\t    int seconds = std_offset % 3600;\n+\t\t    if (seconds != 0)\n+\t\t      {\n+\t\t\tif (seconds < 0)\n+\t\t\t  seconds *= -1;\n+\t\t\tif (seconds < 600)\n+\t\t\t  offset_string\n+\t\t\t    += \":0\" + Integer.toString(seconds / 60);\n+\t\t\telse\n+\t\t\t  offset_string\n+\t\t\t    += \":\" + Integer.toString(seconds / 60);\n+\t\t\tseconds = seconds % 60;\n+\t\t\tif (seconds >= 10)\n+\t\t\t  offset_string\n+\t\t\t    += \":\" + Integer.toString(seconds);\n+\t\t\telse if (seconds > 0)\n+\t\t\t  offset_string\n+\t\t\t    += \":0\" + Integer.toString(seconds);\n+\t\t      }\n+\t\t    if (dst_abbrind >= 0\n+\t\t\t&& dst_offset != std_offset - 3600)\n+\t\t      {\n+\t\t\tdst_offset_string\n+\t\t\t  = Integer.toString(dst_offset / 3600);\n+\t\t\tseconds = dst_offset % 3600;\n+\t\t\tif (seconds != 0)\n+\t\t\t  {\n+\t\t\t    if (seconds < 0)\n+\t\t\t      seconds *= -1;\n+\t\t\t    if (seconds < 600)\n+\t\t\t      dst_offset_string\n+\t\t\t\t+= \":0\" + Integer.toString(seconds / 60);\n+\t\t\t    else\n+\t\t\t      dst_offset_string\n+\t\t\t\t+= \":\" + Integer.toString(seconds / 60);\n+\t\t\t    seconds = seconds % 60;\n+\t\t\t    if (seconds >= 10)\n+\t\t\t      dst_offset_string\n+\t\t\t\t+= \":\" + Integer.toString(seconds);\n+\t\t\t    else if (seconds > 0)\n+\t\t\t      dst_offset_string\n+\t\t\t\t+= \":0\" + Integer.toString(seconds);\n+\t\t\t  }\n+\t\t      }\n+\t\t  }\n+\n+\t\tif (dst_abbrind < 0)\n+\t\t  id = zonename + offset_string;\n+\t\telse if (change_spec[0] != null && change_spec[1] != null)\n+\t\t  id = zonename + offset_string + dst_zonename\n+\t\t       + dst_offset_string + change_spec[0] + change_spec[1];\n \t      }\n+\t    else if (tzif2 == 8)\n+\t      skipFully(dis, charcnt);\n \t  }\n-\t\n-\t// Something didn't match while reading the file.\n-\treturn null;\n+\telse if (tzif2 == 8)\n+\t  skipFully(dis, timecnt * (8 + 1) + typecnt * (4 + 1 + 1) + charcnt);\n+\n+\tif (tzif2 == 8)\n+\t  {\n+\t    // Skip over the rest of 64-bit data\n+\t    skipFully(dis, leapcnt * (8 + 4) + ttisgmtcnt + ttisstdcnt);\n+\t    if (dis.readByte() == '\\n')\n+\t      {\n+\t\tString posixtz = dis.readLine();\n+\t\tif (posixtz.length() > 0)\n+\t\t  id = posixtz;\n+\t      }\n+\t  }\n+\n+\treturn id;\n       }\n     catch (IOException ioe)\n       {"}]}