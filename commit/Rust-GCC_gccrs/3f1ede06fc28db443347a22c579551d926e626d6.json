{"sha": "3f1ede06fc28db443347a22c579551d926e626d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YxZWRlMDZmYzI4ZGI0NDMzNDdhMjJjNTc5NTUxZDkyNmU2MjZkNg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:58:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:58:16Z"}, "message": "freeze.adb: Add handling of Last_Assignment field\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb: Add handling of Last_Assignment field\n\t(Warn_Overlay): Supply missing continuation marks in error msgs\n\t(Freeze_Entity): Add check for Preelaborable_Initialization\n\n\t* g-comlin.adb: Add Warnings (Off) to prevent new warning\n\n\t* g-expect.adb: Add Warnings (Off) to prevent new warning\n\n\t* lib-xref.adb: Add handling of Last_Assignment field\n\t(Generate_Reference): Centralize handling of pragma Obsolescent here\n\t(Generate_Reference): Accept an implicit reference generated for a\n\tdefault in an instance.\n\t(Generate_Reference): Accept a reference for a node that is not in the\n\tmain unit, if it is the generic body corresponding to an subprogram\n\tinstantiation.\n\n\t* xref_lib.adb: Add pragma Warnings (Off) to avoid new warnings\n\n        * sem_warn.ads, sem_warn.adb (Set_Warning_Switch): Add processing for\n\t-gnatwq/Q.\n\t(Warn_On_Useless_Assignment): Suppress warning if enclosing inner\n\texception handler.\n\t(Output_Obsolescent_Entity_Warnings): Rewrite to avoid any messages on\n\tuse clauses, to avoid messages on packages used to qualify, and also\n\tto avoid messages from obsolescent units.\n\t(Warn_On_Useless_Assignments): Don't generate messages for imported\n\tand exported variables.\n\t(Warn_On_Useless_Assignments): New procedure\n\t(Output_Obsolescent_Entity_Warnings): New procedure\n\t(Check_Code_Statement): New procedure\n\n        * einfo.ads, einfo.adb (Has_Static_Discriminants): New flag\n\tChange name Is_Ada_2005 to Is_Ada_2005_Only\n\t(Last_Assignment): New field for useless assignment warning\n\nFrom-SVN: r118271", "tree": {"sha": "822b27575fa161de1d3401c4f2b7073cea546bbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/822b27575fa161de1d3401c4f2b7073cea546bbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f1ede06fc28db443347a22c579551d926e626d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1ede06fc28db443347a22c579551d926e626d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f1ede06fc28db443347a22c579551d926e626d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1ede06fc28db443347a22c579551d926e626d6/comments", "author": null, "committer": null, "parents": [{"sha": "ac3b962ec3965793916eea80eab7f5dd42aa7570", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3b962ec3965793916eea80eab7f5dd42aa7570", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac3b962ec3965793916eea80eab7f5dd42aa7570"}], "stats": {"total": 1301, "additions": 1006, "deletions": 295}, "files": [{"sha": "5406f07cb61a1e19d697c990e235727c0767843a", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=3f1ede06fc28db443347a22c579551d926e626d6", "patch": "@@ -887,31 +887,12 @@ package body Freeze is\n         (T : Entity_Id) return Boolean\n       is\n          Constraint : Elmt_Id;\n-         Discr      : Entity_Id;\n \n       begin\n          if Has_Discriminants (T)\n            and then Present (Discriminant_Constraint (T))\n            and then Present (First_Component (T))\n          then\n-            Discr := First_Discriminant (T);\n-\n-            if Is_Access_Type (Etype (Discr)) then\n-               null;\n-\n-            --  If the bounds of the discriminant are not compile-time known,\n-            --  treat this as non-static, even if the value of the discriminant\n-            --  is compile-time known, because the back-end treats aggregates\n-            --  of such a subtype as having unknown size.\n-\n-            elsif not\n-              (Compile_Time_Known_Value (Type_Low_Bound  (Etype (Discr)))\n-                 and then\n-               Compile_Time_Known_Value (Type_High_Bound (Etype (Discr))))\n-            then\n-               return False;\n-            end if;\n-\n             Constraint := First_Elmt (Discriminant_Constraint (T));\n             while Present (Constraint) loop\n                if not Compile_Time_Known_Value (Node (Constraint)) then\n@@ -2453,6 +2434,16 @@ package body Freeze is\n       --  Case of a type or subtype being frozen\n \n       else\n+         --  Check preelaborable initialization for full type completing a\n+         --  private type for which pragma Preelaborable_Initialization given.\n+\n+         if Must_Have_Preelab_Init (E)\n+           and then not Has_Preelaborable_Initialization (E)\n+         then\n+            Error_Msg_N\n+              (\"full view of & does not have preelaborable initialization\", E);\n+         end if;\n+\n          --  The type may be defined in a generic unit. This can occur when\n          --  freezing a generic function that returns the type (which is\n          --  defined in a parent unit). It is clearly meaningless to freeze\n@@ -3014,7 +3005,7 @@ package body Freeze is\n \n             Freeze_Subprogram (E);\n \n-            --  AI-326: Check wrong use of tag incomplete type\n+            --  Ada 2005 (AI-326): Check wrong use of tag incomplete type\n             --\n             --    type T is tagged;\n             --    type Acc is access function (X : T) return T; -- ERROR\n@@ -4503,11 +4494,15 @@ package body Freeze is\n       --  Reset True_Constant flag, since something strange is going on with\n       --  the scoping here, and our simple value tracing may not be sufficient\n       --  for this indication to be reliable. We kill the Constant_Value\n-      --  indication for the same reason.\n+      --  and Last_Assignment indications for the same reason.\n \n       Set_Is_True_Constant (E, False);\n       Set_Current_Value    (E, Empty);\n \n+      if Ekind (E) = E_Variable then\n+         Set_Last_Assignment  (E, Empty);\n+      end if;\n+\n    exception\n       when Cannot_Be_Static =>\n \n@@ -5091,8 +5086,9 @@ package body Freeze is\n                      and then Present (Packed_Array_Type (Etype (Comp)))\n                   then\n                      Error_Msg_NE\n-                       (\"packed array component& will be initialized to zero?\",\n-                          Nam, Comp);\n+                       (\"\\packed array component& \" &\n+                        \"will be initialized to zero?\",\n+                        Nam, Comp);\n                      exit;\n                   else\n                      Next_Component (Comp);\n@@ -5102,9 +5098,9 @@ package body Freeze is\n          end if;\n \n          Error_Msg_N\n-           (\"use pragma Import for & to \" &\n-              \"suppress initialization ('R'M B.1(24))?\",\n-             Nam);\n+           (\"\\use pragma Import for & to \" &\n+            \"suppress initialization ('R'M B.1(24))?\",\n+            Nam);\n       end if;\n    end Warn_Overlay;\n "}, {"sha": "4b62e1ceb03df5f56c4f8058f19797e896634f6d", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=3f1ede06fc28db443347a22c579551d926e626d6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -683,6 +683,9 @@ package body GNAT.Command_Line is\n       Last            : Integer;\n       Delimiter_Found : Boolean;\n \n+      Discard : Boolean;\n+      pragma Warnings (Off, Discard);\n+\n    begin\n       Current_Argument := 0;\n       Current_Index := 0;\n@@ -732,7 +735,7 @@ package body GNAT.Command_Line is\n          end loop;\n       end loop;\n \n-      Delimiter_Found := Goto_Next_Argument_In_Section;\n+      Discard := Goto_Next_Argument_In_Section;\n    end Initialize_Option_Scan;\n \n    ---------------"}, {"sha": "9517905d410b033ef86f83e1692d40c4ee760060", "filename": "gcc/ada/g-expect.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Fg-expect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Fg-expect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.adb?ref=3f1ede06fc28db443347a22c579551d926e626d6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2005, AdaCore                     --\n+--                     Copyright (C) 2000-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1110,8 +1110,8 @@ package body GNAT.Expect is\n       Result      : Expect_Match;\n       Descriptors : Array_Of_Pd := (1 => Descriptor'Unrestricted_Access);\n \n-      Dummy : Natural;\n-      pragma Unreferenced (Dummy);\n+      Discard : Natural;\n+      pragma Warnings (Off, Discard);\n \n    begin\n       if Empty_Buffer then\n@@ -1135,7 +1135,7 @@ package body GNAT.Expect is\n \n       Call_Filters (Descriptor, Full_Str (Full_Str'First .. Last), Input);\n \n-      Dummy :=\n+      Discard :=\n         Write (Descriptor.Input_Fd,\n                Full_Str'Address,\n                Last - Full_Str'First + 1);\n@@ -1275,7 +1275,6 @@ package body GNAT.Expect is\n       Pipe3 : in out Pipe_Type)\n    is\n       pragma Warnings (Off, Pid);\n-\n    begin\n       Close (Pipe1.Input);\n       Close (Pipe2.Output);"}, {"sha": "3148afeb2e4a1f7766a2d8ef09b1c265c84b0e19", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 119, "deletions": 74, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=3f1ede06fc28db443347a22c579551d926e626d6", "patch": "@@ -37,6 +37,7 @@ with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n+with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n@@ -111,6 +112,7 @@ package body Lib.Xref is\n       if Opt.Xref_Active\n \n          --  Definition must come from source\n+\n          --  We make an exception for subprogram child units that have no\n          --  spec. For these we generate a subprogram declaration for library\n          --  use, and the corresponding entity does not come from source.\n@@ -212,17 +214,15 @@ package body Lib.Xref is\n       Ent  : Entity_Id;\n \n       function Is_On_LHS (Node : Node_Id) return Boolean;\n-      --  Used to check if a node is on the left hand side of an\n-      --  assignment. The following cases are handled:\n+      --  Used to check if a node is on the left hand side of an assignment.\n+      --  The following cases are handled:\n       --\n-      --   Variable  Node is a direct descendant of an assignment\n-      --             statement.\n+      --   Variable  Node is a direct descendant of an assignment statement.\n       --\n-      --   Prefix    Of an indexed or selected component that is\n-      --             present in a subtree rooted by an assignment\n-      --             statement. There is no restriction of nesting\n-      --             of components, thus cases such as A.B(C).D are\n-      --             handled properly.\n+      --   Prefix    Of an indexed or selected component that is present in a\n+      --             subtree rooted by an assignment statement. There is no\n+      --             restriction of nesting of components, thus cases such as\n+      --             A.B(C).D are handled properly.\n \n       ---------------\n       -- Is_On_LHS --\n@@ -240,9 +240,9 @@ package body Lib.Xref is\n             return False;\n          end if;\n \n-         --  Reach the assignment statement subtree root. In the\n-         --  case of a variable being a direct descendant of an\n-         --  assignment statement, the loop is skiped.\n+         --  Reach the assignment statement subtree root. In the case of a\n+         --  variable being a direct descendant of an assignment statement,\n+         --  the loop is skiped.\n \n          while Nkind (Parent (N)) /= N_Assignment_Statement loop\n \n@@ -270,16 +270,43 @@ package body Lib.Xref is\n    begin\n       pragma Assert (Nkind (E) in N_Entity);\n \n-      --  Check for obsolescent reference to ASCII\n+      --  Check for obsolescent reference to package ASCII. GNAT treats this\n+      --  element of annex J specially since in practice, programs make a lot\n+      --  of use of this feature, so we don't include it in the set of features\n+      --  diagnosed when Warn_On_Obsolescent_Features mode is set. However we\n+      --  are required to note it as a violation of the RM defined restriction.\n \n       if E = Standard_ASCII then\n          Check_Restriction (No_Obsolescent_Features, N);\n       end if;\n \n+      --  Check for reference to entity marked with Is_Obsolescent\n+\n+      --  Note that we always allow obsolescent references in the compiler\n+      --  itself and the run time, since we assume that we know what we are\n+      --  doing in such cases. For example the calls in Ada.Characters.Handling\n+      --  to its own obsolescent subprograms are just fine.\n+\n+      --  In any case we do not generate warnings within the extended source\n+      --  unit of the entity in question, since we assume the source unit\n+      --  itself knows what is going on (and for sure we do not want silly\n+      --  warnings, e.g. on the end line of an obsolescent procedure body).\n+\n+      if Is_Obsolescent (E)\n+        and then not GNAT_Mode\n+        and then not In_Extended_Main_Source_Unit (E)\n+      then\n+         Check_Restriction (No_Obsolescent_Features, N);\n+\n+         if Warn_On_Obsolescent_Feature then\n+            Output_Obsolescent_Entity_Warnings (N, E);\n+         end if;\n+      end if;\n+\n       --  Warn if reference to Ada 2005 entity not in Ada 2005 mode. We only\n       --  detect real explicit references (modifications and references).\n \n-      if Is_Ada_2005 (E)\n+      if Is_Ada_2005_Only (E)\n         and then Ada_Version < Ada_05\n         and then Warn_On_Ada_2005_Compatibility\n         and then (Typ = 'm' or else Typ = 'r')\n@@ -294,12 +321,23 @@ package body Lib.Xref is\n       --  case of 'p' since we want to include inherited primitive operations\n       --  from other packages.\n \n-      if not In_Extended_Main_Source_Unit (N)\n-        and then Typ /= 'e'\n-        and then Typ /= 'p'\n-        and then Typ /= 'k'\n-      then\n-         return;\n+      --  We also omit this test is this is a body reference for a subprogram\n+      --  instantiation. In this case the reference is to the generic body,\n+      --  which clearly need not be in the main unit containing the instance.\n+      --  For the same reason we accept an implicit reference generated for\n+      --  a default in an instance.\n+\n+      if not In_Extended_Main_Source_Unit (N) then\n+         if Typ = 'e'\n+           or else Typ = 'p'\n+           or else Typ = 'i'\n+           or else Typ = 'k'\n+           or else (Typ = 'b' and then Is_Generic_Instance (E))\n+         then\n+            null;\n+         else\n+            return;\n+         end if;\n       end if;\n \n       --  For reference type p, the entity must be in main source unit\n@@ -308,29 +346,27 @@ package body Lib.Xref is\n          return;\n       end if;\n \n-      --  Unless the reference is forced, we ignore references where\n-      --  the reference itself does not come from Source.\n+      --  Unless the reference is forced, we ignore references where the\n+      --  reference itself does not come from Source.\n \n       if not Force and then not Comes_From_Source (N) then\n          return;\n       end if;\n \n-      --  Deal with setting entity as referenced, unless suppressed.\n-      --  Note that we still do Set_Referenced on entities that do not\n-      --  come from source. This situation arises when we have a source\n-      --  reference to a derived operation, where the derived operation\n-      --  itself does not come from source, but we still want to mark it\n-      --  as referenced, since we really are referencing an entity in the\n-      --  corresponding package (this avoids incorrect complaints that the\n-      --  package contains no referenced entities).\n+      --  Deal with setting entity as referenced, unless suppressed. Note that\n+      --  we still do Set_Referenced on entities that do not come from source.\n+      --  This situation arises when we have a source reference to a derived\n+      --  operation, where the derived operation itself does not come from\n+      --  source, but we still want to mark it as referenced, since we really\n+      --  are referencing an entity in the corresponding package (this avoids\n+      --  wrong complaints that the package contains no referenced entities).\n \n       if Set_Ref then\n \n-         --  For a variable that appears on the left side of an\n-         --  assignment statement, we set the Referenced_As_LHS\n-         --  flag since this is indeed a left hand side.\n-         --  We also set the Referenced_As_LHS flag of a prefix\n-         --  of selected or indexed component.\n+         --  For a variable that appears on the left side of an assignment\n+         --  statement, we set the Referenced_As_LHS flag since this is indeed\n+         --  a left hand side. We also set the Referenced_As_LHS flag of a\n+         --  prefix of selected or indexed component.\n \n          if Ekind (E) = E_Variable\n            and then Is_On_LHS (N)\n@@ -343,11 +379,10 @@ package body Lib.Xref is\n          elsif Is_Non_Significant_Pragma_Reference (N) then\n             null;\n \n-         --  A reference in an attribute definition clause does not\n-         --  count as a reference except for the case of Address.\n-         --  The reason that 'Address is an exception is that it\n-         --  creates an alias through which the variable may be\n-         --  referenced.\n+         --  A reference in an attribute definition clause does not count as a\n+         --  reference except for the case of Address. The reason that 'Address\n+         --  is an exception is that it creates an alias through which the\n+         --  variable may be referenced.\n \n          elsif Nkind (Parent (N)) = N_Attribute_Definition_Clause\n            and then Chars (Parent (N)) /= Name_Address\n@@ -380,6 +415,10 @@ package body Lib.Xref is\n \n          else\n             Set_Referenced (E);\n+\n+            if Ekind (E) = E_Variable then\n+               Set_Last_Assignment (E, Empty);\n+            end if;\n          end if;\n \n          --  Check for pragma Unreferenced given and reference is within\n@@ -403,12 +442,12 @@ package body Lib.Xref is\n             elsif Is_On_LHS (N) then\n                null;\n \n-            --  For entry formals, we want to place the warning on the\n-            --  corresponding entity in the accept statement. The current\n-            --  scope is the body of the accept, so we find the formal\n-            --  whose name matches that of the entry formal (there is no\n-            --  link between the two entities, and the one in the accept\n-            --  statement is only used for conformance checking).\n+            --  For entry formals, we want to place the warning message on the\n+            --  corresponding entity in the accept statement. The current scope\n+            --  is the body of the accept, so we find the formal whose name\n+            --  matches that of the entry formal (there is no link between the\n+            --  two entities, and the one in the accept statement is only used\n+            --  for conformance checking).\n \n             elsif Ekind (Scope (E)) = E_Entry then\n                declare\n@@ -510,15 +549,12 @@ package body Lib.Xref is\n            and then Present (Alias (E))\n          then\n             Ent := Alias (E);\n-\n-            loop\n-               if Comes_From_Source (Ent) then\n-                  exit;\n-               elsif No (Alias (Ent)) then\n+            while not Comes_From_Source (Ent) loop\n+               if No (Alias (Ent)) then\n                   return;\n-               else\n-                  Ent := Alias (Ent);\n                end if;\n+\n+               Ent := Alias (Ent);\n             end loop;\n \n          --  The internally created defining entity for a child subprogram\n@@ -623,7 +659,6 @@ package body Lib.Xref is\n \n    begin\n       Formal := First_Entity (E);\n-\n       while Present (Formal) loop\n          if Comes_From_Source (Formal) then\n             Generate_Reference (E, Formal, 'z', False);\n@@ -734,9 +769,9 @@ package body Lib.Xref is\n                         Right := ')';\n                      end if;\n \n-                  --  If non-derived array, get component type.\n-                  --  Skip component type for case of String\n-                  --  or Wide_String, saves worthwhile space.\n+                  --  If non-derived array, get component type. Skip component\n+                  --  type for case of String or Wide_String, saves worthwhile\n+                  --  space.\n \n                   elsif Is_Array_Type (Tref)\n                     and then Tref /= Standard_String\n@@ -828,7 +863,10 @@ package body Lib.Xref is\n       procedure Output_Import_Export_Info (Ent : Entity_Id) is\n          Language_Name : Name_Id;\n          Conv          : constant Convention_Id := Convention (Ent);\n+\n       begin\n+         --  Generate language name from convention\n+\n          if Conv  = Convention_C then\n             Language_Name := Name_C;\n \n@@ -839,7 +877,7 @@ package body Lib.Xref is\n             Language_Name := Name_Ada;\n \n          else\n-            --  These are the only languages that GPS knows about\n+            --  For the moment we ignore all other cases ???\n \n             return;\n          end if;\n@@ -1104,6 +1142,8 @@ package body Lib.Xref is\n          -- Name_Change --\n          -----------------\n \n+         --  Why a string comparison here??? Why not compare Name_Id values???\n+\n          function Name_Change (X : Entity_Id) return Boolean is\n          begin\n             Get_Unqualified_Name_String (Chars (X));\n@@ -1358,7 +1398,6 @@ package body Lib.Xref is\n                --  Special handling for abstract types and operations\n \n                if Is_Abstract (XE.Ent) then\n-\n                   if Ctyp = 'U' then\n                      Ctyp := 'x';            --  abstract procedure\n \n@@ -1370,11 +1409,11 @@ package body Lib.Xref is\n                   end if;\n                end if;\n \n-               --  Only output reference if interesting type of entity,\n-               --  and suppress self references, except for bodies that\n-               --  act as specs. Also suppress definitions of body formals\n-               --  (we only treat these as references, and the references\n-               --  were separately recorded).\n+               --  Only output reference if interesting type of entity, and\n+               --  suppress self references, except for bodies that act as\n+               --  specs. Also suppress definitions of body formals (we only\n+               --  treat these as references, and the references were\n+               --  separately recorded).\n \n                if Ctyp = ' '\n                  or else (XE.Loc = XE.Def\n@@ -1559,6 +1598,11 @@ package body Lib.Xref is\n                            end if;\n                         end loop;\n \n+                        --  Write out the identifier by copying the exact\n+                        --  source characters used in its declaration. Note\n+                        --  that this means wide characters will be in their\n+                        --  original encoded form.\n+\n                         for J in\n                           Original_Location (Sloc (XE.Ent)) .. P - 1\n                         loop\n@@ -1628,23 +1672,24 @@ package body Lib.Xref is\n                           (Int (Get_Column_Number (Sloc (Rref))));\n                      end if;\n \n-                     --  Indicate that the entity is in the unit\n-                     --  of the current xref xection.\n+                     --  Indicate that the entity is in the unit of the current\n+                     --  xref xection.\n \n                      Curru := Curxu;\n \n-                     --  Write out information about generic parent,\n-                     --  if entity is an instance.\n+                     --  Write out information about generic parent, if entity\n+                     --  is an instance.\n \n                      if  Is_Generic_Instance (XE.Ent) then\n                         declare\n                            Gen_Par : constant Entity_Id :=\n-                             Generic_Parent\n-                               (Specification\n-                                  (Unit_Declaration_Node (XE.Ent)));\n-                           Loc : constant Source_Ptr := Sloc (Gen_Par);\n-                           Gen_U : constant Unit_Number_Type :=\n-                                     Get_Source_Unit (Loc);\n+                                       Generic_Parent\n+                                         (Specification\n+                                            (Unit_Declaration_Node (XE.Ent)));\n+                           Loc     : constant Source_Ptr := Sloc (Gen_Par);\n+                           Gen_U   : constant Unit_Number_Type :=\n+                                       Get_Source_Unit (Loc);\n+\n                         begin\n                            Write_Info_Char ('[');\n                            if Curru /= Gen_U then"}, {"sha": "530f0afcb3d2cd2fcda484e11a6b898ee75bd7fb", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 812, "deletions": 181, "changes": 993, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=3f1ede06fc28db443347a22c579551d926e626d6", "patch": "@@ -28,18 +28,23 @@ with Alloc;\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n+with Exp_Code; use Exp_Code;\n with Fname;    use Fname;\n with Lib;      use Lib;\n+with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Stringt;  use Stringt;\n with Table;\n+with Uintp;    use Uintp;\n \n package body Sem_Warn is\n \n@@ -54,83 +59,6 @@ package body Sem_Warn is\n      Table_Increment      => Alloc.Unreferenced_Entities_Increment,\n      Table_Name           => \"Unreferenced_Entities\");\n \n-   ------------------------------\n-   -- Handling of Conditionals --\n-   ------------------------------\n-\n-   --  Note: this is work in progress, the data structures and general approach\n-   --  are defined, but are not in use yet. ???\n-\n-   --  An entry is made in the following table for each branch of conditional,\n-   --  e.g. an if-then-elsif-else-endif structure creates three entries in this\n-   --  table.\n-\n-   type Branch_Entry is record\n-      Sloc : Source_Ptr;\n-      --  Location for warnings associated with this branch\n-\n-      Defs : Elist_Id;\n-      --  List of entities defined for the first time in this branch. On exit\n-      --  from a conditional structure, any entity that is in the list of all\n-      --  branches is removed (and the entity flagged as defined by the\n-      --  conditional as a whole). Thus after processing a conditional, Defs\n-      --  contains a list of entities defined in this branch for the first\n-      --  time, but not defined at all in some other branch of the same\n-      --  conditional. A value of No_Elist is used to represent the initial\n-      --  empty list.\n-\n-      Next : Nat;\n-      --  Index of next branch for this conditional, zero = last branch\n-   end record;\n-\n-   package Branch_Table is new Table.Table (\n-     Table_Component_Type => Branch_Entry,\n-     Table_Index_Type     => Nat,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => Alloc.Branches_Initial,\n-     Table_Increment      => Alloc.Branches_Increment,\n-     Table_Name           => \"Branches\");\n-\n-   --  The following table is used to represent conditionals, there is one\n-   --  entry in this table for each conditional structure.\n-\n-   type Conditional_Entry is record\n-      If_Stmt : Boolean;\n-      --  True for IF statement, False for CASE statement\n-\n-      First_Branch : Nat;\n-      --  Index in Branch table of first branch, zero = none yet\n-\n-      Current_Branch : Nat;\n-      --  Index in Branch table of current branch, zero = none yet\n-   end record;\n-\n-   package Conditional_Table is new Table.Table (\n-     Table_Component_Type => Conditional_Entry,\n-     Table_Index_Type     => Nat,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => Alloc.Conditionals_Initial,\n-     Table_Increment      => Alloc.Conditionals_Increment,\n-     Table_Name           => \"Conditionals\");\n-\n-   --  The following table is a stack that keeps track of the current\n-   --  conditional. The Last entry is the top of the stack. An Empty entry\n-   --  represents the start of a compilation unit. Non-zero entries in the\n-   --  stack are indexes into the conditional table.\n-\n-   package Conditional_Stack is new Table.Table (\n-     Table_Component_Type => Nat,\n-     Table_Index_Type     => Nat,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => Alloc.Conditional_Stack_Initial,\n-     Table_Increment      => Alloc.Conditional_Stack_Increment,\n-     Table_Name           => \"Conditional_Stack\");\n-\n-   pragma Warnings (Off, Branch_Table);\n-   pragma Warnings (Off, Conditional_Table);\n-   pragma Warnings (Off, Conditional_Stack);\n-   --  Not yet referenced, see note above ???\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -148,6 +76,49 @@ package body Sem_Warn is\n    --  the Warnings_Off flag is set. True is returned if such an entity is\n    --  encountered, and False otherwise.\n \n+   --------------------------\n+   -- Check_Code_Statement --\n+   --------------------------\n+\n+   procedure Check_Code_Statement (N : Node_Id) is\n+   begin\n+      --  If volatile, nothing to worry about\n+\n+      if Is_Asm_Volatile (N) then\n+         return;\n+      end if;\n+\n+      --  Warn if no input or no output\n+\n+      Setup_Asm_Inputs (N);\n+\n+      if No (Asm_Input_Value) then\n+         Error_Msg_F\n+           (\"?code statement with no inputs should usually be Volatile\", N);\n+         return;\n+      end if;\n+\n+      Setup_Asm_Outputs (N);\n+\n+      if No (Asm_Output_Variable) then\n+         Error_Msg_F\n+           (\"?code statement with no outputs should usually be Volatile\", N);\n+         return;\n+      end if;\n+\n+      --  Check multiple code statements in a row\n+\n+      if Is_List_Member (N)\n+        and then Present (Prev (N))\n+        and then Nkind (Prev (N)) = N_Code_Statement\n+      then\n+         Error_Msg_F\n+           (\"?code statements in sequence should usually be Volatile\", N);\n+         Error_Msg_F\n+           (\"\\?(suggest using template with multiple instructions)\", N);\n+      end if;\n+   end Check_Code_Statement;\n+\n    ----------------------\n    -- Check_References --\n    ----------------------\n@@ -431,8 +402,13 @@ package body Sem_Warn is\n                      --  Pragma Unreferenced not set, so output message\n \n                      else\n-                        Output_Reference_Error\n-                          (\"& is never assigned a value?\");\n+                        if Referenced (E1) then\n+                           Output_Reference_Error\n+                             (\"variable& is read but never assigned?\");\n+                        else\n+                           Output_Reference_Error\n+                             (\"variable& is never read and never assigned?\");\n+                        end if;\n \n                         --  Deal with special case where this variable is\n                         --  hidden by a loop variable\n@@ -1174,13 +1150,15 @@ package body Sem_Warn is\n             then\n                Lunit := Entity (Name (Item));\n \n-               --  Check if this unit is referenced\n-\n-               if not Referenced (Lunit) then\n+               --  Check if this unit is referenced (skip the check if this\n+               --  is explicitly marked by a pragma Unreferenced).\n \n+               if not Referenced (Lunit)\n+                 and then not Has_Pragma_Unreferenced (Lunit)\n+               then\n                   --  Suppress warnings in internal units if not in -gnatg mode\n                   --  (these would be junk warnings for an application program,\n-                  --  since they refer to problems in internal units)\n+                  --  since they refer to problems in internal units).\n \n                   if GNAT_Mode\n                     or else not Is_Internal_File_Name (Unit_File_Name (Unit))\n@@ -1202,9 +1180,14 @@ package body Sem_Warn is\n \n                --  If main unit is a renaming of this unit, then we consider\n                --  the with to be OK (obviously it is needed in this case!)\n+               --  This may be transitive: the unit in the with_clause may\n+               --  itself be a renaming, in which case both it and the main\n+               --  unit rename the same ultimate package.\n \n                elsif Present (Renamed_Entity (Munite))\n-                  and then Renamed_Entity (Munite) = Lunit\n+                  and then\n+                    (Renamed_Entity (Munite) = Lunit\n+                      or else Renamed_Entity (Munite) = Renamed_Entity (Lunit))\n                then\n                   null;\n \n@@ -1291,7 +1274,7 @@ package body Sem_Warn is\n                         then\n                            --  This means that the with is indeed fine, in that\n                            --  it is definitely needed somewhere, and we can\n-                           --  quite worrying about this one.\n+                           --  quit worrying about this one.\n \n                            --  Except for one little detail, if either of the\n                            --  flags was set during spec processing, this is\n@@ -1488,6 +1471,149 @@ package body Sem_Warn is\n          return False;\n    end Operand_Has_Warnings_Suppressed;\n \n+   ----------------------------------------\n+   -- Output_Obsolescent_Entity_Warnings --\n+   ----------------------------------------\n+\n+   procedure Output_Obsolescent_Entity_Warnings (N : Node_Id; E : Entity_Id) is\n+      P : constant Node_Id := Parent (N);\n+      S : Entity_Id;\n+\n+   begin\n+      S := Current_Scope;\n+\n+      --  Do not output message if we are the scope of standard. This means\n+      --  we have a reference from a context clause from when it is originally\n+      --  processed, and that's too early to tell whether it is an obsolescent\n+      --  unit doing the with'ing. In Sem_Ch10.Analyze_Compilation_Unit we make\n+      --  sure that we have a later call when the scope is available. This test\n+      --  also eliminates all messages for use clauses, which is fine (we do\n+      --  not want messages for use clauses, since they are always redundant\n+      --  with respect to the associated with clause).\n+\n+      if S = Standard_Standard then\n+         return;\n+      end if;\n+\n+      --  Do not output message if we are in scope of an obsolescent package\n+      --  or subprogram.\n+\n+      loop\n+         if Is_Obsolescent (S) then\n+            return;\n+         end if;\n+\n+         S := Scope (S);\n+         exit when S = Standard_Standard;\n+      end loop;\n+\n+      --  Here we will output the message\n+\n+      Error_Msg_Sloc := Sloc (E);\n+\n+      --  Case of with clause\n+\n+      if Nkind (P) = N_With_Clause then\n+         if Ekind (E) = E_Package then\n+            Error_Msg_NE\n+              (\"?with of obsolescent package& declared#\", N, E);\n+         elsif Ekind (E) = E_Procedure then\n+            Error_Msg_NE\n+              (\"?with of obsolescent procedure& declared#\", N, E);\n+         else\n+            Error_Msg_NE\n+              (\"?with of obsolescent function& declared#\", N, E);\n+         end if;\n+\n+      --  If we do not have a with clause, then ignore any reference to an\n+      --  obsolescent package name. We only want to give the one warning of\n+      --  withing the package, not one each time it is used to qualify.\n+\n+      elsif Ekind (E) = E_Package then\n+         return;\n+\n+      --  Procedure call statement\n+\n+      elsif Nkind (P) = N_Procedure_Call_Statement then\n+         Error_Msg_NE\n+           (\"?call to obsolescent procedure& declared#\", N, E);\n+\n+      --  Function call\n+\n+      elsif Nkind (P) = N_Function_Call then\n+         Error_Msg_NE\n+           (\"?call to obsolescent function& declared#\", N, E);\n+\n+      --  Reference to obsolescent type\n+\n+      elsif Is_Type (E) then\n+         Error_Msg_NE\n+           (\"?reference to obsolescent type& declared#\", N, E);\n+\n+      --  Reference to obsolescent component\n+\n+      elsif Ekind (E) = E_Component\n+        or else Ekind (E) = E_Discriminant\n+      then\n+         Error_Msg_NE\n+           (\"?reference to obsolescent component& declared#\", N, E);\n+\n+      --  Reference to obsolescent variable\n+\n+      elsif Ekind (E) = E_Variable then\n+         Error_Msg_NE\n+           (\"?reference to obsolescent variable& declared#\", N, E);\n+\n+      --  Reference to obsolescent constant\n+\n+      elsif Ekind (E) = E_Constant\n+        or else Ekind (E) in Named_Kind\n+      then\n+         Error_Msg_NE\n+           (\"?reference to obsolescent constant& declared#\", N, E);\n+\n+      --  Reference to obsolescent enumeration literal\n+\n+      elsif Ekind (E) = E_Enumeration_Literal then\n+         Error_Msg_NE\n+           (\"?reference to obsolescent enumeration literal& declared#\", N, E);\n+\n+      --  Generic message for any other case we missed\n+\n+      else\n+         Error_Msg_NE\n+           (\"?reference to obsolescent entity& declared#\", N, E);\n+      end if;\n+\n+      --  Output additional warning if present\n+\n+      declare\n+         W : constant Node_Id := Obsolescent_Warning (E);\n+\n+      begin\n+         if Present (W) then\n+\n+            --  This is a warning continuation to start on a new line\n+            Name_Buffer (1) := '\\';\n+            Name_Buffer (2) := '\\';\n+            Name_Buffer (3) := '?';\n+            Name_Len := 3;\n+\n+            --  Add characters to message, and output message. Note that\n+            --  we quote every character of the message since we don't\n+            --  want to process any insertions.\n+\n+            for J in 1 .. String_Length (Strval (W)) loop\n+               Add_Char_To_Name_Buffer (''');\n+               Add_Char_To_Name_Buffer\n+                 (Get_Character (Get_String_Char (Strval (W), J)));\n+            end loop;\n+\n+            Error_Msg_N (Name_Buffer (1 .. Name_Len), N);\n+         end if;\n+      end;\n+   end Output_Obsolescent_Entity_Warnings;\n+\n    ----------------------------------\n    -- Output_Unreferenced_Messages --\n    ----------------------------------\n@@ -1516,29 +1642,47 @@ package body Sem_Warn is\n                      if Warn_On_Modified_Unread\n                        and then not Is_Imported (E)\n \n-                        --  Suppress the message for aliased or renamed\n-                        --  variables, since there may be other entities read\n-                        --  the same memory location.\n+                        --  Suppress message for aliased or renamed variables,\n+                        --  since there may be other entities that read the\n+                        --  same memory location.\n \n                        and then not Is_Aliased (E)\n                        and then No (Renamed_Object (E))\n \n                      then\n                         Error_Msg_N\n                           (\"variable & is assigned but never read?\", E);\n+                        Set_Last_Assignment (E, Empty);\n                      end if;\n \n                   --  Normal case of neither assigned nor read\n \n                   else\n-                     if Present (Renamed_Object (E))\n-                       and then Comes_From_Source (Renamed_Object (E))\n+                     --  We suppress the message for limited controlled types,\n+                     --  to catch the common design pattern (known as RAII, or\n+                     --  Resource Acquisition Is Initialization) which uses\n+                     --  such types solely for their initialization and\n+                     --  finalization semantics.\n+\n+                     if Is_Controlled (Etype (E))\n+                       and then Is_Limited_Type (Etype (E))\n                      then\n-                        Error_Msg_N\n-                          (\"renamed variable & is not referenced?\", E);\n+                        null;\n+\n+                     --  Normal case where we want to give message\n+\n                      else\n-                        Error_Msg_N\n-                          (\"variable & is not referenced?\", E);\n+                        --  Distinguish renamed case in message\n+\n+                        if Present (Renamed_Object (E))\n+                          and then Comes_From_Source (Renamed_Object (E))\n+                        then\n+                           Error_Msg_N\n+                             (\"renamed variable & is not referenced?\", E);\n+                        else\n+                           Error_Msg_N\n+                             (\"variable & is not referenced?\", E);\n+                        end if;\n                      end if;\n                   end if;\n \n@@ -1604,176 +1748,192 @@ package body Sem_Warn is\n    begin\n       case C is\n          when 'a' =>\n-            Check_Unreferenced              := True;\n-            Check_Unreferenced_Formals      := True;\n-            Check_Withs                     := True;\n-            Constant_Condition_Warnings     := True;\n-            Implementation_Unit_Warnings    := True;\n-            Ineffective_Inline_Warnings     := True;\n-            Warn_On_Ada_2005_Compatibility  := True;\n-            Warn_On_Bad_Fixed_Value         := True;\n-            Warn_On_Constant                := True;\n-            Warn_On_Export_Import           := True;\n-            Warn_On_Modified_Unread         := True;\n-            Warn_On_No_Value_Assigned       := True;\n-            Warn_On_Obsolescent_Feature     := True;\n-            Warn_On_Redundant_Constructs    := True;\n-            Warn_On_Unchecked_Conversion    := True;\n-            Warn_On_Unrecognized_Pragma     := True;\n+            Check_Unreferenced                  := True;\n+            Check_Unreferenced_Formals          := True;\n+            Check_Withs                         := True;\n+            Constant_Condition_Warnings         := True;\n+            Implementation_Unit_Warnings        := True;\n+            Ineffective_Inline_Warnings         := True;\n+            Warn_On_Ada_2005_Compatibility      := True;\n+            Warn_On_Assumed_Low_Bound           := True;\n+            Warn_On_Bad_Fixed_Value             := True;\n+            Warn_On_Constant                    := True;\n+            Warn_On_Export_Import               := True;\n+            Warn_On_Modified_Unread             := True;\n+            Warn_On_No_Value_Assigned           := True;\n+            Warn_On_Obsolescent_Feature         := True;\n+            Warn_On_Questionable_Missing_Parens := True;\n+            Warn_On_Redundant_Constructs        := True;\n+            Warn_On_Unchecked_Conversion        := True;\n+            Warn_On_Unrecognized_Pragma         := True;\n \n          when 'A' =>\n-            Check_Unreferenced              := False;\n-            Check_Unreferenced_Formals      := False;\n-            Check_Withs                     := False;\n-            Constant_Condition_Warnings     := False;\n-            Elab_Warnings                   := False;\n-            Implementation_Unit_Warnings    := False;\n-            Ineffective_Inline_Warnings     := False;\n-            Warn_On_Ada_2005_Compatibility  := False;\n-            Warn_On_Bad_Fixed_Value         := False;\n-            Warn_On_Constant                := False;\n-            Warn_On_Dereference             := False;\n-            Warn_On_Export_Import           := False;\n-            Warn_On_Hiding                  := False;\n-            Warn_On_Modified_Unread         := False;\n-            Warn_On_No_Value_Assigned       := False;\n-            Warn_On_Obsolescent_Feature     := False;\n-            Warn_On_Redundant_Constructs    := False;\n-            Warn_On_Unchecked_Conversion    := False;\n-            Warn_On_Unrecognized_Pragma     := False;\n+            Check_Unreferenced                  := False;\n+            Check_Unreferenced_Formals          := False;\n+            Check_Withs                         := False;\n+            Constant_Condition_Warnings         := False;\n+            Elab_Warnings                       := False;\n+            Implementation_Unit_Warnings        := False;\n+            Ineffective_Inline_Warnings         := False;\n+            Warn_On_Ada_2005_Compatibility      := False;\n+            Warn_On_Bad_Fixed_Value             := False;\n+            Warn_On_Constant                    := False;\n+            Warn_On_Deleted_Code                := False;\n+            Warn_On_Dereference                 := False;\n+            Warn_On_Export_Import               := False;\n+            Warn_On_Hiding                      := False;\n+            Warn_On_Modified_Unread             := False;\n+            Warn_On_No_Value_Assigned           := False;\n+            Warn_On_Obsolescent_Feature         := False;\n+            Warn_On_Questionable_Missing_Parens := True;\n+            Warn_On_Redundant_Constructs        := False;\n+            Warn_On_Unchecked_Conversion        := False;\n+            Warn_On_Unrecognized_Pragma         := False;\n \n          when 'b' =>\n-            Warn_On_Bad_Fixed_Value         := True;\n+            Warn_On_Bad_Fixed_Value             := True;\n \n          when 'B' =>\n-            Warn_On_Bad_Fixed_Value         := False;\n+            Warn_On_Bad_Fixed_Value             := False;\n \n          when 'c' =>\n-            Constant_Condition_Warnings     := True;\n+            Constant_Condition_Warnings         := True;\n \n          when 'C' =>\n-            Constant_Condition_Warnings     := False;\n+            Constant_Condition_Warnings         := False;\n \n          when 'd' =>\n-            Warn_On_Dereference             := True;\n+            Warn_On_Dereference                 := True;\n \n          when 'D' =>\n-            Warn_On_Dereference             := False;\n+            Warn_On_Dereference                 := False;\n \n          when 'e' =>\n-            Warning_Mode                    := Treat_As_Error;\n+            Warning_Mode                        := Treat_As_Error;\n \n          when 'f' =>\n-            Check_Unreferenced_Formals      := True;\n+            Check_Unreferenced_Formals          := True;\n \n          when 'F' =>\n-            Check_Unreferenced_Formals      := False;\n+            Check_Unreferenced_Formals          := False;\n \n          when 'g' =>\n-            Warn_On_Unrecognized_Pragma     := True;\n+            Warn_On_Unrecognized_Pragma         := True;\n \n          when 'G' =>\n-            Warn_On_Unrecognized_Pragma     := False;\n+            Warn_On_Unrecognized_Pragma         := False;\n \n          when 'h' =>\n-            Warn_On_Hiding                  := True;\n+            Warn_On_Hiding                      := True;\n \n          when 'H' =>\n-            Warn_On_Hiding                  := False;\n+            Warn_On_Hiding                      := False;\n \n          when 'i' =>\n-            Implementation_Unit_Warnings    := True;\n+            Implementation_Unit_Warnings        := True;\n \n          when 'I' =>\n-            Implementation_Unit_Warnings    := False;\n+            Implementation_Unit_Warnings        := False;\n \n          when 'j' =>\n-            Warn_On_Obsolescent_Feature     := True;\n+            Warn_On_Obsolescent_Feature         := True;\n \n          when 'J' =>\n-            Warn_On_Obsolescent_Feature     := False;\n+            Warn_On_Obsolescent_Feature         := False;\n \n          when 'k' =>\n-            Warn_On_Constant                := True;\n+            Warn_On_Constant                    := True;\n \n          when 'K' =>\n-            Warn_On_Constant                := False;\n+            Warn_On_Constant                    := False;\n \n          when 'l' =>\n-            Elab_Warnings                   := True;\n+            Elab_Warnings                       := True;\n \n          when 'L' =>\n-            Elab_Warnings                   := False;\n+            Elab_Warnings                       := False;\n \n          when 'm' =>\n-            Warn_On_Modified_Unread         := True;\n+            Warn_On_Modified_Unread             := True;\n \n          when 'M' =>\n-            Warn_On_Modified_Unread         := False;\n+            Warn_On_Modified_Unread             := False;\n \n          when 'n' =>\n-            Warning_Mode                    := Normal;\n+            Warning_Mode                        := Normal;\n \n          when 'o' =>\n-            Address_Clause_Overlay_Warnings := True;\n+            Address_Clause_Overlay_Warnings     := True;\n \n          when 'O' =>\n-            Address_Clause_Overlay_Warnings := False;\n+            Address_Clause_Overlay_Warnings     := False;\n \n          when 'p' =>\n-            Ineffective_Inline_Warnings     := True;\n+            Ineffective_Inline_Warnings         := True;\n \n          when 'P' =>\n-            Ineffective_Inline_Warnings     := False;\n+            Ineffective_Inline_Warnings         := False;\n+\n+         when 'q' =>\n+            Warn_On_Questionable_Missing_Parens := True;\n+\n+         when 'Q' =>\n+            Warn_On_Questionable_Missing_Parens := False;\n \n          when 'r' =>\n-            Warn_On_Redundant_Constructs    := True;\n+            Warn_On_Redundant_Constructs        := True;\n \n          when 'R' =>\n-            Warn_On_Redundant_Constructs    := False;\n+            Warn_On_Redundant_Constructs        := False;\n \n          when 's' =>\n-            Warning_Mode                    := Suppress;\n+            Warning_Mode                        := Suppress;\n+\n+         when 't' =>\n+            Warn_On_Deleted_Code                := True;\n+\n+         when 'T' =>\n+            Warn_On_Deleted_Code                := False;\n \n          when 'u' =>\n-            Check_Unreferenced              := True;\n-            Check_Withs                     := True;\n-            Check_Unreferenced_Formals      := True;\n+            Check_Unreferenced                  := True;\n+            Check_Withs                         := True;\n+            Check_Unreferenced_Formals          := True;\n \n          when 'U' =>\n-            Check_Unreferenced              := False;\n-            Check_Withs                     := False;\n-            Check_Unreferenced_Formals      := False;\n+            Check_Unreferenced                  := False;\n+            Check_Withs                         := False;\n+            Check_Unreferenced_Formals          := False;\n \n          when 'v' =>\n-            Warn_On_No_Value_Assigned       := True;\n+            Warn_On_No_Value_Assigned           := True;\n \n          when 'V' =>\n-            Warn_On_No_Value_Assigned       := False;\n+            Warn_On_No_Value_Assigned           := False;\n+\n+         when 'w' =>\n+            Warn_On_Assumed_Low_Bound           := True;\n+\n+         when 'W' =>\n+            Warn_On_Assumed_Low_Bound           := False;\n \n          when 'x' =>\n-            Warn_On_Export_Import           := True;\n+            Warn_On_Export_Import               := True;\n \n          when 'X' =>\n-            Warn_On_Export_Import           := False;\n+            Warn_On_Export_Import               := False;\n \n          when 'y' =>\n-            Warn_On_Ada_2005_Compatibility  := True;\n+            Warn_On_Ada_2005_Compatibility      := True;\n \n          when 'Y' =>\n-            Warn_On_Ada_2005_Compatibility  := False;\n+            Warn_On_Ada_2005_Compatibility      := False;\n \n          when 'z' =>\n-            Warn_On_Unchecked_Conversion    := True;\n+            Warn_On_Unchecked_Conversion        := True;\n \n          when 'Z' =>\n-            Warn_On_Unchecked_Conversion    := False;\n-\n-            --  Allow and ignore 'w' so that the old\n-            --  format (e.g. -gnatwuwl) will work.\n-\n-         when 'w' =>\n-            null;\n+            Warn_On_Unchecked_Conversion        := False;\n \n          when others =>\n             return False;\n@@ -1789,6 +1949,52 @@ package body Sem_Warn is\n    procedure Warn_On_Known_Condition (C : Node_Id) is\n       P : Node_Id;\n \n+      procedure Track (N : Node_Id; Loc : Node_Id);\n+      --  Adds continuation warning(s) pointing to reason (assignment or test)\n+      --  for the operand of the conditional having a known value (or at least\n+      --  enough is known about the value to issue the warning). N is the node\n+      --  which is judged to have a known value. Loc is the warning location.\n+\n+      -----------\n+      -- Track --\n+      -----------\n+\n+      procedure Track (N : Node_Id; Loc : Node_Id) is\n+         Nod : constant Node_Id := Original_Node (N);\n+\n+      begin\n+         if Nkind (Nod) in N_Op_Compare then\n+            Track (Left_Opnd (Nod), Loc);\n+            Track (Right_Opnd (Nod), Loc);\n+\n+         elsif Is_Entity_Name (Nod)\n+           and then Is_Object (Entity (Nod))\n+         then\n+            declare\n+               CV : constant Node_Id := Current_Value (Entity (Nod));\n+\n+            begin\n+               if Present (CV) then\n+                  Error_Msg_Sloc := Sloc (CV);\n+\n+                  if Nkind (CV) not in N_Subexpr then\n+                     Error_Msg_N (\"\\\\?(see test #)\", Loc);\n+\n+                  elsif Nkind (Parent (CV)) =\n+                          N_Case_Statement_Alternative\n+                  then\n+                     Error_Msg_N (\"\\\\?(see case alternative #)\", Loc);\n+\n+                  else\n+                     Error_Msg_N (\"\\\\?(see assignment #)\", Loc);\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+      end Track;\n+\n+   --  Start of processing for Warn_On_Known_Condition\n+\n    begin\n       --   Argument replacement in an inlined body can make conditions static.\n       --   Do not emit warnings in this case.\n@@ -1869,16 +2075,441 @@ package body Sem_Warn is\n                     and then Nkind (Cond) /= N_Op_Not\n                   then\n                      Error_Msg_NE\n-                      (\"object & is always True?\", Cond, Original_Node (C));\n+                       (\"object & is always True?\", Cond, Original_Node (C));\n+                     Track (Original_Node (C), Cond);\n+\n                   else\n                      Error_Msg_N (\"condition is always True?\", Cond);\n+                     Track (Cond, Cond);\n                   end if;\n+\n                else\n                   Error_Msg_N (\"condition is always False?\", Cond);\n+                  Track (Cond, Cond);\n                end if;\n             end;\n          end if;\n       end if;\n    end Warn_On_Known_Condition;\n \n+   ------------------------------\n+   -- Warn_On_Suspicious_Index --\n+   ------------------------------\n+\n+   procedure Warn_On_Suspicious_Index (Name : Entity_Id; X : Node_Id) is\n+\n+      Low_Bound : Uint;\n+      --  Set to lower bound for a suspicious type\n+\n+      Ent : Entity_Id;\n+      --  Entity for array reference\n+\n+      Typ : Entity_Id;\n+      --  Array type\n+\n+      function Is_Suspicious_Type (Typ : Entity_Id) return Boolean;\n+      --  Tests to see if Typ is a type for which we may have a suspicious\n+      --  index, namely an unconstrained array type, whose lower bound is\n+      --  either zero or one. If so, True is returned, and Low_Bound is set\n+      --  to this lower bound. If not, False is returned, and Low_Bound is\n+      --  undefined on return.\n+      --\n+      --  For now, we limite this to standard string types, so any other\n+      --  unconstrained types return False. We may change our minds on this\n+      --  later on, but strings seem the most important case.\n+\n+      procedure Test_Suspicious_Index;\n+      --  Test if index is of suspicious type and if so, generate warning\n+\n+      ------------------------\n+      -- Is_Suspicious_Type --\n+      ------------------------\n+\n+      function Is_Suspicious_Type (Typ : Entity_Id) return Boolean is\n+         LB : Node_Id;\n+\n+      begin\n+         if Is_Array_Type (Typ)\n+           and then not Is_Constrained (Typ)\n+           and then Number_Dimensions (Typ) = 1\n+           and then not Warnings_Off (Typ)\n+           and then (Root_Type (Typ) = Standard_String\n+                       or else\n+                     Root_Type (Typ) = Standard_Wide_String\n+                       or else\n+                     Root_Type (Typ) = Standard_Wide_Wide_String)\n+         then\n+            LB := Type_Low_Bound (Etype (First_Index (Typ)));\n+\n+            if Compile_Time_Known_Value (LB) then\n+               Low_Bound := Expr_Value (LB);\n+               return Low_Bound = Uint_0 or else Low_Bound = Uint_1;\n+            end if;\n+         end if;\n+\n+         return False;\n+      end Is_Suspicious_Type;\n+\n+      ---------------------------\n+      -- Test_Suspicious_Index --\n+      ---------------------------\n+\n+      procedure Test_Suspicious_Index is\n+\n+         function Length_Reference (N : Node_Id) return Boolean;\n+         --  Check if node N is of the form Name'Length\n+\n+         procedure Warn1;\n+         --  Generate first warning line\n+\n+         ----------------------\n+         -- Length_Reference --\n+         ----------------------\n+\n+         function Length_Reference (N : Node_Id) return Boolean is\n+            R : constant Node_Id := Original_Node (N);\n+         begin\n+            return\n+              Nkind (R) = N_Attribute_Reference\n+               and then Attribute_Name (R) = Name_Length\n+               and then Is_Entity_Name (Prefix (R))\n+               and then Entity (Prefix (R)) = Ent;\n+         end Length_Reference;\n+\n+         -----------\n+         -- Warn1 --\n+         -----------\n+\n+         procedure Warn1 is\n+         begin\n+            Error_Msg_Uint_1 := Low_Bound;\n+            Error_Msg_FE (\"?index for& may assume lower bound of^\", X, Ent);\n+         end Warn1;\n+\n+      --  Start of processing for Test_Suspicious_Index\n+\n+      begin\n+         --  Nothing to do if subscript does not come from source (we don't\n+         --  want to give garbage warnings on compiler expanded code, e.g. the\n+         --  loops generated for slice assignments. Sucb junk warnings would\n+         --  be placed on source constructs with no subscript in sight!)\n+\n+         if not Comes_From_Source (Original_Node (X)) then\n+            return;\n+         end if;\n+\n+         --  Case where subscript is a constant integer\n+\n+         if Nkind (X) = N_Integer_Literal then\n+            Warn1;\n+\n+            --  Case where original form of subscript is an integer literal\n+\n+            if Nkind (Original_Node (X)) = N_Integer_Literal then\n+               if Intval (X) = Low_Bound then\n+                  Error_Msg_FE\n+                    (\"\\suggested replacement: `&''First`\", X, Ent);\n+               else\n+                  Error_Msg_Uint_1 := Intval (X) - Low_Bound;\n+                  Error_Msg_FE\n+                    (\"\\suggested replacement: `&''First + ^`\", X, Ent);\n+\n+               end if;\n+\n+            --  Case where original form of subscript is more complex\n+\n+            else\n+               --  Build string X'First - 1 + expression where the expression\n+               --  is the original subscript. If the expression starts with \"1\n+               --  + \", then the \"- 1 + 1\" is elided.\n+\n+               Error_Msg_String (1 .. 13) := \"'First - 1 + \";\n+               Error_Msg_Strlen := 13;\n+\n+               declare\n+                  Sref : Source_Ptr := Sloc (First_Node (Original_Node (X)));\n+                  Tref : constant Source_Buffer_Ptr :=\n+                           Source_Text (Get_Source_File_Index (Sref));\n+                  --  Tref (Sref) is used to scan the subscript\n+\n+                  Pctr : Natural;\n+                  --  Paretheses counter when scanning subscript\n+\n+               begin\n+                  --  Tref (Sref) points to start of subscript\n+\n+                  --  Elide - 1 if subscript starts with 1 +\n+\n+                  if Tref (Sref .. Sref + 2) = \"1 +\" then\n+                     Error_Msg_Strlen := Error_Msg_Strlen - 6;\n+                     Sref := Sref + 2;\n+\n+                  elsif Tref (Sref .. Sref + 1) = \"1+\" then\n+                     Error_Msg_Strlen := Error_Msg_Strlen - 6;\n+                     Sref := Sref + 1;\n+                  end if;\n+\n+                  --  Now we will copy the subscript to the string buffer\n+\n+                  Pctr := 0;\n+                  loop\n+                     --  Count parens, exit if terminating right paren. Note\n+                     --  check to ignore paren appearing as character literal.\n+\n+                     if Tref (Sref + 1) = '''\n+                          and then\n+                        Tref (Sref - 1) = '''\n+                     then\n+                        null;\n+                     else\n+                        if Tref (Sref) = '(' then\n+                           Pctr := Pctr + 1;\n+                        elsif Tref (Sref) = ')' then\n+                           exit when Pctr = 0;\n+                           Pctr := Pctr - 1;\n+                        end if;\n+                     end if;\n+\n+                     --  Done if terminating double dot (slice case)\n+\n+                     exit when Pctr = 0\n+                       and then (Tref (Sref .. Sref + 1) = \"..\"\n+                                  or else\n+                                 Tref (Sref .. Sref + 2) = \" ..\");\n+\n+                     --  Quit if we have hit EOF character, something wrong\n+\n+                     if Tref (Sref) = EOF then\n+                        return;\n+                     end if;\n+\n+                     --  String literals are too much of a pain to handle\n+\n+                     if Tref (Sref) = '\"' or else Tref (Sref) = '%' then\n+                        return;\n+                     end if;\n+\n+                     --  If we have a 'Range reference, then this is a case\n+                     --  where we cannot easily give a replacement. Don't try!\n+\n+                     if Tref (Sref .. Sref + 4) = \"range\"\n+                       and then Tref (Sref - 1) < 'A'\n+                       and then Tref (Sref + 5) < 'A'\n+                     then\n+                        return;\n+                     end if;\n+\n+                     --  Else store next character\n+\n+                     Error_Msg_Strlen := Error_Msg_Strlen + 1;\n+                     Error_Msg_String (Error_Msg_Strlen) := Tref (Sref);\n+                     Sref := Sref + 1;\n+\n+                     --  If we get more than 40 characters then the expression\n+                     --  is too long to copy, or something has gone wrong. In\n+                     --  either case, just skip the attempt at a suggested fix.\n+\n+                     if Error_Msg_Strlen > 40 then\n+                        return;\n+                     end if;\n+                  end loop;\n+               end;\n+\n+               --  Replacement subscript is now in string buffer\n+\n+               Error_Msg_FE\n+                 (\"\\suggested replacement: `&~`\", Original_Node (X), Ent);\n+            end if;\n+\n+         --  Case where subscript is of the form X'Length\n+\n+         elsif Length_Reference (X) then\n+            Warn1;\n+            Error_Msg_Node_2 := Ent;\n+            Error_Msg_FE\n+              (\"\\suggest replacement of `&''Length` by `&''Last`\",\n+               X, Ent);\n+\n+         --  Case where subscript is of the form X'Length - expression\n+\n+         elsif Nkind (X) = N_Op_Subtract\n+           and then Length_Reference (Left_Opnd (X))\n+         then\n+            Warn1;\n+            Error_Msg_Node_2 := Ent;\n+            Error_Msg_FE\n+              (\"\\suggest replacement of `&''Length` by `&''Last`\",\n+               Left_Opnd (X), Ent);\n+         end if;\n+      end Test_Suspicious_Index;\n+\n+   --  Start of processing for Warn_On_Suspicious_Index\n+\n+   begin\n+      --  Only process if warnings activated\n+\n+      if Warn_On_Assumed_Low_Bound then\n+\n+         --  Test if array is simple entity name\n+\n+         if Is_Entity_Name (Name) then\n+\n+            --  Test if array is parameter of unconstrained string type\n+\n+            Ent := Entity (Name);\n+            Typ := Etype (Ent);\n+\n+            if Is_Formal (Ent)\n+              and then Is_Suspicious_Type (Typ)\n+              and then not Low_Bound_Known (Ent)\n+            then\n+               Test_Suspicious_Index;\n+            end if;\n+         end if;\n+      end if;\n+   end Warn_On_Suspicious_Index;\n+\n+   --------------------------------\n+   -- Warn_On_Useless_Assignment --\n+   --------------------------------\n+\n+   procedure Warn_On_Useless_Assignment\n+     (Ent : Entity_Id;\n+      Loc : Source_Ptr := No_Location)\n+   is\n+      P : Node_Id;\n+      X : Node_Id;\n+\n+      function Check_Ref (N : Node_Id) return Traverse_Result;\n+      --  Used to instantiate Traverse_Func. Returns Abandon if\n+      --  a reference to the entity in question is found.\n+\n+      function Test_No_Refs is new Traverse_Func (Check_Ref);\n+\n+      ---------------\n+      -- Check_Ref --\n+      ---------------\n+\n+      function Check_Ref (N : Node_Id) return Traverse_Result is\n+      begin\n+         --  Check reference to our identifier. We use name equality here\n+         --  because the exception handlers have not yet been analyzed. This\n+         --  is not quite right, but it really does not matter that we fail\n+         --  to output the warning in some obscure cases of name clashes.\n+\n+         if Nkind (N) = N_Identifier\n+           and then Chars (N) = Chars (Ent)\n+         then\n+            return Abandon;\n+         else\n+            return OK;\n+         end if;\n+      end Check_Ref;\n+\n+   --  Start of processing for Warn_On_Useless_Assignment\n+\n+   begin\n+      --  Check if this is a case we want to warn on, a variable with\n+      --  the last assignment field set, with warnings enabled, and\n+      --  which is not imported or exported.\n+\n+      if Ekind (Ent) = E_Variable\n+        and then Present (Last_Assignment (Ent))\n+        and then not Warnings_Off (Ent)\n+        and then not Has_Pragma_Unreferenced (Ent)\n+        and then not Is_Imported (Ent)\n+        and then not Is_Exported (Ent)\n+      then\n+         --  Before we issue the message, check covering exception handlers.\n+         --  Search up tree for enclosing statement sequences and handlers\n+\n+         P := Parent (Last_Assignment (Ent));\n+         while Present (P) loop\n+\n+            --  Something is really wrong if we don't find a handled\n+            --  statement sequence, so just suppress the warning.\n+\n+            if No (P) then\n+               Set_Last_Assignment (Ent, Empty);\n+               return;\n+\n+            --  When we hit a package/subprogram body, issue warning and exit\n+\n+            elsif Nkind (P) = N_Subprogram_Body\n+              or else Nkind (P) = N_Package_Body\n+            then\n+               if Loc = No_Location then\n+                  Error_Msg_NE\n+                    (\"?useless assignment to&, value never referenced\",\n+                     Last_Assignment (Ent), Ent);\n+               else\n+                  Error_Msg_Sloc := Loc;\n+                  Error_Msg_NE\n+                    (\"?useless assignment to&, value overwritten #\",\n+                     Last_Assignment (Ent), Ent);\n+               end if;\n+\n+               Set_Last_Assignment (Ent, Empty);\n+               return;\n+\n+            --  Enclosing handled sequence of statements\n+\n+            elsif Nkind (P) = N_Handled_Sequence_Of_Statements then\n+\n+               --  Check exception handlers present\n+\n+               if Present (Exception_Handlers (P)) then\n+\n+                  --  If we are not at the top level, we regard an inner\n+                  --  exception handler as a decisive indicator that we should\n+                  --  not generate the warning, since the variable in question\n+                  --  may be acceessed after an exception in the outer block.\n+\n+                  if Nkind (Parent (P)) /= N_Subprogram_Body\n+                    and then Nkind (Parent (P)) /= N_Package_Body\n+                  then\n+                     Set_Last_Assignment (Ent, Empty);\n+                     return;\n+\n+                     --  Otherwise we are at the outer level. An exception\n+                     --  handler is significant only if it references the\n+                     --  variable in question.\n+\n+                  else\n+                     X := First (Exception_Handlers (P));\n+                     while Present (X) loop\n+                        if Test_No_Refs (X) = Abandon then\n+                           Set_Last_Assignment (Ent, Empty);\n+                           return;\n+                        end if;\n+\n+                        X := Next (X);\n+                     end loop;\n+                  end if;\n+               end if;\n+            end if;\n+\n+            P := Parent (P);\n+         end loop;\n+      end if;\n+   end Warn_On_Useless_Assignment;\n+\n+   ---------------------------------\n+   -- Warn_On_Useless_Assignments --\n+   ---------------------------------\n+\n+   procedure Warn_On_Useless_Assignments (E : Entity_Id) is\n+      Ent : Entity_Id;\n+   begin\n+      if Warn_On_Modified_Unread\n+        and then In_Extended_Main_Source_Unit (E)\n+      then\n+         Ent := First_Entity (E);\n+         while Present (Ent) loop\n+            Warn_On_Useless_Assignment (Ent);\n+            Next_Entity (Ent);\n+         end loop;\n+      end if;\n+   end Warn_On_Useless_Assignments;\n+\n end Sem_Warn;"}, {"sha": "25dafaa71e7b20324354c2f0ca93306760e85b59", "filename": "gcc/ada/sem_warn.ads", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Fsem_warn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Fsem_warn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.ads?ref=3f1ede06fc28db443347a22c579551d926e626d6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1999-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -98,6 +98,11 @@ package Sem_Warn is\n    -- Output Routines --\n    ---------------------\n \n+   procedure Output_Obsolescent_Entity_Warnings (N : Node_Id; E : Entity_Id);\n+   --  N is a reference to obsolescent entity E, for which appropriate warning\n+   --  messages are to be generated (caller has already checked that warnings\n+   --  are active and appropriate for this entity).\n+\n    procedure Output_Unreferenced_Messages;\n    --  Warnings about unreferenced entities are collected till the end of\n    --  the compilation process (see Check_Unset_Reference for further\n@@ -107,6 +112,9 @@ package Sem_Warn is\n    -- Other Warning Routines --\n    ----------------------------\n \n+   procedure Check_Code_Statement (N : Node_Id);\n+   --  Peform warning checks on a code statement node\n+\n    procedure Warn_On_Known_Condition (C : Node_Id);\n    --  C is a node for a boolean expression resluting from a relational\n    --  or membership operation. If the expression has a compile time known\n@@ -132,4 +140,29 @@ package Sem_Warn is\n    --  If all these conditions are met, the warning is issued noting that\n    --  the result of the test is always false or always true as appropriate.\n \n+   procedure Warn_On_Suspicious_Index (Name : Entity_Id; X : Node_Id);\n+   --  This is called after resolving an indexed component or a slice. Name\n+   --  is the entity for the name of the indexed array, and X is the subscript\n+   --  for the indexed component case, or one of the bounds in the slice case.\n+   --  If Name is an unconstrained parameter of a standard string type, and\n+   --  the index is of the form of a literal or Name'Length [- literal], then\n+   --  a warning is generated that the subscripting operation is possibly\n+   --  incorrectly assuming a lower bound of 1.\n+\n+   procedure Warn_On_Useless_Assignment\n+     (Ent : Entity_Id;\n+      Loc : Source_Ptr := No_Location);\n+   --  Called to check if we have a case of a useless assignment to the given\n+   --  entity Ent, as indicated by a non-empty Last_Assignment field. This call\n+   --  should only be made if Warn_On_Modified_Unread is True, and if Ent is in\n+   --  the extended main source unit. Loc is No_Location for the end of block\n+   --  call (warning msg says value unreferenced), or the it is the location of\n+   --  an overwriting assignment (warning msg points to this assignment).\n+\n+   procedure Warn_On_Useless_Assignments (E : Entity_Id);\n+   pragma Inline (Warn_On_Useless_Assignments);\n+   --  Called at the end of a block or subprogram. Scans the entities of the\n+   --  block or subprogram to see if there are any variables for which useless\n+   --  assignments were made (assignments whose values were never read).\n+\n end Sem_Warn;"}, {"sha": "004b2773ec9acc7e527780c65592ad8231473d08", "filename": "gcc/ada/xref_lib.adb", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Fxref_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1ede06fc28db443347a22c579551d926e626d6/gcc%2Fada%2Fxref_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.adb?ref=3f1ede06fc28db443347a22c579551d926e626d6", "patch": "@@ -136,12 +136,14 @@ package body Xref_Lib is\n       Entity  : String;\n       Glob    : Boolean := False)\n    is\n-      File_Start  : Natural;\n-      Line_Start  : Natural;\n-      Col_Start   : Natural;\n-      Line_Num    : Natural := 0;\n-      Col_Num     : Natural := 0;\n-      File_Ref    : File_Reference := Empty_File;\n+      File_Start : Natural;\n+      Line_Start : Natural;\n+      Col_Start  : Natural;\n+      Line_Num   : Natural := 0;\n+      Col_Num    : Natural := 0;\n+\n+      File_Ref : File_Reference := Empty_File;\n+      pragma Warnings (Off, File_Ref);\n \n    begin\n       --  Find the end of the first item in Entity (pattern or file?)\n@@ -275,7 +277,9 @@ package body Xref_Lib is\n         Add_To_Xref_File\n           (Entity (File_Start .. Line_Start - 1), Visited => True);\n       Pattern.File_Ref := File_Ref;\n+\n       Add_Line (Pattern.File_Ref, Line_Num, Col_Num);\n+\n       File_Ref :=\n         Add_To_Xref_File\n           (ALI_File_Name (Entity (File_Start .. Line_Start - 1)),"}]}