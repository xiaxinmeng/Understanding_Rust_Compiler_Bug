{"sha": "9f4a4394397cba5d9431410a94325b35f8432ef2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY0YTQzOTQzOTdjYmE1ZDk0MzE0MTBhOTQzMjViMzVmODQzMmVmMg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-11-07T15:43:57Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-11-07T15:43:57Z"}, "message": "2008-11-07  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* Complete last commit.\n\nFrom-SVN: r141675", "tree": {"sha": "49cf9fb61970e310d23d2f59669b44fef984fc8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49cf9fb61970e310d23d2f59669b44fef984fc8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f4a4394397cba5d9431410a94325b35f8432ef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f4a4394397cba5d9431410a94325b35f8432ef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f4a4394397cba5d9431410a94325b35f8432ef2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f4a4394397cba5d9431410a94325b35f8432ef2/comments", "author": null, "committer": null, "parents": [{"sha": "b74318f12b6c344a01e7039ca6a287d3c2245d12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b74318f12b6c344a01e7039ca6a287d3c2245d12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b74318f12b6c344a01e7039ca6a287d3c2245d12"}], "stats": {"total": 121, "additions": 121, "deletions": 0}, "files": [{"sha": "02aedf181c9a3da2b813b924579e91dfd9624fea", "filename": "libstdc++-v3/include/ext/cast.h", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4a4394397cba5d9431410a94325b35f8432ef2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fcast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4a4394397cba5d9431410a94325b35f8432ef2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fcast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fcast.h?ref=9f4a4394397cba5d9431410a94325b35f8432ef2", "patch": "@@ -0,0 +1,121 @@\n+// <cast.h> -*- C++ -*-\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _EXT_CAST_\n+#define _EXT_CAST_ 1\n+\n+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx);\n+\n+  /**\n+   * These functions are here to allow containers to support non standard\n+   * pointer types.  For normal pointers, these resolve to the use of the\n+   * standard cast operation.  For other types the functions will perform\n+   * the apprpriate cast to/from the custom pointer class so long as that\n+   * class meets the following conditions:\n+   * 1) has a typedef element_type which names tehe type it points to.\n+   * 2) has a get() const method which returns element_type*.\n+   * 3) has a constructor which can take one element_type* argument.\n+   */\n+\n+  /**\n+   * This type supports the semantics of the pointer cast operators (below.)\n+   */\n+  template<typename _ToType>\n+    struct _Caster\n+    {\n+      typedef typename _ToType::element_type*  type;\n+    };\n+  template<typename _ToType>\n+    struct _Caster<_ToType*>\n+    {\n+      typedef _ToType*  type;\n+    };\n+\n+  /**\n+   * Casting operations for cases where _FromType is not a standard pointer.\n+   * _ToType can be a standard or non-standard pointer.  Given that _FromType\n+   * is not a pointer, it must have a get() method that returns the standard\n+   * pointer equivalent of the address it points to, and must have an\n+   * element_type typedef which names the type it points to.\n+   */\n+  template<typename _ToType, typename _FromType>\n+    inline _ToType\n+    __static_pointer_cast(const _FromType& __arg)\n+    { return _ToType(static_cast<typename _Caster<_ToType>::\n+\t\t     type>(__arg.get())); }\n+\n+  template<typename _ToType, typename _FromType>\n+    inline _ToType\n+    __dynamic_pointer_cast(const _FromType& __arg)\n+    { return _ToType(dynamic_cast<typename _Caster<_ToType>::\n+\t\t     type>(__arg.get())); }\n+\n+  template<typename _ToType, typename _FromType>\n+    inline _ToType\n+    __const_pointer_cast(const _FromType& __arg)\n+    { return _ToType(const_cast<typename _Caster<_ToType>::\n+\t\t     type>(__arg.get())); }\n+\n+  template<typename _ToType, typename _FromType>\n+    inline _ToType\n+    __reinterpret_pointer_cast(const _FromType& __arg)\n+    { return _ToType(reinterpret_cast<typename _Caster<_ToType>::\n+\t\t     type>(__arg.get())); }\n+\n+  /**\n+   * Casting operations for cases where _FromType is a standard pointer.\n+   * _ToType can be a standard or non-standard pointer.\n+   */\n+  template<typename _ToType, typename _FromType>\n+    inline _ToType\n+    __static_pointer_cast(_FromType* __arg)\n+    { return _ToType(static_cast<typename _Caster<_ToType>::\n+\t\t     type>(__arg)); }\n+\n+  template<typename _ToType, typename _FromType>\n+    inline _ToType\n+    __dynamic_pointer_cast(_FromType* __arg)\n+    { return _ToType(dynamic_cast<typename _Caster<_ToType>::\n+\t\t     type>(__arg)); }\n+\n+  template<typename _ToType, typename _FromType>\n+    inline _ToType\n+    __const_pointer_cast(_FromType* __arg)\n+    { return _ToType(const_cast<typename _Caster<_ToType>::\n+\t\t     type>(__arg)); }\n+\n+  template<typename _ToType, typename _FromType>\n+    inline _ToType\n+    __reinterpret_pointer_cast(_FromType* __arg)\n+    { return _ToType(reinterpret_cast<typename _Caster<_ToType>::\n+\t\t     type>(__arg)); }\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif"}]}