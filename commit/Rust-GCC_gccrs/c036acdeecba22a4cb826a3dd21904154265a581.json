{"sha": "c036acdeecba22a4cb826a3dd21904154265a581", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAzNmFjZGVlY2JhMjJhNGNiODI2YTNkZDIxOTA0MTU0MjY1YTU4MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:56:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:56:05Z"}, "message": "poly_int: pointer_may_wrap_p\n\nThis patch changes the bitpos argument to pointer_may_wrap_p from\nHOST_WIDE_INT to poly_int64.  A later patch makes the callers track\npolynomial offsets.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* fold-const.c (pointer_may_wrap_p): Take the offset as a\n\tHOST_WIDE_INT rather than a poly_int64.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255890", "tree": {"sha": "6c6f29b5b1b11d72e87525a16d917bc1d45fdc43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c6f29b5b1b11d72e87525a16d917bc1d45fdc43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c036acdeecba22a4cb826a3dd21904154265a581", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c036acdeecba22a4cb826a3dd21904154265a581", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c036acdeecba22a4cb826a3dd21904154265a581", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c036acdeecba22a4cb826a3dd21904154265a581/comments", "author": null, "committer": null, "parents": [{"sha": "4a022c701b1dca1bfc3d73dc82dd5858525876ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a022c701b1dca1bfc3d73dc82dd5858525876ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a022c701b1dca1bfc3d73dc82dd5858525876ef"}], "stats": {"total": 49, "additions": 29, "deletions": 20}, "files": [{"sha": "9a60b00e19b1455f61909f281e72bab93510fdab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c036acdeecba22a4cb826a3dd21904154265a581/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c036acdeecba22a4cb826a3dd21904154265a581/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c036acdeecba22a4cb826a3dd21904154265a581", "patch": "@@ -1,3 +1,10 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* fold-const.c (pointer_may_wrap_p): Take the offset as a\n+\tHOST_WIDE_INT rather than a poly_int64.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "75bc7627a0719b7f25cd435f3a6f055c51dd62cf", "filename": "gcc/fold-const.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c036acdeecba22a4cb826a3dd21904154265a581/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c036acdeecba22a4cb826a3dd21904154265a581/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c036acdeecba22a4cb826a3dd21904154265a581", "patch": "@@ -8325,48 +8325,50 @@ maybe_canonicalize_comparison (location_t loc, enum tree_code code, tree type,\n    expressions like &p->x which can not wrap.  */\n \n static bool\n-pointer_may_wrap_p (tree base, tree offset, HOST_WIDE_INT bitpos)\n+pointer_may_wrap_p (tree base, tree offset, poly_int64 bitpos)\n {\n   if (!POINTER_TYPE_P (TREE_TYPE (base)))\n     return true;\n \n-  if (bitpos < 0)\n+  if (maybe_lt (bitpos, 0))\n     return true;\n \n-  wide_int wi_offset;\n+  poly_wide_int wi_offset;\n   int precision = TYPE_PRECISION (TREE_TYPE (base));\n   if (offset == NULL_TREE)\n     wi_offset = wi::zero (precision);\n-  else if (TREE_CODE (offset) != INTEGER_CST || TREE_OVERFLOW (offset))\n+  else if (!poly_int_tree_p (offset) || TREE_OVERFLOW (offset))\n     return true;\n   else\n-    wi_offset = wi::to_wide (offset);\n+    wi_offset = wi::to_poly_wide (offset);\n \n   bool overflow;\n-  wide_int units = wi::shwi (bitpos / BITS_PER_UNIT, precision);\n-  wide_int total = wi::add (wi_offset, units, UNSIGNED, &overflow);\n+  poly_wide_int units = wi::shwi (bits_to_bytes_round_down (bitpos),\n+\t\t\t\t  precision);\n+  poly_wide_int total = wi::add (wi_offset, units, UNSIGNED, &overflow);\n   if (overflow)\n     return true;\n \n-  if (!wi::fits_uhwi_p (total))\n+  poly_uint64 total_hwi, size;\n+  if (!total.to_uhwi (&total_hwi)\n+      || !poly_int_tree_p (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (base))),\n+\t\t\t   &size)\n+      || known_eq (size, 0U))\n     return true;\n \n-  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (TREE_TYPE (base)));\n-  if (size <= 0)\n-    return true;\n+  if (known_le (total_hwi, size))\n+    return false;\n \n   /* We can do slightly better for SIZE if we have an ADDR_EXPR of an\n      array.  */\n-  if (TREE_CODE (base) == ADDR_EXPR)\n-    {\n-      HOST_WIDE_INT base_size;\n-\n-      base_size = int_size_in_bytes (TREE_TYPE (TREE_OPERAND (base, 0)));\n-      if (base_size > 0 && size < base_size)\n-\tsize = base_size;\n-    }\n+  if (TREE_CODE (base) == ADDR_EXPR\n+      && poly_int_tree_p (TYPE_SIZE_UNIT (TREE_TYPE (TREE_OPERAND (base, 0))),\n+\t\t\t  &size)\n+      && maybe_ne (size, 0U)\n+      && known_le (total_hwi, size))\n+    return false;\n \n-  return total.to_uhwi () > (unsigned HOST_WIDE_INT) size;\n+  return true;\n }\n \n /* Return a positive integer when the symbol DECL is known to have"}]}