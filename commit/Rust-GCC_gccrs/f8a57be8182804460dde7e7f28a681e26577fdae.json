{"sha": "f8a57be8182804460dde7e7f28a681e26577fdae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhhNTdiZTgxODI4MDQ0NjBkZGU3ZTdmMjhhNjgxZTI2NTc3ZmRhZQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2004-07-01T04:09:07Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2004-07-01T04:09:07Z"}, "message": "Index: gcc/ChangeLog\n2004-06-28  Geoffrey Keating  <geoffk@apple.com>\n\t    Andreas Tobler  <a.tobler@schweiz.ch>\n\n\tPR 15813\n\t* dwarf2out.c (reg_save): Output DW_CFA_same_value when a\n\tregister is saved in itself.\n\t(initial_return_save): If the return address is a register,\n\tit's already there, don't bother to mention it in the CFI.\n\t(struct queued_reg_save): Add field saved_reg.\n\t(struct reg_saved_in_data): New.\n\t(regs_saved_in_regs): New.\n\t(num_regs_saved_in_regs): New.\n\t(queue_reg_save): Add extra parameter to specify register saved\n\tin register.  Remove duplicate entries from queue.  Add comment\n\tfor function.\n\t(flush_queued_reg_saves): Handle registers saved in registers.\n\tUpdate regs_saved_in_regs.  Add comment for function.\n\t(clobbers_queued_reg_save): Add comment for function.  Allow\n\tfor regs_saved_in_regs.\n\t(reg_saved_in): New.\n\t(dwarf2out_frame_debug_expr): Handle saving registers in other\n\tregisters.\n\t(dwarf2out_frame_debug): Reset regs_saved_in_regs.\n\t* unwind-dw2.c (execute_cfa_program): Correct handling of\n\tDW_CFA_same_value.  Add FIXME comment about incorrect implementation\n\tof DW_CFA_restore_extended.\n\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Let\n\tdwarf2out_frame_debug_expr see instructions that save registers\n\tin other registers or save those other registers in memory.\n\n\t* unwind-dw2.c (DWARF_FRAME_REGISTERS): Move to unwind-dw2.h.\n\t(_Unwind_FrameState): Likewise.\n\t* unwind-dw2.h: New.\n\t* Makefile.in (LIB2ADDEHDEP): Add unwind-dw2.h.\n\t* config/rs6000/darwin-fallback.c: New file.\n\t* config/rs6000/darwin.h (MD_FALLBACK_FRAME_STATE_FOR): Define.\n\t* config/rs6000/t-darwin (LIB2FUNCS_EXTRA): Add darwin-fallback.o.\n\nIndex: gcc/testsuite/ChangeLog\n2004-06-26  Geoffrey Keating  <geoffk@apple.com>\n\t    Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* gcc.dg/cleanup-10.c: Run on all Linux platforms and powerpc-darwin.\n\tUse SA_RESETHAND rather than SA_ONESHOT.  Trap SIGBUS as well\n\tas SIGSEGV.\n\t* gcc.dg/cleanup-11.c: Likewise.\n\t* gcc.dg/cleanup-8.c: Likewise.\n\t* gcc.dg/cleanup-9.c: Likewise.\n\t* gcc.dg/cleanup-5.c: Run on all platforms.\n\nIndex: libjava/ChangeLog\n2004-06-26  Geoffrey Keating  <geoffk@apple.com>\n\t    Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* configure.host (powerpc-*-darwin*): New case, define\n\tcan_unwind_signal.\n\t* configure.in (*-*-darwin*): New case, point to darwin-signal.h.\n\t* configure: Regenerate.\n\t* include/darwin-signal.h: New.\n\nCo-Authored-By: Andreas Tobler <a.tobler@schweiz.ch>\n\nFrom-SVN: r83953", "tree": {"sha": "c06b7ba921908103e7b86d67bed62ad6003088e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c06b7ba921908103e7b86d67bed62ad6003088e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8a57be8182804460dde7e7f28a681e26577fdae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a57be8182804460dde7e7f28a681e26577fdae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8a57be8182804460dde7e7f28a681e26577fdae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a57be8182804460dde7e7f28a681e26577fdae/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec6376abd7f23e0993138ed92c56552eea9cd5a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6376abd7f23e0993138ed92c56552eea9cd5a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6376abd7f23e0993138ed92c56552eea9cd5a2"}], "stats": {"total": 981, "additions": 859, "deletions": 122}, "files": [{"sha": "46f33600eef12bdcbc14d78cda7fb45b8346ac50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -1,3 +1,41 @@\n+2004-06-28  Geoffrey Keating  <geoffk@apple.com>\n+\t    Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\tPR 15813\n+\t* dwarf2out.c (reg_save): Output DW_CFA_same_value when a\n+\tregister is saved in itself.\n+\t(initial_return_save): If the return address is a register,\n+\tit's already there, don't bother to mention it in the CFI.\n+\t(struct queued_reg_save): Add field saved_reg.\n+\t(struct reg_saved_in_data): New.\n+\t(regs_saved_in_regs): New.\n+\t(num_regs_saved_in_regs): New.\n+\t(queue_reg_save): Add extra parameter to specify register saved\n+\tin register.  Remove duplicate entries from queue.  Add comment\n+\tfor function.\n+\t(flush_queued_reg_saves): Handle registers saved in registers.\n+\tUpdate regs_saved_in_regs.  Add comment for function.\n+\t(clobbers_queued_reg_save): Add comment for function.  Allow\n+\tfor regs_saved_in_regs.\n+\t(reg_saved_in): New.\n+\t(dwarf2out_frame_debug_expr): Handle saving registers in other\n+\tregisters.\n+\t(dwarf2out_frame_debug): Reset regs_saved_in_regs.\n+\t* unwind-dw2.c (execute_cfa_program): Correct handling of\n+\tDW_CFA_same_value.  Add FIXME comment about incorrect implementation\n+\tof DW_CFA_restore_extended.\n+\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Let\n+\tdwarf2out_frame_debug_expr see instructions that save registers\n+\tin other registers or save those other registers in memory.\n+\n+\t* unwind-dw2.c (DWARF_FRAME_REGISTERS): Move to unwind-dw2.h.\n+\t(_Unwind_FrameState): Likewise.\n+\t* unwind-dw2.h: New.\n+\t* Makefile.in (LIB2ADDEHDEP): Add unwind-dw2.h.\n+\t* config/rs6000/darwin-fallback.c: New file.\n+\t* config/rs6000/darwin.h (MD_FALLBACK_FRAME_STATE_FOR): Define.\n+\t* config/rs6000/t-darwin (LIB2FUNCS_EXTRA): Add darwin-fallback.o.\n+\n 2004-07-01  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.c (rs6000_mixed_function_arg): Rewrite."}, {"sha": "41e84117857cdc4fe07bcb62c0acec50de0a6c74", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -528,7 +528,7 @@ CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n # Additional sources to handle exceptions; overridden by targets as needed.\n LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \\\n    $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c\n-LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h\n+LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2.h\n \n # nm flags to list global symbols in libgcc object files.\n SHLIB_NM_FLAGS = -pg"}, {"sha": "f7756fbac843a845d8a82e72e087abd5316b1e22", "filename": "gcc/config/rs6000/darwin-fallback.c", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Fconfig%2Frs6000%2Fdarwin-fallback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Fconfig%2Frs6000%2Fdarwin-fallback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin-fallback.c?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -0,0 +1,432 @@\n+/* Fallback frame-state unwinder for Darwin.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combined\n+   executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"dwarf2.h\"\n+#include \"unwind.h\"\n+#include \"unwind-dw2.h\"\n+#include <stdint.h>\n+#include <stdbool.h>\n+#include <signal.h>\n+#include <ucontext.h>\n+\n+typedef unsigned long reg_unit;\n+\n+/* Place in GPRS the parameters to the first 'sc' instruction that would\n+   have been executed if we were returning from this CONTEXT, or\n+   return false if an unexpected instruction is encountered.  */\n+\n+static bool\n+interpret_libc (reg_unit gprs[32], struct _Unwind_Context *context)\n+{\n+  uint32_t *pc = (uint32_t *)_Unwind_GetIP (context);\n+  uint32_t cr;\n+  reg_unit lr = (reg_unit) pc;\n+  reg_unit ctr = 0;\n+  uint32_t *invalid_address = NULL;\n+\n+  int i;\n+\n+  for (i = 0; i < 13; i++)\n+    gprs[i] = 1;\n+  gprs[1] = _Unwind_GetCFA (context);\n+  for (; i < 32; i++)\n+    gprs[i] = _Unwind_GetGR (context, i);\n+  cr = _Unwind_GetGR (context, CR2_REGNO);\n+\n+  /* For each supported Libc, we have to track the code flow\n+     all the way back into the kernel.\n+  \n+     This code is believed to support all released Libc/Libsystem builds since\n+     Jaguar 6C115, including all the security updates.  To be precise,\n+\n+     Libc\tLibsystem\tBuild(s)\n+     262~1\t60~37\t\t6C115\n+     262~1\t60.2~4\t\t6D52\n+     262~1\t61~3\t\t6F21-6F22\n+     262~1\t63~24\t\t6G30-6G37\n+     262~1\t63~32\t\t6I34-6I35\n+     262~1\t63~64\t\t6L29-6L60\n+     262.4.1~1\t63~84\t\t6L123-6R172\n+     \n+     320~1\t71~101\t\t7B85-7D28\n+     320~1\t71~266\t\t7F54-7F56\n+     320~1\t71~288\t\t7F112\n+     320~1\t71~289\t\t7F113\n+     320.1.3~1\t71.1.1~29\t7H60-7H105\n+     320.1.3~1\t71.1.1~30\t7H110-7H113\n+     320.1.3~1\t71.1.1~31\t7H114\n+     \n+     That's a big table!  It would be insane to try to keep track of\n+     every little detail, so we just read the code itself and do what\n+     it would do.\n+  */\n+\n+  for (;;)\n+    {\n+      uint32_t ins = *pc++;\n+      \n+      if ((ins & 0xFC000003) == 0x48000000)  /* b instruction */\n+\t{\n+\t  pc += ((((int32_t) ins & 0x3FFFFFC) ^ 0x2000000) - 0x2000004) / 4;\n+\t  continue;\n+\t}\n+      if ((ins & 0xFC600000) == 0x2C000000)  /* cmpwi */\n+\t{\n+\t  int32_t val1 = (int16_t) ins;\n+\t  int32_t val2 = gprs[ins >> 16 & 0x1F];\n+\t  /* Only beq and bne instructions are supported, so we only\n+\t     need to set the EQ bit.  */\n+\t  uint32_t mask = 0xF << ((ins >> 21 & 0x1C) ^ 0x1C);\n+\t  if (val1 == val2)\n+\t    cr |= mask;\n+\t  else\n+\t    cr &= ~mask;\n+\t  continue;\n+\t}\n+      if ((ins & 0xFEC38003) == 0x40820000)  /* forwards beq/bne */\n+\t{\n+\t  if ((cr >> ((ins >> 16 & 0x1F) ^ 0x1F) & 1) == (ins >> 24 & 1))\n+\t    pc += (ins & 0x7FFC) / 4 - 1;\n+\t  continue;\n+\t}\n+      if ((ins & 0xFC0007FF) == 0x7C000378) /* or, including mr */\n+\t{\n+\t  gprs [ins >> 16 & 0x1F] = (gprs [ins >> 11 & 0x1F] \n+\t\t\t\t     | gprs [ins >> 21 & 0x1F]);\n+\t  continue;\n+\t}\n+      if (ins >> 26 == 0x0E)  /* addi, including li */\n+\t{\n+\t  reg_unit src = (ins >> 16 & 0x1F) == 0 ? 0 : gprs [ins >> 16 & 0x1F];\n+\t  gprs [ins >> 21 & 0x1F] = src + (int16_t) ins;\n+\t  continue;\n+\t}\n+      if (ins >> 26 == 0x0F)  /* addis, including lis */\n+\t{\n+\t  reg_unit src = (ins >> 16 & 0x1F) == 0 ? 0 : gprs [ins >> 16 & 0x1F];\n+\t  gprs [ins >> 21 & 0x1F] = src + ((int16_t) ins << 16);\n+\t  continue;\n+\t}\n+      if (ins >> 26 == 0x20)  /* lwz */\n+\t{\n+\t  reg_unit src = (ins >> 16 & 0x1F) == 0 ? 0 : gprs [ins >> 16 & 0x1F];\n+\t  uint32_t *p = (uint32_t *)(src + (int16_t) ins);\n+\t  if (p == invalid_address)\n+\t    return false;\n+\t  gprs [ins >> 21 & 0x1F] = *p;\n+\t  continue;\n+\t}\n+      if (ins >> 26 == 0x21)  /* lwzu */\n+\t{\n+\t  uint32_t *p = (uint32_t *)(gprs [ins >> 16 & 0x1F] += (int16_t) ins);\n+\t  if (p == invalid_address)\n+\t    return false;\n+\t  gprs [ins >> 21 & 0x1F] = *p;\n+\t  continue;\n+\t}\n+      if (ins >> 26 == 0x24)  /* stw */\n+\t/* What we hope this is doing is '--in_sigtramp'.  We don't want\n+\t   to actually store to memory, so just make a note of the\n+\t   address and refuse to load from it.  */\n+\t{\n+\t  reg_unit src = (ins >> 16 & 0x1F) == 0 ? 0 : gprs [ins >> 16 & 0x1F];\n+\t  uint32_t *p = (uint32_t *)(src + (int16_t) ins);\n+\t  if (p == NULL || invalid_address != NULL)\n+\t    return false;\n+\t  invalid_address = p;\n+\t  continue;\n+\t}\n+      if (ins >> 26 == 0x2E) /* lmw */\n+\t{\n+\t  reg_unit src = (ins >> 16 & 0x1F) == 0 ? 0 : gprs [ins >> 16 & 0x1F];\n+\t  uint32_t *p = (uint32_t *)(src + (int16_t) ins);\n+\t  int i;\n+\n+\t  for (i = (ins >> 21 & 0x1F); i < 32; i++)\n+\t    {\n+\t      if (p == invalid_address)\n+\t\treturn false;\n+\t      gprs[i] = *p++;\n+\t    }\n+\t  continue;\n+\t}\n+      if ((ins & 0xFC1FFFFF) == 0x7c0803a6)  /* mtlr */\n+\t{\n+\t  lr = gprs [ins >> 21 & 0x1F];\n+\t  continue;\n+\t}\n+      if ((ins & 0xFC1FFFFF) == 0x7c0802a6)  /* mflr */\n+\t{\n+\t  gprs [ins >> 21 & 0x1F] = lr;\n+\t  continue;\n+\t}\n+      if ((ins & 0xFC1FFFFF) == 0x7c0903a6)  /* mtctr */\n+\t{\n+\t  ctr = gprs [ins >> 21 & 0x1F];\n+\t  continue;\n+\t}\n+      /* The PowerPC User's Manual says that bit 11 of the mtcrf\n+\t instruction is reserved and should be set to zero, but it\n+\t looks like the Darwin assembler doesn't do that... */\n+      if ((ins & 0xFC000FFF) == 0x7c000120) /* mtcrf */\n+\t{\n+\t  int i;\n+\t  uint32_t mask = 0;\n+\t  for (i = 0; i < 8; i++)\n+\t    mask |= ((-(ins >> (12 + i) & 1)) & 0xF) << 4 * i;\n+\t  cr = (cr & ~mask) | (gprs [ins >> 21 & 0x1F] & mask);\n+\t  continue;\n+\t}\n+      if (ins == 0x429f0005)  /* bcl- 20,4*cr7+so,.+4, loads pc into LR */\n+\t{\n+\t  lr = (reg_unit) pc;\n+\t  continue;\n+\t}\n+      if (ins == 0x4e800420) /* bctr */\n+\t{\n+\t  pc = (uint32_t *) ctr;\n+\t  continue;\n+\t}\n+      if (ins == 0x44000002) /* sc */\n+\treturn true;\n+\n+      return false;\n+    }\n+}\n+\n+/* These defines are from the kernel's bsd/dev/ppc/unix_signal.c.  */\n+#define UC_TRAD                 1\n+#define UC_TRAD_VEC             6\n+#define UC_TRAD64               20\n+#define UC_TRAD64_VEC           25\n+#define UC_FLAVOR               30\n+#define UC_FLAVOR_VEC           35\n+#define UC_FLAVOR64             40\n+#define UC_FLAVOR64_VEC         45\n+#define UC_DUAL                 50\n+#define UC_DUAL_VEC             55\n+\n+/* These are based on /usr/include/ppc/ucontext.h and\n+   /usr/include/mach/ppc/thread_status.h, but rewritten to be more\n+   convenient, to compile on Jaguar, and to work around Radar 3712064\n+   on Panther, which is that the 'es' field of 'struct mcontext64' has\n+   the wrong type (doh!).  */\n+\n+struct gcc_mcontext64 {\n+  uint64_t dar;\n+  uint32_t dsisr;\n+  uint32_t exception;\n+  uint32_t padding1[4];\n+  uint64_t srr0;\n+  uint64_t srr1;\n+  uint32_t gpr[32][2];\n+  uint32_t cr;\n+  uint32_t xer[2];  /* These are arrays because the original structure has them misaligned.  */\n+  uint32_t lr[2];\n+  uint32_t ctr[2];\n+  uint32_t vrsave;\n+  ppc_float_state_t fs;\n+  ppc_vector_state_t vs;\n+};\n+\n+#define UC_FLAVOR_SIZE \\\n+  (sizeof (struct mcontext) - sizeof (ppc_vector_state_t))\n+\n+#define UC_FLAVOR_VEC_SIZE (sizeof (struct mcontext))\n+\n+#define UC_FLAVOR64_SIZE \\\n+  (sizeof (struct gcc_mcontext64) - sizeof (ppc_vector_state_t))\n+\n+#define UC_FLAVOR64_VEC_SIZE (sizeof (struct gcc_mcontext64))\n+\n+/* Given GPRS as input to a 'sc' instruction, and OLD_CFA, update FS\n+   to represent the execution of a signal return; or, if not a signal\n+   return, return false.  */\n+\n+static bool\n+handle_syscall (_Unwind_FrameState *fs, const reg_unit gprs[32],\n+\t\t_Unwind_Ptr old_cfa)\n+{\n+  struct ucontext *uctx;\n+  bool is_64, is_vector;\n+  ppc_float_state_t *float_state;\n+  ppc_vector_state_t *vector_state;\n+  _Unwind_Ptr new_cfa;\n+  int i;\n+  static _Unwind_Ptr return_addr;\n+  \n+  /* Yay!  We're in a Libc that we understand, and it's made a\n+     system call.  It'll be one of two kinds: either a Jaguar-style\n+     SYS_sigreturn, or a Panther-style 'syscall' call with 184, which \n+     is also SYS_sigreturn.  */\n+  \n+  if (gprs[0] == 0x67 /* SYS_SIGRETURN */)\n+    {\n+      uctx = (struct ucontext *) gprs[3];\n+      is_vector = (uctx->uc_mcsize == UC_FLAVOR64_VEC_SIZE\n+\t\t   || uctx->uc_mcsize == UC_FLAVOR_VEC_SIZE);\n+      is_64 = (uctx->uc_mcsize == UC_FLAVOR64_VEC_SIZE\n+\t       || uctx->uc_mcsize == UC_FLAVOR64_SIZE);\n+    }\n+  else if (gprs[0] == 0 && gprs[3] == 184)\n+    {\n+      int ctxstyle = gprs[5];\n+      uctx = (struct ucontext *) gprs[4];\n+      is_vector = (ctxstyle == UC_FLAVOR_VEC || ctxstyle == UC_FLAVOR64_VEC\n+\t\t   || ctxstyle == UC_TRAD_VEC || ctxstyle == UC_TRAD64_VEC);\n+      is_64 = (ctxstyle == UC_FLAVOR64_VEC || ctxstyle == UC_TRAD64_VEC\n+\t       || ctxstyle == UC_FLAVOR64 || ctxstyle == UC_TRAD64);\n+    }\n+  else\n+    return false;\n+\n+#define set_offset(r, addr)\t\t\t\t\t\\\n+  (fs->regs.reg[r].how = REG_SAVED_OFFSET,\t\t\t\\\n+   fs->regs.reg[r].loc.offset = (_Unwind_Ptr)(addr) - new_cfa)\n+\n+  /* Restore even the registers that are not call-saved, since they\n+     might be being used in the prologue to save other registers,\n+     for instance GPR0 is sometimes used to save LR.  */\n+\n+  /* Handle the GPRs, and produce the information needed to do the rest.  */\n+  if (is_64)\n+    {\n+      /* The context is 64-bit, but it doesn't carry any extra information\n+\t for us because only the low 32 bits of the registers are\n+\t call-saved.  */\n+      struct gcc_mcontext64 *m64 = (struct gcc_mcontext64 *)uctx->uc_mcontext;\n+      int i;\n+\n+      float_state = &m64->fs;\n+      vector_state = &m64->vs;\n+\n+      new_cfa = m64->gpr[1][1];\n+      \n+      set_offset (CR2_REGNO, &m64->cr);\n+      for (i = 0; i < 32; i++)\n+\tset_offset (i, m64->gpr[i] + 1);\n+      set_offset (XER_REGNO, m64->xer + 1);\n+      set_offset (LINK_REGISTER_REGNUM, m64->lr + 1);\n+      set_offset (COUNT_REGISTER_REGNUM, m64->ctr + 1);\n+      if (is_vector)\n+\tset_offset (VRSAVE_REGNO, &m64->vrsave);\n+      \n+      /* Sometimes, srr0 points to the instruction that caused the exception,\n+\t and sometimes to the next instruction to be executed; we want\n+\t the latter.  */\n+      if (m64->exception == 3 || m64->exception == 4\n+\t  || m64->exception == 6\n+\t  || (m64->exception == 7 && !(m64->srr1 & 0x10000)))\n+\treturn_addr = m64->srr0 + 4;\n+      else\n+\treturn_addr = m64->srr0;\n+    }\n+  else\n+    {\n+      struct mcontext *m = uctx->uc_mcontext;\n+      int i;\n+\n+      float_state = &m->fs;\n+      vector_state = &m->vs;\n+      \n+      new_cfa = m->ss.r1;\n+\n+      set_offset (CR2_REGNO, &m->ss.cr);\n+      for (i = 0; i < 32; i++)\n+\tset_offset (i, &m->ss.r0 + i);\n+      set_offset (XER_REGNO, &m->ss.xer);\n+      set_offset (LINK_REGISTER_REGNUM, &m->ss.lr);\n+      set_offset (COUNT_REGISTER_REGNUM, &m->ss.ctr);\n+\n+      if (is_vector)\n+\tset_offset (VRSAVE_REGNO, &m->ss.vrsave);\n+\n+      /* Sometimes, srr0 points to the instruction that caused the exception,\n+\t and sometimes to the next instruction to be executed; we want\n+\t the latter.  */\n+      if (m->es.exception == 3 || m->es.exception == 4\n+\t  || m->es.exception == 6\n+\t  || (m->es.exception == 7 && !(m->ss.srr1 & 0x10000)))\n+\treturn_addr = m->ss.srr0 + 4;\n+      else\n+\treturn_addr = m->ss.srr0;\n+    }\n+\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = STACK_POINTER_REGNUM;\n+  fs->cfa_offset = new_cfa - old_cfa;;\n+  \n+  /* The choice of column for the return address is somewhat tricky.\n+     Fortunately, the actual choice is private to this file, and\n+     the space it's reserved from is the GCC register space, not the\n+     DWARF2 numbering.  So any free element of the right size is an OK\n+     choice.  Thus: */\n+  fs->retaddr_column = ARG_POINTER_REGNUM;\n+  /* FIXME: this should really be done using a DWARF2 location expression,\n+     not using a static variable.  In fact, this entire file should\n+     be implemented in DWARF2 expressions.  */\n+  set_offset (ARG_POINTER_REGNUM, &return_addr);\n+\n+  for (i = 0; i < 32; i++)\n+    set_offset (32 + i, float_state->fpregs + i);\n+  set_offset (SPEFSCR_REGNO, &float_state->fpscr);\n+  \n+  if (is_vector)\n+    {\n+      for (i = 0; i < 32; i++)\n+\tset_offset (FIRST_ALTIVEC_REGNO + i, vector_state->save_vr + i);\n+      set_offset (VSCR_REGNO, vector_state->save_vscr);\n+    }\n+\n+  return true;\n+}\n+\n+/* This is also prototyped in rs6000/darwin.h, inside the\n+   MD_FALLBACK_FRAME_STATE_FOR macro.  */\n+extern bool _Unwind_fallback_frame_state_for (struct _Unwind_Context *context,\n+\t\t\t\t\t      _Unwind_FrameState *fs);\n+\n+/* Implement the MD_FALLBACK_FRAME_STATE_FOR macro,\n+   returning true iff the frame was a sigreturn() frame that we\n+   can understand.  */\n+\n+bool\n+_Unwind_fallback_frame_state_for (struct _Unwind_Context *context,\n+\t\t\t\t  _Unwind_FrameState *fs)\n+{\n+  reg_unit gprs[32];\n+\n+  if (!interpret_libc (gprs, context))\n+    return false;\n+  return handle_syscall (fs, gprs, _Unwind_GetCFA (context));\n+}"}, {"sha": "ae65eb26851e91455747de5b2e4e8fb1bc6d9ec5", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -327,3 +327,17 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef REGISTER_TARGET_PRAGMAS\n #define REGISTER_TARGET_PRAGMAS DARWIN_REGISTER_TARGET_PRAGMAS\n \n+#ifdef IN_LIBGCC2\n+#include <stdbool.h>\n+#endif\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    extern bool _Unwind_fallback_frame_state_for\t\t\t\\\n+      (struct _Unwind_Context *context, _Unwind_FrameState *fs);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (_Unwind_fallback_frame_state_for (CONTEXT, FS))\t\t\t\\\n+      goto SUCCESS;\t\t\t\t\t\t\t\\\n+  }\n+\n+#define HAS_MD_FALLBACK_FRAME_STATE_FOR 1"}, {"sha": "47c9bed2e7d123f93e6884cc6afbad10b5069e61", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 48, "deletions": 19, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -12298,14 +12298,31 @@ rs6000_emit_prologue (void)\n \n   /* If we use the link register, get it into r0.  */\n   if (info->lr_save_p)\n-    emit_move_insn (gen_rtx_REG (Pmode, 0),\n-\t\t    gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+    {\n+      insn = emit_move_insn (gen_rtx_REG (Pmode, 0),\n+\t\t\t     gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n \n   /* If we need to save CR, put it into r12.  */\n   if (info->cr_save_p && frame_reg_rtx != frame_ptr_rtx)\n     {\n+      rtx set;\n+      \n       cr_save_rtx = gen_rtx_REG (SImode, 12);\n-      emit_insn (gen_movesi_from_cr (cr_save_rtx));\n+      insn = emit_insn (gen_movesi_from_cr (cr_save_rtx));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      /* Now, there's no way that dwarf2out_frame_debug_expr is going\n+\t to understand '(unspec:SI [(reg:CC 68) ...] UNSPEC_MOVESI_FROM_CR)'.\n+\t But that's OK.  All we have to do is specify that _one_ condition\n+\t code register is saved in this stack slot.  The thrower's epilogue\n+\t will then restore all the call-saved registers.\n+\t We use CR2_REGNO (70) to be compatible with gcc-2.95 on Linux.  */\n+      set = gen_rtx_SET (VOIDmode, cr_save_rtx,\n+\t\t\t gen_rtx_REG (SImode, CR2_REGNO));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t\t\t    set,\n+\t\t\t\t\t    REG_NOTES (insn));\n     }\n \n   /* Do any required saving of fpr's.  If only one or two to save, do\n@@ -12484,7 +12501,7 @@ rs6000_emit_prologue (void)\n       \n       insn = emit_move_insn (mem, reg);\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n-\t\t\t    reg, gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+\t\t\t    NULL_RTX, NULL_RTX);\n     }\n \n   /* Save CR if we use any that must be preserved.  */\n@@ -12493,26 +12510,30 @@ rs6000_emit_prologue (void)\n       rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->cr_save_offset + sp_offset));\n       rtx mem = gen_rtx_MEM (SImode, addr);\n+      /* See the large comment above about why CR2_REGNO is used.  */\n+      rtx magic_eh_cr_reg = gen_rtx_REG (SImode, CR2_REGNO);\n \n       set_mem_alias_set (mem, rs6000_sr_alias_set);\n \n       /* If r12 was used to hold the original sp, copy cr into r0 now\n \t that it's free.  */\n       if (REGNO (frame_reg_rtx) == 12)\n \t{\n+\t  rtx set;\n+\n \t  cr_save_rtx = gen_rtx_REG (SImode, 0);\n-\t  emit_insn (gen_movesi_from_cr (cr_save_rtx));\n+\t  insn = emit_insn (gen_movesi_from_cr (cr_save_rtx));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  set = gen_rtx_SET (VOIDmode, cr_save_rtx, magic_eh_cr_reg);\n+\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t\t\t\tset,\n+\t\t\t\t\t\tREG_NOTES (insn));\n+\t  \n \t}\n       insn = emit_move_insn (mem, cr_save_rtx);\n \n-      /* Now, there's no way that dwarf2out_frame_debug_expr is going\n-\t to understand '(unspec:SI [(reg:CC 68) ...] UNSPEC_MOVESI_FROM_CR)'.\n-\t But that's OK.  All we have to do is specify that _one_ condition\n-\t code register is saved in this stack slot.  The thrower's epilogue\n-\t will then restore all the call-saved registers.\n-\t We use CR2_REGNO (70) to be compatible with gcc-2.95 on Linux.  */\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n-\t\t\t    cr_save_rtx, gen_rtx_REG (SImode, CR2_REGNO));\n+\t\t\t    NULL_RTX, NULL_RTX);\n     }\n \n   /* Update stack and set back pointer unless this is V.4, \n@@ -12546,9 +12567,16 @@ rs6000_emit_prologue (void)\n     if (save_LR_around_toc_setup)\n       {\n \trtx lr = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n-\trs6000_maybe_dead (emit_move_insn (frame_ptr_rtx, lr));\n+\n+\tinsn = emit_move_insn (frame_ptr_rtx, lr);\n+\trs6000_maybe_dead (insn);\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+\n \trs6000_emit_load_toc_table (TRUE);\n-\trs6000_maybe_dead (emit_move_insn (lr, frame_ptr_rtx));\n+\n+\tinsn = emit_move_insn (lr, frame_ptr_rtx);\n+\trs6000_maybe_dead (insn);\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n       }\n     else\n       rs6000_emit_load_toc_table (TRUE);\n@@ -12558,15 +12586,16 @@ rs6000_emit_prologue (void)\n   if (DEFAULT_ABI == ABI_DARWIN\n       && flag_pic && current_function_uses_pic_offset_table)\n     {\n-      rtx dest = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n+      rtx lr = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n       const char *picbase = machopic_function_base_name ();\n       rtx src = gen_rtx_SYMBOL_REF (Pmode, picbase);\n \n-      rs6000_maybe_dead (emit_insn (gen_load_macho_picbase (dest, src)));\n+      rs6000_maybe_dead (emit_insn (gen_load_macho_picbase (lr, src)));\n \n-      rs6000_maybe_dead (\n-\temit_move_insn (gen_rtx_REG (Pmode, RS6000_PIC_OFFSET_TABLE_REGNUM),\n-\t\t\tgen_rtx_REG (Pmode, LINK_REGISTER_REGNUM)));\n+      insn = emit_move_insn (gen_rtx_REG (Pmode, \n+\t\t\t\t\t  RS6000_PIC_OFFSET_TABLE_REGNUM),\n+\t\t\t     lr);\n+      rs6000_maybe_dead (insn);\n     }\n #endif\n }"}, {"sha": "f38adb92a33f6a470ccdd55c35fcadddcaae741c", "filename": "gcc/config/rs6000/t-darwin", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Fconfig%2Frs6000%2Ft-darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Fconfig%2Frs6000%2Ft-darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-darwin?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -1,6 +1,6 @@\n-# Add trampoline and long double support to libgcc.\n LIB2FUNCS_EXTRA = $(srcdir)/config/rs6000/darwin-tramp.asm \\\n-\t$(srcdir)/config/rs6000/darwin-ldouble.c\n+\t$(srcdir)/config/rs6000/darwin-ldouble.c \\\n+\t$(srcdir)/config/rs6000/darwin-fallback.c\n \n LIB2FUNCS_STATIC_EXTRA = \\\n \t$(srcdir)/config/rs6000/darwin-fpsave.asm  \\"}, {"sha": "8549c7d453c46ac81de046b5d9d2f755ab776d1f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 141, "deletions": 31, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -359,7 +359,6 @@ static HOST_WIDE_INT stack_adjust_offset (rtx);\n static void output_cfi (dw_cfi_ref, dw_fde_ref, int);\n static void output_call_frame_info (int);\n static void dwarf2out_stack_adjust (rtx);\n-static void queue_reg_save (const char *, rtx, HOST_WIDE_INT);\n static void flush_queued_reg_saves (void);\n static bool clobbers_queued_reg_save (rtx);\n static void dwarf2out_frame_debug_expr (rtx, const char *);\n@@ -843,8 +842,7 @@ reg_save (const char *label, unsigned int reg, unsigned int sreg, HOST_WIDE_INT\n       cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n     }\n   else if (sreg == reg)\n-    /* We could emit a DW_CFA_same_value in this case, but don't bother.  */\n-    return;\n+    cfi->dw_cfi_opc = DW_CFA_same_value;\n   else\n     {\n       cfi->dw_cfi_opc = DW_CFA_register;\n@@ -974,7 +972,8 @@ initial_return_save (rtx rtl)\n       abort ();\n     }\n \n-  reg_save (NULL, DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa.offset);\n+  if (reg != DWARF_FRAME_RETURN_COLUMN)\n+    reg_save (NULL, DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa.offset);\n }\n \n /* Given a SET, calculate the amount of stack adjustment it\n@@ -1144,53 +1143,134 @@ struct queued_reg_save GTY(())\n   struct queued_reg_save *next;\n   rtx reg;\n   HOST_WIDE_INT cfa_offset;\n+  rtx saved_reg;\n };\n \n static GTY(()) struct queued_reg_save *queued_reg_saves;\n \n+/* The caller's ORIG_REG is saved in SAVED_IN_REG.  */\n+struct reg_saved_in_data GTY(()) {\n+  rtx orig_reg;\n+  rtx saved_in_reg;\n+};\n+\n+/* A list of registers saved in other registers.\n+   The list intentionally has a small maximum capacity of 4; if your\n+   port needs more than that, you might consider implementing a\n+   more efficient data structure.  */\n+static GTY(()) struct reg_saved_in_data regs_saved_in_regs[4];\n+static GTY(()) size_t num_regs_saved_in_regs;\n+  \n #if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n static const char *last_reg_save_label;\n \n+/* Add an entry to QUEUED_REG_SAVES saying that REG is now saved at\n+   SREG, or if SREG is NULL then it is saved at OFFSET to the CFA.  */\n+\n static void\n-queue_reg_save (const char *label, rtx reg, HOST_WIDE_INT offset)\n+queue_reg_save (const char *label, rtx reg, rtx sreg, HOST_WIDE_INT offset)\n {\n-  struct queued_reg_save *q = ggc_alloc (sizeof (*q));\n+  struct queued_reg_save *q;\n+\n+  /* Duplicates waste space, but it's also necessary to remove them\n+     for correctness, since the queue gets output in reverse\n+     order.  */\n+  for (q = queued_reg_saves; q != NULL; q = q->next)\n+    if (REGNO (q->reg) == REGNO (reg))\n+      break;\n+\n+  if (q == NULL)\n+    {\n+      q = ggc_alloc (sizeof (*q));\n+      q->next = queued_reg_saves;\n+      queued_reg_saves = q;\n+    }\n \n-  q->next = queued_reg_saves;\n   q->reg = reg;\n   q->cfa_offset = offset;\n-  queued_reg_saves = q;\n+  q->saved_reg = sreg;\n \n   last_reg_save_label = label;\n }\n \n+/* Output all the entries in QUEUED_REG_SAVES.  */\n+\n static void\n flush_queued_reg_saves (void)\n {\n-  struct queued_reg_save *q, *next;\n+  struct queued_reg_save *q;\n \n-  for (q = queued_reg_saves; q; q = next)\n+  for (q = queued_reg_saves; q; q = q->next)\n     {\n-      dwarf2out_reg_save (last_reg_save_label, REGNO (q->reg), q->cfa_offset);\n-      next = q->next;\n+      size_t i;\n+      for (i = 0; i < num_regs_saved_in_regs; i++)\n+\tif (REGNO (regs_saved_in_regs[i].orig_reg) == REGNO (q->reg))\n+\t  break;\n+      if (q->saved_reg && i == num_regs_saved_in_regs)\n+\t{\n+\t  if (i == ARRAY_SIZE (regs_saved_in_regs))\n+\t    abort ();\n+\t  num_regs_saved_in_regs++;\n+\t}\n+      if (i != num_regs_saved_in_regs)\n+\t{\n+\t  regs_saved_in_regs[i].orig_reg = q->reg;\n+\t  regs_saved_in_regs[i].saved_in_reg = q->saved_reg;\n+\t}\n+\n+      reg_save (last_reg_save_label, REGNO (q->reg), \n+\t\tq->saved_reg ? REGNO (q->saved_reg) : -1U, q->cfa_offset);\n     }\n \n   queued_reg_saves = NULL;\n   last_reg_save_label = NULL;\n }\n \n+/* Does INSN clobber any register which QUEUED_REG_SAVES lists a saved\n+   location for?  Or, does it clobber a register which we've previously\n+   said that some other register is saved in, and for which we now\n+   have a new location for?  */\n+\n static bool\n clobbers_queued_reg_save (rtx insn)\n {\n   struct queued_reg_save *q;\n \n   for (q = queued_reg_saves; q; q = q->next)\n-    if (modified_in_p (q->reg, insn))\n-      return true;\n+    {\n+      size_t i;\n+      if (modified_in_p (q->reg, insn))\n+\treturn true;\n+      for (i = 0; i < num_regs_saved_in_regs; i++)\n+\tif (REGNO (q->reg) == REGNO (regs_saved_in_regs[i].orig_reg)\n+\t    && modified_in_p (regs_saved_in_regs[i].saved_in_reg, insn))\n+\t  return true;\n+    }\n \n   return false;\n }\n \n+/* What register, if any, is currently saved in REG?  */\n+\n+static rtx\n+reg_saved_in (rtx reg)\n+{\n+  unsigned int regn = REGNO (reg);\n+  size_t i;\n+  struct queued_reg_save *q;\n+  \n+  for (q = queued_reg_saves; q; q = q->next)\n+    if (q->saved_reg && regn == REGNO (q->saved_reg))\n+      return q->reg;\n+\n+  for (i = 0; i < num_regs_saved_in_regs; i++)\n+    if (regs_saved_in_regs[i].saved_in_reg\n+\t&& regn == REGNO (regs_saved_in_regs[i].saved_in_reg))\n+      return regs_saved_in_regs[i].orig_reg;\n+\n+  return NULL_RTX;\n+}\n+\n \n /* A temporary register holding an integral value used in adjusting SP\n    or setting up the store_reg.  The \"offset\" field holds the integer\n@@ -1199,8 +1279,8 @@ static dw_cfa_location cfa_temp;\n \n /* Record call frame debugging information for an expression EXPR,\n    which either sets SP or FP (adjusting how we calculate the frame\n-   address) or saves a register to the stack.  LABEL indicates the\n-   address of EXPR.\n+   address) or saves a register to the stack or another register.\n+   LABEL indicates the address of EXPR.\n \n    This function encodes a state machine mapping rtxes to actions on\n    cfa, cfa_store, and cfa_temp.reg.  We describe these rules so\n@@ -1224,12 +1304,20 @@ static dw_cfa_location cfa_temp;\n   RTX_FRAME_RELATED_P is set on an insn which modifies memory, it's a\n   register save, and the register used to calculate the destination\n   had better be the one we think we're using for this purpose.\n+  It's also assumed that a copy from a call-saved register to another\n+  register is saving that register if RTX_FRAME_RELATED_P is set on\n+  that instruction.  If the copy is from a call-saved register to\n+  the *same* register, that means that the register is now the same\n+  value as in the caller.\n \n   Except: If the register being saved is the CFA register, and the\n   offset is nonzero, we are saving the CFA, so we assume we have to\n   use DW_CFA_def_cfa_expression.  If the offset is 0, we assume that\n   the intent is to save the value of SP from the previous frame.\n \n+  In addition, if a register has previously been saved to a different\n+  register, \n+\n   Invariants / Summaries of Rules\n \n   cfa\t       current rule for calculating the CFA.  It usually\n@@ -1380,29 +1468,42 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n   src = SET_SRC (expr);\n   dest = SET_DEST (expr);\n \n+  if (GET_CODE (src) == REG)\n+    {\n+      rtx rsi = reg_saved_in (src);\n+      if (rsi)\n+\tsrc = rsi;\n+    }\n+\n   switch (GET_CODE (dest))\n     {\n     case REG:\n-      /* Rule 1 */\n-      /* Update the CFA rule wrt SP or FP.  Make sure src is\n-\t relative to the current CFA register.  */\n       switch (GET_CODE (src))\n \t{\n \t  /* Setting FP from SP.  */\n \tcase REG:\n \t  if (cfa.reg == (unsigned) REGNO (src))\n-\t    /* OK.  */\n-\t    ;\n+\t    {\n+\t      /* Rule 1 */\n+\t      /* Update the CFA rule wrt SP or FP.  Make sure src is\n+\t\t relative to the current CFA register. \n+\n+\t\t We used to require that dest be either SP or FP, but the\n+\t\t ARM copies SP to a temporary register, and from there to\n+\t\t FP.  So we just rely on the backends to only set\n+\t\t RTX_FRAME_RELATED_P on appropriate insns.  */\n+\t      cfa.reg = REGNO (dest);\n+\t      cfa_temp.reg = cfa.reg;\n+\t      cfa_temp.offset = cfa.offset;\n+\t    }\n+\t  else if (call_used_regs [REGNO (dest)] \n+\t\t   && ! fixed_regs [REGNO (dest)])\n+\t    {\n+\t      /* Saving a register in a register.  */\n+\t      queue_reg_save (label, src, dest, 0);\n+\t    }\n \t  else\n \t    abort ();\n-\n-\t  /* We used to require that dest be either SP or FP, but the\n-\t     ARM copies SP to a temporary register, and from there to\n-\t     FP.  So we just rely on the backends to only set\n-\t     RTX_FRAME_RELATED_P on appropriate insns.  */\n-\t  cfa.reg = REGNO (dest);\n-\t  cfa_temp.reg = cfa.reg;\n-\t  cfa_temp.offset = cfa.offset;\n \t  break;\n \n \tcase PLUS:\n@@ -1642,7 +1743,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t\t we're saving SP like any other register; this happens\n \t\t on the ARM.  */\n \t      def_cfa_1 (label, &cfa);\n-\t      queue_reg_save (label, stack_pointer_rtx, offset);\n+\t      queue_reg_save (label, stack_pointer_rtx, NULL_RTX, offset);\n \t      break;\n \t    }\n \t  else\n@@ -1665,7 +1766,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t}\n \n       def_cfa_1 (label, &cfa);\n-      queue_reg_save (label, src, offset);\n+      queue_reg_save (label, src, NULL_RTX, offset);\n       break;\n \n     default:\n@@ -1685,6 +1786,8 @@ dwarf2out_frame_debug (rtx insn)\n \n   if (insn == NULL_RTX)\n     {\n+      size_t i;\n+      \n       /* Flush any queued register saves.  */\n       flush_queued_reg_saves ();\n \n@@ -1697,6 +1800,13 @@ dwarf2out_frame_debug (rtx insn)\n       cfa_store = cfa;\n       cfa_temp.reg = -1;\n       cfa_temp.offset = 0;\n+      \n+      for (i = 0; i < num_regs_saved_in_regs; i++)\n+\t{\n+\t  regs_saved_in_regs[i].orig_reg = NULL_RTX;\n+\t  regs_saved_in_regs[i].saved_in_reg = NULL_RTX;\n+\t}\n+      num_regs_saved_in_regs = 0;\n       return;\n     }\n "}, {"sha": "926c9cd8b7f9989b2c6c9f1053b1182fb7576cd1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -1,3 +1,14 @@\n+2004-06-26  Geoffrey Keating  <geoffk@apple.com>\n+\t    Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* gcc.dg/cleanup-10.c: Run on all Linux platforms and powerpc-darwin.\n+\tUse SA_RESETHAND rather than SA_ONESHOT.  Trap SIGBUS as well\n+\tas SIGSEGV.\n+\t* gcc.dg/cleanup-11.c: Likewise.\n+\t* gcc.dg/cleanup-8.c: Likewise.\n+\t* gcc.dg/cleanup-9.c: Likewise.\n+\t* gcc.dg/cleanup-5.c: Run on all platforms.\n+\n 2004-06-30  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* g++.dg/warn/nonnull1.C: New test."}, {"sha": "76470e615816b7d19df32cb87f1864fff8fd4fa2", "filename": "gcc/testsuite/gcc.dg/cleanup-10.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-10.c?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* mips*-*-linux* } } */\n+/* { dg-do run { target *-*-linux* powerpc*-*-darwin* } } */\n /* { dg-options \"-fasynchronous-unwind-tables -fexceptions -O2\" } */\n /* Verify that cleanups work with exception handling through signal frames\n    on alternate stack.  */\n@@ -93,8 +93,9 @@ static int __attribute__((noinline)) fn1 ()\n \n   sigemptyset (&s.sa_mask);\n   s.sa_sigaction = fn4;\n-  s.sa_flags = SA_ONESHOT | SA_ONSTACK;\n+  s.sa_flags = SA_RESETHAND | SA_ONSTACK;\n   sigaction (SIGSEGV, &s, NULL);\n+  sigaction (SIGBUS, &s, NULL);\n   fn2 ();\n   return 0;\n }"}, {"sha": "4ad131f00ae893d10130cfba42447b9769656f6f", "filename": "gcc/testsuite/gcc.dg/cleanup-11.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-11.c?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* mips*-*-linux* } } */\n+/* { dg-do run { target *-*-linux* powerpc*-*-darwin* } } */\n /* { dg-options \"-fasynchronous-unwind-tables -fexceptions -O2\" } */\n /* Verify that cleanups work with exception handling through realtime signal\n    frames on alternate stack.  */\n@@ -93,8 +93,9 @@ static int __attribute__((noinline)) fn1 ()\n \n   sigemptyset (&s.sa_mask);\n   s.sa_sigaction = fn4;\n-  s.sa_flags = SA_ONESHOT | SA_ONSTACK | SA_SIGINFO;\n+  s.sa_flags = SA_RESETHAND | SA_ONSTACK | SA_SIGINFO;\n   sigaction (SIGSEGV, &s, NULL);\n+  sigaction (SIGBUS, &s, NULL);\n   fn2 ();\n   return 0;\n }"}, {"sha": "f5306db47526af3822f13f03b49097edc3a02c74", "filename": "gcc/testsuite/gcc.dg/cleanup-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-5.c?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* mips*-*-linux* } } */\n+/* { dg-do run } */\n /* { dg-options \"-fexceptions\" } */\n /* Verify that cleanups work with exception handling.  */\n "}, {"sha": "b802d25ead179b4939f46ac50517c20dc786ffa7", "filename": "gcc/testsuite/gcc.dg/cleanup-8.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-8.c?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* } } */\n+/* { dg-do run { target *-*-linux* powerpc*-*-darwin* } } */\n /* { dg-options \"-fasynchronous-unwind-tables -fexceptions -O2\" } */\n /* Verify that cleanups work with exception handling through signal\n    frames.  */\n@@ -78,6 +78,7 @@ static int __attribute__((noinline)) fn2 ()\n static int __attribute__((noinline)) fn1 ()\n {\n   signal (SIGSEGV, fn4);\n+  signal (SIGBUS, fn4);\n   fn2 ();\n   return 0;\n }"}, {"sha": "2381e955e44d1a39130cf417efd347a3ea8355a4", "filename": "gcc/testsuite/gcc.dg/cleanup-9.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-9.c?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* mips*-*-linux* } } */\n+/* { dg-do run { target *-*-linux* powerpc*-*-darwin* } } */\n /* { dg-options \"-fasynchronous-unwind-tables -fexceptions -O2\" } */\n /* Verify that cleanups work with exception handling through realtime\n    signal frames.  */\n@@ -80,8 +80,9 @@ static int __attribute__((noinline)) fn1 ()\n   struct sigaction s;\n   sigemptyset (&s.sa_mask);\n   s.sa_sigaction = fn4;\n-  s.sa_flags = SA_ONESHOT | SA_SIGINFO;\n+  s.sa_flags = SA_RESETHAND | SA_SIGINFO;\n   sigaction (SIGSEGV, &s, NULL);\n+  sigaction (SIGBUS, &s, NULL);\n   fn2 ();\n   return 0;\n }"}, {"sha": "11b94b123d0f72d4b20d5708e5c1e817c6cb4b70", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 4, "deletions": 59, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -40,7 +40,7 @@\n #include \"unwind-pe.h\"\n #include \"unwind-dw2-fde.h\"\n #include \"gthr.h\"\n-\n+#include \"unwind-dw2.h\"\n \n #ifndef __USING_SJLJ_EXCEPTIONS__\n \n@@ -51,12 +51,6 @@\n #define STACK_GROWS_DOWNWARD 1\n #endif\n \n-/* A target can override (perhaps for backward compatibility) how\n-   many dwarf2 columns are unwound.  */\n-#ifndef DWARF_FRAME_REGISTERS\n-#define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER\n-#endif\n-\n /* Dwarf frame registers used for pre gcc 3.0 compiled glibc.  */\n #ifndef PRE_GCC3_DWARF_FRAME_REGISTERS\n #define PRE_GCC3_DWARF_FRAME_REGISTERS DWARF_FRAME_REGISTERS\n@@ -87,58 +81,6 @@ struct _Unwind_Context\n /* Byte size of every register managed by these routines.  */\n static unsigned char dwarf_reg_size_table[DWARF_FRAME_REGISTERS+1];\n \n-\f\n-/* The result of interpreting the frame unwind info for a frame.\n-   This is all symbolic at this point, as none of the values can\n-   be resolved until the target pc is located.  */\n-typedef struct\n-{\n-  /* Each register save state can be described in terms of a CFA slot,\n-     another register, or a location expression.  */\n-  struct frame_state_reg_info\n-  {\n-    struct {\n-      union {\n-\t_Unwind_Word reg;\n-\t_Unwind_Sword offset;\n-\tconst unsigned char *exp;\n-      } loc;\n-      enum {\n-\tREG_UNSAVED,\n-\tREG_SAVED_OFFSET,\n-\tREG_SAVED_REG,\n-\tREG_SAVED_EXP\n-      } how;\n-    } reg[DWARF_FRAME_REGISTERS+1];\n-\n-    /* Used to implement DW_CFA_remember_state.  */\n-    struct frame_state_reg_info *prev;\n-  } regs;\n-\n-  /* The CFA can be described in terms of a reg+offset or a\n-     location expression.  */\n-  _Unwind_Sword cfa_offset;\n-  _Unwind_Word cfa_reg;\n-  const unsigned char *cfa_exp;\n-  enum {\n-    CFA_UNSET,\n-    CFA_REG_OFFSET,\n-    CFA_EXP\n-  } cfa_how;\n-\n-  /* The PC described by the current frame state.  */\n-  void *pc;\n-\n-  /* The information we care about from the CIE/FDE.  */\n-  _Unwind_Personality_Fn personality;\n-  _Unwind_Sword data_align;\n-  _Unwind_Word code_align;\n-  _Unwind_Word retaddr_column;\n-  unsigned char fde_encoding;\n-  unsigned char lsda_encoding;\n-  unsigned char saw_z;\n-  void *eh_ptr;\n-} _Unwind_FrameState;\n \f\n /* Read unaligned data from the instruction buffer.  */\n \n@@ -866,12 +808,15 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \n \tcase DW_CFA_restore_extended:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  /* FIXME, this is wrong; the CIE might have said that the\n+\t     register was saved somewhere.  */\n \t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNSAVED;\n \t  break;\n \n \tcase DW_CFA_undefined:\n \tcase DW_CFA_same_value:\n \t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNSAVED;\n \t  break;\n \n \tcase DW_CFA_nop:"}, {"sha": "77563e7441488a6a13508e59b391252256a4d4e8", "filename": "gcc/unwind-dw2.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Funwind-dw2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/gcc%2Funwind-dw2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.h?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -0,0 +1,88 @@\n+/* DWARF2 frame unwind data structure.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combined\n+   executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* A target can override (perhaps for backward compatibility) how\n+   many dwarf2 columns are unwound.  */\n+#ifndef DWARF_FRAME_REGISTERS\n+#define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER\n+#endif\n+\n+/* The result of interpreting the frame unwind info for a frame.\n+   This is all symbolic at this point, as none of the values can\n+   be resolved until the target pc is located.  */\n+typedef struct\n+{\n+  /* Each register save state can be described in terms of a CFA slot,\n+     another register, or a location expression.  */\n+  struct frame_state_reg_info\n+  {\n+    struct {\n+      union {\n+\t_Unwind_Word reg;\n+\t_Unwind_Sword offset;\n+\tconst unsigned char *exp;\n+      } loc;\n+      enum {\n+\tREG_UNSAVED,\n+\tREG_SAVED_OFFSET,\n+\tREG_SAVED_REG,\n+\tREG_SAVED_EXP\n+      } how;\n+    } reg[DWARF_FRAME_REGISTERS+1];\n+\n+    /* Used to implement DW_CFA_remember_state.  */\n+    struct frame_state_reg_info *prev;\n+  } regs;\n+\n+  /* The CFA can be described in terms of a reg+offset or a\n+     location expression.  */\n+  _Unwind_Sword cfa_offset;\n+  _Unwind_Word cfa_reg;\n+  const unsigned char *cfa_exp;\n+  enum {\n+    CFA_UNSET,\n+    CFA_REG_OFFSET,\n+    CFA_EXP\n+  } cfa_how;\n+\n+  /* The PC described by the current frame state.  */\n+  void *pc;\n+\n+  /* The information we care about from the CIE/FDE.  */\n+  _Unwind_Personality_Fn personality;\n+  _Unwind_Sword data_align;\n+  _Unwind_Word code_align;\n+  _Unwind_Word retaddr_column;\n+  unsigned char fde_encoding;\n+  unsigned char lsda_encoding;\n+  unsigned char saw_z;\n+  void *eh_ptr;\n+} _Unwind_FrameState;\n+"}, {"sha": "8df39520d91a019fc6f048da4506b56488f4ee57", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -1,3 +1,12 @@\n+2004-06-26  Geoffrey Keating  <geoffk@apple.com>\n+\t    Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* configure.host (powerpc-*-darwin*): New case, define\n+\tcan_unwind_signal.\n+\t* configure.in (*-*-darwin*): New case, point to darwin-signal.h.\n+\t* configure: Regenerate.\n+\t* include/darwin-signal.h: New.\n+\n 2004-06-30  Jerry Quinn  <jlquinn@optonline.net>\n \n \t* java/beans/Statement.java (doExecute): Fix formatting."}, {"sha": "463bd0b085a6edc0d620c4d3e02a7984a908392c", "filename": "libjava/configure", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -8553,6 +8553,9 @@ case \"${host}\" in\n  mips*-*-linux*)\n     SIGNAL_HANDLER=include/mips-signal.h\n     ;;\n+ *-*-darwin*)\n+    SIGNAL_HANDLER=include/darwin-signal.h\n+    ;;\n  *)\n     SIGNAL_HANDLER=include/default-signal.h\n     ;;"}, {"sha": "d008df1d00108d7c78881c1b680c9f5daad2ac61", "filename": "libjava/configure.host", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -232,10 +232,10 @@ EOF\n \t    ;;\n \tesac\n \t;;\n-  *-*-darwin*)\n+  powerpc*-*-darwin*)\n \tenable_hash_synchronization_default=no\n \tslow_pthread_self=\n-\tcan_unwind_signal=no\n+\tcan_unwind_signal=yes\n \t;;\n   *-*-freebsd*)\n \tslow_pthread_self="}, {"sha": "2eff8f95d6d5921ffded1c0fff376d9f603710d8", "filename": "libjava/configure.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -1205,6 +1205,9 @@ case \"${host}\" in\n  mips*-*-linux*)\n     SIGNAL_HANDLER=include/mips-signal.h\n     ;;\n+ *-*-darwin*)\n+    SIGNAL_HANDLER=include/darwin-signal.h\n+    ;;\n  *)\n     SIGNAL_HANDLER=include/default-signal.h\n     ;;"}, {"sha": "5003e211c241387e38c533f70ae102c586c09492", "filename": "libjava/include/darwin-signal.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a57be8182804460dde7e7f28a681e26577fdae/libjava%2Finclude%2Fdarwin-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a57be8182804460dde7e7f28a681e26577fdae/libjava%2Finclude%2Fdarwin-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fdarwin-signal.h?ref=f8a57be8182804460dde7e7f28a681e26577fdae", "patch": "@@ -0,0 +1,51 @@\n+/* darwin-signal.h - Catch runtime signals and turn them into exceptions,\n+   on a Darwin system.  */\n+\n+/* Copyright (C) 2004  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* This file is really more of a specification.  The rest of the system\n+   should be arranged so that this Just Works.  */\n+\n+#ifndef JAVA_SIGNAL_H\n+# define JAVA_SIGNAL_H 1\n+\n+#include <sys/types.h>\n+#include <stdio.h>\n+#include <signal.h>\n+\n+typedef void (* SIG_PF)(int);\n+\n+# define HANDLE_SEGV 1\n+# undef HANDLE_FPE\n+\n+# define SIGNAL_HANDLER(_name)\t\t\t\t\t\\\n+  static void _name (int _dummy __attribute__ ((unused)))\n+\n+# define MAKE_THROW_FRAME(_exception)\n+\n+# define INIT_SEGV\t\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+      struct sigaction sa;\t\t\t\\\n+      sa.sa_handler = catch_segv;\t\t\\\n+      sigemptyset (&sa.sa_mask);\t\t\\\n+      sa.sa_flags = SA_NODEFER;\t\t\t\\\n+      sigaction (SIGBUS, &sa, NULL);\t\t\\\n+      sigaction (SIGSEGV, &sa, NULL);\t\t\\\n+    } while (0)\n+\n+# define INIT_FPE\t\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+      struct sigaction sa;\t\t\t\\\n+      sa.sa_handler = catch_fpe;\t\t\\\n+      sigemptyset (&sa.sa_mask);\t\t\\\n+      sa.sa_flags = SA_NODEFER;\t\t\t\\\n+      sigaction (SIGFPE, &sa, NULL);\t\t\\\n+    } while (0)\n+\n+#endif /* JAVA_SIGNAL_H */"}]}