{"sha": "a12fe13ddb02336f99401401bfd8e85d5bd343bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEyZmUxM2RkYjAyMzM2Zjk5NDAxNDAxYmZkOGU4NWQ1YmQzNDNiYw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-11-05T23:39:54Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-11-05T23:39:54Z"}, "message": "Class.h (Class): Made _Jv_BytecodeVerifier a friend.\n\n\t* java/lang/Class.h (Class): Made _Jv_BytecodeVerifier a friend.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (libgcj_la_SOURCES): Added verify.cc.\n\t* verify.cc: New file.\n\t* include/java-interp.h (_Jv_count_arguments): Declare.\n\t(_Jv_VerifyMethod): Likewise.\n\t(class _Jv_InterpMethod): Made _Jv_BytecodeVerifier a friend.\n\t(class _Jv_InterpException): Likewise.\n\t* resolve.cc (_Jv_count_arguments): Renamed from count_arguments.\n\tNo longer static.  Updated callers.\n\t* defineclass.cc (int_bits_to_float): Removed.\n\t(long_bits_to_double): Likewise.\n\t(prepare_pool_entry): Updated.\n\t(handleCodeAttribute): Verify method (commented out for now).\n\nFrom-SVN: r46796", "tree": {"sha": "00e8580aca78cea0cc0c6157e06cdab7d56a0790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00e8580aca78cea0cc0c6157e06cdab7d56a0790"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a12fe13ddb02336f99401401bfd8e85d5bd343bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a12fe13ddb02336f99401401bfd8e85d5bd343bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a12fe13ddb02336f99401401bfd8e85d5bd343bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a12fe13ddb02336f99401401bfd8e85d5bd343bc/comments", "author": null, "committer": null, "parents": [{"sha": "e6ec164c8d2631e6dcb9f20e9ca0266d73633e37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ec164c8d2631e6dcb9f20e9ca0266d73633e37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6ec164c8d2631e6dcb9f20e9ca0266d73633e37"}], "stats": {"total": 2560, "additions": 2513, "deletions": 47}, "files": [{"sha": "cc3d33faeb3a955d05def8a89be8f7fb19018e9e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a12fe13ddb02336f99401401bfd8e85d5bd343bc", "patch": "@@ -1,3 +1,20 @@\n+2001-11-05  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/Class.h (Class): Made _Jv_BytecodeVerifier a friend.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (libgcj_la_SOURCES): Added verify.cc.\n+\t* verify.cc: New file.\n+\t* include/java-interp.h (_Jv_count_arguments): Declare.\n+\t(_Jv_VerifyMethod): Likewise.\n+\t(class _Jv_InterpMethod): Made _Jv_BytecodeVerifier a friend.\n+\t(class _Jv_InterpException): Likewise.\n+\t* resolve.cc (_Jv_count_arguments): Renamed from count_arguments.\n+\tNo longer static.  Updated callers.\n+\t* defineclass.cc (int_bits_to_float): Removed.\n+\t(long_bits_to_double): Likewise.\n+\t(prepare_pool_entry): Updated.\n+\t(handleCodeAttribute): Verify method (commented out for now).\n+\n 2001-11-05  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* java/util/ResourceBundle.java (class Security): Now static."}, {"sha": "a75d886eddd9660e3690a0cd75b07289171cc887", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=a12fe13ddb02336f99401401bfd8e85d5bd343bc", "patch": "@@ -124,7 +124,7 @@ javao_files = $(java_source_files:.java=.lo) \\\n x_javao_files = $(x_java_source_files:.java=.lo)\n \n libgcj_la_SOURCES = prims.cc posix.cc jni.cc exception.cc \\\n-\tresolve.cc defineclass.cc interpret.cc name-finder.cc \\\n+\tresolve.cc defineclass.cc interpret.cc name-finder.cc verify.cc \\\n \t$(nat_source_files)\n EXTRA_libgcj_la_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n \t$(c_source_files) $(java_source_files) $(built_java_source_files)"}, {"sha": "5d51c32599402a9d6aec5da4ab03bff03fd32a9c", "filename": "libjava/Makefile.in", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=a12fe13ddb02336f99401401bfd8e85d5bd343bc", "patch": "@@ -123,28 +123,40 @@ libgcj_basedir = @libgcj_basedir@\n mkinstalldirs = @mkinstalldirs@\n \n AUTOMAKE_OPTIONS = foreign\n-@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n-@XLIB_AWT_TRUE@cond_x_ltlibrary = @XLIB_AWT_TRUE@libgcjx.la\n-@XLIB_AWT_FALSE@cond_x_ltlibrary = \n+@TESTSUBDIR_TRUE@SUBDIRS = \\\n+@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = \\\n+@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = \\\n+@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = \\\n+@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = \\\n+@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@XLIB_AWT_TRUE@cond_x_ltlibrary = \\\n+@XLIB_AWT_TRUE@libgcjx.la\n+@XLIB_AWT_FALSE@cond_x_ltlibrary = \\\n \n toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.jar\n \n secdir = $(libdir)/security\n \n-@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij rmic rmiregistry\n+@NATIVE_TRUE@bin_PROGRAMS = \\\n+@NATIVE_TRUE@jv-convert gij rmic rmiregistry\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@jar\n-@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@jar\n+@CANADIAN_FALSE@ZIP = \\\n+@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = \\\n+@CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = \\\n+@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n \n GCJ_WITH_FLAGS = $(GCJ) --encoding=UTF-8\n \n@@ -164,8 +176,10 @@ AM_CXXFLAGS = -fno-rtti -fnon-call-exceptions \\\n \t@LIBGCJ_CXXFLAGS@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE \\\n \t-DPREFIX=\"\\\"$(prefix)\\\"\"\n \n-@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = \\\n+@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = \\\n+@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = @LIBGCJ_JAVAFLAGS@ $(GCJFLAGS)\n@@ -186,7 +200,7 @@ javao_files = $(java_source_files:.java=.lo) \\\n x_javao_files = $(x_java_source_files:.java=.lo)\n \n libgcj_la_SOURCES = prims.cc posix.cc jni.cc exception.cc \\\n-\tresolve.cc defineclass.cc interpret.cc name-finder.cc \\\n+\tresolve.cc defineclass.cc interpret.cc name-finder.cc verify.cc \\\n \t$(nat_source_files)\n \n EXTRA_libgcj_la_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n@@ -234,7 +248,8 @@ extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -1496,7 +1511,7 @@ X_LIBS = @X_LIBS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_PRE_LIBS = @X_PRE_LIBS@\n libgcj_la_OBJECTS =  prims.lo posix.lo jni.lo exception.lo resolve.lo \\\n-defineclass.lo interpret.lo name-finder.lo gnu/gcj/natCore.lo \\\n+defineclass.lo interpret.lo name-finder.lo verify.lo gnu/gcj/natCore.lo \\\n gnu/gcj/convert/JIS0208_to_Unicode.lo \\\n gnu/gcj/convert/JIS0212_to_Unicode.lo gnu/gcj/convert/Unicode_to_JIS.lo \\\n gnu/gcj/convert/natIconv.lo gnu/gcj/convert/natInput_EUCJIS.lo \\\n@@ -1562,7 +1577,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -2369,7 +2384,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/org/xml/sax/helpers/XMLFilterImpl.P \\\n .deps/org/xml/sax/helpers/XMLReaderAdapter.P \\\n .deps/org/xml/sax/helpers/XMLReaderFactory.P .deps/posix-threads.P \\\n-.deps/posix.P .deps/prims.P .deps/resolve.P\n+.deps/posix.P .deps/prims.P .deps/resolve.P .deps/verify.P\n SOURCES = $(libgcj_la_SOURCES) $(EXTRA_libgcj_la_SOURCES) $(libgcjx_la_SOURCES) $(EXTRA_libgcjx_la_SOURCES) $(jv_convert_SOURCES) $(EXTRA_jv_convert_SOURCES) $(gij_SOURCES) $(rmic_SOURCES) $(EXTRA_rmic_SOURCES) $(rmiregistry_SOURCES) $(EXTRA_rmiregistry_SOURCES) $(gen_from_JIS_SOURCES) $(EXTRA_gen_from_JIS_SOURCES)\n OBJECTS = $(libgcj_la_OBJECTS) $(libgcjx_la_OBJECTS) $(jv_convert_OBJECTS) $(gij_OBJECTS) $(rmic_OBJECTS) $(rmiregistry_OBJECTS) $(gen_from_JIS_OBJECTS)\n \n@@ -2710,7 +2725,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "db37203e2c4d37e28745e646dfa76ab5b2ee5023", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=a12fe13ddb02336f99401401bfd8e85d5bd343bc", "patch": "@@ -58,9 +58,6 @@ static void throw_incompatible_class_change_error (jstring msg)\n static void throw_class_circularity_error (jstring msg)\n \t__attribute__ ((__noreturn__));\n \n-static jdouble long_bits_to_double (jlong);\n-static jfloat int_bits_to_float (jint);\n-\n /**\n  * We define class reading using a class.  It is practical, since then\n  * the entire class-reader can be a friend of class Class (it needs to\n@@ -826,7 +823,7 @@ _Jv_ClassReader::prepare_pool_entry (int index, unsigned char this_tag)\n \t    \n     case JV_CONSTANT_Float:\n       {\n-\tjfloat f = int_bits_to_float ((jint) get4 (this_data));\n+\tjfloat f = java::lang::Float::intBitsToFloat ((jint) get4 (this_data));\n \t_Jv_storeFloat (&pool_data[index], f);\n \tpool_tags[index] = JV_CONSTANT_Float;\n       }\n@@ -842,7 +839,8 @@ _Jv_ClassReader::prepare_pool_entry (int index, unsigned char this_tag)\n \t    \n     case JV_CONSTANT_Double:\n       {\n-\tjdouble d = long_bits_to_double ((jlong) get8 (this_data));\n+\tjdouble d\n+\t  = java::lang::Double::longBitsToDouble ((jlong) get8 (this_data));\n \t_Jv_storeDouble (&pool_data[index], d);\n \tpool_tags[index] = JV_CONSTANT_Double;\n       }\n@@ -1282,10 +1280,12 @@ void _Jv_ClassReader::handleCodeAttribute\n   memcpy ((void*) method->bytecode (),\n \t  (void*) (bytes+code_start),\n \t  code_length);\n-  \n+\n   def->interpreted_methods[method_index] = method;\n \n-  /* that's all we do for now */\n+  // FIXME: Shouldn't this be done after loading completes?\n+//    if (verify)\n+//      _Jv_VerifyMethod (method);\n }\n \n void _Jv_ClassReader::handleExceptionTableEntry \n@@ -1635,16 +1635,6 @@ throw_internal_error (char *msg)\n   throw new java::lang::InternalError (JvNewStringLatin1 (msg));\n }\n \n-static jfloat int_bits_to_float (jint value)\n-{\n-  return java::lang::Float::intBitsToFloat (value);\n-}\n-\n-static jdouble long_bits_to_double (jlong value)\n-{\n-  return java::lang::Double::longBitsToDouble (value);\n-}\n-\n static void throw_incompatible_class_change_error (jstring msg)\n {\n   throw new java::lang::IncompatibleClassChangeError (msg);"}, {"sha": "8eeb09493787dac22dee4224056c77366600bdc9", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=a12fe13ddb02336f99401401bfd8e85d5bd343bc", "patch": "@@ -43,6 +43,9 @@ void _Jv_DefineClass (jclass, jbyteArray, jint, jint);\n \n void _Jv_InitField (jobject, jclass, int);\n void * _Jv_AllocMethodInvocation (jsize size);\n+int  _Jv_count_arguments (_Jv_Utf8Const *signature,\n+\t\t\t  jboolean staticp = true);\n+void _Jv_VerifyMethod (_Jv_InterpMethod *method);\n \n /* FIXME: this should really be defined in some more generic place */\n #define ROUND(V, A) (((((unsigned) (V))-1) | ((A)-1))+1)\n@@ -54,14 +57,16 @@ class _Jv_InterpClass;\n class _Jv_InterpMethod;\n class _Jv_InterpMethodInvocation;\n \n-class _Jv_InterpException {\n+class _Jv_InterpException\n+{\n   int  start_pc;\n   int  end_pc;\n   int  handler_pc;\n   int  handler_type;\n \n   friend class _Jv_ClassReader;\n   friend class _Jv_InterpMethod;\n+  friend class _Jv_BytecodeVerifier;\n };\n \n // Base class for method representations.  Subclasses are interpreted\n@@ -133,6 +138,7 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n \n   friend class _Jv_ClassReader;\n   friend class _Jv_InterpMethodInvocation;\n+  friend class _Jv_BytecodeVerifier;\n \n   friend void _Jv_PrepareClass(jclass);\n };"}, {"sha": "aac5f12dd26ef322a45137ad9dc7d571905cecbf", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=a12fe13ddb02336f99401401bfd8e85d5bd343bc", "patch": "@@ -337,6 +337,8 @@ class java::lang::Class : public java::lang::Object\n   friend JV_MARKOBJ_DECL;\n #endif\n \n+  friend class _Jv_BytecodeVerifier;\n+\n   // Chain for class pool.\n   jclass next;\n   // Name of class."}, {"sha": "2b25b578b8524b6ac229b88e7c135e7b86c41e72", "filename": "libjava/resolve.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=a12fe13ddb02336f99401401bfd8e85d5bd343bc", "patch": "@@ -958,9 +958,9 @@ get_ffi_type_from_signature (unsigned char* ptr)\n  * function is non-static, then one is added to the number of elements\n  * found in the signature */\n \n-static int \n-count_arguments (_Jv_Utf8Const *signature,\n-\t\t jboolean staticp)\n+int \n+_Jv_count_arguments (_Jv_Utf8Const *signature,\n+\t\t     jboolean staticp)\n {\n   unsigned char *ptr = (unsigned char*) signature->data;\n   int arg_count = staticp ? 0 : 1;\n@@ -1048,7 +1048,7 @@ init_cif (_Jv_Utf8Const* signature,\n #endif\n \n /* we put this one here, and not in interpret.cc because it\n- * calls the utility routines count_arguments \n+ * calls the utility routines _Jv_count_arguments \n  * which are static to this module.  The following struct defines the\n  * layout we use for the stubs, it's only used in the ncode method. */\n \n@@ -1069,7 +1069,7 @@ _Jv_InterpMethod::ncode ()\n     return self->ncode;\n \n   jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n-  int arg_count = count_arguments (self->signature, staticp);\n+  int arg_count = _Jv_count_arguments (self->signature, staticp);\n \n   ncode_closure *closure =\n     (ncode_closure*)_Jv_AllocBytes (sizeof (ncode_closure)\n@@ -1119,7 +1119,7 @@ _Jv_JNIMethod::ncode ()\n     return self->ncode;\n \n   jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n-  int arg_count = count_arguments (self->signature, staticp);\n+  int arg_count = _Jv_count_arguments (self->signature, staticp);\n \n   ncode_closure *closure =\n     (ncode_closure*)_Jv_AllocBytes (sizeof (ncode_closure)\n@@ -1180,7 +1180,7 @@ _Jv_BuildResolvedMethod (_Jv_Method* method,\n \t\t\t jboolean staticp,\n \t\t\t jint vtable_index)\n {\n-  int arg_count = count_arguments (method->signature, staticp);\n+  int arg_count = _Jv_count_arguments (method->signature, staticp);\n \n   _Jv_ResolvedMethod* result = (_Jv_ResolvedMethod*)\n     _Jv_AllocBytes (sizeof (_Jv_ResolvedMethod)"}, {"sha": "a32af6857007e217a00727c723e3a290616bdb76", "filename": "libjava/verify.cc", "status": "added", "additions": 2436, "deletions": 0, "changes": 2436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12fe13ddb02336f99401401bfd8e85d5bd343bc/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=a12fe13ddb02336f99401401bfd8e85d5bd343bc", "patch": "@@ -0,0 +1,2436 @@\n+// defineclass.cc - defining a class from .class format.\n+\n+/* Copyright (C) 2001  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Writte by Tom Tromey <tromey@redhat.com>\n+\n+#include <config.h>\n+\n+#include <jvm.h>\n+#include <gcj/cni.h>\n+#include <java-insns.h>\n+#include <java-interp.h>\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/VerifyError.h>\n+#include <java/lang/Throwable.h>\n+#include <java/lang/reflect/Modifier.h>\n+\n+\n+// TO DO\n+// * read more about when classes must be loaded\n+// * there are bugs with boolean arrays?\n+// * class loader madness\n+// * Lots and lots of debugging and testing\n+// * type representation is still ugly.  look for the big switches\n+// * at least one GC problem :-(\n+\n+\n+// This is global because __attribute__ doesn't seem to work on static\n+// methods.\n+static void verify_fail (char *s) __attribute__ ((__noreturn__));\n+\n+class _Jv_BytecodeVerifier\n+{\n+private:\n+\n+  static const int FLAG_INSN_START = 1;\n+  static const int FLAG_BRANCH_TARGET = 2;\n+  static const int FLAG_JSR_TARGET = 4;\n+\n+  struct state;\n+  struct type;\n+  struct subr_info;\n+\n+  // The current PC.\n+  int PC;\n+  // The PC corresponding to the start of the current instruction.\n+  int start_PC;\n+\n+  // The current state of the stack, locals, etc.\n+  state *current_state;\n+\n+  // We store the state at branch targets, for merging.  This holds\n+  // such states.\n+  state **states;\n+\n+  // We keep a linked list of all the PCs which we must reverify.\n+  // The link is done using the PC values.  This is the head of the\n+  // list.\n+  int next_verify_pc;\n+\n+  // We keep some flags for each instruction.  The values are the\n+  // FLAG_* constants defined above.\n+  char *flags;\n+\n+  // We need to keep track of which instructions can call a given\n+  // subroutine.  FIXME: this is inefficient.  We keep a linked list\n+  // of all calling `jsr's at at each jsr target.\n+  subr_info **jsr_ptrs;\n+\n+  // The current top of the stack, in terms of slots.\n+  int stacktop;\n+  // The current depth of the stack.  This will be larger than\n+  // STACKTOP when wide types are on the stack.\n+  int stackdepth;\n+\n+  // The bytecode itself.\n+  unsigned char *bytecode;\n+  // The exceptions.\n+  _Jv_InterpException *exception;\n+\n+  // Defining class.\n+  jclass current_class;\n+  // This method.\n+  _Jv_InterpMethod *current_method;\n+\n+  // This enum holds a list of tags for all the different types we\n+  // need to handle.  Reference types are treated specially by the\n+  // type class.\n+  enum type_val\n+  {\n+    void_type,\n+\n+    // The values for primitive types are chosen to correspond to values\n+    // specified to newarray.\n+    boolean_type = 4,\n+    char_type = 5,\n+    float_type = 6,\n+    double_type = 7,\n+    byte_type = 8,\n+    short_type = 9,\n+    int_type = 10,\n+    long_type = 11,\n+\n+    // Used when overwriting second word of a double or long in the\n+    // local variables.  Also used after merging local variable states\n+    // to indicate an unusable value.\n+    unsuitable_type,\n+    return_address_type,\n+    continuation_type,\n+\n+    // Everything after `reference_type' must be a reference type.\n+    reference_type,\n+    null_type,\n+    unresolved_reference_type,\n+    uninitialized_reference_type,\n+    uninitialized_unresolved_reference_type\n+  };\n+\n+  // Return the type_val corresponding to a primitive signature\n+  // character.  For instance `I' returns `int.class'.\n+  static type_val get_type_val_for_signature (jchar sig)\n+  {\n+    type_val rt;\n+    switch (sig)\n+      {\n+      case 'Z':\n+\trt = boolean_type;\n+\tbreak;\n+      case 'C':\n+\trt = char_type;\n+\tbreak;\n+      case 'S':\n+\trt = short_type;\n+\tbreak;\n+      case 'I':\n+\trt = int_type;\n+\tbreak;\n+      case 'J':\n+\trt = long_type;\n+\tbreak;\n+      case 'F':\n+\trt = float_type;\n+\tbreak;\n+      case 'D':\n+\trt = double_type;\n+\tbreak;\n+      case 'V':\n+\trt = void_type;\n+\tbreak;\n+      default:\n+\tverify_fail (\"invalid signature\");\n+      }\n+    return rt;\n+  }\n+\n+  // Return the type_val corresponding to a primitive class.\n+  static type_val get_type_val_for_signature (jclass k)\n+  {\n+    return get_type_val_for_signature ((jchar) k->method_count);\n+  }\n+\n+  // This is used to keep track of which `jsr's correspond to a given\n+  // jsr target.\n+  struct subr_info\n+  {\n+    // PC of the instruction just after the jsr.\n+    int pc;\n+    // Link.\n+    subr_info *next;\n+  };\n+\n+  // The `type' class is used to represent a single type in the\n+  // verifier.\n+  struct type\n+  {\n+    // The type.\n+    type_val key;\n+    // Some associated data.\n+    union\n+    {\n+      // For a resolved reference type, this is a pointer to the class.\n+      jclass klass;\n+      // For other reference types, this it the name of the class.\n+      _Jv_Utf8Const *name;\n+    } data;\n+    // This is used when constructing a new object.  It is the PC of the\n+    // `new' instruction which created the object.  We use the special\n+    // value -2 to mean that this is uninitialized, and the special\n+    // value -1 for the case where the current method is itself the\n+    // <init> method.\n+    int pc;\n+\n+    static const int UNINIT = -2;\n+    static const int SELF = -1;\n+\n+    // Basic constructor.\n+    type ()\n+    {\n+      key = unsuitable_type;\n+      data.klass = NULL;\n+      pc = UNINIT;\n+    }\n+\n+    // Make a new instance given the type tag.  We assume a generic\n+    // `reference_type' means Object.\n+    type (type_val k)\n+    {\n+      key = k;\n+      data.klass = NULL;\n+      if (key == reference_type)\n+\tdata.klass = &java::lang::Object::class$;\n+      pc = UNINIT;\n+    }\n+\n+    // Make a new instance given a class.\n+    type (jclass klass)\n+    {\n+      key = reference_type;\n+      data.klass = klass;\n+      pc = UNINIT;\n+    }\n+\n+    // Make a new instance given the name of a class.\n+    type (_Jv_Utf8Const *n)\n+    {\n+      key = unresolved_reference_type;\n+      data.name = n;\n+      pc = UNINIT;\n+    }\n+\n+    // Copy constructor.\n+    type (const type &t)\n+    {\n+      key = t.key;\n+      data = t.data;\n+      pc = t.pc;\n+    }\n+\n+    // These operators are required because libgcj can't link in\n+    // -lstdc++.\n+    void *operator new[] (size_t bytes)\n+    {\n+      return _Jv_Malloc (bytes);\n+    }\n+\n+    void operator delete[] (void *mem)\n+    {\n+      _Jv_Free (mem);\n+    }\n+\n+    type& operator= (type_val k)\n+    {\n+      key = k;\n+      data.klass = NULL;\n+      pc = UNINIT;\n+      return *this;\n+    }\n+\n+    type& operator= (const type& t)\n+    {\n+      key = t.key;\n+      data = t.data;\n+      pc = t.pc;\n+      return *this;\n+    }\n+\n+    // Promote a numeric type.\n+    void promote ()\n+    {\n+      if (key == boolean_type || key == char_type\n+\t  || key == byte_type || key == short_type)\n+\tkey = int_type;\n+    }\n+\n+    // If *THIS is an unresolved reference type, resolve it.\n+    void resolve ()\n+    {\n+      if (key != unresolved_reference_type\n+\t  && key != uninitialized_unresolved_reference_type)\n+\treturn;\n+\n+      // FIXME: class loader\n+      using namespace java::lang;\n+      // We might see either kind of name.  Sigh.\n+      if (data.name->data[0] == 'L'\n+\t  && data.name->data[data.name->length - 1] == ';')\n+\tdata.klass = _Jv_FindClassFromSignature (data.name->data, NULL);\n+      else\n+\tdata.klass = Class::forName (_Jv_NewStringUtf8Const (data.name),\n+\t\t\t\t     false, NULL);\n+      key = (key == unresolved_reference_type\n+\t     ? reference_type\n+\t     : uninitialized_reference_type);\n+    }\n+\n+    // Mark this type as the uninitialized result of `new'.\n+    void set_uninitialized (int pc)\n+    {\n+      if (key != reference_type && key != unresolved_reference_type)\n+\tverify_fail (\"internal error in type::uninitialized\");\n+      key = (key == reference_type\n+\t     ? uninitialized_reference_type\n+\t     : uninitialized_unresolved_reference_type);\n+      pc = pc;\n+    }\n+\n+    // Mark this type as now initialized.\n+    void set_initialized (int npc)\n+    {\n+      if (pc == npc)\n+\t{\n+\t  key = (key == uninitialized_reference_type\n+\t\t ? reference_type\n+\t\t : unresolved_reference_type);\n+\t  pc = UNINIT;\n+\t}\n+    }\n+\n+\n+    // Return true if an object of type K can be assigned to a variable\n+    // of type *THIS.  Handle various special cases too.  Might modify\n+    // *THIS or K.  Note however that this does not perform numeric\n+    // promotion.\n+    bool compatible (type &k)\n+    {\n+      // Any type is compatible with the unsuitable type.\n+      if (key == unsuitable_type)\n+\treturn true;\n+\n+      if (key < reference_type || k.key < reference_type)\n+\treturn key == k.key;\n+\n+      // The `null' type is convertible to any reference type.\n+      // FIXME: is this correct for THIS?\n+      if (key == null_type || k.key == null_type)\n+\treturn true;\n+\n+      // Any reference type is convertible to Object.  This is a special\n+      // case so we don't need to unnecessarily resolve a class.\n+      if (key == reference_type\n+\t  && data.klass == &java::lang::Object::class$)\n+\treturn true;\n+\n+      // An initialized type and an uninitialized type are not\n+      // compatible.\n+      if (isinitialized () != k.isinitialized ())\n+\treturn false;\n+\n+      // Two uninitialized objects are compatible if either:\n+      // * The PCs are identical, or\n+      // * One PC is UNINIT.\n+      if (! isinitialized ())\n+\t{\n+\t  if (pc != k.pc && pc != UNINIT && k.pc != UNINIT)\n+\t    return false;\n+\t}\n+\n+      // Two unresolved types are equal if their names are the same.\n+      if (! isresolved ()\n+\t  && ! k.isresolved ()\n+\t  && _Jv_equalUtf8Consts (data.name, k.data.name))\n+\treturn true;\n+\n+      // We must resolve both types and check assignability.\n+      resolve ();\n+      k.resolve ();\n+      return data.klass->isAssignableFrom (k.data.klass);\n+    }\n+\n+    bool isvoid () const\n+    {\n+      return key == void_type;\n+    }\n+\n+    bool iswide () const\n+    {\n+      return key == long_type || key == double_type;\n+    }\n+\n+    // Return number of stack or local variable slots taken by this\n+    // type.\n+    int depth () const\n+    {\n+      return iswide () ? 2 : 1;\n+    }\n+\n+    bool isarray () const\n+    {\n+      // We treat null_type as not an array.  This is ok based on the\n+      // current uses of this method.\n+      if (key == reference_type)\n+\treturn data.klass->isArray ();\n+      else if (key == unresolved_reference_type)\n+\treturn data.name->data[0] == '[';\n+      return false;\n+    }\n+\n+    bool isinterface ()\n+    {\n+      resolve ();\n+      if (key != reference_type)\n+\treturn false;\n+      return data.klass->isInterface ();\n+    }\n+\n+    bool isabstract ()\n+    {\n+      resolve ();\n+      if (key != reference_type)\n+\treturn false;\n+      using namespace java::lang::reflect;\n+      return Modifier::isAbstract (data.klass->getModifiers ());\n+    }\n+\n+    // Return the element type of an array.\n+    type element_type ()\n+    {\n+      // FIXME: maybe should do string manipulation here.\n+      resolve ();\n+      if (key != reference_type)\n+\tverify_fail (\"programmer error in type::element_type()\");\n+\n+      jclass k = data.klass->getComponentType ();\n+      if (k->isPrimitive ())\n+\treturn type (get_type_val_for_signature (k));\n+      return type (k);\n+    }\n+\n+    bool isreference () const\n+    {\n+      return key >= reference_type;\n+    }\n+\n+    int get_pc () const\n+    {\n+      return pc;\n+    }\n+\n+    bool isinitialized () const\n+    {\n+      return (key == reference_type\n+\t      || key == null_type\n+\t      || key == unresolved_reference_type);\n+    }\n+\n+    bool isresolved () const\n+    {\n+      return (key == reference_type\n+\t      || key == null_type\n+\t      || key == uninitialized_reference_type);\n+    }\n+\n+    void verify_dimensions (int ndims)\n+    {\n+      // The way this is written, we don't need to check isarray().\n+      if (key == reference_type)\n+\t{\n+\t  jclass k = data.klass;\n+\t  while (k->isArray () && ndims > 0)\n+\t    {\n+\t      k = k->getComponentType ();\n+\t      --ndims;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  // We know KEY == unresolved_reference_type.\n+\t  char *p = data.name->data;\n+\t  while (*p++ == '[' && ndims-- > 0)\n+\t    ;\n+\t}\n+\n+      if (ndims > 0)\n+\tverify_fail (\"array type has fewer dimensions than required\");\n+    }\n+\n+    // Merge OLD_TYPE into this.  On error throw exception.\n+    bool merge (type& old_type, bool local_semantics = false)\n+    {\n+      bool changed = false;\n+      bool refo = old_type.isreference ();\n+      bool refn = isreference ();\n+      if (refo && refn)\n+\t{\n+\t  if (old_type.key == null_type)\n+\t    ;\n+\t  else if (key == null_type)\n+\t    {\n+\t      *this = old_type;\n+\t      changed = true;\n+\t    }\n+\t  else if (isinitialized () != old_type.isinitialized ())\n+\t    verify_fail (\"merging initialized and uninitialized types\");\n+\t  else\n+\t    {\n+\t      if (! isinitialized ())\n+\t\t{\n+\t\t  if (pc == UNINIT)\n+\t\t    pc = old_type.pc;\n+\t\t  else if (old_type.pc == UNINIT)\n+\t\t    ;\n+\t\t  else if (pc != old_type.pc)\n+\t\t    verify_fail (\"merging different uninitialized types\");\n+\t\t}\n+\n+\t      if (! isresolved ()\n+\t\t  && ! old_type.isresolved ()\n+\t\t  && _Jv_equalUtf8Consts (data.name, old_type.data.name))\n+\t\t{\n+\t\t  // Types are identical.\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  resolve ();\n+\t\t  old_type.resolve ();\n+\n+\t\t  jclass k = data.klass;\n+\t\t  jclass oldk = old_type.data.klass;\n+\n+\t\t  int arraycount = 0;\n+\t\t  while (k->isArray () && oldk->isArray ())\n+\t\t    {\n+\t\t      ++arraycount;\n+\t\t      k = k->getComponentType ();\n+\t\t      oldk = oldk->getComponentType ();\n+\t\t    }\n+\n+\t\t  // This loop will end when we hit Object.\n+\t\t  while (true)\n+\t\t    {\n+\t\t      if (k->isAssignableFrom (oldk))\n+\t\t\tbreak;\n+\t\t      k = k->getSuperclass ();\n+\t\t      changed = true;\n+\t\t    }\n+\n+\t\t  if (changed)\n+\t\t    {\n+\t\t      while (arraycount > 0)\n+\t\t\t{\n+\t\t\t  // FIXME: Class loader.\n+\t\t\t  k = _Jv_GetArrayClass (k, NULL);\n+\t\t\t  --arraycount;\n+\t\t\t}\n+\t\t      data.klass = k;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else if (refo || refn || key != old_type.key)\n+\t{\n+\t  if (local_semantics)\n+\t    {\n+\t      key = unsuitable_type;\n+\t      changed = true;\n+\t    }\n+\t  else\n+\t    verify_fail (\"unmergeable type\");\n+\t}\n+      return changed;\n+    }\n+  };\n+\n+  // This class holds all the state information we need for a given\n+  // location.\n+  struct state\n+  {\n+    // Current top of stack.\n+    int stacktop;\n+    // Current stack depth.  This is like the top of stack but it\n+    // includes wide variable information.\n+    int stackdepth;\n+    // The stack.\n+    type *stack;\n+    // The local variables.\n+    type *locals;\n+    // This is used in subroutines to keep track of which local\n+    // variables have been accessed.\n+    bool *local_changed;\n+    // If not 0, then we are in a subroutine.  The value is the PC of\n+    // the subroutine's entry point.  We can use 0 as an exceptional\n+    // value because PC=0 can never be a subroutine.\n+    int subroutine;\n+    // This is used to keep a linked list of all the states which\n+    // require re-verification.  We use the PC to keep track.\n+    int next;\n+\n+    // INVALID marks a state which is not on the linked list of states\n+    // requiring reverification.\n+    static const int INVALID = -1;\n+    // NO_NEXT marks the state at the end of the reverification list.\n+    static const int NO_NEXT = -2;\n+\n+    state ()\n+    {\n+      stack = NULL;\n+      locals = NULL;\n+      local_changed = NULL;\n+    }\n+\n+    state (int max_stack, int max_locals)\n+    {\n+      stacktop = 0;\n+      stackdepth = 0;\n+      stack = new type[max_stack];\n+      for (int i = 0; i < max_stack; ++i)\n+\tstack[i] = unsuitable_type;\n+      locals = new type[max_locals];\n+      local_changed = (bool *) _Jv_Malloc (sizeof (bool) * max_locals);\n+      for (int i = 0; i < max_locals; ++i)\n+\t{\n+\t  locals[i] = unsuitable_type;\n+\t  local_changed[i] = false;\n+\t}\n+      next = INVALID;\n+      subroutine = 0;\n+    }\n+\n+    state (const state *copy, int max_stack, int max_locals)\n+    {\n+      stack = new type[max_stack];\n+      locals = new type[max_locals];\n+      local_changed = (bool *) _Jv_Malloc (sizeof (bool) * max_locals);\n+      *this = *copy;\n+      next = INVALID;\n+    }\n+\n+    ~state ()\n+    {\n+      if (stack)\n+\tdelete[] stack;\n+      if (locals)\n+\tdelete[] locals;\n+      if (local_changed)\n+\t_Jv_Free (local_changed);\n+    }\n+\n+    void *operator new[] (size_t bytes)\n+    {\n+      return _Jv_Malloc (bytes);\n+    }\n+\n+    void operator delete[] (void *mem)\n+    {\n+      _Jv_Free (mem);\n+    }\n+\n+    void *operator new (size_t bytes)\n+    {\n+      return _Jv_Malloc (bytes);\n+    }\n+\n+    void operator delete (void *mem)\n+    {\n+      _Jv_Free (mem);\n+    }\n+\n+    void copy (const state *copy, int max_stack, int max_locals)\n+    {\n+      stacktop = copy->stacktop;\n+      stackdepth = copy->stackdepth;\n+      subroutine = copy->subroutine;\n+      for (int i = 0; i < max_stack; ++i)\n+\tstack[i] = copy->stack[i];\n+      for (int i = 0; i < max_locals; ++i)\n+\t{\n+\t  locals[i] = copy->locals[i];\n+\t  local_changed[i] = copy->local_changed[i];\n+\t}\n+      // Don't modify `next'.\n+    }\n+\n+    // Modify this state to reflect entry to an exception handler.\n+    void set_exception (type t, int max_stack)\n+    {\n+      stackdepth = 1;\n+      stacktop = 1;\n+      stack[0] = t;\n+      for (int i = stacktop; i < max_stack; ++i)\n+\tstack[i] = unsuitable_type;\n+\n+      // FIXME: subroutine handling?\n+    }\n+\n+    // Merge STATE into this state.  Destructively modifies this state.\n+    // Returns true if the new state was in fact changed.  Will throw an\n+    // exception if the states are not mergeable.\n+    bool merge (state *state_old, bool ret_semantics,\n+\t\tint max_locals)\n+    {\n+      bool changed = false;\n+\n+      // Merge subroutine states.  *THIS and *STATE_OLD must be in the\n+      // same subroutine.  Also, recursive subroutine calls must be\n+      // avoided.\n+      if (subroutine == state_old->subroutine)\n+\t{\n+\t  // Nothing.\n+\t}\n+      else if (subroutine == 0)\n+\t{\n+\t  subroutine = state_old->subroutine;\n+\t  changed = true;\n+\t}\n+      else\n+\tverify_fail (\"subroutines merged\");\n+\n+      // Merge stacks.\n+      if (state_old->stacktop != stacktop)\n+\tverify_fail (\"stack sizes differ\");\n+      for (int i = 0; i < state_old->stacktop; ++i)\n+\t{\n+\t  if (stack[i].merge (state_old->stack[i]))\n+\t    changed = true;\n+\t}\n+\n+      // Merge local variables.\n+      for (int i = 0; i < max_locals; ++i)\n+\t{\n+\t  if (! ret_semantics || local_changed[i])\n+\t    {\n+\t      if (locals[i].merge (state_old->locals[i], true))\n+\t\t{\n+\t\t  changed = true;\n+\t\t  note_variable (i);\n+\t\t}\n+\t    }\n+\n+\t  // If we're in a subroutine, we must compute the union of\n+\t  // all the changed local variables.\n+\t  if (state_old->local_changed[i])\n+\t    note_variable (i);\n+\t}\n+\n+      return changed;\n+    }\n+\n+    // Throw an exception if there is an uninitialized object on the\n+    // stack or in a local variable.  EXCEPTION_SEMANTICS controls\n+    // whether we're using backwards-branch or exception-handing\n+    // semantics.\n+    void check_no_uninitialized_objects (int max_locals,\n+\t\t\t\t\t bool exception_semantics = false)\n+    {\n+      if (! exception_semantics)\n+\t{\n+\t  for (int i = 0; i < stacktop; ++i)\n+\t    if (stack[i].isreference () && ! stack[i].isinitialized ())\n+\t      verify_fail (\"uninitialized object on stack\");\n+\t}\n+\n+      for (int i = 0; i < max_locals; ++i)\n+\tif (locals[i].isreference () && ! locals[i].isinitialized ())\n+\t  verify_fail (\"uninitialized object in local variable\");\n+    }\n+\n+    // Note that a local variable was accessed or modified.\n+    void note_variable (int index)\n+    {\n+      if (subroutine > 0)\n+\tlocal_changed[index] = true;\n+    }\n+\n+    // Mark each `new'd object we know of that was allocated at PC as\n+    // initialized.\n+    void set_initialized (int pc, int max_locals)\n+    {\n+      for (int i = 0; i < stacktop; ++i)\n+\tstack[i].set_initialized (pc);\n+      for (int i = 0; i < max_locals; ++i)\n+\tlocals[i].set_initialized (pc);\n+    }\n+  };\n+\n+  type pop_raw ()\n+  {\n+    if (current_state->stacktop <= 0)\n+      verify_fail (\"stack empty\");\n+    type r = current_state->stack[--current_state->stacktop];\n+    current_state->stackdepth -= r.depth ();\n+    if (current_state->stackdepth < 0)\n+      verify_fail (\"stack empty\");\n+    return r;\n+  }\n+\n+  type pop32 ()\n+  {\n+    type r = pop_raw ();\n+    if (r.iswide ())\n+      verify_fail (\"narrow pop of wide type\");\n+    return r;\n+  }\n+\n+  type pop64 ()\n+  {\n+    type r = pop_raw ();\n+    if (! r.iswide ())\n+      verify_fail (\"wide pop of narrow type\");\n+    return r;\n+  }\n+\n+  type pop_type (type match)\n+  {\n+    type t = pop_raw ();\n+    if (! match.compatible (t))\n+      verify_fail (\"incompatible type on stack\");\n+    return t;\n+  }\n+\n+  void push_type (type t)\n+  {\n+    // If T is a numeric type like short, promote it to int.\n+    t.promote ();\n+\n+    int depth = t.depth ();\n+    if (current_state->stackdepth + depth > current_method->max_stack)\n+      verify_fail (\"stack overflow\");\n+    current_state->stack[current_state->stacktop++] = t;\n+    current_state->stackdepth += depth;\n+  }\n+\n+  void set_variable (int index, type t)\n+  {\n+    // If T is a numeric type like short, promote it to int.\n+    t.promote ();\n+\n+    int depth = t.depth ();\n+    if (index > current_method->max_locals - depth)\n+      verify_fail (\"invalid local variable\");\n+    current_state->locals[index] = t;\n+    current_state->note_variable (index);\n+\n+    if (depth == 2)\n+      {\n+\tcurrent_state->locals[index + 1] = continuation_type;\n+\tcurrent_state->note_variable (index + 1);\n+      }\n+    if (index > 0 && current_state->locals[index - 1].iswide ())\n+      {\n+\tcurrent_state->locals[index - 1] = unsuitable_type;\n+\t// There's no need to call note_variable here.\n+      }\n+  }\n+\n+  type get_variable (int index, type t)\n+  {\n+    int depth = t.depth ();\n+    if (index > current_method->max_locals - depth)\n+      verify_fail (\"invalid local variable\");\n+    if (! t.compatible (current_state->locals[index]))\n+      verify_fail (\"incompatible type in local variable\");\n+    if (depth == 2)\n+      {\n+\ttype t (continuation_type);\n+\tif (! current_state->locals[index + 1].compatible (t))\n+\t  verify_fail (\"invalid local variable\");\n+      }\n+    current_state->note_variable (index);\n+    return current_state->locals[index];\n+  }\n+\n+  // Make sure ARRAY is an array type and that its elements are\n+  // compatible with type ELEMENT.  Returns the actual element type.\n+  type require_array_type (type array, type element)\n+  {\n+    if (! array.isarray ())\n+      verify_fail (\"array required\");\n+\n+    type t = array.element_type ();\n+    if (! element.compatible (t))\n+      verify_fail (\"incompatible array element type\");\n+\n+    // Return T and not ELEMENT, because T might be specialized.\n+    return t;\n+  }\n+\n+  jint get_byte ()\n+  {\n+    if (PC >= current_method->code_length)\n+      verify_fail (\"premature end of bytecode\");\n+    return (jint) bytecode[PC++] & 0xff;\n+  }\n+\n+  jint get_ushort ()\n+  {\n+    jbyte b1 = get_byte ();\n+    jbyte b2 = get_byte ();\n+    return (jint) ((b1 << 8) | b2) & 0xffff;\n+  }\n+\n+  jint get_short ()\n+  {\n+    jbyte b1 = get_byte ();\n+    jbyte b2 = get_byte ();\n+    jshort s = (b1 << 8) | b2;\n+    return (jint) s;\n+  }\n+\n+  jint get_int ()\n+  {\n+    jbyte b1 = get_byte ();\n+    jbyte b2 = get_byte ();\n+    jbyte b3 = get_byte ();\n+    jbyte b4 = get_byte ();\n+    return (b1 << 24) | (b2 << 16) | (b3 << 8) | b4;\n+  }\n+\n+  int compute_jump (int offset)\n+  {\n+    int npc = start_PC + offset;\n+    if (npc < 0 || npc >= current_method->code_length)\n+      verify_fail (\"branch out of range\");\n+    return npc;\n+  }\n+\n+  // Merge the indicated state into a new state and schedule a new PC if\n+  // there is a change.  If RET_SEMANTICS is true, then we are merging\n+  // from a `ret' instruction into the instruction after a `jsr'.  This\n+  // is a special case with its own modified semantics.\n+  void push_jump_merge (int npc, state *nstate, bool ret_semantics = false)\n+  {\n+    bool changed = true;\n+    if (states[npc] == NULL)\n+      {\n+\t// FIXME: what if we reach this code from a `ret'?\n+\t\n+\tstates[npc] = new state (nstate, current_method->max_stack,\n+\t\t\t\t current_method->max_locals);\n+      }\n+    else\n+      changed = nstate->merge (states[npc], ret_semantics,\n+\t\t\t       current_method->max_stack);\n+\n+    if (changed && states[npc]->next == state::INVALID)\n+      {\n+\t// The merge changed the state, and the new PC isn't yet on our\n+\t// list of PCs to re-verify.\n+\tstates[npc]->next = next_verify_pc;\n+\tnext_verify_pc = npc;\n+      }\n+  }\n+\n+  void push_jump (int offset)\n+  {\n+    int npc = compute_jump (offset);\n+    if (npc < PC)\n+      current_state->check_no_uninitialized_objects (current_method->max_stack);\n+    push_jump_merge (npc, current_state);\n+  }\n+\n+  void push_exception_jump (type t, int pc)\n+  {\n+    current_state->check_no_uninitialized_objects (current_method->max_stack,\n+\t\t\t\t\t\t  true);\n+    state s (current_state, current_method->max_stack,\n+\t     current_method->max_locals);\n+    s.set_exception (t, current_method->max_stack);\n+    push_jump_merge (pc, &s);\n+  }\n+\n+  int pop_jump ()\n+  {\n+    int npc = next_verify_pc;\n+    if (npc != state::NO_NEXT)\n+      {\n+\tnext_verify_pc = states[npc]->next;\n+\tstates[npc]->next = state::INVALID;\n+      }\n+    return npc;\n+  }\n+\n+  void invalidate_pc ()\n+  {\n+    PC = state::NO_NEXT;\n+  }\n+\n+  void note_branch_target (int pc, bool is_jsr_target = false)\n+  {\n+    if (pc <= PC && ! (flags[pc] & FLAG_INSN_START))\n+      verify_fail (\"branch not to instruction start\");\n+    flags[pc] |= FLAG_BRANCH_TARGET;\n+    if (is_jsr_target)\n+      {\n+\t// Record the jsr which called this instruction.\n+\tsubr_info *info = (subr_info *) _Jv_Malloc (sizeof (subr_info));\n+\tinfo->pc = PC;\n+\tinfo->next = jsr_ptrs[pc];\n+\tjsr_ptrs[pc] = info;\n+\tflags[pc] |= FLAG_JSR_TARGET;\n+      }\n+  }\n+\n+  void skip_padding ()\n+  {\n+    while ((PC % 4) > 0)\n+      get_byte ();\n+  }\n+\n+  // Return the subroutine to which the instruction at PC belongs.\n+  int get_subroutine (int pc)\n+  {\n+    if (states[pc] == NULL)\n+      return 0;\n+    return states[pc]->subroutine;\n+  }\n+\n+  // Do the work for a `ret' instruction.  INDEX is the index into the\n+  // local variables.\n+  void handle_ret_insn (int index)\n+  {\n+    get_variable (index, return_address_type);\n+\n+    int csub = current_state->subroutine;\n+    if (csub == 0)\n+      verify_fail (\"no subroutine\");\n+\n+    for (subr_info *subr = jsr_ptrs[csub]; subr != NULL; subr = subr->next)\n+      {\n+\t// Temporarily modify the current state so it looks like we're\n+\t// in the enclosing context.\n+\tcurrent_state->subroutine = get_subroutine (subr->pc);\n+\tif (subr->pc < PC)\n+\t  current_state->check_no_uninitialized_objects (current_method->max_stack);\n+\tpush_jump_merge (subr->pc, current_state, true);\n+      }\n+\n+    current_state->subroutine = csub;\n+    invalidate_pc ();\n+  }\n+\n+  // We're in the subroutine SUB, calling a subroutine at DEST.  Make\n+  // sure this subroutine isn't already on the stack.\n+  void check_nonrecursive_call (int sub, int dest)\n+  {\n+    if (sub == 0)\n+      return;\n+    if (sub == dest)\n+      verify_fail (\"recursive subroutine call\");\n+    for (subr_info *info = jsr_ptrs[sub]; info != NULL; info = info->next)\n+      check_nonrecursive_call (get_subroutine (info->pc), dest);\n+  }\n+\n+  void handle_jsr_insn (int offset)\n+  {\n+    int npc = compute_jump (offset);\n+\n+    if (npc < PC)\n+      current_state->check_no_uninitialized_objects (current_method->max_stack);\n+    check_nonrecursive_call (current_state->subroutine, npc);\n+\n+    // Temporarily modify the current state so that it looks like we are\n+    // in the subroutine.\n+    push_type (return_address_type);\n+    int save = current_state->subroutine;\n+    current_state->subroutine = npc;\n+\n+    // Merge into the subroutine.\n+    push_jump_merge (npc, current_state);\n+\n+    // Undo our modifications.\n+    current_state->subroutine = save;\n+    pop_type (return_address_type);\n+  }\n+\n+  jclass construct_primitive_array_type (type_val prim)\n+  {\n+    jclass k = NULL;\n+    switch (prim)\n+      {\n+      case boolean_type:\n+\tk = JvPrimClass (boolean);\n+\tbreak;\n+      case char_type:\n+\tk = JvPrimClass (char);\n+\tbreak;\n+      case float_type:\n+\tk = JvPrimClass (float);\n+\tbreak;\n+      case double_type:\n+\tk = JvPrimClass (double);\n+\tbreak;\n+      case byte_type:\n+\tk = JvPrimClass (byte);\n+\tbreak;\n+      case short_type:\n+\tk = JvPrimClass (short);\n+\tbreak;\n+      case int_type:\n+\tk = JvPrimClass (int);\n+\tbreak;\n+      case long_type:\n+\tk = JvPrimClass (long);\n+\tbreak;\n+      default:\n+\tverify_fail (\"unknown type in construct_primitive_array_type\");\n+      }\n+    k = _Jv_GetArrayClass (k, NULL);\n+    return k;\n+  }\n+\n+  // This pass computes the location of branch targets and also\n+  // instruction starts.\n+  void branch_prepass ()\n+  {\n+    flags = (char *) _Jv_Malloc (current_method->code_length);\n+    jsr_ptrs = (subr_info **) _Jv_Malloc (sizeof (subr_info *)\n+\t\t\t\t\t  * current_method->code_length);\n+\n+    for (int i = 0; i < current_method->code_length; ++i)\n+      {\n+\tflags[i] = 0;\n+\tjsr_ptrs[i] = NULL;\n+      }\n+\n+    bool last_was_jsr = false;\n+\n+    PC = 0;\n+    while (PC < current_method->code_length)\n+      {\n+\tflags[PC] |= FLAG_INSN_START;\n+\n+\t// If the previous instruction was a jsr, then the next\n+\t// instruction is a branch target -- the branch being the\n+\t// corresponding `ret'.\n+\tif (last_was_jsr)\n+\t  note_branch_target (PC);\n+\tlast_was_jsr = false;\n+\n+\tstart_PC = PC;\n+\tunsigned char opcode = bytecode[PC++];\n+\tswitch (opcode)\n+\t  {\n+\t  case op_nop:\n+\t  case op_aconst_null:\n+\t  case op_iconst_m1:\n+\t  case op_iconst_0:\n+\t  case op_iconst_1:\n+\t  case op_iconst_2:\n+\t  case op_iconst_3:\n+\t  case op_iconst_4:\n+\t  case op_iconst_5:\n+\t  case op_lconst_0:\n+\t  case op_lconst_1:\n+\t  case op_fconst_0:\n+\t  case op_fconst_1:\n+\t  case op_fconst_2:\n+\t  case op_dconst_0:\n+\t  case op_dconst_1:\n+\t  case op_iload_0:\n+\t  case op_iload_1:\n+\t  case op_iload_2:\n+\t  case op_iload_3:\n+\t  case op_lload_0:\n+\t  case op_lload_1:\n+\t  case op_lload_2:\n+\t  case op_lload_3:\n+\t  case op_fload_0:\n+\t  case op_fload_1:\n+\t  case op_fload_2:\n+\t  case op_fload_3:\n+\t  case op_dload_0:\n+\t  case op_dload_1:\n+\t  case op_dload_2:\n+\t  case op_dload_3:\n+\t  case op_aload_0:\n+\t  case op_aload_1:\n+\t  case op_aload_2:\n+\t  case op_aload_3:\n+\t  case op_iaload:\n+\t  case op_laload:\n+\t  case op_faload:\n+\t  case op_daload:\n+\t  case op_aaload:\n+\t  case op_baload:\n+\t  case op_caload:\n+\t  case op_saload:\n+\t  case op_istore_0:\n+\t  case op_istore_1:\n+\t  case op_istore_2:\n+\t  case op_istore_3:\n+\t  case op_lstore_0:\n+\t  case op_lstore_1:\n+\t  case op_lstore_2:\n+\t  case op_lstore_3:\n+\t  case op_fstore_0:\n+\t  case op_fstore_1:\n+\t  case op_fstore_2:\n+\t  case op_fstore_3:\n+\t  case op_dstore_0:\n+\t  case op_dstore_1:\n+\t  case op_dstore_2:\n+\t  case op_dstore_3:\n+\t  case op_astore_0:\n+\t  case op_astore_1:\n+\t  case op_astore_2:\n+\t  case op_astore_3:\n+\t  case op_iastore:\n+\t  case op_lastore:\n+\t  case op_fastore:\n+\t  case op_dastore:\n+\t  case op_aastore:\n+\t  case op_bastore:\n+\t  case op_castore:\n+\t  case op_sastore:\n+\t  case op_pop:\n+\t  case op_pop2:\n+\t  case op_dup:\n+\t  case op_dup_x1:\n+\t  case op_dup_x2:\n+\t  case op_dup2:\n+\t  case op_dup2_x1:\n+\t  case op_dup2_x2:\n+\t  case op_swap:\n+\t  case op_iadd:\n+\t  case op_isub:\n+\t  case op_imul:\n+\t  case op_idiv:\n+\t  case op_irem:\n+\t  case op_ishl:\n+\t  case op_ishr:\n+\t  case op_iushr:\n+\t  case op_iand:\n+\t  case op_ior:\n+\t  case op_ixor:\n+\t  case op_ladd:\n+\t  case op_lsub:\n+\t  case op_lmul:\n+\t  case op_ldiv:\n+\t  case op_lrem:\n+\t  case op_lshl:\n+\t  case op_lshr:\n+\t  case op_lushr:\n+\t  case op_land:\n+\t  case op_lor:\n+\t  case op_lxor:\n+\t  case op_fadd:\n+\t  case op_fsub:\n+\t  case op_fmul:\n+\t  case op_fdiv:\n+\t  case op_frem:\n+\t  case op_dadd:\n+\t  case op_dsub:\n+\t  case op_dmul:\n+\t  case op_ddiv:\n+\t  case op_drem:\n+\t  case op_ineg:\n+\t  case op_i2b:\n+\t  case op_i2c:\n+\t  case op_i2s:\n+\t  case op_lneg:\n+\t  case op_fneg:\n+\t  case op_dneg:\n+\t  case op_iinc:\n+\t  case op_i2l:\n+\t  case op_i2f:\n+\t  case op_i2d:\n+\t  case op_l2i:\n+\t  case op_l2f:\n+\t  case op_l2d:\n+\t  case op_f2i:\n+\t  case op_f2l:\n+\t  case op_f2d:\n+\t  case op_d2i:\n+\t  case op_d2l:\n+\t  case op_d2f:\n+\t  case op_lcmp:\n+\t  case op_fcmpl:\n+\t  case op_fcmpg:\n+\t  case op_dcmpl:\n+\t  case op_dcmpg:\n+\t  case op_monitorenter:\n+\t  case op_monitorexit:\n+\t  case op_ireturn:\n+\t  case op_lreturn:\n+\t  case op_freturn:\n+\t  case op_dreturn:\n+\t  case op_areturn:\n+\t  case op_return:\n+\t  case op_athrow:\n+\t    break;\n+\n+\t  case op_bipush:\n+\t  case op_sipush:\n+\t  case op_ldc:\n+\t  case op_iload:\n+\t  case op_lload:\n+\t  case op_fload:\n+\t  case op_dload:\n+\t  case op_aload:\n+\t  case op_istore:\n+\t  case op_lstore:\n+\t  case op_fstore:\n+\t  case op_dstore:\n+\t  case op_astore:\n+\t  case op_arraylength:\n+\t  case op_ret:\n+\t    get_byte ();\n+\t    break;\n+\n+\t  case op_ldc_w:\n+\t  case op_ldc2_w:\n+\t  case op_getstatic:\n+\t  case op_getfield:\n+\t  case op_putfield:\n+\t  case op_putstatic:\n+\t  case op_new:\n+\t  case op_anewarray:\n+\t  case op_instanceof:\n+\t  case op_checkcast:\n+\t  case op_invokespecial:\n+\t  case op_invokestatic:\n+\t  case op_invokevirtual:\n+\t    get_short ();\n+\t    break;\n+\n+\t  case op_multianewarray:\n+\t    get_short ();\n+\t    get_byte ();\n+\t    break;\n+\n+\t  case op_jsr:\n+\t    last_was_jsr = true;\n+\t    // Fall through.\n+\t  case op_ifeq:\n+\t  case op_ifne:\n+\t  case op_iflt:\n+\t  case op_ifge:\n+\t  case op_ifgt:\n+\t  case op_ifle:\n+\t  case op_if_icmpeq:\n+\t  case op_if_icmpne:\n+\t  case op_if_icmplt:\n+\t  case op_if_icmpge:\n+\t  case op_if_icmpgt:\n+\t  case op_if_icmple:\n+\t  case op_if_acmpeq:\n+\t  case op_if_acmpne:\n+\t  case op_ifnull:\n+\t  case op_ifnonnull:\n+\t  case op_goto:\n+\t    note_branch_target (compute_jump (get_short ()), last_was_jsr);\n+\t    break;\n+\n+\t  case op_tableswitch:\n+\t    {\n+\t      skip_padding ();\n+\t      note_branch_target (compute_jump (get_int ()));\n+\t      jint low = get_int ();\n+\t      jint hi = get_int ();\n+\t      if (low > hi)\n+\t\tverify_fail (\"invalid tableswitch\");\n+\t      for (int i = low; i <= hi; ++i)\n+\t\tnote_branch_target (compute_jump (get_int ()));\n+\t    }\n+\t    break;\n+\n+\t  case op_lookupswitch:\n+\t    {\n+\t      skip_padding ();\n+\t      note_branch_target (compute_jump (get_int ()));\n+\t      int npairs = get_int ();\n+\t      if (npairs < 0)\n+\t\tverify_fail (\"too few pairs in lookupswitch\");\n+\t      while (npairs-- > 0)\n+\t\t{\n+\t\t  get_int ();\n+\t\t  note_branch_target (compute_jump (get_int ()));\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case op_invokeinterface:\n+\t    get_short ();\n+\t    get_byte ();\n+\t    get_byte ();\n+\t    break;\n+\n+\t  case op_wide:\n+\t    {\n+\t      opcode = get_byte ();\n+\t      get_short ();\n+\t      if (opcode == (unsigned char) op_iinc)\n+\t\tget_short ();\n+\t    }\n+\t    break;\n+\n+\t  case op_jsr_w:\n+\t    last_was_jsr = true;\n+\t    // Fall through.\n+\t  case op_goto_w:\n+\t    note_branch_target (compute_jump (get_int ()), last_was_jsr);\n+\t    break;\n+\n+\t  default:\n+\t    verify_fail (\"unrecognized instruction\");\n+\t  }\n+\n+\t// See if any previous branch tried to branch to the middle of\n+\t// this instruction.\n+\tfor (int pc = start_PC + 1; pc < PC; ++pc)\n+\t  {\n+\t    if ((flags[pc] & FLAG_BRANCH_TARGET))\n+\t      verify_fail (\"branch not to instruction start\");\n+\t  }\n+      }\n+\n+    // Verify exception handlers.\n+    for (int i = 0; i < current_method->exc_count; ++i)\n+      {\n+\tif (! (flags[exception[i].handler_pc] & FLAG_INSN_START))\n+\t  verify_fail (\"exception handler not at instruction start\");\n+\tif (exception[i].start_pc > exception[i].end_pc)\n+\t  verify_fail (\"exception range inverted\");\n+\tif (! (flags[exception[i].start_pc] & FLAG_INSN_START)\n+\t    || ! (flags[exception[i].start_pc] & FLAG_INSN_START))\n+\t  verify_fail (\"exception endpoint not at instruction start\");\n+\n+\tflags[exception[i].handler_pc] |= FLAG_BRANCH_TARGET;\n+      }\n+  }\n+\n+  void check_pool_index (int index)\n+  {\n+    if (index < 0 || index >= current_class->constants.size)\n+      verify_fail (\"constant pool index out of range\");\n+  }\n+\n+  type check_class_constant (int index)\n+  {\n+    check_pool_index (index);\n+    _Jv_Constants *pool = &current_class->constants;\n+    if (pool->tags[index] == JV_CONSTANT_ResolvedClass)\n+      return type (pool->data[index].clazz);\n+    else if (pool->tags[index] == JV_CONSTANT_Class)\n+      return type (pool->data[index].utf8);\n+    verify_fail (\"expected class constant\");\n+  }\n+\n+  type check_constant (int index)\n+  {\n+    check_pool_index (index);\n+    _Jv_Constants *pool = &current_class->constants;\n+    if (pool->tags[index] == JV_CONSTANT_ResolvedString\n+\t|| pool->tags[index] == JV_CONSTANT_String)\n+      return type (&java::lang::String::class$);\n+    else if (pool->tags[index] == JV_CONSTANT_Integer)\n+      return type (int_type);\n+    else if (pool->tags[index] == JV_CONSTANT_Float)\n+      return type (float_type);\n+    verify_fail (\"String, int, or float constant expected\");\n+  }\n+\n+  // Helper for both field and method.  These are laid out the same in\n+  // the constant pool.\n+  type handle_field_or_method (int index, int expected,\n+\t\t\t       _Jv_Utf8Const **name,\n+\t\t\t       _Jv_Utf8Const **fmtype)\n+  {\n+    check_pool_index (index);\n+    _Jv_Constants *pool = &current_class->constants;\n+    if (pool->tags[index] != expected)\n+      verify_fail (\"didn't see expected constant\");\n+    // Once we know we have a Fieldref or Methodref we assume that it\n+    // is correctly laid out in the constant pool.  I think the code\n+    // in defineclass.cc guarantees this.\n+    _Jv_ushort class_index, name_and_type_index;\n+    _Jv_loadIndexes (&pool->data[index],\n+\t\t     class_index,\n+\t\t     name_and_type_index);\n+    _Jv_ushort name_index, desc_index;\n+    _Jv_loadIndexes (&pool->data[name_and_type_index],\n+\t\t     name_index, desc_index);\n+\n+    *name = pool->data[name_index].utf8;\n+    *fmtype = pool->data[desc_index].utf8;\n+\n+    return check_class_constant (class_index);\n+  }\n+\n+  // Return field's type, compute class' type if requested.\n+  type check_field_constant (int index, type *class_type = NULL)\n+  {\n+    _Jv_Utf8Const *name, *field_type;\n+    type ct = handle_field_or_method (index,\n+\t\t\t\t      JV_CONSTANT_Fieldref,\n+\t\t\t\t      &name, &field_type);\n+    if (class_type)\n+      *class_type = ct;\n+    return type (field_type);\n+  }\n+\n+  type check_method_constant (int index, bool is_interface,\n+\t\t\t      _Jv_Utf8Const **method_name,\n+\t\t\t      _Jv_Utf8Const **method_signature)\n+  {\n+    return handle_field_or_method (index,\n+\t\t\t\t   (is_interface\n+\t\t\t\t    ? JV_CONSTANT_InterfaceMethodref\n+\t\t\t\t    : JV_CONSTANT_Methodref),\n+\t\t\t\t   method_name, method_signature);\n+  }\n+\n+  type get_one_type (char *&p)\n+  {\n+    char *start = p;\n+\n+    int arraycount = 0;\n+    while (*p == '[')\n+      {\n+\t++arraycount;\n+\t++p;\n+      }\n+\n+    char v = *p++;\n+\n+    if (v == 'L')\n+      {\n+\twhile (*p != ';')\n+\t  ++p;\n+\t++p;\n+\t// FIXME!  This will get collected!\n+\t_Jv_Utf8Const *name = _Jv_makeUtf8Const (start, p - start);\n+\treturn type (name);\n+      }\n+\n+    // Casting to jchar here is ok since we are looking at an ASCII\n+    // character.\n+    type_val rt = get_type_val_for_signature (jchar (v));\n+\n+    if (arraycount == 0)\n+      return type (rt);\n+\n+    jclass k = construct_primitive_array_type (rt);\n+    while (--arraycount > 0)\n+      k = _Jv_GetArrayClass (k, NULL);\n+    return type (k);\n+  }\n+\n+  void compute_argument_types (_Jv_Utf8Const *signature,\n+\t\t\t       type *types)\n+  {\n+    char *p = signature->data;\n+    // Skip `('.\n+    ++p;\n+\n+    int i = 0;\n+    while (*p != ')')\n+      types[i++] = get_one_type (p);\n+  }\n+\n+  type compute_return_type (_Jv_Utf8Const *signature)\n+  {\n+    char *p = signature->data;\n+    while (*p != ')')\n+      ++p;\n+    ++p;\n+    return get_one_type (p);\n+  }\n+\n+  void check_return_type (type expected)\n+  {\n+    type rt = compute_return_type (current_method->self->signature);\n+    if (! expected.compatible (rt))\n+      verify_fail (\"incompatible return type\");\n+  }\n+\n+  void verify_instructions_0 ()\n+  {\n+    current_state = new state (current_method->max_stack,\n+\t\t\t       current_method->max_locals);\n+\n+    PC = 0;\n+\n+    {\n+      int var = 0;\n+\n+      using namespace java::lang::reflect;\n+      if (! Modifier::isStatic (current_method->self->accflags))\n+\t{\n+\t  type kurr (current_class);\n+\t  if (_Jv_equalUtf8Consts (current_method->self->name, gcj::init_name))\n+\t    kurr.set_uninitialized (type::SELF);\n+\t  set_variable (0, kurr);\n+\t  ++var;\n+\t}\n+\n+      if (var + _Jv_count_arguments (current_method->self->signature)\n+\t  > current_method->max_locals)\n+\tverify_fail (\"too many arguments\");\n+      compute_argument_types (current_method->self->signature,\n+\t\t\t      &current_state->locals[var]);\n+    }\n+\n+    states = (state **) _Jv_Malloc (sizeof (state *)\n+\t\t\t\t    * current_method->code_length);\n+    for (int i = 0; i < current_method->code_length; ++i)\n+      states[i] = NULL;\n+\n+    next_verify_pc = state::NO_NEXT;\n+\n+    while (true)\n+      {\n+\t// If the PC was invalidated, get a new one from the work list.\n+\tif (PC == state::NO_NEXT)\n+\t  {\n+\t    PC = pop_jump ();\n+\t    if (PC == state::INVALID)\n+\t      verify_fail (\"saw state::INVALID\");\n+\t    if (PC == state::NO_NEXT)\n+\t      break;\n+\t    // Set up the current state.\n+\t    *current_state = *states[PC];\n+\t  }\n+\n+\t// Control can't fall off the end of the bytecode.\n+\tif (PC >= current_method->code_length)\n+\t  verify_fail (\"fell off end\");\n+\n+\tif (states[PC] != NULL)\n+\t  {\n+\t    // We've already visited this instruction.  So merge the\n+\t    // states together.  If this yields no change then we don't\n+\t    // have to re-verify.\n+\t    if (! current_state->merge (states[PC], false,\n+\t\t\t\t\tcurrent_method->max_stack))\n+\t      {\n+\t\tinvalidate_pc ();\n+\t\tcontinue;\n+\t      }\n+\t    // Save a copy of it for later.\n+\t    states[PC]->copy (current_state, current_method->max_stack,\n+\t\t\t      current_method->max_locals);\n+\t  }\n+\telse if ((flags[PC] & FLAG_BRANCH_TARGET))\n+\t  {\n+\t    // We only have to keep saved state at branch targets.\n+\t    states[PC] = new state (current_state, current_method->max_stack,\n+\t\t\t\t    current_method->max_locals);\n+\t  }\n+\n+\t// Update states for all active exception handlers.  Ordinarily\n+\t// there are not many exception handlers.  So we simply run\n+\t// through them all.\n+\tfor (int i = 0; i < current_method->exc_count; ++i)\n+\t  {\n+\t    if (PC >= exception[i].start_pc && PC < exception[i].end_pc)\n+\t      {\n+\t\ttype handler = reference_type;\n+\t\tif (exception[i].handler_type != 0)\n+\t\t  handler = check_class_constant (exception[i].handler_type);\n+\t\tpush_exception_jump (handler, exception[i].handler_pc);\n+\t      }\n+\t  }\n+\n+\tstart_PC = PC;\n+\tunsigned char opcode = bytecode[PC++];\n+\tswitch (opcode)\n+\t  {\n+\t  case op_nop:\n+\t    break;\n+\n+\t  case op_aconst_null:\n+\t    push_type (null_type);\n+\t    break;\n+\n+\t  case op_iconst_m1:\n+\t  case op_iconst_0:\n+\t  case op_iconst_1:\n+\t  case op_iconst_2:\n+\t  case op_iconst_3:\n+\t  case op_iconst_4:\n+\t  case op_iconst_5:\n+\t    push_type (int_type);\n+\t    break;\n+\n+\t  case op_lconst_0:\n+\t  case op_lconst_1:\n+\t    push_type (long_type);\n+\t    break;\n+\n+\t  case op_fconst_0:\n+\t  case op_fconst_1:\n+\t  case op_fconst_2:\n+\t    push_type (float_type);\n+\t    break;\n+\n+\t  case op_dconst_0:\n+\t  case op_dconst_1:\n+\t    push_type (double_type);\n+\t    break;\n+\n+\t  case op_bipush:\n+\t    get_byte ();\n+\t    push_type (int_type);\n+\t    break;\n+\n+\t  case op_sipush:\n+\t    get_short ();\n+\t    push_type (int_type);\n+\t    break;\n+\n+\t  case op_ldc:\n+\t    push_type (check_constant (get_byte ()));\n+\t    break;\n+\t  case op_ldc_w:\n+\t    push_type (check_constant (get_ushort ()));\n+\t    break;\n+\t  case op_ldc2_w:\n+\t    push_type (check_constant (get_ushort ()));\n+\t    break;\n+\n+\t  case op_iload:\n+\t    push_type (get_variable (get_byte (), int_type));\n+\t    break;\n+\t  case op_lload:\n+\t    push_type (get_variable (get_byte (), long_type));\n+\t    break;\n+\t  case op_fload:\n+\t    push_type (get_variable (get_byte (), float_type));\n+\t    break;\n+\t  case op_dload:\n+\t    push_type (get_variable (get_byte (), double_type));\n+\t    break;\n+\t  case op_aload:\n+\t    push_type (get_variable (get_byte (), reference_type));\n+\t    break;\n+\n+\t  case op_iload_0:\n+\t  case op_iload_1:\n+\t  case op_iload_2:\n+\t  case op_iload_3:\n+\t    push_type (get_variable (opcode - op_iload_0, int_type));\n+\t    break;\n+\t  case op_lload_0:\n+\t  case op_lload_1:\n+\t  case op_lload_2:\n+\t  case op_lload_3:\n+\t    push_type (get_variable (opcode - op_lload_0, long_type));\n+\t    break;\n+\t  case op_fload_0:\n+\t  case op_fload_1:\n+\t  case op_fload_2:\n+\t  case op_fload_3:\n+\t    push_type (get_variable (opcode - op_fload_0, float_type));\n+\t    break;\n+\t  case op_dload_0:\n+\t  case op_dload_1:\n+\t  case op_dload_2:\n+\t  case op_dload_3:\n+\t    push_type (get_variable (opcode - op_dload_0, double_type));\n+\t    break;\n+\t  case op_aload_0:\n+\t  case op_aload_1:\n+\t  case op_aload_2:\n+\t  case op_aload_3:\n+\t    push_type (get_variable (opcode - op_aload_0, reference_type));\n+\t    break;\n+\t  case op_iaload:\n+\t    pop_type (int_type);\n+\t    push_type (require_array_type (pop_type (reference_type),\n+\t\t\t\t\t   int_type));\n+\t    break;\n+\t  case op_laload:\n+\t    pop_type (int_type);\n+\t    push_type (require_array_type (pop_type (reference_type),\n+\t\t\t\t\t   long_type));\n+\t    break;\n+\t  case op_faload:\n+\t    pop_type (int_type);\n+\t    push_type (require_array_type (pop_type (reference_type),\n+\t\t\t\t\t   float_type));\n+\t    break;\n+\t  case op_daload:\n+\t    pop_type (int_type);\n+\t    push_type (require_array_type (pop_type (reference_type),\n+\t\t\t\t\t   double_type));\n+\t    break;\n+\t  case op_aaload:\n+\t    pop_type (int_type);\n+\t    push_type (require_array_type (pop_type (reference_type),\n+\t\t\t\t\t   reference_type));\n+\t    break;\n+\t  case op_baload:\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), byte_type);\n+\t    push_type (int_type);\n+\t    break;\n+\t  case op_caload:\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), char_type);\n+\t    push_type (int_type);\n+\t    break;\n+\t  case op_saload:\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), short_type);\n+\t    push_type (int_type);\n+\t    break;\n+\t  case op_istore:\n+\t    set_variable (get_byte (), pop_type (int_type));\n+\t    break;\n+\t  case op_lstore:\n+\t    set_variable (get_byte (), pop_type (long_type));\n+\t    break;\n+\t  case op_fstore:\n+\t    set_variable (get_byte (), pop_type (float_type));\n+\t    break;\n+\t  case op_dstore:\n+\t    set_variable (get_byte (), pop_type (double_type));\n+\t    break;\n+\t  case op_astore:\n+\t    set_variable (get_byte (), pop_type (reference_type));\n+\t    break;\n+\t  case op_istore_0:\n+\t  case op_istore_1:\n+\t  case op_istore_2:\n+\t  case op_istore_3:\n+\t    set_variable (opcode - op_istore_0, pop_type (int_type));\n+\t    break;\n+\t  case op_lstore_0:\n+\t  case op_lstore_1:\n+\t  case op_lstore_2:\n+\t  case op_lstore_3:\n+\t    set_variable (opcode - op_lstore_0, pop_type (long_type));\n+\t    break;\n+\t  case op_fstore_0:\n+\t  case op_fstore_1:\n+\t  case op_fstore_2:\n+\t  case op_fstore_3:\n+\t    set_variable (opcode - op_fstore_0, pop_type (float_type));\n+\t    break;\n+\t  case op_dstore_0:\n+\t  case op_dstore_1:\n+\t  case op_dstore_2:\n+\t  case op_dstore_3:\n+\t    set_variable (opcode - op_dstore_0, pop_type (double_type));\n+\t    break;\n+\t  case op_astore_0:\n+\t  case op_astore_1:\n+\t  case op_astore_2:\n+\t  case op_astore_3:\n+\t    set_variable (opcode - op_astore_0, pop_type (reference_type));\n+\t    break;\n+\t  case op_iastore:\n+\t    pop_type (int_type);\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), int_type);\n+\t    break;\n+\t  case op_lastore:\n+\t    pop_type (long_type);\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), long_type);\n+\t    break;\n+\t  case op_fastore:\n+\t    pop_type (float_type);\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), float_type);\n+\t    break;\n+\t  case op_dastore:\n+\t    pop_type (double_type);\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), double_type);\n+\t    break;\n+\t  case op_aastore:\n+\t    pop_type (reference_type);\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), reference_type);\n+\t    break;\n+\t  case op_bastore:\n+\t    pop_type (int_type);\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), byte_type);\n+\t    break;\n+\t  case op_castore:\n+\t    pop_type (int_type);\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), char_type);\n+\t    break;\n+\t  case op_sastore:\n+\t    pop_type (int_type);\n+\t    pop_type (int_type);\n+\t    require_array_type (pop_type (reference_type), short_type);\n+\t    break;\n+\t  case op_pop:\n+\t    pop32 ();\n+\t    break;\n+\t  case op_pop2:\n+\t    pop64 ();\n+\t    break;\n+\t  case op_dup:\n+\t    {\n+\t      type t = pop32 ();\n+\t      push_type (t);\n+\t      push_type (t);\n+\t    }\n+\t    break;\n+\t  case op_dup_x1:\n+\t    {\n+\t      type t1 = pop32 ();\n+\t      type t2 = pop32 ();\n+\t      push_type (t1);\n+\t      push_type (t2);\n+\t      push_type (t1);\n+\t    }\n+\t    break;\n+\t  case op_dup_x2:\n+\t    {\n+\t      type t1 = pop32 ();\n+\t      type t2 = pop32 ();\n+\t      type t3 = pop32 ();\n+\t      push_type (t1);\n+\t      push_type (t3);\n+\t      push_type (t2);\n+\t      push_type (t1);\n+\t    }\n+\t    break;\n+\t  case op_dup2:\n+\t    {\n+\t      type t = pop64 ();\n+\t      push_type (t);\n+\t      push_type (t);\n+\t    }\n+\t    break;\n+\t  case op_dup2_x1:\n+\t    {\n+\t      type t1 = pop64 ();\n+\t      type t2 = pop64 ();\n+\t      push_type (t1);\n+\t      push_type (t2);\n+\t      push_type (t1);\n+\t    }\n+\t    break;\n+\t  case op_dup2_x2:\n+\t    {\n+\t      type t1 = pop64 ();\n+\t      type t2 = pop64 ();\n+\t      type t3 = pop64 ();\n+\t      push_type (t1);\n+\t      push_type (t3);\n+\t      push_type (t2);\n+\t      push_type (t1);\n+\t    }\n+\t    break;\n+\t  case op_swap:\n+\t    {\n+\t      type t1 = pop32 ();\n+\t      type t2 = pop32 ();\n+\t      push_type (t1);\n+\t      push_type (t2);\n+\t    }\n+\t    break;\n+\t  case op_iadd:\n+\t  case op_isub:\n+\t  case op_imul:\n+\t  case op_idiv:\n+\t  case op_irem:\n+\t  case op_ishl:\n+\t  case op_ishr:\n+\t  case op_iushr:\n+\t  case op_iand:\n+\t  case op_ior:\n+\t  case op_ixor:\n+\t    pop_type (int_type);\n+\t    push_type (pop_type (int_type));\n+\t    break;\n+\t  case op_ladd:\n+\t  case op_lsub:\n+\t  case op_lmul:\n+\t  case op_ldiv:\n+\t  case op_lrem:\n+\t  case op_lshl:\n+\t  case op_lshr:\n+\t  case op_lushr:\n+\t  case op_land:\n+\t  case op_lor:\n+\t  case op_lxor:\n+\t    pop_type (long_type);\n+\t    push_type (pop_type (long_type));\n+\t    break;\n+\t  case op_fadd:\n+\t  case op_fsub:\n+\t  case op_fmul:\n+\t  case op_fdiv:\n+\t  case op_frem:\n+\t    pop_type (float_type);\n+\t    push_type (pop_type (float_type));\n+\t    break;\n+\t  case op_dadd:\n+\t  case op_dsub:\n+\t  case op_dmul:\n+\t  case op_ddiv:\n+\t  case op_drem:\n+\t    pop_type (double_type);\n+\t    push_type (pop_type (double_type));\n+\t    break;\n+\t  case op_ineg:\n+\t  case op_i2b:\n+\t  case op_i2c:\n+\t  case op_i2s:\n+\t    push_type (pop_type (int_type));\n+\t    break;\n+\t  case op_lneg:\n+\t    push_type (pop_type (long_type));\n+\t    break;\n+\t  case op_fneg:\n+\t    push_type (pop_type (float_type));\n+\t    break;\n+\t  case op_dneg:\n+\t    push_type (pop_type (double_type));\n+\t    break;\n+\t  case op_iinc:\n+\t    get_variable (get_byte (), int_type);\n+\t    get_byte ();\n+\t    break;\n+\t  case op_i2l:\n+\t    pop_type (int_type);\n+\t    push_type (long_type);\n+\t    break;\n+\t  case op_i2f:\n+\t    pop_type (int_type);\n+\t    push_type (float_type);\n+\t    break;\n+\t  case op_i2d:\n+\t    pop_type (int_type);\n+\t    push_type (double_type);\n+\t    break;\n+\t  case op_l2i:\n+\t    pop_type (long_type);\n+\t    push_type (int_type);\n+\t    break;\n+\t  case op_l2f:\n+\t    pop_type (long_type);\n+\t    push_type (float_type);\n+\t    break;\n+\t  case op_l2d:\n+\t    pop_type (long_type);\n+\t    push_type (double_type);\n+\t    break;\n+\t  case op_f2i:\n+\t    pop_type (float_type);\n+\t    push_type (int_type);\n+\t    break;\n+\t  case op_f2l:\n+\t    pop_type (float_type);\n+\t    push_type (long_type);\n+\t    break;\n+\t  case op_f2d:\n+\t    pop_type (float_type);\n+\t    push_type (double_type);\n+\t    break;\n+\t  case op_d2i:\n+\t    pop_type (double_type);\n+\t    push_type (int_type);\n+\t    break;\n+\t  case op_d2l:\n+\t    pop_type (double_type);\n+\t    push_type (long_type);\n+\t    break;\n+\t  case op_d2f:\n+\t    pop_type (double_type);\n+\t    push_type (float_type);\n+\t    break;\n+\t  case op_lcmp:\n+\t    pop_type (long_type);\n+\t    pop_type (long_type);\n+\t    push_type (int_type);\n+\t    break;\n+\t  case op_fcmpl:\n+\t  case op_fcmpg:\n+\t    pop_type (float_type);\n+\t    pop_type (float_type);\n+\t    push_type (int_type);\n+\t    break;\n+\t  case op_dcmpl:\n+\t  case op_dcmpg:\n+\t    pop_type (double_type);\n+\t    pop_type (double_type);\n+\t    push_type (int_type);\n+\t    break;\n+\t  case op_ifeq:\n+\t  case op_ifne:\n+\t  case op_iflt:\n+\t  case op_ifge:\n+\t  case op_ifgt:\n+\t  case op_ifle:\n+\t    pop_type (int_type);\n+\t    push_jump (get_short ());\n+\t    break;\n+\t  case op_if_icmpeq:\n+\t  case op_if_icmpne:\n+\t  case op_if_icmplt:\n+\t  case op_if_icmpge:\n+\t  case op_if_icmpgt:\n+\t  case op_if_icmple:\n+\t    pop_type (int_type);\n+\t    pop_type (int_type);\n+\t    push_jump (get_short ());\n+\t    break;\n+\t  case op_if_acmpeq:\n+\t  case op_if_acmpne:\n+\t    pop_type (reference_type);\n+\t    pop_type (reference_type);\n+\t    push_jump (get_short ());\n+\t    break;\n+\t  case op_goto:\n+\t    push_jump (get_short ());\n+\t    invalidate_pc ();\n+\t    break;\n+\t  case op_jsr:\n+\t    handle_jsr_insn (get_short ());\n+\t    break;\n+\t  case op_ret:\n+\t    handle_ret_insn (get_byte ());\n+\t    break;\n+\t  case op_tableswitch:\n+\t    {\n+\t      pop_type (int_type);\n+\t      skip_padding ();\n+\t      push_jump (get_int ());\n+\t      jint low = get_int ();\n+\t      jint high = get_int ();\n+\t      // Already checked LOW -vs- HIGH.\n+\t      for (int i = low; i <= high; ++i)\n+\t\tpush_jump (get_int ());\n+\t      invalidate_pc ();\n+\t    }\n+\t    break;\n+\n+\t  case op_lookupswitch:\n+\t    {\n+\t      pop_type (int_type);\n+\t      skip_padding ();\n+\t      push_jump (get_int ());\n+\t      jint npairs = get_int ();\n+\t      // Already checked NPAIRS >= 0.\n+\t      jint lastkey = 0;\n+\t      for (int i = 0; i < npairs; ++i)\n+\t\t{\n+\t\t  jint key = get_int ();\n+\t\t  if (i > 0 && key <= lastkey)\n+\t\t    verify_fail (\"lookupswitch pairs unsorted\");\n+\t\t  lastkey = key;\n+\t\t  push_jump (get_int ());\n+\t\t}\n+\t      invalidate_pc ();\n+\t    }\n+\t    break;\n+\t  case op_ireturn:\n+\t    check_return_type (pop_type (int_type));\n+\t    invalidate_pc ();\n+\t    break;\n+\t  case op_lreturn:\n+\t    check_return_type (pop_type (long_type));\n+\t    invalidate_pc ();\n+\t    break;\n+\t  case op_freturn:\n+\t    check_return_type (pop_type (float_type));\n+\t    invalidate_pc ();\n+\t    break;\n+\t  case op_dreturn:\n+\t    check_return_type (pop_type (double_type));\n+\t    invalidate_pc ();\n+\t    break;\n+\t  case op_areturn:\n+\t    check_return_type (pop_type (reference_type));\n+\t    invalidate_pc ();\n+\t    break;\n+\t  case op_return:\n+\t    check_return_type (void_type);\n+\t    invalidate_pc ();\n+\t    break;\n+\t  case op_getstatic:\n+\t    push_type (check_field_constant (get_ushort ()));\n+\t    break;\n+\t  case op_putstatic:\n+\t    pop_type (check_field_constant (get_ushort ()));\n+\t    break;\n+\t  case op_getfield:\n+\t    {\n+\t      type klass;\n+\t      type field = check_field_constant (get_ushort (), &klass);\n+\t      pop_type (klass);\n+\t      push_type (field);\n+\t    }\n+\t    break;\n+\t  case op_putfield:\n+\t    {\n+\t      type klass;\n+\t      type field = check_field_constant (get_ushort (), &klass);\n+\t      pop_type (field);\n+\t      pop_type (klass);\n+\t    }\n+\t    break;\n+\n+\t  case op_invokevirtual:\n+\t  case op_invokespecial:\n+\t  case op_invokestatic:\n+\t  case op_invokeinterface:\n+\t    {\n+\t      _Jv_Utf8Const *method_name, *method_signature;\n+\t      type class_type\n+\t\t= check_method_constant (get_ushort (),\n+\t\t\t\t\t opcode == (unsigned char) op_invokeinterface,\n+\t\t\t\t\t &method_name,\n+\t\t\t\t\t &method_signature);\n+\t      int arg_count = _Jv_count_arguments (method_signature);\n+\t      if (opcode == (unsigned char) op_invokeinterface)\n+\t\t{\n+\t\t  int nargs = get_byte ();\n+\t\t  if (nargs == 0)\n+\t\t    verify_fail (\"too few arguments to invokeinterface\");\n+\t\t  if (get_byte () != 0)\n+\t\t    verify_fail (\"invokeinterface dummy byte is wrong\");\n+\t\t  if (nargs - 1 != arg_count)\n+\t\t    verify_fail (\"wrong argument count for invokeinterface\");\n+\t\t}\n+\n+\t      bool is_init = false;\n+\t      if (_Jv_equalUtf8Consts (method_name, gcj::init_name))\n+\t\t{\n+\t\t  is_init = true;\n+\t\t  if (opcode != (unsigned char) op_invokespecial)\n+\t\t    verify_fail (\"can't invoke <init>\");\n+\t\t}\n+\t      else if (method_name->data[0] == '<')\n+\t\tverify_fail (\"can't invoke method starting with `<'\");\n+\n+\t      // Pop arguments and check types.\n+\t      type arg_types[arg_count];\n+\t      compute_argument_types (method_signature, arg_types);\n+\t      for (int i = arg_count - 1; i >= 0; --i)\n+\t\tpop_type (arg_types[i]);\n+\n+\t      if (opcode != (unsigned char) op_invokestatic)\n+\t\t{\n+\t\t  type t = class_type;\n+\t\t  if (is_init)\n+\t\t    {\n+\t\t      // In this case the PC doesn't matter.\n+\t\t      t.set_uninitialized (type::UNINIT);\n+\t\t    }\n+\t\t  t = pop_type (t);\n+\t\t  if (is_init)\n+\t\t    current_state->set_initialized (t.get_pc (),\n+\t\t\t\t\t\t    current_method->max_locals);\n+\t\t}\n+\n+\t      type rt = compute_return_type (method_signature);\n+\t      if (! rt.isvoid ())\n+\t\tpush_type (rt);\n+\t    }\n+\t    break;\n+\n+\t  case op_new:\n+\t    {\n+\t      type t = check_class_constant (get_ushort ());\n+\t      if (t.isarray () || t.isinterface () || t.isabstract ())\n+\t\tverify_fail (\"type is array, interface, or abstract\");\n+\t      t.set_uninitialized (start_PC);\n+\t      push_type (t);\n+\t    }\n+\t    break;\n+\n+\t  case op_newarray:\n+\t    {\n+\t      int atype = get_byte ();\n+\t      // We intentionally have chosen constants to make this\n+\t      // valid.\n+\t      if (atype < boolean_type || atype > long_type)\n+\t\tverify_fail (\"type not primitive\");\n+\t      pop_type (int_type);\n+\t      push_type (construct_primitive_array_type (type_val (atype)));\n+\t    }\n+\t    break;\n+\t  case op_anewarray:\n+\t    pop_type (int_type);\n+\t    push_type (check_class_constant (get_ushort ()));\n+\t    break;\n+\t  case op_arraylength:\n+\t    {\n+\t      type t = pop_type (reference_type);\n+\t      if (! t.isarray ())\n+\t\tverify_fail (\"array type expected\");\n+\t      push_type (int_type);\n+\t    }\n+\t    break;\n+\t  case op_athrow:\n+\t    pop_type (type (&java::lang::Throwable::class$));\n+\t    invalidate_pc ();\n+\t    break;\n+\t  case op_checkcast:\n+\t    pop_type (reference_type);\n+\t    push_type (check_class_constant (get_ushort ()));\n+\t    break;\n+\t  case op_instanceof:\n+\t    pop_type (reference_type);\n+\t    check_class_constant (get_ushort ());\n+\t    push_type (int_type);\n+\t    break;\n+\t  case op_monitorenter:\n+\t    pop_type (reference_type);\n+\t    break;\n+\t  case op_monitorexit:\n+\t    pop_type (reference_type);\n+\t    break;\n+\t  case op_wide:\n+\t    {\n+\t      switch (get_byte ())\n+\t\t{\n+\t\tcase op_iload:\n+\t\t  push_type (get_variable (get_ushort (), int_type));\n+\t\t  break;\n+\t\tcase op_lload:\n+\t\t  push_type (get_variable (get_ushort (), long_type));\n+\t\t  break;\n+\t\tcase op_fload:\n+\t\t  push_type (get_variable (get_ushort (), float_type));\n+\t\t  break;\n+\t\tcase op_dload:\n+\t\t  push_type (get_variable (get_ushort (), double_type));\n+\t\t  break;\n+\t\tcase op_aload:\n+\t\t  push_type (get_variable (get_ushort (), reference_type));\n+\t\t  break;\n+\t\tcase op_istore:\n+\t\t  set_variable (get_ushort (), pop_type (int_type));\n+\t\t  break;\n+\t\tcase op_lstore:\n+\t\t  set_variable (get_ushort (), pop_type (long_type));\n+\t\t  break;\n+\t\tcase op_fstore:\n+\t\t  set_variable (get_ushort (), pop_type (float_type));\n+\t\t  break;\n+\t\tcase op_dstore:\n+\t\t  set_variable (get_ushort (), pop_type (double_type));\n+\t\t  break;\n+\t\tcase op_astore:\n+\t\t  set_variable (get_ushort (), pop_type (reference_type));\n+\t\t  break;\n+\t\tcase op_ret:\n+\t\t  handle_ret_insn (get_short ());\n+\t\t  break;\n+\t\tcase op_iinc:\n+\t\t  get_variable (get_ushort (), int_type);\n+\t\t  get_short ();\n+\t\t  break;\n+\t\tdefault:\n+\t\t  verify_fail (\"unrecognized wide instruction\");\n+\t\t}\n+\t    }\n+\t    break;\n+\t  case op_multianewarray:\n+\t    {\n+\t      type atype = check_class_constant (get_ushort ());\n+\t      int dim = get_byte ();\n+\t      if (dim < 1)\n+\t\tverify_fail (\"too few dimensions to multianewarray\");\n+\t      atype.verify_dimensions (dim);\n+\t      for (int i = 0; i < dim; ++i)\n+\t\tpop_type (int_type);\n+\t      push_type (atype);\n+\t    }\n+\t    break;\n+\t  case op_ifnull:\n+\t  case op_ifnonnull:\n+\t    pop_type (reference_type);\n+\t    push_jump (get_short ());\n+\t    break;\n+\t  case op_goto_w:\n+\t    push_jump (get_int ());\n+\t    invalidate_pc ();\n+\t    break;\n+\t  case op_jsr_w:\n+\t    handle_jsr_insn (get_int ());\n+\t    break;\n+\n+\t  default:\n+\t    // Unrecognized opcode.\n+\t    verify_fail (\"unrecognized instruction\");\n+\t  }\n+      }\n+  }\n+\n+public:\n+\n+  void verify_instructions ()\n+  {\n+    branch_prepass ();\n+    verify_instructions_0 ();\n+  }\n+\n+  _Jv_BytecodeVerifier (_Jv_InterpMethod *m)\n+  {\n+    current_method = m;\n+    bytecode = m->bytecode ();\n+    exception = m->exceptions ();\n+    current_class = m->defining_class;\n+\n+    states = NULL;\n+    flags = NULL;\n+    jsr_ptrs = NULL;\n+  }\n+\n+  ~_Jv_BytecodeVerifier ()\n+  {\n+    if (states)\n+      _Jv_Free (states);\n+    if (flags)\n+      _Jv_Free (flags);\n+    if (jsr_ptrs)\n+      _Jv_Free (jsr_ptrs);\n+  }\n+};\n+\n+void\n+_Jv_VerifyMethod (_Jv_InterpMethod *meth)\n+{\n+  _Jv_BytecodeVerifier v (meth);\n+  v.verify_instructions ();\n+}\n+\n+// FIXME: add more info, like PC, when required.\n+static void\n+verify_fail (char *s)\n+{\n+  char buf[1024];\n+  strcpy (buf, \"verification failed: \");\n+  strcat (buf, s);\n+  throw new java::lang::VerifyError (JvNewStringLatin1 (buf));\n+}"}]}