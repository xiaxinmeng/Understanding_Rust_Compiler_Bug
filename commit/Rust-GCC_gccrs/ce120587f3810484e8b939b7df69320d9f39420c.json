{"sha": "ce120587f3810484e8b939b7df69320d9f39420c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxMjA1ODdmMzgxMDQ4NGU4YjkzOWI3ZGY2OTMyMGQ5ZjM5NDIwYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-06-07T11:22:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-06-07T11:22:26Z"}, "message": "gimple.c: Include builtins.h\n\n\n\t* gimple.c: Include builtins.h\n\t(gimple_inexpensive_call_p): New function.\n\t* gimple.h (gimple_inexpensive_call_p): Declare.\n\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Use it.\n\t* tree-ssa-loop-ivcanon.c (tree_estimate_loop_size): Likewise;\n\tfix formatting.\n\nFrom-SVN: r237172", "tree": {"sha": "ac682fe7cfb00fbb346d33d65ef0332beab85aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac682fe7cfb00fbb346d33d65ef0332beab85aad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce120587f3810484e8b939b7df69320d9f39420c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce120587f3810484e8b939b7df69320d9f39420c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce120587f3810484e8b939b7df69320d9f39420c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce120587f3810484e8b939b7df69320d9f39420c/comments", "author": null, "committer": null, "parents": [{"sha": "701b9a47bd1a19ba1625a5f1ecbc4b7d064c7e10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/701b9a47bd1a19ba1625a5f1ecbc4b7d064c7e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/701b9a47bd1a19ba1625a5f1ecbc4b7d064c7e10"}], "stats": {"total": 68, "additions": 48, "deletions": 20}, "files": [{"sha": "16f8b60afaf5c76964ff9b0229164f7595e87c85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce120587f3810484e8b939b7df69320d9f39420c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce120587f3810484e8b939b7df69320d9f39420c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce120587f3810484e8b939b7df69320d9f39420c", "patch": "@@ -1,3 +1,12 @@\n+2016-06-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gimple.c: Include builtins.h\n+\t(gimple_inexpensive_call_p): New function.\n+\t* gimple.h (gimple_inexpensive_call_p): Declare.\n+\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Use it.\n+\t* tree-ssa-loop-ivcanon.c (tree_estimate_loop_size): Likewise;\n+\tfix formatting.\n+\n 2016-06-07  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* diagnostic.c (diagnostic_impl, diagnostic_n_impl): New."}, {"sha": "677c56070904f82d77aa8a6e4de7a2e664ecda76", "filename": "gcc/gimple.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce120587f3810484e8b939b7df69320d9f39420c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce120587f3810484e8b939b7df69320d9f39420c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=ce120587f3810484e8b939b7df69320d9f39420c", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-walk.h\"\n #include \"gimplify.h\"\n #include \"target.h\"\n+#include \"builtins.h\"\n #include \"selftest.h\"\n #include \"gimple-pretty-print.h\"\n \n@@ -3025,6 +3026,19 @@ maybe_remove_unused_call_args (struct function *fn, gimple *stmt)\n     }\n }\n \n+/* Return false if STMT will likely expand to real function call.  */\n+\n+bool\n+gimple_inexpensive_call_p (gcall *stmt)\n+{\n+  if (gimple_call_internal_p (stmt))\n+    return true;\n+  tree decl = gimple_call_fndecl (stmt);\n+  if (decl && is_inexpensive_builtin (decl))\n+    return true;\n+  return false;\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "1da719c52e074be2daa6ceff1e8e2af93b96e0c7", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce120587f3810484e8b939b7df69320d9f39420c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce120587f3810484e8b939b7df69320d9f39420c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=ce120587f3810484e8b939b7df69320d9f39420c", "patch": "@@ -1525,6 +1525,7 @@ extern void preprocess_case_label_vec_for_gimple (vec<tree>, tree, tree *);\n extern void gimple_seq_set_location (gimple_seq, location_t);\n extern void gimple_seq_discard (gimple_seq);\n extern void maybe_remove_unused_call_args (struct function *, gimple *);\n+extern bool gimple_inexpensive_call_p (gcall *);\n \n /* Formal (expression) temporary table handling: multiple occurrences of\n    the same scalar expression are evaluated into the same temporary.  */"}, {"sha": "0ddbda6da7ea5f4fe8ac8efe93abee4054bf1127", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce120587f3810484e8b939b7df69320d9f39420c/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce120587f3810484e8b939b7df69320d9f39420c/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=ce120587f3810484e8b939b7df69320d9f39420c", "patch": "@@ -118,7 +118,8 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n       if (is_gimple_debug (last))\n \tcontinue;\n \n-      if (is_gimple_call (last))\n+      if (gimple_code (last) == GIMPLE_CALL\n+\t  && !gimple_inexpensive_call_p (as_a <gcall *> (last)))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,"}, {"sha": "fff28ee8712f41e1d0594ffaef5911260a60c72e", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce120587f3810484e8b939b7df69320d9f39420c/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce120587f3810484e8b939b7df69320d9f39420c/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=ce120587f3810484e8b939b7df69320d9f39420c", "patch": "@@ -207,8 +207,8 @@ constant_after_peeling (tree op, gimple *stmt, struct loop *loop)\n    Stop estimating after UPPER_BOUND is met.  Return true in this case.  */\n \n static bool\n-tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, struct loop_size *size,\n-\t\t\t int upper_bound)\n+tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel,\n+\t\t\t struct loop_size *size, int upper_bound)\n {\n   basic_block *body = get_loop_body (loop);\n   gimple_stmt_iterator gsi;\n@@ -236,7 +236,8 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n       else\n \tafter_exit = false;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \" BB: %i, after_exit: %i\\n\", body[i]->index, after_exit);\n+\tfprintf (dump_file, \" BB: %i, after_exit: %i\\n\", body[i]->index,\n+\t\t after_exit);\n \n       for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n@@ -285,20 +286,24 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n \t  /* Assignments of IV variables.  */\n \t  else if (gimple_code (stmt) == GIMPLE_ASSIGN\n \t\t   && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n-\t\t   && constant_after_peeling (gimple_assign_rhs1 (stmt), stmt, loop)\n+\t\t   && constant_after_peeling (gimple_assign_rhs1 (stmt), stmt,\n+\t\t\t\t\t      loop)\n \t\t   && (gimple_assign_rhs_class (stmt) != GIMPLE_BINARY_RHS\n \t\t       || constant_after_peeling (gimple_assign_rhs2 (stmt),\n \t\t       \t\t\t\t  stmt, loop)))\n \t    {\n \t      size->constant_iv = true;\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        fprintf (dump_file, \"   Constant expression will be folded away.\\n\");\n+\t        fprintf (dump_file,\n+\t\t\t \"   Constant expression will be folded away.\\n\");\n \t      likely_eliminated = true;\n \t    }\n \t  /* Conditionals.  */\n \t  else if ((gimple_code (stmt) == GIMPLE_COND\n-\t\t    && constant_after_peeling (gimple_cond_lhs (stmt), stmt, loop)\n-\t\t    && constant_after_peeling (gimple_cond_rhs (stmt), stmt, loop)\n+\t\t    && constant_after_peeling (gimple_cond_lhs (stmt), stmt,\n+\t\t\t\t\t       loop)\n+\t\t    && constant_after_peeling (gimple_cond_rhs (stmt), stmt,\n+\t\t\t\t\t       loop)\n \t\t    /* We don't simplify all constant compares so make sure\n \t\t       they are not both constant already.  See PR70288.  */\n \t\t    && (! is_gimple_min_invariant (gimple_cond_lhs (stmt))\n@@ -307,8 +312,8 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n \t\t       && constant_after_peeling (gimple_switch_index (\n \t\t\t\t\t\t    as_a <gswitch *> (stmt)),\n \t\t\t\t\t\t  stmt, loop)\n-\t\t       && ! is_gimple_min_invariant (gimple_switch_index (\n-\t\t\t\t\t\t       as_a <gswitch *> (stmt)))))\n+\t\t       && ! is_gimple_min_invariant\n+\t\t\t       (gimple_switch_index (as_a <gswitch *> (stmt)))))\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t        fprintf (dump_file, \"   Constant conditional.\\n\");\n@@ -339,26 +344,24 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n-\t  if (gimple_code (stmt) == GIMPLE_CALL)\n+\t  if (gimple_code (stmt) == GIMPLE_CALL\n+\t      && !gimple_inexpensive_call_p (as_a <gcall *>  (stmt)))\n \t    {\n \t      int flags = gimple_call_flags (stmt);\n-\t      tree decl = gimple_call_fndecl (stmt);\n-\n-\t      if (decl && DECL_IS_BUILTIN (decl)\n-\t\t  && is_inexpensive_builtin (decl))\n-\t\t;\n-\t      else if (flags & (ECF_PURE | ECF_CONST))\n+\t      if (flags & (ECF_PURE | ECF_CONST))\n \t\tsize->num_pure_calls_on_hot_path++;\n \t      else\n \t\tsize->num_non_pure_calls_on_hot_path++;\n \t      size->num_branches_on_hot_path ++;\n \t    }\n-\t  else if (gimple_code (stmt) != GIMPLE_CALL\n-\t\t   && gimple_code (stmt) != GIMPLE_DEBUG)\n+\t  /* Count inexpensive calls as non-calls, because they will likely\n+\t     expand inline.  */\n+\t  else if (gimple_code (stmt) != GIMPLE_DEBUG)\n \t    size->non_call_stmts_on_hot_path++;\n \t  if (((gimple_code (stmt) == GIMPLE_COND\n \t        && (!constant_after_peeling (gimple_cond_lhs (stmt), stmt, loop)\n-\t\t    || constant_after_peeling (gimple_cond_rhs (stmt), stmt, loop)))\n+\t\t    || constant_after_peeling (gimple_cond_rhs (stmt), stmt,\n+\t\t\t\t\t       loop)))\n \t       || (gimple_code (stmt) == GIMPLE_SWITCH\n \t\t   && !constant_after_peeling (gimple_switch_index (\n \t\t\t\t\t\t as_a <gswitch *> (stmt)),"}]}