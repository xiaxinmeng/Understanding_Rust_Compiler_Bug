{"sha": "99b25753bb82141b1f9b9a8eb62e14d6237c7a23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTliMjU3NTNiYjgyMTQxYjFmOWI5YThlYjYyZTE0ZDYyMzdjN2EyMw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-05-30T21:34:04Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-05-30T21:34:04Z"}, "message": "re PR tree-optimization/23452 (Optimizing CONJG_EXPR (a) * a)\n\n\n\tPR tree-optimization/23452\n\t* fold-const.c (fold_mult_zconjz): New subroutine of fold_binary,\n\tto optimize z * conj(z) as realpart(z)^2 + imagpart(z)^2.\n\t(fold_binary) <MULT_EXPR>: Call fold_mult_zconjz for integral\n\tcomplex values and with -ffast-math for FP complex values.\n\n\t* gcc.dg/fold-mulconj-1.c: New test case.\n\nFrom-SVN: r114246", "tree": {"sha": "e8c7d9474db25736fdee60d42de43372bd6ae36e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8c7d9474db25736fdee60d42de43372bd6ae36e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99b25753bb82141b1f9b9a8eb62e14d6237c7a23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99b25753bb82141b1f9b9a8eb62e14d6237c7a23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99b25753bb82141b1f9b9a8eb62e14d6237c7a23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99b25753bb82141b1f9b9a8eb62e14d6237c7a23/comments", "author": null, "committer": null, "parents": [{"sha": "606791f69894426ecd59d7baf18664fb77138324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606791f69894426ecd59d7baf18664fb77138324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/606791f69894426ecd59d7baf18664fb77138324"}], "stats": {"total": 86, "additions": 86, "deletions": 0}, "files": [{"sha": "95c9bad85ca9fdd4ea15d0ce74878bed04cf9a55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b25753bb82141b1f9b9a8eb62e14d6237c7a23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b25753bb82141b1f9b9a8eb62e14d6237c7a23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99b25753bb82141b1f9b9a8eb62e14d6237c7a23", "patch": "@@ -1,3 +1,11 @@\n+2006-05-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR tree-optimization/23452\n+\t* fold-const.c (fold_mult_zconjz): New subroutine of fold_binary,\n+\tto optimize z * conj(z) as realpart(z)^2 + imagpart(z)^2.\n+\t(fold_binary) <MULT_EXPR>: Call fold_mult_zconjz for integral\n+\tcomplex values and with -ffast-math for FP complex values.\n+\n 2006-05-30  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* c-common.h: Remove the prototype for yyparse."}, {"sha": "19058b2f1431b302d707d52a283f9066e752cf30", "filename": "gcc/fold-const.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b25753bb82141b1f9b9a8eb62e14d6237c7a23/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b25753bb82141b1f9b9a8eb62e14d6237c7a23/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=99b25753bb82141b1f9b9a8eb62e14d6237c7a23", "patch": "@@ -8105,6 +8105,44 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n   return NULL_TREE;\n }\n \n+\n+/* Subroutine of fold_binary.  Optimize complex multiplications of the\n+   form z * conj(z), as pow(realpart(z),2) + pow(imagpart(z),2).  The\n+   argument EXPR represents the expression \"z\" of type TYPE.  */\n+\n+static tree\n+fold_mult_zconjz (tree type, tree expr)\n+{\n+  tree itype = TREE_TYPE (type);\n+  tree rpart, ipart, tem;\n+\n+  if (TREE_CODE (expr) == COMPLEX_EXPR)\n+    {\n+      rpart = TREE_OPERAND (expr, 0);\n+      ipart = TREE_OPERAND (expr, 1);\n+    }\n+  else if (TREE_CODE (expr) == COMPLEX_CST)\n+    {\n+      rpart = TREE_REALPART (expr);\n+      ipart = TREE_IMAGPART (expr);\n+    }\n+  else\n+    {\n+      expr = save_expr (expr);\n+      rpart = fold_build1 (REALPART_EXPR, itype, expr);\n+      ipart = fold_build1 (IMAGPART_EXPR, itype, expr);\n+    }\n+\n+  rpart = save_expr (rpart);\n+  ipart = save_expr (ipart);\n+  tem = fold_build2 (PLUS_EXPR, itype,\n+\t\t     fold_build2 (MULT_EXPR, itype, rpart, rpart),\n+\t\t     fold_build2 (MULT_EXPR, itype, ipart, ipart));\n+  return fold_build2 (COMPLEX_EXPR, type, tem,\n+\t\t      fold_convert (itype, integer_zero_node));\n+}\n+\n+\n /* Fold a binary expression of code CODE and type TYPE with operands\n    OP0 and OP1.  Return the folded expression if folding is\n    successful.  Otherwise, return NULL_TREE.  */\n@@ -8768,6 +8806,13 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t\t     code, NULL_TREE)))\n \t    return fold_convert (type, tem);\n \n+\t  /* Optimize z * conj(z) for integer complex numbers.  */\n+\t  if (TREE_CODE (arg0) == CONJ_EXPR\n+\t      && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n+\t    return fold_mult_zconjz (type, arg1);\n+\t  if (TREE_CODE (arg1) == CONJ_EXPR\n+\t      && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n+\t    return fold_mult_zconjz (type, arg0);\n \t}\n       else\n \t{\n@@ -8813,6 +8858,18 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t}\n \t    }\n \n+\t  /* Optimize z * conj(z) for floating point complex numbers.\n+\t     Guarded by flag_unsafe_math_optimizations as non-finite\n+\t     imaginary components don't produce scalar results.  */\n+\t  if (flag_unsafe_math_optimizations\n+\t      && TREE_CODE (arg0) == CONJ_EXPR\n+\t      && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n+\t    return fold_mult_zconjz (type, arg1);\n+\t  if (flag_unsafe_math_optimizations\n+\t      && TREE_CODE (arg1) == CONJ_EXPR\n+\t      && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n+\t    return fold_mult_zconjz (type, arg0);\n+\n \t  if (flag_unsafe_math_optimizations)\n \t    {\n \t      enum built_in_function fcode0 = builtin_mathfn_code (arg0);"}, {"sha": "3738afa6fa78deca327b32d79336c22f5d33908f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b25753bb82141b1f9b9a8eb62e14d6237c7a23/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b25753bb82141b1f9b9a8eb62e14d6237c7a23/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=99b25753bb82141b1f9b9a8eb62e14d6237c7a23", "patch": "@@ -1,3 +1,8 @@\n+2006-05-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR tree-optimization/23452\n+\t* gcc.dg/fold-mulconj-1.c: New test case.\n+\n 2006-05-30  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/27803"}, {"sha": "0e04653e393f66e88a866d45747a554979ecaea6", "filename": "gcc/testsuite/gcc.dg/fold-mulconj-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b25753bb82141b1f9b9a8eb62e14d6237c7a23/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-mulconj-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b25753bb82141b1f9b9a8eb62e14d6237c7a23/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-mulconj-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-mulconj-1.c?ref=99b25753bb82141b1f9b9a8eb62e14d6237c7a23", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/23452 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ffast-math -fdump-tree-gimple\" } */\n+\n+_Complex double foo(_Complex double z)\n+{\n+  return z * ~z;\n+}\n+\n+_Complex int bar(_Complex int z)\n+{\n+  return z * ~z;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"CONJ_EXPR\" 0 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}]}