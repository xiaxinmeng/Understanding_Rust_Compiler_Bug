{"sha": "4c5e9870f255a35bbf5848284c20ad9345f5d58b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM1ZTk4NzBmMjU1YTM1YmJmNTg0ODI4NGMyMGFkOTM0NWY1ZDU4Yg==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2020-05-21T21:42:53Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-20T07:21:48Z"}, "message": "[Ada] Implement AI12-0280 Making 'Old more flexible\n\ngcc/ada/\n\n\t* sem_util.ads: Declare a new package, Old_Attr_Util, which in\n\tturn declares two more packages, Conditional_Evaluation and\n\tIndirect_Temps. Conditional_Evaluation provides a predicate for\n\tdeciding whether a given 'Old attribute reference is eligible\n\tfor conditional evaluation and, in the case where it is\n\teligible, a function that constructs the Boolean-valued\n\tcondition that is to be evaluated at run time in deciding\n\twhether to evaluate the attribute prefix.  Indirect_Temps\n\tprovides support for declaring a temporary which is only\n\tinitialized conditionally; more specifically, an access type and\n\ta variable of that type are declared (unconditionally) and then\n\tthe variable is (conditionally) initialized with an allocator.\n\tThe existence of the access type and the pointer variable is\n\thidden from clients, except that a predicate,\n\tIs_Access_Type_For_Indirect_Temp, is provided for identifying\n\tsuch access types. This is needed because we want such an access\n\ttype to be treated like a \"normal\" access type (specifically\n\twith respect to finalization of allocated objects). Other parts\n\tof the compiler treat access types differently if\n\tComes_From_Source is False, or if the secondary stack storage\n\tpool is used; this predicate is used to disable this special\n\ttreatment.\n\t* sem_attr.adb (Uneval_Old_Msg): Improve message text to reflect\n\tAda202x changes.\n\t(Analyze_Attribute): A previously-illegal 'Old attribute\n\treference is accepted in Ada2020 if it is eligible for\n\tconditional evaluation.\n\t* sem_res.adb (Valid_Conversion): Do not treat a rewritten 'Old\n\tattribute like other rewrite substitutions. This makes a\n\tdifference, for example, in the case where we are generating the\n\texpansion of a membership test of the form \"Saooaaat'Old in\n\tNamed_Access_Type\"; in this case Valid_Conversion needs to\n\treturn True (otherwise the expansion will be False - see the\n\tcall site in exp_ch4.adb).\n\t* exp_attr.adb (Expand_N_Attribute_Reference): When expanding a\n\t'Old attribute reference, test for the case where the reference\n\tis eligible for conditional evaluation. In that case, use the\n\tnew \"indirect temporary\" mechanism provided by Sem_Util.\n\t* exp_prag.adb\n\t(Expand_Attributes_In_Consequence.Expand_Attributes): If\n\tSem_Util.Indirect_Temp_Needed indicates that there could be\n\tcorrectness problems associated with the old expansion scheme\n\tfor dealing with 'Old attributes in contract cases consequences,\n\tthen we use the new \"indirect temporary\" mechanism provided by\n\tSem_Util instead. We do not want to do this unconditionally.\n\t* sem_util.adb: Provide a body for the new Old_Attr_Util\n\tpackage. Further work is needed in several areas for\n\tcorrectness:\n\t- The function Is_Repeatedly_Evaluated does not deal with\n\tcontainer aggregates yet.\n\t- The function Is_Known_On_Entry does not deal with interactions\n\twith the Global aspect.\n\tEach area where more work is needed is indicated with a \"???\"\n\tcomment in the code; a more detailed description can be found\n\tthere. Some optimization opportunties are similarly indicated\n\twith a \"???\" comment.\n\t* exp_ch3.adb (Freeze_Type): In deciding whether to generate\n\texpansion for the list controller of an access type, take the\n\tpredicate Is_Access_Type_For_Indirect_Temp into account. If the\n\tpredicate yields True, then generate the expansion.\n\t* exp_util.adb (Build_Allocate_Deallocate_Proc): We don't\n\tnormally finalize allocated objects that are allocated on the\n\tsecondary stack. Add an exception to this rule if the predicate\n\tIs_Access_Type_For_Indirect_Temp yields True.  As a result of\n\tthis exception, we have to deal with the fact that gigi expects\n\ta different parameter profile if we are using the secondary\n\tstack pool; the Pool and Alignment parameters must be omitted in\n\tthis case.", "tree": {"sha": "e8d0b07c4361fd6d954cd79ce7f9a8d45a94acce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8d0b07c4361fd6d954cd79ce7f9a8d45a94acce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c5e9870f255a35bbf5848284c20ad9345f5d58b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c5e9870f255a35bbf5848284c20ad9345f5d58b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c5e9870f255a35bbf5848284c20ad9345f5d58b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c5e9870f255a35bbf5848284c20ad9345f5d58b/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3b69cc24f53d5502721c3358b24b1d0faf55d04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b69cc24f53d5502721c3358b24b1d0faf55d04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3b69cc24f53d5502721c3358b24b1d0faf55d04"}], "stats": {"total": 1339, "additions": 1245, "deletions": 94}, "files": [{"sha": "0bc08aee03560433d7231654096235b3b8007a68", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=4c5e9870f255a35bbf5848284c20ad9345f5d58b", "patch": "@@ -4665,6 +4665,8 @@ package body Exp_Attr is\n          Subp    : Node_Id;\n          Temp    : Entity_Id;\n \n+         use Old_Attr_Util.Conditional_Evaluation;\n+         use Old_Attr_Util.Indirect_Temps;\n       begin\n          --  Generating C code we don't need to expand this attribute when\n          --  we are analyzing the internally built nested postconditions\n@@ -4748,10 +4750,60 @@ package body Exp_Attr is\n             Ins_Nod := First (Declarations (Ins_Nod));\n          end if;\n \n+         if Eligible_For_Conditional_Evaluation (N) then\n+            declare\n+               Eval_Stmts : constant List_Id := New_List;\n+\n+               procedure Append_For_Indirect_Temp\n+                 (N : Node_Id; Is_Eval_Stmt : Boolean);\n+               --  Append either a declaration (which is to be elaborated\n+               --  unconditionally) or an evaluation statement (which is\n+               --  to be executed conditionally).\n+\n+               -------------------------------\n+               --  Append_For_Indirect_Temp --\n+               -------------------------------\n+\n+               procedure Append_For_Indirect_Temp\n+                 (N : Node_Id; Is_Eval_Stmt : Boolean)\n+               is\n+               begin\n+                  if Is_Eval_Stmt then\n+                     Append_To (Eval_Stmts, N);\n+                  else\n+                     Insert_Before_And_Analyze (Ins_Nod, N);\n+                  end if;\n+               end Append_For_Indirect_Temp;\n+\n+               procedure Declare_Indirect_Temporary is new\n+                 Declare_Indirect_Temp\n+                   (Append_Item => Append_For_Indirect_Temp);\n+            begin\n+               Declare_Indirect_Temporary\n+                 (Attr_Prefix => Pref, Indirect_Temp => Temp);\n+\n+               Insert_Before_And_Analyze (\n+                 Ins_Nod,\n+                 Make_If_Statement\n+                   (Sloc            => Loc,\n+                    Condition       => Conditional_Evaluation_Condition  (N),\n+                    Then_Statements => Eval_Stmts));\n+\n+               Rewrite (N, Indirect_Temp_Value\n+                             (Temp => Temp,\n+                              Typ  => Etype (Pref),\n+                              Loc  => Loc));\n+\n+               if Present (Subp) then\n+                  Pop_Scope;\n+               end if;\n+               return;\n+            end;\n+\n          --  Preserve the tag of the prefix by offering a specific view of the\n          --  class-wide version of the prefix.\n \n-         if Is_Tagged_Type (Typ) then\n+         elsif Is_Tagged_Type (Typ) then\n \n             --  Generate:\n             --    CW_Temp : constant Typ'Class := Typ'Class (Pref);"}, {"sha": "8b8462a846b58bd6cbf64739d3c0a06effd4b387", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=4c5e9870f255a35bbf5848284c20ad9345f5d58b", "patch": "@@ -8178,8 +8178,9 @@ package body Exp_Ch3 is\n             --  Taft-amendment types, which potentially have controlled\n             --  components), expand the list controller object that will store\n             --  the dynamically allocated objects. Don't do this transformation\n-            --  for expander-generated access types, but do it for types that\n-            --  are the full view of types derived from other private types.\n+            --  for expander-generated access types, except do it for types\n+            --  that are the full view of types derived from other private\n+            --  types and for access types used to implement indirect temps.\n             --  Also suppress the list controller in the case of a designated\n             --  type with convention Java, since this is used when binding to\n             --  Java API specs, where there's no equivalent of a finalization\n@@ -8188,6 +8189,8 @@ package body Exp_Ch3 is\n \n             if not Comes_From_Source (Def_Id)\n               and then not Has_Private_Declaration (Def_Id)\n+              and then not Old_Attr_Util.Indirect_Temps\n+                             .Is_Access_Type_For_Indirect_Temp (Def_Id)\n             then\n                null;\n "}, {"sha": "050b05c578a11f34a2dacae101a0e53a930eb408", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 79, "deletions": 28, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=4c5e9870f255a35bbf5848284c20ad9345f5d58b", "patch": "@@ -1365,9 +1365,43 @@ package body Exp_Prag is\n          -----------------------\n \n          function Expand_Attributes (N : Node_Id) return Traverse_Result is\n-            Decl : Node_Id;\n-            Pref : Node_Id;\n-            Temp : Entity_Id;\n+            Decl     : Node_Id;\n+            Pref     : Node_Id;\n+            Temp     : Entity_Id;\n+            Indirect : Boolean := False;\n+\n+            use Sem_Util.Old_Attr_Util.Indirect_Temps;\n+\n+            procedure Append_For_Indirect_Temp\n+              (N : Node_Id; Is_Eval_Stmt : Boolean);\n+\n+            --  Append either a declaration (which is to be elaborated\n+            --  unconditionally) or an evaluation statement (which is\n+            --  to be executed conditionally).\n+\n+            -------------------------------\n+            --  Append_For_Indirect_Temp --\n+            -------------------------------\n+\n+            procedure Append_For_Indirect_Temp\n+              (N : Node_Id; Is_Eval_Stmt : Boolean)\n+            is\n+            begin\n+               if Is_Eval_Stmt then\n+                  Append_To (Eval_Stmts, N);\n+               else\n+                  Prepend_To (Decls, N);\n+                  --  This use of Prepend (as opposed to Append) is why\n+                  --  we have the Append_Decls_In_Reverse_Order parameter.\n+               end if;\n+            end Append_For_Indirect_Temp;\n+\n+            procedure Declare_Indirect_Temporary is new\n+              Declare_Indirect_Temp (\n+                Append_Item                   => Append_For_Indirect_Temp,\n+                Append_Decls_In_Reverse_Order => True);\n+\n+         --  Start of processing for Expand_Attributes\n \n          begin\n             --  Attribute 'Old\n@@ -1376,37 +1410,49 @@ package body Exp_Prag is\n               and then Attribute_Name (N) = Name_Old\n             then\n                Pref := Prefix (N);\n-               Temp := Make_Temporary (Loc, 'T', Pref);\n-               Set_Etype (Temp, Etype (Pref));\n \n-               --  Generate a temporary to capture the value of the prefix:\n-               --    Temp : <Pref type>;\n+               Indirect := Indirect_Temp_Needed (Etype (Pref));\n \n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Object_Definition   =>\n-                     New_Occurrence_Of (Etype (Pref), Loc));\n+               if Indirect then\n+                  if No (Eval_Stmts) then\n+                     Eval_Stmts := New_List;\n+                  end if;\n \n-               --  Place that temporary at the beginning of declarations, to\n-               --  prevent anomalies in the GNATprove flow-analysis pass in\n-               --  the precondition procedure that follows.\n+                  Declare_Indirect_Temporary\n+                    (Attr_Prefix   => Pref,\n+                     Indirect_Temp => Temp);\n \n-               Prepend_To (Decls, Decl);\n+               --  Declare a temporary of the prefix type with no explicit\n+               --  initial value. If the appropriate contract case is selected\n+               --  at run time, then the temporary will be initialized via an\n+               --  assignment statement.\n \n-               --  If the type is unconstrained, the prefix provides its\n-               --  value and constraint, so add it to declaration.\n+               else\n+                  Temp := Make_Temporary (Loc, 'T', Pref);\n+                  Set_Etype (Temp, Etype (Pref));\n \n-               if not Is_Constrained (Etype (Pref))\n-                 and then Is_Entity_Name (Pref)\n-               then\n-                  Set_Expression (Decl, Pref);\n-                  Analyze (Decl);\n+                  --  Generate a temporary to capture the value of the prefix:\n+                  --    Temp : <Pref type>;\n \n-               --  Otherwise add an assignment statement to temporary using\n-               --  prefix as RHS.\n+                  Decl :=\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Temp,\n+                      Object_Definition   =>\n+                        New_Occurrence_Of (Etype (Pref), Loc));\n \n-               else\n+                  --  Place that temporary at the beginning of declarations, to\n+                  --  prevent anomalies in the GNATprove flow-analysis pass in\n+                  --  the precondition procedure that follows.\n+\n+                  Prepend_To (Decls, Decl);\n+\n+                  --  Initially Temp is uninitialized (which is required for\n+                  --  correctness if default initialization might have side\n+                  --  effects). Assign prefix value to temp on Eval_Statement\n+                  --  list, so assignment will be executed conditionally.\n+\n+                  Set_Ekind (Temp, E_Variable);\n+                  Set_Suppress_Initialization (Temp);\n                   Analyze (Decl);\n \n                   if No (Eval_Stmts) then\n@@ -1417,7 +1463,6 @@ package body Exp_Prag is\n                     Make_Assignment_Statement (Loc,\n                       Name       => New_Occurrence_Of (Temp, Loc),\n                       Expression => Pref));\n-\n                end if;\n \n                --  Ensure that the prefix is valid\n@@ -1429,7 +1474,13 @@ package body Exp_Prag is\n                --  Replace the original attribute 'Old by a reference to the\n                --  generated temporary.\n \n-               Rewrite (N, New_Occurrence_Of (Temp, Loc));\n+               if Indirect then\n+                  Rewrite (N,\n+                    Indirect_Temp_Value\n+                      (Temp => Temp, Typ => Etype (Pref), Loc => Loc));\n+               else\n+                  Rewrite (N, New_Occurrence_Of (Temp, Loc));\n+               end if;\n \n             --  Attribute 'Result\n "}, {"sha": "67c3a3676669e56688dfc5e5f3d0725b0b3d36e1", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 82, "deletions": 59, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=4c5e9870f255a35bbf5848284c20ad9345f5d58b", "patch": "@@ -734,12 +734,13 @@ package body Exp_Util is\n \n       --  Local variables\n \n-      Desig_Typ    : Entity_Id;\n-      Expr         : Node_Id;\n-      Needs_Fin    : Boolean;\n-      Pool_Id      : Entity_Id;\n-      Proc_To_Call : Node_Id := Empty;\n-      Ptr_Typ      : Entity_Id;\n+      Desig_Typ                : Entity_Id;\n+      Expr                     : Node_Id;\n+      Needs_Fin                : Boolean;\n+      Pool_Id                  : Entity_Id;\n+      Proc_To_Call             : Node_Id := Empty;\n+      Ptr_Typ                  : Entity_Id;\n+      Use_Secondary_Stack_Pool : Boolean;\n \n    --  Start of processing for Build_Allocate_Deallocate_Proc\n \n@@ -804,17 +805,22 @@ package body Exp_Util is\n          Desig_Typ := Corresponding_Record_Type (Desig_Typ);\n       end if;\n \n+      Use_Secondary_Stack_Pool :=\n+        Is_RTE (Pool_Id, RE_SS_Pool)\n+          or else (Nkind (Expr) = N_Allocator\n+                    and then Is_RTE (Storage_Pool (Expr), RE_SS_Pool));\n+\n       --  Do not process allocations / deallocations without a pool\n \n       if No (Pool_Id) then\n          return;\n \n       --  Do not process allocations on / deallocations from the secondary\n-      --  stack.\n+      --  stack, except for access types used to implement indirect temps.\n \n-      elsif Is_RTE (Pool_Id, RE_SS_Pool)\n-        or else (Nkind (Expr) = N_Allocator\n-                  and then Is_RTE (Storage_Pool (Expr), RE_SS_Pool))\n+      elsif Use_Secondary_Stack_Pool\n+        and then not Old_Attr_Util.Indirect_Temps\n+                       .Is_Access_Type_For_Indirect_Temp (Ptr_Typ)\n       then\n          return;\n \n@@ -951,7 +957,9 @@ package body Exp_Util is\n          Append_To (Actuals, New_Occurrence_Of (Addr_Id, Loc));\n          Append_To (Actuals, New_Occurrence_Of (Size_Id, Loc));\n \n-         if Is_Allocate or else not Is_Class_Wide_Type (Desig_Typ) then\n+         if (Is_Allocate or else not Is_Class_Wide_Type (Desig_Typ))\n+           and then not Use_Secondary_Stack_Pool\n+         then\n             Append_To (Actuals, New_Occurrence_Of (Alig_Id, Loc));\n \n          --  For deallocation of class-wide types we obtain the value of\n@@ -967,6 +975,9 @@ package body Exp_Util is\n             --  into the code that reads the value of alignment from the TSD\n             --  (see Expand_N_Attribute_Reference)\n \n+            --  In the Use_Secondary_Stack_Pool case, Alig_Id is not\n+            --  passed in and therefore must not be referenced.\n+\n             Append_To (Actuals,\n               Unchecked_Convert_To (RTE (RE_Storage_Offset),\n                 Make_Attribute_Reference (Loc,\n@@ -1116,55 +1127,67 @@ package body Exp_Util is\n          --  Create a custom Allocate / Deallocate routine which has identical\n          --  profile to that of System.Storage_Pools.\n \n-         Insert_Action (N,\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-\n-               --  procedure Pnn\n-\n-               Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name       => Proc_Id,\n-                 Parameter_Specifications => New_List (\n-\n-                  --  P : Root_Storage_Pool\n-\n-                   Make_Parameter_Specification (Loc,\n-                     Defining_Identifier => Make_Temporary (Loc, 'P'),\n-                     Parameter_Type      =>\n-                       New_Occurrence_Of (RTE (RE_Root_Storage_Pool), Loc)),\n-\n-                  --  A : [out] Address\n-\n-                   Make_Parameter_Specification (Loc,\n-                     Defining_Identifier => Addr_Id,\n-                     Out_Present         => Is_Allocate,\n-                     Parameter_Type      =>\n-                       New_Occurrence_Of (RTE (RE_Address), Loc)),\n-\n-                  --  S : Storage_Count\n-\n-                   Make_Parameter_Specification (Loc,\n-                     Defining_Identifier => Size_Id,\n-                     Parameter_Type      =>\n-                       New_Occurrence_Of (RTE (RE_Storage_Count), Loc)),\n-\n-                  --  L : Storage_Count\n-\n-                   Make_Parameter_Specification (Loc,\n-                     Defining_Identifier => Alig_Id,\n-                     Parameter_Type      =>\n-                       New_Occurrence_Of (RTE (RE_Storage_Count), Loc)))),\n-\n-             Declarations               => No_List,\n+         declare\n+            --  P : Root_Storage_Pool\n+            function Pool_Param return Node_Id is (\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => Make_Temporary (Loc, 'P'),\n+                Parameter_Type      =>\n+                  New_Occurrence_Of (RTE (RE_Root_Storage_Pool), Loc)));\n+\n+            --  A : [out] Address\n+            function Address_Param return Node_Id is (\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => Addr_Id,\n+                Out_Present         => Is_Allocate,\n+                Parameter_Type      =>\n+                  New_Occurrence_Of (RTE (RE_Address), Loc)));\n+\n+            --  S : Storage_Count\n+            function Size_Param return Node_Id is (\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => Size_Id,\n+                Parameter_Type      =>\n+                  New_Occurrence_Of (RTE (RE_Storage_Count), Loc)));\n+\n+            --  L : Storage_Count\n+            function Alignment_Param return Node_Id is (\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => Alig_Id,\n+                Parameter_Type      =>\n+                  New_Occurrence_Of (RTE (RE_Storage_Count), Loc)));\n+\n+            Formal_Params : List_Id;\n+         begin\n+            if Use_Secondary_Stack_Pool then\n+               --  Gigi expects a different profile in the Secondary_Stack_Pool\n+               --  case. There must be no uses of the two missing formals\n+               --  (i.e., Pool_Param and Alignment_Param) in this case.\n+               Formal_Params := New_List (Address_Param, Size_Param);\n+            else\n+               Formal_Params := New_List (\n+                 Pool_Param, Address_Param, Size_Param, Alignment_Param);\n+            end if;\n \n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (\n-                   Make_Procedure_Call_Statement (Loc,\n-                     Name                   =>\n-                       New_Occurrence_Of (Proc_To_Call, Loc),\n-                     Parameter_Associations => Actuals)))),\n-           Suppress => All_Checks);\n+            Insert_Action (N,\n+              Make_Subprogram_Body (Loc,\n+                Specification              =>\n+                  --  procedure Pnn\n+                  Make_Procedure_Specification (Loc,\n+                    Defining_Unit_Name       => Proc_Id,\n+                    Parameter_Specifications => Formal_Params),\n+\n+                Declarations               => No_List,\n+\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (\n+                      Make_Procedure_Call_Statement (Loc,\n+                        Name                   =>\n+                          New_Occurrence_Of (Proc_To_Call, Loc),\n+                        Parameter_Associations => Actuals)))),\n+              Suppress => All_Checks);\n+         end;\n \n          --  The newly generated Allocate / Deallocate becomes the default\n          --  procedure to call when the back end processes the allocation /"}, {"sha": "fcb04a2c62b23f56b96736b933469c926d39ca3f", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=4c5e9870f255a35bbf5848284c20ad9345f5d58b", "patch": "@@ -2828,9 +2828,21 @@ package body Sem_Attr is\n \n          case Uneval_Old_Setting is\n             when 'E' =>\n+               --  ??? In the case where Ada_Version is < Ada_2020 and\n+               --  an illegal 'Old prefix would be legal in Ada_2020,\n+               --  we'd like to call Error_Msg_Ada_2020_Feature.\n+               --  Identifying that case involves some work.\n+\n                Error_Attr_P\n                  (\"prefix of attribute % that is potentially \"\n-                  & \"unevaluated must statically name an entity\");\n+                  & \"unevaluated must statically name an entity\"\n+\n+                  --  further text needed for accuracy if Ada_2020\n+                  & (if Ada_Version >= Ada_2020\n+                       and then Attr_Id = Attribute_Old\n+                     then \" or be eligible for conditional evaluation\"\n+                          & \" (RM 6.1.1 (27))\"\n+                     else \"\"));\n \n             when 'W' =>\n                Error_Msg_Name_1 := Aname;\n@@ -5136,10 +5148,15 @@ package body Sem_Attr is\n \n          else\n             --  Ensure that the prefix of attribute 'Old is an entity when it\n-            --  is potentially unevaluated (6.1.1 (27/3)).\n+            --  is potentially unevaluated (6.1.1 (27/3)). This rule is\n+            --  relaxed in Ada2020 - this relaxation is reflected in the\n+            --  call (below) to Eligible_For_Conditional_Evaluation.\n \n             if Is_Potentially_Unevaluated (N)\n               and then not Statically_Names_Object (P)\n+              and then not\n+                Old_Attr_Util.Conditional_Evaluation\n+                 .Eligible_For_Conditional_Evaluation (N)\n             then\n                Uneval_Old_Msg;\n "}, {"sha": "8b9902d07271896c4cd28658603339e2127243d2", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=4c5e9870f255a35bbf5848284c20ad9345f5d58b", "patch": "@@ -13422,11 +13422,21 @@ package body Sem_Res is\n             --  rewritten. The Comes_From_Source test isn't sufficient because\n             --  nodes in inlined calls to predefined library routines can have\n             --  Comes_From_Source set to False. (Is there a better way to test\n-            --  for implicit conversions???)\n+            --  for implicit conversions???).\n+            --\n+            --  Do not treat a rewritten 'Old attribute reference like other\n+            --  rewrite substitutions. This makes a difference, for example,\n+            --  in the case where we are generating the expansion of a\n+            --  membership test of the form\n+            --     Saooaaat'Old in Named_Access_Type\n+            --  because in this case Valid_Conversion needs to return True\n+            --  (otherwise the expansion will be False - see the call site\n+            --  in exp_ch4.adb).\n \n             if Ada_Version >= Ada_2012\n               and then not Comes_From_Source (N)\n               and then Is_Rewrite_Substitution (N)\n+              and then not Is_Attribute_Old (Original_Node (N))\n               and then Ekind (Base_Type (Target_Type)) = E_General_Access_Type\n               and then Ekind (Opnd_Type) = E_Anonymous_Access_Type\n             then"}, {"sha": "45a551f16d054eb0e1639902d0901cb12f0d7d25", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 909, "deletions": 0, "changes": 909, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=4c5e9870f255a35bbf5848284c20ad9345f5d58b", "patch": "@@ -29698,6 +29698,915 @@ package body Sem_Util is\n \n    end Interval_Lists;\n \n+   package body Old_Attr_Util is\n+      package body Conditional_Evaluation is\n+         type Determining_Expr_Context is\n+           (No_Context, If_Expr, Case_Expr, Short_Circuit_Op, Membership_Test);\n+\n+         --  Determining_Expr_Context enumeration elements (except for\n+         --  No_Context) correspond to the list items in RM 6.1.1 definition\n+         --  of \"determining expression\".\n+\n+         type Determining_Expr\n+           (Context : Determining_Expr_Context := No_Context)\n+         is record\n+            Expr : Node_Id := Empty;\n+            case Context is\n+               when Short_Circuit_Op =>\n+                  Is_And_Then         : Boolean;\n+               when If_Expr =>\n+                  Is_Then_Part        : Boolean;\n+               when Case_Expr =>\n+                  Alternatives        : Node_Id;\n+               when Membership_Test =>\n+                  --  Given a subexpression of <exp4> in a membership test\n+                  --    <exp1> in <exp2> | <exp3> | <exp4> | <exp5>\n+                  --  the corresponding determining expression value would\n+                  --  have First_Non_Preceding = <exp4> (See RM 6.1.1).\n+                  First_Non_Preceding : Node_Id;\n+               when No_Context =>\n+                  null;\n+            end case;\n+         end record;\n+\n+         type Determining_Expression_List is\n+           array (Positive range <>) of Determining_Expr;\n+\n+         function Determining_Condition (Det : Determining_Expr)\n+           return Node_Id;\n+         --  Given a determining expression, build a Boolean-valued\n+         --  condition that incorporates that expression into condition\n+         --  suitable for deciding whether to initialize a 'Old constant.\n+         --  Polarity is \"True => initialize the constant\".\n+\n+         function Determining_Expressions\n+           (Expr : Node_Id; Expr_Trailer : Node_Id := Empty)\n+           return Determining_Expression_List;\n+         --  Given a conditionally evaluated expression, return its\n+         --  determining expressions.\n+         --  See RM 6.1.1 for definition of term \"determining expressions\".\n+         --  Tests should be performed in the order they occur in the\n+         --  array, with short circuiting.\n+         --  A determining expression need not be of a boolean type (e.g.,\n+         --  it might be the determining expression of a case expression).\n+         --  The Expr_Trailer parameter should be defaulted for nonrecursive\n+         --  calls.\n+\n+         function Is_Conditionally_Evaluated (Expr : Node_Id) return Boolean;\n+         --  See RM 6.1.1 for definition of term \"conditionally evaluated\".\n+\n+         function Is_Known_On_Entry (Expr : Node_Id) return Boolean;\n+         --  See RM 6.1.1 for definition of term \"known on entry\".\n+\n+         --------------------------------------\n+         -- Conditional_Evaluation_Condition --\n+         --------------------------------------\n+\n+         function Conditional_Evaluation_Condition\n+           (Expr : Node_Id) return Node_Id\n+         is\n+            Determiners : constant Determining_Expression_List :=\n+              Determining_Expressions (Expr);\n+            Loc         : constant Source_Ptr := Sloc (Expr);\n+            Result      : Node_Id :=\n+              New_Occurrence_Of (Standard_True, Loc);\n+         begin\n+            pragma Assert (Determiners'Length > 0 or else\n+                           Is_Anonymous_Access_Type (Etype (Expr)));\n+\n+            for I in Determiners'Range loop\n+               Result := Make_And_Then\n+                          (Loc,\n+                           Left_Opnd  => Result,\n+                           Right_Opnd =>\n+                             Determining_Condition (Determiners (I)));\n+            end loop;\n+            return Result;\n+         end Conditional_Evaluation_Condition;\n+\n+         ---------------------------\n+         -- Determining_Condition --\n+         ---------------------------\n+\n+         function Determining_Condition (Det : Determining_Expr) return Node_Id\n+         is\n+            Loc : constant Source_Ptr := Sloc (Det.Expr);\n+         begin\n+            case Det.Context is\n+               when Short_Circuit_Op =>\n+                  if Det.Is_And_Then then\n+                     return New_Copy_Tree (Det.Expr);\n+                  else\n+                     return Make_Op_Not (Loc, New_Copy_Tree (Det.Expr));\n+                  end if;\n+\n+               when If_Expr =>\n+                  if Det.Is_Then_Part then\n+                     return New_Copy_Tree (Det.Expr);\n+                  else\n+                     return Make_Op_Not (Loc, New_Copy_Tree (Det.Expr));\n+                  end if;\n+\n+               when Case_Expr =>\n+                  declare\n+                     Alts : List_Id := Discrete_Choices (Det.Alternatives);\n+                  begin\n+                     if Nkind (First (Alts)) = N_Others_Choice then\n+                        Alts := Others_Discrete_Choices (First (Alts));\n+                     end if;\n+\n+                     return Make_In (Loc,\n+                       Left_Opnd    => New_Copy_Tree (Det.Expr),\n+                       Right_Opnd   => Empty,\n+                       Alternatives => New_Copy_List (Alts));\n+                  end;\n+\n+               when Membership_Test =>\n+                  declare\n+                     function Copy_Prefix\n+                       (List : List_Id; Suffix_Start : Node_Id)\n+                       return List_Id;\n+                     --  Given a list and a member of that list, returns\n+                     --  a copy (similar to Nlists.New_Copy_List) of the\n+                     --  prefix of the list up to but not including\n+                     --  Suffix_Start.\n+\n+                     -----------------\n+                     -- Copy_Prefix --\n+                     -----------------\n+\n+                     function Copy_Prefix\n+                       (List : List_Id; Suffix_Start : Node_Id)\n+                       return List_Id\n+                     is\n+                        Result : constant List_Id := New_List;\n+                        Elem   : Node_Id := First (List);\n+                     begin\n+                        while Elem /= Suffix_Start loop\n+                           Append (New_Copy (Elem), Result);\n+                           Next (Elem);\n+                           pragma Assert (Present (Elem));\n+                        end loop;\n+                        return Result;\n+                     end Copy_Prefix;\n+\n+                  begin\n+                     return Make_In (Loc,\n+                       Left_Opnd    => New_Copy_Tree (Left_Opnd (Det.Expr)),\n+                       Right_Opnd   => Empty,\n+                       Alternatives => Copy_Prefix\n+                                         (Alternatives (Det.Expr),\n+                                          Det.First_Non_Preceding));\n+                  end;\n+\n+               when No_Context =>\n+                  raise Program_Error;\n+            end case;\n+         end Determining_Condition;\n+\n+         -----------------------------\n+         -- Determining_Expressions --\n+         -----------------------------\n+\n+         function Determining_Expressions\n+           (Expr : Node_Id; Expr_Trailer : Node_Id := Empty)\n+           return Determining_Expression_List\n+         is\n+            Par           : Node_Id := Expr;\n+            Trailer       : Node_Id := Expr_Trailer;\n+            Next_Element  : Determining_Expr;\n+         begin\n+            --  We want to stop climbing up the tree when we reach the\n+            --  postcondition expression. An aspect_specification is\n+            --  transformed into a pragma, so reaching a pragma is our\n+            --  termination condition. This relies on the fact that\n+            --  pragmas are not allowed in declare expressions (or any\n+            --  other kind of expression).\n+\n+            loop\n+               Next_Element.Expr := Empty;\n+\n+               case Nkind (Par) is\n+                  when N_Short_Circuit =>\n+                     if Trailer = Right_Opnd (Par) then\n+                        Next_Element :=\n+                          (Expr        => Left_Opnd (Par),\n+                           Context     => Short_Circuit_Op,\n+                           Is_And_Then => Nkind (Par) = N_And_Then);\n+                     end if;\n+\n+                  when N_If_Expression =>\n+                     --  For an expression like\n+                     --    (if C1 then ... elsif C2 then ... else Foo'Old)\n+                     --  the RM says are two determining expressions,\n+                     --  C1 and C2. Our treatment here (where we only add\n+                     --  one determining expression to the list) is ok because\n+                     --  we will see two if-expressions, one within the other.\n+\n+                     if Trailer /= First (Expressions (Par)) then\n+                        Next_Element :=\n+                           (Expr         => First (Expressions (Par)),\n+                            Context      => If_Expr,\n+                            Is_Then_Part =>\n+                              Trailer = Next (First (Expressions (Par))));\n+                     end if;\n+\n+                  when N_Case_Expression_Alternative =>\n+                     pragma Assert (Nkind (Parent (Par)) = N_Case_Expression);\n+\n+                     Next_Element :=\n+                       (Expr         => Expression (Parent (Par)),\n+                        Context      => Case_Expr,\n+                        Alternatives => Par);\n+\n+                  when N_Membership_Test =>\n+                     if Trailer /= Left_Opnd (Par)\n+                       and then Is_Non_Empty_List (Alternatives (Par))\n+                       and then Trailer /= First (Alternatives (Par))\n+                     then\n+                        pragma Assert (not Present (Right_Opnd (Par)));\n+                        pragma Assert\n+                          (Is_List_Member (Trailer)\n+                           and then List_Containing (Trailer)\n+                                    = Alternatives (Par));\n+\n+                        --  This one is different than the others\n+                        --  because one element in the array result\n+                        --  may represent multiple determining\n+                        --  expressions (i.e. every member of the list\n+                        --     Alternatives (Par)\n+                        --  up to but not including Trailer).\n+\n+                        Next_Element :=\n+                          (Expr                => Par,\n+                           Context             => Membership_Test,\n+                           First_Non_Preceding => Trailer);\n+                     end if;\n+\n+                  when N_Pragma =>\n+                     declare\n+                        Previous : constant Node_Id := Prev (Par);\n+                        Prev_Expr : Node_Id;\n+                     begin\n+                        if Nkind (Previous) = N_Pragma and then\n+                          Split_PPC (Previous)\n+                        then\n+                           --  A source-level postcondition of\n+                           --    A and then B and then C\n+                           --  results in\n+                           --    pragma Postcondition (A);\n+                           --    pragma Postcondition (B);\n+                           --    pragma Postcondition (C);\n+                           --  with Split_PPC set to True on all but the\n+                           --  last pragma. We account for that here.\n+\n+                           Prev_Expr :=\n+                             Expression (First\n+                               (Pragma_Argument_Associations (Previous)));\n+\n+                           --  This Analyze call is needed in the case when\n+                           --  Sem_Attr.Analyze_Attribute calls\n+                           --  Eligible_For_Conditional_Evaluation. Without\n+                           --  it, we end up passing an unanalyzed expression\n+                           --  to Is_Known_On_Entry and that doesn't work.\n+\n+                           Analyze (Prev_Expr);\n+\n+                           Next_Element :=\n+                             (Expr        => Prev_Expr,\n+                              Context     => Short_Circuit_Op,\n+                              Is_And_Then => True);\n+\n+                           return Determining_Expressions (Prev_Expr)\n+                             & Next_Element;\n+                        else\n+                           pragma Assert\n+                             (Get_Pragma_Id (Pragma_Name (Par)) in\n+                                Pragma_Post | Pragma_Postcondition\n+                                | Pragma_Post_Class | Pragma_Refined_Post\n+                                | Pragma_Check | Pragma_Contract_Cases);\n+\n+                           return (1 .. 0 => <>); -- recursion terminates here\n+                        end if;\n+                     end;\n+\n+                  when N_Empty =>\n+                     --  This case should be impossible, but if it does\n+                     --  happen somehow then we don't want an infinite loop.\n+                     raise Program_Error;\n+\n+                  when others =>\n+                     null;\n+               end case;\n+\n+               Trailer := Par;\n+               Par := Parent (Par);\n+\n+               if Present (Next_Element.Expr) then\n+                  return Determining_Expressions\n+                           (Expr => Par, Expr_Trailer => Trailer)\n+                         & Next_Element;\n+               end if;\n+            end loop;\n+         end Determining_Expressions;\n+\n+         -----------------------------------------\n+         -- Eligible_For_Conditional_Evaluation --\n+         -----------------------------------------\n+\n+         function Eligible_For_Conditional_Evaluation\n+           (Expr : Node_Id) return Boolean\n+         is\n+         begin\n+            if Is_Anonymous_Access_Type (Etype (Expr)) then\n+               --  The code in exp_attr.adb that also builds declarations\n+               --  for 'Old constants doesn't handle the anonymous access\n+               --  type case correctly, so we avoid that problem by\n+               --  returning True here.\n+               return True;\n+            elsif Ada_Version < Ada_2020 then\n+               return False;\n+            elsif not Is_Conditionally_Evaluated (Expr) then\n+               return False;\n+            else\n+               declare\n+                  Determiners : constant Determining_Expression_List :=\n+                    Determining_Expressions (Expr);\n+               begin\n+                  pragma Assert (Determiners'Length > 0);\n+\n+                  for Idx in Determiners'Range loop\n+                     if not Is_Known_On_Entry (Determiners (Idx).Expr) then\n+                        return False;\n+                     end if;\n+                  end loop;\n+               end;\n+               return True;\n+            end if;\n+         end Eligible_For_Conditional_Evaluation;\n+\n+         --------------------------------\n+         -- Is_Conditionally_Evaluated --\n+         --------------------------------\n+\n+         function Is_Conditionally_Evaluated (Expr : Node_Id) return Boolean\n+         is\n+            --  There are three possibilities - the expression is\n+            --  unconditionally evaluated, repeatedly evaluated, or\n+            --  conditionally evaluated (see RM 6.1.1). So we implement\n+            --  this test by testing for the other two.\n+\n+            function Is_Repeatedly_Evaluated (Expr : Node_Id) return Boolean;\n+            --  See RM 6.1.1 for definition of \"repeatedly evaluated\".\n+\n+            -----------------------------\n+            -- Is_Repeatedly_Evaluated --\n+            -----------------------------\n+\n+            function Is_Repeatedly_Evaluated (Expr : Node_Id) return Boolean is\n+               Par : Node_Id := Expr;\n+               Trailer : Node_Id := Empty;\n+\n+               --  There are three ways that an expression can be repeatedly\n+               --  evaluated. We only test for two of them here because\n+               --  container aggregates and the Aggregate aspect are not\n+               --  implemented yet. ???\n+\n+            begin\n+               --  An aspect_specification is transformed into a pragma, so\n+               --  reaching a pragma is our termination condition. We want to\n+               --  stop when we reach the postcondition expression.\n+\n+               while Nkind (Par) /= N_Pragma loop\n+                  pragma Assert (Present (Par));\n+\n+                  --  test for case 1:\n+                  --    A subexpression of a predicate of a\n+                  --    quantified_expression.\n+\n+                  if Nkind (Par) = N_Quantified_Expression\n+                     and then Trailer = Condition (Par)\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  --  test for case 2:\n+                  --    A subexpression of the expression of an\n+                  --    array_component_association\n+\n+                  if Nkind (Par) = N_Component_Association\n+                    and then Trailer = Expression (Par)\n+                  then\n+\n+                     --  determine whether Par is part of an array aggregate\n+                     declare\n+                        Rover : Node_Id := Par;\n+                     begin\n+                        while Nkind (Rover) not in N_Has_Etype loop\n+                           pragma Assert (Present (Rover));\n+                           Rover := Parent (Rover);\n+                        end loop;\n+                        if Present (Etype (Rover))\n+                          and then Is_Array_Type (Etype (Rover))\n+                        then\n+                           return True;\n+                        end if;\n+                     end;\n+                  end if;\n+\n+                  --  As noted above, there is a case 3 that we don't yet\n+                  --  test for. When we do, that test goes here. ???\n+                  null;\n+\n+                  Trailer := Par;\n+                  Par := Parent (Par);\n+               end loop;\n+\n+               return False;\n+            end Is_Repeatedly_Evaluated;\n+\n+         begin\n+            if not Is_Potentially_Unevaluated (Expr) then\n+               --  the expression is unconditionally evaluated\n+               return False;\n+            elsif Is_Repeatedly_Evaluated (Expr) then\n+               return False;\n+            end if;\n+\n+            return True;\n+         end Is_Conditionally_Evaluated;\n+\n+         -----------------------\n+         -- Is_Known_On_Entry --\n+         -----------------------\n+\n+         function Is_Known_On_Entry (Expr : Node_Id) return Boolean is\n+            --  ??? This implementation is incomplete. See RM 6.1.1\n+            --  for details. In particular, this function *should* return\n+            --  True for a function call (or a user-defined literal, which\n+            --  is equivalent to a function call) if all actual parameters\n+            --  (including defaulted params) are known on entry and the\n+            --  function has \"Globals => null\" specified; the current\n+            --  implementation will incorrectly return False in this case.\n+\n+            function All_Exps_Known_On_Entry\n+              (Expr_List : List_Id) return Boolean;\n+            --  Given a list of expressions, returns False iff\n+            --  Is_Known_On_Entry is False for at least one list element.\n+\n+            -----------------------------\n+            -- All_Exps_Known_On_Entry --\n+            -----------------------------\n+\n+            function All_Exps_Known_On_Entry\n+              (Expr_List : List_Id) return Boolean\n+            is\n+               Expr : Node_Id := First (Expr_List);\n+            begin\n+               while Present (Expr) loop\n+                  if not Is_Known_On_Entry (Expr) then\n+                     return False;\n+                  end if;\n+                  Next (Expr);\n+               end loop;\n+               return True;\n+            end All_Exps_Known_On_Entry;\n+\n+         begin\n+            if Is_Static_Expression (Expr) then\n+               return True;\n+            end if;\n+\n+            if Is_Attribute_Old (Expr) then\n+               return True;\n+            end if;\n+\n+            declare\n+               Pref : Node_Id := Expr;\n+            begin\n+               loop\n+                  case Nkind (Pref) is\n+                     when N_Selected_Component =>\n+                        null;\n+\n+                     when N_Indexed_Component =>\n+                        if not All_Exps_Known_On_Entry (Expressions (Pref))\n+                        then\n+                           return False;\n+                        end if;\n+\n+                     when N_Slice =>\n+                        return False; -- just to be clear about this case\n+\n+                     when others =>\n+                        exit;\n+                  end case;\n+\n+                  Pref := Prefix (Pref);\n+               end loop;\n+\n+               if Is_Entity_Name (Pref)\n+                 and then Is_Constant_Object (Entity (Pref))\n+               then\n+                  declare\n+                     Obj     : constant Entity_Id := Entity (Pref);\n+                     Obj_Typ : constant Entity_Id := Etype (Obj);\n+                  begin\n+                     case Ekind (Obj) is\n+                        when E_In_Parameter =>\n+                           if not Is_Elementary_Type (Obj_Typ) then\n+                              return False;\n+                           elsif Is_Aliased (Obj) then\n+                              return False;\n+                           end if;\n+\n+                        when E_Constant =>\n+                           --  return False for a deferred constant\n+                           if Present (Full_View (Obj)) then\n+                              return False;\n+                           end if;\n+\n+                           --  return False if not \"all views are constant\".\n+                           if Is_Immutably_Limited_Type (Obj_Typ)\n+                             or Needs_Finalization (Obj_Typ)\n+                           then\n+                              return False;\n+                           end if;\n+\n+                        when others =>\n+                           null;\n+                     end case;\n+                  end;\n+\n+                  return True;\n+               end if;\n+\n+               --  ??? Cope with a malformed tree. Code to cope with a\n+               --  nonstatic use of an enumeration literal should not be\n+               --  necessary.\n+               if Is_Entity_Name (Pref)\n+                 and then Ekind (Entity (Pref)) = E_Enumeration_Literal\n+               then\n+                  return True;\n+               end if;\n+            end;\n+\n+            case Nkind (Expr) is\n+               when N_Unary_Op =>\n+                  return Is_Known_On_Entry (Right_Opnd (Expr));\n+\n+               when N_Binary_Op =>\n+                  return Is_Known_On_Entry (Left_Opnd (Expr))\n+                    and then Is_Known_On_Entry (Right_Opnd (Expr));\n+\n+               when N_Type_Conversion | N_Qualified_Expression =>\n+                  return Is_Known_On_Entry (Expression (Expr));\n+\n+               when N_If_Expression =>\n+                  if not All_Exps_Known_On_Entry (Expressions (Expr)) then\n+                     return False;\n+                  end if;\n+\n+               when N_Case_Expression =>\n+                  if not Is_Known_On_Entry (Expression (Expr)) then\n+                     return False;\n+                  end if;\n+\n+                  declare\n+                     Alt : Node_Id := First (Alternatives (Expr));\n+                  begin\n+                     while Present (Alt) loop\n+                        if not Is_Known_On_Entry (Expression (Alt)) then\n+                           return False;\n+                        end if;\n+                        Next (Alt);\n+                     end loop;\n+                  end;\n+\n+                  return True;\n+\n+               when others =>\n+                  null;\n+            end case;\n+\n+            return False;\n+         end Is_Known_On_Entry;\n+\n+      end Conditional_Evaluation;\n+\n+      package body Indirect_Temps is\n+\n+         Indirect_Temp_Access_Type_Char : constant Character := 'K';\n+         --  The character passed to Make_Temporary when declaring\n+         --  the access type that is used in the implementation of an\n+         --  indirect temporary.\n+\n+         --------------------------\n+         -- Indirect_Temp_Needed --\n+         --------------------------\n+\n+         function Indirect_Temp_Needed (Typ : Entity_Id) return Boolean is\n+         begin\n+            --  There should be no correctness issues if the only cases where\n+            --  this function returns False are cases where Typ is an\n+            --  anonymous access type and we need to generate a saooaaat (a\n+            --  stand-alone object of an anonymous access type) in order get\n+            --  accessibility right. In other cases where this function\n+            --  returns False, there would be no correctness problems with\n+            --  returning True instead; however, returning False when we can\n+            --  generally results in simpler code.\n+\n+            return False\n+\n+               --  If Typ is not definite, then we cannot generate\n+               --    Temp : Typ;\n+\n+              or else not Is_Definite_Subtype (Typ)\n+\n+              --  If Typ is tagged, then generating\n+              --    Temp : Typ;\n+              --  might generate an object with the wrong tag. If we had\n+              --  a predicate that indicated whether the nominal tag is\n+              --  trustworthy, we could use that predicate here.\n+\n+              or else Is_Tagged_Type (Typ)\n+\n+              --  If Typ needs finalization, then generating an implicit\n+              --    Temp : Typ;\n+              --  declaration could have user-visible side effects.\n+\n+              or else Needs_Finalization (Typ)\n+\n+              --  In the anonymous access type case, we need to\n+              --  generate a saooaaat. We don't want the code in\n+              --  in exp_attr.adb that deals with the case where this\n+              --  function returns False to have to deal with that case\n+              --  (just to avoid code duplication). So we cheat a little\n+              --  bit and return True here for an anonymous access type.\n+\n+              or else Is_Anonymous_Access_Type (Typ);\n+\n+            --  ??? Unimplemented - spec description says:\n+            --    For an unconstrained-but-definite discriminated subtype,\n+            --    returns True if the potential difference in size between an\n+            --    unconstrained object and a constrained object is large.\n+            --\n+            --  For example,\n+            --    type Typ (Len : Natural := 0) is\n+            --      record F : String (1 .. Len); end record;\n+            --\n+            --  See Large_Max_Size_Mutable function elsewhere in this\n+            --  file (currently declared inside of\n+            --  New_Requires_Transient_Scope, so it would have to be\n+            --  moved if we want it to be callable from here).\n+\n+         end Indirect_Temp_Needed;\n+\n+         ---------------------------\n+         -- Declare_Indirect_Temp --\n+         ---------------------------\n+\n+         procedure Declare_Indirect_Temp\n+           (Attr_Prefix : Node_Id; Indirect_Temp : out Entity_Id)\n+         is\n+            Loc         : constant Source_Ptr := Sloc (Attr_Prefix);\n+            Prefix_Type : constant Entity_Id := Etype (Attr_Prefix);\n+            Temp_Id     : constant Entity_Id :=\n+              Make_Temporary (Loc, 'P', Attr_Prefix);\n+\n+            procedure Declare_Indirect_Temp_Via_Allocation;\n+            --  Handle the usual case.\n+\n+            -------------------------------------------\n+            --  Declare_Indirect_Temp_Via_Allocation --\n+            -------------------------------------------\n+\n+            procedure Declare_Indirect_Temp_Via_Allocation is\n+               Access_Type_Id : constant Entity_Id\n+                 := Make_Temporary\n+                      (Loc, Indirect_Temp_Access_Type_Char, Attr_Prefix);\n+\n+               Temp_Decl : constant Node_Id :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp_Id,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Access_Type_Id, Loc));\n+\n+               Allocate_Class_Wide : constant Boolean :=\n+                 Is_Specific_Tagged_Type (Prefix_Type);\n+               --  If True then access type designates the class-wide type in\n+               --  order to preserve (at run time) the value of the underlying\n+               --  tag.\n+               --  ??? We could do better here (in the case where Prefix_Type\n+               --  is tagged and specific) if we had a predicate which takes an\n+               --  expression and returns True iff the expression is of\n+               --  a specific tagged type and the underlying tag (at run time)\n+               --  is statically known to match that of the specific type.\n+               --  In that case, Allocate_Class_Wide could safely be False.\n+\n+               function Designated_Subtype_Mark return Node_Id;\n+               --  Usually, a subtype mark indicating the subtype of the\n+               --  attribute prefix. If that subtype is a specific tagged\n+               --  type, then returns the corresponding class-wide type.\n+               --  If the prefix is of an anonymous access type, then returns\n+               --  the designated type of that type.\n+\n+            -----------------------------\n+               -- Designated_Subtype_Mark --\n+            -----------------------------\n+\n+               function Designated_Subtype_Mark return Node_Id is\n+                  Typ : Entity_Id := Prefix_Type;\n+               begin\n+                  if Allocate_Class_Wide then\n+                     if Is_Private_Type (Typ)\n+                       and then Present (Full_View (Typ))\n+                     then\n+                        Typ := Full_View (Typ);\n+                     end if;\n+                     Typ := Class_Wide_Type (Typ);\n+                  end if;\n+\n+                  return New_Occurrence_Of (Typ, Loc);\n+               end Designated_Subtype_Mark;\n+\n+               Access_Type_Def : constant Node_Id\n+                 := Make_Access_To_Object_Definition\n+                      (Loc, Subtype_Indication => Designated_Subtype_Mark);\n+\n+               Access_Type_Decl : constant Node_Id\n+                 := Make_Full_Type_Declaration\n+                      (Loc, Access_Type_Id,\n+                       Type_Definition => Access_Type_Def);\n+            begin\n+               Set_Ekind (Temp_Id, E_Variable);\n+               Set_Etype (Temp_Id, Access_Type_Id);\n+               Set_Ekind (Access_Type_Id, E_Access_Type);\n+\n+               if Append_Decls_In_Reverse_Order then\n+                  Append_Item (Temp_Decl, Is_Eval_Stmt => False);\n+                  Append_Item (Access_Type_Decl, Is_Eval_Stmt => False);\n+               else\n+                  Append_Item (Access_Type_Decl, Is_Eval_Stmt => False);\n+                  Append_Item (Temp_Decl, Is_Eval_Stmt => False);\n+               end if;\n+\n+               Analyze (Access_Type_Decl);\n+               Analyze (Temp_Decl);\n+\n+               pragma Assert\n+                 (Is_Access_Type_For_Indirect_Temp (Access_Type_Id));\n+\n+               declare\n+                  Expression : Node_Id := Attr_Prefix;\n+                  Allocator  : Node_Id;\n+               begin\n+                  if Allocate_Class_Wide then\n+                     --  generate T'Class'(T'Class (<prefix>))\n+                     Expression :=\n+                       Make_Type_Conversion (Loc,\n+                         Subtype_Mark => Designated_Subtype_Mark,\n+                         Expression   => Expression);\n+                  end if;\n+\n+                  Allocator :=\n+                    Make_Allocator (Loc,\n+                      Make_Qualified_Expression\n+                        (Loc,\n+                         Subtype_Mark => Designated_Subtype_Mark,\n+                         Expression   => Expression));\n+\n+                  --  Allocate saved prefix value on the secondary stack\n+                  --  in order to avoid introducing a storage leak. This\n+                  --  allocated object is never explicitly reclaimed.\n+                  --\n+                  --  ??? Emit storage leak warning if RE_SS_Pool\n+                  --  unavailable?\n+\n+                  if RTE_Available (RE_SS_Pool) then\n+                     Set_Storage_Pool (Allocator, RTE (RE_SS_Pool));\n+                     Set_Procedure_To_Call\n+                       (Allocator, RTE (RE_SS_Allocate));\n+                     Set_Uses_Sec_Stack (Current_Scope);\n+                  end if;\n+\n+                  Append_Item\n+                    (Make_Assignment_Statement (Loc,\n+                       Name       => New_Occurrence_Of (Temp_Id, Loc),\n+                       Expression => Allocator),\n+                     Is_Eval_Stmt => True);\n+               end;\n+            end Declare_Indirect_Temp_Via_Allocation;\n+\n+         begin\n+            Indirect_Temp := Temp_Id;\n+\n+            if Is_Anonymous_Access_Type (Prefix_Type) then\n+               --  In the anonymous access type case, we do not want a level\n+               --  indirection (which would result in declaring an\n+               --  access-to-access type); that would result in correctness\n+               --  problems - the accessibility level of the type of the\n+               --  'Old constant would be wrong (See 6.1.1.). So in that case,\n+               --  we do not generate an allocator. Instead we generate\n+               --     Temp : access Designated := null;\n+               --  which is unconditionally elaborated and then\n+               --     Temp := <attribute prefix>;\n+               --  which is conditionally executed.\n+\n+               declare\n+                  Temp_Decl : constant Node_Id :=\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Temp_Id,\n+                      Object_Definition   =>\n+                        Make_Access_Definition\n+                          (Loc,\n+                           Constant_Present =>\n+                             Is_Access_Constant (Prefix_Type),\n+                           Subtype_Mark =>\n+                             New_Occurrence_Of\n+                               (Designated_Type (Prefix_Type), Loc)));\n+               begin\n+                  Append_Item (Temp_Decl, Is_Eval_Stmt => False);\n+                  Analyze (Temp_Decl);\n+                  Append_Item\n+                    (Make_Assignment_Statement (Loc,\n+                       Name       => New_Occurrence_Of (Temp_Id, Loc),\n+                       Expression => Attr_Prefix),\n+                     Is_Eval_Stmt => True);\n+               end;\n+            else\n+               --  the usual case\n+               Declare_Indirect_Temp_Via_Allocation;\n+            end if;\n+         end Declare_Indirect_Temp;\n+\n+         -------------------------\n+         -- Indirect_Temp_Value --\n+         -------------------------\n+\n+         function Indirect_Temp_Value\n+           (Temp : Entity_Id;\n+            Typ  : Entity_Id;\n+            Loc  : Source_Ptr) return Node_Id\n+         is\n+            Result : Node_Id;\n+         begin\n+            if Is_Anonymous_Access_Type (Typ) then\n+               --  No indirection in this case; just evaluate the temp.\n+               Result := New_Occurrence_Of (Temp, Loc);\n+               Set_Etype (Result, Etype (Temp));\n+\n+            else\n+               Result := Make_Explicit_Dereference (Loc,\n+                                     New_Occurrence_Of (Temp, Loc));\n+\n+               Set_Etype (Result, Designated_Type (Etype (Temp)));\n+\n+               if Is_Specific_Tagged_Type (Typ) then\n+                  --  The designated type of the access type is class-wide, so\n+                  --  convert to the specific type.\n+\n+                  Result :=\n+                    Make_Type_Conversion (Loc,\n+                      Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n+                      Expression   => Result);\n+\n+                  Set_Etype (Result, Typ);\n+               end if;\n+            end if;\n+\n+            return Result;\n+         end Indirect_Temp_Value;\n+\n+         function Is_Access_Type_For_Indirect_Temp\n+           (T : Entity_Id) return Boolean is\n+         begin\n+            if Is_Access_Type (T)\n+               and then not Comes_From_Source (T)\n+               and then Is_Internal_Name (Chars (T))\n+               and then Nkind (Scope (T)) in N_Entity\n+               and then Ekind (Scope (T))\n+                 in E_Entry | E_Entry_Family | E_Function | E_Procedure\n+               and then\n+                 (Present (Postconditions_Proc (Scope (T)))\n+                  or else Present (Contract (Scope (T))))\n+            then\n+               --  ??? Should define a flag for this. We could incorrectly\n+               --  return True if other clients of Make_Temporary happen to\n+               --  pass in the same character.\n+               declare\n+                  Name : constant String := Get_Name_String (Chars (T));\n+               begin\n+                  if Name (Name'First) = Indirect_Temp_Access_Type_Char then\n+                     return True;\n+                  end if;\n+               end;\n+            end if;\n+            return False;\n+         end Is_Access_Type_For_Indirect_Temp;\n+\n+      end Indirect_Temps;\n+   end Old_Attr_Util;\n begin\n    Erroutc.Subprogram_Name_Ptr := Subprogram_Name'Access;\n end Sem_Util;"}, {"sha": "1d6794cb058fbcc9857df3e98d7f1df9fb43c90a", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5e9870f255a35bbf5848284c20ad9345f5d58b/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=4c5e9870f255a35bbf5848284c20ad9345f5d58b", "patch": "@@ -3205,11 +3205,97 @@ package Sem_Util is\n       --  correctly for real types with static predicates, we may need\n       --  an analogous Real_Interval_List type. Most of the language\n       --  rules that reference \"is statically compatible\" pertain to\n-      --  discriminants and therefore do require support for real types;\n+      --  discriminants and therefore do not require support for real types;\n       --  the exception is 12.5.1(8).\n \n       Intervals_Error : exception;\n       --  Raised when the list of non-empty pair-wise disjoint intervals cannot\n       --  be built.\n    end Interval_Lists;\n+\n+   package Old_Attr_Util is\n+      --  Operations related to 'Old attribute evaluation. This\n+      --  includes cases where a level of indirection is needed due to\n+      --  conditional evaluation as well as support for the\n+      --  \"known on entry\" rules.\n+\n+      package Conditional_Evaluation is\n+         function Eligible_For_Conditional_Evaluation\n+           (Expr : Node_Id) return Boolean;\n+         --  Given a subexpression of a Postcondition expression\n+         --  (typically a 'Old attribute reference), returns True if\n+         --     - the expression is conditionally evaluated; and\n+         --     - its determining expressions are all known on entry; and\n+         --     - Ada_Version >= Ada_2020.\n+         --  See RM 6.1.1 for definitions of these terms.\n+         --\n+         --  Also returns True if Expr is of an anonymous access type;\n+         --  this is just because we want the code that knows how to build\n+         --  'Old temps in that case to reside in only one place.\n+\n+         function Conditional_Evaluation_Condition\n+           (Expr : Node_Id) return Node_Id;\n+         --  Given an expression which is eligible for conditional evaluation,\n+         --  build a Boolean expression whose value indicates whether the\n+         --  expression should be evaluated.\n+      end Conditional_Evaluation;\n+\n+      package Indirect_Temps is\n+         generic\n+            with procedure Append_Item (N : Node_Id; Is_Eval_Stmt : Boolean);\n+            --  If Is_Eval_Stmt is True, then N is a statement that should\n+            --  only be executed in the case where the 'Old prefix is to be\n+            --  evaluated. If Is_Eval_Stmt is False, then N is a declaration\n+            --  which should be elaborated unconditionally.\n+            --  Client is responsible for ensuring that any appended\n+            --  Eval_Stmt nodes are eventually analyzed.\n+\n+            Append_Decls_In_Reverse_Order : Boolean := False;\n+            --  This parameter is for the convenience of exp_prag.adb, where we\n+            --  want to Prepend rather than Append so it is better to get the\n+            --  Append calls in reverse order.\n+\n+         procedure Declare_Indirect_Temp\n+           (Attr_Prefix   : Node_Id; -- prefix of 'Old attribute (or similar?)\n+            Indirect_Temp : out Entity_Id);\n+         --  Indirect_Temp is of an access type; it is unconditionally\n+         --  declared but only conditionally initialized to reference the\n+         --  saved value of Attr_Prefix.\n+\n+         function Indirect_Temp_Needed (Typ : Entity_Id) return Boolean;\n+         --  Returns True for a specific tagged type because the temp must\n+         --  be of the class-wide type in order to preserve the underlying tag.\n+         --\n+         --  Also returns True in the case of an anonymous access type\n+         --  because we want the code that knows how to deal with\n+         --  this case to reside in only one place.\n+         --\n+         --  For an unconstrained-but-definite discriminated subtype, returns\n+         --  True if the potential difference in size between an\n+         --  unconstrained object and a constrained object is large.\n+         --  [This part is not implemented yet.]\n+         --\n+         --  Otherwise, returns False if a declaration of the form\n+         --     Temp : Typ;\n+         --  is legal and side-effect-free (assuming that default\n+         --  initialization is suppressed). For example, returns True if Typ is\n+         --  indefinite, or if Typ has a controlled part.\n+         --\n+\n+         function Indirect_Temp_Value\n+           (Temp : Entity_Id;\n+            Typ  : Entity_Id;\n+            Loc  : Source_Ptr) return Node_Id;\n+         --  Evaluate a temp declared by Declare_Indirect_Temp.\n+\n+         function Is_Access_Type_For_Indirect_Temp\n+           (T : Entity_Id) return Boolean;\n+         --  True for an access type that was declared via a call\n+         --  to Declare_Indirect_Temp.\n+         --  Indicates that the given access type should be treated\n+         --  the same with respect to finalization as a\n+         --  user-defined \"comes from source\" access type.\n+\n+      end Indirect_Temps;\n+   end Old_Attr_Util;\n end Sem_Util;"}]}