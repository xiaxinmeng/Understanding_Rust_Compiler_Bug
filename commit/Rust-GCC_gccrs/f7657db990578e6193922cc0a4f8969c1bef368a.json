{"sha": "f7657db990578e6193922cc0a4f8969c1bef368a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc2NTdkYjk5MDU3OGU2MTkzOTIyY2MwYTRmODk2OWMxYmVmMzY4YQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-09-09T22:10:32Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-09-09T22:10:32Z"}, "message": "builtins.c (real_dconstp, [...]): New, split out from fold_builtin.\n\n\t* builtins.c (real_dconstp, fold_builtin_logarithm,\n\tfold_builtin_exponent): New, split out from fold_builtin.  Also\n\tgeneralize to add log2, log10, exp2 and exp10/pow10 equivalents.\n\t* emit-rtl.c (dconst3, dconst10, dconstthird): New.\n\t(init_emit_once): Initialize new dconsts, use ARRAY_SIZE in lieu\n\tof hardcoded array size.\n\t* fold-const.c (fold): Add cases for exp2, exp10 and pow10.\n\t(tree_expr_nonnegative_p): Likewise.\n\t* real.h (dconst3, dconst10, dconstthird): New.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-explog-1.c: New testcase.\n\nFrom-SVN: r71252", "tree": {"sha": "017b032798831b2ccb2f7a0e8cab504de72ba7fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/017b032798831b2ccb2f7a0e8cab504de72ba7fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7657db990578e6193922cc0a4f8969c1bef368a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7657db990578e6193922cc0a4f8969c1bef368a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7657db990578e6193922cc0a4f8969c1bef368a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7657db990578e6193922cc0a4f8969c1bef368a/comments", "author": null, "committer": null, "parents": [{"sha": "dcbdd9cc82664884084bc48ec6869f893043f3c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcbdd9cc82664884084bc48ec6869f893043f3c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcbdd9cc82664884084bc48ec6869f893043f3c8"}], "stats": {"total": 587, "additions": 481, "deletions": 106}, "files": [{"sha": "cbffdfcdbbb04d6367f665e519faa5f825ef9133", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7657db990578e6193922cc0a4f8969c1bef368a", "patch": "@@ -1,3 +1,15 @@\n+2003-09-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (real_dconstp, fold_builtin_logarithm,\n+\tfold_builtin_exponent): New, split out from fold_builtin.  Also\n+\tgeneralize to add log2, log10, exp2 and exp10/pow10 equivalents.\n+\t* emit-rtl.c (dconst3, dconst10, dconstthird): New.\n+\t(init_emit_once): Initialize new dconsts, use ARRAY_SIZE in lieu\n+\tof hardcoded array size.\n+\t* fold-const.c (fold): Add cases for exp2, exp10 and pow10.\n+\t(tree_expr_nonnegative_p): Likewise.\n+\t* real.h (dconst3, dconst10, dconstthird): New.\n+\n Tue Sep  9 22:18:48 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphunit.c (cgraph_finalize_function): Fix handling of extern"}, {"sha": "dfa047f06f504e709f3faac3e9949d702015680d", "filename": "gcc/builtins.c", "status": "modified", "additions": 234, "deletions": 98, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f7657db990578e6193922cc0a4f8969c1bef368a", "patch": "@@ -5939,6 +5939,213 @@ fold_builtin_bitop (tree exp)\n   return NULL_TREE;\n }\n \n+/* Return true if EXPR is the real constant contained in VALUE.  */\n+\n+static bool\n+real_dconstp (tree expr, const REAL_VALUE_TYPE *value)\n+{\n+  STRIP_NOPS (expr);\n+\n+  return ((TREE_CODE (expr) == REAL_CST\n+           && ! TREE_CONSTANT_OVERFLOW (expr)\n+           && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), *value))\n+          || (TREE_CODE (expr) == COMPLEX_CST\n+              && real_dconstp (TREE_REALPART (expr), value)\n+              && real_zerop (TREE_IMAGPART (expr))));\n+}\n+\n+/* A subroutine of fold_builtin to fold the various logarithmic\n+   functions.  EXP is the CALL_EXPR of a call to a builtin log*\n+   function.  VALUE is the base of the log* function.  */\n+\n+static tree\n+fold_builtin_logarithm (tree exp, const REAL_VALUE_TYPE *value)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+\n+  if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    {\n+      tree fndecl = get_callee_fndecl (exp);\n+      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n+      tree arg = TREE_VALUE (arglist);\n+      const enum built_in_function fcode = builtin_mathfn_code (arg);\n+      const REAL_VALUE_TYPE value_mode =\n+\treal_value_truncate (TYPE_MODE (type), *value);\n+\t\n+      /* Optimize log*(1.0) = 0.0.  */\n+      if (real_onep (arg))\n+\treturn build_real (type, dconst0);\n+\n+      /* Optimize logN(N) = 1.0.  */\n+      if (real_dconstp (arg, &value_mode))\n+\treturn build_real (type, dconst1);\n+      \n+      /* Special case, optimize logN(expN(x)) = x.  */\n+      if (flag_unsafe_math_optimizations\n+\t  && ((value == &dconste\n+\t       && (fcode == BUILT_IN_EXP\n+\t\t   || fcode == BUILT_IN_EXPF\n+\t\t   || fcode == BUILT_IN_EXPL))\n+\t      || (value == &dconst2\n+\t\t  && (fcode == BUILT_IN_EXP2\n+\t\t      || fcode == BUILT_IN_EXP2F\n+\t\t      || fcode == BUILT_IN_EXP2L))\n+\t      || (value == &dconst10\n+\t\t  && (fcode == BUILT_IN_EXP10\n+\t\t      || fcode == BUILT_IN_EXP10F\n+\t\t      || fcode == BUILT_IN_EXP10L))))\n+\treturn convert (type, TREE_VALUE (TREE_OPERAND (arg, 1)));\n+\n+      /* Optimize log*(func()) for various exponential functions.  We\n+         want to determine the value \"x\" and the power \"exponent\" in\n+         order to transform logN(x**exponent) into exponent*logN(x).  */\n+      if (flag_unsafe_math_optimizations)\n+        {\n+\t  tree exponent = 0, x = 0;\n+\t  \n+\t  switch (fcode)\n+\t  {\n+\t  case BUILT_IN_EXP:\n+\t  case BUILT_IN_EXPF:\n+\t  case BUILT_IN_EXPL:\n+\t    /* Prepare to do logN(exp(exponent) -> exponent*logN(e).  */\n+\t    if (! builtin_dconsts_init)\n+\t      init_builtin_dconsts ();\n+\t    x = build_real (type,\n+\t\t\t    real_value_truncate (TYPE_MODE (type), dconste));\n+\t    exponent = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t    break;\n+\t  case BUILT_IN_EXP2:\n+\t  case BUILT_IN_EXP2F:\n+\t  case BUILT_IN_EXP2L:\n+\t    /* Prepare to do logN(exp2(exponent) -> exponent*logN(2).  */\n+\t    x = build_real (type, dconst2);\n+\t    exponent = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t    break;\n+\t  case BUILT_IN_EXP10:\n+\t  case BUILT_IN_EXP10F:\n+\t  case BUILT_IN_EXP10L:\n+\t  case BUILT_IN_POW10:\n+\t  case BUILT_IN_POW10F:\n+\t  case BUILT_IN_POW10L:\n+\t    /* Prepare to do logN(exp10(exponent) -> exponent*logN(10).  */\n+\t    x = build_real (type, dconst10);\n+\t    exponent = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t    break;\n+\t  case BUILT_IN_SQRT:\n+\t  case BUILT_IN_SQRTF:\n+\t  case BUILT_IN_SQRTL:\n+\t    /* Prepare to do logN(sqrt(x) -> 0.5*logN(x).  */\n+\t    x = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t    exponent = build_real (type, dconsthalf);\n+\t    break;\n+\t  case BUILT_IN_CBRT:\n+\t  case BUILT_IN_CBRTF:\n+\t  case BUILT_IN_CBRTL:\n+\t    /* Prepare to do logN(cbrt(x) -> (1/3)*logN(x).  */\n+\t    x = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t    exponent = build_real (type, real_value_truncate (TYPE_MODE (type),\n+\t\t\t\t\t\t\t      dconstthird));\n+\t    break;\n+\t  case BUILT_IN_POW:\n+\t  case BUILT_IN_POWF:\n+\t  case BUILT_IN_POWL:\n+\t    /* Prepare to do logN(pow(x,exponent) -> exponent*logN(x).  */\n+\t    x = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t    exponent = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg, 1)));\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\n+\t  /* Now perform the optimization.  */\n+\t  if (x && exponent)\n+\t    {\n+\t      tree logfn;\n+\t      arglist = build_tree_list (NULL_TREE, x);\n+\t      logfn = build_function_call_expr (fndecl, arglist);\n+\t      return fold (build (MULT_EXPR, type, exponent, logfn));\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\t  \n+/* A subroutine of fold_builtin to fold the various exponent\n+   functions.  EXP is the CALL_EXPR of a call to a builtin function.\n+   VALUE is the value which will be raised to a power.  */\n+\n+static tree\n+fold_builtin_exponent (tree exp, const REAL_VALUE_TYPE *value)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+\n+  if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    {\n+      tree fndecl = get_callee_fndecl (exp);\n+      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n+      tree arg = TREE_VALUE (arglist);\n+\n+      /* Optimize exp*(0.0) = 1.0.  */\n+      if (real_zerop (arg))\n+\treturn build_real (type, dconst1);\n+\n+      /* Optimize expN(1.0) = N.  */\n+      if (real_onep (arg))\n+        {\n+\t  REAL_VALUE_TYPE cst;\n+\n+\t  real_convert (&cst, TYPE_MODE (type), value);\n+\t  return build_real (type, cst);\n+\t}\n+\n+      /* Attempt to evaluate expN(integer) at compile-time.  */\n+      if (flag_unsafe_math_optimizations\n+\t  && TREE_CODE (arg) == REAL_CST\n+\t  && ! TREE_CONSTANT_OVERFLOW (arg))\n+        {\n+\t  REAL_VALUE_TYPE cint;\n+\t  REAL_VALUE_TYPE c;\n+\t  HOST_WIDE_INT n;\n+\n+\t  c = TREE_REAL_CST (arg);\n+\t  n = real_to_integer (&c);\n+\t  real_from_integer (&cint, VOIDmode, n,\n+\t\t\t     n < 0 ? -1 : 0, 0);\n+\t  if (real_identical (&c, &cint))\n+\t    {\n+\t      REAL_VALUE_TYPE x;\n+\n+\t      real_powi (&x, TYPE_MODE (type), value, n);\n+\t      return build_real (type, x);\n+\t    }\n+\t}\n+\n+      /* Optimize expN(logN(x)) = x.  */\n+      if (flag_unsafe_math_optimizations)\n+        {\n+\t  const enum built_in_function fcode = builtin_mathfn_code (arg);\n+\n+\t  if ((value == &dconste\n+\t       && (fcode == BUILT_IN_LOG\n+\t\t   || fcode == BUILT_IN_LOGF\n+\t\t   || fcode == BUILT_IN_LOGL))\n+\t      || (value == &dconst2\n+\t\t  && (fcode == BUILT_IN_LOG2\n+\t\t      || fcode == BUILT_IN_LOG2F\n+\t\t      || fcode == BUILT_IN_LOG2L))\n+\t      || (value == &dconst10\n+\t\t  && (fcode == BUILT_IN_LOG10\n+\t\t      || fcode == BUILT_IN_LOG10F\n+\t\t      || fcode == BUILT_IN_LOG10L)))\n+\t    return convert (type, TREE_VALUE (TREE_OPERAND (arg, 1)));\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n /* Used by constant folding to eliminate some builtin calls early.  EXP is\n    the CALL_EXPR of a call to a builtin function.  */\n \n@@ -6076,107 +6283,36 @@ fold_builtin (tree exp)\n     case BUILT_IN_EXP:\n     case BUILT_IN_EXPF:\n     case BUILT_IN_EXPL:\n-      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n-\t{\n-\t  enum built_in_function fcode;\n-\t  tree arg = TREE_VALUE (arglist);\n-\n-\t  /* Optimize exp(0.0) = 1.0.  */\n-\t  if (real_zerop (arg))\n-\t    return build_real (type, dconst1);\n-\n-\t  /* Optimize exp(1.0) = e.  */\n-\t  if (real_onep (arg))\n-\t    {\n-\t      REAL_VALUE_TYPE cst;\n-\n-\t      if (! builtin_dconsts_init)\n-\t\tinit_builtin_dconsts ();\n-\t      real_convert (&cst, TYPE_MODE (type), &dconste);\n-\t      return build_real (type, cst);\n-\t    }\n-\n-\t  /* Attempt to evaluate exp at compile-time.  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (arg))\n-\t    {\n-\t      REAL_VALUE_TYPE cint;\n-\t      REAL_VALUE_TYPE c;\n-\t      HOST_WIDE_INT n;\n-\n-\t      c = TREE_REAL_CST (arg);\n-\t      n = real_to_integer (&c);\n-\t      real_from_integer (&cint, VOIDmode, n,\n-\t\t\t\t n < 0 ? -1 : 0, 0);\n-\t      if (real_identical (&c, &cint))\n-\t\t{\n-\t\t  REAL_VALUE_TYPE x;\n-\n-\t\t  if (! builtin_dconsts_init)\n-\t\t    init_builtin_dconsts ();\n-\t\t  real_powi (&x, TYPE_MODE (type), &dconste, n);\n-\t\t  return build_real (type, x);\n-\t\t}\n-\t    }\n-\n-\t  /* Optimize exp(log(x)) = x.  */\n-\t  fcode = builtin_mathfn_code (arg);\n-\t  if (flag_unsafe_math_optimizations\n-\t      && (fcode == BUILT_IN_LOG\n-\t\t  || fcode == BUILT_IN_LOGF\n-\t\t  || fcode == BUILT_IN_LOGL))\n-\t    return TREE_VALUE (TREE_OPERAND (arg, 1));\n-\t}\n-      break;\n-\n+      if (! builtin_dconsts_init)\n+\tinit_builtin_dconsts ();\n+      return fold_builtin_exponent (exp, &dconste);\n+    case BUILT_IN_EXP2:\n+    case BUILT_IN_EXP2F:\n+    case BUILT_IN_EXP2L:\n+      return fold_builtin_exponent (exp, &dconst2);\n+    case BUILT_IN_EXP10:\n+    case BUILT_IN_EXP10F:\n+    case BUILT_IN_EXP10L:\n+    case BUILT_IN_POW10:\n+    case BUILT_IN_POW10F:\n+    case BUILT_IN_POW10L:\n+      return fold_builtin_exponent (exp, &dconst10);\n     case BUILT_IN_LOG:\n     case BUILT_IN_LOGF:\n     case BUILT_IN_LOGL:\n-      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n-\t{\n-\t  enum built_in_function fcode;\n-\t  tree arg = TREE_VALUE (arglist);\n-\n-\t  /* Optimize log(1.0) = 0.0.  */\n-\t  if (real_onep (arg))\n-\t    return build_real (type, dconst0);\n-\n-\t  /* Optimize log(exp(x)) = x.  */\n-\t  fcode = builtin_mathfn_code (arg);\n-\t  if (flag_unsafe_math_optimizations\n-\t      && (fcode == BUILT_IN_EXP\n-\t\t  || fcode == BUILT_IN_EXPF\n-\t\t  || fcode == BUILT_IN_EXPL))\n-\t    return TREE_VALUE (TREE_OPERAND (arg, 1));\n-\n-\t  /* Optimize log(sqrt(x)) = log(x)*0.5.  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && (fcode == BUILT_IN_SQRT\n-\t\t  || fcode == BUILT_IN_SQRTF\n-\t\t  || fcode == BUILT_IN_SQRTL))\n-\t    {\n-\t      tree logfn = build_function_call_expr (fndecl,\n-\t\t\t\t\t\t     TREE_OPERAND (arg, 1));\n-\t      return fold (build (MULT_EXPR, type, logfn,\n-\t\t\t\t  build_real (type, dconsthalf)));\n-\t    }\n-\n-\t  /* Optimize log(pow(x,y)) = y*log(x).  */\n-          if (flag_unsafe_math_optimizations\n-\t      && (fcode == BUILT_IN_POW\n-\t\t  || fcode == BUILT_IN_POWF\n-\t\t  || fcode == BUILT_IN_POWL))\n-\t    {\n-\t      tree arg0, arg1, logfn;\n-\n-\t      arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n-\t      arg1 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg, 1)));\n-\t      arglist = build_tree_list (NULL_TREE, arg0);\n-\t      logfn = build_function_call_expr (fndecl, arglist);\n-\t      return fold (build (MULT_EXPR, type, arg1, logfn));\n-\t    }\n-\t}\n+      if (! builtin_dconsts_init)\n+\tinit_builtin_dconsts ();\n+      return fold_builtin_logarithm (exp, &dconste);\n+      break;\n+    case BUILT_IN_LOG2:\n+    case BUILT_IN_LOG2F:\n+    case BUILT_IN_LOG2L:\n+      return fold_builtin_logarithm (exp, &dconst2);\n+      break;\n+    case BUILT_IN_LOG10:\n+    case BUILT_IN_LOG10F:\n+    case BUILT_IN_LOG10L:\n+      return fold_builtin_logarithm (exp, &dconst10);\n       break;\n \n     case BUILT_IN_TAN:"}, {"sha": "fbd72244b91ecd29027a73c37986638148c87be7", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f7657db990578e6193922cc0a4f8969c1bef368a", "patch": "@@ -110,9 +110,12 @@ rtx const_true_rtx;\n REAL_VALUE_TYPE dconst0;\n REAL_VALUE_TYPE dconst1;\n REAL_VALUE_TYPE dconst2;\n+REAL_VALUE_TYPE dconst3;\n+REAL_VALUE_TYPE dconst10;\n REAL_VALUE_TYPE dconstm1;\n REAL_VALUE_TYPE dconstm2;\n REAL_VALUE_TYPE dconsthalf;\n+REAL_VALUE_TYPE dconstthird;\n \n /* All references to the following fixed hard registers go through\n    these unique rtl objects.  On machines where the frame-pointer and\n@@ -5414,13 +5417,17 @@ init_emit_once (int line_numbers)\n   REAL_VALUE_FROM_INT (dconst0,   0,  0, double_mode);\n   REAL_VALUE_FROM_INT (dconst1,   1,  0, double_mode);\n   REAL_VALUE_FROM_INT (dconst2,   2,  0, double_mode);\n+  REAL_VALUE_FROM_INT (dconst3,   3,  0, double_mode);\n+  REAL_VALUE_FROM_INT (dconst10, 10,  0, double_mode);\n   REAL_VALUE_FROM_INT (dconstm1, -1, -1, double_mode);\n   REAL_VALUE_FROM_INT (dconstm2, -2, -1, double_mode);\n \n   dconsthalf = dconst1;\n   dconsthalf.exp--;\n \n-  for (i = 0; i <= 2; i++)\n+  real_arithmetic (&dconstthird, RDIV_EXPR, &dconst1, &dconst3);\n+\n+  for (i = 0; i < (int) ARRAY_SIZE (const_tiny_rtx); i++)\n     {\n       REAL_VALUE_TYPE *r =\n \t(i == 0 ? &dconst0 : i == 1 ? &dconst1 : &dconst2);"}, {"sha": "c9a43e6d7ac04fe284520fcb1086d728904ff80f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f7657db990578e6193922cc0a4f8969c1bef368a", "patch": "@@ -6110,10 +6110,20 @@ fold (tree expr)\n \t\t  return build_function_call_expr (sqrtfn, arglist);\n \t\t}\n \n-\t      /* Optimize exp(x)*exp(y) as exp(x+y).  */\n-\t      if ((fcode0 == BUILT_IN_EXP && fcode1 == BUILT_IN_EXP)\n-\t\t  || (fcode0 == BUILT_IN_EXPF && fcode1 == BUILT_IN_EXPF)\n-\t\t  || (fcode0 == BUILT_IN_EXPL && fcode1 == BUILT_IN_EXPL))\n+\t      /* Optimize expN(x)*expN(y) as expN(x+y).  */\n+\t      if (fcode0 == fcode1\n+\t\t  && (fcode0 == BUILT_IN_EXP\n+\t\t      || fcode0 == BUILT_IN_EXPF\n+\t\t      || fcode0 == BUILT_IN_EXPL\n+\t\t      || fcode0 == BUILT_IN_EXP2\n+\t\t      || fcode0 == BUILT_IN_EXP2F\n+\t\t      || fcode0 == BUILT_IN_EXP2L\n+\t\t      || fcode0 == BUILT_IN_EXP10\n+\t\t      || fcode0 == BUILT_IN_EXP10F\n+\t\t      || fcode0 == BUILT_IN_EXP10L\n+\t\t      || fcode0 == BUILT_IN_POW10\n+\t\t      || fcode0 == BUILT_IN_POW10F\n+\t\t      || fcode0 == BUILT_IN_POW10L))\n \t\t{\n \t\t  tree expfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n \t\t  tree arg = build (PLUS_EXPR, type,\n@@ -6445,10 +6455,19 @@ fold (tree expr)\n       if (flag_unsafe_math_optimizations)\n \t{\n \t  enum built_in_function fcode = builtin_mathfn_code (arg1);\n-\t  /* Optimize x/exp(y) into x*exp(-y).  */\n+\t  /* Optimize x/expN(y) into x*expN(-y).  */\n \t  if (fcode == BUILT_IN_EXP\n \t      || fcode == BUILT_IN_EXPF\n-\t      || fcode == BUILT_IN_EXPL)\n+\t      || fcode == BUILT_IN_EXPL\n+\t      || fcode == BUILT_IN_EXP2\n+\t      || fcode == BUILT_IN_EXP2F\n+\t      || fcode == BUILT_IN_EXP2L\n+\t      || fcode == BUILT_IN_EXP10\n+\t      || fcode == BUILT_IN_EXP10F\n+\t      || fcode == BUILT_IN_EXP10L\n+\t      || fcode == BUILT_IN_POW10\n+\t      || fcode == BUILT_IN_POW10F\n+\t      || fcode == BUILT_IN_POW10L)\n \t    {\n \t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n \t      tree arg = build1 (NEGATE_EXPR, type,\n@@ -8674,6 +8693,15 @@ tree_expr_nonnegative_p (tree t)\n \t    case BUILT_IN_EXP:\n \t    case BUILT_IN_EXPF:\n \t    case BUILT_IN_EXPL:\n+\t    case BUILT_IN_EXP2:\n+\t    case BUILT_IN_EXP2F:\n+\t    case BUILT_IN_EXP2L:\n+\t    case BUILT_IN_EXP10:\n+\t    case BUILT_IN_EXP10F:\n+\t    case BUILT_IN_EXP10L:\n+\t    case BUILT_IN_POW10:\n+\t    case BUILT_IN_POW10F:\n+\t    case BUILT_IN_POW10L:\n \t    case BUILT_IN_FABS:\n \t    case BUILT_IN_FABSF:\n \t    case BUILT_IN_FABSL:"}, {"sha": "0543b8f8f9d61239860e48d5743ff0259b2b92ac", "filename": "gcc/real.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=f7657db990578e6193922cc0a4f8969c1bef368a", "patch": "@@ -322,14 +322,17 @@ extern void real_ldexp (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, int);\n \n /* **** End of software floating point emulator interface macros **** */\n \f\n-/* Constant real values 0, 1, 2, -1, -2 and 0.5.  */\n+/* Constant real values 0, 1, 2, 3, 10, -1, -2, 0.5 and 1/3.  */\n \n extern REAL_VALUE_TYPE dconst0;\n extern REAL_VALUE_TYPE dconst1;\n extern REAL_VALUE_TYPE dconst2;\n+extern REAL_VALUE_TYPE dconst3;\n+extern REAL_VALUE_TYPE dconst10;\n extern REAL_VALUE_TYPE dconstm1;\n extern REAL_VALUE_TYPE dconstm2;\n extern REAL_VALUE_TYPE dconsthalf;\n+extern REAL_VALUE_TYPE dconstthird;\n \n /* Function to return a real value (not a tree node)\n    from a given integer constant.  */"}, {"sha": "2745abe955af909023639db3c72c8f98c666b87d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7657db990578e6193922cc0a4f8969c1bef368a", "patch": "@@ -1,3 +1,7 @@\n+2003-09-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-explog-1.c: New testcase.\n+\n 2003-09-08  Mark Mitchell  <mark@codesourcery.com>\n \n \t* gcc.dg/ia64-types1.c: New test."}, {"sha": "352f5b037b15a7121fd5b8702316b34896676360", "filename": "gcc/testsuite/gcc.dg/torture/builtin-explog-1.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-explog-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7657db990578e6193922cc0a4f8969c1bef368a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-explog-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-explog-1.c?ref=f7657db990578e6193922cc0a4f8969c1bef368a", "patch": "@@ -0,0 +1,185 @@\n+/* Copyright (C) 2003  Free Software Foundation.\n+\n+   Verify that built-in math function constant folding of log & exp is\n+   correctly performed by the compiler.\n+\n+   Written by Kaveh Ghazi, 2003-09-05.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-ffast-math\" } */\n+\n+/* Define \"e\" with as many bits as found in builtins.c:dconste.  */\n+#define M_E  2.7182818284590452353602874713526624977572470936999595749669676277241\n+#define M_EF 2.7182818284590452353602874713526624977572470936999595749669676277241F\n+#define M_EL 2.7182818284590452353602874713526624977572470936999595749669676277241L\n+/* Precision for comparison tests.  */\n+#define PREC  0.0000001\n+#define PRECF 0.0001F\n+#define PRECL 0.0000000000001L\n+#define PROTOTYPE(FN) extern double FN(double); extern float FN##f(float); \\\n+  extern long double FN##l(long double);\n+#define PROTOTYPE2(FN) extern double FN(double, double); \\\n+  extern float FN##f(float, float); \\\n+  extern long double FN##l(long double, long double);\n+\n+PROTOTYPE(exp)\n+PROTOTYPE(exp2)\n+PROTOTYPE(exp10)\n+PROTOTYPE(log)\n+PROTOTYPE(log2)\n+PROTOTYPE(log10)\n+PROTOTYPE(pow10)\n+PROTOTYPE(sqrt)\n+PROTOTYPE(cbrt)\n+PROTOTYPE2(pow)\n+\n+void test(double d1, double d2, float f1, float f2,\n+\t  long double ld1, long double ld2)\n+{\n+#define LOG_1(LOG) \\\n+ extern void link_failure_##LOG##_1(void); \\\n+ if (LOG(1.0) != 0.0 || LOG##f(1.0F) != 0.0F || LOG##l(1.0L) != 0.0L) \\\n+    link_failure_##LOG##_1()\n+\n+  LOG_1(log);\n+  LOG_1(log2);\n+  LOG_1(log10);\n+  \n+#define LOG_N(LOG, BASE) \\\n+ extern void link_failure_##LOG##_N(void); \\\n+ if (LOG(BASE) != 1.0 || LOG##f(BASE##F) != 1.0F || LOG##l(BASE##L) != 1.0L) \\\n+    link_failure_##LOG##_N()\n+\n+  LOG_N(log, M_E);\n+  LOG_N(log2, 2.0);\n+  LOG_N(log10, 10.0);\n+\n+#define LOGEXP_SAME(LOG, EXP) \\\n+ extern void link_failure_##LOG##_##EXP##_same(void); \\\n+ if (LOG(EXP(d1)) != d1 || LOG##f(EXP##f(f1)) != f1 \\\n+  || LOG##l(EXP##l(ld1)) != ld1) link_failure_##LOG##_##EXP##_same()\n+\n+  LOGEXP_SAME(log,exp);\n+  LOGEXP_SAME(log2,exp2);\n+  LOGEXP_SAME(log10,exp10);\n+  LOGEXP_SAME(log10,pow10);\n+\n+#define LOGEXP(LOG, EXP, BASE) \\\n+ extern void link_failure_##LOG##_##EXP(void); \\\n+ if (LOG(EXP(d1)) != d1*LOG(BASE) || LOG##f(EXP##f(f1)) != f1*LOG##f(BASE##F) \\\n+  || LOG##l(EXP##l(ld1)) != ld1*LOG##l(BASE##L)) link_failure_##LOG##_##EXP()\n+\n+  LOGEXP(log,exp,M_E);\n+  LOGEXP(log,exp2,2.0);\n+  LOGEXP(log,exp10,10.0);\n+  LOGEXP(log,pow10,10.0);\n+  LOGEXP(log2,exp,M_E);\n+  LOGEXP(log2,exp2,2.0);\n+  LOGEXP(log2,exp10,10.0);\n+  LOGEXP(log2,pow10,10.0);\n+  LOGEXP(log10,exp,M_E);\n+  LOGEXP(log10,exp2,2.0);\n+  LOGEXP(log10,exp10,10.0);\n+  LOGEXP(log10,pow10,10.0);\n+  \n+#define LOG_SQRT(LOG) \\\n+ extern void link_failure_##LOG##_sqrt(void); \\\n+ if (LOG(sqrt(d1)) != 0.5*LOG(d1) || LOG##f(sqrtf(f1)) != 0.5F*LOG##f(f1) \\\n+  || LOG##l(sqrtl(ld1)) != 0.5L*LOG##l(ld1)) link_failure_##LOG##_sqrt()\n+    \n+  LOG_SQRT(log);\n+  LOG_SQRT(log2);\n+  LOG_SQRT(log10);\n+  \n+#define LOG_CBRT(LOG) \\\n+ extern void link_failure_##LOG##_cbrt(void); \\\n+ if (LOG(cbrt(d1)) != (1.0/3)*LOG(d1) \\\n+  || LOG##f(cbrtf(f1)) != (1.0F/3)*LOG##f(f1) \\\n+  || LOG##l(cbrtl(ld1)) != (1.0L/3)*LOG##l(ld1)) link_failure_##LOG##_cbrt()\n+    \n+  LOG_CBRT(log);\n+  LOG_CBRT(log2);\n+  LOG_CBRT(log10);\n+  \n+#define LOGPOW(LOG, POW) \\\n+ extern void link_failure_##LOG##_##POW(void); \\\n+ if (LOG(POW(d1,d2)) != d2*LOG(d1) || LOG##f(POW##f(f1,f2)) != f2*LOG##f(f1) \\\n+  || LOG##l(POW##l(ld1,ld2)) != ld2*LOG##l(ld1)) link_failure_##LOG##_##POW()\n+  \n+  LOGPOW(log,pow);\n+  LOGPOW(log2,pow);\n+  LOGPOW(log10,pow);\n+\n+#define EXP_0(EXP) \\\n+ extern void link_failure_##EXP##_0(void); \\\n+ if (EXP(0.0) != 1.0 || EXP##f(0.0F) != 1.0F || EXP##l(0.0L) != 1.0L) \\\n+  link_failure_##EXP##_0()\n+\n+  EXP_0(exp);\n+  EXP_0(exp2);\n+  EXP_0(exp10);\n+  EXP_0(pow10);\n+  \n+#define EXP_N(EXP, BASE) \\\n+ extern void link_failure_##EXP##_N(void); \\\n+ if (EXP(1.0) != BASE || EXP##f(1.0F) != BASE##F || EXP##l(1.0L) != BASE##L) \\\n+  link_failure_##EXP##_N()\n+\n+  EXP_N(exp, M_E);\n+  EXP_N(exp2, 2.0);\n+  EXP_N(exp10, 10.0);\n+  EXP_N(pow10, 10.0);\n+\n+#define EXP_INT(EXP, BASE) \\\n+ extern void link_failure_##EXP##_INT(void); \\\n+ if (EXP(5.0) < (BASE)*(BASE)*(BASE)*(BASE)*(BASE) - PREC \\\n+  || EXP(5.0) > (BASE)*(BASE)*(BASE)*(BASE)*(BASE) + PREC \\\n+  || EXP##f(5.0F) < (BASE##F)*(BASE##F)*(BASE##F)*(BASE##F)*(BASE##F) -PRECF \\\n+  || EXP##f(5.0F) > (BASE##F)*(BASE##F)*(BASE##F)*(BASE##F)*(BASE##F) +PRECF \\\n+  || EXP##l(5.0L) < (BASE##L)*(BASE##L)*(BASE##L)*(BASE##L)*(BASE##L) -PRECL \\\n+  || EXP##l(5.0L) > (BASE##L)*(BASE##L)*(BASE##L)*(BASE##L)*(BASE##L) +PRECL) \\\n+   link_failure_##EXP##_INT()\n+\n+  EXP_INT(exp, M_E);\n+  EXP_INT(exp2, 2.0);\n+  EXP_INT(exp10, 10.0);\n+  EXP_INT(pow10, 10.0);\n+\n+#define EXPLOG_SAME(EXP, LOG) \\\n+ extern void link_failure_##EXP##_##LOG##_same(void); \\\n+ if (EXP(LOG(d1)) != d1 || EXP##f(LOG##f(f1)) != f1 \\\n+  || EXP##l(LOG##l(ld1)) != ld1) link_failure_##EXP##_##LOG##_same()\n+\n+  EXPLOG_SAME(exp, log);\n+  EXPLOG_SAME(exp2, log2);\n+  EXPLOG_SAME(exp10, log10);\n+  EXPLOG_SAME(pow10, log10);\n+\n+#define EXPXEXP(EXP) \\\n+ extern void link_failure_##EXP##X##EXP(void); \\\n+ if (EXP(d1)*EXP(d2) != EXP(d1+d2) || EXP##f(f1)*EXP##f(f2) != EXP##f(f1+f2) \\\n+  || EXP##l(ld1)*EXP##l(ld2) != EXP##l(ld1+ld2)) link_failure_##EXP##X##EXP()\n+\n+  EXPXEXP(exp);\n+  EXPXEXP(exp2);\n+  EXPXEXP(exp10);\n+  EXPXEXP(pow10);\n+\n+#define DIVEXP(EXP) \\\n+ extern void link_failure_div1_##EXP(void); \\\n+ if (d1/EXP(d2) != d1*EXP(-d2) || f1/EXP##f(f2) != f1*EXP##f(-f2) \\\n+  || ld1/EXP##l(ld2) != ld1*EXP##l(-ld2)) link_failure_div1_##EXP(); \\\n+ extern void link_failure_div2_##EXP(void); \\\n+ if (EXP(d1)/EXP(d2) != EXP(d1-d2) || EXP##f(f1)/EXP##f(f2) != EXP##f(f1-f2) \\\n+  || EXP##l(ld1)/EXP##l(ld2) != EXP##l(ld1-ld2)) link_failure_div2_##EXP()\n+\n+  DIVEXP(exp);\n+  DIVEXP(exp2);\n+  DIVEXP(exp10);\n+  DIVEXP(pow10);\n+}\n+\n+int main (void)\n+{\n+  return 0;\n+}"}]}