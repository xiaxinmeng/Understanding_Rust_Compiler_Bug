{"sha": "2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYwYjgwYzdhNGFiNDI1NGY1N2JhNjNkZTI2ZWJiNzg5NmUzNzQyZA==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2018-11-08T22:39:45Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2018-11-08T22:39:45Z"}, "message": "re PR rtl-optimization/87600 (Fix for PRs 86939 and 87479 causes build issues for several targets)\n\ngcc/\n\tPR rtl-optimization/87600\n\t* cfgexpand.c (expand_asm_stmt): Catch illegal asm constraint usage.\n\t* lra-constraints.c (process_alt_operands): Skip illegal hard\n\tregister usage.  Prefer reloading non hard register operands.\n\ngcc/testsuite/\n\tPR rtl-optimization/87600\n\t* gcc.dg/pr87600.h: New file.\n\t* gcc.dg/pr87600-1.c: New test.\n\t* gcc.dg/pr87600-2.c: Likewise.\n\nFrom-SVN: r265942", "tree": {"sha": "0b641c23205b2def0563667593bc61bb7bc6e042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b641c23205b2def0563667593bc61bb7bc6e042"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "39abbb865c2363ab508bdf5dc24553e448c803b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39abbb865c2363ab508bdf5dc24553e448c803b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39abbb865c2363ab508bdf5dc24553e448c803b0"}], "stats": {"total": 246, "additions": 233, "deletions": 13}, "files": [{"sha": "85788749b46d1c476c79c7ecc14c544d8df53f67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "patch": "@@ -1,3 +1,16 @@\n+2018-11-08  Peter Bergner  <bergner@linux.ibm.com>\n+\n+\tPR rtl-optimization/87600\n+\t* cfgexpand.c (expand_asm_stmt): Catch illegal asm constraint usage.\n+\t* lra-constraints.c (process_alt_operands): Skip illegal hard\n+\tregister usage.  Prefer reloading non hard register operands.\n+\n+gcc/testsuite/\n+\tPR rtl-optimization/87600\n+\t* gcc.dg/pr87600.h: New file.\n+\t* gcc.dg/pr87600-1.c: New test.\n+\t* gcc.dg/pr87600-2.c: Likewise.\n+\n 2018-11-08  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR other/36572\n@@ -12,7 +25,7 @@\n \t* common.opt (-fuse-ld=lld): New option.\n \t* doc/invoke.texi (-fuse-ld=lld): Document.\n \t* opts.c (common_handle_option): Handle OPT_fuse_ld_lld.\n-\t\n+\n 2018-11-08  Paul Koning  <ni1d@arrl.net>\n \n \t* config/pdp11/constraints.md: Add \"Z\" series constraints for use"}, {"sha": "8fa392fcd8adf931649295351756850204812bc1", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "patch": "@@ -3010,6 +3010,55 @@ expand_asm_stmt (gasm *stmt)\n \t\t\t\t    &allows_mem, &allows_reg, &is_inout))\n \treturn;\n \n+      /* If the output is a hard register, verify it doesn't conflict with\n+\t any other operand's possible hard register use.  */\n+      if (DECL_P (val)\n+\t  && REG_P (DECL_RTL (val))\n+\t  && HARD_REGISTER_P (DECL_RTL (val)))\n+\t{\n+\t  unsigned j, output_hregno = REGNO (DECL_RTL (val));\n+\t  bool early_clobber_p = strchr (constraints[i], '&') != NULL;\n+\t  unsigned long match;\n+\n+\t  /* Verify the other outputs do not use the same hard register.  */\n+\t  for (j = i + 1; j < noutputs; ++j)\n+\t    if (DECL_P (output_tvec[j])\n+\t\t&& REG_P (DECL_RTL (output_tvec[j]))\n+\t\t&& HARD_REGISTER_P (DECL_RTL (output_tvec[j]))\n+\t\t&& output_hregno == REGNO (DECL_RTL (output_tvec[j])))\n+\t      error (\"invalid hard register usage between output operands\");\n+\n+\t  /* Verify matching constraint operands use the same hard register\n+\t     and that the non-matching constraint operands do not use the same\n+\t     hard register if the output is an early clobber operand.  */\n+\t  for (j = 0; j < ninputs; ++j)\n+\t    if (DECL_P (input_tvec[j])\n+\t\t&& REG_P (DECL_RTL (input_tvec[j]))\n+\t\t&& HARD_REGISTER_P (DECL_RTL (input_tvec[j])))\n+\t      {\n+\t\tunsigned input_hregno = REGNO (DECL_RTL (input_tvec[j]));\n+\t\tswitch (*constraints[j + noutputs])\n+\t\t  {\n+\t\t  case '0':  case '1':  case '2':  case '3':  case '4':\n+\t\t  case '5':  case '6':  case '7':  case '8':  case '9':\n+\t\t    match = strtoul (constraints[j + noutputs], NULL, 10);\n+\t\t    break;\n+\t\t  default:\n+\t\t    match = ULONG_MAX;\n+\t\t    break;\n+\t\t  }\n+\t\tif (i == match\n+\t\t    && output_hregno != input_hregno)\n+\t\t  error (\"invalid hard register usage between output operand \"\n+\t\t\t \"and matching constraint operand\");\n+\t\telse if (early_clobber_p\n+\t\t\t && i != match\n+\t\t\t && output_hregno == input_hregno)\n+\t\t  error (\"invalid hard register usage between earlyclobber \"\n+\t\t\t \"operand and input operand\");\n+\t      }\n+\t}\n+\n       if (! allows_reg\n \t  && (allows_mem\n \t      || is_inout"}, {"sha": "88546d2138ae814f5f86f80a51c8e5227c550709", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "patch": "@@ -2146,9 +2146,32 @@ process_alt_operands (int only_alternative)\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\t/* Operands don't match.  Both operands must\n-\t\t\t   allow a reload register, otherwise we\n-\t\t\t   cannot make them match.  */\n+\t\t\t/* Operands don't match.  If the operands are\n+\t\t\t   different user defined explicit hard registers,\n+\t\t\t   then we cannot make them match.  */\n+\t\t\tif ((REG_P (*curr_id->operand_loc[nop])\n+\t\t\t     || SUBREG_P (*curr_id->operand_loc[nop]))\n+\t\t\t    && (REG_P (*curr_id->operand_loc[m])\n+\t\t\t\t|| SUBREG_P (*curr_id->operand_loc[m])))\n+\t\t\t  {\n+\t\t\t    rtx nop_reg = *curr_id->operand_loc[nop];\n+\t\t\t    if (SUBREG_P (nop_reg))\n+\t\t\t      nop_reg = SUBREG_REG (nop_reg);\n+\t\t\t    rtx m_reg = *curr_id->operand_loc[m];\n+\t\t\t    if (SUBREG_P (m_reg))\n+\t\t\t      m_reg = SUBREG_REG (m_reg);\n+\n+\t\t\t    if (REG_P (nop_reg)\n+\t\t\t\t&& HARD_REGISTER_P (nop_reg)\n+\t\t\t\t&& REG_USERVAR_P (nop_reg)\n+\t\t\t\t&& REG_P (m_reg)\n+\t\t\t\t&& HARD_REGISTER_P (m_reg)\n+\t\t\t\t&& REG_USERVAR_P (m_reg))\n+\t\t\t      break;\n+\t\t\t  }\n+\n+\t\t\t/* Both operands must allow a reload register,\n+\t\t\t   otherwise we cannot make them match.  */\n \t\t\tif (curr_alt[m] == NO_REGS)\n \t\t\t  break;\n \t\t\t/* Retroactively mark the operand we had to\n@@ -2910,18 +2933,31 @@ process_alt_operands (int only_alternative)\n \t\tif (first_conflict_j < 0)\n \t\t  first_conflict_j = j;\n \t\tlast_conflict_j = j;\n+\t\t/* Both the earlyclobber operand and conflicting operand\n+\t\t   cannot both be user defined hard registers.  */\n+\t\tif (HARD_REGISTER_P (operand_reg[i])\n+\t\t    && REG_USERVAR_P (operand_reg[i])\n+\t\t    && operand_reg[j] != NULL_RTX\n+\t\t    && HARD_REGISTER_P (operand_reg[j])\n+\t\t    && REG_USERVAR_P (operand_reg[j]))\n+\t\t  fatal_insn (\"unable to generate reloads for \"\n+\t\t\t      \"impossible constraints:\", curr_insn);\n \t      }\n \t  if (last_conflict_j < 0)\n \t    continue;\n-\t  /* If earlyclobber operand conflicts with another\n-\t     non-matching operand which is actually the same register\n-\t     as the earlyclobber operand, it is better to reload the\n-\t     another operand as an operand matching the earlyclobber\n-\t     operand can be also the same.  */\n-\t  if (first_conflict_j == last_conflict_j\n-\t      && operand_reg[last_conflict_j] != NULL_RTX\n-\t      && ! curr_alt_match_win[last_conflict_j]\n-\t      && REGNO (operand_reg[i]) == REGNO (operand_reg[last_conflict_j]))\n+\n+\t  /* If an earlyclobber operand conflicts with another non-matching\n+\t     operand (ie, they have been assigned the same hard register),\n+\t     then it is better to reload the other operand, as there may\n+\t     exist yet another operand with a matching constraint associated\n+\t     with the earlyclobber operand.  However, if one of the operands\n+\t     is an explicit use of a hard register, then we must reload the\n+\t     other non-hard register operand.  */\n+\t  if (HARD_REGISTER_P (operand_reg[i])\n+\t      || (first_conflict_j == last_conflict_j\n+\t\t  && operand_reg[last_conflict_j] != NULL_RTX\n+\t\t  && !curr_alt_match_win[last_conflict_j]\n+\t\t  && !HARD_REGISTER_P (operand_reg[last_conflict_j])))\n \t    {\n \t      curr_alt_win[last_conflict_j] = false;\n \t      curr_alt_dont_inherit_ops[curr_alt_dont_inherit_ops_num++]"}, {"sha": "4769e451d4c2fe8004f63511971b1e1e92471943", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "patch": "@@ -1,3 +1,10 @@\n+2018-11-08  Peter Bergner  <bergner@linux.ibm.com>\n+\n+\tPR rtl-optimization/87600\n+\t* gcc.dg/pr87600.h: New file.\n+\t* gcc.dg/pr87600-1.c: New test.\n+\t* gcc.dg/pr87600-2.c: Likewise.\n+\n 2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-c++-common/gomp/atomic-17.c: New test."}, {"sha": "351795756a31bb1be84206b574597fbf815c1245", "filename": "gcc/testsuite/gcc.dg/pr87600-1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87600-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87600-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87600-1.c?ref=2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "patch": "@@ -0,0 +1,52 @@\n+/* PR rtl-optimization/87600  */\n+/* { dg-do compile { target aarch64*-*-* arm*-*-* i?86-*-* powerpc*-*-* s390*-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include \"pr87600.h\"\n+\n+/* The following are all valid uses of local register variables.  */\n+\n+long\n+test0 (long arg)\n+{\n+  register long var asm (REG1);\n+  asm (\"blah %0 %1\" : \"+&r\" (var) : \"r\" (arg));\n+  return var;\n+}\n+\n+long\n+test1 (long arg0, long arg1)\n+{\n+  register long var asm (REG1);\n+  asm (\"blah %0, %1, %2\" : \"=&r\" (var) : \"r\" (arg0), \"0\" (arg1));\n+  return var + arg1;\n+}\n+\n+long\n+test2 (void)\n+{\n+  register long var1 asm (REG1);\n+  register long var2 asm (REG1);\n+  asm (\"blah %0 %1\" : \"=&r\" (var1) : \"0\" (var2));\n+  return var1;\n+}\n+\n+long\n+test3 (void)\n+{\n+  register long var1 asm (REG1);\n+  register long var2 asm (REG2);\n+  long var3;\n+  asm (\"blah %0 %1\" : \"=&r\" (var1), \"=r\" (var3) : \"1\" (var2));\n+  return var1 + var3;\n+}\n+\n+long\n+test4 (void)\n+{\n+  register long var1 asm (REG1);\n+  register long var2 asm (REG2);\n+  register long var3 asm (REG2);\n+  asm (\"blah %0 %1\" : \"=&r\" (var1), \"=r\" (var2) : \"1\" (var3));\n+  return var1;\n+}"}, {"sha": "e8a9f194b7333083958c00d724312801eb7f2c0e", "filename": "gcc/testsuite/gcc.dg/pr87600-2.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87600-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87600-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87600-2.c?ref=2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "patch": "@@ -0,0 +1,44 @@\n+/* PR rtl-optimization/87600  */\n+/* { dg-do compile { target aarch64*-*-* arm*-*-* i?86-*-* powerpc*-*-* s390*-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include \"pr87600.h\"\n+\n+/* The following are all invalid uses of local register variables.  */\n+\n+long\n+test0 (void)\n+{\n+  register long var1 asm (REG1);\n+  register long var2 asm (REG1);\n+  asm (\"blah %0 %1\" : \"=r\" (var1), \"=r\" (var2)); /* { dg-error \"invalid hard register usage between output operands\" } */\n+  return var1;\n+}\n+\n+long\n+test1 (void)\n+{\n+  register long var1 asm (REG1);\n+  register long var2 asm (REG2);\n+  asm (\"blah %0 %1\" : \"=r\" (var1) : \"0\" (var2)); /* { dg-error \"invalid hard register usage between output operand and matching constraint operand\" } */\n+  return var1;\n+}\n+\n+long\n+test2 (void)\n+{\n+  register long var1 asm (REG1);\n+  register long var2 asm (REG1);\n+  asm (\"blah %0 %1\" : \"=&r\" (var1) : \"r\" (var2)); /* { dg-error \"invalid hard register usage between earlyclobber operand and input operand\" } */\n+  return var1;\n+}\n+\n+long\n+test3 (void)\n+{\n+  register long var1 asm (REG1);\n+  register long var2 asm (REG1);\n+  long var3;\n+  asm (\"blah %0 %1\" : \"=&r\" (var1), \"=r\" (var3) : \"1\" (var2)); /* { dg-error \"invalid hard register usage between earlyclobber operand and input operand\" } */\n+  return var1 + var3;\n+}"}, {"sha": "5ebb9288e6fed0da24ac01717fa5e67abfd9193e", "filename": "gcc/testsuite/gcc.dg/pr87600.h", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87600.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f0b80c7a4ab4254f57ba63de26ebb7896e3742d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87600.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87600.h?ref=2f0b80c7a4ab4254f57ba63de26ebb7896e3742d", "patch": "@@ -0,0 +1,19 @@\n+#if defined (__aarch64__)\n+# define REG1 \"x0\"\n+# define REG2 \"x1\"\n+#elif defined (__arm__)\n+# define REG1 \"r0\"\n+# define REG2 \"r1\"\n+#elif defined (__i386__)\n+# define REG1 \"%eax\"\n+# define REG2 \"%edx\"\n+#elif defined (__powerpc__)\n+# define REG1 \"r3\"\n+# define REG2 \"r4\"\n+#elif defined (__s390__)\n+# define REG1 \"0\"\n+# define REG2 \"1\"\n+#elif defined (__x86_64__)\n+# define REG1 \"rax\"\n+# define REG2 \"rdx\"\n+#endif"}]}