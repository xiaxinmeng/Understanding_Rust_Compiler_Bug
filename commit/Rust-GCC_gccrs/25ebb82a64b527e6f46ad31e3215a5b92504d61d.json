{"sha": "25ebb82a64b527e6f46ad31e3215a5b92504d61d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlYmI4MmE2NGI1MjdlNmY0NmFkMzFlMzIxNWE1YjkyNTA0ZDYxZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-01-12T21:38:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-01-12T21:38:04Z"}, "message": "re PR rtl-optimization/10776 (Large aggregate initializers with a single relocated entry causes excessive compile time regression)\n\n        PR opt/10776\n        * typeck2.c (split_nonconstant_init_1, split_nonconstant_init): New.\n        (store_init_value): Use it.\n        * decl.c (check_initializer): Expect full initialization code\n        from store_init_value.\n        * init.c (expand_aggr_init_1): Likewise.\n        * decl2.c (maybe_emit_vtables): Abort if runtime init needed.\n\nFrom-SVN: r75763", "tree": {"sha": "4735db9e9cee85a6927d43897c4fcf385b6c978c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4735db9e9cee85a6927d43897c4fcf385b6c978c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25ebb82a64b527e6f46ad31e3215a5b92504d61d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25ebb82a64b527e6f46ad31e3215a5b92504d61d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25ebb82a64b527e6f46ad31e3215a5b92504d61d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25ebb82a64b527e6f46ad31e3215a5b92504d61d/comments", "author": null, "committer": null, "parents": [{"sha": "6b692ad7bd93797953906b93a72c8a6675e95112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b692ad7bd93797953906b93a72c8a6675e95112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b692ad7bd93797953906b93a72c8a6675e95112"}], "stats": {"total": 142, "additions": 131, "deletions": 11}, "files": [{"sha": "941176d855b40ff35bc0ddde9db1359d3f8f0c90", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ebb82a64b527e6f46ad31e3215a5b92504d61d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ebb82a64b527e6f46ad31e3215a5b92504d61d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=25ebb82a64b527e6f46ad31e3215a5b92504d61d", "patch": "@@ -1,3 +1,13 @@\n+2004-01-12  Richard Henderson  <rth@redhat.com>\n+\n+\tPR opt/10776\n+\t* typeck2.c (split_nonconstant_init_1, split_nonconstant_init): New.\n+\t(store_init_value): Use it.\n+\t* decl.c (check_initializer): Expect full initialization code\n+\tfrom store_init_value.\n+\t* init.c (expand_aggr_init_1): Likewise.\n+\t* decl2.c (maybe_emit_vtables): Abort if runtime init needed.\n+\n 2004-01-12  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (layout_class_type): For non-POD class types, also copy"}, {"sha": "9a830698bb6f3d24c475600423eae653d5538b4e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ebb82a64b527e6f46ad31e3215a5b92504d61d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ebb82a64b527e6f46ad31e3215a5b92504d61d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=25ebb82a64b527e6f46ad31e3215a5b92504d61d", "patch": "@@ -4395,6 +4395,7 @@ static tree\n check_initializer (tree decl, tree init, int flags, tree *cleanup)\n {\n   tree type = TREE_TYPE (decl);\n+  tree init_code = NULL;\n \n   /* If `start_decl' didn't like having an initialization, ignore it now.  */\n   if (init != NULL_TREE && DECL_INITIAL (decl) == NULL_TREE)\n@@ -4511,7 +4512,10 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \t{\n \tdont_use_constructor:\n \t  if (TREE_CODE (init) != TREE_VEC)\n-\t    init = store_init_value (decl, init);\n+\t    {\n+\t      init_code = store_init_value (decl, init);\n+\t      init = NULL;\n+\t    }\n \t}\n     }\n   else if (DECL_EXTERNAL (decl))\n@@ -4534,9 +4538,9 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n     check_for_uninitialized_const_var (decl);\n \n   if (init && init != error_mark_node)\n-    init = build (INIT_EXPR, type, decl, init);\n+    init_code = build (INIT_EXPR, type, decl, init);\n \n-  return init;\n+  return init_code;\n }\n \n /* If DECL is not a local variable, give it RTL.  */"}, {"sha": "ef8ea6e310c44b76fc6722c4fab90cf0a24fe32f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ebb82a64b527e6f46ad31e3215a5b92504d61d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ebb82a64b527e6f46ad31e3215a5b92504d61d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=25ebb82a64b527e6f46ad31e3215a5b92504d61d", "patch": "@@ -1605,7 +1605,11 @@ maybe_emit_vtables (tree ctype)\n \tcgraph_varpool_mark_needed_node (cgraph_varpool_node (vtbl));\n \n       if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)\n-\tstore_init_value (vtbl, DECL_INITIAL (vtbl));\n+\t{\n+\t  /* It had better be all done at compile-time.  */\n+\t  if (store_init_value (vtbl, DECL_INITIAL (vtbl)))\n+\t    abort ();\n+\t}\n \n       if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG)\n \t{"}, {"sha": "1dc5d9d145fb548988945d231da3888e6dddb0a3", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ebb82a64b527e6f46ad31e3215a5b92504d61d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ebb82a64b527e6f46ad31e3215a5b92504d61d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=25ebb82a64b527e6f46ad31e3215a5b92504d61d", "patch": "@@ -1272,8 +1272,9 @@ expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags)\n       /* If store_init_value returns NULL_TREE, the INIT has been\n \t record in the DECL_INITIAL for EXP.  That means there's\n \t nothing more we have to do.  */\n-      if (store_init_value (exp, init))\n-\tfinish_expr_stmt (build (INIT_EXPR, type, exp, init));\n+      init = store_init_value (exp, init);\n+      if (init)\n+\tfinish_expr_stmt (init);\n       return;\n     }\n "}, {"sha": "bad9b1e0ac2bd370fe04a8c0b8a91a49995af78f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 106, "deletions": 5, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ebb82a64b527e6f46ad31e3215a5b92504d61d/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ebb82a64b527e6f46ad31e3215a5b92504d61d/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=25ebb82a64b527e6f46ad31e3215a5b92504d61d", "patch": "@@ -284,6 +284,108 @@ cxx_incomplete_type_error (tree value, tree type)\n }\n \n \f\n+/* The recursive part of split_nonconstant_init.  DEST is an lvalue\n+   expression to which INIT should be assigned.  INIT is a CONSTRUCTOR.\n+   PCODE is a pointer to the tail of a chain of statements being emitted.\n+   The return value is the new tail of that chain after new statements\n+   are generated.  */\n+\n+static tree *\n+split_nonconstant_init_1 (tree dest, tree init, tree *pcode)\n+{\n+  tree *pelt, elt, type = TREE_TYPE (dest);\n+  tree sub, code, inner_type = NULL;\n+  bool array_type_p = false;\n+\n+  pelt = &CONSTRUCTOR_ELTS (init);\n+  switch (TREE_CODE (type))\n+    {\n+    case ARRAY_TYPE:\n+      inner_type = TREE_TYPE (type);\n+      array_type_p = true;\n+      /* FALLTHRU */\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      while ((elt = *pelt))\n+\t{\n+\t  tree field_index = TREE_PURPOSE (elt);\n+\t  tree value = TREE_VALUE (elt);\n+\n+\t  if (!array_type_p)\n+\t    inner_type = TREE_TYPE (field_index);\n+\n+\t  if (TREE_CODE (value) == CONSTRUCTOR)\n+\t    {\n+\t      if (array_type_p)\n+\t        sub = build (ARRAY_REF, inner_type, dest, field_index);\n+\t      else\n+\t        sub = build (COMPONENT_REF, inner_type, dest, field_index);\n+\n+\t      pcode = split_nonconstant_init_1 (sub, value, pcode);\n+\t    }\n+\t  else if (!initializer_constant_valid_p (value, inner_type))\n+\t    {\n+\t      *pelt = TREE_CHAIN (elt);\n+\n+\t      if (array_type_p)\n+\t        sub = build (ARRAY_REF, inner_type, dest, field_index);\n+\t      else\n+\t        sub = build (COMPONENT_REF, inner_type, dest, field_index);\n+\n+\t      code = build (MODIFY_EXPR, inner_type, sub, value);\n+\t      code = build_stmt (EXPR_STMT, code);\n+\n+\t      *pcode = code;\n+\t      pcode = &TREE_CHAIN (code);\n+\t      continue;\n+\t    }\n+\t  pelt = &TREE_CHAIN (elt);\n+\t}\n+      break;\n+\n+    case VECTOR_TYPE:\n+      if (!initializer_constant_valid_p (init, type))\n+\t{\n+\t  CONSTRUCTOR_ELTS (init) = NULL;\n+\t  code = build (MODIFY_EXPR, type, dest, init);\n+\t  code = build_stmt (EXPR_STMT, code);\n+\t  pcode = &TREE_CHAIN (code);\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return pcode;\n+}\n+\n+/* A subroutine of store_init_value.  Splits non-constant static \n+   initializer INIT into a constant part and generates code to\n+   perform the non-constant part of the initialization to DEST.\n+   Returns the code for the runtime init.  */\n+\n+static tree\n+split_nonconstant_init (tree dest, tree init)\n+{\n+  tree code;\n+\n+  if (TREE_CODE (init) == CONSTRUCTOR)\n+    {\n+      code = build_stmt (COMPOUND_STMT, NULL_TREE);\n+      split_nonconstant_init_1 (dest, init, &COMPOUND_BODY (code));\n+      code = build1 (STMT_EXPR, void_type_node, code);\n+      TREE_SIDE_EFFECTS (code) = 1;\n+      DECL_INITIAL (dest) = init;\n+    }\n+  else\n+    code = build (INIT_EXPR, TREE_TYPE (dest), dest, init);\n+\n+  return code;\n+}\n+\n /* Perform appropriate conversions on the initial value of a variable,\n    store it in the declaration DECL,\n    and print any error messages that are appropriate.\n@@ -299,9 +401,8 @@ cxx_incomplete_type_error (tree value, tree type)\n    into a CONSTRUCTOR and use standard initialization techniques.\n    Perhaps a warning should be generated?\n \n-   Returns value of initializer if initialization could not be\n-   performed for static variable.  In that case, caller must do\n-   the storing.  */\n+   Returns code to be executed if initialization could not be performed\n+   for static variable.  In that case, caller must emit the code.  */\n \n tree\n store_init_value (tree decl, tree init)\n@@ -356,11 +457,11 @@ store_init_value (tree decl, tree init)\n      constructing never make it into DECL_INITIAL, and passes 'init' to\n      build_aggr_init without checking DECL_INITIAL.  So just return.  */\n   else if (TYPE_NEEDS_CONSTRUCTING (type))\n-    return value;\n+    return build (INIT_EXPR, type, decl, value);\n   else if (TREE_STATIC (decl)\n \t   && (! TREE_CONSTANT (value)\n \t       || ! initializer_constant_valid_p (value, TREE_TYPE (value))))\n-    return value;\n+    return split_nonconstant_init (decl, value);\n   \n   /* Store the VALUE in DECL_INITIAL.  If we're building a\n      statement-tree we will actually expand the initialization later"}]}