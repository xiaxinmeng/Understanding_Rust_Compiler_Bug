{"sha": "127abeb2e8448b2932bd52245f055d0c5c4b44a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI3YWJlYjJlODQ0OGIyOTMyYmQ1MjI0NWYwNTVkMGM1YzRiNDRhMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-29T10:51:03Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-29T10:51:03Z"}, "message": "arm: Fix parameter passing for [[no_unique_address]]\n\nThis patch makes the ABI code ignore zero-sized [[no_unique_address]]\nfields when deciding whether something is a HFA or HVA.\n\nFor the tests, I wanted an -march setting that was stable enough\nto use check-function-bodies and also wanted to force -mfloat-abi=hard.\nI couldn't see any existing way of doing both together, since most\narm-related effective-target keywords are agnostic about the choice\nbetween -mfloat-abi=softfp and -mfloat-abi=hard.  I therefore added\na new effective-target keyword for this combination.\n\nI used the arm_arch_* framework for the effective-target rather than\nwriting a new set of custom Tcl routines.  This has the nice property\nof separating the \"compile and assemble\" cases from the \"link and run\"\ncases.  I only need compilation to work for the new tests, so requiring\nlinking to work would be an unnecessary restriction.\n\nHowever, including an ABI requirement is arguably stretching what the\nlist was originally intended to handle.  The name arm_arch_v8a_hard\ndoesn't fit very naturally with some of the NEON-based tests.\nOn the other hand, the naming convention isn't entirely consistent,\nso any choice would be inconsistent with something.\n\n2020-04-29  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* doc/sourcebuild.texi (arm_arch_v8a_hard_ok): Document new\n\teffective-target keyword.\n\t(arm_arch_v8a_hard_multilib): Likewise.\n\t(arm_arch_v8a_hard): Document new dg-add-options keyword.\n\t* config/arm/arm.c (arm_return_in_memory): Note that the APCS\n\tcode is deprecated and has not been updated to handle\n\tDECL_FIELD_ABI_IGNORED.\n\t(WARN_PSABI_EMPTY_CXX17_BASE): New constant.\n\t(WARN_PSABI_NO_UNIQUE_ADDRESS): Likewise.\n\t(aapcs_vfp_sub_candidate): Replace the boolean pointer parameter\n\tavoid_cxx17_empty_base with a pointer to a bitmask.  Ignore fields\n\twhose DECL_FIELD_ABI_IGNORED bit is set when determining whether\n\tsomething actually is a HFA or HVA.  Record whether we see a\n\t[[no_unique_address]] field that previous GCCs would not have\n\tignored in this way.\n\t(aapcs_vfp_is_call_or_return_candidate): Update the calls to\n\taapcs_vfp_sub_candidate and report a -Wpsabi warning for the\n\t[[no_unique_address]] case.  Use TYPE_MAIN_VARIANT in the\n\tdiagnostic messages.\n\t(arm_needs_doubleword_align): Add a comment explaining why we\n\tconsider even zero-sized fields.\n\ngcc/testsuite/\n\t* lib/target-supports.exp: Add v8a_hard to the list of arm_arch_*\n\ttargets.\n\t* g++.target/arm/no_unique_address_1.C: New test.\n\t* g++.target/arm/no_unique_address_2.C: Likewise.", "tree": {"sha": "9b2e9dec0c4e3a269acb3ba4214fb109b5429fef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b2e9dec0c4e3a269acb3ba4214fb109b5429fef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/127abeb2e8448b2932bd52245f055d0c5c4b44a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/127abeb2e8448b2932bd52245f055d0c5c4b44a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/127abeb2e8448b2932bd52245f055d0c5c4b44a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/127abeb2e8448b2932bd52245f055d0c5c4b44a0/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6e616074f02b81c397a2848ab242b54ef21efbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6e616074f02b81c397a2848ab242b54ef21efbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6e616074f02b81c397a2848ab242b54ef21efbc"}], "stats": {"total": 557, "additions": 529, "deletions": 28}, "files": [{"sha": "7a04f1f4191925497c8acf3d84acd7f37bf70c3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=127abeb2e8448b2932bd52245f055d0c5c4b44a0", "patch": "@@ -1,3 +1,27 @@\n+2020-04-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/sourcebuild.texi (arm_arch_v8a_hard_ok): Document new\n+\teffective-target keyword.\n+\t(arm_arch_v8a_hard_multilib): Likewise.\n+\t(arm_arch_v8a_hard): Document new dg-add-options keyword.\n+\t* config/arm/arm.c (arm_return_in_memory): Note that the APCS\n+\tcode is deprecated and has not been updated to handle\n+\tDECL_FIELD_ABI_IGNORED.\n+\t(WARN_PSABI_EMPTY_CXX17_BASE): New constant.\n+\t(WARN_PSABI_NO_UNIQUE_ADDRESS): Likewise.\n+\t(aapcs_vfp_sub_candidate): Replace the boolean pointer parameter\n+\tavoid_cxx17_empty_base with a pointer to a bitmask.  Ignore fields\n+\twhose DECL_FIELD_ABI_IGNORED bit is set when determining whether\n+\tsomething actually is a HFA or HVA.  Record whether we see a\n+\t[[no_unique_address]] field that previous GCCs would not have\n+\tignored in this way.\n+\t(aapcs_vfp_is_call_or_return_candidate): Update the calls to\n+\taapcs_vfp_sub_candidate and report a -Wpsabi warning for the\n+\t[[no_unique_address]] case.  Use TYPE_MAIN_VARIANT in the\n+\tdiagnostic messages.\n+\t(arm_needs_doubleword_align): Add a comment explaining why we\n+\tconsider even zero-sized fields.\n+\n 2020-04-29  Richard Biener  <rguenther@suse.de>\n \t    Li Zekun  <lizekun1@huawei.com>\n "}, {"sha": "dcaae7bf7aae4057bf4feab06c0d35fd3258181a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 80, "deletions": 28, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=127abeb2e8448b2932bd52245f055d0c5c4b44a0", "patch": "@@ -5963,6 +5963,8 @@ arm_return_in_memory (const_tree type, const_tree fntype)\n \n       /* Find the first field, ignoring non FIELD_DECL things which will\n \t have been created by C++.  */\n+      /* NOTE: This code is deprecated and has not been updated to handle\n+\t DECL_FIELD_ABI_IGNORED.  */\n       for (field = TYPE_FIELDS (type);\n \t   field && TREE_CODE (field) != FIELD_DECL;\n \t   field = DECL_CHAIN (field))\n@@ -6135,23 +6137,42 @@ aapcs_vfp_cum_init (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,\n   pcum->aapcs_vfp_reg_alloc = 0;\n }\n \n+/* Bitmasks that indicate whether earlier versions of GCC would have\n+   taken a different path through the ABI logic.  This should result in\n+   a -Wpsabi warning if the earlier path led to a different ABI decision.\n+\n+   WARN_PSABI_EMPTY_CXX17_BASE\n+      Indicates that the type includes an artificial empty C++17 base field\n+      that, prior to GCC 10.1, would prevent the type from being treated as\n+      a HFA or HVA.  See PR94711 for details.\n+\n+   WARN_PSABI_NO_UNIQUE_ADDRESS\n+      Indicates that the type includes an empty [[no_unique_address]] field\n+      that, prior to GCC 10.1, would prevent the type from being treated as\n+      a HFA or HVA.  */\n+const unsigned int WARN_PSABI_EMPTY_CXX17_BASE = 1U << 0;\n+const unsigned int WARN_PSABI_NO_UNIQUE_ADDRESS = 1U << 1;\n+\n /* Walk down the type tree of TYPE counting consecutive base elements.\n    If *MODEP is VOIDmode, then set it to the first valid floating point\n    type.  If a non-floating point type is found, or if a floating point\n    type that doesn't match a non-VOIDmode *MODEP is found, then return -1,\n    otherwise return the count in the sub-tree.\n \n-   The AVOID_CXX17_EMPTY_BASE argument is to allow the caller to check whether\n-   this function has changed its behavior after the fix for PR94384 -- this fix\n-   is to avoid artificial fields in empty base classes.\n-   When called with this argument as a NULL pointer this function does not\n-   avoid the artificial fields -- this is useful to check whether the function\n-   returns something different after the fix.\n-   When called pointing at a value, this function avoids such artificial fields\n-   and sets the value to TRUE when one of these fields has been set.  */\n+   The WARN_PSABI_FLAGS argument allows the caller to check whether this\n+   function has changed its behavior relative to earlier versions of GCC.\n+   Normally the argument should be nonnull and point to a zero-initialized\n+   variable.  The function then records whether the ABI decision might\n+   be affected by a known fix to the ABI logic, setting the associated\n+   WARN_PSABI_* bits if so.\n+\n+   When the argument is instead a null pointer, the function tries to\n+   simulate the behavior of GCC before all such ABI fixes were made.\n+   This is useful to check whether the function returns something\n+   different after the ABI fixes.  */\n static int\n aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,\n-\t\t\t bool *avoid_cxx17_empty_base)\n+\t\t\t unsigned int *warn_psabi_flags)\n {\n   machine_mode mode;\n   HOST_WIDE_INT size;\n@@ -6224,7 +6245,7 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,\n \t  return -1;\n \n \tcount = aapcs_vfp_sub_candidate (TREE_TYPE (type), modep,\n-\t\t\t\t\t avoid_cxx17_empty_base);\n+\t\t\t\t\t warn_psabi_flags);\n \tif (count == -1\n \t    || !index\n \t    || !TYPE_MAX_VALUE (index)\n@@ -6262,20 +6283,30 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,\n \t    if (TREE_CODE (field) != FIELD_DECL)\n \t      continue;\n \n-\t    /* Ignore C++17 empty base fields, while their type indicates they\n-\t       contain padding, this is only sometimes contributed to the derived\n-\t       class.\n-\t       When the padding is contributed to the derived class that's\n-\t       caught by the general test for padding below.  */\n-\t    if (cxx17_empty_base_field_p (field)\n-\t\t&& avoid_cxx17_empty_base)\n+\t    if (DECL_FIELD_ABI_IGNORED (field))\n \t      {\n-\t\t*avoid_cxx17_empty_base = true;\n-\t\tcontinue;\n+\t\t/* See whether this is something that earlier versions of\n+\t\t   GCC failed to ignore.  */\n+\t\tunsigned int flag;\n+\t\tif (lookup_attribute (\"no_unique_address\",\n+\t\t\t\t      DECL_ATTRIBUTES (field)))\n+\t\t  flag = WARN_PSABI_NO_UNIQUE_ADDRESS;\n+\t\telse if (cxx17_empty_base_field_p (field))\n+\t\t  flag = WARN_PSABI_EMPTY_CXX17_BASE;\n+\t\telse\n+\t\t  /* No compatibility problem.  */\n+\t\t  continue;\n+\n+\t\t/* Simulate the old behavior when WARN_PSABI_FLAGS is null.  */\n+\t\tif (warn_psabi_flags)\n+\t\t  {\n+\t\t    *warn_psabi_flags |= flag;\n+\t\t    continue;\n+\t\t  }\n \t      }\n \n \t    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep,\n-\t\t\t\t\t\t avoid_cxx17_empty_base);\n+\t\t\t\t\t\t warn_psabi_flags);\n \t    if (sub_count < 0)\n \t      return -1;\n \t    count += sub_count;\n@@ -6309,7 +6340,7 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,\n \t      continue;\n \n \t    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep,\n-\t\t\t\t\t\t avoid_cxx17_empty_base);\n+\t\t\t\t\t\t warn_psabi_flags);\n \t    if (sub_count < 0)\n \t      return -1;\n \t    count = count > sub_count ? count : sub_count;\n@@ -6371,24 +6402,32 @@ aapcs_vfp_is_call_or_return_candidate (enum arm_pcs pcs_variant,\n      out from the mode.  */\n   if (type)\n     {\n-      bool avoided = false;\n-      int ag_count = aapcs_vfp_sub_candidate (type, &new_mode, &avoided);\n+      unsigned int warn_psabi_flags = 0;\n+      int ag_count = aapcs_vfp_sub_candidate (type, &new_mode,\n+\t\t\t\t\t      &warn_psabi_flags);\n       if (ag_count > 0 && ag_count <= 4)\n \t{\n \t  static unsigned last_reported_type_uid;\n \t  unsigned uid = TYPE_UID (TYPE_MAIN_VARIANT (type));\n \t  int alt;\n \t  if (warn_psabi\n-\t      && avoided\n+\t      && warn_psabi_flags\n \t      && uid != last_reported_type_uid\n \t      && ((alt = aapcs_vfp_sub_candidate (type, &new_mode, NULL))\n \t\t  != ag_count))\n \t    {\n \t      gcc_assert (alt == -1);\n \t      last_reported_type_uid = uid;\n-\t      inform (input_location, \"parameter passing for argument of type \"\n-\t\t      \"%qT when C++17 is enabled changed to match C++14 \"\n-\t\t      \"in GCC 10.1\", type);\n+\t      /* Use TYPE_MAIN_VARIANT to strip any redundant const\n+\t\t qualification.  */\n+\t      if (warn_psabi_flags & WARN_PSABI_NO_UNIQUE_ADDRESS)\n+\t\tinform (input_location, \"parameter passing for argument of \"\n+\t\t\t\"type %qT with %<[[no_unique_address]]%> members \"\n+\t\t\t\"changed in GCC 10.1\", TYPE_MAIN_VARIANT (type));\n+\t      else if (warn_psabi_flags & WARN_PSABI_EMPTY_CXX17_BASE)\n+\t\tinform (input_location, \"parameter passing for argument of \"\n+\t\t\t\"type %qT when C++17 is enabled changed to match \"\n+\t\t\t\"C++14 in GCC 10.1\", TYPE_MAIN_VARIANT (type));\n \t    }\n \t  *count = ag_count;\n \t}\n@@ -6933,7 +6972,20 @@ arm_needs_doubleword_align (machine_mode mode, const_tree type)\n \n   int ret = 0;\n   int ret2 = 0;\n-  /* Record/aggregate types: Use greatest member alignment of any member.  */\n+  /* Record/aggregate types: Use greatest member alignment of any member.\n+\n+     Note that we explicitly consider zero-sized fields here, even though\n+     they don't map to AAPCS machine types.  For example, in:\n+\n+\t struct __attribute__((aligned(8))) empty {};\n+\n+\t struct s {\n+\t   [[no_unique_address]] empty e;\n+\t   int x;\n+\t };\n+\n+     \"s\" contains only one Fundamental Data Type (the int field)\n+     but gains 8-byte alignment and size thanks to \"e\".  */\n   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     if (DECL_ALIGN (field) > PARM_BOUNDARY)\n       {"}, {"sha": "d8da77d5ba468b0b5e51174d9e06eef29c433894", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=127abeb2e8448b2932bd52245f055d0c5c4b44a0", "patch": "@@ -1829,6 +1829,16 @@ Some multilibs may be incompatible with these options.\n ARM target supports @code{-mfpu=vfp3 -mfloat-abi=softfp}.\n Some multilibs may be incompatible with these options.\n \n+@item arm_arch_v8a_hard_ok\n+The compiler is targeting @code{arm*-*-*} and can compile and assemble code\n+using the options @code{-march=armv8-a -mfpu=neon-fp-armv8 -mfloat-abi=hard}.\n+This is not enough to guarantee that linking works.\n+\n+@item arm_arch_v8a_hard_multilib\n+The compiler is targeting @code{arm*-*-*} and can build programs using\n+the options @code{-march=armv8-a -mfpu=neon-fp-armv8 -mfloat-abi=hard}.\n+The target can also run the resulting binaries.\n+\n @item arm_v8_vfp_ok\n ARM target supports @code{-mfpu=fp-armv8 -mfloat-abi=softfp}.\n Some multilibs may be incompatible with these options.\n@@ -2586,6 +2596,11 @@ the @ref{arm_neon_fp16_ok,,arm_neon_fp16_ok effective target keyword}.\n arm vfp3 floating point support; see\n the @ref{arm_vfp3_ok,,arm_vfp3_ok effective target keyword}.\n \n+@item arm_arch_v8a_hard\n+Add options for ARMv8-A and the hard-float variant of the AAPCS,\n+if this is supported by the compiler; see the\n+@ref{arm_arch_v8a_hard_ok,,arm_arch_v8a_hard_ok} effective target keyword.\n+\n @item arm_v8_1a_neon\n Add options for ARMv8.1-A with Adv.SIMD support, if this is supported\n by the target; see the @ref{arm_v8_1a_neon_ok,,arm_v8_1a_neon_ok}"}, {"sha": "b4d1ee2b8c21784a35c658f1abcca49678696fec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=127abeb2e8448b2932bd52245f055d0c5c4b44a0", "patch": "@@ -1,3 +1,10 @@\n+2020-04-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* lib/target-supports.exp: Add v8a_hard to the list of arm_arch_*\n+\ttargets.\n+\t* g++.target/arm/no_unique_address_1.C: New test.\n+\t* g++.target/arm/no_unique_address_2.C: Likewise.\n+\n 2020-04-29  Richard Biener  <rguenther@suse.de>\n \t    Li Zekun  <lizekun1@huawei.com>\n "}, {"sha": "038aa00a499e9f590a9df41f10d71f53eef737ac", "filename": "gcc/testsuite/g++.target/arm/no_unique_address_1.C", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fno_unique_address_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fno_unique_address_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fno_unique_address_1.C?ref=127abeb2e8448b2932bd52245f055d0c5c4b44a0", "patch": "@@ -0,0 +1,201 @@\n+/* { dg-require-effective-target arm_arch_v8a_hard_ok } */\n+/* { dg-options \"-std=c++11 -O -foptimize-sibling-calls\" } */\n+/* { dg-add-options arm_arch_v8a_hard } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+struct X { };\n+struct Y { int : 0; };\n+struct Z { int : 0; Y y; };\n+struct W : public X { X q; };\n+\n+struct A { float a; };\n+\n+struct B : public X { float a; };\n+struct C : public Y { float a; };\n+struct D : public Z { float a; };\n+struct E : public W { float a; };\n+\n+struct F { [[no_unique_address]] X x; float a; };\n+struct G { [[no_unique_address]] Y y; float a; };\n+struct H { [[no_unique_address]] Z z; float a; };\n+struct I { [[no_unique_address]] W w; float a; };\n+\n+struct J { float a; [[no_unique_address]] X x; float b; };\n+struct K { float a; [[no_unique_address]] Y y; float b; };\n+struct L { float a; [[no_unique_address]] Z z; float b; };\n+struct M { float a; [[no_unique_address]] W w; float b; };\n+\n+struct N : public A { float b; };\n+struct O { [[no_unique_address]] A a; float b; };\n+\n+struct P : public Y { int : 0; float a, b, c, d; };\n+\n+union Q { X x; float a; };\n+union R { [[no_unique_address]] X x; float a; };\n+\n+union S { A a; float b; };\n+union T { F f; float b; };\n+union U { N n; O o; };\n+\n+typedef S Salias;\n+typedef T Talias;\n+typedef U Ualias;\n+\n+#define T(S, s) extern int callee_##s (S)\n+\n+/*\n+** _Z8caller_aR1A:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (A, a); int caller_a (A &a) { return callee_a (a); } /* { dg-bogus {argument of type 'A'} } */\n+\n+/*\n+** _Z8caller_bR1B:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (B, b); int caller_b (B &b) { return callee_b (b); } /* { dg-bogus {argument of type 'B'} } */\n+\n+/*\n+** _Z8caller_cR1C:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (C, c); int caller_c (C &c) { return callee_c (c); } /* { dg-bogus {argument of type 'C'} } */\n+\n+/*\n+** _Z8caller_dR1D:\n+**\tldm\tr0, {r0, r1}\n+**\tb\t.*\n+*/\n+T (D, d); int caller_d (D &d) { return callee_d (d); } /* { dg-bogus {argument of type 'D'} } */\n+\n+/*\n+** _Z8caller_eR1E:\n+**\tldm\tr0, {r0, r1}\n+**\tb\t.*\n+*/\n+T (E, e); int caller_e (E &e) { return callee_e (e); } /* { dg-bogus {argument of type 'E'} } */\n+\n+/*\n+** _Z8caller_fR1F:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (F, f); int caller_f (F &f) { return callee_f (f); } /* { dg-message {parameter passing for argument of type 'F' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_gR1G:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (G, g); int caller_g (G &g) { return callee_g (g); } /* { dg-message {parameter passing for argument of type 'G' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_hR1H:\n+**\tldm\tr0, {r0, r1}\n+**\tb\t.*\n+*/\n+T (H, h); int caller_h (H &h) { return callee_h (h); } /* { dg-bogus {argument of type 'H'} } */\n+\n+/*\n+** _Z8caller_iR1I:\n+**\tldm\tr0, {r0, r1}\n+**\tb\t.*\n+*/\n+T (I, i); int caller_i (I &i) { return callee_i (i); } /* { dg-bogus {argument of type 'I'} } */\n+\n+/*\n+** _Z8caller_jR1J:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tb\t.*\n+*/\n+T (J, j); int caller_j (J &j) { return callee_j (j); } /* { dg-message {parameter passing for argument of type 'J' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_kR1K:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tb\t.*\n+*/\n+T (K, k); int caller_k (K &k) { return callee_k (k); } /* { dg-message {parameter passing for argument of type 'K' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_lR1L:\n+**\tldm\tr0, {r0, r1, r2}\n+**\tb\t.*\n+*/\n+T (L, l); int caller_l (L &l) { return callee_l (l); } /* { dg-bogus {argument of type 'L'} } */\n+\n+/*\n+** _Z8caller_mR1M:\n+**\tldm\tr0, {r0, r1, r2}\n+**\tb\t.*\n+*/\n+T (M, m); int caller_m (M &m) { return callee_m (m); } /* { dg-bogus {argument of type 'M'} } */\n+\n+/*\n+** _Z8caller_nR1N:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tb\t.*\n+*/\n+T (N, n); int caller_n (N &n) { return callee_n (n); } /* { dg-bogus {argument of type 'N'} } */\n+\n+/*\n+** _Z8caller_oR1O:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tb\t.*\n+*/\n+T (O, o); int caller_o (O &o) { return callee_o (o); } /* { dg-bogus {argument of type 'O'} } */\n+\n+/*\n+** _Z8caller_pR1P:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tvldr.32\ts2, \\[r0, #8\\]\n+**\tvldr.32\ts3, \\[r0, #12\\]\n+**\tb\t.*\n+*/\n+T (P, p); int caller_p (P &p) { return callee_p (p); } /* { dg-bogus {argument of type 'P'} } */\n+\n+/*\n+** _Z8caller_qR1Q:\n+**\tldr\tr0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (Q, q); int caller_q (Q &q) { return callee_q (q); } /* { dg-bogus {argument of type 'Q'} } */\n+\n+/*\n+** _Z8caller_rR1R:\n+**\tldr\tr0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (R, r); int caller_r (R &r) { return callee_r (r); } /* { dg-bogus {argument of type 'R'} } */\n+\n+/*\n+** _Z8caller_sR1S:\n+**\tvldr.32\ts0, \\[r0\\]\t@ int\n+**\tb\t.*\n+*/\n+T (Salias, s); int caller_s (Salias &s) { return callee_s (s); } /* { dg-bogus {argument of type 'S'} } */\n+\n+/*\n+** _Z8caller_tR1T:\n+**\tvldr.32\ts0, \\[r0\\]\t@ int\n+**\tb\t.*\n+*/\n+T (Talias, t); int caller_t (Talias &t) { return callee_t (t); } /* { dg-message {parameter passing for argument of type 'T' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_uR1U:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tb\t.*\n+*/\n+T (Ualias, u); int caller_u (Ualias &u) { return callee_u (u); } /* { dg-bogus {argument of type 'U'} } */\n+\n+/* { dg-bogus {argument of type 'const} \"should not be printed as const\" { target *-*-*} 0 } */"}, {"sha": "8be5de2539a38ae6f6f539e93b4d4ace7654b60a", "filename": "gcc/testsuite/g++.target/arm/no_unique_address_2.C", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fno_unique_address_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fno_unique_address_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fno_unique_address_2.C?ref=127abeb2e8448b2932bd52245f055d0c5c4b44a0", "patch": "@@ -0,0 +1,201 @@\n+/* { dg-require-effective-target arm_arch_v8a_hard_ok } */\n+/* { dg-options \"-std=c++17 -O -foptimize-sibling-calls\" } */\n+/* { dg-add-options arm_arch_v8a_hard } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+struct X { };\n+struct Y { int : 0; };\n+struct Z { int : 0; Y y; };\n+struct W : public X { X q; };\n+\n+struct A { float a; };\n+\n+struct B : public X { float a; };\n+struct C : public Y { float a; };\n+struct D : public Z { float a; };\n+struct E : public W { float a; };\n+\n+struct F { [[no_unique_address]] X x; float a; };\n+struct G { [[no_unique_address]] Y y; float a; };\n+struct H { [[no_unique_address]] Z z; float a; };\n+struct I { [[no_unique_address]] W w; float a; };\n+\n+struct J { float a; [[no_unique_address]] X x; float b; };\n+struct K { float a; [[no_unique_address]] Y y; float b; };\n+struct L { float a; [[no_unique_address]] Z z; float b; };\n+struct M { float a; [[no_unique_address]] W w; float b; };\n+\n+struct N : public A { float b; };\n+struct O { [[no_unique_address]] A a; float b; };\n+\n+struct P : public Y { int : 0; float a, b, c, d; };\n+\n+union Q { X x; float a; };\n+union R { [[no_unique_address]] X x; float a; };\n+\n+union S { A a; float b; };\n+union T { F f; float b; };\n+union U { N n; O o; };\n+\n+typedef S Salias;\n+typedef T Talias;\n+typedef U Ualias;\n+\n+#define T(S, s) extern int callee_##s (S)\n+\n+/*\n+** _Z8caller_aR1A:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (A, a); int caller_a (A &a) { return callee_a (a); } /* { dg-bogus {argument of type 'A'} } */\n+\n+/*\n+** _Z8caller_bR1B:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (B, b); int caller_b (B &b) { return callee_b (b); } /* { dg-message {parameter passing for argument of type 'B' when C\\+\\+17 is enabled changed to match C\\+\\+14 in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_cR1C:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (C, c); int caller_c (C &c) { return callee_c (c); } /* { dg-message {parameter passing for argument of type 'C' when C\\+\\+17 is enabled changed to match C\\+\\+14 in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_dR1D:\n+**\tldm\tr0, {r0, r1}\n+**\tb\t.*\n+*/\n+T (D, d); int caller_d (D &d) { return callee_d (d); } /* { dg-bogus {argument of type 'D'} } */\n+\n+/*\n+** _Z8caller_eR1E:\n+**\tldm\tr0, {r0, r1}\n+**\tb\t.*\n+*/\n+T (E, e); int caller_e (E &e) { return callee_e (e); } /* { dg-bogus {argument of type 'E'} } */\n+\n+/*\n+** _Z8caller_fR1F:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (F, f); int caller_f (F &f) { return callee_f (f); } /* { dg-message {parameter passing for argument of type 'F' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_gR1G:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (G, g); int caller_g (G &g) { return callee_g (g); } /* { dg-message {parameter passing for argument of type 'G' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_hR1H:\n+**\tldm\tr0, {r0, r1}\n+**\tb\t.*\n+*/\n+T (H, h); int caller_h (H &h) { return callee_h (h); } /* { dg-bogus {argument of type 'H'} } */\n+\n+/*\n+** _Z8caller_iR1I:\n+**\tldm\tr0, {r0, r1}\n+**\tb\t.*\n+*/\n+T (I, i); int caller_i (I &i) { return callee_i (i); } /* { dg-bogus {argument of type 'I'} } */\n+\n+/*\n+** _Z8caller_jR1J:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tb\t.*\n+*/\n+T (J, j); int caller_j (J &j) { return callee_j (j); } /* { dg-message {parameter passing for argument of type 'J' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_kR1K:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tb\t.*\n+*/\n+T (K, k); int caller_k (K &k) { return callee_k (k); } /* { dg-message {parameter passing for argument of type 'K' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_lR1L:\n+**\tldm\tr0, {r0, r1, r2}\n+**\tb\t.*\n+*/\n+T (L, l); int caller_l (L &l) { return callee_l (l); } /* { dg-bogus {argument of type 'L'} } */\n+\n+/*\n+** _Z8caller_mR1M:\n+**\tldm\tr0, {r0, r1, r2}\n+**\tb\t.*\n+*/\n+T (M, m); int caller_m (M &m) { return callee_m (m); } /* { dg-bogus {argument of type 'M'} } */\n+\n+/*\n+** _Z8caller_nR1N:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tb\t.*\n+*/\n+T (N, n); int caller_n (N &n) { return callee_n (n); } /* { dg-bogus {argument of type 'N'} } */\n+\n+/*\n+** _Z8caller_oR1O:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tb\t.*\n+*/\n+T (O, o); int caller_o (O &o) { return callee_o (o); } /* { dg-bogus {argument of type 'O'} } */\n+\n+/*\n+** _Z8caller_pR1P:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tvldr.32\ts2, \\[r0, #8\\]\n+**\tvldr.32\ts3, \\[r0, #12\\]\n+**\tb\t.*\n+*/\n+T (P, p); int caller_p (P &p) { return callee_p (p); } /* { dg-message {parameter passing for argument of type 'P' when C\\+\\+17 is enabled changed to match C\\+\\+14 in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_qR1Q:\n+**\tldr\tr0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (Q, q); int caller_q (Q &q) { return callee_q (q); } /* { dg-bogus {argument of type 'Q'} } */\n+\n+/*\n+** _Z8caller_rR1R:\n+**\tldr\tr0, \\[r0\\]\n+**\tb\t.*\n+*/\n+T (R, r); int caller_r (R &r) { return callee_r (r); } /* { dg-bogus {argument of type 'R'} } */\n+\n+/*\n+** _Z8caller_sR1S:\n+**\tvldr.32\ts0, \\[r0\\]\t@ int\n+**\tb\t.*\n+*/\n+T (Salias, s); int caller_s (Salias &s) { return callee_s (s); } /* { dg-bogus {argument of type 'S'} } */\n+\n+/*\n+** _Z8caller_tR1T:\n+**\tvldr.32\ts0, \\[r0\\]\t@ int\n+**\tb\t.*\n+*/\n+T (Talias, t); int caller_t (Talias &t) { return callee_t (t); } /* { dg-message {parameter passing for argument of type 'T' with '\\[\\[no_unique_address\\]\\]' members changed in GCC 10.1} } */\n+\n+/*\n+** _Z8caller_uR1U:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tvldr.32\ts1, \\[r0, #4\\]\n+**\tb\t.*\n+*/\n+T (Ualias, u); int caller_u (Ualias &u) { return callee_u (u); } /* { dg-bogus {argument of type 'U'} } */\n+\n+/* { dg-bogus {argument of type 'const} \"should not be printed as const\" { target *-*-*} 0 } */"}, {"sha": "13761491e6399e04335d7c00185842ebeb92320f", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/127abeb2e8448b2932bd52245f055d0c5c4b44a0/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=127abeb2e8448b2932bd52245f055d0c5c4b44a0", "patch": "@@ -4443,6 +4443,7 @@ foreach { armfunc armflag armdefs } {\n \tv7ve \"-march=armv7ve -marm\"\n \t\t\"__ARM_ARCH_7A__ && __ARM_FEATURE_IDIV\"\n \tv8a \"-march=armv8-a\" __ARM_ARCH_8A__\n+\tv8a_hard \"-march=armv8-a -mfpu=neon-fp-armv8 -mfloat-abi=hard\" __ARM_ARCH_8A__\n \tv8_1a \"-march=armv8.1-a\" __ARM_ARCH_8A__\n \tv8_2a \"-march=armv8.2-a\" __ARM_ARCH_8A__\n \tv8r \"-march=armv8-r\" __ARM_ARCH_8R__"}]}