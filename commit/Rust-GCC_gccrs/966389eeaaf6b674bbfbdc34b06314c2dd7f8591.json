{"sha": "966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY2Mzg5ZWVhYWY2YjY3NGJiZmJkYzM0YjA2MzE0YzJkZDdmODU5MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-14T14:09:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-14T14:09:38Z"}, "message": "ada-tree.def (LOOP_STMT, EXIT_STMT): Update documentation.\n\n\t* ada-tree.def (LOOP_STMT, EXIT_STMT): Update documentation.\n\t* ada-tree.h (EXIT_STMT_LABEL): Renamed from EXIT_STMT_LOOP.\n\t* decl.c (gnat_to_gnu_entity): Also set force_global for imported\n\tsubprograms.\n\t* trans.c (gnu_loop_label_stack): Renamed from gnu_loop_stmt_stack;\n\tall callers changed.\n\t(gnat_to_gnu, case N_Loop_Statement, case N_Exit_Statement): Change\n\tthe way that EXIT_STMT finds the loop label.\n\t(gnat_gimplify_stmt, case LOOP_STMT, EXIT_STMT): Likewise.\n\t(gnat_gimplify_stmt, case DECL_STMT): Handle variable-sized decls here.\n\t(add_stmt): Use annotate_with_locus insted of setting directly.\n\t(pos_to_construct): Set TREE_PURPOSE of each entry to index.\n\t(gnat_stabilize_reference, case ARRAY_RANGE_REF): Merge with ARRAY_REF.\n\t* utils.c (gnat_install_builtins): Install __builtin_memcmp.\n\t(build_vms_descriptor): Add extra args to ARRAY_REF.\n\t(convert): Use VIEW_CONVERT_EXPR between aggregate types.\n\t* utils2.c (gnat_truthvalue_conversion, case INTEGER_CST, REAL_CST):\n\tNew cases.\n\t(build_binary_op): Don't make explicit CONVERT_EXPR.\n\tAdd extra rgs to ARRAY_REF.\n\nFrom-SVN: r83103", "tree": {"sha": "4a73e45526ddb48295d919dce3f9ab9d54d0cdea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a73e45526ddb48295d919dce3f9ab9d54d0cdea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/comments", "author": null, "committer": null, "parents": [{"sha": "715f8bb802ecb1ab114f8b904fa376f40ccb50c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/715f8bb802ecb1ab114f8b904fa376f40ccb50c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/715f8bb802ecb1ab114f8b904fa376f40ccb50c7"}], "stats": {"total": 189, "additions": 124, "deletions": 65}, "files": [{"sha": "f0551826626a692b93fa6747557da46a38614a16", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "patch": "@@ -1,3 +1,26 @@\n+2004-06-14  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* ada-tree.def (LOOP_STMT, EXIT_STMT): Update documentation.\n+\t* ada-tree.h (EXIT_STMT_LABEL): Renamed from EXIT_STMT_LOOP.\n+\t* decl.c (gnat_to_gnu_entity): Also set force_global for imported\n+\tsubprograms.\n+\t* trans.c (gnu_loop_label_stack): Renamed from gnu_loop_stmt_stack;\n+\tall callers changed.\n+\t(gnat_to_gnu, case N_Loop_Statement, case N_Exit_Statement): Change\n+\tthe way that EXIT_STMT finds the loop label.\n+\t(gnat_gimplify_stmt, case LOOP_STMT, EXIT_STMT): Likewise.\n+\t(gnat_gimplify_stmt, case DECL_STMT): Handle variable-sized decls here.\n+\t(add_stmt): Use annotate_with_locus insted of setting directly.\n+\t(pos_to_construct): Set TREE_PURPOSE of each entry to index.\n+\t(gnat_stabilize_reference, case ARRAY_RANGE_REF): Merge with ARRAY_REF.\n+\t* utils.c (gnat_install_builtins): Install __builtin_memcmp.\n+\t(build_vms_descriptor): Add extra args to ARRAY_REF.\n+\t(convert): Use VIEW_CONVERT_EXPR between aggregate types.\n+\t* utils2.c (gnat_truthvalue_conversion, case INTEGER_CST, REAL_CST):\n+\tNew cases.\n+\t(build_binary_op): Don't make explicit CONVERT_EXPR.\n+\tAdd extra rgs to ARRAY_REF.\n+\n 2004-06-14  Pascal Obry  <obry@gnat.com>\n \n \t* gnat_ugn.texi: Document relocatable vs. dynamic Library_Kind on"}, {"sha": "b185106f62e819293f302a9adfb4d3058a33e593", "filename": "gcc/ada/ada-tree.def", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "patch": "@@ -61,13 +61,13 @@ DEFTREECODE (STMT_STMT, \"stmt_stmt\", 's', 1)\n /* A loop.  LOOP_STMT_TOP_COND and LOOP_STMT_BOT_COND are the tests to exit a\n    loop at the top and bottom, respectively.  LOOP_STMT_UPDATE is the statement\n    to update the loop iterator at the continue point.  LOOP_STMT_BODY are the\n-   statements in the body of the loop.  LOOP_STMT_LABEL is used during\n-   gimplification to point to the LABEL_DECL of the end label of the loop.  */\n+   statements in the body of the loop.  LOOP_STMT_LABEL points to the LABEL_DECL\n+   of the end label of the loop.  */\n DEFTREECODE (LOOP_STMT, \"loop_stmt\", 's', 5)\n \n /* Conditionally exit a loop.  EXIT_STMT_COND is the condition, which, if\n    true, will cause the loop to be exited.  If no condition is specified,\n-   the loop is unconditionally exited.  EXIT_STMT_LOOP is the LOOP_STMT\n+   the loop is unconditionally exited.  EXIT_STMT_LABEL is the end label\n    corresponding to the loop to exit.  */\n DEFTREECODE (EXIT_STMT, \"exit_stmt\", 's', 2)\n \n@@ -85,4 +85,3 @@ DEFTREECODE (HANDLER_STMT, \"handler_stmt\", 's', 3)\n \n /* A statement that emits a USE for its single operand.  */\n DEFTREECODE (USE_STMT, \"use_expr\", 's', 1)\n-"}, {"sha": "9cdcc5d5584eecf2d11cd5f775aa4201c41b2104", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "patch": "@@ -272,7 +272,7 @@ struct lang_type GTY(()) {union lang_tree_node t; };\n #define LOOP_STMT_BODY(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 3)\n #define LOOP_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 4)\n #define EXIT_STMT_COND(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 0)\n-#define EXIT_STMT_LOOP(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 1)\n+#define EXIT_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 1)\n #define REGION_STMT_BODY(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 0)\n #define REGION_STMT_HANDLE(NODE) TREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 1)\n #define REGION_STMT_BLOCK(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 2)"}, {"sha": "3f5d80939fb1cd16473a30065c425209d0567ad4", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "patch": "@@ -299,12 +299,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n   /* For cases when we are not defining (i.e., we are referencing from\n      another compilation unit) Public entities, show we are at global level\n-     for the purpose of computing sizes.  Don't do this for components or\n+     for the purpose of computing scopes.  Don't do this for components or\n      discriminants since the relevant test is whether or not the record is\n-     being defined.  */\n-  if (! definition && Is_Public (gnat_entity)\n-      && ! Is_Statically_Allocated (gnat_entity)\n-      && kind != E_Discriminant && kind != E_Component)\n+     being defined.  But do this for Imported functions or procedures in\n+     all cases.  */\n+  if ((! definition && Is_Public (gnat_entity)\n+       && ! Is_Statically_Allocated (gnat_entity)\n+       && kind != E_Discriminant && kind != E_Component)\n+      || (Is_Imported (gnat_entity)\n+\t  && (kind == E_Function || kind == E_Procedure)))\n     force_global++, this_global = 1;\n \n   /* Handle any attributes.  */"}, {"sha": "0dec672125239feee4df82147f9900a72066f3fc", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 60, "deletions": 34, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "patch": "@@ -106,8 +106,8 @@ static GTY(()) tree gnu_except_ptr_stack;\n static GTY(()) tree gnu_return_label_stack;\n \n /* List of TREE_LIST nodes representing a stack of LOOP_STMT nodes.\n-   TREE_VALUE of each entry is the corresponding LOOP_STMT.  */\n-static GTY(()) tree gnu_loop_stmt_stack;\n+   TREE_VALUE of each entry is the label of the corresponding LOOP_STMT.  */\n+static GTY(()) tree gnu_loop_label_stack;\n \n /* List of TREE_LIST nodes containing pending elaborations lists.\n    used to prevent the elaborations being reclaimed by GC.  */\n@@ -2139,11 +2139,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \tTREE_TYPE (gnu_loop_stmt) = void_type_node;\n \tTREE_SIDE_EFFECTS (gnu_loop_stmt) = 1;\n+\tLOOP_STMT_LABEL (gnu_loop_stmt) = create_artificial_label ();\n \tannotate_with_node (gnu_loop_stmt, gnat_node);\n \n-\t/* Save this LOOP_STMT in a stack so that the corresponding\n-\t   N_Exit_Statement can find it.  */\n-\tpush_stack (&gnu_loop_stmt_stack, NULL_TREE, gnu_loop_stmt);\n+\t/* Save the end label of this LOOP_STMT in a stack so that the\n+\t   corresponding N_Exit_Statement can find it.  */\n+\tpush_stack (&gnu_loop_label_stack, NULL_TREE,\n+\t\t    LOOP_STMT_LABEL (gnu_loop_stmt));\n \n \t/* Set the condition that under which the loop should continue.\n \t   For \"LOOP .... END LOOP;\" the condition is always true.  */\n@@ -2227,10 +2229,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\tgnat_iter_scheme);\n \t  }\n \n-\t/* If the loop was named, have the name point to this loop.  In this\n-\t   case, the association is not a ..._DECL node, but this LOOP_STMT. */\n+\t/* If the loop was named, have the name point to this loop.  In this case,\n+\t   the association is not a ..._DECL node, but the end label from this\n+\t   LOOP_STMT. */\n         if (Present (Identifier (gnat_node)))\n-\t  save_gnu_tree (Entity (Identifier (gnat_node)), gnu_loop_stmt, 1);\n+\t  save_gnu_tree (Entity (Identifier (gnat_node)),\n+\t\t\t LOOP_STMT_LABEL (gnu_loop_stmt), 1);\n \n         /* Make the loop body into its own block, so any allocated storage\n            will be released every iteration.  This is needed for stack\n@@ -2258,7 +2262,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \telse\n \t  gnu_result = gnu_loop_stmt;\n \n-\tpop_stack (&gnu_loop_stmt_stack);\n+\tpop_stack (&gnu_loop_label_stack);\n       }\n       break;\n \n@@ -2281,7 +2285,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t  ? gnat_to_gnu (Condition (gnat_node)) : NULL_TREE),\n \t\t (Present (Name (gnat_node))\n \t\t  ? get_gnu_tree (Entity (Name (gnat_node)))\n-\t\t  : TREE_VALUE (gnu_loop_stmt_stack)));\n+\t\t  : TREE_VALUE (gnu_loop_label_stack)));\n       break;\n \n     case N_Return_Statement:\n@@ -4025,7 +4029,7 @@ add_stmt (tree gnu_stmt)\n \t\t\t   gnu_lhs, DECL_INITIAL (gnu_decl));\n       DECL_INITIAL (gnu_decl) = 0;\n \n-      SET_EXPR_LOCUS (gnu_assign_stmt, &DECL_SOURCE_LOCATION (gnu_decl));\n+      annotate_with_locus (gnu_assign_stmt, DECL_SOURCE_LOCATION (gnu_decl));\n       add_stmt (gnu_assign_stmt);\n     }\n }\n@@ -4254,20 +4258,44 @@ gnat_gimplify_stmt (tree *stmt_p)\n       return GS_ALL_DONE;\n \n     case DECL_STMT:\n-      if (TREE_CODE (DECL_STMT_VAR (stmt)) == TYPE_DECL)\n-\t*stmt_p = gnat_gimplify_type_sizes (TREE_TYPE (DECL_STMT_VAR (stmt)));\n-      else\n-\t*stmt_p = build_empty_stmt ();\n-      return GS_ALL_DONE;\n+      {\n+\ttree var = DECL_STMT_VAR (stmt);\n+\n+\tif (TREE_CODE (var) == TYPE_DECL)\n+\t  *stmt_p = gnat_gimplify_type_sizes (TREE_TYPE (var));\n+\telse if (TREE_CODE (var) == VAR_DECL && !DECL_EXTERNAL (var)\n+\t\t && !TREE_CONSTANT (DECL_SIZE_UNIT (var)))\n+\t  {\n+\t    tree pt_type = build_pointer_type (TREE_TYPE (var));\n+\t    tree size, pre = NULL_TREE, post = NULL_TREE;\n+\n+\t    /* This is a variable-sized decl.  Simplify its size and mark it\n+\t       for deferred expansion.  Note that mudflap depends on the format\n+\t       of the emitted code: see mx_register_decls.  */\n+\t    *stmt_p = NULL_TREE;\n+\t    size = get_initialized_tmp_var (DECL_SIZE_UNIT (var), &pre, &post);\n+\t    DECL_DEFER_OUTPUT (var) = 1;\n+\t    append_to_statement_list (pre, stmt_p);\n+\t    append_to_statement_list\n+\t      (build_function_call_expr\n+\t       (implicit_built_in_decls[BUILT_IN_STACK_ALLOC],\n+\t\ttree_cons (NULL_TREE,\n+\t\t\t   build1 (ADDR_EXPR, pt_type, var),\n+\t\t\t   tree_cons (NULL_TREE, size, NULL_TREE))),\n+\t       stmt_p);\n+\t    append_to_statement_list (post, stmt_p);\n+\t  }\n+\telse\n+\t  *stmt_p = build_empty_stmt ();\n+\treturn GS_ALL_DONE;\n+      }\n \n     case LOOP_STMT:\n       {\n \ttree gnu_start_label = create_artificial_label ();\n-\ttree gnu_end_label = create_artificial_label ();\n+\ttree gnu_end_label = LOOP_STMT_LABEL (stmt);\n \n-\t/* Save the end label for EXIT_STMT and set to emit the statements\n-\t   of the loop.  */\n-\tLOOP_STMT_LABEL (stmt) = gnu_end_label;\n+\t/* Set to emit the statements of the loop.  */\n \t*stmt_p = NULL_TREE;\n \n \t/* We first emit the start label and then a conditional jump to\n@@ -4314,8 +4342,7 @@ gnat_gimplify_stmt (tree *stmt_p)\n     case EXIT_STMT:\n       /* Build a statement to jump to the corresponding end label, then\n \t see if it needs to be conditional.  */\n-      *stmt_p = build1 (GOTO_EXPR, void_type_node,\n-\t\t\tLOOP_STMT_LABEL (EXIT_STMT_LOOP (stmt)));\n+      *stmt_p = build1 (GOTO_EXPR, void_type_node, EXIT_STMT_LABEL (stmt));\n       if (EXIT_STMT_COND (stmt))\n \t*stmt_p = build (COND_EXPR, void_type_node,\n \t\t\t EXIT_STMT_COND (stmt), *stmt_p, alloc_stmt_list ());\n@@ -5255,12 +5282,12 @@ assoc_to_constructor (Node_Id gnat_assoc, tree gnu_type)\n    of the array component. It is needed for range checking. */\n \n static tree\n-pos_to_constructor (Node_Id gnat_expr,\n-                    tree gnu_array_type,\n+pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n                     Entity_Id gnat_component_type)\n {\n-  tree gnu_expr;\n   tree gnu_expr_list = NULL_TREE;\n+  tree gnu_index = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_array_type));\n+  tree gnu_expr;\n \n   for ( ; Present (gnat_expr); gnat_expr = Next (gnat_expr))\n     {\n@@ -5285,8 +5312,12 @@ pos_to_constructor (Node_Id gnat_expr,\n \t}\n \n       gnu_expr_list\n-\t= tree_cons (NULL_TREE, convert (TREE_TYPE (gnu_array_type), gnu_expr),\n+\t= tree_cons (gnu_index, convert (TREE_TYPE (gnu_array_type), gnu_expr),\n \t\t     gnu_expr_list);\n+\n+      gnu_index = fold (build2 (PLUS_EXPR, TREE_TYPE (gnu_index), gnu_index,\n+\t\t\t\tconvert (TREE_TYPE (gnu_index),\n+\t\t\t\t\t integer_one_node)));\n     }\n \n   return gnat_build_constructor (gnu_array_type, nreverse (gnu_expr_list));\n@@ -5454,17 +5485,12 @@ gnat_stabilize_reference (tree ref, int force)\n       break;\n \n     case ARRAY_REF:\n-      result = build (ARRAY_REF, type,\n-\t\t      gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n-\t\t      gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t\t\t  force));\n-      break;\n-\n     case ARRAY_RANGE_REF:\n-      result = build (ARRAY_RANGE_REF, type,\n+      result = build (code, type,\n \t\t      gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n \t\t      gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t\t\t  force));\n+\t\t\t\t\t\t  force),\n+\t\t      NULL_TREE, NULL_TREE);\n       break;\n \n     case COMPOUND_EXPR:"}, {"sha": "6906e98e2934d9950e3382a90b42ce38cc50f689", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "patch": "@@ -467,6 +467,13 @@ gnat_install_builtins ()\n   gnat_define_builtin (\"__builtin_memcpy\", ftype, BUILT_IN_MEMCPY,\n \t\t       \"memcpy\", false);\n \n+  tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, tmp);\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, tmp);\n+  ftype = build_function_type (integer_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_memcmp\", ftype, BUILT_IN_MEMCMP,\n+\t\t       \"memcmp\", false);\n+\n   tmp = tree_cons (NULL_TREE, integer_type_node, void_list_node);\n   ftype = build_function_type (integer_type_node, tmp);\n   gnat_define_builtin (\"__builtin_clz\", ftype, BUILT_IN_CLZ, \"clz\", true);\n@@ -2489,7 +2496,8 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n       for (i = 0, inner_type = type; i < ndim;\n \t   i++, inner_type = TREE_TYPE (inner_type))\n \ttem = build (ARRAY_REF, TREE_TYPE (inner_type), tem,\n-\t\t     convert (TYPE_DOMAIN (inner_type), size_zero_node));\n+\t\t     convert (TYPE_DOMAIN (inner_type), size_zero_node),\n+\t\t     NULL_TREE, NULL_TREE);\n \n       field_list\n \t= chainon (field_list,\n@@ -2847,10 +2855,10 @@ convert (tree type, tree expr)\n   if (type == etype)\n     return expr;\n   /* If we're converting between two aggregate types that have the same main\n-     variant, just make a NOP_EXPR.  */\n+     variant, just make a VIEW_CONVER_EXPR.  */\n   else if (AGGREGATE_TYPE_P (type)\n \t   && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype))\n-    return build1 (NOP_EXPR, type, expr);\n+    return build1 (VIEW_CONVERT_EXPR, type, expr);\n \n   /* If the input type has padding, remove it by doing a component reference\n      to the field.  If the output type has padding, make a constructor"}, {"sha": "0d83f74e9b6344afafef441b7016d2a267eb0e2a", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/966389eeaaf6b674bbfbdc34b06314c2dd7f8591/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=966389eeaaf6b674bbfbdc34b06314c2dd7f8591", "patch": "@@ -84,6 +84,14 @@ gnat_truthvalue_conversion (tree expr)\n     case ERROR_MARK:\n       return expr;\n \n+    case INTEGER_CST:\n+      return (integer_zerop (expr) ? convert (type, integer_zero_node)\n+\t      : convert (type, integer_one_node));\n+\n+    case REAL_CST:\n+      return (real_zerop (expr) ? convert (type, integer_zero_node)\n+\t      : convert (type, integer_one_node));\n+\n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n       return fold\n@@ -578,10 +586,8 @@ nonbinary_modular_operation (enum tree_code op_code,\n    have to do here is validate the work done by SEM and handle subtypes.  */\n \n tree\n-build_binary_op (enum tree_code op_code,\n-                 tree result_type,\n-                 tree left_operand,\n-                 tree right_operand)\n+build_binary_op (enum tree_code op_code, tree result_type,\n+                 tree left_operand, tree right_operand)\n {\n   tree left_type  = TREE_TYPE (left_operand);\n   tree right_type = TREE_TYPE (right_operand);\n@@ -739,17 +745,7 @@ build_binary_op (enum tree_code op_code,\n       if (operation_type != right_type\n \t  && (! CONTAINS_PLACEHOLDER_P (TYPE_SIZE (operation_type))))\n \t{\n-\t  /* For a variable-size type, with both BLKmode, convert using\n-\t     CONVERT_EXPR instead of an unchecked conversion since we don't\n-\t     need to make a temporary (and can't anyway).  */\n-\t  if (TREE_CODE (TYPE_SIZE (operation_type)) != INTEGER_CST\n-\t      && TYPE_MODE (TREE_TYPE (right_operand)) == BLKmode\n-\t      && TREE_CODE (right_operand) != UNCONSTRAINED_ARRAY_REF)\n-\t    right_operand = build1 (CONVERT_EXPR, operation_type,\n-\t\t\t\t    right_operand);\n-\t  else\n-\t    right_operand = convert (operation_type, right_operand);\n-\n+\t  right_operand = convert (operation_type, right_operand);\n \t  right_type = operation_type;\n \t}\n \n@@ -894,7 +890,8 @@ build_binary_op (enum tree_code op_code,\n \t just compare the data pointer.  */\n       else if (TYPE_FAT_POINTER_P (left_base_type)\n \t       && TREE_CODE (right_operand) == CONSTRUCTOR\n-\t       && integer_zerop (TREE_VALUE (CONSTRUCTOR_ELTS (right_operand))))\n+\t       && integer_zerop (TREE_VALUE\n+\t\t\t\t (CONSTRUCTOR_ELTS (right_operand))))\n \t{\n \t  right_operand = build_component_ref (left_operand, NULL_TREE,\n \t\t\t\t\t       TYPE_FIELDS (left_base_type),\n@@ -1008,9 +1005,12 @@ build_binary_op (enum tree_code op_code,\n     return build1 (NULL_EXPR, operation_type, TREE_OPERAND (left_operand, 0));\n   else if (TREE_CODE (right_operand) == NULL_EXPR)\n     return build1 (NULL_EXPR, operation_type, TREE_OPERAND (right_operand, 0));\n+  else if (op_code == ARRAY_REF || op_code == ARRAY_RANGE_REF)\n+    result = fold (build (op_code, operation_type, left_operand, right_operand,\n+\t\t\t  NULL_TREE, NULL_TREE));\n   else\n-    result = fold (build (op_code, operation_type,\n-\t\t\t  left_operand, right_operand));\n+    result\n+      = fold (build (op_code, operation_type, left_operand, right_operand));\n \n   TREE_SIDE_EFFECTS (result) |= has_side_effects;\n   TREE_CONSTANT (result)"}]}