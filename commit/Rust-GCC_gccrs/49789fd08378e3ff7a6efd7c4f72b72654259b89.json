{"sha": "49789fd08378e3ff7a6efd7c4f72b72654259b89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk3ODlmZDA4Mzc4ZTNmZjdhNmVmZDdjNGY3MmI3MjY1NDI1OWI4OQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-01-18T11:54:46Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-01-18T11:55:56Z"}, "message": "[C++ coroutines] Initial implementation.\n\nThis is the squashed version of the first 6 patches that were split to\nfacilitate review.\n\nThe changes to libiberty (7th patch) to support demangling the co_await\noperator stand alone and are applied separately.\n\nThe patch series is an initial implementation of a coroutine feature,\nexpected to be standardised in C++20.\n\nStandardisation status (and potential impact on this implementation)\n--------------------------------------------------------------------\n\nThe facility was accepted into the working draft for C++20 by WG21 in\nFebruary 2019.  During following WG21 meetings, design and national body\ncomments have been reviewed, with no significant change resulting.\n\nThe current GCC implementation is against n4835 [1].\n\nAt this stage, the remaining potential for change comes from:\n\n* Areas of national body comments that were not resolved in the version we\n  have worked to:\n  (a) handling of the situation where aligned allocation is available.\n  (b) handling of the situation where a user wants coroutines, but does not\n      want exceptions (e.g. a GPU).\n\n* Agreed changes that have not yet been worded in a draft standard that we\n  have worked to.\n\nIt is not expected that the resolution to these can produce any major\nchange at this phase of the standardisation process.  Such changes should be\nlimited to the coroutine-specific code.\n\nABI\n---\n\nThe various compiler developers 'vendors' have discussed a minimal ABI to\nallow one implementation to call coroutines compiled by another.\n\nThis amounts to:\n\n1. The layout of a public portion of the coroutine frame.\n\n Coroutines need to preserve state across suspension points, the storage for\n this is called a \"coroutine frame\".\n\n The ABI mandates that pointers into the coroutine frame point to an area\n begining with two function pointers (to the resume and destroy functions\n described below); these are immediately followed by the \"promise object\"\n described in the standard.\n\n This is sufficient that the builtins can take a coroutine frame pointer and\n determine the address of the promise (or call the resume/destroy functions).\n\n2. A number of compiler builtins that the standard library might use.\n\n  These are implemented by this patch series.\n\n3. This introduces a new operator 'co_await' the mangling for which is also\nagreed between vendors (and has an issue filed for that against the upstream\nc++abi).  Demangling for this is added to libiberty in a separate patch.\n\nThe ABI has currently no target-specific content (a given psABI might elect\nto mandate alignment, but the common ABI does not do this).\n\nStandard Library impact\n-----------------------\n\nThe current implementations require addition of only a single header to\nthe standard library (no change to the runtime).  This header is part of\nthe patch.\n\nGCC Implementation outline\n--------------------------\n\nThe standard's design for coroutines does not decorate the definition of\na coroutine in any way, so that a function is only known to be a coroutine\nwhen one of the keywords (co_await, co_yield, co_return) is encountered.\n\nThis means that we cannot special-case such functions from the outset, but\nmust process them differently when they are finalised - which we do from\n\"finish_function ()\".\n\nAt a high level, this design of coroutine produces four pieces from the\noriginal user's function:\n\n  1. A coroutine state frame (taking the logical place of the activation\n     record for a regular function).  One item stored in that state is the\n     index of the current suspend point.\n  2. A \"ramp\" function\n     This is what the user calls to construct the coroutine frame and start\n     the coroutine execution.  This will return some object representing the\n     coroutine's eventual return value (or means to continue it when it it\n     suspended).\n  3. A \"resume\" function.\n     This is what gets called when a the coroutine is resumed when suspended.\n  4. A \"destroy\" function.\n     This is what gets called when the coroutine state should be destroyed\n     and its memory released.\n\nThe standard's coroutines involve cooperation of the user's authored function\nwith a provided \"promise\" class, which includes mandatory methods for\nhandling the state transitions and providing output values.  Most realistic\ncoroutines will also have one or more 'awaiter' classes that implement the\nuser's actions for each suspend point.  As we parse (or during template\nexpansion) the types of the promise and awaiter classes become known, and can\nthen be verified against the signatures expected by the standard.\n\nOnce the function is parsed (and templates expanded) we are able to make the\ntransformation into the four pieces noted above.\n\nThe implementation here takes the approach of a series of AST transforms.\nThe state machine suspend points are encoded in three internal functions\n(one of which represents an exit from scope without cleanups).  These three\nIFNs are lowered early in the middle end, such that the majority of GCC's\noptimisers can be run on the resulting output.\n\nAs a design choice, we have carried out the outlining of the user's function\nin the front end, and taken advantage of the existing middle end's abilities\nto inline and DCE where that is profitable.\n\nSince the state machine is actually common to both resumer and destroyer\nfunctions, we make only a single function \"actor\" that contains both the\nresume and destroy paths.  The destroy function is represented by a small\nstub that sets a value to signal the use of the destroy path and calls the\nactor.  The idea is that optimisation of the state machine need only be done\nonce - and then the resume and destroy paths can be identified allowing the\nmiddle end's inline and DCE machinery to optimise as profitable as noted\nabove.\n\nThe middle end components for this implementation are:\n\nA pass that:\n 1. Lowers the coroutine builtins that allow the standard library header to\n    interact with the coroutine frame (these fairly simple logical or\n    numerical substitution of values, given a coroutine frame pointer).\n 2. Lowers the IFN that represents the exit from state without cleanup.\n    Essentially, this becomes a gimple goto.\n 3. Sets the final size of the coroutine frame at this stage.\n\nA second pass (that requires the revised CFG that results from the lowering\nof the scope exit IFNs in the first).\n\n 1. Lower the IFNs that represent the state machine paths for the resume and\n    destroy cases.\n\nPatches squashed into this commit:\n\n[C++ coroutines 1] Common code and base definitions.\n\nThis part of the patch series provides the gating flag, the keywords,\ncpp defines etc.\n\n[C++ coroutines 2] Define builtins and internal functions.\n\nThis part of the patch series provides the builtin functions\nused by the standard library code and the internal functions\nused to implement lowering of the coroutine state machine.\n\n[C++ coroutines 3] Front end parsing and transforms.\n\nThere are two parts to this.\n\n1. Parsing, template instantiation and diagnostics for the standard-\n   mandated class entries.\n\n  The user authors a function that becomes a coroutine (lazily) by\n  making use of any of the co_await, co_yield or co_return keywords.\n\n  Unlike a regular function, where the activation record is placed on the\n  stack, and is destroyed on function exit, a coroutine has some state that\n  persists between calls - the 'coroutine frame' (thus analogous to a stack\n  frame).\n\n  We transform the user's function into three pieces:\n  1. A so-called ramp function, that establishes the coroutine frame and\n     begins execution of the coroutine.\n  2. An actor function that contains the state machine corresponding to the\n     user's suspend/resume structure.\n  3. A stub function that calls the actor function in 'destroy' mode.\n\n  The actor function is executed:\n   * from \"resume point 0\" by the ramp.\n   * from resume point N ( > 0 ) for handle.resume() calls.\n   * from the destroy stub for destroy point N for handle.destroy() calls.\n\n  The C++ coroutine design described in the standard makes use of some helper\n  methods that are authored in a so-called \"promise\" class provided by the\n  user.\n\n  At parse time (or post substitution) the type of the coroutine promise\n  will be determined.  At that point, we can look up the required promise\n  class methods and issue diagnostics if they are missing or incorrect.  To\n  avoid repeating these actions at code-gen time, we make use of temporary\n  'proxy' variables for the coroutine handle and the promise - which will\n  eventually be instantiated in the coroutine frame.\n\n  Each of the keywords will expand to a code sequence (although co_yield is\n  just syntactic sugar for a co_await).\n\n  We defer the analysis and transformatin until template expansion is\n  complete so that we have complete types at that time.\n\n2. AST analysis and transformation which performs the code-gen for the\n   outlined state machine.\n\n   The entry point here is morph_fn_to_coro () which is called from\n   finish_function () when we have completed any template expansion.\n\n   This is preceded by helper functions that implement the phases below.\n\n   The process proceeds in four phases.\n\n   A Initial framing.\n     The user's function body is wrapped in the initial and final suspend\n     points and we begin building the coroutine frame.\n     We build empty decls for the actor and destroyer functions at this\n     time too.\n     When exceptions are enabled, the user's function body will also be\n     wrapped in a try-catch block with the catch invoking the promise\n     class 'unhandled_exception' method.\n\n   B Analysis.\n     The user's function body is analysed to determine the suspend points,\n     if any, and to capture local variables that might persist across such\n     suspensions.  In most cases, it is not necessary to capture compiler\n     temporaries, since the tree-lowering nests the suspensions correctly.\n     However, in the case of a captured reference, there is a lifetime\n     extension to the end of the full expression - which can mean across a\n     suspend point in which case it must be promoted to a frame variable.\n\n     At the conclusion of analysis, we have a conservative frame layout and\n     maps of the local variables to their frame entry points.\n\n   C Build the ramp function.\n     Carry out the allocation for the coroutine frame (NOTE; the actual size\n     computation is deferred until late in the middle end to allow for future\n     optimisations that will be allowed to elide unused frame entries).\n     We build the return object.\n\n   D Build and expand the actor and destroyer function bodies.\n     The destroyer is a trivial shim that sets a bit to indicate that the\n     destroy dispatcher should be used and then calls into the actor.\n\n     The actor function is the implementation of the user's state machine.\n     The current suspend point is noted in an index.\n     Each suspend point is encoded as a pair of internal functions, one in\n     the relevant dispatcher, and one representing the suspend point.\n\n     During this process, the user's local variables and the proxies for the\n     self-handle and the promise class instanceare re-written to their\n     coroutine frame equivalents.\n\n     The complete bodies for the ramp, actor and destroy function are passed\n     back to finish_function for folding and gimplification.\n\n[C++ coroutines 4] Middle end expanders and transforms.\n\nThe first part of this is a pass that provides:\n * expansion of the library support builtins, these are simple boolean\n   or numerical substitutions.\n\n * The functionality of implementing an exit from scope without cleanup\n   is performed here by lowering an IFN to a gimple goto.\n\nThis pass has to run for non-coroutine functions, since functions calling\nthe builtins are not necessarily coroutines (i.e. they are implementing the\nlibrary interfaces which may be called from anywhere).\n\nThe second part is the expansion of the coroutine IFNs that describe the\nstate machine connections to the dispatchers.  This only has to be run\nfor functions that are coroutine components.  The work done by this pass\nis:\n\n   In the front end we construct a single actor function that contains\n   the coroutine state machine.\n\n   The actor function has three entry conditions:\n    1. from the ramp, resume point 0 - to initial-suspend.\n    2. when resume () is executed (resume point N).\n    3. from the destroy () shim when that is executed.\n\n   The actor function begins with two dispatchers; one for resume and\n   one for destroy (where the initial entry from the ramp is a special-\n   case of resume point 0).\n\n   Each suspend point and each dispatch entry is marked with an IFN such\n   that we can connect the relevant dispatchers to their target labels.\n\n   So, if we have:\n\n   CO_YIELD (NUM, FINAL, RES_LAB, DEST_LAB, FRAME_PTR)\n\n   This is await point NUM, and is the final await if FINAL is non-zero.\n   The resume point is RES_LAB, and the destroy point is DEST_LAB.\n\n   We expect to find a CO_ACTOR (NUM) in the resume dispatcher and a\n   CO_ACTOR (NUM+1) in the destroy dispatcher.\n\n   Initially, the intent of keeping the resume and destroy paths together\n   is that the conditionals controlling them are identical, and thus there\n   would be duplication of any optimisation of those paths if the split\n   were earlier.\n\n   Subsequent inlining of the actor (and DCE) is then able to extract the\n   resume and destroy paths as separate functions if that is found\n   profitable by the optimisers.\n\n   Once we have remade the connections to their correct postions, we elide\n   the labels that the front end inserted.\n\n[C++ coroutines 5] Standard library header.\n\nThis provides the interfaces mandated by the standard and implements\nthe interaction with the coroutine frame by means of inline use of\nbuiltins expanded at compile-time.  There should be a 1:1 correspondence\nwith the standard sections which are cross-referenced.\n\nThere is no runtime content.\n\nAt this stage, we have the content in an inline namespace \"__n4835\" for\nthe CD we worked to.\n\n[C++ coroutines 6] Testsuite.\n\nThere are two categories of test:\n\n1. Checks for correctly formed source code and the error reporting.\n2. Checks for transformation and code-gen.\n\nThe second set are run as 'torture' tests for the standard options\nset, including LTO.  These are also intentionally run with no options\nprovided (from the coroutines.exp script).\n\ngcc/ChangeLog:\n\n2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* Makefile.in: Add coroutine-passes.o.\n\t* builtin-types.def (BT_CONST_SIZE): New.\n\t(BT_FN_BOOL_PTR): New.\n\t(BT_FN_PTR_PTR_CONST_SIZE_BOOL): New.\n\t* builtins.def (DEF_COROUTINE_BUILTIN): New.\n\t* coroutine-builtins.def: New file.\n\t* coroutine-passes.cc: New file.\n\t* function.h (struct GTY function): Add a bit to indicate that the\n\tfunction is a coroutine component.\n\t* internal-fn.c (expand_CO_FRAME): New.\n\t(expand_CO_YIELD): New.\n\t(expand_CO_SUSPN): New.\n\t(expand_CO_ACTOR): New.\n\t* internal-fn.def (CO_ACTOR): New.\n\t(CO_YIELD): New.\n\t(CO_SUSPN): New.\n\t(CO_FRAME): New.\n\t* passes.def: Add pass_coroutine_lower_builtins,\n\tpass_coroutine_early_expand_ifns.\n\t* tree-pass.h (make_pass_coroutine_lower_builtins): New.\n\t(make_pass_coroutine_early_expand_ifns): New.\n\t* doc/invoke.texi: Document the fcoroutines command line\n\tswitch.\n\ngcc/c-family/ChangeLog:\n\n2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* c-common.c (co_await, co_yield, co_return): New.\n\t* c-common.h (RID_CO_AWAIT, RID_CO_YIELD,\n\tRID_CO_RETURN): New enumeration values.\n\t(D_CXX_COROUTINES): Bit to identify coroutines are active.\n\t(D_CXX_COROUTINES_FLAGS): Guard for coroutine keywords.\n\t* c-cppbuiltin.c (__cpp_coroutines): New cpp define.\n\t* c.opt (fcoroutines): New command-line switch.\n\ngcc/cp/ChangeLog:\n\n2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* Make-lang.in: Add coroutines.o.\n\t* cp-tree.h (lang_decl-fn): coroutine_p, new bit.\n\t(DECL_COROUTINE_P): New.\n\t* lex.c (init_reswords): Enable keywords when the coroutine flag\n\tis set,\n\t* operators.def (co_await): New operator.\n\t* call.c (add_builtin_candidates): Handle CO_AWAIT_EXPR.\n\t(op_error): Likewise.\n\t(build_new_op_1): Likewise.\n\t(build_new_function_call): Validate coroutine builtin arguments.\n\t* constexpr.c (potential_constant_expression_1): Handle\n\tCO_AWAIT_EXPR, CO_YIELD_EXPR, CO_RETURN_EXPR.\n\t* coroutines.cc: New file.\n\t* cp-objcp-common.c (cp_common_init_ts): Add CO_AWAIT_EXPR,\n\tCO_YIELD_EXPR, CO_RETRN_EXPR as TS expressions.\n\t* cp-tree.def (CO_AWAIT_EXPR, CO_YIELD_EXPR, (CO_RETURN_EXPR): New.\n\t* cp-tree.h (coro_validate_builtin_call): New.\n\t* decl.c (emit_coro_helper): New.\n\t(finish_function): Handle the case when a function is found to\n\tbe a coroutine, perform the outlining and emit the outlined\n\tfunctions. Set a bit to signal that this is a coroutine component.\n\t* parser.c (enum required_token): New enumeration RT_CO_YIELD.\n\t(cp_parser_unary_expression): Handle co_await.\n\t(cp_parser_assignment_expression): Handle co_yield.\n\t(cp_parser_statement): Handle RID_CO_RETURN.\n\t(cp_parser_jump_statement): Handle co_return.\n\t(cp_parser_operator): Handle co_await operator.\n\t(cp_parser_yield_expression): New.\n\t(cp_parser_required_error): Handle RT_CO_YIELD.\n\t* pt.c (tsubst_copy): Handle CO_AWAIT_EXPR.\n\t(tsubst_expr): Handle CO_AWAIT_EXPR, CO_YIELD_EXPR and\n\tCO_RETURN_EXPRs.\n\t* tree.c (cp_walk_subtrees): Likewise.\n\nlibstdc++-v3/ChangeLog:\n\n2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* include/Makefile.am: Add coroutine to the std set.\n\t* include/Makefile.in: Regenerated.\n\t* include/std/coroutine: New file.\n\ngcc/testsuite/ChangeLog:\n\n2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* g++.dg/coroutines/co-await-syntax-00-needs-expr.C: New test.\n\t* g++.dg/coroutines/co-await-syntax-01-outside-fn.C: New test.\n\t* g++.dg/coroutines/co-await-syntax-02-outside-fn.C: New test.\n\t* g++.dg/coroutines/co-await-syntax-03-auto.C: New test.\n\t* g++.dg/coroutines/co-await-syntax-04-ctor-dtor.C: New test.\n\t* g++.dg/coroutines/co-await-syntax-05-constexpr.C: New test.\n\t* g++.dg/coroutines/co-await-syntax-06-main.C: New test.\n\t* g++.dg/coroutines/co-await-syntax-07-varargs.C: New test.\n\t* g++.dg/coroutines/co-await-syntax-08-lambda-auto.C: New test.\n\t* g++.dg/coroutines/co-return-syntax-01-outside-fn.C: New test.\n\t* g++.dg/coroutines/co-return-syntax-02-outside-fn.C: New test.\n\t* g++.dg/coroutines/co-return-syntax-03-auto.C: New test.\n\t* g++.dg/coroutines/co-return-syntax-04-ctor-dtor.C: New test.\n\t* g++.dg/coroutines/co-return-syntax-05-constexpr-fn.C: New test.\n\t* g++.dg/coroutines/co-return-syntax-06-main.C: New test.\n\t* g++.dg/coroutines/co-return-syntax-07-vararg.C: New test.\n\t* g++.dg/coroutines/co-return-syntax-08-bad-return.C: New test.\n\t* g++.dg/coroutines/co-return-syntax-09-lambda-auto.C: New test.\n\t* g++.dg/coroutines/co-yield-syntax-00-needs-expr.C: New test.\n\t* g++.dg/coroutines/co-yield-syntax-01-outside-fn.C: New test.\n\t* g++.dg/coroutines/co-yield-syntax-02-outside-fn.C: New test.\n\t* g++.dg/coroutines/co-yield-syntax-03-auto.C: New test.\n\t* g++.dg/coroutines/co-yield-syntax-04-ctor-dtor.C: New test.\n\t* g++.dg/coroutines/co-yield-syntax-05-constexpr.C: New test.\n\t* g++.dg/coroutines/co-yield-syntax-06-main.C: New test.\n\t* g++.dg/coroutines/co-yield-syntax-07-varargs.C: New test.\n\t* g++.dg/coroutines/co-yield-syntax-08-needs-expr.C: New test.\n\t* g++.dg/coroutines/co-yield-syntax-09-lambda-auto.C: New test.\n\t* g++.dg/coroutines/coro-builtins.C: New test.\n\t* g++.dg/coroutines/coro-missing-gro.C: New test.\n\t* g++.dg/coroutines/coro-missing-promise-yield.C: New test.\n\t* g++.dg/coroutines/coro-missing-ret-value.C: New test.\n\t* g++.dg/coroutines/coro-missing-ret-void.C: New test.\n\t* g++.dg/coroutines/coro-missing-ueh-1.C: New test.\n\t* g++.dg/coroutines/coro-missing-ueh-2.C: New test.\n\t* g++.dg/coroutines/coro-missing-ueh-3.C: New test.\n\t* g++.dg/coroutines/coro-missing-ueh.h: New test.\n\t* g++.dg/coroutines/coro-pre-proc.C: New test.\n\t* g++.dg/coroutines/coro.h: New file.\n\t* g++.dg/coroutines/coro1-ret-int-yield-int.h: New file.\n\t* g++.dg/coroutines/coroutines.exp: New file.\n\t* g++.dg/coroutines/torture/alloc-00-gro-on-alloc-fail.C: New test.\n\t* g++.dg/coroutines/torture/alloc-01-overload-newdel.C: New test.\n\t* g++.dg/coroutines/torture/call-00-co-aw-arg.C: New test.\n\t* g++.dg/coroutines/torture/call-01-multiple-co-aw.C: New test.\n\t* g++.dg/coroutines/torture/call-02-temp-co-aw.C: New test.\n\t* g++.dg/coroutines/torture/call-03-temp-ref-co-aw.C: New test.\n\t* g++.dg/coroutines/torture/class-00-co-ret.C: New test.\n\t* g++.dg/coroutines/torture/class-01-co-ret-parm.C: New test.\n\t* g++.dg/coroutines/torture/class-02-templ-parm.C: New test.\n\t* g++.dg/coroutines/torture/class-03-operator-templ-parm.C: New test.\n\t* g++.dg/coroutines/torture/class-04-lambda-1.C: New test.\n\t* g++.dg/coroutines/torture/class-05-lambda-capture-copy-local.C: New test.\n\t* g++.dg/coroutines/torture/class-06-lambda-capture-ref.C: New test.\n\t* g++.dg/coroutines/torture/co-await-00-trivial.C: New test.\n\t* g++.dg/coroutines/torture/co-await-01-with-value.C: New test.\n\t* g++.dg/coroutines/torture/co-await-02-xform.C: New test.\n\t* g++.dg/coroutines/torture/co-await-03-rhs-op.C: New test.\n\t* g++.dg/coroutines/torture/co-await-04-control-flow.C: New test.\n\t* g++.dg/coroutines/torture/co-await-05-loop.C: New test.\n\t* g++.dg/coroutines/torture/co-await-06-ovl.C: New test.\n\t* g++.dg/coroutines/torture/co-await-07-tmpl.C: New test.\n\t* g++.dg/coroutines/torture/co-await-08-cascade.C: New test.\n\t* g++.dg/coroutines/torture/co-await-09-pair.C: New test.\n\t* g++.dg/coroutines/torture/co-await-10-template-fn-arg.C: New test.\n\t* g++.dg/coroutines/torture/co-await-11-forwarding.C: New test.\n\t* g++.dg/coroutines/torture/co-await-12-operator-2.C: New test.\n\t* g++.dg/coroutines/torture/co-await-13-return-ref.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-00-void-return-is-ready.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-01-void-return-is-suspend.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-03-different-GRO-type.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-04-GRO-nontriv.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-05-return-value.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-06-template-promise-val-1.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-07-void-cast-expr.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-08-template-cast-ret.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-09-bool-await-susp.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-10-expression-evaluates-once.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-11-co-ret-co-await.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-12-co-ret-fun-co-await.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-13-template-2.C: New test.\n\t* g++.dg/coroutines/torture/co-ret-14-template-3.C: New test.\n\t* g++.dg/coroutines/torture/co-yield-00-triv.C: New test.\n\t* g++.dg/coroutines/torture/co-yield-01-multi.C: New test.\n\t* g++.dg/coroutines/torture/co-yield-02-loop.C: New test.\n\t* g++.dg/coroutines/torture/co-yield-03-tmpl.C: New test.\n\t* g++.dg/coroutines/torture/co-yield-04-complex-local-state.C: New test.\n\t* g++.dg/coroutines/torture/co-yield-05-co-aw.C: New test.\n\t* g++.dg/coroutines/torture/co-yield-06-fun-parm.C: New test.\n\t* g++.dg/coroutines/torture/co-yield-07-template-fn-param.C: New test.\n\t* g++.dg/coroutines/torture/co-yield-08-more-refs.C: New test.\n\t* g++.dg/coroutines/torture/co-yield-09-more-templ-refs.C: New test.\n\t* g++.dg/coroutines/torture/coro-torture.exp: New file.\n\t* g++.dg/coroutines/torture/exceptions-test-0.C: New test.\n\t* g++.dg/coroutines/torture/func-params-00.C: New test.\n\t* g++.dg/coroutines/torture/func-params-01.C: New test.\n\t* g++.dg/coroutines/torture/func-params-02.C: New test.\n\t* g++.dg/coroutines/torture/func-params-03.C: New test.\n\t* g++.dg/coroutines/torture/func-params-04.C: New test.\n\t* g++.dg/coroutines/torture/func-params-05.C: New test.\n\t* g++.dg/coroutines/torture/func-params-06.C: New test.\n\t* g++.dg/coroutines/torture/lambda-00-co-ret.C: New test.\n\t* g++.dg/coroutines/torture/lambda-01-co-ret-parm.C: New test.\n\t* g++.dg/coroutines/torture/lambda-02-co-yield-values.C: New test.\n\t* g++.dg/coroutines/torture/lambda-03-auto-parm-1.C: New test.\n\t* g++.dg/coroutines/torture/lambda-04-templ-parm.C: New test.\n\t* g++.dg/coroutines/torture/lambda-05-capture-copy-local.C: New test.\n\t* g++.dg/coroutines/torture/lambda-06-multi-capture.C: New test.\n\t* g++.dg/coroutines/torture/lambda-07-multi-yield.C: New test.\n\t* g++.dg/coroutines/torture/lambda-08-co-ret-parm-ref.C: New test.\n\t* g++.dg/coroutines/torture/local-var-0.C: New test.\n\t* g++.dg/coroutines/torture/local-var-1.C: New test.\n\t* g++.dg/coroutines/torture/local-var-2.C: New test.\n\t* g++.dg/coroutines/torture/local-var-3.C: New test.\n\t* g++.dg/coroutines/torture/local-var-4.C: New test.\n\t* g++.dg/coroutines/torture/mid-suspend-destruction-0.C: New test.\n\t* g++.dg/coroutines/torture/pr92933.C: New test.", "tree": {"sha": "f9fced1025c3557ea736bfaf3b8a58c4741eae12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9fced1025c3557ea736bfaf3b8a58c4741eae12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49789fd08378e3ff7a6efd7c4f72b72654259b89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49789fd08378e3ff7a6efd7c4f72b72654259b89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49789fd08378e3ff7a6efd7c4f72b72654259b89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49789fd08378e3ff7a6efd7c4f72b72654259b89/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "472ef1d34bbe510cec7f23bd637de021a99f67c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472ef1d34bbe510cec7f23bd637de021a99f67c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/472ef1d34bbe510cec7f23bd637de021a99f67c5"}], "stats": {"total": 11061, "additions": 11052, "deletions": 9}, "files": [{"sha": "064bb38a674491347e6c818a5d6e6e1e486e4ab8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -1,3 +1,29 @@\n+2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* Makefile.in: Add coroutine-passes.o.\n+\t* builtin-types.def (BT_CONST_SIZE): New.\n+\t(BT_FN_BOOL_PTR): New.\n+\t(BT_FN_PTR_PTR_CONST_SIZE_BOOL): New.\n+\t* builtins.def (DEF_COROUTINE_BUILTIN): New.\n+\t* coroutine-builtins.def: New file.\n+\t* coroutine-passes.cc: New file.\n+\t* function.h (struct GTY function): Add a bit to indicate that the\n+\tfunction is a coroutine component.\n+\t* internal-fn.c (expand_CO_FRAME): New.\n+\t(expand_CO_YIELD): New.\n+\t(expand_CO_SUSPN): New.\n+\t(expand_CO_ACTOR): New.\n+\t* internal-fn.def (CO_ACTOR): New.\n+\t(CO_YIELD): New.\n+\t(CO_SUSPN): New.\n+\t(CO_FRAME): New.\n+\t* passes.def: Add pass_coroutine_lower_builtins,\n+\tpass_coroutine_early_expand_ifns.\n+\t* tree-pass.h (make_pass_coroutine_lower_builtins): New.\n+\t(make_pass_coroutine_early_expand_ifns): New.\n+\t* doc/invoke.texi: Document the fcoroutines command line\n+\tswitch.\n+\n 2020-01-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/arm/vfp.md (*clear_vfp_multiple): Remove unused variable."}, {"sha": "b1423d1dbfde4cda9c03ff908c569987daba8730", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -1292,6 +1292,7 @@ OBJS = \\\n \tcompare-elim.o \\\n \tcontext.o \\\n \tconvert.o \\\n+\tcoroutine-passes.o \\\n \tcoverage.o \\\n \tcppbuiltin.o \\\n \tcppdefault.o \\"}, {"sha": "c7aa691b243771c9768d524026600cb484115092", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -131,6 +131,8 @@ DEF_PRIMITIVE_TYPE (BT_CONST_DOUBLE_PTR,\n DEF_PRIMITIVE_TYPE (BT_LONGDOUBLE_PTR, long_double_ptr_type_node)\n DEF_PRIMITIVE_TYPE (BT_PID, pid_type_node)\n DEF_PRIMITIVE_TYPE (BT_SIZE, size_type_node)\n+DEF_PRIMITIVE_TYPE (BT_CONST_SIZE,\n+\t\t    build_qualified_type (size_type_node, TYPE_QUAL_CONST))\n DEF_PRIMITIVE_TYPE (BT_SSIZE, signed_size_type_node)\n DEF_PRIMITIVE_TYPE (BT_WINT, wint_type_node)\n DEF_PRIMITIVE_TYPE (BT_STRING, string_type_node)\n@@ -300,6 +302,7 @@ DEF_FUNCTION_TYPE_1 (BT_FN_UINT32_UINT32, BT_UINT32, BT_UINT32)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT64_UINT64, BT_UINT64, BT_UINT64)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT64_FLOAT, BT_UINT64, BT_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_PTR, BT_BOOL, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_PTR_CONST_PTR, BT_PTR, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_CONST_PTR_CONST_PTR, BT_CONST_PTR, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT16_UINT32, BT_UINT16, BT_UINT32)\n@@ -628,6 +631,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_UINT32_UINT32_PTR,\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_SIZE_SIZE_PTR, BT_VOID, BT_SIZE, BT_SIZE,\n \t\t     BT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_UINT_UINT_PTR_PTR, BT_UINT, BT_UINT, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_CONST_SIZE_BOOL,\n+\t\t     BT_PTR, BT_PTR, BT_CONST_SIZE, BT_BOOL)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)"}, {"sha": "5ab842c34c2f1be8fa53808b9b10149a870f195e", "filename": "gcc/builtins.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -189,6 +189,12 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, BT_LAST, BT_LAST, false, false, \\\n \t       false, ATTR_LAST, false, false)\n \n+/* Builtins used in implementing coroutine support. */\n+#undef DEF_COROUTINE_BUILTIN\n+#define DEF_COROUTINE_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_coro_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE, \\\n+\t       true, true, true, ATTRS, true, flag_coroutines)\n+\n /* Builtin used by the implementation of OpenACC and OpenMP.  Few of these are\n    actually implemented in the compiler; most are in libgomp.  */\n /* These builtins also need to be enabled in offloading compilers invoked from\n@@ -1064,6 +1070,9 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n /* Sanitizer builtins. */\n #include \"sanitizer.def\"\n \n+/* Coroutine builtins.  */\n+#include \"coroutine-builtins.def\"\n+\n /* Do not expose the BRIG builtins by default gcc-wide, but only privately in\n    the BRIG FE as long as there are no references for them in the middle end\n    or any of the upstream backends.  */"}, {"sha": "09ba2c8b40fd282749cc63b86dce5fdb118d0649", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -1,3 +1,13 @@\n+2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* c-common.c (co_await, co_yield, co_return): New.\n+\t* c-common.h (RID_CO_AWAIT, RID_CO_YIELD,\n+\tRID_CO_RETURN): New enumeration values.\n+\t(D_CXX_COROUTINES): Bit to identify coroutines are active.\n+\t(D_CXX_COROUTINES_FLAGS): Guard for coroutine keywords.\n+\t* c-cppbuiltin.c (__cpp_coroutines): New cpp define.\n+\t* c.opt (fcoroutines): New command-line switch.\n+\n 2020-01-10  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-format.c (local_event_ptr_node): New."}, {"sha": "82c08945a50bf30666dfd7c8a5ed7044a2f20de0", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -537,6 +537,11 @@ const struct c_common_resword c_common_reswords[] =\n   { \"concept\",\t\tRID_CONCEPT,\tD_CXX_CONCEPTS_FLAGS | D_CXXWARN },\n   { \"requires\", \tRID_REQUIRES,\tD_CXX_CONCEPTS_FLAGS | D_CXXWARN },\n \n+  /* Coroutines-related keywords */\n+  { \"co_await\",\t\tRID_CO_AWAIT,\tD_CXX_COROUTINES_FLAGS | D_CXXWARN },\n+  { \"co_yield\",\t\tRID_CO_YIELD,\tD_CXX_COROUTINES_FLAGS | D_CXXWARN },\n+  { \"co_return\", \tRID_CO_RETURN,\tD_CXX_COROUTINES_FLAGS | D_CXXWARN },\n+\n   /* These Objective-C keywords are recognized only immediately after\n      an '@'.  */\n   { \"compatibility_alias\", RID_AT_ALIAS,\tD_OBJC },"}, {"sha": "59d4aaf44352fc0f1214fffedb2d719d4627ba80", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -189,6 +189,9 @@ enum rid\n   /* C++ concepts */\n   RID_CONCEPT, RID_REQUIRES,\n \n+  /* C++ coroutines */\n+  RID_CO_AWAIT, RID_CO_YIELD, RID_CO_RETURN,\n+\n   /* C++ transactional memory.  */\n   RID_ATOMIC_NOEXCEPT, RID_ATOMIC_CANCEL, RID_SYNCHRONIZED,\n \n@@ -433,9 +436,11 @@ extern machine_mode c_default_pointer_mode;\n #define D_TRANSMEM\t0X0800\t/* C++ transactional memory TS.  */\n #define D_CXX_CHAR8_T\t0X1000\t/* In C++, only with -fchar8_t.  */\n #define D_CXX20\t\t0x2000  /* In C++, C++20 only.  */\n+#define D_CXX_COROUTINES 0x4000  /* In C++, only with coroutines.  */\n \n #define D_CXX_CONCEPTS_FLAGS D_CXXONLY | D_CXX_CONCEPTS\n #define D_CXX_CHAR8_T_FLAGS D_CXXONLY | D_CXX_CHAR8_T\n+#define D_CXX_COROUTINES_FLAGS (D_CXXONLY | D_CXX_COROUTINES)\n \n /* The reserved keyword table.  */\n extern const struct c_common_resword c_common_reswords[];"}, {"sha": "a6308921dc9a5716b43c868a9fb335cff72e6c84", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -1017,6 +1017,8 @@ c_cpp_builtins (cpp_reader *pfile)\n           else\n             cpp_define (pfile, \"__cpp_concepts=201507L\");\n         }\n+      if (flag_coroutines)\n+\tcpp_define (pfile, \"__cpp_coroutines=201902L\"); /* n4835, C++20 CD */\n       if (flag_tm)\n \t/* Use a value smaller than the 201505 specified in\n \t   the TS, since we don't yet support atomic_cancel.  */"}, {"sha": "aa0fa5deae6e997447cfe4069e7e6517352a492c", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -1477,6 +1477,10 @@ fconstexpr-ops-limit=\n C++ ObjC++ Joined RejectNegative Host_Wide_Int Var(constexpr_ops_limit) Init(33554432)\n -fconstexpr-ops-limit=<number>\tSpecify maximum number of constexpr operations during a single constexpr evaluation.\n \n+fcoroutines\n+C++ LTO Var(flag_coroutines)\n+Enable C++ coroutines (experimental).\n+\n fdebug-cpp\n C ObjC C++ ObjC++\n Emit debug annotations during preprocessing."}, {"sha": "3839cb54faecb854e69dca383829f47b1eda7ce1", "filename": "gcc/coroutine-builtins.def", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcoroutine-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcoroutine-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoroutine-builtins.def?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,53 @@\n+/* This file contains the definitions and documentation for the\n+   coroutines builtins used in GCC.\n+\n+   Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+\n+ Contributed by Iain Sandoe <iain@sandoe.co.uk> under contract to Facebook.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Before including this file, you should define a macro:\n+\n+     DEF_BUILTIN_STUB(ENUM, NAME)\n+     DEF_COROUTINE_BUILTIN (ENUM, NAME, TYPE, ATTRS)\n+\n+   See builtins.def for details.\n+   The builtins are created used by library implementations of C++\n+   coroutines.  */\n+\n+/* This has to come before all the coroutine builtins.  */\n+DEF_BUILTIN_STUB (BEGIN_COROUTINE_BUILTINS, (const char *) 0)\n+\n+/* These are the builtins that are externally-visible and used by the\n+   standard library implementation of the coroutine header.  */\n+\n+DEF_COROUTINE_BUILTIN (BUILT_IN_CORO_PROMISE, \"promise\",\n+\t\t       BT_FN_PTR_PTR_CONST_SIZE_BOOL,\n+\t\t       ATTR_CONST_NOTHROW_LEAF_LIST)\n+\n+DEF_COROUTINE_BUILTIN (BUILT_IN_CORO_RESUME, \"resume\", BT_FN_VOID_PTR,\n+\t\t       ATTR_NULL)\n+\n+DEF_COROUTINE_BUILTIN (BUILT_IN_CORO_DESTROY, \"destroy\", BT_FN_VOID_PTR,\n+\t\t       ATTR_NULL)\n+\n+DEF_COROUTINE_BUILTIN (BUILT_IN_CORO_DONE, \"done\", BT_FN_BOOL_PTR,\n+\t\t       ATTR_NOTHROW_LEAF_LIST)\n+\n+/* This has to come after all the coroutine builtins.  */\n+DEF_BUILTIN_STUB (END_COROUTINE_BUILTINS, (const char *) 0)"}, {"sha": "d032a392ce656165daab46823ca708fb451fb460", "filename": "gcc/coroutine-passes.cc", "status": "added", "additions": 532, "deletions": 0, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcoroutine-passes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcoroutine-passes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoroutine-passes.cc?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,532 @@\n+/* coroutine expansion and optimisation passes.\n+\n+   Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+\n+ Contributed by Iain Sandoe <iain@sandoe.co.uk> under contract to Facebook.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"cgraph.h\"\n+#include \"pretty-print.h\"\n+#include \"diagnostic-core.h\"\n+#include \"fold-const.h\"\n+#include \"internal-fn.h\"\n+#include \"langhooks.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimplify-me.h\"\n+#include \"gimple-walk.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-into-ssa.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"cfghooks.h\"\n+\n+/* Here we:\n+   * lower the internal function that implements an exit from scope.\n+   * expand the builtins that are used to implement the library\n+     interfaces to the coroutine frame.  */\n+\n+static tree\n+lower_coro_builtin (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n+\t\t    struct walk_stmt_info *wi ATTRIBUTE_UNUSED)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  *handled_ops_p = !gimple_has_substatements (stmt);\n+\n+  if (gimple_code (stmt) != GIMPLE_CALL)\n+    return NULL_TREE;\n+\n+  /* This internal function implements an exit from scope without\n+     performing any cleanups; it jumps directly to the label provided.  */\n+  if (gimple_call_internal_p (stmt)\n+      && gimple_call_internal_fn (stmt) == IFN_CO_SUSPN)\n+    {\n+      tree dest = TREE_OPERAND (gimple_call_arg (stmt, 0), 0);\n+      ggoto *g = gimple_build_goto (dest);\n+      gsi_replace (gsi, g, /* do EH */ false);\n+      *handled_ops_p = true;\n+      return NULL_TREE;\n+    }\n+\n+  tree decl = gimple_call_fndecl (stmt);\n+  if (!decl || !fndecl_built_in_p (decl, BUILT_IN_NORMAL))\n+    return NULL_TREE;\n+\n+  /* The remaining builtins implement the library interfaces to the coro\n+     frame.  */\n+  unsigned call_idx = 0;\n+\n+  switch (DECL_FUNCTION_CODE (decl))\n+    {\n+    default:\n+      break;\n+    case BUILT_IN_CORO_PROMISE:\n+      {\n+\t/* If we are discarding this, then skip it; the function has no\n+\t   side-effects.  */\n+\ttree lhs = gimple_call_lhs (stmt);\n+\tif (!lhs)\n+\t  {\n+\t    gsi_remove (gsi, true);\n+\t    *handled_ops_p = true;\n+\t    return NULL_TREE;\n+\t  }\n+\t/* The coro frame starts with two pointers (to the resume and\n+\t   destroy() functions).  These are followed by the promise which\n+\t   is aligned as per type [or user attribute].\n+\t   The input pointer is the first argument.\n+\t   The promise alignment is the second and the third is a bool\n+\t   that is true when we are converting from a promise ptr to a\n+\t   frame pointer, and false for the inverse.  */\n+\ttree ptr = gimple_call_arg (stmt, 0);\n+\ttree align_t = gimple_call_arg (stmt, 1);\n+\ttree from = gimple_call_arg (stmt, 2);\n+\tgcc_checking_assert (TREE_CODE (align_t) == INTEGER_CST);\n+\tgcc_checking_assert (TREE_CODE (from) == INTEGER_CST);\n+\tbool dir = wi::to_wide (from) != 0;\n+\tHOST_WIDE_INT promise_align = TREE_INT_CST_LOW (align_t);\n+\tHOST_WIDE_INT psize =\n+\t  TREE_INT_CST_LOW (TYPE_SIZE_UNIT (ptr_type_node));\n+\tHOST_WIDE_INT align = TYPE_ALIGN_UNIT (ptr_type_node);\n+\talign = MAX (align, promise_align);\n+\tpsize *= 2; /* Start with two pointers.  */\n+\tpsize = ROUND_UP (psize, align);\n+\tHOST_WIDE_INT offs = dir ? -psize : psize;\n+\ttree repl = build2 (POINTER_PLUS_EXPR, ptr_type_node, ptr,\n+\t\t\t    size_int (offs));\n+\tgassign *grpl = gimple_build_assign (lhs, repl);\n+\tgsi_replace (gsi, grpl, true);\n+\t*handled_ops_p = true;\n+      }\n+      break;\n+    case BUILT_IN_CORO_DESTROY:\n+      call_idx = 1;\n+      /* FALLTHROUGH */\n+    case BUILT_IN_CORO_RESUME:\n+      {\n+\ttree ptr = gimple_call_arg (stmt, 0); /* frame ptr.  */\n+\tHOST_WIDE_INT psize =\n+\t  TREE_INT_CST_LOW (TYPE_SIZE_UNIT (ptr_type_node));\n+\tHOST_WIDE_INT offset = call_idx * psize;\n+\ttree fntype = TREE_TYPE (decl);\n+\ttree fntype_ptr = build_pointer_type (fntype);\n+\ttree fntype_ppp = build_pointer_type (fntype_ptr);\n+\ttree indirect = fold_build2 (MEM_REF, fntype_ptr, ptr,\n+\t\t\t\t     build_int_cst (fntype_ppp, offset));\n+\ttree f_ptr_tmp = make_ssa_name (TYPE_MAIN_VARIANT (fntype_ptr));\n+\tgassign *get_fptr = gimple_build_assign (f_ptr_tmp, indirect);\n+\tgsi_insert_before (gsi, get_fptr, GSI_SAME_STMT);\n+\tgimple_call_set_fn (static_cast<gcall *> (stmt), f_ptr_tmp);\n+\t*handled_ops_p = true;\n+      }\n+      break;\n+    case BUILT_IN_CORO_DONE:\n+      {\n+\t/* If we are discarding this, then skip it; the function has no\n+\t   side-effects.  */\n+\ttree lhs = gimple_call_lhs (stmt);\n+\tif (!lhs)\n+\t  {\n+\t    gsi_remove (gsi, true);\n+\t    *handled_ops_p = true;\n+\t    return NULL_TREE;\n+\t  }\n+\t/* When we're done, the resume fn is set to NULL.  */\n+\ttree ptr = gimple_call_arg (stmt, 0); /* frame ptr.  */\n+\ttree vpp = build_pointer_type (ptr_type_node);\n+\ttree indirect\n+\t  = fold_build2 (MEM_REF, vpp, ptr, build_int_cst (vpp, 0));\n+\ttree d_ptr_tmp = make_ssa_name (ptr_type_node);\n+\tgassign *get_dptr = gimple_build_assign (d_ptr_tmp, indirect);\n+\tgsi_insert_before (gsi, get_dptr, GSI_SAME_STMT);\n+\ttree done = fold_build2 (EQ_EXPR, boolean_type_node, d_ptr_tmp,\n+\t\t\t\t null_pointer_node);\n+\tgassign *get_res = gimple_build_assign (lhs, done);\n+\tgsi_replace (gsi, get_res, true);\n+\t*handled_ops_p = true;\n+      }\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Main entry point for lowering coroutine FE builtins.  */\n+\n+static unsigned int\n+execute_lower_coro_builtins (void)\n+{\n+  struct walk_stmt_info wi;\n+  gimple_seq body;\n+\n+  body = gimple_body (current_function_decl);\n+  memset (&wi, 0, sizeof (wi));\n+  walk_gimple_seq_mod (&body, lower_coro_builtin, NULL, &wi);\n+  gimple_set_body (current_function_decl, body);\n+\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_coroutine_lower_builtins = {\n+  GIMPLE_PASS,\t\t /* type */\n+  \"coro-lower-builtins\", /* name */\n+  OPTGROUP_NONE,\t /* optinfo_flags */\n+  TV_NONE,\t\t /* tv_id */\n+  0,\t\t\t /* properties_required */\n+  0,\t\t\t /* properties_provided */\n+  0,\t\t\t /* properties_destroyed */\n+  0,\t\t\t /* todo_flags_start */\n+  0\t\t\t /* todo_flags_finish */\n+};\n+\n+class pass_coroutine_lower_builtins : public gimple_opt_pass\n+{\n+public:\n+  pass_coroutine_lower_builtins (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_coroutine_lower_builtins, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_coroutines; };\n+\n+  virtual unsigned int execute (function *f ATTRIBUTE_UNUSED)\n+  {\n+    return execute_lower_coro_builtins ();\n+  }\n+\n+}; // class pass_coroutine_lower_builtins\n+\n+} // namespace\n+\n+gimple_opt_pass *\n+make_pass_coroutine_lower_builtins (gcc::context *ctxt)\n+{\n+  return new pass_coroutine_lower_builtins (ctxt);\n+}\n+\n+/* Expand the remaining coroutine IFNs.\n+\n+   In the front end we construct a single actor function that contains\n+   the coroutine state machine.\n+\n+   The actor function has three entry conditions:\n+    1. from the ramp, resume point 0 - to initial-suspend.\n+    2. when resume () is executed (resume point N).\n+    3. from the destroy () shim when that is executed.\n+\n+   The actor function begins with two dispatchers; one for resume and\n+   one for destroy (where the initial entry from the ramp is a special-\n+   case of resume point 0).\n+\n+   Each suspend point and each dispatch entry is marked with an IFN such\n+   that we can connect the relevant dispatchers to their target labels.\n+\n+   So, if we have:\n+\n+   CO_YIELD (NUM, FINAL, RES_LAB, DEST_LAB, FRAME_PTR)\n+\n+   This is await point NUM, and is the final await if FINAL is non-zero.\n+   The resume point is RES_LAB, and the destroy point is DEST_LAB.\n+\n+   We expect to find a CO_ACTOR (NUM) in the resume dispatcher and a\n+   CO_ACTOR (NUM+1) in the destroy dispatcher.\n+\n+   Initially, the intent of keeping the resume and destroy paths together\n+   is that the conditionals controlling them are identical, and thus there\n+   would be duplication of any optimisation of those paths if the split\n+   were earlier.\n+\n+   Subsequent inlining of the actor (and DCE) is then able to extract the\n+   resume and destroy paths as separate functions if that is found\n+   profitable by the optimisers.\n+\n+   Once we have remade the connections to their correct postions, we elide\n+   the labels that the front end inserted.  */\n+\n+static void\n+move_edge_and_update (edge e, basic_block old_bb, basic_block new_bb)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"redirecting edge from bb %u to bb %u\\n\", old_bb->index,\n+\t     new_bb->index);\n+\n+  e = redirect_edge_and_branch (e, new_bb);\n+  if (!e && dump_file)\n+    fprintf (dump_file, \"failed to redirect edge ..  \\n\");\n+\n+  /* Die if we failed.  */\n+  gcc_checking_assert (e);\n+}\n+\n+static unsigned int\n+execute_early_expand_coro_ifns (void)\n+{\n+  /* Don't rebuild stuff unless we have to. */\n+  unsigned int todoflags = 0;\n+  bool changed = false;\n+  /* Some of the possible YIELD points will hopefully have been removed by\n+     earlier optimisations; record the ones that are still present.  */\n+  hash_map<int_hash<HOST_WIDE_INT, -1, -2>, tree> destinations;\n+  /* Labels we added to carry the CFG changes, we need to remove these to\n+     avoid confusing EH.  */\n+  hash_set<tree> to_remove;\n+  /* List of dispatch points to update.  */\n+  auto_vec<gimple_stmt_iterator, 16> actor_worklist;\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+      {\n+\tgimple *stmt = gsi_stmt (gsi);\n+\n+\tif (!is_gimple_call (stmt) || !gimple_call_internal_p (stmt))\n+\t  {\n+\t    gsi_next (&gsi);\n+\t    continue;\n+\t  }\n+\tswitch (gimple_call_internal_fn (stmt))\n+\t  {\n+\t  case IFN_CO_FRAME:\n+\t    {\n+\t      /* This internal function is a placeholder for the frame\n+\t\t size.  In principle, we might lower it later (after some\n+\t\t optimisation had reduced the frame size).  At present,\n+\t\t without any such optimisation, we just set it here.  */\n+\t      tree lhs = gimple_call_lhs (stmt);\n+\t      tree size = gimple_call_arg (stmt, 0);\n+\t      /* Right now, this is a trivial operation - copy through\n+\t\t the size computed during initial layout.  */\n+\t      gassign *grpl = gimple_build_assign (lhs, size);\n+\t      gsi_replace (&gsi, grpl, true);\n+\t      gsi_next (&gsi);\n+\t    }\n+\t    break;\n+\t  case IFN_CO_ACTOR:\n+\t    changed = true;\n+\t    actor_worklist.safe_push (gsi); /* Save for later.  */\n+\t    gsi_next (&gsi);\n+\t    break;\n+\t  case IFN_CO_YIELD:\n+\t    {\n+\t      changed = true;\n+\t      /* .CO_YIELD (NUM, FINAL, RES_LAB, DEST_LAB, FRAME_PTR);\n+\t\t  NUM = await number.\n+\t\t  FINAL = 1 if this is the final_suspend() await.\n+\t\t  RES_LAB = resume point label.\n+\t\t  DEST_LAB = destroy point label.\n+\t\t  FRAME_PTR = is a null pointer with the type of the coro\n+\t\t\t      frame, so that we can resize, if needed.  */\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"saw CO_YIELD in BB %u\\n\", bb->index);\n+\t      tree num = gimple_call_arg (stmt, 0); /* yield point.  */\n+\t      HOST_WIDE_INT idx = TREE_INT_CST_LOW (num);\n+\t      bool existed;\n+\t      tree res_tgt = TREE_OPERAND (gimple_call_arg (stmt, 2), 0);\n+\t      tree &res_dest = destinations.get_or_insert (idx, &existed);\n+\t      if (existed && dump_file)\n+\t\t{\n+\t\t  fprintf (\n+\t\t    dump_file,\n+\t\t    \"duplicate YIELD RESUME point (\" HOST_WIDE_INT_PRINT_DEC\n+\t\t    \") ?\\n\",\n+\t\t    idx);\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS);\n+\t\t}\n+\t      else\n+\t\tres_dest = res_tgt;\n+\t      tree dst_tgt = TREE_OPERAND (gimple_call_arg (stmt, 3), 0);\n+\t      tree &dst_dest = destinations.get_or_insert (idx + 1, &existed);\n+\t      if (existed && dump_file)\n+\t\t{\n+\t\t  fprintf (\n+\t\t    dump_file,\n+\t\t    \"duplicate YIELD DESTROY point (\" HOST_WIDE_INT_PRINT_DEC\n+\t\t    \") ?\\n\",\n+\t\t    idx + 1);\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS);\n+\t\t}\n+\t      else\n+\t\tdst_dest = dst_tgt;\n+\t      to_remove.add (res_tgt);\n+\t      to_remove.add (dst_tgt);\n+\t      /* lose the co_yield.  */\n+\t      gsi_remove (&gsi, true);\n+\t      stmt = gsi_stmt (gsi); /* next. */\n+\t      /* lose the copy present at O0.  */\n+\t      if (is_gimple_assign (stmt))\n+\t\t{\n+\t\t  gsi_remove (&gsi, true);\n+\t\t  stmt = gsi_stmt (gsi);\n+\t\t}\n+\t      /* Simplify the switch or if following.  */\n+\t      if (gswitch *gsw = dyn_cast<gswitch *> (stmt))\n+\t\t{\n+\t\t  gimple_switch_set_index (gsw, integer_zero_node);\n+\t\t  fold_stmt (&gsi);\n+\t\t}\n+\t      else if (gcond *gif = dyn_cast<gcond *> (stmt))\n+\t\t{\n+\t\t  if (gimple_cond_code (gif) == EQ_EXPR)\n+\t\t    gimple_cond_make_true (gif);\n+\t\t  else\n+\t\t    gimple_cond_make_false (gif);\n+\t\t  fold_stmt (&gsi);\n+\t\t}\n+\t      else if (dump_file)\n+\t\tprint_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS);\n+\t      if (gsi_end_p (gsi))\n+\t\tbreak;\n+\t      continue;\n+\t    }\n+\t  default:\n+\t    gsi_next (&gsi);\n+\t    break;\n+\t  }\n+      }\n+\n+  if (!changed)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"coro: nothing to do\\n\");\n+      return todoflags;\n+    }\n+\n+  while (!actor_worklist.is_empty ())\n+    {\n+      gsi = actor_worklist.pop ();\n+      gimple *stmt = gsi_stmt (gsi);\n+      gcc_checking_assert (is_gimple_call (stmt)\n+\t\t\t   && gimple_call_internal_p (stmt)\n+\t\t\t   && gimple_call_internal_fn (stmt) == IFN_CO_ACTOR);\n+      bb = gsi_bb (gsi);\n+      HOST_WIDE_INT idx = TREE_INT_CST_LOW (gimple_call_arg (stmt, 0));\n+      tree *seen = destinations.get (idx);\n+      changed = true;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"saw CO_ACTOR in BB %u\\n\", bb->index);\n+\n+      if (!seen)\n+\t{\n+\t  /* If we never saw this index, it means that the CO_YIELD\n+\t  associated was elided during earlier optimisations, so we\n+\t  don't need to fix up the switch targets.  */\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"yield point \" HOST_WIDE_INT_PRINT_DEC\n+\t\t     \" not used, removing it .. \\n\",  idx);\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (stmt);\n+\t}\n+      else\n+\t{\n+\t  /* So we need to switch the target of this switch case to the\n+\t     relevant BB.  */\n+\t  basic_block new_bb = label_to_block (cfun, *seen);\n+\t  /* We expect the block we're modifying to contain a single\n+\t     CO_ACTOR() followed by a goto <switch default bb>.  */\n+\t  gcc_checking_assert (EDGE_COUNT (bb->succs) == 1);\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      basic_block old_bb = e->dest;\n+\t      move_edge_and_update (e, old_bb, new_bb);\n+\t    }\n+\t  gsi_remove (&gsi, true);\n+\t}\n+    }\n+\n+  /* Remove the labels we inserted to map our hidden CFG, this\n+     avoids confusing block merges when there are also EH labels.  */\n+  FOR_EACH_BB_FN (bb, cfun)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+      {\n+\tgimple *stmt = gsi_stmt (gsi);\n+\tif (glabel *glab = dyn_cast<glabel *> (stmt))\n+\t  {\n+\t    tree rem = gimple_label_label (glab);\n+\t    if (to_remove.contains (rem))\n+\t      {\n+\t\tgsi_remove (&gsi, true);\n+\t\tto_remove.remove (rem);\n+\t\tcontinue; /* We already moved to the next insn.  */\n+\t      }\n+\t  }\n+\telse\n+\t  break;\n+\tgsi_next (&gsi);\n+      }\n+\n+  /* Changed the CFG.  */\n+  todoflags |= TODO_cleanup_cfg;\n+  return todoflags;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_coroutine_early_expand_ifns = {\n+  GIMPLE_PASS,\t\t    /* type */\n+  \"coro-early-expand-ifns\", /* name */\n+  OPTGROUP_NONE,\t    /* optinfo_flags */\n+  TV_NONE,\t\t    /* tv_id */\n+  (PROP_cfg),\t\t    /* properties_required */\n+  0,\t\t\t    /* properties_provided */\n+  0,\t\t\t    /* properties_destroyed */\n+  0,\t\t\t    /* todo_flags_start */\n+  0\t\t\t    /* todo_flags_finish, set this in the fn. */\n+};\n+\n+class pass_coroutine_early_expand_ifns : public gimple_opt_pass\n+{\n+public:\n+  pass_coroutine_early_expand_ifns (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_coroutine_early_expand_ifns, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *f)\n+    {\n+      return flag_coroutines && f->coroutine_component;\n+    }\n+\n+  virtual unsigned int execute (function *f ATTRIBUTE_UNUSED)\n+  {\n+    return execute_early_expand_coro_ifns ();\n+  }\n+\n+}; // class pass_coroutine_expand_ifns\n+\n+} // namespace\n+\n+gimple_opt_pass *\n+make_pass_coroutine_early_expand_ifns (gcc::context *ctxt)\n+{\n+  return new pass_coroutine_early_expand_ifns (ctxt);\n+}"}, {"sha": "90665e1f8e35d11e65b9d1b1061547971a572fb8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -1,3 +1,39 @@\n+2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* Make-lang.in: Add coroutines.o.\n+\t* cp-tree.h (lang_decl-fn): coroutine_p, new bit.\n+\t(DECL_COROUTINE_P): New.\n+\t* lex.c (init_reswords): Enable keywords when the coroutine flag\n+\tis set,\n+\t* operators.def (co_await): New operator.\n+\t* call.c (add_builtin_candidates): Handle CO_AWAIT_EXPR.\n+\t(op_error): Likewise.\n+\t(build_new_op_1): Likewise.\n+\t(build_new_function_call): Validate coroutine builtin arguments.\n+\t* constexpr.c (potential_constant_expression_1): Handle\n+\tCO_AWAIT_EXPR, CO_YIELD_EXPR, CO_RETURN_EXPR.\n+\t* coroutines.cc: New file.\n+\t* cp-objcp-common.c (cp_common_init_ts): Add CO_AWAIT_EXPR,\n+\tCO_YIELD_EXPR, CO_RETRN_EXPR as TS expressions.\n+\t* cp-tree.def (CO_AWAIT_EXPR, CO_YIELD_EXPR, (CO_RETURN_EXPR): New.\n+\t* cp-tree.h (coro_validate_builtin_call): New.\n+\t* decl.c (emit_coro_helper): New.\n+\t(finish_function): Handle the case when a function is found to\n+\tbe a coroutine, perform the outlining and emit the outlined\n+\tfunctions. Set a bit to signal that this is a coroutine component.\n+\t* parser.c (enum required_token): New enumeration RT_CO_YIELD.\n+\t(cp_parser_unary_expression): Handle co_await.\n+\t(cp_parser_assignment_expression): Handle co_yield.\n+\t(cp_parser_statement): Handle RID_CO_RETURN.\n+\t(cp_parser_jump_statement): Handle co_return.\n+\t(cp_parser_operator): Handle co_await operator.\n+\t(cp_parser_yield_expression): New.\n+\t(cp_parser_required_error): Handle RT_CO_YIELD.\n+\t* pt.c (tsubst_copy): Handle CO_AWAIT_EXPR.\n+\t(tsubst_expr): Handle CO_AWAIT_EXPR, CO_YIELD_EXPR and\n+\tCO_RETURN_EXPRs.\n+\t* tree.c (cp_walk_subtrees): Likewise.\n+\n 2020-01-17  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/92531 - ICE with noexcept(lambda)."}, {"sha": "7896591dd4b2b995b05bc89e807af57680dc4a24", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -73,7 +73,7 @@ CXX_C_OBJS = attribs.o incpath.o \\\n # Language-specific object files for C++ and Objective C++.\n CXX_AND_OBJCXX_OBJS = \\\n \tcp/call.o cp/class.o cp/constexpr.o cp/constraint.o \\\n-\tcp/cp-gimplify.o \\\n+\tcp/coroutines.o cp/cp-gimplify.o \\\n \tcp/cp-objcp-common.o cp/cp-ubsan.o \\\n \tcp/cvt.o cp/cxx-pretty-print.o \\\n \tcp/decl.o cp/decl2.o cp/dump.o \\"}, {"sha": "d47747117b9344f7c92e317ffbed2e67c7e0c013", "filename": "gcc/cp/call.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -3173,6 +3173,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n     case ADDR_EXPR:\n     case COMPOUND_EXPR:\n     case COMPONENT_REF:\n+    case CO_AWAIT_EXPR:\n       return;\n \n     case COND_EXPR:\n@@ -4584,6 +4585,13 @@ build_new_function_call (tree fn, vec<tree, va_gc> **args,\n       result = build_over_call (cand, flags, complain);\n     }\n \n+  if (flag_coroutines\n+      && result\n+      && TREE_CODE (result) == CALL_EXPR\n+      && DECL_BUILT_IN_CLASS (TREE_OPERAND (CALL_EXPR_FN (result), 0))\n+\t  == BUILT_IN_NORMAL)\n+   result = coro_validate_builtin_call (result);\n+\n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);\n \n@@ -4942,6 +4950,16 @@ op_error (const op_location_t &loc,\n \t\t  opname, opname, arg1, TREE_TYPE (arg1));\n       break;\n \n+    case CO_AWAIT_EXPR:\n+      if (flag_diagnostics_show_caret)\n+\terror_at (loc, op_error_string (G_(\"%<operator %s%>\"), 1, match),\n+\t\t  opname, TREE_TYPE (arg1));\n+      else\n+\terror_at (loc, op_error_string (G_(\"%<operator %s%> in %<%s%E%>\"),\n+\t\t\t\t\t  1, match),\n+\t\t   opname, opname, arg1, TREE_TYPE (arg1));\n+      break;\n+\n     default:\n       if (arg2)\n \tif (flag_diagnostics_show_caret)\n@@ -6197,6 +6215,7 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \tcase ADDR_EXPR:\n \tcase COMPOUND_EXPR:\n \tcase COMPONENT_REF:\n+\tcase CO_AWAIT_EXPR:\n \t  result = NULL_TREE;\n \t  result_valid_p = true;\n \t  break;\n@@ -6489,6 +6508,7 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n     case ABS_EXPR:\n+    case CO_AWAIT_EXPR:\n       return cp_build_unary_op (code, arg1, false, complain);\n \n     case ARRAY_REF:"}, {"sha": "da70b358413b798780653274cb2b3e82d1f989fc", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -39,7 +39,7 @@ gtfiles=\"\\\n \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-format.c \\\n \\$(srcdir)/c-family/c-cppbuiltin.c \\$(srcdir)/c-family/c-pragma.c \\\n \\$(srcdir)/cp/call.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/constexpr.c \\\n-\\$(srcdir)/cp/constraint.cc \\\n+\\$(srcdir)/cp/constraint.cc \\$(srcdir)/cp/coroutines.cc \\\n \\$(srcdir)/cp/cp-gimplify.c \\\n \\$(srcdir)/cp/cp-lang.c \\$(srcdir)/cp/cp-objcp-common.c \\\n \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\"}, {"sha": "5864b67d4de0d2607e7623344bb0b36b79ef2093", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -7852,6 +7852,12 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     case ANNOTATE_EXPR:\n       return RECUR (TREE_OPERAND (t, 0), rval);\n \n+    /* Coroutine await, yield and return expressions are not.  */\n+    case CO_AWAIT_EXPR:\n+    case CO_YIELD_EXPR:\n+    case CO_RETURN_EXPR:\n+      return false;\n+\n     default:\n       if (objc_is_property_ref (t))\n \treturn false;"}, {"sha": "ad0e9efa2b73a985f32322e1c3841390409e2391", "filename": "gcc/cp/coroutines.cc", "status": "added", "additions": 3643, "deletions": 0, "changes": 3643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89"}, {"sha": "dfd8be978b4001c2e90e04c5a4be7759cd088077", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -551,6 +551,10 @@ cp_common_init_ts (void)\n   MARK_TS_EXP (SIMPLE_REQ);\n   MARK_TS_EXP (TYPE_REQ);\n \n+  MARK_TS_EXP (CO_AWAIT_EXPR);\n+  MARK_TS_EXP (CO_YIELD_EXPR);\n+  MARK_TS_EXP (CO_RETURN_EXPR);\n+\n   c_common_init_ts ();\n }\n "}, {"sha": "1454802bf68e8f62fd153261fb14b3a696cb788a", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -574,6 +574,30 @@ DEFTREECODE (DISJ_CONSTR, \"disj_constr\", tcc_expression, 2)\n    CHECK_CONSTR_ARGUMENTS are the template arguments */\n DEFTREECODE (CHECK_CONSTR, \"check_constr\", tcc_expression, 2)\n \n+/* The co_await expression is used to support coroutines.\n+\n+  Op 0 is the cast expresssion (potentially modified by the\n+  promise \"await_transform()\" method).\n+  Op1 is a proxy for the temp / coro frame slot 'e' value.\n+  Op2 is the initialiser for Op1 (Op0, potentially modified by any\n+  applicable 'co_await' operator).\n+  Op3 is a vector of the [0] e.ready, [1] e.suspend and [2] e.resume calls.\n+  Op4 is a mode : 0 (await) 1 (yield) 2 (initial) 3 (final) */\n+DEFTREECODE (CO_AWAIT_EXPR, \"co_await\", tcc_expression, 5)\n+\n+/* The co_yield expression is used to support coroutines.\n+\n+   Op0 is the original expr (for use in diagnostics)\n+   Op2 is the co_await derived from this. */\n+DEFTREECODE (CO_YIELD_EXPR, \"co_yield\", tcc_expression, 2)\n+\n+/* The co_return expression is used to support coroutines.\n+\n+   Op0 is the original expr, can be void (for use in diagnostics)\n+   Op2 is the promise return_xxxx call for Op0. */\n+\n+DEFTREECODE (CO_RETURN_EXPR, \"co_return\", tcc_expression, 2)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "3d76096b04142f5773a97b0e4a779b98f1c744bb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -2703,7 +2703,9 @@ struct GTY(()) lang_decl_fn {\n   unsigned has_dependent_explicit_spec_p : 1;\n   unsigned immediate_fn_p : 1;\n   unsigned maybe_deleted : 1;\n-  unsigned spare : 10;\n+  unsigned coroutine_p : 1;\n+\n+  unsigned spare : 9;\n \n   /* 32-bits padding on 64-bit host.  */\n \n@@ -4994,6 +4996,13 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define QUALIFIED_NAME_IS_TEMPLATE(NODE) \\\n   (TREE_LANG_FLAG_1 (SCOPE_REF_CHECK (NODE)))\n \n+/* [coroutines]\n+*/\n+\n+/* True if NODE is a co-routine FUNCTION_DECL.  */\n+#define DECL_COROUTINE_P(NODE) \\\n+  (LANG_DECL_FN_CHECK (DECL_COMMON_CHECK (NODE))->coroutine_p)\n+\n /* True for an OMP_ATOMIC that has dependent parameters.  These are stored\n    as an expr in operand 1, and integer_zero_node or clauses in operand 0.  */\n #define OMP_ATOMIC_DEPENDENT_P(NODE) \\\n@@ -7934,6 +7943,14 @@ extern tree cp_ubsan_maybe_instrument_downcast\t(location_t, tree, tree, tree);\n extern tree cp_ubsan_maybe_instrument_cast_to_vbase (location_t, tree, tree);\n extern void cp_ubsan_maybe_initialize_vtbl_ptrs (tree);\n \n+/* In coroutines.cc */\n+extern tree finish_co_return_stmt\t\t(location_t, tree);\n+extern tree finish_co_await_expr\t\t(location_t, tree);\n+extern tree finish_co_yield_expr\t\t(location_t, tree);\n+extern tree coro_validate_builtin_call\t\t(tree,\n+\t\t\t\t\t\t tsubst_flags_t = tf_warning_or_error);\n+extern bool morph_fn_to_coro\t\t\t(tree, tree *, tree *);\n+\n /* Inline bodies.  */\n \n inline tree"}, {"sha": "e58fecc9de72eac0ee13fc77304c32f2f400cf89", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -16783,6 +16783,36 @@ add_return_star_this_fixit (gcc_rich_location *richloc, tree fndecl)\n \t\t\t\t       indent);\n }\n \n+/* This function carries out the subset of finish_function operations needed\n+   to emit the compiler-generated outlined helper functions used by the\n+   coroutines implementation.  */\n+\n+static void\n+emit_coro_helper (tree helper)\n+{\n+  /* This is a partial set of the operations done by finish_function()\n+     plus emitting the result.  */\n+  set_cfun (NULL);\n+  current_function_decl = helper;\n+  begin_scope (sk_function_parms, NULL);\n+  store_parm_decls (DECL_ARGUMENTS (helper));\n+  announce_function (helper);\n+  allocate_struct_function (helper, false);\n+  cfun->language = ggc_cleared_alloc<language_function> ();\n+  poplevel (1, 0, 1);\n+  maybe_save_function_definition (helper);\n+  /* We must start each function with a clear fold cache.  */\n+  clear_fold_cache ();\n+  cp_fold_function (helper);\n+  DECL_CONTEXT (DECL_RESULT (helper)) = helper;\n+  BLOCK_SUPERCONTEXT (DECL_INITIAL (helper)) = helper;\n+  /* This function has coroutine IFNs that we should handle in middle\n+     end lowering.  */\n+  cfun->coroutine_component = true;\n+  cp_genericize (helper);\n+  expand_or_defer_fn (helper);\n+}\n+\n /* Finish up a function declaration and compile that function\n    all the way to assembler language output.  The free the storage\n    for the function definition. INLINE_P is TRUE if we just\n@@ -16795,6 +16825,10 @@ finish_function (bool inline_p)\n {\n   tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n+  tree resumer = NULL_TREE, destroyer = NULL_TREE;\n+  bool coro_p = flag_coroutines\n+\t\t&& !processing_template_decl\n+\t\t&& DECL_COROUTINE_P (fndecl);\n \n   /* When we get some parse errors, we can end up without a\n      current_function_decl, so cope.  */\n@@ -16821,6 +16855,25 @@ finish_function (bool inline_p)\n      error_mark_node.  */\n   gcc_assert (DECL_INITIAL (fndecl) == error_mark_node);\n \n+  if (coro_p)\n+    {\n+      if (!morph_fn_to_coro (fndecl, &resumer, &destroyer))\n+\t{\n+\t  DECL_SAVED_TREE (fndecl) = pop_stmt_list (DECL_SAVED_TREE (fndecl));\n+\t  poplevel (1, 0, 1);\n+\t  DECL_SAVED_TREE (fndecl) = error_mark_node;\n+\t  return fndecl;\n+\t}\n+\n+      /* We should handle coroutine IFNs in middle end lowering.  */\n+      cfun->coroutine_component = true;\n+\n+      if (use_eh_spec_block (fndecl))\n+\tfinish_eh_spec_block (TYPE_RAISES_EXCEPTIONS\n+\t\t\t      (TREE_TYPE (fndecl)),\n+\t\t\t      current_eh_spec_block);\n+    }\n+  else\n   /* For a cloned function, we've already got all the code we need;\n      there's no need to add any extra bits.  */\n   if (!DECL_CLONED_FUNCTION_P (fndecl))\n@@ -17064,6 +17117,13 @@ finish_function (bool inline_p)\n       && !DECL_OMP_DECLARE_REDUCTION_P (fndecl))\n     cp_genericize (fndecl);\n \n+  /* Emit the resumer and destroyer functions now.  */\n+  if (coro_p)\n+    {\n+      emit_coro_helper (resumer);\n+      emit_coro_helper (destroyer);\n+    }\n+\n  cleanup:\n   /* We're leaving the context of this function, so zap cfun.  It's still in\n      DECL_STRUCT_FUNCTION, and we'll restore it in tree_rest_of_compilation.  */"}, {"sha": "37282d56973495901c58acd08b00d95fc5069cc7", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -233,6 +233,8 @@ init_reswords (void)\n     mask |= D_CXX20;\n   if (!flag_concepts)\n     mask |= D_CXX_CONCEPTS;\n+  if (!flag_coroutines)\n+    mask |= D_CXX_COROUTINES;\n   if (!flag_tm)\n     mask |= D_TRANSMEM;\n   if (!flag_char8_t)"}, {"sha": "d2395355af3dd3667a05e4fe105039f65a0f4934", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -87,6 +87,7 @@ DEF_OPERATOR (\"++\", PREINCREMENT_EXPR, \"pp\", OVL_OP_FLAG_UNARY)\n DEF_OPERATOR (\"--\", PREDECREMENT_EXPR, \"mm\", OVL_OP_FLAG_UNARY)\n DEF_OPERATOR (\"->\", COMPONENT_REF, \"pt\", OVL_OP_FLAG_UNARY)\n DEF_OPERATOR (\"sizeof\", SIZEOF_EXPR, \"sz\", OVL_OP_FLAG_UNARY)\n+DEF_OPERATOR (\"co_await\", CO_AWAIT_EXPR, \"aw\", OVL_OP_FLAG_UNARY)\n \n /* These are extensions.  */\n DEF_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"az\", OVL_OP_FLAG_UNARY)"}, {"sha": "75e32fcebcbe94775ead99ce512bd48c4d038056", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 83, "deletions": 6, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -177,7 +177,9 @@ enum required_token {\n   RT_CLASS_TYPENAME_TEMPLATE, /* class, typename, or template */\n   RT_TRANSACTION_ATOMIC, /* __transaction_atomic */\n   RT_TRANSACTION_RELAXED, /* __transaction_relaxed */\n-  RT_TRANSACTION_CANCEL /* __transaction_cancel */\n+  RT_TRANSACTION_CANCEL, /* __transaction_cancel */\n+\n+  RT_CO_YIELD /* co_yield */\n };\n \n /* RAII wrapper for parser->in_type_id_in_expr_p, setting it on creation and\n@@ -2471,6 +2473,12 @@ static void cp_parser_function_transaction\n static tree cp_parser_transaction_cancel\n   (cp_parser *);\n \n+/* Coroutine extensions.  */\n+\n+static tree cp_parser_yield_expression\n+  (cp_parser *);\n+\n+\n enum pragma_context {\n   pragma_external,\n   pragma_member,\n@@ -8112,6 +8120,7 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n      postfix-expression\n      ++ cast-expression\n      -- cast-expression\n+     await-expression\n      unary-operator cast-expression\n      sizeof unary-expression\n      sizeof ( type-id )\n@@ -8326,6 +8335,22 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t\t\t    noexcept_loc);\n \t  }\n \n+\tcase RID_CO_AWAIT:\n+\t  {\n+\t    tree expr;\n+\t    location_t kw_loc = token->location;\n+\n+\t    /* Consume the `co_await' token.  */\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t    /* Parse its cast-expression.  */\n+\t    expr = cp_parser_simple_cast_expression (parser);\n+\t    if (expr == error_mark_node)\n+\t      return error_mark_node;\n+\n+\t    /* Handle [expr.await].  */\n+\t    return cp_expr (finish_co_await_expr (kw_loc, expr));\n+\t  }\n+\n \tdefault:\n \t  break;\n \t}\n@@ -9757,6 +9782,7 @@ cp_parser_question_colon_clause (cp_parser* parser, cp_expr logical_or_expr)\n      conditional-expression\n      logical-or-expression assignment-operator assignment_expression\n      throw-expression\n+     yield-expression\n \n    CAST_P is true if this expression is the target of a cast.\n    DECLTYPE_P is true if this expression is the operand of decltype.\n@@ -9773,6 +9799,10 @@ cp_parser_assignment_expression (cp_parser* parser, cp_id_kind * pidk,\n      a throw-expression.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_THROW))\n     expr = cp_parser_throw_expression (parser);\n+  /* If the next token is the `co_yield' keyword, then we're looking at\n+     a yield-expression.  */\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_CO_YIELD))\n+    expr = cp_parser_yield_expression (parser);\n   /* Otherwise, it must be that we are looking at a\n      logical-or-expression.  */\n   else\n@@ -11271,6 +11301,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \tcase RID_BREAK:\n \tcase RID_CONTINUE:\n \tcase RID_RETURN:\n+\tcase RID_CO_RETURN:\n \tcase RID_GOTO:\n \t  std_attrs = process_stmt_hotness_attribute (std_attrs, attrs_loc);\n \t  statement = cp_parser_jump_statement (parser);\n@@ -12915,6 +12946,7 @@ cp_parser_init_statement (cp_parser *parser, tree *decl)\n      continue ;\n      return expression [opt] ;\n      return braced-init-list ;\n+     coroutine-return-statement;\n      goto identifier ;\n \n    GNU extension:\n@@ -12985,6 +13017,7 @@ cp_parser_jump_statement (cp_parser* parser)\n       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       break;\n \n+    case RID_CO_RETURN:\n     case RID_RETURN:\n       {\n \ttree expr;\n@@ -13002,8 +13035,11 @@ cp_parser_jump_statement (cp_parser* parser)\n \t  /* If the next token is a `;', then there is no\n \t     expression.  */\n \t  expr = NULL_TREE;\n-\t/* Build the return-statement.  */\n-\tif (FNDECL_USED_AUTO (current_function_decl) && in_discarded_stmt)\n+\t/* Build the return-statement, check co-return first, since type\n+\t   deduction is not valid there.  */\n+\tif (keyword == RID_CO_RETURN)\n+\t  statement = finish_co_return_stmt (token->location, expr);\n+\telse if (FNDECL_USED_AUTO (current_function_decl) && in_discarded_stmt)\n \t  /* Don't deduce from a discarded return statement.  */;\n \telse\n \t  statement = finish_return_stmt (expr);\n@@ -15383,22 +15419,25 @@ cp_parser_operator (cp_parser* parser, location_t start_loc)\n     {\n     case CPP_KEYWORD:\n       {\n-\t/* The keyword should be either `new' or `delete'.  */\n+\t/* The keyword should be either `new', `delete' or `co_await'.  */\n \tif (token->keyword == RID_NEW)\n \t  op = NEW_EXPR;\n \telse if (token->keyword == RID_DELETE)\n \t  op = DELETE_EXPR;\n+\telse if (token->keyword == RID_CO_AWAIT)\n+\t  op = CO_AWAIT_EXPR;\n \telse\n \t  break;\n \n-\t/* Consume the `new' or `delete' token.  */\n+\t/* Consume the `new', `delete' or co_await token.  */\n \tend_loc = cp_lexer_consume_token (parser->lexer)->location;\n \n \t/* Peek at the next token.  */\n \ttoken = cp_lexer_peek_token (parser->lexer);\n \t/* If it's a `[' token then this is the array variant of the\n \t   operator.  */\n-\tif (token->type == CPP_OPEN_SQUARE)\n+\tif (token->type == CPP_OPEN_SQUARE\n+\t    && op != CO_AWAIT_EXPR)\n \t  {\n \t    /* Consume the `[' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n@@ -26085,6 +26124,41 @@ cp_parser_throw_expression (cp_parser* parser)\n   return expression;\n }\n \n+/* Parse a yield-expression.\n+\n+   yield-expression:\n+     co_yield assignment-expression\n+     co_yield braced-init-list\n+\n+   Returns a CO_YIELD_EXPR representing the yield-expression.  */\n+\n+static tree\n+cp_parser_yield_expression (cp_parser* parser)\n+{\n+  tree expr;\n+\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  location_t kw_loc = token->location; /* Save for later.  */\n+\n+  cp_parser_require_keyword (parser, RID_CO_YIELD, RT_CO_YIELD);\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+    {\n+      bool expr_non_constant_p;\n+      cp_lexer_set_source_position (parser->lexer);\n+      /* ??? : probably a moot point?  */\n+      maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n+      expr = cp_parser_braced_list (parser, &expr_non_constant_p);\n+    }\n+  else\n+    expr = cp_parser_assignment_expression (parser);\n+\n+  if (expr == error_mark_node)\n+    return expr;\n+\n+  return finish_co_yield_expr (kw_loc, expr);\n+}\n+\n /* GNU Extensions */\n \n /* Parse an (optional) asm-specification.\n@@ -30337,6 +30411,9 @@ cp_parser_required_error (cp_parser *parser,\n       case RT_TRANSACTION_RELAXED:\n \tgmsgid = G_(\"expected %<__transaction_relaxed%>\");\n \tbreak;\n+      case RT_CO_YIELD:\n+\tgmsgid = G_(\"expected %<co_yield%>\");\n+\tbreak;\n       default:\n \tbreak;\n     }"}, {"sha": "cad97514cdc2a9d574f8c467d66d765e6bf2183d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -16814,6 +16814,11 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t to the containing function, inlined copy or so.  */\n       return t;\n \n+    case CO_AWAIT_EXPR:\n+      return tsubst_expr (t, args, complain, in_decl,\n+\t\t\t  /*integral_constant_expression_p=*/false);\n+      break;\n+\n     default:\n       /* We shouldn't get here, but keep going if !flag_checking.  */\n       if (flag_checking)\n@@ -17680,6 +17685,22 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       finish_return_stmt (RECUR (TREE_OPERAND (t, 0)));\n       break;\n \n+    case CO_RETURN_EXPR:\n+      finish_co_return_stmt (input_location, RECUR (TREE_OPERAND (t, 0)));\n+      break;\n+\n+    case CO_YIELD_EXPR:\n+      stmt = finish_co_yield_expr (input_location,\n+\t\t\t\t   RECUR (TREE_OPERAND (t, 0)));\n+      RETURN (stmt);\n+      break;\n+\n+    case CO_AWAIT_EXPR:\n+      stmt = finish_co_await_expr (input_location,\n+\t\t\t\t   RECUR (TREE_OPERAND (t, 0)));\n+      RETURN (stmt);\n+      break;\n+\n     case EXPR_STMT:\n       tmp = RECUR (EXPR_STMT_EXPR (t));\n       if (EXPR_STMT_STMT_EXPR_RESULT (t))"}, {"sha": "21f733af48629d8577011cd0d2c06e705e2ebd6b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -5068,6 +5068,37 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n \tWALK_SUBTREE (TREE_VALUE (cap));\n       break;\n \n+    case CO_YIELD_EXPR:\n+      if (TREE_OPERAND (*tp, 1))\n+\t/* Operand 1 is the tree for the relevant co_await which has any\n+\t   interesting sub-trees.  */\n+\tWALK_SUBTREE (TREE_OPERAND (*tp, 1));\n+      break;\n+\n+    case CO_AWAIT_EXPR:\n+      if (TREE_OPERAND (*tp, 1))\n+\t/* Operand 1 is frame variable.  */\n+\tWALK_SUBTREE (TREE_OPERAND (*tp, 1));\n+      if (TREE_OPERAND (*tp, 2))\n+\t/* Operand 2 has the initialiser, and we need to walk any subtrees\n+\t   there.  */\n+\tWALK_SUBTREE (TREE_OPERAND (*tp, 2));\n+      break;\n+\n+    case CO_RETURN_EXPR:\n+      if (TREE_OPERAND (*tp, 0))\n+\t{\n+\t  if (VOID_TYPE_P (TREE_OPERAND (*tp, 0)))\n+\t    /* For void expressions, operand 1 is a trivial call, and any\n+\t       interesting subtrees will be part of operand 0.  */\n+\t    WALK_SUBTREE (TREE_OPERAND (*tp, 0));\n+\t  else if (TREE_OPERAND (*tp, 1))\n+\t    /* Interesting sub-trees will be in the return_value () call\n+\t       arguments.  */\n+\t    WALK_SUBTREE (TREE_OPERAND (*tp, 1));\n+\t}\n+      break;\n+\n     default:\n       return NULL_TREE;\n     }"}, {"sha": "bbd03f87c6750167a7246d45bcdaaf72e8cd0b73", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -2628,6 +2628,10 @@ of a loop too many expressions need to be evaluated, the resulting constexpr\n evaluation might take too long.\n The default is 33554432 (1<<25).\n \n+@item -fcoroutines\n+@opindex fcoroutines\n+Enable support for the C++ coroutines extension (experimental).\n+\n @item -fno-elide-constructors\n @opindex fno-elide-constructors\n @opindex felide-constructors"}, {"sha": "1ee8ed3de53f8d3c637ad5640d6360a0c66b3342", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -418,6 +418,9 @@ struct GTY(()) function {\n   /* Set when the function was compiled with generation of debug\n      (begin stmt, inline entry, ...) markers enabled.  */\n   unsigned int debug_nonbind_markers : 1;\n+\n+  /* Set if this is a coroutine-related function.  */\n+  unsigned int coroutine_component : 1;\n };\n \n /* Add the decl D to the local_decls list of FUN.  */"}, {"sha": "52d1638917a5202bc33cb0e36df97603c46dd0d2", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -2884,6 +2884,32 @@ expand_NOP (internal_fn, gcall *)\n   /* Nothing.  But it shouldn't really prevail.  */\n }\n \n+/* Coroutines, all should have been processed at this stage.  */\n+\n+static void\n+expand_CO_FRAME (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+static void\n+expand_CO_YIELD (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+static void\n+expand_CO_SUSPN (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+static void\n+expand_CO_ACTOR (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Expand a call to FN using the operands in STMT.  FN has a single\n    output operand and NARGS input operands.  */\n "}, {"sha": "1d190d492ff17ed8ff10d6ca83bb8b1afe635653", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -366,6 +366,12 @@ DEF_INTERNAL_FN (LAUNDER, ECF_LEAF | ECF_NOTHROW | ECF_NOVOPS, NULL)\n /* Divmod function.  */\n DEF_INTERNAL_FN (DIVMOD, ECF_CONST | ECF_LEAF, NULL)\n \n+/* For coroutines.  */\n+DEF_INTERNAL_FN (CO_ACTOR, ECF_NOTHROW | ECF_LEAF, NULL)\n+DEF_INTERNAL_FN (CO_YIELD, ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (CO_SUSPN, ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (CO_FRAME, ECF_PURE | ECF_NOTHROW | ECF_LEAF, NULL)\n+\n /* A NOP function with arbitrary arguments and return value.  */\n DEF_INTERNAL_FN (NOP, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n "}, {"sha": "2bf2cb78fc50b64ca2fc01d226960a95987787f9", "filename": "gcc/passes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -39,8 +39,10 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_lower_tm);\n   NEXT_PASS (pass_refactor_eh);\n   NEXT_PASS (pass_lower_eh);\n+  NEXT_PASS (pass_coroutine_lower_builtins);\n   NEXT_PASS (pass_build_cfg);\n   NEXT_PASS (pass_warn_function_return);\n+  NEXT_PASS (pass_coroutine_early_expand_ifns);\n   NEXT_PASS (pass_expand_omp);\n   NEXT_PASS (pass_warn_printf);\n   NEXT_PASS (pass_walloca, /*strict_mode_p=*/true);"}, {"sha": "14273ae3bd6cb1ee7b803930a17d3cbcc31c2bd8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -1,3 +1,123 @@\n+2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* g++.dg/coroutines/co-await-syntax-00-needs-expr.C: New test.\n+\t* g++.dg/coroutines/co-await-syntax-01-outside-fn.C: New test.\n+\t* g++.dg/coroutines/co-await-syntax-02-outside-fn.C: New test.\n+\t* g++.dg/coroutines/co-await-syntax-03-auto.C: New test.\n+\t* g++.dg/coroutines/co-await-syntax-04-ctor-dtor.C: New test.\n+\t* g++.dg/coroutines/co-await-syntax-05-constexpr.C: New test.\n+\t* g++.dg/coroutines/co-await-syntax-06-main.C: New test.\n+\t* g++.dg/coroutines/co-await-syntax-07-varargs.C: New test.\n+\t* g++.dg/coroutines/co-await-syntax-08-lambda-auto.C: New test.\n+\t* g++.dg/coroutines/co-return-syntax-01-outside-fn.C: New test.\n+\t* g++.dg/coroutines/co-return-syntax-02-outside-fn.C: New test.\n+\t* g++.dg/coroutines/co-return-syntax-03-auto.C: New test.\n+\t* g++.dg/coroutines/co-return-syntax-04-ctor-dtor.C: New test.\n+\t* g++.dg/coroutines/co-return-syntax-05-constexpr-fn.C: New test.\n+\t* g++.dg/coroutines/co-return-syntax-06-main.C: New test.\n+\t* g++.dg/coroutines/co-return-syntax-07-vararg.C: New test.\n+\t* g++.dg/coroutines/co-return-syntax-08-bad-return.C: New test.\n+\t* g++.dg/coroutines/co-return-syntax-09-lambda-auto.C: New test.\n+\t* g++.dg/coroutines/co-yield-syntax-00-needs-expr.C: New test.\n+\t* g++.dg/coroutines/co-yield-syntax-01-outside-fn.C: New test.\n+\t* g++.dg/coroutines/co-yield-syntax-02-outside-fn.C: New test.\n+\t* g++.dg/coroutines/co-yield-syntax-03-auto.C: New test.\n+\t* g++.dg/coroutines/co-yield-syntax-04-ctor-dtor.C: New test.\n+\t* g++.dg/coroutines/co-yield-syntax-05-constexpr.C: New test.\n+\t* g++.dg/coroutines/co-yield-syntax-06-main.C: New test.\n+\t* g++.dg/coroutines/co-yield-syntax-07-varargs.C: New test.\n+\t* g++.dg/coroutines/co-yield-syntax-08-needs-expr.C: New test.\n+\t* g++.dg/coroutines/co-yield-syntax-09-lambda-auto.C: New test.\n+\t* g++.dg/coroutines/coro-builtins.C: New test.\n+\t* g++.dg/coroutines/coro-missing-gro.C: New test.\n+\t* g++.dg/coroutines/coro-missing-promise-yield.C: New test.\n+\t* g++.dg/coroutines/coro-missing-ret-value.C: New test.\n+\t* g++.dg/coroutines/coro-missing-ret-void.C: New test.\n+\t* g++.dg/coroutines/coro-missing-ueh-1.C: New test.\n+\t* g++.dg/coroutines/coro-missing-ueh-2.C: New test.\n+\t* g++.dg/coroutines/coro-missing-ueh-3.C: New test.\n+\t* g++.dg/coroutines/coro-missing-ueh.h: New test.\n+\t* g++.dg/coroutines/coro-pre-proc.C: New test.\n+\t* g++.dg/coroutines/coro.h: New file.\n+\t* g++.dg/coroutines/coro1-ret-int-yield-int.h: New file.\n+\t* g++.dg/coroutines/coroutines.exp: New file.\n+\t* g++.dg/coroutines/torture/alloc-00-gro-on-alloc-fail.C: New test.\n+\t* g++.dg/coroutines/torture/alloc-01-overload-newdel.C: New test.\n+\t* g++.dg/coroutines/torture/call-00-co-aw-arg.C: New test.\n+\t* g++.dg/coroutines/torture/call-01-multiple-co-aw.C: New test.\n+\t* g++.dg/coroutines/torture/call-02-temp-co-aw.C: New test.\n+\t* g++.dg/coroutines/torture/call-03-temp-ref-co-aw.C: New test.\n+\t* g++.dg/coroutines/torture/class-00-co-ret.C: New test.\n+\t* g++.dg/coroutines/torture/class-01-co-ret-parm.C: New test.\n+\t* g++.dg/coroutines/torture/class-02-templ-parm.C: New test.\n+\t* g++.dg/coroutines/torture/class-03-operator-templ-parm.C: New test.\n+\t* g++.dg/coroutines/torture/class-04-lambda-1.C: New test.\n+\t* g++.dg/coroutines/torture/class-05-lambda-capture-copy-local.C: New test.\n+\t* g++.dg/coroutines/torture/class-06-lambda-capture-ref.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-00-trivial.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-01-with-value.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-02-xform.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-03-rhs-op.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-04-control-flow.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-05-loop.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-06-ovl.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-07-tmpl.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-08-cascade.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-09-pair.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-10-template-fn-arg.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-11-forwarding.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-12-operator-2.C: New test.\n+\t* g++.dg/coroutines/torture/co-await-13-return-ref.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-00-void-return-is-ready.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-01-void-return-is-suspend.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-03-different-GRO-type.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-04-GRO-nontriv.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-05-return-value.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-06-template-promise-val-1.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-07-void-cast-expr.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-08-template-cast-ret.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-09-bool-await-susp.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-10-expression-evaluates-once.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-11-co-ret-co-await.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-12-co-ret-fun-co-await.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-13-template-2.C: New test.\n+\t* g++.dg/coroutines/torture/co-ret-14-template-3.C: New test.\n+\t* g++.dg/coroutines/torture/co-yield-00-triv.C: New test.\n+\t* g++.dg/coroutines/torture/co-yield-01-multi.C: New test.\n+\t* g++.dg/coroutines/torture/co-yield-02-loop.C: New test.\n+\t* g++.dg/coroutines/torture/co-yield-03-tmpl.C: New test.\n+\t* g++.dg/coroutines/torture/co-yield-04-complex-local-state.C: New test.\n+\t* g++.dg/coroutines/torture/co-yield-05-co-aw.C: New test.\n+\t* g++.dg/coroutines/torture/co-yield-06-fun-parm.C: New test.\n+\t* g++.dg/coroutines/torture/co-yield-07-template-fn-param.C: New test.\n+\t* g++.dg/coroutines/torture/co-yield-08-more-refs.C: New test.\n+\t* g++.dg/coroutines/torture/co-yield-09-more-templ-refs.C: New test.\n+\t* g++.dg/coroutines/torture/coro-torture.exp: New file.\n+\t* g++.dg/coroutines/torture/exceptions-test-0.C: New test.\n+\t* g++.dg/coroutines/torture/func-params-00.C: New test.\n+\t* g++.dg/coroutines/torture/func-params-01.C: New test.\n+\t* g++.dg/coroutines/torture/func-params-02.C: New test.\n+\t* g++.dg/coroutines/torture/func-params-03.C: New test.\n+\t* g++.dg/coroutines/torture/func-params-04.C: New test.\n+\t* g++.dg/coroutines/torture/func-params-05.C: New test.\n+\t* g++.dg/coroutines/torture/func-params-06.C: New test.\n+\t* g++.dg/coroutines/torture/lambda-00-co-ret.C: New test.\n+\t* g++.dg/coroutines/torture/lambda-01-co-ret-parm.C: New test.\n+\t* g++.dg/coroutines/torture/lambda-02-co-yield-values.C: New test.\n+\t* g++.dg/coroutines/torture/lambda-03-auto-parm-1.C: New test.\n+\t* g++.dg/coroutines/torture/lambda-04-templ-parm.C: New test.\n+\t* g++.dg/coroutines/torture/lambda-05-capture-copy-local.C: New test.\n+\t* g++.dg/coroutines/torture/lambda-06-multi-capture.C: New test.\n+\t* g++.dg/coroutines/torture/lambda-07-multi-yield.C: New test.\n+\t* g++.dg/coroutines/torture/lambda-08-co-ret-parm-ref.C: New test.\n+\t* g++.dg/coroutines/torture/local-var-0.C: New test.\n+\t* g++.dg/coroutines/torture/local-var-1.C: New test.\n+\t* g++.dg/coroutines/torture/local-var-2.C: New test.\n+\t* g++.dg/coroutines/torture/local-var-3.C: New test.\n+\t* g++.dg/coroutines/torture/local-var-4.C: New test.\n+\t* g++.dg/coroutines/torture/mid-suspend-destruction-0.C: New test.\n+\t* g++.dg/coroutines/torture/pr92933.C: New test.\n+\n 2020-01-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/93234"}, {"sha": "d068c3d19af1a333fea14b5c178dedfa7b37bb97", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-00-needs-expr.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-00-needs-expr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-00-needs-expr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-00-needs-expr.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,7 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+void bar () {\n+  co_await;  // { dg-error \"expected primary-expression before\" }\n+}"}, {"sha": "484859c7062e478fc324137c191c98239af953ee", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-01-outside-fn.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-01-outside-fn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-01-outside-fn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-01-outside-fn.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,5 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+int x = co_await coro::suspend_always{}; // { dg-error {'co_await' cannot be used outside a function} }"}, {"sha": "4ce5c2e04a0abda0e3d240109e57d97b12441171", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-02-outside-fn.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-02-outside-fn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-02-outside-fn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-02-outside-fn.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,5 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+auto f (int x = co_await coro::suspend_always{}); // { dg-error {'co_await' cannot be used outside a function} }"}, {"sha": "7f4ed9afef53951943315e077aeee1f4b48a5052", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-03-auto.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-03-auto.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-03-auto.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-03-auto.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,16 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+extern struct awaitable *aw ();\n+\n+auto bar () {\n+  int x = 1 + co_await *aw();  // { dg-error \"cannot be used in a function with a deduced return type\" }\n+  \n+  return x;\n+}\n+\n+int main () {\n+  bar ();\n+  return 0;\n+}"}, {"sha": "ac0ba2e54f86e8b427d4c9fc4f448b2a57034d4e", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-04-ctor-dtor.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-04-ctor-dtor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-04-ctor-dtor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-04-ctor-dtor.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,8 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+struct Foo {\n+  Foo ()  { co_await coro::suspend_always{}; } // { dg-error \"cannot be used in a constructor\" }\n+  ~Foo () { co_await coro::suspend_always{}; } // { dg-error \"cannot be used in a destructor\" }\n+};"}, {"sha": "73a0b1499d48ecd0fb5b0c0fdb2ab50c23eac021", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-05-constexpr.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-05-constexpr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-05-constexpr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-05-constexpr.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,12 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+constexpr int bar () {\n+  co_await coro::suspend_always{}; // { dg-error \"cannot be used in a .constexpr. function\" }\n+  return 42; /* Suppress the \"no return\" error.  */\n+}\n+\n+int main () {\n+  return bar ();\n+}"}, {"sha": "ab520baaff145cc050ea2f77b37bfc58b43cb1da", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-06-main.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-06-main.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-06-main.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-06-main.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,7 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+int main (int ac, char *av[]) {\n+  co_await coro::suspend_always{}; // { dg-error \"cannot be used in the .main. function\" }\n+}"}, {"sha": "4e41dd3be4aff17614d061eab0896cb55eec8b2a", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-07-varargs.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-07-varargs.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-07-varargs.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-07-varargs.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,14 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+int\n+bar (int x, ...)\n+{\n+  co_await coro::suspend_always{}; // { dg-error \"cannot be used in a varargs function\" }\n+}\n+\n+int main (int ac, char *av[]) {\n+  bar (5, ac);\n+  return 0;\n+}"}, {"sha": "61db5feed32c150d2c48b65970ed79a2237efd0d", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-08-lambda-auto.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-08-lambda-auto.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-08-lambda-auto.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-08-lambda-auto.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,19 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+// Check that we decline return type deduction for lambda coroutines.\n+\n+#include \"coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  /* Attempt to deduce the return type for a lambda coroutine.  */\n+  auto f = []()\n+  {\n+    co_await coro::suspend_always{}; // { dg-error \"cannot be used in a function with a deduced return type\" }\n+  };\n+\n+  return 0;\n+}"}, {"sha": "3fcd8dd104d95fa68e5b18212967078e7e1955a0", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-01-outside-fn.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-01-outside-fn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-01-outside-fn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-01-outside-fn.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,6 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+co_return; // { dg-error {expected unqualified-id before 'co_return'} }\n+"}, {"sha": "cda36eb2a3dfd408761a9949e37d8a7e9c2c2471", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-02-outside-fn.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-02-outside-fn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-02-outside-fn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-02-outside-fn.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,5 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+auto f (co_return); // { dg-error {expected primary-expression before 'co_return'} }"}, {"sha": "93a04dc459aa917b339835a1c0b9a13e46cb1cbd", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-03-auto.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-03-auto.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-03-auto.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-03-auto.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,12 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+auto bar () {\n+  co_return 5;  // { dg-error \"cannot be used in a function with a deduced return type\" }\n+}\n+\n+int main () {\n+  bar ();\n+  return 0;\n+}"}, {"sha": "9396432e8bfdec94ba51c7425b88c8876067f15f", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-04-ctor-dtor.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-04-ctor-dtor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-04-ctor-dtor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-04-ctor-dtor.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,8 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+struct Foo {\n+  Foo ()  { co_return; } // { dg-error \"cannot be used in a constructor\" }\n+  ~Foo () { co_return 5; } // { dg-error \"cannot be used in a destructor\" }\n+};"}, {"sha": "69b109fb604761b13922ceb644a2b6c4ed90d50d", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-05-constexpr-fn.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-05-constexpr-fn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-05-constexpr-fn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-05-constexpr-fn.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,12 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+constexpr int bar () {\n+  co_return 5; // { dg-error \"cannot be used in a .constexpr. function\" }\n+  return 42; /* Suppress the \"no return\" error.  */\n+}\n+\n+int main () {\n+  return bar ();\n+}"}, {"sha": "40d7e4e36231d4ba4ee7f449e6aa4ef4cf72d337", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-06-main.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-06-main.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-06-main.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-06-main.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,7 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+int main (int ac, char *av[]) {\n+  co_return 0; // { dg-error \"cannot be used in the .main. function\" }\n+}"}, {"sha": "0aea17a1db8a078dfe0c7a2c9040bff56b17d461", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-07-vararg.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-07-vararg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-07-vararg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-07-vararg.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,14 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+int\n+bar (int x, ...)\n+{\n+  co_return 1; // { dg-error \"cannot be used in a varargs function\" }\n+}\n+\n+int main (int ac, char *av[]) {\n+  bar (5, ac);\n+  return 0;\n+}"}, {"sha": "4bfa41cd4a980f6e0d39407a77a75e3a4820a280", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-08-bad-return.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-08-bad-return.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-08-bad-return.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-08-bad-return.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,43 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+struct Coro {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<Coro::promise_type>;\n+  handle_type handle;\n+  Coro () : handle(0) {}\n+  Coro (handle_type _handle) : handle(_handle) {}\n+  Coro (Coro &&s) : handle(s.handle) { s.handle = nullptr; }\n+  Coro &operator = (Coro &&s) {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\treturn *this;\n+  }\n+  Coro (const Coro &) = delete;\n+  ~Coro() {\n+    if ( handle )\n+      handle.destroy();\n+  }\n+  struct promise_type {\n+  promise_type() {}\n+  ~promise_type() {}\n+  Coro get_return_object () { return Coro (handle_type::from_promise (*this)); }\n+  auto initial_suspend () { return coro::suspend_always{}; }\n+  auto final_suspend () { return coro::suspend_always{}; }\n+  void return_void () { }\n+   void unhandled_exception() { }\n+  };\n+};\n+\n+extern int x;\n+\n+// Diagnose disallowed \"return\" in coroutine.\n+Coro\n+bar () // { dg-error {a 'return' statement is not allowed} }\n+{\n+  if (x)\n+    return Coro(); \n+  else\n+    co_return;\n+}"}, {"sha": "8fe52361ba20adfb6650c0fe80174069a9ee7312", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-09-lambda-auto.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-09-lambda-auto.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-09-lambda-auto.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-09-lambda-auto.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,19 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+// Check that we decline return type deduction for lambda coroutines.\n+\n+#include \"coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  /* Attempt to deduce the return type for a lambda coroutine.  */\n+  auto f = []()\n+  {\n+    co_return 42; // { dg-error \"cannot be used in a function with a deduced return type\" }\n+  };\n+\n+  return 0;\n+}"}, {"sha": "547f1a31c0c66795ca9550fabd307869fd0745a0", "filename": "gcc/testsuite/g++.dg/coroutines/co-yield-syntax-00-needs-expr.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-00-needs-expr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-00-needs-expr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-00-needs-expr.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,7 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+void foo () {\n+  co_yield;  // { dg-error \"expected primary-expression before\" }\n+}"}, {"sha": "30db0e963b09be34c206a512af622464bfeaa5e2", "filename": "gcc/testsuite/g++.dg/coroutines/co-yield-syntax-01-outside-fn.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-01-outside-fn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-01-outside-fn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-01-outside-fn.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,6 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+auto f (int x = co_yield 5); // { dg-error {'co_yield' cannot be used outside a function} }\n+"}, {"sha": "71e119fbef3fd62c543006f10849c58de862e752", "filename": "gcc/testsuite/g++.dg/coroutines/co-yield-syntax-02-outside-fn.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-02-outside-fn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-02-outside-fn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-02-outside-fn.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,6 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+int a[] = { co_yield 21 }; // { dg-error {'co_yield' cannot be used outside a function} }\n+"}, {"sha": "808a07f5e1400b4a08ecad170cf4a37639b2e649", "filename": "gcc/testsuite/g++.dg/coroutines/co-yield-syntax-03-auto.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-03-auto.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-03-auto.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-03-auto.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,12 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+auto bar () {\n+  co_yield 5;  // { dg-error \"cannot be used in a function with a deduced return type\" }\n+}\n+\n+int main () {\n+  bar ();\n+  return 0;\n+}"}, {"sha": "cc46e01d778692749072c7346d736f53c5b80152", "filename": "gcc/testsuite/g++.dg/coroutines/co-yield-syntax-04-ctor-dtor.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-04-ctor-dtor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-04-ctor-dtor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-04-ctor-dtor.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,8 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+struct Foo {\n+  Foo ()  { co_yield 4; } // { dg-error \"cannot be used in a constructor\" }\n+  ~Foo () { co_yield 4; } // { dg-error \"cannot be used in a destructor\" }\n+};"}, {"sha": "39ef19c63b9b45c71098c3e1a300c5e9caff31cc", "filename": "gcc/testsuite/g++.dg/coroutines/co-yield-syntax-05-constexpr.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-05-constexpr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-05-constexpr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-05-constexpr.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,12 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+constexpr int bar () {\n+  co_yield 5; // { dg-error \"cannot be used in a .constexpr. function\" }\n+  return 42; /* Suppress the \"no return\" error.  */\n+}\n+\n+int main () {\n+  return bar ();\n+}"}, {"sha": "dcc3dbce756f7cdca0debca58055e483bbd0acc9", "filename": "gcc/testsuite/g++.dg/coroutines/co-yield-syntax-06-main.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-06-main.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-06-main.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-06-main.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,7 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+int main (int ac, char *av[]) {\n+  co_yield 0; // { dg-error \"cannot be used in the .main. function\" }\n+}"}, {"sha": "f0b568335e4769304dc8564a902c7cae80b09c64", "filename": "gcc/testsuite/g++.dg/coroutines/co-yield-syntax-07-varargs.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-07-varargs.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-07-varargs.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-07-varargs.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,14 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+int\n+bar (int x, ...)\n+{\n+  co_yield 1; // { dg-error \"cannot be used in a varargs function\" }\n+}\n+\n+int main (int ac, char *av[]) {\n+  bar (5, ac);\n+  return 0;\n+}"}, {"sha": "86969f781e4ae5c997f5cc0ace8e8856ee8daa2a", "filename": "gcc/testsuite/g++.dg/coroutines/co-yield-syntax-08-needs-expr.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-08-needs-expr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-08-needs-expr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-08-needs-expr.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,37 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+// Check syntax for missing expr in a coroutine context.\n+\n+#include \"coro.h\"\n+\n+struct DummyYield {\n+  coro::coroutine_handle<> handle;\n+  DummyYield () : handle (nullptr) {}\n+  DummyYield (coro::coroutine_handle<> handle) : handle (handle) {}\n+  struct dummy_yield {\n+    coro::suspend_never initial_suspend() { return {}; }\n+    coro::suspend_never final_suspend() { return {}; }\n+    DummyYield get_return_object() {\n+      return DummyYield (coro::coroutine_handle<dummy_yield>::from_promise (*this));\n+    }\n+    void yield_value (int v) {}\n+    void return_value (int v) {}\n+    void unhandled_exception() { /*std::terminate();*/ };\n+  };\n+};\n+\n+template<> struct coro::coroutine_traits<DummyYield> {\n+    using promise_type = DummyYield::dummy_yield;\n+};\n+\n+DummyYield\n+bar ()\n+{\n+  co_yield; // { dg-error {expected primary-expression before} }\n+  co_return 0;\n+}\n+\n+int main (int ac, char *av[]) {\n+  DummyYield x = bar ();\n+  return 0;\n+}"}, {"sha": "5190face000c6d8749d5df620435df811ebe9067", "filename": "gcc/testsuite/g++.dg/coroutines/co-yield-syntax-09-lambda-auto.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-09-lambda-auto.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-09-lambda-auto.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-yield-syntax-09-lambda-auto.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,19 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+// Check that we decline return type deduction for lambda coroutines.\n+\n+#include \"coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  /* Attempt to deduce the return type for a lambda coroutine.  */\n+  auto f = []()\n+  {\n+    co_yield 42; // { dg-error \"cannot be used in a function with a deduced return type\" }\n+  };\n+\n+  return 0;\n+}"}, {"sha": "d7c48833844bbec5cb402d2375a119f1c6976807", "filename": "gcc/testsuite/g++.dg/coroutines/coro-builtins.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-builtins.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-builtins.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-builtins.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,17 @@\n+//  { dg-additional-options \"-fsyntax-only \" }\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+int main ()\n+{\n+  void *co_h;\n+  void *promise;\n+  const size_t co_align = 16;\n+\n+  bool d = __builtin_coro_done (co_h);\n+  __builtin_coro_resume (co_h);\n+  __builtin_coro_destroy (co_h);\n+  promise = __builtin_coro_promise (co_h, co_align, true);\n+\n+  return 0;\n+}"}, {"sha": "fb02e9d5801b3d6bb85045018f4ddf53c998223c", "filename": "gcc/testsuite/g++.dg/coroutines/coro-missing-gro.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-gro.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-gro.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-gro.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,32 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+// Diagose missing get_return_object() in the promise type.\n+\n+#include \"coro.h\"\n+\n+struct MissingGRO {\n+  coro::coroutine_handle<> handle;\n+  MissingGRO () : handle (nullptr) {}\n+  MissingGRO (coro::coroutine_handle<> handle) : handle (handle) {}\n+  struct missing_gro {\n+    coro::suspend_never initial_suspend() { return {}; }\n+    coro::suspend_never final_suspend() { return {}; }\n+    void return_void () {}\n+    void unhandled_exception() { /*std::terminate();*/ };\n+  };\n+};\n+\n+template<> struct coro::coroutine_traits<MissingGRO> {\n+    using promise_type = MissingGRO::missing_gro;\n+};\n+\n+MissingGRO\n+bar () // { dg-error {no member named 'get_return_object' in} }\n+{ \n+  co_return;\n+}\n+\n+int main (int ac, char *av[]) {\n+  MissingGRO x = bar ();\n+  return 0;\n+}"}, {"sha": "d489c3953ac9d22179109f0f0e2f8f2230606f1b", "filename": "gcc/testsuite/g++.dg/coroutines/coro-missing-promise-yield.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-promise-yield.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-promise-yield.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-promise-yield.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,33 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+#include \"coro.h\"\n+\n+struct MissingPromiseYield {\n+  coro::coroutine_handle<> handle;\n+  MissingPromiseYield () : handle (nullptr) {}\n+  MissingPromiseYield (coro::coroutine_handle<> handle) : handle (handle) {}\n+  struct missing_yield {\n+    coro::suspend_never initial_suspend() { return {}; }\n+    coro::suspend_never final_suspend() { return {}; }\n+    MissingPromiseYield get_return_object() {\n+      return MissingPromiseYield (coro::coroutine_handle<missing_yield>::from_promise (*this));\n+    }\n+    void return_value (int v) {}\n+    void unhandled_exception() { /*std::terminate();*/ };\n+  };\n+};\n+\n+template<> struct coro::coroutine_traits<MissingPromiseYield> {\n+    using promise_type = MissingPromiseYield::missing_yield;\n+};\n+\n+MissingPromiseYield\n+bar ()\n+{\n+  co_yield 22; // { dg-error {no member named 'yield_value' in} }\n+  co_return 0;\n+}\n+\n+int main (int ac, char *av[]) {\n+  MissingPromiseYield x = bar ();\n+  return 0;\n+}"}, {"sha": "f238c4b9a3543ad80fc4eff64f4d99792b5cacb9", "filename": "gcc/testsuite/g++.dg/coroutines/coro-missing-ret-value.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ret-value.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ret-value.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ret-value.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,34 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+// Diagose missing return_value() in the promise type.\n+\n+#include \"coro.h\"\n+\n+struct MissingRetValue {\n+  coro::coroutine_handle<> handle;\n+  MissingRetValue () : handle (nullptr) {}\n+  MissingRetValue (coro::coroutine_handle<> handle) : handle (handle) {}\n+  struct missing_retvoid {\n+    coro::suspend_never initial_suspend() { return {}; }\n+    coro::suspend_never final_suspend() { return {}; }\n+    MissingRetValue get_return_object() {\n+      return MissingRetValue (coro::coroutine_handle<missing_retvoid>::from_promise (*this));\n+    }\n+    void unhandled_exception() { /*std::terminate();*/ };\n+  };\n+};\n+\n+template<> struct coro::coroutine_traits<MissingRetValue> {\n+    using promise_type = MissingRetValue::missing_retvoid;\n+};\n+\n+MissingRetValue\n+bar ()\n+{\n+  co_return 6174; // { dg-error {no member named 'return_value' in} }\n+}\n+\n+int main (int ac, char *av[]) {\n+  MissingRetValue x = bar ();\n+  return 0;\n+}"}, {"sha": "c9f84e59020b2e9115ec88da2c12c080a83896f9", "filename": "gcc/testsuite/g++.dg/coroutines/coro-missing-ret-void.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ret-void.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ret-void.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ret-void.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,34 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+#include \"coro.h\"\n+\n+// Diagose missing return_void() in the promise type.\n+\n+struct MissingRetVoid {\n+  coro::coroutine_handle<> handle;\n+  MissingRetVoid () : handle (nullptr) {}\n+  MissingRetVoid (coro::coroutine_handle<> handle) : handle (handle) {}\n+  struct missing_retvoid {\n+    coro::suspend_never initial_suspend() { return {}; }\n+    coro::suspend_never final_suspend() { return {}; }\n+    MissingRetVoid get_return_object() {\n+      return MissingRetVoid (coro::coroutine_handle<missing_retvoid>::from_promise (*this));\n+    }\n+    void unhandled_exception() { /*std::terminate();*/ };\n+  };\n+};\n+\n+template<> struct coro::coroutine_traits<MissingRetVoid> {\n+    using promise_type = MissingRetVoid::missing_retvoid;\n+};\n+\n+MissingRetVoid\n+bar ()\n+{\n+  co_return; // { dg-error \"no member named .return_void. in\" }\n+}\n+\n+int main (int ac, char *av[]) {\n+  MissingRetVoid x = bar ();\n+  return 0;\n+}"}, {"sha": "3943e78d9d596f1c070297e2e48401f64fe35fba", "filename": "gcc/testsuite/g++.dg/coroutines/coro-missing-ueh-1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh-1.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,17 @@\n+//  { dg-additional-options \"-fsyntax-only -fexceptions -w\" }\n+\n+// Diagose missing unhandled_exception() in the promise type.\n+\n+#include \"coro.h\"\n+#include \"coro-missing-ueh.h\"\n+\n+MissingUEH\n+bar () // { dg-error {no member named 'unhandled_exception' in} }\n+{ \n+  co_return;\n+}\n+\n+int main (int ac, char *av[]) {\n+  MissingUEH x = bar ();\n+  return 0;\n+}"}, {"sha": "0f105c4c2d819a72b55a96deb5fa99ad4b78de1b", "filename": "gcc/testsuite/g++.dg/coroutines/coro-missing-ueh-2.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh-2.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,18 @@\n+//  { dg-additional-options \"-fsyntax-only -fno-exceptions \" }\n+\n+// The missing method is warned for when exceptions are off and pedantic\n+// is on (default in the testsuite).\n+\n+#include \"coro.h\"\n+#include \"coro-missing-ueh.h\"\n+\n+MissingUEH\n+bar () // { dg-warning {no member named 'unhandled_exception' in} }\n+{ \n+  co_return;\n+}\n+\n+int main (int ac, char *av[]) {\n+  MissingUEH x = bar ();\n+  return 0;\n+}"}, {"sha": "d775d8a630e6767458b4a13193a0062ad8dd138f", "filename": "gcc/testsuite/g++.dg/coroutines/coro-missing-ueh-3.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh-3.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,18 @@\n+//  { dg-additional-options \"-fsyntax-only -fno-exceptions -Wno-pedantic\" }\n+\n+/* We don't warn about the missing method, unless in pedantic mode, so\n+   this compile should be clean.  */\n+\n+#include \"coro.h\"\n+#include \"coro-missing-ueh.h\"\n+\n+MissingUEH\n+bar ()\n+{ \n+  co_return;\n+}\n+\n+int main (int ac, char *av[]) {\n+  MissingUEH x = bar ();\n+  return 0;\n+}"}, {"sha": "51e6135b8a76bec1257295a521eded3665347eb5", "filename": "gcc/testsuite/g++.dg/coroutines/coro-missing-ueh.h", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-missing-ueh.h?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,23 @@\n+#ifndef __MissingUEH_H\n+#define __MissingUEH_H\n+\n+/* Common code for testing missing unhandled_exception.  */\n+struct MissingUEH {\n+  coro::coroutine_handle<> handle;\n+  MissingUEH () : handle (nullptr) {}\n+  MissingUEH (coro::coroutine_handle<> handle) : handle (handle) {}\n+  struct missing_ueh {\n+    coro::suspend_never initial_suspend() { return {}; }\n+    coro::suspend_never final_suspend() { return {}; }\n+    MissingUEH get_return_object() {\n+      return MissingUEH (coro::coroutine_handle<missing_ueh>::from_promise (*this));\n+    }\n+    void return_void () {}\n+  };\n+};\n+\n+template<> struct coro::coroutine_traits<MissingUEH> {\n+    using promise_type = MissingUEH::missing_ueh;\n+};\n+\n+#endif"}, {"sha": "f22a5e08332d05f7c77ab79ec570dad1e5451614", "filename": "gcc/testsuite/g++.dg/coroutines/coro-pre-proc.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-pre-proc.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-pre-proc.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-pre-proc.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,9 @@\n+// Only need to compile this, with the default options from the .exp.\n+\n+#ifndef __cpp_coroutines\n+#error \"coroutines should engaged.\"\n+#endif\n+\n+#if __cpp_coroutines != 201902L\n+#error \"coroutine version out of sync.\"\n+#endif"}, {"sha": "31336549f82be5112919f311c1695b5f4eae489f", "filename": "gcc/testsuite/g++.dg/coroutines/coro.h", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro.h?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,152 @@\n+#if __has_include(<coroutine>)\n+\n+#include <coroutine>\n+\n+#  if __clang__\n+#    include <utility>\n+#  endif\n+\n+namespace coro = std;\n+\n+#elif __has_include(<experimental/coroutine>)\n+\n+#include <experimental/coroutine>\n+\n+#  if __clang__\n+#    include <utility>\n+#  endif\n+\n+namespace coro = std::experimental;\n+\n+#else\n+\n+#warning \"no installed coroutine headers found, using test-suite local one\"\n+\n+/* Dummy version to allow tests without an installed header.  */\n+#  ifndef __TESTSUITE_CORO_H_n4835\n+#  define __TESTSUITE_CORO_H_n4835\n+\n+// Fragments (with short-cuts) to mimic enough of the library header to\n+// make some progress.\n+\n+#  if __cpp_coroutines\n+\n+namespace std {\n+inline namespace __n4835 {\n+\n+// 21.11.1 coroutine traits\n+template<typename _R, typename...> struct coroutine_traits {\n+  using promise_type = typename _R::promise_type;\n+};\n+\n+// 21.11.2  coroutine handle\n+template <typename Promise = void> struct coroutine_handle;\n+\n+template <> \n+struct coroutine_handle<void> {\n+  public:\n+      // 21.11.2.1 construct/reset\n+  constexpr coroutine_handle () noexcept\n+    : __fr_ptr (0) {}\n+  constexpr coroutine_handle (decltype(nullptr) __h) noexcept\n+    : __fr_ptr (__h) {}\n+  coroutine_handle &operator= (decltype(nullptr)) noexcept {\n+    __fr_ptr = nullptr;\n+    return *this;\n+  }\n+\n+  public:\n+    // 21.11.2.2 export/import\n+    constexpr void *address () const noexcept { return __fr_ptr; }\n+    constexpr static coroutine_handle from_address (void *__a) noexcept {\n+      coroutine_handle __self;\n+      __self.__fr_ptr = __a;\n+      return __self;\n+    }\n+  public:\n+      // 21.11.2.3 observers\n+    constexpr explicit operator bool () const noexcept {\n+      return bool (__fr_ptr);\n+    }\n+    bool done () const noexcept {\n+      return __builtin_coro_done (__fr_ptr);\n+    }\n+      // 21.11.2.4 resumption\n+    void operator () () const { resume (); }\n+    void resume () const {\n+      __builtin_coro_resume (__fr_ptr);\n+    }\n+    void destroy () const {\n+      __builtin_coro_destroy (__fr_ptr);\n+    }\n+  protected:\n+    void *__fr_ptr;\n+};\n+\n+template <class _Promise>\n+struct coroutine_handle : coroutine_handle<> {\n+  // 21.11.2.1 construct/reset\n+  using coroutine_handle<>::coroutine_handle;\n+  static coroutine_handle from_promise(_Promise &p) {\n+    coroutine_handle __self;\n+    __self.__fr_ptr = \n+      __builtin_coro_promise((char *)&p,  __alignof(_Promise), true);\n+    return __self;\n+  }\n+  coroutine_handle& operator=(decltype(nullptr)) noexcept {\n+    coroutine_handle<>::operator=(nullptr);\n+    return *this;\n+  }\n+  // 21.11.2.2 export/import\n+  constexpr static coroutine_handle from_address(void* __a){\n+    coroutine_handle __self;\n+    __self.__fr_ptr = __a;\n+    return __self;\n+  }\n+  // 21.11.2.5 promise access\n+  _Promise& promise() const {\n+    void * __t = __builtin_coro_promise(this->__fr_ptr,\n+\t\t\t\t\t__alignof(_Promise), false);\n+    return *static_cast<_Promise*>(__t);\n+  }\n+};\n+\n+// n4760 - 21.11.5 trivial awaitables\n+\n+struct suspend_always {\n+  bool await_ready() { return false; }\n+  void await_suspend(coroutine_handle<>) {}\n+  void await_resume() {}\n+};\n+\n+struct suspend_never {\n+  bool await_ready() { return true; }\n+  void await_suspend(coroutine_handle<>) {}\n+  void await_resume() {}\n+};\n+\n+} // namespace __n4835\n+} // namespace std\n+\n+namespace coro = std;\n+\n+#  else\n+#    error \"coro.h requires support for coroutines, add -fcoroutines\"\n+#  endif\n+#  endif // __TESTSUITE_CORO_H_n4835\n+\n+#endif // __has_include(<experimental/coroutine>)\n+\n+/* just to avoid cluttering dump files. */\n+extern \"C\" int puts (const char *);\n+extern \"C\" int printf (const char *, ...);\n+\n+#include <cstdlib> /* for abort () */\n+\n+#ifndef OUTPUT\n+#  define PRINT(X)\n+#  define PRINTF (void)\n+#else\n+#  define PRINT(X) puts(X)\n+#  define PRINTF printf\n+#endif"}, {"sha": "b961755e472e590291bf7d9354d3ab00f18f0c2a", "filename": "gcc/testsuite/g++.dg/coroutines/coro1-ret-int-yield-int.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro1-ret-int-yield-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro1-ret-int-yield-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro1-ret-int-yield-int.h?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,133 @@\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() {\n+        PRINT(\"Destroyed coro1\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  // Some awaitables to use in tests.\n+  // With progress printing for debug.\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  ~suspend_always_prt() { PRINT (\"susp-always-dtor\"); }\n+  };\n+\n+  struct suspend_always_intprt {\n+    int x;\n+    suspend_always_intprt() : x(5) {}\n+    suspend_always_intprt(int __x) : x(__x) {}\n+    ~suspend_always_intprt() {}\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(coro::coroutine_handle<>) const noexcept { PRINT (\"susp-always-susp-intprt\");}\n+    int await_resume() const noexcept { PRINT (\"susp-always-resume-intprt\"); return x;}\n+  };\n+  \n+  /* This returns the square of the int that it was constructed with.  */\n+  struct suspend_always_longprtsq {\n+    long x;\n+    suspend_always_longprtsq() : x(12L) { PRINT (\"suspend_always_longprtsq def ctor\"); }\n+    suspend_always_longprtsq(long _x) : x(_x) { PRINTF (\"suspend_always_longprtsq ctor with %ld\\n\", x); }\n+    ~suspend_always_longprtsq() {}\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(coro::coroutine_handle<>) const noexcept { PRINT (\"susp-always-susp-longsq\");}\n+    long await_resume() const noexcept { PRINT (\"susp-always-resume-longsq\"); return x * x;}\n+  };\n+\n+  struct suspend_always_intrefprt {\n+    int& x;\n+    suspend_always_intrefprt(int& __x) : x(__x) {}\n+    ~suspend_always_intrefprt() {}\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(coro::coroutine_handle<>) const noexcept { PRINT (\"susp-always-susp-intprt\");}\n+    int& await_resume() const noexcept { PRINT (\"susp-always-resume-intprt\"); return x;}\n+  };\n+\n+  struct promise_type {\n+\n+  promise_type() : vv(-1) {  PRINT (\"Created Promise\"); }\n+  promise_type(int __x) : vv(__x) {  PRINTF (\"Created Promise with %d\\n\",__x); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+\n+#ifdef USE_AWAIT_TRANSFORM\n+\n+  auto await_transform (int v) {\n+    PRINTF (\"await_transform an int () %d\\n\",v);\n+    return suspend_always_intprt (v);\n+  }\n+\n+  auto await_transform (long v) {\n+    PRINTF (\"await_transform a long () %ld\\n\",v);\n+    return suspend_always_longprtsq (v);\n+  }\n+\n+#endif\n+\n+  auto yield_value (int v) {\n+    PRINTF (\"yield_value (%d)\\n\", v);\n+    vv = v;\n+    return suspend_always_prt{};\n+  }\n+\n+#ifdef RETURN_VOID\n+\n+  void return_void () {\n+    PRINT (\"return_void ()\");\n+  }\n+\n+#else\n+\n+  void return_value (int v) {\n+    PRINTF (\"return_value (%d)\\n\", v);\n+    vv = v;\n+  }\n+\n+#endif\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+\n+  int get_value () { return vv; }\n+  private:\n+    int vv;\n+  };\n+\n+};"}, {"sha": "e7fd4dac461bf2b52ec9e96c72c0b86ca249261f", "filename": "gcc/testsuite/g++.dg/coroutines/coroutines.exp", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoroutines.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoroutines.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoroutines.exp?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,50 @@\n+#   Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+\n+# Contributed by Iain Sandoe <iain@sandoe.co.uk> under contract to Facebook.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Test C++ coroutines, requires c++17; doesn't, at present, seem much \n+# point in repeating these for other versions.\n+\n+# Load support procs.\n+load_lib g++-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CXXFLAGS\n+if ![info exists DEFAULT_CXXFLAGS] then {\n+    set DEFAULT_CXXFLAGS \" -pedantic-errors -Wno-long-long\"\n+}\n+\n+set DEFAULT_COROFLAGS $DEFAULT_CXXFLAGS\n+lappend DEFAULT_COROFLAGS \"-std=c++17\" \"-fcoroutines\"\n+\n+dg-init\n+\n+# Run the tests.\n+# g++-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C]] \\\n+#        \"\" $DEFAULT_COROFLAGS\n+\n+foreach test [lsort [find $srcdir/$subdir {*.[CH]}]] {\n+    if [runtest_file_p $runtests $test] {\n+        set nshort [file tail [file dirname $test]]/[file tail $test]\n+        verbose \"Testing $nshort $DEFAULT_COROFLAGS\" 1\n+        dg-test $test \"\" $DEFAULT_COROFLAGS\n+        set testcase [string range $test [string length \"$srcdir/\"] end]\n+    }\n+}\n+\n+# done.\n+dg-finish"}, {"sha": "8430d053c65f801e878d59f31a214b08378462f5", "filename": "gcc/testsuite/g++.dg/coroutines/torture/alloc-00-gro-on-alloc-fail.C", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-00-gro-on-alloc-fail.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-00-gro-on-alloc-fail.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-00-gro-on-alloc-fail.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,118 @@\n+//  { dg-do run }\n+\n+// check the code-gen for the failed alloc return.\n+\n+#include \"../coro.h\"\n+\n+#if __has_include(<new>)\n+#  include <new>\n+#else\n+\n+// Required when get_return_object_on_allocation_failure() is defined by\n+// the promise.\n+// we need a no-throw new, and new etc.  build the relevant pieces here to\n+// avoid needing the headers in the test.\n+\n+namespace std {\n+  struct nothrow_t {};\n+  constexpr nothrow_t nothrow = {};\n+  typedef __SIZE_TYPE__ size_t;\n+} // end namespace std\n+\n+void* operator new(std::size_t, const std::nothrow_t&) noexcept;\n+void  operator delete(void* __p, const std::nothrow_t&) noexcept;\n+#endif\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () noexcept : handle(0) {}\n+  coro1 (handle_type _handle) noexcept\n+    : handle(_handle)  {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) noexcept : handle(s.handle)  {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) noexcept {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() noexcept {\n+        PRINT(\"Destroyed coro1\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  ~suspend_never_prt() {};\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  };\n+\n+  struct promise_type {\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_void () {\n+    PRINT (\"return_void ()\");\n+  }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  static coro1 get_return_object_on_allocation_failure () noexcept;\n+  }; // promise\n+}; // coro1\n+\n+coro1 coro1::promise_type::\n+get_return_object_on_allocation_failure () noexcept {\n+  PRINT (\"alloc fail return\");\n+  return coro1 (nullptr);\n+}\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "f779f6e4863417d4cff83560ef887a5bca554ff7", "filename": "gcc/testsuite/g++.dg/coroutines/torture/alloc-01-overload-newdel.C", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-01-overload-newdel.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-01-overload-newdel.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-01-overload-newdel.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,120 @@\n+//  { dg-do run }\n+\n+// check codegen for overloaded operator new/delete.\n+\n+#include \"../coro.h\"\n+\n+int used_ovl_new = 0;\n+int used_ovl_del = 0;\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () noexcept : handle(0) {}\n+  coro1 (handle_type _handle) noexcept\n+    : handle(_handle)  {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) noexcept : handle(s.handle)  {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) noexcept {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() noexcept {\n+        PRINT(\"Destroyed coro1\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  ~suspend_never_prt() {};\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  };\n+\n+  struct promise_type {\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  void *operator new (std::size_t sz) {\n+    PRINT (\"promise_type: used overloaded operator new\");\n+    used_ovl_new++;\n+    return ::operator new(sz);\n+  }\n+\n+  void operator delete (void *p)  {\n+    PRINT (\"promise_type: used overloaded operator delete\");\n+    used_ovl_del++;\n+    return ::operator delete(p);\n+  }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_void () {\n+    PRINT (\"return_void ()\");\n+  }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  }; // promise\n+}; // coro1\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  // Nest a scope so that we can inspect the flags after the DTORs run.\n+  {\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  }\n+  if (used_ovl_new != 1)\n+    {\n+      PRINT (\"main: failed to call overloaded operator new\");\n+      abort ();\n+    }\n+  if (used_ovl_del != 1)\n+    {\n+      PRINT (\"main: failed to call overloaded operator delete\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "ee108072f690e17546112313355b435d574d58f3", "filename": "gcc/testsuite/g++.dg/coroutines/torture/call-00-co-aw-arg.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-00-co-aw-arg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-00-co-aw-arg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-00-co-aw-arg.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,73 @@\n+// { dg-do run }\n+\n+// Check that we can use co_await as a call parm.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+\n+__attribute__((__noinline__))\n+static int\n+foo (int x)\n+{\n+  return x + 2;\n+}\n+\n+/* Function with a single await.  */\n+coro1 \n+f ()\n+{\n+  gX = foo (co_await 9);\n+  co_return gX + 31;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resuming [1] (initial suspend)\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [2] (await 9 parm)\");\n+  f_coro.handle.resume();\n+\n+  if (gX != 11)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 11\\n\", gX);\n+      abort ();\n+    }\n+\n+  /* we should now have returned with the co_return 11 + 31) */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done'\");\n+      abort ();\n+    }\n+\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 42)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 42\\n\", y);\n+      abort ();\n+    }\n+\n+  puts (\"main: done\");\n+  return 0;\n+}\n\\ No newline at end of file"}, {"sha": "0f5785163fce2ddc7b36281dca759d4fe7367e5d", "filename": "gcc/testsuite/g++.dg/coroutines/torture/call-01-multiple-co-aw.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-01-multiple-co-aw.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-01-multiple-co-aw.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-01-multiple-co-aw.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,73 @@\n+// { dg-do run }\n+\n+// Check that we can use multiple co_awaits as a call parm.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+\n+__attribute__((__noinline__))\n+static int\n+bar (int x, int y)\n+{\n+  return x + y;\n+}\n+\n+/* Function with a multiple awaits.  */\n+coro1\n+g ()\n+{\n+  gX = bar (co_await 9, co_await 2);\n+  co_return gX + 31;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 g_coro = g ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (g_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resuming [1] (initial suspend)\");\n+  g_coro.handle.resume();\n+\n+  PRINT (\"main: resuming [2] (parm 1)\");\n+  g_coro.handle.resume();\n+  PRINT (\"main: resuming [2] (parm 2)\");\n+  g_coro.handle.resume();\n+  if (gX != 11)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 11\\n\", gX);\n+      abort ();\n+    }\n+\n+  /* we should now have returned with the co_return 11 + 31) */\n+  if (!g_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done'\");\n+      abort ();\n+    }\n+\n+  int y = g_coro.handle.promise().get_value();\n+  if (y != 42)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 42\\n\", y);\n+      abort ();\n+    }\n+\n+  puts (\"main: done\");\n+  return 0;\n+}\n\\ No newline at end of file"}, {"sha": "4982c49d796b8f1ea736a58691967c843a72df48", "filename": "gcc/testsuite/g++.dg/coroutines/torture/call-02-temp-co-aw.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-02-temp-co-aw.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-02-temp-co-aw.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-02-temp-co-aw.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,72 @@\n+// { dg-do run }\n+\n+// Check  foo (compiler temp, co_await).\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+\n+__attribute__((__noinline__))\n+static int\n+bar (int x, int y)\n+{\n+  return x + y;\n+}\n+\n+/* Function with a compiler temporary and a co_await.  */\n+coro1\n+g ()\n+{\n+  gX = bar (gX + 8, co_await 2);\n+  co_return gX + 31;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 g_coro = g ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (g_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resuming [1] (initial suspend)\");\n+  g_coro.handle.resume();\n+\n+  PRINT (\"main: resuming [2] (parm 1)\");\n+  g_coro.handle.resume();\n+\n+  if (gX != 11)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 11\\n\", gX);\n+      abort ();\n+    }\n+\n+  /* we should now have returned with the co_return 11 + 31) */\n+  if (!g_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done'\");\n+      abort ();\n+    }\n+\n+  int y = g_coro.handle.promise().get_value();\n+  if (y != 42)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 42\\n\", y);\n+      abort ();\n+    }\n+\n+  puts (\"main: done\");\n+  return 0;\n+}\n\\ No newline at end of file"}, {"sha": "d0bb4667ac95384cbd1b64cecf0550aeab6aa8f4", "filename": "gcc/testsuite/g++.dg/coroutines/torture/call-03-temp-ref-co-aw.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-03-temp-ref-co-aw.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-03-temp-ref-co-aw.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcall-03-temp-ref-co-aw.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,72 @@\n+// { dg-do run }\n+\n+// Check  foo (compiler temp, co_await).\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+\n+__attribute__((__noinline__))\n+static int\n+bar (int x, const int& y)\n+{\n+  return x + y;\n+}\n+\n+/* Function with a compiler temporary and a co_await.  */\n+coro1\n+g ()\n+{\n+  gX = bar (gX + 8, co_await 2);\n+  co_return gX + 31;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 g_coro = g ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (g_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resuming [1] (initial suspend)\");\n+  g_coro.handle.resume();\n+\n+  PRINT (\"main: resuming [2] (parm 1)\");\n+  g_coro.handle.resume();\n+\n+  if (gX != 11)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 11\\n\", gX);\n+      abort ();\n+    }\n+\n+  /* we should now have returned with the co_return 11 + 31) */\n+  if (!g_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done'\");\n+      abort ();\n+    }\n+\n+  int y = g_coro.handle.promise().get_value();\n+  if (y != 42)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 42\\n\", y);\n+      abort ();\n+    }\n+\n+  puts (\"main: done\");\n+  return 0;\n+}\n\\ No newline at end of file"}, {"sha": "932fe4b2830f3189a1cc6ca05cb929a3ab34788d", "filename": "gcc/testsuite/g++.dg/coroutines/torture/class-00-co-ret.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-00-co-ret.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-00-co-ret.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-00-co-ret.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,41 @@\n+//  { dg-do run }\n+\n+// Simplest class.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+class foo\n+{\n+  public:\n+  coro1 meth ()\n+    {\n+      PRINT (\"coro1: about to return\");\n+      co_return 42;\n+    }\n+};\n+\n+int main ()\n+{\n+  foo inst;\n+\n+  PRINT (\"main: create coro1\");\n+  coro1 x = inst.meth ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "0bd477044b4cee1af9b999e81b1771e96041895f", "filename": "gcc/testsuite/g++.dg/coroutines/torture/class-01-co-ret-parm.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-01-co-ret-parm.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-01-co-ret-parm.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-01-co-ret-parm.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,57 @@\n+//  { dg-do run }\n+\n+// Class with parm capture\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+class foo\n+{\n+  public:\n+  coro1 meth (int x)\n+    {\n+      if (x > 30)\n+\t{\n+\t  PRINT (\"coro1: about to return k\");\n+\t  co_return 6174;\n+\t}\n+      else if (x > 20)\n+\t{\n+\t  PRINT (\"coro1: about to return the answer\");\n+\t  co_return 42;\n+\t}\n+      else\n+\t{\n+\t  PRINT (\"coro1: about to return 0\");\n+\t  co_return 0;\n+\t}\n+    }\n+};\n+\n+int main ()\n+{\n+  foo inst;\n+\n+  PRINT (\"main: create coro1\");\n+  coro1 x = inst.meth (25);\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    {\n+      PRINTF (\"main: wrong result (%d)\", y);\n+      abort ();\n+    }\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "0cc6069c32f6adf52b3f6d3a76d7df9073fd52b4", "filename": "gcc/testsuite/g++.dg/coroutines/torture/class-02-templ-parm.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-02-templ-parm.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-02-templ-parm.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-02-templ-parm.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do run }\n+\n+// template parm in a class\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+template <typename T>\n+class foo\n+{\n+  public:\n+  coro1 meth (T y)\n+    {\n+      PRINT (\"coro1: about to return\");\n+      T x = y;\n+      co_return co_await x + 3;\n+    }\n+};\n+\n+int main ()\n+{\n+  foo<int> inst {};\n+  PRINT (\"main: create coro1\");\n+  coro1 x = inst.meth (17);\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (co_await)\");\n+\n+  /* Now we should have the co_returned value.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != 20 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "2d888a745586c7619bd53efda0196f5ab2698c29", "filename": "gcc/testsuite/g++.dg/coroutines/torture/class-03-operator-templ-parm.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-03-operator-templ-parm.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-03-operator-templ-parm.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-03-operator-templ-parm.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do run }\n+\n+// template parm in a class\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+template <typename T>\n+class foo\n+{\n+  public:\n+  coro1 operator()(T y)\n+    {\n+      PRINT (\"coro1: about to return\");\n+      T x = y;\n+      co_return co_await x + 3;\n+    }\n+};\n+\n+int main ()\n+{\n+  foo<int> inst {};\n+  PRINT (\"main: create coro1\");\n+  coro1 x = inst.operator()(17);\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (co_await)\");\n+\n+  /* Now we should have the co_returned value.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != 20 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "e191c20ac06114146b7c70658e5d7c4951d8aa7d", "filename": "gcc/testsuite/g++.dg/coroutines/torture/class-04-lambda-1.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-04-lambda-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-04-lambda-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-04-lambda-1.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run }\n+\n+// template parm in a class\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+template <typename T>\n+class foo\n+{\n+  public:\n+  auto get_lam ()\n+    {\n+      auto l = [](T y) -> coro1\n+      {\n+\tT x = y;\n+\tco_return co_await x + 3;\n+      };\n+      return l;\n+    }\n+};\n+\n+int main ()\n+{\n+  foo<int> inst {};\n+  auto ll = inst.get_lam ();\n+\n+  PRINT (\"main: create coro1\");\n+  int arg = 17; // avoid a dangling reference\n+  coro1 x = ll (arg);\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (co_await)\");\n+\n+  /* Now we should have the co_returned value.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != 20 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "968940f50564a9304c8fdb541a95e12c73dadedd", "filename": "gcc/testsuite/g++.dg/coroutines/torture/class-05-lambda-capture-copy-local.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-05-lambda-capture-copy-local.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-05-lambda-capture-copy-local.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-05-lambda-capture-copy-local.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,59 @@\n+// { dg-do run }\n+\n+// template parm in a class\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+template <typename T>\n+class foo\n+{\n+  public:\n+  auto get_lam (int parm)\n+    {\n+      int local = 3;\n+      auto l = [=](T y) -> coro1\n+      {\n+\tT x = y;\n+\tco_return co_await x + local;\n+      };\n+      return l;\n+    }\n+};\n+\n+int main ()\n+{\n+  foo<int> inst {};\n+  auto ll = inst.get_lam (10);\n+\n+  PRINT (\"main: create coro1\");\n+  int arg = 17; // avoid a dangling reference\n+  coro1 x = ll (arg);\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (co_await)\");\n+\n+  /* Now we should have the co_returned value.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != 20 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "db60132b0eed16e3a917bdeb50330212783066fb", "filename": "gcc/testsuite/g++.dg/coroutines/torture/class-06-lambda-capture-ref.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-06-lambda-capture-ref.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-06-lambda-capture-ref.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fclass-06-lambda-capture-ref.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,59 @@\n+// { dg-do run }\n+\n+// template parm in a class\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+template <typename T>\n+class foo\n+{\n+  public:\n+  void use_lambda ()\n+    {\n+      int a_copy = 20;\n+      int a_ref = 10;\n+\n+      auto f = [&, a_copy]() -> coro1\n+      {\n+\tco_yield a_ref + a_copy;\n+\tco_return a_ref + a_copy;\n+      };\n+\n+      coro1 A = f ();\n+      A.handle.resume(); // Initial suspend.\n+      PRINT (\"main: [a_copy = 20, a_ref = 10]\");\n+  \n+      int y = A.handle.promise().get_value();\n+      if (y != 30)\n+\t{\n+\t  PRINTF (\"main: co-yield = %d, should be 30\\n\", y);\n+\t  abort ();\n+\t}\n+\n+      a_copy = 5;\n+      a_ref = 7;\n+\n+      A.handle.resume(); // from the yield.\n+      PRINT (\"main: [a_copy = 5, a_ref = 7]\");\n+\n+      y = A.handle.promise().get_value();\n+      if (y != 27)\n+\t{\n+\t  PRINTF (\"main: co-ret = %d, should be 27\\n\", y);\n+\t  abort ();\n+\t}\n+      PRINT (\"use_lambda: about to return\");\n+    }\n+  ~foo () { PRINT (\"foo: DTOR\"); }\n+};\n+\n+int main ()\n+{\n+  foo<int> inst;\n+  inst.use_lambda();\n+  return 0;\n+}"}, {"sha": "a24c26159971afc3206b509c50bf74e644581025", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-00-trivial.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-00-trivial.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-00-trivial.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-00-trivial.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,52 @@\n+//  { dg-do run }\n+\n+// The simplest co_await we can do.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+\n+coro1\n+f ()\n+{\n+  co_await coro1::suspend_always_prt{};\n+  co_return gX + 10;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+  PRINT (\"main: resuming [1] initial suspend\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [2] co_await\");\n+  f_coro.handle.resume();\n+  /* we should now have returned with the co_return (15) */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done' \");\n+      abort ();\n+    }\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 11)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 11\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "db5c90224d2370e7a883b822898a985d7e2e132b", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-01-with-value.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-01-with-value.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-01-with-value.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-01-with-value.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,57 @@\n+//  { dg-do run }\n+\n+/* The simplest valued co_await we can do.  */\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+\n+coro1\n+f ()\n+{\n+  gX = co_await coro1::suspend_always_intprt{};\n+  co_return gX + 10;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+  PRINT (\"main: resuming [1] initial suspend\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [2] co_await suspend_always_intprt\");\n+  f_coro.handle.resume();\n+  if (gX != 5)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 5\\n\", gX);\n+      abort ();\n+    }\n+  /* we should now have returned with the co_return (15) */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done' \");\n+      abort ();\n+    }\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 15)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 15\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "79ee6e17146b01464ec1bbcdef245047e0b4e12b", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-02-xform.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-02-xform.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-02-xform.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-02-xform.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,58 @@\n+//  { dg-do run }\n+\n+// Test of basic await transform, no local state.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+\n+coro1\n+f ()\n+{\n+  gX = co_await 11;\n+  co_return gX + 31;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+  PRINT (\"main: resuming [1] initial suspend\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [2] co_await\");\n+  f_coro.handle.resume();\n+  if (gX != 11)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 11\\n\", gX);\n+      abort ();\n+    }\n+  /* we should now have returned with the co_return (15) */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done' \");\n+      abort ();\n+    }\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 42)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 42\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "64084325736e8df0fe0f7a6fb8f72d4653dc5934", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-03-rhs-op.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-03-rhs-op.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-03-rhs-op.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-03-rhs-op.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,58 @@\n+//  { dg-do run }\n+\n+// Basic check of co_await with an expression to await transform.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+\n+coro1\n+f ()\n+{\n+  gX = co_await 11 + 15;\n+  co_return gX + 16;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+  PRINT (\"main: resuming [1] initial suspend\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [1] await\");\n+  f_coro.handle.resume();\n+  if (gX != 26)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 26\\n\", gX);\n+      abort ();\n+    }\n+  /* we should now have returned with the co_return (26+16) */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done' \");\n+      abort ();\n+    }\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 42)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 42\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "9bc99e875d095542cdfb0d89fcd7f3c9b0e28283", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-04-control-flow.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-04-control-flow.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-04-control-flow.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-04-control-flow.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,50 @@\n+//  { dg-do run }\n+\n+// Check correct operation of await transform.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* Valued with an await_transform.  */\n+int gX = 1;\n+int y = 30;\n+\n+coro1\n+f ()\n+{\n+  if (gX < 12) {\n+    gX += y;\n+    gX += co_await 11;\n+  } else\n+    gX += co_await 12;\n+    \n+  co_return gX;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  PRINT (\"main: gX OK -- looping\");\n+  do {\n+    PRINTF (\"main: gX : %d \\n\", gX);\n+    f_coro.handle.resume();\n+  } while (!f_coro.handle.done());\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 42)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 42\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "34af740c99dcd61dd80d6a348401f29776a6f1c3", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-05-loop.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-05-loop.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-05-loop.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-05-loop.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,51 @@\n+//  { dg-do run }\n+\n+// Check correct operation of co_await in a loop without local state.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* Valued with an await_transform.  */\n+int gX = 1;\n+\n+coro1\n+f ()\n+{\n+  for (;;)\n+    {\n+      gX += co_await 11;\n+      if (gX > 100)\n+        break;\n+    }\n+  co_return gX;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  PRINT (\"main: gX OK -- looping\");\n+  do {\n+    PRINTF (\"main: gX : %d \\n\", gX);\n+    f_coro.handle.resume();\n+  } while (!f_coro.handle.done());\n+\n+  int y = f_coro.handle.promise().get_value();\n+  // first value above 100 is 10*11 + 1.\n+  if (y != 111)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 111\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "14945faffd0d9ba6fc7a570486a3c24fce72e082", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-06-ovl.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-06-ovl.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-06-ovl.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-06-ovl.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,65 @@\n+//  { dg-do run }\n+\n+// Basic check of the co_await operator overload.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* A very simple overload.  */\n+struct empty \n+{\n+  auto operator co_await() const & noexcept { \n+    return coro1::suspend_always_intprt{};\n+  }\n+};\n+\n+int gX = 1;\n+empty e{};\n+\n+coro1\n+f ()\n+{\n+  int a = co_await(e); /* operator ovl. */\n+  co_return gX + 5 + a;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done'\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resuming [1] initial suspend\");\n+  f_coro.handle.resume();\n+\n+  PRINT (\"main: resuming [2] co_await\");\n+  f_coro.handle.resume();\n+\n+  /* we should now have returned with the co_return (11) */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done' \");\n+      abort ();\n+    }\n+\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 11)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 11\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "33f8e99d8c306853daa73676f0adca50340758a9", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-07-tmpl.C", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-07-tmpl.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-07-tmpl.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-07-tmpl.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,132 @@\n+//  { dg-do run }\n+\n+// Check that we correctly operate when the coroutine object is templated.\n+\n+#include \"../coro.h\"\n+\n+template <typename T> \n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT (\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+    s.handle = nullptr;\n+    PRINT (\"Moved coro1\");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+    handle = s.handle;\n+    s.handle = nullptr;\n+    return *this;\n+  }\n+  ~coro1() {\n+    PRINT (\"Destroyed coro1\");\n+    if ( handle )\n+      handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+    ~suspend_never_prt() {}\n+    bool await_ready() const noexcept { return true; }\n+    void await_suspend(handle_type h) const noexcept { PRINT (\"susp-never-susp\");}\n+    void await_resume() const noexcept {PRINT (\"susp-never-resume\");}\n+  };\n+\n+  struct  suspend_always_prt {\n+    T x;\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+    void await_resume() const noexcept {PRINT (\"susp-always-resume\");}\n+  };\n+\n+  /* This returns the int it was constructed with.  */\n+  struct suspend_always_intprt {\n+    T x;\n+    suspend_always_intprt() : x((T)5) { PRINT (\"suspend_always_intprt def ctor\"); }\n+    suspend_always_intprt(T _x) : x(_x)\n+      { PRINTF (\"suspend_always_intprt ctor with %ld\\n\", (long)x); }\n+    ~suspend_always_intprt() {}\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(coro::coroutine_handle<>) const noexcept { PRINT (\"susp-always-susp-int\");}\n+    int await_resume() const noexcept { PRINT (\"susp-always-resume-int\"); return x;}\n+  };\n+\n+  struct promise_type {\n+  T value;\n+  promise_type()  { PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  coro1 get_return_object() {\n+    PRINT (\"get_return_object: from handle from promise\");\n+    return coro1 (handle_type::from_promise (*this));\n+  }\n+\n+  auto initial_suspend() {\n+    PRINT (\"get initial_suspend \");\n+    return suspend_never_prt{};\n+  }\n+\n+  auto final_suspend() {\n+    PRINT (\"get final_suspend\");\n+    return suspend_always_prt{};\n+  }\n+\n+  void return_value (int v) {\n+    PRINTF (\"return_value () %ld\\n\", (long) v);\n+    value = v;\n+  }\n+\n+  auto await_transform (T v) {\n+    PRINTF (\"await_transform a T () %ld\\n\", (long)v);\n+    return suspend_always_intprt (v);\n+  }\n+\n+  T get_value () { return value; }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+};\n+\n+/* Valued with an await_transform.  */\n+int gX = 2;\n+\n+template <typename T> \n+coro1<T> f ()\n+{\n+  for (int i = 0; i < 4; ++i)\n+    {\n+      gX += co_await 10;\n+    }\n+  co_return gX;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  auto f_coro = f<int>();\n+  \n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 2)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 2\\n\", gX);\n+      abort ();\n+    }\n+  PRINT (\"main: gX OK -- looping\");\n+  do {\n+    f_coro.handle.resume();\n+  } while (!f_coro.handle.done());\n+\n+  int y = f_coro.handle.promise().get_value();\n+\n+  if (y != 42)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 42\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "d34619d6b661b5c46cc0c35a6cc3115547769fec", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-08-cascade.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-08-cascade.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-08-cascade.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-08-cascade.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,63 @@\n+//  { dg-do run }\n+\n+// Check cascaded co_await operations.\n+\n+#include \"../coro.h\"\n+\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* Valued with an await_transform.  */\n+int gX = 1;\n+coro1 f ()\n+{\n+  /* We are going to use an await transform that takes a long, the\n+     await_resume squares it.\n+     so we get 11 ** 4, 14641.  */\n+  gX = (int) co_await co_await 11L;\n+  co_return gX + 31;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+  PRINT (\"main: resuming [1] - inital suspend\");\n+  f_coro.handle.resume();\n+\n+  PRINT (\"main: resuming [2] - nested\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [3] - outer\");\n+  f_coro.handle.resume();\n+\n+  if (gX != 14641)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 14641\\n\", gX);\n+      abort ();\n+    }\n+  /* we should now have returned with the co_return (14672) */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done' \");\n+      abort ();\n+    }\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 14672)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 14672\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "525c6fc46779aa436d1e2a7b74d98329a64a0805", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-09-pair.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-09-pair.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-09-pair.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-09-pair.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,57 @@\n+//  { dg-do run }\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* Valued with an await_transform.  */\n+int gX = 1;\n+coro1 f ()\n+{\n+  gX = co_await 11 + co_await 15;\n+  co_return gX + 31;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+  PRINT (\"main: resuming [1] (initial suspend)\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [2] one side of add\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [3] other side of add\");\n+  f_coro.handle.resume();\n+  if (gX != 26)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 26\\n\", gX);\n+      abort ();\n+    }\n+  /* we should now have returned with the co_return (57) */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done' \");\n+      abort ();\n+    }\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 57)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 57\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "71a5b18c3ccb4a9908def02aa77dc19d842ce159", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-10-template-fn-arg.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-10-template-fn-arg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-10-template-fn-arg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-10-template-fn-arg.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,60 @@\n+// { dg-do run }\n+\n+// Check type dependent function parms. \n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+// there is a promise ctor that takes a single int.\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+template <typename T>\n+coro1\n+f (T y) noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  T x = y;\n+  co_return co_await x + 3;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f<int>(17);\n+\n+  /* We should have created the promise with an initial value of\n+     17.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != 17 )\n+    {\n+      PRINTF (\"main: wrong promise init (%d).\", y);\n+      abort ();\n+    }\n+\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (co_await)\");\n+\n+  /* Now we should have the co_returned value.  */\n+  y = x.handle.promise().get_value();\n+  if ( y != 20 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "78c88ed14e9df8ae4e6b9662ee91567a1ada24b7", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-11-forwarding.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-11-forwarding.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-11-forwarding.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-11-forwarding.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,43 @@\n+//  { dg-do run }\n+\n+// Test of forwarding a templated awaitable to co_await.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* Valued with an await_transform.  */\n+\n+template< typename AWAITABLE >\n+coro1\n+test_fwd (AWAITABLE&& awaitable)\n+{\n+  // the await_resume() just returns the saved int value.\n+  int a = co_await std::forward<AWAITABLE>(awaitable);\n+  // Which we co-return to the promise so that it can be\n+  // retrieved.\n+  co_return a;\n+}\n+\n+int main ()\n+{\n+  // We have an awaitable that stores the int it was constructed with.\n+  coro1::suspend_always_intprt g(15);\n+  struct coro1 g_coro = test_fwd (g);\n+\n+  PRINT (\"main: resuming g [1] (initial suspend)\");\n+  g_coro.handle.resume();\n+\n+  PRINT (\"main: resuming g [2] co_await\");\n+  g_coro.handle.resume();\n+\n+  int y = g_coro.handle.promise().get_value();\n+  if (y != 15)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 15\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "189332b78e509077c9c1414ef7f9a283f47963cb", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-12-operator-2.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-12-operator-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-12-operator-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-12-operator-2.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,66 @@\n+//  { dg-do run }\n+\n+// Basic check of the co_await operator overload.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* A very simple overload.  */\n+struct empty \n+{\n+  auto operator co_await() & noexcept { \n+    return coro1::suspend_always_intprt{};\n+  }\n+  auto operator co_await() && noexcept { \n+    return coro1::suspend_always_longprtsq(3L);\n+  }\n+};\n+\n+empty e{};\n+\n+coro1\n+f ()\n+{\n+  int a = co_await e; /* operator ovl lv. */\n+  int b = co_await empty{}; /* operator ovl rv. */\n+  co_return b + a;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done'\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: resuming [1] initial suspend\");\n+  f_coro.handle.resume();\n+\n+  PRINT (\"main: resuming [2] co_await a\");\n+  f_coro.handle.resume();\n+\n+  PRINT (\"main: resuming [3] co_await b\");\n+  f_coro.handle.resume();\n+\n+  /* we should now have returned with the co_return (14) */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done' \");\n+      abort ();\n+    }\n+\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 14)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 14\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "339ebe4ff279c8f9c7d9ae5bf7d34e0792bb68d7", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-13-return-ref.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-13-return-ref.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-13-return-ref.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-13-return-ref.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,58 @@\n+//  { dg-do run }\n+\n+/* The simplest valued co_await we can do.  */\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+\n+coro1\n+f ()\n+{\n+  int t = 5;\n+  gX = co_await coro1::suspend_always_intrefprt{t};\n+  co_return t + 10;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - checking gX\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should not be 'done' [1]\");\n+      abort ();\n+    }\n+  PRINT (\"main: resuming [1] initial suspend\");\n+  f_coro.handle.resume();\n+  PRINT (\"main: resuming [2] co_await suspend_always_intprt\");\n+  f_coro.handle.resume();\n+  if (gX != 5)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 5\\n\", gX);\n+      abort ();\n+    }\n+  /* we should now have returned with the co_return (15) */\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: we should be 'done' \");\n+      abort ();\n+    }\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 15)\n+    {\n+      PRINTF (\"main: y is wrong : %d, should be 15\\n\", y);\n+      abort ();\n+    }\n+  puts (\"main: done\");\n+  return 0;\n+}"}, {"sha": "f551c6e76070e276c4d8da21d38772b40628e7a3", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-00-void-return-is-ready.C", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-00-void-return-is-ready.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-00-void-return-is-ready.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-00-void-return-is-ready.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,90 @@\n+//  { dg-do run }\n+\n+// Basic functionality check, co_return.\n+// Here we check the case that initial suspend is \"never\", so that the co-\n+// routine runs to completion immediately.\n+\n+#include \"../coro.h\"\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() {\n+        PRINT(\"Destroyed coro1\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n+  void await_resume() const noexcept {PRINT (\"susp-never-resume\");}\n+  ~suspend_never_prt() {};\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  };\n+\n+  struct promise_type {\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  coro1 get_return_object () {\n+    PRINT (\"get_return_object: from handle from promise\");\n+    return coro1 (handle_type::from_promise (*this));\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (never) \");\n+    return suspend_never_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always) \");\n+    return suspend_always_prt{};\n+  }\n+  void return_void () {\n+    PRINT (\"return_void ()\");\n+  }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+};\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - should be done\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently was not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "03fc6eeb84bbeb5704f3743b481545a44433fa49", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-01-void-return-is-suspend.C", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-01-void-return-is-suspend.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-01-void-return-is-suspend.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-01-void-return-is-suspend.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,94 @@\n+//  { dg-do run }\n+\n+// Basic functionality check, co_return.\n+// Here we check the case that initial suspend is \"always\".\n+\n+#include \"../coro.h\"\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() {\n+        PRINT(\"Destroyed coro1\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  ~suspend_never_prt() {};\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  };\n+\n+\n+  struct promise_type {\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  coro1 get_return_object () {\n+    PRINT (\"get_return_object: from handle from promise\");\n+    return coro1 (handle_type::from_promise (*this));\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_void () {\n+    PRINT (\"return_void ()\");\n+  }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+};\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "36da680f7f98a019a372fec23ec3c84077946ff3", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-03-different-GRO-type.C", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-03-different-GRO-type.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-03-different-GRO-type.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-03-different-GRO-type.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,92 @@\n+//  { dg-do run }\n+\n+// GRO differs from the eventual return type.\n+\n+# include \"../coro.h\"\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() {\n+        PRINT(\"Destroyed coro1\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  ~suspend_never_prt() {};\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  };\n+\n+  struct promise_type {\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_void () {\n+    PRINT (\"return_void ()\");\n+  }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+};\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "29fb9424f82595c5f94ff5d9478e2c4294e72ee2", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-04-GRO-nontriv.C", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-04-GRO-nontriv.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-04-GRO-nontriv.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-04-GRO-nontriv.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,109 @@\n+//  { dg-do run }\n+\n+// GRO differs from eventual return type and has non-trivial dtor.\n+\n+#include \"../coro.h\"\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+\n+  struct nontriv {\n+    handle_type handle;\n+    nontriv () : handle(0) {PRINT(\"nontriv nul ctor\");}\n+    nontriv (handle_type _handle)\n+\t: handle(_handle) {\n+        PRINT(\"Created nontriv object from handle\");\n+    }\n+    ~nontriv () {\n+         PRINT(\"Destroyed nontriv\");\n+    }\n+  };\n+\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (nontriv _nt)\n+    : handle(_nt.handle) {\n+        PRINT(\"Created coro1 object from nontriv\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() {\n+        PRINT(\"Destroyed coro1\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  ~suspend_never_prt() {};\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  };\n+\n+  struct promise_type {\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return nontriv(handle_type::from_promise (*this));\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_void () {\n+    PRINT (\"return_void ()\");\n+  }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+};\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "42b80ff6bb614c80384f4eb9d2422969c677cc64", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-05-return-value.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-05-return-value.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-05-return-value.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-05-return-value.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,38 @@\n+//  { dg-do run }\n+\n+// Test returning an int.\n+// We will use the promise to contain this to avoid having to include\n+// additional C++ headers.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return 42;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "5b1acb814579d61fb427d22d4e30d566dcfeb057", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-06-template-promise-val-1.C", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-06-template-promise-val-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-06-template-promise-val-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-06-template-promise-val-1.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,105 @@\n+//  { dg-do run }\n+\n+// Test returning a T.\n+// We will use the promise to contain this to avoid having to include\n+// additional C++ headers.\n+\n+#include \"../coro.h\"\n+\n+struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(coro::coroutine_handle<>) const noexcept\n+    { PRINT (\"susp-never-susp\"); }\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+};\n+\n+/* NOTE: this has a DTOR to test that pathway.  */\n+struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(coro::coroutine_handle<>) const noexcept\n+    { PRINT (\"susp-always-susp\"); }\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\"); }\n+  ~suspend_always_prt() { PRINT (\"susp-always-DTOR\"); }\n+};\n+\n+template <typename T>\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+    PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+    s.handle = nullptr;\n+    PRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+    handle = s.handle;\n+    s.handle = nullptr;\n+    PRINT(\"coro1 op=  \");\n+    return *this;\n+  }\n+  ~coro1() {\n+    PRINT(\"Destroyed coro1\");\n+    if ( handle )\n+      handle.destroy();\n+  }\n+\n+  struct promise_type {\n+  T value;\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+\n+  auto initial_suspend () const {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () const {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_value (T v) {\n+    PRINTF (\"return_value () %d\\n\",v);\n+    value = v;\n+  }\n+  T get_value (void) { return value; }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+};\n+\n+coro1<float>\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return (float) 42;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  coro1<float> x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != (float)42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "b1a06f284958b90b67c0846c6d3fae46fae5980d", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-07-void-cast-expr.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-07-void-cast-expr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-07-void-cast-expr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-07-void-cast-expr.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,44 @@\n+//  { dg-do run }\n+\n+// Check that \"co_return (void)expression;\" evaluates expression once.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define RETURN_VOID\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+__attribute__((__noinline__))\n+int foo (void) { PRINT (\"called the int fn foo\"); gX +=1 ; return gX; }\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return (void)foo();\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  // We want to check that foo() was called exactly once.\n+  if (gX != 2) \n+    {\n+      PRINT (\"main: failed check for a single call to foo()\");\n+      abort ();\n+    }\n+  PRINT (\"main: after resume\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "266bc7b3b26cc91db63daa6f10027b3c45f38010", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-08-template-cast-ret.C", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-08-template-cast-ret.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-08-template-cast-ret.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-08-template-cast-ret.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,104 @@\n+//  { dg-do run }\n+\n+// Test templated co-return.\n+\n+#include \"../coro.h\"\n+\n+struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(coro::coroutine_handle<>) const noexcept\n+    { PRINT (\"susp-never-susp\"); }\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+};\n+\n+/* NOTE: this has a DTOR to test that pathway.  */\n+struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(coro::coroutine_handle<>) const noexcept\n+    { PRINT (\"susp-always-susp\"); }\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\"); }\n+  ~suspend_always_prt() { PRINT (\"susp-always-DTOR\"); }\n+};\n+\n+template <typename T>\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+    PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+    s.handle = nullptr;\n+    PRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+    handle = s.handle;\n+    s.handle = nullptr;\n+    PRINT(\"coro1 op=  \");\n+    return *this;\n+  }\n+  ~coro1() {\n+    PRINT(\"Destroyed coro1\");\n+    if ( handle )\n+      handle.destroy();\n+  }\n+\n+  struct promise_type {\n+  T value;\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+  suspend_always_prt initial_suspend () const {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  suspend_always_prt final_suspend () const {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_value (T v) {\n+    PRINTF (\"return_value () %d\\n\",v);\n+    value = v;\n+  }\n+  T get_value (void) { return value; }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+};\n+\n+template <typename T>\n+coro1<T> f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return (T)42;\n+}\n+\n+// The test will only really for int, but that's OK here.\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  auto x = f<int>();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+      //x.handle.resume();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "91f3f14cc0935c7845c4da3cff99cc0e83404ccd", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-09-bool-await-susp.C", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-09-bool-await-susp.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-09-bool-await-susp.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-09-bool-await-susp.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,97 @@\n+//  { dg-do run }\n+\n+// test boolean return from await_suspend ().\n+\n+#include \"../coro.h\"\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() {\n+        PRINT(\"Destroyed coro1\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  bool await_suspend(handle_type) const noexcept {\n+    PRINT (\"susp-never-susp\"); // never executed.\n+    return true; // ...\n+  }\n+  void await_resume() const noexcept {PRINT (\"susp-never-resume\");}\n+  ~suspend_never_prt() {};\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  bool await_suspend(handle_type) const noexcept {\n+    PRINT (\"susp-always-susp, but we're going to continue.. \");\n+    return false; // not going to suspend.\n+  }\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  };\n+\n+  struct promise_type {\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  coro1 get_return_object () {\n+    PRINT (\"get_return_object: from handle from promise\");\n+    return coro1 (handle_type::from_promise (*this));\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always, but really never) \");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always, but never) \");\n+    return suspend_always_prt{};\n+  }\n+  void return_void () {\n+    PRINT (\"return_void ()\");\n+  }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+};\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  auto p = x.handle.promise ();\n+  auto aw = p.initial_suspend();\n+  auto f = aw.await_suspend(coro::coroutine_handle<coro1::promise_type>::from_address ((void *)&x));\n+  PRINT (\"main: got coro1 - should be done\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently was not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "7b07be5f4482a50fce325f0ee8e81ef6098fa4f1", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-10-expression-evaluates-once.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-10-expression-evaluates-once.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-10-expression-evaluates-once.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-10-expression-evaluates-once.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run }\n+\n+// Check that \"co_return expression;\" only evaluates expression once.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* Give foo() a measureable side-effect.  */\n+int gX = 1;\n+__attribute__((__noinline__))\n+int foo (void)\n+{ \n+  PRINT (\"called the int fn foo\");\n+  gX += 1;\n+  return gX;\n+}\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return foo();\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  // We want to check that foo() was called exactly once.\n+  if (gX != 2) \n+    {\n+      PRINT (\"main: failed check for a single call to foo()\");\n+      abort ();\n+    }\n+  PRINT (\"main: after resume\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "06939107d800671387a4e6dbb5cfe9274d3a8eec", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-11-co-ret-co-await.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-11-co-ret-co-await.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-11-co-ret-co-await.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-11-co-ret-co-await.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do run }\n+\n+// Check co_return co_await \n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return co_await coro1::suspend_always_intprt{};\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume 1 (initial suspend)\");\n+  x.handle.resume();\n+  PRINT (\"main: after resume 2 (await intprt)\");\n+\n+  int y = x.handle.promise().get_value();\n+  if ( y != 5 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "50124c080b3396172993f0077fb49e9f070a6974", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-12-co-ret-fun-co-await.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-12-co-ret-fun-co-await.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-12-co-ret-fun-co-await.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-12-co-ret-fun-co-await.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do run }\n+\n+// Check co_return function (co_await)\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+__attribute__((__noinline__))\n+static int\n+foo (int x)\n+{\n+  return x + 2;\n+}\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return foo (co_await 5);\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume 1 (initial suspend)\");\n+  x.handle.resume();\n+  PRINT (\"main: after resume 2 (await parm)\");\n+\n+  int y = x.handle.promise().get_value();\n+  if ( y != 7 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "9d4a4de8ebe8afa302c756e65056dd0202315f50", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-13-template-2.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-13-template-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-13-template-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-13-template-2.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,56 @@\n+// { dg-do run }\n+\n+// Check type dependent function parms. \n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+// there is a promise ctor that takes a single int.\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+template <typename T>\n+coro1\n+f (T y) noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  T x = y;\n+  co_return 3;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f<int>(17);\n+\n+  /* We should have created the promise with an initial value of\n+     17.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != 17 )\n+    {\n+      PRINT (\"main: wrong promise init.\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  /* Now we should have the co_returned value.  */\n+  y = x.handle.promise().get_value();\n+  if ( y != 3 )\n+    {\n+      PRINT (\"main: wrong answer.\");\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "ebc1adba821f7d5fa2d226df18979643e816f79f", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-14-template-3.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-14-template-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-14-template-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-14-template-3.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run }\n+\n+// Check type dependent function parms. \n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+// there is a promise ctor that takes a single int.\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+template <typename T, typename U, typename V>\n+coro1\n+f (T x, U y, V z) noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  T xi = (T) y;\n+  T yi = (T) z;\n+  T zi = x;\n+  co_return 3 + xi + yi + zi;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f<int, float, double>(2, 18.0F, 19.0);\n+\n+  /* We should be using the default promise ctor, which sets the value\n+     to -1.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != -1 )\n+    {\n+      PRINT (\"main: wrong promise init.\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  /* Now we should have the co_returned value.  */\n+  y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    {\n+      PRINT (\"main: wrong answer.\");\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "586b6b257152d24dcea63e741ba56f36abf9b1fc", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-yield-00-triv.C", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-00-triv.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-00-triv.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-00-triv.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,129 @@\n+//  { dg-do run }\n+\n+// Test yielding an int.\n+\n+// We will use the promise to contain this to avoid having to include\n+// additional C++ headers.\n+\n+// Check that we resolve the correct overload for the yield_value method.\n+\n+#include \"../coro.h\"\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+    s.handle = nullptr;\n+    PRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+    handle = s.handle;\n+    s.handle = nullptr;\n+    PRINT(\"coro1 op=  \");\n+    return *this;\n+  }\n+  ~coro1() {\n+    PRINT(\"Destroyed coro1\");\n+    if ( handle )\n+      handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+    bool await_ready() const noexcept { return true; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\"); }\n+    void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  };\n+\n+  /* NOTE: this has a DTOR to test that pathway.  */\n+  struct  suspend_always_prt {\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\"); }\n+    void await_resume() const noexcept { PRINT (\"susp-always-resume\"); }\n+    ~suspend_always_prt() { PRINT (\"susp-always-DTOR\"); }\n+  };\n+\n+  struct promise_type {\n+  int value;\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_value (int v) {\n+    PRINTF (\"return_value () %d\\n\",v);\n+    value = v;\n+  }\n+  auto yield_value (int v) {\n+    PRINTF (\"yield_value () %d and suspend always\\n\",v);\n+    value = v;\n+    return suspend_always_prt{};\n+  }\n+  /* Some non-matching overloads.  */\n+  auto yield_value (suspend_always_prt s, int x) {\n+    return s;\n+  }\n+  auto yield_value (void) {\n+    return 42;\n+  }\n+  int get_value (void) { return value; }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+};\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"f: about to yield 42\");\n+  co_yield 42;\n+\n+  PRINT (\"f: about to return 6174\");\n+  co_return 6174;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming (1)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (1)\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  PRINT (\"main: apparently got 42\");\n+  PRINT (\"main: got coro1 - resuming (2)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2)\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  PRINT (\"main: apparently got 6174\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "5df69c7f15673ec8ead1059e84c4465b124da8c0", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-yield-01-multi.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-01-multi.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-01-multi.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-01-multi.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,64 @@\n+//  { dg-do run }\n+\n+// Test yielding an int.\n+// We will use the promise to contain this to avoid having to include\n+// additional C++ headers.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"f: about to yield 42\");\n+  co_yield 42;\n+\n+  PRINT (\"f: about to yield 11\");\n+  co_yield 11;\n+\n+  PRINT (\"f: about to return 6174\");\n+  co_return 6174;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming (1)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (1)\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  PRINT (\"main: apparently got 42 - resuming (2)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2)\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 11 )\n+    abort ();\n+  PRINT (\"main: apparently got 11 - resuming (3)\");\n+  if (x.handle.done())\n+    {\n+   PRINT (\"main: done?\");\n+   abort();\n+    }\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2) checking return\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  PRINT (\"main: apparently got 6174\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "8d4f1d5d82368e4adb8bfeebf24116e974c3b6ce", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-yield-02-loop.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-02-loop.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-02-loop.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-02-loop.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,68 @@\n+//  { dg-do run }\n+\n+// Test co_yield in a loop with no local state.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int gX = 1;\n+\n+struct coro1\n+f () noexcept\n+{\n+  for (gX = 5; gX < 10 ; gX++)\n+    {\n+      PRINTF (\"f: about to yield %d\\n\", gX);\n+      co_yield gX;\n+     }\n+\n+  PRINT (\"f: about to return 6174\");\n+  co_return 6174;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 f_coro = f ();\n+  PRINT (\"main: got coro1 - resuming (1)\");\n+  if (gX != 1)\n+    {\n+      PRINTF (\"main: gX is wrong : %d, should be 1\\n\", gX);\n+      abort ();\n+    }\n+  if (f_coro.handle.done())\n+    abort();\n+  f_coro.handle.resume();\n+  PRINT (\"main: after resume (1)\");\n+  int y = f_coro.handle.promise().get_value();\n+  if (y != 5)\n+    {\n+      PRINTF (\"main: got %d not 5.\\n\",y);\n+      abort ();\n+    }\n+  PRINT (\"main: gX OK -- looping\");\n+  do {\n+    y = f_coro.handle.promise().get_value();\n+    if (y != gX)\n+      {\n+        PRINTF (\"main: got %d not %d.\\n\",y, gX);\n+        abort ();\n+      }\n+    PRINTF (\"main: gX : %d \\n\", gX);\n+    f_coro.handle.resume();\n+  } while (!f_coro.handle.done());\n+\n+  y = f_coro.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  PRINT (\"main: apparently got 6174\");\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "cceee1f19e946774fc967a5a2baf1bd4eb0b26da", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-yield-03-tmpl.C", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-03-tmpl.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-03-tmpl.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-03-tmpl.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,140 @@\n+//  { dg-do run }\n+\n+// Test co_yield in templated code.\n+\n+#include \"../coro.h\"\n+\n+template <typename T> \n+struct looper {\n+\n+  struct promise_type {\n+  T value;\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+\n+  void return_value (T v) {\n+    PRINTF (\"return_value () %lf\\n\", (double)v);\n+    value = v;\n+  }\n+\n+  auto yield_value (T v) {\n+    PRINTF (\"yield_value () %lf and suspend always\\n\", (double)v);\n+    value = v;\n+    return suspend_always_prt{};\n+  }\n+  \n+  T get_value (void) { return value; }\n+\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+  \n+  using handle_type = coro::coroutine_handle<looper::promise_type>;\n+  handle_type handle;\n+\n+  looper () : handle(0) {}\n+  looper (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  looper (const looper &) = delete; // no copying\n+  looper (looper &&s) : handle(s.handle) {\n+    s.handle = nullptr;\n+    PRINT(\"looper mv ctor \");\n+  }\n+  looper &operator = (looper &&s) {\n+    handle = s.handle;\n+    s.handle = nullptr;\n+    PRINT(\"looper op=  \");\n+    return *this;\n+  }\n+  ~looper() {\n+    PRINT(\"Destroyed coro1\");\n+    if ( handle )\n+      handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+    bool await_ready() const noexcept { return true; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\"); }\n+    void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  };\n+\n+  /* NOTE: this has a DTOR to test that pathway.  */\n+  struct  suspend_always_prt {\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\"); }\n+    void await_resume() const noexcept { PRINT (\"susp-always-resume\"); }\n+    ~suspend_always_prt() { PRINT (\"susp-always-DTOR\"); }\n+  };\n+\n+};\n+\n+// Contrived to avoid non-scalar state across the yield.\n+template <typename T> \n+looper<T> f () noexcept\n+{\n+  for (int i = 5; i < 10 ; ++i)\n+    {\n+      PRINTF (\"f: about to yield %d\\n\", i);\n+      co_yield (T) i;\n+    }\n+\n+  PRINT (\"f: about to return 6174\");\n+  co_return 6174;\n+}\n+\n+// contrived, only going to work for an int.\n+int main ()\n+{\n+  PRINT (\"main: create int looper\");\n+  auto f_coro = f<int> ();\n+\n+  if (f_coro.handle.done())\n+    {\n+      PRINT (\"main: said we were done, but we hadn't started!\");\n+      abort();\n+    }\n+\n+  PRINT (\"main: OK -- looping\");\n+  int y, test = 5;\n+  do {\n+    f_coro.handle.resume();\n+    if (f_coro.handle.done())\n+      break;\n+    y = f_coro.handle.promise().get_value();\n+    if (y != test)\n+      {\n+\tPRINTF (\"main: failed for test %d, got %d\\n\", test, y);\n+\tabort();\n+      }\n+    test++;\n+  } while (test < 20);\n+\n+  y = f_coro.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+\n+  PRINT (\"main: apparently got 6174\");\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "d9330b33b76465acc05b0282cb2211ea4ee495fd", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-yield-04-complex-local-state.C", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-04-complex-local-state.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-04-complex-local-state.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-04-complex-local-state.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,162 @@\n+//  { dg-do run }\n+\n+// using non-trivial types in the coro.\n+\n+# include \"../coro.h\"\n+\n+#include <vector>\n+#include <string>\n+\n+template <typename T> \n+struct looper {\n+\n+  struct promise_type {\n+  T value;\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+\n+  void return_value (T v) {\n+    PRINTF (\"return_value () %s\\n\",  v.c_str());\n+    value = v;\n+  }\n+\n+  auto yield_value (T v) {\n+    PRINTF (\"yield_value () %s and suspend always\\n\", v.c_str());\n+    value = v;\n+    return suspend_always_prt{};\n+  }\n+  \n+  T get_value (void) { return value; }\n+\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+  \n+  using handle_type = coro::coroutine_handle<looper::promise_type>;\n+  handle_type handle;\n+\n+  looper () : handle(0) {}\n+  looper (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  looper (const looper &) = delete; // no copying\n+  looper (looper &&s) : handle(s.handle) {\n+    s.handle = nullptr;\n+    PRINT(\"looper mv ctor \");\n+  }\n+  looper &operator = (looper &&s) {\n+    handle = s.handle;\n+    s.handle = nullptr;\n+    PRINT(\"looper op=  \");\n+    return *this;\n+  }\n+  ~looper() {\n+    PRINT(\"Destroyed coro1\");\n+    if ( handle )\n+      handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+    bool await_ready() const noexcept { return true; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\"); }\n+    void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  };\n+\n+  /* NOTE: this has a DTOR to test that pathway.  */\n+  struct  suspend_always_prt {\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\"); }\n+    void await_resume() const noexcept { PRINT (\"susp-always-resume\"); }\n+    ~suspend_always_prt() { PRINT (\"susp-always-DTOR\"); }\n+  };\n+\n+};\n+\n+int gX ;\n+\n+struct mycounter \n+{ \n+  mycounter () : v(0) { PRINT (\"mycounter CTOR\"); }\n+  ~mycounter () { gX = 6174; PRINT (\"mycounter DTOR\"); }\n+  int value () { return v; }\n+  void incr () { v++; }\n+  int v;\n+};\n+\n+template <typename T> \n+looper<T> with_ctorable_state (std::vector<T> d) noexcept\n+{\n+  std::vector<T> loc;\n+  unsigned lim = d.size()-1;\n+  mycounter c;\n+  for (unsigned  i = 0; i < lim ; ++i)\n+    {\n+      loc.push_back(d[i]);\n+      c.incr();\n+      PRINTF (\"f: about to yield value %d \\n\", i);\n+      co_yield loc[i];\n+     }\n+  loc.push_back(d[lim]);\n+\n+  PRINT (\"f: done\");\n+  co_return loc[lim];\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create looper\");\n+  std::vector<std::string> input = {\"first\", \"the\", \"quick\", \"reddish\", \"fox\", \"done\" };\n+  auto f_coro = with_ctorable_state<std::string> (input);\n+\n+  PRINT (\"main: got looper - resuming (1)\");\n+  if (f_coro.handle.done())\n+    abort();\n+\n+  f_coro.handle.resume();\n+  std::string s = f_coro.handle.promise().get_value();\n+  if ( s != \"first\" )\n+    abort ();\n+\n+  PRINTF (\"main: got : %s\\n\", s.c_str());\n+  unsigned check = 1;\n+  do {\n+    f_coro.handle.resume();\n+    s = f_coro.handle.promise().get_value();\n+    if (s != input[check++])\n+      abort ();  \n+    PRINTF (\"main: got : %s\\n\", s.c_str());\n+  } while (!f_coro.handle.done());\n+\n+  if ( s != \"done\" )\n+    abort ();\n+\n+  PRINT (\"main: should be done\");\n+  if (!f_coro.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+\n+  if (gX != 6174)\n+    {\n+      PRINT (\"main: apparently we didn't run mycounter DTOR...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "043f97b6e1b320c230e3d610a167a8d3865a5398", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-yield-05-co-aw.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-05-co-aw.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-05-co-aw.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-05-co-aw.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do run }\n+\n+// Check co_return co_await \n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"f: about to yield\");\n+  co_yield co_await coro1::suspend_always_intprt(42);\n+\n+  PRINT (\"f: about to return 6174\");\n+  co_return 6174;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  if (x.handle.done())\n+    abort();\n+\n+  PRINT (\"main: resuming (initial suspend)\");\n+  x.handle.resume();\n+  PRINT (\"main: resuming (await intprt)\");\n+  x.handle.resume();\n+\n+  PRINT (\"main: after resume (2)\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  PRINT (\"main: apparently got 42\");\n+\n+  PRINT (\"main: got coro1 - resuming (co_yield)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+\n+  PRINT (\"main: after resume (co_yield)\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  PRINT (\"main: apparently got 6174\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "c74e44d15d521014a2145675f971863b4eda11b2", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-yield-06-fun-parm.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-06-fun-parm.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-06-fun-parm.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-06-fun-parm.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,64 @@\n+// { dg-do run }\n+\n+// Check co_return co_await \n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+__attribute__((__noinline__))\n+static int\n+foo (int x)\n+{\n+  return x + 2;\n+}\n+\n+/* Function with a single await.  */\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"f: about to yield\");\n+  co_yield foo (co_await 40);\n+\n+  PRINT (\"f: about to return 6174\");\n+  co_return 6174;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  if (x.handle.done())\n+    abort();\n+\n+  PRINT (\"main: resuming (initial suspend)\");\n+  x.handle.resume();\n+  PRINT (\"main: resuming (await intprt)\");\n+  x.handle.resume();\n+\n+  PRINT (\"main: after resume (2)\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  PRINT (\"main: apparently got 42\");\n+\n+  PRINT (\"main: got coro1 - resuming (co_yield)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+\n+  PRINT (\"main: after resume (co_yield)\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  PRINT (\"main: apparently got 6174\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "74dae6339556ad00f86cfebc4a32e6104d54e1ae", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-yield-07-template-fn-param.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-07-template-fn-param.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-07-template-fn-param.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-07-template-fn-param.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,71 @@\n+// { dg-do run }\n+\n+// Check type dependent function parms. \n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+// there is a promise ctor that takes a single int.\n+\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+template <typename T>\n+coro1\n+f (T y) noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  T x = y;\n+  co_yield x + 3;\n+  co_return 42;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f<int>(17);\n+\n+  /* We should have created the promise with an initial value of\n+     17.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != 17 )\n+    {\n+      PRINTF (\"main: wrong promise init (%d).\", y);\n+      abort ();\n+    }\n+  if (x.handle.done())\n+    abort();\n+\n+  PRINT (\"main: got coro1 - resuming\");\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  if (x.handle.done())\n+    abort();\n+\n+  /* Now we should have the co_yielded value.  */\n+  y = x.handle.promise().get_value();\n+  if ( y != 20 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  PRINT (\"main: after resume (co_yield)\");\n+  x.handle.resume();\n+\n+  /* now we should have the co_returned value.  */\n+  y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "8e39127a1ae79c2b5b206c8a127c1244e3dc7742", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-yield-08-more-refs.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-08-more-refs.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-08-more-refs.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-08-more-refs.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,68 @@\n+// { dg-do run }\n+\n+// Check co_return co_await \n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* Tests for .  */\n+struct test \n+{\n+  auto operator co_await() & noexcept { \n+    return coro1::suspend_always_intprt{};\n+  }\n+\n+  auto operator co_await() && noexcept { \n+    return coro1::suspend_always_longprtsq(3L);\n+  }\n+};\n+\n+struct coro1\n+f (test thing) noexcept\n+{\n+  co_yield co_await static_cast<test&&>(thing);\n+  co_return 6174;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+\n+  struct coro1 x = f (test{});\n+  if (x.handle.done())\n+    abort();\n+\n+  PRINT (\"main: resuming (initial suspend)\");\n+  x.handle.resume();\n+  PRINT (\"main: resuming (await intprt)\");\n+  x.handle.resume();\n+\n+  int y = x.handle.promise().get_value();\n+  if ( y != 9 )\n+    {\n+      PRINTF (\"main: co-yield gave %d, should be 9\\n\", y);\n+      abort ();\n+    }\n+\n+  PRINT (\"main: got coro1 - resuming (co_yield)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+\n+  y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    {\n+      PRINTF (\"main: co-return gave %d, should be 9\\n\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "3abbe1c43abb2d0f3bc53f31e2b7bbbce202b3d2", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-yield-09-more-templ-refs.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-09-more-templ-refs.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-09-more-templ-refs.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-yield-09-more-templ-refs.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,68 @@\n+// { dg-do run }\n+\n+// Check co_return co_await \n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* A very simple overload.  */\n+struct test \n+{\n+  auto operator co_await() & noexcept { \n+    return coro1::suspend_always_intprt{};\n+  }\n+\n+  auto operator co_await() && noexcept { \n+    return coro1::suspend_always_longprtsq(3L);\n+  }\n+};\n+\n+template<typename RESULT, typename PARAM>\n+RESULT\n+f (PARAM thing) noexcept\n+{\n+  co_yield co_await static_cast<PARAM&&>(thing);\n+  co_return 6174;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f<coro1, test> (test{});\n+  if (x.handle.done())\n+    abort();\n+\n+  PRINT (\"main: resuming (initial suspend)\");\n+  x.handle.resume();\n+  PRINT (\"main: resuming (await intprt)\");\n+  x.handle.resume();\n+\n+  int y = x.handle.promise().get_value();\n+  if ( y != 9 )\n+    {\n+      PRINTF (\"main: co-yield gave %d, should be 9\\n\", y);\n+      abort ();\n+    }\n+\n+  PRINT (\"main: got coro1 - resuming (co_yield)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+\n+  y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    {\n+      PRINTF (\"main: co-return gave %d, should be 9\\n\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "d2463b279831b1fe9f2feb07cd4afb69018a484e", "filename": "gcc/testsuite/g++.dg/coroutines/torture/coro-torture.exp", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcoro-torture.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcoro-torture.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fcoro-torture.exp?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,19 @@\n+# This harness is for tests that should be run at all optimisation levels.\n+\n+load_lib g++-dg.exp\n+load_lib torture-options.exp\n+\n+global DG_TORTURE_OPTIONS LTO_TORTURE_OPTIONS\n+\n+dg-init\n+torture-init\n+\n+set DEFAULT_COROFLAGS $DEFAULT_CXXFLAGS\n+lappend DEFAULT_COROFLAGS \"-std=c++17\" \"-fcoroutines\"\n+\n+set-torture-options [concat $DG_TORTURE_OPTIONS $LTO_TORTURE_OPTIONS]\n+\n+gcc-dg-runtest [lsort [glob $srcdir/$subdir/*.C]] \"\" $DEFAULT_COROFLAGS\n+\n+torture-finish\n+dg-finish"}, {"sha": "164c804797d563994167e963dbb04b8694bd26bb", "filename": "gcc/testsuite/g++.dg/coroutines/torture/exceptions-test-0.C", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fexceptions-test-0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fexceptions-test-0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fexceptions-test-0.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,167 @@\n+//  { dg-do run }\n+\n+// Test exceptions.\n+\n+#include \"../coro.h\"\n+#include <exception>\n+\n+int gX = 0;\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+    s.handle = nullptr;\n+    PRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+    handle = s.handle;\n+    s.handle = nullptr;\n+    PRINT(\"coro1 op=  \");\n+    return *this;\n+  }\n+  ~coro1() {\n+    PRINT(\"Destroyed coro1\");\n+    if ( handle )\n+      handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+    bool await_ready() const noexcept { return true; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\"); }\n+    void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  };\n+\n+  /* NOTE: this has a DTOR to test that pathway.  */\n+  struct  suspend_always_prt {\n+    bool await_ready() const noexcept { return false; }\n+    void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\"); }\n+    void await_resume() const noexcept { PRINT (\"susp-always-resume\"); }\n+    ~suspend_always_prt() { PRINT (\"susp-always-DTOR\"); }\n+  };\n+\n+  struct promise_type {\n+  int value;\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_value (int v) {\n+    PRINTF (\"return_value () %d\\n\",v);\n+    value = v;\n+  }\n+  auto yield_value (int v) {\n+    PRINTF (\"yield_value () %d and suspend always\\n\",v);\n+    value = v;\n+    return suspend_always_prt{};\n+  }\n+  /* Some non-matching overloads.  */\n+  auto yield_value (suspend_always_prt s, int x) {\n+    return s;\n+  }\n+  auto yield_value (void) {\n+    return 42;//suspend_always_prt{};\n+  }\n+  int get_value (void) { return value; }\n+\n+  void unhandled_exception() {\n+    PRINT (\"unhandled_exception: caught one!\");\n+    gX = -1;\n+    // returning from here should end up in final_suspend.\n+    }\n+  };\n+};\n+\n+// So we want to check that the internal behaviour of try/catch is \n+// working OK - and that if we have an unhandled exception it is caught\n+// by the wrapper that we add to the rewritten func.\n+\n+struct coro1 throw_and_catch () noexcept\n+{\n+  int caught = 0;\n+\n+  try {\n+    PRINT (\"f: about to yield 42\");\n+    co_yield 42;\n+ \n+    throw (20);\n+\n+    PRINT (\"f: about to yield 6174\");\n+    co_return 6174;\n+\n+  } catch (int x) {\n+    PRINTF (\"f: caught %d\\n\", x);\n+    caught = x;\n+  }\n+\n+  PRINTF (\"f: about to yield what we caught %d\\n\", caught);\n+  co_yield caught;\n+\n+  throw (\"bah\");\n+\n+  PRINT (\"f: about to return 22\");\n+  co_return 22;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = throw_and_catch ();\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: got coro, resuming..\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  PRINT (\"main: apparently got the expected 42\");\n+  if (x.handle.done())\n+    abort();\n+  PRINT (\"main: resuming...\");\n+  x.handle.resume();\n+\n+  y = x.handle.promise().get_value();\n+  if ( y != 20 )\n+    abort ();\n+  PRINT (\"main: apparently got 20, which we expected\");\n+  if (x.handle.done())\n+    abort();\n+\n+  PRINT (\"main: resuming...\");\n+  x.handle.resume();\n+  // This should cause the throw of \"bah\" which is unhandled.\n+  // We should catch the unhandled exception and then fall through\n+  // to the final suspend point... thus be \"done\".\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  // When we caught the unhandled exception we flagged it instead of\n+  // std::terminate-ing.\n+  if (gX != -1)\n+    {\n+      PRINT (\"main: apparently failed to catch\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "b5716972d47940e474ce76c47972f7a91bb7c4cd", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-00.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-00.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-00.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-00.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,42 @@\n+//  { dg-do run }\n+\n+// Test promise construction from function args list.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f (int x) noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return 42;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (555);\n+  int y = x.handle.promise().get_value();\n+  if ( y != 555 )\n+    {\n+      PRINT (\"main: incorrect ctor value\");\n+      abort ();\n+    }\n+  PRINTF (\"main: after coro1 ctor %d - now resuming\\n\", y);\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "f530431a6bba4f2ec2b7b9ccfcf270cb205eac07", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-01.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-01.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,45 @@\n+//  { dg-do run }\n+\n+// Simplest test that we correctly handle function params in the body\n+// of the coroutine.  No local state, just the parm.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f (int x) noexcept\n+{\n+  if (x > 20)\n+    {\n+      PRINT (\"coro1: about to return k\");\n+      co_return 6174;\n+    }\n+  else\n+    {\n+      PRINT (\"coro1: about to return the answer\");\n+      co_return 42;\n+    }\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (32);\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "396b438cb2d95e27ea3c0af2fe214de712b14d40", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-02.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-02.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-02.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-02.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,50 @@\n+//  { dg-do run }\n+\n+// Test that we correctly re-write multiple uses of a function param\n+// in the body.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f (int x) noexcept\n+{\n+  if (x > 30)\n+    {\n+      PRINT (\"coro1: about to return k\");\n+      co_return 6174;\n+    }\n+  else if (x > 20)\n+    {\n+      PRINT (\"coro1: about to return the answer\");\n+      co_return 42;\n+    }\n+  else\n+    {\n+      PRINT (\"coro1: about to return 0\");\n+      co_return 0;\n+    }\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (25);\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "bf699722a1ab9cb76db8d6f60f697183721568a6", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-03.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-03.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-03.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-03.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,49 @@\n+//  { dg-do run }\n+\n+// Test that we can use a function param in a co_xxxx status.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f (int x) noexcept\n+{\n+  if (x > 30)\n+    {\n+      PRINT (\"coro1: about to return k\");\n+      co_return 6174;\n+    }\n+  else if (x > 20)\n+    {\n+      PRINTF (\"coro1: about to co-return %d\", x);\n+      co_return x;\n+    }\n+  else\n+    {\n+      PRINT (\"coro1: about to return 0\");\n+      co_return 0;\n+    }\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (25);\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 25 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "789e2c05b6939bec465ab1f3c7a7c9a7d71cf2c4", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-04.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-04.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-04.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-04.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,57 @@\n+//  { dg-do run }\n+\n+// Test that we can manage a constructed param copy.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+// Require a ctor.\n+struct nontriv {\n+  int a, b, c;\n+  nontriv (int _a, int _b, int _c) : a(_a), b(_b), c(_c) {}\n+  virtual int getA () { return a; }\n+};\n+\n+struct coro1\n+f (nontriv t) noexcept\n+{\n+  if (t.a > 30)\n+    {\n+      PRINTF (\"coro1: about to return %d\", t.b);\n+      co_return t.b;\n+    }\n+  else if (t.a > 20)\n+    {\n+      PRINTF (\"coro1: about to co-return %d\", t.c);\n+      co_return t.c;\n+    }\n+  else\n+    {\n+      PRINT (\"coro1: about to return 0\");\n+      co_return 0;\n+    }\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  nontriv test (25, 6174, 42);\n+  struct coro1 x = f (test);\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "8bdb2b5d0f780933b32d44b1ab19ae129852d048", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-05.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-05.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-05.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-05.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,57 @@\n+//  { dg-do run }\n+\n+// Test that we can manage a constructed param reference\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+// Require a ctor.\n+struct nontriv {\n+  int a, b, c;\n+  nontriv (int _a, int _b, int _c) : a(_a), b(_b), c(_c) {}\n+  virtual int getA () { return a; }\n+};\n+\n+struct coro1\n+f (nontriv &t) noexcept\n+{\n+  if (t.a > 30)\n+    {\n+      PRINTF (\"coro1: about to return %d\", t.b);\n+      co_return t.b;\n+    }\n+  else if (t.a > 20)\n+    {\n+      PRINTF (\"coro1: about to co-return %d\", t.c);\n+      co_return t.c;\n+    }\n+  else\n+    {\n+      PRINT (\"coro1: about to return 0\");\n+      co_return 0;\n+    }\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  nontriv test (25, 6174, 42);\n+  struct coro1 x = f (test);\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "cbcfe67ff1af5a297563a8fa3b6aecaa045efcbf", "filename": "gcc/testsuite/g++.dg/coroutines/torture/func-params-06.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-06.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-06.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Ffunc-params-06.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,47 @@\n+//  { dg-do run }\n+\n+// check references are handled as expected.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+coro1 \n+f (int& a_ref, int a_copy)\n+{\n+    co_yield a_ref + a_copy;\n+    co_return a_ref + a_copy;\n+}\n+\n+int main ()\n+{\n+  int a_copy = 20;\n+  int a_ref = 10;\n+\n+  coro1 A = f (a_ref, a_copy);\n+  A.handle.resume(); // Initial suspend.\n+  PRINT (\"main: [a_copy = 20, a_ref = 10]\");\n+  \n+  int y = A.handle.promise().get_value();\n+  if (y != 30)\n+    {\n+      PRINTF (\"main: co-yield = %d, should be 30\\n\", y);\n+      abort ();\n+    }\n+\n+  a_copy = 5;\n+  a_ref = 7;\n+\n+  A.handle.resume();\n+  PRINT (\"main: [a_copy = 5, a_ref = 7]\");\n+\n+  y = A.handle.promise().get_value();\n+  if (y != 27)\n+    {\n+      PRINTF (\"main: co-ret = %d, should be 27\\n\", y);\n+      abort ();\n+    }\n+  \n+  return 0;\n+}"}, {"sha": "61e284d5c8f5c5cd5c63d6a6b22758fe4223f265", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-00-co-ret.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-00-co-ret.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-00-co-ret.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-00-co-ret.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,35 @@\n+//  { dg-do run }\n+\n+// Simplest lambda\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  auto f = []() -> coro1\n+  {\n+    PRINT (\"coro1: about to return\");\n+    co_return 42;\n+  };\n+\n+  PRINT (\"main: create coro1\");\n+  coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "378eedc6d89d9e3397553744f965a3cd81fe0287", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-01-co-ret-parm.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-01-co-ret-parm.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-01-co-ret-parm.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-01-co-ret-parm.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,48 @@\n+//  { dg-do run }\n+\n+// Lambda with parm\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  auto f = [](int x) -> coro1\n+  {\n+    if (x > 30)\n+     {\n+\tPRINT (\"coro1: about to return k\");\n+\tco_return 6174;\n+     }\n+    else if (x > 20)\n+     {\n+\tPRINT (\"coro1: about to return the answer\");\n+\tco_return 42;\n+     }\n+    else\n+     {\n+\tPRINT (\"coro1: about to return 0\");\n+\tco_return 0;\n+     }\n+  };\n+\n+  PRINT (\"main: create coro1\");\n+  coro1 x = f (25);\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "a6f592cd77af27e1624e166f4ccf2b767566f55c", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-02-co-yield-values.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-02-co-yield-values.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-02-co-yield-values.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-02-co-yield-values.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,64 @@\n+//  { dg-do run }\n+\n+// lambda with parm and local state\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  auto f = [](int start) -> coro1\n+  {\n+    int value = start;\n+    PRINT (\"f: about to yield start\");\n+    co_yield start;\n+\n+    value -= 31;\n+    PRINT (\"f: about to yield (value-31)\");\n+    co_yield value;\n+\n+    value += 6163;\n+    PRINT (\"f: about to return (value+6163)\");\n+    co_return value;\n+  };\n+\n+  PRINT (\"main: create coro1\");\n+  coro1 x = f (42);\n+  PRINT (\"main: got coro1 - resuming (1)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (1)\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  PRINT (\"main: apparently got 42 - resuming (2)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2)\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 11 )\n+    abort ();\n+  PRINT (\"main: apparently got 11 - resuming (3)\");\n+  if (x.handle.done())\n+    {\n+   PRINT (\"main: done?\");\n+   abort();\n+    }\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2) checking return\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  PRINT (\"main: apparently got 6174\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "bfa5400225da76c4f987397b627b5d28c2b2bfa0", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-03-auto-parm-1.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-03-auto-parm-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-03-auto-parm-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-03-auto-parm-1.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,46 @@\n+//  { dg-do run }\n+\n+// generic Lambda with auto parm (c++14)\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  auto f = [](auto y) -> coro1\n+  {\n+    PRINT (\"coro1: about to return\");\n+    auto x = y;\n+    co_return co_await x + 3;\n+  };\n+\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f((int)17);\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (co_await)\");\n+\n+  /* Now we should have the co_returned value.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != 20 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "adf31e22dbac5a6ece88b51cd655d1bfad5e9f58", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-04-templ-parm.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-04-templ-parm.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-04-templ-parm.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-04-templ-parm.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do run }\n+// { dg-additional-options \"-std=c++2a\" }\n+\n+// generic Lambda with template parm (from c++20)\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#define USE_AWAIT_TRANSFORM\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  auto f = []<typename T>(T y) -> coro1\n+  {\n+    PRINT (\"coro1: about to return\");\n+    T x = y;\n+    co_return co_await x + 3;\n+  };\n+\n+  PRINT (\"main: create coro1\");\n+  coro1 x = f.operator()<int>(17);\n+  if (x.handle.done())\n+    abort();\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (initial suspend)\");\n+\n+  x.handle.resume();\n+  PRINT (\"main: after resume (co_await)\");\n+\n+  /* Now we should have the co_returned value.  */\n+  int y = x.handle.promise().get_value();\n+  if ( y != 20 )\n+    {\n+      PRINTF (\"main: wrong result (%d).\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "7cd6648cca69e0f27d09e2f38de9a7acdbe9077b", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-05-capture-copy-local.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-05-capture-copy-local.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-05-capture-copy-local.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-05-capture-copy-local.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,66 @@\n+//  { dg-do run }\n+\n+// lambda with parm and local state\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  int local = 31;\n+\n+  auto f = [=](int start) -> coro1\n+  {\n+    int value = start;\n+    PRINT (\"f: about to yield start\");\n+    co_yield start;\n+\n+    value -= local;\n+    PRINT (\"f: about to yield (value-31)\");\n+    co_yield value;\n+\n+    value += 6163;\n+    PRINT (\"f: about to return (value+6163)\");\n+    co_return value;\n+  };\n+\n+  PRINT (\"main: create coro1\");\n+  coro1 x = f (42);\n+  PRINT (\"main: got coro1 - resuming (1)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (1)\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  PRINT (\"main: apparently got 42 - resuming (2)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2)\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 11 )\n+    abort ();\n+  PRINT (\"main: apparently got 11 - resuming (3)\");\n+  if (x.handle.done())\n+    {\n+   PRINT (\"main: done?\");\n+   abort();\n+    }\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2) checking return\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  PRINT (\"main: apparently got 6174\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "7b445d3d9cd032fe049c491271623b3d7773317f", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-06-multi-capture.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-06-multi-capture.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-06-multi-capture.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-06-multi-capture.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,48 @@\n+//  { dg-do run }\n+\n+// lambda with parm and local state\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  int a_copy = 20;\n+  int a_ref = 10;\n+\n+  auto f = [&, a_copy]() -> coro1\n+  {\n+    co_return a_ref + a_copy;\n+  };\n+\n+  {\n+    coro1 A = f ();\n+    A.handle.resume();\n+    PRINT (\"main: [a_copy = 20, a_ref = 10]\");\n+  \n+    int y = A.handle.promise().get_value();\n+    if (y != 30)\n+      {\n+\tPRINTF (\"main: A co-ret = %d, should be 30\\n\", y);\n+\tabort ();\n+      }\n+  }\n+\n+  a_copy = 5;\n+  a_ref = 7;\n+\n+  coro1 B = f ();\n+  B.handle.resume();\n+  PRINT (\"main: [a_copy = 5, a_ref = 7]\");\n+\n+  int y = B.handle.promise().get_value();\n+  if (y != 27)\n+    {\n+      PRINTF (\"main: B co-ret = %d, should be 27\\n\", y);\n+      abort ();\n+    }\n+  \n+  return 0;\n+}"}, {"sha": "2bd58cbf2ec4114241bc51e1412c005adc5d79a3", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-07-multi-yield.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-07-multi-yield.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-07-multi-yield.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-07-multi-yield.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,46 @@\n+//  { dg-do run }\n+\n+// lambda with parm and local state\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  int a_copy = 20;\n+  int a_ref = 10;\n+\n+  auto f = [&, a_copy]() -> coro1\n+  {\n+    co_yield a_ref + a_copy;\n+    co_return a_ref + a_copy;\n+  };\n+\n+  coro1 A = f ();\n+  A.handle.resume(); // Initial suspend.\n+  PRINT (\"main: [a_copy = 20, a_ref = 10]\");\n+  \n+  int y = A.handle.promise().get_value();\n+  if (y != 30)\n+    {\n+      PRINTF (\"main: co-yield = %d, should be 30\\n\", y);\n+      abort ();\n+    }\n+\n+  a_copy = 5;\n+  a_ref = 7;\n+\n+  A.handle.resume();\n+  PRINT (\"main: [a_copy = 5, a_ref = 7]\");\n+\n+  y = A.handle.promise().get_value();\n+  if (y != 27)\n+    {\n+      PRINTF (\"main: co-ret = %d, should be 27\\n\", y);\n+      abort ();\n+    }\n+  \n+  return 0;\n+}"}, {"sha": "4d5a44fe29a49f1e6331c9b18ed84ed1ee29bf73", "filename": "gcc/testsuite/g++.dg/coroutines/torture/lambda-08-co-ret-parm-ref.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-08-co-ret-parm-ref.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-08-co-ret-parm-ref.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flambda-08-co-ret-parm-ref.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,59 @@\n+//  { dg-do run }\n+\n+// Test that we can use a function param in a co_xxxx status.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+int main ()\n+{\n+  int val;\n+\n+  auto f = [&] (int x) -> coro1\n+  {\n+    if (val + x > 25)\n+      {\n+        PRINT (\"coro1: about to return k\");\n+        co_return 6174;\n+      }\n+    else if (val + x > 20)\n+      {\n+        PRINTF (\"coro1: about to co-return %d\\n\", val + x);\n+        co_return val + x;\n+      }\n+    else if (val + x > 5)\n+      {\n+        PRINTF (\"coro1: about to co-return %d\\n\", val);\n+        co_return val;\n+      }\n+    else\n+      {\n+        PRINT (\"coro1: about to return 0\");\n+        co_return 0;\n+      }\n+  };\n+\n+  PRINT (\"main: create coro1\");\n+\n+  val = 20;  // We should get this by ref.\n+  int arg = 5; // and this as a regular parm.\n+\n+  coro1 x = f (arg);\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 25 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "a8956457dcd3f6ff7dd9b6ef82c377eee2a1e8d9", "filename": "gcc/testsuite/g++.dg/coroutines/torture/local-var-0.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-0.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,37 @@\n+//  { dg-do run }\n+\n+// Simplest local decl.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f () noexcept\n+{\n+  const int answer = 42;\n+  PRINTF (\"coro1: about to return %d\\n\", answer);\n+  co_return answer;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "69a5b707563c80218356dcf276ce63b37b7ab9ea", "filename": "gcc/testsuite/g++.dg/coroutines/torture/local-var-1.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-1.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,37 @@\n+//  { dg-do run }\n+\n+// Simplest local var\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f (int x) noexcept\n+{\n+  int answer = x + 6132;\n+  PRINTF (\"coro1: about to return %d\\n\", answer);\n+  co_return answer;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (42);\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "f232edabdae42dd7f142bd49e59c2a849bfe7d9b", "filename": "gcc/testsuite/g++.dg/coroutines/torture/local-var-2.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-2.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,50 @@\n+//  { dg-do run }\n+\n+// Test local vars in nested scopes\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f (int x) noexcept\n+{\n+  int y = x;\n+  const int test = 20;\n+  if (y > test)\n+    {\n+      int fred = y - 20;\n+      PRINTF (\"coro1: about to return %d\\n\", fred);\n+      co_return fred;\n+    }\n+  else\n+    {\n+      PRINT (\"coro1: about to return the answer\\n\");\n+      co_return y;\n+    }\n+\n+  co_return x;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (6194);\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+      //x.handle.resume();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "bd06db53d4832222bb4c0cbe959d89c56e712895", "filename": "gcc/testsuite/g++.dg/coroutines/torture/local-var-3.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-3.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,65 @@\n+//  { dg-do run }\n+\n+// Test modifying a local var and yielding several instances of it.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f (int start) noexcept\n+{\n+  int value = start;\n+  PRINT (\"f: about to yield start\");\n+  co_yield start;\n+\n+  value -= 31;\n+  PRINT (\"f: about to yield (value-31)\");\n+  co_yield value;\n+\n+  value += 6163;\n+  PRINT (\"f: about to return (value+6163)\");\n+  co_return value;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (42);\n+  PRINT (\"main: got coro1 - resuming (1)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (1)\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    abort ();\n+  PRINT (\"main: apparently got 42 - resuming (2)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2)\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 11 )\n+    abort ();\n+  PRINT (\"main: apparently got 11 - resuming (3)\");\n+  if (x.handle.done())\n+    {\n+   PRINT (\"main: done?\");\n+   abort();\n+    }\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2) checking return\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  PRINT (\"main: apparently got 6174\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "419eb6b64673552d18ed0c2555b87af7b3b45c7c", "filename": "gcc/testsuite/g++.dg/coroutines/torture/local-var-4.C", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-4.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,75 @@\n+//  { dg-do run }\n+\n+// Test modifying a local var across nested scopes containing vars\n+// hiding those at outer scopes.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct coro1\n+f (int start) noexcept\n+{\n+  int value = start;\n+  {\n+    int value = start + 5;\n+    {\n+\tint value = start + 20;\n+    }\n+    {\n+\tint value = start + 1;\n+\tPRINT (\"f: about to yield start\");\n+\tco_yield value;\n+    }\n+  }\n+\n+  value -= 31;\n+  PRINT (\"f: about to yield (value-31)\");\n+  co_yield value;\n+\n+  value += 6163;\n+  PRINT (\"f: about to return (value+6163)\");\n+  co_return value;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (42);\n+  PRINT (\"main: got coro1 - resuming (1)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (1)\");\n+  int y = x.handle.promise().get_value();\n+  if ( y != 43 )\n+    abort ();\n+  PRINT (\"main: apparently got 42 - resuming (2)\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2)\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 11 )\n+    abort ();\n+  PRINT (\"main: apparently got 11 - resuming (3)\");\n+  if (x.handle.done())\n+    {\n+   PRINT (\"main: done?\");\n+   abort();\n+    }\n+  x.handle.resume();\n+  PRINT (\"main: after resume (2) checking return\");\n+  y = x.handle.promise().get_value();\n+  if ( y != 6174 )\n+    abort ();\n+  PRINT (\"main: apparently got 6174\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "934fb19de7d26bcc6759909e10dc808aef2823d7", "filename": "gcc/testsuite/g++.dg/coroutines/torture/mid-suspend-destruction-0.C", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fmid-suspend-destruction-0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fmid-suspend-destruction-0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fmid-suspend-destruction-0.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,107 @@\n+// { dg-do run }\n+// { dg-output \"main: returning\\n\" }\n+// { dg-output \"Destroyed coro1\\n\" }\n+// { dg-output \"Destroyed suspend_always_prt\\n\" }\n+// { dg-output \"Destroyed Promise\\n\" }\n+\n+// Check that we still get the right DTORs run when we let a suspended coro\n+// go out of scope.\n+\n+#include \"../coro.h\"\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () : handle(0) {}\n+  coro1 (handle_type _handle)\n+    : handle(_handle) {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) : handle(s.handle) {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() {\n+        printf (\"Destroyed coro1\\n\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  ~suspend_never_prt() {};\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  ~suspend_always_prt() { printf (\"Destroyed suspend_always_prt\\n\"); }\n+  };\n+\n+  struct promise_type {\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { printf (\"Destroyed Promise\\n\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_void () {\n+    PRINT (\"return_void ()\");\n+  }\n+\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+  };\n+};\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f ();\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    {\n+      PRINT (\"main: f() should be suspended, says it's done\");\n+      abort();\n+    }\n+\n+#if __has_builtin (__builtin_coro_suspended)\n+  if (! __builtin_coro_suspended(handle))\n+    {\n+      PRINT (\"main: f() should be suspended, but says it isn't\");\n+      abort();\n+    }\n+#endif\n+\n+  /* We are suspended... so let everything out of scope and therefore\n+     destroy it.  */\n+\n+  puts (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "b2f1be78b3e8fc5904a074cc4227fd1d9ebe4c35", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr92933.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr92933.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr92933.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr92933.C?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,18 @@\n+//  { dg-do compile }\n+\n+// Test that we compile the simple case described in PR 92933\n+\n+#include \"../coro.h\"\n+\n+#define RETURN_VOID\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+struct some_error {};\n+\n+coro1\n+foo() {\n+    try {\n+        co_return;\n+    } catch (some_error) {\n+    }\n+}"}, {"sha": "a1207a20a3c9e84eee8035281b518e616ba57cfc", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -478,6 +478,8 @@ extern gimple_opt_pass *make_pass_gen_hsail (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_warn_nonnull_compare (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_sprintf_length (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_walloca (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_coroutine_lower_builtins (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_coroutine_early_expand_ifns (gcc::context *ctxt);\n \n /* IPA Passes */\n extern simple_ipa_opt_pass *make_pass_ipa_lower_emutls (gcc::context *ctxt);"}, {"sha": "79bab71441941037de55a46403d63977737f9558", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -1,3 +1,9 @@\n+2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* include/Makefile.am: Add coroutine to the std set.\n+\t* include/Makefile.in: Regenerated.\n+\t* include/std/coroutine: New file.\n+\n 2020-01-17  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/92376"}, {"sha": "ad4404793beaa9ab48669d58706d9cd9e309c89b", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -38,6 +38,7 @@ std_headers = \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/concepts \\\n \t${std_srcdir}/condition_variable \\\n+\t${std_srcdir}/coroutine \\\n \t${std_srcdir}/deque \\\n \t${std_srcdir}/execution \\\n \t${std_srcdir}/filesystem \\"}, {"sha": "f8b5645224223f3b8ab9fb5f9d8aa81ca625663c", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -382,6 +382,7 @@ std_headers = \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/concepts \\\n \t${std_srcdir}/condition_variable \\\n+\t${std_srcdir}/coroutine \\\n \t${std_srcdir}/deque \\\n \t${std_srcdir}/execution \\\n \t${std_srcdir}/filesystem \\"}, {"sha": "363402330e45d62823137d413e181d8cdb346fb7", "filename": "libstdc++-v3/include/std/coroutine", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49789fd08378e3ff7a6efd7c4f72b72654259b89/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcoroutine", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49789fd08378e3ff7a6efd7c4f72b72654259b89/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcoroutine", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcoroutine?ref=49789fd08378e3ff7a6efd7c4f72b72654259b89", "patch": "@@ -0,0 +1,291 @@\n+// <coroutine> -*- C++ -*-\n+\n+// Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/coroutine\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_COROUTINE\n+#define _GLIBCXX_COROUTINE 1\n+\n+#pragma GCC system_header\n+\n+// It is very likely that earlier versions would work, but they are untested.\n+#if __cplusplus >= 201402L\n+\n+#include <bits/c++config.h>\n+\n+/**\n+ * @defgroup coroutines Coroutines\n+ *\n+ * Components for supporting coroutine implementations.\n+ */\n+\n+#if __cplusplus > 201703L && __cpp_impl_three_way_comparison >= 201907L\n+#  include <compare>\n+#  define _COROUTINES_USE_SPACESHIP 1\n+#else\n+#  include <bits/stl_function.h> // for std::less\n+#  define _COROUTINES_USE_SPACESHIP 0\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY (default)\n+{\n+  _GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+#if __cpp_coroutines\n+  inline namespace __n4835 {\n+\n+  // 17.12.2 coroutine traits\n+  /// [coroutine.traits]\n+  /// [coroutine.traits.primary]\n+  template <typename _Result, typename...>\n+    struct coroutine_traits\n+    {\n+       using promise_type = typename _Result::promise_type;\n+    };\n+\n+  // 17.12.3 Class template coroutine_handle\n+  /// [coroutine.handle]\n+  template <typename _Promise = void>\n+    struct coroutine_handle;\n+\n+  template <> struct\n+    coroutine_handle<void>\n+    {\n+    public:\n+      // 17.12.3.1, construct/reset\n+      constexpr coroutine_handle() noexcept : _M_fr_ptr(0) {}\n+\n+      constexpr coroutine_handle(std::nullptr_t __h) noexcept\n+\t: _M_fr_ptr(__h)\n+      {}\n+\n+      coroutine_handle& operator=(std::nullptr_t) noexcept\n+      {\n+\t_M_fr_ptr = nullptr;\n+\treturn *this;\n+      }\n+\n+    public:\n+      // 17.12.3.2, export/import\n+      constexpr void* address() const noexcept { return _M_fr_ptr; }\n+\n+      constexpr static coroutine_handle from_address(void* __a) noexcept\n+      {\n+\tcoroutine_handle __self;\n+\t__self._M_fr_ptr = __a;\n+\treturn __self;\n+      }\n+\n+    public:\n+      // 17.12.3.3, observers\n+      constexpr explicit operator bool() const noexcept\n+      {\n+\treturn bool(_M_fr_ptr);\n+      }\n+\n+      bool done() const noexcept { return __builtin_coro_done(_M_fr_ptr); }\n+\n+      // 17.12.3.4, resumption\n+      void operator()() const { resume(); }\n+\n+      void resume() const { __builtin_coro_resume(_M_fr_ptr); }\n+\n+      void destroy() const { __builtin_coro_destroy(_M_fr_ptr); }\n+\n+    protected:\n+      void* _M_fr_ptr;\n+  };\n+\n+  // 17.12.3.6 Comparison operators\n+  /// [coroutine.handle.compare]\n+  constexpr bool operator==(coroutine_handle<> __a,\n+\t\t\t    coroutine_handle<> __b) noexcept\n+  {\n+    return __a.address() == __b.address();\n+  }\n+\n+#if _COROUTINES_USE_SPACESHIP\n+  constexpr strong_ordering\n+  operator<=>(coroutine_handle<> __a, coroutine_handle<> __b) noexcept\n+  { return std::compare_three_way()(__a.address(), __b.address()); }\n+#else\n+  // These are to enable operation with std=c++14,17.\n+  constexpr bool operator!=(coroutine_handle<> __a,\n+\t\t\t    coroutine_handle<> __b) noexcept\n+  {\n+    return !(__a == __b);\n+  }\n+\n+  constexpr bool operator<(coroutine_handle<> __a,\n+\t\t\t   coroutine_handle<> __b) noexcept\n+  {\n+    return less<void*>()(__a.address(), __b.address());\n+  }\n+\n+  constexpr bool operator>(coroutine_handle<> __a,\n+\t\t\t   coroutine_handle<> __b) noexcept\n+  {\n+    return __b < __a;\n+  }\n+\n+  constexpr bool operator<=(coroutine_handle<> __a,\n+\t\t\t    coroutine_handle<> __b) noexcept\n+  {\n+    return !(__a > __b);\n+  }\n+\n+  constexpr bool operator>=(coroutine_handle<> __a,\n+\t\t\t    coroutine_handle<> __b) noexcept\n+  {\n+    return !(__a < __b);\n+  }\n+#endif\n+\n+  template <typename _Promise>\n+    struct coroutine_handle : coroutine_handle<>\n+    {\n+      // 17.12.3.1, construct/reset\n+      using coroutine_handle<>::coroutine_handle;\n+\n+      static coroutine_handle from_promise(_Promise& p)\n+      {\n+\tcoroutine_handle __self;\n+\t__self._M_fr_ptr\n+\t  = __builtin_coro_promise((char*) &p, __alignof(_Promise), true);\n+\treturn __self;\n+      }\n+\n+      coroutine_handle& operator=(std::nullptr_t) noexcept\n+      {\n+\tcoroutine_handle<>::operator=(nullptr);\n+\treturn *this;\n+      }\n+\n+    // 17.12.3.2, export/import\n+    constexpr static coroutine_handle from_address(void* __a)\n+    {\n+      coroutine_handle __self;\n+      __self._M_fr_ptr = __a;\n+      return __self;\n+    }\n+\n+    // 17.12.3.5, promise accesss\n+    _Promise& promise() const\n+    {\n+      void* __t\n+\t= __builtin_coro_promise (this->_M_fr_ptr, __alignof(_Promise), false);\n+      return *static_cast<_Promise*>(__t);\n+    }\n+  };\n+\n+  /// [coroutine.noop]\n+  struct noop_coroutine_promise\n+  {\n+  };\n+\n+  void __dummy_resume_destroy() __attribute__((__weak__));\n+  void __dummy_resume_destroy() {}\n+\n+  struct __noop_coro_frame\n+  {\n+    void (*__r)() = __dummy_resume_destroy;\n+    void (*__d)() = __dummy_resume_destroy;\n+    struct noop_coroutine_promise __p;\n+  } __noop_coro_fr __attribute__((__weak__));\n+\n+  // 17.12.4.1 Class noop_coroutine_promise\n+  /// [coroutine.promise.noop]\n+  template <>\n+    struct coroutine_handle<noop_coroutine_promise> : public coroutine_handle<>\n+    {\n+      using _Promise = noop_coroutine_promise;\n+\n+    public:\n+      // 17.12.4.2.1, observers\n+      constexpr explicit operator bool() const noexcept { return true; }\n+\n+      constexpr bool done() const noexcept { return false; }\n+\n+      // 17.12.4.2.2, resumption\n+      void operator()() const noexcept {}\n+\n+      void resume() const noexcept {}\n+\n+      void destroy() const noexcept {}\n+\n+      // 17.12.4.2.3, promise access\n+      _Promise& promise() const\n+      {\n+\treturn *static_cast<_Promise*>(\n+\t  __builtin_coro_promise(this->_M_fr_ptr, __alignof(_Promise), false));\n+      }\n+\n+      // 17.12.4.2.4, address\n+    private:\n+      friend coroutine_handle<noop_coroutine_promise> noop_coroutine() noexcept;\n+\n+      coroutine_handle() noexcept { this->_M_fr_ptr = (void*) &__noop_coro_fr; }\n+    };\n+\n+  using noop_coroutine_handle = coroutine_handle<noop_coroutine_promise>;\n+\n+  inline noop_coroutine_handle noop_coroutine() noexcept\n+  {\n+    return noop_coroutine_handle();\n+  }\n+\n+  // 17.12.5 Trivial awaitables\n+  /// [coroutine.trivial.awaitables]\n+  struct suspend_always\n+  {\n+    bool await_ready() { return false; }\n+\n+    void await_suspend(coroutine_handle<>) {}\n+\n+    void await_resume() {}\n+  };\n+\n+  struct suspend_never\n+  {\n+    bool await_ready() { return true; }\n+\n+    void await_suspend(coroutine_handle<>) {}\n+\n+    void await_resume() {}\n+  };\n+\n+  } // namespace __n4835\n+\n+#else\n+#error \"the coroutine header requires -fcoroutines\"\n+#endif\n+\n+  _GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++14 (we are allowing use from at least this)\n+\n+#endif // _GLIBCXX_COROUTINE"}]}