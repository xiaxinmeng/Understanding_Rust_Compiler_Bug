{"sha": "065ae6117579cc9a089c238207b42f5a1470423a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY1YWU2MTE3NTc5Y2M5YTA4OWMyMzgyMDdiNDJmNWExNDcwNDIzYQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2007-03-26T21:04:59Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2007-03-26T21:04:59Z"}, "message": "gengtype.h: Remove all type definitions to gengtype.c...\n\n\t* gengtype.h: Remove all type definitions to gengtype.c; leave\n\tonly definitions of options_p, type_p, and pair_p as opaque\n\tpointers.  Update prototypes.\n\t* gengtype.c: Many type definitions moved here from gengtype.h.\n\tConsolidate type definitions at the top of the file.\n\t(xvasprintf): Delete.\n\t(xasprintf): Make static.\n\t(create_nested_pointer_option): Add 'next' parameter.\n\t(create_field_all, create_field_at): New functions.\n\t(create_field): Now a thin wrapper around create_field_all.\n\t(create_optional_field): Rename create_optional_field_ and add\n\tline argument.  Original name is now a macro which supplies\n\t__LINE__.\n\t(oprintf): Use vsnprintf directly.\n\t(close_output_files): Use fatal rather than perror/exit.\n\t(note_def_vec, note_def_vec_alloc): Use create_field_at.\n\t(main): Set progname.  Don't use exit.\n\t* gengtype-yacc.y (struct_fields): Use create_field_at.\n\t(option, optionseqopt): Delete.\n\t(optionseq): Consolidate productions from option here so we\n\tcan use the first argument to create_option.\n\nFrom-SVN: r123233", "tree": {"sha": "0a7175b4448ec3facb884c40c5169621bbe9bbe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a7175b4448ec3facb884c40c5169621bbe9bbe8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/065ae6117579cc9a089c238207b42f5a1470423a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/065ae6117579cc9a089c238207b42f5a1470423a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/065ae6117579cc9a089c238207b42f5a1470423a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/065ae6117579cc9a089c238207b42f5a1470423a/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "17defa6a13ef4f317e22dcb3827b4e8ea1b37541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17defa6a13ef4f317e22dcb3827b4e8ea1b37541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17defa6a13ef4f317e22dcb3827b4e8ea1b37541"}], "stats": {"total": 552, "additions": 275, "deletions": 277}, "files": [{"sha": "b0dd7b8ea7c12dcb97933ea8eebc37db0ae9ccfa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065ae6117579cc9a089c238207b42f5a1470423a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065ae6117579cc9a089c238207b42f5a1470423a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=065ae6117579cc9a089c238207b42f5a1470423a", "patch": "@@ -1,5 +1,27 @@\n 2007-03-26  Zack Weinberg  <zackw@panix.com>\n \n+\t* gengtype.h: Remove all type definitions to gengtype.c; leave\n+\tonly definitions of options_p, type_p, and pair_p as opaque\n+\tpointers.  Update prototypes.\n+\t* gengtype.c: Many type definitions moved here from gengtype.h.\n+\tConsolidate type definitions at the top of the file.\n+\t(xvasprintf): Delete.\n+\t(xasprintf): Make static.\n+\t(create_nested_pointer_option): Add 'next' parameter.\n+\t(create_field_all, create_field_at): New functions.\n+\t(create_field): Now a thin wrapper around create_field_all.\n+\t(create_optional_field): Rename create_optional_field_ and add\n+\tline argument.  Original name is now a macro which supplies\n+\t__LINE__.\n+\t(oprintf): Use vsnprintf directly.\n+\t(close_output_files): Use fatal rather than perror/exit.\n+\t(note_def_vec, note_def_vec_alloc): Use create_field_at.\n+\t(main): Set progname.  Don't use exit.\n+\t* gengtype-yacc.y (struct_fields): Use create_field_at.\n+\t(option, optionseqopt): Delete.\n+\t(optionseq): Consolidate productions from option here so we\n+\tcan use the first argument to create_option.\n+\n \t* gengtype-lex.l: Distinguish unions from structures in the\n \ttoken type.  Don't call find_structure; return the tag as a string.\n \t* gengtype-yacc.y: Add new token types ENT_TYPEDEF_UNION and ENT_UNION."}, {"sha": "292f3ef6f028ed7aacec9a342d94088f29bcc7d4", "filename": "gcc/gengtype-yacc.y", "status": "modified", "additions": 20, "deletions": 48, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065ae6117579cc9a089c238207b42f5a1470423a/gcc%2Fgengtype-yacc.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065ae6117579cc9a089c238207b42f5a1470423a/gcc%2Fgengtype-yacc.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-yacc.y?ref=065ae6117579cc9a089c238207b42f5a1470423a", "patch": "@@ -57,7 +57,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n %type <p> struct_fields\n %type <t> type lasttype\n-%type <o> optionsopt options option optionseq optionseqopt\n+%type <o> optionsopt options optionseq\n %type <s> type_option stringseq\n \n %%\n@@ -128,33 +128,17 @@ semiequal: ';'\n struct_fields: { $$ = NULL; }\n \t       | type optionsopt ID bitfieldopt ';' struct_fields\n \t          {\n-\t            pair_p p = XNEW (struct pair);\n-\t\t    p->type = adjust_field_type ($1, $2);\n-\t\t    p->opt = $2;\n-\t\t    p->name = $3;\n-\t\t    p->next = $6;\n-\t\t    p->line = lexer_line;\n-\t\t    $$ = p;\n+\t\t    $$ = create_field_at ($6, $1, $3, $2, &lexer_line);\n \t\t  }\n \t       | type optionsopt ID ARRAY ';' struct_fields\n \t          {\n-\t            pair_p p = XNEW (struct pair);\n-\t\t    p->type = adjust_field_type (create_array ($1, $4), $2);\n-\t\t    p->opt = $2;\n-\t\t    p->name = $3;\n-\t\t    p->next = $6;\n-\t\t    p->line = lexer_line;\n-\t\t    $$ = p;\n+\t\t    $$ = create_field_at ($6, create_array ($1, $4),\n+\t\t    \t\t\t  $3, $2, &lexer_line);\n \t\t  }\n \t       | type optionsopt ID ARRAY ARRAY ';' struct_fields\n \t          {\n-\t            pair_p p = XNEW (struct pair);\n-\t\t    p->type = create_array (create_array ($1, $5), $4);\n-\t\t    p->opt = $2;\n-\t\t    p->name = $3;\n-\t\t    p->next = $7;\n-\t\t    p->line = lexer_line;\n-\t\t    $$ = p;\n+\t\t    type_p arr = create_array (create_array ($1, $5), $4);\n+\t\t    $$ = create_field_at ($7, arr, $3, $2, &lexer_line);\n \t\t  }\n \t       | type ':' bitfieldlen ';' struct_fields\n \t\t  { $$ = $5; }\n@@ -204,7 +188,7 @@ optionsopt: { $$ = NULL; }\n \t    | options { $$ = $1; }\n \t    ;\n \n-options: GTY_TOKEN '(' '(' optionseqopt ')' ')'\n+options: GTY_TOKEN '(' '(' optionseq ')' ')'\n \t   { $$ = $4; }\n \t ;\n \n@@ -214,31 +198,19 @@ type_option : ALIAS\n \t        { $$ = $1; }\n \t      ;\n \n-option:   ID\n-\t    { $$ = create_option (NULL, $1, (void *)\"\"); }\n-        | ID '(' stringseq ')'\n-            { $$ = create_option (NULL, $1, (void *)$3); }\n-\t| type_option '(' type ')'\n-\t    { $$ = create_option (NULL, $1, adjust_field_type ($3, NULL)); }\n-\t| NESTED_PTR '(' type ',' stringseq ',' stringseq ')'\n-\t    { $$ = create_nested_ptr_option ($3, $5, $7); }\n-\t;\n-\n-optionseq: option\n-\t      {\n-\t        $1->next = NULL;\n-\t\t$$ = $1;\n-\t      }\n-\t    | optionseq ',' option\n-\t      {\n-\t        $3->next = $1;\n-\t\t$$ = $3;\n-\t      }\n-\t    ;\n-\n-optionseqopt: { $$ = NULL; }\n-\t      | optionseq { $$ = $1; }\n-\t      ;\n+optionseq: { $$ = NULL; }\n+\t| optionseq commaopt ID\n+\t   { $$ = create_option ($1, $3, (void *)\"\"); }\n+\t| optionseq commaopt ID '(' stringseq ')'\n+\t   { $$ = create_option ($1, $3, (void *)$5); }\n+\t| optionseq commaopt type_option '(' type ')'\n+\t   { $$ = create_option ($1, $3, adjust_field_type ($5, 0)); }\n+\t| optionseq commaopt NESTED_PTR '(' type ',' stringseq ',' stringseq ')'\n+\t   { $$ = create_nested_ptr_option ($1, $5, $7, $9); }\n+\n+commaopt: /* nothing */\n+\t  | ','\n+\t  ;\n \n stringseq: STRING\n \t     { $$ = $1; }"}, {"sha": "604d94cf8712816009a9211c074da5a34be1ca61", "filename": "gcc/gengtype.c", "status": "modified", "additions": 223, "deletions": 103, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065ae6117579cc9a089c238207b42f5a1470423a/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065ae6117579cc9a089c238207b42f5a1470423a/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=065ae6117579cc9a089c238207b42f5a1470423a", "patch": "@@ -22,9 +22,153 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"bconfig.h\"\n #include \"system.h\"\n #include \"gengtype.h\"\n-#include \"gtyp-gen.h\"\n #include \"errors.h\"\t/* for fatal */\n \n+/* Data types, macros, etc. used only in this file.  */\n+\n+/* Kinds of types we can understand.  */\n+enum typekind {\n+  TYPE_SCALAR,\n+  TYPE_STRING,\n+  TYPE_STRUCT,\n+  TYPE_UNION,\n+  TYPE_POINTER,\n+  TYPE_ARRAY,\n+  TYPE_LANG_STRUCT,\n+  TYPE_PARAM_STRUCT\n+};\n+\n+typedef unsigned lang_bitmap;\n+\n+/* A way to pass data through to the output end.  */\n+struct options\n+{\n+  struct options *next;\n+  const char *name;\n+  const char *info;\n+};\n+\n+/* Option data for the 'nested_ptr' option.  */\n+struct nested_ptr_data\n+{\n+  type_p type;\n+  const char *convert_to;\n+  const char *convert_from;\n+};\n+\n+/* A name and a type.  */\n+struct pair\n+{\n+  pair_p next;\n+  const char *name;\n+  type_p type;\n+  struct fileloc line;\n+  options_p opt;\n+};\n+\n+#define NUM_PARAM 10\n+\n+/* A description of a type.  */\n+enum gc_used_enum\n+  {\n+    GC_UNUSED = 0,\n+    GC_USED,\n+    GC_MAYBE_POINTED_TO,\n+    GC_POINTED_TO\n+  };\n+\n+struct type\n+{\n+  enum typekind kind;\n+  type_p next;\n+  type_p pointer_to;\n+  enum gc_used_enum gc_used;\n+  union {\n+    type_p p;\n+    struct {\n+      const char *tag;\n+      struct fileloc line;\n+      pair_p fields;\n+      options_p opt;\n+      lang_bitmap bitmap;\n+      type_p lang_struct;\n+    } s;\n+    bool scalar_is_char;\n+    struct {\n+      type_p p;\n+      const char *len;\n+    } a;\n+    struct {\n+      type_p stru;\n+      type_p param[NUM_PARAM];\n+      struct fileloc line;\n+    } param_struct;\n+  } u;\n+};\n+\n+#define UNION_P(x)\t\t\t\t\t\\\n+ ((x)->kind == TYPE_UNION || \t\t\t\t\\\n+  ((x)->kind == TYPE_LANG_STRUCT \t\t\t\\\n+   && (x)->u.s.lang_struct->kind == TYPE_UNION))\n+#define UNION_OR_STRUCT_P(x)\t\t\t\\\n+ ((x)->kind == TYPE_UNION \t\t\t\\\n+  || (x)->kind == TYPE_STRUCT \t\t\t\\\n+  || (x)->kind == TYPE_LANG_STRUCT)\n+\n+/* Structure representing an output file.  */\n+struct outf\n+{\n+  struct outf *next;\n+  const char *name;\n+  size_t buflength;\n+  size_t bufused;\n+  char *buf;\n+};\n+typedef struct outf * outf_p;\n+\n+/* An output file, suitable for definitions, that can see declarations\n+   made in INPUT_FILE and is linked into every language that uses\n+   INPUT_FILE.  */\n+extern outf_p get_output_file_with_visibility\n+   (const char *input_file);\n+const char *get_output_file_name (const char *);\n+\n+#include \"gtyp-gen.h\"\n+\n+/* A bitmap that specifies which of BASE_FILES should be used to\n+   output a definition that is different for each language and must be\n+   defined once in each language that uses INPUT_FILE.  */\n+static lang_bitmap get_base_file_bitmap (const char *input_file);\n+\n+/* Print, like fprintf, to O.  */\n+static void oprintf (outf_p o, const char *S, ...)\n+     ATTRIBUTE_PRINTF_2;\n+\n+/* The list of output files.  */\n+static outf_p output_files;\n+\n+/* The output header file that is included into pretty much every\n+   source file.  */\n+static outf_p header_file;\n+\n+/* Number of files specified in gtfiles.  */\n+#define NUM_GT_FILES (ARRAY_SIZE (all_files) - 1)\n+\n+/* Number of files in the language files array.  */\n+#define NUM_LANG_FILES (ARRAY_SIZE (lang_files) - 1)\n+\n+/* Length of srcdir name.  */\n+static int srcdir_len = 0;\n+\n+/* A list of output files suitable for definitions.  There is one\n+   BASE_FILES entry for each language.  */\n+#define NUM_BASE_FILES (ARRAY_SIZE (lang_dir_names) - 1)\n+static outf_p base_files[NUM_BASE_FILES];\n+\n+static outf_p create_file (const char *, const char *);\n+static const char * get_file_basename (const char *);\n+\n+\f\n /* Nonzero iff an error has occurred.  */\n static int hit_error = 0;\n \n@@ -50,29 +194,20 @@ error_at_line (struct fileloc *pos, const char *msg, ...)\n   va_end (ap);\n }\n \n-/* vasprintf, but produces fatal message on out-of-memory.  */\n-int\n-xvasprintf (char **result, const char *format, va_list args)\n-{\n-  int ret = vasprintf (result, format, args);\n-  if (*result == NULL || ret < 0)\n-    {\n-      fputs (\"gengtype: out of memory\", stderr);\n-      xexit (1);\n-    }\n-  return ret;\n-}\n-\n-/* Wrapper for xvasprintf.  */\n-char *\n+/* asprintf, but produces fatal message on out-of-memory.  */\n+static char * ATTRIBUTE_PRINTF_1\n xasprintf (const char *format, ...)\n {\n+  int n;\n   char *result;\n   va_list ap;\n \n   va_start (ap, format);\n-  xvasprintf (&result, format, ap);\n+  n = vasprintf (&result, format, ap);\n+  if (result == NULL || n < 0)\n+    fatal (\"out of memory\");\n   va_end (ap);\n+\n   return result;\n }\n \n@@ -332,14 +467,15 @@ create_option (options_p next, const char *name, const void *info)\n \n /* Return an options structure for a \"nested_ptr\" option.  */\n options_p\n-create_nested_ptr_option (type_p t, const char *to, const char *from)\n+create_nested_ptr_option (options_p next, type_p t,\n+\t\t\t  const char *to, const char *from)\n {\n   struct nested_ptr_data *d = XNEW (struct nested_ptr_data);\n \n   d->type = adjust_field_type (t, 0);\n   d->convert_to = to;\n   d->convert_from = from;\n-  return create_option (NULL, \"nested_ptr\", d);\n+  return create_option (next, \"nested_ptr\", d);\n }\n \n /* Add a variable named S of type T with options O defined at POS,\n@@ -358,33 +494,48 @@ note_variable (const char *s, type_p t, options_p o, struct fileloc *pos)\n   variables = n;\n }\n \n-/* Create a fake field with the given type and name.  NEXT is the next\n-   field in the chain.  */\n-\n+/* Most-general structure field creator.  */\n static pair_p\n-create_field (pair_p next, type_p type, const char *name)\n+create_field_all (pair_p next, type_p type, const char *name, options_p opt,\n+\t\t  const char *file, int line)\n {\n   pair_p field;\n \n   field = XNEW (struct pair);\n   field->next = next;\n   field->type = type;\n   field->name = name;\n-  field->opt = NULL;\n-  field->line.file = __FILE__;\n-  field->line.line = __LINE__;\n+  field->opt = opt;\n+  field->line.file = file;\n+  field->line.line = line;\n   return field;\n }\n \n+/* Create a field that came from the source code we are scanning,\n+   i.e. we have a 'struct fileloc', and possibly options; also,\n+   adjust_field_type should be called.  */\n+pair_p\n+create_field_at (pair_p next, type_p type, const char *name, options_p opt,\n+\t\t struct fileloc *pos)\n+{\n+  return create_field_all (next, adjust_field_type (type, opt),\n+\t\t\t   name, opt, pos->file, pos->line);\n+}\n+\n+/* Create a fake field with the given type and name.  NEXT is the next\n+   field in the chain.  */\n+#define create_field(next,type,name) \\\n+    create_field_all(next,type,name, 0, __FILE__, __LINE__)\n+\n /* Like create_field, but the field is only valid when condition COND\n    is true.  */\n \n static pair_p\n-create_optional_field (pair_p next, type_p type, const char *name,\n-\t\t       const char *cond)\n+create_optional_field_ (pair_p next, type_p type, const char *name,\n+\t\t\tconst char *cond, int line)\n {\n   static int id = 1;\n-  pair_p union_fields, field;\n+  pair_p union_fields;\n   type_p union_type;\n \n   /* Create a fake union type with a single nameless field of type TYPE.\n@@ -398,10 +549,12 @@ create_optional_field (pair_p next, type_p type, const char *name,\n \n   /* Create the field and give it the new fake union type.  Add a \"desc\"\n      tag that specifies the condition under which the field is valid.  */\n-  field = create_field (next, union_type, name);\n-  field->opt = create_option (field->opt, \"desc\", cond);\n-  return field;\n+  return create_field_all (next, union_type, name,\n+\t\t\t   create_option (0, \"desc\", cond),\n+\t\t\t   __FILE__, line);\n }\n+#define create_optional_field(next,type,name,cond)\t\\\n+       create_optional_field_(next,type,name,cond,__LINE__)\n \n /* We don't care how long a CONST_DOUBLE is.  */\n #define CONST_DOUBLE_FORMAT \"ww\"\n@@ -953,27 +1106,7 @@ set_gc_used (pair_p variables)\n    (but some output files have many input files), and there is one .h file\n    for the whole build.  */\n \n-/* The list of output files.  */\n-static outf_p output_files;\n-\n-/* The output header file that is included into pretty much every\n-   source file.  */\n-static outf_p header_file;\n-\n-/* Number of files specified in gtfiles.  */\n-#define NUM_GT_FILES (ARRAY_SIZE (all_files) - 1)\n-\n-/* Number of files in the language files array.  */\n-#define NUM_LANG_FILES (ARRAY_SIZE (lang_files) - 1)\n-\n-/* Length of srcdir name.  */\n-static int srcdir_len = 0;\n-\n-#define NUM_BASE_FILES (ARRAY_SIZE (lang_dir_names) - 1)\n-outf_p base_files[NUM_BASE_FILES];\n-\n-static outf_p create_file (const char *, const char *);\n-static const char * get_file_basename (const char *);\n+/* Output file handling.  */\n \n /* Create and return an outf_p for a new file for NAME, to be called\n    ONAME.  */\n@@ -1021,15 +1154,20 @@ create_file (const char *name, const char *oname)\n void\n oprintf (outf_p o, const char *format, ...)\n {\n-  char *s;\n   size_t slength;\n-  va_list ap;\n \n-  va_start (ap, format);\n-  slength = xvasprintf (&s, format, ap);\n+  /* Try first with the assumption that there is enough space.  */\n+  {\n+    va_list ap;\n+    va_start (ap, format);\n+    slength = vsnprintf (o->buf + o->bufused, o->buflength - o->bufused,\n+\t\t\t format, ap);\n+    va_end (ap);\n+  }\n \n-  if (o->bufused + slength > o->buflength)\n+  if (o->bufused + slength >= o->buflength)\n     {\n+      /* There wasn't enough space.  */\n       size_t new_len = o->buflength;\n       if (new_len == 0)\n \tnew_len = 1024;\n@@ -1038,11 +1176,21 @@ oprintf (outf_p o, const char *format, ...)\n       } while (o->bufused + slength >= new_len);\n       o->buf = XRESIZEVEC (char, o->buf, new_len);\n       o->buflength = new_len;\n+\n+      /* We now know that there is enough space. */\n+      {\n+\tsize_t slen2;\n+\tva_list ap;\n+\tva_start (ap, format);\n+\tslen2 = vsnprintf (o->buf + o->bufused, o->buflength - o->bufused,\n+\t\t\t   format, ap);\n+\tva_end (ap);\n+\n+\tgcc_assert (slen2 == slength);\n+\tgcc_assert (o->bufused + slen2 < o->buflength);\n+      }\n     }\n-  memcpy (o->buf + o->bufused, s, slength);\n   o->bufused += slength;\n-  free (s);\n-  va_end (ap);\n }\n \n /* Open the global header file and the language-specific header files.  */\n@@ -1298,20 +1446,11 @@ close_output_files (void)\n \n       newfile = fopen (of->name, \"w\");\n       if (newfile == NULL)\n-\t{\n-\t  perror (\"opening output file\");\n-\t  exit (1);\n-\t}\n+\tfatal (\"opening output file %s: %s\", of->name, strerror (errno));\n       if (fwrite (of->buf, 1, of->bufused, newfile) != of->bufused)\n-\t{\n-\t  perror (\"writing output file\");\n-\t  exit (1);\n-\t}\n+\tfatal (\"writing output file %s: %s\", of->name, strerror (errno));\n       if (fclose (newfile) != 0)\n-\t{\n-\t  perror (\"closing output file\");\n-\t  exit (1);\n-\t}\n+\tfatal (\"closing output file %s: %s\", of->name, strerror (errno));\n     }\n }\n \f\n@@ -3029,9 +3168,10 @@ write_roots (pair_p variables)\n void\n note_def_vec (const char *typename, bool is_scalar, struct fileloc *pos)\n {\n-  pair_p f, fields;\n+  pair_p fields;\n   type_p t;\n   options_p o;\n+  type_p len_ty = create_scalar_type (\"unsigned\");\n   const char *name = concat (\"VEC_\", typename, \"_base\", (char *)0);\n \n   if (is_scalar)\n@@ -3046,29 +3186,9 @@ note_def_vec (const char *typename, bool is_scalar, struct fileloc *pos)\n     }\n \n   /* We assemble the field list in reverse order.  */\n-  f = XNEW (struct pair);\n-  f->type = adjust_field_type (create_array (t, \"1\"), o);\n-  f->name = \"vec\";\n-  f->opt = o;\n-  f->line = *pos;\n-  f->next = 0;\n-  fields = f;\n-\n-  f = XNEW (struct pair);\n-  f->type = adjust_field_type (create_scalar_type (\"unsigned\"), 0);\n-  f->name = \"alloc\";\n-  f->opt = 0;\n-  f->line = *pos;\n-  f->next = fields;\n-  fields = f;\n-\n-  f = XNEW (struct pair);\n-  f->type = adjust_field_type (create_scalar_type (\"unsigned\"), 0);\n-  f->name = \"num\";\n-  f->opt = 0;\n-  f->line = *pos;\n-  f->next = fields;\n-  fields = f;\n+  fields = create_field_at (0, create_array (t, \"1\"), \"vec\", o, pos);\n+  fields = create_field_at (fields, len_ty, \"alloc\", 0, pos);\n+  fields = create_field_at (fields, len_ty, \"num\", 0, pos);\n \n   do_typedef (name, new_structure (name, 0, pos, fields, 0), pos);\n }\n@@ -3086,11 +3206,8 @@ note_def_vec_alloc (const char *type, const char *astrat, struct fileloc *pos)\n   const char *astratname = concat (\"VEC_\", type, \"_\", astrat, (char *)0);\n   const char *basename = concat (\"VEC_\", type, \"_base\", (char *)0);\n \n-  pair_p field = XNEW (struct pair);\n-  field->name = \"base\";\n-  field->type = adjust_field_type (resolve_typedef (basename, pos), 0);\n-  field->line = *pos;\n-  field->next = 0;\n+  pair_p field = create_field_at (0, resolve_typedef (basename, pos),\n+\t\t\t\t  \"base\", 0, pos);\n \n   do_typedef (astratname, new_structure (astratname, 0, pos, field, 0), pos);\n }\n@@ -3109,6 +3226,9 @@ main (int ARG_UNUSED (argc), char ** ARG_UNUSED (argv))\n   scalar_char.u.scalar_is_char = true;\n   scalar_nonchar.u.scalar_is_char = false;\n \n+  /* fatal uses this */\n+  progname = \"gengtype\";\n+\n   gen_rtx_next ();\n \n   do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos);\n@@ -3150,7 +3270,7 @@ main (int ARG_UNUSED (argc), char ** ARG_UNUSED (argv))\n     }\n \n   if (hit_error != 0)\n-    exit (1);\n+    return 1;\n \n   set_gc_used (variables);\n "}, {"sha": "345d80d9022c3cb942dda2259fc705063cbb8ec0", "filename": "gcc/gengtype.h", "status": "modified", "additions": 10, "deletions": 126, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065ae6117579cc9a089c238207b42f5a1470423a/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065ae6117579cc9a089c238207b42f5a1470423a/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=065ae6117579cc9a089c238207b42f5a1470423a", "patch": "@@ -18,99 +18,20 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n+#ifndef GCC_GENGTYPE_H\n+#define GCC_GENGTYPE_H\n+\n /* A file position, mostly for error messages.  \n    The FILE element may be compared using pointer equality.  */\n struct fileloc {\n   const char *file;\n   int line;\n };\n \n-/* Kinds of types we can understand.  */\n-enum typekind {\n-  TYPE_SCALAR,\n-  TYPE_STRING,\n-  TYPE_STRUCT,\n-  TYPE_UNION,\n-  TYPE_POINTER,\n-  TYPE_ARRAY,\n-  TYPE_LANG_STRUCT,\n-  TYPE_PARAM_STRUCT\n-};\n-\n+/* Data types handed around within, but opaque to, the lexer and parser.  */\n typedef struct pair *pair_p;\n typedef struct type *type_p;\n-typedef unsigned lang_bitmap;\n-\n-/* Option data for the 'nested_ptr' option.  */\n-struct nested_ptr_data {\n-  type_p type;\n-  const char *convert_to;\n-  const char *convert_from;\n-};    \n-\n-/* A way to pass data through to the output end.  */\n-typedef struct options {\n-  struct options *next;\n-  const char *name;\n-  const char *info;\n-} *options_p;\n-\n-/* A name and a type.  */\n-struct pair {\n-  pair_p next;\n-  const char *name;\n-  type_p type;\n-  struct fileloc line;\n-  options_p opt;\n-};\n-\n-#define NUM_PARAM 10\n-\n-/* A description of a type.  */\n-enum gc_used_enum\n-  {\n-    GC_UNUSED = 0,\n-    GC_USED,\n-    GC_MAYBE_POINTED_TO,\n-    GC_POINTED_TO\n-  };\n-\n-struct type {\n-  enum typekind kind;\n-  type_p next;\n-  type_p pointer_to;\n-  enum gc_used_enum gc_used;\n-  union {\n-    type_p p;\n-    struct {\n-      const char *tag;\n-      struct fileloc line;\n-      pair_p fields;\n-      options_p opt;\n-      lang_bitmap bitmap;\n-      type_p lang_struct;\n-    } s;\n-    bool scalar_is_char;\n-    struct {\n-      type_p p;\n-      const char *len;\n-    } a;\n-    struct {\n-      type_p stru;\n-      type_p param[NUM_PARAM];\n-      struct fileloc line;\n-    } param_struct;\n-  } u;\n-};\n-\n-#define UNION_P(x)\t\t\t\t\t\\\n- ((x)->kind == TYPE_UNION || \t\t\t\t\\\n-  ((x)->kind == TYPE_LANG_STRUCT \t\t\t\\\n-   && (x)->u.s.lang_struct->kind == TYPE_UNION))\n-#define UNION_OR_STRUCT_P(x)\t\t\t\\\n- ((x)->kind == TYPE_UNION \t\t\t\\\n-  || (x)->kind == TYPE_STRUCT \t\t\t\\\n-  || (x)->kind == TYPE_LANG_STRUCT)\n+typedef struct options *options_p;\n \n /* Variables used to communicate between the lexer and the parser.  */\n extern int lexer_toplevel_done;\n@@ -120,13 +41,6 @@ extern struct fileloc lexer_line;\n extern void error_at_line \n   (struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;\n \n-/* Combines xmalloc() and vasprintf().  */\n-extern int xvasprintf (char **, const char *, va_list)\n-     ATTRIBUTE_PRINTF (2, 0);\n-/* Like the above, but more convenient for quick coding.  */\n-extern char * xasprintf (const char *, ...)\n-     ATTRIBUTE_PRINTF_1;\n-\n /* Constructor routines for types.  */\n extern void do_typedef (const char *s, type_p t, struct fileloc *pos);\n extern void do_scalar_typedef (const char *s, struct fileloc *pos);\n@@ -139,8 +53,10 @@ extern type_p create_scalar_type (const char *name);\n extern type_p create_pointer (type_p t);\n extern type_p create_array (type_p t, const char *len);\n extern options_p create_option (options_p, const char *name, const void *info);\n-extern options_p create_nested_ptr_option (type_p t, const char *from,\n-\t\t\t\t\t   const char *to);\n+extern options_p create_nested_ptr_option (options_p, type_p t,\n+\t\t\t\t\t   const char *from, const char *to);\n+extern pair_p create_field_at (pair_p next, type_p type, const char *name,\n+\t\t\t       options_p opt, struct fileloc *pos);\n extern type_p adjust_field_type (type_p, options_p);\n extern void note_variable (const char *s, type_p t, options_p o,\n \t\t\t   struct fileloc *pos);\n@@ -155,36 +71,4 @@ extern void yyerror (const char *);\n extern int yyparse (void);\n extern void parse_file (const char *name);\n \n-/* Output file handling.  */\n-\n-/* Structure representing an output file.  */\n-struct outf \n-{\n-  struct outf *next;\n-  const char *name;\n-  size_t buflength;\n-  size_t bufused;\n-  char *buf;\n-};\n-\n-typedef struct outf * outf_p;\n-\n-/* An output file, suitable for definitions, that can see declarations\n-   made in INPUT_FILE and is linked into every language that uses\n-   INPUT_FILE.  */\n-extern outf_p get_output_file_with_visibility \n-   (const char *input_file);\n-const char *get_output_file_name (const char *);\n-\n-/* A list of output files suitable for definitions.  There is one\n-   BASE_FILES entry for each language.  */\n-extern outf_p base_files[];\n-\n-/* A bitmap that specifies which of BASE_FILES should be used to\n-   output a definition that is different for each language and must be\n-   defined once in each language that uses INPUT_FILE.  */\n-extern lang_bitmap get_base_file_bitmap (const char *input_file);\n-\n-/* Print, like fprintf, to O.  */\n-extern void oprintf (outf_p o, const char *S, ...)\n-     ATTRIBUTE_PRINTF_2;\n+#endif"}]}