{"sha": "f76b9db2874507ed287d1fe39ca2b1e89ae95207", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc2YjlkYjI4NzQ1MDdlZDI4N2QxZmUzOWNhMmIxZTg5YWU5NTIwNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1994-11-16T21:10:09Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1994-11-16T21:10:09Z"}, "message": "Check target endianness at run time, not compile time\n\nFrom-SVN: r8470", "tree": {"sha": "036743ae971e4dddc0469a67fd6d6272b0801af8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/036743ae971e4dddc0469a67fd6d6272b0801af8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f76b9db2874507ed287d1fe39ca2b1e89ae95207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f76b9db2874507ed287d1fe39ca2b1e89ae95207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f76b9db2874507ed287d1fe39ca2b1e89ae95207", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f76b9db2874507ed287d1fe39ca2b1e89ae95207/comments", "author": null, "committer": null, "parents": [{"sha": "1942e820686abbdd62515895e219476c26429945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1942e820686abbdd62515895e219476c26429945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1942e820686abbdd62515895e219476c26429945"}], "stats": {"total": 1875, "additions": 985, "deletions": 890}, "files": [{"sha": "d7a547d17cd2ec25a2e941ddc7d5a9dfc9642b52", "filename": "gcc/bi-run.h", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fbi-run.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fbi-run.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-run.h?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -124,30 +124,23 @@ struct bytecode\n    DEST offset by OFFSET bits. */\n \n \n-#if BYTES_BIG_ENDIAN\n-\n #define SHIFT_IN_BITS(DEST, SOURCE, OFFSET, NBITS)\t\t\\\n   (DEST = ((DEST) << (NBITS))\t\t\t\t\t\\\n    | (LM ((NBITS))\t\t\t\t\t\t\\\n-      & ((SOURCE) >> (INTERP_BPC - (OFFSET) - (NBITS)))))\n+      & ((SOURCE)\t\t\t\t\t\t\\\n+\t >> (BYTES_BIG_ENDIAN\t\t\t\t\t\\\n+\t     ? (INTERP_BPC - (OFFSET) - (NBITS))\t\t\\\n+\t     : (OFFSET)))))\n \n #define OR_IN_BITS(DEST, VALUE, OFFSET, NBITS)\t\t\t\\\n-  (DEST = ((DEST) & ~(LM ((NBITS)) << (INTERP_BPC - (OFFSET) - (NBITS))))\t\\\n-   | (((VALUE) & LM ((NBITS))) << (INTERP_BPC - (OFFSET) - (NBITS))))\n-\n-#else\n-\n-#define SHIFT_IN_BITS(DEST, SOURCE, OFFSET, NBITS)\t\t\\\n-  (DEST = ((DEST) << (NBITS))\t\t\t\t\t\\\n-   | (LM ((NBITS))\t\t\t\t\t\t\\\n-      & ((SOURCE) >> (OFFSET))))\n-\n-#define OR_IN_BITS(DEST, VALUE, OFFSET, NBITS)\t\t\t\\\n-  (DEST = ((DEST) & ~(LM ((NBITS)) << (OFFSET)))\t\t\\\n-   | (((VALUE) & LM ((NBITS))) << (OFFSET)))\n-\n-#endif\n-\n+  (DEST = ((DEST) & ~(LM ((NBITS))\t\t\t\t\\\n+\t\t      << (BIG_ENDIAN\t\t\t\t\\\n+\t\t\t  ? (INTERP_BPC - (OFFSET) - (NBITS))\t\\\n+\t\t\t  : (OFFSET)))\t\t\t\t\\\n+   | (((VALUE) & LM ((NBITS)))\t\t\t\t\t\\\n+      << (BIG_ENDIAN\t\t\t\t\t\t\\\n+\t  ? (INTERP_BPC - (OFFSET) - (NBITS))\t\t\t\\\n+\t  : (OFFSET)))))\n \n /* Procedure call; arguments are a pointer to the function to be called,\n    a pointer to a place to store the return value, a pointer to a vector"}, {"sha": "e2dc73a5fff08c3fa41b1a536fc0a9d6314981e7", "filename": "gcc/bytecode.h", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fbytecode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fbytecode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbytecode.h?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -24,28 +24,17 @@ extern int max_stack_depth;\n \n /* Emit DI constant according to target machine word ordering */\n \n-#if WORDS_BIG_ENDIAN\n-\n #define bc_emit_bytecode_DI_const(CST) \t\t\t\t\\\n { int opcode;\t\t\t\t\t\t\t\\\n-  opcode = TREE_INT_CST_HIGH (CST); \t\t\t\t\\\n+  opcode = (WORDS_BIG_ENDIAN\t\t\t\t\t\\\n+\t    ? TREE_INT_CST_HIGH (CST) \t\t\t\t\\\n+\t    : TREE_INT_CST_LOW (CST));\t\t\t\t\\\n   bc_emit_bytecode_const ((char *) &opcode, sizeof opcode); \t\\\n-  opcode = TREE_INT_CST_LOW (CST); \t\t\t\t\\\n+  opcode = (WORDS_BIG_ENDIAN\t\t\t\t\t\\\n+\t    ? TREE_INT_CST_LOW (CST) \t\t\t\t\\\n+\t    : TREE_INT_CST_HIGH (CST));\t\t\t\t\\\n   bc_emit_bytecode_const ((char *) &opcode, sizeof opcode);\t\\\n }\n-\t  \n-#else\n-\n-#define bc_emit_bytecode_DI_const(CST)\t \t\t\t\\\n-{ int opcode;\t\t\t\t\t\t\t\\\n-  opcode = TREE_INT_CST_LOW (CST); \t\t\t\t\\\n-  bc_emit_bytecode_const ((char *) &opcode, sizeof opcode); \t\\\n-  opcode = TREE_INT_CST_HIGH (CST); \t\t\t\t\\\n-  bc_emit_bytecode_const ((char *) &opcode, sizeof opcode);\t\\\n-}\n-\t  \n-#endif\n-\n \n extern void bc_expand_expr ();\n extern void bc_output_data_constructor ();"}, {"sha": "bc04c09874abff3f7b4269c88386291f9d9dc2a7", "filename": "gcc/combine.c", "status": "modified", "additions": 98, "deletions": 92, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -2508,9 +2508,8 @@ find_split_point (loc, insn)\n \t  enum machine_mode mode = GET_MODE (dest);\n \t  unsigned HOST_WIDE_INT mask = ((HOST_WIDE_INT) 1 << len) - 1;\n \n-#if BITS_BIG_ENDIAN\n-\t  pos = GET_MODE_BITSIZE (mode) - len - pos;\n-#endif\n+\t  if (BITS_BIG_ENDIAN)\n+\t    pos = GET_MODE_BITSIZE (mode) - len - pos;\n \n \t  if (src == mask)\n \t    SUBST (SET_SRC (x),\n@@ -2579,9 +2578,8 @@ find_split_point (loc, insn)\n \t      len = INTVAL (XEXP (SET_SRC (x), 1));\n \t      pos = INTVAL (XEXP (SET_SRC (x), 2));\n \n-#if BITS_BIG_ENDIAN\n-\t      pos = GET_MODE_BITSIZE (GET_MODE (inner)) - len - pos;\n-#endif\n+\t      if (BITS_BIG_ENDIAN)\n+\t\tpos = GET_MODE_BITSIZE (GET_MODE (inner)) - len - pos;\n \t      unsignedp = (code == ZERO_EXTRACT);\n \t    }\n \t  break;\n@@ -3165,12 +3163,14 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t      || mode_dependent_address_p (XEXP (inner, 0)))\n \t    return gen_rtx (CLOBBER, mode, const0_rtx);\n \n-#if BYTES_BIG_ENDIAN\n-\t  if (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n-\t    endian_offset += UNITS_PER_WORD - GET_MODE_SIZE (mode);\n-\t  if (GET_MODE_SIZE (GET_MODE (inner)) < UNITS_PER_WORD)\n-\t    endian_offset -= UNITS_PER_WORD - GET_MODE_SIZE (GET_MODE (inner));\n-#endif\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    {\n+\t      if (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+\t\tendian_offset += UNITS_PER_WORD - GET_MODE_SIZE (mode);\n+\t      if (GET_MODE_SIZE (GET_MODE (inner)) < UNITS_PER_WORD)\n+\t\tendian_offset -= (UNITS_PER_WORD\n+\t\t\t\t  - GET_MODE_SIZE (GET_MODE (inner)));\n+\t    }\n \t  /* Note if the plus_constant doesn't make a valid address\n \t     then this combination won't be accepted.  */\n \t  x = gen_rtx (MEM, mode,\n@@ -3246,10 +3246,8 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t only if the constant's mode fits in one word.  */\n       if (CONSTANT_P (SUBREG_REG (x)) && subreg_lowpart_p (x)\n \t  && GET_MODE_SIZE (mode) < GET_MODE_SIZE (op0_mode)\n-#if WORDS_BIG_ENDIAN\n-\t  && GET_MODE_BITSIZE (op0_mode) <= BITS_PER_WORD\n-#endif\n-\t  )\n+\t  && (! WORDS_BIG_ENDIAN\n+\t      || GET_MODE_BITSIZE (op0_mode) <= BITS_PER_WORD))\n \treturn gen_lowpart_for_combine (mode, SUBREG_REG (x));\n \n       /* A paradoxical SUBREG of a VOIDmode constant is the same constant,\n@@ -4777,9 +4775,9 @@ expand_compound_operation (x)\n       if (len + pos > GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))))\n \tSUBST (XEXP (x, 0), gen_rtx (USE, GET_MODE (x), XEXP (x, 0)));\n \n-#if BITS_BIG_ENDIAN\n-      pos = GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - len - pos;\n-#endif\n+      if (BITS_BIG_ENDIAN)\n+\tpos = GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - len - pos;\n+\n       break;\n \n     default:\n@@ -4871,22 +4869,23 @@ expand_field_assignment (x)\n \t      && INTVAL (pos) + len > GET_MODE_BITSIZE (GET_MODE (inner)))\n \t    inner = gen_rtx (USE, GET_MODE (SET_DEST (x)), inner);\n \n-#if BITS_BIG_ENDIAN\n-\t  if (GET_CODE (pos) == CONST_INT)\n-\t    pos = GEN_INT (GET_MODE_BITSIZE (GET_MODE (inner)) - len\n-\t\t\t   - INTVAL (pos));\n-\t  else if (GET_CODE (pos) == MINUS\n-\t\t   && GET_CODE (XEXP (pos, 1)) == CONST_INT\n-\t\t   && (INTVAL (XEXP (pos, 1))\n-\t\t       == GET_MODE_BITSIZE (GET_MODE (inner)) - len))\n-\t    /* If position is ADJUST - X, new position is X.  */\n-\t    pos = XEXP (pos, 0);\n-\t  else\n-\t    pos = gen_binary (MINUS, GET_MODE (pos),\n-\t\t\t      GEN_INT (GET_MODE_BITSIZE (GET_MODE (inner))\n-\t\t\t\t       - len),\n-\t\t\t      pos);\n-#endif\n+\t  if (BITS_BIG_ENDIAN)\n+\t    {\n+\t      if (GET_CODE (pos) == CONST_INT)\n+\t\tpos = GEN_INT (GET_MODE_BITSIZE (GET_MODE (inner)) - len\n+\t\t\t       - INTVAL (pos));\n+\t      else if (GET_CODE (pos) == MINUS\n+\t\t       && GET_CODE (XEXP (pos, 1)) == CONST_INT\n+\t\t       && (INTVAL (XEXP (pos, 1))\n+\t\t\t   == GET_MODE_BITSIZE (GET_MODE (inner)) - len))\n+\t\t/* If position is ADJUST - X, new position is X.  */\n+\t\tpos = XEXP (pos, 0);\n+\t      else\n+\t\tpos = gen_binary (MINUS, GET_MODE (pos),\n+\t\t\t\t  GEN_INT (GET_MODE_BITSIZE (GET_MODE (inner))\n+\t\t\t\t\t   - len),\n+\t\t\t\t  pos);\n+\t    }\n \t}\n \n       /* A SUBREG between two modes that occupy the same numbers of words\n@@ -5169,20 +5168,22 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n   orig_pos = pos;\n \n-#if BITS_BIG_ENDIAN\n-  /* If position is constant, compute new position.  Otherwise, build\n-     subtraction.  */\n-  if (pos_rtx == 0)\n-    pos = (MAX (GET_MODE_BITSIZE (is_mode), GET_MODE_BITSIZE (wanted_mem_mode))\n-\t   - len - pos);\n-  else\n-    pos_rtx\n-      = gen_rtx_combine (MINUS, GET_MODE (pos_rtx),\n-\t\t\t GEN_INT (MAX (GET_MODE_BITSIZE (is_mode),\n-\t\t\t\t       GET_MODE_BITSIZE (wanted_mem_mode))\n-\t\t\t\t  - len),\n-\t\t\t pos_rtx);\n-#endif\n+  if (BITS_BIG_ENDIAN)\n+    {\n+      /* If position is constant, compute new position.  Otherwise,\n+\t build subtraction.  */\n+      if (pos_rtx == 0)\n+\tpos = (MAX (GET_MODE_BITSIZE (is_mode),\n+\t\t    GET_MODE_BITSIZE (wanted_mem_mode))\n+\t       - len - pos);\n+      else\n+\tpos_rtx\n+\t  = gen_rtx_combine (MINUS, GET_MODE (pos_rtx),\n+\t\t\t     GEN_INT (MAX (GET_MODE_BITSIZE (is_mode),\n+\t\t\t\t\t   GET_MODE_BITSIZE (wanted_mem_mode))\n+\t\t\t\t      - len),\n+\t\t\t     pos_rtx);\n+    }\n \n   /* If INNER has a wider mode, make it smaller.  If this is a constant\n      extract, try to adjust the byte to point to the byte containing\n@@ -5202,11 +5203,10 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t     \n       /* If bytes are big endian and we had a paradoxical SUBREG, we must\n \t adjust OFFSET to compensate. */\n-#if BYTES_BIG_ENDIAN\n-      if (! spans_byte\n+      if (BYTES_BIG_ENDIAN\n+\t  && ! spans_byte\n \t  && GET_MODE_SIZE (inner_mode) < GET_MODE_SIZE (is_mode))\n \toffset -= GET_MODE_SIZE (is_mode) - GET_MODE_SIZE (inner_mode);\n-#endif\n \n       /* If this is a constant position, we can move to the desired byte.  */\n       if (pos_rtx == 0)\n@@ -5215,11 +5215,11 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t  pos %= GET_MODE_BITSIZE (wanted_mem_mode);\n \t}\n \n-#if BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN\n-      if (! spans_byte && is_mode != wanted_mem_mode)\n+      if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN\n+\t  && ! spans_byte\n+\t  && is_mode != wanted_mem_mode)\n \toffset = (GET_MODE_SIZE (is_mode)\n \t\t  - GET_MODE_SIZE (wanted_mem_mode) - offset);\n-#endif\n \n       if (offset != 0 || inner_mode != wanted_mem_mode)\n \t{\n@@ -5701,14 +5701,14 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t generating something that won't match. */\n       return x;\n \n-#if ! BITS_BIG_ENDIAN\n     case USE:\n       /* X is a (use (mem ..)) that was made from a bit-field extraction that\n \t spanned the boundary of the MEM.  If we are now masking so it is\n \t within that boundary, we don't need the USE any more.  */\n-      if ((mask & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n+      if (! BITS_BIG_ENDIAN\n+\t  && (mask & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n \treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n-#endif\n+      break;\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n@@ -7627,16 +7627,17 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t      && (tmode = mode_for_size (GET_MODE_BITSIZE (mode) - count,\n \t\t\t\t\t MODE_INT, 1)) != BLKmode)\n \t    {\n-#if BYTES_BIG_ENDIAN\n-\t      new = gen_rtx (MEM, tmode, XEXP (varop, 0));\n-#else\n-\t      new = gen_rtx (MEM, tmode,\n-\t\t\t     plus_constant (XEXP (varop, 0),\n-\t\t\t\t\t    count / BITS_PER_UNIT));\n-\t      RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (varop);\n-\t      MEM_VOLATILE_P (new) = MEM_VOLATILE_P (varop);\n-\t      MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (varop);\n-#endif\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\tnew = gen_rtx (MEM, tmode, XEXP (varop, 0));\n+\t      else\n+\t\t{\n+\t\t  new = gen_rtx (MEM, tmode,\n+\t\t\t\t plus_constant (XEXP (varop, 0),\n+\t\t\t\t\t\tcount / BITS_PER_UNIT));\n+\t\t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (varop);\n+\t\t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (varop);\n+\t\t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (varop);\n+\t\t}\n \t      varop = gen_rtx_combine (code == ASHIFTRT ? SIGN_EXTEND\n \t\t\t\t       : ZERO_EXTEND, mode, new);\n \t      count = 0;\n@@ -7654,14 +7655,15 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t\t\t\t\t MODE_INT, 1)) != BLKmode\n \t      && tmode == GET_MODE (XEXP (varop, 0)))\n \t    {\n-#if BITS_BIG_ENDIAN\n-\t      new = XEXP (varop, 0);\n-#else\n-\t      new = copy_rtx (XEXP (varop, 0));\n-\t      SUBST (XEXP (new, 0), \n-\t\t     plus_constant (XEXP (new, 0),\n-\t\t\t\t    count / BITS_PER_UNIT));\n-#endif\n+\t      if (BITS_BIG_ENDIAN)\n+\t\tnew = XEXP (varop, 0);\n+\t      else\n+\t\t{\n+\t\t  new = copy_rtx (XEXP (varop, 0));\n+\t\t  SUBST (XEXP (new, 0), \n+\t\t\t plus_constant (XEXP (new, 0),\n+\t\t\t\t\tcount / BITS_PER_UNIT));\n+\t\t}\n \n \t      varop = gen_rtx_combine (code == ASHIFTRT ? SIGN_EXTEND\n \t\t\t\t       : ZERO_EXTEND, mode, new);\n@@ -8327,16 +8329,16 @@ gen_lowpart_for_combine (mode, x)\n       if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode))\n \treturn gen_rtx (SUBREG, mode, x, 0);\n \n-#if WORDS_BIG_ENDIAN\n-      offset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n-\t\t- MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n-#endif\n-#if BYTES_BIG_ENDIAN\n-      /* Adjust the address so that the address-after-the-data\n-\t is unchanged.  */\n-      offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n-\t\t - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n-#endif\n+      if (WORDS_BIG_ENDIAN)\n+\toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n+\t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  /* Adjust the address so that the address-after-the-data is\n+\t     unchanged.  */\n+\t  offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n+\t\t     - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n+\t}\n       new = gen_rtx (MEM, mode, plus_constant (XEXP (x, 0), offset));\n       RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n       MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n@@ -8896,15 +8898,20 @@ simplify_comparison (code, pop0, pop1)\n \t     do this if bit endian and we don't have an extzv since we then\n \t     can't know what mode to use for the endianness adjustment.  */\n \n-#if ! BITS_BIG_ENDIAN || defined (HAVE_extzv)\n \t  if (GET_CODE (XEXP (op0, 0)) == CONST_INT\n \t      && XEXP (op0, 1) == const1_rtx\n \t      && equality_comparison_p && const_op == 0\n-\t      && (i = exact_log2 (INTVAL (XEXP (op0, 0)))) >= 0)\n+\t      && (i = exact_log2 (INTVAL (XEXP (op0, 0)))) >= 0\n+\t      && (! BITS_BIG_ENDIAN\n+#ifdef HAVE_extzv\n+\t\t  || HAVE_extzv\n+#endif\n+\t\t  ))\n \t    {\n-#if BITS_BIG_ENDIAN\n-\t      i = (GET_MODE_BITSIZE\n-\t\t   (insn_operand_mode[(int) CODE_FOR_extzv][1]) - 1 - i);\n+#ifdef HAVE_extzv\n+\t      if (BITS_BIG_ENDIAN)\n+\t\ti = (GET_MODE_BITSIZE\n+\t\t     (insn_operand_mode[(int) CODE_FOR_extzv][1]) - 1 - i);\n #endif\n \n \t      op0 = XEXP (op0, 2);\n@@ -8915,7 +8922,6 @@ simplify_comparison (code, pop0, pop1)\n \t      code = reverse_condition (code);\n \t      continue;\n \t    }\n-#endif\n \n \t  /* ... fall through ... */\n "}, {"sha": "103d369f280f2c6c32071b03be2f4c2584f1d0b9", "filename": "gcc/cse.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -4581,11 +4581,12 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n \t  /* Extracting a bit-field from a constant */\n \t  HOST_WIDE_INT val = INTVAL (op0);\n \n-#if BITS_BIG_ENDIAN\n-\t  val >>= (GET_MODE_BITSIZE (op0_mode) - INTVAL (op2) - INTVAL (op1));\n-#else\n-\t  val >>= INTVAL (op2);\n-#endif\n+\t  if (BITS_BIG_ENDIAN)\n+\t    val >>= (GET_MODE_BITSIZE (op0_mode)\n+\t\t     - INTVAL (op2) - INTVAL (op1));\n+\t  else\n+\t    val >>= INTVAL (op2);\n+\n \t  if (HOST_BITS_PER_WIDE_INT != INTVAL (op1))\n \t    {\n \t      /* First zero-extend.  */\n@@ -5625,16 +5626,14 @@ gen_lowpart_if_possible (mode, x)\n       register int offset = 0;\n       rtx new;\n \n-#if WORDS_BIG_ENDIAN\n-      offset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n-\t\t- MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n-#endif\n-#if BYTES_BIG_ENDIAN\n-      /* Adjust the address so that the address-after-the-data\n-\t is unchanged.  */\n-      offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n-\t\t - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n-#endif\n+      if (WORDS_BIG_ENDIAN)\n+\toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n+\t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n+      if (BYTES_BIG_ENDIAN)\n+\t/* Adjust the address so that the address-after-the-data is\n+\t   unchanged.  */\n+\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n+\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n       new = gen_rtx (MEM, mode, plus_constant (XEXP (x, 0), offset));\n       if (! memory_address_p (mode, XEXP (new, 0)))\n \treturn 0;"}, {"sha": "ddddd40ebbc58464520d40ca6785b907d58c291c", "filename": "gcc/dbxout.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -2136,11 +2136,10 @@ dbxout_parms (parms)\n \t\t   with the variable's declared type, and adjust the address\n \t\t   if the least significant bytes (which we are using) are not\n \t\t   the first ones.  */\n-#if BYTES_BIG_ENDIAN\n-\t\tif (TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n+\t\tif (BYTES_BIG_ENDIAN\n+\t\t    && TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n \t\t  current_sym_value += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n \t\t\t\t\t- GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n-#endif\n \n \t\tif (GET_CODE (DECL_RTL (parms)) == MEM\n \t\t    && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n@@ -2348,11 +2347,11 @@ dbxout_reg_parms (parms)\n \t    /* A parm declared char is really passed as an int,\n \t       so it occupies the least significant bytes.\n \t       On a big-endian machine those are not the low-numbered ones.  */\n-#if BYTES_BIG_ENDIAN\n-\t    if (offset != -1 && TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n+\t    if (BYTES_BIG_ENDIAN\n+\t\t&& offset != -1\n+\t\t&& TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n \t      offset += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n \t\t\t - GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n-#endif\n \t    if (INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) != offset) {...}\n #endif\n \t    dbxout_symbol_location (parms, TREE_TYPE (parms),"}, {"sha": "4287e106a09054f3cbe27c6200f64453aaf3735a", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -2204,12 +2204,10 @@ location_or_const_value_attribute (decl)\n \n \tif (declared_type == passed_type)\n \t  rtl = DECL_INCOMING_RTL (decl);\n-#if (BYTES_BIG_ENDIAN == 0)\n-\telse\n+\telse if (! BYTES_BIG_ENDIAN)\n \t  if (TREE_CODE (declared_type) == INTEGER_TYPE)\n \t    if (TYPE_SIZE (declared_type) <= TYPE_SIZE (passed_type))\n \t      rtl = DECL_INCOMING_RTL (decl);\n-#endif /* (BYTES_BIG_ENDIAN == 0) */\n       }\n \n   if (rtl == NULL_RTX)\n@@ -2519,19 +2517,18 @@ bit_offset_attribute (decl)\n   highest_order_object_bit_offset = object_offset_in_bytes * BITS_PER_UNIT;\n   highest_order_field_bit_offset = bitpos_int;\n \n-#if (BYTES_BIG_ENDIAN == 0)\n-  highest_order_field_bit_offset\n-    += (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl));\n+  if (! BYTES_BIG_ENDIAN)\n+    {\n+      highest_order_field_bit_offset\n+\t+= (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl));\n \n-  highest_order_object_bit_offset += simple_type_size_in_bits (type);\n-#endif /* (BYTES_BIG_ENDIAN == 0) */\n+      highest_order_object_bit_offset += simple_type_size_in_bits (type);\n+    }\n \n   bit_offset =\n-#if (BYTES_BIG_ENDIAN == 0)\n-\t  highest_order_object_bit_offset - highest_order_field_bit_offset;\n-#else /* (BYTES_BIG_ENDIAN != 0) */\n-\t  highest_order_field_bit_offset - highest_order_object_bit_offset;\n-#endif /* (BYTES_BIG_ENDIAN != 0) */\n+    (! BYTES_BIG_ENDIAN\n+     ? highest_order_object_bit_offset - highest_order_field_bit_offset\n+     : highest_order_field_bit_offset - highest_order_object_bit_offset);\n \n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_bit_offset);\n   ASM_OUTPUT_DWARF_DATA2 (asm_out_file, bit_offset);"}, {"sha": "4db9d058611bd9a0d6bda1b4a485fa6e1a719373", "filename": "gcc/expmed.c", "status": "modified", "additions": 75, "deletions": 77, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -221,13 +221,13 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       op0 = SUBREG_REG (op0);\n     }\n \n-#if BYTES_BIG_ENDIAN\n   /* If OP0 is a register, BITPOS must count within a word.\n      But as we have it, it counts within whatever size OP0 now has.\n      On a bigendian machine, these are not the same, so convert.  */\n-  if (GET_CODE (op0) != MEM && unit > GET_MODE_BITSIZE (GET_MODE (op0)))\n+  if (BYTES_BIG_ENDIAN\n+      && GET_CODE (op0) != MEM\n+      && unit > GET_MODE_BITSIZE (GET_MODE (op0)))\n     bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n-#endif\n \n   value = protect_from_queue (value, 0);\n \n@@ -261,11 +261,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n      can be done with a movestrict instruction.  */\n \n   if (GET_CODE (op0) != MEM\n-#if BYTES_BIG_ENDIAN\n-      && bitpos + bitsize == unit\n-#else\n-      && bitpos == 0\n-#endif\n+      && (BYTES_BIG_ENDIAN ? bitpos + bitsize == unit : bitpos == 0)\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n       && (GET_MODE (op0) == fieldmode\n \t  || (movstrict_optab->handlers[(int) fieldmode].insn_code\n@@ -450,15 +446,14 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       /* On big-endian machines, we count bits from the most significant.\n \t If the bit field insn does not, we must invert.  */\n \n-#if BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN\n-      xbitpos = unit - bitsize - xbitpos;\n-#endif\n+      if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+\txbitpos = unit - bitsize - xbitpos;\n+\n       /* We have been counting XBITPOS within UNIT.\n \t Count instead within the size of the register.  */\n-#if BITS_BIG_ENDIAN\n-      if (GET_CODE (xop0) != MEM)\n+      if (BITS_BIG_ENDIAN && GET_CODE (xop0) != MEM)\n \txbitpos += GET_MODE_BITSIZE (maxmode) - unit;\n-#endif\n+\n       unit = GET_MODE_BITSIZE (maxmode);\n \n       /* Convert VALUE to maxmode (which insv insn wants) in VALUE1.  */\n@@ -606,13 +601,12 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n      BITPOS is the starting bit number within OP0.\n      (OP0's mode may actually be narrower than MODE.)  */\n \n-#if BYTES_BIG_ENDIAN\n-  /* BITPOS is the distance between our msb\n-     and that of the containing datum.\n-     Convert it to the distance from the lsb.  */\n+  if (BYTES_BIG_ENDIAN)\n+      /* BITPOS is the distance between our msb\n+\t and that of the containing datum.\n+\t Convert it to the distance from the lsb.  */\n+      bitpos = total_bits - bitsize - bitpos;\n \n-  bitpos = total_bits - bitsize - bitpos;\n-#endif\n   /* Now BITPOS is always the distance between our lsb\n      and that of OP0.  */\n \n@@ -740,29 +734,33 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n       thissize = MIN (bitsize - bitsdone, BITS_PER_WORD);\n       thissize = MIN (thissize, unit - thispos);\n \n-#if BYTES_BIG_ENDIAN\n-      /* Fetch successively less significant portions.  */\n-      if (GET_CODE (value) == CONST_INT)\n-\tpart = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n-\t\t\t >> (bitsize - bitsdone - thissize))\n-\t\t\t& (((HOST_WIDE_INT) 1 << thissize) - 1));\n-      else\n-\t/* The args are chosen so that the last part includes the lsb.\n-\t   Give extract_bit_field the value it needs (with endianness\n-\t   compensation) to fetch the piece we want.  */\n-\tpart = extract_fixed_bit_field (word_mode, value, 0, thissize,\n-\t\t\t\t\tGET_MODE_BITSIZE (GET_MODE (value))\n-\t\t\t\t\t- bitsize + bitsdone,\n-\t\t\t\t\tNULL_RTX, 1, align);\n-#else\n-      /* Fetch successively more significant portions.  */\n-      if (GET_CODE (value) == CONST_INT)\n-\tpart = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value)) >> bitsdone)\n-\t\t\t& (((HOST_WIDE_INT) 1 << thissize) - 1));\n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  /* Fetch successively less significant portions.  */\n+\t  if (GET_CODE (value) == CONST_INT)\n+\t    part = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n+\t\t\t     >> (bitsize - bitsdone - thissize))\n+\t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n+\t  else\n+\t    /* The args are chosen so that the last part includes the\n+\t       lsb.  Give extract_bit_field the value it needs (with\n+\t       endianness compensation) to fetch the piece we want.  */\n+\t    part = extract_fixed_bit_field (word_mode, value, 0, thissize,\n+\t\t\t\t\t    GET_MODE_BITSIZE (GET_MODE (value))\n+\t\t\t\t\t    - bitsize + bitsdone,\n+\t\t\t\t\t    NULL_RTX, 1, align);\n+\t}\n       else\n-\tpart = extract_fixed_bit_field (word_mode, value, 0, thissize,\n-\t\t\t\t\tbitsdone, NULL_RTX, 1, align);\n-#endif\n+\t{\n+\t  /* Fetch successively more significant portions.  */\n+\t  if (GET_CODE (value) == CONST_INT)\n+\t    part = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n+\t\t\t     >> bitsdone)\n+\t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n+\t  else\n+\t    part = extract_fixed_bit_field (word_mode, value, 0, thissize,\n+\t\t\t\t\t    bitsdone, NULL_RTX, 1, align);\n+\t}\n \n       /* If OP0 is a register, then handle OFFSET here.\n \n@@ -850,13 +848,13 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n       op0 = SUBREG_REG (op0);\n     }\n   \n-#if BYTES_BIG_ENDIAN\n   /* If OP0 is a register, BITPOS must count within a word.\n      But as we have it, it counts within whatever size OP0 now has.\n      On a bigendian machine, these are not the same, so convert.  */\n-  if (GET_CODE (op0) != MEM && unit > GET_MODE_BITSIZE (GET_MODE (op0)))\n+  if (BYTES_BIG_ENDIAN &&\n+      GET_CODE (op0) != MEM\n+      && unit > GET_MODE_BITSIZE (GET_MODE (op0)))\n     bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n-#endif\n \n   /* Extracting a full-word or multi-word value\n      from a structure in a register or aligned memory.\n@@ -872,12 +870,9 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n       && ((bitsize >= BITS_PER_WORD && bitsize == GET_MODE_BITSIZE (mode)\n \t   && bitpos % BITS_PER_WORD == 0)\n \t  || (mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0) != BLKmode\n-#if BYTES_BIG_ENDIAN\n-\t      && bitpos + bitsize == BITS_PER_WORD\n-#else\n-\t      && bitpos == 0\n-#endif\n-\t      )))\n+\t      && (BYTES_BIG_ENDIAN\n+\t\t  ? bitpos + bitsize == BITS_PER_WORD\n+\t\t  : bitpos == 0))))\n     {\n       enum machine_mode mode1\n \t= mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0);\n@@ -1050,14 +1045,13 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n \t  /* On big-endian machines, we count bits from the most significant.\n \t     If the bit field insn does not, we must invert.  */\n-#if BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN\n-\t  xbitpos = unit - bitsize - xbitpos;\n-#endif\n+\t  if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+\t    xbitpos = unit - bitsize - xbitpos;\n+\n \t  /* Now convert from counting within UNIT to counting in MAXMODE.  */\n-#if BITS_BIG_ENDIAN\n-\t  if (GET_CODE (xop0) != MEM)\n+\t  if (BITS_BIG_ENDIAN && GET_CODE (xop0) != MEM)\n \t    xbitpos += GET_MODE_BITSIZE (maxmode) - unit;\n-#endif\n+\n \t  unit = GET_MODE_BITSIZE (maxmode);\n \n \t  if (xtarget == 0\n@@ -1185,15 +1179,14 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n \t  /* On big-endian machines, we count bits from the most significant.\n \t     If the bit field insn does not, we must invert.  */\n-#if BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN\n-\t  xbitpos = unit - bitsize - xbitpos;\n-#endif\n+\t  if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+\t    xbitpos = unit - bitsize - xbitpos;\n+\n \t  /* XBITPOS counts within a size of UNIT.\n \t     Adjust to count within a size of MAXMODE.  */\n-#if BITS_BIG_ENDIAN\n-\t  if (GET_CODE (xop0) != MEM)\n+\t  if (BITS_BIG_ENDIAN && GET_CODE (xop0) != MEM)\n \t    xbitpos += (GET_MODE_BITSIZE (maxmode) - unit);\n-#endif\n+\n \t  unit = GET_MODE_BITSIZE (maxmode);\n \n \t  if (xtarget == 0\n@@ -1347,12 +1340,14 @@ extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n \n   mode = GET_MODE (op0);\n \n-#if BYTES_BIG_ENDIAN\n-  /* BITPOS is the distance between our msb and that of OP0.\n-     Convert it to the distance from the lsb.  */\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      /* BITPOS is the distance between our msb and that of OP0.\n+\t Convert it to the distance from the lsb.  */\n+\n+      bitpos = total_bits - bitsize - bitpos;\n+    }\n \n-  bitpos = total_bits - bitsize - bitpos;\n-#endif\n   /* Now BITPOS is always the distance between the field's lsb and that of OP0.\n      We have reduced the big-endian case to the little-endian case.  */\n \n@@ -1570,15 +1565,18 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n       bitsdone += thissize;\n \n       /* Shift this part into place for the result.  */\n-#if BYTES_BIG_ENDIAN\n-      if (bitsize != bitsdone)\n-\tpart = expand_shift (LSHIFT_EXPR, word_mode, part,\n-\t\t\t     build_int_2 (bitsize - bitsdone, 0), 0, 1);\n-#else\n-      if (bitsdone != thissize)\n-\tpart = expand_shift (LSHIFT_EXPR, word_mode, part,\n-\t\t\t     build_int_2 (bitsdone - thissize, 0), 0, 1);\n-#endif\n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  if (bitsize != bitsdone)\n+\t    part = expand_shift (LSHIFT_EXPR, word_mode, part,\n+\t\t\t\t build_int_2 (bitsize - bitsdone, 0), 0, 1);\n+\t}\n+      else\n+\t{\n+\t  if (bitsdone != thissize)\n+\t    part = expand_shift (LSHIFT_EXPR, word_mode, part,\n+\t\t\t\t build_int_2 (bitsdone - thissize, 0), 0, 1);\n+\t}\n \n       if (first)\n \tresult = part;"}, {"sha": "757ee63b853085990e9102658dff2d5b92738a9e", "filename": "gcc/expr.h", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -176,16 +176,14 @@ struct args_size\n enum direction {none, upward, downward};  /* Value has this type.  */\n \n #ifndef FUNCTION_ARG_PADDING\n-#if BYTES_BIG_ENDIAN\n #define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n-  (((MODE) == BLKmode\t\t\t\t\t\t\t\\\n-    ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n-       && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT))\t\\\n-    : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\t\\\n-   ? downward : upward)\n-#else\n-#define FUNCTION_ARG_PADDING(MODE, TYPE) upward\n-#endif\n+  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n+   ? upward\t\t\t\t\t\t\t\t\\\n+   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n+       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n+\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT)) \\\n+       : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\\\n+      ? downward : upward))\n #endif\n \n /* Supply a default definition for FUNCTION_ARG_BOUNDARY.  Normally, we let\n@@ -212,12 +210,6 @@ enum direction {none, upward, downward};  /* Value has this type.  */\n    So a value padded in memory at the upper end can't go in a register.\n    For a little-endian machine, the reverse is true.  */\n \n-#if BYTES_BIG_ENDIAN\n-#define MUST_PASS_IN_STACK_BAD_PADDING\tupward\n-#else\n-#define MUST_PASS_IN_STACK_BAD_PADDING\tdownward\n-#endif\n-\n #define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n   ((TYPE) != 0\t\t\t\t\t\t\\\n    && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n@@ -227,7 +219,7 @@ enum direction {none, upward, downward};  /* Value has this type.  */\n \t\t && 0 == (int_size_in_bytes (TYPE)\t\\\n \t\t\t  % (PARM_BOUNDARY / BITS_PER_UNIT))) \\\n \t   && (FUNCTION_ARG_PADDING (MODE, TYPE)\t\\\n-\t       == MUST_PASS_IN_STACK_BAD_PADDING))))\n+\t       == (BYTES_BIG_ENDIAN ? upward : downward)))))\n \n /* Nonzero if type TYPE should be returned in memory.\n    Most machines can use the following default definition.  */"}, {"sha": "b046d7853d3afd6c9805935a22a7a67664d1269e", "filename": "gcc/final.c", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -2077,10 +2077,9 @@ alter_subreg (x)\n   else if (GET_CODE (y) == MEM)\n     {\n       register int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n-#if BYTES_BIG_ENDIAN\n-      offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x)))\n-\t\t - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (y))));\n-#endif\n+      if (BYTES_BIG_ENDIAN)\n+\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x)))\n+\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (y))));\n       PUT_CODE (x, MEM);\n       MEM_VOLATILE_P (x) = MEM_VOLATILE_P (y);\n       XEXP (x, 0) = plus_constant (XEXP (y, 0), offset);\n@@ -2839,37 +2838,46 @@ split_double (value, first, second)\n \t is that we regard the value as signed.\n \t So sign-extend it.  */\n       rtx high = (INTVAL (value) < 0 ? constm1_rtx : const0_rtx);\n-#if WORDS_BIG_ENDIAN\n-      *first = high;\n-      *second = value;\n-#else\n-      *first = value;\n-      *second = high;\n-#endif\n+      if (WORDS_BIG_ENDIAN)\n+\t{\n+\t  *first = high;\n+\t  *second = value;\n+\t}\n+      else\n+\t{\n+\t  *first = value;\n+\t  *second = high;\n+\t}\n     }\n   else if (GET_CODE (value) != CONST_DOUBLE)\n     {\n-#if WORDS_BIG_ENDIAN\n-      *first = const0_rtx;\n-      *second = value;\n-#else\n-      *first = value;\n-      *second = const0_rtx;\n-#endif\n+      if (WORDS_BIG_ENDIAN)\n+\t{\n+\t  *first = const0_rtx;\n+\t  *second = value;\n+\t}\n+      else\n+\t{\n+\t  *first = value;\n+\t  *second = const0_rtx;\n+\t}\n     }\n   else if (GET_MODE (value) == VOIDmode\n \t   /* This is the old way we did CONST_DOUBLE integers.  */\n \t   || GET_MODE_CLASS (GET_MODE (value)) == MODE_INT)\n     {\n       /* In an integer, the words are defined as most and least significant.\n \t So order them by the target's convention.  */\n-#if WORDS_BIG_ENDIAN\n-      *first = GEN_INT (CONST_DOUBLE_HIGH (value));\n-      *second = GEN_INT (CONST_DOUBLE_LOW (value));\n-#else\n-      *first = GEN_INT (CONST_DOUBLE_LOW (value));\n-      *second = GEN_INT (CONST_DOUBLE_HIGH (value));\n-#endif\n+      if (WORDS_BIG_ENDIAN)\n+\t{\n+\t  *first = GEN_INT (CONST_DOUBLE_HIGH (value));\n+\t  *second = GEN_INT (CONST_DOUBLE_LOW (value));\n+\t}\n+      else\n+\t{\n+\t  *first = GEN_INT (CONST_DOUBLE_LOW (value));\n+\t  *second = GEN_INT (CONST_DOUBLE_HIGH (value));\n+\t}\n     }\n   else\n     {\n@@ -2891,14 +2899,23 @@ split_double (value, first, second)\n \t  && ! flag_pretend_float)\n       abort ();\n \n-#if defined (HOST_WORDS_BIG_ENDIAN) == WORDS_BIG_ENDIAN\n-      /* Host and target agree => no need to swap.  */\n-      *first = GEN_INT (CONST_DOUBLE_LOW (value));\n-      *second = GEN_INT (CONST_DOUBLE_HIGH (value));\n+      if (\n+#ifdef HOST_WORDS_BIG_ENDIAN\n+\t  WORDS_BIG_ENDIAN\n #else\n-      *second = GEN_INT (CONST_DOUBLE_LOW (value));\n-      *first = GEN_INT (CONST_DOUBLE_HIGH (value));\n+\t  ! WORDS_BIG_ENDIAN\n #endif\n+\t  )\n+\t{\n+\t  /* Host and target agree => no need to swap.  */\n+\t  *first = GEN_INT (CONST_DOUBLE_LOW (value));\n+\t  *second = GEN_INT (CONST_DOUBLE_HIGH (value));\n+\t}\n+      else\n+\t{\n+\t  *second = GEN_INT (CONST_DOUBLE_LOW (value));\n+\t  *first = GEN_INT (CONST_DOUBLE_HIGH (value));\n+\t}\n #endif /* no REAL_ARITHMETIC */\n     }\n }"}, {"sha": "d286f278bd390f1e0ba755e87ebdae28ba5991aa", "filename": "gcc/fold-const.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -2267,9 +2267,8 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n \treturn 0;\n     }\n \n-#if BYTES_BIG_ENDIAN\n-  lbitpos = lnbitsize - lbitsize - lbitpos;\n-#endif\n+  if (BYTES_BIG_ENDIAN)\n+    lbitpos = lnbitsize - lbitsize - lbitpos;\n \n   /* Make the mask to be used against the extracted field.  */\n   mask = build_int_2 (~0, ~0);\n@@ -2818,10 +2817,11 @@ fold_truthop (code, truth_type, lhs, rhs)\n   type = type_for_size (lnbitsize, 1);\n   xll_bitpos = ll_bitpos - lnbitpos, xrl_bitpos = rl_bitpos - lnbitpos;\n \n-#if BYTES_BIG_ENDIAN\n-  xll_bitpos = lnbitsize - xll_bitpos - ll_bitsize;\n-  xrl_bitpos = lnbitsize - xrl_bitpos - rl_bitsize;\n-#endif\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      xll_bitpos = lnbitsize - xll_bitpos - ll_bitsize;\n+      xrl_bitpos = lnbitsize - xrl_bitpos - rl_bitsize;\n+    }\n \n   ll_mask = const_binop (LSHIFT_EXPR, convert (type, ll_mask),\n \t\t\t size_int (xll_bitpos), 0);\n@@ -2870,10 +2870,11 @@ fold_truthop (code, truth_type, lhs, rhs)\n       rnbitpos = first_bit & ~ (rnbitsize - 1);\n       xlr_bitpos = lr_bitpos - rnbitpos, xrr_bitpos = rr_bitpos - rnbitpos;\n \n-#if BYTES_BIG_ENDIAN\n-      xlr_bitpos = rnbitsize - xlr_bitpos - lr_bitsize;\n-      xrr_bitpos = rnbitsize - xrr_bitpos - rr_bitsize;\n-#endif\n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  xlr_bitpos = rnbitsize - xlr_bitpos - lr_bitsize;\n+\t  xrr_bitpos = rnbitsize - xrr_bitpos - rr_bitsize;\n+\t}\n \n       lr_mask = const_binop (LSHIFT_EXPR, convert (type, lr_mask),\n \t\t\t     size_int (xlr_bitpos), 0);"}, {"sha": "3811835b028552bb0b5fc22fc8374e67aa88a720", "filename": "gcc/function.c", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -682,10 +682,8 @@ assign_stack_local (mode, size, align)\n \n   /* On a big-endian machine, if we are allocating more space than we will use,\n      use the least significant bytes of those that are allocated.  */\n-#if BYTES_BIG_ENDIAN\n-  if (mode != BLKmode)\n+  if (BYTES_BIG_ENDIAN && mode != BLKmode)\n     bigend_correction = size - GET_MODE_SIZE (mode);\n-#endif\n \n #ifdef FRAME_GROWS_DOWNWARD\n   frame_offset -= size;\n@@ -755,10 +753,8 @@ assign_outer_stack_local (mode, size, align, function)\n \n   /* On a big-endian machine, if we are allocating more space than we will use,\n      use the least significant bytes of those that are allocated.  */\n-#if BYTES_BIG_ENDIAN\n-  if (mode != BLKmode)\n+  if (BYTES_BIG_ENDIAN && mode != BLKmode)\n     bigend_correction = size - GET_MODE_SIZE (mode);\n-#endif\n \n #ifdef FRAME_GROWS_DOWNWARD\n   function->frame_offset -= size;\n@@ -1703,10 +1699,9 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \n \t\t  /* If the bytes and bits are counted differently, we\n \t\t     must adjust the offset.  */\n-#if BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN\n-\t\t  offset = (GET_MODE_SIZE (is_mode)\n-\t\t\t    - GET_MODE_SIZE (wanted_mode) - offset);\n-#endif\n+\t\t  if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN)\n+\t\t    offset = (GET_MODE_SIZE (is_mode)\n+\t\t\t      - GET_MODE_SIZE (wanted_mode) - offset);\n \n \t\t  pos %= GET_MODE_BITSIZE (wanted_mode);\n \n@@ -1876,10 +1871,9 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\t    rtx old_pos = XEXP (outerdest, 2);\n \t\t    rtx newmem;\n \n-#if BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN\n-\t\t    offset = (GET_MODE_SIZE (is_mode)\n-\t\t\t      - GET_MODE_SIZE (wanted_mode) - offset);\n-#endif\n+\t\t    if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN)\n+\t\t      offset = (GET_MODE_SIZE (is_mode)\n+\t\t\t\t- GET_MODE_SIZE (wanted_mode) - offset);\n \n \t\t    pos %= GET_MODE_BITSIZE (wanted_mode);\n \n@@ -2088,10 +2082,9 @@ fixup_memory_subreg (x, insn, uncritical)\n       && ! uncritical)\n     abort ();\n \n-#if BYTES_BIG_ENDIAN\n-  offset += (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t     - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n-#endif\n+  if (BYTES_BIG_ENDIAN)\n+    offset += (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\t       - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n   addr = plus_constant (addr, offset);\n   if (!flag_force_addr && memory_address_p (mode, addr))\n     /* Shortcut if no insns need be emitted.  */\n@@ -2271,21 +2264,20 @@ optimize_bit_field (body, insn, equiv_mem)\n \t  rtx insns;\n \n \t  /* Adjust OFFSET to count bits from low-address byte.  */\n-#if BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN\n-\t  offset = (GET_MODE_BITSIZE (GET_MODE (XEXP (bitfield, 0)))\n-\t\t    - offset - INTVAL (XEXP (bitfield, 1)));\n-#endif\n+\t  if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+\t    offset = (GET_MODE_BITSIZE (GET_MODE (XEXP (bitfield, 0)))\n+\t\t      - offset - INTVAL (XEXP (bitfield, 1)));\n+\n \t  /* Adjust OFFSET to count bytes from low-address byte.  */\n \t  offset /= BITS_PER_UNIT;\n \t  if (GET_CODE (XEXP (bitfield, 0)) == SUBREG)\n \t    {\n \t      offset += SUBREG_WORD (XEXP (bitfield, 0)) * UNITS_PER_WORD;\n-#if BYTES_BIG_ENDIAN\n-\t      offset -= (MIN (UNITS_PER_WORD,\n-\t\t\t      GET_MODE_SIZE (GET_MODE (XEXP (bitfield, 0))))\n-\t\t\t - MIN (UNITS_PER_WORD,\n-\t\t\t\tGET_MODE_SIZE (GET_MODE (memref))));\n-#endif\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\toffset -= (MIN (UNITS_PER_WORD,\n+\t\t\t\tGET_MODE_SIZE (GET_MODE (XEXP (bitfield, 0))))\n+\t\t\t   - MIN (UNITS_PER_WORD,\n+\t\t\t\t  GET_MODE_SIZE (GET_MODE (memref))));\n \t    }\n \n \t  start_sequence ();\n@@ -3454,11 +3446,10 @@ assign_parms (fndecl, second_time)\n \t{\n \t  rtx offset_rtx;\n \n-#if BYTES_BIG_ENDIAN\n-\t  if (GET_MODE_SIZE (nominal_mode) < UNITS_PER_WORD)\n+\t  if (BYTES_BIG_ENDIAN\n+\t      && GET_MODE_SIZE (nominal_mode) < UNITS_PER_WORD)\n \t    stack_offset.constant += (GET_MODE_SIZE (passed_mode)\n \t\t\t\t      - GET_MODE_SIZE (nominal_mode));\n-#endif\n \n \t  offset_rtx = ARGS_SIZE_RTX (stack_offset);\n \t  if (offset_rtx == const0_rtx)"}, {"sha": "ee3f01770671cf9333890cb708b37a9cb2ded7a5", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -516,17 +516,16 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\tif (i < 0)\n \t\t  delete_insn (insn);\n \t      }\n-#if !BYTES_BIG_ENDIAN /* Not worth the hair to detect this\n-\t\t\t in the big-endian case.  */\n \t    /* Also delete insns to store bit fields if they are no-ops.  */\n-\t    else if (GET_CODE (body) == SET\n+\t    /* Not worth the hair to detect this in the big-endian case.  */\n+\t    else if (! BYTES_BIG_ENDIAN\n+\t\t     && GET_CODE (body) == SET\n \t\t     && GET_CODE (SET_DEST (body)) == ZERO_EXTRACT\n \t\t     && XEXP (SET_DEST (body), 2) == const0_rtx\n \t\t     && XEXP (SET_DEST (body), 0) == SET_SRC (body)\n \t\t     && ! (GET_CODE (SET_SRC (body)) == MEM\n \t\t\t   && MEM_VOLATILE_P (SET_SRC (body))))\n \t      delete_insn (insn);\n-#endif /* not BYTES_BIG_ENDIAN */\n \t  }\n       insn = next;\n     }"}, {"sha": "247b8350d422b4fd44f99da9b24ab5f39c839491", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -40,6 +40,14 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #undef abort\n #endif\n \n+/* Permit the tm.h file to select the endianness to use just for this\n+   file.  This is used when the endianness is determined when the\n+   compiler is run.  */\n+\n+#ifndef LIBGCC2_WORDS_BIG_ENDIAN\n+#define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n+#endif\n+\n /* In the first part of this file, we are interfacing to calls generated\n    by the compiler itself.  These calls pass values into these routines\n    which have very specific modes (rather than very specific types), and\n@@ -90,9 +98,9 @@ typedef int word_type __attribute__ ((mode (DI)));\n #define SI_TYPE_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n \n /* DIstructs are pairs of SItype values in the order determined by\n-   WORDS_BIG_ENDIAN.  */\n+   LIBGCC2_WORDS_BIG_ENDIAN.  */\n \n-#if WORDS_BIG_ENDIAN\n+#if LIBGCC2_WORDS_BIG_ENDIAN\n   struct DIstruct {SItype high, low;};\n #else\n   struct DIstruct {SItype low, high;};"}, {"sha": "126923717e651042c9389650a4647ccdb6e2a5ff", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -1159,7 +1159,7 @@ static efdr_t init_file =\n     langC,\t\t/* lang:\tlanguage for this file */\n     1,\t\t\t/* fMerge:\twhether this file can be merged */\n     0,\t\t\t/* fReadin:\ttrue if read in (not just created) */\n-#if BYTES_BIG_ENDIAN\n+#ifdef HOST_WORDS_BIG_ENDIAN\n     1,\t\t\t/* fBigendian:\tif 1, compiled on big endian machine */\n #else\n     0,\t\t\t/* fBigendian:\tif 1, compiled on big endian machine */"}, {"sha": "937384d615ac2051810e0b1250ed192d1e1d0145", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -2462,11 +2462,9 @@ forwarding_offset (parm)\n       with the variable's declared type, and adjust the address\n       if the least significant bytes (which we are using) are not\n       the first ones.  */\n-#if BYTES_BIG_ENDIAN\n-  if (TREE_TYPE (parm) != DECL_ARG_TYPE (parm))\n+  if (BYTES_BIG_ENDIAN && TREE_TYPE (parm) != DECL_ARG_TYPE (parm))\n     offset_in_bytes += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parm)))\n \t\t\t- GET_MODE_SIZE (GET_MODE (DECL_RTL (parm))));\n-#endif\n \n   return offset_in_bytes;\n }"}, {"sha": "484d84cd55226f3351b6726f13aa4985de84a928", "filename": "gcc/real.c", "status": "modified", "additions": 530, "deletions": 425, "changes": 955, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -58,19 +58,21 @@ transcendental functions can be obtained by ftp from\n research.att.com: netlib/cephes/ldouble.shar.Z  */\n \f\n /* Type of computer arithmetic.\n-   Only one of DEC, IBM, MIEEE, IBMPC, or UNK should get defined.\n-\n-   `MIEEE' refers generically to big-endian IEEE floating-point data\n-   structure.  This definition should work in SFmode `float' type and\n-   DFmode `double' type on virtually all big-endian IEEE machines.\n-   If LONG_DOUBLE_TYPE_SIZE has been defined to be 96, then MIEEE\n-   also invokes the particular XFmode (`long double' type) data\n-   structure used by the Motorola 680x0 series processors.\n-\n-   `IBMPC' refers generally to little-endian IEEE machines. In this\n-   case, if LONG_DOUBLE_TYPE_SIZE has been defined to be 96, then\n-   IBMPC also invokes the particular XFmode `long double' data\n-   structure used by the Intel 80x86 series processors.\n+   Only one of DEC, IBM, IEEE, or UNK should get defined.\n+\n+   `IEEE', when FLOAT_WORDS_BIG_ENDIAN is non-zero, refers generically\n+   to big-endian IEEE floating-point data structure.  This definition\n+   should work in SFmode `float' type and DFmode `double' type on\n+   virtually all big-endian IEEE machines.  If LONG_DOUBLE_TYPE_SIZE\n+   has been defined to be 96, then IEEE also invokes the particular\n+   XFmode (`long double' type) data structure used by the Motorola\n+   680x0 series processors.\n+\n+   `IEEE', when FLOAT_WORDS_BIG_ENDIAN is zero, refers generally to\n+   little-endian IEEE machines. In this case, if LONG_DOUBLE_TYPE_SIZE\n+   has been defined to be 96, then IEEE also invokes the particular\n+   XFmode `long double' data structure used by the Intel 80x86 series\n+   processors.\n \n    `DEC' refers specifically to the Digital Equipment Corp PDP-11\n    and VAX floating point data structure.  This model currently\n@@ -119,14 +121,7 @@ research.att.com: netlib/cephes/ldouble.shar.Z  */\n #define IBM 1\n #else /* it's also not an IBM */\n #if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-#if FLOAT_WORDS_BIG_ENDIAN\n-/* Motorola IEEE, high order words come first (Sun workstation): */\n-#define MIEEE 1\n-#else /* not big-endian */\n-/* Intel IEEE, low order words come first:\n- */\n-#define IBMPC 1\n-#endif /*  big-endian */\n+#define IEEE\n #else /* it's not IEEE either */\n /* UNKnown arithmetic.  We don't support this and can't go on. */\n unknown arithmetic type\n@@ -150,11 +145,7 @@ unknown arithmetic type\n #define IBM 1\n #else /* it's also not an IBM */\n #if HOST_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-#if HOST_FLOAT_WORDS_BIG_ENDIAN\n-#define MIEEE 1\n-#else /* not big-endian */\n-#define IBMPC 1\n-#endif /*  big-endian */\n+#define IEEE\n #else /* it's not IEEE either */\n unknown arithmetic type\n #define UNK 1\n@@ -263,29 +254,35 @@ unknown arithmetic type\n /* Emulator uses target format internally\n    but host stores it in host endian-ness. */\n \n-#if HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN\n-#define GET_REAL(r,e) e53toe ((unsigned EMUSHORT*) (r), (e))\n-#define PUT_REAL(e,r) etoe53 ((e), (unsigned EMUSHORT *) (r))\n-\n-#else /* endian-ness differs */\n-/* emulator uses target endian-ness internally */\n-#define GET_REAL(r,e)\t\t\\\n-do { unsigned EMUSHORT w[4];\t\\\n- w[3] = ((EMUSHORT *) r)[0];\t\\\n- w[2] = ((EMUSHORT *) r)[1];\t\\\n- w[1] = ((EMUSHORT *) r)[2];\t\\\n- w[0] = ((EMUSHORT *) r)[3];\t\\\n- e53toe (w, (e)); } while (0)\n-\n-#define PUT_REAL(e,r)\t\t\\\n-do { unsigned EMUSHORT w[4];\t\\\n- etoe53 ((e), w);\t\t\\\n- *((EMUSHORT *) r) = w[3];\t\\\n- *((EMUSHORT *) r + 1) = w[2];\t\\\n- *((EMUSHORT *) r + 2) = w[1];\t\\\n- *((EMUSHORT *) r + 3) = w[0]; } while (0)\n-\n-#endif /* endian-ness differs */\n+#define GET_REAL(r,e)\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+     if (HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN)\t\\\n+       e53toe ((unsigned EMUSHORT*) (r), (e));\t\t\t\\\n+     else\t\t\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\\\n+\t unsigned EMUSHORT w[4];\t\t\t\t\\\n+\t w[3] = ((EMUSHORT *) r)[0];\t\t\t\t\\\n+\t w[2] = ((EMUSHORT *) r)[1];\t\t\t\t\\\n+\t w[1] = ((EMUSHORT *) r)[2];\t\t\t\t\\\n+\t w[0] = ((EMUSHORT *) r)[3];\t\t\t\t\\\n+\t e53toe (w, (e));\t\t\t\t\t\\\n+       }\t\t\t\t\t\t\t\\\n+   } while (0)\n+\n+#define PUT_REAL(e,r)\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+     if (HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN)\t\\\n+       etoe53 ((e), (unsigned EMUSHORT *) (r));\t\t\t\\\n+     else\t\t\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\\\n+\t unsigned EMUSHORT w[4];\t\t\t\t\\\n+\t etoe53 ((e), w);\t\t\t\t\t\\\n+\t *((EMUSHORT *) r) = w[3];\t\t\t\t\\\n+\t *((EMUSHORT *) r + 1) = w[2];\t\t\t\t\\\n+\t *((EMUSHORT *) r + 2) = w[1];\t\t\t\t\\\n+\t *((EMUSHORT *) r + 3) = w[0];\t\t\t\t\\\n+       }\t\t\t\t\t\t\t\\\n+   } while (0)\n \n #else /* not REAL_ARITHMETIC */\n \n@@ -436,99 +433,99 @@ endian (e, x, mode)\n {\n   unsigned long th, t;\n \n-#if FLOAT_WORDS_BIG_ENDIAN\n-  switch (mode)\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n     {\n+      switch (mode)\n+\t{\n \n-    case TFmode:\n-      /* Swap halfwords in the fourth long. */\n-      th = (unsigned long) e[6] & 0xffff;\n-      t = (unsigned long) e[7] & 0xffff;\n-      t |= th << 16;\n-      x[3] = (long) t;\n-\n-    case XFmode:\n-\n-      /* Swap halfwords in the third long. */\n-      th = (unsigned long) e[4] & 0xffff;\n-      t = (unsigned long) e[5] & 0xffff;\n-      t |= th << 16;\n-      x[2] = (long) t;\n-      /* fall into the double case */\n-\n-    case DFmode:\n-\n-      /* swap halfwords in the second word */\n-      th = (unsigned long) e[2] & 0xffff;\n-      t = (unsigned long) e[3] & 0xffff;\n-      t |= th << 16;\n-      x[1] = (long) t;\n-      /* fall into the float case */\n-\n-    case HFmode:\n-    case SFmode:\n-\n-      /* swap halfwords in the first word */\n-      th = (unsigned long) e[0] & 0xffff;\n-      t = (unsigned long) e[1] & 0xffff;\n-      t |= th << 16;\n-      x[0] = t;\n-      break;\n+\tcase TFmode:\n+\t  /* Swap halfwords in the fourth long. */\n+\t  th = (unsigned long) e[6] & 0xffff;\n+\t  t = (unsigned long) e[7] & 0xffff;\n+\t  t |= th << 16;\n+\t  x[3] = (long) t;\n+\n+\tcase XFmode:\n+\n+\t  /* Swap halfwords in the third long. */\n+\t  th = (unsigned long) e[4] & 0xffff;\n+\t  t = (unsigned long) e[5] & 0xffff;\n+\t  t |= th << 16;\n+\t  x[2] = (long) t;\n+\t  /* fall into the double case */\n+\n+\tcase DFmode:\n+\n+\t  /* swap halfwords in the second word */\n+\t  th = (unsigned long) e[2] & 0xffff;\n+\t  t = (unsigned long) e[3] & 0xffff;\n+\t  t |= th << 16;\n+\t  x[1] = (long) t;\n+\t  /* fall into the float case */\n+\n+\tcase HFmode:\n+\tcase SFmode:\n+\n+\t  /* swap halfwords in the first word */\n+\t  th = (unsigned long) e[0] & 0xffff;\n+\t  t = (unsigned long) e[1] & 0xffff;\n+\t  t |= th << 16;\n+\t  x[0] = t;\n+\t  break;\n \n-    default:\n-      abort ();\n+\tdefault:\n+\t  abort ();\n+\t}\n     }\n-\n-#else\n-\n-  /* Pack the output array without swapping. */\n-\n-  switch (mode)\n+  else\n     {\n+      /* Pack the output array without swapping. */\n \n-    case TFmode:\n-\n-      /* Pack the fourth long. */\n-      th = (unsigned long) e[7] & 0xffff;\n-      t = (unsigned long) e[6] & 0xffff;\n-      t |= th << 16;\n-      x[3] = (long) t;\n-\n-    case XFmode:\n-\n-      /* Pack the third long.\n-\t Each element of the input REAL_VALUE_TYPE array has 16 useful bits\n-\t in it.  */\n-      th = (unsigned long) e[5] & 0xffff;\n-      t = (unsigned long) e[4] & 0xffff;\n-      t |= th << 16;\n-      x[2] = (long) t;\n-      /* fall into the double case */\n-\n-    case DFmode:\n-\n-      /* pack the second long */\n-      th = (unsigned long) e[3] & 0xffff;\n-      t = (unsigned long) e[2] & 0xffff;\n-      t |= th << 16;\n-      x[1] = (long) t;\n-      /* fall into the float case */\n-\n-    case HFmode:\n-    case SFmode:\n+      switch (mode)\n+\t{\n \n-      /* pack the first long */\n-      th = (unsigned long) e[1] & 0xffff;\n-      t = (unsigned long) e[0] & 0xffff;\n-      t |= th << 16;\n-      x[0] = t;\n-      break;\n+\tcase TFmode:\n+\n+\t  /* Pack the fourth long. */\n+\t  th = (unsigned long) e[7] & 0xffff;\n+\t  t = (unsigned long) e[6] & 0xffff;\n+\t  t |= th << 16;\n+\t  x[3] = (long) t;\n+\n+\tcase XFmode:\n+\n+\t  /* Pack the third long.\n+\t     Each element of the input REAL_VALUE_TYPE array has 16 useful bits\n+\t     in it.  */\n+\t  th = (unsigned long) e[5] & 0xffff;\n+\t  t = (unsigned long) e[4] & 0xffff;\n+\t  t |= th << 16;\n+\t  x[2] = (long) t;\n+\t  /* fall into the double case */\n+\n+\tcase DFmode:\n+\n+\t  /* pack the second long */\n+\t  th = (unsigned long) e[3] & 0xffff;\n+\t  t = (unsigned long) e[2] & 0xffff;\n+\t  t |= th << 16;\n+\t  x[1] = (long) t;\n+\t  /* fall into the float case */\n+\n+\tcase HFmode:\n+\tcase SFmode:\n+\n+\t  /* pack the first long */\n+\t  th = (unsigned long) e[1] & 0xffff;\n+\t  t = (unsigned long) e[0] & 0xffff;\n+\t  t |= th << 16;\n+\t  x[0] = t;\n+\t  break;\n \n-    default:\n-      abort ();\n+\tdefault:\n+\t  abort ();\n+\t}\n     }\n-\n-#endif\n }\n \n \n@@ -1223,6 +1220,8 @@ ereal_isneg (x)\n   Std 754-1985), the symbol IBMPC or MIEEE should be defined.\n   These numbers have 53-bit significands.  In this mode, constants\n   are provided as arrays of hexadecimal 16 bit integers.\n+  [This has been changed to instead check the preprocessor macros IEEE\n+  and FLOAT_WORDS_BIG_ENDIAN].\n  \n   To accommodate other types of computer arithmetic, all\n   constants are also provided in a normal decimal radix\n@@ -2841,9 +2840,8 @@ e53toe (pe, y)\n   e = pe;\n   denorm = 0;\t\t\t/* flag if denormalized number */\n   ecleaz (yy);\n-#ifdef IBMPC\n-  e += 3;\n-#endif\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    e += 3;\n   r = *e;\n   yy[0] = 0;\n   if (r & 0x8000)\n@@ -2854,21 +2852,24 @@ e53toe (pe, y)\n   if (r == 0x7ff0)\n     {\n #ifdef NANS\n-#ifdef IBMPC\n-      if (((pe[3] & 0xf) != 0) || (pe[2] != 0)\n-\t  || (pe[1] != 0) || (pe[0] != 0))\n+      if (! FLOAT_WORDS_BIG_ENDIAN)\n \t{\n-\t  enan (y, yy[0] != 0);\n-\t  return;\n+\t  if (((pe[3] & 0xf) != 0) || (pe[2] != 0)\n+\t      || (pe[1] != 0) || (pe[0] != 0))\n+\t    {\n+\t      enan (y, yy[0] != 0);\n+\t      return;\n+\t    }\n \t}\n-#else\n-      if (((pe[0] & 0xf) != 0) || (pe[1] != 0)\n-\t  || (pe[2] != 0) || (pe[3] != 0))\n+      else\n \t{\n-\t  enan (y, yy[0] != 0);\n-\t  return;\n+\t  if (((pe[0] & 0xf) != 0) || (pe[1] != 0)\n+\t      || (pe[2] != 0) || (pe[3] != 0))\n+\t    {\n+\t      enan (y, yy[0] != 0);\n+\t      return;\n+\t    }\n \t}\n-#endif\n #endif  /* NANS */\n       eclear (y);\n       einfin (y);\n@@ -2889,16 +2890,20 @@ e53toe (pe, y)\n   r += EXONE - 01777;\n   yy[E] = r;\n   p = &yy[M + 1];\n-#ifdef IBMPC\n-  *p++ = *(--e);\n-  *p++ = *(--e);\n-  *p++ = *(--e);\n-#endif\n-#ifdef MIEEE\n-  ++e;\n-  *p++ = *e++;\n-  *p++ = *e++;\n-  *p++ = *e++;\n+#ifdef IEEE\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      *p++ = *(--e);\n+      *p++ = *(--e);\n+      *p++ = *(--e);\n+    }\n+  else\n+    {\n+      ++e;\n+      *p++ = *e++;\n+      *p++ = *e++;\n+      *p++ = *e++;\n+    }\n #endif\n   eshift (yy, -5);\n   if (denorm)\n@@ -2925,10 +2930,6 @@ e64toe (pe, y)\n   p = yy;\n   for (i = 0; i < NE - 5; i++)\n     *p++ = 0;\n-#ifdef IBMPC\n-  for (i = 0; i < 5; i++)\n-    *p++ = *e++;\n-#endif\n /* This precision is not ordinarily supported on DEC or IBM. */\n #ifdef DEC\n   for (i = 0; i < 5; i++)\n@@ -2941,38 +2942,49 @@ e64toe (pe, y)\n   for (i = 0; i < 5; i++)\n     *p-- = *e++;\n #endif\n-#ifdef MIEEE\n-  p = &yy[0] + (NE - 1);\n-  *p-- = *e++;\n-  ++e;\n-  for (i = 0; i < 4; i++)\n-    *p-- = *e++;\n+#ifdef IEEE\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      for (i = 0; i < 5; i++)\n+\t*p++ = *e++;\n+    }\n+  else\n+    {\n+      p = &yy[0] + (NE - 1);\n+      *p-- = *e++;\n+      ++e;\n+      for (i = 0; i < 4; i++)\n+\t*p-- = *e++;\n+    }\n #endif\n   p = yy;\n   q = y;\n #ifdef INFINITY\n   if (*p == 0x7fff)\n     {\n #ifdef NANS\n-#ifdef IBMPC\n-      for (i = 0; i < 4; i++)\n+      if (! FLOAT_WORDS_BIG_ENDIAN)\n \t{\n-\t  if (pe[i] != 0)\n+\t  for (i = 0; i < 4; i++)\n \t    {\n-\t      enan (y, (*p & 0x8000) != 0);\n-\t      return;\n+\t      if (pe[i] != 0)\n+\t\t{\n+\t\t  enan (y, (*p & 0x8000) != 0);\n+\t\t  return;\n+\t\t}\n \t    }\n \t}\n-#else\n-      for (i = 1; i <= 4; i++)\n+      else\n \t{\n-\t  if (pe[i] != 0)\n+\t  for (i = 1; i <= 4; i++)\n \t    {\n-\t      enan (y, (*p & 0x8000) != 0);\n-\t      return;\n+\t      if (pe[i] != 0)\n+\t\t{\n+\t\t  enan (y, (*p & 0x8000) != 0);\n+\t\t  return;\n+\t\t}\n \t    }\n \t}\n-#endif\n #endif /* NANS */\n       eclear (y);\n       einfin (y);\n@@ -2998,8 +3010,9 @@ e113toe (pe, y)\n   e = pe;\n   denorm = 0;\n   ecleaz (yy);\n-#ifdef IBMPC\n-  e += 7;\n+#ifdef IEEE\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    e += 7;\n #endif\n   r = *e;\n   yy[0] = 0;\n@@ -3010,25 +3023,28 @@ e113toe (pe, y)\n   if (r == 0x7fff)\n     {\n #ifdef NANS\n-#ifdef IBMPC\n-      for (i = 0; i < 7; i++)\n+      if (! FLOAT_WORDS_BIG_ENDIAN)\n \t{\n-\t  if (pe[i] != 0)\n+\t  for (i = 0; i < 7; i++)\n \t    {\n-\t      enan (y, yy[0] != 0);\n-\t      return;\n+\t      if (pe[i] != 0)\n+\t\t{\n+\t\t  enan (y, yy[0] != 0);\n+\t\t  return;\n+\t\t}\n \t    }\n \t}\n-#else\n-      for (i = 1; i < 8; i++)\n+      else\n \t{\n-\t  if (pe[i] != 0)\n+\t  for (i = 1; i < 8; i++)\n \t    {\n-\t      enan (y, yy[0] != 0);\n-\t      return;\n+\t      if (pe[i] != 0)\n+\t\t{\n+\t\t  enan (y, yy[0] != 0);\n+\t\t  return;\n+\t\t}\n \t    }\n \t}\n-#endif\n #endif /* NANS */\n       eclear (y);\n       einfin (y);\n@@ -3039,14 +3055,18 @@ e113toe (pe, y)\n #endif  /* INFINITY */\n   yy[E] = r;\n   p = &yy[M + 1];\n-#ifdef IBMPC\n-  for (i = 0; i < 7; i++)\n-    *p++ = *(--e);\n-#endif\n-#ifdef MIEEE\n-  ++e;\n-  for (i = 0; i < 7; i++)\n-    *p++ = *e++;\n+#ifdef IEEE\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      for (i = 0; i < 7; i++)\n+\t*p++ = *(--e);\n+    }\n+  else\n+    {\n+      ++e;\n+      for (i = 0; i < 7; i++)\n+\t*p++ = *e++;\n+    }\n #endif\n /* If denormal, remove the implied bit; else shift down 1. */\n   if (r == 0)\n@@ -3081,8 +3101,9 @@ e24toe (pe, y)\n   e = pe;\n   denorm = 0;\t\t\t/* flag if denormalized number */\n   ecleaz (yy);\n-#ifdef IBMPC\n-  e += 1;\n+#ifdef IEEE\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    e += 1;\n #endif\n #ifdef DEC\n   e += 1;\n@@ -3097,19 +3118,22 @@ e24toe (pe, y)\n   if (r == 0x7f80)\n     {\n #ifdef NANS\n-#ifdef MIEEE\n-      if (((pe[0] & 0x7f) != 0) || (pe[1] != 0))\n+      if (FLOAT_WORDS_BIG_ENDIAN)\n \t{\n-\t  enan (y, yy[0] != 0);\n-\t  return;\n+\t  if (((pe[0] & 0x7f) != 0) || (pe[1] != 0))\n+\t    {\n+\t      enan (y, yy[0] != 0);\n+\t      return;\n+\t    }\n \t}\n-#else\n-      if (((pe[1] & 0x7f) != 0) || (pe[0] != 0))\n+      else\n \t{\n-\t  enan (y, yy[0] != 0);\n-\t  return;\n+\t  if (((pe[1] & 0x7f) != 0) || (pe[0] != 0))\n+\t    {\n+\t      enan (y, yy[0] != 0);\n+\t      return;\n+\t    }\n \t}\n-#endif\n #endif  /* NANS */\n       eclear (y);\n       einfin (y);\n@@ -3129,15 +3153,17 @@ e24toe (pe, y)\n   r += EXONE - 0177;\n   yy[E] = r;\n   p = &yy[M + 1];\n-#ifdef IBMPC\n-  *p++ = *(--e);\n-#endif\n #ifdef DEC\n   *p++ = *(--e);\n #endif\n-#ifdef MIEEE\n-  ++e;\n-  *p++ = *e++;\n+#ifdef IEEE\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    *p++ = *(--e);\n+  else\n+    {\n+      ++e;\n+      *p++ = *e++;\n+    }\n #endif\n   eshift (yy, -8);\n   if (denorm)\n@@ -3199,11 +3225,10 @@ toe113 (a, b)\n     }\n #endif\n   p = a;\n-#ifdef MIEEE\n-  q = b;\n-#else\n-  q = b + 7;\t\t\t/* point to output exponent */\n-#endif\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    q = b;\n+  else\n+    q = b + 7;\t\t\t/* point to output exponent */\n \n   /* If not denormal, delete the implied bit. */\n   if (a[E] != 0)\n@@ -3212,27 +3237,33 @@ toe113 (a, b)\n     }\n   /* combine sign and exponent */\n   i = *p++;\n-#ifdef MIEEE\n-  if (i)\n-    *q++ = *p++ | 0x8000;\n-  else\n-    *q++ = *p++;\n-#else\n-  if (i)\n-    *q-- = *p++ | 0x8000;\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      if (i)\n+\t*q++ = *p++ | 0x8000;\n+      else\n+\t*q++ = *p++;\n+    }\n   else\n-    *q-- = *p++;\n-#endif\n+    {\n+      if (i)\n+\t*q-- = *p++ | 0x8000;\n+      else\n+\t*q-- = *p++;\n+    }\n   /* skip over guard word */\n   ++p;\n   /* move the significand */\n-#ifdef MIEEE\n-  for (i = 0; i < 7; i++)\n-    *q++ = *p++;\n-#else\n-  for (i = 0; i < 7; i++)\n-    *q-- = *p++;\n-#endif\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      for (i = 0; i < 7; i++)\n+\t*q++ = *p++;\n+    }\n+  else\n+    {\n+      for (i = 0; i < 7; i++)\n+\t*q-- = *p++;\n+    }\n }\n \n static void \n@@ -3284,40 +3315,80 @@ toe64 (a, b)\n     }\n #endif\n   p = a;\n-#if defined(MIEEE) || defined(IBM)\n+#ifdef IBM\n   q = b;\n-#else\n-  q = b + 4;\t\t\t/* point to output exponent */\n+#endif\n+#ifdef DEC\n+  q = b + 4;\n+#endif\n+#ifdef IEEE\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    q = b;\n+  else\n+    {\n+      q = b + 4;\t\t\t/* point to output exponent */\n #if LONG_DOUBLE_TYPE_SIZE == 96\n-  /* Clear the last two bytes of 12-byte Intel format */\n-  *(q+1) = 0;\n+      /* Clear the last two bytes of 12-byte Intel format */\n+      *(q+1) = 0;\n #endif\n+    }\n #endif\n \n   /* combine sign and exponent */\n   i = *p++;\n-#if defined(MIEEE) || defined(IBM)\n+#ifdef IBM\n   if (i)\n     *q++ = *p++ | 0x8000;\n   else\n     *q++ = *p++;\n   *q++ = 0;\n-#else\n+#endif\n+#ifdef DEC\n   if (i)\n     *q-- = *p++ | 0x8000;\n   else\n     *q-- = *p++;\n+#endif\n+#ifdef IEEE\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      if (i)\n+\t*q++ = *p++ | 0x8000;\n+      else\n+\t*q++ = *p++;\n+      *q++ = 0;\n+    }\n+  else\n+    {\n+      if (i)\n+\t*q-- = *p++ | 0x8000;\n+      else\n+\t*q-- = *p++;\n+    }\n #endif\n   /* skip over guard word */\n   ++p;\n   /* move the significand */\n-#if defined(MIEEE) || defined(IBM)\n+#ifdef IBM\n   for (i = 0; i < 4; i++)\n     *q++ = *p++;\n-#else\n+#endif\n+#ifdef DEC\n   for (i = 0; i < 4; i++)\n     *q-- = *p++;\n #endif\n+#ifdef IEEE\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      for (i = 0; i < 4; i++)\n+\t*q++ = *p++;\n+    }\n+  else\n+    {\n+      for (i = 0; i < 4; i++)\n+\t*q-- = *p++;\n+    }\n+#endif\n }\n \n \n@@ -3405,8 +3476,9 @@ toe53 (x, y)\n     }\n #endif\n   p = &x[0];\n-#ifdef IBMPC\n-  y += 3;\n+#ifdef IEEE\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    y += 3;\n #endif\n   *y = 0;\t\t\t/* output high order */\n   if (*p++)\n@@ -3417,30 +3489,34 @@ toe53 (x, y)\n     {\t\t\t\t/* Saturate at largest number less than infinity. */\n #ifdef INFINITY\n       *y |= 0x7ff0;\n-#ifdef IBMPC\n-      *(--y) = 0;\n-      *(--y) = 0;\n-      *(--y) = 0;\n-#endif\n-#ifdef MIEEE\n-      ++y;\n-      *y++ = 0;\n-      *y++ = 0;\n-      *y++ = 0;\n-#endif\n+      if (! FLOAT_WORDS_BIG_ENDIAN)\n+\t{\n+\t  *(--y) = 0;\n+\t  *(--y) = 0;\n+\t  *(--y) = 0;\n+\t}\n+      else\n+\t{\n+\t  ++y;\n+\t  *y++ = 0;\n+\t  *y++ = 0;\n+\t  *y++ = 0;\n+\t}\n #else\n       *y |= (unsigned EMUSHORT) 0x7fef;\n-#ifdef IBMPC\n-      *(--y) = 0xffff;\n-      *(--y) = 0xffff;\n-      *(--y) = 0xffff;\n-#endif\n-#ifdef MIEEE\n-      ++y;\n-      *y++ = 0xffff;\n-      *y++ = 0xffff;\n-      *y++ = 0xffff;\n-#endif\n+      if (! FLOAT_WORDS_BIG_ENDIAN)\n+\t{\n+\t  *(--y) = 0xffff;\n+\t  *(--y) = 0xffff;\n+\t  *(--y) = 0xffff;\n+\t}\n+      else\n+\t{\n+\t  ++y;\n+\t  *y++ = 0xffff;\n+\t  *y++ = 0xffff;\n+\t  *y++ = 0xffff;\n+\t}\n #endif\n       return;\n     }\n@@ -3455,17 +3531,19 @@ toe53 (x, y)\n     }\n   i |= *p++ & (unsigned EMUSHORT) 0x0f;\t/* *p = xi[M] */\n   *y |= (unsigned EMUSHORT) i;\t/* high order output already has sign bit set */\n-#ifdef IBMPC\n-  *(--y) = *p++;\n-  *(--y) = *p++;\n-  *(--y) = *p;\n-#endif\n-#ifdef MIEEE\n-  ++y;\n-  *y++ = *p++;\n-  *y++ = *p++;\n-  *y++ = *p++;\n-#endif\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      *(--y) = *p++;\n+      *(--y) = *p++;\n+      *(--y) = *p;\n+    }\n+  else\n+    {\n+      ++y;\n+      *y++ = *p++;\n+      *y++ = *p++;\n+      *y++ = *p++;\n+    }\n }\n \n #endif /* not IBM */\n@@ -3539,8 +3617,9 @@ toe24 (x, y)\n     }\n #endif\n   p = &x[0];\n-#ifdef IBMPC\n-  y += 1;\n+#ifdef IEEE\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    y += 1;\n #endif\n #ifdef DEC\n   y += 1;\n@@ -3555,27 +3634,31 @@ toe24 (x, y)\n     {\n #ifdef INFINITY\n       *y |= (unsigned EMUSHORT) 0x7f80;\n-#ifdef IBMPC\n-      *(--y) = 0;\n-#endif\n #ifdef DEC\n       *(--y) = 0;\n #endif\n-#ifdef MIEEE\n-      ++y;\n-      *y = 0;\n+#ifdef IEEE\n+      if (! FLOAT_WORDS_BIG_ENDIAN)\n+\t*(--y) = 0;\n+      else\n+\t{\n+\t  ++y;\n+\t  *y = 0;\n+\t}\n #endif\n #else  /* no INFINITY */\n       *y |= (unsigned EMUSHORT) 0x7f7f;\n-#ifdef IBMPC\n-      *(--y) = 0xffff;\n-#endif\n #ifdef DEC\n       *(--y) = 0xffff;\n #endif\n-#ifdef MIEEE\n-      ++y;\n-      *y = 0xffff;\n+#ifdef IEEE\n+      if (! FLOAT_WORDS_BIG_ENDIAN)\n+\t*(--y) = 0xffff;\n+      else\n+\t{\n+\t  ++y;\n+\t  *y = 0xffff;\n+\t}\n #endif\n #ifdef ERANGE\n       errno = ERANGE;\n@@ -3594,15 +3677,17 @@ toe24 (x, y)\n     }\n   i |= *p++ & (unsigned EMUSHORT) 0x7f;\t/* *p = xi[M] */\n   *y |= i;\t\t\t/* high order output already has sign bit set */\n-#ifdef IBMPC\n-  *(--y) = *p;\n-#endif\n #ifdef DEC\n   *(--y) = *p;\n #endif\n-#ifdef MIEEE\n-  ++y;\n-  *y = *p;\n+#ifdef IEEE\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    *(--y) = *p;\n+  else\n+    {\n+      ++y;\n+      *y = *p;\n+    }\n #endif\n }\n #endif  /* not IBM */\n@@ -5400,45 +5485,38 @@ toibm (x, y, mode)\n #ifdef TFMODE_NAN\n TFMODE_NAN;\n #else\n-#ifdef MIEEE\n-unsigned EMUSHORT TFnan[8] =\n+#ifdef IEEE\n+unsigned EMUSHORT TFbignan[8] =\n  {0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff};\n-#endif\n-#ifdef IBMPC\n-unsigned EMUSHORT TFnan[8] = {0, 0, 0, 0, 0, 0, 0x8000, 0xffff};\n+unsigned EMUSHORT TFlittlenan[8] = {0, 0, 0, 0, 0, 0, 0x8000, 0xffff};\n #endif\n #endif\n \n #ifdef XFMODE_NAN\n XFMODE_NAN;\n #else\n-#ifdef MIEEE\n-unsigned EMUSHORT XFnan[6] = {0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff};\n-#endif\n-#ifdef IBMPC\n-unsigned EMUSHORT XFnan[6] = {0, 0, 0, 0xc000, 0xffff, 0};\n+#ifdef IEEE\n+unsigned EMUSHORT XFbignan[6] =\n+ {0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff};\n+unsigned EMUSHORT XFlittlenan[6] = {0, 0, 0, 0xc000, 0xffff, 0};\n #endif\n #endif\n \n #ifdef DFMODE_NAN\n DFMODE_NAN;\n #else\n-#ifdef MIEEE\n-unsigned EMUSHORT DFnan[4] = {0x7fff, 0xffff, 0xffff, 0xffff};\n-#endif\n-#ifdef IBMPC\n-unsigned EMUSHORT DFnan[4] = {0, 0, 0, 0xfff8};\n+#ifdef IEEE\n+unsigned EMUSHORT DFbignan[4] = {0x7fff, 0xffff, 0xffff, 0xffff};\n+unsigned EMUSHORT DFlittlenan[4] = {0, 0, 0, 0xfff8};\n #endif\n #endif\n \n #ifdef SFMODE_NAN\n SFMODE_NAN;\n #else\n-#ifdef MIEEE\n-unsigned EMUSHORT SFnan[2] = {0x7fff, 0xffff};\n-#endif\n-#ifdef IBMPC\n-unsigned EMUSHORT SFnan[2] = {0, 0xffc0};\n+#ifdef IEEE\n+unsigned EMUSHORT SFbignan[2] = {0x7fff, 0xffff};\n+unsigned EMUSHORT SFlittlenan[2] = {0, 0xffc0};\n #endif\n #endif\n \n@@ -5459,33 +5537,43 @@ make_nan (nan, sign, mode)\n #if !defined(DEC) && !defined(IBM)\n     case TFmode:\n       n = 8;\n-      p = TFnan;\n+      if (FLOAT_WORDS_BIG_ENDIAN)\n+\tp = TFbignan;\n+      else\n+\tp = TFlittlenan;\n       break;\n     case XFmode:\n       n = 6;\n-      p = XFnan;\n+      if (FLOAT_WORDS_BIG_ENDIAN)\n+\tp = XFbignan;\n+      else\n+\tp = XFlittlenan;\n       break;\n     case DFmode:\n       n = 4;\n-      p = DFnan;\n+      if (FLOAT_WORDS_BIG_ENDIAN)\n+\tp = DFbignan;\n+      else\n+\tp = DFlittlenan;\n       break;\n     case HFmode:\n     case SFmode:\n       n = 2;\n-      p = SFnan;\n+      if (FLOAT_WORDS_BIG_ENDIAN)\n+\tp = SFbignan;\n+      else\n+\tp = SFlittlenan;\n       break;\n #endif\n     default:\n       abort ();\n     }\n-#ifdef MIEEE\n-  *nan++ = (sign << 15) | *p++;\n-#endif\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    *nan++ = (sign << 15) | *p++;\n   while (--n != 0)\n     *nan++ = *p++;\n-#ifndef MIEEE\n-  *nan = (sign << 15) | *p;\n-#endif\n+  if (! FLOAT_WORDS_BIG_ENDIAN)\n+    *nan = (sign << 15) | *p;\n }\n \n /* Convert an SFmode target `float' value to a REAL_VALUE_TYPE.\n@@ -5502,13 +5590,16 @@ ereal_from_float (f)\n \n   /* Convert 32 bit integer to array of 16 bit pieces in target machine order.\n    This is the inverse operation to what the function `endian' does.  */\n-#if FLOAT_WORDS_BIG_ENDIAN\n-  s[0] = (unsigned EMUSHORT) (f >> 16);\n-  s[1] = (unsigned EMUSHORT) f;\n-#else\n-  s[0] = (unsigned EMUSHORT) f;\n-  s[1] = (unsigned EMUSHORT) (f >> 16);\n-#endif\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      s[0] = (unsigned EMUSHORT) (f >> 16);\n+      s[1] = (unsigned EMUSHORT) f;\n+    }\n+  else\n+    {\n+      s[0] = (unsigned EMUSHORT) f;\n+      s[1] = (unsigned EMUSHORT) (f >> 16);\n+    }\n   /* Convert and promote the target float to E-type. */\n   e24toe (s, e);\n   /* Output E-type to REAL_VALUE_TYPE. */\n@@ -5535,30 +5626,34 @@ ereal_from_double (d)\n   unsigned EMUSHORT e[NE];\n \n   /* Convert array of HOST_WIDE_INT to equivalent array of 16-bit pieces.  */\n-#if FLOAT_WORDS_BIG_ENDIAN\n-  s[0] = (unsigned EMUSHORT) (d[0] >> 16);\n-  s[1] = (unsigned EMUSHORT) d[0];\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      s[0] = (unsigned EMUSHORT) (d[0] >> 16);\n+      s[1] = (unsigned EMUSHORT) d[0];\n #if HOST_BITS_PER_WIDE_INT == 32\n-  s[2] = (unsigned EMUSHORT) (d[1] >> 16);\n-  s[3] = (unsigned EMUSHORT) d[1];\n+      s[2] = (unsigned EMUSHORT) (d[1] >> 16);\n+      s[3] = (unsigned EMUSHORT) d[1];\n #else\n-  /* In this case the entire target double is contained in the\n-     first array element.  The second element of the input is ignored.  */\n-  s[2] = (unsigned EMUSHORT) (d[0] >> 48);\n-  s[3] = (unsigned EMUSHORT) (d[0] >> 32);\n+      /* In this case the entire target double is contained in the\n+\t first array element.  The second element of the input is\n+\t ignored.  */\n+      s[2] = (unsigned EMUSHORT) (d[0] >> 48);\n+      s[3] = (unsigned EMUSHORT) (d[0] >> 32);\n #endif\n-#else\n-/* Target float words are little-endian.  */\n-  s[0] = (unsigned EMUSHORT) d[0];\n-  s[1] = (unsigned EMUSHORT) (d[0] >> 16);\n+    }\n+  else\n+    {\n+      /* Target float words are little-endian.  */\n+      s[0] = (unsigned EMUSHORT) d[0];\n+      s[1] = (unsigned EMUSHORT) (d[0] >> 16);\n #if HOST_BITS_PER_WIDE_INT == 32\n-  s[2] = (unsigned EMUSHORT) d[1];\n-  s[3] = (unsigned EMUSHORT) (d[1] >> 16);\n+      s[2] = (unsigned EMUSHORT) d[1];\n+      s[3] = (unsigned EMUSHORT) (d[1] >> 16);\n #else\n-  s[2] = (unsigned EMUSHORT) (d[0] >> 32);\n-  s[3] = (unsigned EMUSHORT) (d[0] >> 48);\n-#endif\n+      s[2] = (unsigned EMUSHORT) (d[0] >> 32);\n+      s[3] = (unsigned EMUSHORT) (d[0] >> 48);\n #endif\n+    }\n   /* Convert target double to E-type. */\n   e53toe (s, e);\n   /* Output E-type to REAL_VALUE_TYPE. */\n@@ -5580,13 +5675,16 @@ uditoe (di, e)\n   int k;\n \n   ecleaz (yi);\n-#if WORDS_BIG_ENDIAN\n-  for (k = M; k < M + 4; k++)\n-    yi[k] = *di++;\n-#else\n-  for (k = M + 3; k >= M; k--)\n-    yi[k] = *di++;\n-#endif\n+  if (WORDS_BIG_ENDIAN)\n+    {\n+      for (k = M; k < M + 4; k++)\n+\tyi[k] = *di++;\n+    }\n+  else\n+    {\n+      for (k = M + 3; k >= M; k--)\n+\tyi[k] = *di++;\n+    }\n   yi[E] = EXONE + 47;\t/* exponent if normalize shift count were 0 */\n   if ((k = enormlz (yi)) > NBITS)/* normalize the significand */\n     ecleaz (yi);\t\t/* it was zero */\n@@ -5608,13 +5706,16 @@ ditoe (di, e)\n   int k, sign;\n \n   ecleaz (yi);\n-#if WORDS_BIG_ENDIAN\n-  for (k = M; k < M + 4; k++)\n-    yi[k] = *di++;\n-#else\n-  for (k = M + 3; k >= M; k--)\n-    yi[k] = *di++;\n-#endif\n+  if (WORDS_BIG_ENDIAN)\n+    {\n+      for (k = M; k < M + 4; k++)\n+\tyi[k] = *di++;\n+    }\n+  else\n+    {\n+      for (k = M + 3; k >= M; k--)\n+\tyi[k] = *di++;\n+    }\n   /* Take absolute value */\n   sign = 0;\n   if (yi[M] & 0x8000)\n@@ -5680,21 +5781,21 @@ etoudi (x, i)\n       if (j == 0)\n \tj = 16;\n       eshift (xi, j);\n-#if WORDS_BIG_ENDIAN\n-      *i++ = xi[M];\n-#else\n-      i += 3;\n-      *i-- = xi[M];\n-#endif\n+      if (WORDS_BIG_ENDIAN)\n+\t*i++ = xi[M];\n+      else\n+\t{\n+\t  i += 3;\n+\t  *i-- = xi[M];\n+\t}\n       k -= j;\n       do\n \t{\n \t  eshup6 (xi);\n-#if WORDS_BIG_ENDIAN\n-\t  *i++ = xi[M];\n-#else\n-\t  *i-- = xi[M];\n-#endif\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    *i++ = xi[M];\n+\t  else\n+\t    *i-- = xi[M];\n \t}\n       while ((k -= 16) > 0);\n     }\n@@ -5705,18 +5806,21 @@ etoudi (x, i)\n \n noshift:\n \n-#if WORDS_BIG_ENDIAN\n-      i += 3;\n-      *i-- = xi[M];\n-      *i-- = 0;\n-      *i-- = 0;\n-      *i = 0;\n-#else\n-      *i++ = xi[M];\n-      *i++ = 0;\n-      *i++ = 0;\n-      *i = 0;\n-#endif\n+      if (WORDS_BIG_ENDIAN)\n+\t{\n+\t  i += 3;\n+\t  *i-- = xi[M];\n+\t  *i-- = 0;\n+\t  *i-- = 0;\n+\t  *i = 0;\n+\t}\n+      else\n+\t{\n+\t  *i++ = xi[M];\n+\t  *i++ = 0;\n+\t  *i++ = 0;\n+\t  *i = 0;\n+\t}\n     }\n }\n \n@@ -5759,21 +5863,21 @@ etodi (x, i)\n       if (j == 0)\n \tj = 16;\n       eshift (xi, j);\n-#if WORDS_BIG_ENDIAN\n-      *i++ = xi[M];\n-#else\n-      i += 3;\n-      *i-- = xi[M];\n-#endif\n+      if (WORDS_BIG_ENDIAN)\n+\t*i++ = xi[M];\n+      else\n+\t{\n+\t  i += 3;\n+\t  *i-- = xi[M];\n+\t}\n       k -= j;\n       do\n \t{\n \t  eshup6 (xi);\n-#if WORDS_BIG_ENDIAN\n-\t  *i++ = xi[M];\n-#else\n-\t  *i-- = xi[M];\n-#endif\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    *i++ = xi[M];\n+\t  else\n+\t    *i-- = xi[M];\n \t}\n       while ((k -= 16) > 0);\n     }\n@@ -5782,34 +5886,35 @@ etodi (x, i)\n         /* shift not more than 16 bits */\n       eshift (xi, k);\n \n-#if WORDS_BIG_ENDIAN\n-      i += 3;\n-      *i = xi[M];\n-      *i-- = 0;\n-      *i-- = 0;\n-      *i = 0;\n-#else\n-      *i++ = xi[M];\n-      *i++ = 0;\n-      *i++ = 0;\n-      *i = 0;\n-#endif\n+      if (WORDS_BIG_ENDIAN)\n+\t{\n+\t  i += 3;\n+\t  *i = xi[M];\n+\t  *i-- = 0;\n+\t  *i-- = 0;\n+\t  *i = 0;\n+\t}\n+      else\n+\t{\n+\t  *i++ = xi[M];\n+\t  *i++ = 0;\n+\t  *i++ = 0;\n+\t  *i = 0;\n+\t}\n     }\n   /* Negate if negative */\n   if (xi[0])\n     {\n       carry = 0;\n-#if WORDS_BIG_ENDIAN\n-      isave += 3;\n-#endif\n+      if (WORDS_BIG_ENDIAN)\n+\tisave += 3;\n       for (k = 0; k < 4; k++)\n \t{\n \t  acc = (unsigned EMULONG) (~(*isave) & 0xffff) + carry;\n-#if WORDS_BIG_ENDIAN\n-\t  *isave-- = acc;\n-#else\n-\t  *isave++ = acc;\n-#endif\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    *isave-- = acc;\n+\t  else\n+\t    *isave++ = acc;\n \t  carry = 0;\n \t  if (acc & 0x10000)\n \t    carry = 1;"}, {"sha": "424264196e64dec57616b9925c281cad63152ac1", "filename": "gcc/real.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -260,19 +260,19 @@ do { float f = (float) (IN);\t\t\t\t\t\t\\\n    values which is its bitwise equivalent, but put the two words into\n    proper word order for the target.  */\n #ifndef REAL_VALUE_TO_TARGET_DOUBLE\n-#if HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN\n #define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT)\t\t\t\t\\\n do { REAL_VALUE_TYPE in = (IN);  /* Make sure it's not in a register.  */\\\n-     (OUT)[0] = ((long *) &in)[0];\t\t\t\t\t\\\n-     (OUT)[1] = ((long *) &in)[1];\t\t\t\t\t\\\n+     if (HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN)\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+\t (OUT)[0] = ((long *) &in)[0];\t\t\t\t\t\\\n+\t (OUT)[1] = ((long *) &in)[1];\t\t\t\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+       {\t\t\t\t\t\t\t\t\\\n+\t (OUT)[1] = ((long *) &in)[0];\t\t\t\t\t\\\n+\t (OUT)[0] = ((long *) &in)[1];\t\t\t\t\t\\\n+       }\t\t\t\t\t\t\t\t\\\n    } while (0)\n-#else\n-#define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT)\t\t\t\t\\\n-do { REAL_VALUE_TYPE in = (IN);  /* Make sure it's not in a register.  */\\\n-     (OUT)[1] = ((long *) &in)[0];\t\t\t\t\t\\\n-     (OUT)[0] = ((long *) &in)[1];\t\t\t\t\t\\\n-   } while (0)\n-#endif\n #endif\n #endif /* HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT */\n "}, {"sha": "4177e072cad60adb1413d648963c511dba242ce6", "filename": "gcc/recog.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -423,11 +423,10 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t  enum machine_mode mode = GET_MODE (x);\n \t  rtx new;\n \n-#if BYTES_BIG_ENDIAN\n-\t  offset += (MIN (UNITS_PER_WORD,\n-\t\t\t  GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t\t     - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n-#endif\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    offset += (MIN (UNITS_PER_WORD,\n+\t\t\t    GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\t\t       - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n \n \t  new = gen_rtx (MEM, mode, plus_constant (XEXP (to, 0), offset));\n \t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (to);\n@@ -474,10 +473,9 @@ validate_replace_rtx_1 (loc, from, to, object)\n \n \t\t  /* If the bytes and bits are counted differently, we\n \t\t     must adjust the offset.  */\n-#if BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN\n-\t      offset = (GET_MODE_SIZE (is_mode) - GET_MODE_SIZE (wanted_mode)\n-\t\t\t- offset);\n-#endif\n+\t      if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN)\n+\t\toffset = (GET_MODE_SIZE (is_mode) - GET_MODE_SIZE (wanted_mode)\n+\t\t\t  - offset);\n \n \t      pos %= GET_MODE_BITSIZE (wanted_mode);\n \n@@ -1083,10 +1081,9 @@ indirect_operand (op, mode)\n       register int offset = SUBREG_WORD (op) * UNITS_PER_WORD;\n       rtx inner = SUBREG_REG (op);\n \n-#if BYTES_BIG_ENDIAN\n-      offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (op)))\n-\t\t - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (inner))));\n-#endif\n+      if (BYTES_BIG_ENDIAN)\n+\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (op)))\n+\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (inner))));\n \n       if (mode != VOIDmode && GET_MODE (op) != mode)\n \treturn 0;"}, {"sha": "06d7746cc405e4c46ceb573af087010f5147718e", "filename": "gcc/reload.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -3934,13 +3934,14 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n \t  int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n \t  rtx addr = (reg_equiv_address[regno] ? reg_equiv_address[regno]\n \t\t      : XEXP (reg_equiv_mem[regno], 0));\n-#if BYTES_BIG_ENDIAN\n-\t  int size;\n-\t  size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n-\t  offset += MIN (size, UNITS_PER_WORD);\n-\t  size = GET_MODE_SIZE (GET_MODE (x));\n-\t  offset -= MIN (size, UNITS_PER_WORD);\n-#endif\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    {\n+\t      int size;\n+\t      size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n+\t      offset += MIN (size, UNITS_PER_WORD);\n+\t      size = GET_MODE_SIZE (GET_MODE (x));\n+\t      offset -= MIN (size, UNITS_PER_WORD);\n+\t    }\n \t  addr = plus_constant (addr, offset);\n \t  x = gen_rtx (MEM, GET_MODE (x), addr);\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);"}, {"sha": "2a5db92322c401cce85400c28580cbb94cbda9ac", "filename": "gcc/reload1.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -2328,13 +2328,14 @@ alter_reg (i, from_reg)\n \t{\n \t  /* No known place to spill from => no slot to reuse.  */\n \t  x = assign_stack_local (GET_MODE (regno_reg_rtx[i]), total_size, -1);\n-#if BYTES_BIG_ENDIAN\n-\t  /* Cancel the  big-endian correction done in assign_stack_local.\n-\t     Get the address of the beginning of the slot.\n-\t     This is so we can do a big-endian correction unconditionally\n-\t     below.  */\n-\t  adjust = inherent_size - total_size;\n-#endif\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    {\n+\t      /* Cancel the  big-endian correction done in assign_stack_local.\n+\t\t Get the address of the beginning of the slot.\n+\t\t This is so we can do a big-endian correction unconditionally\n+\t\t below.  */\n+\t      adjust = inherent_size - total_size;\n+\t    }\n \t}\n       /* Reuse a stack slot if possible.  */\n       else if (spill_stack_slot[from_reg] != 0\n@@ -2358,23 +2359,22 @@ alter_reg (i, from_reg)\n \t    }\n \t  /* Make a slot with that size.  */\n \t  x = assign_stack_local (mode, total_size, -1);\n-#if BYTES_BIG_ENDIAN\n-\t  /* Cancel the  big-endian correction done in assign_stack_local.\n-\t     Get the address of the beginning of the slot.\n-\t     This is so we can do a big-endian correction unconditionally\n-\t     below.  */\n-\t  adjust = GET_MODE_SIZE (mode) - total_size;\n-#endif\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    {\n+\t      /* Cancel the  big-endian correction done in assign_stack_local.\n+\t\t Get the address of the beginning of the slot.\n+\t\t This is so we can do a big-endian correction unconditionally\n+\t\t below.  */\n+\t      adjust = GET_MODE_SIZE (mode) - total_size;\n+\t    }\n \t  spill_stack_slot[from_reg] = x;\n \t  spill_stack_slot_width[from_reg] = total_size;\n \t}\n \n-#if BYTES_BIG_ENDIAN\n       /* On a big endian machine, the \"address\" of the slot\n \t is the address of the low part that fits its inherent mode.  */\n-      if (inherent_size < total_size)\n+      if (BYTES_BIG_ENDIAN && inherent_size < total_size)\n \tadjust += (total_size - inherent_size);\n-#endif /* BYTES_BIG_ENDIAN */\n \n       /* If we have any adjustment to make, or if the stack slot is the\n \t wrong mode, make a new stack slot.  */\n@@ -2930,11 +2930,10 @@ eliminate_regs (x, mem_mode, insn)\n \t      int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n \t      enum machine_mode mode = GET_MODE (x);\n \n-#if BYTES_BIG_ENDIAN\n-\t      offset += (MIN (UNITS_PER_WORD,\n-\t\t\t      GET_MODE_SIZE (GET_MODE (new)))\n-\t\t\t - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n-#endif\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\toffset += (MIN (UNITS_PER_WORD,\n+\t\t\t\tGET_MODE_SIZE (GET_MODE (new)))\n+\t\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n \n \t      PUT_MODE (new, mode);\n \t      XEXP (new, 0) = plus_constant (XEXP (new, 0), offset);"}, {"sha": "e5d643ec8d50883b06c1129d1dc426da1a65389e", "filename": "gcc/sdbout.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -1252,12 +1252,12 @@ sdbout_parms (parms)\n \t\t   the parm with the variable's declared type, and adjust\n \t\t   the address if the least significant bytes (which we are\n \t\t   using) are not the first ones.  */\n-#if BYTES_BIG_ENDIAN\n-\t\tif (TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n+\t\tif (BYTES_BIG_ENDIAN\n+\t\t    && TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n \t\t  current_sym_value +=\n \t\t    (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n \t\t     - GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n-#endif\n+\n \t\tif (GET_CODE (DECL_RTL (parms)) == MEM\n \t\t    && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n \t\t    && (GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 1))\n@@ -1374,11 +1374,11 @@ sdbout_reg_parms (parms)\n \t    /* A parm declared char is really passed as an int,\n \t       so it occupies the least significant bytes.\n \t       On a big-endian machine those are not the low-numbered ones.  */\n-#if BYTES_BIG_ENDIAN\n-\t    if (offset != -1 && TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n+\t    if (BYTES_BIG_ENDIAN\n+\t\t&& offset != -1\n+\t\t&& TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n \t      offset += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n \t\t\t - GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n-#endif\n \t    if (INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) != offset) {...}\n #endif\n \t      {"}, {"sha": "69008a18e327d1fd057c7c0648a706f5947a97ac", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -4094,11 +4094,10 @@ get_set_constructor_words (init, buffer, wd_size)\n     {\n       if (bit_buffer[i])\n \t{\n-#if BITS_BIG_ENDIAN\n-\t  *wordp |= (1 << (set_word_size - 1 - bit_pos));\n-#else\n-\t  *wordp |= 1 << bit_pos;\n-#endif\n+\t  if (BITS_BIG_ENDIAN)\n+\t    *wordp |= (1 << (set_word_size - 1 - bit_pos));\n+\t  else\n+\t    *wordp |= 1 << bit_pos;\n \t}\n       bit_pos++;\n       if (bit_pos >= set_word_size)"}, {"sha": "28165a545adec1dc0c9742d4d2ec170a4ec7108c", "filename": "gcc/varasm.c", "status": "modified", "additions": 71, "deletions": 64, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76b9db2874507ed287d1fe39ca2b1e89ae95207/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f76b9db2874507ed287d1fe39ca2b1e89ae95207", "patch": "@@ -3554,17 +3554,20 @@ bc_assemble_integer (exp, size)\n \t}\n       else if (size == 8)\n \t{\n-#if WORDS_BIG_ENDIAN\n-\t  int i = TREE_INT_CST_HIGH (const_part);\n-\t  bc_emit ((char *) &i, 4);\n-\t  i = TREE_INT_CST_LOW (const_part);\n-\t  bc_emit ((char *) &i, 4);\n-#else\n-\t  int i = TREE_INT_CST_LOW (const_part);\n-\t  bc_emit ((char *) &i, 4);\n-\t  i = TREE_INT_CST_HIGH (const_part);\n-\t  bc_emit ((char *) &i, 4);\n-#endif\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    {\n+\t      int i = TREE_INT_CST_HIGH (const_part);\n+\t      bc_emit ((char *) &i, 4);\n+\t      i = TREE_INT_CST_LOW (const_part);\n+\t      bc_emit ((char *) &i, 4);\n+\t    }\n+\t  else\n+\t    {\n+\t      int i = TREE_INT_CST_LOW (const_part);\n+\t      bc_emit ((char *) &i, 4);\n+\t      i = TREE_INT_CST_HIGH (const_part);\n+\t      bc_emit ((char *) &i, 4);\n+\t    }\n \t  size -= 8;\n \t}\n     }\n@@ -3767,64 +3770,68 @@ output_constructor (exp, size)\n \t\t (all part of the same byte).  */\n \t      this_time = MIN (end_offset - next_offset,\n \t\t\t       BITS_PER_UNIT - next_bit);\n-#if BYTES_BIG_ENDIAN\n-\t      /* On big-endian machine, take the most significant bits\n-\t\t first (of the bits that are significant)\n-\t\t and put them into bytes from the most significant end.  */\n-\t      shift = end_offset - next_offset - this_time;\n-\t      /* Don't try to take a bunch of bits that cross\n-\t\t the word boundary in the INTEGER_CST.  */\n-\t      if (shift < HOST_BITS_PER_WIDE_INT\n-\t\t  && shift + this_time > HOST_BITS_PER_WIDE_INT)\n+\t      if (BYTES_BIG_ENDIAN)\n \t\t{\n-\t\t  this_time -= (HOST_BITS_PER_WIDE_INT - shift);\n-\t\t  shift = HOST_BITS_PER_WIDE_INT;\n-\t\t}\n-\n-\t      /* Now get the bits from the appropriate constant word.  */\n-\t      if (shift < HOST_BITS_PER_WIDE_INT)\n-\t\t{\n-\t\t  value = TREE_INT_CST_LOW (val);\n-\t\t}\n-\t      else if (shift < 2 * HOST_BITS_PER_WIDE_INT)\n-\t\t{\n-\t\t  value = TREE_INT_CST_HIGH (val);\n-\t\t  shift -= HOST_BITS_PER_WIDE_INT;\n+\t\t  /* On big-endian machine, take the most significant bits\n+\t\t     first (of the bits that are significant)\n+\t\t     and put them into bytes from the most significant end.  */\n+\t\t  shift = end_offset - next_offset - this_time;\n+\t\t  /* Don't try to take a bunch of bits that cross\n+\t\t     the word boundary in the INTEGER_CST.  */\n+\t\t  if (shift < HOST_BITS_PER_WIDE_INT\n+\t\t      && shift + this_time > HOST_BITS_PER_WIDE_INT)\n+\t\t    {\n+\t\t      this_time -= (HOST_BITS_PER_WIDE_INT - shift);\n+\t\t      shift = HOST_BITS_PER_WIDE_INT;\n+\t\t    }\n+\n+\t\t  /* Now get the bits from the appropriate constant word.  */\n+\t\t  if (shift < HOST_BITS_PER_WIDE_INT)\n+\t\t    {\n+\t\t      value = TREE_INT_CST_LOW (val);\n+\t\t    }\n+\t\t  else if (shift < 2 * HOST_BITS_PER_WIDE_INT)\n+\t\t    {\n+\t\t      value = TREE_INT_CST_HIGH (val);\n+\t\t      shift -= HOST_BITS_PER_WIDE_INT;\n+\t\t    }\n+\t\t  else\n+\t\t    abort ();\n+\t\t  byte |= (((value >> shift)\n+\t\t\t    & (((HOST_WIDE_INT) 1 << this_time) - 1))\n+\t\t\t   << (BITS_PER_UNIT - this_time - next_bit));\n \t\t}\n \t      else\n-\t\tabort ();\n-\t      byte |= (((value >> shift)\n-\t\t\t& (((HOST_WIDE_INT) 1 << this_time) - 1))\n-\t\t       << (BITS_PER_UNIT - this_time - next_bit));\n-#else\n-\t      /* On little-endian machines,\n-\t\t take first the least significant bits of the value\n-\t\t and pack them starting at the least significant\n-\t\t bits of the bytes.  */\n-\t      shift = (next_offset\n-\t\t       - TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)));\n-\t      /* Don't try to take a bunch of bits that cross\n-\t\t the word boundary in the INTEGER_CST.  */\n-\t      if (shift < HOST_BITS_PER_WIDE_INT\n-\t\t  && shift + this_time > HOST_BITS_PER_WIDE_INT)\n \t\t{\n-\t\t  this_time -= (HOST_BITS_PER_WIDE_INT - shift);\n-\t\t  shift = HOST_BITS_PER_WIDE_INT;\n+\t\t  /* On little-endian machines,\n+\t\t     take first the least significant bits of the value\n+\t\t     and pack them starting at the least significant\n+\t\t     bits of the bytes.  */\n+\t\t  shift = (next_offset\n+\t\t\t   - TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)));\n+\t\t  /* Don't try to take a bunch of bits that cross\n+\t\t     the word boundary in the INTEGER_CST.  */\n+\t\t  if (shift < HOST_BITS_PER_WIDE_INT\n+\t\t      && shift + this_time > HOST_BITS_PER_WIDE_INT)\n+\t\t    {\n+\t\t      this_time -= (HOST_BITS_PER_WIDE_INT - shift);\n+\t\t      shift = HOST_BITS_PER_WIDE_INT;\n+\t\t    }\n+\n+\t\t  /* Now get the bits from the appropriate constant word.  */\n+\t\t  if (shift < HOST_BITS_PER_INT)\n+\t\t    value = TREE_INT_CST_LOW (val);\n+\t\t  else if (shift < 2 * HOST_BITS_PER_WIDE_INT)\n+\t\t    {\n+\t\t      value = TREE_INT_CST_HIGH (val);\n+\t\t      shift -= HOST_BITS_PER_WIDE_INT;\n+\t\t    }\n+\t\t  else\n+\t\t    abort ();\n+\t\t  byte |= (((value >> shift)\n+\t\t\t    & (((HOST_WIDE_INT) 1 << this_time) - 1))\n+\t\t\t   << next_bit);\n \t\t}\n-\n-\t      /* Now get the bits from the appropriate constant word.  */\n-\t      if (shift < HOST_BITS_PER_INT)\n-\t\tvalue = TREE_INT_CST_LOW (val);\n-\t      else if (shift < 2 * HOST_BITS_PER_WIDE_INT)\n-\t\t{\n-\t\t  value = TREE_INT_CST_HIGH (val);\n-\t\t  shift -= HOST_BITS_PER_WIDE_INT;\n-\t\t}\n-\t      else\n-\t\tabort ();\n-\t      byte |= ((value >> shift)\n-\t\t       & (((HOST_WIDE_INT) 1 << this_time) - 1)) << next_bit;\n-#endif\n \t      next_offset += this_time;\n \t      byte_buffer_in_use = 1;\n \t    }"}]}