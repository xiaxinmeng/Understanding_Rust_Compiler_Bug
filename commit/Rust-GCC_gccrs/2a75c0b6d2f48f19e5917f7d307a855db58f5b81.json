{"sha": "2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE3NWMwYjZkMmY0OGYxOWU1OTE3ZjdkMzA3YTg1NWRiNThmNWI4MQ==", "commit": {"author": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2005-06-28T20:06:39Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2005-06-28T20:06:39Z"}, "message": "Makefile.in: Set and use UNWIND_H.\n\n2005-06-28  Paul Brook  <paul@codesourcery.com>\n\ngcc/\n\t* Makefile.in: Set and use UNWIND_H.  Install as unwind.h.\n\t* c-decl.c (finish_decl): Call default_init_unwind_resume_libfunc.\n\t* except.c (add_ehspec_entry): Generate arm eabi filter lists.\n\t(assign_filter_values): Ditto.\n\t(output_ttype): New function.\n\t(output_function_exception_table): Use output_ttype.  Generate arm\n\teabi filter lists.\n\t(default_init_unwind_resume_libfunc): New function.\n\t* except.h (default_init_unwind_resume_libfunc): Add prototype.\n\t* optabs.c (init_optabs): Don't set unwind_resume_libfunc.\n\t* opts.c (decode_options): Use targetm.unwind_tables_default.\n\t* target-def.h (TARGET_ASM_TTYPE): Provide and use definition.\n\t(TARGET_ARM_EABI_UNWINDER, TARGET_UNWIND_TABLES_DEFAULT): Ditto.\n\t* target.h (struct gcc_target): Add asm.ttype, unwind_tables_default\n\tand arm_eabi_unwinder.\n\t* unwind-c.c: Support Arm EABI unwinder.\n\t* unwind.h: Rename ...\n\t* unwind-generic.h: ... To this.\n\t* doc/tm.texi (TARGET_ASM_TTYPE, TARGET_ARM_EABI_UNWINDER): Document.\n\t(TARGET_UNWID_TABLES_DEFAULT): Document.\n\n\t* config/arm/arm-protos.h (arm_output_fn_unwind): Add prototype.\n\t* config/arm/arm.c (arm_unwind_emit, arm_output_ttype): New functions.\n\t(TARGET_UNWIND_EMIT, TARGET_ASM_TTYPE, TARGET_ARM_EABI_UNWINDER):\n\tDefine.\n\t(thumb_pushpop, thumb_output_function_prologue): Output unwinding\n\tdirectives.\n\t(arm_unwind_emit_stm, arm_unwind_emit_set): New functions.\n\t* config/arm/arm.h (MUST_USE_SJLJ_EXCEPTIONS): Only define when\n\t!TARGET_UNWIND_INFO.\n\t(ARM_OUTPUT_FN_UNWIND, ARM_EABI_UNWIND_TABLES): Define.\n\t* config/arm/bpabi.h (TARGET_UNWIND_INFO): Define.\n\t* config/arm/elf.h (ASM_DECLARE_FUNCTION_NAME,\n\tASM_DECLARE_FUNCTION_SIZE): Use ARM_OUTPUT_FN_UNWIND.\n\t* config/arm/lib1funcs.asm: Include libunwind.S.\n\t* config/arm/libgcc-bpabi.ver: Add unwinding routines.\n\t* config/arm/libunwind.S: New file.\n\t* config/arm/pr-support.c: New file.\n\t* config/arm/t-bpabi (LIB1ASMFUNCS): Add _unwind.\n\t(UNWIND_H, LIB2ADDEH, LIB2ADDEHDEP): Set.\n\t* config/arm/t-symbian (UNWIND_H, LIB2ADDEH, LIB2ADDEHDEP): Set.\n\t* config/arm/unwind-arm.c: New file.\n\t* config/arm/unwind-arm.h: New file.\n\t* config/i386/t-netware (USER_H): Remove unwind.h.\n\t* config/ia64/ia64.h (TARGET_UNWIND_TABLES_DEFAULT): Define.\n\ngcc/cp/\n\t* Make-lang.in (cp/except.o): Depend on $(TARGET_H)\n\t* except.c: Include target.h.\n\t(init_exception_processing): Initialize unwind_resume_libfunc.\n\t* doc/tm.texi: Document TARGET_ASM_TTYPE\ngcc/ada/\n\t* misc.c (gnat_init_gcc_eh): Call default_init_unwind_resume_libfunc.\ngcc/java/\n\t* decl.c (java_init_decl_processing): Call\n\tdefault_init_unwind_resume_libfunc.\ngcc/objc/\n\t* objc-act.c (objc_init_exceptions): Call\n\tdefault_init_unwind_resume_libfunc.\nlibstdc++/\n\t* acinclude.m4 (GLIBCXX_ENABLE_SJLJ_EXCEPTIONS): Check for\n\t__cxa_end_cleanup.\n\t* libsupc++/Makefile.am (sources): Add eh_call.c and eh_arm.c.\n\t* libsupc++/eh_arm.cc: New file.\n\t* libsupc++/eh_call.cc: New file.\n\t* libsupc++/eh_catch.cc (__cxa_get_exception_ptr): Use\n\t__gxx_caught_object.\n\t(__cxa_begin_catch): Ditto. Use __is_gxx_exception_class. Call\n\t_Unwind_Complete when using the ARM EABI.\n\t(__cxa_end_catch): Use __is_gxx_exception_class.\n\t* libsupc++/eh_personality.cc: Define NO_SIZE_OF_ENCODED_VALUE when\n\tusing the ARM EABI.\n\t(save_caught_exception, restore_caught_exception): New functions.\n\t(_throw_typet): New typedef.\n\t(get_ttype_entry, get_adjusted_ptr, check_exception_spec): Add ARM\n\tEABI implementations.\n\t(PERSONALITY_FUNCTION): Use new functions.  Addd support for ARM EABI\n\tunwinding libary.\n\t(__cxa_unexpected): Disable when using the ARM EABI.\n\t* libsupc++/eh_throw.cc (__cxa_throw): Use __GXX_INIT_EXCEPTION_CLASS.\n\t(__cxa_rethrow): Use __is_gxx_exception_class.  Call\n\t_Unwind_RaiseException when using the ARM EABI.\n\t* libsupc++/unwind-cxx.h (struct __cxa_exception): Add fields for ARM\n\tEABI semantics.\n\t(struct __cxa_eh_globals): Ditto.\n\t(__cxa_call_terminate): Add prototype.\n\t(__cxa_type_match, __cxa_begin_cleanup, __cxa_end_cleanup): Add\n\tprototypes.\n\t(__get_exception_header_from_obj, __get_exception_header_from_ue):\n\tMove earlier in file.\n\t(__is_gxx_exception_class, __GXX_INIT_EXCEPTION_CLASS,\n\t__gxx_caught_object): New functions.\n\t* aclocal.m4: Regenerate.\n\t* configure: Regenerate.\n\t* Makefile.in: Regenerate.\n\t* include/Makefile.in: Regenerate.\n\t* libmath/Makefile.in: Regenerate.\n\t* libsupc++/Makefile.in: Regenerate.\n\t* po/Makefile.in: Regenerate.\n\t* src/Makefie.in: Regenerate.\n\t* testsuite/makefile.in: Regenerate.\n\nFrom-SVN: r101389", "tree": {"sha": "214e5a11650374e06cac5a8e6772f820408cecb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/214e5a11650374e06cac5a8e6772f820408cecb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/comments", "author": null, "committer": null, "parents": [{"sha": "57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57e84f1840c3da2c5c73d5c2f81a9b922957a27b"}], "stats": {"total": 1934, "additions": 1934, "deletions": 0}, "files": [{"sha": "dc8539567cdbaac48a8f4c11b6955f8e4ef81b28", "filename": "gcc/config/arm/libunwind.S", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/gcc%2Fconfig%2Farm%2Flibunwind.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/gcc%2Fconfig%2Farm%2Flibunwind.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flibunwind.S?ref=2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "patch": "@@ -0,0 +1,116 @@\n+/* Support functions for the unwinder.\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combine\n+   executable.)\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#ifdef L_unwind\n+\n+.macro UNPREFIX name\n+\t.global SYM (\\name)\n+\tEQUIV SYM (\\name), SYM (__\\name)\n+.endm\n+\n+/* r0 points to a 16-word block.  Upload these values to the actual core\n+   state.  */\n+ARM_FUNC_START restore_core_regs\n+\t/* We must use sp as the base register when restoring sp.  Push the\n+\t   last 3 registers onto the top of the current stack to achieve\n+\t   this.  */\n+\tadd r1, r0, #52\n+\tldmia r1, {r3, r4, r5}  /* {sp, lr, pc}.  */\n+#ifdef __INTERWORKING__\n+\t/* Restore pc into ip.  */\n+\tmov r2, r5\n+\tstmfd sp!, {r2, r3, r4}\n+#else\n+\tstmfd sp!, {r3, r4, r5}\n+#endif\n+\t/* Don't bother restoring ip.  */\n+\tldmia r0, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}\n+\t/* Pop the three registers we pushed earlier.  */\n+#ifdef __INTERWORKING__\n+\tldmfd sp, {ip, sp, lr}\n+\tbx ip\n+#else\n+\tldmfd sp, {sp, lr, pc}\n+#endif\n+\tFUNC_END restore_core_regs\n+\tUNPREFIX restore_core_regs\n+\n+/* Load VFP registers d0-d15 from the address in r0.  */\n+ARM_FUNC_START gnu_Unwind_Restore_VFP\n+\t/* Use the generic coprocessor form so that gas doesn't complain\n+\t   on soft-float targets.  */\n+\tldc   p11,cr0,[r0],{0x21} /* fldmiax r0, {d0-d15} */\n+\tRET\n+\n+/* Store VFR regsters d0-d15 to the address in r0.  */\n+ARM_FUNC_START gnu_Unwind_Save_VFP\n+\t/* Use the generic coprocessor form so that gas doesn't complain\n+\t   on soft-float targets.  */\n+\tstc   p11,cr0,[r0],{0x21} /* fstmiax r0, {d0-d15} */\n+\tRET\n+\n+/* Wrappers to save core registers, then call the real routine.   */\n+\n+.macro  UNWIND_WRAPPER name\n+\tARM_FUNC_START \\name\n+\t/* Create a phase2_vrs structure.  */\n+\t/* Split reg push in two to ensure the correct value for sp.  */\n+\tstmfd sp!, {sp, lr, pc}\n+\tstmfd sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}\n+\t\n+\t/* Demand-save flags, plus an extra word for alignment.  */\n+\tmov r3, #0\n+\tstmfd sp!, {r2, r3}\n+\n+\t/* Point r1 at the block.  Pass r0 unchanged.  */\n+\tadd r1, sp, #4\n+#if defined(__thumb__)\n+\t/* Switch back to thumb mode to avoid interworking hassle.  */\n+\tadr ip, .L1_\\name\n+\torr ip, ip, #1\n+\tbx ip\n+\t.thumb\n+.L1_\\name:\n+\tbl SYM (__gnu\\name) __PLT__\n+\tldr r3, [sp, #64]\n+\tadd sp, #72\n+\tbx r3\n+#else\n+\tbl SYM (__gnu\\name) __PLT__\n+\tldr lr, [sp, #64]\n+\tadd sp, sp, #72\n+\tRET\n+#endif\n+\tFUNC_END \\name\n+\tUNPREFIX \\name\n+.endm\n+\n+UNWIND_WRAPPER _Unwind_RaiseException\n+UNWIND_WRAPPER _Unwind_Resume\n+\n+#endif  /* L_unwind */"}, {"sha": "7a595531474d4ccc4c470e969119fa3af260e44c", "filename": "gcc/config/arm/pr-support.c", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/gcc%2Fconfig%2Farm%2Fpr-support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/gcc%2Fconfig%2Farm%2Fpr-support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpr-support.c?ref=2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "patch": "@@ -0,0 +1,377 @@\n+/* ARM EABI compliant unwinding routines\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+ \n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combine\n+   executable.)\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+#include \"unwind.h\"\n+\n+typedef struct _ZSt9type_info type_info; /* This names C++ type_info type */\n+\n+/* Misc constants.  */\n+#define R_IP    12\n+#define R_SP    13\n+#define R_LR    14\n+#define R_PC    15\n+\n+#define uint32_highbit (((_uw) 1) << 31)\n+\n+void __attribute__((weak)) __cxa_call_unexpected(_Unwind_Control_Block *ucbp);\n+\n+/* Unwind descriptors.  */\n+\n+typedef struct\n+{\n+  _uw16 length;\n+  _uw16 offset;\n+} EHT16;\n+\n+typedef struct\n+{\n+  _uw length;\n+  _uw offset;\n+} EHT32;\n+\n+/* Calculate the address encoded by a 31-bit self-relative offset at address\n+   P.  Copy of routine in unwind-arm.c.  */\n+\n+static inline _uw\n+selfrel_offset31 (const _uw *p)\n+{\n+  _uw offset;\n+\n+  offset = *p;\n+  /* Sign extend to 32 bits.  */\n+  if (offset & (1 << 30))\n+    offset |= 1u << 31;\n+\n+  return offset + (_uw) p;\n+}\n+\n+\n+/* Personality routine helper functions.  */\n+\n+#define CODE_FINISH (0xb0)\n+\n+/* Return the next byte of unwinding information, or CODE_FINISH if there is\n+   no data remaining.  */\n+static inline _uw8\n+next_unwind_byte (__gnu_unwind_state * uws)\n+{\n+  _uw8 b;\n+\n+  if (uws->bytes_left == 0)\n+    {\n+      /* Load another word */\n+      if (uws->words_left == 0)\n+\treturn CODE_FINISH; /* Nothing left.  */\n+      uws->words_left--;\n+      uws->data = *(uws->next++);\n+      uws->bytes_left = 3;\n+    }\n+  else\n+    uws->bytes_left--;\n+\n+  /* Extract the most significant byte.  */\n+  b = (uws->data >> 24) & 0xff;\n+  uws->data <<= 8;\n+  return b;\n+}\n+\n+/* Execute the unwinding instructions described by UWS.  */\n+_Unwind_Reason_Code\n+__gnu_unwind_execute (_Unwind_Context * context, __gnu_unwind_state * uws)\n+{\n+  _uw op;\n+  int set_pc;\n+  _uw reg;\n+\n+  set_pc = 0;\n+  for (;;)\n+    {\n+      op = next_unwind_byte (uws);\n+      if (op == CODE_FINISH)\n+\t{\n+\t  /* If we haven't already set pc then copy it from lr.  */\n+\t  if (!set_pc)\n+\t    {\n+\t      _Unwind_VRS_Get (context, _UVRSC_CORE, R_LR, _UVRSD_UINT32,\n+\t\t\t       &reg);\n+\t      _Unwind_VRS_Set (context, _UVRSC_CORE, R_PC, _UVRSD_UINT32,\n+\t\t\t       &reg);\n+\t      set_pc = 1;\n+\t    }\n+\t  /* Drop out of the loop.  */\n+\t  break;\n+\t}\n+      if ((op & 0x80) == 0)\n+\t{\n+\t  /* vsp = vsp +- (imm6 << 2 + 4).  */\n+\t  _uw offset;\n+\n+\t  offset = ((op & 0x3f) << 2) + 4;\n+\t  _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &reg);\n+\t  if (op & 0x40)\n+\t    reg -= offset;\n+\t  else\n+\t    reg += offset;\n+\t  _Unwind_VRS_Set (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &reg);\n+\t  continue;\n+\t}\n+      \n+      if ((op & 0xf0) == 0x80)\n+\t{\n+\t  op = (op << 8) | next_unwind_byte (uws);\n+\t  if (op == 0x8000)\n+\t    {\n+\t      /* Refuse to unwind.  */\n+\t      return _URC_FAILURE;\n+\t    }\n+\t  /* Pop r4-r15 under mask.  */\n+\t  op = (op << 4) & 0xfff0;\n+\t  if (_Unwind_VRS_Pop (context, _UVRSC_CORE, op, _UVRSD_UINT32)\n+\t      != _UVRSR_OK)\n+\t    return _URC_FAILURE;\n+\t  if (op & (1 << R_PC))\n+\t    set_pc = 1;\n+\t  continue;\n+\t}\n+      if ((op & 0xf0) == 0x90)\n+\t{\n+\t  op &= 0xf;\n+\t  if (op == 13 || op == 15)\n+\t    /* Reserved.  */\n+\t    return _URC_FAILURE;\n+\t  /* vsp = r[nnnn].  */\n+\t  _Unwind_VRS_Get (context, _UVRSC_CORE, op, _UVRSD_UINT32, &reg);\n+\t  _Unwind_VRS_Set (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32, &reg);\n+\t  continue;\n+\t}\n+      if ((op & 0xf0) == 0xa0)\n+\t{\n+\t  /* Pop r4-r[4+nnn], [lr].  */\n+\t  _uw mask;\n+\t  \n+\t  mask = (0xff0 >> (7 - (op & 7))) & 0xff0;\n+\t  if (op & 8)\n+\t    mask |= (1 << R_LR);\n+\t  if (_Unwind_VRS_Pop (context, _UVRSC_CORE, mask, _UVRSD_UINT32)\n+\t      != _UVRSR_OK)\n+\t    return _URC_FAILURE;\n+\t  continue;\n+\t}\n+      if ((op & 0xf0) == 0xb0)\n+\t{\n+\t  /* op == 0xb0 already handled.  */\n+\t  if (op == 0xb1)\n+\t    {\n+\t      op = next_unwind_byte (uws);\n+\t      if (op == 0 || ((op & 0xf0) != 0))\n+\t\t/* Spare.  */\n+\t\treturn _URC_FAILURE;\n+\t      /* Pop r0-r4 under mask.  */\n+\t      if (_Unwind_VRS_Pop (context, _UVRSC_CORE, op, _UVRSD_UINT32)\n+\t\t  != _UVRSR_OK)\n+\t\treturn _URC_FAILURE;\n+\t      continue;\n+\t    }\n+\t  if (op == 0xb2)\n+\t    {\n+\t      /* vsp = vsp + 0x204 + (uleb128 << 2).  */\n+\t      int shift;\n+\n+\t      _Unwind_VRS_Get (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32,\n+\t\t\t       &reg);\n+\t      op = next_unwind_byte (uws);\n+\t      shift = 2;\n+\t      while (op & 0x80)\n+\t\t{\n+\t\t  reg += ((op & 0x7f) << shift);\n+\t\t  shift += 7;\n+\t\t  op = next_unwind_byte (uws);\n+\t\t}\n+\t      reg += ((op & 0x7f) << shift) + 0x204;\n+\t      _Unwind_VRS_Set (context, _UVRSC_CORE, R_SP, _UVRSD_UINT32,\n+\t\t\t       &reg);\n+\t      continue;\n+\t    }\n+\t  if (op == 0xb3)\n+\t    {\n+\t      /* Pop VFP registers with fldmx.  */\n+\t      op = next_unwind_byte (uws);\n+\t      op = ((op & 0xf0) << 12) | (op & 0xf);\n+\t      if (_Unwind_VRS_Pop (context, _UVRSC_VFP, op, _UVRSD_VFPX)\n+\t\t  != _UVRSR_OK)\n+\t\treturn _URC_FAILURE;\n+\t      continue;\n+\t    }\n+\t  if ((op & 0xfc) == 0xb4)\n+\t    {\n+\t      /* Pop FPA E[4]-E[4+nn].  */\n+\t      op = 0x40000 | ((op & 3) + 1);\n+\t      if (_Unwind_VRS_Pop (context, _UVRSC_FPA, op, _UVRSD_FPAX)\n+\t\t  != _UVRSR_OK)\n+\t\treturn _URC_FAILURE;\n+\t      continue;\n+\t    }\n+\t  /* op & 0xf8 == 0xb8.  */\n+\t  /* Pop VFP D[8]-D[8+nnn] with fldmx.  */\n+\t  op = 0x80000 | ((op & 7) + 1);\n+\t  if (_Unwind_VRS_Pop (context, _UVRSC_VFP, op, _UVRSD_VFPX)\n+\t      != _UVRSR_OK)\n+\t    return _URC_FAILURE;\n+\t  continue;\n+\t}\n+      if ((op & 0xf0) == 0xc0)\n+\t{\n+\t  if (op == 0xc6)\n+\t    {\n+\t      /* Pop iWMMXt D registers.  */\n+\t      op = next_unwind_byte (uws);\n+\t      op = ((op & 0xf0) << 12) | (op & 0xf);\n+\t      if (_Unwind_VRS_Pop (context, _UVRSC_WMMXD, op, _UVRSD_UINT64)\n+\t\t  != _UVRSR_OK)\n+\t\treturn _URC_FAILURE;\n+\t      continue;\n+\t    }\n+\t  if (op == 0xc7)\n+\t    {\n+\t      op = next_unwind_byte (uws);\n+\t      if (op == 0 || (op & 0xf0) != 0)\n+\t\t/* Spare.  */\n+\t\treturn _URC_FAILURE;\n+\t      /* Pop iWMMXt wCGR{3,2,1,0} under mask.  */\n+\t      if (_Unwind_VRS_Pop (context, _UVRSC_WMMXC, op, _UVRSD_UINT32)\n+\t\t  != _UVRSR_OK)\n+\t\treturn _URC_FAILURE;\n+\t      continue;\n+\t    }\n+\t  if ((op & 0xf8) == 0xc0)\n+\t    {\n+\t      /* Pop iWMMXt wR[10]-wR[10+nnn].  */\n+\t      op = 0xa0000 | ((op & 0xf) + 1);\n+\t      if (_Unwind_VRS_Pop (context, _UVRSC_WMMXD, op, _UVRSD_UINT64)\n+\t\t  != _UVRSR_OK)\n+\t\treturn _URC_FAILURE;\n+\t      continue;\n+\t    }\n+\t  if (op == 0xc8)\n+\t    {\n+\t      /* Pop FPA registers.  */\n+\t      op = next_unwind_byte (uws);\n+\t      op = ((op & 0xf0) << 12) | (op & 0xf);\n+\t      if (_Unwind_VRS_Pop (context, _UVRSC_FPA, op, _UVRSD_FPAX)\n+\t\t  != _UVRSR_OK)\n+\t\treturn _URC_FAILURE;\n+\t      continue;\n+\t    }\n+\t  if (op == 0xc9)\n+\t    {\n+\t      /* Pop VFP registers with fldmd.  */\n+\t      op = next_unwind_byte (uws);\n+\t      op = ((op & 0xf0) << 12) | (op & 0xf);\n+\t      if (_Unwind_VRS_Pop (context, _UVRSC_VFP, op, _UVRSD_DOUBLE)\n+\t\t  != _UVRSR_OK)\n+\t\treturn _URC_FAILURE;\n+\t      continue;\n+\t    }\n+\t  /* Spare.  */\n+\t  return _URC_FAILURE;\n+\t}\n+      if ((op & 0xf8) == 0xd0)\n+\t{\n+\t  /* Pop VFP D[8]-D[8+nnn] with fldmd.  */\n+\t  op = 0x80000 | ((op & 7) + 1);\n+\t  if (_Unwind_VRS_Pop (context, _UVRSC_VFP, op, _UVRSD_DOUBLE)\n+\t      != _UVRSR_OK)\n+\t    return _URC_FAILURE;\n+\t  continue;\n+\t}\n+      /* Spare.  */\n+      return _URC_FAILURE;\n+    }\n+  return _URC_OK;\n+}\n+\n+\n+/* Execute the unwinding instructions associated with a frame.  UCBP and\n+   CONTEXT are the current exception object and virtual CPU state\n+   respectively.  */\n+\n+_Unwind_Reason_Code\n+__gnu_unwind_frame (_Unwind_Control_Block * ucbp, _Unwind_Context * context)\n+{\n+  _uw *ptr;\n+  __gnu_unwind_state uws;\n+\n+  ptr = (_uw *) ucbp->pr_cache.ehtp;\n+  /* Skip over the personality routine address.  */\n+  ptr++;\n+  /* Setup the unwinder state.  */\n+  uws.data = (*ptr) << 8;\n+  uws.next = ptr + 1;\n+  uws.bytes_left = 3;\n+  uws.words_left = ((*ptr) >> 24) & 0xff;\n+\n+  return __gnu_unwind_execute (context, &uws);\n+}\n+\n+/* Get the _Unwind_Control_Block from an _Unwind_Context.  */\n+\n+static inline _Unwind_Control_Block *\n+unwind_UCB_from_context (_Unwind_Context * context)\n+{\n+  return (_Unwind_Control_Block *) _Unwind_GetGR (context, R_IP);\n+}\n+\n+/* Get the start address of the function being unwound.  */\n+\n+_Unwind_Ptr\n+_Unwind_GetRegionStart (_Unwind_Context * context)\n+{\n+  _Unwind_Control_Block *ucbp;\n+\n+  ucbp = unwind_UCB_from_context (context);\n+  return (_Unwind_Ptr) ucbp->pr_cache.fnstart;\n+}\n+\n+/* Find the Language specific exception data.  */\n+\n+void *\n+_Unwind_GetLanguageSpecificData (_Unwind_Context * context)\n+{\n+  _Unwind_Control_Block *ucbp;\n+  _uw *ptr;\n+\n+  /* Get a pointer to the exception table entry.  */\n+  ucbp = unwind_UCB_from_context (context);\n+  ptr = (_uw *) ucbp->pr_cache.ehtp;\n+  /* Skip the personality routine address.  */\n+  ptr++;\n+  /* Skip the unwind opcodes.  */\n+  ptr += (((*ptr) >> 24) & 0xff) + 1;\n+\n+  return ptr;\n+}\n+"}, {"sha": "3199d11f14aa48dd3c196a6bc20702b0a1bb88b6", "filename": "gcc/config/arm/unwind-arm.c", "status": "added", "additions": 855, "deletions": 0, "changes": 855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/gcc%2Fconfig%2Farm%2Funwind-arm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/gcc%2Fconfig%2Farm%2Funwind-arm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funwind-arm.c?ref=2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "patch": "@@ -0,0 +1,855 @@\n+/* ARM EABI compliant unwinding routines.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combine\n+   executable.)\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+#include \"unwind.h\"\n+\n+/* Definitions for C++ runtime support routines.  We make these weak\n+   declarations to avoid pulling in libsupc++ unneccesarily.  */\n+typedef unsigned char bool;\n+\n+typedef struct _ZSt9type_info type_info; /* This names C++ type_info type */\n+\n+void __attribute__((weak)) __cxa_call_unexpected(_Unwind_Control_Block *ucbp);\n+bool __attribute__((weak)) __cxa_begin_cleanup(_Unwind_Control_Block *ucbp);\n+bool __attribute__((weak)) __cxa_type_match(_Unwind_Control_Block *ucbp,\n+\t\t\t\t\t    const type_info *rttip,\n+\t\t\t\t\t    void **matched_object);\n+\n+_Unwind_Ptr __attribute__((weak))\n+__gnu_Unwind_Find_exidx (_Unwind_Ptr, int *);\n+\n+/* Misc constants.  */\n+#define R_IP\t12\n+#define R_SP\t13\n+#define R_LR\t14\n+#define R_PC\t15\n+\n+#define EXIDX_CANTUNWIND 1\n+#define uint32_highbit (((_uw) 1) << 31)\n+\n+#define UCB_PR_ADDR(ucbp) ((ucbp)->unwinder_cache.reserved2)\n+#define UCB_SAVED_CALLSITE_ADDR(ucbp) ((ucbp)->unwinder_cache.reserved3)\n+\n+struct core_regs\n+{\n+  _uw r[16];\n+};\n+\n+/* We use normal integer types here to avoid the compiler generating\n+   coprocessor instructions.  */\n+struct vfp_regs\n+{\n+  _uw64 d[16];\n+  _uw pad;\n+};\n+\n+struct fpa_reg\n+{\n+  _uw w[3];\n+};\n+\n+struct fpa_regs\n+{\n+  struct fpa_reg f[8];\n+};\n+\n+/* Unwind descriptors.  */\n+\n+typedef struct\n+{\n+  _uw16 length;\n+  _uw16 offset;\n+} EHT16;\n+\n+typedef struct\n+{\n+  _uw length;\n+  _uw offset;\n+} EHT32;\n+\n+/* The ABI specifies that the unwind routines may only use core registers,\n+   except when actually manipulating coprocessor state.  This allows\n+   us to write one implementation that works on all platforms by\n+   demand-saving coprocessor registers.\n+\n+   During unwinding we hold the coprocessor state in the actual hardware\n+   registers and allocate demand-save areas for use during phase1\n+   unwinding.  */\n+\n+typedef struct\n+{\n+  /* The first fields must be the same as a phase2_vrs.  */\n+  _uw demand_save_flags;\n+  struct core_regs core;\n+  struct vfp_regs vfp;\n+  struct fpa_regs fpa;\n+} phase1_vrs;\n+\n+#define DEMAND_SAVE_VFP 1\n+\n+/* This must match the structure created by the assembly wrappers.  */\n+typedef struct\n+{\n+  _uw demand_save_flags;\n+  struct core_regs core;\n+} phase2_vrs;\n+\n+\n+/* An exeption index table entry.  */\n+\n+typedef struct __EIT_entry\n+{\n+  _uw fnoffset;\n+  _uw content;\n+} __EIT_entry;\n+\n+/* Assembly helper functions.  */\n+\n+/* Restore core register state.  Never returns.  */\n+void __attribute__((noreturn)) restore_core_regs (struct core_regs *);\n+\n+\n+/* Coprocessor register state manipulation functions.  */\n+\n+void __gnu_Unwind_Save_VFP (struct vfp_regs * p);\n+void __gnu_Unwind_Restore_VFP (struct vfp_regs * p);\n+\n+/* Restore coprocessor state after phase1 unwinding.  */\n+static void\n+restore_non_core_regs (phase1_vrs * vrs)\n+{\n+  if ((vrs->demand_save_flags & DEMAND_SAVE_VFP) == 0)\n+    __gnu_Unwind_Restore_VFP (&vrs->vfp);\n+}\n+\n+/* A better way to do this would probably be to compare the absolute address\n+   with a segment relative relocation of the same symbol.  */\n+\n+extern int __text_start;\n+extern int __data_start;\n+\n+/* The exception index table location.  */\n+extern __EIT_entry __exidx_start;\n+extern __EIT_entry __exidx_end;\n+\n+/* ABI defined personality routines.  */\n+extern _Unwind_Reason_Code __aeabi_unwind_cpp_pr0 (_Unwind_State,\n+    _Unwind_Control_Block *, _Unwind_Context *);// __attribute__((weak));\n+extern _Unwind_Reason_Code __aeabi_unwind_cpp_pr1 (_Unwind_State,\n+    _Unwind_Control_Block *, _Unwind_Context *) __attribute__((weak));\n+extern _Unwind_Reason_Code __aeabi_unwind_cpp_pr2 (_Unwind_State,\n+    _Unwind_Control_Block *, _Unwind_Context *) __attribute__((weak));\n+\n+/* ABI defined routine to store a virtual register to memory.  */\n+\n+_Unwind_VRS_Result _Unwind_VRS_Get (_Unwind_Context *context,\n+\t\t\t\t    _Unwind_VRS_RegClass regclass,\n+\t\t\t\t    _uw regno,\n+\t\t\t\t    _Unwind_VRS_DataRepresentation representation,\n+\t\t\t\t    void *valuep)\n+{\n+  phase1_vrs *vrs = (phase1_vrs *) context;\n+\n+  switch (regclass)\n+    {\n+    case _UVRSC_CORE:\n+      if (representation != _UVRSD_UINT32\n+\t  || regno > 15)\n+\treturn _UVRSR_FAILED;\n+      *(_uw *) valuep = vrs->core.r[regno];\n+      return _UVRSR_OK;\n+\n+    case _UVRSC_VFP:\n+    case _UVRSC_FPA:\n+    case _UVRSC_WMMXD:\n+    case _UVRSC_WMMXC:\n+      return _UVRSR_NOT_IMPLEMENTED;\n+\n+    default:\n+      return _UVRSR_FAILED;\n+    }\n+}\n+\n+\n+/* ABI defined function to load a virtual register from memory.  */\n+\n+_Unwind_VRS_Result _Unwind_VRS_Set (_Unwind_Context *context,\n+\t\t\t\t    _Unwind_VRS_RegClass regclass,\n+\t\t\t\t    _uw regno,\n+\t\t\t\t    _Unwind_VRS_DataRepresentation representation,\n+\t\t\t\t    void *valuep)\n+{\n+  phase1_vrs *vrs = (phase1_vrs *) context;\n+\n+  switch (regclass)\n+    {\n+    case _UVRSC_CORE:\n+      if (representation != _UVRSD_UINT32\n+\t  || regno > 15)\n+\treturn _UVRSR_FAILED;\n+\n+      vrs->core.r[regno] = *(_uw *) valuep;\n+      return _UVRSR_OK;\n+\n+    case _UVRSC_VFP:\n+    case _UVRSC_FPA:\n+    case _UVRSC_WMMXD:\n+    case _UVRSC_WMMXC:\n+      return _UVRSR_NOT_IMPLEMENTED;\n+\n+    default:\n+      return _UVRSR_FAILED;\n+    }\n+}\n+\n+\n+/* ABI defined function to pop registers off the stack.  */\n+\n+_Unwind_VRS_Result _Unwind_VRS_Pop (_Unwind_Context *context,\n+\t\t\t\t    _Unwind_VRS_RegClass regclass,\n+\t\t\t\t    _uw discriminator,\n+\t\t\t\t    _Unwind_VRS_DataRepresentation representation)\n+{\n+  phase1_vrs *vrs = (phase1_vrs *) context;\n+\n+  switch (regclass)\n+    {\n+    case _UVRSC_CORE:\n+      {\n+\t_uw *ptr;\n+\t_uw mask;\n+\tint i;\n+\n+\tif (representation != _UVRSD_UINT32)\n+\t  return _UVRSR_FAILED;\n+\n+\tmask = discriminator & 0xffff;\n+\tptr = (_uw *) vrs->core.r[R_SP];\n+\t/* Pop the requested registers.  */\n+\tfor (i = 0; i < 16; i++)\n+\t  {\n+\t    if (mask & (1 << i))\n+\t      vrs->core.r[i] = *(ptr++);\n+\t  }\n+\t/* Writeback the stack pointer value if it wasn't restored.  */\n+\tif ((mask & (1 << R_SP)) == 0)\n+\t  vrs->core.r[R_SP] = (_uw) ptr;\n+      }\n+      return _UVRSR_OK;\n+\n+    case _UVRSC_VFP:\n+      {\n+\t_uw start = discriminator >> 16;\n+\t_uw count = discriminator & 0xffff;\n+\tstruct vfp_regs tmp;\n+\t_uw *sp;\n+\t_uw *dest;\n+\n+\tif ((representation != _UVRSD_VFPX && representation != _UVRSD_DOUBLE)\n+\t    || start + count > 16)\n+\t  return _UVRSR_FAILED;\n+\n+\tif (vrs->demand_save_flags & DEMAND_SAVE_VFP)\n+\t  {\n+\t    /* Demand-save resisters for stage1.  */\n+\t    vrs->demand_save_flags &= ~DEMAND_SAVE_VFP;\n+\t    __gnu_Unwind_Save_VFP (&vrs->vfp);\n+\t  }\n+\n+\t/* Restore the registers from the stack.  Do this by saving the\n+\t   current VFP registers to a memory area, moving the in-memory\n+\t   values into that area, and restoring from the whole area.\n+\t   For _UVRSD_VFPX we assume FSTMX standard format 1.  */\n+\t__gnu_Unwind_Save_VFP (&tmp);\n+\n+\t/* The stack address is only guaranteed to be word aligned, so\n+\t   we can't use doubleword copies.  */\n+\tsp = (_uw *) vrs->core.r[R_SP];\n+\tdest = (_uw *) &tmp.d[start];\n+\tcount *= 2;\n+\twhile (count--)\n+\t  *(dest++) = *(sp++);\n+\n+\t/* Skip the pad word */\n+\tif (representation == _UVRSD_VFPX)\n+\t  sp++;\n+\n+\t/* Set the new stack pointer.  */\n+\tvrs->core.r[R_SP] = (_uw) sp;\n+\n+\t/* Reload the registers.  */\n+\t__gnu_Unwind_Restore_VFP (&tmp);\n+      }\n+      return _UVRSR_OK;\n+\n+    case _UVRSC_FPA:\n+    case _UVRSC_WMMXD:\n+    case _UVRSC_WMMXC:\n+      return _UVRSR_NOT_IMPLEMENTED;\n+\n+    default:\n+      return _UVRSR_FAILED;\n+    }\n+}\n+\n+\n+/* Core unwinding functions.  */\n+\n+/* Calculate the address encoded by a 31-bit self-relative offset at address\n+   P.  */\n+static inline _uw\n+selfrel_offset31 (const _uw *p)\n+{\n+  _uw offset;\n+\n+  offset = *p;\n+  /* Sign extend to 32 bits.  */\n+  if (offset & (1 << 30))\n+    offset |= 1u << 31;\n+\n+  return offset + (_uw) p;\n+}\n+\n+\n+/* Perform a binary search for RETURN_ADDRESS in TABLE.  The table contains\n+   NREC entries.  */\n+\n+static const __EIT_entry *\n+search_EIT_table (const __EIT_entry * table, int nrec, _uw return_address)\n+{\n+  _uw next_fn;\n+  _uw this_fn;\n+  int n, left, right;\n+\n+  if (nrec == 0)\n+    return (__EIT_entry *) 0;\n+\n+  left = 0;\n+  right = nrec - 1;\n+\n+  while (1)\n+    {\n+      n = (left + right) / 2;\n+      this_fn = selfrel_offset31 (&table[n].fnoffset);\n+      if (n != nrec - 1)\n+\tnext_fn = selfrel_offset31 (&table[n + 1].fnoffset);\n+      else\n+\tnext_fn = ~(_uw) 0;\n+\n+      if (return_address < this_fn)\n+\t{\n+\t  if (n == left)\n+\t    return (__EIT_entry *) 0;\n+\t  right = n - 1;\n+\t}\n+      else if (return_address < next_fn)\n+\treturn &table[n];\n+      else\n+\tleft = n + 1;\n+    }\n+}\n+\n+/* Find the exception index table eintry for the given address.\n+   Fill in the relevant fields of the UCB.\n+   Returns _URC_FAILURE if an error occured, _URC_OK on success*/\n+\n+static _Unwind_Reason_Code\n+get_eit_entry (_Unwind_Control_Block *ucbp, _uw return_address)\n+{\n+  const __EIT_entry * eitp;\n+  int nrec;\n+  \n+  /* The return address is the address of the instruction following the\n+     call instruction (plus one in thumb mode).  If this was the last\n+     instruction in the function the address will lie in the following\n+     function.  Subtract 2 from the address so that it points within the call\n+     instruction itself.  */\n+  return_address -= 2;\n+\n+  if (__gnu_Unwind_Find_exidx)\n+    {\n+      eitp = (const __EIT_entry *) __gnu_Unwind_Find_exidx (return_address,\n+\t\t\t\t\t\t\t    &nrec);\n+      if (!eitp)\n+\t{\n+\t  UCB_PR_ADDR (ucbp) = 0;\n+\t  return _URC_FAILURE;\n+\t}\n+    }\n+  else\n+    {\n+      eitp = &__exidx_start;\n+      nrec = &__exidx_end - &__exidx_start;\n+    }\n+\n+  eitp = search_EIT_table (eitp, nrec, return_address);\n+\n+  if (!eitp)\n+    {\n+      UCB_PR_ADDR (ucbp) = 0;\n+      return _URC_FAILURE;\n+    }\n+  ucbp->pr_cache.fnstart = selfrel_offset31 (&eitp->fnoffset);\n+\n+  /* Can this frame be unwound at all?  */\n+  if (eitp->content == EXIDX_CANTUNWIND)\n+    {\n+      UCB_PR_ADDR (ucbp) = 0;\n+      return _URC_FAILURE;\n+    }\n+\n+  /* Obtain the address of the \"real\" __EHT_Header word.  */\n+\n+  if (eitp->content & uint32_highbit)\n+    {\n+      /* It is immediate data.  */\n+      ucbp->pr_cache.ehtp = (_Unwind_EHT_Header *)&eitp->content;\n+      ucbp->pr_cache.additional = 1;\n+    }\n+  else\n+    {\n+      /* The low 31 bits of the content field are a self-relative\n+\t offset to an _Unwind_EHT_Entry structure.  */\n+      ucbp->pr_cache.ehtp =\n+\t(_Unwind_EHT_Header *) selfrel_offset31 (&eitp->content);\n+      ucbp->pr_cache.additional = 0;\n+    }\n+\n+  /* Discover the personality routine address.  */\n+  if (*ucbp->pr_cache.ehtp & (1u << 31))\n+    {\n+      /* One of the predefined standard routines.  */\n+      _uw idx = (*(_uw *) ucbp->pr_cache.ehtp >> 24) & 0xf;\n+      if (idx == 0)\n+\tUCB_PR_ADDR (ucbp) = (_uw) &__aeabi_unwind_cpp_pr0;\n+      else if (idx == 1)\n+\tUCB_PR_ADDR (ucbp) = (_uw) &__aeabi_unwind_cpp_pr1;\n+      else if (idx == 2)\n+\tUCB_PR_ADDR (ucbp) = (_uw) &__aeabi_unwind_cpp_pr2;\n+      else\n+\t{ /* Failed */\n+\t  UCB_PR_ADDR (ucbp) = 0;\n+\t  return _URC_FAILURE;\n+\t}\n+    } \n+  else\n+    {\n+      /* Execute region offset to PR */\n+      UCB_PR_ADDR (ucbp) = selfrel_offset31 (ucbp->pr_cache.ehtp);\n+    }\n+  return _URC_OK;\n+}\n+\n+\n+/* Perform phase2 unwinding.  VRS is the initial virtual register state.  */\n+\n+static void __attribute__((noreturn))\n+unwind_phase2 (_Unwind_Control_Block * ucbp, phase2_vrs * vrs)\n+{\n+  _Unwind_Reason_Code pr_result;\n+\n+  for(;;)\n+    {\n+      /* Find the entry for this routine.  */\n+      if (get_eit_entry (ucbp, vrs->core.r[R_PC]) != _URC_OK)\n+\tabort ();\n+\n+      UCB_SAVED_CALLSITE_ADDR (ucbp) = vrs->core.r[R_PC];\n+      \n+      /* Call the pr to decide what to do.  */\n+      pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n+\t(_US_UNWIND_FRAME_STARTING, ucbp, (_Unwind_Context *) vrs);\n+\n+      if (pr_result != _URC_CONTINUE_UNWIND)\n+\tbreak;\n+    }\n+  \n+  if (pr_result != _URC_INSTALL_CONTEXT)\n+    abort();\n+  \n+  restore_core_regs (&vrs->core);\n+}\n+\n+/* Perform phase1 unwinding.  UCBP is the exception being thrown, and\n+   entry_VRS is the register state on entry to _Unwind_RaiseException.  */\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_RaiseException (_Unwind_Control_Block *, phase2_vrs *);\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_RaiseException (_Unwind_Control_Block * ucbp,\n+\t\t\t     phase2_vrs * entry_vrs)\n+{\n+  phase1_vrs saved_vrs;\n+  _Unwind_Reason_Code pr_result;\n+\n+  /* Set the pc to the call site.  */\n+  entry_vrs->core.r[R_PC] = entry_vrs->core.r[R_LR];\n+\n+  /* Save the core registers.  */\n+  saved_vrs.core = entry_vrs->core;\n+  /* Set demand-save flags.  */\n+  saved_vrs.demand_save_flags = ~(_uw) 0;\n+  \n+  /* Unwind until we reach a propagation barrier.  */\n+  for (;;)\n+    {\n+      /* Find the entry for this routine.  */\n+      if (get_eit_entry (ucbp, saved_vrs.core.r[R_PC]) != _URC_OK)\n+\treturn _URC_FAILURE;\n+\n+      /* Call the pr to decide what to do.  */\n+      pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n+\t(_US_VIRTUAL_UNWIND_FRAME, ucbp, (void *) &saved_vrs);\n+\n+      if (pr_result != _URC_CONTINUE_UNWIND)\n+\tbreak;\n+    }\n+\n+  /* We've unwound as far as we want to go, so restore the original\n+     register state.  */\n+  restore_non_core_regs (&saved_vrs);\n+  if (pr_result != _URC_HANDLER_FOUND)\n+    {\n+      /* Some sort of failure has occurred in the pr and probably the\n+\t pr returned _URC_FAILURE.  */\n+      return _URC_FAILURE;\n+    }\n+  \n+  unwind_phase2 (ucbp, entry_vrs);\n+}\n+\n+/* Resume unwinding after a cleanup has been run.  UCBP is the exception\n+   being thrown and ENTRY_VRS is the register state on entry to\n+   _Unwind_Resume.  */\n+_Unwind_Reason_Code\n+__gnu_Unwind_Resume (_Unwind_Control_Block *, phase2_vrs *);\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_Resume (_Unwind_Control_Block * ucbp, phase2_vrs * entry_vrs)\n+{\n+  _Unwind_Reason_Code pr_result;\n+\n+  /* Recover the saved address.  */\n+  entry_vrs->core.r[R_PC] = UCB_SAVED_CALLSITE_ADDR (ucbp);\n+  \n+  /* Call the cached PR.  */\n+  pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n+\t(_US_UNWIND_FRAME_RESUME, ucbp, (_Unwind_Context *) entry_vrs);\n+\n+  switch (pr_result)\n+    {\n+    case _URC_INSTALL_CONTEXT:\n+      /* Upload the registers to enter the landing pad.  */\n+      restore_core_regs (&entry_vrs->core);\n+\n+    case _URC_CONTINUE_UNWIND:\n+      /* Continue unwinding the next frame.  */\n+      unwind_phase2 (ucbp, entry_vrs);\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Clean up an exception object when unwinding is complete.  */\n+void\n+_Unwind_Complete (_Unwind_Control_Block * ucbp __attribute__((unused)))\n+{\n+}\n+\n+\n+/* Get the _Unwind_Control_Block from an _Unwind_Context.  */\n+\n+static inline _Unwind_Control_Block *\n+unwind_UCB_from_context (_Unwind_Context * context)\n+{\n+  return (_Unwind_Control_Block *) _Unwind_GetGR (context, R_IP);\n+}\n+\n+\n+/* Free an exception.  */\n+\n+void\n+_Unwind_DeleteException (_Unwind_Exception * exc)\n+{\n+  if (exc->exception_cleanup)\n+    (*exc->exception_cleanup) (_URC_FOREIGN_EXCEPTION_CAUGHT, exc);\n+}\n+\n+\n+/* Common implementation for ARM ABI defined personality routines.\n+   ID is the index of the personality routine, other arguments are as defined\n+   by __aeabi_unwind_cpp_pr{0,1,2}.  */\n+\n+static _Unwind_Reason_Code\n+__gnu_unwind_pr_common (_Unwind_State state,\n+\t\t\t_Unwind_Control_Block *ucbp,\n+\t\t\t_Unwind_Context *context,\n+\t\t\tint id)\n+{\n+  __gnu_unwind_state uws;\n+  _uw *data;\n+  _uw offset;\n+  _uw len;\n+  _uw rtti_count;\n+  int phase2_call_unexpected_after_unwind = 0;\n+  int in_range = 0;\n+\n+  data = (_uw *) ucbp->pr_cache.ehtp;\n+  uws.data = *(data++);\n+  uws.next = data;\n+  if (id == 0)\n+    {\n+      uws.data <<= 8;\n+      uws.words_left = 0;\n+      uws.bytes_left = 3;\n+    }\n+  else\n+    {\n+      uws.words_left = (uws.data >> 16) & 0xff;\n+      uws.data <<= 16;\n+      uws.bytes_left = 2;\n+      data += uws.words_left;\n+    }\n+\n+  /* Restore the saved pointer.  */\n+  if (state == _US_UNWIND_FRAME_RESUME)\n+    data = (_uw *) ucbp->cleanup_cache.bitpattern[0];\n+\n+  if ((ucbp->pr_cache.additional & 1) == 0)\n+    {\n+      /* Process descriptors.  */\n+      while (*data)\n+\t{\n+\t  _uw addr;\n+\t  _uw fnstart;\n+\n+\t  if (id == 2)\n+\t    {\n+\t      len = ((EHT32 *) data)->length;\n+\t      offset = ((EHT32 *) data)->offset;\n+\t      data += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      len = ((EHT16 *) data)->length;\n+\t      offset = ((EHT16 *) data)->offset;\n+\t      data++;\n+\t    }\n+\n+\t  fnstart = ucbp->pr_cache.fnstart + (offset & ~1);\n+\t  addr = _Unwind_GetGR (context, R_PC);\n+\t  in_range = (fnstart <= addr && addr < fnstart + (len & ~1));\n+\n+\t  switch (((offset & 1) << 1) | (len & 1))\n+\t    {\n+\t    case 0:\n+\t      /* Cleanup.  */\n+\t      if (state != _US_VIRTUAL_UNWIND_FRAME\n+\t\t  && in_range)\n+\t\t{\n+\t\t  /* Cleanup in range, and we are running cleanups.  */\n+\t\t  _uw lp;\n+\n+\t\t  /* Landing pad address is 31-bit pc-relatvie offset.  */\n+\t\t  lp = selfrel_offset31 (data);\n+\t\t  data++;\n+\t\t  /* Save the exception data pointer.  */\n+\t\t  ucbp->cleanup_cache.bitpattern[0] = (_uw) data;\n+\t\t  if (!__cxa_begin_cleanup (ucbp))\n+\t\t    return _URC_FAILURE;\n+\t\t  /* Setup the VRS to enter the landing pad.  */\n+\t\t  _Unwind_SetGR (context, R_PC, lp);\n+\t\t  return _URC_INSTALL_CONTEXT;\n+\t\t}\n+\t      /* Cleanup not in range, or we are in stage 1.  */\n+\t      data++;\n+\t      break;\n+\n+\t    case 1:\n+\t      /* Catch handler.  */\n+\t      if (state == _US_VIRTUAL_UNWIND_FRAME)\n+\t\t{\n+\t\t  if (in_range)\n+\t\t    {\n+\t\t      /* Check for a barrier.  */\n+\t\t      _uw rtti;\n+\t\t      void *matched;\n+\n+\t\t      /* Check for no-throw areas.  */\n+\t\t      if (data[1] == (_uw) -2)\n+\t\t\treturn _URC_FAILURE;\n+\n+\t\t      /* The thrown object immediately folows the ECB.  */\n+\t\t      matched = (void *)(ucbp + 1);\n+\t\t      if (data[1] != (_uw) -1)\n+\t\t\t{\n+\t\t\t  /* Match a catch specification.  */\n+\t\t\t  rtti = _Unwind_decode_target2 ((_uw) &data[1]);\n+\t\t\t  if (!__cxa_type_match (ucbp, (type_info *) rtti,\n+\t\t\t\t\t\t &matched))\n+\t\t\t    matched = (void *)0;\n+\t\t\t}\n+\n+\t\t      if (matched)\n+\t\t\t{\n+\t\t\t  ucbp->barrier_cache.sp =\n+\t\t\t    _Unwind_GetGR (context, R_SP);\n+\t\t\t  ucbp->barrier_cache.bitpattern[0] = (_uw) matched;\n+\t\t\t  ucbp->barrier_cache.bitpattern[1] = (_uw) data;\n+\t\t\t  return _URC_HANDLER_FOUND;\n+\t\t\t}\n+\t\t    }\n+\t\t  /* Handler out of range, or not matched.  */\n+\t\t}\n+\t      else if (ucbp->barrier_cache.sp == _Unwind_GetGR (context, R_SP)\n+\t\t       && ucbp->barrier_cache.bitpattern[1] == (_uw) data)\n+\t\t{\n+\t\t  /* Matched a previous propagation barrier.  */\n+\t\t  _uw lp;\n+\n+\t\t  /* Setup for entry to the handler.  */\n+\t\t  lp = selfrel_offset31 (data);\n+\t\t  _Unwind_SetGR (context, R_PC, lp);\n+\t\t  _Unwind_SetGR (context, 0, (_uw) ucbp);\n+\t\t  return _URC_INSTALL_CONTEXT;\n+\t\t}\n+\t      /* Catch handler not mached.  Advance to the next descriptor.  */\n+\t      data += 2;\n+\t      break;\n+\n+\t    case 2:\n+\t      rtti_count = data[0] & 0x7fffffff;\n+\t      /* Exception specification.  */\n+\t      if (state == _US_VIRTUAL_UNWIND_FRAME)\n+\t\t{\n+\t\t  if (in_range)\n+\t\t    {\n+\t\t      /* Match against teh exception specification.  */\n+\t\t      _uw i;\n+\t\t      _uw rtti;\n+\t\t      void *matched;\n+\n+\t\t      for (i = 0; i < rtti_count; i++)\n+\t\t\t{\n+\t\t\t  matched = (void *)(ucbp + 1);\n+\t\t\t  rtti = _Unwind_decode_target2 ((_uw) &data[i + 1]);\n+\t\t\t  if (__cxa_type_match (ucbp, (type_info *) rtti,\n+\t\t\t\t\t\t&matched))\n+\t\t\t    break;\n+\t\t\t}\n+\n+\t\t      if (i == rtti_count)\n+\t\t\t{\n+\t\t\t  /* Exception does not match the spec.  */\n+\t\t\t  ucbp->barrier_cache.sp =\n+\t\t\t    _Unwind_GetGR (context, R_SP);\n+\t\t\t  ucbp->barrier_cache.bitpattern[0] = (_uw) matched;\n+\t\t\t  ucbp->barrier_cache.bitpattern[1] = (_uw) data;\n+\t\t\t  return _URC_HANDLER_FOUND;\n+\t\t\t}\n+\t\t    }\n+\t\t  /* Handler out of range, or exception is permitted.  */\n+\t\t}\n+\t      else if (ucbp->barrier_cache.sp == _Unwind_GetGR (context, R_SP)\n+\t\t       && ucbp->barrier_cache.bitpattern[1] == (_uw) data)\n+\t\t{\n+\t\t  /* Matched a previous propagation barrier.  */\n+\t\t  _uw lp;\n+\t\t  /* Record the RTTI list for __cxa_call_unexpected.  */\n+\t\t  ucbp->barrier_cache.bitpattern[1] = rtti_count;\n+\t\t  ucbp->barrier_cache.bitpattern[2] = 0;\n+\t\t  ucbp->barrier_cache.bitpattern[3] = 4;\n+\t\t  ucbp->barrier_cache.bitpattern[4] = (_uw) &data[1];\n+\n+\t\t  if (data[0] & uint32_highbit)\n+\t\t    phase2_call_unexpected_after_unwind = 1;\n+\t\t  else\n+\t\t    {\n+\t\t      data += rtti_count + 1;\n+\t\t      /* Setup for entry to the handler.  */\n+\t\t      lp = selfrel_offset31 (data);\n+\t\t      data++;\n+\t\t      _Unwind_SetGR (context, R_PC, lp);\n+\t\t      _Unwind_SetGR (context, 0, (_uw) ucbp);\n+\t\t      return _URC_INSTALL_CONTEXT;\n+\t\t    }\n+\t\t}\n+\t      if (data[0] & uint32_highbit)\n+\t\tdata++;\n+\t      data += rtti_count + 1;\n+\t      break;\n+\n+\t    default:\n+\t      /* Should never happen.  */\n+\t      return _URC_FAILURE;\n+\t    }\n+\t  /* Finished processing this descriptor.  */\n+\t}\n+    }\n+\n+  if (__gnu_unwind_execute (context, &uws) != _URC_OK)\n+    return _URC_FAILURE;\n+\n+  if (phase2_call_unexpected_after_unwind)\n+    {\n+      /* Enter __cxa_unexpected as if called from the callsite.  */\n+      _Unwind_SetGR (context, R_LR, _Unwind_GetGR (context, R_PC));\n+      _Unwind_SetGR (context, R_PC, (_uw) &__cxa_call_unexpected);\n+      return _URC_INSTALL_CONTEXT;\n+    }\n+\n+  return _URC_CONTINUE_UNWIND;\n+}\n+\n+\n+/* ABI defined personality routine entry points.  */\n+\n+_Unwind_Reason_Code\n+__aeabi_unwind_cpp_pr0 (_Unwind_State state,\n+\t\t\t_Unwind_Control_Block *ucbp,\n+\t\t\t_Unwind_Context *context)\n+{\n+  return __gnu_unwind_pr_common (state, ucbp, context, 0);\n+}\n+\n+_Unwind_Reason_Code\n+__aeabi_unwind_cpp_pr1 (_Unwind_State state,\n+\t\t\t_Unwind_Control_Block *ucbp,\n+\t\t\t_Unwind_Context *context)\n+{\n+  return __gnu_unwind_pr_common (state, ucbp, context, 1);\n+}\n+\n+_Unwind_Reason_Code\n+__aeabi_unwind_cpp_pr2 (_Unwind_State state,\n+\t\t\t_Unwind_Control_Block *ucbp,\n+\t\t\t_Unwind_Context *context)\n+{\n+  return __gnu_unwind_pr_common (state, ucbp, context, 2);\n+}"}, {"sha": "e6b6a224955375c5872aafb76fe52e753cb2ae3a", "filename": "gcc/config/arm/unwind-arm.h", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/gcc%2Fconfig%2Farm%2Funwind-arm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/gcc%2Fconfig%2Farm%2Funwind-arm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funwind-arm.h?ref=2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "patch": "@@ -0,0 +1,271 @@\n+/* Header file for the ARM EABI unwinder\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combine\n+   executable.)\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* Language-independent unwinder header public defines.  This contins both\n+   ABI defined objects, and GNU support routines.*/\n+\n+#ifndef UNWIND_ARM_H\n+#define UNWIND_ARM_H\n+\n+#define __ARM_EABI_UNWINDER__ 1\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+  /* We add a prototype for abort here to avoid creating a dependency on\n+     target headers.  */\n+  extern void abort();\n+\n+  typedef unsigned _Unwind_Word __attribute__((__mode__(__word__)));\n+  typedef signed _Unwind_Sword __attribute__((__mode__(__word__)));\n+  typedef unsigned _Unwind_Ptr __attribute__((__mode__(__pointer__)));\n+  typedef unsigned _Unwind_Internal_Ptr __attribute__((__mode__(__pointer__)));\n+  typedef _Unwind_Word _uw;\n+  typedef unsigned _uw64 __attribute__((mode(__DI__)));\n+  typedef unsigned _uw16 __attribute__((mode(__HI__)));\n+  typedef unsigned _uw8 __attribute__((mode(__QI__)));\n+\n+  typedef enum\n+    {\n+      _URC_OK = 0,       /* operation completed successfully */\n+      _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+      _URC_HANDLER_FOUND = 6,\n+      _URC_INSTALL_CONTEXT = 7,\n+      _URC_CONTINUE_UNWIND = 8,\n+      _URC_FAILURE = 9   /* unspecified failure of some kind */\n+    }\n+  _Unwind_Reason_Code;\n+  \n+  typedef enum\n+    {\n+      _US_VIRTUAL_UNWIND_FRAME = 0,\n+      _US_UNWIND_FRAME_STARTING = 1,\n+      _US_UNWIND_FRAME_RESUME = 2\n+    }\n+  _Unwind_State;\n+  \n+  typedef struct _Unwind_Control_Block _Unwind_Control_Block;\n+  typedef struct _Unwind_Context _Unwind_Context;\n+  typedef _uw _Unwind_EHT_Header;\n+  \n+  \n+  /* UCB: */\n+  \n+  struct _Unwind_Control_Block\n+    {\n+      char exception_class[8];\n+      void (*exception_cleanup)(_Unwind_Reason_Code, _Unwind_Control_Block *);\n+      /* Unwinder cache, private fields for the unwinder's use */\n+      struct\n+\t{\n+\t  _uw reserved1;\t/* init reserved1 to 0, then don't touch */\n+\t  _uw reserved2;\n+\t  _uw reserved3;\n+\t  _uw reserved4;\n+\t  _uw reserved5;\n+\t}\n+      unwinder_cache;\n+      /* Propagation barrier cache (valid after phase 1): */\n+      struct\n+\t{\n+\t  _uw sp;\n+\t  _uw bitpattern[5];\n+\t}\n+      barrier_cache;\n+      /* Cleanup cache (preserved over cleanup): */\n+      struct\n+\t{\n+\t  _uw bitpattern[4];\n+\t}\n+      cleanup_cache;\n+      /* Pr cache (for pr's benefit): */\n+      struct\n+\t{\n+\t  _uw fnstart;\t\t\t/* function start address */\n+\t  _Unwind_EHT_Header *ehtp;\t/* pointer to EHT entry header word */\n+\t  _uw additional;\t\t/* additional data */\n+\t  _uw reserved1;\n+\t}\n+      pr_cache;\n+      long long int :0;\t/* Force alignment to 8-byte boundary */\n+    };\n+  \n+  /* Interface functions: */\n+  _Unwind_Reason_Code _Unwind_RaiseException(_Unwind_Control_Block *ucbp);\n+  void __attribute__((noreturn)) _Unwind_Resume(_Unwind_Control_Block *ucbp);\n+  void _Unwind_Complete(_Unwind_Control_Block *ucbp);\n+\n+  /* Virtual Register Set*/\n+        \n+  typedef enum\n+    {\n+      _UVRSC_CORE = 0,      /* integer register */\n+      _UVRSC_VFP = 1,       /* vfp */\n+      _UVRSC_FPA = 2,       /* fpa */\n+      _UVRSC_WMMXD = 3,     /* Intel WMMX data register */\n+      _UVRSC_WMMXC = 4      /* Intel WMMX control register */\n+    }\n+  _Unwind_VRS_RegClass;\n+  \n+  typedef enum\n+    {\n+      _UVRSD_UINT32 = 0,\n+      _UVRSD_VFPX = 1,\n+      _UVRSD_FPAX = 2,\n+      _UVRSD_UINT64 = 3,\n+      _UVRSD_FLOAT = 4,\n+      _UVRSD_DOUBLE = 5\n+    }\n+  _Unwind_VRS_DataRepresentation;\n+  \n+  typedef enum\n+    {\n+      _UVRSR_OK = 0,\n+      _UVRSR_NOT_IMPLEMENTED = 1,\n+      _UVRSR_FAILED = 2\n+    } \n+  _Unwind_VRS_Result;\n+\n+  /* Frame unwinding state.  */\n+  typedef struct\n+    {\n+      /* The current word (bytes packed msb first).  */\n+      _uw data;\n+      /* Pointer to the next word of data.  */\n+      _uw *next;\n+      /* The number of bytes left in this word.  */\n+      _uw8 bytes_left;\n+      /* The number of words pointed to by ptr.  */\n+      _uw8 words_left;\n+    }\n+  __gnu_unwind_state;\n+\n+  typedef _Unwind_Reason_Code (*personality_routine) (_Unwind_State,\n+      _Unwind_Control_Block *, _Unwind_Context *);\n+\n+  _Unwind_VRS_Result _Unwind_VRS_Set(_Unwind_Context *, _Unwind_VRS_RegClass,\n+                                     _uw, _Unwind_VRS_DataRepresentation,\n+                                     void *);\n+  \n+  _Unwind_VRS_Result _Unwind_VRS_Get(_Unwind_Context *, _Unwind_VRS_RegClass,\n+                                     _uw, _Unwind_VRS_DataRepresentation,\n+                                     void *);\n+  \n+  _Unwind_VRS_Result _Unwind_VRS_Pop(_Unwind_Context *, _Unwind_VRS_RegClass,\n+                                     _uw, _Unwind_VRS_DataRepresentation);\n+\n+\n+  /* Support functions for the PR.  */\n+#define _Unwind_Exception _Unwind_Control_Block\n+  typedef char _Unwind_Exception_Class[8];\n+\n+  void * _Unwind_GetLanguageSpecificData (_Unwind_Context *);\n+  _Unwind_Ptr _Unwind_GetRegionStart (_Unwind_Context *);\n+\n+  /* These two should never be used */\n+  static inline _Unwind_Ptr\n+  _Unwind_GetDataRelBase (_Unwind_Context * context __attribute__ ((unused)))\n+    {\n+      abort ();\n+    }\n+\n+  static inline _Unwind_Ptr\n+  _Unwind_GetTextRelBase (_Unwind_Context * context __attribute__ ((unused)))\n+    {\n+      abort ();\n+    }\n+\n+  void _Unwind_DeleteException (_Unwind_Exception *);\n+\n+  _Unwind_Reason_Code __gnu_unwind_frame (_Unwind_Control_Block *,\n+\t\t\t\t\t  _Unwind_Context *);\n+  _Unwind_Reason_Code __gnu_unwind_execute (_Unwind_Context *,\n+\t\t\t\t\t    __gnu_unwind_state *);\n+\n+  /* Decode an R_ARM_TARGET2 relocation.  */\n+  static inline _Unwind_Word\n+  _Unwind_decode_target2 (_Unwind_Word ptr)\n+    {\n+      _Unwind_Word tmp;\n+\n+      tmp = *(_Unwind_Word *) ptr;\n+      /* Zero values are always NULL.  */\n+      if (!tmp)\n+\treturn 0;\n+\n+#if defined(linux) || defined(__NetBSD__)\n+      /* Pc-relative indirect.  */\n+      tmp += ptr;\n+      tmp = *(_Unwind_Word *) tmp;\n+#elif defined(__symbian__)\n+      /* Absoute pointer.  Nothing more to do.  */\n+#else\n+      /* Pc-relative pointer.  */\n+      tmp += ptr;\n+#endif\n+      return tmp;\n+    }\n+\n+  static inline _Unwind_Word\n+  _Unwind_GetGR (_Unwind_Context *context, int regno)\n+    {\n+      _uw val;\n+      _Unwind_VRS_Get (context, _UVRSC_CORE, regno, _UVRSD_UINT32, &val);\n+      return val;\n+    }\n+\n+  /* Return the address of the instruction, not the actual IP value.  */\n+#define _Unwind_GetIP(context) \\\n+  (_Unwind_GetGR (context, 15) & ~(_Unwind_Word)1)\n+\n+  static inline void\n+  _Unwind_SetGR (_Unwind_Context *context, int regno, _Unwind_Word val)\n+    {\n+      _Unwind_VRS_Set (context, _UVRSC_CORE, regno, _UVRSD_UINT32, &val);\n+    }\n+\n+  /* The dwarf unwinder doesn't understand arm/thumb state.  We assume the\n+     landing pad uses the same instruction set as the callsite.  */\n+#define _Unwind_SetIP(context, val) \\\n+  _Unwind_SetGR (context, 15, val | (_Unwind_GetGR (context, 15) & 1))\n+\n+  /* Provided only for for compatibility with existing code.  */\n+  typedef int _Unwind_Action;\n+#define _UA_SEARCH_PHASE\t1\n+#define _UA_CLEANUP_PHASE\t2\n+#define _UA_HANDLER_FRAME\t4\n+#define _UA_FORCE_UNWIND\t8\n+#define _UA_END_OF_STACK\t16\n+\n+#define _URC_NO_REASON _URC_OK\n+\n+#ifdef __cplusplus\n+}   /* extern \"C\" */\n+#endif\n+\n+#endif /* defined UNWIND_ARM_H */"}, {"sha": "9c0c7da07adfaf1d238e17ce47827d6cc2547fc4", "filename": "gcc/unwind-generic.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/gcc%2Funwind-generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/gcc%2Funwind-generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-generic.h?ref=2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "previous_filename": "gcc/unwind.h"}, {"sha": "d77c86dd7d07332775cba7cf7dfe4bd62a7deb5d", "filename": "libstdc++-v3/libsupc++/eh_arm.cc", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc?ref=2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "patch": "@@ -0,0 +1,153 @@\n+// -*- C++ -*- ARM specific Exception handling support routines.\n+// Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cxxabi.h>\n+#include \"unwind-cxx.h\"\n+\n+#ifdef __ARM_EABI_UNWINDER__\n+\n+using namespace __cxxabiv1;\n+\n+\n+// Given the thrown type THROW_TYPE, pointer to a variable containing a\n+// pointer to the exception object THROWN_PTR_P and a type CATCH_TYPE to\n+// compare against, return whether or not there is a match and if so,\n+// update *THROWN_PTR_P.\n+\n+extern \"C\" __cxa_type_match_result\n+__cxa_type_match(_Unwind_Exception* ue_header,\n+\t\t const std::type_info* catch_type,\n+\t\t bool is_reference __attribute__((__unused__)),\n+\t\t void** thrown_ptr_p)\n+{\n+  if (!__is_gxx_exception_class(ue_header->exception_class))\n+    return ctm_failed;\n+\n+  __cxa_exception* xh = __get_exception_header_from_ue(ue_header);\n+  const std::type_info* throw_type = xh->exceptionType;\n+  void* thrown_ptr = *thrown_ptr_p;\n+\n+  // Pointer types need to adjust the actual pointer, not\n+  // the pointer to pointer that is the exception object.\n+  // This also has the effect of passing pointer types\n+  // \"by value\" through the __cxa_begin_catch return value.\n+  if (throw_type->__is_pointer_p())\n+    thrown_ptr = *(void**) thrown_ptr;\n+\n+  if (catch_type->__do_catch(throw_type, &thrown_ptr, 1))\n+    {\n+      *thrown_ptr_p = thrown_ptr;\n+\n+      if (typeid(*catch_type) == typeid (typeid(void*)))\n+\t{\n+\t  const __pointer_type_info *catch_pointer_type =\n+\t    static_cast<const __pointer_type_info *> (catch_type);\n+\t  const __pointer_type_info *throw_pointer_type =\n+\t    static_cast<const __pointer_type_info *> (throw_type);\n+\n+\t  if (typeid (*catch_pointer_type->__pointee) != typeid (void)\n+\t      && (*catch_pointer_type->__pointee != \n+\t\t  *throw_pointer_type->__pointee))\n+\t    return ctm_succeeded_with_ptr_to_base;\n+\t}\n+\n+      return ctm_succeeded;\n+    }\n+\n+  return ctm_failed;\n+}\n+\n+// ABI defined routine called at the start of a cleanup handler.\n+extern \"C\" bool\n+__cxa_begin_cleanup(_Unwind_Exception* ue_header)\n+{\n+  __cxa_eh_globals *globals = __cxa_get_globals();\n+  __cxa_exception *header = __get_exception_header_from_ue(ue_header);\n+\n+  if (!__is_gxx_exception_class(header->unwindHeader.exception_class))\n+    {\n+      // TODO: cleanups with foreign exceptions.\n+      return false;\n+    }\n+  header->propagationCount++;\n+  // Add it to the chain if this is the first time we've seen this exception.\n+  if (header->propagationCount == 1)\n+    {\n+      header->nextPropagatingException = globals->propagatingExceptions;\n+      globals->propagatingExceptions = header;\n+    }\n+  return true;\n+}\n+\n+// Do the work for __cxa_end_cleanup.  Returns the currently propagating\n+// exception object.\n+extern \"C\" _Unwind_Exception *\n+__gnu_end_cleanup(void)\n+{\n+  __cxa_exception *header;\n+  __cxa_eh_globals *globals = __cxa_get_globals();\n+\n+  header = globals->propagatingExceptions;\n+\n+  // Check something hasn't gone horribly wrong.\n+  if (!header)\n+    std::terminate();\n+\n+  header->propagationCount--;\n+  if (header->propagationCount == 0)\n+    {\n+      // Remove exception from chain.\n+      globals->propagatingExceptions = header->nextPropagatingException;\n+      header->nextPropagatingException = NULL;\n+    }\n+  return &header->unwindHeader;\n+}\n+\n+// Assembly wrapper to call __gnu_end_cleanup without clobbering r1-r3.\n+// Also push r4 to preserve stack alignment.\n+#ifdef __thumb__\n+asm (\".global __cxa_end_cleanup\\n\"\n+\"\t.type __cxa_end_cleanup, \\\"function\\\"\\n\"\n+\"\t.thumb_func\\n\"\n+\"__cxa_end_cleanup:\\n\"\n+\"\tpush\\t{r1, r2, r3, r4}\\n\"\n+\"\tbl\\t__gnu_end_cleanup\\n\"\n+\"\tpop\\t{r1, r2, r3, r4}\\n\"\n+\"\tbl\\t_Unwind_Resume @ Never returns\\n\");\n+#else\n+asm (\".global __cxa_end_cleanup\\n\"\n+\"\t.type __cxa_end_cleanup, \\\"function\\\"\\n\"\n+\"__cxa_end_cleanup:\\n\"\n+\"\tstmfd\\tsp!, {r1, r2, r3, r4}\\n\"\n+\"\tbl\\t__gnu_end_cleanup\\n\"\n+\"\tldmfd\\tsp!, {r1, r2, r3, r4}\\n\"\n+\"\tbl\\t_Unwind_Resume @ Never returns\\n\");\n+#endif\n+\n+#endif"}, {"sha": "74d5d2fb0e08225979f6c780c1174d8fa8d36f6a", "filename": "libstdc++-v3/libsupc++/eh_call.cc", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a75c0b6d2f48f19e5917f7d307a855db58f5b81/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_call.cc?ref=2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "patch": "@@ -0,0 +1,162 @@\n+// -*- C++ -*- Helpers for calling unextected and terminate\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+\n+#include <bits/c++config.h>\n+#include <cstdlib>\n+#include <exception_defines.h>\n+#include \"unwind-cxx.h\"\n+\n+using namespace __cxxabiv1;\n+\n+#include \"unwind-pe.h\"\n+\n+\n+// Helper routine for when the exception handling code needs to call\n+// terminate.\n+\n+extern \"C\" void\n+__cxa_call_terminate(_Unwind_Exception* ue_header)\n+{\n+\n+  if (ue_header)\n+    {\n+      // terminate is classed as a catch handler.\n+      __cxa_begin_catch(ue_header);\n+\n+      // Call the terminate handler that was in effect when we threw this\n+      // exception.  */\n+      if (__is_gxx_exception_class(ue_header->exception_class))\n+\t{\n+\t  __cxa_exception* xh;\n+\n+\t  xh = __get_exception_header_from_ue(ue_header);\n+\t  __terminate(xh->terminateHandler);\n+\t}\n+    }\n+  /* Call the global routine if we don't have anything better.  */\n+  std::terminate();\n+}\n+\n+\n+#ifdef __ARM_EABI_UNWINDER__\n+// The ARM EABI __cxa_call_unexpected has the same semantics as the generic\n+// routine, but the exception specification has a different format.\n+extern \"C\" void\n+__cxa_call_unexpected(void* exc_obj_in)\n+{\n+  _Unwind_Exception* exc_obj\n+    = reinterpret_cast<_Unwind_Exception*>(exc_obj_in);\n+\n+  int rtti_count = 0;\n+  _Unwind_Word rtti_stride = 0;\n+  _Unwind_Word* rtti_list = NULL;\n+  bool foreign_exception;\n+  std::unexpected_handler unexpectedHandler = NULL;\n+  std::terminate_handler terminateHandler = NULL;\n+  __cxa_exception* xh;\n+  if (__is_gxx_exception_class(exc_obj->exception_class))\n+    {\n+      // Save data from the EO, which may be clobbered by _cxa_begin_catch.\n+      xh = __get_exception_header_from_ue(exc_obj);\n+      unexpectedHandler = xh->unexpectedHandler;\n+      terminateHandler = xh->terminateHandler;\n+      rtti_count = exc_obj->barrier_cache.bitpattern[1];\n+\n+      rtti_stride = exc_obj->barrier_cache.bitpattern[3];\n+      rtti_list = (_Unwind_Word*) exc_obj->barrier_cache.bitpattern[4];\n+      foreign_exception = false;\n+    }\n+  else\n+    foreign_exception = true;\n+\n+  /* This must be called after extracting data from the EO, but before\n+     calling unexpected().   */\n+  __cxa_begin_catch(exc_obj);\n+\n+  // This function is a handler for our exception argument.  If we exit\n+  // by throwing a different exception, we'll need the original cleaned up.\n+  struct end_catch_protect\n+  {\n+    end_catch_protect() { }\n+    ~end_catch_protect() { __cxa_end_catch(); }\n+  } end_catch_protect_obj;\n+\n+\n+  try \n+    { \n+      if (foreign_exception)\n+\tstd::unexpected();\n+      else\n+\t__unexpected(unexpectedHandler);\n+    }\n+  catch(...) \n+    {\n+      /* See if the new exception matches the rtti list.  */\n+      if (foreign_exception)\n+\tstd::terminate();\n+\n+      // Get the exception thrown from unexpected.\n+\n+      __cxa_eh_globals* globals = __cxa_get_globals_fast();\n+      __cxa_exception* new_xh = globals->caughtExceptions;\n+      void* new_ptr = new_xh + 1;\n+      const std::type_info* catch_type;\n+      int n;\n+      bool bad_exception_allowed = false;\n+      const std::type_info& bad_exc = typeid(std::bad_exception);\n+\n+      // Check the new exception against the rtti list\n+      for (n = 0; n < rtti_count; n++)\n+\t{\n+\t  _Unwind_Word offset;\n+\n+\t  offset = (_Unwind_Word) &rtti_list[n * (rtti_stride >> 2)];\n+\t  offset = _Unwind_decode_target2(offset);\n+\t  catch_type = (const std::type_info*) (offset);\n+\n+\t  if (__cxa_type_match(&new_xh->unwindHeader, catch_type, false,\n+\t\t\t       &new_ptr) != ctm_failed)\n+\t    __throw_exception_again;\n+\n+\t  if (catch_type->__do_catch(&bad_exc, 0, 1))\n+\t    bad_exception_allowed = true;\n+\t}\n+\n+      // If the exception spec allows std::bad_exception, throw that.\n+#ifdef __EXCEPTIONS  \n+      if (bad_exception_allowed)\n+\tthrow std::bad_exception();\n+#endif   \n+\n+      // Otherwise, die.\n+      __terminate(terminateHandler);\n+    }\n+}\n+#endif // __ARM_EABI_UNWINDER__"}]}