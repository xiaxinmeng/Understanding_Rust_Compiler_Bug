{"sha": "98f01d532a15a16c5d9afb0d35c9ea18688d2541", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThmMDFkNTMyYTE1YTE2YzVkOWFmYjBkMzVjOWVhMTg2ODhkMjU0MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-12-08T11:27:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-12-08T11:27:00Z"}, "message": "exp_ch6.adb (Expand_Call): Add comment on handling of back end intrinsic\n\n\t* exp_ch6.adb (Expand_Call): Add comment on handling of back end\n\tintrinsic\n\n\t* exp_intr.adb (Expand_Intrinsic_Call): Ignore unrecognized intrinsic,\n\tleaving call unchanged.\n\tThis deals with the case where the pragma Import specified\n\tan external name, to be handled by the back end.\n\n\t* sem_prag.adb (Process_Import_Or_Interface): Do not check validity of\n\tsubprogram which is Imported with convention Intrinsic if an\n\tExternal_Name argument is specified.\n\t(Process_Import_Or_Interface): Properly diagnose link name argument.\n\t(Inlining_Not_Possible): New name for Cannot_Inline, to avoid confusion\n\twith Sem_Ch6.Cannot_Inline.\n\t(Process_Inline): Provide separate warning for inapplicable inline\n\tpragma.\n\t(Cannot_Inline): Reject subprograms that have an at_end handler, so that\n\ttreatment is uniform on different targets.\n\nFrom-SVN: r91882", "tree": {"sha": "e3354052180da5126261623c30a67e2d42ebd791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3354052180da5126261623c30a67e2d42ebd791"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98f01d532a15a16c5d9afb0d35c9ea18688d2541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f01d532a15a16c5d9afb0d35c9ea18688d2541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98f01d532a15a16c5d9afb0d35c9ea18688d2541", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f01d532a15a16c5d9afb0d35c9ea18688d2541/comments", "author": null, "committer": null, "parents": [{"sha": "2717634daab64ed32a49b329f61cf0064f80f046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2717634daab64ed32a49b329f61cf0064f80f046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2717634daab64ed32a49b329f61cf0064f80f046"}], "stats": {"total": 134, "additions": 91, "deletions": 43}, "files": [{"sha": "0b6447aad4ee142e26976636f10d8e4e15936d9e", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f01d532a15a16c5d9afb0d35c9ea18688d2541/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f01d532a15a16c5d9afb0d35c9ea18688d2541/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=98f01d532a15a16c5d9afb0d35c9ea18688d2541", "patch": "@@ -1051,7 +1051,7 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n-      --  The call node itself is re-analyzed in Expand_Call.\n+      --  The call node itself is re-analyzed in Expand_Call\n \n    end Expand_Actuals;\n \n@@ -1974,6 +1974,10 @@ package body Exp_Ch6 is\n       --  appropriate expansion to the corresponding tree node and we\n       --  are all done (since after that the call is gone!)\n \n+      --  In the case where the intrinsic is to be processed by the back end,\n+      --  the call to Expand_Intrinsic_Call will do nothing, which is fine,\n+      --  since the idea in this case is to pass the call unchanged.\n+\n       if Is_Intrinsic_Subprogram (Subp) then\n          Expand_Intrinsic_Call (N, Subp);\n          return;\n@@ -2300,7 +2304,7 @@ package body Exp_Ch6 is\n       Temp_Typ : Entity_Id;\n \n       procedure Make_Exit_Label;\n-      --  Build declaration for exit label to be used in Return statements.\n+      --  Build declaration for exit label to be used in Return statements\n \n       function Process_Formals (N : Node_Id) return Traverse_Result;\n       --  Replace occurrence of a formal with the corresponding actual, or\n@@ -2331,7 +2335,7 @@ package body Exp_Ch6 is\n \n       procedure Make_Exit_Label is\n       begin\n-         --  Create exit label for subprogram, if one doesn't exist yet.\n+         --  Create exit label for subprogram if one does not exist yet\n \n          if No (Exit_Lab) then\n             Lab_Id := Make_Identifier (Loc, New_Internal_Name ('L'));\n@@ -2509,15 +2513,13 @@ package body Exp_Ch6 is\n          elsif Nkind (N) = N_Identifier\n            and then Nkind (Parent (Entity (N))) = N_Object_Declaration\n          then\n-\n-            --  The block assigns the result of the call to the temporary.\n+            --  The block assigns the result of the call to the temporary\n \n             Insert_After (Parent (Entity (N)), Blk);\n \n          elsif Nkind (Parent (N)) = N_Assignment_Statement\n            and then Is_Entity_Name (Name (Parent (N)))\n          then\n-\n             --  Replace assignment with the block\n \n             declare\n@@ -2660,7 +2662,7 @@ package body Exp_Ch6 is\n          Set_Declarations (Blk, New_List);\n       end if;\n \n-      --  If this is a derived function, establish the proper return type.\n+      --  If this is a derived function, establish the proper return type\n \n       if Present (Orig_Subp)\n         and then Orig_Subp /= Subp\n@@ -2797,7 +2799,7 @@ package body Exp_Ch6 is\n             Targ := Name (Parent (N));\n \n          else\n-            --  Replace call with temporary, and create its declaration.\n+            --  Replace call with temporary and create its declaration\n \n             Temp :=\n               Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n@@ -2815,7 +2817,7 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n-      --  Traverse the tree and replace  formals with actuals or their thunks.\n+      --  Traverse the tree and replace formals with actuals or their thunks.\n       --  Attach block to tree before analysis and rewriting.\n \n       Replace_Formals (Blk);\n@@ -2879,7 +2881,7 @@ package body Exp_Ch6 is\n \n       Restore_Env;\n \n-      --  Cleanup mapping between formals and actuals, for other expansions.\n+      --  Cleanup mapping between formals and actuals for other expansions\n \n       F := First_Formal (Subp);\n \n@@ -3493,9 +3495,9 @@ package body Exp_Ch6 is\n             end loop;\n          end if;\n \n-      --  For a function, we must deal with the case where there is at\n-      --  least one missing return. What we do is to wrap the entire body\n-      --  of the function in a block:\n+      --  For a function, we must deal with the case where there is at least\n+      --  one missing return. What we do is to wrap the entire body of the\n+      --  function in a block:\n \n       --    begin\n       --      ...\n@@ -3732,7 +3734,7 @@ package body Exp_Ch6 is\n       if Is_Subprogram (Proc)\n         and then Proc /= Corr\n       then\n-         --  Protected function or procedure.\n+         --  Protected function or procedure\n \n          Set_Entity (Rec, Param);\n "}, {"sha": "8f4170495207715e80edef2550a16992688c6a80", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f01d532a15a16c5d9afb0d35c9ea18688d2541/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f01d532a15a16c5d9afb0d35c9ea18688d2541/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=98f01d532a15a16c5d9afb0d35c9ea18688d2541", "patch": "@@ -281,12 +281,21 @@ package body Exp_Intr is\n       then\n          Expand_Source_Info (N, Nam);\n \n-      else\n-         --  Only other possibility is a renaming, in which case we expand\n-         --  the call to the original operation (which must be intrinsic).\n+         --  If we have a renaming, expand the call to the original operation,\n+         --  which must itself be intrinsic, since renaming requires matching\n+         --  conventions and this has already been checked.\n \n-         pragma Assert (Present (Alias (E)));\n+      elsif Present (Alias (E)) then\n          Expand_Intrinsic_Call (N,  Alias (E));\n+\n+         --  The only other case is where an external name was specified,\n+         --  since this is the only way that an otherwise unrecognized\n+         --  name could escape the checking in Sem_Prag. Nothing needs\n+         --  to be done in such a case, since we pass such a call to the\n+         --  back end unchanged.\n+\n+      else\n+         null;\n       end if;\n    end Expand_Intrinsic_Call;\n "}, {"sha": "9691ebbc1db7ea01e32f0e29766726d199413784", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 62, "deletions": 25, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f01d532a15a16c5d9afb0d35c9ea18688d2541/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f01d532a15a16c5d9afb0d35c9ea18688d2541/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=98f01d532a15a16c5d9afb0d35c9ea18688d2541", "patch": "@@ -2965,13 +2965,34 @@ package body Sem_Prag is\n                else\n                   Set_Imported (Def_Id);\n \n-                  --  If Import intrinsic, set intrinsic flag and verify\n-                  --  that it is known as such.\n+                  --  Special processing for Convention_Intrinsic\n \n                   if C = Convention_Intrinsic then\n+\n+                     --  Link_Name argument not allowed for intrinsic\n+\n+                     if Present (Arg3)\n+                       and then Chars (Arg3) = Name_Link_Name\n+                     then\n+                        Arg4 := Arg3;\n+                     end if;\n+\n+                     if Present (Arg4) then\n+                        Error_Pragma_Arg\n+                          (\"Link_Name argument not allowed for \" &\n+                           \"Import Intrinsic\",\n+                           Arg4);\n+                     end if;\n+\n                      Set_Is_Intrinsic_Subprogram (Def_Id);\n-                     Check_Intrinsic_Subprogram\n-                       (Def_Id, Expression (Arg2));\n+\n+                     --  If no external name is present, then check that\n+                     --  this is a valid intrinsic subprogram. If an external\n+                     --  name is present, then this is handled by the back end.\n+\n+                     if No (Arg3) then\n+                        Check_Intrinsic_Subprogram (Def_Id, Expression (Arg2));\n+                     end if;\n                   end if;\n \n                   --  All interfaced procedures need an external symbol\n@@ -3073,24 +3094,29 @@ package body Sem_Prag is\n          procedure Set_Inline_Flags (Subp : Entity_Id);\n          --  Sets Is_Inlined and Has_Pragma_Inline flags for Subp\n \n-         function Cannot_Inline (Subp : Entity_Id) return Boolean;\n-         --  Do not set the inline flag if body is available and contains\n-         --  exception handlers, to prevent undefined symbols at link time.\n-         --  Emit warning if front-end inlining is enabled and the pragma\n-         --  appears too late.\n+         function Inlining_Not_Possible (Subp : Entity_Id) return Boolean;\n+         --  Returns True if it can be determined at this stage that inlining\n+         --  is not possible, for examle if the body is available and contains\n+         --  exception handlers, we prevent inlining, since otherwise we can\n+         --  get undefined symbols at link time. This function also emits a\n+         --  warning if front-end inlining is enabled and the pragma appears\n+         --  too late.\n+         --  ??? is business with link symbols still valid, or does it relate\n+         --  to front end ZCX which is being phased out ???\n \n-         -------------------\n-         -- Cannot_Inline --\n-         -------------------\n+         ---------------------------\n+         -- Inlining_Not_Possible --\n+         ---------------------------\n \n-         function Cannot_Inline (Subp : Entity_Id) return Boolean is\n-            Decl : constant Node_Id := Unit_Declaration_Node (Subp);\n+         function Inlining_Not_Possible (Subp : Entity_Id) return Boolean is\n+            Decl  : constant Node_Id := Unit_Declaration_Node (Subp);\n+            Stats : Node_Id;\n \n          begin\n             if Nkind (Decl) = N_Subprogram_Body then\n-               return\n-                 Present\n-                   (Exception_Handlers (Handled_Statement_Sequence (Decl)));\n+               Stats := Handled_Statement_Sequence (Decl);\n+               return Present (Exception_Handlers (Stats))\n+                 or else Present (At_End_Proc (Stats));\n \n             elsif Nkind (Decl) = N_Subprogram_Declaration\n               and then Present (Corresponding_Body (Decl))\n@@ -3112,18 +3138,22 @@ package body Sem_Prag is\n                   return False;\n \n                else\n+                  Stats :=\n+                    Handled_Statement_Sequence\n+                        (Unit_Declaration_Node (Corresponding_Body (Decl)));\n+\n                   return\n-                    Present (Exception_Handlers\n-                      (Handled_Statement_Sequence\n-                        (Unit_Declaration_Node (Corresponding_Body (Decl)))));\n+                    Present (Exception_Handlers (Stats))\n+                      or else Present (At_End_Proc (Stats));\n                end if;\n+\n             else\n                --  If body is not available, assume the best, the check is\n                --  performed again when compiling enclosing package bodies.\n \n                return False;\n             end if;\n-         end Cannot_Inline;\n+         end Inlining_Not_Possible;\n \n          -----------------\n          -- Make_Inline --\n@@ -3137,8 +3167,10 @@ package body Sem_Prag is\n             if Etype (Subp) = Any_Type then\n                return;\n \n-            elsif Cannot_Inline (Subp) then\n-               Applies := True;    --  Do not treat as an error.\n+            --  If inlining is not possible, for now do not treat as an error\n+\n+            elsif Inlining_Not_Possible (Subp) then\n+               Applies := True;\n                return;\n \n             --  Here we have a candidate for inlining, but we must exclude\n@@ -3277,8 +3309,13 @@ package body Sem_Prag is\n             elsif not Effective\n               and then Warn_On_Redundant_Constructs\n             then\n-               Error_Msg_NE (\"pragma Inline for& is redundant?\",\n-                 N, Entity (Subp_Id));\n+               if Inlining_Not_Possible (Subp) then\n+                  Error_Msg_NE\n+                    (\"pragma Inline for& is ignored?\", N, Entity (Subp_Id));\n+               else\n+                  Error_Msg_NE\n+                    (\"pragma Inline for& is redundant?\", N, Entity (Subp_Id));\n+               end if;\n             end if;\n \n             Next (Assoc);"}]}