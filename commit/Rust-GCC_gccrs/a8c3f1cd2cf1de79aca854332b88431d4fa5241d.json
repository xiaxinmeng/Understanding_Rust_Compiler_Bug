{"sha": "a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThjM2YxY2QyY2YxZGU3OWFjYTg1NDMzMmI4ODQzMWQ0ZmE1MjQxZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-12-13T05:23:14Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-12-13T05:23:14Z"}, "message": "Update to copy of current master Go testsuite.\n\nFrom-SVN: r205955", "tree": {"sha": "c67736e2ae2c733d75720c237eb1eb8c4fd3964f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c67736e2ae2c733d75720c237eb1eb8c4fd3964f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/comments", "author": null, "committer": null, "parents": [{"sha": "8a614b4f3780a41ff631ba33c6990c8d7766a273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a614b4f3780a41ff631ba33c6990c8d7766a273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a614b4f3780a41ff631ba33c6990c8d7766a273"}], "stats": {"total": 3231, "additions": 3096, "deletions": 135}, "files": [{"sha": "4e7d17a11b9cb429172b9bb521ca8150eaf5738e", "filename": "gcc/testsuite/go.test/test/bench/shootout/timing.log", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fshootout%2Ftiming.log", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fshootout%2Ftiming.log", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fbench%2Fshootout%2Ftiming.log?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -1161,3 +1161,94 @@ chameneos 6000000\n \tgccgo -O2 chameneosredux.go\t11.28u 6.68s 18.00r\n \tgc chameneosredux\t6.94u 0.00s 6.96r\n \n+# May 23, 2013\n+# Go 1.1, which includes precise GC, new scheduler, faster maps.\n+# 20%-ish speedups across many benchmarks.\n+# gccgo showing significant improvement (even though it's not yet up to Go 1.1)\n+#\n+# Standouts:\n+#\tfannkuch, regex-dna, k-nucleotide, threadring, chameneos\n+\n+fasta -n 25000000\n+\tgcc -m64 -O2 fasta.c\t1.54u 0.01s 1.55r\n+\tgccgo -O2 fasta.go\t1.42u 0.00s 1.43r\n+\tgc fasta\t1.50u 0.01s 1.52r # -16%\n+\tgc_B fasta\t1.46u 0.00s 1.46r # -17%\n+\n+reverse-complement < output-of-fasta-25000000\n+\tgcc -m64 -O2 reverse-complement.c\t0.87u 0.37s 4.36r\n+\tgccgo -O2 reverse-complement.go\t0.77u 0.15s 0.93r # -15%\n+\tgc reverse-complement\t0.99u 0.12s 1.12r # -15%\n+\tgc_B reverse-complement\t0.85u 0.17s 1.02r # -21%\n+\n+nbody -n 50000000\n+\tgcc -m64 -O2 nbody.c -lm\t13.50u 0.00s 13.53r\n+\tgccgo -O2 nbody.go\t13.98u 0.01s 14.02r\n+\tgc nbody\t16.63u 0.01s 16.67r\n+\tgc_B nbody\t15.74u 0.00s 15.76r\n+\n+binary-tree 15 # too slow to use 20\n+\tgcc -m64 -O2 binary-tree.c -lm\t0.61u 0.00s 0.61r\n+\tgccgo -O2 binary-tree.go\t1.11u 0.01s 1.12r # -13%\n+\tgccgo -O2 binary-tree-freelist.go\t0.22u 0.01s 0.23r\n+\tgc binary-tree\t1.83u 0.02s 1.83r # -7%\n+\tgc binary-tree-freelist\t0.32u 0.00s 0.32r\n+\n+fannkuch 12\n+\tgcc -m64 -O2 fannkuch.c\t45.56u 0.00s 45.67r\n+\tgccgo -O2 fannkuch.go\t57.71u 0.00s 57.85r # -4%\n+\tgccgo -O2 fannkuch-parallel.go\t146.31u 0.00s 37.50r #-37%\n+\tgc fannkuch\t70.06u 0.03s 70.17r # -3%\n+\tgc fannkuch-parallel\t131.88u 0.06s 33.59r # -23%\n+\tgc_B fannkuch\t45.55u 0.02s 45.63r # -15%\n+\n+regex-dna 100000\n+\tgcc -m64 -O2 regex-dna.c -lpcre\t0.44u 0.01s 0.45r\n+\tgccgo -O2 regex-dna.go\t5.59u 0.00s 5.61r # -14%\n+\tgccgo -O2 regex-dna-parallel.go\t10.85u 0.30s 3.34r # -24%\n+\tgc regex-dna\t2.23u 0.01s 2.25r # -43%\n+\tgc regex-dna-parallel\t2.35u 0.00s 0.93r # -40%\n+\tgc_B regex-dna\t2.24u 0.01s 2.25r # -43%\n+\n+spectral-norm 5500\n+\tgcc -m64 -O2 spectral-norm.c -lm\t14.84u 0.00s 14.88r\n+\tgccgo -O2 spectral-norm.go\t15.33u 0.00s 15.37r\n+\tgc spectral-norm\t16.75u 0.02s 16.79r # -15%\n+\tgc_B spectral-norm\t16.77u 0.01s 16.79r # -15%\n+\n+k-nucleotide 1000000\n+\tgcc -O2 k-nucleotide.c -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -lglib-2.0 \t4.50u 0.00s 4.52r\n+\tgccgo -O2 k-nucleotide.go\t3.72u 0.04s 3.77r # -21%\n+\tgccgo -O2 k-nucleotide-parallel.go\t3.88u 0.03s 1.42r # -35%\n+\tgc k-nucleotide\t6.32u 0.01s 6.33r # -31%\n+\tgc k-nucleotide-parallel\t6.47u 0.05s 2.13r # -33%\n+\tgc_B k-nucleotide\t6.45u 0.01s 6.47r # - 28%\n+\n+mandelbrot 16000\n+\tgcc -m64 -O2 mandelbrot.c\t36.03u 0.00s 36.11r\n+\tgccgo -O2 mandelbrot.go\t37.61u 0.00s 37.74r # -14%\n+\tgc mandelbrot\t38.19u 0.05s 38.29r\n+\tgc_B mandelbrot\t38.19u 0.03s 38.26r\n+\n+meteor 2098\n+\tgcc -m64 -O2 meteor-contest.c\t0.08u 0.00s 0.08r\n+\tgccgo -O2 meteor-contest.go\t0.09u 0.01s 0.10r\n+\tgc meteor-contest\t0.12u 0.00s 0.12r # -15% although perhaps just noise\n+\tgc_B meteor-contest\t0.11u 0.00s 0.12r # -8% although perhaps just noise\n+\n+pidigits 10000\n+\tgcc -m64 -O2 pidigits.c -lgmp\t2.27u 0.00s 2.28r\n+\tgccgo -O2 pidigits.go\t8.95u 0.02s 8.99r\n+\tgc pidigits\t2.88u 0.14s 2.91r\n+\tgc_B pidigits\t2.92u 0.10s 2.91r\n+\n+threadring 50000000\n+\tgcc -m64 -O2 threadring.c -lpthread\t14.75u 167.88s 212.23r\n+\tgccgo -O2 threadring.go\t36.72u 12.08s 48.91r # -29%\n+\tgc threadring\t10.93u 0.01s 10.95r # -16%\n+\n+chameneos 6000000\n+\tgcc -m64 -O2 chameneosredux.c -lpthread\t8.89u 56.62s 9.75r\n+\tgccgo -O2 chameneosredux.go\t9.48u 2.48s 11.99r # -33%\n+\tgc chameneosredux\t5.80u 0.00s 5.81r # -16%\n+"}, {"sha": "0539debb1f25249788954bf0704db109ae1d635b", "filename": "gcc/testsuite/go.test/test/blank.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -27,6 +27,10 @@ func (T) _() {\n func (T) _() {\n }\n \n+type U struct {\n+\t_ struct{ a, b, c int }\n+}\n+\n const (\n \tc0 = iota\n \t_\n@@ -107,15 +111,21 @@ func main() {\n \t\tpanic(sum)\n \t}\n \n-\t// exp/ssa/interp doesn't yet skip blank fields in struct\n-\t// equivalence.  It also cannot support unsafe.Pointer.\n+\t// go.tools/ssa/interp cannot support unsafe.Pointer.\n \tif os.Getenv(\"GOSSAINTERP\") == \"\" {\n \t\ttype T1 struct{ x, y, z int }\n \t\tt1 := *(*T)(unsafe.Pointer(&T1{1, 2, 3}))\n \t\tt2 := *(*T)(unsafe.Pointer(&T1{4, 5, 6}))\n \t\tif t1 != t2 {\n \t\t\tpanic(\"T{} != T{}\")\n \t\t}\n+\n+\t\tvar u1, u2 interface{}\n+\t\tu1 = *(*U)(unsafe.Pointer(&T1{1, 2, 3}))\n+\t\tu2 = *(*U)(unsafe.Pointer(&T1{4, 5, 6}))\n+\t\tif u1 != u2 {\n+\t\t\tpanic(\"U{} != U{}\")\n+\t\t}\n \t}\n \n \th(a, b)"}, {"sha": "54a72976b77c64a6cac7efd6fcfa21cc9e6ee1ea", "filename": "gcc/testsuite/go.test/test/blank1.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fblank1.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -13,9 +13,16 @@ var t struct {\n \t_ int\n }\n \n+type T struct {\n+      _ []int\n+}\n+\n func main() {\n \t_()\t// ERROR \"cannot use _ as value\"\n \tx := _+1\t// ERROR \"cannot use _ as value\"\n \t_ = x\n \t_ = t._ // ERROR \"cannot refer to blank field|invalid use of\"\n+\n+      var v1, v2 T\n+      _ = v1 == v2 // ERROR \"cannot be compared|non-comparable\"\n }"}, {"sha": "6be3faf55a940a30d5e5f6cc0447f52da1fdba88", "filename": "gcc/testsuite/go.test/test/chan/doubleselect.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fdoubleselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fdoubleselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fdoubleselect.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -36,7 +36,7 @@ func sender(n int, c1, c2, c3, c4 chan<- int) {\n }\n \n // mux receives the values from sender and forwards them onto another channel.\n-// It would be simplier to just have sender's four cases all be the same\n+// It would be simpler to just have sender's four cases all be the same\n // channel, but this doesn't actually trigger the bug.\n func mux(out chan<- int, in <-chan int, done chan<- bool) {\n \tfor v := range in {"}, {"sha": "ccf9dab81bc2aab83c599ee173ed3123dcf31f34", "filename": "gcc/testsuite/go.test/test/chan/select2.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect2.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -47,7 +47,8 @@ func main() {\n \truntime.GC()\n \truntime.ReadMemStats(memstats)\n \n-\tif memstats.Alloc-alloc > 1.1e5 {\n+\t// Be careful to avoid wraparound.\n+\tif memstats.Alloc > alloc && memstats.Alloc-alloc > 1.1e5 {\n \t\tprintln(\"BUG: too much memory for 100,000 selects:\", memstats.Alloc-alloc)\n \t}\n }"}, {"sha": "fa5a93354dce57c851dac4d49450c72ac56bef07", "filename": "gcc/testsuite/go.test/test/deferfin.go", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeferfin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeferfin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdeferfin.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,63 @@\n+// run\n+\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that defers do not prevent garbage collection.\n+\n+package main\n+\n+import (\n+\t\"runtime\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n+\t\"time\"\n+)\n+\n+var sink func()\n+\n+func main() {\n+\t// Does not work on 32-bits due to partially conservative GC.\n+\t// Try to enable when we have fully precise GC.\n+\tif runtime.GOARCH != \"amd64\" {\n+\t\treturn\n+\t}\n+\t// Likewise for gccgo.\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\treturn\n+\t}\n+\tN := 10\n+\tcount := int32(N)\n+\tvar wg sync.WaitGroup\n+\twg.Add(N)\n+\tfor i := 0; i < N; i++ {\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tv := new(int)\n+\t\t\tf := func() {\n+\t\t\t\tif *v != 0 {\n+\t\t\t\t\tpanic(\"oops\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif *v != 0 {\n+\t\t\t\t// let the compiler think f escapes\n+\t\t\t\tsink = f\n+\t\t\t}\n+\t\t\truntime.SetFinalizer(v, func(p *int) {\n+\t\t\t\tatomic.AddInt32(&count, -1)\n+\t\t\t})\n+\t\t\tdefer f()\n+\t\t}()\n+\t}\n+\twg.Wait()\n+\tfor i := 0; i < 3; i++ {\n+\t\ttime.Sleep(10 * time.Millisecond)\n+\t\truntime.GC()\n+\t}\n+\tif count != 0 {\n+\t\tprintln(count, \"out of\", N, \"finalizer are not called\")\n+\t\tpanic(\"not all finalizers are called\")\n+\t}\n+}\n+"}, {"sha": "49fed0222c6f8b8f01ac7f6a48dc760fb7e25108", "filename": "gcc/testsuite/go.test/test/divmod.go", "status": "added", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdivmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdivmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fdivmod.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,460 @@\n+// run\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test division of variables. Generate many test cases,\n+// compute correct answer using shift and subtract,\n+// and then compare against results from divison and\n+// modulus operators.\n+//\n+// Primarily useful for testing software div/mod.\n+\n+package main\n+\n+const long = false\n+\n+func main() {\n+\tif long {\n+\t\t// About 3e9 test cases (calls to checkdiv3).\n+\t\t// Too long for everyday testing.\n+\t\tgen2(3, 64, 2, 64, checkdiv1)\n+\t\tprintln(ntest)\n+\t} else {\n+\t\t// About 4e6 test cases (calls to checkdiv3).\n+\t\t// Runs for 8 seconds on ARM chromebook, much faster elsewhere.\n+\t\tgen2(2, 64, 1, 64, checkdiv1)\n+\t}\n+}\n+\n+// generate all uint64 values x where x has at most n bits set in the low w\n+// and call f(x) for each.\n+func gen1(n, w int, f func(uint64)) {\n+\tgen(0, 0, n, w-1, f)\n+}\n+\n+func gen(val uint64, nbits, maxbits, pos int, f func(uint64)) {\n+\tif pos < 0 {\n+\t\tf(val)\n+\t\treturn\n+\t}\n+\tgen(val, nbits, maxbits, pos-1, f)\n+\tif nbits < maxbits {\n+\t\tgen(val|1<<uint(pos), nbits+1, maxbits, pos-1, f)\n+\t}\n+}\n+\n+// generate all uint64 values x, y where x has at most n1 bits set in the low w1\n+// and y has at most n2 bits set in the low w2 and call f(x, y) for each.\n+func gen2(n1, w1, n2, w2 int, f func(uint64, uint64)) {\n+\tgen1(n1, w1, func(x uint64) {\n+\t\tgen1(n2, w2, func(y uint64) {\n+\t\t\tf(x, y)\n+\t\t})\n+\t})\n+}\n+\n+// x and y are uint64s with at most 2 bits set.\n+// Check those values and values above and below,\n+// along with bitwise inversions of the same (done in checkdiv2).\n+func checkdiv1(x, y uint64) {\n+\tcheckdiv2(x, y)\n+\t// If the low bit is set in x or y, adding or subtracting 1\n+\t// produces a number that checkdiv1 is going to be called\n+\t// with anyway, so don't duplicate effort.\n+\tif x&1 == 0 {\n+\t\tcheckdiv2(x+1, y)\n+\t\tcheckdiv2(x-1, y)\n+\t}\n+\tif y&1 == 0 {\n+\t\tcheckdiv2(x, y-1)\n+\t\tcheckdiv2(x, y+1)\n+\t\tif x&1 == 0 {\n+\t\t\tcheckdiv2(x+1, y-1)\n+\t\t\tcheckdiv2(x-1, y-1)\n+\t\t\tcheckdiv2(x-1, y+1)\n+\t\t\tcheckdiv2(x+1, y+1)\n+\t\t}\n+\t}\n+}\n+\n+func checkdiv2(x, y uint64) {\n+\tcheckdiv3(x, y)\n+\tcheckdiv3(^x, y)\n+\tcheckdiv3(x, ^y)\n+\tcheckdiv3(^x, ^y)\n+}\n+\n+var ntest int64 = 0\n+\n+func checkdiv3(x, y uint64) {\n+\tntest++\n+\tif ntest&(ntest-1) == 0 && long {\n+\t\tprintln(ntest, \"...\")\n+\t}\n+\tcheckuint64(x, y)\n+\tif (uint64(uint32(x)) == x || uint64(uint32(^x)) == ^x) && (uint64(uint32(y)) == y || uint64(uint32(^y)) == ^y) {\n+\t\tcheckuint32(uint32(x), uint32(y))\n+\t}\n+\tif (uint64(uint16(x)) == x || uint64(uint16(^x)) == ^x) && (uint64(uint16(y)) == y || uint64(uint16(^y)) == ^y) {\n+\t\tcheckuint16(uint16(x), uint16(y))\n+\t}\n+\tif (uint64(uint8(x)) == x || uint64(uint8(^x)) == ^x) && (uint64(uint8(y)) == y || uint64(uint8(^y)) == ^y) {\n+\t\tcheckuint8(uint8(x), uint8(y))\n+\t}\n+\t\n+\t\n+\tsx := int64(x)\n+\tsy := int64(y)\n+\tcheckint64(sx, sy)\n+\tif (int64(int32(sx)) == sx || int64(int32(^sx)) == ^sx) && (int64(int32(sy)) == sy || int64(int32(^sy)) == ^sy) {\n+\t\tcheckint32(int32(sx), int32(sy))\n+\t}\n+\tif (int64(int16(sx)) == sx || int64(int16(^sx)) == ^sx) && (int64(int16(sy)) == sy || int64(int16(^sy)) == ^sy) {\n+\t\tcheckint16(int16(sx), int16(sy))\n+\t}\n+\tif (int64(int8(sx)) == sx || int64(int8(^sx)) == ^sx) && (int64(int8(sy)) == sy || int64(int8(^sy)) == ^sy) {\n+\t\tcheckint8(int8(sx), int8(sy))\n+\t}\n+}\n+\n+// Check result of x/y, x%y for various types.\n+\n+func checkuint(x, y uint) {\n+\tif y == 0 {\n+\t\tdivzerouint(x, y)\n+\t\tmodzerouint(x, y)\n+\t\treturn\n+\t}\n+\tq, r := udiv(uint64(x), uint64(y))\n+\tq1 := x/y\n+\tr1 := x%y\n+\tif q1 != uint(q) {\n+\t\tprint(\"uint(\", x, \"/\", y, \") = \", q1, \", want \", q, \"\\n\")\n+\t}\n+\tif r1 != uint(r) {\n+\t\tprint(\"uint(\", x, \"%\", y, \") = \", r1, \", want \", r, \"\\n\")\n+\t}\n+}\n+\n+func checkuint64(x, y uint64) {\n+\tif y == 0 {\n+\t\tdivzerouint64(x, y)\n+\t\tmodzerouint64(x, y)\n+\t\treturn\n+\t}\n+\tq, r := udiv(x, y)\n+\tq1 := x/y\n+\tr1 := x%y\n+\tif q1 != q {\n+\t\tprint(\"uint64(\", x, \"/\", y, \") = \", q1, \", want \", q, \"\\n\")\n+\t}\n+\tif r1 != r {\n+\t\tprint(\"uint64(\", x, \"%\", y, \") = \", r1, \", want \", r, \"\\n\")\n+\t}\n+}\n+\n+func checkuint32(x, y uint32) {\n+\tif y == 0 {\n+\t\tdivzerouint32(x, y)\n+\t\tmodzerouint32(x, y)\n+\t\treturn\n+\t}\n+\tq, r := udiv(uint64(x), uint64(y))\n+\tq1 := x/y\n+\tr1 := x%y\n+\tif q1 != uint32(q) {\n+\t\tprint(\"uint32(\", x, \"/\", y, \") = \", q1, \", want \", q, \"\\n\")\n+\t}\n+\tif r1 != uint32(r) {\n+\t\tprint(\"uint32(\", x, \"%\", y, \") = \", r1, \", want \", r, \"\\n\")\n+\t}\n+}\n+\n+func checkuint16(x, y uint16) {\n+\tif y == 0 {\n+\t\tdivzerouint16(x, y)\n+\t\tmodzerouint16(x, y)\n+\t\treturn\n+\t}\n+\tq, r := udiv(uint64(x), uint64(y))\n+\tq1 := x/y\n+\tr1 := x%y\n+\tif q1 != uint16(q) {\n+\t\tprint(\"uint16(\", x, \"/\", y, \") = \", q1, \", want \", q, \"\\n\")\n+\t}\n+\tif r1 != uint16(r) {\n+\t\tprint(\"uint16(\", x, \"%\", y, \") = \", r1, \", want \", r, \"\\n\")\n+\t}\n+}\n+\n+func checkuint8(x, y uint8) {\n+\tif y == 0 {\n+\t\tdivzerouint8(x, y)\n+\t\tmodzerouint8(x, y)\n+\t\treturn\n+\t}\n+\tq, r := udiv(uint64(x), uint64(y))\n+\tq1 := x/y\n+\tr1 := x%y\n+\tif q1 != uint8(q) {\n+\t\tprint(\"uint8(\", x, \"/\", y, \") = \", q1, \", want \", q, \"\\n\")\n+\t}\n+\tif r1 != uint8(r) {\n+\t\tprint(\"uint8(\", x, \"%\", y, \") = \", r1, \", want \", r, \"\\n\")\n+\t}\n+}\n+\n+func checkint(x, y int) {\n+\tif y == 0 {\n+\t\tdivzeroint(x, y)\n+\t\tmodzeroint(x, y)\n+\t\treturn\n+\t}\n+\tq, r := idiv(int64(x), int64(y))\n+\tq1 := x/y\n+\tr1 := x%y\n+\tif q1 != int(q) {\n+\t\tprint(\"int(\", x, \"/\", y, \") = \", q1, \", want \", q, \"\\n\")\n+\t}\n+\tif r1 != int(r) {\n+\t\tprint(\"int(\", x, \"%\", y, \") = \", r1, \", want \", r, \"\\n\")\n+\t}\n+}\n+\n+func checkint64(x, y int64) {\n+\tif y == 0 {\n+\t\tdivzeroint64(x, y)\n+\t\tmodzeroint64(x, y)\n+\t\treturn\n+\t}\n+\tq, r := idiv(x, y)\n+\tq1 := x/y\n+\tr1 := x%y\n+\tif q1 != q {\n+\t\tprint(\"int64(\", x, \"/\", y, \") = \", q1, \", want \", q, \"\\n\")\n+\t}\n+\tif r1 != r {\n+\t\tprint(\"int64(\", x, \"%\", y, \") = \", r1, \", want \", r, \"\\n\")\n+\t}\n+}\n+\n+func checkint32(x, y int32) {\n+\tif y == 0 {\n+\t\tdivzeroint32(x, y)\n+\t\tmodzeroint32(x, y)\n+\t\treturn\n+\t}\n+\tq, r := idiv(int64(x), int64(y))\n+\tq1 := x/y\n+\tr1 := x%y\n+\tif q1 != int32(q) {\n+\t\tprint(\"int32(\", x, \"/\", y, \") = \", q1, \", want \", q, \"\\n\")\n+\t}\n+\tif r1 != int32(r) {\n+\t\tprint(\"int32(\", x, \"%\", y, \") = \", r1, \", want \", r, \"\\n\")\n+\t}\n+}\n+\n+func checkint16(x, y int16) {\n+\tif y == 0 {\n+\t\tdivzeroint16(x, y)\n+\t\tmodzeroint16(x, y)\n+\t\treturn\n+\t}\n+\tq, r := idiv(int64(x), int64(y))\n+\tq1 := x/y\n+\tr1 := x%y\n+\tif q1 != int16(q) {\n+\t\tprint(\"int16(\", x, \"/\", y, \") = \", q1, \", want \", q, \"\\n\")\n+\t}\n+\tif r1 != int16(r) {\n+\t\tprint(\"int16(\", x, \"%\", y, \") = \", r1, \", want \", r, \"\\n\")\n+\t}\n+}\n+\n+func checkint8(x, y int8) {\n+\tif y == 0 {\n+\t\tdivzeroint8(x, y)\n+\t\tmodzeroint8(x, y)\n+\t\treturn\n+\t}\n+\tq, r := idiv(int64(x), int64(y))\n+\tq1 := x/y\n+\tr1 := x%y\n+\tif q1 != int8(q) {\n+\t\tprint(\"int8(\", x, \"/\", y, \") = \", q1, \", want \", q, \"\\n\")\n+\t}\n+\tif r1 != int8(r) {\n+\t\tprint(\"int8(\", x, \"%\", y, \") = \", r1, \", want \", r, \"\\n\")\n+\t}\n+}\n+\n+func divzerouint(x, y uint) uint {\n+\tdefer checkudivzero(\"uint\", uint64(x))\n+\treturn x / y\n+}\n+\n+func divzerouint64(x, y uint64) uint64 {\n+\tdefer checkudivzero(\"uint64\", uint64(x))\n+\treturn x / y\n+}\n+\n+func divzerouint32(x, y uint32) uint32 {\n+\tdefer checkudivzero(\"uint32\", uint64(x))\n+\treturn x / y\n+}\n+\n+func divzerouint16(x, y uint16) uint16 {\n+\tdefer checkudivzero(\"uint16\", uint64(x))\n+\treturn x / y\n+}\n+\n+func divzerouint8(x, y uint8) uint8 {\n+\tdefer checkudivzero(\"uint8\", uint64(x))\n+\treturn x / y\n+}\n+\n+func checkudivzero(typ string, x uint64) {\n+\tif recover() == nil {\n+\t\tprint(typ, \"(\", x, \" / 0) did not panic\")\n+\t}\n+}\n+\n+func divzeroint(x, y int) int {\n+\tdefer checkdivzero(\"int\", int64(x))\n+\treturn x / y\n+}\n+\n+func divzeroint64(x, y int64) int64 {\n+\tdefer checkdivzero(\"int64\", int64(x))\n+\treturn x / y\n+}\n+\n+func divzeroint32(x, y int32) int32 {\n+\tdefer checkdivzero(\"int32\", int64(x))\n+\treturn x / y\n+}\n+\n+func divzeroint16(x, y int16) int16 {\n+\tdefer checkdivzero(\"int16\", int64(x))\n+\treturn x / y\n+}\n+\n+func divzeroint8(x, y int8) int8 {\n+\tdefer checkdivzero(\"int8\", int64(x))\n+\treturn x / y\n+}\n+\n+func checkdivzero(typ string, x int64) {\n+\tif recover() == nil {\n+\t\tprint(typ, \"(\", x, \" / 0) did not panic\")\n+\t}\n+}\n+\n+func modzerouint(x, y uint) uint {\n+\tdefer checkumodzero(\"uint\", uint64(x))\n+\treturn x % y\n+}\n+\n+func modzerouint64(x, y uint64) uint64 {\n+\tdefer checkumodzero(\"uint64\", uint64(x))\n+\treturn x % y\n+}\n+\n+func modzerouint32(x, y uint32) uint32 {\n+\tdefer checkumodzero(\"uint32\", uint64(x))\n+\treturn x % y\n+}\n+\n+func modzerouint16(x, y uint16) uint16 {\n+\tdefer checkumodzero(\"uint16\", uint64(x))\n+\treturn x % y\n+}\n+\n+func modzerouint8(x, y uint8) uint8 {\n+\tdefer checkumodzero(\"uint8\", uint64(x))\n+\treturn x % y\n+}\n+\n+func checkumodzero(typ string, x uint64) {\n+\tif recover() == nil {\n+\t\tprint(typ, \"(\", x, \" % 0) did not panic\")\n+\t}\n+}\n+\n+func modzeroint(x, y int) int {\n+\tdefer checkmodzero(\"int\", int64(x))\n+\treturn x % y\n+}\n+\n+func modzeroint64(x, y int64) int64 {\n+\tdefer checkmodzero(\"int64\", int64(x))\n+\treturn x % y\n+}\n+\n+func modzeroint32(x, y int32) int32 {\n+\tdefer checkmodzero(\"int32\", int64(x))\n+\treturn x % y\n+}\n+\n+func modzeroint16(x, y int16) int16 {\n+\tdefer checkmodzero(\"int16\", int64(x))\n+\treturn x % y\n+}\n+\n+func modzeroint8(x, y int8) int8 {\n+\tdefer checkmodzero(\"int8\", int64(x))\n+\treturn x % y\n+}\n+\n+func checkmodzero(typ string, x int64) {\n+\tif recover() == nil {\n+\t\tprint(typ, \"(\", x, \" % 0) did not panic\")\n+\t}\n+}\n+\n+// unsigned divide and mod using shift and subtract.\n+func udiv(x, y uint64) (q, r uint64) {\n+\tsh := 0\n+\tfor y+y > y && y+y <= x {\n+\t\tsh++\n+\t\ty <<= 1\n+\t}\n+\tfor ; sh >= 0; sh-- {\n+\t\tq <<= 1\n+\t\tif x >= y {\n+\t\t\tx -= y\n+\t\t\tq |= 1\n+\t\t}\n+\t\ty >>= 1\n+\t}\n+\treturn q, x\t\n+}\n+\n+// signed divide and mod: do unsigned and adjust signs.\n+func idiv(x, y int64) (q, r int64) {\n+\t// special case for minint / -1 = minint\n+\tif x-1 > x && y == -1 {\n+\t\treturn x, 0\n+\t}\n+\tux := uint64(x)\n+\tuy := uint64(y)\n+\tif x < 0 {\n+\t\tux = -ux\n+\t}\n+\tif y < 0 {\n+\t\tuy = -uy\n+\t}\n+\tuq, ur := udiv(ux, uy)\n+\tq = int64(uq)\n+\tr = int64(ur)\n+\tif x < 0 {\n+\t\tr = -r\n+\t}\n+\tif (x < 0) != (y < 0) {\n+\t\tq = -q\n+\t}\n+\treturn q, r\n+}"}, {"sha": "de0c4fd2f87c71faa12b41a727091a37086818fe", "filename": "gcc/testsuite/go.test/test/errchk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ferrchk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ferrchk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ferrchk?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/perl\n+#!/usr/bin/env perl\n # Copyright 2009 The Go Authors. All rights reserved.\n # Use of this source code is governed by a BSD-style\n # license that can be found in the LICENSE file."}, {"sha": "be89c2d84082b86e517e3a8ab9564b8122abf424", "filename": "gcc/testsuite/go.test/test/escape2.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fescape2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fescape2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fescape2.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -1136,6 +1136,7 @@ func foo126() {\n \t\t\tpx = &i // ERROR \"&i escapes\"\n \t\t}()\n \t}\n+\t_ = px\n }\n \n var px *int\n@@ -1325,3 +1326,34 @@ func foo142() {\n \tt := new(Tm) // ERROR \"escapes to heap\"\n \tgf = t.M // ERROR \"t.M escapes to heap\"\n }\n+\n+// issue 3888.\n+func foo143() {\n+\tfor i := 0; i < 1000; i++ {\n+\t\tfunc() { // ERROR \"func literal does not escape\"\n+\t\t\tfor i := 0; i < 1; i++ {\n+\t\t\t\tvar t Tm\n+\t\t\t\tt.M() // ERROR \"t does not escape\"\n+\t\t\t}\n+\t\t}()\n+\t}\n+}\n+\n+// issue 5773\n+// Check that annotations take effect regardless of whether they\n+// are before or after the use in the source code.\n+\n+//go:noescape\n+\n+func foo144a(*int)\n+\n+func foo144() {\n+\tvar x int\n+\tfoo144a(&x) // ERROR \"&x does not escape\"\n+\tvar y int\n+\tfoo144b(&y) // ERROR \"&y does not escape\"\n+}\n+\n+//go:noescape\n+\n+func foo144b(*int)"}, {"sha": "c9646872d51ac54486b3a000caad76c5afdc25ac", "filename": "gcc/testsuite/go.test/test/escape5.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fescape5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fescape5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fescape5.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -142,3 +142,10 @@ func f9() {\n \tvar j T1 // ERROR \"moved to heap: j\"\n \tf8(&j) // ERROR \"&j escapes to heap\"\n }\n+\n+func f10() {\n+\t// These don't escape but are too big for the stack\n+\tvar x [1<<30]byte // ERROR \"moved to heap: x\"\n+\tvar y = make([]byte, 1<<30) // ERROR \"does not escape\"\n+\t_ = x[0] + y[0]\n+}"}, {"sha": "139a8a3a2307d0814548dc16ba0a908e3a280e19", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug191.dir/a.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug191.dir%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug191.dir%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug191.dir%2Fa.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -4,8 +4,10 @@\n \n package a\n \n+var A int\n+\n func init() {\n-\tprintln(\"a\");\n+\tA = 1\n }\n \n type T int;"}, {"sha": "36770f6fc99e3f814ec16dd13d4d2f305a81dc98", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug191.dir/b.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug191.dir%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug191.dir%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug191.dir%2Fb.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -4,8 +4,10 @@\n \n package b\n \n+var B int\n+\n func init() {\n-\tprintln(\"b\");\n+\tB = 2\n }\n \n type V int;"}, {"sha": "2d24dd12d5293d97e7891dd52493e2e393e8cc68", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug191.dir/main.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug191.dir%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug191.dir%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug191.dir%2Fmain.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -11,4 +11,7 @@ var _ T\n var _ V\n \n func main() {\n+\tif A != 1 || B != 2 {\n+\t\tpanic(\"wrong vars\")\n+\t}\n }"}, {"sha": "63a12a3a741883b320c00887896bc21aa360cdc4", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug295.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug295.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug295.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug295.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -6,7 +6,9 @@\n \n package main\n \n-import . \"testing\"  // defines top-level T\n+import . \"testing\"  // defines file-level T\n+\n+type _ B // make use of package \"testing\" (but don't refer to T)\n \n type S struct {\n \tT int"}, {"sha": "6789c0abf0f7d6f8d5063e9d58f5d721cbb53dae", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug385_64.go", "status": "modified", "additions": 209, "deletions": 8, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug385_64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug385_64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug385_64.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -10,13 +10,214 @@\n \n package main\n \n-func main() { // GC_ERROR \"stack frame too large\"\n-\tvar arr [1000200030]int32\n-\tarr_bkup := arr\n-\t_ = arr_bkup\n-}\n+var z [10<<20]byte\n \n-func F() { // GC_ERROR \"stack frame too large\"\n-\tvar arr [1 << 30]int32\n-\t_ = arr[42]\n+func main() { // GC_ERROR \"stack frame too large\"\n+\t// seq 1 206 | sed 's/.*/\tvar x& [10<<20]byte; z = x&/'\n+\tvar x1 [10<<20]byte; z = x1\n+\tvar x2 [10<<20]byte; z = x2\n+\tvar x3 [10<<20]byte; z = x3\n+\tvar x4 [10<<20]byte; z = x4\n+\tvar x5 [10<<20]byte; z = x5\n+\tvar x6 [10<<20]byte; z = x6\n+\tvar x7 [10<<20]byte; z = x7\n+\tvar x8 [10<<20]byte; z = x8\n+\tvar x9 [10<<20]byte; z = x9\n+\tvar x10 [10<<20]byte; z = x10\n+\tvar x11 [10<<20]byte; z = x11\n+\tvar x12 [10<<20]byte; z = x12\n+\tvar x13 [10<<20]byte; z = x13\n+\tvar x14 [10<<20]byte; z = x14\n+\tvar x15 [10<<20]byte; z = x15\n+\tvar x16 [10<<20]byte; z = x16\n+\tvar x17 [10<<20]byte; z = x17\n+\tvar x18 [10<<20]byte; z = x18\n+\tvar x19 [10<<20]byte; z = x19\n+\tvar x20 [10<<20]byte; z = x20\n+\tvar x21 [10<<20]byte; z = x21\n+\tvar x22 [10<<20]byte; z = x22\n+\tvar x23 [10<<20]byte; z = x23\n+\tvar x24 [10<<20]byte; z = x24\n+\tvar x25 [10<<20]byte; z = x25\n+\tvar x26 [10<<20]byte; z = x26\n+\tvar x27 [10<<20]byte; z = x27\n+\tvar x28 [10<<20]byte; z = x28\n+\tvar x29 [10<<20]byte; z = x29\n+\tvar x30 [10<<20]byte; z = x30\n+\tvar x31 [10<<20]byte; z = x31\n+\tvar x32 [10<<20]byte; z = x32\n+\tvar x33 [10<<20]byte; z = x33\n+\tvar x34 [10<<20]byte; z = x34\n+\tvar x35 [10<<20]byte; z = x35\n+\tvar x36 [10<<20]byte; z = x36\n+\tvar x37 [10<<20]byte; z = x37\n+\tvar x38 [10<<20]byte; z = x38\n+\tvar x39 [10<<20]byte; z = x39\n+\tvar x40 [10<<20]byte; z = x40\n+\tvar x41 [10<<20]byte; z = x41\n+\tvar x42 [10<<20]byte; z = x42\n+\tvar x43 [10<<20]byte; z = x43\n+\tvar x44 [10<<20]byte; z = x44\n+\tvar x45 [10<<20]byte; z = x45\n+\tvar x46 [10<<20]byte; z = x46\n+\tvar x47 [10<<20]byte; z = x47\n+\tvar x48 [10<<20]byte; z = x48\n+\tvar x49 [10<<20]byte; z = x49\n+\tvar x50 [10<<20]byte; z = x50\n+\tvar x51 [10<<20]byte; z = x51\n+\tvar x52 [10<<20]byte; z = x52\n+\tvar x53 [10<<20]byte; z = x53\n+\tvar x54 [10<<20]byte; z = x54\n+\tvar x55 [10<<20]byte; z = x55\n+\tvar x56 [10<<20]byte; z = x56\n+\tvar x57 [10<<20]byte; z = x57\n+\tvar x58 [10<<20]byte; z = x58\n+\tvar x59 [10<<20]byte; z = x59\n+\tvar x60 [10<<20]byte; z = x60\n+\tvar x61 [10<<20]byte; z = x61\n+\tvar x62 [10<<20]byte; z = x62\n+\tvar x63 [10<<20]byte; z = x63\n+\tvar x64 [10<<20]byte; z = x64\n+\tvar x65 [10<<20]byte; z = x65\n+\tvar x66 [10<<20]byte; z = x66\n+\tvar x67 [10<<20]byte; z = x67\n+\tvar x68 [10<<20]byte; z = x68\n+\tvar x69 [10<<20]byte; z = x69\n+\tvar x70 [10<<20]byte; z = x70\n+\tvar x71 [10<<20]byte; z = x71\n+\tvar x72 [10<<20]byte; z = x72\n+\tvar x73 [10<<20]byte; z = x73\n+\tvar x74 [10<<20]byte; z = x74\n+\tvar x75 [10<<20]byte; z = x75\n+\tvar x76 [10<<20]byte; z = x76\n+\tvar x77 [10<<20]byte; z = x77\n+\tvar x78 [10<<20]byte; z = x78\n+\tvar x79 [10<<20]byte; z = x79\n+\tvar x80 [10<<20]byte; z = x80\n+\tvar x81 [10<<20]byte; z = x81\n+\tvar x82 [10<<20]byte; z = x82\n+\tvar x83 [10<<20]byte; z = x83\n+\tvar x84 [10<<20]byte; z = x84\n+\tvar x85 [10<<20]byte; z = x85\n+\tvar x86 [10<<20]byte; z = x86\n+\tvar x87 [10<<20]byte; z = x87\n+\tvar x88 [10<<20]byte; z = x88\n+\tvar x89 [10<<20]byte; z = x89\n+\tvar x90 [10<<20]byte; z = x90\n+\tvar x91 [10<<20]byte; z = x91\n+\tvar x92 [10<<20]byte; z = x92\n+\tvar x93 [10<<20]byte; z = x93\n+\tvar x94 [10<<20]byte; z = x94\n+\tvar x95 [10<<20]byte; z = x95\n+\tvar x96 [10<<20]byte; z = x96\n+\tvar x97 [10<<20]byte; z = x97\n+\tvar x98 [10<<20]byte; z = x98\n+\tvar x99 [10<<20]byte; z = x99\n+\tvar x100 [10<<20]byte; z = x100\n+\tvar x101 [10<<20]byte; z = x101\n+\tvar x102 [10<<20]byte; z = x102\n+\tvar x103 [10<<20]byte; z = x103\n+\tvar x104 [10<<20]byte; z = x104\n+\tvar x105 [10<<20]byte; z = x105\n+\tvar x106 [10<<20]byte; z = x106\n+\tvar x107 [10<<20]byte; z = x107\n+\tvar x108 [10<<20]byte; z = x108\n+\tvar x109 [10<<20]byte; z = x109\n+\tvar x110 [10<<20]byte; z = x110\n+\tvar x111 [10<<20]byte; z = x111\n+\tvar x112 [10<<20]byte; z = x112\n+\tvar x113 [10<<20]byte; z = x113\n+\tvar x114 [10<<20]byte; z = x114\n+\tvar x115 [10<<20]byte; z = x115\n+\tvar x116 [10<<20]byte; z = x116\n+\tvar x117 [10<<20]byte; z = x117\n+\tvar x118 [10<<20]byte; z = x118\n+\tvar x119 [10<<20]byte; z = x119\n+\tvar x120 [10<<20]byte; z = x120\n+\tvar x121 [10<<20]byte; z = x121\n+\tvar x122 [10<<20]byte; z = x122\n+\tvar x123 [10<<20]byte; z = x123\n+\tvar x124 [10<<20]byte; z = x124\n+\tvar x125 [10<<20]byte; z = x125\n+\tvar x126 [10<<20]byte; z = x126\n+\tvar x127 [10<<20]byte; z = x127\n+\tvar x128 [10<<20]byte; z = x128\n+\tvar x129 [10<<20]byte; z = x129\n+\tvar x130 [10<<20]byte; z = x130\n+\tvar x131 [10<<20]byte; z = x131\n+\tvar x132 [10<<20]byte; z = x132\n+\tvar x133 [10<<20]byte; z = x133\n+\tvar x134 [10<<20]byte; z = x134\n+\tvar x135 [10<<20]byte; z = x135\n+\tvar x136 [10<<20]byte; z = x136\n+\tvar x137 [10<<20]byte; z = x137\n+\tvar x138 [10<<20]byte; z = x138\n+\tvar x139 [10<<20]byte; z = x139\n+\tvar x140 [10<<20]byte; z = x140\n+\tvar x141 [10<<20]byte; z = x141\n+\tvar x142 [10<<20]byte; z = x142\n+\tvar x143 [10<<20]byte; z = x143\n+\tvar x144 [10<<20]byte; z = x144\n+\tvar x145 [10<<20]byte; z = x145\n+\tvar x146 [10<<20]byte; z = x146\n+\tvar x147 [10<<20]byte; z = x147\n+\tvar x148 [10<<20]byte; z = x148\n+\tvar x149 [10<<20]byte; z = x149\n+\tvar x150 [10<<20]byte; z = x150\n+\tvar x151 [10<<20]byte; z = x151\n+\tvar x152 [10<<20]byte; z = x152\n+\tvar x153 [10<<20]byte; z = x153\n+\tvar x154 [10<<20]byte; z = x154\n+\tvar x155 [10<<20]byte; z = x155\n+\tvar x156 [10<<20]byte; z = x156\n+\tvar x157 [10<<20]byte; z = x157\n+\tvar x158 [10<<20]byte; z = x158\n+\tvar x159 [10<<20]byte; z = x159\n+\tvar x160 [10<<20]byte; z = x160\n+\tvar x161 [10<<20]byte; z = x161\n+\tvar x162 [10<<20]byte; z = x162\n+\tvar x163 [10<<20]byte; z = x163\n+\tvar x164 [10<<20]byte; z = x164\n+\tvar x165 [10<<20]byte; z = x165\n+\tvar x166 [10<<20]byte; z = x166\n+\tvar x167 [10<<20]byte; z = x167\n+\tvar x168 [10<<20]byte; z = x168\n+\tvar x169 [10<<20]byte; z = x169\n+\tvar x170 [10<<20]byte; z = x170\n+\tvar x171 [10<<20]byte; z = x171\n+\tvar x172 [10<<20]byte; z = x172\n+\tvar x173 [10<<20]byte; z = x173\n+\tvar x174 [10<<20]byte; z = x174\n+\tvar x175 [10<<20]byte; z = x175\n+\tvar x176 [10<<20]byte; z = x176\n+\tvar x177 [10<<20]byte; z = x177\n+\tvar x178 [10<<20]byte; z = x178\n+\tvar x179 [10<<20]byte; z = x179\n+\tvar x180 [10<<20]byte; z = x180\n+\tvar x181 [10<<20]byte; z = x181\n+\tvar x182 [10<<20]byte; z = x182\n+\tvar x183 [10<<20]byte; z = x183\n+\tvar x184 [10<<20]byte; z = x184\n+\tvar x185 [10<<20]byte; z = x185\n+\tvar x186 [10<<20]byte; z = x186\n+\tvar x187 [10<<20]byte; z = x187\n+\tvar x188 [10<<20]byte; z = x188\n+\tvar x189 [10<<20]byte; z = x189\n+\tvar x190 [10<<20]byte; z = x190\n+\tvar x191 [10<<20]byte; z = x191\n+\tvar x192 [10<<20]byte; z = x192\n+\tvar x193 [10<<20]byte; z = x193\n+\tvar x194 [10<<20]byte; z = x194\n+\tvar x195 [10<<20]byte; z = x195\n+\tvar x196 [10<<20]byte; z = x196\n+\tvar x197 [10<<20]byte; z = x197\n+\tvar x198 [10<<20]byte; z = x198\n+\tvar x199 [10<<20]byte; z = x199\n+\tvar x200 [10<<20]byte; z = x200\n+\tvar x201 [10<<20]byte; z = x201\n+\tvar x202 [10<<20]byte; z = x202\n+\tvar x203 [10<<20]byte; z = x203\n+\tvar x204 [10<<20]byte; z = x204\n+\tvar x205 [10<<20]byte; z = x205\n+\tvar x206 [10<<20]byte; z = x206\n }"}, {"sha": "45323d8eed6be2c97cd2ff4e8fc37a57840a69d3", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug435.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug435.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug435.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug435.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -12,4 +12,4 @@\n package main\n \n func foo() {\n-\tbar(1, // ERROR \"unexpected|missing|undefined\"\n+\tbar(1, // ERROR \"unexpected|missing|undefined\"\n\\ No newline at end of file"}, {"sha": "29049d9aae5779539fe0bf7c680f0a22674d6a0c", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug460.dir/a.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug460.dir%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug460.dir%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug460.dir%2Fa.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -6,4 +6,8 @@ package a\n \n type Foo struct {\n \tint\n+\tint8\n+\terror\n+\trune\n+\tbyte\n }"}, {"sha": "5c0a0c47e3c164eff5ab2612663c2fb9c4f00d72", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug460.dir/b.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug460.dir%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug460.dir%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug460.dir%2Fb.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -9,6 +9,9 @@ import \"./a\"\n var x a.Foo\n \n func main() {\n-\tx.int = 20 // ERROR \"unexported field\"\n+\tx.int = 20    // ERROR \"unexported field\"\n+\tx.int8 = 20   // ERROR \"unexported field\"\n+\tx.error = nil // ERROR \"unexported field\"\n+\tx.rune = 'a'  // ERROR \"unexported field\"\n+\tx.byte = 20   // ERROR \"unexported field\"\n }\n-"}, {"sha": "1bd6fa35ce7ac1324483d28f72a9608f3f7064fc", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug475.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug475.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug475.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug475.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,22 @@\n+// compile\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Variable in enclosing function with same name as field in struct\n+// composite literal confused gccgo.\n+\n+package p\n+\n+type s1 struct {\n+\tf *s1\n+}\n+\n+func F() {\n+\tvar f *s1\n+\t_ = func() {\n+\t\t_ = s1{f: nil}\n+\t}\n+\t_ = f\n+}"}, {"sha": "4ea2174048402a20004a25889198fd9e2526850d", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug476.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug476.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug476.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug476.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,23 @@\n+// compile\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Logical operation on named boolean type returns the same type,\n+// supporting an implicit convertion to an interface type.  This used\n+// to crash gccgo.\n+\n+package p\n+\n+type B bool\n+\n+func (b B) M() {}\n+\n+type I interface {\n+\tM()\n+}\n+\n+func F(a, b B) I {\n+\treturn a && b\n+}"}, {"sha": "86289afa6db2305292f2470dad0a22a6aa256ea4", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug477.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug477.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug477.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug477.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,34 @@\n+// compile\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test multiple identical unnamed structs with methods.  This caused\n+// a compilation error with gccgo.\n+\n+package p\n+\n+type S1 struct{}\n+\n+func (s S1) M() {}\n+\n+type S2 struct {\n+\tF1 struct {\n+\t\tS1\n+\t}\n+\tF2 struct {\n+\t\tS1\n+\t}\n+}\n+\n+type I interface {\n+\tM()\n+}\n+\n+func F() {\n+\tvar s2 S2\n+\tvar i1 I = s2.F1\n+\tvar i2 I = s2.F2\n+\t_, _ = i1, i2\n+}"}, {"sha": "a40e454f9b1a269cd0768874c00bedbc43c2b442", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug478.dir/a.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug478.dir%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug478.dir%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug478.dir%2Fa.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p1\n+\n+type S1 struct{}\n+\n+func (s S1) f() {}"}, {"sha": "c0fdf1127b42a6dbaefcf7d5861d5c92e290249d", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug478.dir/b.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug478.dir%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug478.dir%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug478.dir%2Fb.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p2\n+\n+import \"./a\"\n+\n+type S2 struct {\n+\tp1.S1\n+}\n+\n+func (s S2) f() {}"}, {"sha": "5e339e801d5825c1bc8bbbdfdf5201680310cfd7", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug478.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug478.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug478.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug478.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,10 @@\n+// compiledir\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Using the same unexported name for a method as a method on an\n+// imported embedded type caused a gccgo compilation failure.\n+\n+package ignored"}, {"sha": "5ff3bef1d16241f66590d5da40cb0df5fba7631e", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug479.dir/a.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug479.dir%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug479.dir%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug479.dir%2Fa.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+import \"unsafe\"\n+\n+type S2 struct {}\n+\n+const C = unsafe.Sizeof(S2{})\n+\n+type S1 struct {\n+\tS2\n+}"}, {"sha": "a1b27b3326414e43b48a0f7d6779dd230b145795", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug479.dir/b.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug479.dir%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug479.dir%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug479.dir%2Fb.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"./a\"\n+\n+type S3 struct {\n+\tp.S1\n+}\n+\n+func main() {\n+\tvar i interface{} = S3{}\n+\t_ = i\n+}"}, {"sha": "f8a0f93c736c74ca8cd24353176a4edcb15ce349", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug479.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug479.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug479.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug479.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,10 @@\n+// rundir\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Gccgo was not consistent in deciding how to compare a struct type\n+// for equality, leading to an undefined symbol at link time.\n+\n+package ignored"}, {"sha": "6dff51586b7be9a902246db20254101c34b366d6", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug480.dir/a.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug480.dir%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug480.dir%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug480.dir%2Fa.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package a\n+\n+type S interface{\n+\tF() T\n+}\n+\n+type T struct {\n+\tS\n+}\n+\n+type U struct {\n+\terror\n+}"}, {"sha": "620736540aec1a6f2e547a7a70a3991bfb2fcaf5", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug480.dir/b.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug480.dir%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug480.dir%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug480.dir%2Fb.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package b\n+\n+import \"./a\"\n+\n+var t a.T\n+\n+func F() error {\n+\treturn a.U{}\n+}"}, {"sha": "5b44af43083b251b321090be7a46050d705b53ad", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug480.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug480.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug480.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug480.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,9 @@\n+// compiledir\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Gccgo mishandled an import of a forward declared type.\n+\n+package ignored"}, {"sha": "d0922a5a4ff16820faf63d837533c3d2349492df", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug481.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug481.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug481.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug481.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,18 @@\n+// compile\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Returning an index into a conversion from string to slice caused a\n+// compilation error when using gccgo.\n+\n+package p\n+\n+func F1(s string) byte {\n+\treturn []byte(s)[0]\n+}\n+\n+func F2(s string) rune {\n+\treturn []rune(s)[0]\n+}"}, {"sha": "10c48287d3a15060dcabf30377ab486c351998b3", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug482.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug482.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug482.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug482.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,20 @@\n+// compile\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Using the same name for a field in a composite literal and for a\n+// global variable that depends on the variable being initialized\n+// caused gccgo to erroneously report \"variable initializer refers to\n+// itself\".\n+\n+package p\n+\n+type S struct {\n+\tF int\n+}\n+\n+var V = S{F: 1}\n+\n+var F = V.F"}, {"sha": "089637d86b86e1b04674a0700ff9134de2890be0", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue4085a.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4085a.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4085a.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4085a.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -9,10 +9,10 @@ package main\n type T []int\n \n func main() {\n-\t_ = make(T, -1)       // ERROR \"negative\"\n-\t_ = make(T, 0.5)       // ERROR \"constant 0.5 truncated to integer|non-integer\"\n-\t_ = make(T, 1.0)       // ok\n-\t_ = make(T, 1<<63)  // ERROR \"len argument too large\"\n-\t_ = make(T, 0, -1)    // ERROR \"negative cap\"\n+\t_ = make(T, -1)    // ERROR \"negative\"\n+\t_ = make(T, 0.5)   // ERROR \"constant 0.5 truncated to integer|non-integer len argument\"\n+\t_ = make(T, 1.0)   // ok\n+\t_ = make(T, 1<<63) // ERROR \"len argument too large\"\n+\t_ = make(T, 0, -1) // ERROR \"negative cap\"\n \t_ = make(T, 10, 0) // ERROR \"len larger than cap\"\n }"}, {"sha": "3668d4c89a8748a96d0086c7636f74dab255beb7", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue4251.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4251.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4251.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4251.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -9,13 +9,13 @@\n package p\n \n func F1(s []byte) []byte {\n-\treturn s[2:1]\t\t// ERROR \"inverted\"\n+\treturn s[2:1]\t\t// ERROR \"invalid slice index|inverted slice range\"\n }\n \n func F2(a [10]byte) []byte {\n-\treturn a[2:1]\t\t// ERROR \"inverted\"\n+\treturn a[2:1]\t\t// ERROR \"invalid slice index|inverted slice range\"\n }\n \n func F3(s string) string {\n-\treturn s[2:1]\t\t// ERROR \"inverted\"\n+\treturn s[2:1]\t\t// ERROR \"invalid slice index|inverted slice range\"\n }"}, {"sha": "3d727d433edcfce427710f4cbab3fce2fa7db707", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue4517d.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4517d.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4517d.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4517d.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,9 @@\n+// errorcheck\n+\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+import init \"fmt\" // ERROR \"cannot import package as init\""}, {"sha": "13781af1f361b0428e2dddcd174b79ca6af6445e", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue4776.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4776.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4776.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4776.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,10 @@\n+// errorcheck\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 4776: missing package declaration error should be fatal.\n+\n+type MyInt int32 // ERROR \"package statement must be first|package clause\"\n+"}, {"sha": "91a6568f27194ac02626081ccb50217b57378b19", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue4847.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4847.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4847.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue4847.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,24 @@\n+// errorcheck\n+\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 4847: initialization loop is not detected.\n+\n+package p\n+\n+type (\n+\tE int\n+\tS int\n+)\n+\n+type matcher func(s *S) E\n+\n+func matchList(s *S) E { return matcher(matchAnyFn)(s) }\n+\n+var foo = matcher(matchList)\n+\n+var matchAny = matcher(matchList) // ERROR \"initialization loop|depends upon itself\"\n+\n+func matchAnyFn(s *S) (err E) { return matchAny(s) }"}, {"sha": "a6acbd3db78923bdc239caa0f03152a5db4e5888", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5172.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5172.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5172.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5172.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,19 @@\n+// errorcheck\n+\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// issue 5172: spurious warn about type conversion on broken type inside go and defer\n+\n+package main\n+\n+type foo struct {\n+\tx bar // ERROR \"undefined\"\n+}\n+\n+func main() {\n+\tvar f foo\n+\tgo f.bar()\t// GCCGO_ERROR \"undefined\"\n+\tdefer f.bar()\t// GCCGO_ERROR \"undefined\"\n+}"}, {"sha": "c2b1da9e0e136d5afb2693eb5612fd46e37ec4de", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5358.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5358.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5358.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5358.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,17 @@\n+// errorcheck\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// issue 5358: incorrect error message when using f(g()) form on ... args.\n+\n+package main\n+\n+func f(x int, y ...int) {}\n+\n+func g() (int, []int)\n+\n+func main() {\n+\tf(g()) // ERROR \"as type int in|incompatible type\"\n+}"}, {"sha": "2ee0398af2c894f4939f594a758eadb9a82d71d5", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5493.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5493.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5493.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5493.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -52,7 +52,7 @@ func main() {\n \t\truntime.GC()\n \t}\n \tif count != 0 {\n-\t\tprintln(count, \"out of\", N, \"finalizer are called\")\n+\t\tprintln(count, \"out of\", N, \"finalizer are not called\")\n \t\tpanic(\"not all finalizers are called\")\n \t}\n }"}, {"sha": "36a4ad671d2c1225416e8d72e99e26e736162ad4", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5581.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5581.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5581.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5581.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,34 @@\n+// errorcheck\n+\n+// Used to emit a spurious \"invalid recursive type\" error.\n+// See golang.org/issue/5581.\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"fmt\"\n+\n+func NewBar() *Bar { return nil }\n+\n+func (x *Foo) Method() (int, error) {\n+\tfor y := range x.m {\n+\t\t_ = y.A\n+\t}\n+\treturn 0, nil\n+}\n+\n+type Foo struct {\n+\tm map[*Bar]int\n+}\n+\n+type Bar struct {\n+\tA *Foo\n+\tB chan Blah // ERROR \"undefined.*Blah\"\n+}\n+\n+func main() {\n+\tfmt.Println(\"Hello, playground\")\n+}"}, {"sha": "ea770b4865417d94c8326259f6fc2fc53dcfb61b", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5609.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5609.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5609.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5609.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,13 @@\n+// errorcheck\n+\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// issue 5609: overflow when calculating array size\n+\n+package pkg\n+\n+const Large uint64 = 18446744073709551615\n+\n+var foo [Large]uint64 // ERROR \"array bound is too large|array bound overflows\""}, {"sha": "035bbd35d25a4be3fb863dbe3c7c385e302d3808", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5698.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5698.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5698.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5698.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,18 @@\n+// errorcheck\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 5698: can define a key type with slices.\n+\n+package main\n+\n+type Key struct {\n+\ta int16 // the compiler was confused by the padding.\n+\tb []int\n+}\n+\n+type Val struct{}\n+\n+type Map map[Key]Val // ERROR \"invalid map key type\""}, {"sha": "1dfa072143e76c1f0b9bac7c0b1734fb20c7ca5a", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5704.go", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5704.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5704.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5704.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,46 @@\n+// run\n+\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 5704: Conversions of empty strings to byte\n+// or rune slices return empty but non-nil slices.\n+\n+package main\n+\n+type (\n+\tmystring string\n+\tmybytes  []byte\n+\tmyrunes  []rune\n+)\n+\n+func checkBytes(s []byte, arg string) {\n+\tif len(s) != 0 {\n+\t\tpanic(\"len(\" + arg + \") != 0\")\n+\t}\n+\tif s == nil {\n+\t\tpanic(arg + \" == nil\")\n+\t}\n+}\n+\n+func checkRunes(s []rune, arg string) {\n+\tif len(s) != 0 {\n+\t\tpanic(\"len(\" + arg + \") != 0\")\n+\t}\n+\tif s == nil {\n+\t\tpanic(arg + \" == nil\")\n+\t}\n+}\n+\n+func main() {\n+\tcheckBytes([]byte(\"\"), `[]byte(\"\")`)\n+\tcheckBytes([]byte(mystring(\"\")), `[]byte(mystring(\"\"))`)\n+\tcheckBytes(mybytes(\"\"), `mybytes(\"\")`)\n+\tcheckBytes(mybytes(mystring(\"\")), `mybytes(mystring(\"\"))`)\n+\n+\tcheckRunes([]rune(\"\"), `[]rune(\"\")`)\n+\tcheckRunes([]rune(mystring(\"\")), `[]rune(mystring(\"\"))`)\n+\tcheckRunes(myrunes(\"\"), `myrunes(\"\")`)\n+\tcheckRunes(myrunes(mystring(\"\")), `myrunes(mystring(\"\"))`)\n+}"}, {"sha": "35cadf8c9e74efd968e84f642ab4148a7128ea84", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5856.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5856.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5856.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5856.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,38 @@\n+// run\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"strings\"\n+)\n+\n+func main() {\n+\tf()\n+\tpanic(\"deferred function not run\")\n+}\n+\n+var x = 1\n+\n+func f() {\n+\tif x == 0 {\n+\t\treturn\n+\t}\n+\tdefer g()\n+\tpanic(\"panic\")\n+}\n+\n+func g() {\n+\t_, file, line, _ := runtime.Caller(2)\n+\tif !strings.HasSuffix(file, \"issue5856.go\") || line != 28 {\n+\t\tfmt.Printf(\"BUG: defer called from %s:%d, want issue5856.go:28\\n\", file, line)\n+\t\tos.Exit(1)\n+\t}\n+\tos.Exit(0)\n+}"}, {"sha": "b236c15c7d39efc6d6005cbc60e1171252de1282", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5910.dir/a.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5910.dir%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5910.dir%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5910.dir%2Fa.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package a\n+\n+type Package struct {\n+\tname string\n+}\n+\n+type Future struct {\n+\tresult chan struct {\n+\t\t*Package\n+\t\terror\n+\t}\n+}\n+\n+func (t *Future) Result() (*Package, error) {\n+\tresult := <-t.result\n+\tt.result <- result\n+\treturn result.Package, result.error\n+}"}, {"sha": "c5d42ea0986e860a35836f1b9c201e3e11255608", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5910.dir/main.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5910.dir%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5910.dir%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5910.dir%2Fmain.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"a\"\n+\n+func main() {\n+\tf := new(a.Future)\n+\tf.Result()\n+}"}, {"sha": "54e74bac8dd0217c979976c37d5e99c622e397da", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5910.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5910.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5910.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5910.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,10 @@\n+// compiledir\n+\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 5910: parsing of unnamed struct types\n+// in inlined bodies was broken.\n+\n+package ignored"}, {"sha": "7411d5fcd54c0c2e2cb3761686054e2afcc4a408", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5957.dir/a.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.dir%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.dir%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.dir%2Fa.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,3 @@\n+package surprise\n+\n+var X int"}, {"sha": "9bc561b9ce5ac82dfaae964888a3ce2fde64e4e7", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5957.dir/b.go", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.dir%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.dir%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.dir%2Fb.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,2 @@\n+package surprise2\n+"}, {"sha": "a1781d4d406d09bebd872794a0d9cca04516e40d", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5957.dir/c.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.dir%2Fc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.dir%2Fc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.dir%2Fc.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,12 @@\n+package p\n+\n+import (\n+\t\"./a\" // ERROR \"imported and not used: \\x22a\\x22 as surprise|imported and not used: surprise\"\n+\t\"./b\" // GC_ERROR \"imported and not used: \\x22b\\x22 as surprise2|imported and not used: surprise2\"\n+\tb \"./b\" // ERROR \"imported and not used: \\x22b\\x22$|imported and not used: surprise2\"\n+\tfoo \"math\" // ERROR \"imported and not used: \\x22math\\x22 as foo|imported and not used: math\"\n+\t\"fmt\" // actually used\n+\t\"strings\" // ERROR \"imported and not used: \\x22strings\\x22|imported and not used: strings\"\n+)\n+\n+var _ = fmt.Printf"}, {"sha": "891d8e6d2eefff3631ccbfa8a354893cd5a63804", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5957.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5957.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,7 @@\n+// errorcheckdir\n+\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ignored"}, {"sha": "190e8f4564748513ae42e3b21ec2dde54db3eb17", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue5963.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5963.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5963.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue5963.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,50 @@\n+// run\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Used to die in runtime due to init goroutine exiting while\n+// locked to main thread.\n+\n+package main\n+\n+import (\n+\t\"os\"\n+\t\"runtime\"\n+)\n+\n+func init() {\n+\tc := make(chan int, 1)\n+\tdefer func() {\n+\t\tc <- 0\n+\t}()\n+\tgo func() {\n+\t\tos.Exit(<-c)\n+\t}()\n+\truntime.Goexit()\n+}\n+\n+func main() {\n+}\n+\n+/* Before fix:\n+\n+invalid m->locked = 2\n+fatal error: internal lockOSThread error\n+\n+goroutine 2 [runnable]:\n+runtime.MHeap_Scavenger()\n+\t/Users/rsc/g/go/src/pkg/runtime/mheap.c:438\n+runtime.goexit()\n+\t/Users/rsc/g/go/src/pkg/runtime/proc.c:1313\n+created by runtime.main\n+\t/Users/rsc/g/go/src/pkg/runtime/proc.c:165\n+\n+goroutine 3 [runnable]:\n+main.func\u00b7002()\n+\t/Users/rsc/g/go/test/fixedbugs/issue5963.go:22\n+created by main.init\u00b71\n+\t/Users/rsc/g/go/test/fixedbugs/issue5963.go:24 +0xb9\n+exit status 2\n+*/"}, {"sha": "45aaffd2c90a09f3f7ef15c99bd2e280de1854d6", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6004.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6004.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6004.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6004.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,15 @@\n+// errorcheck\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+func main() {\n+\t_ = nil // ERROR \"use of untyped nil\"\n+\t_, _ = nil, 1 // ERROR \"use of untyped nil\"\n+\t_, _ = 1, nil // ERROR \"use of untyped nil\"\n+\t_ = append(nil, 1, 2, 3) // ERROR \"untyped nil\"\n+}\n+"}, {"sha": "5f787c56900b776f23d0bd18b08c46ca67007251", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6036.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6036.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6036.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6036.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,44 @@\n+// +build amd64\n+// compile\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 6036: 6g's backend generates OINDREG with\n+// offsets larger than 32-bit.\n+\n+package main\n+\n+type T struct {\n+\tLarge [1 << 31]byte\n+\tA     int\n+\tB     int\n+}\n+\n+func F(t *T) {\n+\tt.B = t.A\n+}\n+\n+type T2 [1<<31 + 2]byte\n+\n+func F2(t *T2) {\n+\tt[1<<31+1] = 42\n+}\n+\n+type T3 [1<<15 + 1][1<<15 + 1]int\n+\n+func F3(t *T3) {\n+\tt[1<<15][1<<15] = 42\n+}\n+\n+type S struct {\n+\tA int32\n+\tB int32\n+}\n+\n+type T4 [1<<29 + 1]S\n+\n+func F4(t *T4) {\n+\tt[1<<29].B = 42\n+}"}, {"sha": "698f62ac95678b789b4bcff1b21c454e84af60cf", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6055.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6055.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6055.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6055.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,35 @@\n+// run\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"runtime\"\n+\n+type Closer interface {\n+\tClose()\n+}\n+\n+func nilInterfaceDeferCall() {\n+\tdefer func() {\n+\t\t// make sure a traceback happens with jmpdefer on the stack\n+\t\truntime.GC()\n+\t}()\n+\tvar x Closer\n+\tdefer x.Close()\n+}\n+\n+func shouldPanic(f func()) {\n+\tdefer func() {\n+\t\tif recover() == nil {\n+\t\t\tpanic(\"did not panic\")\n+\t\t}\n+\t}()\n+\tf()\n+}\n+\n+func main() {\n+\tshouldPanic(nilInterfaceDeferCall)\n+}"}, {"sha": "817e4a877cdc17b22418bad7a5566b374a1907f7", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6131.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6131.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6131.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6131.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,20 @@\n+// compile\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 6131: missing typecheck after reducing\n+// n%1 == 0 to a constant value.\n+\n+package main\n+\n+func isGood(n int) bool {\n+\treturn n%1 == 0\n+}\n+\n+func main() {\n+\tif !isGood(256) {\n+\t\tpanic(\"!isGood\")\n+\t}\n+}"}, {"sha": "d494933b2e29d504aeafab47aa5b77b17e7132b4", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6140.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6140.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6140.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6140.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,31 @@\n+// compile\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 6140: compiler incorrectly rejects method values\n+// whose receiver has an unnamed interface type.\n+\n+package p\n+\n+type T *interface {\n+\tm() int\n+}\n+\n+var x T\n+\n+var _ = (*x).m\n+\n+var y interface {\n+\tm() int\n+}\n+\n+var _ = y.m\n+\n+type I interface {\n+\tString() string\n+}\n+\n+var z *struct{ I }\n+var _ = z.String"}, {"sha": "eea8f9c878f05a95f2df0b59e6767f6835392b0b", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6247.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6247.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6247.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6247.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,17 @@\n+// compile\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 6247: 5g used to be confused by the numbering\n+// of floating-point registers.\n+\n+package main\n+\n+var p map[string]interface{}\n+var v interface{}\n+\n+func F() {\n+\tp[\"hello\"] = v.(complex128) * v.(complex128)\n+}"}, {"sha": "af5feb728669ba69acfb31a546abd0e1ac9ca962", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6269.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6269.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6269.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6269.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,39 @@\n+// run\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// issue 6269: name collision on method names for function local types.\n+\n+package main\n+\n+type foo struct{}\n+\n+func (foo) Error() string {\n+\treturn \"ok\"\n+}\n+\n+type bar struct{}\n+\n+func (bar) Error() string {\n+\treturn \"fail\"\n+}\n+\n+func unused() {\n+\ttype collision struct {\n+\t\tbar\n+\t}\n+\t_ = collision{}\n+}\n+\n+func main() {\n+\ttype collision struct {\n+\t\tfoo\n+\t}\n+\ts := error(collision{})\n+\tif str := s.Error(); str != \"ok\" {\n+\t\tprintln(\"s.Error() ==\", str)\n+\t\tpanic(`s.Error() != \"ok\"`)\n+\t}\n+}"}, {"sha": "6303dbe5b093559f8399ff4ba7825100cde914a3", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6298.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6298.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6298.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6298.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,15 @@\n+// compile\n+\n+// golang.org/issue/6298.\n+// Used to cause \"internal error: typename ideal bool\"\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+func main() {\n+\tvar x interface{} = \"abc\"[0] == 'a'\n+\t_ = x\n+}"}, {"sha": "b3d1c855b2cc789193cb417f03b21ac4a798aac3", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6399.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6399.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6399.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6399.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,27 @@\n+// compile\n+\n+package main\n+\n+type Foo interface {\n+\tPrint()\n+}\n+\n+type Bar struct{}\n+\n+func (b Bar) Print() {}\n+\n+func main() {\n+\tb := make([]Bar, 20)\n+\tf := make([]Foo, 20)\n+\tfor i := range f {\n+\t\tf[i] = b[i]\n+\t}\n+\tT(f)\n+\t_ = make([]struct{}, 1)\n+}\n+\n+func T(f []Foo) {\n+\tfor i := range f {\n+\t\tf[i].Print()\n+\t}\n+}"}, {"sha": "da90ca377b47e0500e6b11a880e1df12a82ce8b3", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6513.dir/a.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.dir%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.dir%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.dir%2Fa.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package a\n+\n+type T struct{ int }"}, {"sha": "3b35b2d324b85e35cfe197e4b21b21e8a751c828", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6513.dir/b.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.dir%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.dir%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.dir%2Fb.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package b\n+\n+import \"./a\"\n+\n+type U struct{ a.T }"}, {"sha": "f09b7274821f8771f56c7d4f7c35ffb547623e61", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6513.dir/main.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.dir%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.dir%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.dir%2Fmain.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"./a\"\n+\t\"./b\"\n+)\n+\n+func main() {\n+\tvar t a.T\n+\tvar u b.U\n+\t_, _ = t, u\n+}"}, {"sha": "b32e0c5614d1060b1faa339c72d52c8ae30a9e69", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6513.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6513.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,10 @@\n+// compiledir\n+\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 6513: embedded builtins may get incorrect qualified\n+// field name during import.\n+\n+package ignored"}, {"sha": "9c90e0740cda5865e09de1f323b7e825dff2218c", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6789.dir/a.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6789.dir%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6789.dir%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6789.dir%2Fa.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package a\n+\n+type unexported struct {\n+        a int\n+        b bool\n+}\n+\n+type Struct struct {\n+        unexported\n+}"}, {"sha": "b6a6fc317f53d4895ad1f6ec8d9b2f73dbcd5e98", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6789.dir/b.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6789.dir%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6789.dir%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6789.dir%2Fb.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"./a\"\n+\n+type s a.Struct\n+\n+func main() {\n+}"}, {"sha": "e3a2c3320ef1258f394b1f7f3bb9c2824027c8c4", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6789.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6789.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6789.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6789.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,10 @@\n+// rundir\n+\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 6789: gccgo failed to find the hash function for an\n+// unexported struct embedded in an exported struct.\n+\n+package ignored"}, {"sha": "a693bf28508aa7999ddfab23da50ed1ad8e99a7e", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6899.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6899.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6899.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6899.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,13 @@\n+// cmpout\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"math\"\n+\n+func main() {\n+\tprintln(math.Copysign(0, -1))\n+}"}, {"sha": "e2375f07766a6c0ee5a3ea8fecd849b481ec0ecb", "filename": "gcc/testsuite/go.test/test/fixedbugs/issue6899.out", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6899.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6899.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fissue6899.out?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1 @@\n+-0.000000e+000"}, {"sha": "2433b5f2ad2b479a5346a721289f4e140dc2a234", "filename": "gcc/testsuite/go.test/test/import1.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fimport1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fimport1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fimport1.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -14,5 +14,6 @@ import bufio \"os\"\t// ERROR \"redeclared|redefinition|incompatible\" \"imported and\n \n import (\n \t\"fmt\"\t// GCCGO_ERROR \"previous|not used\"\n-\tfmt \"math\"\t// ERROR \"redeclared|redefinition|incompatible\" \"imported and not used\"\n+\tfmt \"math\"\t// ERROR \"redeclared|redefinition|incompatible\" \"imported and not used: \\x22math\\x22 as fmt\"\n+\t. \"math\"\t// GC_ERROR \"imported and not used: \\x22math\\x22$\"\n )"}, {"sha": "36fa1a4224f9d329981390c5ba11d1aa6448d55e", "filename": "gcc/testsuite/go.test/test/interface/explicit.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Fexplicit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Fexplicit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Fexplicit.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -80,3 +80,22 @@ var m2 M = jj // ERROR \"incompatible|wrong type for M method\"\n \n var m3 = M(ii) // ERROR \"invalid|missing\"\n var m4 = M(jj) // ERROR \"invalid|wrong type for M method\"\n+\n+\n+type B1 interface {\n+\t_()\n+}\n+\n+type B2 interface {\n+\tM()\n+\t_()\n+}\n+\n+type T2 struct{}\n+\n+func (t *T2) M() {}\n+func (t *T2) _() {}\n+\n+// Check that nothing satisfies an interface with blank methods.\n+var b1 B1 = &T2{} // ERROR \"incompatible|missing _ method\"\n+var b2 B2 = &T2{} // ERROR \"incompatible|missing _ method\""}, {"sha": "81eb6cb3c151958b9193526c5e25f5941ef4cb42", "filename": "gcc/testsuite/go.test/test/interface/fail.go", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Ffail.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Ffail.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Ffail.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -14,18 +14,33 @@ type I interface {\n \n func main() {\n \tshouldPanic(p1)\n+\tshouldPanic(p2)\n }\n \n func p1() {\n \tvar s *S\n \tvar i I\n-\tvar e interface {}\n+\tvar e interface{}\n \te = s\n \ti = e.(I)\n \t_ = i\n }\n \n-type S struct {\n+type S struct{}\n+\n+func (s *S) _() {}\n+\n+type B interface {\n+\t_()\n+}\n+\n+func p2() {\n+\tvar s *S\n+\tvar b B\n+\tvar e interface{}\n+\te = s\n+\tb = e.(B)\n+\t_ = b\n }\n \n func shouldPanic(f func()) {"}, {"sha": "f081cab01d4b3a522b11c6112de38bc524fe2861", "filename": "gcc/testsuite/go.test/test/mapnan.go", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmapnan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmapnan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmapnan.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -13,17 +13,13 @@ import (\n \t\"fmt\"\n \t\"math\"\n \t\"time\"\n-\t\"syscall\"\n )\n \n func main() {\n \n \t// Test that NaNs in maps don't go quadratic.\n \tt := func(n int) time.Duration {\n-\t\tvar u0 syscall.Rusage\n-\t\tif err := syscall.Getrusage(0,  &u0); err != nil {\n-\t\t\tpanic(err)\n-\t\t}\n+\t\tt1 := time.Now()\n \t\tm := map[float64]int{}\n \t\tnan := math.NaN()\n \t\tfor i := 0; i < n; i++ {\n@@ -32,11 +28,7 @@ func main() {\n \t\tif len(m) != n {\n \t\t\tpanic(\"wrong size map after nan insertion\")\n \t\t}\n-\t\tvar u1 syscall.Rusage\n-\t\tif err := syscall.Getrusage(0,  &u1); err != nil {\n-\t\t\tpanic(err)\n-\t\t}\n-\t\treturn time.Duration(u1.Utime.Nano() - u0.Utime.Nano())\n+\t\treturn time.Since(t1)\n \t}\n \n \t// Depending on the machine and OS, this test might be too fast"}, {"sha": "aaa850e7191c96171eaa173a44dd4033b7b43883", "filename": "gcc/testsuite/go.test/test/method2.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmethod2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmethod2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmethod2.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -21,7 +21,7 @@ func (p *P1) val() int { return 1 } // ERROR \"receiver.* pointer|invalid pointer\n type I interface{}\n type I1 interface{}\n \n-func (p I) val() int { return 1 } // ERROR \"receiver.*interface|invalid pointer or interface receiver\"\n+func (p I) val() int   { return 1 } // ERROR \"receiver.*interface|invalid pointer or interface receiver\"\n func (p *I1) val() int { return 1 } // ERROR \"receiver.*interface|invalid pointer or interface receiver\"\n \n type Val interface {\n@@ -33,4 +33,5 @@ var _ = (*Val).val // ERROR \"method\"\n var v Val\n var pv = &v\n \n-var _ = pv.val()\t// ERROR \"method\"\n+var _ = pv.val() // ERROR \"method\"\n+var _ = pv.val   // ERROR \"method\""}, {"sha": "fe05d05c9252904a25be7c8686cb8f514d36980f", "filename": "gcc/testsuite/go.test/test/nilcheck.go", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilcheck.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,184 @@\n+// errorcheck -0 -N -d=nil\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that nil checks are inserted.\n+// Optimization is disabled, so redundant checks are not removed.\n+\n+package p\n+\n+type Struct struct {\n+\tX int\n+\tY float64\n+}\n+\n+type BigStruct struct {\n+\tX int\n+\tY float64\n+\tA [1<<20]int\n+\tZ string\n+}\n+\n+type Empty struct {\n+}\n+\n+type Empty1 struct {\n+\tEmpty\n+}\n+\n+var (\n+\tintp *int\n+\tarrayp *[10]int\n+\tarray0p *[0]int\n+\tbigarrayp *[1<<26]int\n+\tstructp *Struct\n+\tbigstructp *BigStruct\n+\temptyp *Empty\n+\tempty1p *Empty1\n+)\n+\n+func f1() {\n+\t_ = *intp // ERROR \"nil check\"\n+\t_ = *arrayp // ERROR \"nil check\"\n+\t_ = *array0p // ERROR \"nil check\"\n+\t_ = *array0p // ERROR \"nil check\"\n+\t_ = *intp // ERROR \"nil check\"\n+\t_ = *arrayp // ERROR \"nil check\"\n+\t_ = *structp // ERROR \"nil check\"\n+\t_ = *emptyp // ERROR \"nil check\"\n+\t_ = *arrayp // ERROR \"nil check\"\n+}\n+\n+func f2() {\n+\tvar (\n+\t\tintp *int\n+\t\tarrayp *[10]int\n+\t\tarray0p *[0]int\n+\t\tbigarrayp *[1<<20]int\n+\t\tstructp *Struct\n+\t\tbigstructp *BigStruct\n+\t\temptyp *Empty\n+\t\tempty1p *Empty1\n+\t)\n+\n+\t_ = *intp // ERROR \"nil check\"\n+\t_ = *arrayp // ERROR \"nil check\"\n+\t_ = *array0p // ERROR \"nil check\"\n+\t_ = *array0p // ERROR \"nil check\"\n+\t_ = *intp // ERROR \"nil check\"\n+\t_ = *arrayp // ERROR \"nil check\"\n+\t_ = *structp // ERROR \"nil check\"\n+\t_ = *emptyp // ERROR \"nil check\"\n+\t_ = *arrayp // ERROR \"nil check\"\n+\t_ = *bigarrayp // ERROR \"nil check\"\n+\t_ = *bigstructp // ERROR \"nil check\"\n+\t_ = *empty1p // ERROR \"nil check\"\n+}\n+\n+func fx10k() *[10000]int\n+var b bool\n+\n+\n+func f3(x *[10000]int) {\n+\t// Using a huge type and huge offsets so the compiler\n+\t// does not expect the memory hardware to fault.\n+\t_ = x[9999] // ERROR \"nil check\"\n+\t\n+\tfor {\n+\t\tif x[9999] != 0 { // ERROR \"nil check\"\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\t\n+\tx = fx10k() \n+\t_ = x[9999] // ERROR \"nil check\"\n+\tif b {\n+\t\t_ = x[9999] // ERROR \"nil check\"\n+\t} else {\n+\t\t_ = x[9999] // ERROR \"nil check\"\n+\t}\t\n+\t_ = x[9999] // ERROR \"nil check\"\n+\n+\tx = fx10k() \n+\tif b {\n+\t\t_ = x[9999] // ERROR \"nil check\"\n+\t} else {\n+\t\t_ = x[9999] // ERROR \"nil check\"\n+\t}\t\n+\t_ = x[9999] // ERROR \"nil check\"\n+\t\n+\tfx10k()\n+\t// This one is a bit redundant, if we figured out that\n+\t// x wasn't going to change across the function call.\n+\t// But it's a little complex to do and in practice doesn't\n+\t// matter enough.\n+\t_ = x[9999] // ERROR \"nil check\"\n+}\n+\n+func f3a() {\n+\tx := fx10k()\n+\ty := fx10k()\n+\tz := fx10k()\n+\t_ = &x[9] // ERROR \"nil check\"\n+\ty = z\n+\t_ = &x[9] // ERROR \"nil check\"\n+\tx = y\n+\t_ = &x[9] // ERROR \"nil check\"\n+}\n+\n+func f3b() {\n+\tx := fx10k()\n+\ty := fx10k()\n+\t_ = &x[9] // ERROR \"nil check\"\n+\ty = x\n+\t_ = &x[9] // ERROR \"nil check\"\n+\tx = y\n+\t_ = &x[9] // ERROR \"nil check\"\n+}\n+\n+func fx10() *[10]int \n+\n+func f4(x *[10]int) {\n+\t// Most of these have no checks because a real memory reference follows,\n+\t// and the offset is small enough that if x is nil, the address will still be\n+\t// in the first unmapped page of memory.\n+\n+\t_ = x[9] // ERROR \"nil check\"\n+\t\n+\tfor {\n+\t\tif x[9] != 0 { // ERROR \"nil check\"\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\t\n+\tx = fx10() \n+\t_ = x[9] // ERROR \"nil check\"\n+\tif b {\n+\t\t_ = x[9] // ERROR \"nil check\"\n+\t} else {\n+\t\t_ = x[9] // ERROR \"nil check\"\n+\t}\t\n+\t_ = x[9] // ERROR \"nil check\"\n+\n+\tx = fx10() \n+\tif b {\n+\t\t_ = x[9] // ERROR \"nil check\"\n+\t} else {\n+\t\t_ = &x[9] // ERROR \"nil check\"\n+\t}\t\n+\t_ = x[9] // ERROR \"nil check\"\n+\t\n+\tfx10()\n+\t_ = x[9] // ERROR \"nil check\"\n+\t\n+\tx = fx10()\n+\ty := fx10()\n+\t_ = &x[9] // ERROR \"nil check\"\n+\ty = x\n+\t_ = &x[9] // ERROR \"nil check\"\n+\tx = y\n+\t_ = &x[9] // ERROR \"nil check\"\n+}\n+"}, {"sha": "9631d1618b5a07cddee9e13ae7582f69e0de2eed", "filename": "gcc/testsuite/go.test/test/nilptr.go", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -40,6 +40,10 @@ func main() {\n \tshouldPanic(p10)\n \tshouldPanic(p11)\n \tshouldPanic(p12)\n+\tshouldPanic(p13)\n+\tshouldPanic(p14)\n+\tshouldPanic(p15)\n+\tshouldPanic(p16)\n }\n \n func shouldPanic(f func()) {\n@@ -152,3 +156,27 @@ func p12() {\n \tvar p *T = nil\n \tprintln(*(&((*p).i)))\n }\n+\n+// Tests suggested in golang.org/issue/6080.\n+\n+func p13() {\n+\tvar x *[10]int\n+\ty := x[:]\n+\t_ = y\n+}\n+\n+func p14() {\n+\tprintln((*[1]int)(nil)[:])\n+}\n+\n+func p15() {\n+\tfor i := range (*[1]int)(nil)[:] {\n+\t\t_ = i\n+\t}\n+}\n+\n+func p16() {\n+\tfor i, v := range (*[1]int)(nil)[:] {\n+\t\t_ = i + v\n+\t}\n+}"}, {"sha": "57a5f8068f090ba1a8b59225ee7c93ff10624b97", "filename": "gcc/testsuite/go.test/test/nilptr2.go", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr2.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,128 @@\n+// run\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+func main() {\n+\tok := true\n+\tfor _, tt := range tests {\n+\t\tfunc() {\n+\t\t\tdefer func() {\n+\t\t\t\tif err := recover(); err == nil {\n+\t\t\t\t\tprintln(tt.name, \"did not panic\")\n+\t\t\t\t\tok = false\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t\ttt.fn()\n+\t\t}()\n+\t}\n+\tif !ok {\n+\t\tprintln(\"BUG\")\n+\t}\n+}\n+\n+var intp *int\n+var slicep *[]byte\n+var a10p *[10]int\n+var a10Mp *[1<<20]int\n+var structp *Struct\n+var bigstructp *BigStruct\n+var i int\n+var m *M\n+var m1 *M1\n+var m2 *M2\n+\n+func use(interface{}) {\n+}\n+\n+var tests = []struct{\n+\tname string\n+\tfn func()\n+}{\n+\t// Edit .+1,/^}/s/^[^\t].+/\t{\"&\", func() { println(&) }},\\n\t{\"\\&&\", func() { println(\\&&) }},/g\n+\t{\"*intp\", func() { println(*intp) }},\n+\t{\"&*intp\", func() { println(&*intp) }},\n+\t{\"*slicep\", func() { println(*slicep) }},\n+\t{\"&*slicep\", func() { println(&*slicep) }},\n+\t{\"(*slicep)[0]\", func() { println((*slicep)[0]) }},\n+\t{\"&(*slicep)[0]\", func() { println(&(*slicep)[0]) }},\n+\t{\"(*slicep)[i]\", func() { println((*slicep)[i]) }},\n+\t{\"&(*slicep)[i]\", func() { println(&(*slicep)[i]) }},\n+\t{\"*a10p\", func() { use(*a10p) }},\n+\t{\"&*a10p\", func() { println(&*a10p) }},\n+\t{\"a10p[0]\", func() { println(a10p[0]) }},\n+\t{\"&a10p[0]\", func() { println(&a10p[0]) }},\n+\t{\"a10p[i]\", func() { println(a10p[i]) }},\n+\t{\"&a10p[i]\", func() { println(&a10p[i]) }},\n+\t{\"*structp\", func() { use(*structp) }},\n+\t{\"&*structp\", func() { println(&*structp) }},\n+\t{\"structp.i\", func() { println(structp.i) }},\n+\t{\"&structp.i\", func() { println(&structp.i) }},\n+\t{\"structp.j\", func() { println(structp.j) }},\n+\t{\"&structp.j\", func() { println(&structp.j) }},\n+\t{\"structp.k\", func() { println(structp.k) }},\n+\t{\"&structp.k\", func() { println(&structp.k) }},\n+\t{\"structp.x[0]\", func() { println(structp.x[0]) }},\n+\t{\"&structp.x[0]\", func() { println(&structp.x[0]) }},\n+\t{\"structp.x[i]\", func() { println(structp.x[i]) }},\n+\t{\"&structp.x[i]\", func() { println(&structp.x[i]) }},\n+\t{\"structp.x[9]\", func() { println(structp.x[9]) }},\n+\t{\"&structp.x[9]\", func() { println(&structp.x[9]) }},\n+\t{\"structp.l\", func() { println(structp.l) }},\n+\t{\"&structp.l\", func() { println(&structp.l) }},\n+\t{\"*bigstructp\", func() { use(*bigstructp) }},\n+\t{\"&*bigstructp\", func() { println(&*bigstructp) }},\n+\t{\"bigstructp.i\", func() { println(bigstructp.i) }},\n+\t{\"&bigstructp.i\", func() { println(&bigstructp.i) }},\n+\t{\"bigstructp.j\", func() { println(bigstructp.j) }},\n+\t{\"&bigstructp.j\", func() { println(&bigstructp.j) }},\n+\t{\"bigstructp.k\", func() { println(bigstructp.k) }},\n+\t{\"&bigstructp.k\", func() { println(&bigstructp.k) }},\n+\t{\"bigstructp.x[0]\", func() { println(bigstructp.x[0]) }},\n+\t{\"&bigstructp.x[0]\", func() { println(&bigstructp.x[0]) }},\n+\t{\"bigstructp.x[i]\", func() { println(bigstructp.x[i]) }},\n+\t{\"&bigstructp.x[i]\", func() { println(&bigstructp.x[i]) }},\n+\t{\"bigstructp.x[9]\", func() { println(bigstructp.x[9]) }},\n+\t{\"&bigstructp.x[9]\", func() { println(&bigstructp.x[9]) }},\n+\t{\"bigstructp.x[100<<20]\", func() { println(bigstructp.x[100<<20]) }},\n+\t{\"&bigstructp.x[100<<20]\", func() { println(&bigstructp.x[100<<20]) }},\n+\t{\"bigstructp.l\", func() { println(bigstructp.l) }},\n+\t{\"&bigstructp.l\", func() { println(&bigstructp.l) }},\n+\t{\"m1.F()\", func() { println(m1.F()) }},\n+\t{\"m1.M.F()\", func() { println(m1.M.F()) }},\n+\t{\"m2.F()\", func() { println(m2.F()) }},\n+\t{\"m2.M.F()\", func() { println(m2.M.F()) }},\n+}\n+\n+type Struct struct {\n+\ti int\n+\tj float64\n+\tk string\n+\tx [10]int\n+\tl []byte\n+}\n+\n+type BigStruct struct {\n+\ti int\n+\tj float64\n+\tk string\n+\tx [128<<20]byte\n+\tl []byte\n+}\n+\n+type M struct {\n+}\n+\n+func (m *M) F() int {return 0}\n+\n+type M1 struct {\n+\tM\n+}\n+\n+type M2 struct {\n+\tx int\n+\tM\n+}"}, {"sha": "08597a02d95f87e952e2f6fad9aa2503738501e1", "filename": "gcc/testsuite/go.test/test/nilptr3.go", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr3.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,191 @@\n+// errorcheck -0 -d=nil\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that nil checks are removed.\n+// Optimization is enabled.\n+\n+package p\n+\n+type Struct struct {\n+\tX int\n+\tY float64\n+}\n+\n+type BigStruct struct {\n+\tX int\n+\tY float64\n+\tA [1<<20]int\n+\tZ string\n+}\n+\n+type Empty struct {\n+}\n+\n+type Empty1 struct {\n+\tEmpty\n+}\n+\n+var (\n+\tintp *int\n+\tarrayp *[10]int\n+\tarray0p *[0]int\n+\tbigarrayp *[1<<26]int\n+\tstructp *Struct\n+\tbigstructp *BigStruct\n+\temptyp *Empty\n+\tempty1p *Empty1\n+)\n+\n+func f1() {\n+\t_ = *intp // ERROR \"generated nil check\"\n+\t\n+\t// This one should be removed but the block copy needs\n+\t// to be turned into its own pseudo-op in order to see\n+\t// the indirect.\n+\t_ = *arrayp // ERROR \"generated nil check\"\n+\t\n+\t// 0-byte indirect doesn't suffice\n+\t_ = *array0p // ERROR \"generated nil check\"\n+\t_ = *array0p // ERROR \"removed repeated nil check\" 386\n+\n+\t_ = *intp // ERROR \"removed repeated nil check\"\n+\t_ = *arrayp // ERROR \"removed repeated nil check\"\n+\t_ = *structp // ERROR \"generated nil check\"\n+\t_ = *emptyp // ERROR \"generated nil check\"\n+\t_ = *arrayp // ERROR \"removed repeated nil check\"\n+}\n+\n+func f2() {\n+\tvar (\n+\t\tintp *int\n+\t\tarrayp *[10]int\n+\t\tarray0p *[0]int\n+\t\tbigarrayp *[1<<20]int\n+\t\tstructp *Struct\n+\t\tbigstructp *BigStruct\n+\t\temptyp *Empty\n+\t\tempty1p *Empty1\n+\t)\n+\n+\t_ = *intp // ERROR \"generated nil check\"\n+\t_ = *arrayp // ERROR \"generated nil check\"\n+\t_ = *array0p // ERROR \"generated nil check\"\n+\t_ = *array0p // ERROR \"removed repeated nil check\"\n+\t_ = *intp // ERROR \"removed repeated nil check\"\n+\t_ = *arrayp // ERROR \"removed repeated nil check\"\n+\t_ = *structp // ERROR \"generated nil check\"\n+\t_ = *emptyp // ERROR \"generated nil check\"\n+\t_ = *arrayp // ERROR \"removed repeated nil check\"\n+\t_ = *bigarrayp // ERROR \"generated nil check\" ARM removed nil check before indirect!!\n+\t_ = *bigstructp // ERROR \"generated nil check\"\n+\t_ = *empty1p // ERROR \"generated nil check\"\n+}\n+\n+func fx10k() *[10000]int\n+var b bool\n+\n+\n+func f3(x *[10000]int) {\n+\t// Using a huge type and huge offsets so the compiler\n+\t// does not expect the memory hardware to fault.\n+\t_ = x[9999] // ERROR \"generated nil check\"\n+\t\n+\tfor {\n+\t\tif x[9999] != 0 { // ERROR \"generated nil check\"\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\t\n+\tx = fx10k() \n+\t_ = x[9999] // ERROR \"generated nil check\"\n+\tif b {\n+\t\t_ = x[9999] // ERROR \"removed repeated nil check\"\n+\t} else {\n+\t\t_ = x[9999] // ERROR \"removed repeated nil check\"\n+\t}\t\n+\t_ = x[9999] // ERROR \"generated nil check\"\n+\n+\tx = fx10k() \n+\tif b {\n+\t\t_ = x[9999] // ERROR \"generated nil check\"\n+\t} else {\n+\t\t_ = x[9999] // ERROR \"generated nil check\"\n+\t}\t\n+\t_ = x[9999] // ERROR \"generated nil check\"\n+\t\n+\tfx10k()\n+\t// This one is a bit redundant, if we figured out that\n+\t// x wasn't going to change across the function call.\n+\t// But it's a little complex to do and in practice doesn't\n+\t// matter enough.\n+\t_ = x[9999] // ERROR \"generated nil check\"\n+}\n+\n+func f3a() {\n+\tx := fx10k()\n+\ty := fx10k()\n+\tz := fx10k()\n+\t_ = &x[9] // ERROR \"generated nil check\"\n+\ty = z\n+\t_ = &x[9] // ERROR \"removed repeated nil check\"\n+\tx = y\n+\t_ = &x[9] // ERROR \"generated nil check\"\n+}\n+\n+func f3b() {\n+\tx := fx10k()\n+\ty := fx10k()\n+\t_ = &x[9] // ERROR \"generated nil check\"\n+\ty = x\n+\t_ = &x[9] // ERROR \"removed repeated nil check\"\n+\tx = y\n+\t_ = &x[9] // ERROR \"removed repeated nil check\"\n+}\n+\n+func fx10() *[10]int \n+\n+func f4(x *[10]int) {\n+\t// Most of these have no checks because a real memory reference follows,\n+\t// and the offset is small enough that if x is nil, the address will still be\n+\t// in the first unmapped page of memory.\n+\n+\t_ = x[9] // ERROR \"removed nil check before indirect\"\n+\t\n+\tfor {\n+\t\tif x[9] != 0 { // ERROR \"removed nil check before indirect\"\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\t\n+\tx = fx10() \n+\t_ = x[9] // ERROR \"removed nil check before indirect\"\n+\tif b {\n+\t\t_ = x[9] // ERROR \"removed nil check before indirect\"\n+\t} else {\n+\t\t_ = x[9] // ERROR \"removed nil check before indirect\"\n+\t}\n+\t_ = x[9] // ERROR \"removed nil check before indirect\"\n+\n+\tx = fx10() \n+\tif b {\n+\t\t_ = x[9] // ERROR \"removed nil check before indirect\"\n+\t} else {\n+\t\t_ = &x[9] // ERROR \"generated nil check\"\n+\t}\t\n+\t_ = x[9] // ERROR \"removed nil check before indirect\"\n+\t\n+\tfx10()\n+\t_ = x[9] // ERROR \"removed nil check before indirect\"\n+\t\n+\tx = fx10()\n+\ty := fx10()\n+\t_ = &x[9] // ERROR \"generated nil check\"\n+\ty = x\n+\t_ = &x[9] // ERROR \"removed repeated nil check\"\n+\tx = y\n+\t_ = &x[9] // ERROR \"removed repeated nil check\"\n+}\n+"}, {"sha": "071be6667acff1c47931d2c8dcc6c489576e1d7c", "filename": "gcc/testsuite/go.test/test/recover.go", "status": "modified", "additions": 233, "deletions": 7, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -10,31 +10,72 @@ package main\n \n import (\n \t\"os\"\n+\t\"reflect\"\n \t\"runtime\"\n )\n \n func main() {\n+\t// go.tools/ssa/interp still has:\n+\t// - some lesser bugs in recover()\n+\t// - incomplete support for reflection\n+\tinterp := os.Getenv(\"GOSSAINTERP\") != \"\"\n+\n \ttest1()\n \ttest1WithClosures()\n \ttest2()\n \ttest3()\n-\t// exp/ssa/interp still has some bugs in recover().\n-\tif os.Getenv(\"GOSSAINTERP\") == \"\" {\n+\tif !interp {\n \t\ttest4()\n-\t\ttest5()\n \t}\n+\ttest5()\n \ttest6()\n \ttest6WithClosures()\n \ttest7()\n+\ttest8()\n+\ttest9()\n+\tif !interp {\n+\t\ttest9reflect1()\n+\t\ttest9reflect2()\n+\t}\n+\ttest10()\n+\tif !interp {\n+\t\ttest10reflect1()\n+\t\ttest10reflect2()\n+\t}\n+\ttest11()\n+\tif !interp {\n+\t\ttest11reflect1()\n+\t\ttest11reflect2()\n+\t}\n+\ttest12()\n+\tif !interp {\n+\t\ttest12reflect1()\n+\t\ttest12reflect2()\n+\t}\n+\ttest13()\n+\tif !interp {\n+\t\ttest13reflect1()\n+\t\ttest13reflect2()\n+\t}\n+\ttest14()\n+\tif !interp {\n+\t\ttest14reflect1()\n+\t\ttest14reflect2()\n+\t\ttest15()\n+\t}\n }\n \n func die() {\n \truntime.Breakpoint() // can't depend on panic\n }\n \n-func mustRecover(x interface{}) {\n-\tmustNotRecover() // because it's not a defer call\n-\tv := recover()\n+func mustRecoverBody(v1, v2, v3, x interface{}) {\n+\tv := v1\n+\tif v != nil {\n+\t\tprintln(\"spurious recover\", v)\n+\t\tdie()\n+\t}\n+\tv = v2\n \tif v == nil {\n \t\tprintln(\"missing recover\")\n \t\tdie() // panic is useless here\n@@ -45,13 +86,21 @@ func mustRecover(x interface{}) {\n \t}\n \n \t// the value should be gone now regardless\n-\tv = recover()\n+\tv = v3\n \tif v != nil {\n \t\tprintln(\"recover didn't recover\")\n \t\tdie()\n \t}\n }\n \n+func doubleRecover() interface{} {\n+\treturn recover()\n+}\n+\n+func mustRecover(x interface{}) {\n+\tmustRecoverBody(doubleRecover(), recover(), recover(), x)\n+}\n+\n func mustNotRecover() {\n \tv := recover()\n \tif v != nil {\n@@ -277,3 +326,180 @@ func test8() {\n \t\tdie()\n \t}\n }\n+\n+type I interface {\n+\tM()\n+}\n+\n+// pointer receiver, so no wrapper in i.M()\n+type T1 struct{}\n+\n+func (*T1) M() {\n+\tmustRecoverBody(doubleRecover(), recover(), recover(), 9)\n+}\n+\n+func test9() {\n+\tvar i I = &T1{}\n+\tdefer i.M()\n+\tpanic(9)\n+}\n+\n+func test9reflect1() {\n+\tf := reflect.ValueOf(&T1{}).Method(0).Interface().(func())\n+\tdefer f()\n+\tpanic(9)\n+}\n+\n+func test9reflect2() {\n+\tf := reflect.TypeOf(&T1{}).Method(0).Func.Interface().(func(*T1))\n+\tdefer f(&T1{})\n+\tpanic(9)\n+}\n+\n+// word-sized value receiver, so no wrapper in i.M()\n+type T2 uintptr\n+\n+func (T2) M() {\n+\tmustRecoverBody(doubleRecover(), recover(), recover(), 10)\n+}\n+\n+func test10() {\n+\tvar i I = T2(0)\n+\tdefer i.M()\n+\tpanic(10)\n+}\n+\n+func test10reflect1() {\n+\tf := reflect.ValueOf(T2(0)).Method(0).Interface().(func())\n+\tdefer f()\n+\tpanic(10)\n+}\n+\n+func test10reflect2() {\n+\tf := reflect.TypeOf(T2(0)).Method(0).Func.Interface().(func(T2))\n+\tdefer f(T2(0))\n+\tpanic(10)\n+}\n+\n+// tiny receiver, so basic wrapper in i.M()\n+type T3 struct{}\n+\n+func (T3) M() {\n+\tmustRecoverBody(doubleRecover(), recover(), recover(), 11)\n+}\n+\n+func test11() {\n+\tvar i I = T3{}\n+\tdefer i.M()\n+\tpanic(11)\n+}\n+\n+func test11reflect1() {\n+\tf := reflect.ValueOf(T3{}).Method(0).Interface().(func())\n+\tdefer f()\n+\tpanic(11)\n+}\n+\n+func test11reflect2() {\n+\tf := reflect.TypeOf(T3{}).Method(0).Func.Interface().(func(T3))\n+\tdefer f(T3{})\n+\tpanic(11)\n+}\n+\n+// large receiver, so basic wrapper in i.M()\n+type T4 [2]string\n+\n+func (T4) M() {\n+\tmustRecoverBody(doubleRecover(), recover(), recover(), 12)\n+}\n+\n+func test12() {\n+\tvar i I = T4{}\n+\tdefer i.M()\n+\tpanic(12)\n+}\n+\n+func test12reflect1() {\n+\tf := reflect.ValueOf(T4{}).Method(0).Interface().(func())\n+\tdefer f()\n+\tpanic(12)\n+}\n+\n+func test12reflect2() {\n+\tf := reflect.TypeOf(T4{}).Method(0).Func.Interface().(func(T4))\n+\tdefer f(T4{})\n+\tpanic(12)\n+}\n+\n+// enormous receiver, so wrapper splits stack to call M\n+type T5 [8192]byte\n+\n+func (T5) M() {\n+\tmustRecoverBody(doubleRecover(), recover(), recover(), 13)\n+}\n+\n+func test13() {\n+\tvar i I = T5{}\n+\tdefer i.M()\n+\tpanic(13)\n+}\n+\n+func test13reflect1() {\n+\tf := reflect.ValueOf(T5{}).Method(0).Interface().(func())\n+\tdefer f()\n+\tpanic(13)\n+}\n+\n+func test13reflect2() {\n+\tf := reflect.TypeOf(T5{}).Method(0).Func.Interface().(func(T5))\n+\tdefer f(T5{})\n+\tpanic(13)\n+}\n+\n+// enormous receiver + enormous method frame, so wrapper splits stack to call M,\n+// and then M splits stack to allocate its frame.\n+// recover must look back two frames to find the panic.\n+type T6 [8192]byte\n+\n+var global byte\n+\n+func (T6) M() {\n+\tvar x [8192]byte\n+\tx[0] = 1\n+\tx[1] = 2\n+\tfor i := range x {\n+\t\tglobal += x[i]\n+\t}\n+\tmustRecoverBody(doubleRecover(), recover(), recover(), 14)\n+}\n+\n+func test14() {\n+\tvar i I = T6{}\n+\tdefer i.M()\n+\tpanic(14)\n+}\n+\n+func test14reflect1() {\n+\tf := reflect.ValueOf(T6{}).Method(0).Interface().(func())\n+\tdefer f()\n+\tpanic(14)\n+}\n+\n+func test14reflect2() {\n+\tf := reflect.TypeOf(T6{}).Method(0).Func.Interface().(func(T6))\n+\tdefer f(T6{})\n+\tpanic(14)\n+}\n+\n+// function created by reflect.MakeFunc\n+\n+func reflectFunc(args []reflect.Value) (results []reflect.Value) {\n+\tmustRecoverBody(doubleRecover(), recover(), recover(), 15)\n+\treturn nil\n+}\n+\n+func test15() {\n+\tf := reflect.MakeFunc(reflect.TypeOf((func())(nil)), reflectFunc).Interface().(func())\n+\tdefer f()\n+\tpanic(15)\n+}"}, {"sha": "e17bfb3f6aa53ab115bcefad02c8e61e06dead36", "filename": "gcc/testsuite/go.test/test/recover3.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frecover3.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -64,7 +64,8 @@ func main() {\n \n \ti = 99999\n \tvar sl []int\n-\tcheck(\"array-bounds\", func() { println(p[i]) }, \"index out of range\")\n+\tp1 := new([10]int)\n+\tcheck(\"array-bounds\", func() { println(p1[i]) }, \"index out of range\")\n \tcheck(\"slice-bounds\", func() { println(sl[i]) }, \"index out of range\")\n \n \tvar inter interface{}"}, {"sha": "5c94de6400f1c9702b9aa229857a478f67d8a270", "filename": "gcc/testsuite/go.test/test/run.go", "status": "modified", "additions": 101, "deletions": 33, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Frun.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -27,6 +27,8 @@ import (\n \t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"time\"\n+\t\"unicode\"\n )\n \n var (\n@@ -113,28 +115,39 @@ func main() {\n \tfailed := false\n \tresCount := map[string]int{}\n \tfor _, test := range tests {\n-\t\t<-test.donec\n-\t\t_, isSkip := test.err.(skipError)\n-\t\terrStr := \"pass\"\n+\t\t<-test.donec\t\t\n+\t\tstatus := \"ok  \"\n+\t\terrStr := \"\"\n+\t\tif _, isSkip := test.err.(skipError); isSkip {\n+\t\t\tstatus = \"skip\"\n+\t\t\ttest.err = nil\n+\t\t\tif !skipOkay[path.Join(test.dir, test.gofile)] {\n+\t\t\t\terrStr = \"unexpected skip for \" + path.Join(test.dir, test.gofile) + \": \" + errStr\n+\t\t\t\tstatus = \"FAIL\"\n+\t\t\t}\n+\t\t}\n \t\tif test.err != nil {\n+\t\t\tstatus = \"FAIL\"\n \t\t\terrStr = test.err.Error()\n-\t\t\tif !isSkip {\n-\t\t\t\tfailed = true\n-\t\t\t}\n \t\t}\n-\t\tif isSkip && !skipOkay[path.Join(test.dir, test.gofile)] {\n-\t\t\terrStr = \"unexpected skip for \" + path.Join(test.dir, test.gofile) + \": \" + errStr\n-\t\t\tisSkip = false\n+\t\tif status == \"FAIL\" {\n \t\t\tfailed = true\n \t\t}\n-\t\tresCount[errStr]++\n-\t\tif isSkip && !*verbose && !*showSkips {\n+\t\tresCount[status]++\n+\t\tif status == \"skip\" && !*verbose && !*showSkips {\n+\t\t\tcontinue\n+\t\t}\n+\t\tdt := fmt.Sprintf(\"%.3fs\", test.dt.Seconds())\n+\t\tif status == \"FAIL\" {\n+\t\t\tfmt.Printf(\"# go run run.go -- %s\\n%s\\nFAIL\\t%s\\t%s\\n\",\n+\t\t\t\tpath.Join(test.dir, test.gofile),\n+\t\t\t\terrStr, test.goFileName(), dt)\n \t\t\tcontinue\n \t\t}\n-\t\tif !*verbose && test.err == nil {\n+\t\tif !*verbose {\n \t\t\tcontinue\n \t\t}\n-\t\tfmt.Printf(\"%-20s %-20s: %s\\n\", test.action, test.goFileName(), errStr)\n+\t\tfmt.Printf(\"%s\\t%s\\t%s\\n\", status, test.goFileName(), dt)\n \t}\n \n \tif *summary {\n@@ -206,7 +219,8 @@ func check(err error) {\n type test struct {\n \tdir, gofile string\n \tdonec       chan bool // closed when done\n-\n+\tdt time.Duration\n+\t\n \tsrc    string\n \taction string // \"compile\", \"build\", etc.\n \n@@ -299,14 +313,17 @@ func goDirPackages(longdir string) ([][]string, error) {\n \treturn pkgs, nil\n }\n \n+type context struct {\n+\tGOOS   string\n+\tGOARCH string\n+}\n+\n // shouldTest looks for build tags in a source file and returns\n // whether the file should be used according to the tags.\n func shouldTest(src string, goos, goarch string) (ok bool, whyNot string) {\n \tif idx := strings.Index(src, \"\\npackage\"); idx >= 0 {\n \t\tsrc = src[:idx]\n \t}\n-\tnotgoos := \"!\" + goos\n-\tnotgoarch := \"!\" + goarch\n \tfor _, line := range strings.Split(src, \"\\n\") {\n \t\tline = strings.TrimSpace(line)\n \t\tif strings.HasPrefix(line, \"//\") {\n@@ -318,34 +335,68 @@ func shouldTest(src string, goos, goarch string) (ok bool, whyNot string) {\n \t\tif len(line) == 0 || line[0] != '+' {\n \t\t\tcontinue\n \t\t}\n+\t\tctxt := &context{\n+\t\t\tGOOS:   goos,\n+\t\t\tGOARCH: goarch,\n+\t\t}\n \t\twords := strings.Fields(line)\n \t\tif words[0] == \"+build\" {\n-\t\t\tfor _, word := range words {\n-\t\t\t\tswitch word {\n-\t\t\t\tcase goos, goarch:\n-\t\t\t\t\treturn true, \"\"\n-\t\t\t\tcase notgoos, notgoarch:\n-\t\t\t\t\tcontinue\n-\t\t\t\tdefault:\n-\t\t\t\t\tif word[0] == '!' {\n-\t\t\t\t\t\t// NOT something-else\n-\t\t\t\t\t\treturn true, \"\"\n-\t\t\t\t\t}\n+\t\t\tok := false\n+\t\t\tfor _, word := range words[1:] {\n+\t\t\t\tif ctxt.match(word) {\n+\t\t\t\t\tok = true\n+\t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t}\n-\t\t\t// no matching tag found.\n-\t\t\treturn false, line\n+\t\t\tif !ok {\n+\t\t\t\t// no matching tag found.\n+\t\t\t\treturn false, line\n+\t\t\t}\n \t\t}\n \t}\n-\t// no build tags.\n+\t// no build tags\n \treturn true, \"\"\n }\n \n+func (ctxt *context) match(name string) bool {\n+\tif name == \"\" {\n+\t\treturn false\n+\t}\n+\tif i := strings.Index(name, \",\"); i >= 0 {\n+\t\t// comma-separated list\n+\t\treturn ctxt.match(name[:i]) && ctxt.match(name[i+1:])\n+\t}\n+\tif strings.HasPrefix(name, \"!!\") { // bad syntax, reject always\n+\t\treturn false\n+\t}\n+\tif strings.HasPrefix(name, \"!\") { // negation\n+\t\treturn len(name) > 1 && !ctxt.match(name[1:])\n+\t}\n+\n+\t// Tags must be letters, digits, underscores or dots.\n+\t// Unlike in Go identifiers, all digits are fine (e.g., \"386\").\n+\tfor _, c := range name {\n+\t\tif !unicode.IsLetter(c) && !unicode.IsDigit(c) && c != '_' && c != '.' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\tif name == ctxt.GOOS || name == ctxt.GOARCH {\n+\t\treturn true\n+\t}\n+\n+\treturn false\n+}\n+\n func init() { checkShouldTest() }\n \n // run runs a test.\n func (t *test) run() {\n-\tdefer close(t.donec)\n+\tstart := time.Now()\n+\tdefer func() {\n+\t\tt.dt = time.Since(start)\n+\t\tclose(t.donec)\n+\t}()\n \n \tsrcBytes, err := ioutil.ReadFile(t.goFileName())\n \tif err != nil {\n@@ -815,19 +866,36 @@ func defaultRunOutputLimit() int {\n \treturn cpu\n }\n \n-// checkShouldTest runs canity checks on the shouldTest function.\n+// checkShouldTest runs sanity checks on the shouldTest function.\n func checkShouldTest() {\n \tassert := func(ok bool, _ string) {\n \t\tif !ok {\n \t\t\tpanic(\"fail\")\n \t\t}\n \t}\n \tassertNot := func(ok bool, _ string) { assert(!ok, \"\") }\n+\n+\t// Simple tests.\n \tassert(shouldTest(\"// +build linux\", \"linux\", \"arm\"))\n \tassert(shouldTest(\"// +build !windows\", \"linux\", \"arm\"))\n \tassertNot(shouldTest(\"// +build !windows\", \"windows\", \"amd64\"))\n-\tassertNot(shouldTest(\"// +build arm 386\", \"linux\", \"amd64\"))\n+\n+\t// A file with no build tags will always be tested.\n \tassert(shouldTest(\"// This is a test.\", \"os\", \"arch\"))\n+\n+\t// Build tags separated by a space are OR-ed together.\n+\tassertNot(shouldTest(\"// +build arm 386\", \"linux\", \"amd64\"))\n+\n+\t// Build tags seperated by a comma are AND-ed together.\n+\tassertNot(shouldTest(\"// +build !windows,!plan9\", \"windows\", \"amd64\"))\n+\tassertNot(shouldTest(\"// +build !windows,!plan9\", \"plan9\", \"386\"))\n+\n+\t// Build tags on multiple lines are AND-ed together.\n+\tassert(shouldTest(\"// +build !windows\\n// +build amd64\", \"linux\", \"amd64\"))\n+\tassertNot(shouldTest(\"// +build !windows\\n// +build amd64\", \"windows\", \"amd64\"))\n+\n+\t// Test that (!a OR !b) matches anything.\n+\tassert(shouldTest(\"// +build !windows !plan9\", \"windows\", \"amd64\"))\n }\n \n // envForDir returns a copy of the environment"}, {"sha": "80e6bbc190da5151fd613269e0d48069bb980110", "filename": "gcc/testsuite/go.test/test/shift2.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fshift2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fshift2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fshift2.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -20,6 +20,7 @@ var (\n \ti       = 1 << s         // 1 has type int\n \tj int32 = 1 << s         // 1 has type int32; j == 0\n \tk       = uint64(1 << s) // 1 has type uint64; k == 1<<33\n+\tl       = g(1 << s)      // 1 has type int\n \tm int   = 1.0 << s       // legal: 1.0 has type int\n \tw int64 = 1.0 << 33      // legal: 1.0<<33 is a constant shift expression\n )"}, {"sha": "c3db1e5c3aefab121adb94836b8d25b386ce8a84", "filename": "gcc/testsuite/go.test/test/sizeof.go", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsizeof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsizeof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsizeof.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -1,4 +1,4 @@\n-// compile\n+// run\n \n // Copyright 2011 The Go Authors.  All rights reserved.\n // Use of this source code is governed by a BSD-style\n@@ -58,35 +58,35 @@ func main() {\n \n type (\n \tS1 struct {\n-\t\tA int32\n+\t\tA int64\n \t\tS2\n \t}\n \tS2 struct {\n-\t\tB int32\n+\t\tB int64\n \t\tS3\n \t}\n \tS3 struct {\n-\t\tC int32\n+\t\tC int64\n \t\tS4\n \t}\n \tS4 struct {\n-\t\tD int32\n+\t\tD int64\n \t\tS5\n \t}\n \tS5 struct {\n-\t\tE int32\n+\t\tE int64\n \t\tS6\n \t}\n \tS6 struct {\n-\t\tF int32\n+\t\tF int64\n \t\tS7\n \t}\n \tS7 struct {\n-\t\tG int32\n+\t\tG int64\n \t\tS8\n \t}\n \tS8 struct {\n-\t\tH int32\n+\t\tH int64\n \t\t*S1\n \t}\n )\n@@ -96,24 +96,24 @@ func testDeep() {\n \tswitch {\n \tcase unsafe.Offsetof(s1.A) != 0:\n \t\tpanic(\"unsafe.Offsetof(s1.A) != 0\")\n-\tcase unsafe.Offsetof(s1.B) != 4:\n-\t\tpanic(\"unsafe.Offsetof(s1.B) != 4\")\n-\tcase unsafe.Offsetof(s1.C) != 8:\n-\t\tpanic(\"unsafe.Offsetof(s1.C) != 8\")\n-\tcase unsafe.Offsetof(s1.D) != 12:\n-\t\tpanic(\"unsafe.Offsetof(s1.D) != 12\")\n-\tcase unsafe.Offsetof(s1.E) != 16:\n-\t\tpanic(\"unsafe.Offsetof(s1.E) != 16\")\n-\tcase unsafe.Offsetof(s1.F) != 20:\n-\t\tpanic(\"unsafe.Offsetof(s1.F) != 20\")\n-\tcase unsafe.Offsetof(s1.G) != 24:\n-\t\tpanic(\"unsafe.Offsetof(s1.G) != 24\")\n-\tcase unsafe.Offsetof(s1.H) != 28:\n-\t\tpanic(\"unsafe.Offsetof(s1.H) != 28\")\n-\tcase unsafe.Offsetof(s1.S1) != 32:\n-\t\tpanic(\"unsafe.Offsetof(s1.S1) != 32\")\n-\tcase unsafe.Offsetof(s1.S1.S2.S3.S4.S5.S6.S7.S8.S1.S2) != 4:\n-\t\tpanic(\"unsafe.Offsetof(s1.S1.S2.S3.S4.S5.S6.S7.S8.S1.S2) != 4\")\n+\tcase unsafe.Offsetof(s1.B) != 8:\n+\t\tpanic(\"unsafe.Offsetof(s1.B) != 8\")\n+\tcase unsafe.Offsetof(s1.C) != 16:\n+\t\tpanic(\"unsafe.Offsetof(s1.C) != 16\")\n+\tcase unsafe.Offsetof(s1.D) != 24:\n+\t\tpanic(\"unsafe.Offsetof(s1.D) != 24\")\n+\tcase unsafe.Offsetof(s1.E) != 32:\n+\t\tpanic(\"unsafe.Offsetof(s1.E) != 32\")\n+\tcase unsafe.Offsetof(s1.F) != 40:\n+\t\tpanic(\"unsafe.Offsetof(s1.F) != 40\")\n+\tcase unsafe.Offsetof(s1.G) != 48:\n+\t\tpanic(\"unsafe.Offsetof(s1.G) != 48\")\n+\tcase unsafe.Offsetof(s1.H) != 56:\n+\t\tpanic(\"unsafe.Offsetof(s1.H) != 56\")\n+\tcase unsafe.Offsetof(s1.S1) != 64:\n+\t\tpanic(\"unsafe.Offsetof(s1.S1) != 64\")\n+\tcase unsafe.Offsetof(s1.S1.S2.S3.S4.S5.S6.S7.S8.S1.S2) != 8:\n+\t\tpanic(\"unsafe.Offsetof(s1.S1.S2.S3.S4.S5.S6.S7.S8.S1.S2) != 8\")\n \t}\n }\n "}, {"sha": "3cf34b57e75c284b9d6482e0a16e3bf17988983d", "filename": "gcc/testsuite/go.test/test/slice3.go", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fslice3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fslice3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fslice3.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,156 @@\n+// runoutput\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test run-time behavior of 3-index slice expressions.\n+\n+package main\n+\n+import (\n+\t\"bufio\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+var bout *bufio.Writer\n+\n+func main() {\n+\tbout = bufio.NewWriter(os.Stdout)\n+\t\n+\tfmt.Fprintf(bout, \"%s\", programTop)\n+\tfmt.Fprintf(bout, \"func main() {\\n\")\n+\t\n+\tindex := []string{\n+\t\t\"0\",\n+\t\t\"1\",\n+\t\t\"2\",\n+\t\t\"3\",\n+\t\t\"10\",\n+\t\t\"20\",\n+\t\t\"vminus1\",\n+\t\t\"v0\",\n+\t\t\"v1\",\n+\t\t\"v2\",\n+\t\t\"v3\",\n+\t\t\"v10\",\n+\t\t\"v20\",\n+\t}\n+\t\n+\tparse := func(s string) (n int, isconst bool) {\n+\t\tif s == \"vminus1\" {\n+\t\t\treturn -1, false\n+\t\t}\n+\t\tisconst = true\n+\t\tif s[0] == 'v' {\n+\t\t\tisconst = false\n+\t\t\ts = s[1:]\n+\t\t}\n+\t\tn, _ = strconv.Atoi(s)\n+\t\treturn n, isconst\n+\t}\n+\n+\tconst Cap = 10 // cap of slice, array\n+\n+\tfor _, base := range []string{\"array\", \"slice\"} {\n+\t\tfor _, i := range index {\n+\t\t\tiv, iconst := parse(i)\n+\t\t\tfor _, j := range index {\n+\t\t\t\tjv, jconst := parse(j)\n+\t\t\t\tfor _, k := range index {\n+\t\t\t\t\tkv, kconst := parse(k)\n+\t\t\t\t\t// Avoid errors that would make the program not compile.\n+\t\t\t\t\t// Those are tested by slice3err.go.\n+\t\t\t\t\tswitch {\n+\t\t\t\t\tcase iconst && jconst && iv > jv,\n+\t\t\t\t\t\tjconst && kconst && jv > kv,\n+\t\t\t\t\t\ticonst && kconst && iv > kv,\n+\t\t\t\t\t\ticonst && base == \"array\" && iv > Cap,\n+\t\t\t\t\t\tjconst && base == \"array\" && jv > Cap,\n+\t\t\t\t\t\tkconst && base == \"array\" && kv > Cap:\t\t\t\t\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\n+\t\t\t\t\texpr := base + \"[\" + i + \":\" + j + \":\" + k + \"]\"\n+\t\t\t\t\tvar xbase, xlen, xcap int\n+\t\t\t\t\tif iv > jv || jv > kv || kv > Cap || iv < 0 || jv < 0 || kv < 0 {\n+\t\t\t\t\t\txbase, xlen, xcap = -1, -1, -1\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\txbase = iv\n+\t\t\t\t\t\txlen = jv - iv\n+\t\t\t\t\t\txcap = kv - iv\n+\t\t\t\t\t}\n+\t\t\t\t\tfmt.Fprintf(bout, \"\\tcheckSlice(%q, func() []byte { return %s }, %d, %d, %d)\\n\", expr, expr, xbase, xlen, xcap)\t\t\t\t\t\t\t\t\t\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfmt.Fprintf(bout, \"\\tif !ok { os.Exit(1) }\\n\")\n+\tfmt.Fprintf(bout, \"}\\n\")\n+\tbout.Flush()\n+}\n+\n+var programTop = `\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"unsafe\"\n+)\n+\n+var ok = true\n+\n+var (\n+\tarray = new([10]byte)\n+\tslice = array[:]\n+\n+\tvminus1 = -1\n+\tv0 = 0\n+\tv1 = 1\n+\tv2 = 2\n+\tv3 = 3\n+\tv4 = 4\n+\tv5 = 5\n+\tv10 = 10\n+\tv20 = 20\n+)\n+\n+func notOK() {\n+\tif ok {\n+\t\tprintln(\"BUG:\")\n+\t\tok = false\n+\t}\n+}\n+\n+func checkSlice(desc string, f func() []byte, xbase, xlen, xcap int) {\n+\tdefer func() {\n+\t\tif err := recover(); err != nil {\n+\t\t\tif xbase >= 0 {\n+\t\t\t\tnotOK()\n+\t\t\t\tprintln(desc, \" unexpected panic: \", fmt.Sprint(err))\n+\t\t\t}\n+\t\t}\n+\t\t// \"no panic\" is checked below\n+\t}()\n+\t\n+\tx := f()\n+\n+\tarrayBase := uintptr(unsafe.Pointer(array))\n+\traw := *(*[3]uintptr)(unsafe.Pointer(&x))\n+\tbase, len, cap := raw[0] - arrayBase, raw[1], raw[2]\n+\tif xbase < 0 {\n+\t\tnotOK()\n+\t\tprintln(desc, \"=\", base, len, cap, \"want panic\")\n+\t\treturn\n+\t}\n+\tif base != uintptr(xbase) || len != uintptr(xlen) || cap != uintptr(xcap) {\n+\t\tnotOK()\n+\t\tprintln(desc, \"=\", base, len, cap, \"want\", xbase, xlen, xcap)\n+\t}\n+}\n+\n+`"}, {"sha": "83fb39be4c14f3a7fd517ef840c46d560482da6e", "filename": "gcc/testsuite/go.test/test/slice3err.go", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fslice3err.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fslice3err.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fslice3err.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -0,0 +1,121 @@\n+// errorcheck\n+\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+var array *[10]int\n+var slice []int\n+var str string\n+var i, j, k int\n+\n+func f() {\n+\t// check what missing arguments are allowed\n+\t_ = array[:]\n+\t_ = array[i:]\n+\t_ = array[:j]\n+\t_ = array[i:j]\n+\t_ = array[::] // ERROR \"middle index required in 3-index slice\" \"final index required in 3-index slice\"\n+\t_ = array[i::] // ERROR \"middle index required in 3-index slice\" \"final index required in 3-index slice\"\n+\t_ = array[:j:] // ERROR \"final index required in 3-index slice\"\n+\t_ = array[i:j:] // ERROR \"final index required in 3-index slice\"\n+\t_ = array[::k] // ERROR \"middle index required in 3-index slice\"\n+\t_ = array[i::k] // ERROR \"middle index required in 3-index slice\"\n+\t_ = array[:j:k]\n+\t_ = array[i:j:k]\n+\t\n+\t_ = slice[:]\n+\t_ = slice[i:]\n+\t_ = slice[:j]\n+\t_ = slice[i:j]\n+\t_ = slice[::] // ERROR \"middle index required in 3-index slice\" \"final index required in 3-index slice\"\n+\t_ = slice[i::] // ERROR \"middle index required in 3-index slice\" \"final index required in 3-index slice\"\n+\t_ = slice[:j:] // ERROR \"final index required in 3-index slice\"\n+\t_ = slice[i:j:] // ERROR \"final index required in 3-index slice\"\n+\t_ = slice[::k] // ERROR \"middle index required in 3-index slice\"\n+\t_ = slice[i::k] // ERROR \"middle index required in 3-index slice\"\n+\t_ = slice[:j:k]\n+\t_ = slice[i:j:k]\n+\t\n+\t_ = str[:]\n+\t_ = str[i:]\n+\t_ = str[:j]\n+\t_ = str[i:j]\n+\t_ = str[::] // ERROR \"3-index slice of string\" \"middle index required in 3-index slice\" \"final index required in 3-index slice\"\n+\t_ = str[i::] // ERROR \"3-index slice of string\" \"middle index required in 3-index slice\" \"final index required in 3-index slice\"\n+\t_ = str[:j:] // ERROR \"3-index slice of string\" \"final index required in 3-index slice\"\n+\t_ = str[i:j:] // ERROR \"3-index slice of string\" \"final index required in 3-index slice\"\n+\t_ = str[::k] // ERROR \"3-index slice of string\" \"middle index required in 3-index slice\"\n+\t_ = str[i::k] // ERROR \"3-index slice of string\" \"middle index required in 3-index slice\"\n+\t_ = str[:j:k] // ERROR \"3-index slice of string\"\n+\t_ = str[i:j:k] // ERROR \"3-index slice of string\"\n+\n+\t// check invalid indices\n+\t_ = array[1:2]\n+\t_ = array[2:1] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = array[2:2]\n+\t_ = array[i:1]\n+\t_ = array[1:j]\n+\t_ = array[1:2:3]\n+\t_ = array[1:3:2] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = array[2:1:3] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = array[2:3:1] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = array[3:1:2] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = array[3:2:1] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = array[i:1:2]\n+\t_ = array[i:2:1] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = array[1:j:2]\n+\t_ = array[2:j:1] // ERROR \"invalid slice index\"\n+\t_ = array[1:2:k]\n+\t_ = array[2:1:k] // ERROR \"invalid slice index|inverted slice\"\n+\t\n+\t_ = slice[1:2]\n+\t_ = slice[2:1] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = slice[2:2]\n+\t_ = slice[i:1]\n+\t_ = slice[1:j]\n+\t_ = slice[1:2:3]\n+\t_ = slice[1:3:2] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = slice[2:1:3] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = slice[2:3:1] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = slice[3:1:2] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = slice[3:2:1] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = slice[i:1:2]\n+\t_ = slice[i:2:1] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = slice[1:j:2]\n+\t_ = slice[2:j:1] // ERROR \"invalid slice index\"\n+\t_ = slice[1:2:k]\n+\t_ = slice[2:1:k] // ERROR \"invalid slice index|inverted slice\"\n+\t\n+\t_ = str[1:2]\n+\t_ = str[2:1] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = str[2:2]\n+\t_ = str[i:1]\n+\t_ = str[1:j]\n+\n+\t// check out of bounds indices on array\n+\t_ = array[11:11] // ERROR \"out of bounds\"\n+\t_ = array[11:12] // ERROR \"out of bounds\"\n+\t_ = array[11:] // ERROR \"out of bounds\"\n+\t_ = array[:11] // ERROR \"out of bounds\"\n+\t_ = array[1:11] // ERROR \"out of bounds\"\n+\t_ = array[1:11:12] // ERROR \"out of bounds\"\n+\t_ = array[1:2:11] // ERROR \"out of bounds\"\n+\t_ = array[1:11:3] // ERROR \"out of bounds|invalid slice index\"\n+\t_ = array[11:2:3] // ERROR \"out of bounds|inverted slice|invalid slice index\"\n+\t_ = array[11:12:13] // ERROR \"out of bounds\"\n+\n+\t// slice bounds not checked\n+\t_ = slice[11:11]\n+\t_ = slice[11:12]\n+\t_ = slice[11:]\n+\t_ = slice[:11]\n+\t_ = slice[1:11]\n+\t_ = slice[1:11:12]\n+\t_ = slice[1:2:11]\n+\t_ = slice[1:11:3] // ERROR \"invalid slice index\"\n+\t_ = slice[11:2:3] // ERROR \"invalid slice index|inverted slice\"\n+\t_ = slice[11:12:13]\n+}"}, {"sha": "76ab2a8b4faf918ccf6474e88be145c760b594e7", "filename": "gcc/testsuite/go.test/test/stress/runstress.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fstress%2Frunstress.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fstress%2Frunstress.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fstress%2Frunstress.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -114,11 +114,16 @@ func stressExec() {\n \t}\n }\n \n-func ringf(in <-chan int, out chan<- int, donec chan<- bool) {\n+func ringf(in <-chan int, out chan<- int, donec chan bool) {\n \tfor {\n-\t\tn := <-in\n+\t\tvar n int\n+\t\tselect {\n+\t\tcase <-donec:\n+\t\t\treturn\n+\t\tcase n = <-in:\n+\t\t}\n \t\tif n == 0 {\n-\t\t\tdonec <- true\n+\t\t\tclose(donec)\n \t\t\treturn\n \t\t}\n \t\tout <- n - 1"}, {"sha": "4751b82ccf49836ab17a2dfb345623f8afa6ec4f", "filename": "gcc/testsuite/go.test/test/string_lit.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fstring_lit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fstring_lit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fstring_lit.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -125,6 +125,11 @@ func main() {\n \ts = string(-1)\n \tassert(s, \"\\xef\\xbf\\xbd\", \"negative rune\")\n \n+\t// the large rune tests yet again, with a slice.\n+\trs := []rune{0x10ffff, 0x10ffff + 1, 0xD800, 0xDFFF, -1}\n+\ts = string(rs)\n+\tassert(s, \"\\xf4\\x8f\\xbf\\xbf\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xef\\xbf\\xbd\", \"large rune slice\")\n+\n \tassert(string(gr1), gx1, \"global ->[]rune\")\n \tassert(string(gr2), gx2fix, \"global invalid ->[]rune\")\n \tassert(string(gb1), gx1, \"->[]byte\")"}, {"sha": "4860422ad87b5235059b3da161f1b4df2529bbb1", "filename": "gcc/testsuite/go.test/test/syntax/chan1.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fchan1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fchan1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fchan1.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -10,8 +10,8 @@ var c chan int\n var v int\n \n func main() {\n-\tif c <- v { // ERROR \"send statement.*value.*select\"\n+\tif c <- v { // ERROR \"used as value\"\n \t}\n }\n \n-var _ = c <- v // ERROR \"send statement.*value.*select\"\n+var _ = c <- v // ERROR \"used as value\""}, {"sha": "6e0428121ff60a9324d01f2dfbc2bfba380bdde4", "filename": "gcc/testsuite/go.test/test/syntax/semi1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi1.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -7,7 +7,7 @@\n package main\n \n func main() {\n-\tif x; y\t\t// ERROR \"unexpected semicolon or newline before .?{.?|undefined\"\n+\tif x; y\t\t// ERROR \"missing .*{.* after if clause|undefined\"\n \t{\n \t\tz\t// GCCGO_ERROR \"undefined\"\n "}, {"sha": "23d7bd0ee88dacb21697a01e4d25befd2d0df5f5", "filename": "gcc/testsuite/go.test/test/syntax/semi2.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi2.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -7,7 +7,7 @@\n package main\n \n func main() {\n-\tswitch x; y\t// ERROR \"unexpected semicolon or newline before .?{.?|undefined\"\n+\tswitch x; y\t// ERROR \"missing .*{.* after switch clause|undefined\"\n \t{\n \t\tz\n "}, {"sha": "ca070d8a577b70dac28289b1f1722fecdf139d51", "filename": "gcc/testsuite/go.test/test/syntax/semi3.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi3.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -7,7 +7,7 @@\n package main\n \n func main() {\n-\tfor x; y; z\t// ERROR \"unexpected semicolon or newline before .?{.?|undefined\"\n+\tfor x; y; z\t// ERROR \"missing .*{.* after for clause|undefined\"\n \t{\n \t\tz\t// GCCGO_ERROR \"undefined\"\n "}, {"sha": "99c2d22561b74f08977a9b00d304cb384c80f748", "filename": "gcc/testsuite/go.test/test/syntax/semi4.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fsyntax%2Fsemi4.go?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -8,7 +8,7 @@ package main\n \n func main() {\n \tfor x\t\t// GCCGO_ERROR \"undefined\"\n-\t{\t\t// ERROR \"unexpected semicolon or newline before .?{.?\"\n+\t{\t\t// ERROR \"missing .*{.* after for clause\"\n \t\tz\t// GCCGO_ERROR \"undefined\"\n \n "}, {"sha": "4a17f4feb9c901b5bbe60d4cef780ff0079a7f02", "filename": "gcc/testsuite/go.test/test/testlib", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ftestlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c3f1cd2cf1de79aca854332b88431d4fa5241d/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ftestlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ftestlib?ref=a8c3f1cd2cf1de79aca854332b88431d4fa5241d", "patch": "@@ -16,29 +16,50 @@ pkgs() {\n \tdone | sort\n }\n \n+_match() {\n+\tcase $1 in\n+\t*,*)\n+\t\t#echo >&2 \"match comma separated $1\"\n+\t\tfirst=$(echo $1 | sed 's/,.*//')\n+\t\trest=$(echo $1 | sed 's/[^,]*,//')\n+\t\tif _match $first && _match $rest; then\n+\t\t\treturn 0\n+\t\tfi\n+\t\treturn 1\n+\t\t;;\n+\t'!'*)\n+\t\t#echo >&2 \"match negation $1\"\n+\t\tneg=$(echo $1 | sed 's/^!//')\n+\t\tif _match $neg; then\n+\t\t\treturn 1\n+\t\tfi\n+\t\treturn 0\n+\t\t;;\n+\t$GOARCH|$GOOS)\n+\t\t#echo >&2 \"match GOARCH or GOOS $1\"\n+\t\treturn 0\n+\t\t;;\n+\tesac\n+\treturn 1\n+}\n+\n # +build aborts execution if the supplied tags don't match,\n # i.e. none of the tags (x or !x) matches GOARCH or GOOS.\n +build() {\n \tif (( $# == 0 )); then\n \t\treturn\n \tfi\n+\tm=0\n \tfor tag; do\n-\t\tcase $tag in\n-\t\t$GOARCH|$GOOS)\n-\t\t\t#echo >&2 \"match $tag in $1\"\n-\t\t\treturn # don't exclude.\n-\t\t\t;;\n-\t\t'!'$GOARCH|'!'$GOOS)\n-\t\t\t;;\n-\t\t'!'*)\n-\t\t\t# not x where x is neither GOOS nor GOARCH.\n-\t\t\t#echo >&2 \"match $tag in $1\"\n-\t\t\treturn # don't exclude\n-\t\t\t;;\n-\t\tesac\n+\t\tif _match $tag; then\n+\t\t\tm=1\n+\t\tfi\n \tdone\n-\t# no match.\n-\texit 0\n+\tif [ $m = 0 ]; then\n+\t\t#echo >&2 no match\n+\t\texit 0\n+\tfi\n+\tunset m\n }\n \n compile() {"}]}