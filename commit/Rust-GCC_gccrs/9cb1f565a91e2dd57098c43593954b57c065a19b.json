{"sha": "9cb1f565a91e2dd57098c43593954b57c065a19b", "node_id": "C_kwDOANBUbNoAKDljYjFmNTY1YTkxZTJkZDU3MDk4YzQzNTkzOTU0YjU3YzA2NWExOWI", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-04-03T10:35:03Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2022-04-28T12:50:59Z"}, "message": "c++, coroutines: Avoid expanding within templates [PR103868]\n\nThis is a forward-port of a patch by Nathan (against 10.x) which fixes an open\nPR.\n\nWe are ICEing because we ended up tsubst_copying something that had already\nbeen tsubst, leading to an assert failure (mostly such repeated tsubsting is\nharmless).\n\nWe had a non-dependent co_await in a non-dependent-type template fn, so we\nprocessed it at definition time, and then reprocessed at instantiation time.\nWe fix this here by deferring substitution while processing templates.\n\nAdditional observations (for a better future fix, in the GCC13 timescale):\n\nExprs only have dependent type if at least one operand is dependent which was\nwhat the current code was intending to do.  Coroutines have the additional\nwrinkle, that the current fn's type is an implicit operand.\n\nSo, if the coroutine function's type is not dependent, and the operand is not\ndependent, we should determine the type of the co_await expression using the\nDEPENDENT_EXPR wrapper machinery.  That allows us to determine the\nsubexpression type, but leave its operand unchanged and then instantiate it\nlater.\n\n\tPR c++/103868\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (finish_co_await_expr): Do not process non-dependent\n\tcoroutine expressions at template definition time.\n\t(finish_co_yield_expr): Likewise.\n\t(finish_co_return_stmt): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/coroutines/pr103868.C: New test.\n\nCo-Authored-by: Iain Sandoe <iain@sandoe.co.uk>", "tree": {"sha": "55d535c120e524211424cc60e94a2c750871be28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55d535c120e524211424cc60e94a2c750871be28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cb1f565a91e2dd57098c43593954b57c065a19b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cb1f565a91e2dd57098c43593954b57c065a19b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cb1f565a91e2dd57098c43593954b57c065a19b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cb1f565a91e2dd57098c43593954b57c065a19b/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d314907fc47f533ab27e8e1a57c09516ec1ac5e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d314907fc47f533ab27e8e1a57c09516ec1ac5e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d314907fc47f533ab27e8e1a57c09516ec1ac5e2"}], "stats": {"total": 175, "additions": 163, "deletions": 12}, "files": [{"sha": "64f4b4412e55d13b6aeaae652d0d4ea54c69ca55", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb1f565a91e2dd57098c43593954b57c065a19b/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb1f565a91e2dd57098c43593954b57c065a19b/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=9cb1f565a91e2dd57098c43593954b57c065a19b", "patch": "@@ -1148,10 +1148,13 @@ finish_co_await_expr (location_t kw, tree expr)\n      extraneous warnings during substitution.  */\n   suppress_warning (current_function_decl, OPT_Wreturn_type);\n \n-  /* If we don't know the promise type, we can't proceed, build the\n-     co_await with the expression unchanged.  */\n-  tree functype = TREE_TYPE (current_function_decl);\n-  if (dependent_type_p (functype) || type_dependent_expression_p (expr))\n+  /* Defer expansion when we are processing a template.\n+     FIXME: If the coroutine function's type is not dependent, and the operand\n+     is not dependent, we should determine the type of the co_await expression\n+     using the DEPENDENT_EXPR wrapper machinery.  That allows us to determine\n+     the subexpression type, but leave its operand unchanged and then\n+     instantiate it later.  */\n+  if (processing_template_decl)\n     {\n       tree aw_expr = build5_loc (kw, CO_AWAIT_EXPR, unknown_type_node, expr,\n \t\t\t\t NULL_TREE, NULL_TREE, NULL_TREE,\n@@ -1222,10 +1225,9 @@ finish_co_yield_expr (location_t kw, tree expr)\n      extraneous warnings during substitution.  */\n   suppress_warning (current_function_decl, OPT_Wreturn_type);\n \n-  /* If we don't know the promise type, we can't proceed, build the\n-     co_await with the expression unchanged.  */\n-  tree functype = TREE_TYPE (current_function_decl);\n-  if (dependent_type_p (functype) || type_dependent_expression_p (expr))\n+  /* Defer expansion when we are processing a template; see FIXME in the\n+     co_await code.  */\n+  if (processing_template_decl)\n     return build2_loc (kw, CO_YIELD_EXPR, unknown_type_node, expr, NULL_TREE);\n \n   if (!coro_promise_type_found_p (current_function_decl, kw))\n@@ -1307,10 +1309,9 @@ finish_co_return_stmt (location_t kw, tree expr)\n       && check_for_bare_parameter_packs (expr))\n     return error_mark_node;\n \n-  /* If we don't know the promise type, we can't proceed, build the\n-     co_return with the expression unchanged.  */\n-  tree functype = TREE_TYPE (current_function_decl);\n-  if (dependent_type_p (functype) || type_dependent_expression_p (expr))\n+  /* Defer expansion when we are processing a template; see FIXME in the\n+     co_await code.  */\n+  if (processing_template_decl)\n     {\n       /* co_return expressions are always void type, regardless of the\n \t expression type.  */"}, {"sha": "8687effb56375dfaf88710dfd1cc4f9f8db79416", "filename": "gcc/testsuite/g++.dg/coroutines/pr103868.C", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb1f565a91e2dd57098c43593954b57c065a19b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr103868.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb1f565a91e2dd57098c43593954b57c065a19b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr103868.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr103868.C?ref=9cb1f565a91e2dd57098c43593954b57c065a19b", "patch": "@@ -0,0 +1,150 @@\n+// { dg-additional-options \"-fpreprocessed -std=gnu++20 -w -fconcepts\" }\n+int _M_invoke___functor;\n+namespace std {\n+template <int __v> struct integral_constant {\n+  static constexpr bool value = __v;\n+};\n+template <typename> struct decay { typedef int type; };\n+template <bool, typename> struct enable_if;\n+template <typename _Tp> struct enable_if<true, _Tp> { typedef _Tp type; };\n+template <typename, typename _Fn, typename... _Args>\n+void __invoke_impl(_Fn __f, _Args... __args) {\n+  __f(__args...);\n+}\n+template <typename, typename _Callable, typename... _Args>\n+void __invoke_r(_Callable __fn, _Args... __args) {\n+  using __result = int;\n+  using __type = __result;\n+  __invoke_impl<__type>(__fn, __args...);\n+}\n+template <typename> class function;\n+template <typename _Functor> struct _Base_manager {\n+  static _Functor *_M_get_pointer(int) {}\n+};\n+template <typename, typename> class _Function_handler;\n+template <typename _Res, typename _Functor, typename... _ArgTypes>\n+struct _Function_handler<_Res(_ArgTypes...), _Functor> {\n+  static _Res _M_invoke(_ArgTypes... __args) {\n+    auto __trans_tmp_1 =\n+        _Base_manager<_Functor>::_M_get_pointer(_M_invoke___functor);\n+    __invoke_r<_Res>(*__trans_tmp_1, __args...);\n+  }\n+};\n+template <typename _Res, typename... _ArgTypes>\n+struct function<_Res(_ArgTypes...)> {\n+  template <typename _Functor> function(_Functor) {\n+    _Function_handler<_Res(_ArgTypes...), _Functor>::_M_invoke;\n+  }\n+};\n+template <typename _Tp> struct __shared_ptr_access {\n+  using element_type = _Tp;\n+  element_type *operator->();\n+};\n+template <typename> void make_shared();\n+} // namespace std\n+namespace boost {\n+using std::decay;\n+using std::enable_if;\n+using std::integral_constant;\n+namespace asio {\n+namespace detail {\n+template <typename> struct is_completion_signature;\n+template <typename R, typename... Args>\n+struct is_completion_signature<R(Args...)> : integral_constant<true> {};\n+} // namespace detail\n+template <typename T>\n+concept completion_signature = detail::is_completion_signature<T>::value;\n+template <typename...> struct async_result;\n+namespace detail {\n+template <completion_signature>\n+struct async_result_has_initiate_memfn : integral_constant<1> {};\n+} // namespace detail\n+template <typename CompletionToken, completion_signature... Signatures,\n+          typename Initiation>\n+enable_if<detail::async_result_has_initiate_memfn<Signatures...>::value,\n+          decltype(async_result<typename decay<CompletionToken>::type,\n+                                Signatures...>::initiate(0))>::type\n+async_initiate(Initiation) {}\n+} // namespace asio\n+} // namespace boost\n+namespace malloy::websocket {\n+struct connection {\n+  auto read(auto, auto done) {\n+    auto wrapper = [] {};\n+    return boost::asio::async_initiate<decltype(done), void()>(wrapper);\n+  }\n+};\n+} // namespace malloy::websocket\n+namespace std {\n+template <typename...> struct coroutine_traits;\n+template <typename = void> struct coroutine_handle {\n+  operator coroutine_handle<>();\n+};\n+struct suspend_always {\n+  bool await_ready();\n+  void await_suspend(coroutine_handle<>);\n+  void await_resume();\n+};\n+} // namespace std\n+namespace boost {\n+namespace asio {\n+namespace detail {\n+using std::coroutine_handle;\n+using std::suspend_always;\n+template <typename> class awaitable_frame;\n+} // namespace detail\n+template <typename, typename = int> struct awaitable {\n+  bool await_ready();\n+  template <class U>\n+  void await_suspend(detail::coroutine_handle<detail::awaitable_frame<U>>);\n+  void await_resume();\n+};\n+namespace detail {\n+struct awaitable_frame_base {\n+  auto initial_suspend() { return suspend_always(); }\n+  auto final_suspend() noexcept {\n+    struct result {\n+      bool await_ready() noexcept;\n+      void await_suspend(coroutine_handle<>) noexcept;\n+      void await_resume() noexcept;\n+    };\n+    return result{};\n+  }\n+  void unhandled_exception();\n+  template <typename T> auto await_transform(T a) { return a; }\n+};\n+template <> struct awaitable_frame<void> : awaitable_frame_base {\n+  void get_return_object();\n+};\n+} // namespace detail\n+} // namespace asio\n+} // namespace boost\n+namespace std {\n+template <typename T, typename Executor, typename... Args>\n+struct coroutine_traits<boost::asio::awaitable<T, Executor>, Args...> {\n+  typedef boost::asio::detail::awaitable_frame<T> promise_type;\n+};\n+} // namespace std\n+namespace boost {\n+namespace asio {\n+struct use_awaitable_t {\n+  use_awaitable_t(char, int, char);\n+} use_awaitable(0, 0, 0);\n+template <typename Executor, typename R, typename... Args>\n+struct async_result<Executor, R(Args...)> {\n+  template <typename Initiation> static awaitable<int> initiate(Initiation);\n+};\n+} // namespace asio\n+} // namespace boost\n+namespace malloy::test {\n+void roundtrip_coro(std::function<void(int)>);\n+}\n+using boost::asio::awaitable;\n+template <int> awaitable<void> client_ws_handler_coro() {\n+  std::__shared_ptr_access<malloy::websocket::connection> conn;\n+  auto buffer = std::make_shared<int>;\n+  co_await conn->read(buffer, boost::asio::use_awaitable);\n+}\n+void port() {\n+  malloy::test::roundtrip_coro([](auto) { client_ws_handler_coro<false>; });\n+}"}]}