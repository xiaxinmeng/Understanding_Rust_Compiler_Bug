{"sha": "148018bc3fe7ce47d005a1c5f7b6dd044024a4af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ4MDE4YmMzZmU3Y2U0N2QwMDVhMWM1ZjdiNmRkMDQ0MDI0YTRhZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-01-29T08:05:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-01-29T08:06:08Z"}, "message": "tree-optimization/93428 - avoid load permutation vector clobbering\n\nWith SLP now being a graph with shared nodes across instances we have\nto make sure to compute the load permutation of nodes once, not\noverwriting the result of earlier analysis.\n\n2020-01-28  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/93428\n\t* tree-vect-slp.c (vect_build_slp_tree_2): Compute the load\n\tpermutation when the load node is created.\n\t(vect_analyze_slp_instance): Re-use it here.\n\n\t* gcc.dg/torture/pr93428.c: New testcase.", "tree": {"sha": "a30ce10c81aca156f2ee9019eab8b7a6f94e6336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a30ce10c81aca156f2ee9019eab8b7a6f94e6336"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/148018bc3fe7ce47d005a1c5f7b6dd044024a4af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/148018bc3fe7ce47d005a1c5f7b6dd044024a4af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/148018bc3fe7ce47d005a1c5f7b6dd044024a4af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/148018bc3fe7ce47d005a1c5f7b6dd044024a4af/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "345ea96111385ecc2a38f1e9b18f4f07cb98140f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345ea96111385ecc2a38f1e9b18f4f07cb98140f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/345ea96111385ecc2a38f1e9b18f4f07cb98140f"}], "stats": {"total": 76, "additions": 64, "deletions": 12}, "files": [{"sha": "f6959ef6ebfe44f59d94ee6dbb1c3e6a368cd67b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148018bc3fe7ce47d005a1c5f7b6dd044024a4af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148018bc3fe7ce47d005a1c5f7b6dd044024a4af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=148018bc3fe7ce47d005a1c5f7b6dd044024a4af", "patch": "@@ -1,3 +1,10 @@\n+2020-01-29  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/93428\n+\t* tree-vect-slp.c (vect_build_slp_tree_2): Compute the load\n+\tpermutation when the load node is created.\n+\t(vect_analyze_slp_instance): Re-use it here.\n+\n 2020-01-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-prop.c (update_indirect_edges_after_inlining): Fix warning."}, {"sha": "a4a775d35560e33c172fc39e043e2cbcfc5d42b6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148018bc3fe7ce47d005a1c5f7b6dd044024a4af/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148018bc3fe7ce47d005a1c5f7b6dd044024a4af/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=148018bc3fe7ce47d005a1c5f7b6dd044024a4af", "patch": "@@ -1,3 +1,8 @@\n+2020-01-29  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/93428\n+\t* gcc.dg/torture/pr93428.c: New testcase.\n+\n 2020-01-28  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/93437"}, {"sha": "b24f651e5a601740da628f93c7015b8706ce5442", "filename": "gcc/testsuite/gcc.dg/torture/pr93428.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148018bc3fe7ce47d005a1c5f7b6dd044024a4af/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93428.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148018bc3fe7ce47d005a1c5f7b6dd044024a4af/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93428.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93428.c?ref=148018bc3fe7ce47d005a1c5f7b6dd044024a4af", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-ftree-slp-vectorize\" } */\n+\n+int ai[2][8];\n+void bar (int *);\n+void\n+br (void)\n+{\n+  int qp[9];\n+  bar (qp);\n+  ai[0][0] = qp[0] + qp[1] + 1 >> 1;\n+  ai[0][1] = qp[1] + qp[2] + 1 >> 1;\n+  ai[0][2] = qp[2] + qp[3] + 1 >> 1;\n+  ai[0][3] = qp[3] + qp[4] + 1 >> 1;\n+  ai[0][4] = qp[4] + qp[5] + 1 >> 1;\n+  ai[0][5] = qp[5] + qp[6] + 1 >> 1;\n+  ai[0][6] = qp[6] + qp[7] + 1 >> 1;\n+  ai[0][7] = qp[7] + qp[8] + 1 >> 1;\n+  ai[1][0] = qp[0] + qp[1] + 2 * qp[0] + 1 >> 2;\n+  ai[1][1] = qp[0] + qp[2] + 2 * qp[1] + 1 >> 2;\n+  ai[1][2] = qp[1] + qp[3] + 2 * qp[2] + 1 >> 2;\n+  ai[1][3] = qp[2] + qp[4] + 2 * qp[3] + 1 >> 2;\n+  ai[1][4] = qp[3] + qp[5] + 2 * qp[4] + 1 >> 2;\n+  ai[1][5] = qp[4] + qp[6] + 2 * qp[5] + 1 >> 2;\n+  ai[1][6] = qp[5] + qp[7] + 2 * qp[6] + 1 >> 2;\n+  ai[1][7] = qp[6] + qp[8] + 2 * qp[7] + 1 >> 2;\n+}"}, {"sha": "71a24b78cf4f152fe61efaea6676f819f2e5f80c", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148018bc3fe7ce47d005a1c5f7b6dd044024a4af/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148018bc3fe7ce47d005a1c5f7b6dd044024a4af/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=148018bc3fe7ce47d005a1c5f7b6dd044024a4af", "patch": "@@ -1353,6 +1353,23 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  *max_nunits = this_max_nunits;\n \t  (*tree_size)++;\n \t  node = vect_create_new_slp_node (stmts);\n+\t  /* And compute the load permutation.  Whether it is actually\n+\t     a permutation depends on the unrolling factor which is\n+\t     decided later.  */\n+\t  vec<unsigned> load_permutation;\n+\t  int j;\n+\t  stmt_vec_info load_info;\n+\t  load_permutation.create (group_size);\n+\t  stmt_vec_info first_stmt_info\n+\t    = DR_GROUP_FIRST_ELEMENT (SLP_TREE_SCALAR_STMTS (node)[0]);\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), j, load_info)\n+\t    {\n+\t      int load_place = vect_get_place_in_interleaving_chain\n+\t\t  (load_info, first_stmt_info);\n+\t      gcc_assert (load_place != -1);\n+\t      load_permutation.safe_push (load_place);\n+\t    }\n+\t  SLP_TREE_LOAD_PERMUTATION (node) = load_permutation;\n \t  return node;\n \t}\n     }\n@@ -2254,22 +2271,19 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  bool loads_permuted = false;\n \t  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (new_instance), i, load_node)\n \t    {\n-\t      vec<unsigned> load_permutation;\n-\t      int j;\n+\t      if (!SLP_TREE_LOAD_PERMUTATION (load_node).exists ())\n+\t\tcontinue;\n+\t      unsigned j;\n \t      stmt_vec_info load_info;\n \t      bool this_load_permuted = false;\n-\t      load_permutation.create (group_size);\n \t      stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT\n \t\t  (SLP_TREE_SCALAR_STMTS (load_node)[0]);\n \t      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load_info)\n-\t\t{\n-\t\t  int load_place = vect_get_place_in_interleaving_chain\n-\t\t      (load_info, first_stmt_info);\n-\t\t  gcc_assert (load_place != -1);\n-\t\t  if (load_place != j)\n+\t\tif (SLP_TREE_LOAD_PERMUTATION (load_node)[j] != j)\n+\t\t  {\n \t\t    this_load_permuted = true;\n-\t\t  load_permutation.safe_push (load_place);\n-\t\t}\n+\t\t    break;\n+\t\t  }\n \t      if (!this_load_permuted\n \t\t  /* The load requires permutation when unrolling exposes\n \t\t     a gap either because the group is larger than the SLP\n@@ -2278,10 +2292,9 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t\t      || (group_size == DR_GROUP_SIZE (first_stmt_info)\n \t\t\t  && DR_GROUP_GAP (first_stmt_info) == 0)))\n \t\t{\n-\t\t  load_permutation.release ();\n+\t\t  SLP_TREE_LOAD_PERMUTATION (load_node).release ();\n \t\t  continue;\n \t\t}\n-\t      SLP_TREE_LOAD_PERMUTATION (load_node) = load_permutation;\n \t      loads_permuted = true;\n \t    }\n "}]}