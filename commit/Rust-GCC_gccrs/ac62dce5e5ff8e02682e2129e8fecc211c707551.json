{"sha": "ac62dce5e5ff8e02682e2129e8fecc211c707551", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM2MmRjZTVlNWZmOGUwMjY4MmUyMTI5ZThmZWNjMjExYzcwNzU1MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:01Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:01Z"}, "message": "Add a class that multiplexes two pointer types\n\nThis patch adds a pointer_mux<T1, T2> class that provides similar\nfunctionality to:\n\n    union { T1 *a; T2 *b; };\n    ...\n    bool is_b_rather_than_a;\n\nexcept that the is_b_rather_than_a tag is stored in the low bit\nof the pointer.  See the comments in the patch for a comparison\nbetween the two approaches and why this one can be more efficient.\n\nI've tried to microoptimise the class a fair bit, since a later\npatch uses it extensively in order to keep the sizes of data\nstructures down.\n\ngcc/\n\t* mux-utils.h: New file.", "tree": {"sha": "3f623df1dae7e03110c1be32b07cccc3ce074ec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f623df1dae7e03110c1be32b07cccc3ce074ec5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac62dce5e5ff8e02682e2129e8fecc211c707551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac62dce5e5ff8e02682e2129e8fecc211c707551", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac62dce5e5ff8e02682e2129e8fecc211c707551", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac62dce5e5ff8e02682e2129e8fecc211c707551/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dd48296433763ba6f3a1c9068ce3991fb71e9b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dd48296433763ba6f3a1c9068ce3991fb71e9b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dd48296433763ba6f3a1c9068ce3991fb71e9b9"}], "stats": {"total": 251, "additions": 251, "deletions": 0}, "files": [{"sha": "b026a9fa4c18639cf18d14491c35f7f84d2afcce", "filename": "gcc/mux-utils.h", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac62dce5e5ff8e02682e2129e8fecc211c707551/gcc%2Fmux-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac62dce5e5ff8e02682e2129e8fecc211c707551/gcc%2Fmux-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmux-utils.h?ref=ac62dce5e5ff8e02682e2129e8fecc211c707551", "patch": "@@ -0,0 +1,251 @@\n+// Multiplexer utilities\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+//\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef GCC_MUX_UTILS_H\n+#define GCC_MUX_UTILS_H 1\n+\n+// A class that stores a choice \"A or B\", where A has type T1 * and B has\n+// type T2 *.  Both T1 and T2 must have an alignment greater than 1, since\n+// the low bit is used to identify B over A.  T1 and T2 can be the same.\n+//\n+// A can be a null pointer but B cannot.\n+//\n+// Barring the requirement that B must be nonnull, using the class is\n+// equivalent to using:\n+//\n+//     union { T1 *A; T2 *B; };\n+//\n+// and having a separate tag bit to indicate which alternative is active.\n+// However, using this class can have two advantages over a union:\n+//\n+// - It avoides the need to find somewhere to store the tag bit.\n+//\n+// - The compiler is aware that B cannot be null, which can make checks\n+//   of the form:\n+//\n+//       if (auto *B = mux.dyn_cast<T2 *> ())\n+//\n+//   more efficient.  With a union-based representation, the dyn_cast\n+//   check could fail either because MUX is an A or because MUX is a\n+//   null B, both of which require a run-time test.  With a pointer_mux,\n+//   only a check for MUX being A is needed.\n+template<typename T1, typename T2 = T1>\n+class pointer_mux\n+{\n+public:\n+  // Return an A pointer with the given value.\n+  static pointer_mux first (T1 *);\n+\n+  // Return a B pointer with the given (nonnull) value.\n+  static pointer_mux second (T2 *);\n+\n+  pointer_mux () = default;\n+\n+  // Create a null A pointer.\n+  pointer_mux (std::nullptr_t) : m_ptr (nullptr) {}\n+\n+  // Create an A or B pointer with the given value.  This is only valid\n+  // if T1 and T2 are distinct and if T can be resolved to exactly one\n+  // of them.\n+  template<typename T,\n+\t   typename Enable = typename\n+\t     std::enable_if<std::is_convertible<T *, T1 *>::value\n+\t\t\t    != std::is_convertible<T *, T2 *>::value>::type>\n+  pointer_mux (T *ptr);\n+\n+  // Return true unless the pointer is a null A pointer.\n+  explicit operator bool () const { return m_ptr; }\n+\n+  // Assign A and B pointers respectively.\n+  void set_first (T1 *ptr) { *this = first (ptr); }\n+  void set_second (T2 *ptr) { *this = second (ptr); }\n+\n+  // Return true if the pointer is an A pointer.\n+  bool is_first () const { return !(uintptr_t (m_ptr) & 1); }\n+\n+  // Return true if the pointer is a B pointer.\n+  bool is_second () const { return uintptr_t (m_ptr) & 1; }\n+\n+  // Return the contents of the pointer, given that it is known to be\n+  // an A pointer.\n+  T1 *known_first () const { return reinterpret_cast<T1 *> (m_ptr); }\n+\n+  // Return the contents of the pointer, given that it is known to be\n+  // a B pointer.\n+  T2 *known_second () const { return reinterpret_cast<T2 *> (m_ptr - 1); }\n+\n+  // If the pointer is an A pointer, return its contents, otherwise\n+  // return null.  Thus a null return can mean that the pointer is\n+  // either a null A pointer or a B pointer.\n+  //\n+  // If all A pointers are nonnull, it is more efficient to use:\n+  //\n+  //    if (ptr.is_first ())\n+  //      ...use ptr.known_first ()...\n+  //\n+  // over:\n+  //\n+  //    if (T1 *a = ptr.first_or_null ())\n+  //      ...use a...\n+  T1 *first_or_null () const;\n+\n+  // If the pointer is a B pointer, return its contents, otherwise\n+  // return null.  Using:\n+  //\n+  //    if (T1 *b = ptr.second_or_null ())\n+  //      ...use b...\n+  //\n+  // should be at least as efficient as:\n+  //\n+  //    if (ptr.is_second ())\n+  //      ...use ptr.known_second ()...\n+  T2 *second_or_null () const;\n+\n+  // Return true if the pointer is a T.\n+  //\n+  // This is only valid if T1 and T2 are distinct and if T can be\n+  // resolved to exactly one of them.  The condition is checked using\n+  // a static assertion rather than SFINAE because it gives a clearer\n+  // error message.\n+  template<typename T>\n+  bool is_a () const;\n+\n+  // Assert that the pointer is a T and return it as such.  See is_a\n+  // for the restrictions on T.\n+  template<typename T>\n+  T as_a () const;\n+\n+  // If the pointer is a T, return it as such, otherwise return null.\n+  // See is_a for the restrictions on T.\n+  template<typename T>\n+  T dyn_cast () const;\n+\n+private:\n+  pointer_mux (char *ptr) : m_ptr (ptr) {}\n+\n+  // The pointer value for A pointers, or the pointer value + 1 for B pointers.\n+  // Using a pointer rather than a uintptr_t tells the compiler that second ()\n+  // can never return null, and that second_or_null () is only null if\n+  // is_first ().\n+  char *m_ptr;\n+};\n+\n+template<typename T1, typename T2>\n+inline pointer_mux<T1, T2>\n+pointer_mux<T1, T2>::first (T1 *ptr)\n+{\n+  gcc_checking_assert (!(uintptr_t (ptr) & 1));\n+  return reinterpret_cast<char *> (ptr);\n+}\n+\n+template<typename T1, typename T2>\n+inline pointer_mux<T1, T2>\n+pointer_mux<T1, T2>::second (T2 *ptr)\n+{\n+  gcc_checking_assert (ptr && !(uintptr_t (ptr) & 1));\n+  return reinterpret_cast<char *> (ptr) + 1;\n+}\n+\n+template<typename T1, typename T2>\n+template<typename T, typename Enable>\n+inline pointer_mux<T1, T2>::pointer_mux (T *ptr)\n+  : m_ptr (reinterpret_cast<char *> (ptr))\n+{\n+  if (std::is_convertible<T *, T2 *>::value)\n+    {\n+      gcc_checking_assert (m_ptr);\n+      m_ptr += 1;\n+    }\n+}\n+\n+template<typename T1, typename T2>\n+inline T1 *\n+pointer_mux<T1, T2>::first_or_null () const\n+{\n+  return is_first () ? known_first () : nullptr;\n+}\n+\n+template<typename T1, typename T2>\n+inline T2 *\n+pointer_mux<T1, T2>::second_or_null () const\n+{\n+  // Micro optimization that's effective as of GCC 11: compute the value\n+  // of the second pointer as an integer and test that, so that the integer\n+  // result can be reused as the pointer and so that all computation can\n+  // happen before a branch on null.  This reduces the number of branches\n+  // needed for loops.\n+  return (uintptr_t (m_ptr) - 1) & 1 ? nullptr : known_second ();\n+}\n+\n+template<typename T1, typename T2>\n+template<typename T>\n+inline bool\n+pointer_mux<T1, T2>::is_a () const\n+{\n+  static_assert (std::is_convertible<T1 *, T>::value\n+\t\t != std::is_convertible<T2 *, T>::value,\n+\t\t \"Ambiguous pointer type\");\n+  if (std::is_convertible<T2 *, T>::value)\n+    return is_second ();\n+  else\n+    return is_first ();\n+}\n+\n+template<typename T1, typename T2>\n+template<typename T>\n+inline T\n+pointer_mux<T1, T2>::as_a () const\n+{\n+  static_assert (std::is_convertible<T1 *, T>::value\n+\t\t != std::is_convertible<T2 *, T>::value,\n+\t\t \"Ambiguous pointer type\");\n+  if (std::is_convertible<T2 *, T>::value)\n+    {\n+      gcc_checking_assert (is_second ());\n+      return reinterpret_cast<T> (m_ptr - 1);\n+    }\n+  else\n+    {\n+      gcc_checking_assert (is_first ());\n+      return reinterpret_cast<T> (m_ptr);\n+    }\n+}\n+\n+template<typename T1, typename T2>\n+template<typename T>\n+inline T\n+pointer_mux<T1, T2>::dyn_cast () const\n+{\n+  static_assert (std::is_convertible<T1 *, T>::value\n+\t\t != std::is_convertible<T2 *, T>::value,\n+\t\t \"Ambiguous pointer type\");\n+  if (std::is_convertible<T2 *, T>::value)\n+    {\n+      if (is_second ())\n+\treturn reinterpret_cast<T> (m_ptr - 1);\n+    }\n+  else\n+    {\n+      if (is_first ())\n+\treturn reinterpret_cast<T> (m_ptr);\n+    }\n+  return nullptr;\n+}\n+\n+#endif"}]}