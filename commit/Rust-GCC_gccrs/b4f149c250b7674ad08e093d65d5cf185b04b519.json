{"sha": "b4f149c250b7674ad08e093d65d5cf185b04b519", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRmMTQ5YzI1MGI3Njc0YWQwOGUwOTNkNjVkNWNmMTg1YjA0YjUxOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T10:48:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T10:48:06Z"}, "message": "[multiple changes]\n\n2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* lib-xref.ads Remove the small table of letter and symbol usage as we\n\talready have one.\n\n2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Emit specific error\n\tmessages depending on the offending misplaced aspect specifications.\n\t(Diagnose_Misplaced_Aspect_Specifications): New routine.\n\n2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Get_Cursor): Utility to retrieve cursor type\n\tfor iterable aspect primitives.\n\t(Resolve_Iterable_Operation): Use expected signature of iterable\n\taspect to resolve primitive when overloading is present.\n\t(Validate_Iterable_Aspect, Analyze_Aspects_At_Freeze_Point): use it.\n\t(Check_Signature): Removed.\n\nFrom-SVN: r207885", "tree": {"sha": "c938c23613148f3d6dc788ddc9346879e654b255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c938c23613148f3d6dc788ddc9346879e654b255"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4f149c250b7674ad08e093d65d5cf185b04b519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4f149c250b7674ad08e093d65d5cf185b04b519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4f149c250b7674ad08e093d65d5cf185b04b519", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4f149c250b7674ad08e093d65d5cf185b04b519/comments", "author": null, "committer": null, "parents": [{"sha": "ddd2bec582698a9a2ad20030278f0137d3b242c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddd2bec582698a9a2ad20030278f0137d3b242c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddd2bec582698a9a2ad20030278f0137d3b242c5"}], "stats": {"total": 413, "additions": 309, "deletions": 104}, "files": [{"sha": "95f2ac33e86c47b7f5e469c88672a359e4759d84", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f149c250b7674ad08e093d65d5cf185b04b519/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f149c250b7674ad08e093d65d5cf185b04b519/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b4f149c250b7674ad08e093d65d5cf185b04b519", "patch": "@@ -1,3 +1,23 @@\n+2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* lib-xref.ads Remove the small table of letter and symbol usage as we\n+\talready have one.\n+\n+2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Emit specific error\n+\tmessages depending on the offending misplaced aspect specifications.\n+\t(Diagnose_Misplaced_Aspect_Specifications): New routine.\n+\n+2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Get_Cursor): Utility to retrieve cursor type\n+\tfor iterable aspect primitives.\n+\t(Resolve_Iterable_Operation): Use expected signature of iterable\n+\taspect to resolve primitive when overloading is present.\n+\t(Validate_Iterable_Aspect, Analyze_Aspects_At_Freeze_Point): use it.\n+\t(Check_Signature): Removed.\n+\n 2014-02-19  Yannick Moy  <moy@adacore.com>\n \n \t* sem_ch10.adb (Analyze_Proper_Body): Issue error on missing"}, {"sha": "7f397a868a5f0820b37ac4e023e6c12b1c6798a9", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f149c250b7674ad08e093d65d5cf185b04b519/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f149c250b7674ad08e093d65d5cf185b04b519/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=b4f149c250b7674ad08e093d65d5cf185b04b519", "patch": "@@ -433,11 +433,6 @@ package Lib.Xref is\n    --  indicating procedures and functions. If the operation is abstract,\n    --  these letters are replaced in the xref by 'x' and 'y' respectively.\n \n-   --  The following letters and symbols are currently in use:\n-   --    A B C D E F I K L M N O P   R S T U V W X Y\n-   --    a b c d e f i k l m n o p q r s t u v w x y\n-   --    @ * + space\n-\n    Xref_Entity_Letters : array (Entity_Kind) of Character :=\n      (E_Abstract_State                             => '@',\n       E_Access_Attribute_Type                      => 'P',"}, {"sha": "7e2a09cc6dd892e9d335955226e40819e4195475", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 199, "deletions": 96, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f149c250b7674ad08e093d65d5cf185b04b519/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f149c250b7674ad08e093d65d5cf185b04b519/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b4f149c250b7674ad08e093d65d5cf185b04b519", "patch": "@@ -128,6 +128,10 @@ package body Sem_Ch13 is\n    --  Uint value. If the value is inappropriate, then error messages are\n    --  posted as required, and a value of No_Uint is returned.\n \n+   function Get_Cursor_Type return Entity_Id;\n+   --  Find Cursor type by name in the current scope, used to resolve primitive\n+   --  operations of an iterable type.\n+\n    function Is_Operational_Item (N : Node_Id) return Boolean;\n    --  A specification for a stream attribute is allowed before the full type\n    --  is declared, as explained in AI-00137 and the corrigendum. Attributes\n@@ -165,6 +169,14 @@ package body Sem_Ch13 is\n    --  either a simple direct reference to TName, or a selected component that\n    --  represents an appropriately qualified occurrence of TName.\n \n+   procedure Resolve_Iterable_Operation\n+     (N      : Node_Id;\n+      Cursor : Entity_Id;\n+      Typ    : Entity_Id;\n+      Nam    : Name_Id);\n+   --  If the name of a primitive operation for an Iterable aspect is\n+   --  overloaded, resolve according to required signature.\n+\n    procedure Set_Biased\n      (E      : Entity_Id;\n       N      : Node_Id;\n@@ -8044,15 +8056,23 @@ package body Sem_Ch13 is\n          --  Ditto for Iterable, legality checks in Validate_Iterable_Aspect.\n \n          when Aspect_Iterable =>\n+            T := Entity (ASN);\n+\n             declare\n-               Assoc : Node_Id;\n+               Cursor : constant Entity_Id := Get_Cursor_Type;\n+               Assoc  : Node_Id;\n+               Expr   : Node_Id;\n             begin\n                Assoc := First (Component_Associations (Expression (ASN)));\n                while Present (Assoc) loop\n-                  Analyze (Expression (Assoc));\n+                  Expr := Expression (Assoc);\n+                  Analyze (Expr);\n+                  Resolve_Iterable_Operation\n+                    (Expr, Cursor, T, Chars (First (Choices (Assoc))));\n                   Next (Assoc);\n                end loop;\n             end;\n+\n             return;\n \n          --  Invariant/Predicate take boolean expressions\n@@ -9725,6 +9745,32 @@ package body Sem_Ch13 is\n       end if;\n    end Get_Alignment_Value;\n \n+   ---------------------\n+   -- Get_Cursor_Type --\n+   ---------------------\n+\n+   function Get_Cursor_Type return Entity_Id is\n+      C : Entity_Id;\n+      E : Entity_Id;\n+\n+   begin\n+      --  There must be a cursor type declared in the same package, to be\n+      --  used in iterable primitives.\n+\n+      C := Empty;\n+      E := First_Entity (Current_Scope);\n+      while Present (E) loop\n+         if Chars (E) = Name_Cursor and then Is_Type (E) then\n+            C := E;\n+            exit;\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+\n+      return C;\n+   end Get_Cursor_Type;\n+\n    -------------------------------------\n    -- Inherit_Aspects_At_Freeze_Point --\n    -------------------------------------\n@@ -10806,6 +10852,140 @@ package body Sem_Ch13 is\n       end if;\n    end Same_Representation;\n \n+   --------------------------------\n+   -- Resolve_Iterable_Operation --\n+   --------------------------------\n+\n+   procedure Resolve_Iterable_Operation\n+     (N      : Node_Id;\n+      Cursor : Entity_Id;\n+      Typ    : Entity_Id;\n+      Nam    : Name_Id)\n+   is\n+      Ent : Entity_Id;\n+      F1  : Entity_Id;\n+      F2  : Entity_Id;\n+\n+   begin\n+      if not Is_Overloaded (N) then\n+         if not Is_Entity_Name (N)\n+           or else Ekind (Entity (N)) /= E_Function\n+           or else Scope (Entity (N)) /= Scope (Typ)\n+           or else No (First_Formal (Entity (N)))\n+           or else Etype (First_Formal (Entity (N))) /= Typ\n+         then\n+            Error_Msg_N (\"iterable primitive must be local function name \"\n+                         & \"whose first formal is an iterable type\", N);\n+         end if;\n+\n+         Ent := Entity (N);\n+         F1 := First_Formal (Ent);\n+         if Nam = Name_First then\n+\n+            --  First (Container) => Cursor\n+\n+            if Etype (Ent) /= Cursor then\n+               Error_Msg_N (\"primitive for First must yield a curosr\", N);\n+            end if;\n+\n+         elsif Nam = Name_Next then\n+\n+            --  Next (Container, Cursor) => Cursor\n+\n+            F2 := Next_Formal (F1);\n+\n+            if Etype (F2) /= Cursor\n+              or else Etype (Ent) /= Cursor\n+              or else Present (Next_Formal (F2))\n+            then\n+               Error_Msg_N (\"no match for Next iterable primitive\", N);\n+            end if;\n+\n+         elsif Nam = Name_Has_Element then\n+\n+            --  Has_Element (Container, Cursor) => Boolean\n+\n+            F2 := Next_Formal (F1);\n+            if Etype (F2) /= Cursor\n+              or else Etype (Ent) /= Standard_Boolean\n+              or else Present (Next_Formal (F2))\n+            then\n+               Error_Msg_N (\"no match for Has_Element iterable primitive\", N);\n+            end if;\n+\n+         elsif Nam = Name_Element then\n+            null;\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      else\n+         --  Overloaded case: find subprogram with proper signature.\n+         --  Caller will report error if no match is found.\n+\n+         declare\n+            I  : Interp_Index;\n+            It : Interp;\n+\n+         begin\n+            Get_First_Interp (N, I, It);\n+            while Present (It.Typ) loop\n+               if Ekind (It.Nam) = E_Function\n+                  and then Etype (First_Formal (It.Nam)) = Typ\n+               then\n+                  F1 := First_Formal (It.Nam);\n+\n+                  if Nam = Name_First then\n+                     if Etype (It.Nam) = Cursor\n+                       and then No (Next_Formal (F1))\n+                     then\n+                        Set_Entity (N, It.Nam);\n+                        exit;\n+                     end if;\n+\n+                  elsif Nam = Name_Next then\n+                     F2 := Next_Formal (F1);\n+\n+                     if Present (F2)\n+                       and then No (Next_Formal (F2))\n+                       and then Etype (F2) = Cursor\n+                       and then Etype (It.Nam) = Cursor\n+                     then\n+                        Set_Entity (N, It.Nam);\n+                        exit;\n+                     end if;\n+\n+                  elsif Nam = Name_Has_Element then\n+                     F2 := Next_Formal (F1);\n+\n+                     if Present (F2)\n+                       and then No (Next_Formal (F2))\n+                       and then Etype (F2) = Cursor\n+                       and then Etype (It.Nam) = Standard_Boolean\n+                     then\n+                        Set_Entity (N, It.Nam);\n+                        F2 := Next_Formal (F1);\n+                        exit;\n+                     end if;\n+\n+                  elsif Nam = Name_Element then\n+                     if Present (F2)\n+                       and then No (Next_Formal (F2))\n+                       and then Etype (F2) = Cursor\n+                     then\n+                        Set_Entity (N, It.Nam);\n+                        exit;\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n+            end loop;\n+         end;\n+      end if;\n+   end Resolve_Iterable_Operation;\n+\n    ----------------\n    -- Set_Biased --\n    ----------------\n@@ -11271,83 +11451,22 @@ package body Sem_Ch13 is\n    ------------------------------\n \n    procedure Validate_Iterable_Aspect (Typ : Entity_Id; ASN : Node_Id) is\n-      Scop   : constant Entity_Id := Scope (Typ);\n-      Assoc  : Node_Id;\n-      Expr   : Node_Id;\n+      Assoc : Node_Id;\n+      Expr  : Node_Id;\n \n       Prim   : Node_Id;\n-      Cursor : Entity_Id;\n+      Cursor : constant Entity_Id := Get_Cursor_Type;\n \n       First_Id       : Entity_Id;\n       Next_Id        : Entity_Id;\n       Has_Element_Id : Entity_Id;\n       Element_Id     : Entity_Id;\n \n-      procedure Check_Signature (Op : Entity_Id; Num_Formals : Positive);\n-      --  Verify that primitive has two parameters of the proper types.\n-\n-      ---------------------\n-      -- Check_Signature --\n-      ---------------------\n-\n-      procedure Check_Signature (Op : Entity_Id; Num_Formals : Positive) is\n-         F1, F2 : Entity_Id;\n-\n-      begin\n-         if Scope (Op) /= Current_Scope then\n-            Error_Msg_N (\"iterable primitive must be declared in scope\", Prim);\n-         end if;\n-\n-         F1 := First_Formal (Op);\n-\n-         if No (F1) or else Etype (F1) /= Typ then\n-            Error_Msg_N (\"first parameter must be container type\", Op);\n-         end if;\n-\n-         if Num_Formals = 1 then\n-            if Present (Next_Formal (F1)) then\n-               Error_Msg_N (\"First must have a single parameter\", Op);\n-            end if;\n-\n-         else\n-            F2 := Next_Formal (F1);\n-\n-            if No (F2) or else Etype (F2) /= Cursor then\n-               Error_Msg_N (\"second parameter must be cursor\", Op);\n-            end if;\n-\n-            if Present (Next_Formal (F2)) then\n-               Error_Msg_N (\"too many parameters in iterable primitive\", Op);\n-            end if;\n-         end if;\n-      end Check_Signature;\n-\n-   --  Start of processing for Validate_Iterable_Aspect\n-\n    begin\n-      --  There must be a cursor type declared in the same package\n-\n-      declare\n-         E : Entity_Id;\n-\n-      begin\n-         Cursor := Empty;\n-\n-         E := First_Entity (Scop);\n-         while Present (E) loop\n-            if Chars (E) = Name_Cursor and then Is_Type (E) then\n-               Cursor := E;\n-               exit;\n-            end if;\n-\n-            Next_Entity (E);\n-         end loop;\n-\n-         if No (Cursor) then\n-            Error_Msg_N (\"Iterable aspect requires a cursor type\", ASN);\n-            return;\n-         end if;\n-      end;\n+      if No (Cursor) then\n+         Error_Msg_N (\"Iterable aspect requires a cursor type\", ASN);\n+         return;\n+      end if;\n \n       First_Id       := Empty;\n       Next_Id        := Empty;\n@@ -11360,12 +11479,6 @@ package body Sem_Ch13 is\n          Expr := Expression (Assoc);\n          Analyze (Expr);\n \n-         if not Is_Entity_Name (Expr)\n-           or else Ekind (Entity (Expr)) /= E_Function\n-         then\n-            Error_Msg_N (\"this should be a function name\", Expr);\n-         end if;\n-\n          Prim := First (Choices (Assoc));\n \n          if Nkind (Prim) /= N_Identifier\n@@ -11374,32 +11487,20 @@ package body Sem_Ch13 is\n             Error_Msg_N (\"illegal name in association\", Prim);\n \n          elsif Chars (Prim) = Name_First then\n+            Resolve_Iterable_Operation (Expr, Cursor, Typ, Name_First);\n             First_Id := Entity (Expr);\n-            Check_Signature (First_Id, 1);\n-\n-            if Etype (First_Id) /= Cursor then\n-               Error_Msg_NE (\"First must return Cursor\", Expr, First_Id);\n-            end if;\n \n          elsif Chars (Prim) = Name_Next then\n+            Resolve_Iterable_Operation (Expr, Cursor, Typ, Name_Next);\n             Next_Id := Entity (Expr);\n-            Check_Signature (Next_Id, 2);\n-\n-            if Etype (Next_Id) /= Cursor then\n-               Error_Msg_NE (\"Next must return Cursor\", Expr, First_Id);\n-            end if;\n \n          elsif Chars (Prim) = Name_Has_Element then\n+            Resolve_Iterable_Operation (Expr, Cursor, Typ, Name_Has_Element);\n             Has_Element_Id := Entity (Expr);\n \n-            if Etype (Has_Element_Id) /= Standard_Boolean then\n-               Error_Msg_NE\n-                (\"Has_Element must return Boolean\", Expr, First_Id);\n-            end if;\n-\n          elsif Chars (Prim) = Name_Element then\n+            Resolve_Iterable_Operation (Expr, Cursor, Typ, Name_Element);\n             Element_Id := Entity (Expr);\n-            Check_Signature (Element_Id, 2);\n \n          else\n             Error_Msg_N (\"invalid name for iterable function\", Prim);\n@@ -11409,14 +11510,16 @@ package body Sem_Ch13 is\n       end loop;\n \n       if No (First_Id) then\n-         Error_Msg_N (\"Iterable aspect must have a First primitive\", ASN);\n+         Error_Msg_N (\"match for First primitive not found\", ASN);\n \n       elsif No (Next_Id) then\n-         Error_Msg_N (\"Iterable aspect must have a Next primitive\", ASN);\n+         Error_Msg_N (\"match for Next primitive not found\", ASN);\n \n       elsif No (Has_Element_Id) then\n-         Error_Msg_N\n-           (\"Iterable aspect must have a Has_Element  primitive\", ASN);\n+         Error_Msg_N (\"match for Has_Element primitive not found\", ASN);\n+\n+      elsif No (Element_Id) then\n+         null;  --  Optional.\n       end if;\n    end Validate_Iterable_Aspect;\n "}, {"sha": "fa2722bc0dadddba0b921241fd7838cffbfd322b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 90, "deletions": 3, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f149c250b7674ad08e093d65d5cf185b04b519/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f149c250b7674ad08e093d65d5cf185b04b519/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=b4f149c250b7674ad08e093d65d5cf185b04b519", "patch": "@@ -2116,6 +2116,11 @@ package body Sem_Ch6 is\n       --  verify that a function ends with a RETURN and that a procedure does\n       --  not contain any RETURN.\n \n+      procedure Diagnose_Misplaced_Aspect_Specifications;\n+      --  It is known that subprogram body N has aspects, but they are not\n+      --  properly placed. Provide specific error messages depending on the\n+      --  aspects involved.\n+\n       function Disambiguate_Spec return Entity_Id;\n       --  When a primitive is declared between the private view and the full\n       --  view of a concurrent type which implements an interface, a special\n@@ -2388,6 +2393,90 @@ package body Sem_Ch6 is\n          end if;\n       end Check_Missing_Return;\n \n+      ----------------------------------------------\n+      -- Diagnose_Misplaced_Aspect_Specifications --\n+      ----------------------------------------------\n+\n+      procedure Diagnose_Misplaced_Aspect_Specifications is\n+         Asp     : Node_Id;\n+         Asp_Nam : Name_Id;\n+         Asp_Id  : Aspect_Id;\n+         --  The current aspect along with its name and id\n+\n+         procedure SPARK_Aspect_Error (Ref_Nam : Name_Id);\n+         --  Emit an error message concerning SPARK aspect Asp. Ref_Nam is the\n+         --  name of the refined version of the aspect.\n+\n+         ------------------------\n+         -- SPARK_Aspect_Error --\n+         ------------------------\n+\n+         procedure SPARK_Aspect_Error (Ref_Nam : Name_Id) is\n+         begin\n+            --  The corresponding spec already contains the aspect in question\n+            --  and the one appearing on the body must be the refined form:\n+\n+            --    procedure P with Global ...;\n+            --    procedure P with Global ... is ... end P;\n+            --                     ^\n+            --                     Refined_Global\n+\n+            if Has_Aspect (Spec_Id, Asp_Id) then\n+               Error_Msg_Name_1 := Asp_Nam;\n+               Error_Msg_Name_2 := Ref_Nam;\n+               Error_Msg_N (\"aspect % should be %\", Asp);\n+\n+            --  Otherwise the aspect must appear in the spec, not in the body:\n+\n+            --    procedure P;\n+            --    procedure P with Global ... is ... end P;\n+\n+            else\n+               Error_Msg_N\n+                 (\"aspect specification must appear in subprogram declaration\",\n+                  Asp);\n+            end if;\n+         end SPARK_Aspect_Error;\n+\n+      --  Start of processing for Diagnose_Misplaced_Aspect_Specifications\n+\n+      begin\n+         --  Iterate over the aspect specifications and emit specific errors\n+         --  where applicable.\n+\n+         Asp := First (Aspect_Specifications (N));\n+         while Present (Asp) loop\n+            Asp_Nam := Chars (Identifier (Asp));\n+            Asp_Id  := Get_Aspect_Id (Asp_Nam);\n+\n+            --  Do not emit errors on aspects that can appear on a subprogram\n+            --  body. This scenario occurs when the aspect specification list\n+            --  contains both misplaced and properly placed aspects.\n+\n+            if Aspect_On_Body_Or_Stub_OK (Asp_Id) then\n+               null;\n+\n+            --  Special diagnostics for SPARK aspects\n+\n+            elsif Asp_Nam = Name_Depends then\n+               SPARK_Aspect_Error (Name_Refined_Depends);\n+\n+            elsif Asp_Nam = Name_Global then\n+               SPARK_Aspect_Error (Name_Refined_Global);\n+\n+            elsif Asp_Nam = Name_Post then\n+               SPARK_Aspect_Error (Name_Refined_Post);\n+\n+            else\n+               Error_Msg_N\n+                 (\"aspect specification must appear in subprogram declaration\",\n+                  Asp);\n+            end if;\n+\n+            Next (Asp);\n+         end loop;\n+      end Diagnose_Misplaced_Aspect_Specifications;\n+\n       -----------------------\n       -- Disambiguate_Spec --\n       -----------------------\n@@ -2774,9 +2863,7 @@ package body Sem_Ch6 is\n \n            and then Nkind (Parent (Parent (Spec_Id))) /= N_Subprogram_Body_Stub\n          then\n-            Error_Msg_N\n-              (\"aspect specifications must appear in subprogram declaration\",\n-               N);\n+            Diagnose_Misplaced_Aspect_Specifications;\n \n          --  Delay the analysis of aspect specifications that apply to a body\n          --  stub until the proper body is analyzed. If the corresponding body"}]}