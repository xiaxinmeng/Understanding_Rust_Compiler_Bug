{"sha": "a1c496cb437080bd861ea5fed4220514e64c915e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFjNDk2Y2I0MzcwODBiZDg2MWVhNWZlZDQyMjA1MTRlNjRjOTE1ZQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-10-01T05:08:59Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-10-01T05:08:59Z"}, "message": "dwarf2.h (dwarf_calling_convention): Add enum for renesas sh abi.\n\n2004-09-30  Eric Christopher  <echristo@redhat.com>\n\n\t* dwarf2.h (dwarf_calling_convention): Add enum for renesas\n\tsh abi.\n\t* dwarf2out.c (add_calling_convention_attribute): New function.\n\t(gen_subroutine_type_die): Use.\n\t* target-def.h (TARGET_DWARF_CALLING_CONVENTION): New hook.\n\t* target.h (gcc_target): Add dwarf_calling_convention.\n\t* hooks.c (hook_int_tree_0): New function.\n\t* hooks.h: Prototype.\n\t* config/sh/sh.c: Include dwarf2.h.\n\t(sh_dwarf_calling_convention): New function.\n\t(TARGET_DWARF_CALLING_CONVENTION): Use.\n\t* doc/tm.texi (TARGET_DWARF_CALLING_CONVENTION): Document.\n\nFrom-SVN: r88382", "tree": {"sha": "c068b7bf095d7380d889d59915274cc18faad4a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c068b7bf095d7380d889d59915274cc18faad4a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1c496cb437080bd861ea5fed4220514e64c915e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c496cb437080bd861ea5fed4220514e64c915e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c496cb437080bd861ea5fed4220514e64c915e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c496cb437080bd861ea5fed4220514e64c915e/comments", "author": null, "committer": null, "parents": [{"sha": "049bc4044531a146d278dd63ff0ad226c239424c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/049bc4044531a146d278dd63ff0ad226c239424c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/049bc4044531a146d278dd63ff0ad226c239424c"}], "stats": {"total": 152, "additions": 111, "deletions": 41}, "files": [{"sha": "5fcdf209fb2ed943da0f44cdcfb1f32dc9afdd13", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -1,3 +1,18 @@\n+2004-09-30  Eric Christopher  <echristo@redhat.com>\n+\n+\t* dwarf2.h (dwarf_calling_convention): Add enum for renesas\n+\tsh abi.\n+\t* dwarf2out.c (add_calling_convention_attribute): New function.\n+\t(gen_subroutine_type_die): Use.\n+\t* target-def.h (TARGET_DWARF_CALLING_CONVENTION): New hook.\n+\t* target.h (gcc_target): Add dwarf_calling_convention.\n+\t* hooks.c (hook_int_tree_0): New function.\n+\t* hooks.h: Prototype.\n+\t* config/sh/sh.c: Include dwarf2.h.\n+\t(sh_dwarf_calling_convention): New function.\n+\t(TARGET_DWARF_CALLING_CONVENTION): Use.\n+\t* doc/tm.texi (TARGET_DWARF_CALLING_CONVENTION): Document.\n+\n 2004-09-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* builtins.c (expand_builtin_strstr, expand_builtin_strchr,\n@@ -102,7 +117,7 @@\n \ts390_update_frame_layout instead of s390_register_info.  Handle\n \tprologue/epilogue insns that touch only RETURN_REGNUM.\n \t(s390_reorg): Remove base_used.  Clear split_branches_pending_p.\n-\t(s390_register_info): Remove base_used and return_addr_used \n+\t(s390_register_info): Remove base_used and return_addr_used\n \targuments, compute special register usage inline.  Return live\n \tregister data to caller.\n \t(s390_frame_info): Remove arguments, do not call s390_register_info."}, {"sha": "349d981ccc98a18e46e65ca52678e1cb8c2a393f", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"c-pragma.h\"\n #include \"integrate.h\"\n+#include \"dwarf2.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n@@ -285,6 +286,7 @@ static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, bool);\n static bool sh_callee_copies (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t      tree, bool);\n+static int sh_dwarf_calling_convention (tree);\n \n \f\n /* Initialize the GCC target structure.  */\n@@ -454,6 +456,9 @@ static bool sh_callee_copies (CUMULATIVE_ARGS *, enum machine_mode,\n #undef TARGET_PCH_VALID_P\n #define TARGET_PCH_VALID_P sh_pch_valid_p\n \n+#undef TARGET_DWARF_CALLING_CONVENTION\n+#define TARGET_DWARF_CALLING_CONVENTION sh_dwarf_calling_convention\n+\n /* Return regmode weight for insn.  */\n #define INSN_REGMODE_WEIGHT(INSN, MODE)  regmode_weight[((MODE) == SImode) ? 0 : 1][INSN_UID (INSN)]\n \n@@ -9402,6 +9407,17 @@ sh_vector_mode_supported_p (enum machine_mode mode)\n   return false;\n }\n \n+/* Implements target hook dwarf_calling_convention.  Return an enum\n+   of dwarf_calling_convention.  */\n+int\n+sh_dwarf_calling_convention (tree func)\n+{\n+  if (sh_attr_renesas_p (func))\n+    return DW_CC_renesas_sh;\n+\n+  return DW_CC_normal;\n+}\n+\n static void\n sh_init_builtins (void)\n {"}, {"sha": "8208a89061a5b921fc67a701dcddec3f6e43996b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -3747,7 +3747,7 @@ known to be passed by reference.  The hook should return true if the\n function argument should be copied by the callee instead of copied\n by the caller.\n \n-For any argument for which the hook returns true, if it can be \n+For any argument for which the hook returns true, if it can be\n determined that the argument is not modified, then a copy need\n not be generated.\n \n@@ -8061,6 +8061,12 @@ for SDB in response to the @option{-g} option.\n Define this macro if GCC should produce dwarf version 2 format\n debugging output in response to the @option{-g} option.\n \n+@deftypefn {Target Hook} int TARGET_DWARF_CALLING_CONVENTION (tree @var{function})\n+Define this to enable the dwarf attribute @code{DW_AT_calling_convention} to\n+be emitted for each function.  Instead of an integer return the enum\n+value for the @code{DW_CC_} tag.\n+@end deftypefn\n+\n To support optional call frame debugging information, you must also\n define @code{INCOMING_RETURN_ADDR_RTX} and either set\n @code{RTX_FRAME_RELATED_P} on the prologue insns if you use RTL for the"}, {"sha": "111ff522fe3616b1a0fbb62c65e0a1518aee7d09", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -474,7 +474,8 @@ enum dwarf_calling_convention\n   {\n     DW_CC_normal = 0x1,\n     DW_CC_program = 0x2,\n-    DW_CC_nocall = 0x3\n+    DW_CC_nocall = 0x3,\n+    DW_CC_renesas_sh = 0x40\n   };\n \n #define DW_CC_lo_user 0x40"}, {"sha": "aa308489ff655b74f31ed3b9287617703687e409", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 51, "deletions": 35, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -116,7 +116,7 @@ dwarf2out_do_frame (void)\n /* Various versions of targetm.eh_frame_section.  Note these must appear\n    outside the DWARF2_DEBUGGING_INFO || DWARF2_UNWIND_INFO macro guards.  */\n \n-/* Version of targetm.eh_frame_section for systems with named sections.  */ \n+/* Version of targetm.eh_frame_section for systems with named sections.  */\n void\n named_section_eh_frame_section (void)\n {\n@@ -142,7 +142,7 @@ named_section_eh_frame_section (void)\n #endif\n }\n \n-/* Version of targetm.eh_frame_section for systems using collect2.  */ \n+/* Version of targetm.eh_frame_section for systems using collect2.  */\n void\n collect2_eh_frame_section (void)\n {\n@@ -1150,7 +1150,7 @@ struct reg_saved_in_data GTY(()) {\n    more efficient data structure.  */\n static GTY(()) struct reg_saved_in_data regs_saved_in_regs[4];\n static GTY(()) size_t num_regs_saved_in_regs;\n-  \n+\n #if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n static const char *last_reg_save_label;\n \n@@ -1253,7 +1253,7 @@ reg_saved_in (rtx reg)\n   unsigned int regn = REGNO (reg);\n   size_t i;\n   struct queued_reg_save *q;\n-  \n+\n   for (q = queued_reg_saves; q; q = q->next)\n     if (q->saved_reg && regn == REGNO (q->saved_reg))\n       return q->reg;\n@@ -1311,7 +1311,7 @@ static dw_cfa_location cfa_temp;\n   the intent is to save the value of SP from the previous frame.\n \n   In addition, if a register has previously been saved to a different\n-  register, \n+  register,\n \n   Invariants / Summaries of Rules\n \n@@ -1480,7 +1480,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t    {\n \t      /* Rule 1 */\n \t      /* Update the CFA rule wrt SP or FP.  Make sure src is\n-\t\t relative to the current CFA register. \n+\t\t relative to the current CFA register.\n \n \t\t We used to require that dest be either SP or FP, but the\n \t\t ARM copies SP to a temporary register, and from there to\n@@ -1677,14 +1677,14 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \tcase LO_SUM:\n \t  {\n \t    int regno;\n-\t    \n+\n \t    gcc_assert (GET_CODE (XEXP (XEXP (dest, 0), 1)) == CONST_INT);\n \t    offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n \t    if (GET_CODE (XEXP (dest, 0)) == MINUS)\n \t      offset = -offset;\n \n \t    regno = REGNO (XEXP (XEXP (dest, 0), 0));\n-\t    \n+\n \t    if (cfa_store.reg == (unsigned) regno)\n \t      offset -= cfa_store.offset;\n \t    else\n@@ -1700,7 +1700,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \tcase REG:\n \t  {\n \t    int regno = REGNO (XEXP (dest, 0));\n-\t    \n+\n \t    if (cfa_store.reg == (unsigned) regno)\n \t      offset = -cfa_store.offset;\n \t    else\n@@ -1778,7 +1778,7 @@ dwarf2out_frame_debug (rtx insn)\n   if (insn == NULL_RTX)\n     {\n       size_t i;\n-      \n+\n       /* Flush any queued register saves.  */\n       flush_queued_reg_saves ();\n \n@@ -1791,7 +1791,7 @@ dwarf2out_frame_debug (rtx insn)\n       cfa_store = cfa;\n       cfa_temp.reg = -1;\n       cfa_temp.offset = 0;\n-      \n+\n       for (i = 0; i < num_regs_saved_in_regs; i++)\n \t{\n \t  regs_saved_in_regs[i].orig_reg = NULL_RTX;\n@@ -3930,6 +3930,7 @@ static dw_die_ref scope_die_for (tree, dw_die_ref);\n static inline int local_scope_p (dw_die_ref);\n static inline int class_or_namespace_scope_p (dw_die_ref);\n static void add_type_attribute (dw_die_ref, tree, int, int, dw_die_ref);\n+static void add_calling_convention_attribute (dw_die_ref, tree);\n static const char *type_tag (tree);\n static tree member_declared_type (tree);\n #if 0\n@@ -4809,11 +4810,11 @@ AT_string_form (dw_attr_ref a)\n   char label[32];\n \n   gcc_assert (a && AT_class (a) == dw_val_class_str);\n-  \n+\n   node = a->dw_attr_val.v.val_str;\n   if (node->form)\n     return node->form;\n-  \n+\n   len = strlen (node->str) + 1;\n \n   /* If the string is shorter or equal to the size of the reference, it is\n@@ -8637,7 +8638,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n     case ASHIFT:\n       op = DW_OP_shl;\n       goto do_binop;\n-      \n+\n     case ASHIFTRT:\n       op = DW_OP_shra;\n       goto do_binop;\n@@ -9283,7 +9284,7 @@ field_byte_offset (tree decl)\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return 0;\n-  \n+\n   gcc_assert (TREE_CODE (decl) == FIELD_DECL);\n \n   type = field_type (decl);\n@@ -9557,7 +9558,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \n \tif (val < 0)\n \t  add_AT_int (die, DW_AT_const_value, val);\n-\telse \n+\telse\n \t  add_AT_unsigned (die, DW_AT_const_value, (unsigned HOST_WIDE_INT) val);\n       }\n       break;\n@@ -9605,30 +9606,30 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \t      {\n \t\trtx elt = CONST_VECTOR_ELT (rtl, i);\n \t\tHOST_WIDE_INT lo, hi;\n-\t\t\n+\n \t\tswitch (GET_CODE (elt))\n \t\t  {\n \t\t  case CONST_INT:\n \t\t    lo = INTVAL (elt);\n \t\t    hi = -(lo < 0);\n \t\t    break;\n-\t\t    \n+\n \t\t  case CONST_DOUBLE:\n \t\t    lo = CONST_DOUBLE_LOW (elt);\n \t\t    hi = CONST_DOUBLE_HIGH (elt);\n \t\t    break;\n-\t\t    \n+\n \t\t  default:\n \t\t    gcc_unreachable ();\n \t\t  }\n-\t\t\n+\n \t\tif (elt_size <= sizeof (HOST_WIDE_INT))\n \t\t  insert_int (lo, elt_size, p);\n \t\telse\n \t\t  {\n \t\t    unsigned char *p0 = p;\n \t\t    unsigned char *p1 = p + sizeof (HOST_WIDE_INT);\n-\t\t    \n+\n \t\t    gcc_assert (elt_size == 2 * sizeof (HOST_WIDE_INT));\n \t\t    if (WORDS_BIG_ENDIAN)\n \t\t      {\n@@ -10621,6 +10622,20 @@ add_type_attribute (dw_die_ref object_die, tree type, int decl_const,\n     add_AT_die_ref (object_die, DW_AT_type, type_die);\n }\n \n+/* Given an object die, add the calling convention attribute for the\n+   function call type.  */\n+static void\n+add_calling_convention_attribute (dw_die_ref subr_die, tree type)\n+{\n+  enum dwarf_calling_convention value = DW_CC_normal;\n+\n+  value = targetm.dwarf_calling_convention (type);\n+\n+  /* Only add the attribute if the backend requests it.  */\n+  if (value)\n+    add_AT_unsigned (subr_die, DW_AT_calling_convention, value);\n+}\n+\n /* Given a tree pointer to a struct, class, union, or enum type node, return\n    a pointer to the (string) tag name for the given type, or zero if the type\n    was declared without a tag.  */\n@@ -11165,7 +11180,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  subr_die = old_die;\n \n \t  /* Clear out the declaration attribute and the formal parameters.\n-\t     Do not remove all children, because it is possible that this \n+\t     Do not remove all children, because it is possible that this\n \t     declaration die was forced using force_decl_die(). In such\n \t     cases die that forced declaration die (e.g. TAG_imported_module)\n \t     is one of the children that we do not want to remove.  */\n@@ -11218,7 +11233,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  /* The first time we see a member function, it is in the context of\n \t     the class to which it belongs.  We make sure of this by emitting\n \t     the class first.  The next time is the definition, which is\n-\t     handled above.  The two may come from the same source text. \n+\t     handled above.  The two may come from the same source text.\n \n \t     Note that force_decl_die() forces function declaration die. It is\n \t     later reused to represent definition.  */\n@@ -11917,6 +11932,7 @@ gen_subroutine_type_die (tree type, dw_die_ref context_die)\n   equate_type_number_to_die (type, subr_die);\n   add_prototyped_attribute (subr_die, type);\n   add_type_attribute (subr_die, return_type, 0, 0, context_die);\n+  add_calling_convention_attribute (subr_die, type);\n   gen_formal_types_die (type, subr_die);\n }\n \n@@ -12356,7 +12372,7 @@ force_decl_die (tree decl)\n \t  save_fn = current_function_decl;\n \t  current_function_decl = NULL_TREE;\n \t  gen_subprogram_die (decl, context_die);\n-\t  current_function_decl = save_fn; \n+\t  current_function_decl = save_fn;\n \t  break;\n \n \tcase VAR_DECL:\n@@ -12375,14 +12391,14 @@ force_decl_die (tree decl)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-  \n+\n       /* See if we can find the die for this deci now.\n \t If not then abort.  */\n       if (!decl_die)\n \tdecl_die = lookup_decl_die (decl);\n       gcc_assert (decl_die);\n     }\n-  \n+\n   return decl_die;\n }\n \n@@ -12696,23 +12712,23 @@ dwarf2out_type_decl (tree decl, int local)\n     dwarf2out_decl (decl);\n }\n \n-/* Output debug information for imported module or decl.  */ \n- \n+/* Output debug information for imported module or decl.  */\n+\n static void\n dwarf2out_imported_module_or_decl (tree decl, tree context)\n {\n   dw_die_ref imported_die, at_import_die;\n   dw_die_ref scope_die;\n   unsigned file_index;\n   expanded_location xloc;\n-  \n+\n   if (debug_info_level <= DINFO_LEVEL_TERSE)\n     return;\n \n   gcc_assert (decl);\n \n   /* To emit DW_TAG_imported_module or DW_TAG_imported_decl, we need two DIEs.\n-     We need decl DIE for reference and scope die. First, get DIE for the decl \n+     We need decl DIE for reference and scope die. First, get DIE for the decl\n      itself.  */\n \n   /* Get the scope die for decl context. Use comp_unit_die for global module\n@@ -12729,8 +12745,8 @@ dwarf2out_imported_module_or_decl (tree decl, tree context)\n     at_import_die = force_type_die (TREE_TYPE (decl));\n   else\n     at_import_die = force_decl_die (decl);\n-  \n-  /* OK, now we have DIEs for decl as well as scope. Emit imported die.  */ \n+\n+  /* OK, now we have DIEs for decl as well as scope. Emit imported die.  */\n   if (TREE_CODE (decl) == NAMESPACE_DECL)\n     imported_die = new_die (DW_TAG_imported_module, scope_die, context);\n   else\n@@ -13440,7 +13456,7 @@ static void\n prune_unused_types_prune (dw_die_ref die)\n {\n   dw_die_ref c, p, n;\n-  \n+\n   gcc_assert (die->die_mark);\n \n   p = NULL;\n@@ -13568,9 +13584,9 @@ dwarf2out_finish (const char *filename)\n \t\tcontext = DECL_CONTEXT (node->created_for);\n \t      else if (TYPE_P (node->created_for))\n \t\tcontext = TYPE_CONTEXT (node->created_for);\n-\t\t\n+\n \t      gcc_assert (context && TREE_CODE (context) == FUNCTION_DECL);\n-\t      \n+\n \t      origin = lookup_decl_die (context);\n \t      if (origin)\n \t        add_child_die (origin, die);"}, {"sha": "9470a4d84c6130953fa5072afb6c607edccfd364", "filename": "gcc/hooks.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -117,6 +117,12 @@ default_can_output_mi_thunk_no_vcall (tree a ATTRIBUTE_UNUSED,\n   return c == 0;\n }\n \n+int\n+hook_int_tree_0 (tree a ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n /* ??? Used for comp_type_attributes, which ought to return bool.  */\n int\n hook_int_tree_tree_1 (tree a ATTRIBUTE_UNUSED, tree b ATTRIBUTE_UNUSED)\n@@ -245,4 +251,3 @@ hook_tree_tree_bool_null (tree t ATTRIBUTE_UNUSED, bool ignore ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }\n-  "}, {"sha": "10966a912a28e7263ef2f45dd700b556d1b29ad5", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -46,6 +46,7 @@ extern void hook_void_FILEptr_constcharptr (FILE *, const char *);\n extern void hook_void_tree (tree);\n extern void hook_void_tree_treeptr (tree, tree *);\n \n+extern int hook_int_tree_0 (tree);\n extern int hook_int_tree_tree_1 (tree, tree);\n extern int hook_int_rtx_0 (rtx);\n extern int hook_int_size_t_constcharptr_int_0 (size_t, const char *, int);"}, {"sha": "700d5db51ec0dac73e49495097a467dce7e9aa42", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -379,6 +379,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #define TARGET_MD_ASM_CLOBBERS hook_tree_tree_identity\n \n+#define TARGET_DWARF_CALLING_CONVENTION hook_int_tree_0\n+\n #define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_false\n #define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_false\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_false\n@@ -523,6 +525,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_DEFAULT_SHORT_ENUMS,\t\t\t\\\n   TARGET_BUILTIN_SETJMP_FRAME_VALUE,\t\t\\\n   TARGET_MD_ASM_CLOBBERS,\t\t\t\\\n+  TARGET_DWARF_CALLING_CONVENTION,              \\\n   TARGET_CALLS,\t\t\t\t\t\\\n   TARGET_CXX,\t\t\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\"}, {"sha": "49a7f9d7f920fd9170b5f0627f632508c90b7c80", "filename": "gcc/target.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -488,6 +488,13 @@ struct gcc_target\n      the port wishes to automatically clobber for all asms.  */\n   tree (* md_asm_clobbers) (tree);\n \n+  /* This target hook allows the backend to specify a calling convention\n+     in the debug information.  This function actually returns an\n+     enum dwarf_calling_convention, but because of forward declarations\n+     and not wanting to include dwarf2.h everywhere target.h is included\n+     the function is being declared as an int.  */\n+  int (* dwarf_calling_convention) (tree);\n+\n   /* Functions relating to calls - argument passing, returns, etc.  */\n   struct calls {\n     bool (*promote_function_args) (tree fntype);"}, {"sha": "852421cb9e33996ab482731812b8fe448bafa3e8", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c496cb437080bd861ea5fed4220514e64c915e/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=a1c496cb437080bd861ea5fed4220514e64c915e", "patch": "@@ -129,7 +129,7 @@ default_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n \t  != default_setup_incoming_varargs);\n }\n \n-enum machine_mode \n+enum machine_mode\n default_eh_return_filter_mode (void)\n {\n   return word_mode;\n@@ -173,7 +173,7 @@ default_cxx_get_cookie_size (tree type)\n      (true_type)) bytes.  */\n   tree sizetype_size;\n   tree type_align;\n-  \n+\n   sizetype_size = size_in_bytes (sizetype);\n   type_align = size_int (TYPE_ALIGN_UNIT (type));\n   if (INT_CST_LT_UNSIGNED (type_align, sizetype_size))"}]}