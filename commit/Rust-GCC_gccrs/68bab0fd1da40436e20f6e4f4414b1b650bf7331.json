{"sha": "68bab0fd1da40436e20f6e4f4414b1b650bf7331", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhiYWIwZmQxZGE0MDQzNmUyMGY2ZTRmNDQxNGIxYjY1MGJmNzMzMQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2013-04-11T10:23:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T10:23:56Z"}, "message": "exp_ch4.adb (Expand_Concatenate): Remove wrapping in expression-with-actions node.\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenate): Remove wrapping in\n\texpression-with-actions node. No longer needed given fix to\n\tsem_prag and caused loss of some useful warnings.\n\t* sem.ads: Minor reformatting.\n\t* sem_prag.adb (Check_Disabled): Removed, to be replaced by not\n\tCheck_Enabled. These two routines were curiously incompatible\n\tcausing confusion.\n\t(Analyze_Pragma, case Check): Make sure we do\n\tnot expand the string argument if the check is disabled. Avoid\n\tuse of Check_Disabled, which resulted in missing analysis in\n\tsome cases.\n\t* sem_prag.ads (Check_Disabled): Removed, to be replaced by not\n\tCheck_Enabled. These two routines were curiously incompatible\n\tcausing confusion.\n\nFrom-SVN: r197761", "tree": {"sha": "13ce44a1b672ba5ff810f2c011f4937eeb05c977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13ce44a1b672ba5ff810f2c011f4937eeb05c977"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68bab0fd1da40436e20f6e4f4414b1b650bf7331", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68bab0fd1da40436e20f6e4f4414b1b650bf7331", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68bab0fd1da40436e20f6e4f4414b1b650bf7331", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68bab0fd1da40436e20f6e4f4414b1b650bf7331/comments", "author": null, "committer": null, "parents": [{"sha": "294f5d825fc452692fda912a5ede6945c91f8ecd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294f5d825fc452692fda912a5ede6945c91f8ecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/294f5d825fc452692fda912a5ede6945c91f8ecd"}], "stats": {"total": 167, "additions": 72, "deletions": 95}, "files": [{"sha": "009d28f2547d9e2380a5432ec0034f6ec2eb8705", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bab0fd1da40436e20f6e4f4414b1b650bf7331/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bab0fd1da40436e20f6e4f4414b1b650bf7331/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=68bab0fd1da40436e20f6e4f4414b1b650bf7331", "patch": "@@ -1,3 +1,20 @@\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenate): Remove wrapping in\n+\texpression-with-actions node. No longer needed given fix to\n+\tsem_prag and caused loss of some useful warnings.\n+\t* sem.ads: Minor reformatting.\n+\t* sem_prag.adb (Check_Disabled): Removed, to be replaced by not\n+\tCheck_Enabled. These two routines were curiously incompatible\n+\tcausing confusion.\n+\t(Analyze_Pragma, case Check): Make sure we do\n+\tnot expand the string argument if the check is disabled. Avoid\n+\tuse of Check_Disabled, which resulted in missing analysis in\n+\tsome cases.\n+\t* sem_prag.ads (Check_Disabled): Removed, to be replaced by not\n+\tCheck_Enabled. These two routines were curiously incompatible\n+\tcausing confusion.\n+\n 2013-04-11  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch4.adb (Process_Transient_Object): Use"}, {"sha": "1ee2ac9b4a5aa011b8e6a815d25997d2731e8230", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bab0fd1da40436e20f6e4f4414b1b650bf7331/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bab0fd1da40436e20f6e4f4414b1b650bf7331/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=68bab0fd1da40436e20f6e4f4414b1b650bf7331", "patch": "@@ -6796,27 +6796,7 @@ package body Exp_Ch4 is\n             Append (Right_Opnd (Cnode), Opnds);\n          end loop Inner;\n \n-         --  Wrap the node to concatenate into an expression actions node to\n-         --  keep it nicely packaged. This is useful in the case of an assert\n-         --  pragma with a concatenation where we want to be able to delete\n-         --  the concatenation and all its expansion stuff.\n-\n-         declare\n-            Cnod : constant Node_Id   := Relocate_Node (Cnode);\n-            Typ  : constant Entity_Id := Base_Type (Etype (Cnode));\n-\n-         begin\n-            --  Note: use Rewrite rather than Replace here, so that for example\n-            --  Why_Not_Static can find the original concatenation node OK!\n-\n-            Rewrite (Cnode,\n-              Make_Expression_With_Actions (Sloc (Cnode),\n-                Actions    => New_List (Make_Null_Statement (Sloc (Cnode))),\n-                Expression => Cnod));\n-\n-            Expand_Concatenate (Cnod, Opnds);\n-            Analyze_And_Resolve (Cnode, Typ);\n-         end;\n+         Expand_Concatenate (Cnode, Opnds);\n \n          exit Outer when Cnode = N;\n          Cnode := Parent (Cnode);\n@@ -11397,7 +11377,6 @@ package body Exp_Ch4 is\n \n       function Is_Checked_Storage_Pool (P : Entity_Id) return Boolean is\n          T : Entity_Id;\n-\n       begin\n          if No (P) then\n             return False;"}, {"sha": "41297f4262e65f1d2c8f8023472b487e31b76640", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bab0fd1da40436e20f6e4f4414b1b650bf7331/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bab0fd1da40436e20f6e4f4414b1b650bf7331/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=68bab0fd1da40436e20f6e4f4414b1b650bf7331", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -177,7 +177,7 @@\n --  repeatedly (for instance in the above aggregate \"new Thing (Function_Call)\"\n --  needs to be called 100 times.)\n \n---  The reason why this mechanism does not work is that, the expanded code for\n+--  The reason why this mechanism does not work is that the expanded code for\n --  the children is typically inserted above the parent and thus when the\n --  father gets expanded no re-evaluation takes place. For instance in the case\n --  of aggregates if \"new Thing (Function_Call)\" is expanded before of the"}, {"sha": "9a116c4bb32d8c602be360be02750209c822a4a9", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 51, "deletions": 63, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bab0fd1da40436e20f6e4f4414b1b650bf7331/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bab0fd1da40436e20f6e4f4414b1b650bf7331/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=68bab0fd1da40436e20f6e4f4414b1b650bf7331", "patch": "@@ -7833,6 +7833,7 @@ package body Sem_Prag is\n             Expr  : Node_Id;\n             Eloc  : Source_Ptr;\n             Cname : Name_Id;\n+            Str   : Node_Id;\n \n             Check_On : Boolean;\n             --  Set True if category of assertions referenced by Name enabled\n@@ -7846,21 +7847,15 @@ package body Sem_Prag is\n \n             if Arg_Count = 3 then\n                Check_Optional_Identifier (Arg3, Name_Message);\n-               Analyze_And_Resolve (Get_Pragma_Arg (Arg3), Standard_String);\n+               Str := Get_Pragma_Arg (Arg3);\n             end if;\n \n             Check_Arg_Is_Identifier (Arg1);\n-\n-            --  Completely ignore if disabled\n-\n-            if Check_Disabled (Chars (Get_Pragma_Arg (Arg1))) then\n-               Rewrite (N, Make_Null_Statement (Loc));\n-               Analyze (N);\n-               return;\n-            end if;\n-\n             Cname := Chars (Get_Pragma_Arg (Arg1));\n             Check_On := Check_Enabled (Cname);\n+            Expr := Get_Pragma_Arg (Arg2);\n+\n+            --  Deal with SCO generation\n \n             case Cname is\n                when Name_Predicate |\n@@ -7882,28 +7877,52 @@ package body Sem_Prag is\n                   end if;\n             end case;\n \n-            --  If expansion is active and the check is not enabled then we\n-            --  rewrite the Check as:\n+            --  Deal with analyzing the string argument.\n+\n+            if Arg_Count = 3 then\n+\n+               --  If checks are not on we don't want any expansion (since\n+               --  such expansion would not get properly deleted) but\n+               --  we do want to analyze (to get proper references).\n+               --  The Preanalyze_And_Resolve routine does just what we want\n+\n+               if not Check_On then\n+                  Preanalyze_And_Resolve (Str, Standard_String);\n+\n+                  --  Otherwise we need a proper analysis and expansion\n+\n+               else\n+                  Analyze_And_Resolve (Str, Standard_String);\n+               end if;\n+            end if;\n+\n+            --  Now you might think we could just do the same with the\n+            --  Boolean expression if checks are off (and expansion is on)\n+            --  and then rewrite the check as a null\n+            --  statement. This would work but we would lose the useful\n+            --  warnings about an assertion being bound to fail even if\n+            --  assertions are turned off.\n+\n+            --  So instead we wrap the boolean expression in an if statement\n+            --  that looks like:\n \n             --    if False and then condition then\n             --       null;\n             --    end if;\n \n-            --  The reason we do this rewriting during semantic analysis rather\n-            --  than as part of normal expansion is that we cannot analyze and\n-            --  expand the code for the boolean expression directly, or it may\n-            --  cause insertion of actions that would escape the attempt to\n-            --  suppress the check code.\n+            --  The reason we do this rewriting during semantic analysis\n+            --  rather than as part of normal expansion is that we cannot\n+            --  analyze and expand the code for the boolean expression\n+            --  directly, or it may cause insertion of actions that would\n+            --  escape the attempt to suppress the check code.\n \n             --  Note that the Sloc for the if statement corresponds to the\n-            --  argument condition, not the pragma itself. The reason for this\n-            --  is that we may generate a warning if the condition is False at\n-            --  compile time, and we do not want to delete this warning when we\n-            --  delete the if statement.\n+            --  argument condition, not the pragma itself. The reason for\n+            --  this is that we may generate a warning if the condition is\n+            --  False at compile time, and we do not want to delete this\n+            --  warning when we delete the if statement.\n \n-            Expr := Get_Pragma_Arg (Arg2);\n-\n-            if Expander_Active and then not Check_On then\n+            if Expander_Active and not Check_On then\n                Eloc := Sloc (Expr);\n \n                Rewrite (N,\n@@ -7915,9 +7934,12 @@ package body Sem_Prag is\n                    Then_Statements => New_List (\n                      Make_Null_Statement (Eloc))));\n \n+               In_Assertion_Expr := In_Assertion_Expr + 1;\n                Analyze (N);\n+               In_Assertion_Expr := In_Assertion_Expr - 1;\n \n-            --  Check is active\n+            --  Check is active or expansion not active. In these cases we can\n+            --  just go ahead and analyze the boolean with no worries.\n \n             else\n                In_Assertion_Expr := In_Assertion_Expr + 1;\n@@ -8314,7 +8336,7 @@ package body Sem_Prag is\n \n             --  Completely ignore if disabled\n \n-            if Check_Disabled (Pname) then\n+            if not Check_Enabled (Pname) then\n                Rewrite (N, Make_Null_Statement (Loc));\n                Analyze (N);\n                return;\n@@ -12401,7 +12423,7 @@ package body Sem_Prag is\n \n             --  Completely ignore if disabled\n \n-            if Check_Disabled (Pname) then\n+            if not Check_Enabled (Pname) then\n                Rewrite (N, Make_Null_Statement (Loc));\n                Analyze (N);\n                return;\n@@ -12474,7 +12496,7 @@ package body Sem_Prag is\n \n             --  Completely ignore if disabled\n \n-            if Check_Disabled (Pname) then\n+            if not Check_Enabled (Pname) then\n                Rewrite (N, Make_Null_Statement (Loc));\n                Analyze (N);\n                return;\n@@ -16390,40 +16412,6 @@ package body Sem_Prag is\n       when Pragma_Exit => null;\n    end Analyze_Pragma;\n \n-   --------------------\n-   -- Check_Disabled --\n-   --------------------\n-\n-   function Check_Disabled (Nam : Name_Id) return Boolean is\n-      PP : Node_Id;\n-\n-   begin\n-      --  Loop through entries in check policy list\n-\n-      PP := Opt.Check_Policy_List;\n-      loop\n-         --  If there are no specific entries that matched, then nothing is\n-         --  disabled, so return False.\n-\n-         if No (PP) then\n-            return False;\n-\n-         --  Here we have an entry see if it matches\n-\n-         else\n-            declare\n-               PPA : constant List_Id := Pragma_Argument_Associations (PP);\n-            begin\n-               if Nam = Chars (Get_Pragma_Arg (First (PPA))) then\n-                  return Chars (Get_Pragma_Arg (Last (PPA))) = Name_Disable;\n-               else\n-                  PP := Next_Pragma (PP);\n-               end if;\n-            end;\n-         end if;\n-      end loop;\n-   end Check_Disabled;\n-\n    -------------------\n    -- Check_Enabled --\n    -------------------\n@@ -16455,7 +16443,7 @@ package body Sem_Prag is\n                   case (Chars (Get_Pragma_Arg (Last (PPA)))) is\n                      when Name_On | Name_Check =>\n                         return True;\n-                     when Name_Off | Name_Ignore =>\n+                     when Name_Off | Name_Disable | Name_Ignore =>\n                         return False;\n                      when others =>\n                         raise Program_Error;"}, {"sha": "8c71fb82039295371f78d5080390f1ef4526b889", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bab0fd1da40436e20f6e4f4414b1b650bf7331/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bab0fd1da40436e20f6e4f4414b1b650bf7331/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=68bab0fd1da40436e20f6e4f4414b1b650bf7331", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,13 +54,6 @@ package Sem_Prag is\n    --  of the expressions in the pragma as \"spec expressions\" (see section\n    --  in Sem \"Handling of Default and Per-Object Expressions...\").\n \n-   function Check_Disabled (Nam : Name_Id) return Boolean;\n-   --  This function is used in connection with pragmas Assertion, Check,\n-   --  Precondition, and Postcondition, to determine if Check pragmas (or\n-   --  corresponding Assert, Precondition, or Postcondition pragmas) are\n-   --  currently disabled (as set by a Check_Policy or Assertion_Policy pragma\n-   --  with the Disable argument).\n-\n    function Check_Enabled (Nam : Name_Id) return Boolean;\n    --  This function is used in connection with pragmas Assertion, Check,\n    --  Precondition, and Postcondition, to determine if Check pragmas (or"}]}