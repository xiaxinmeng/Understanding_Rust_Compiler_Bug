{"sha": "e1f56f62a0395318f20e55e206a838785dc42229", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmNTZmNjJhMDM5NTMxOGYyMGU1NWUyMDZhODM4Nzg1ZGM0MjIyOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-16T12:55:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-16T12:55:26Z"}, "message": "(fold): If moved conversion into COND_EXPR, leave it there if it is an integral conversion to word or narrower.\n\n(fold): If moved conversion into COND_EXPR, leave it there if it is an\nintegral conversion to word or narrower.\n(fold, case NOP_EXPR): Ignore conversion to same type as operand.\n(fold, case COND_EXPR): Make third operand the simplest.\n\nFrom-SVN: r8467", "tree": {"sha": "fb83956bc96a10095d4f15f146f39360e32c7f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb83956bc96a10095d4f15f146f39360e32c7f68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1f56f62a0395318f20e55e206a838785dc42229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f56f62a0395318f20e55e206a838785dc42229", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f56f62a0395318f20e55e206a838785dc42229", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f56f62a0395318f20e55e206a838785dc42229/comments", "author": null, "committer": null, "parents": [{"sha": "5a32d03841c8db674ef3f6fb7e223b37c4122e46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a32d03841c8db674ef3f6fb7e223b37c4122e46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a32d03841c8db674ef3f6fb7e223b37c4122e46"}], "stats": {"total": 41, "additions": 36, "deletions": 5}, "files": [{"sha": "54ac7337b35a59f8d80d9afbb5d3c639b5610815", "filename": "gcc/fold-const.c", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f56f62a0395318f20e55e206a838785dc42229/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f56f62a0395318f20e55e206a838785dc42229/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e1f56f62a0395318f20e55e206a838785dc42229", "patch": "@@ -3170,17 +3170,24 @@ fold (expr)\n \t\t\t   fold (build1 (code, type, TREE_OPERAND (arg0, 2)))));\n \n \t  /* If this was a conversion, and all we did was to move into\n-\t     inside the COND_EXPR, bring it back out.  Then return so we\n-\t     don't get into an infinite recursion loop taking the conversion\n-\t     out and then back in.  */\n+\t     inside the COND_EXPR, bring it back out.  But leave it if\n+\t     it is a conversion from integer to integer and the\n+\t     result precision is no wider than a word since such a\n+\t     conversion is cheap and may be optimized away by combine,\n+\t     while it couldn't if it were outside the COND_EXPR.  Then return\n+\t     so we don't get into an infinite recursion loop taking the\n+\t     conversion out and then back in.  */\n \n \t  if ((code == NOP_EXPR || code == CONVERT_EXPR\n \t       || code == NON_LVALUE_EXPR)\n \t      && TREE_CODE (t) == COND_EXPR\n \t      && TREE_CODE (TREE_OPERAND (t, 1)) == code\n \t      && TREE_CODE (TREE_OPERAND (t, 2)) == code\n \t      && (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0))\n-\t\t  == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 2), 0))))\n+\t\t  == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 2), 0)))\n+\t      && ! (INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t\t    && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0)))\n+\t\t    && TYPE_PRECISION (TREE_TYPE (t)) <= BITS_PER_WORD))\n \t    t = build1 (code, type,\n \t\t\tbuild (COND_EXPR,\n \t\t\t       TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0)),\n@@ -3327,6 +3334,9 @@ fold (expr)\n     case FIX_TRUNC_EXPR:\n       /* Other kinds of FIX are not handled properly by fold_convert.  */\n \n+      if (TREE_TYPE (TREE_OPERAND (t, 0)) == TREE_TYPE (t))\n+\treturn TREE_OPERAND (t, 0);\n+\n       /* In addition to the cases of two conversions in a row \n \t handled below, if we are converting something to its own\n \t type via an object of identical or wider precision, neither\n@@ -4822,6 +4832,28 @@ fold (expr)\n \t      }\n \t}\n \n+      /* If the second operand is simpler than the third, swap them\n+\t since that produces better jump optimization results.  */\n+      if ((TREE_CONSTANT (arg1) || TREE_CODE_CLASS (TREE_CODE (arg1)) == 'd'\n+\t   || TREE_CODE (arg1) == SAVE_EXPR)\n+\t  && ! (TREE_CONSTANT (TREE_OPERAND (t, 2))\n+\t\t|| TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, 2))) == 'd'\n+\t\t|| TREE_CODE (TREE_OPERAND (t, 2)) == SAVE_EXPR))\n+\t{\n+\t  /* See if this can be inverted.  If it can't, possibly because\n+\t     it was a floating-point inequality comparison, don't do\n+\t     anything.  */\n+\t  tem = invert_truthvalue (arg0);\n+\n+\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n+\t    {\n+\t      arg0 = TREE_OPERAND (t, 0) = tem;\n+\t      TREE_OPERAND (t, 1) = TREE_OPERAND (t, 2);\n+\t      TREE_OPERAND (t, 2) = arg1;\n+\t      arg1 = TREE_OPERAND (t, 1);\n+\t    }\n+\t}\n+\n       /* Convert A ? 1 : 0 to simply A.  */\n       if (integer_onep (TREE_OPERAND (t, 1))\n \t  && integer_zerop (TREE_OPERAND (t, 2))\n@@ -4832,7 +4864,6 @@ fold (expr)\n \t  && type == TREE_TYPE (arg0))\n \treturn pedantic_non_lvalue (arg0);\n \n-\n       /* Look for expressions of the form A & 2 ? 2 : 0.  The result of this\n \t operation is simply A & 2.  */\n "}]}