{"sha": "8a1d8dd9c8d5343b61154d5f0ee45e7e31342931", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGExZDhkZDljOGQ1MzQzYjYxMTU0ZDVmMGVlNDVlN2UzMTM0MjkzMQ==", "commit": {"author": {"name": "Matt Austern", "email": "austern@apple.com", "date": "2003-12-18T18:35:38Z"}, "committer": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2003-12-18T18:35:38Z"}, "message": "demangle.h: Fix allocator type correctness, i.e.\n\n\t* include/bits/demangle.h: Fix allocator type correctness,\n\ti.e. make sure that when we instantiate a container with a value\n\ttype and an allocator, the allocator's value type matches the\n\tcontainer's.\n\t* include/bits/stl_deque.h (_Deque_alloc_base): Eliminate.\n\t(_Deque_base): inherit directly from the deque's allocator.  Use\n\trebinding instead of _Alloc_traits.  Pick up data members from\n\t_Deque_alloc_base.\n\t* include/bits/stl_list.h (_List_alloc_base): Eliminate.\n\t(_List_base): Inherit directly from the list's allocator.  Use\n\trebinding instead of _Alloc_traits.  Pick up data members from\n\t_List_alloc_base.\n\t* include/bits/stl_vector.h (_Vector_alloc_base): Eliminate\n\t(_Vector_base): Inherit directly from the vector's allocator.  Use\n\trebinding instead of _Alloc_traits.  Pick up data members from\n\t_Vector_alloc_base.\n\t* include/ext/hashtable.h: Fix allocator type correctness (the\n\tvector of buckets must be passed an allocator for objects of\n\ttype _Node*).  Use rebinding instead of _Alloc_traits.\n\nFrom-SVN: r74787", "tree": {"sha": "d71e92d2f714303433e3e6f0e501859221810a08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d71e92d2f714303433e3e6f0e501859221810a08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/comments", "author": null, "committer": null, "parents": [{"sha": "38700ceee72fb7b538a291c7e69e0d86f08f8fba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38700ceee72fb7b538a291c7e69e0d86f08f8fba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38700ceee72fb7b538a291c7e69e0d86f08f8fba"}], "stats": {"total": 423, "additions": 136, "deletions": 287}, "files": [{"sha": "3d9f85e979d67b106ad107a28e5cc6080d99fe0e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8a1d8dd9c8d5343b61154d5f0ee45e7e31342931", "patch": "@@ -1,3 +1,25 @@\n+2003-12-18  Matt Austern  <austern@apple.com>\n+\n+\t* include/bits/demangle.h: Fix allocator type correctness,\n+\ti.e. make sure that when we instantiate a container with a value\n+\ttype and an allocator, the allocator's value type matches the\n+\tcontainer's.\n+\t* include/bits/stl_deque.h (_Deque_alloc_base): Eliminate.\n+\t(_Deque_base): inherit directly from the deque's allocator.  Use\n+\trebinding instead of _Alloc_traits.  Pick up data members from \n+\t_Deque_alloc_base.\n+\t* include/bits/stl_list.h (_List_alloc_base): Eliminate.\n+\t(_List_base): Inherit directly from the list's allocator.  Use\n+\trebinding instead of _Alloc_traits.  Pick up data members from \n+\t_List_alloc_base.\n+\t* include/bits/stl_vector.h (_Vector_alloc_base): Eliminate\n+\t(_Vector_base): Inherit directly from the vector's allocator.  Use\n+\trebinding instead of _Alloc_traits.  Pick up data members from \n+\t_Vector_alloc_base.\n+\t* include/ext/hashtable.h: Fix allocator type correctness (the\n+\tvector of buckets must be passed an allocator for objects of\n+\ttype _Node*).  Use rebinding instead of _Alloc_traits.\n+\t\n 2003-12-17  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/locale_facets.tcc (time_get::_M_extract_via_format):"}, {"sha": "82e2d06cd90467166a5c074e2bc5cbb021ef38f3", "filename": "libstdc++-v3/include/bits/demangle.h", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h?ref=8a1d8dd9c8d5343b61154d5f0ee45e7e31342931", "patch": "@@ -113,7 +113,9 @@ namespace __gnu_cxx\n     template<typename Allocator>\n       class qualifier\n       {\n-\ttypedef std::basic_string<char, std::char_traits<char>, Allocator>\n+\ttypedef typename Allocator::template rebind<char>::other\n+\t        char_Allocator;\n+\ttypedef std::basic_string<char, std::char_traits<char>, char_Allocator>\n \t    string_type;\n \n       private:\n@@ -206,17 +208,22 @@ namespace __gnu_cxx\n     template<typename Allocator>\n       class qualifier_list\n       {\n-\ttypedef std::basic_string<char, std::char_traits<char>, Allocator>\n+\ttypedef typename Allocator::template rebind<char>::other\n+  \t  char_Allocator;\n+\ttypedef std::basic_string<char, std::char_traits<char>, char_Allocator>\n \t  string_type;\n \n       private:\n \tmutable bool M_printing_suppressed;\n-\tstd::vector<qualifier<Allocator>, Allocator> M_qualifier_starts;\n+\ttypedef qualifier<Allocator> qual;\n+        typedef typename Allocator::template rebind<qual>::other qual_Allocator;\n+\ttypedef std::vector<qual, qual_Allocator> qual_vector;\n+\tqual_vector M_qualifier_starts;\n \tsession<Allocator>& M_demangler;\n \n \tvoid decode_KVrA(string_type& prefix, string_type& postfix, int cvq,\n-          typename std::vector<qualifier<Allocator>, Allocator>::\n-\t      const_reverse_iterator const& iter_array) const;\n+\t\t\t typename qual_vector::\n+\t\t\t   const_reverse_iterator const& iter_array) const;\n \n       public:\n \tqualifier_list(session<Allocator>& demangler_obj)\n@@ -270,7 +277,7 @@ namespace __gnu_cxx\n #if _GLIBCXX_DEMANGLER_CWDEBUG\n \tfriend std::ostream& operator<<(std::ostream& os, qualifier_list const& list)\n \t{\n-\t  typename std::vector<qualifier<Allocator>, Allocator>::const_iterator\n+\t  typename qual_vector::const_iterator\n \t      iter = list.M_qualifier_starts.begin();\n \t  if (iter != list.M_qualifier_starts.end())\n \t  {\n@@ -344,7 +351,9 @@ namespace __gnu_cxx\n       class session\n       {\n \tfriend class qualifier_list<Allocator>;\n-\ttypedef std::basic_string<char, std::char_traits<char>, Allocator>\n+\ttypedef typename Allocator::template rebind<char>::other\n+    \t    char_Allocator;\n+\ttypedef std::basic_string<char, std::char_traits<char>, char_Allocator>\n \t    string_type;\n \n       private:\n@@ -361,9 +370,13 @@ namespace __gnu_cxx\n \tbool M_name_is_conversion_operator;\n \tbool M_template_args_need_space;\n \tstring_type M_function_name;\n-\tstd::vector<int, Allocator> M_template_arg_pos;\n+        typedef typename Allocator::template rebind<int>::other\n+                int_Allocator;\n+        typedef typename Allocator::template rebind<substitution_st>::other\n+                subst_Allocator;\n+\tstd::vector<int, int_Allocator> M_template_arg_pos;\n \tint M_template_arg_pos_offset;\n-\tstd::vector<substitution_st, Allocator> M_substitutions_pos;\n+\tstd::vector<substitution_st, subst_Allocator> M_substitutions_pos;\n \timplementation_details const& M_implementation_details;\n #if _GLIBCXX_DEMANGLER_CWDEBUG\n \tbool M_inside_add_substitution;\n@@ -1690,8 +1703,7 @@ namespace __gnu_cxx\n       void\n       qualifier_list<Allocator>::decode_KVrA(\n           string_type& prefix, string_type& postfix, int cvq,\n-          typename std::vector<qualifier<Allocator>, Allocator>::\n-\t      const_reverse_iterator const& iter_array) const\n+          typename qual_vector::const_reverse_iterator const& iter_array) const\n \t{\n \t  _GLIBCXX_DEMANGLER_DOUT_ENTERING3(\"decode_KVrA\");\n \t  if ((cvq & cvq_K))\n@@ -1703,7 +1715,7 @@ namespace __gnu_cxx\n \t  if ((cvq & cvq_A))\n \t  {\n \t    int n = cvq >> 5;\n-\t    for (typename std::vector<qualifier<Allocator>, Allocator>::\n+\t    for (typename qual_vector::\n \t        const_reverse_iterator iter = iter_array;\n \t\titer != M_qualifier_starts.rend(); ++iter)\n \t    {\n@@ -1744,9 +1756,8 @@ namespace __gnu_cxx\n       {\n \t_GLIBCXX_DEMANGLER_DOUT_ENTERING3(\"decode_qualifiers\");\n \tint cvq = 0;\n-\ttypename std::vector<qualifier<Allocator>, Allocator>::\n-\t    const_reverse_iterator iter_array;\n-\tfor(typename std::vector<qualifier<Allocator>, Allocator>::\n+\ttypename qual_vector::const_reverse_iterator iter_array;\n+\tfor(typename qual_vector::\n \t    const_reverse_iterator iter = M_qualifier_starts.rbegin();\n \t    iter != M_qualifier_starts.rend(); ++iter)\n \t{\n@@ -2676,8 +2687,8 @@ namespace __gnu_cxx\n   template<typename Allocator>\n     struct demangle\n     {\n-      typedef Allocator allocator_type;\n-      typedef std::basic_string<char, std::char_traits<char>, Allocator> \n+      typedef typename Allocator::template rebind<char>::other char_Allocator;\n+      typedef std::basic_string<char, std::char_traits<char>, char_Allocator> \n \t  string_type;\n       static string_type symbol(char const* in,\n                                 demangler::implementation_details const& id);\n@@ -2690,7 +2701,7 @@ namespace __gnu_cxx\n   // Demangle `input' which should be a mangled function name as for\n   // instance returned by nm(1).\n   template<typename Allocator>\n-    std::basic_string<char, std::char_traits<char>, Allocator>\n+    typename demangle<Allocator>::string_type\n     demangle<Allocator>::symbol(char const* input,\n                                 demangler::implementation_details const& id)\n     {\n@@ -2741,7 +2752,7 @@ namespace __gnu_cxx\n   // Demangle `input' which must be a zero terminated mangled type\n   // name as for instance returned by std::type_info::name().\n   template<typename Allocator>\n-    std::basic_string<char, std::char_traits<char>, Allocator> \n+    typename demangle<Allocator>::string_type\n     demangle<Allocator>::type(char const* input,\n                               demangler::implementation_details const& id)\n     {"}, {"sha": "64a24b1c027262530de24a09e3264abf97d7c1a8", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 35, "deletions": 106, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=8a1d8dd9c8d5343b61154d5f0ee45e7e31342931", "patch": "@@ -332,139 +332,70 @@ namespace __gnu_norm\n     return __x + __n;\n   }\n   \n-  \n-  /// @if maint Primary default version.  @endif\n   /**\n    *  @if maint\n-   *  Deque base class.  It has two purposes.  First, its constructor\n-   *  and destructor allocate (but don't initialize) storage.  This makes\n-   *  %exception safety easier.  Second, the base class encapsulates all of\n-   *  the differences between SGI-style allocators and standard-conforming\n-   *  allocators.  (See allocator.h for more on this topic.)  There are two\n-   *  versions:  this ordinary one, and the space-saving specialization for\n-   *  instanceless allocators.\n+   *  Deque base class.  This class provides the unified face for %deque's\n+   *  allocation.  This class's constructor and destructor allocate and\n+   *  deallocate (but do not initialize) storage.  This makes %exception\n+   *  safety easier.\n+   *\n+   *  Nothing in this class ever constructs or destroys an actual Tp element.\n+   *  (Deque handles that itself.)  Only/All memory management is performed\n+   *  here.\n    *  @endif\n   */\n-  template<typename _Tp, typename _Alloc, bool __is_static>\n-    class _Deque_alloc_base\n-  {\n-  public:\n-    typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;\n-    allocator_type get_allocator() const { return _M_node_allocator; }\n-  \n-    _Deque_alloc_base(const allocator_type& __a)\n-      : _M_node_allocator(__a), _M_map_allocator(__a),\n-        _M_map(0), _M_map_size(0)\n-    {}\n-    \n-  protected:\n-    typedef typename _Alloc_traits<_Tp*, _Alloc>::allocator_type\n-            _Map_allocator_type;\n-  \n-    _Tp*\n-    _M_allocate_node()\n-    {\n-      return _M_node_allocator.allocate(__deque_buf_size(sizeof(_Tp)));\n-    }\n-  \n-    void\n-    _M_deallocate_node(_Tp* __p)\n-    {\n-      _M_node_allocator.deallocate(__p, __deque_buf_size(sizeof(_Tp)));\n-    }\n-  \n-    _Tp**\n-    _M_allocate_map(size_t __n) \n-      { return _M_map_allocator.allocate(__n); }\n-  \n-    void\n-    _M_deallocate_map(_Tp** __p, size_t __n) \n-      { _M_map_allocator.deallocate(__p, __n); }\n-  \n-    allocator_type       _M_node_allocator;\n-    _Map_allocator_type  _M_map_allocator;\n-    _Tp**                _M_map;\n-    size_t               _M_map_size;\n-  };\n-  \n-  /// @if maint Specialization for instanceless allocators.  @endif\n   template<typename _Tp, typename _Alloc>\n-    class _Deque_alloc_base<_Tp, _Alloc, true>\n+    class _Deque_base\n+    : public _Alloc\n   {\n   public:\n-    typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;\n-    allocator_type get_allocator() const { return allocator_type(); }\n+    typedef _Alloc                                     allocator_type;\n+    allocator_type get_allocator() const\n+      { return *static_cast<const _Alloc*>(this); }\n+\n+    typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+    typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n   \n-    _Deque_alloc_base(const allocator_type&)\n-      : _M_map(0), _M_map_size(0)\n-    {}\n-    \n+    _Deque_base(const allocator_type& __a, size_t __num_elements)\n+      : _Alloc(__a), _M_start(), _M_finish()\n+      { _M_initialize_map(__num_elements); }\n+    _Deque_base(const allocator_type& __a) \n+      : _Alloc(__a), _M_start(), _M_finish() {}\n+    ~_Deque_base();    \n+\n   protected:\n-    typedef typename _Alloc_traits<_Tp,_Alloc>::_Alloc_type  _Node_alloc_type;\n-    typedef typename _Alloc_traits<_Tp*,_Alloc>::_Alloc_type _Map_alloc_type;\n-  \n+    typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;\n+    _Map_alloc_type _M_get_map_allocator() const\n+      { return _Map_alloc_type(this->get_allocator()); }\n+\n     _Tp*\n     _M_allocate_node()\n     {\n-      return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));\n+      return _Alloc::allocate(__deque_buf_size(sizeof(_Tp)));\n     }\n   \n     void\n     _M_deallocate_node(_Tp* __p)\n     {\n-      _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));\n+      _Alloc::deallocate(__p, __deque_buf_size(sizeof(_Tp)));\n     }\n   \n     _Tp**\n     _M_allocate_map(size_t __n) \n-      { return _Map_alloc_type::allocate(__n); }\n+      { return _M_get_map_allocator().allocate(__n); }\n   \n     void\n     _M_deallocate_map(_Tp** __p, size_t __n) \n-      { _Map_alloc_type::deallocate(__p, __n); }\n-  \n-    _Tp**   _M_map;\n-    size_t  _M_map_size;\n-  };\n-  \n-  \n-  /**\n-   *  @if maint\n-   *  Deque base class.  Using _Alloc_traits in the instantiation of the parent\n-   *  class provides the compile-time dispatching mentioned in the parent's\n-   *  docs.  This class provides the unified face for %deque's allocation.\n-   *\n-   *  Nothing in this class ever constructs or destroys an actual Tp element.\n-   *  (Deque handles that itself.)  Only/All memory management is performed\n-   *  here.\n-   *  @endif\n-  */\n-  template<typename _Tp, typename _Alloc>\n-    class _Deque_base\n-    : public _Deque_alloc_base<_Tp,_Alloc,\n-                                _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-  {\n-  public:\n-    typedef _Deque_alloc_base<_Tp,_Alloc,\n-                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-            _Base;\n-    typedef typename _Base::allocator_type             allocator_type;\n-    typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-    typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-  \n-    _Deque_base(const allocator_type& __a, size_t __num_elements)\n-      : _Base(__a), _M_start(), _M_finish()\n-      { _M_initialize_map(__num_elements); }\n-    _Deque_base(const allocator_type& __a) \n-      : _Base(__a), _M_start(), _M_finish() {}\n-    ~_Deque_base();    \n-  \n+      { _M_get_map_allocator().deallocate(__p, __n); }\n+\n   protected:\n     void _M_initialize_map(size_t);\n     void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);\n     void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);\n     enum { _S_initial_map_size = 8 };\n   \n+    _Tp** _M_map;\n+    size_t _M_map_size;\n     iterator _M_start;\n     iterator _M_finish;\n   };\n@@ -670,9 +601,7 @@ namespace __gnu_norm\n     using _Base::_M_deallocate_map;\n   \n     /** @if maint\n-     *  A total of four data members accumulated down the heirarchy.  If the\n-     *  _Alloc type requires separate instances, then two of them will also be\n-     *  included in each deque.\n+     *  A total of four data members accumulated down the heirarchy.\n      *  @endif\n     */\n     using _Base::_M_map;"}, {"sha": "8fd2f71026e0ab1d128a4fe9fcc490f789cec3b5", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 20, "deletions": 80, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=8a1d8dd9c8d5343b61154d5f0ee45e7e31342931", "patch": "@@ -202,36 +202,16 @@ namespace __gnu_norm\n     }\n   };\n   \n-  \n-  /// @if maint Primary default version.  @endif\n   /**\n    *  @if maint\n-   *  See bits/stl_deque.h's _Deque_alloc_base for an explanation.\n+   *  See bits/stl_deque.h's _Deque_base for an explanation.\n    *  @endif\n   */\n-  template<typename _Tp, typename _Allocator, bool _IsStatic>\n-    class _List_alloc_base\n+  template <typename _Tp, typename _Alloc>\n+    class _List_base\n+    : public _Alloc::template rebind<_List_node<_Tp> >::other\n   {\n-  public:\n-    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-            allocator_type;\n-  \n-    allocator_type\n-    get_allocator() const { return _M_node_allocator; }\n-  \n-    _List_alloc_base(const allocator_type& __a)\n-    : _M_node_allocator(__a)\n-    { }\n-  \n   protected:\n-    _List_node<_Tp>*\n-    _M_get_node()\n-    { return _M_node_allocator.allocate(1); }\n-  \n-    void\n-    _M_put_node(_List_node<_Tp>* __p)\n-    { _M_node_allocator.deallocate(__p, 1); }\n-  \n     // NOTA BENE\n     // The stored instance is not actually of \"allocator_type\"'s type.\n     // Instead we rebind the type to Allocator<List_node<Tp>>, which\n@@ -240,69 +220,29 @@ namespace __gnu_norm\n     // larger), and specializations on Tp may go unused because\n     // List_node<Tp> is being bound instead.\n     //\n-    // We put this to the test in get_allocator above; if the two\n-    // types are actually different, there had better be a conversion\n-    // between them.\n-    //\n-    // None of the predefined allocators shipped with the library (as\n-    // of 3.1) use this instantiation anyhow; they're all\n-    // instanceless.\n-    typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type\n-             _M_node_allocator;\n-  \n-    _List_node_base _M_node;\n-  };\n-  \n-  /// @if maint Specialization for instanceless allocators.  @endif\n-  template<typename _Tp, typename _Allocator>\n-    class _List_alloc_base<_Tp, _Allocator, true>\n-  {\n-  public:\n-    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-            allocator_type;\n-  \n-    allocator_type\n-    get_allocator() const { return allocator_type(); }\n-  \n-    _List_alloc_base(const allocator_type&)\n-    { }\n-  \n-  protected:\n-    // See comment in primary template class about why this is safe for the\n-    // standard predefined classes.\n-    typedef typename _Alloc_traits<_List_node<_Tp>, _Allocator>::_Alloc_type\n-            _Alloc_type;\n-  \n+    // We put this to the test in the constructors and in get_allocator,\n+    // where we use conversions between allocator_type and \n+    // _Node_Alloc_type. The conversion is required by table 32 in [20.1.5].\n+    typedef typename _Alloc::template rebind<_List_node<_Tp> >::other\n+      _Node_Alloc_type;\n+\n     _List_node<_Tp>*\n     _M_get_node()\n-    { return _Alloc_type::allocate(1); }\n-  \n+    { return _Node_Alloc_type::allocate(1); }\n+\n     void\n     _M_put_node(_List_node<_Tp>* __p)\n-    { _Alloc_type::deallocate(__p, 1); }\n-  \n+    { _Node_Alloc_type::deallocate(__p, 1); }\n+\n     _List_node_base _M_node;\n-  };\n-  \n-  \n-  /**\n-   *  @if maint\n-   *  See bits/stl_deque.h's _Deque_base for an explanation.\n-   *  @endif\n-  */\n-  template <typename _Tp, typename _Alloc>\n-    class _List_base\n-    : public _List_alloc_base<_Tp, _Alloc,\n-                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-  {\n   public:\n-    typedef _List_alloc_base<_Tp, _Alloc,\n-                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-            _Base;\n-    typedef typename _Base::allocator_type allocator_type;\n-  \n+    typedef _Alloc allocator_type;\n+    allocator_type get_allocator() const\n+\n+    { return allocator_type(*static_cast<const _Node_Alloc_type*>(this)); }\n+\n     _List_base(const allocator_type& __a)\n-    : _Base(__a)\n+    : _Node_Alloc_type(__a)\n     {\n       this->_M_node._M_next = &this->_M_node;\n       this->_M_node._M_prev = &this->_M_node;"}, {"sha": "de9c1a341b9aa3de0bf0514b33afa655f8e369ee", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 21, "deletions": 76, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=8a1d8dd9c8d5343b61154d5f0ee45e7e31342931", "patch": "@@ -67,91 +67,26 @@\n \n namespace __gnu_norm\n {\n-  /// @if maint Primary default version.  @endif\n-  /**\n-   *  @if maint\n-   *  See bits/stl_deque.h's _Deque_alloc_base for an explanation.\n-   *  @endif\n-  */\n-  template<typename _Tp, typename _Allocator, bool _IsStatic>\n-    class _Vector_alloc_base\n-    {\n-    public:\n-      typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-      allocator_type;\n-\n-      allocator_type\n-      get_allocator() const { return _M_data_allocator; }\n-  \n-      _Vector_alloc_base(const allocator_type& __a)\n-      : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n-      { }\n-  \n-    protected:\n-      allocator_type _M_data_allocator;\n-      _Tp*           _M_start;\n-      _Tp*           _M_finish;\n-      _Tp*           _M_end_of_storage;\n-  \n-      _Tp*\n-      _M_allocate(size_t __n) { return _M_data_allocator.allocate(__n); }\n-  \n-      void\n-      _M_deallocate(_Tp* __p, size_t __n)\n-      { if (__p) _M_data_allocator.deallocate(__p, __n); }\n-    };\n-  \n-  /// @if maint Specialization for instanceless allocators.  @endif\n-  template<typename _Tp, typename _Allocator>\n-    class _Vector_alloc_base<_Tp, _Allocator, true>\n-    {\n-    public:\n-      typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-             allocator_type;\n-  \n-      allocator_type\n-      get_allocator() const { return allocator_type(); }\n-      \n-      _Vector_alloc_base(const allocator_type&)\n-      : _M_start(0), _M_finish(0), _M_end_of_storage(0)\n-      { }\n-  \n-    protected:\n-      _Tp* _M_start;\n-      _Tp* _M_finish;\n-      _Tp* _M_end_of_storage;\n-  \n-      typedef typename _Alloc_traits<_Tp, _Allocator>::_Alloc_type _Alloc_type;\n-      \n-      _Tp*\n-      _M_allocate(size_t __n) { return _Alloc_type::allocate(__n); }\n-  \n-      void\n-      _M_deallocate(_Tp* __p, size_t __n) { _Alloc_type::deallocate(__p, __n);}\n-    };\n-  \n-  \n   /**\n    *  @if maint\n    *  See bits/stl_deque.h's _Deque_base for an explanation.\n    *  @endif\n   */\n   template<typename _Tp, typename _Alloc>\n     struct _Vector_base\n-    : public _Vector_alloc_base<_Tp, _Alloc,\n-                                _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+    : public _Alloc\n     {\n     public:\n-      typedef _Vector_alloc_base<_Tp, _Alloc,\n-\t\t\t\t _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-         _Base;\n-      typedef typename _Base::allocator_type allocator_type;\n+      typedef _Alloc allocator_type;\n+\n+      allocator_type\n+      get_allocator() const { return *static_cast<const _Alloc*>(this); }\n \n       _Vector_base(const allocator_type& __a)\n-      : _Base(__a) { }\n+      : _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0) { }\n       \n       _Vector_base(size_t __n, const allocator_type& __a)\n-      : _Base(__a)\n+      : _Alloc(__a)\n       {\n \tthis->_M_start = this->_M_allocate(__n);\n \tthis->_M_finish = this->_M_start;\n@@ -161,6 +96,18 @@ namespace __gnu_norm\n       ~_Vector_base() \n       { _M_deallocate(this->_M_start,\n \t\t      this->_M_end_of_storage - this->_M_start); }\n+\n+    public:\n+      _Tp*           _M_start;\n+      _Tp*           _M_finish;\n+      _Tp*           _M_end_of_storage;\n+  \n+      _Tp*\n+      _M_allocate(size_t __n) { return _Alloc::allocate(__n); }\n+  \n+      void\n+      _M_deallocate(_Tp* __p, size_t __n)\n+      { if (__p) _Alloc::deallocate(__p, __n); }\n     };\n   \n   \n@@ -209,8 +156,7 @@ namespace __gnu_norm\n     protected:\n       /** @if maint\n        *  These two functions and three data members are all from the\n-       *  top-most base class, which varies depending on the type of\n-       *  %allocator.  They should be pretty self-explanatory, as\n+       *  base class.  They should be pretty self-explanatory, as\n        *  %vector uses a simple contiguous allocation scheme.  @endif\n        */\n       using _Base::_M_allocate;\n@@ -347,8 +293,7 @@ namespace __gnu_norm\n \t}\n   \n       /// Get a copy of the memory allocation object.\n-      allocator_type\n-      get_allocator() const { return _Base::get_allocator(); }\n+      using _Base::get_allocator;\n       \n       // iterators\n       /**"}, {"sha": "54540c40aeef390678a35969b5e96467d026fe99", "filename": "libstdc++-v3/include/ext/hashtable.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a1d8dd9c8d5343b61154d5f0ee45e7e31342931/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h?ref=8a1d8dd9c8d5343b61154d5f0ee45e7e31342931", "patch": "@@ -77,7 +77,6 @@ using std::size_t;\n using std::ptrdiff_t;\n using std::forward_iterator_tag;\n using std::input_iterator_tag;\n-using std::_Alloc_traits;\n using std::_Construct;\n using std::_Destroy;\n using std::distance;\n@@ -242,18 +241,22 @@ class hashtable {\n   typedef _Hashtable_node<_Val> _Node;\n \n public:\n-  typedef typename _Alloc_traits<_Val,_Alloc>::allocator_type allocator_type;\n+  typedef _Alloc allocator_type;\n   allocator_type get_allocator() const { return _M_node_allocator; }\n private:\n-  typename _Alloc_traits<_Node, _Alloc>::allocator_type _M_node_allocator;\n+  typedef typename _Alloc::template rebind<_Node>::other _Node_Alloc;\n+  typedef typename _Alloc::template rebind<_Node*>::other _Nodeptr_Alloc;\n+  typedef vector<_Node*, _Nodeptr_Alloc> _Vector_type;\n+\n+  _Node_Alloc _M_node_allocator;\n   _Node* _M_get_node() { return _M_node_allocator.allocate(1); }\n   void _M_put_node(_Node* __p) { _M_node_allocator.deallocate(__p, 1); }\n \n private:\n   hasher                _M_hash;\n   key_equal             _M_equals;\n   _ExtractKey           _M_get_key;\n-  vector<_Node*,_Alloc> _M_buckets;\n+  _Vector_type          _M_buckets;\n   size_type             _M_num_elements;\n \n public:\n@@ -876,8 +879,7 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>\n   if (__num_elements_hint > __old_n) {\n     const size_type __n = _M_next_size(__num_elements_hint);\n     if (__n > __old_n) {\n-      vector<_Node*, _All> __tmp(__n, (_Node*)(0),\n-                                 _M_buckets.get_allocator());\n+      _Vector_type __tmp(__n, (_Node*)(0), _M_buckets.get_allocator());\n       try {\n         for (size_type __bucket = 0; __bucket < __old_n; ++__bucket) {\n           _Node* __first = _M_buckets[__bucket];"}]}