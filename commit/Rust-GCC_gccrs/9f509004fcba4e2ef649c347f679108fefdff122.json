{"sha": "9f509004fcba4e2ef649c347f679108fefdff122", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY1MDkwMDRmY2JhNGUyZWY2NDljMzQ3ZjY3OTEwOGZlZmRmZjEyMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-09-17T21:42:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-09-17T21:42:55Z"}, "message": "tree-cfg.c (verify_types_in_gimple_assign): Rename to ...\n\n2008-09-17  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-cfg.c (verify_types_in_gimple_assign): Rename to ...\n\t(verify_gimple_assign): ... this.  Split into ...\n\t(verify_gimple_assign_unary): ... this,\n\t(verify_gimple_assign_binary): ... that,\n\t(verify_gimple_assign_single): ... and this.\n\t(verify_types_in_gimple_stmt): Call verify_gimple_assign.\n\tFix GIMPLE_CHANGE_DYNAMIC_TYPE handling.\n\t(verify_types_in_gimple_min_lval): Handle TARGET_MEM_REF.\n\t(verify_types_in_gimple_reference): Be forgiving with\n\tVIEW_CONVERT_EXPRs.\n\t(verify_gimple_phi): Deal with virtual operands.\n\n\t* tree.def (PREDICT_EXPR): Change to tcc_expression.\n\nFrom-SVN: r140431", "tree": {"sha": "7fabe819327c7f2d722c200fd40771d593760da4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fabe819327c7f2d722c200fd40771d593760da4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f509004fcba4e2ef649c347f679108fefdff122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f509004fcba4e2ef649c347f679108fefdff122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f509004fcba4e2ef649c347f679108fefdff122", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f509004fcba4e2ef649c347f679108fefdff122/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2700cb867541331e5ff208e451870c7a801a5613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2700cb867541331e5ff208e451870c7a801a5613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2700cb867541331e5ff208e451870c7a801a5613"}], "stats": {"total": 534, "additions": 341, "deletions": 193}, "files": [{"sha": "fc5263e34bb4f7657424b540f75d145056184865", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f509004fcba4e2ef649c347f679108fefdff122/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f509004fcba4e2ef649c347f679108fefdff122/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f509004fcba4e2ef649c347f679108fefdff122", "patch": "@@ -1,3 +1,19 @@\n+2008-09-17  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-cfg.c (verify_types_in_gimple_assign): Rename to ...\n+\t(verify_gimple_assign): ... this.  Split into ...\n+\t(verify_gimple_assign_unary): ... this,\n+\t(verify_gimple_assign_binary): ... that,\n+\t(verify_gimple_assign_single): ... and this.\n+\t(verify_types_in_gimple_stmt): Call verify_gimple_assign.\n+\tFix GIMPLE_CHANGE_DYNAMIC_TYPE handling.\n+\t(verify_types_in_gimple_min_lval): Handle TARGET_MEM_REF.\n+\t(verify_types_in_gimple_reference): Be forgiving with\n+\tVIEW_CONVERT_EXPRs.\n+\t(verify_gimple_phi): Deal with virtual operands.\n+\n+\t* tree.def (PREDICT_EXPR): Change to tcc_expression.\n+\n 2008-09-17  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* tree.c (get_callee_fndecl): Don't call the language hook."}, {"sha": "ef891e5b3325f62c2d88b04bac195de932ea6809", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 324, "deletions": 192, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f509004fcba4e2ef649c347f679108fefdff122/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f509004fcba4e2ef649c347f679108fefdff122/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9f509004fcba4e2ef649c347f679108fefdff122", "patch": "@@ -3035,14 +3035,17 @@ verify_types_in_gimple_min_lval (tree expr)\n   if (is_gimple_id (expr))\n     return false;\n \n-  if (TREE_CODE (expr) != INDIRECT_REF\n-      && TREE_CODE (expr) != ALIGN_INDIRECT_REF\n-      && TREE_CODE (expr) != MISALIGNED_INDIRECT_REF)\n+  if (!INDIRECT_REF_P (expr)\n+      && TREE_CODE (expr) != TARGET_MEM_REF)\n     {\n       error (\"invalid expression for min lvalue\");\n       return true;\n     }\n \n+  /* TARGET_MEM_REFs are strange beasts.  */\n+  if (TREE_CODE (expr) == TARGET_MEM_REF)\n+    return false;\n+\n   op = TREE_OPERAND (expr, 0);\n   if (!is_gimple_val (op))\n     {\n@@ -3131,6 +3134,9 @@ verify_types_in_gimple_reference (tree expr)\n       /* For VIEW_CONVERT_EXPRs which are allowed here, too, there\n \t is nothing to verify.  Gross mismatches at most invoke\n \t undefined behavior.  */\n+      if (TREE_CODE (expr) == VIEW_CONVERT_EXPR\n+\t  && !handled_component_p (op))\n+\treturn false;\n \n       expr = op;\n     }\n@@ -3257,45 +3263,50 @@ verify_gimple_comparison (tree type, tree op0, tree op1)\n   return false;\n }\n \n-/* Verify the contents of a GIMPLE_ASSIGN STMT.  Returns true when there\n-   is a problem, otherwise false.\n-\n-   Verify that the types of the LHS and the RHS operands are\n-   compatible.  This verification largely depends on what kind of\n-   operation is done on the RHS of the assignment.  It is not always\n-   the case that all the types of the operands must match (e.g., 'a =\n-   (unsigned long) b' or 'ptr = ptr + 1').  */\n+/* Verify a gimple assignment statement STMT with an unary rhs.\n+   Returns true if anything is wrong.  */\n \n static bool\n-verify_types_in_gimple_assign (gimple stmt)\n+verify_gimple_assign_unary (gimple stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n   tree lhs = gimple_assign_lhs (stmt);\n-  tree rhs1 = gimple_assign_rhs1 (stmt);\n-  tree rhs2 = (gimple_num_ops (stmt) == 3) ? gimple_assign_rhs2 (stmt) : NULL;\n   tree lhs_type = TREE_TYPE (lhs);\n+  tree rhs1 = gimple_assign_rhs1 (stmt);\n   tree rhs1_type = TREE_TYPE (rhs1);\n-  tree rhs2_type = (rhs2) ? TREE_TYPE (rhs2) : NULL;\n \n-  /* Special codes we cannot handle via their class.  */\n+  if (!is_gimple_reg (lhs)\n+      && !(optimize == 0\n+\t   && TREE_CODE (lhs_type) == COMPLEX_TYPE))\n+    {\n+      error (\"non-register as LHS of unary operation\");\n+      return true;\n+    }\n+\n+  if (!is_gimple_val (rhs1))\n+    {\n+      error (\"invalid operand in unary operation\");\n+      return true;\n+    }\n+\n+  /* First handle conversions.  */\n   switch (rhs_code)\n     {\n     CASE_CONVERT:\n       {\n-\tif (!is_gimple_val (rhs1))\n-\t  {\n-\t    error (\"invalid operand in conversion\");\n-\t    return true;\n-\t  }\n-\n \t/* Allow conversions between integral types and pointers only if\n-\t   there is no sign or zero extension involved.  */\n-\tif (((POINTER_TYPE_P (lhs_type) && INTEGRAL_TYPE_P (rhs1_type))\n-\t     || (POINTER_TYPE_P (rhs1_type) && INTEGRAL_TYPE_P (lhs_type)))\n-\t    && (TYPE_PRECISION (lhs_type) == TYPE_PRECISION (rhs1_type)\n-\t\t/* For targets were the precision of sizetype doesn't\n-\t\t   match that of pointers we need the following.  */\n-\t\t|| lhs_type == sizetype || rhs1_type == sizetype))\n+\t   there is no sign or zero extension involved.\n+\t   For targets were the precision of sizetype doesn't match that\n+\t   of pointers we need to allow arbitrary conversions from and\n+\t   to sizetype.  */\n+\tif ((POINTER_TYPE_P (lhs_type)\n+\t     && INTEGRAL_TYPE_P (rhs1_type)\n+\t     && (TYPE_PRECISION (lhs_type) >= TYPE_PRECISION (rhs1_type)\n+\t\t || rhs1_type == sizetype))\n+\t    || (POINTER_TYPE_P (rhs1_type)\n+\t\t&& INTEGRAL_TYPE_P (lhs_type)\n+\t\t&& (TYPE_PRECISION (rhs1_type) >= TYPE_PRECISION (lhs_type)\n+\t\t    || lhs_type == sizetype)))\n \t  return false;\n \n \t/* Allow conversion from integer to offset type and vice versa.  */\n@@ -3320,12 +3331,6 @@ verify_types_in_gimple_assign (gimple stmt)\n \n     case FIXED_CONVERT_EXPR:\n       {\n-\tif (!is_gimple_val (rhs1))\n-\t  {\n-\t    error (\"invalid operand in conversion\");\n-\t    return true;\n-\t  }\n-\n \tif (!valid_fixed_convert_types_p (lhs_type, rhs1_type)\n \t    && !valid_fixed_convert_types_p (rhs1_type, lhs_type))\n \t  {\n@@ -3340,12 +3345,6 @@ verify_types_in_gimple_assign (gimple stmt)\n \n     case FLOAT_EXPR:\n       {\n-\tif (!is_gimple_val (rhs1))\n-\t  {\n-\t    error (\"invalid operand in int to float conversion\");\n-\t    return true;\n-\t  }\n-\n \tif (!INTEGRAL_TYPE_P (rhs1_type) || !SCALAR_FLOAT_TYPE_P (lhs_type))\n \t  {\n \t    error (\"invalid types in conversion to floating point\");\n@@ -3359,12 +3358,6 @@ verify_types_in_gimple_assign (gimple stmt)\n \n     case FIX_TRUNC_EXPR:\n       {\n-\tif (!is_gimple_val (rhs1))\n-\t  {\n-\t    error (\"invalid operand in float to int conversion\");\n-\t    return true;\n-\t  }\n-\n \tif (!INTEGRAL_TYPE_P (lhs_type) || !SCALAR_FLOAT_TYPE_P (rhs1_type))\n \t  {\n \t    error (\"invalid types in conversion to integer\");\n@@ -3376,18 +3369,79 @@ verify_types_in_gimple_assign (gimple stmt)\n         return false;\n       }\n \n-    case COMPLEX_EXPR:\n+    case TRUTH_NOT_EXPR:\n       {\n-\tif (!is_gimple_val (rhs1) || !is_gimple_val (rhs2))\n-\t  {\n-\t    error (\"invalid operands in complex expression\");\n-\t    return true;\n-\t  }\n+      }\n+\n+    case NEGATE_EXPR:\n+    case ABS_EXPR:\n+    case BIT_NOT_EXPR:\n+    case PAREN_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case CONJ_EXPR:\n+    case REDUC_MAX_EXPR:\n+    case REDUC_MIN_EXPR:\n+    case REDUC_PLUS_EXPR:\n+    case VEC_UNPACK_HI_EXPR:\n+    case VEC_UNPACK_LO_EXPR:\n+    case VEC_UNPACK_FLOAT_HI_EXPR:\n+    case VEC_UNPACK_FLOAT_LO_EXPR:\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* For the remaining codes assert there is no conversion involved.  */\n+  if (!useless_type_conversion_p (lhs_type, rhs1_type))\n+    {\n+      error (\"non-trivial conversion in unary operation\");\n+      debug_generic_expr (lhs_type);\n+      debug_generic_expr (rhs1_type);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Verify a gimple assignment statement STMT with a binary rhs.\n+   Returns true if anything is wrong.  */\n+\n+static bool\n+verify_gimple_assign_binary (gimple stmt)\n+{\n+  enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree lhs_type = TREE_TYPE (lhs);\n+  tree rhs1 = gimple_assign_rhs1 (stmt);\n+  tree rhs1_type = TREE_TYPE (rhs1);\n+  tree rhs2 = gimple_assign_rhs2 (stmt);\n+  tree rhs2_type = TREE_TYPE (rhs2);\n+\n+  if (!is_gimple_reg (lhs)\n+      && !(optimize == 0\n+\t   && TREE_CODE (lhs_type) == COMPLEX_TYPE))\n+    {\n+      error (\"non-register as LHS of binary operation\");\n+      return true;\n+    }\n \n-\tif (!TREE_CODE (lhs_type) == COMPLEX_TYPE\n-\t    || !(TREE_CODE (rhs1_type) == INTEGER_TYPE\n+  if (!is_gimple_val (rhs1)\n+      || !is_gimple_val (rhs2))\n+    {\n+      error (\"invalid operands in binary operation\");\n+      return true;\n+    }\n+\n+  /* First handle operations that involve different types.  */\n+  switch (rhs_code)\n+    {\n+    case COMPLEX_EXPR:\n+      {\n+\tif (TREE_CODE (lhs_type) != COMPLEX_TYPE\n+\t    || !(INTEGRAL_TYPE_P (rhs1_type)\n \t         || SCALAR_FLOAT_TYPE_P (rhs1_type))\n-\t    || !(TREE_CODE (rhs2_type) == INTEGER_TYPE\n+\t    || !(INTEGRAL_TYPE_P (rhs2_type)\n \t         || SCALAR_FLOAT_TYPE_P (rhs2_type)))\n \t  {\n \t    error (\"type mismatch in complex expression\");\n@@ -3400,26 +3454,13 @@ verify_types_in_gimple_assign (gimple stmt)\n \treturn false;\n       }\n \n-    case CONSTRUCTOR:\n-      {\n-\t/* In this context we know that we are on the RHS of an\n-\t   assignment, so CONSTRUCTOR operands are OK.  */\n-\t/* FIXME: verify constructor arguments.  */\n-\treturn false;\n-      }\n-\n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n       {\n-\tif (!is_gimple_val (rhs1) || !is_gimple_val (rhs2))\n-\t  {\n-\t    error (\"invalid operands in shift expression\");\n-\t    return true;\n-\t  }\n-\n-\tif (!TREE_CODE (rhs1_type) == INTEGER_TYPE\n+\tif (!INTEGRAL_TYPE_P (rhs1_type)\n+\t    || !INTEGRAL_TYPE_P (rhs2_type)\n \t    || !useless_type_conversion_p (lhs_type, rhs1_type))\n \t  {\n \t    error (\"type mismatch in shift expression\");\n@@ -3432,28 +3473,28 @@ verify_types_in_gimple_assign (gimple stmt)\n \treturn false;\n       }\n \n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n+    case VEC_LSHIFT_EXPR:\n+    case VEC_RSHIFT_EXPR:\n       {\n-\tif (POINTER_TYPE_P (lhs_type)\n-\t    || POINTER_TYPE_P (rhs1_type)\n-\t    || POINTER_TYPE_P (rhs2_type))\n+\tif (TREE_CODE (rhs1_type) != VECTOR_TYPE\n+\t    || !INTEGRAL_TYPE_P (TREE_TYPE (rhs1_type))\n+\t    || (!INTEGRAL_TYPE_P (rhs2_type)\n+\t\t&& (TREE_CODE (rhs2_type) != VECTOR_TYPE\n+\t\t    || !INTEGRAL_TYPE_P (TREE_TYPE (rhs2_type))))\n+\t    || !useless_type_conversion_p (lhs_type, rhs1_type))\n \t  {\n-\t    error (\"invalid (pointer) operands to plus/minus\");\n+\t    error (\"type mismatch in vector shift expression\");\n+\t    debug_generic_expr (lhs_type);\n+\t    debug_generic_expr (rhs1_type);\n+\t    debug_generic_expr (rhs2_type);\n \t    return true;\n \t  }\n \n-\t/* Continue with generic binary expression handling.  */\n-\tbreak;\n+\treturn false;\n       }\n \n     case POINTER_PLUS_EXPR:\n       {\n-      \tif (!is_gimple_val (rhs1) || !is_gimple_val (rhs2))\n-\t  {\n-\t    error (\"invalid operands in pointer plus expression\");\n-\t    return true;\n-\t  }\n \tif (!POINTER_TYPE_P (rhs1_type)\n \t    || !useless_type_conversion_p (lhs_type, rhs1_type)\n \t    || !useless_type_conversion_p (sizetype, rhs2_type))\n@@ -3468,30 +3509,6 @@ verify_types_in_gimple_assign (gimple stmt)\n \treturn false;\n       } \n \n-    case ADDR_EXPR:\n-      {\n-\ttree op = TREE_OPERAND (rhs1, 0);\n-\tif (!is_gimple_addressable (op))\n-\t  {\n-\t    error (\"invalid operand in unary expression\");\n-\t    return true;\n-\t  }\n-\n-\tif (!one_pointer_to_useless_type_conversion_p (lhs_type, TREE_TYPE (op))\n-\t    /* FIXME: a longstanding wart, &a == &a[0].  */\n-\t    && (TREE_CODE (TREE_TYPE (op)) != ARRAY_TYPE\n-\t\t|| !one_pointer_to_useless_type_conversion_p (lhs_type,\n-\t\t      TREE_TYPE (TREE_TYPE (op)))))\n-\t  {\n-\t    error (\"type mismatch in address expression\");\n-\t    debug_generic_stmt (lhs_type);\n-\t    debug_generic_stmt (TYPE_POINTER_TO (TREE_TYPE (op)));\n-\t    return true;\n-\t  }\n-\n-\treturn verify_types_in_gimple_reference (TREE_OPERAND (rhs1, 0));\n-      }\n-\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n       gcc_unreachable ();\n@@ -3500,12 +3517,6 @@ verify_types_in_gimple_assign (gimple stmt)\n     case TRUTH_OR_EXPR:\n     case TRUTH_XOR_EXPR:\n       {\n-      \tif (!is_gimple_val (rhs1) || !is_gimple_val (rhs2))\n-\t  {\n-\t    error (\"invalid operands in truth expression\");\n-\t    return true;\n-\t  }\n-\n \t/* We allow any kind of integral typed argument and result.  */\n \tif (!INTEGRAL_TYPE_P (rhs1_type)\n \t    || !INTEGRAL_TYPE_P (rhs2_type)\n@@ -3521,108 +3532,226 @@ verify_types_in_gimple_assign (gimple stmt)\n \treturn false;\n       }\n \n-    case TRUTH_NOT_EXPR:\n-      {\n-\tif (!is_gimple_val (rhs1))\n-\t  {\n-\t    error (\"invalid operand in unary not\");\n-\t    return true;\n-\t  }\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case LTGT_EXPR:\n+      /* Comparisons are also binary, but the result type is not\n+\t connected to the operand types.  */\n+      return verify_gimple_comparison (lhs_type, rhs1, rhs2);\n \n-\t/* For TRUTH_NOT_EXPR we can have any kind of integral\n-\t   typed arguments and results.  */\n-\tif (!INTEGRAL_TYPE_P (rhs1_type)\n-\t    || !INTEGRAL_TYPE_P (lhs_type))\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      {\n+\tif (POINTER_TYPE_P (lhs_type)\n+\t    || POINTER_TYPE_P (rhs1_type)\n+\t    || POINTER_TYPE_P (rhs2_type))\n \t  {\n-\t    error (\"type mismatch in not expression\");\n-\t    debug_generic_expr (lhs_type);\n-\t    debug_generic_expr (rhs1_type);\n+\t    error (\"invalid (pointer) operands to plus/minus\");\n \t    return true;\n \t  }\n \n-\treturn false;\n+\t/* Continue with generic binary expression handling.  */\n+\tbreak;\n       }\n \n-    /* After gimplification we should not have any of these.  */\n-    case ASM_EXPR:\n-    case BIND_EXPR:\n-    case CALL_EXPR:\n-    case COND_EXPR:\n-    case TREE_LIST:\n-    case COMPOUND_EXPR:\n-    case MODIFY_EXPR:\n-    case INIT_EXPR:\n-    case GOTO_EXPR:\n-    case LABEL_EXPR:\n-    case RETURN_EXPR:\n-    case TRY_FINALLY_EXPR:\n-    case TRY_CATCH_EXPR:\n-    case EH_FILTER_EXPR:\n-    case STATEMENT_LIST:\n-      {\n-\terror (\"tree node that should already be gimple.\");\n-\treturn true;\n-      }\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case WIDEN_SUM_EXPR:\n+    case WIDEN_MULT_EXPR:\n+    case VEC_WIDEN_MULT_HI_EXPR:\n+    case VEC_WIDEN_MULT_LO_EXPR:\n+    case VEC_PACK_TRUNC_EXPR:\n+    case VEC_PACK_SAT_EXPR:\n+    case VEC_PACK_FIX_TRUNC_EXPR:\n+    case VEC_EXTRACT_EVEN_EXPR:\n+    case VEC_EXTRACT_ODD_EXPR:\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+    case VEC_INTERLEAVE_LOW_EXPR:\n+      /* Continue with generic binary expression handling.  */\n+      break;\n \n-    case OBJ_TYPE_REF:\n-      /* FIXME.  */\n-      return false;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-    default:;\n+  if (!useless_type_conversion_p (lhs_type, rhs1_type)\n+      || !useless_type_conversion_p (lhs_type, rhs2_type))\n+    {\n+      error (\"type mismatch in binary expression\");\n+      debug_generic_stmt (lhs_type);\n+      debug_generic_stmt (rhs1_type);\n+      debug_generic_stmt (rhs2_type);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Verify a gimple assignment statement STMT with a single rhs.\n+   Returns true if anything is wrong.  */\n+\n+static bool\n+verify_gimple_assign_single (gimple stmt)\n+{\n+  enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree lhs_type = TREE_TYPE (lhs);\n+  tree rhs1 = gimple_assign_rhs1 (stmt);\n+  tree rhs1_type = TREE_TYPE (rhs1);\n+  bool res = false;\n+\n+  if (!useless_type_conversion_p (lhs_type, rhs1_type))\n+    {\n+      error (\"non-trivial conversion at assignment\");\n+      debug_generic_expr (lhs_type);\n+      debug_generic_expr (rhs1_type);\n+      return true;\n     }\n \n-  /* Generic handling via classes.  */\n-  switch (TREE_CODE_CLASS (rhs_code))\n+  if (handled_component_p (lhs))\n+    res |= verify_types_in_gimple_reference (lhs);\n+\n+  /* Special codes we cannot handle via their class.  */\n+  switch (rhs_code)\n     {\n-    case tcc_exceptional: /* for SSA_NAME */\n-    case tcc_unary:\n-      if (!useless_type_conversion_p (lhs_type, rhs1_type))\n-\t{\n-\t  error (\"non-trivial conversion at assignment\");\n-\t  debug_generic_expr (lhs_type);\n-\t  debug_generic_expr (rhs1_type);\n-\t  return true;\n-\t}\n-      break;\n+    case ADDR_EXPR:\n+      {\n+\ttree op = TREE_OPERAND (rhs1, 0);\n+\tif (!is_gimple_addressable (op))\n+\t  {\n+\t    error (\"invalid operand in unary expression\");\n+\t    return true;\n+\t  }\n \n-    case tcc_binary:\n-      if (!is_gimple_val (rhs1) || !is_gimple_val (rhs2))\n-\t{\n-\t  error (\"invalid operands in binary expression\");\n-\t  return true;\n-\t}\n-      if (!useless_type_conversion_p (lhs_type, rhs1_type)\n-\t  || !useless_type_conversion_p (lhs_type, rhs2_type))\n+\tif (!one_pointer_to_useless_type_conversion_p (lhs_type, TREE_TYPE (op))\n+\t    /* FIXME: a longstanding wart, &a == &a[0].  */\n+\t    && (TREE_CODE (TREE_TYPE (op)) != ARRAY_TYPE\n+\t\t|| !one_pointer_to_useless_type_conversion_p (lhs_type,\n+\t\t      TREE_TYPE (TREE_TYPE (op)))))\n+\t  {\n+\t    error (\"type mismatch in address expression\");\n+\t    debug_generic_stmt (lhs_type);\n+\t    debug_generic_stmt (TYPE_POINTER_TO (TREE_TYPE (op)));\n+\t    return true;\n+\t  }\n+\n+\treturn verify_types_in_gimple_reference (op);\n+      }\n+\n+    /* tcc_reference  */\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+    case INDIRECT_REF:\n+    case ALIGN_INDIRECT_REF:\n+    case MISALIGNED_INDIRECT_REF:\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+    case VIEW_CONVERT_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case TARGET_MEM_REF:\n+      if (!is_gimple_reg (lhs)\n+\t  && is_gimple_reg_type (TREE_TYPE (lhs)))\n \t{\n-\t  error (\"type mismatch in binary expression\");\n-\t  debug_generic_stmt (lhs_type);\n-\t  debug_generic_stmt (rhs1_type);\n-\t  debug_generic_stmt (rhs2_type);\n+\t  error (\"invalid rhs for gimple memory store\");\n+\t  debug_generic_stmt (lhs);\n+\t  debug_generic_stmt (rhs1);\n \t  return true;\n \t}\n-      break;\n+      return res || verify_types_in_gimple_reference (rhs1);\n \n-    case tcc_reference:\n-      /* All tcc_reference trees are GIMPLE_SINGLE_RHS.  Verify that\n-         no implicit type change happens here.  */\n-      if (!useless_type_conversion_p (lhs_type, rhs1_type))\n+    /* tcc_constant  */\n+    case SSA_NAME:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case FIXED_CST:\n+    case COMPLEX_CST:\n+    case VECTOR_CST:\n+    case STRING_CST:\n+      return res;\n+\n+    /* tcc_declaration  */\n+    case CONST_DECL:\n+      return res;\n+    case VAR_DECL:\n+    case PARM_DECL:\n+      if (!is_gimple_reg (lhs)\n+\t  && !is_gimple_reg (rhs1)\n+\t  && is_gimple_reg_type (TREE_TYPE (lhs)))\n \t{\n-\t  error (\"non-trivial conversion at assignment\");\n-\t  debug_generic_expr (lhs_type);\n-\t  debug_generic_expr (rhs1_type);\n+\t  error (\"invalid rhs for gimple memory store\");\n+\t  debug_generic_stmt (lhs);\n+\t  debug_generic_stmt (rhs1);\n \t  return true;\n \t}\n-      return verify_types_in_gimple_reference (rhs1);\n+      return res;\n \n-    case tcc_comparison:\n-      return verify_gimple_comparison (lhs_type, rhs1, rhs2);\n+    case COND_EXPR:\n+    case CONSTRUCTOR:\n+    case OBJ_TYPE_REF:\n+    case ASSERT_EXPR:\n+    case WITH_SIZE_EXPR:\n+    case EXC_PTR_EXPR:\n+    case FILTER_EXPR:\n+    case POLYNOMIAL_CHREC:\n+    case DOT_PROD_EXPR:\n+    case VEC_COND_EXPR:\n+    case REALIGN_LOAD_EXPR:\n+      /* FIXME.  */\n+      return res;\n \n     default:;\n     }\n \n-  return false;\n+  return res;\n }\n \n+/* Verify the contents of a GIMPLE_ASSIGN STMT.  Returns true when there\n+   is a problem, otherwise false.  */\n+\n+static bool\n+verify_gimple_assign (gimple stmt)\n+{\n+  switch (gimple_assign_rhs_class (stmt))\n+    {\n+    case GIMPLE_SINGLE_RHS:\n+      return verify_gimple_assign_single (stmt);\n+\n+    case GIMPLE_UNARY_RHS:\n+      return verify_gimple_assign_unary (stmt);\n+\n+    case GIMPLE_BINARY_RHS:\n+      return verify_gimple_assign_binary (stmt);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n \n /* Verify the contents of a GIMPLE_RETURN STMT.  Returns true when there\n    is a problem, otherwise false.  */\n@@ -3719,7 +3848,10 @@ verify_gimple_phi (gimple stmt)\n   for (i = 0; i < gimple_phi_num_args (stmt); i++)\n     {\n       tree arg = gimple_phi_arg_def (stmt, i);\n-      if (!is_gimple_val (arg))\n+      if ((is_gimple_reg (gimple_phi_result (stmt))\n+\t   && !is_gimple_val (arg))\n+\t  || (!is_gimple_reg (gimple_phi_result (stmt))\n+\t      && !is_gimple_addressable (arg)))\n \t{\n \t  error (\"Invalid PHI argument\");\n \t  debug_generic_stmt (arg);\n@@ -3758,7 +3890,7 @@ verify_types_in_gimple_stmt (gimple stmt)\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_ASSIGN:\n-      return verify_types_in_gimple_assign (stmt);\n+      return verify_gimple_assign (stmt);\n \n     case GIMPLE_LABEL:\n       return TREE_CODE (gimple_label_label (stmt)) != LABEL_DECL;\n@@ -3784,7 +3916,7 @@ verify_types_in_gimple_stmt (gimple stmt)\n       return false;\n \n     case GIMPLE_CHANGE_DYNAMIC_TYPE:\n-      return (!is_gimple_reg (gimple_cdt_location (stmt))\n+      return (!is_gimple_val (gimple_cdt_location (stmt))\n \t      || !POINTER_TYPE_P (TREE_TYPE (gimple_cdt_location (stmt))));\n \n     case GIMPLE_PHI:"}, {"sha": "ef103cdba502397ceeed143287aead87c03bc253", "filename": "gcc/tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f509004fcba4e2ef649c347f679108fefdff122/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f509004fcba4e2ef649c347f679108fefdff122/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=9f509004fcba4e2ef649c347f679108fefdff122", "patch": "@@ -1137,7 +1137,7 @@ DEFTREECODE (VEC_INTERLEAVE_LOW_EXPR, \"vec_interleavelow_expr\", tcc_binary, 2)\n    outcome (0 for not taken and 1 for taken).  Once the profile is guessed\n    all conditional branches leading to execution paths executing the\n    PREDICT_EXPR will get predicted by the specified predictor.  */\n-DEFTREECODE (PREDICT_EXPR, \"predict_expr\", tcc_unary, 1)\n+DEFTREECODE (PREDICT_EXPR, \"predict_expr\", tcc_expression, 1)\n \n /* OPTIMIZATION_NODE.  Node to store the optimization options.  */\n DEFTREECODE (OPTIMIZATION_NODE, \"optimization_node\", tcc_exceptional, 0)"}]}