{"sha": "5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU0OGQ4YTA5ZTRhZWZhM2NkZDZlMDk3MWM1MmIxNjY1ZWY2OWUzNA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-11-27T08:43:56Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-11-27T08:43:56Z"}, "message": "Replace spaces with tabs and remove trailing whitespaces\n\n\t* tree-ssa-uninit.c: Fix whitespaces in the source file.\n\tThe change is just automatical.\n\nFrom-SVN: r230998", "tree": {"sha": "c0cbb1cc4163315a983a6375425eb6e90db7fee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0cbb1cc4163315a983a6375425eb6e90db7fee5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2f0fc50514322ce1531aafe9eae7f9ecde482f8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f0fc50514322ce1531aafe9eae7f9ecde482f8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f0fc50514322ce1531aafe9eae7f9ecde482f8b"}], "stats": {"total": 1009, "additions": 507, "deletions": 502}, "files": [{"sha": "1a04191a0fcd730ea3696675f58042f1547796aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34", "patch": "@@ -1,3 +1,8 @@\n+2015-11-27  Martin Liska  <mliska@suse.cz>\n+\n+\t* tree-ssa-uninit.c: Fix whitespaces in the source file.\n+\tThe change is just automatical.\n+\n 2015-11-27  Martin Liska  <mliska@suse.cz>\n \n \t* tree-chkp.c (chkp_make_static_bounds): Release buffer"}, {"sha": "50bfb0361f108bbc574868cedcc2b7539796aee9", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 502, "deletions": 502, "changes": 1004, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=5e48d8a09e4aefa3cdd6e0971c52b1665ef69e34", "patch": "@@ -76,8 +76,8 @@ static bool\n has_undefined_value_p (tree t)\n {\n   return (ssa_undefined_value_p (t)\n-          || (possibly_undefined_names\n-              && possibly_undefined_names->contains (t)));\n+\t  || (possibly_undefined_names\n+\t      && possibly_undefined_names->contains (t)));\n }\n \n \n@@ -270,9 +270,9 @@ can_skip_redundant_opnd (tree opnd, gimple *phi)\n     {\n       tree op = gimple_phi_arg_def (op_def, i);\n       if (TREE_CODE (op) != SSA_NAME)\n-        continue;\n+\tcontinue;\n       if (op != phi_def && uninit_undefined_value_p (op))\n-        return false;\n+\treturn false;\n     }\n \n   return true;\n@@ -296,10 +296,10 @@ compute_uninit_opnds_pos (gphi *phi)\n     {\n       tree op = gimple_phi_arg_def (phi, i);\n       if (TREE_CODE (op) == SSA_NAME\n-          && uninit_undefined_value_p (op)\n-          && !can_skip_redundant_opnd (op, phi))\n+\t  && uninit_undefined_value_p (op)\n+\t  && !can_skip_redundant_opnd (op, phi))\n \t{\n-          if (cfun->has_nonlocal_label || cfun->calls_setjmp)\n+\t  if (cfun->has_nonlocal_label || cfun->calls_setjmp)\n \t    {\n \t      /* Ignore SSA_NAMEs that appear on abnormal edges\n \t\t somewhere.  */\n@@ -323,7 +323,7 @@ find_pdom (basic_block block)\n    else\n      {\n        basic_block bb\n-           = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n+\t   = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n        if (! bb)\n \t return EXIT_BLOCK_PTR_FOR_FN (cfun);\n        return bb;\n@@ -398,8 +398,8 @@ find_control_equiv_block (basic_block bb)\n \n static bool\n compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n-                           vec<edge> *cd_chains,\n-                           size_t *num_chains,\n+\t\t\t   vec<edge> *cd_chains,\n+\t\t\t   size_t *num_chains,\n \t\t\t   vec<edge> *cur_cd_chain,\n \t\t\t   int *num_calls)\n {\n@@ -426,47 +426,47 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n       edge e = (*cur_cd_chain)[i];\n       /* Cycle detected. */\n       if (e->src == bb)\n-        return false;\n+\treturn false;\n     }\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       basic_block cd_bb;\n       int post_dom_check = 0;\n       if (e->flags & (EDGE_FAKE | EDGE_ABNORMAL))\n-        continue;\n+\tcontinue;\n \n       cd_bb = e->dest;\n       cur_cd_chain->safe_push (e);\n       while (!is_non_loop_exit_postdominating (cd_bb, bb))\n-        {\n-          if (cd_bb == dep_bb)\n-            {\n-              /* Found a direct control dependence.  */\n-              if (*num_chains < MAX_NUM_CHAINS)\n-                {\n-                  cd_chains[*num_chains] = cur_cd_chain->copy ();\n-                  (*num_chains)++;\n-                }\n-              found_cd_chain = true;\n-              /* Check path from next edge.  */\n-              break;\n-            }\n-\n-          /* Now check if DEP_BB is indirectly control dependent on BB.  */\n-          if (compute_control_dep_chain (cd_bb, dep_bb, cd_chains,\n+\t{\n+\t  if (cd_bb == dep_bb)\n+\t    {\n+\t      /* Found a direct control dependence.  */\n+\t      if (*num_chains < MAX_NUM_CHAINS)\n+\t\t{\n+\t\t  cd_chains[*num_chains] = cur_cd_chain->copy ();\n+\t\t  (*num_chains)++;\n+\t\t}\n+\t      found_cd_chain = true;\n+\t      /* Check path from next edge.  */\n+\t      break;\n+\t    }\n+\n+\t  /* Now check if DEP_BB is indirectly control dependent on BB.  */\n+\t  if (compute_control_dep_chain (cd_bb, dep_bb, cd_chains,\n \t\t\t\t\t num_chains, cur_cd_chain, num_calls))\n-            {\n-              found_cd_chain = true;\n-              break;\n-            }\n+\t    {\n+\t      found_cd_chain = true;\n+\t      break;\n+\t    }\n \n-          cd_bb = find_pdom (cd_bb);\n-          post_dom_check++;\n+\t  cd_bb = find_pdom (cd_bb);\n+\t  post_dom_check++;\n \t  if (cd_bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || post_dom_check >\n \t      MAX_POSTDOM_CHECK)\n-            break;\n-        }\n+\t    break;\n+\t}\n       cur_cd_chain->pop ();\n       gcc_assert (cur_cd_chain->length () == cur_chain_len);\n     }\n@@ -508,8 +508,8 @@ typedef vec<pred_chain, va_heap, vl_ptr> pred_chain_union;\n \n static bool\n convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n-                                      size_t num_chains,\n-                                      pred_chain_union *preds)\n+\t\t\t\t      size_t num_chains,\n+\t\t\t\t      pred_chain_union *preds)\n {\n   bool has_valid_pred = false;\n   size_t i, j;\n@@ -527,48 +527,48 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n       has_valid_pred = false;\n       pred_chain t_chain = vNULL;\n       for (j = 0; j < one_cd_chain.length (); j++)\n-        {\n+\t{\n \t  gimple *cond_stmt;\n-          gimple_stmt_iterator gsi;\n-          basic_block guard_bb;\n-          pred_info one_pred;\n-          edge e;\n-\n-          e = one_cd_chain[j];\n-          guard_bb = e->src;\n-          gsi = gsi_last_bb (guard_bb);\n-          if (gsi_end_p (gsi))\n-            {\n-              has_valid_pred = false;\n-              break;\n-            }\n-          cond_stmt = gsi_stmt (gsi);\n-          if (is_gimple_call (cond_stmt)\n-              && EDGE_COUNT (e->src->succs) >= 2)\n-            {\n-              /* Ignore EH edge. Can add assertion\n-                 on the other edge's flag.  */\n-              continue;\n-            }\n-          /* Skip if there is essentially one succesor.  */\n-          if (EDGE_COUNT (e->src->succs) == 2)\n-            {\n-              edge e1;\n-              edge_iterator ei1;\n-              bool skip = false;\n-\n-              FOR_EACH_EDGE (e1, ei1, e->src->succs)\n-                {\n-                  if (EDGE_COUNT (e1->dest->succs) == 0)\n-                    {\n-                      skip = true;\n-                      break;\n-                    }\n-                }\n-              if (skip)\n-                continue;\n-            }\n-          if (gimple_code (cond_stmt) == GIMPLE_COND)\n+\t  gimple_stmt_iterator gsi;\n+\t  basic_block guard_bb;\n+\t  pred_info one_pred;\n+\t  edge e;\n+\n+\t  e = one_cd_chain[j];\n+\t  guard_bb = e->src;\n+\t  gsi = gsi_last_bb (guard_bb);\n+\t  if (gsi_end_p (gsi))\n+\t    {\n+\t      has_valid_pred = false;\n+\t      break;\n+\t    }\n+\t  cond_stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_call (cond_stmt)\n+\t      && EDGE_COUNT (e->src->succs) >= 2)\n+\t    {\n+\t      /* Ignore EH edge. Can add assertion\n+\t\t on the other edge's flag.  */\n+\t      continue;\n+\t    }\n+\t  /* Skip if there is essentially one succesor.  */\n+\t  if (EDGE_COUNT (e->src->succs) == 2)\n+\t    {\n+\t      edge e1;\n+\t      edge_iterator ei1;\n+\t      bool skip = false;\n+\n+\t      FOR_EACH_EDGE (e1, ei1, e->src->succs)\n+\t\t{\n+\t\t  if (EDGE_COUNT (e1->dest->succs) == 0)\n+\t\t    {\n+\t\t      skip = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (skip)\n+\t\tcontinue;\n+\t    }\n+\t  if (gimple_code (cond_stmt) == GIMPLE_COND)\n \t    {\n \t      one_pred.pred_lhs = gimple_cond_lhs (cond_stmt);\n \t      one_pred.pred_rhs = gimple_cond_rhs (cond_stmt);\n@@ -603,7 +603,7 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n \t\t    }\n \t\t}\n \t      /* If more than one label reaches this block or the case\n-\t         label doesn't have a single value (like the default one)\n+\t\t label doesn't have a single value (like the default one)\n \t\t fail.  */\n \t      if (!l\n \t\t  || !CASE_LOW (l)\n@@ -621,11 +621,11 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n \t      has_valid_pred = true;\n \t    }\n \t  else\n-            {\n-              has_valid_pred = false;\n-              break;\n-            }\n-        }\n+\t    {\n+\t      has_valid_pred = false;\n+\t      break;\n+\t    }\n+\t}\n \n       if (!has_valid_pred)\n \tbreak;\n@@ -642,8 +642,8 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n \n static bool\n find_predicates (pred_chain_union *preds,\n-                 basic_block phi_bb,\n-                 basic_block use_bb)\n+\t\t basic_block phi_bb,\n+\t\t basic_block use_bb)\n {\n   size_t num_chains = 0, i;\n   int num_calls = 0;\n@@ -659,9 +659,9 @@ find_predicates (pred_chain_union *preds,\n     {\n       basic_block ctrl_eq_bb = find_control_equiv_block (cd_root);\n       if (ctrl_eq_bb && dominated_by_p (CDI_DOMINATORS, use_bb, ctrl_eq_bb))\n-        cd_root = ctrl_eq_bb;\n+\tcd_root = ctrl_eq_bb;\n       else\n-        break;\n+\tbreak;\n     }\n \n   compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains,\n@@ -699,33 +699,33 @@ collect_phi_def_edges (gphi *phi, basic_block cd_root,\n       opnd = gimple_phi_arg_def (phi, i);\n \n       if (TREE_CODE (opnd) != SSA_NAME)\n-        {\n-          if (dump_file && (dump_flags & TDF_DETAILS))\n-            {\n-              fprintf (dump_file, \"\\n[CHECK] Found def edge %d in \", (int)i);\n-              print_gimple_stmt (dump_file, phi, 0, 0);\n-            }\n-          edges->safe_push (opnd_edge);\n-        }\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\n[CHECK] Found def edge %d in \", (int)i);\n+\t      print_gimple_stmt (dump_file, phi, 0, 0);\n+\t    }\n+\t  edges->safe_push (opnd_edge);\n+\t}\n       else\n-        {\n+\t{\n \t  gimple *def = SSA_NAME_DEF_STMT (opnd);\n \n-          if (gimple_code (def) == GIMPLE_PHI\n-              && dominated_by_p (CDI_DOMINATORS,\n-                                 gimple_bb (def), cd_root))\n-            collect_phi_def_edges (as_a <gphi *> (def), cd_root, edges,\n-                                   visited_phis);\n-          else if (!uninit_undefined_value_p (opnd))\n-            {\n-              if (dump_file && (dump_flags & TDF_DETAILS))\n-                {\n-                  fprintf (dump_file, \"\\n[CHECK] Found def edge %d in \", (int)i);\n-                  print_gimple_stmt (dump_file, phi, 0, 0);\n-                }\n-              edges->safe_push (opnd_edge);\n-            }\n-        }\n+\t  if (gimple_code (def) == GIMPLE_PHI\n+\t      && dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t gimple_bb (def), cd_root))\n+\t    collect_phi_def_edges (as_a <gphi *> (def), cd_root, edges,\n+\t\t\t\t   visited_phis);\n+\t  else if (!uninit_undefined_value_p (opnd))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"\\n[CHECK] Found def edge %d in \", (int)i);\n+\t\t  print_gimple_stmt (dump_file, phi, 0, 0);\n+\t\t}\n+\t      edges->safe_push (opnd_edge);\n+\t    }\n+\t}\n     }\n }\n \n@@ -769,14 +769,14 @@ find_def_preds (pred_chain_union *preds, gphi *phi)\n \t\t\t\t &num_chains, &cur_chain, &num_calls);\n \n       /* Now update the newly added chains with\n-         the phi operand edge:  */\n+\t the phi operand edge:  */\n       if (EDGE_COUNT (opnd_edge->src->succs) > 1)\n-        {\n+\t{\n \t  if (prev_nc == num_chains && num_chains < MAX_NUM_CHAINS)\n \t    dep_chains[num_chains++] = vNULL;\n-          for (j = prev_nc; j < num_chains; j++)\n+\t  for (j = prev_nc; j < num_chains; j++)\n \t    dep_chains[j].safe_push (opnd_edge);\n-        }\n+\t}\n     }\n \n   has_valid_pred\n@@ -790,7 +790,7 @@ find_def_preds (pred_chain_union *preds, gphi *phi)\n \n static void\n dump_predicates (gimple *usestmt, pred_chain_union preds,\n-                 const char* msg)\n+\t\t const char* msg)\n {\n   size_t i, j;\n   pred_chain one_pred_chain = vNULL;\n@@ -807,22 +807,22 @@ dump_predicates (gimple *usestmt, pred_chain_union preds,\n       np = one_pred_chain.length ();\n \n       for (j = 0; j < np; j++)\n-        {\n-          pred_info one_pred = one_pred_chain[j];\n-          if (one_pred.invert)\n-            fprintf (dump_file, \" (.NOT.) \");\n-          print_generic_expr (dump_file, one_pred.pred_lhs, 0);\n-          fprintf (dump_file, \" %s \", op_symbol_code (one_pred.cond_code));\n-          print_generic_expr (dump_file, one_pred.pred_rhs, 0);\n-          if (j < np - 1)\n-            fprintf (dump_file, \" (.AND.) \");\n-          else\n-            fprintf (dump_file, \"\\n\");\n-        }\n+\t{\n+\t  pred_info one_pred = one_pred_chain[j];\n+\t  if (one_pred.invert)\n+\t    fprintf (dump_file, \" (.NOT.) \");\n+\t  print_generic_expr (dump_file, one_pred.pred_lhs, 0);\n+\t  fprintf (dump_file, \" %s \", op_symbol_code (one_pred.cond_code));\n+\t  print_generic_expr (dump_file, one_pred.pred_rhs, 0);\n+\t  if (j < np - 1)\n+\t    fprintf (dump_file, \" (.AND.) \");\n+\t  else\n+\t    fprintf (dump_file, \"\\n\");\n+\t}\n       if (i < num_preds - 1)\n-        fprintf (dump_file, \"(.OR.)\\n\");\n+\tfprintf (dump_file, \"(.OR.)\\n\");\n       else\n-        fprintf (dump_file, \"\\n\\n\");\n+\tfprintf (dump_file, \"\\n\\n\");\n     }\n }\n \n@@ -845,7 +845,7 @@ destroy_predicate_vecs (pred_chain_union *preds)\n \n static enum tree_code\n get_cmp_code (enum tree_code orig_cmp_code,\n-              bool swap_cond, bool invert)\n+\t      bool swap_cond, bool invert)\n {\n   enum tree_code tc = orig_cmp_code;\n \n@@ -896,27 +896,27 @@ is_value_included_in (tree val, tree boundary, enum tree_code cmpc)\n   if (is_unsigned)\n     {\n       if (cmpc == EQ_EXPR)\n-        result = tree_int_cst_equal (val, boundary);\n+\tresult = tree_int_cst_equal (val, boundary);\n       else if (cmpc == LT_EXPR)\n-        result = tree_int_cst_lt (val, boundary);\n+\tresult = tree_int_cst_lt (val, boundary);\n       else\n-        {\n-          gcc_assert (cmpc == LE_EXPR);\n-          result = tree_int_cst_le (val, boundary);\n-        }\n+\t{\n+\t  gcc_assert (cmpc == LE_EXPR);\n+\t  result = tree_int_cst_le (val, boundary);\n+\t}\n     }\n   else\n     {\n       if (cmpc == EQ_EXPR)\n-        result = tree_int_cst_equal (val, boundary);\n+\tresult = tree_int_cst_equal (val, boundary);\n       else if (cmpc == LT_EXPR)\n-        result = tree_int_cst_lt (val, boundary);\n+\tresult = tree_int_cst_lt (val, boundary);\n       else\n-        {\n-          gcc_assert (cmpc == LE_EXPR);\n-          result = (tree_int_cst_equal (val, boundary)\n-                    || tree_int_cst_lt (val, boundary));\n-        }\n+\t{\n+\t  gcc_assert (cmpc == LE_EXPR);\n+\t  result = (tree_int_cst_equal (val, boundary)\n+\t\t    || tree_int_cst_lt (val, boundary));\n+\t}\n     }\n \n   if (inverted)\n@@ -931,8 +931,8 @@ is_value_included_in (tree val, tree boundary, enum tree_code cmpc)\n \n static bool\n find_matching_predicate_in_rest_chains (pred_info pred,\n-                                        pred_chain_union preds,\n-                                        size_t num_pred_chains)\n+\t\t\t\t\tpred_chain_union preds,\n+\t\t\t\t\tsize_t num_pred_chains)\n {\n   size_t i, j, n;\n \n@@ -946,36 +946,36 @@ find_matching_predicate_in_rest_chains (pred_info pred,\n       pred_chain one_chain = preds[i];\n       n = one_chain.length ();\n       for (j = 0; j < n; j++)\n-        {\n-          pred_info pred2 = one_chain[j];\n-          /* Can relax the condition comparison to not\n-             use address comparison. However, the most common\n-             case is that multiple control dependent paths share\n-             a common path prefix, so address comparison should\n-             be ok.  */\n-\n-          if (operand_equal_p (pred2.pred_lhs, pred.pred_lhs, 0)\n-              && operand_equal_p (pred2.pred_rhs, pred.pred_rhs, 0)\n-              && pred2.invert == pred.invert)\n-            {\n-              found = true;\n-              break;\n-            }\n-        }\n+\t{\n+\t  pred_info pred2 = one_chain[j];\n+\t  /* Can relax the condition comparison to not\n+\t     use address comparison. However, the most common\n+\t     case is that multiple control dependent paths share\n+\t     a common path prefix, so address comparison should\n+\t     be ok.  */\n+\n+\t  if (operand_equal_p (pred2.pred_lhs, pred.pred_lhs, 0)\n+\t      && operand_equal_p (pred2.pred_rhs, pred.pred_rhs, 0)\n+\t      && pred2.invert == pred.invert)\n+\t    {\n+\t      found = true;\n+\t      break;\n+\t    }\n+\t}\n       if (!found)\n-        return false;\n+\treturn false;\n     }\n   return true;\n }\n \n /* Forward declaration.  */\n static bool\n is_use_properly_guarded (gimple *use_stmt,\n-                         basic_block use_bb,\n-                         gphi *phi,\n-                         unsigned uninit_opnds,\n+\t\t\t basic_block use_bb,\n+\t\t\t gphi *phi,\n+\t\t\t unsigned uninit_opnds,\n \t\t\t pred_chain_union *def_preds,\n-                         hash_set<gphi *> *visited_phis);\n+\t\t\t hash_set<gphi *> *visited_phis);\n \n /* Returns true if all uninitialized opnds are pruned. Returns false\n    otherwise. PHI is the phi node with uninitialized operands,\n@@ -990,7 +990,7 @@ is_use_properly_guarded (gimple *use_stmt,\n    Example scenario:\n \n    BB1:\n-   flag_1 = phi <0, 1>                  // (1)\n+   flag_1 = phi <0, 1>\t\t  // (1)\n    var_1  = phi <undef, some_val>\n \n \n@@ -1001,7 +1001,7 @@ is_use_properly_guarded (gimple *use_stmt,\n       goto BB3;\n \n    BB3:\n-   use of var_2                         // (3)\n+   use of var_2\t\t\t // (3)\n \n    Because some flag arg in (1) is not constant, if we do not look into the\n    flag phis recursively, it is conservatively treated as unknown and var_1\n@@ -1027,77 +1027,77 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n       tree flag_arg;\n \n       if (!MASK_TEST_BIT (uninit_opnds, i))\n-        continue;\n+\tcontinue;\n \n       flag_arg = gimple_phi_arg_def (flag_def, i);\n       if (!is_gimple_constant (flag_arg))\n-        {\n-          gphi *flag_arg_def, *phi_arg_def;\n-          tree phi_arg;\n-          unsigned uninit_opnds_arg_phi;\n-\n-          if (TREE_CODE (flag_arg) != SSA_NAME)\n-            return false;\n-          flag_arg_def = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (flag_arg));\n+\t{\n+\t  gphi *flag_arg_def, *phi_arg_def;\n+\t  tree phi_arg;\n+\t  unsigned uninit_opnds_arg_phi;\n+\n+\t  if (TREE_CODE (flag_arg) != SSA_NAME)\n+\t    return false;\n+\t  flag_arg_def = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (flag_arg));\n \t  if (!flag_arg_def)\n-            return false;\n+\t    return false;\n \n-          phi_arg = gimple_phi_arg_def (phi, i);\n-          if (TREE_CODE (phi_arg) != SSA_NAME)\n-            return false;\n+\t  phi_arg = gimple_phi_arg_def (phi, i);\n+\t  if (TREE_CODE (phi_arg) != SSA_NAME)\n+\t    return false;\n \n-          phi_arg_def = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (phi_arg));\n+\t  phi_arg_def = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (phi_arg));\n \t  if (!phi_arg_def)\n-            return false;\n+\t    return false;\n \n-          if (gimple_bb (phi_arg_def) != gimple_bb (flag_arg_def))\n-            return false;\n+\t  if (gimple_bb (phi_arg_def) != gimple_bb (flag_arg_def))\n+\t    return false;\n \n-          if (!*visited_flag_phis)\n-            *visited_flag_phis = BITMAP_ALLOC (NULL);\n+\t  if (!*visited_flag_phis)\n+\t    *visited_flag_phis = BITMAP_ALLOC (NULL);\n \n-          if (bitmap_bit_p (*visited_flag_phis,\n-                            SSA_NAME_VERSION (gimple_phi_result (flag_arg_def))))\n-            return false;\n+\t  if (bitmap_bit_p (*visited_flag_phis,\n+\t\t\t    SSA_NAME_VERSION (gimple_phi_result (flag_arg_def))))\n+\t    return false;\n \n-          bitmap_set_bit (*visited_flag_phis,\n-                          SSA_NAME_VERSION (gimple_phi_result (flag_arg_def)));\n+\t  bitmap_set_bit (*visited_flag_phis,\n+\t\t\t  SSA_NAME_VERSION (gimple_phi_result (flag_arg_def)));\n \n-          /* Now recursively prune the uninitialized phi args.  */\n-          uninit_opnds_arg_phi = compute_uninit_opnds_pos (phi_arg_def);\n-          if (!prune_uninit_phi_opnds_in_unrealizable_paths\n+\t  /* Now recursively prune the uninitialized phi args.  */\n+\t  uninit_opnds_arg_phi = compute_uninit_opnds_pos (phi_arg_def);\n+\t  if (!prune_uninit_phi_opnds_in_unrealizable_paths\n \t\t (phi_arg_def, uninit_opnds_arg_phi, flag_arg_def,\n \t\t  boundary_cst, cmp_code, visited_phis, visited_flag_phis))\n-            return false;\n+\t    return false;\n \n-          bitmap_clear_bit (*visited_flag_phis,\n-                            SSA_NAME_VERSION (gimple_phi_result (flag_arg_def)));\n-          continue;\n-        }\n+\t  bitmap_clear_bit (*visited_flag_phis,\n+\t\t\t    SSA_NAME_VERSION (gimple_phi_result (flag_arg_def)));\n+\t  continue;\n+\t}\n \n       /* Now check if the constant is in the guarded range.  */\n       if (is_value_included_in (flag_arg, boundary_cst, cmp_code))\n-        {\n-          tree opnd;\n+\t{\n+\t  tree opnd;\n \t  gimple *opnd_def;\n \n-          /* Now that we know that this undefined edge is not\n-             pruned. If the operand is defined by another phi,\n-             we can further prune the incoming edges of that\n-             phi by checking the predicates of this operands.  */\n-\n-          opnd = gimple_phi_arg_def (phi, i);\n-          opnd_def = SSA_NAME_DEF_STMT (opnd);\n-          if (gphi *opnd_def_phi = dyn_cast <gphi *> (opnd_def))\n-            {\n-              edge opnd_edge;\n-              unsigned uninit_opnds2\n-                  = compute_uninit_opnds_pos (opnd_def_phi);\n-              pred_chain_union def_preds = vNULL;\n-              bool ok;\n-              gcc_assert (!MASK_EMPTY (uninit_opnds2));\n-              opnd_edge = gimple_phi_arg_edge (phi, i);\n-              ok = is_use_properly_guarded (phi,\n+\t  /* Now that we know that this undefined edge is not\n+\t     pruned. If the operand is defined by another phi,\n+\t     we can further prune the incoming edges of that\n+\t     phi by checking the predicates of this operands.  */\n+\n+\t  opnd = gimple_phi_arg_def (phi, i);\n+\t  opnd_def = SSA_NAME_DEF_STMT (opnd);\n+\t  if (gphi *opnd_def_phi = dyn_cast <gphi *> (opnd_def))\n+\t    {\n+\t      edge opnd_edge;\n+\t      unsigned uninit_opnds2\n+\t\t  = compute_uninit_opnds_pos (opnd_def_phi);\n+\t      pred_chain_union def_preds = vNULL;\n+\t      bool ok;\n+\t      gcc_assert (!MASK_EMPTY (uninit_opnds2));\n+\t      opnd_edge = gimple_phi_arg_edge (phi, i);\n+\t      ok = is_use_properly_guarded (phi,\n \t\t\t\t\t    opnd_edge->src,\n \t\t\t\t\t    opnd_def_phi,\n \t\t\t\t\t    uninit_opnds2,\n@@ -1106,10 +1106,10 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n \t      destroy_predicate_vecs (&def_preds);\n \t      if (!ok)\n \t\treturn false;\n-            }\n-          else\n-            return false;\n-        }\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n     }\n \n   return true;\n@@ -1119,50 +1119,50 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n    of the use is not overlapping with that of the uninit paths.\n    The most common senario of guarded use is in Example 1:\n      Example 1:\n-           if (some_cond)\n-           {\n-              x = ...;\n-              flag = true;\n-           }\n+\t   if (some_cond)\n+\t   {\n+\t      x = ...;\n+\t      flag = true;\n+\t   }\n \n-            ... some code ...\n+\t    ... some code ...\n \n-           if (flag)\n-              use (x);\n+\t   if (flag)\n+\t      use (x);\n \n      The real world examples are usually more complicated, but similar\n      and usually result from inlining:\n \n-         bool init_func (int * x)\n-         {\n-             if (some_cond)\n-                return false;\n-             *x  =  ..\n-             return true;\n-         }\n+\t bool init_func (int * x)\n+\t {\n+\t     if (some_cond)\n+\t\treturn false;\n+\t     *x  =  ..\n+\t     return true;\n+\t }\n \n-         void foo(..)\n-         {\n-             int x;\n+\t void foo(..)\n+\t {\n+\t     int x;\n \n-             if (!init_func(&x))\n-                return;\n+\t     if (!init_func(&x))\n+\t\treturn;\n \n-             .. some_code ...\n-             use (x);\n-         }\n+\t     .. some_code ...\n+\t     use (x);\n+\t }\n \n      Another possible use scenario is in the following trivial example:\n \n      Example 2:\n-          if (n > 0)\n-             x = 1;\n-          ...\n-          if (n > 0)\n-            {\n-              if (m < 2)\n-                 .. = x;\n-            }\n+\t  if (n > 0)\n+\t     x = 1;\n+\t  ...\n+\t  if (n > 0)\n+\t    {\n+\t      if (m < 2)\n+\t\t .. = x;\n+\t    }\n \n      Predicate analysis needs to compute the composite predicate:\n \n@@ -1173,8 +1173,8 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n        bb and is dominating the operand def.)\n \n        and check overlapping:\n-          (n > 0) .AND. (m < 2) .AND. (.NOT. (n > 0))\n-        <==> false\n+\t  (n > 0) .AND. (m < 2) .AND. (.NOT. (n > 0))\n+\t<==> false\n \n      This implementation provides framework that can handle\n      scenarios. (Note that many simple cases are handled properly\n@@ -1191,7 +1191,7 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n \n static bool\n use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n-\t\t\t\t           gphi *phi, unsigned uninit_opnds,\n+\t\t\t\t\t   gphi *phi, unsigned uninit_opnds,\n \t\t\t\t\t   hash_set<gphi *> *visited_phis)\n {\n   unsigned int i, n;\n@@ -1223,32 +1223,32 @@ use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n       cmp_code = the_pred.cond_code;\n \n       if (cond_lhs != NULL_TREE && TREE_CODE (cond_lhs) == SSA_NAME\n-          && cond_rhs != NULL_TREE && is_gimple_constant (cond_rhs))\n-        {\n-          boundary_cst = cond_rhs;\n-          flag = cond_lhs;\n-        }\n+\t  && cond_rhs != NULL_TREE && is_gimple_constant (cond_rhs))\n+\t{\n+\t  boundary_cst = cond_rhs;\n+\t  flag = cond_lhs;\n+\t}\n       else if (cond_rhs != NULL_TREE && TREE_CODE (cond_rhs) == SSA_NAME\n-               && cond_lhs != NULL_TREE && is_gimple_constant (cond_lhs))\n-        {\n-          boundary_cst = cond_lhs;\n-          flag = cond_rhs;\n-          swap_cond = true;\n-        }\n+\t       && cond_lhs != NULL_TREE && is_gimple_constant (cond_lhs))\n+\t{\n+\t  boundary_cst = cond_lhs;\n+\t  flag = cond_rhs;\n+\t  swap_cond = true;\n+\t}\n \n       if (!flag)\n-        continue;\n+\tcontinue;\n \n       flag_def = SSA_NAME_DEF_STMT (flag);\n \n       if (!flag_def)\n-        continue;\n+\tcontinue;\n \n       if ((gimple_code (flag_def) == GIMPLE_PHI)\n-          && (gimple_bb (flag_def) == gimple_bb (phi))\n-          && find_matching_predicate_in_rest_chains (the_pred, preds,\n+\t  && (gimple_bb (flag_def) == gimple_bb (phi))\n+\t  && find_matching_predicate_in_rest_chains (the_pred, preds,\n \t\t\t\t\t\t     num_preds))\n-        break;\n+\tbreak;\n \n       flag_def = 0;\n     }\n@@ -1264,12 +1264,12 @@ use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n     return false;\n \n   all_pruned = prune_uninit_phi_opnds_in_unrealizable_paths (phi,\n-                                                             uninit_opnds,\n-                                                             as_a <gphi *> (flag_def),\n-                                                             boundary_cst,\n-                                                             cmp_code,\n-                                                             visited_phis,\n-                                                             &visited_flag_phis);\n+\t\t\t\t\t\t\t     uninit_opnds,\n+\t\t\t\t\t\t\t     as_a <gphi *> (flag_def),\n+\t\t\t\t\t\t\t     boundary_cst,\n+\t\t\t\t\t\t\t     cmp_code,\n+\t\t\t\t\t\t\t     visited_phis,\n+\t\t\t\t\t\t\t     &visited_flag_phis);\n \n   if (visited_flag_phis)\n     BITMAP_FREE (visited_flag_phis);\n@@ -1305,13 +1305,13 @@ static inline bool\n is_neq_relop_p (pred_info pred)\n {\n \n-  return (pred.cond_code == NE_EXPR && !pred.invert) \n-          || (pred.cond_code == EQ_EXPR && pred.invert);\n+  return (pred.cond_code == NE_EXPR && !pred.invert)\n+\t  || (pred.cond_code == EQ_EXPR && pred.invert);\n }\n \n /* Returns true if pred is of the form X != 0.  */\n \n-static inline bool \n+static inline bool\n is_neq_zero_form_p (pred_info pred)\n {\n   if (!is_neq_relop_p (pred) || !integer_zerop (pred.pred_rhs)\n@@ -1377,7 +1377,7 @@ is_pred_expr_subset_of (pred_info expr1, pred_info expr2)\n \n static bool\n is_pred_chain_subset_of (pred_chain pred1,\n-                         pred_chain pred2)\n+\t\t\t pred_chain pred2)\n {\n   size_t np1, np2, i1, i2;\n \n@@ -1389,16 +1389,16 @@ is_pred_chain_subset_of (pred_chain pred1,\n       bool found = false;\n       pred_info info2 = pred2[i2];\n       for (i1 = 0; i1 < np1; i1++)\n-        {\n-          pred_info info1 = pred1[i1];\n-          if (is_pred_expr_subset_of (info1, info2))\n-            {\n-              found = true;\n-              break;\n-            }\n-        }\n+\t{\n+\t  pred_info info1 = pred1[i1];\n+\t  if (is_pred_expr_subset_of (info1, info2))\n+\t    {\n+\t      found = true;\n+\t      break;\n+\t    }\n+\t}\n       if (!found)\n-        return false;\n+\treturn false;\n     }\n   return true;\n }\n@@ -1421,7 +1421,7 @@ is_included_in (pred_chain one_pred, pred_chain_union preds)\n   for (i = 0; i < n; i++)\n     {\n       if (is_pred_chain_subset_of (one_pred, preds[i]))\n-        return true;\n+\treturn true;\n     }\n \n   return false;\n@@ -1452,7 +1452,7 @@ is_superset_of (pred_chain_union preds1, pred_chain_union preds2)\n     {\n       one_pred_chain = preds2[i];\n       if (!is_included_in (one_pred_chain, preds1))\n-        return false;\n+\treturn false;\n     }\n \n   return true;\n@@ -1464,8 +1464,8 @@ static inline bool\n is_and_or_or_p (enum tree_code tc, tree type)\n {\n   return (tc == BIT_IOR_EXPR\n-          || (tc == BIT_AND_EXPR\n-              && (type == 0 || TREE_CODE (type) == BOOLEAN_TYPE)));\n+\t  || (tc == BIT_AND_EXPR\n+\t      && (type == 0 || TREE_CODE (type) == BOOLEAN_TYPE)));\n }\n \n /* Returns true if X1 is the negate of X2.  */\n@@ -1477,7 +1477,7 @@ pred_neg_p (pred_info x1, pred_info x2)\n   if (!operand_equal_p (x1.pred_lhs, x2.pred_lhs, 0)\n       || !operand_equal_p (x1.pred_rhs, x2.pred_rhs, 0))\n     return false;\n-      \n+\n   c1 = x1.cond_code;\n   if (x1.invert == x2.invert)\n     c2 = invert_tree_comparison (x2.cond_code, false);\n@@ -1493,7 +1493,7 @@ pred_neg_p (pred_info x1, pred_info x2)\n    4) ((x IAND y) != 0) || (x != 0 AND y != 0)) is equivalent to\n       (x != 0 AND y != 0)\n    5) (X AND Y) OR (!X AND Z) OR (!Y AND Z) is equivalent to\n-      (X AND Y) OR Z \n+      (X AND Y) OR Z\n \n    PREDS is the predicate chains, and N is the number of chains.  */\n \n@@ -1514,35 +1514,35 @@ simplify_pred (pred_chain *one_chain)\n       pred_info *a_pred = &(*one_chain)[i];\n \n       if (!a_pred->pred_lhs)\n-        continue;\n+\tcontinue;\n       if (!is_neq_zero_form_p (*a_pred))\n-        continue;\n+\tcontinue;\n \n       gimple *def_stmt = SSA_NAME_DEF_STMT (a_pred->pred_lhs);\n       if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n-        continue;\n+\tcontinue;\n       if (gimple_assign_rhs_code (def_stmt) == BIT_IOR_EXPR)\n-        {\n-          for (j = 0; j < n; j++)\n-            {\n-              pred_info *b_pred = &(*one_chain)[j];\n-\n-              if (!b_pred->pred_lhs)\n-                continue;\n-              if (!is_neq_zero_form_p (*b_pred))\n-                continue;\n-\n-              if (pred_expr_equal_p (*b_pred, gimple_assign_rhs1 (def_stmt))\n-                  || pred_expr_equal_p (*b_pred, gimple_assign_rhs2 (def_stmt)))\n-                 {\n-                   /* Mark a_pred for removal.  */\n-                   a_pred->pred_lhs = NULL;\n-                   a_pred->pred_rhs = NULL;\n-                   simplified = true;\n-                   break;\n-                 }\n-            }\n-        }\n+\t{\n+\t  for (j = 0; j < n; j++)\n+\t    {\n+\t      pred_info *b_pred = &(*one_chain)[j];\n+\n+\t      if (!b_pred->pred_lhs)\n+\t\tcontinue;\n+\t      if (!is_neq_zero_form_p (*b_pred))\n+\t\tcontinue;\n+\n+\t      if (pred_expr_equal_p (*b_pred, gimple_assign_rhs1 (def_stmt))\n+\t\t  || pred_expr_equal_p (*b_pred, gimple_assign_rhs2 (def_stmt)))\n+\t\t {\n+\t\t   /* Mark a_pred for removal.  */\n+\t\t   a_pred->pred_lhs = NULL;\n+\t\t   a_pred->pred_rhs = NULL;\n+\t\t   simplified = true;\n+\t\t   break;\n+\t\t }\n+\t    }\n+\t}\n     }\n \n   if (!simplified)\n@@ -1552,7 +1552,7 @@ simplify_pred (pred_chain *one_chain)\n     {\n       pred_info *a_pred = &(*one_chain)[i];\n       if (!a_pred->pred_lhs)\n-        continue;\n+\tcontinue;\n       s_chain.safe_push (*a_pred);\n     }\n \n@@ -1572,7 +1572,7 @@ simplify_preds_2 (pred_chain_union *preds)\n   bool simplified = false;\n   pred_chain_union s_preds = vNULL;\n \n-  /* (X AND Y) OR (!X AND Y) is equivalent to Y.  \n+  /* (X AND Y) OR (!X AND Y) is equivalent to Y.\n      (X AND Y) OR (X AND !Y) is equivalent to X.  */\n \n   n = preds->length ();\n@@ -1582,55 +1582,55 @@ simplify_preds_2 (pred_chain_union *preds)\n       pred_chain *a_chain = &(*preds)[i];\n \n       if (a_chain->length () != 2)\n-        continue;\n+\tcontinue;\n \n       x = (*a_chain)[0];\n       y = (*a_chain)[1];\n \n       for (j = 0; j < n; j++)\n-        {\n-          pred_chain *b_chain;\n-          pred_info x2, y2;\n-\n-          if (j == i)\n-            continue;\n-\n-          b_chain = &(*preds)[j];\n-          if (b_chain->length () != 2)\n-            continue;\n-\n-          x2 = (*b_chain)[0];\n-          y2 = (*b_chain)[1];\n-\n-          if (pred_equal_p (x, x2) && pred_neg_p (y, y2))\n-            {\n-              /* Kill a_chain.  */\n-              a_chain->release ();\n-              b_chain->release ();\n-              b_chain->safe_push (x);\n-              simplified = true;\n-              break;\n-            }\n-          if (pred_neg_p (x, x2) && pred_equal_p (y, y2))\n-            {\n-              /* Kill a_chain.  */\n-              a_chain->release ();\n-              b_chain->release ();\n-              b_chain->safe_push (y);\n-              simplified = true;\n-              break;\n-            }\n-        }\n+\t{\n+\t  pred_chain *b_chain;\n+\t  pred_info x2, y2;\n+\n+\t  if (j == i)\n+\t    continue;\n+\n+\t  b_chain = &(*preds)[j];\n+\t  if (b_chain->length () != 2)\n+\t    continue;\n+\n+\t  x2 = (*b_chain)[0];\n+\t  y2 = (*b_chain)[1];\n+\n+\t  if (pred_equal_p (x, x2) && pred_neg_p (y, y2))\n+\t    {\n+\t      /* Kill a_chain.  */\n+\t      a_chain->release ();\n+\t      b_chain->release ();\n+\t      b_chain->safe_push (x);\n+\t      simplified = true;\n+\t      break;\n+\t    }\n+\t  if (pred_neg_p (x, x2) && pred_equal_p (y, y2))\n+\t    {\n+\t      /* Kill a_chain.  */\n+\t      a_chain->release ();\n+\t      b_chain->release ();\n+\t      b_chain->safe_push (y);\n+\t      simplified = true;\n+\t      break;\n+\t    }\n+\t}\n     }\n   /* Now clean up the chain.  */\n   if (simplified)\n     {\n       for (i = 0; i < n; i++)\n-        {\n-          if ((*preds)[i].is_empty ())\n-            continue;\n-          s_preds.safe_push ((*preds)[i]);\n-        }\n+\t{\n+\t  if ((*preds)[i].is_empty ())\n+\t    continue;\n+\t  s_preds.safe_push ((*preds)[i]);\n+\t}\n       preds->release ();\n       (*preds) = s_preds;\n       s_preds = vNULL;\n@@ -1663,34 +1663,34 @@ simplify_preds_3 (pred_chain_union *preds)\n       pred_chain *a_chain = &(*preds)[i];\n \n       if (a_chain->length () != 1)\n-        continue;\n+\tcontinue;\n \n       x = (*a_chain)[0];\n \n       for (j = 0; j < n; j++)\n-        {\n-          pred_chain *b_chain;\n-          pred_info x2;\n-          size_t k;\n-\n-          if (j == i)\n-            continue;\n-\n-          b_chain = &(*preds)[j];\n-          if (b_chain->length () < 2)\n-            continue;\n-\n-          for (k = 0; k < b_chain->length (); k++)\n-            {\n-              x2 = (*b_chain)[k];\n-              if (pred_neg_p (x, x2))\n-                {\n-                  b_chain->unordered_remove (k);\n-                  simplified = true;\n-                  break;\n-                }\n-            }\n-        }\n+\t{\n+\t  pred_chain *b_chain;\n+\t  pred_info x2;\n+\t  size_t k;\n+\n+\t  if (j == i)\n+\t    continue;\n+\n+\t  b_chain = &(*preds)[j];\n+\t  if (b_chain->length () < 2)\n+\t    continue;\n+\n+\t  for (k = 0; k < b_chain->length (); k++)\n+\t    {\n+\t      x2 = (*b_chain)[k];\n+\t      if (pred_neg_p (x, x2))\n+\t\t{\n+\t\t  b_chain->unordered_remove (k);\n+\t\t  simplified = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n     }\n   return simplified;\n }\n@@ -1716,59 +1716,59 @@ simplify_preds_4 (pred_chain_union *preds)\n       pred_chain *a_chain = &(*preds)[i];\n \n       if (a_chain->length () != 1)\n-        continue;\n+\tcontinue;\n \n       z = (*a_chain)[0];\n \n       if (!is_neq_zero_form_p (z))\n-        continue;\n+\tcontinue;\n \n       def_stmt = SSA_NAME_DEF_STMT (z.pred_lhs);\n       if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n-        continue;\n+\tcontinue;\n \n       if (gimple_assign_rhs_code (def_stmt) != BIT_AND_EXPR)\n-        continue;\n+\tcontinue;\n \n       for (j = 0; j < n; j++)\n-        {\n-          pred_chain *b_chain;\n-          pred_info x2, y2;\n-\n-          if (j == i)\n-            continue;\n-\n-          b_chain = &(*preds)[j];\n-          if (b_chain->length () != 2)\n-            continue;\n-\n-          x2 = (*b_chain)[0];\n-          y2 = (*b_chain)[1];\n-          if (!is_neq_zero_form_p (x2)\n-              || !is_neq_zero_form_p (y2))\n-            continue;\n-\n-          if ((pred_expr_equal_p (x2, gimple_assign_rhs1 (def_stmt))\n-               && pred_expr_equal_p (y2, gimple_assign_rhs2 (def_stmt)))\n-              || (pred_expr_equal_p (x2, gimple_assign_rhs2 (def_stmt))\n-                  && pred_expr_equal_p (y2, gimple_assign_rhs1 (def_stmt))))\n-            {\n-              /* Kill a_chain.  */\n-              a_chain->release ();\n-              simplified = true;\n-              break;\n-            }\n-        }\n+\t{\n+\t  pred_chain *b_chain;\n+\t  pred_info x2, y2;\n+\n+\t  if (j == i)\n+\t    continue;\n+\n+\t  b_chain = &(*preds)[j];\n+\t  if (b_chain->length () != 2)\n+\t    continue;\n+\n+\t  x2 = (*b_chain)[0];\n+\t  y2 = (*b_chain)[1];\n+\t  if (!is_neq_zero_form_p (x2)\n+\t      || !is_neq_zero_form_p (y2))\n+\t    continue;\n+\n+\t  if ((pred_expr_equal_p (x2, gimple_assign_rhs1 (def_stmt))\n+\t       && pred_expr_equal_p (y2, gimple_assign_rhs2 (def_stmt)))\n+\t      || (pred_expr_equal_p (x2, gimple_assign_rhs2 (def_stmt))\n+\t\t  && pred_expr_equal_p (y2, gimple_assign_rhs1 (def_stmt))))\n+\t    {\n+\t      /* Kill a_chain.  */\n+\t      a_chain->release ();\n+\t      simplified = true;\n+\t      break;\n+\t    }\n+\t}\n     }\n   /* Now clean up the chain.  */\n   if (simplified)\n     {\n       for (i = 0; i < n; i++)\n-        {\n-          if ((*preds)[i].is_empty ())\n-            continue;\n-          s_preds.safe_push ((*preds)[i]);\n-        }\n+\t{\n+\t  if ((*preds)[i].is_empty ())\n+\t    continue;\n+\t  s_preds.safe_push ((*preds)[i]);\n+\t}\n \n       destroy_predicate_vecs (preds);\n       (*preds) = s_preds;\n@@ -1804,15 +1804,15 @@ simplify_preds (pred_chain_union *preds, gimple *use_or_def, bool is_use)\n     {\n       changed = false;\n       if (simplify_preds_2 (preds))\n-        changed = true;\n+\tchanged = true;\n \n       /* Now iteratively simplify X OR (!X AND Z ..)\n        into X OR (Z ...).  */\n       if (simplify_preds_3 (preds))\n-        changed = true;\n+\tchanged = true;\n \n       if (simplify_preds_4 (preds))\n-        changed = true;\n+\tchanged = true;\n \n     } while (changed);\n \n@@ -1821,7 +1821,7 @@ simplify_preds (pred_chain_union *preds, gimple *use_or_def, bool is_use)\n \n /* This is a helper function which attempts to normalize predicate chains\n   by following UD chains. It basically builds up a big tree of either IOR\n-  operations or AND operations, and convert the IOR tree into a \n+  operations or AND operations, and convert the IOR tree into a\n   pred_chain_union or BIT_AND tree into a pred_chain.\n   Example:\n \n@@ -1846,7 +1846,7 @@ simplify_preds (pred_chain_union *preds, gimple *use_or_def, bool is_use)\n \n  then _t != 0 will be normalized into a pred_chain:\n    (_2 RELOP1 _1) AND (_5 RELOP2 _4) AND (_8 RELOP3 _7) AND (_0 != 0)\n-   \n+\n   */\n \n /* This is a helper function that stores a PRED into NORM_PREDS.  */\n@@ -1864,7 +1864,7 @@ push_pred (pred_chain_union *norm_preds, pred_info pred)\n \n inline static void\n push_to_worklist (tree op, vec<pred_info, va_heap, vl_ptr> *work_list,\n-                  hash_set<tree> *mark_set)\n+\t\t  hash_set<tree> *mark_set)\n {\n   if (mark_set->contains (op))\n     return;\n@@ -1925,76 +1925,76 @@ is_degenerated_phi (gimple *phi, pred_info *pred_p)\n       tree op = gimple_phi_arg_def (phi, i);\n \n       if (TREE_CODE (op) != SSA_NAME)\n-        return false;\n+\treturn false;\n \n       def = SSA_NAME_DEF_STMT (op);\n       if (gimple_code (def) != GIMPLE_ASSIGN)\n-        return false;\n+\treturn false;\n       if (TREE_CODE_CLASS (gimple_assign_rhs_code (def))\n-          != tcc_comparison)\n-        return false;\n+\t  != tcc_comparison)\n+\treturn false;\n       pred = get_pred_info_from_cmp (def);\n       if (!pred_equal_p (pred, pred0))\n-        return false;\n+\treturn false;\n     }\n \n   *pred_p = pred0;\n   return true;\n }\n \n-/* Normalize one predicate PRED  \n+/* Normalize one predicate PRED\n    1) if PRED can no longer be normlized, put it into NORM_PREDS.\n    2) otherwise if PRED is of the form x != 0, follow x's definition\n       and put normalized predicates into WORK_LIST.  */\n- \n+\n static void\n-normalize_one_pred_1 (pred_chain_union *norm_preds, \n-                      pred_chain *norm_chain,\n-                      pred_info pred,\n-                      enum tree_code and_or_code,\n-                      vec<pred_info, va_heap, vl_ptr> *work_list,\n+normalize_one_pred_1 (pred_chain_union *norm_preds,\n+\t\t      pred_chain *norm_chain,\n+\t\t      pred_info pred,\n+\t\t      enum tree_code and_or_code,\n+\t\t      vec<pred_info, va_heap, vl_ptr> *work_list,\n \t\t      hash_set<tree> *mark_set)\n {\n   if (!is_neq_zero_form_p (pred))\n     {\n       if (and_or_code == BIT_IOR_EXPR)\n-        push_pred (norm_preds, pred);\n+\tpush_pred (norm_preds, pred);\n       else\n-        norm_chain->safe_push (pred);\n+\tnorm_chain->safe_push (pred);\n       return;\n     }\n \n   gimple *def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n- \n+\n   if (gimple_code (def_stmt) == GIMPLE_PHI\n       && is_degenerated_phi (def_stmt, &pred))\n     work_list->safe_push (pred);\n   else if (gimple_code (def_stmt) == GIMPLE_PHI\n-           && and_or_code == BIT_IOR_EXPR)\n+\t   && and_or_code == BIT_IOR_EXPR)\n     {\n       int i, n;\n       n = gimple_phi_num_args (def_stmt);\n \n       /* If we see non zero constant, we should punt. The predicate\n        * should be one guarding the phi edge.  */\n       for (i = 0; i < n; ++i)\n-        {\n-          tree op = gimple_phi_arg_def (def_stmt, i);\n-          if (TREE_CODE (op) == INTEGER_CST && !integer_zerop (op))\n-            {\n-              push_pred (norm_preds, pred);\n-              return;\n-            }\n-        }\n+\t{\n+\t  tree op = gimple_phi_arg_def (def_stmt, i);\n+\t  if (TREE_CODE (op) == INTEGER_CST && !integer_zerop (op))\n+\t    {\n+\t      push_pred (norm_preds, pred);\n+\t      return;\n+\t    }\n+\t}\n \n       for (i = 0; i < n; ++i)\n-        {\n-          tree op = gimple_phi_arg_def (def_stmt, i);\n-          if (integer_zerop (op))\n-            continue;\n+\t{\n+\t  tree op = gimple_phi_arg_def (def_stmt, i);\n+\t  if (integer_zerop (op))\n+\t    continue;\n \n-          push_to_worklist (op, work_list, mark_set);\n-        }\n+\t  push_to_worklist (op, work_list, mark_set);\n+\t}\n     }\n   else if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n     {\n@@ -2047,7 +2047,7 @@ normalize_one_pred_1 (pred_chain_union *norm_preds,\n \n static void\n normalize_one_pred (pred_chain_union *norm_preds,\n-                    pred_info pred)\n+\t\t    pred_info pred)\n {\n   vec<pred_info, va_heap, vl_ptr> work_list = vNULL;\n   enum tree_code and_or_code = ERROR_MARK;\n@@ -2066,13 +2066,13 @@ normalize_one_pred (pred_chain_union *norm_preds,\n       && and_or_code != BIT_AND_EXPR)\n     {\n       if (TREE_CODE_CLASS (and_or_code)\n-          == tcc_comparison)\n-        {\n-          pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n-          push_pred (norm_preds, n_pred);\n-        } \n+\t  == tcc_comparison)\n+\t{\n+\t  pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n+\t  push_pred (norm_preds, n_pred);\n+\t}\n        else\n-          push_pred (norm_preds, pred);\n+\t  push_pred (norm_preds, pred);\n       return;\n     }\n \n@@ -2083,7 +2083,7 @@ normalize_one_pred (pred_chain_union *norm_preds,\n     {\n       pred_info a_pred = work_list.pop ();\n       normalize_one_pred_1 (norm_preds, &norm_chain, a_pred,\n-                            and_or_code, &work_list, &mark_set);\n+\t\t\t    and_or_code, &work_list, &mark_set);\n     }\n   if (and_or_code == BIT_AND_EXPR)\n     norm_preds->safe_push (norm_chain);\n@@ -2093,7 +2093,7 @@ normalize_one_pred (pred_chain_union *norm_preds,\n \n static void\n normalize_one_pred_chain (pred_chain_union *norm_preds,\n-                          pred_chain one_chain)\n+\t\t\t  pred_chain one_chain)\n {\n   vec<pred_info, va_heap, vl_ptr> work_list = vNULL;\n   hash_set<tree> mark_set;\n@@ -2110,7 +2110,7 @@ normalize_one_pred_chain (pred_chain_union *norm_preds,\n     {\n       pred_info a_pred = work_list.pop ();\n       normalize_one_pred_1 (0, &norm_chain, a_pred,\n-                            BIT_AND_EXPR, &work_list, &mark_set);\n+\t\t\t    BIT_AND_EXPR, &work_list, &mark_set);\n     }\n \n   norm_preds->safe_push (norm_chain);\n@@ -2135,12 +2135,12 @@ normalize_preds (pred_chain_union preds, gimple *use_or_def, bool is_use)\n   for (i = 0; i < n; i++)\n     {\n       if (preds[i].length () != 1)\n-        normalize_one_pred_chain (&norm_preds, preds[i]);\n+\tnormalize_one_pred_chain (&norm_preds, preds[i]);\n       else\n-        {\n-          normalize_one_pred (&norm_preds, preds[i][0]);\n-          preds[i].release ();\n-        }\n+\t{\n+\t  normalize_one_pred (&norm_preds, preds[i][0]);\n+\t  preds[i].release ();\n+\t}\n     }\n \n   if (dump_file)\n@@ -2177,11 +2177,11 @@ normalize_preds (pred_chain_union preds, gimple *use_or_def, bool is_use)\n \n static bool\n is_use_properly_guarded (gimple *use_stmt,\n-                         basic_block use_bb,\n-                         gphi *phi,\n-                         unsigned uninit_opnds,\n+\t\t\t basic_block use_bb,\n+\t\t\t gphi *phi,\n+\t\t\t unsigned uninit_opnds,\n \t\t\t pred_chain_union *def_preds,\n-                         hash_set<gphi *> *visited_phis)\n+\t\t\t hash_set<gphi *> *visited_phis)\n {\n   basic_block phi_bb;\n   pred_chain_union preds = vNULL;\n@@ -2249,7 +2249,7 @@ is_use_properly_guarded (gimple *use_stmt,\n \n static gimple *\n find_uninit_use (gphi *phi, unsigned uninit_opnds,\n-                 vec<gphi *> *worklist,\n+\t\t vec<gphi *> *worklist,\n \t\t hash_set<gphi *> *added_to_worklist)\n {\n   tree phi_result;\n@@ -2281,10 +2281,10 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds,\n \tcontinue;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-        {\n-          fprintf (dump_file, \"[CHECK]: Found unguarded use: \");\n-          print_gimple_stmt (dump_file, use_stmt, 0, 0);\n-        }\n+\t{\n+\t  fprintf (dump_file, \"[CHECK]: Found unguarded use: \");\n+\t  print_gimple_stmt (dump_file, use_stmt, 0, 0);\n+\t}\n       /* Found one real use, return.  */\n       if (gimple_code (use_stmt) != GIMPLE_PHI)\n \t{\n@@ -2293,18 +2293,18 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds,\n \t}\n \n       /* Found a phi use that is not guarded,\n-         add the phi to the worklist.  */\n+\t add the phi to the worklist.  */\n       if (!added_to_worklist->add (as_a <gphi *> (use_stmt)))\n-        {\n-          if (dump_file && (dump_flags & TDF_DETAILS))\n-            {\n-              fprintf (dump_file, \"[WORKLIST]: Update worklist with phi: \");\n-              print_gimple_stmt (dump_file, use_stmt, 0, 0);\n-            }\n-\n-          worklist->safe_push (as_a <gphi *> (use_stmt));\n-          possibly_undefined_names->add (phi_result);\n-        }\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"[WORKLIST]: Update worklist with phi: \");\n+\t      print_gimple_stmt (dump_file, use_stmt, 0, 0);\n+\t    }\n+\n+\t  worklist->safe_push (as_a <gphi *> (use_stmt));\n+\t  possibly_undefined_names->add (phi_result);\n+\t}\n     }\n \n   destroy_predicate_vecs (&def_preds);\n@@ -2321,7 +2321,7 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds,\n \n static void\n warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n-                        hash_set<gphi *> *added_to_worklist)\n+\t\t\thash_set<gphi *> *added_to_worklist)\n {\n   unsigned uninit_opnds;\n   gimple *uninit_use_stmt = 0;\n@@ -2346,7 +2346,7 @@ warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n \n   /* Now check if we have any use of the value without proper guard.  */\n   uninit_use_stmt = find_uninit_use (phi, uninit_opnds,\n-                                     worklist, added_to_worklist);\n+\t\t\t\t     worklist, added_to_worklist);\n \n   /* All uses are properly guarded.  */\n   if (!uninit_use_stmt)\n@@ -2362,8 +2362,8 @@ warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n     loc = UNKNOWN_LOCATION;\n   warn_uninit (OPT_Wmaybe_uninitialized, uninit_op, SSA_NAME_VAR (uninit_op),\n \t       SSA_NAME_VAR (uninit_op),\n-               \"%qD may be used uninitialized in this function\",\n-               uninit_use_stmt, loc);\n+\t       \"%qD may be used uninitialized in this function\",\n+\t       uninit_use_stmt, loc);\n \n }\n "}]}