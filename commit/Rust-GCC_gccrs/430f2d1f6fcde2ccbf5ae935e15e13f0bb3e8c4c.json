{"sha": "430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMwZjJkMWY2ZmNkZTJjY2JmNWFlOTM1ZTE1ZTEzZjBiYjNlOGM0Yw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-02-05T05:28:37Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-02-05T05:28:37Z"}, "message": "re PR fortran/42309 (Problem with a pointer array passed to a subroutine)\n\n2010-02-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42309\n\t* trans-expr.c (gfc_conv_subref_array_arg): Add new argument\n\t'formal_ptr'. If this is true, give returned descriptor unity\n\tlbounds, in all dimensions, and the appropriate offset.\n\t(gfc_conv_procedure_call); If formal is a pointer, set the last\n\targument of gfc_conv_subref_array_arg to true.\n\t* trans.h : Add last argument for gfc_conv_subref_array_arg.\n\t* trans-io.c (set_internal_unit, gfc_trans_transfer): Set the\n\tnew arg of gfc_conv_subref_array_arg to false.\n\t* trans-stmt.c (forall_make_variable_temp): The same.\n\n2010-02-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42309\n\t* gfortran.dg/subref_array_pointer_4.f90 : New test.\n\nFrom-SVN: r156512", "tree": {"sha": "9ce142b33f6bfd6ae121c00b831210a43bbbf320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ce142b33f6bfd6ae121c00b831210a43bbbf320"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/comments", "author": null, "committer": null, "parents": [{"sha": "e7da179e4d159e5e7efef8459b97463e70161f37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7da179e4d159e5e7efef8459b97463e70161f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7da179e4d159e5e7efef8459b97463e70161f37"}], "stats": {"total": 98, "additions": 91, "deletions": 7}, "files": [{"sha": "6d52e5d46ac8d5b48b11ac3c6b11f9f17c0230ca", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "patch": "@@ -1,3 +1,16 @@\n+2010-02-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42309\n+\t* trans-expr.c (gfc_conv_subref_array_arg): Add new argument\n+\t'formal_ptr'. If this is true, give returned descriptor unity\n+\tlbounds, in all dimensions, and the appropriate offset.\n+\t(gfc_conv_procedure_call); If formal is a pointer, set the last\n+\targument of gfc_conv_subref_array_arg to true.\n+\t* trans.h : Add last argument for gfc_conv_subref_array_arg.\n+\t* trans-io.c (set_internal_unit, gfc_trans_transfer): Set the\n+\tnew arg of gfc_conv_subref_array_arg to false.\n+\t* trans-stmt.c (forall_make_variable_temp): The same.\n+\n 2010-02-03  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/42936"}, {"sha": "4a70e739e4a73fa9ef4f1a85ff8b9278a08114ee", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "patch": "@@ -2294,8 +2294,8 @@ gfc_apply_interface_mapping (gfc_interface_mapping * mapping,\n    an actual argument derived type array is copied and then returned\n    after the function call.  */\n void\n-gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n-\t\t\t   int g77, sym_intent intent)\n+gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n+\t\t\t   sym_intent intent, bool formal_ptr)\n {\n   gfc_se lse;\n   gfc_se rse;\n@@ -2308,6 +2308,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n   tree tmp_index;\n   tree tmp;\n   tree base_type;\n+  tree size;\n   stmtblock_t body;\n   int n;\n \n@@ -2501,6 +2502,42 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n   if (expr->ts.type == BT_CHARACTER)\n     parmse->string_length = expr->ts.u.cl->backend_decl;\n \n+  /* Determine the offset for pointer formal arguments and set the\n+     lbounds to one.  */\n+  if (formal_ptr)\n+    {\n+      size = gfc_index_one_node;\n+      offset = gfc_index_zero_node;  \n+      for (n = 0; n < info->dimen; n++)\n+\t{\n+\t  tmp = gfc_conv_descriptor_ubound_get (parmse->expr,\n+\t\t\t\t\t\tgfc_rank_cst[n]);\n+\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+\t  gfc_conv_descriptor_ubound_set (&parmse->pre,\n+\t\t\t\t\t  parmse->expr,\n+\t\t\t\t\t  gfc_rank_cst[n],\n+\t\t\t\t\t  tmp);\n+\t  gfc_conv_descriptor_lbound_set (&parmse->pre,\n+\t\t\t\t\t  parmse->expr,\n+\t\t\t\t\t  gfc_rank_cst[n],\n+\t\t\t\t\t  gfc_index_one_node);\n+\t  size = gfc_evaluate_now (size, &parmse->pre);\n+\t  offset = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\toffset, size);\n+\t  offset = gfc_evaluate_now (offset, &parmse->pre);\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     rse.loop->to[n], rse.loop->from[n]);\n+\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+\t  size = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t      size, tmp);\n+\t}\n+\n+      gfc_conv_descriptor_offset_set (&parmse->pre, parmse->expr,\n+\t\t\t\t      offset);\n+    }\n+\n   /* We want either the address for the data or the address of the descriptor,\n      depending on the mode of passing array arguments.  */\n   if (g77)\n@@ -3005,7 +3042,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t   is converted to a temporary, which is passed and then\n \t\t   written back after the procedure call.  */\n \t\tgfc_conv_subref_array_arg (&parmse, e, f,\n-\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT);\n+\t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n+\t\t\t\tfsym && fsym->attr.pointer);\n \t      else\n \t        gfc_conv_array_parameter (&parmse, e, argss, f, fsym,\n \t\t\t\t\t  sym->name, NULL);"}, {"sha": "30561bb168ec7363f78b9bd119ed4f73c6b3a3a8", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "patch": "@@ -741,7 +741,7 @@ set_internal_unit (stmtblock_t * block, stmtblock_t * post_block,\n \t  /* Use a temporary for components of arrays of derived types\n \t     or substring array references.  */\n \t  gfc_conv_subref_array_arg (&se, e, 0,\n-\t\tlast_dt == READ ? INTENT_IN : INTENT_OUT);\n+\t\tlast_dt == READ ? INTENT_IN : INTENT_OUT, false);\n \t  tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t se.expr);\n \t  se.expr = gfc_build_addr_expr (pchar_type_node, tmp);\n@@ -2211,7 +2211,7 @@ gfc_trans_transfer (gfc_code * code)\n \t  if (seen_vector && last_dt == READ)\n \t    {\n \t      /* Create a temp, read to that and copy it back.  */\n-\t      gfc_conv_subref_array_arg (&se, expr, 0, INTENT_OUT);\n+\t      gfc_conv_subref_array_arg (&se, expr, 0, INTENT_OUT, false);\n \t      tmp =  se.expr;\n \t    }\n \t  else"}, {"sha": "84c3c85ead48bcc879601ce987373f70bc965e9e", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "patch": "@@ -1800,7 +1800,7 @@ forall_make_variable_temp (gfc_code *c, stmtblock_t *pre, stmtblock_t *post)\n   if (old_sym->attr.dimension)\n     {\n       gfc_init_se (&tse, NULL);\n-      gfc_conv_subref_array_arg (&tse, e, 0, INTENT_IN);\n+      gfc_conv_subref_array_arg (&tse, e, 0, INTENT_IN, false);\n       gfc_add_block_to_block (pre, &tse.pre);\n       gfc_add_block_to_block (post, &tse.post);\n       tse.expr = build_fold_indirect_ref_loc (input_location, tse.expr);"}, {"sha": "30a775311b2e10f50df219225724c91c7c243b80", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "patch": "@@ -315,7 +315,7 @@ int gfc_is_intrinsic_libcall (gfc_expr *);\n int gfc_conv_procedure_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n \t\t\t    gfc_expr *, tree);\n \n-void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent);\n+void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent, bool);\n \n /* gfc_trans_* shouldn't call push/poplevel, use gfc_push/pop_scope */\n "}, {"sha": "94ccbc4266afc0dd4d7aeb24895d476172055d59", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "patch": "@@ -1,3 +1,8 @@\n+2010-02-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42309\n+\t* gfortran.dg/subref_array_pointer_4.f90 : New test.\n+\n 2010-02-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR rtl-optimization/42952"}, {"sha": "19edfdca98af1a8059aa502121f8af7d3c70bcbf", "filename": "gcc/testsuite/gfortran.dg/subref_array_pointer_4.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubref_array_pointer_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubref_array_pointer_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubref_array_pointer_4.f90?ref=430f2d1f6fcde2ccbf5ae935e15e13f0bb3e8c4c", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+! Tests the fix for PR42309, in which the indexing of 'Q'\n+! was off by one.\n+!\n+! Contributed by Gilbert Scott <gilbert.scott@easynet.co.uk>\n+!\n+PROGRAM X\n+  TYPE T\n+    INTEGER :: I\n+    REAL :: X\n+  END TYPE T\n+  TYPE(T), TARGET :: T1(0:3)\n+  INTEGER, POINTER :: P(:)\n+  REAL :: SOURCE(4) = [10., 20., 30., 40.]\n+\n+  T1%I = [1, 2, 3, 4]\n+  T1%X = SOURCE\n+  P => T1%I\n+  CALL Z(P)\n+  IF (ANY (T1%I .NE. [999, 2, 999, 4])) CALL ABORT\n+  IF (ANY (T1%X .NE. SOURCE)) CALL ABORT\n+CONTAINS\n+  SUBROUTINE Z(Q)\n+    INTEGER, POINTER :: Q(:)\n+    Q(1:3:2) = 999\n+  END SUBROUTINE Z\n+END PROGRAM X\n+"}]}