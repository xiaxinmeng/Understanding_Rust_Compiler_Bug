{"sha": "6303eee4b92e8509409503a3abebde8bd50f0f05", "node_id": "C_kwDOANBUbNoAKDYzMDNlZWU0YjkyZTg1MDk0MDk1MDNhM2FiZWJkZThiZDUwZjBmMDU", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-09T15:48:25Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-13T11:20:49Z"}, "message": "c++: Separate late stage module writing\n\nThis moves some module writing into a newly added write_end function,\nwhich is called after writing initializers.\n\n\tgcc/cp/\n\t* module.cc (module_state::write): Separate to ...\n\t(module_state::write_begin, module_state::write_end): ...\n\tthese.\n\t(module_state::write_readme): Drop extensions parameter.\n\t(struct module_processing_cookie): Add more fields.\n\t(finish_module_processing): Adjust state writing call.\n\t(late_finish_module): Call write_end.", "tree": {"sha": "a86e0310572cb9f80640e230935470024e8008bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a86e0310572cb9f80640e230935470024e8008bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6303eee4b92e8509409503a3abebde8bd50f0f05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6303eee4b92e8509409503a3abebde8bd50f0f05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6303eee4b92e8509409503a3abebde8bd50f0f05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6303eee4b92e8509409503a3abebde8bd50f0f05/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0"}], "stats": {"total": 47, "additions": 30, "deletions": 17}, "files": [{"sha": "e7ce40ef464c534cb6c5f6876a851a0bf1ddc099", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6303eee4b92e8509409503a3abebde8bd50f0f05/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6303eee4b92e8509409503a3abebde8bd50f0f05/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=6303eee4b92e8509409503a3abebde8bd50f0f05", "patch": "@@ -3523,7 +3523,10 @@ class GTY((chain_next (\"%h.parent\"), for_user)) module_state {\n \n  public:\n   /* Read and write module.  */\n-  void write (elf_out *to, cpp_reader *);\n+  void write_begin (elf_out *to, cpp_reader *,\n+\t\t    module_state_config &, unsigned &crc);\n+  void write_end (elf_out *to, cpp_reader *,\n+\t\t  module_state_config &, unsigned &crc);\n   bool read_initial (cpp_reader *);\n   bool read_preprocessor (bool);\n   bool read_language (bool);\n@@ -3545,8 +3548,7 @@ class GTY((chain_next (\"%h.parent\"), for_user)) module_state {\n \n  private:\n   /* The README, for human consumption.  */\n-  void write_readme (elf_out *to, cpp_reader *,\n-\t\t     const char *dialect, unsigned extensions);\n+  void write_readme (elf_out *to, cpp_reader *, const char *dialect);\n   void write_env (elf_out *to);\n \n  private:\n@@ -13954,8 +13956,7 @@ module_state::announce (const char *what) const\n      readelf -pgnu.c++.README $(module).gcm */\n \n void\n-module_state::write_readme (elf_out *to, cpp_reader *reader,\n-\t\t\t    const char *dialect, unsigned extensions)\n+module_state::write_readme (elf_out *to, cpp_reader *reader, const char *dialect)\n {\n   bytes_out readme (to);\n \n@@ -17560,7 +17561,8 @@ ool_cmp (const void *a_, const void *b_)\n */\n \n void\n-module_state::write (elf_out *to, cpp_reader *reader)\n+module_state::write_begin (elf_out *to, cpp_reader *reader,\n+\t\t\t   module_state_config &config, unsigned &crc)\n {\n   /* Figure out remapped module numbers, which might elide\n      partitions.  */\n@@ -17656,8 +17658,6 @@ module_state::write (elf_out *to, cpp_reader *reader)\n     }\n   ool->qsort (ool_cmp);\n \n-  unsigned crc = 0;\n-  module_state_config config;\n   location_map_info map_info = write_prepare_maps (&config);\n   unsigned counts[MSC_HWM];\n \n@@ -17811,28 +17811,35 @@ module_state::write (elf_out *to, cpp_reader *reader)\n   unsigned clusters = counts[MSC_sec_hwm] - counts[MSC_sec_lwm];\n   dump () && dump (\"Wrote %u clusters, average %u bytes/cluster\",\n \t\t   clusters, (bytes + clusters / 2) / (clusters + !clusters));\n+  trees_out::instrument ();\n \n   write_counts (to, counts, &crc);\n \n-  /* And finish up.  */\n-  write_config (to, config, crc);\n-\n   spaces.release ();\n   sccs.release ();\n \n   vec_free (ool);\n \n-  /* Human-readable info.  */\n-  write_readme (to, reader, config.dialect_str, extensions);\n-\n   // FIXME:QOI:  Have a command line switch to control more detailed\n   // information (which might leak data you do not want to leak).\n   // Perhaps (some of) the write_readme contents should also be\n   // so-controlled.\n   if (false)\n     write_env (to);\n+}\n+\n+// Finish module writing after we've emitted all dynamic initializers. \n+\n+void\n+module_state::write_end (elf_out *to, cpp_reader *reader,\n+\t\t\t module_state_config &config, unsigned &crc)\n+{\n+  /* And finish up.  */\n+  write_config (to, config, crc);\n+\n+  /* Human-readable info.  */\n+  write_readme (to, reader, config.dialect_str);\n \n-  trees_out::instrument ();\n   dump () && dump (\"Wrote %u sections\", to->get_section_limit ());\n }\n \n@@ -19855,15 +19862,18 @@ maybe_check_all_macros (cpp_reader *reader)\n }\n \n // State propagated from finish_module_processing to fini_modules\n+\n struct module_processing_cookie\n {\n   elf_out out;\n+  module_state_config config;\n   char *cmi_name;\n   char *tmp_name;\n+  unsigned crc;\n   bool began;\n \n   module_processing_cookie (char *cmi, char *tmp, int fd, int e)\n-    : out (fd, e), cmi_name (cmi), tmp_name (tmp), began (false)\n+    : out (fd, e), cmi_name (cmi), tmp_name (tmp), crc (0), began (false)\n   {\n   }\n   ~module_processing_cookie ()\n@@ -19941,7 +19951,7 @@ finish_module_processing (cpp_reader *reader)\n \t  auto loc = input_location;\n \t  /* So crashes finger-point the module decl.  */\n \t  input_location = state->loc;\n-\t  state->write (&cookie->out, reader);\n+\t  state->write_begin (&cookie->out, reader, cookie->config, cookie->crc);\n \t  input_location = loc;\n \t}\n \n@@ -19977,6 +19987,9 @@ late_finish_module (cpp_reader *reader, module_processing_cookie *cookie)\n   unsigned n = dump.push (state);\n   state->announce (\"finishing\");\n \n+  if (cookie->began)\n+    state->write_end (&cookie->out, reader, cookie->config, cookie->crc);\n+\n   if (cookie->out.end () && cookie->cmi_name)\n     {\n       /* Some OS's do not replace NEWNAME if it already exists."}]}