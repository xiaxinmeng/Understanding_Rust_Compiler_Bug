{"sha": "aa9ec4db5f08f659b904199129d3c5e52564df49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE5ZWM0ZGI1ZjA4ZjY1OWI5MDQxOTkxMjlkM2M1ZTUyNTY0ZGY0OQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-01-24T12:38:52Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-01-24T12:38:52Z"}, "message": "re PR target/49868 (Implement named address space to place/access data in flash memory)\n\n\tPR target/49868\n\t* doc/extend.texi (AVR Named Address Spaces): Move sample code up.\n\tRemove note on size/offset limitation.\n\t(AVR Variable Attributes): Add example how to read data located\n\twith progmem.  Refer to named address spaces.\n\t* doc/invoke.texi (AVR Options): Fix typo.\n\nFrom-SVN: r183473", "tree": {"sha": "5ba53142f8058b38661189947d5f1d5ca6fa1ae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ba53142f8058b38661189947d5f1d5ca6fa1ae9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa9ec4db5f08f659b904199129d3c5e52564df49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9ec4db5f08f659b904199129d3c5e52564df49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa9ec4db5f08f659b904199129d3c5e52564df49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9ec4db5f08f659b904199129d3c5e52564df49/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cc35b68d5fe7ec32079ec56098f2a7f77893586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc35b68d5fe7ec32079ec56098f2a7f77893586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc35b68d5fe7ec32079ec56098f2a7f77893586"}], "stats": {"total": 127, "additions": 71, "deletions": 56}, "files": [{"sha": "4f274190481914071d535cb58e3cfc4744df6ef1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9ec4db5f08f659b904199129d3c5e52564df49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9ec4db5f08f659b904199129d3c5e52564df49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa9ec4db5f08f659b904199129d3c5e52564df49", "patch": "@@ -1,3 +1,12 @@\n+2012-01-24  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/49868\n+\t* doc/extend.texi (AVR Named Address Spaces): Move sample code up.\n+\tRemove note on size/offset limitation.\n+\t(AVR Variable Attributes): Add example how to read data located\n+\twith progmem.  Refer to named address spaces.\n+\t* doc/invoke.texi (AVR Options): Fix typo.\n+\n 2012-01-24  Richard Guenther  <rguenther@suse.de>\n \n \tForward-port to trunk"}, {"sha": "229e87c2493ec77137436e9de577a891c6a309fe", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 59, "deletions": 53, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9ec4db5f08f659b904199129d3c5e52564df49/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9ec4db5f08f659b904199129d3c5e52564df49/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=aa9ec4db5f08f659b904199129d3c5e52564df49", "patch": "@@ -1237,9 +1237,10 @@ in order to put read-only data into the flash memory and access that\n data by means of the special instructions @code{LPM} or @code{ELPM}\n needed to read from flash.\n \n-Per default, any data including read-only data is located in RAM so\n-that address spaces are needed to locate read-only data in flash memory\n-@emph{and} to generate the right instructions to access the data\n+Per default, any data including read-only data is located in RAM\n+(the generic address space) so that non-generic address spaces are\n+needed to locate read-only data in flash memory\n+@emph{and} to generate the right instructions to access this data\n without using (inline) assembler code.\n \n @table @code\n@@ -1265,9 +1266,9 @@ address space @code{__pgm@var{N}}.\n The compiler will set the @code{RAMPZ} segment register approptiately \n before reading data by means of the @code{ELPM} instruction.\n \n-On devices with less 64kiB flash segments as indicated by the address\n+On devices with less 64@tie{}kiB flash segments as indicated by the address\n space, the compiler will cut down the segment number to a number the\n-device actually supports. Counting starts at @code{0}\n+device actually supports. Counting starts at@tie{}@code{0}\n for space @code{__pgm}. For example, if you access address space\n @code{__pgm3} on an ATmega128 device with two 64@tie{}kiB flash segments,\n the compiler will generate a read from @code{__pgm1}, i.e.@: it\n@@ -1284,6 +1285,31 @@ with @code{RAMPZ} set according to the high byte of the address.\n Objects in this address space will be located in @code{.progmem.data}.\n @end table\n \n+@b{Example}\n+\n+@example\n+char my_read (const __pgm char ** p)\n+@{\n+    /* p is a pointer to RAM that points to a pointer to flash.\n+       The first indirection of p will read that flash pointer\n+       from RAM and the second indirection reads a char from this\n+       flash address.  */\n+\n+    return **p;\n+@}\n+\n+/* Locate array[] in flash memory */\n+const __pgm int array[] = @{ 3, 5, 7, 11, 13, 17, 19 @};\n+\n+int i = 1;\n+\n+int main (void)\n+@{\n+   /* Return 17 by reading from flash memory */\n+   return array[array[i]];\n+@}\n+@end example\n+\n For each named address space supported by avr-gcc there is an equally\n named but uppercase built-in macro defined. \n The purpose is to facilitate testing if respective address space\n@@ -1311,8 +1337,9 @@ int read_i (void)\n \n Notice that attribute @ref{AVR Variable Attributes,@code{progmem}}\n locates data in flash but\n-accesses to these data will be to generic address space, i.e.@: RAM,\n-so that you need special access functions like @code{pgm_read_byte}\n+accesses to these data will read from generic address space, i.e.@:\n+from RAM,\n+so that you need special accessors like @code{pgm_read_byte}\n from @w{@uref{http://nongnu.org/avr-libc/user-manual,avr-libc}}.\n \n @b{Limitations and caveats}\n@@ -1331,10 +1358,10 @@ you will have to arrange your linker skript to locate the\n @code{.progmem@var{N}.data} sections according to your needs.\n \n @item\n-Any data or pointers to the AVR address spaces spaces must\n-also be qualified as @code{const}, i.e.@: as read-only data.\n+Any data or pointers to the non-generic address spaces must\n+be qualified as @code{const}, i.e.@: as read-only data.\n This still applies if the data in one of these address\n-spaces like software version number or lookup tables are intended to\n+spaces like software version number or calibration lookup table are intended to\n be changed after load time by, say, a boot loader. In this case\n the right qualification is @code{const} @code{volatile} so that the compiler\n must not optimize away known values or insert them\n@@ -1349,52 +1376,12 @@ extern const __pgmx char foo;\n const __pgmx void *pfoo = &foo;\n @end example\n The code will throw an assembler warning and the high byte of\n-@code{pfoo} will be initialized with @code{0}, i.e.@: the\n+@code{pfoo} will be initialized with@tie{}@code{0}, i.e.@: the\n initialization will be as if @code{foo} was located in the first\n 64@tie{}KiB chunk of flash.\n \n-@item\n-Address arithmetic for the @code{__pgmx} address space is carried out\n-as 16-bit signed integer arithmetic. This means that in the following\n-code array positions with offsets @code{idx}@tie{}>@tie{}8191 are\n-inaccessible.\n-\n-@example\n-extern const __pgmx long lookup[];\n-\n-long read_lookup (unsigned idx)\n-@{\n-    return lookup[idx];\n-@}\n-@end example\n-\n @end itemize\n \n-@b{Example}\n-\n-@example\n-char my_read (const __pgm ** p)\n-@{\n-    /* p is a pointer to RAM that points to a pointer to flash.\n-       The first indirection of p will read that flash pointer\n-       from RAM and the second indirection reads a char from this\n-       flash address.  */\n-\n-    return **p;\n-@}\n-\n-/* Locate array[] in flash memory */\n-const __pgm int array[] = @{ 3, 5, 7, 11, 13, 17, 19 @};\n-\n-int i = 1;\n-\n-int main (void)\n-@{\n-   /* Return 17 by reading from flash memory */\n-   return array[array[i]];\n-@}\n-@end example\n-\n @subsection M32C Named Address Spaces\n @cindex @code{__far} M32C Named Address Spaces\n \n@@ -3235,7 +3222,7 @@ is entered like for, e@.g@. task functions in a multi-threading operating\n system. In that case, changing the stack pointer register will be\n guarded by save/clear/restore of the global interrupt enable flag.\n \n-The differences to the @code{naked} function attrubute are:\n+The differences to the @code{naked} function attribute are:\n @itemize @bullet\n @item @code{naked} functions do not have a return instruction whereas \n @code{OS_main} and @code{OS_task} functions will have a @code{RET} or\n@@ -4752,13 +4739,32 @@ data in the non-volatile program memory (flash). The @code{progmem}\n attribute accomplishes this by putting respective variables into a\n section whose name starts with @code{.progmem}.\n \n-This attrubute wirks similar to the @code{section} attribute\n+This attribute works similar to the @code{section} attribute\n but adds additional checking. Notice that just like the\n @code{section} attribute, @code{progmem} affects the location\n of the data but not how this data is accessed.\n \n+In order to read data located with the @code{progmem} attribute\n+(inline) assembler must be used.\n+@example\n+/* Use custom macros from @w{@uref{http://nongnu.org/avr-libc/user-manual,avr-libc}} */\n+#include <avr/pgmspace.h> \n+\n+/* Locate var in flash memory */\n+const int var[2] PROGMEM = @{ 1, 2 @};\n+\n+int read_var (int i)\n+@{\n+    /* Access var[] by accessor macro from avr/pgmspace.h */\n+    return (int) pgm_read_word (& var[i]);\n+@}\n+@end example\n+\n AVR is a Harvard architecture processor and data and read-only data\n normally resides in the data memory (RAM).\n+\n+See also the @ref{AVR Named Address Spaces} section for\n+an alternate way to locate and access data in flash memory.\n @end table\n \n @subsection Blackfin Variable Attributes"}, {"sha": "e3d3789818a40677377bc481fd3cbd91bb37e0f5", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9ec4db5f08f659b904199129d3c5e52564df49/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9ec4db5f08f659b904199129d3c5e52564df49/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=aa9ec4db5f08f659b904199129d3c5e52564df49", "patch": "@@ -10973,11 +10973,11 @@ before calling a function and popped afterwards.\n \n Popping the arguments after the function call can be expensive on\n AVR so that accumulating the stack space might lead to smaller\n-executables because areguments need not to be removed from the\n+executables because arguments need not to be removed from the\n stack after such a function call.\n \n-This option can lead to reduced code size for functions that get\n-their arguments on the stack like functions that perform several\n+This option can lead to reduced code size for functions that perform\n+several calls to functions which get their arguments on the stack like\n calls to printf-like functions.\n \n @item -mbranch-cost=@var{cost}"}]}