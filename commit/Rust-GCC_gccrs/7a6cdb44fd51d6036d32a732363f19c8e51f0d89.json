{"sha": "7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E2Y2RiNDRmZDUxZDYwMzZkMzJhNzMyMzYzZjE5YzhlNTFmMGQ4OQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2003-05-27T18:44:57Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-05-27T18:44:57Z"}, "message": "tree.h (contains_placeholder_p): Now returns bool.\n\n\t* tree.h (contains_placeholder_p): Now returns bool.\n\t(CONTAINS_PLACEHOLDER_P): New macro.\n\t(type_contains_placeholder_p): New function.\n\t* tree.c (save_expr): Remove code avoiding folding COMPONENT_REF.\n\t(contains_placeholder_p): Now returns bool.\n\tRework to use CONTAINS_PLACEHOLDER_P macro.\n\t(type_contains_placeholder_p): New function.\n\t* fold-const.c (fold, case COMPONENT_REF): Don't fold if\n\ttype_contains_placeholder_p.\n\t(fold_range_test, fold_mathfn_compare, fold_inf_compare, fold):\n\tUse CONTAINS_PLACEHOLDER_P macro.\n\t* builtins.c (fold_builtin): Likewise.\n\t* calls.c (initialize_argument_information): Likewise.\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Likewise.\n\t* explow.c (expr_size): Likewise.\n\t* expr.c (store_constructor, get_inner_reference): Likewise.\n\t* function.c (assign_parms): Likewise.\n\t* stor-layout.c (variable_size): Likewise.\n\nFrom-SVN: r67189", "tree": {"sha": "6be268fb48b8e0a8cb871503b25decd003ae8522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6be268fb48b8e0a8cb871503b25decd003ae8522"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/comments", "author": null, "committer": null, "parents": [{"sha": "86982c71d17f2e9888e649fe5c88b65ff84561d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86982c71d17f2e9888e649fe5c88b65ff84561d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86982c71d17f2e9888e649fe5c88b65ff84561d8"}], "stats": {"total": 228, "additions": 176, "deletions": 52}, "files": [{"sha": "d56b572547de5358c3cb35965676f15e495b4554", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "patch": "@@ -1,3 +1,24 @@\n+2003-05027  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* tree.h (contains_placeholder_p): Now returns bool.\n+\t(CONTAINS_PLACEHOLDER_P): New macro.\n+\t(type_contains_placeholder_p): New function.\n+\t* tree.c (save_expr): Remove code avoiding folding COMPONENT_REF.\n+\t(contains_placeholder_p): Now returns bool.\n+\tRework to use CONTAINS_PLACEHOLDER_P macro.\n+\t(type_contains_placeholder_p): New function.\n+\t* fold-const.c (fold, case COMPONENT_REF): Don't fold if\n+\ttype_contains_placeholder_p.\n+\t(fold_range_test, fold_mathfn_compare, fold_inf_compare, fold): \n+\tUse CONTAINS_PLACEHOLDER_P macro.\n+\t* builtins.c (fold_builtin): Likewise.\n+\t* calls.c (initialize_argument_information): Likewise.\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Likewise.\n+\t* explow.c (expr_size): Likewise.\n+\t* expr.c (store_constructor, get_inner_reference): Likewise.\n+\t* function.c (assign_parms): Likewise.\n+\t* stor-layout.c (variable_size): Likewise.\n+\n 2003-05-25  Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n \t* diagnostic.h (output_verbatim, verbatim):  Remove  printf"}, {"sha": "eef1cce496c1c3b62c016f5dd30551facf18d4d9", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "patch": "@@ -5242,7 +5242,7 @@ fold_builtin (exp)\n \t      /* Optimize pow(x,2.0) = x*x.  */\n \t      if (REAL_VALUES_EQUAL (c, dconst2)\n \t\t  && (*lang_hooks.decls.global_bindings_p) () == 0\n-\t\t  && ! contains_placeholder_p (arg0))\n+\t\t  && ! CONTAINS_PLACEHOLDER_P (arg0))\n \t\t{\n \t\t  arg0 = save_expr (arg0);\n \t\t  return fold (build (MULT_EXPR, type, arg0, arg0));\n@@ -5252,7 +5252,7 @@ fold_builtin (exp)\n \t      if (flag_unsafe_math_optimizations\n \t\t  && REAL_VALUES_EQUAL (c, dconstm2)\n \t\t  && (*lang_hooks.decls.global_bindings_p) () == 0\n-\t\t  && ! contains_placeholder_p (arg0))\n+\t\t  && ! CONTAINS_PLACEHOLDER_P (arg0))\n \t\t{\n \t\t  arg0 = save_expr (arg0);\n \t\t  return fold (build (RDIV_EXPR, type,"}, {"sha": "9d7899c8bceebfb7d7cd9bf694aed3a95956cac9", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "patch": "@@ -1146,8 +1146,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t with those made by function.c.  */\n \n       /* See if this argument should be passed by invisible reference.  */\n-      if ((TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n-\t   && contains_placeholder_p (TYPE_SIZE (type)))\n+      if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (type))\n \t  || TREE_ADDRESSABLE (type)\n #ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n \t  || FUNCTION_ARG_PASS_BY_REFERENCE (*args_so_far, TYPE_MODE (type),"}, {"sha": "f568991934396a959bb168cf7396a4ed59f85658", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "patch": "@@ -1986,11 +1986,9 @@ set_mem_attributes_minus_bitpos (ref, t, objectp, bitpos)\n \t      /* If the index has a self-referential type, pass it to a\n \t\t WITH_RECORD_EXPR; if the component size is, pass our\n \t\t component to one.  */\n-\t      if (! TREE_CONSTANT (index)\n-\t\t  && contains_placeholder_p (index))\n+\t      if (CONTAINS_PLACEHOLDER_P (index))\n \t\tindex = build (WITH_RECORD_EXPR, TREE_TYPE (index), index, t);\n-\t      if (! TREE_CONSTANT (unit_size)\n-\t\t  && contains_placeholder_p (unit_size))\n+\t      if (CONTAINS_PLACEHOLDER_P (unit_size))\n \t\tunit_size = build (WITH_RECORD_EXPR, sizetype,\n \t\t\t\t   unit_size, array);\n "}, {"sha": "ec7a69a783366985eec5612d1e20f52fc95bc942", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "patch": "@@ -294,8 +294,7 @@ expr_size (exp)\n {\n   tree size = (*lang_hooks.expr_size) (exp);\n \n-  if (TREE_CODE (size) != INTEGER_CST\n-      && contains_placeholder_p (size))\n+  if (CONTAINS_PLACEHOLDER_P (size))\n     size = build (WITH_RECORD_EXPR, sizetype, size, exp);\n \n   return expand_expr (size, NULL_RTX, TYPE_MODE (sizetype), 0);"}, {"sha": "770bef4afa25b3f0b842d37b9509c0e15547e9b7", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "patch": "@@ -4982,7 +4982,7 @@ store_constructor (exp, target, cleared, size)\n \t    {\n \t      rtx offset_rtx;\n \n-\t      if (contains_placeholder_p (offset))\n+\t      if (CONTAINS_PLACEHOLDER_P (offset))\n \t\toffset = build (WITH_RECORD_EXPR, sizetype,\n \t\t\t\toffset, make_tree (TREE_TYPE (exp), target));\n \n@@ -5799,7 +5799,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t     made during type construction.  */\n \t  if (this_offset == 0)\n \t    break;\n-\t  else if (contains_placeholder_p (this_offset))\n+\t  else if (CONTAINS_PLACEHOLDER_P (this_offset))\n \t    this_offset = build (WITH_RECORD_EXPR, sizetype, this_offset, exp);\n \n \t  offset = size_binop (PLUS_EXPR, offset, this_offset);\n@@ -5829,9 +5829,9 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t  /* If the index has a self-referential type, pass it to a\n \t     WITH_RECORD_EXPR; if the component size is, pass our\n \t     component to one.  */\n-\t  if (contains_placeholder_p (index))\n+\t  if (CONTAINS_PLACEHOLDER_P (index))\n \t    index = build (WITH_RECORD_EXPR, TREE_TYPE (index), index, exp);\n-\t  if (contains_placeholder_p (unit_size))\n+\t  if (CONTAINS_PLACEHOLDER_P (unit_size))\n \t    unit_size = build (WITH_RECORD_EXPR, sizetype, unit_size, array);\n \n \t  offset = size_binop (PLUS_EXPR, offset,"}, {"sha": "381bc9cb959e97d8a8465d9f0d6a5240792df36b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "patch": "@@ -3470,7 +3470,7 @@ fold_range_test (exp)\n \t\t      TREE_OPERAND (exp, 1));\n \n       else if ((*lang_hooks.decls.global_bindings_p) () == 0\n-\t       && ! contains_placeholder_p (lhs))\n+\t       && ! CONTAINS_PLACEHOLDER_P (lhs))\n \t{\n \t  tree common = save_expr (lhs);\n \n@@ -4768,7 +4768,7 @@ fold_mathfn_compare (fcode, code, type, arg0, arg1)\n \n \t      /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n \t      if ((*lang_hooks.decls.global_bindings_p) () != 0\n-\t\t  || contains_placeholder_p (arg))\n+\t\t  || CONTAINS_PLACEHOLDER_P (arg))\n \t\treturn NULL_TREE;\n \n \t      arg = save_expr (arg);\n@@ -4788,7 +4788,7 @@ fold_mathfn_compare (fcode, code, type, arg0, arg1)\n \n \t  /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n \t  if ((*lang_hooks.decls.global_bindings_p) () == 0\n-\t      && ! contains_placeholder_p (arg))\n+\t      && ! CONTAINS_PLACEHOLDER_P (arg))\n \t    {\n \t      arg = save_expr (arg);\n \t      return fold (build (TRUTH_ANDIF_EXPR, type,\n@@ -4851,7 +4851,7 @@ fold_inf_compare (code, type, arg0, arg1)\n \n       /* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n       if ((*lang_hooks.decls.global_bindings_p) () == 0\n-\t  && ! contains_placeholder_p (arg0))\n+\t  && ! CONTAINS_PLACEHOLDER_P (arg0))\n \t{\n \t  arg0 = save_expr (arg0);\n \t  return fold (build (EQ_EXPR, type, arg0, arg0));\n@@ -5119,7 +5119,7 @@ fold (expr)\n \t\t   || count_cond (arg0, 25) + count_cond (arg1, 25) <= 25)\n \t       && (! TREE_SIDE_EFFECTS (arg0)\n \t\t   || ((*lang_hooks.decls.global_bindings_p) () == 0\n-\t\t       && ! contains_placeholder_p (arg0))))\n+\t\t       && ! CONTAINS_PLACEHOLDER_P (arg0))))\n \treturn\n \t  fold_binary_op_with_conditional_arg (code, type, arg1, arg0,\n \t\t\t\t\t       /*cond_first_p=*/0);\n@@ -5133,7 +5133,7 @@ fold (expr)\n \t\t   || count_cond (arg0, 25) + count_cond (arg1, 25) <= 25)\n \t       && (! TREE_SIDE_EFFECTS (arg1)\n \t\t   || ((*lang_hooks.decls.global_bindings_p) () == 0\n-\t\t       && ! contains_placeholder_p (arg1))))\n+\t\t       && ! CONTAINS_PLACEHOLDER_P (arg1))))\n \treturn\n \t  fold_binary_op_with_conditional_arg (code, type, arg0, arg1,\n \t\t\t\t\t       /*cond_first_p=*/1);\n@@ -5313,7 +5313,8 @@ fold (expr)\n       return t;\n \n     case COMPONENT_REF:\n-      if (TREE_CODE (arg0) == CONSTRUCTOR)\n+      if (TREE_CODE (arg0) == CONSTRUCTOR\n+\t  && ! type_contains_placeholder_p (TREE_TYPE (arg0)))\n \t{\n \t  tree m = purpose_member (arg1, CONSTRUCTOR_ELTS (arg0));\n \t  if (m)\n@@ -5883,7 +5884,7 @@ fold (expr)\n \t  /* x*2 is x+x */\n \t  if (! wins && real_twop (arg1)\n \t      && (*lang_hooks.decls.global_bindings_p) () == 0\n-\t      && ! contains_placeholder_p (arg0))\n+\t      && ! CONTAINS_PLACEHOLDER_P (arg0))\n \t    {\n \t      tree arg = save_expr (arg0);\n \t      return fold (build (PLUS_EXPR, type, arg, arg));"}, {"sha": "64d045b9b13f697418f7c9fcda65d369ed3b44bc", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "patch": "@@ -4494,8 +4494,7 @@ assign_parms (fndecl)\n \t object itself or if the machine requires these objects be passed\n \t that way.  */\n \n-      if ((TREE_CODE (TYPE_SIZE (passed_type)) != INTEGER_CST\n-\t   && contains_placeholder_p (TYPE_SIZE (passed_type)))\n+      if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (passed_type))\n \t  || TREE_ADDRESSABLE (passed_type)\n #ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n \t  || FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, passed_mode,"}, {"sha": "51ff3faea105eb6ca21075dcc6b72a3c83e54c07", "filename": "gcc/tree.c", "status": "modified", "additions": 122, "deletions": 27, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "patch": "@@ -1390,15 +1390,9 @@ tree\n save_expr (expr)\n      tree expr;\n {\n-  tree t = expr;\n+  tree t = fold (expr);\n   tree inner;\n \n-  /* Don't fold a COMPONENT_EXPR: if the operand was a CONSTRUCTOR (the\n-     only time it will fold), it can cause problems with PLACEHOLDER_EXPRs\n-     in Ada.  Moreover, it isn't at all clear why we fold here at all.  */\n-  if (TREE_CODE (t) != COMPONENT_REF)\n-    t = fold (t);\n-\n   /* If the tree evaluates to a constant, then we don't want to hide that\n      fact (i.e. this allows further folding, and direct checks for constants).\n      However, a read-only object that has side effects cannot be bypassed.\n@@ -1745,7 +1739,7 @@ unsafe_for_reeval (expr)\n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.  */\n \n-int\n+bool\n contains_placeholder_p (exp)\n      tree exp;\n {\n@@ -1770,13 +1764,12 @@ contains_placeholder_p (exp)\n \t position computations since they will be converted into a\n \t WITH_RECORD_EXPR involving the reference, which will assume\n \t here will be valid.  */\n-      return contains_placeholder_p (TREE_OPERAND (exp, 0));\n+      return CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 0));\n \n     case 'x':\n       if (code == TREE_LIST)\n-\treturn (contains_placeholder_p (TREE_VALUE (exp))\n-\t\t|| (TREE_CHAIN (exp) != 0\n-\t\t    && contains_placeholder_p (TREE_CHAIN (exp))));\n+\treturn (CONTAINS_PLACEHOLDER_P (TREE_VALUE (exp))\n+\t\t|| CONTAINS_PLACEHOLDER_P (TREE_CHAIN (exp)));\n       break;\n \n     case '1':\n@@ -1786,16 +1779,16 @@ contains_placeholder_p (exp)\n \t{\n \tcase COMPOUND_EXPR:\n \t  /* Ignoring the first operand isn't quite right, but works best.  */\n-\t  return contains_placeholder_p (TREE_OPERAND (exp, 1));\n+\t  return CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1));\n \n \tcase RTL_EXPR:\n \tcase CONSTRUCTOR:\n \t  return 0;\n \n \tcase COND_EXPR:\n-\t  return (contains_placeholder_p (TREE_OPERAND (exp, 0))\n-\t\t  || contains_placeholder_p (TREE_OPERAND (exp, 1))\n-\t\t  || contains_placeholder_p (TREE_OPERAND (exp, 2)));\n+\t  return (CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 0))\n+\t\t  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1))\n+\t\t  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 2)));\n \n \tcase SAVE_EXPR:\n \t  /* If we already know this doesn't have a placeholder, don't\n@@ -1804,15 +1797,14 @@ contains_placeholder_p (exp)\n \t    return 0;\n \n \t  SAVE_EXPR_NOPLACEHOLDER (exp) = 1;\n-\t  result = contains_placeholder_p (TREE_OPERAND (exp, 0));\n+\t  result = CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 0));\n \t  if (result)\n \t    SAVE_EXPR_NOPLACEHOLDER (exp) = 0;\n \n \t  return result;\n \n \tcase CALL_EXPR:\n-\t  return (TREE_OPERAND (exp, 1) != 0\n-\t\t  && contains_placeholder_p (TREE_OPERAND (exp, 1)));\n+\t  return CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1));\n \n \tdefault:\n \t  break;\n@@ -1821,10 +1813,10 @@ contains_placeholder_p (exp)\n       switch (TREE_CODE_LENGTH (code))\n \t{\n \tcase 1:\n-\t  return contains_placeholder_p (TREE_OPERAND (exp, 0));\n+\t  return CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 0));\n \tcase 2:\n-\t  return (contains_placeholder_p (TREE_OPERAND (exp, 0))\n-\t\t  || contains_placeholder_p (TREE_OPERAND (exp, 1)));\n+\t  return (CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 0))\n+\t\t  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1)));\n \tdefault:\n \t  return 0;\n \t}\n@@ -1835,6 +1827,109 @@ contains_placeholder_p (exp)\n   return 0;\n }\n \n+/* Return 1 if any part of the computation of TYPE involves a PLACEHOLDER_EXPR.\n+   This includes size, bounds, qualifiers (for QUAL_UNION_TYPE) and field\n+   positions.  */\n+\n+bool\n+type_contains_placeholder_p (type)\n+     tree type;\n+{\n+  /* If the size contains a placeholder or the parent type (component type in\n+     the case of arrays) type involves a placeholder, this type does.  */\n+  if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (type))\n+      || CONTAINS_PLACEHOLDER_P (TYPE_SIZE_UNIT (type))\n+      || (TREE_TYPE (type) != 0\n+\t  && type_contains_placeholder_p (TREE_TYPE (type))))\n+    return 1;\n+\n+  /* Now do type-specific checks.  Note that the last part of the check above\n+     greatly limits what we have to do below.  */\n+  switch (TREE_CODE (type))\n+    {\n+    case VOID_TYPE:\n+    case COMPLEX_TYPE:\n+    case VECTOR_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case CHAR_TYPE:\n+    case POINTER_TYPE:\n+    case OFFSET_TYPE:\n+    case REFERENCE_TYPE:\n+    case METHOD_TYPE:\n+    case FILE_TYPE:\n+    case FUNCTION_TYPE:\n+      return 0;\n+\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+      /* Here we just check the bounds.  */\n+      return (CONTAINS_PLACEHOLDER_P (TYPE_MIN_VALUE (type))\n+\t      || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (type)));\n+\n+    case ARRAY_TYPE:\n+    case SET_TYPE:\n+      /* We're already checked the component type (TREE_TYPE), so just check\n+\t the index type.  */\n+      return type_contains_placeholder_p (TYPE_DOMAIN (type));\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\tstatic tree seen_types = 0;\n+\ttree field;\n+\tbool ret = 0;\n+\n+\t/* We have to be careful here that we don't end up in infinite\n+\t   recursions due to a field of a type being a pointer to that type\n+\t   or to a mutually-recursive type.  So we store a list of record\n+\t   types that we've seen and see if this type is in them.  To save\n+\t   memory, we don't use a list for just one type.  Here we check\n+\t   whether we've seen this type before and store it if not.  */\n+\tif (seen_types == 0)\n+\t  seen_types = type;\n+\telse if (TREE_CODE (seen_types) != TREE_LIST)\n+\t  {\n+\t    if (seen_types == type)\n+\t      return 0;\n+\n+\t    seen_types = tree_cons (NULL_TREE, type,\n+\t\t\t\t    build_tree_list (NULL_TREE, seen_types));\n+\t  }\n+\telse\n+\t  {\n+\t    if (value_member (type, seen_types) != 0)\n+\t      return 0;\n+\n+\t    seen_types = tree_cons (NULL_TREE, type, seen_types);\n+\t  }\n+\n+\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  if (TREE_CODE (field) == FIELD_DECL\n+\t      && (CONTAINS_PLACEHOLDER_P (DECL_FIELD_OFFSET (field))\n+\t\t  || (TREE_CODE (type) == QUAL_UNION_TYPE\n+\t\t      && CONTAINS_PLACEHOLDER_P (DECL_QUALIFIER (field)))\n+\t\t  || type_contains_placeholder_p (TREE_TYPE (field))))\n+\t    {\n+\t      ret = true;\n+\t      break;\n+\t    }\n+\n+\t/* Now remove us from seen_types and return the result.  */\n+\tif (seen_types == type)\n+\t  seen_types = 0;\n+\telse\n+\t  seen_types = TREE_CHAIN (seen_types);\n+\n+\treturn ret;\n+      }\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* Return 1 if EXP contains any expressions that produce cleanups for an\n    outer scope to deal with.  Used by fold.  */\n \n@@ -1960,9 +2055,9 @@ substitute_in_expr (exp, f, r)\n \n \t  op0 = TREE_OPERAND (exp, 0);\n \t  op1 = TREE_OPERAND (exp, 1);\n-\t  if (contains_placeholder_p (op0))\n+\t  if (CONTAINS_PLACEHOLDER_P (op0))\n \t    op0 = substitute_in_expr (op0, f, r);\n-\t  if (contains_placeholder_p (op1))\n+\t  if (CONTAINS_PLACEHOLDER_P (op1))\n \t    op1 = substitute_in_expr (op1, f, r);\n \n \t  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n@@ -1994,11 +2089,11 @@ substitute_in_expr (exp, f, r)\n \t  op1 = TREE_OPERAND (exp, 1);\n \t  op2 = TREE_OPERAND (exp, 2);\n \n-\t  if (contains_placeholder_p (op0))\n+\t  if (CONTAINS_PLACEHOLDER_P (op0))\n \t    op0 = substitute_in_expr (op0, f, r);\n-\t  if (contains_placeholder_p (op1))\n+\t  if (CONTAINS_PLACEHOLDER_P (op1))\n \t    op1 = substitute_in_expr (op1, f, r);\n-\t  if (contains_placeholder_p (op2))\n+\t  if (CONTAINS_PLACEHOLDER_P (op2))\n \t    op2 = substitute_in_expr (op2, f, r);\n \n \t  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)"}, {"sha": "65b7de27bca5df927f7d774d32f8d2655b5077f2", "filename": "gcc/tree.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6cdb44fd51d6036d32a732363f19c8e51f0d89/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7a6cdb44fd51d6036d32a732363f19c8e51f0d89", "patch": "@@ -2523,7 +2523,19 @@ extern int unsafe_for_reeval\t\tPARAMS ((tree));\n    Note that we only allow such expressions within simple arithmetic\n    or a COND_EXPR.  */\n \n-extern int contains_placeholder_p\tPARAMS ((tree));\n+extern bool contains_placeholder_p\tPARAMS ((tree));\n+\n+/* This macro calls the above function but short-circuits the common\n+   case of a constant to save time.  Also check for null.  */\n+\n+#define CONTAINS_PLACEHOLDER_P(EXP) \\\n+  ((EXP) != 0 && ! TREE_CONSTANT (EXP) && contains_placeholder_p (EXP))\n+\n+/* Return 1 if any part of the computation of TYPE involves a PLACEHOLDER_EXPR.\n+   This includes size, bounds, qualifiers (for QUAL_UNION_TYPE) and field\n+   positions.  */\n+\n+extern bool type_contains_placeholder_p\tPARAMS ((tree));\n \n /* Return 1 if EXP contains any expressions that produce cleanups for an\n    outer scope to deal with.  Used by fold.  */"}]}