{"sha": "f65f371bcff00263f9e870d546b580caebd953b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY1ZjM3MWJjZmYwMDI2M2Y5ZTg3MGQ1NDZiNTgwY2FlYmQ5NTNiMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-05-28T07:36:02Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-05-28T07:36:02Z"}, "message": "decl.c (components_to_record): Set a name on the type created for the REP part, if any.\n\n\t* gcc-interface/decl.c (components_to_record): Set a name on the type\n\tcreated for the REP part, if any.\n\t* gcc-interface/utils.c (finish_record_type): Only take the maximum\n\twhen merging sizes for a variant part at offset 0.\n\t(merge_sizes): Rename has_rep parameter into max.\n\nFrom-SVN: r271681", "tree": {"sha": "c9d1a1e2186cd885fe778b09942d0358616a012e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9d1a1e2186cd885fe778b09942d0358616a012e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f65f371bcff00263f9e870d546b580caebd953b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65f371bcff00263f9e870d546b580caebd953b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f65f371bcff00263f9e870d546b580caebd953b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65f371bcff00263f9e870d546b580caebd953b3/comments", "author": null, "committer": null, "parents": [{"sha": "e6ca6782acfa8b126c6abb6bcd9026572217525d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ca6782acfa8b126c6abb6bcd9026572217525d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6ca6782acfa8b126c6abb6bcd9026572217525d"}], "stats": {"total": 109, "additions": 90, "deletions": 19}, "files": [{"sha": "8c22c322a2c5c375138ae64054a48881e114f6a4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f371bcff00263f9e870d546b580caebd953b3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f371bcff00263f9e870d546b580caebd953b3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f65f371bcff00263f9e870d546b580caebd953b3", "patch": "@@ -1,3 +1,11 @@\n+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (components_to_record): Set a name on the type\n+\tcreated for the REP part, if any.\n+\t* gcc-interface/utils.c (finish_record_type): Only take the maximum\n+\twhen merging sizes for a variant part at offset 0.\n+\t(merge_sizes): Rename has_rep parameter into max.\n+\n 2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (gnat_internal_attribute_table): Add support"}, {"sha": "dc23743b55f5895bd756f99607a8b08e5eec4d9f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f371bcff00263f9e870d546b580caebd953b3/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f371bcff00263f9e870d546b580caebd953b3/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=f65f371bcff00263f9e870d546b580caebd953b3", "patch": "@@ -8162,6 +8162,8 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \tgnu_field_list = gnu_rep_list;\n       else\n \t{\n+\t  TYPE_NAME (gnu_rep_type)\n+\t    = create_concat_name (gnat_record_type, \"REP\");\n \t  TYPE_REVERSE_STORAGE_ORDER (gnu_rep_type)\n \t    = TYPE_REVERSE_STORAGE_ORDER (gnu_record_type);\n \t  finish_record_type (gnu_rep_type, gnu_rep_list, 1, debug_info);"}, {"sha": "dbf7c1825060665af9cd0003f85ccba5e3457d21", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f371bcff00263f9e870d546b580caebd953b3/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f371bcff00263f9e870d546b580caebd953b3/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=f65f371bcff00263f9e870d546b580caebd953b3", "patch": "@@ -1863,6 +1863,9 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n       else\n \tthis_ada_size = this_size;\n \n+      const bool variant_part = (TREE_CODE (type) == QUAL_UNION_TYPE);\n+      const bool variant_part_at_zero = variant_part && integer_zerop (pos);\n+\n       /* Clear DECL_BIT_FIELD for the cases layout_decl does not handle.  */\n       if (DECL_BIT_FIELD (field)\n \t  && operand_equal_p (this_size, TYPE_SIZE (type), 0))\n@@ -1904,9 +1907,7 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n       /* Clear DECL_BIT_FIELD_TYPE for a variant part at offset 0, it's simply\n \t not supported by the DECL_BIT_FIELD_REPRESENTATIVE machinery because\n \t the variant part is always the last field in the list.  */\n-      if (DECL_INTERNAL_P (field)\n-\t  && TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE\n-\t  && integer_zerop (pos))\n+      if (variant_part_at_zero)\n \tDECL_BIT_FIELD_TYPE (field) = NULL_TREE;\n \n       /* If we still have DECL_BIT_FIELD set at this point, we know that the\n@@ -1941,18 +1942,18 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n \tcase RECORD_TYPE:\n \t  /* Since we know here that all fields are sorted in order of\n \t     increasing bit position, the size of the record is one\n-\t     higher than the ending bit of the last field processed\n-\t     unless we have a rep clause, since in that case we might\n-\t     have a field outside a QUAL_UNION_TYPE that has a higher ending\n-\t     position.  So use a MAX in that case.  Also, if this field is a\n-\t     QUAL_UNION_TYPE, we need to take into account the previous size in\n-\t     the case of empty variants.  */\n+\t     higher than the ending bit of the last field processed,\n+\t     unless we have a variant part at offset 0, since in this\n+\t     case we might have a field outside the variant part that\n+\t     has a higher ending position; so use a MAX in this case.\n+\t     Also, if this field is a QUAL_UNION_TYPE, we need to take\n+\t     into account the previous size in the case of empty variants.  */\n \t  ada_size\n-\t    = merge_sizes (ada_size, pos, this_ada_size,\n-\t\t\t   TREE_CODE (type) == QUAL_UNION_TYPE, rep_level > 0);\n+\t    = merge_sizes (ada_size, pos, this_ada_size, variant_part,\n+\t\t\t   variant_part_at_zero);\n \t  size\n-\t    = merge_sizes (size, pos, this_size,\n-\t\t\t   TREE_CODE (type) == QUAL_UNION_TYPE, rep_level > 0);\n+\t    = merge_sizes (size, pos, this_size, variant_part,\n+\t\t\t   variant_part_at_zero);\n \t  break;\n \n \tdefault:\n@@ -2233,21 +2234,20 @@ rest_of_record_type_compilation (tree record_type)\n /* Utility function of above to merge LAST_SIZE, the previous size of a record\n    with FIRST_BIT and SIZE that describe a field.  SPECIAL is true if this\n    represents a QUAL_UNION_TYPE in which case we must look for COND_EXPRs and\n-   replace a value of zero with the old size.  If HAS_REP is true, we take the\n+   replace a value of zero with the old size.  If MAX is true, we take the\n    MAX of the end position of this field with LAST_SIZE.  In all other cases,\n    we use FIRST_BIT plus SIZE.  Return an expression for the size.  */\n \n static tree\n-merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n-\t     bool has_rep)\n+merge_sizes (tree last_size, tree first_bit, tree size, bool special, bool max)\n {\n   tree type = TREE_TYPE (last_size);\n   tree new_size;\n \n   if (!special || TREE_CODE (size) != COND_EXPR)\n     {\n       new_size = size_binop (PLUS_EXPR, first_bit, size);\n-      if (has_rep)\n+      if (max)\n \tnew_size = size_binop (MAX_EXPR, last_size, new_size);\n     }\n \n@@ -2256,11 +2256,11 @@ merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n \t\t\t    integer_zerop (TREE_OPERAND (size, 1))\n \t\t\t    ? last_size : merge_sizes (last_size, first_bit,\n \t\t\t\t\t\t       TREE_OPERAND (size, 1),\n-\t\t\t\t\t\t       1, has_rep),\n+\t\t\t\t\t\t       1, max),\n \t\t\t    integer_zerop (TREE_OPERAND (size, 2))\n \t\t\t    ? last_size : merge_sizes (last_size, first_bit,\n \t\t\t\t\t\t       TREE_OPERAND (size, 2),\n-\t\t\t\t\t\t       1, has_rep));\n+\t\t\t\t\t\t       1, max));\n \n   /* We don't need any NON_VALUE_EXPRs and they can confuse us (especially\n      when fed through SUBSTITUTE_IN_EXPR) into thinking that a constant"}, {"sha": "0bf055b25f582def2233447722a8db293306b876", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f371bcff00263f9e870d546b580caebd953b3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f371bcff00263f9e870d546b580caebd953b3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f65f371bcff00263f9e870d546b580caebd953b3", "patch": "@@ -1,3 +1,7 @@\n+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/discr5.ads: New test.\n+\n 2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/prefetch1.ad[sb]: New test."}, {"sha": "c265723ec47093914c43851df4dcfd2570196731", "filename": "gcc/testsuite/gnat.dg/specs/discr5.ads", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f371bcff00263f9e870d546b580caebd953b3/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fdiscr5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f371bcff00263f9e870d546b580caebd953b3/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fdiscr5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fdiscr5.ads?ref=f65f371bcff00263f9e870d546b580caebd953b3", "patch": "@@ -0,0 +1,57 @@\n+-- { dg-do compile }\n+\n+with System;\n+\n+package Discr5 is\n+\n+   X, Y : Boolean;\n+\n+   type R (D : Boolean := False) is tagged limited record\n+      F : Integer;\n+      case D is\n+         when True =>\n+            F1, F2 : Integer;\n+         when False =>\n+            null;\n+      end case;\n+   end record;\n+   for R use record\n+      F1 at 100 range 0..31;\n+   end record;\n+   \n+   subtype Rt is R(True);\n+   subtype Rf is R(False);\n+\n+   type R1 (D1 : Boolean) is new R (X) with record\n+      FF : Float;\n+      case D1 is\n+         when True =>\n+            F3, F4 : Float;\n+         when False =>\n+            null;\n+      end case;\n+   end record;\n+   for R1 use record\n+      F4 at 200 range 0..31;\n+   end record;\n+\n+   subtype R1t is R1 (True);\n+   subtype R1f is R1 (False);\n+\n+   type R2 (D2 : Boolean) is new R1 (Y) with record\n+      FFF: System.Address;\n+      case D2 is\n+         when True =>\n+            F5, F6: System.Address;\n+         when False =>\n+            null;\n+      end case;\n+   end record;\n+   for R2 use record\n+      F6 at 300 range 0..63;\n+   end record;\n+\n+   subtype R2t is R2 (True);\n+   subtype R2f is R2 (False);\n+\n+end Discr5;"}]}