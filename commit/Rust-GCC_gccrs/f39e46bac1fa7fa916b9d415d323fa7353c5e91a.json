{"sha": "f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM5ZTQ2YmFjMWZhN2ZhOTE2YjlkNDE1ZDMyM2ZhNzM1M2M1ZTkxYQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-11-24T11:32:24Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-11-24T11:32:24Z"}, "message": "cfgrtl.c (rtl_delete_block): Fix comment.\n\n\t* cfgrtl.c (rtl_delete_block): Fix comment.\n\t* emit-rtl.c (remove_unnecessary_notes): Die if we see BLOCK_BEG\n\tor BLOCK_END insn notes.\n\t* jump.c (squeeze_notes): Likewise.\n\t* haifa-sched.c (reemit_notes): Don't \"re-emit\" EH_REGION_BEG and\n\tEH_REGION_END notes, we never have them to begin with.\n\t* sched-deps.c (sched_analyze_insn): When updating loop notes,\n\tverify that we have indeed only recorded loop notes.\n\t(sched_analyze): Die if we see EH_REGION_BEG or EH_REGION_END notes.\n\tOnly record loop notes.\n\n\t* cfgexpand.c (tree_expand_cfg): Fix comment.\n\n\t* passes.c (rest_of_compilation): Don't do a second call to\n\tconvert_from_eh_region_ranges from here, it's already called\n\tfrom cfgexpand.c.\n\t* except.c (resolve_fixup_regions): Remove.\n\t(remove_fixup_regions): Remove.\n\t(convert_from_eh_region_ranges_1): Remove.\n\t(convert_from_eh_region_ranges): Remove the case where EH is\n\tnot already lowered at the tree level.  We always lower there.\n\nFrom-SVN: r91148", "tree": {"sha": "6b6bc6570ef7a0a4f2c302b560d0913867479133", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b6bc6570ef7a0a4f2c302b560d0913867479133"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/comments", "author": null, "committer": null, "parents": [{"sha": "b4345a57d828a55b70d6e5f5f4294c97c6acf304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4345a57d828a55b70d6e5f5f4294c97c6acf304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4345a57d828a55b70d6e5f5f4294c97c6acf304"}], "stats": {"total": 378, "additions": 60, "deletions": 318}, "files": [{"sha": "e9e7ebc2cc44ae322b4ee82433ccce89617d0fa5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "patch": "@@ -1,7 +1,30 @@\n+2004-11-24  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* cfgrtl.c (rtl_delete_block): Fix comment.\n+\t* emit-rtl.c (remove_unnecessary_notes): Die if we see BLOCK_BEG\n+\tor BLOCK_END insn notes.\n+\t* jump.c (squeeze_notes): Likewise.\n+\t* haifa-sched.c (reemit_notes): Don't \"re-emit\" EH_REGION_BEG and\n+\tEH_REGION_END notes, we never have them to begin with.\n+\t* sched-deps.c (sched_analyze_insn): When updating loop notes,\n+\tverify that we have indeed only recorded loop notes.\n+\t(sched_analyze): Die if we see EH_REGION_BEG or EH_REGION_END notes.\n+\tOnly record loop notes.\n+\n+\t* cfgexpand.c (tree_expand_cfg): Fix comment.\n+\n+\t* passes.c (rest_of_compilation): Don't do a second call to\n+\tconvert_from_eh_region_ranges from here, it's already called\n+\tfrom cfgexpand.c.\n+\t* except.c (resolve_fixup_regions): Remove.\n+\t(remove_fixup_regions): Remove.\n+\t(convert_from_eh_region_ranges_1): Remove.\n+\t(convert_from_eh_region_ranges): Remove the case where EH is\n+\tnot already lowered at the tree level.  We always lower there.\n+\n 2004-11-24  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR c++/16882\n-\n \t* tree.c (make_vector_type): Move qualifiers to the vector type,\n \tuse the inner type's main variant and build a main variant for\n \tthe vector type if necessary."}, {"sha": "f710aedbd8177e582912ce62814feba147fd07b5", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "patch": "@@ -1310,8 +1310,8 @@ tree_expand_cfg (void)\n   /* We're done expanding trees to RTL.  */\n   currently_expanding_to_rtl = 0;\n \n-  /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n-     sorts of eh initialization.  */\n+  /* Convert tree EH labels to RTL EH labels, and clean out any unreachable\n+     EH regions.  */\n   convert_from_eh_region_ranges ();\n \n   rebuild_jump_labels (get_insns ());"}, {"sha": "3c2dc96aacb1b1a5ead15f96bb8af3e058c7753d", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "patch": "@@ -368,14 +368,9 @@ rtl_delete_block (basic_block b)\n   rtx insn, end, tmp;\n \n   /* If the head of this block is a CODE_LABEL, then it might be the\n-     label for an exception handler which can't be reached.\n-\n-     We need to remove the label from the exception_handler_label list\n-     and remove the associated NOTE_INSN_EH_REGION_BEG and\n-     NOTE_INSN_EH_REGION_END notes.  */\n-\n+     label for an exception handler which can't be reached.  We need\n+     to remove the label from the exception_handler_label list.  */\n   insn = BB_HEAD (b);\n-\n   if (LABEL_P (insn))\n     maybe_remove_eh_handler (insn);\n "}, {"sha": "fba241266386506feb2384285194139fe0abb43b", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "patch": "@@ -3728,7 +3728,6 @@ find_line_note (rtx insn)\n void\n remove_unnecessary_notes (void)\n {\n-  rtx block_stack = NULL_RTX;\n   rtx eh_stack = NULL_RTX;\n   rtx insn;\n   rtx next;\n@@ -3767,66 +3766,17 @@ remove_unnecessary_notes (void)\n \t  break;\n \n \tcase NOTE_INSN_BLOCK_BEG:\n-\t  /* By now, all notes indicating lexical blocks should have\n-\t     NOTE_BLOCK filled in.  */\n-\t  gcc_assert (NOTE_BLOCK (insn));\n-\t  block_stack = alloc_INSN_LIST (insn, block_stack);\n-\t  break;\n-\n \tcase NOTE_INSN_BLOCK_END:\n-\t  /* Too many end notes.  */\n-\t  gcc_assert (block_stack);\n-\t  /* Mismatched nesting.  */\n-\t  gcc_assert (NOTE_BLOCK (XEXP (block_stack, 0)) == NOTE_BLOCK (insn));\n-\t  tmp = block_stack;\n-\t  block_stack = XEXP (block_stack, 1);\n-\t  free_INSN_LIST_node (tmp);\n+          /* BLOCK_END and BLOCK_BEG notes only exist in the `final' pass.  */\n+          gcc_unreachable ();\n \n-\t  /* Scan back to see if there are any non-note instructions\n-\t     between INSN and the beginning of this block.  If not,\n-\t     then there is no PC range in the generated code that will\n-\t     actually be in this block, so there's no point in\n-\t     remembering the existence of the block.  */\n-\t  for (tmp = PREV_INSN (insn); tmp; tmp = PREV_INSN (tmp))\n-\t    {\n-\t      /* This block contains a real instruction.  Note that we\n-\t\t don't include labels; if the only thing in the block\n-\t\t is a label, then there are still no PC values that\n-\t\t lie within the block.  */\n-\t      if (INSN_P (tmp))\n-\t\tbreak;\n-\n-\t      /* We're only interested in NOTEs.  */\n-\t      if (!NOTE_P (tmp))\n-\t\tcontinue;\n-\n-\t      if (NOTE_LINE_NUMBER (tmp) == NOTE_INSN_BLOCK_BEG)\n-\t\t{\n-\t\t  /* We just verified that this BLOCK matches us with\n-\t\t     the block_stack check above.  Never delete the\n-\t\t     BLOCK for the outermost scope of the function; we\n-\t\t     can refer to names from that scope even if the\n-\t\t     block notes are messed up.  */\n-\t\t  if (! is_body_block (NOTE_BLOCK (insn))\n-\t\t      && (*debug_hooks->ignore_block) (NOTE_BLOCK (insn)))\n-\t\t    {\n-\t\t      remove_insn (tmp);\n-\t\t      remove_insn (insn);\n-\t\t    }\n-\t\t  break;\n-\t\t}\n-\t      else if (NOTE_LINE_NUMBER (tmp) == NOTE_INSN_BLOCK_END)\n-\t\t/* There's a nested block.  We need to leave the\n-\t\t   current block in place since otherwise the debugger\n-\t\t   wouldn't be able to show symbols from our block in\n-\t\t   the nested block.  */\n-\t\tbreak;\n-\t    }\n+\tdefault:\n+\t  break;\n \t}\n     }\n \n-  /* Too many begin notes.  */\n-  gcc_assert (!block_stack && !eh_stack);\n+  /* Too many EH_REGION_BEG notes.  */\n+  gcc_assert (!eh_stack);\n }\n \n \f"}, {"sha": "b906cf0af6dde4136e4e679d5940d7711eecfa14", "filename": "gcc/except.c", "status": "modified", "additions": 10, "deletions": 220, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "patch": "@@ -260,10 +260,7 @@ static hashval_t t2r_hash (const void *);\n static void add_type_for_runtime (tree);\n static tree lookup_type_for_runtime (tree);\n \n-static void resolve_fixup_regions (void);\n-static void remove_fixup_regions (void);\n static void remove_unreachable_regions (rtx);\n-static void convert_from_eh_region_ranges_1 (rtx *, int *, int);\n \n static int ttypes_filter_eq (const void *, const void *);\n static hashval_t ttypes_filter_hash (const void *);\n@@ -668,123 +665,6 @@ collect_eh_region_array (void)\n     }\n }\n \n-static void\n-resolve_one_fixup_region (struct eh_region *fixup)\n-{\n-  struct eh_region *cleanup, *real;\n-  int j, n;\n-\n-  n = cfun->eh->last_region_number;\n-  cleanup = 0;\n-\n-  for (j = 1; j <= n; ++j)\n-    {\n-      cleanup = cfun->eh->region_array[j];\n-      if (cleanup && cleanup->type == ERT_CLEANUP\n-\t  && cleanup->u.cleanup.exp == fixup->u.fixup.cleanup_exp)\n-\tbreak;\n-    }\n-  gcc_assert (j <= n);\n-\n-  real = cleanup->outer;\n-  if (real && real->type == ERT_FIXUP)\n-    {\n-      if (!real->u.fixup.resolved)\n-\tresolve_one_fixup_region (real);\n-      real = real->u.fixup.real_region;\n-    }\n-\n-  fixup->u.fixup.real_region = real;\n-  fixup->u.fixup.resolved = true;\n-}\n-\n-static void\n-resolve_fixup_regions (void)\n-{\n-  int i, n = cfun->eh->last_region_number;\n-\n-  for (i = 1; i <= n; ++i)\n-    {\n-      struct eh_region *fixup = cfun->eh->region_array[i];\n-\n-      if (!fixup || fixup->type != ERT_FIXUP || fixup->u.fixup.resolved)\n-\tcontinue;\n-\n-      resolve_one_fixup_region (fixup);\n-    }\n-}\n-\n-/* Now that we've discovered what region actually encloses a fixup,\n-   we can shuffle pointers and remove them from the tree.  */\n-\n-static void\n-remove_fixup_regions (void)\n-{\n-  int i;\n-  rtx insn, note;\n-  struct eh_region *fixup;\n-\n-  /* Walk the insn chain and adjust the REG_EH_REGION numbers\n-     for instructions referencing fixup regions.  This is only\n-     strictly necessary for fixup regions with no parent, but\n-     doesn't hurt to do it for all regions.  */\n-  for (insn = get_insns(); insn ; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn)\n-\t&& (note = find_reg_note (insn, REG_EH_REGION, NULL))\n-\t&& INTVAL (XEXP (note, 0)) > 0\n-\t&& (fixup = cfun->eh->region_array[INTVAL (XEXP (note, 0))])\n-\t&& fixup->type == ERT_FIXUP)\n-      {\n-\tif (fixup->u.fixup.real_region)\n-\t  XEXP (note, 0) = GEN_INT (fixup->u.fixup.real_region->region_number);\n-\telse\n-\t  remove_note (insn, note);\n-      }\n-\n-  /* Remove the fixup regions from the tree.  */\n-  for (i = cfun->eh->last_region_number; i > 0; --i)\n-    {\n-      fixup = cfun->eh->region_array[i];\n-      if (! fixup)\n-\tcontinue;\n-\n-      /* Allow GC to maybe free some memory.  */\n-      if (fixup->type == ERT_CLEANUP)\n-\tfixup->u.cleanup.exp = NULL_TREE;\n-\n-      if (fixup->type != ERT_FIXUP)\n-\tcontinue;\n-\n-      if (fixup->inner)\n-\t{\n-\t  struct eh_region *parent, *p, **pp;\n-\n-\t  parent = fixup->u.fixup.real_region;\n-\n-\t  /* Fix up the children's parent pointers; find the end of\n-\t     the list.  */\n-\t  for (p = fixup->inner; ; p = p->next_peer)\n-\t    {\n-\t      p->outer = parent;\n-\t      if (! p->next_peer)\n-\t\tbreak;\n-\t    }\n-\n-\t  /* In the tree of cleanups, only outer-inner ordering matters.\n-\t     So link the children back in anywhere at the correct level.  */\n-\t  if (parent)\n-\t    pp = &parent->inner;\n-\t  else\n-\t    pp = &cfun->eh->region_tree;\n-\t  p->next_peer = *pp;\n-\t  *pp = fixup->inner;\n-\t  fixup->inner = NULL;\n-\t}\n-\n-      remove_eh_handler (fixup);\n-    }\n-}\n-\n /* Remove all regions whose labels are not reachable from insns.  */\n \n static void\n@@ -868,113 +748,23 @@ remove_unreachable_regions (rtx insns)\n   free (uid_region_num);\n }\n \n-/* Turn NOTE_INSN_EH_REGION notes into REG_EH_REGION notes for each\n-   can_throw instruction in the region.  */\n-\n-static void\n-convert_from_eh_region_ranges_1 (rtx *pinsns, int *orig_sp, int cur)\n-{\n-  int *sp = orig_sp;\n-  rtx insn, next;\n-\n-  for (insn = *pinsns; insn ; insn = next)\n-    {\n-      next = NEXT_INSN (insn);\n-      if (NOTE_P (insn))\n-\t{\n-\t  int kind = NOTE_LINE_NUMBER (insn);\n-\t  if (kind == NOTE_INSN_EH_REGION_BEG\n-\t      || kind == NOTE_INSN_EH_REGION_END)\n-\t    {\n-\t      if (kind == NOTE_INSN_EH_REGION_BEG)\n-\t\t{\n-\t\t  struct eh_region *r;\n-\n-\t\t  *sp++ = cur;\n-\t\t  cur = NOTE_EH_HANDLER (insn);\n-\n-\t\t  r = cfun->eh->region_array[cur];\n-\t\t  if (r->type == ERT_FIXUP)\n-\t\t    {\n-\t\t      r = r->u.fixup.real_region;\n-\t\t      cur = r ? r->region_number : 0;\n-\t\t    }\n-\t\t  else if (r->type == ERT_CATCH)\n-\t\t    {\n-\t\t      r = r->outer;\n-\t\t      cur = r ? r->region_number : 0;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tcur = *--sp;\n-\n-\t      if (insn == *pinsns)\n-\t\t*pinsns = next;\n-\t      remove_insn (insn);\n-\t      continue;\n-\t    }\n-\t}\n-      else if (INSN_P (insn))\n-\t{\n-\t  if (cur > 0\n-\t      && ! find_reg_note (insn, REG_EH_REGION, NULL_RTX)\n-\t      /* Calls can always potentially throw exceptions, unless\n-\t\t they have a REG_EH_REGION note with a value of 0 or less.\n-\t\t Which should be the only possible kind so far.  */\n-\t      && (CALL_P (insn)\n-\t\t  /* If we wanted exceptions for non-call insns, then\n-\t\t     any may_trap_p instruction could throw.  */\n-\t\t  || (flag_non_call_exceptions\n-\t\t      && GET_CODE (PATTERN (insn)) != CLOBBER\n-\t\t      && GET_CODE (PATTERN (insn)) != USE\n-\t\t      && may_trap_p (PATTERN (insn)))))\n-\t    {\n-\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_EH_REGION, GEN_INT (cur),\n-\t\t\t\t\t\t  REG_NOTES (insn));\n-\t    }\n-\t}\n-    }\n-\n-  gcc_assert (sp == orig_sp);\n-}\n-\n-static void\n-collect_rtl_labels_from_trees (void)\n-{\n-  int i, n = cfun->eh->last_region_number;\n-  for (i = 1; i <= n; ++i)\n-    {\n-      struct eh_region *reg = cfun->eh->region_array[i];\n-      if (reg && reg->tree_label)\n-\treg->label = DECL_RTL_IF_SET (reg->tree_label);\n-    }\n-}\n+/* Set up EH labels for RTL.  */\n \n void\n convert_from_eh_region_ranges (void)\n {\n   rtx insns = get_insns ();\n+  int i, n = cfun->eh->last_region_number;\n \n-  if (cfun->eh->region_array)\n-    {\n-      /* If the region array already exists, assume we're coming from\n-\t optimize_function_tree.  In this case all we need to do is\n-\t collect the rtl labels that correspond to the tree labels\n-\t that we allocated earlier.  */\n-      collect_rtl_labels_from_trees ();\n-    }\n-  else\n+  /* Most of the work is already done at the tree level.  All we need to\n+     do is collect the rtl labels that correspond to the tree labels that\n+     collect the rtl labels that correspond to the tree labels\n+     we allocated earlier.  */\n+  for (i = 1; i <= n; ++i)\n     {\n-      int *stack;\n-\n-      collect_eh_region_array ();\n-      resolve_fixup_regions ();\n-\n-      stack = xmalloc (sizeof (int) * (cfun->eh->last_region_number + 1));\n-      convert_from_eh_region_ranges_1 (&insns, stack, 0);\n-      free (stack);\n-\n-      remove_fixup_regions ();\n+      struct eh_region *region = cfun->eh->region_array[i];\n+      if (region && region->tree_label)\n+\tregion->label = DECL_RTL_IF_SET (region->tree_label);\n     }\n \n   remove_unreachable_regions (insns);"}, {"sha": "9b3ed5e8eff8614fcf607714be63ced5cd6d92d4", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "patch": "@@ -1648,11 +1648,6 @@ reemit_notes (rtx insn, rtx last)\n \n \t  last = emit_note_before (note_type, last);\n \t  remove_note (insn, note);\n-\t  note = XEXP (note, 1);\n-\t  if (note_type == NOTE_INSN_EH_REGION_BEG\n-\t      || note_type == NOTE_INSN_EH_REGION_END)\n-\t    NOTE_EH_HANDLER (last) = INTVAL (XEXP (note, 0));\n-\t  remove_note (insn, note);\n \t}\n     }\n   return retval;"}, {"sha": "85c1f6b2d75f77cd41e5fddea22e04622a22d09a", "filename": "gcc/jump.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "patch": "@@ -248,6 +248,10 @@ squeeze_notes (rtx* startp, rtx* endp)\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END))\n \t{\n+\t  /* BLOCK_BEG or BLOCK_END notes only exist in the `final' pass.  */\n+\t  gcc_assert (NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_BEG\n+\t\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_END);\n+\n \t  if (insn == start)\n \t    start = next;\n \t  else"}, {"sha": "37e84c8de8befb57e200e24950c7c76158f7bb24", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "patch": "@@ -1538,10 +1538,6 @@ rest_of_clean_state (void)\n static void\n rest_of_compilation (void)\n {\n-  /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n-     sorts of eh initialization.  */\n-  convert_from_eh_region_ranges ();\n-\n   /* If we're emitting a nested function, make sure its parent gets\n      emitted as well.  Doing otherwise confuses debug info.  */\n   {"}, {"sha": "32d0fdba813393e7c14702d60efffcb39f0d7d4a", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f39e46bac1fa7fa916b9d415d323fa7353c5e91a/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=f39e46bac1fa7fa916b9d415d323fa7353c5e91a", "patch": "@@ -976,18 +976,14 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n     {\n       rtx link;\n \n-      /* Update loop_notes with any notes from this insn.  Also determine\n-\t if any of the notes on the list correspond to instruction scheduling\n-\t barriers (loop, eh & setjmp notes, but not range notes).  */\n+      /* Update loop_notes with any notes from this insn.  */\n       link = loop_notes;\n       while (XEXP (link, 1))\n \t{\n-\t  if (INTVAL (XEXP (link, 0)) == NOTE_INSN_LOOP_BEG\n-\t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_LOOP_END\n-\t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_EH_REGION_BEG\n-\t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_EH_REGION_END)\n-\t    reg_pending_barrier = MOVE_BARRIER;\n+\t  gcc_assert (INTVAL (XEXP (link, 0)) == NOTE_INSN_LOOP_BEG\n+\t\t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_LOOP_END);\n \n+\t  reg_pending_barrier = MOVE_BARRIER;\n \t  link = XEXP (link, 1);\n \t}\n       XEXP (link, 1) = REG_NOTES (insn);\n@@ -1323,26 +1319,19 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n \t    deps->in_post_call_group_p = post_call;\n \t}\n \n+      /* EH_REGION insn notes can not appear until well after we complete\n+\t scheduling.  */\n+      if (NOTE_P (insn))\n+\tgcc_assert (NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_BEG\n+\t\t    && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_END);\n+\n       /* See comments on reemit_notes as to why we do this.\n \t ??? Actually, the reemit_notes just say what is done, not why.  */\n \n       if (NOTE_P (insn)\n-\t       && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n-\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n-\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n-\t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n+\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n+\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END))\n \t{\n-\t  rtx rtx_region;\n-\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n-\t    rtx_region = GEN_INT (NOTE_EH_HANDLER (insn));\n-\t  else\n-\t    rtx_region = const0_rtx;\n-\n-\t  loop_notes = alloc_EXPR_LIST (REG_SAVE_NOTE,\n-\t\t\t\t\trtx_region,\n-\t\t\t\t\tloop_notes);\n \t  loop_notes = alloc_EXPR_LIST (REG_SAVE_NOTE,\n \t\t\t\t\tGEN_INT (NOTE_LINE_NUMBER (insn)),\n \t\t\t\t\tloop_notes);"}]}