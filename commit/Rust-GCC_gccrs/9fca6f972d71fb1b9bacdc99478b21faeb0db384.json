{"sha": "9fca6f972d71fb1b9bacdc99478b21faeb0db384", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZjYTZmOTcyZDcxZmIxYjliYWNkYzk5NDc4YjIxZmFlYjBkYjM4NA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2006-11-27T11:38:42Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-11-27T11:38:42Z"}, "message": "re PR fortran/25620 (Missed optimization with power)\n\n2006-11-27  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/25620\n\t* builtins.c (expand_builtin_pow): Optimize non integer valued\n\tconstant exponents using sqrt or cbrt if possible.  Always fall back\n\tto expanding via optabs.\n\n\t* gcc.target/i386/pow-1.c: New testcase.\n\t* gcc.dg/builtins-58.c: Likewise.\n\nFrom-SVN: r119248", "tree": {"sha": "de6e2a8d2396c1467bd70b318ac62505b5035e61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de6e2a8d2396c1467bd70b318ac62505b5035e61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fca6f972d71fb1b9bacdc99478b21faeb0db384", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fca6f972d71fb1b9bacdc99478b21faeb0db384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fca6f972d71fb1b9bacdc99478b21faeb0db384", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fca6f972d71fb1b9bacdc99478b21faeb0db384/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4090db01e884cc331643008783ac864ad681cb56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4090db01e884cc331643008783ac864ad681cb56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4090db01e884cc331643008783ac864ad681cb56"}], "stats": {"total": 193, "additions": 170, "deletions": 23}, "files": [{"sha": "65451c705eda2941fd88b3f1fc1588704530dc70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fca6f972d71fb1b9bacdc99478b21faeb0db384/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fca6f972d71fb1b9bacdc99478b21faeb0db384/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fca6f972d71fb1b9bacdc99478b21faeb0db384", "patch": "@@ -1,3 +1,10 @@\n+2006-11-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/25620\n+\t* builtins.c (expand_builtin_pow): Optimize non integer valued\n+\tconstant exponents using sqrt or cbrt if possible.  Always fall back\n+\tto expanding via optabs.\n+\n 2006-11-27  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/22372"}, {"sha": "d610198a637d537bba034d260ac0a371d309a731", "filename": "gcc/builtins.c", "status": "modified", "additions": 100, "deletions": 23, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fca6f972d71fb1b9bacdc99478b21faeb0db384/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fca6f972d71fb1b9bacdc99478b21faeb0db384/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=9fca6f972d71fb1b9bacdc99478b21faeb0db384", "patch": "@@ -2601,45 +2601,122 @@ expand_powi (rtx x, enum machine_mode mode, HOST_WIDE_INT n)\n static rtx\n expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n {\n+  tree arg0, arg1, fn, narg0, narglist;\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree arg0, arg1;\n+  tree type = TREE_TYPE (exp);\n+  REAL_VALUE_TYPE cint, c, c2;\n+  HOST_WIDE_INT n;\n+  rtx op, op2;\n+  enum machine_mode mode = TYPE_MODE (type);\n \n   if (! validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n     return 0;\n \n   arg0 = TREE_VALUE (arglist);\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n \n-  if (TREE_CODE (arg1) == REAL_CST\n-      && ! TREE_CONSTANT_OVERFLOW (arg1))\n+  if (TREE_CODE (arg1) != REAL_CST\n+      || TREE_CONSTANT_OVERFLOW (arg1))\n+    return expand_builtin_mathfn_2 (exp, target, subtarget);\n+\n+  /* Handle constant exponents.  */\n+\n+  /* For integer valued exponents we can expand to an optimal multiplication\n+     sequence using expand_powi.  */\n+  c = TREE_REAL_CST (arg1);\n+  n = real_to_integer (&c);\n+  real_from_integer (&cint, VOIDmode, n, n < 0 ? -1 : 0, 0);\n+  if (real_identical (&c, &cint)\n+      && ((n >= -1 && n <= 2)\n+\t  || (flag_unsafe_math_optimizations\n+\t      && !optimize_size\n+\t      && powi_cost (n) <= POWI_MAX_MULTS)))\n     {\n-      REAL_VALUE_TYPE cint;\n-      REAL_VALUE_TYPE c;\n-      HOST_WIDE_INT n;\n+      op = expand_expr (arg0, subtarget, VOIDmode, 0);\n+      if (n != 1)\n+\t{\n+\t  op = force_reg (mode, op);\n+\t  op = expand_powi (op, mode, n);\n+\t}\n+      return op;\n+    }\n \n-      c = TREE_REAL_CST (arg1);\n-      n = real_to_integer (&c);\n+  narg0 = builtin_save_expr (arg0);\n+  narglist = build_tree_list (NULL_TREE, narg0);\n+\n+  /* If the exponent is not integer valued, check if it is half of an integer.\n+     In this case we can expand to sqrt (x) * x**(n/2).  */\n+  fn = mathfn_built_in (type, BUILT_IN_SQRT);\n+  if (fn != NULL_TREE)\n+    {\n+      real_arithmetic (&c2, MULT_EXPR, &c, &dconst2);\n+      n = real_to_integer (&c2);\n       real_from_integer (&cint, VOIDmode, n, n < 0 ? -1 : 0, 0);\n-      if (real_identical (&c, &cint))\n-\t{\n-\t  /* If the exponent is -1, 0, 1 or 2, then expand_powi is exact.\n-\t     Otherwise, check the number of multiplications required.\n-\t     Note that pow never sets errno for an integer exponent.  */\n-\t  if ((n >= -1 && n <= 2)\n-\t      || (flag_unsafe_math_optimizations\n-\t\t  && ! optimize_size\n-\t\t  && powi_cost (n) <= POWI_MAX_MULTS))\n+      if (real_identical (&c2, &cint)\n+\t  && ((flag_unsafe_math_optimizations\n+\t       && !optimize_size\n+\t       && powi_cost (n/2) <= POWI_MAX_MULTS)\n+\t      || n == 1))\n+\t{\n+\t  tree call_expr = build_function_call_expr (fn, narglist);\n+\t  op = expand_builtin (call_expr, NULL_RTX, subtarget, mode, 0);\n+\t  if (n != 1)\n \t    {\n-\t      enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n-\t      rtx op = expand_expr (arg0, subtarget, VOIDmode, 0);\n-\t      op = force_reg (mode, op);\n-\t      return expand_powi (op, mode, n);\n+\t      op2 = expand_expr (narg0, subtarget, VOIDmode, 0);\n+\t      op2 = force_reg (mode, op2);\n+\t      op2 = expand_powi (op2, mode, abs (n / 2));\n+\t      op = expand_simple_binop (mode, MULT, op, op2, NULL_RTX,\n+\t\t\t\t\t0, OPTAB_LIB_WIDEN);\n+\t      /* If the original exponent was negative, reciprocate the\n+\t\t result.  */\n+\t      if (n < 0)\n+\t\top = expand_binop (mode, sdiv_optab, CONST1_RTX (mode),\n+\t\t\t\t   op, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \t    }\n+\t  return op;\n \t}\n     }\n \n-  if (! flag_unsafe_math_optimizations)\n-    return NULL_RTX;\n+  /* Try if the exponent is a third of an integer.  In this case\n+     we can expand to x**(n/3) * cbrt(x)**(n%3).  */\n+  fn = mathfn_built_in (type, BUILT_IN_CBRT);\n+  if (fn != NULL_TREE)\n+    {\n+      real_arithmetic (&c2, MULT_EXPR, &c, &dconst3);\n+      real_round (&c2, mode, &c2);\n+      n = real_to_integer (&c2);\n+      real_from_integer (&cint, VOIDmode, n, n < 0 ? -1 : 0, 0);\n+      real_arithmetic (&c2, RDIV_EXPR, &cint, &dconst3);\n+      real_convert (&c2, mode, &c2);\n+      if (real_identical (&c2, &c)\n+\t  && ((!optimize_size\n+\t       && flag_unsafe_math_optimizations\n+\t       && powi_cost (n/3) <= POWI_MAX_MULTS)\n+\t      || n == 1))\n+\t{\n+\t  tree call_expr = build_function_call_expr (fn, narglist);\n+\t  op = expand_builtin (call_expr, NULL_RTX, subtarget, mode, 0);\n+\t  if (abs (n) % 3 == 2)\n+\t    op = expand_simple_binop (mode, MULT, op, op, op,\n+\t\t\t\t      0, OPTAB_LIB_WIDEN);\n+\t  if (n != 1)\n+\t    {\n+\t      op2 = expand_expr (narg0, subtarget, VOIDmode, 0);\n+\t      op2 = force_reg (mode, op2);\n+\t      op2 = expand_powi (op2, mode, abs (n / 3));\n+\t      op = expand_simple_binop (mode, MULT, op, op2, NULL_RTX,\n+\t\t\t\t\t0, OPTAB_LIB_WIDEN);\n+\t      /* If the original exponent was negative, reciprocate the\n+\t\t result.  */\n+\t      if (n < 0)\n+\t\top = expand_binop (mode, sdiv_optab, CONST1_RTX (mode),\n+\t\t\t\t   op, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t    }\n+\t  return op;\n+\t}\n+    }\n+\n+  /* Fall back to optab expansion.  */\n   return expand_builtin_mathfn_2 (exp, target, subtarget);\n }\n "}, {"sha": "14e8f12da2e702d501d3bd00f9cd47c87d81be30", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fca6f972d71fb1b9bacdc99478b21faeb0db384/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fca6f972d71fb1b9bacdc99478b21faeb0db384/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9fca6f972d71fb1b9bacdc99478b21faeb0db384", "patch": "@@ -1,3 +1,9 @@\n+2006-11-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/25620\n+\t* gcc.target/i386/pow-1.c: New testcase.\n+\t* gcc.dg/builtins-58.c: Likewise.\n+\n 2006-11-26  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/29886"}, {"sha": "cf5a9c2f3cd27aa0559650a01e7e40661d642b16", "filename": "gcc/testsuite/gcc.dg/builtins-58.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fca6f972d71fb1b9bacdc99478b21faeb0db384/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fca6f972d71fb1b9bacdc99478b21faeb0db384/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-58.c?ref=9fca6f972d71fb1b9bacdc99478b21faeb0db384", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -ffast-math -std=c99\" } */\n+\n+#include \"builtins-config.h\"\n+\n+#ifdef HAVE_C99_RUNTIME\n+double test1 (double x)\n+{\n+  return __builtin_pow (x, 1./3.);\n+}\n+\n+double test2 (double x)\n+{\n+  return __builtin_pow (x, 4./3.);\n+}\n+\n+double test3a (double x)\n+{\n+  return __builtin_pow (x, 5./3.);\n+}\n+\n+double test3b (double x)\n+{\n+  return __builtin_pow (x, -5./3.);\n+}\n+\n+double test4 (double x)\n+{\n+  return __builtin_pow (x, 7./3.);\n+}\n+#endif\n+\n+/* { dg-final { scan-assembler-not \"pow\" } } */"}, {"sha": "3bb3fe0a90600934eedc02a4dbe4b0e80ca6abda", "filename": "gcc/testsuite/gcc.target/i386/pow-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fca6f972d71fb1b9bacdc99478b21faeb0db384/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fca6f972d71fb1b9bacdc99478b21faeb0db384/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpow-1.c?ref=9fca6f972d71fb1b9bacdc99478b21faeb0db384", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -ffast-math\" } */\n+\n+double test1 (double x)\n+{\n+  return __builtin_pow (x, 1./2.);\n+}\n+\n+double test2 (double x)\n+{\n+  return __builtin_pow (x, 3./2.);\n+}\n+\n+double test3 (double x)\n+{\n+  return __builtin_pow (x, 5./2.);\n+}\n+\n+double test4 (double x)\n+{\n+  return __builtin_pow (x, -5./2.);\n+}\n+\n+/* { dg-final { scan-assembler-not \"call\" } } */"}]}