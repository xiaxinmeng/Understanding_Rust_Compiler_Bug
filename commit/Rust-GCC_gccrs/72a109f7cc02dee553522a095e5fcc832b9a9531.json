{"sha": "72a109f7cc02dee553522a095e5fcc832b9a9531", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJhMTA5ZjdjYzAyZGVlNTUzNTIyYTA5NWU1ZmNjODMyYjlhOTUzMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-05-01T07:32:01Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-05-01T07:32:01Z"}, "message": "rs6000.c (altivec_expand_lv_builtin): Do not use switch statement on instruction code.\n\n\t* config/rs6000/rs6000.c (altivec_expand_lv_builtin): Do not use switch\n\tstatement on instruction code.  Remove trailing spaces.\n\t(altivec_expand_stv_builtin): Likewise.\n\nFrom-SVN: r235690", "tree": {"sha": "612731300742377a5fa88831ed56be858426f422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/612731300742377a5fa88831ed56be858426f422"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72a109f7cc02dee553522a095e5fcc832b9a9531", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a109f7cc02dee553522a095e5fcc832b9a9531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a109f7cc02dee553522a095e5fcc832b9a9531", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a109f7cc02dee553522a095e5fcc832b9a9531/comments", "author": null, "committer": null, "parents": [{"sha": "d5dd0a6208e74cedfff3a95edc3c21345cb7c357", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5dd0a6208e74cedfff3a95edc3c21345cb7c357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5dd0a6208e74cedfff3a95edc3c21345cb7c357"}], "stats": {"total": 178, "additions": 86, "deletions": 92}, "files": [{"sha": "999e7719179364b1c74265613a589f1d7bba5e53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a109f7cc02dee553522a095e5fcc832b9a9531/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a109f7cc02dee553522a095e5fcc832b9a9531/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72a109f7cc02dee553522a095e5fcc832b9a9531", "patch": "@@ -1,3 +1,9 @@\n+2016-05-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/rs6000/rs6000.c (altivec_expand_lv_builtin): Do not use switch\n+\tstatement on instruction code.  Remove trailing spaces.\n+\t(altivec_expand_stv_builtin): Likewise.\n+\n 2016-05-01  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/sh.h (TARGET_SH4): Remove and use default implementation."}, {"sha": "d12633d85c92589b9726b00accd8da6460f27f26", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 80, "deletions": 92, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a109f7cc02dee553522a095e5fcc832b9a9531/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a109f7cc02dee553522a095e5fcc832b9a9531/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=72a109f7cc02dee553522a095e5fcc832b9a9531", "patch": "@@ -13105,45 +13105,41 @@ altivec_expand_lv_builtin (enum insn_code icode, tree exp, rtx target, bool blk)\n   /* For LVX, express the RTL accurately by ANDing the address with -16.\n      LVXL and LVE*X expand to use UNSPECs to hide their special behavior,\n      so the raw address is fine.  */\n-  switch (icode)\n-    {\n-    case CODE_FOR_altivec_lvx_v2df_2op:\n-    case CODE_FOR_altivec_lvx_v2di_2op:\n-    case CODE_FOR_altivec_lvx_v4sf_2op:\n-    case CODE_FOR_altivec_lvx_v4si_2op:\n-    case CODE_FOR_altivec_lvx_v8hi_2op:\n-    case CODE_FOR_altivec_lvx_v16qi_2op:\n-      {\n-\trtx rawaddr;\n-\tif (op0 == const0_rtx)\n-\t  rawaddr = op1;\n-\telse\n-\t  {\n-\t    op0 = copy_to_mode_reg (mode0, op0);\n-\t    rawaddr = gen_rtx_PLUS (Pmode, op1, op0);\n-\t  }\n-\taddr = gen_rtx_AND (Pmode, rawaddr, gen_rtx_CONST_INT (Pmode, -16));\n-\taddr = gen_rtx_MEM (blk ? BLKmode : tmode, addr);\n-\n-\t/* For -maltivec=be, emit the load and follow it up with a\n-\t   permute to swap the elements.  */\n-\tif (!BYTES_BIG_ENDIAN && VECTOR_ELT_ORDER_BIG)\n-\t  {\n-\t    rtx temp = gen_reg_rtx (tmode);\n-\t    emit_insn (gen_rtx_SET (temp, addr));\n-\n-\t    rtx sel = swap_selector_for_mode (tmode);\n-\t    rtx vperm = gen_rtx_UNSPEC (tmode, gen_rtvec (3, temp, temp, sel),\n-\t\t\t\t\tUNSPEC_VPERM);\n-\t    emit_insn (gen_rtx_SET (target, vperm));\n-\t  }\n-\telse\n-\t  emit_insn (gen_rtx_SET (target, addr));\n+  if (icode == CODE_FOR_altivec_lvx_v2df_2op\n+      || icode == CODE_FOR_altivec_lvx_v2di_2op\n+      || icode == CODE_FOR_altivec_lvx_v4sf_2op\n+      || icode == CODE_FOR_altivec_lvx_v4si_2op\n+      || icode == CODE_FOR_altivec_lvx_v8hi_2op\n+      || icode == CODE_FOR_altivec_lvx_v16qi_2op)\n+    {\n+      rtx rawaddr;\n+      if (op0 == const0_rtx)\n+\trawaddr = op1;\n+      else\n+\t{\n+\t  op0 = copy_to_mode_reg (mode0, op0);\n+\t  rawaddr = gen_rtx_PLUS (Pmode, op1, op0);\n+\t}\n+      addr = gen_rtx_AND (Pmode, rawaddr, gen_rtx_CONST_INT (Pmode, -16));\n+      addr = gen_rtx_MEM (blk ? BLKmode : tmode, addr);\n \n-\tbreak;\n-      }\n+      /* For -maltivec=be, emit the load and follow it up with a\n+\t permute to swap the elements.  */\n+      if (!BYTES_BIG_ENDIAN && VECTOR_ELT_ORDER_BIG)\n+\t{\n+\t  rtx temp = gen_reg_rtx (tmode);\n+\t  emit_insn (gen_rtx_SET (temp, addr));\n \n-    default:\n+\t  rtx sel = swap_selector_for_mode (tmode);\n+\t  rtx vperm = gen_rtx_UNSPEC (tmode, gen_rtvec (3, temp, temp, sel),\n+\t\t\t\t      UNSPEC_VPERM);\n+\t  emit_insn (gen_rtx_SET (target, vperm));\n+\t}\n+      else\n+\temit_insn (gen_rtx_SET (target, addr));\n+    }\n+  else\n+    {\n       if (op0 == const0_rtx)\n \taddr = gen_rtx_MEM (blk ? BLKmode : tmode, op1);\n       else\n@@ -13157,10 +13153,8 @@ altivec_expand_lv_builtin (enum insn_code icode, tree exp, rtx target, bool blk)\n       if (! pat)\n \treturn 0;\n       emit_insn (pat);\n-\n-      break;\n     }\n-  \n+\n   return target;\n }\n \n@@ -13264,63 +13258,57 @@ altivec_expand_stv_builtin (enum insn_code icode, tree exp)\n   /* For STVX, express the RTL accurately by ANDing the address with -16.\n      STVXL and STVE*X expand to use UNSPECs to hide their special behavior,\n      so the raw address is fine.  */\n-  switch (icode)\n-    {\n-    case CODE_FOR_altivec_stvx_v2df_2op:\n-    case CODE_FOR_altivec_stvx_v2di_2op:\n-    case CODE_FOR_altivec_stvx_v4sf_2op:\n-    case CODE_FOR_altivec_stvx_v4si_2op:\n-    case CODE_FOR_altivec_stvx_v8hi_2op:\n-    case CODE_FOR_altivec_stvx_v16qi_2op:\n-      {\n-\tif (op1 == const0_rtx)\n-\t  rawaddr = op2;\n-\telse\n-\t  {\n-\t    op1 = copy_to_mode_reg (mode1, op1);\n-\t    rawaddr = gen_rtx_PLUS (Pmode, op2, op1);\n-\t  }\n-\n-\taddr = gen_rtx_AND (Pmode, rawaddr, gen_rtx_CONST_INT (Pmode, -16));\n-\taddr = gen_rtx_MEM (tmode, addr);\n-\n-\top0 = copy_to_mode_reg (tmode, op0);\n+  if (icode == CODE_FOR_altivec_stvx_v2df_2op\n+      || icode == CODE_FOR_altivec_stvx_v2di_2op\n+      || icode == CODE_FOR_altivec_stvx_v4sf_2op\n+      || icode == CODE_FOR_altivec_stvx_v4si_2op\n+      || icode == CODE_FOR_altivec_stvx_v8hi_2op\n+      || icode == CODE_FOR_altivec_stvx_v16qi_2op)\n+    {\n+      if (op1 == const0_rtx)\n+\trawaddr = op2;\n+      else\n+\t{\n+\t  op1 = copy_to_mode_reg (mode1, op1);\n+\t  rawaddr = gen_rtx_PLUS (Pmode, op2, op1);\n+\t}\n \n-\t/* For -maltivec=be, emit a permute to swap the elements, followed\n-\t   by the store.  */\n-\tif (!BYTES_BIG_ENDIAN && VECTOR_ELT_ORDER_BIG)\n-\t  {\n-\t    rtx temp = gen_reg_rtx (tmode);\n-\t    rtx sel = swap_selector_for_mode (tmode);\n-\t    rtx vperm = gen_rtx_UNSPEC (tmode, gen_rtvec (3, op0, op0, sel),\n-\t\t\t\t\tUNSPEC_VPERM);\n-\t    emit_insn (gen_rtx_SET (temp, vperm));\n-\t    emit_insn (gen_rtx_SET (addr, temp));\n-\t  }\n-\telse\n-\t  emit_insn (gen_rtx_SET (addr, op0));\n+      addr = gen_rtx_AND (Pmode, rawaddr, gen_rtx_CONST_INT (Pmode, -16));\n+      addr = gen_rtx_MEM (tmode, addr);\n \n-\tbreak;\n-      }\n+      op0 = copy_to_mode_reg (tmode, op0);\n \n-    default:\n-      {\n-\tif (! (*insn_data[icode].operand[1].predicate) (op0, smode))\n-\t  op0 = copy_to_mode_reg (smode, op0);\n+      /* For -maltivec=be, emit a permute to swap the elements, followed\n+\tby the store.  */\n+     if (!BYTES_BIG_ENDIAN && VECTOR_ELT_ORDER_BIG)\n+\t{\n+\t  rtx temp = gen_reg_rtx (tmode);\n+\t  rtx sel = swap_selector_for_mode (tmode);\n+\t  rtx vperm = gen_rtx_UNSPEC (tmode, gen_rtvec (3, op0, op0, sel),\n+\t\t\t\t      UNSPEC_VPERM);\n+\t  emit_insn (gen_rtx_SET (temp, vperm));\n+\t  emit_insn (gen_rtx_SET (addr, temp));\n+\t}\n+      else\n+\temit_insn (gen_rtx_SET (addr, op0));\n+    }\n+  else\n+    {\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, smode))\n+\top0 = copy_to_mode_reg (smode, op0);\n \n-\tif (op1 == const0_rtx)\n-\t  addr = gen_rtx_MEM (tmode, op2);\n-\telse\n-\t  {\n-\t    op1 = copy_to_mode_reg (mode1, op1);\n-\t    addr = gen_rtx_MEM (tmode, gen_rtx_PLUS (Pmode, op2, op1));\n-\t  }\n+      if (op1 == const0_rtx)\n+\taddr = gen_rtx_MEM (tmode, op2);\n+      else\n+\t{\n+\t  op1 = copy_to_mode_reg (mode1, op1);\n+\t  addr = gen_rtx_MEM (tmode, gen_rtx_PLUS (Pmode, op2, op1));\n+\t}\n \n-\tpat = GEN_FCN (icode) (addr, op0);\n-\tif (pat)\n-\t  emit_insn (pat);\n-      }\n-    }      \n+      pat = GEN_FCN (icode) (addr, op0);\n+      if (pat)\n+\temit_insn (pat);\n+    }\n \n   return NULL_RTX;\n }"}]}