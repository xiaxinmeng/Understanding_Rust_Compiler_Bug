{"sha": "280f58bab1ac41736ac1be1b8dcfc2c4c512809f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgwZjU4YmFiMWFjNDE3MzZhYzFiZTFiOGRjZmMyYzRjNTEyODA5Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-20T12:11:32Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-20T12:11:32Z"}, "message": "(make_compound_operation): Call recursively in the cases where we find a simplification.\n\n(make_compound_operation): Call recursively in the cases where we find a\nsimplification.\n(make_compound_operation, case SUBREG): If the recursive call changes the rtx\ncode and this is an appropriate SUBREG, use force_to_mode.\n\nFrom-SVN: r3800", "tree": {"sha": "0182d64e4087d5914eb15496e8725f3287d6b234", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0182d64e4087d5914eb15496e8725f3287d6b234"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/280f58bab1ac41736ac1be1b8dcfc2c4c512809f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280f58bab1ac41736ac1be1b8dcfc2c4c512809f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/280f58bab1ac41736ac1be1b8dcfc2c4c512809f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280f58bab1ac41736ac1be1b8dcfc2c4c512809f/comments", "author": null, "committer": null, "parents": [{"sha": "28d10ceaf5378573273250563b879c15296a77a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28d10ceaf5378573273250563b879c15296a77a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28d10ceaf5378573273250563b879c15296a77a4"}], "stats": {"total": 108, "additions": 74, "deletions": 34}, "files": [{"sha": "9e761308ccf01a6833e69242c9f2a78fb1155e7c", "filename": "gcc/combine.c", "status": "modified", "additions": 74, "deletions": 34, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280f58bab1ac41736ac1be1b8dcfc2c4c512809f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280f58bab1ac41736ac1be1b8dcfc2c4c512809f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=280f58bab1ac41736ac1be1b8dcfc2c4c512809f", "patch": "@@ -4951,6 +4951,7 @@ make_compound_operation (x, in_code)\n   enum rtx_code next_code;\n   int i, count;\n   rtx new = 0;\n+  rtx tem;\n   char *fmt;\n \n   /* Select the code to be used in recursive calls.  Once we are inside an\n@@ -4974,9 +4975,12 @@ make_compound_operation (x, in_code)\n       if (in_code == MEM && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT\n \t  && INTVAL (XEXP (x, 1)) >= 0)\n-\tnew = gen_rtx_combine (MULT, mode, XEXP (x, 0),\n-\t\t\t       GEN_INT ((HOST_WIDE_INT) 1\n-\t\t\t\t\t<< INTVAL (XEXP (x, 1))));\n+\t{\n+\t  new = make_compound_operation (XEXP (x, 0), next_code);\n+\t  new = gen_rtx_combine (MULT, mode, new,\n+\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t\t  << INTVAL (XEXP (x, 1))));\n+\t}\n       break;\n \n     case AND:\n@@ -4989,20 +4993,24 @@ make_compound_operation (x, in_code)\n \t is a logical right shift, make an extraction.  */\n       if (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n \t  && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n-\tnew = make_extraction (mode, XEXP (XEXP (x, 0), 0), 0,\n-\t\t\t       XEXP (XEXP (x, 0), 1), i, 1,\n-\t\t\t       0, in_code == COMPARE);\n+\t{\n+\t  new = make_compound_operation (XEXP (XEXP (x, 0), 0), next_code);\n+\t  new = make_extraction (mode, new, 0, XEXP (XEXP (x, 0), 1), i, 1,\n+\t\t\t\t 0, in_code == COMPARE);\n+\t}\n \n       /* Same as previous, but for (subreg (lshiftrt ...)) in first op.  */\n       else if (GET_CODE (XEXP (x, 0)) == SUBREG\n \t       && subreg_lowpart_p (XEXP (x, 0))\n \t       && GET_CODE (SUBREG_REG (XEXP (x, 0))) == LSHIFTRT\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n-\tnew = make_extraction (GET_MODE (SUBREG_REG (XEXP (x, 0))),\n-\t\t\t       XEXP (SUBREG_REG (XEXP (x, 0)), 0), 0,\n-\t\t\t       XEXP (SUBREG_REG (XEXP (x, 0)), 1), i, 1,\n-\t\t\t       0, in_code == COMPARE);\n-\n+\t{\n+\t  new = make_compound_operation (XEXP (SUBREG_REG (XEXP (x, 0)), 0),\n+\t\t\t\t\t next_code);\n+\t  new = make_extraction (GET_MODE (SUBREG_REG (XEXP (x, 0))), new, 0,\n+\t\t\t\t XEXP (SUBREG_REG (XEXP (x, 0)), 1), i, 1,\n+\t\t\t\t 0, in_code == COMPARE);\n+\t}\n \n       /* If we are have (and (rotate X C) M) and C is larger than the number\n \t of bits in M, this is an extraction.  */\n@@ -5011,10 +5019,13 @@ make_compound_operation (x, in_code)\n \t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0\n \t       && i <= INTVAL (XEXP (XEXP (x, 0), 1)))\n-\tnew = make_extraction (mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t       (GET_MODE_BITSIZE (mode)\n-\t\t\t\t- INTVAL (XEXP (XEXP (x, 0), 1))),\n-\t\t\t       NULL_RTX, i, 1, 0, in_code == COMPARE);\n+\t{\n+\t  new = make_compound_operation (XEXP (XEXP (x, 0), 0), next_code);\n+\t  new = make_extraction (mode, new,\n+\t\t\t\t (GET_MODE_BITSIZE (mode)\n+\t\t\t\t  - INTVAL (XEXP (XEXP (x, 0), 1))),\n+\t\t\t\t NULL_RTX, i, 1, 0, in_code == COMPARE);\n+\t}\n \n       /* On machines without logical shifts, if the operand of the AND is\n \t a logical shift and our mask turns off all the propagated sign\n@@ -5033,7 +5044,9 @@ make_compound_operation (x, in_code)\n \t  mask >>= INTVAL (XEXP (XEXP (x, 0), 1));\n \t  if ((INTVAL (XEXP (x, 1)) & ~mask) == 0)\n \t    SUBST (XEXP (x, 0),\n-\t\t   gen_rtx_combine (ASHIFTRT, mode, XEXP (XEXP (x, 0), 0),\n+\t\t   gen_rtx_combine (ASHIFTRT, mode,\n+\t\t\t\t    make_compound_operation (XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t\t\t     next_code),\n \t\t\t\t    XEXP (XEXP (x, 0), 1)));\n \t}\n \n@@ -5042,14 +5055,19 @@ make_compound_operation (x, in_code)\n \t If it doesn't end up being a ZERO_EXTEND, we will ignore it unless\n \t we are in a COMPARE.  */\n       else if ((i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n-\tnew = make_extraction (mode, XEXP (x, 0), 0, NULL_RTX, i, 1,\n-\t\t\t       0, in_code == COMPARE);\n+\tnew = make_extraction (mode,\n+\t\t\t       make_compound_operation (XEXP (x, 0),\n+\t\t\t\t\t\t\tnext_code),\n+\t\t\t       0, NULL_RTX, i, 1, 0, in_code == COMPARE);\n \n       /* If we are in a comparison and this is an AND with a power of two,\n \t convert this into the appropriate bit extract.  */\n       else if (in_code == COMPARE\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0)\n-\tnew = make_extraction (mode, XEXP (x, 0), i, NULL_RTX, 1, 1, 0, 1);\n+\tnew = make_extraction (mode,\n+\t\t\t       make_compound_operation (XEXP (x, 0),\n+\t\t\t\t\t\t\tnext_code),\n+\t\t\t       i, NULL_RTX, 1, 1, 0, 1);\n \n       break;\n \n@@ -5061,7 +5079,10 @@ make_compound_operation (x, in_code)\n \t  && mode_width <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (XEXP (x, 0), mode) & (1 << (mode_width - 1))) == 0)\n \t{\n-\t  new = gen_rtx_combine (ASHIFTRT, mode, XEXP (x, 0), XEXP (x, 1));\n+\t  new = gen_rtx_combine (ASHIFTRT, mode,\n+\t\t\t\t make_compound_operation (XEXP (x, 0),\n+\t\t\t\t\t\t\t  next_code),\n+\t\t\t\t XEXP (x, 1));\n \t  break;\n \t}\n \n@@ -5074,11 +5095,14 @@ make_compound_operation (x, in_code)\n \t  && GET_CODE (XEXP (x, 0)) == ASHIFT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) >= INTVAL (XEXP (XEXP (x, 0), 1)))\n-\tnew = make_extraction (mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t       (INTVAL (XEXP (x, 1))\n-\t\t\t\t- INTVAL (XEXP (XEXP (x, 0), 1))),\n-\t\t\t       NULL_RTX, mode_width - INTVAL (XEXP (x, 1)),\n-\t\t\t       code == LSHIFTRT, 0, in_code == COMPARE);\n+\t{\n+\t  new = make_compound_operation (XEXP (XEXP (x, 0), 0), next_code);\n+\t  new = make_extraction (mode, new,\n+\t\t\t\t (INTVAL (XEXP (x, 1))\n+\t\t\t\t  - INTVAL (XEXP (XEXP (x, 0), 1))),\n+\t\t\t\t NULL_RTX, mode_width - INTVAL (XEXP (x, 1)),\n+\t\t\t\t code == LSHIFTRT, 0, in_code == COMPARE);\n+\t}\n \n       /* Similarly if we have (ashifrt (OP (ashift foo C1) C3) C2).  In these\n \t cases, we are better off returning a SIGN_EXTEND of the operation.  */\n@@ -5100,9 +5124,10 @@ make_compound_operation (x, in_code)\n \t    = (INTVAL (XEXP (XEXP (x, 0), 1))\n \t       >> INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)));\n \n+\t  new = make_compound_operation (XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t\t\t\t\t next_code);\n \t  new = make_extraction (mode,\n-\t\t\t\t gen_binary (GET_CODE (XEXP (x, 0)), mode,\n-\t\t\t\t\t     XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t\t\t\t gen_binary (GET_CODE (XEXP (x, 0)), mode, new,\n \t\t\t\t\t     GEN_INT (newop1)),\n \t\t\t\t (INTVAL (XEXP (x, 1))\n \t\t\t\t  - INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))),\n@@ -5116,14 +5141,29 @@ make_compound_operation (x, in_code)\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == ASHIFT\n \t  && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) >= INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)))\n-\tnew = make_extraction (mode,\n-\t\t\t       gen_unary (GET_CODE (XEXP (x, 0)), mode,\n-\t\t\t\t\t  XEXP (XEXP (XEXP (x, 0), 0), 0)),\n-\t\t\t       (INTVAL (XEXP (x, 1))\n-\t\t\t\t- INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))),\n-\t\t\t       NULL_RTX, mode_width - INTVAL (XEXP (x, 1)),\n-\t\t\t       code == LSHIFTRT, 0, in_code == COMPARE);\n+\t{\n+\t  new = make_compound_operation (XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t\t\t\t\t next_code);\n+\t  new = make_extraction (mode,\n+\t\t\t\t gen_unary (GET_CODE (XEXP (x, 0)), mode,\n+\t\t\t\t\t    new, 0),\n+\t\t\t\t (INTVAL (XEXP (x, 1))\n+\t\t\t\t  - INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))),\n+\t\t\t\t NULL_RTX, mode_width - INTVAL (XEXP (x, 1)),\n+\t\t\t\t code == LSHIFTRT, 0, in_code == COMPARE);\n+\t}\n       break;\n+\n+    case SUBREG:\n+      /* Call ourselves recursively on the inner expression.  If we are\n+\t narrowing the object and it has a different RTL code from\n+\t what it originally did, do this SUBREG as a force_to_mode.  */\n+\n+      tem = make_compound_operation (SUBREG_REG (x), next_code);\n+      if (GET_CODE (tem) != GET_CODE (SUBREG_REG (x))\n+\t  && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (tem))\n+\t  && subreg_lowpart_p (x))\n+\treturn force_to_mode (tem, mode, GET_MODE_BITSIZE (mode), NULL_RTX);\n     }\n \n   if (new)"}]}