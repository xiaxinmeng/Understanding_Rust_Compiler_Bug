{"sha": "5e0f10a0f590b31bd7d78bd194c1c9808008f378", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUwZjEwYTBmNTkwYjMxYmQ3ZDc4YmQxOTRjMWM5ODA4MDA4ZjM3OA==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2016-11-23T17:33:39Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2016-11-23T17:33:39Z"}, "message": "[Patch 16/17 libgcc ARM] Half to double precision conversions\n\ngcc/\n\n\t* config/arm/arm.c (arm_convert_to_type): Delete.\n\t(TARGET_CONVERT_TO_TYPE): Delete.\n\t(arm_init_libfuncs): Enable trunc_optab from DFmode to HFmode.\n\t(arm_libcall_uses_aapcs_base): Add trunc_optab from DF- to HFmode.\n\t* config/arm/arm.h (TARGET_FP16_TO_DOUBLE): New.\n\t* config/arm/arm.md (truncdfhf2): Only convert through SFmode if we\n\tare in fast math mode, and have no single step hardware instruction.\n\t(extendhfdf2): Only expand through SFmode if we don't have a\n\tsingle-step hardware instruction.\n\t* config/arm/vfp.md (*truncdfhf2): New.\n\t(extendhfdf2): Likewise.\n\ngcc/testsuite/\n\n\t* gcc.target/arm/fp16-rounding-alt-1.c (ROUNDED): Change expected\n\tresult.\n\t* gcc.target/arm/fp16-rounding-ieee-1.c (ROUNDED): Change expected\n\tresult.\n\nFrom-SVN: r242783", "tree": {"sha": "3ee6485c7d9b7bddbb110c3138aafa0a48a342b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ee6485c7d9b7bddbb110c3138aafa0a48a342b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e0f10a0f590b31bd7d78bd194c1c9808008f378", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0f10a0f590b31bd7d78bd194c1c9808008f378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e0f10a0f590b31bd7d78bd194c1c9808008f378", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0f10a0f590b31bd7d78bd194c1c9808008f378/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bea64ca303c145dbe9763d63921d405833edeb0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bea64ca303c145dbe9763d63921d405833edeb0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bea64ca303c145dbe9763d63921d405833edeb0c"}], "stats": {"total": 163, "additions": 109, "deletions": 54}, "files": [{"sha": "4ab87a9d009ca0876881b4f4f459393db9a8fe57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e0f10a0f590b31bd7d78bd194c1c9808008f378", "patch": "@@ -1,3 +1,17 @@\n+2016-11-23  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/arm/arm.c (arm_convert_to_type): Delete.\n+\t(TARGET_CONVERT_TO_TYPE): Delete.\n+\t(arm_init_libfuncs): Enable trunc_optab from DFmode to HFmode.\n+\t(arm_libcall_uses_aapcs_base): Add trunc_optab from DF- to HFmode.\n+\t* config/arm/arm.h (TARGET_FP16_TO_DOUBLE): New.\n+\t* config/arm/arm.md (truncdfhf2): Only convert through SFmode if we\n+\tare in fast math mode, and have no single step hardware instruction.\n+\t(extendhfdf2): Only expand through SFmode if we don't have a\n+\tsingle-step hardware instruction.\n+\t* config/arm/vfp.md (*truncdfhf2): New.\n+\t(extendhfdf2): Likewise.\n+\n 2016-11-23  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* targhooks.c (default_floatn_mode): Enable _Float16 if a target"}, {"sha": "118b93b94308a1e2411d330faaeff8c873b39264", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5e0f10a0f590b31bd7d78bd194c1c9808008f378", "patch": "@@ -245,7 +245,6 @@ static bool arm_output_addr_const_extra (FILE *, rtx);\n static bool arm_allocate_stack_slots_for_args (void);\n static bool arm_warn_func_return (tree);\n static tree arm_promoted_type (const_tree t);\n-static tree arm_convert_to_type (tree type, tree expr);\n static bool arm_scalar_mode_supported_p (machine_mode);\n static bool arm_frame_pointer_required (void);\n static bool arm_can_eliminate (const int, const int);\n@@ -654,9 +653,6 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef TARGET_PROMOTED_TYPE\n #define TARGET_PROMOTED_TYPE arm_promoted_type\n \n-#undef TARGET_CONVERT_TO_TYPE\n-#define TARGET_CONVERT_TO_TYPE arm_convert_to_type\n-\n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P arm_scalar_mode_supported_p\n \n@@ -2535,6 +2531,11 @@ arm_init_libfuncs (void)\n \t\t\t ? \"__gnu_h2f_ieee\"\n \t\t\t : \"__gnu_h2f_alternative\"));\n \n+      set_conv_libfunc (trunc_optab, HFmode, DFmode,\n+\t\t\t(arm_fp16_format == ARM_FP16_FORMAT_IEEE\n+\t\t\t ? \"__gnu_d2h_ieee\"\n+\t\t\t : \"__gnu_d2h_alternative\"));\n+\n       /* Arithmetic.  */\n       set_optab_libfunc (add_optab, HFmode, NULL);\n       set_optab_libfunc (sdiv_optab, HFmode, NULL);\n@@ -5259,6 +5260,8 @@ arm_libcall_uses_aapcs_base (const_rtx libcall)\n \t\t\t\t\t\t\tSFmode));\n       add_libcall (libcall_htab, convert_optab_libfunc (trunc_optab, SFmode,\n \t\t\t\t\t\t\tDFmode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (trunc_optab, HFmode, DFmode));\n     }\n \n   return libcall && libcall_htab->find (libcall) != NULL;\n@@ -22514,23 +22517,6 @@ arm_promoted_type (const_tree t)\n   return NULL_TREE;\n }\n \n-/* Implement TARGET_CONVERT_TO_TYPE.\n-   Specifically, this hook implements the peculiarity of the ARM\n-   half-precision floating-point C semantics that requires conversions between\n-   __fp16 to or from double to do an intermediate conversion to float.  */\n-\n-static tree\n-arm_convert_to_type (tree type, tree expr)\n-{\n-  tree fromtype = TREE_TYPE (expr);\n-  if (!SCALAR_FLOAT_TYPE_P (fromtype) || !SCALAR_FLOAT_TYPE_P (type))\n-    return NULL_TREE;\n-  if ((TYPE_PRECISION (fromtype) == 16 && TYPE_PRECISION (type) > 32)\n-      || (TYPE_PRECISION (type) == 16 && TYPE_PRECISION (fromtype) > 32))\n-    return convert (type, convert (float_type_node, expr));\n-  return NULL_TREE;\n-}\n-\n /* Implement TARGET_SCALAR_MODE_SUPPORTED_P.\n    This simply adds HFmode as a supported mode; even though we don't\n    implement arithmetic on this type directly, it's supported by"}, {"sha": "15930f0ca8fa148f1b02745574cc6994f0c5f837", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=5e0f10a0f590b31bd7d78bd194c1c9808008f378", "patch": "@@ -179,6 +179,11 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #define TARGET_FP16\t\t\t\t\t\t\t\\\n   (ARM_FPU_FSET_HAS (TARGET_FPU_FEATURES, FPU_FL_FP16))\n \n+/* FPU supports converting between HFmode and DFmode in a single hardware\n+   step.  */\n+#define TARGET_FP16_TO_DOUBLE\t\t\t\t\t\t\\\n+  (TARGET_HARD_FLOAT && (TARGET_FP16 && TARGET_VFP5))\n+\n /* FPU supports fused-multiply-add operations.  */\n #define TARGET_FMA (TARGET_FPU_REV >= 4)\n "}, {"sha": "5523baf5099cb7c35a6ad3c8a39e5c31efd32f17", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=5e0f10a0f590b31bd7d78bd194c1c9808008f378", "patch": "@@ -5182,20 +5182,34 @@\n   \"\"\n )\n \n-;; DFmode to HFmode conversions have to go through SFmode.\n+;; DFmode to HFmode conversions on targets without a single-step hardware\n+;; instruction for it would have to go through SFmode.  This is dangerous\n+;; as it introduces double rounding.\n+;;\n+;; Disable this pattern unless we are in an unsafe math mode, or we have\n+;; a single-step instruction.\n+\n (define_expand \"truncdfhf2\"\n-  [(set (match_operand:HF  0 \"general_operand\" \"\")\n+  [(set (match_operand:HF  0 \"s_register_operand\" \"\")\n \t(float_truncate:HF\n- \t (match_operand:DF 1 \"general_operand\" \"\")))]\n-  \"TARGET_EITHER\"\n-  \"\n-  {\n-    rtx op1;\n-    op1 = convert_to_mode (SFmode, operands[1], 0);\n-    op1 = convert_to_mode (HFmode, op1, 0);\n-    emit_move_insn (operands[0], op1);\n-    DONE;\n-  }\"\n+\t (match_operand:DF 1 \"s_register_operand\" \"\")))]\n+  \"(TARGET_EITHER && flag_unsafe_math_optimizations)\n+   || (TARGET_32BIT && TARGET_FP16_TO_DOUBLE)\"\n+{\n+  /* We don't have a direct instruction for this, so we must be in\n+     an unsafe math mode, and going via SFmode.  */\n+\n+  if (!(TARGET_32BIT && TARGET_FP16_TO_DOUBLE))\n+    {\n+      rtx op1;\n+      op1 = convert_to_mode (SFmode, operands[1], 0);\n+      op1 = convert_to_mode (HFmode, op1, 0);\n+      emit_move_insn (operands[0], op1);\n+      DONE;\n+    }\n+  /* Otherwise, we will pick this up as a single instruction with\n+     no intermediary rounding.  */\n+}\n )\n \f\n ;; Zero and sign extension instructions.\n@@ -5689,19 +5703,28 @@\n   \"\"\n )\n \n-;; HFmode -> DFmode conversions have to go through SFmode.\n+;; HFmode -> DFmode conversions where we don't have an instruction for it\n+;; must go through SFmode.\n+;;\n+;; This is always safe for an extend.\n+\n (define_expand \"extendhfdf2\"\n-  [(set (match_operand:DF                  0 \"general_operand\" \"\")\n-\t(float_extend:DF (match_operand:HF 1 \"general_operand\"  \"\")))]\n+  [(set (match_operand:DF\t\t   0 \"s_register_operand\" \"\")\n+\t(float_extend:DF (match_operand:HF 1 \"s_register_operand\" \"\")))]\n   \"TARGET_EITHER\"\n-  \"\n-  {\n-    rtx op1;\n-    op1 = convert_to_mode (SFmode, operands[1], 0);\n-    op1 = convert_to_mode (DFmode, op1, 0);\n-    emit_insn (gen_movdf (operands[0], op1));\n-    DONE;\n-  }\"\n+{\n+  /* We don't have a direct instruction for this, so go via SFmode.  */\n+  if (!(TARGET_32BIT && TARGET_FP16_TO_DOUBLE))\n+    {\n+      rtx op1;\n+      op1 = convert_to_mode (SFmode, operands[1], 0);\n+      op1 = convert_to_mode (DFmode, op1, 0);\n+      emit_insn (gen_movdf (operands[0], op1));\n+      DONE;\n+    }\n+  /* Otherwise, we're done producing RTL and will pick up the correct\n+     pattern to do this with one rounding-step in a single instruction.  */\n+}\n )\n \f\n ;; Move insns (including loads and stores)"}, {"sha": "f83dc9b130e4288faa49e40ee8285a0cd7d325b1", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=5e0f10a0f590b31bd7d78bd194c1c9808008f378", "patch": "@@ -1507,6 +1507,26 @@\n    (set_attr \"type\" \"f_cvt\")]\n )\n \n+(define_insn \"*truncdfhf2\"\n+  [(set (match_operand:HF\t\t   0 \"s_register_operand\" \"=t\")\n+\t(float_truncate:HF (match_operand:DF 1 \"s_register_operand\" \"w\")))]\n+  \"TARGET_32BIT && TARGET_FP16_TO_DOUBLE\"\n+  \"vcvtb%?.f16.f64\\\\t%0, %P1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"predicable_short_it\" \"no\")\n+   (set_attr \"type\" \"f_cvt\")]\n+)\n+\n+(define_insn \"*extendhfdf2\"\n+  [(set (match_operand:DF\t\t   0 \"s_register_operand\" \"=w\")\n+\t(float_extend:DF (match_operand:HF 1 \"s_register_operand\" \"t\")))]\n+  \"TARGET_32BIT && TARGET_FP16_TO_DOUBLE\"\n+  \"vcvtb%?.f64.f16\\\\t%P0, %1\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"predicable_short_it\" \"no\")\n+   (set_attr \"type\" \"f_cvt\")]\n+)\n+\n (define_insn \"truncsfhf2\"\n   [(set (match_operand:HF\t\t   0 \"s_register_operand\" \"=t\")\n \t(float_truncate:HF (match_operand:SF 1 \"s_register_operand\" \"t\")))]"}, {"sha": "0d5909052d44c00c92cad6186c4fc132d81cc120", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e0f10a0f590b31bd7d78bd194c1c9808008f378", "patch": "@@ -1,3 +1,10 @@\n+2016-11-23  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* gcc.target/arm/fp16-rounding-alt-1.c (ROUNDED): Change expected\n+\tresult.\n+\t* gcc.target/arm/fp16-rounding-ieee-1.c (ROUNDED): Change expected\n+\tresult.\n+\n 2016-11-23  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* lib/target-supports.exp (check_effective_target_float16): Add"}, {"sha": "27bb40dcfee837587e79af6e2be90290a572c06f", "filename": "gcc/testsuite/gcc.target/arm/fp16-rounding-alt-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-rounding-alt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-rounding-alt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-rounding-alt-1.c?ref=5e0f10a0f590b31bd7d78bd194c1c9808008f378", "patch": "@@ -1,6 +1,6 @@\n-/* Test intermediate rounding of double to float and then to __fp16, using\n-   an example of a number that would round differently if it went directly\n-   from double to __fp16.  */\n+/* Test that rounding double to __fp16 happens directly, using an example\n+   of a number that would round differently if it went from double to\n+   __fp16 via float.  */\n \n /* { dg-do run } */\n /* { dg-require-effective-target arm_fp16_alternative_ok } */\n@@ -11,8 +11,8 @@\n /* The original double value.  */\n #define ORIG 0x1.0020008p0\n \n-/* The expected (double)((__fp16)((float)ORIG)) value.  */\n-#define ROUNDED 0x1.0000000p0\n+/* The expected (double)((__fp16)ORIG) value.  */\n+#define ROUNDED 0x1.0040000p0\n \n typedef union u {\n   __fp16 f;"}, {"sha": "194dc9dc3bdff9721c5a37e0ec06b1a7d6627a4c", "filename": "gcc/testsuite/gcc.target/arm/fp16-rounding-ieee-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-rounding-ieee-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0f10a0f590b31bd7d78bd194c1c9808008f378/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-rounding-ieee-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-rounding-ieee-1.c?ref=5e0f10a0f590b31bd7d78bd194c1c9808008f378", "patch": "@@ -1,6 +1,6 @@\n-/* Test intermediate rounding of double to float and then to __fp16, using\n-   an example of a number that would round differently if it went directly\n-   from double to __fp16.  */\n+/* Test that rounding double to __fp16 happens directly, using an example\n+   of a number that would round differently if it went from double to\n+   __fp16 via float.  */\n \n /* { dg-do run } */\n /* { dg-options \"-mfp16-format=ieee\" } */\n@@ -10,8 +10,8 @@\n /* The original double value.  */\n #define ORIG 0x1.0020008p0\n \n-/* The expected (double)((__fp16)((float)ORIG)) value.  */\n-#define ROUNDED 0x1.0000000p0\n+/* The expected (double)((__fp16)ORIG) value.  */\n+#define ROUNDED 0x1.0040000p0\n \n typedef union u {\n   __fp16 f;"}]}