{"sha": "8240018b0c5da12a6e6df5689055983e76768151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI0MDAxOGIwYzVkYTEyYTZlNmRmNTY4OTA1NTk4M2U3Njc2ODE1MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-11-12T15:52:42Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-11-12T15:52:42Z"}, "message": "Implement protection of global variables\n\nThis patch implements the protection of global variables.  See the\ncomments appended to the beginning of the asan.c file.\n\n\t* varasm.c: Include asan.h.\n\t(assemble_noswitch_variable): Grow size by asan_red_zone_size\n\tif decl is asan protected.\n\t(place_block_symbol): Likewise.\n\t(assemble_variable): If decl is asan protected, increase\n\tDECL_ALIGN if needed, and for decls emitted using\n\tassemble_variable_contents append padding zeros after it.\n\t* Makefile.in (varasm.o): Depend on asan.h.\n\t* asan.c: Include output.h.\n\t(asan_pp, asan_pp_initialized, asan_ctor_statements): New variables.\n\t(asan_pp_initialize, asan_pp_string): New functions.\n\t(asan_emit_stack_protection): Use asan_pp{,_initialized}\n\tinstead of local pp{,_initialized} vars, use asan_pp_initialize\n\tand asan_pp_string helpers.\n\t(asan_needs_local_alias, asan_protect_global,\n\tasan_global_struct, asan_add_global): New functions.\n\t(asan_finish_file): Protect global vars that can be protected. Use\n\tasan_ctor_statements instead of ctor_statements\n\t* asan.h (asan_protect_global): New prototype.\n\t(asan_red_zone_size): New inline function.\n\nCo-Authored-By: Wei Mi <wmi@google.com>\n\nFrom-SVN: r193437", "tree": {"sha": "18be1f25e100232473bd95eeef5508dbb137f634", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18be1f25e100232473bd95eeef5508dbb137f634"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8240018b0c5da12a6e6df5689055983e76768151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8240018b0c5da12a6e6df5689055983e76768151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8240018b0c5da12a6e6df5689055983e76768151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8240018b0c5da12a6e6df5689055983e76768151/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f3ddd6929ad26e1c6202265460730241ad6c28d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3ddd6929ad26e1c6202265460730241ad6c28d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3ddd6929ad26e1c6202265460730241ad6c28d0"}], "stats": {"total": 403, "additions": 365, "deletions": 38}, "files": [{"sha": "49ac3850fa676fad717251b7f6a723b8694f0db2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8240018b0c5da12a6e6df5689055983e76768151/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8240018b0c5da12a6e6df5689055983e76768151/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8240018b0c5da12a6e6df5689055983e76768151", "patch": "@@ -1,3 +1,27 @@\n+2012-11-12  Jakub Jelinek  <jakub@redhat.com>\n+\t    Wei Mi <wmi@google.com>\n+\n+\t* varasm.c: Include asan.h.\n+\t(assemble_noswitch_variable): Grow size by asan_red_zone_size\n+\tif decl is asan protected.\n+\t(place_block_symbol): Likewise.\n+\t(assemble_variable): If decl is asan protected, increase\n+\tDECL_ALIGN if needed, and for decls emitted using\n+\tassemble_variable_contents append padding zeros after it.\n+\t* Makefile.in (varasm.o): Depend on asan.h.\n+\t* asan.c: Include output.h.\n+\t(asan_pp, asan_pp_initialized, asan_ctor_statements): New variables.\n+\t(asan_pp_initialize, asan_pp_string): New functions.\n+\t(asan_emit_stack_protection): Use asan_pp{,_initialized}\n+\tinstead of local pp{,_initialized} vars, use asan_pp_initialize\n+\tand asan_pp_string helpers.\n+\t(asan_needs_local_alias, asan_protect_global,\n+\tasan_global_struct, asan_add_global): New functions.\n+\t(asan_finish_file): Protect global vars that can be protected. Use\n+\tasan_ctor_statements instead of ctor_statements\n+\t* asan.h (asan_protect_global): New prototype.\n+\t(asan_red_zone_size): New inline function.\n+\n 2012-11-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* Makefile.in (asan.o): Depend on $(EXPR_H) $(OPTABS_H)."}, {"sha": "83a424e5e9dead9492a7d295655bccdb8179e3e6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8240018b0c5da12a6e6df5689055983e76768151/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8240018b0c5da12a6e6df5689055983e76768151/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8240018b0c5da12a6e6df5689055983e76768151", "patch": "@@ -2719,7 +2719,7 @@ varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    output.h $(DIAGNOSTIC_CORE_H) xcoffout.h debug.h $(GGC_H) $(TM_P_H) \\\n    $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h $(BASIC_BLOCK_H) \\\n    $(CGRAPH_H) $(TARGET_DEF_H) tree-mudflap.h \\\n-   pointer-set.h $(COMMON_TARGET_H)\n+   pointer-set.h $(COMMON_TARGET_H) asan.h\n function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    $(TREE_H) $(GIMPLE_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) \\\n    $(OPTABS_H) $(LIBFUNCS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\"}, {"sha": "db82ba7aadb6c1f0e906774ddb7566033f80147b", "filename": "gcc/asan.c", "status": "modified", "additions": 307, "deletions": 37, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8240018b0c5da12a6e6df5689055983e76768151/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8240018b0c5da12a6e6df5689055983e76768151/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=8240018b0c5da12a6e6df5689055983e76768151", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n+#include \"output.h\"\n \n /*\n  AddressSanitizer finds out-of-bounds and use-after-free bugs \n@@ -166,14 +167,78 @@ along with GCC; see the file COPYING3.  If not see\n  non-accessible) the regions of the red zones and mark the regions of\n  stack variables as accessible, and emit some epilogue code to\n  un-poison (mark as accessible) the regions of red zones right before\n- the function exits.  */\n+ the function exits.\n+\n+ [Protection of global variables]\n+\n+ The basic idea is to insert a red zone between two global variables\n+ and install a constructor function that calls the asan runtime to do\n+ the populating of the relevant shadow memory regions at load time.\n+\n+ So the global variables are laid out as to insert a red zone between\n+ them. The size of the red zones is so that each variable starts on a\n+ 32 bytes boundary.\n+\n+ Then a constructor function is installed so that, for each global\n+ variable, it calls the runtime asan library function\n+ __asan_register_globals_with an instance of this type:\n+\n+     struct __asan_global\n+     {\n+       // Address of the beginning of the global variable.\n+       const void *__beg;\n+\n+       // Initial size of the global variable.\n+       uptr __size;\n+\n+       // Size of the global variable + size of the red zone.  This\n+       //   size is 32 bytes aligned.\n+       uptr __size_with_redzone;\n+\n+       // Name of the global variable.\n+       const void *__name;\n+\n+       // This is always set to NULL for now.\n+       uptr __has_dynamic_init;\n+     }\n+\n+ A destructor function that calls the runtime asan library function\n+ _asan_unregister_globals is also installed.  */\n \n alias_set_type asan_shadow_set = -1;\n \n /* Pointer types to 1 resp. 2 byte integers in shadow memory.  A separate\n    alias set is used for all shadow memory accesses.  */\n static GTY(()) tree shadow_ptr_types[2];\n \n+/* Asan pretty-printer, used for buidling of the description STRING_CSTs.  */\n+static pretty_printer asan_pp;\n+static bool asan_pp_initialized;\n+\n+/* Initialize asan_pp.  */\n+\n+static void\n+asan_pp_initialize (void)\n+{\n+  pp_construct (&asan_pp, /* prefix */NULL, /* line-width */0);\n+  asan_pp_initialized = true;\n+}\n+\n+/* Create ADDR_EXPR of STRING_CST with asan_pp text.  */\n+\n+static tree\n+asan_pp_string (void)\n+{\n+  const char *buf = pp_base_formatted_text (&asan_pp);\n+  size_t len = strlen (buf);\n+  tree ret = build_string (len + 1, buf);\n+  TREE_TYPE (ret)\n+    = build_array_type (char_type_node, build_index_type (size_int (len)));\n+  TREE_READONLY (ret) = 1;\n+  TREE_STATIC (ret) = 1;\n+  return build1 (ADDR_EXPR, build_pointer_type (char_type_node), ret);\n+}\n+\n /* Return a CONST_INT representing 4 subsequent shadow memory bytes.  */\n \n static rtx\n@@ -208,51 +273,38 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n   HOST_WIDE_INT last_offset, last_size;\n   int l;\n   unsigned char cur_shadow_byte = ASAN_STACK_MAGIC_LEFT;\n-  static pretty_printer pp;\n-  static bool pp_initialized;\n-  const char *buf;\n-  size_t len;\n   tree str_cst;\n \n   /* First of all, prepare the description string.  */\n-  if (!pp_initialized)\n-    {\n-      pp_construct (&pp, /* prefix */NULL, /* line-width */0);\n-      pp_initialized = true;\n-    }\n-  pp_clear_output_area (&pp);\n+  if (!asan_pp_initialized)\n+    asan_pp_initialize ();\n+\n+  pp_clear_output_area (&asan_pp);\n   if (DECL_NAME (current_function_decl))\n-    pp_base_tree_identifier (&pp, DECL_NAME (current_function_decl));\n+    pp_base_tree_identifier (&asan_pp, DECL_NAME (current_function_decl));\n   else\n-    pp_string (&pp, \"<unknown>\");\n-  pp_space (&pp);\n-  pp_decimal_int (&pp, length / 2 - 1);\n-  pp_space (&pp);\n+    pp_string (&asan_pp, \"<unknown>\");\n+  pp_space (&asan_pp);\n+  pp_decimal_int (&asan_pp, length / 2 - 1);\n+  pp_space (&asan_pp);\n   for (l = length - 2; l; l -= 2)\n     {\n       tree decl = decls[l / 2 - 1];\n-      pp_wide_integer (&pp, offsets[l] - base_offset);\n-      pp_space (&pp);\n-      pp_wide_integer (&pp, offsets[l - 1] - offsets[l]);\n-      pp_space (&pp);\n+      pp_wide_integer (&asan_pp, offsets[l] - base_offset);\n+      pp_space (&asan_pp);\n+      pp_wide_integer (&asan_pp, offsets[l - 1] - offsets[l]);\n+      pp_space (&asan_pp);\n       if (DECL_P (decl) && DECL_NAME (decl))\n \t{\n-\t  pp_decimal_int (&pp, IDENTIFIER_LENGTH (DECL_NAME (decl)));\n-\t  pp_space (&pp);\n-\t  pp_base_tree_identifier (&pp, DECL_NAME (decl));\n+\t  pp_decimal_int (&asan_pp, IDENTIFIER_LENGTH (DECL_NAME (decl)));\n+\t  pp_space (&asan_pp);\n+\t  pp_base_tree_identifier (&asan_pp, DECL_NAME (decl));\n \t}\n       else\n-\tpp_string (&pp, \"9 <unknown>\");\n-      pp_space (&pp);\n+\tpp_string (&asan_pp, \"9 <unknown>\");\n+      pp_space (&asan_pp);\n     }\n-  buf = pp_base_formatted_text (&pp);\n-  len = strlen (buf);\n-  str_cst = build_string (len + 1, buf);\n-  TREE_TYPE (str_cst)\n-    = build_array_type (char_type_node, build_index_type (size_int (len)));\n-  TREE_READONLY (str_cst) = 1;\n-  TREE_STATIC (str_cst) = 1;\n-  str_cst = build1 (ADDR_EXPR, build_pointer_type (char_type_node), str_cst);\n+  str_cst = asan_pp_string ();\n \n   /* Emit the prologue sequence.  */\n   base = expand_binop (Pmode, add_optab, base, GEN_INT (base_offset),\n@@ -357,6 +409,75 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n   return ret;\n }\n \n+/* Return true if DECL, a global var, might be overridden and needs\n+   therefore a local alias.  */\n+\n+static bool\n+asan_needs_local_alias (tree decl)\n+{\n+  return DECL_WEAK (decl) || !targetm.binds_local_p (decl);\n+}\n+\n+/* Return true if DECL is a VAR_DECL that should be protected\n+   by Address Sanitizer, by appending a red zone with protected\n+   shadow memory after it and aligning it to at least\n+   ASAN_RED_ZONE_SIZE bytes.  */\n+\n+bool\n+asan_protect_global (tree decl)\n+{\n+  rtx rtl, symbol;\n+  section *sect;\n+\n+  if (TREE_CODE (decl) != VAR_DECL\n+      /* TLS vars aren't statically protectable.  */\n+      || DECL_THREAD_LOCAL_P (decl)\n+      /* Externs will be protected elsewhere.  */\n+      || DECL_EXTERNAL (decl)\n+      || !TREE_ASM_WRITTEN (decl)\n+      || !DECL_RTL_SET_P (decl)\n+      /* Comdat vars pose an ABI problem, we can't know if\n+\t the var that is selected by the linker will have\n+\t padding or not.  */\n+      || DECL_ONE_ONLY (decl)\n+      /* Similarly for common vars.  People can use -fno-common.  */\n+      || DECL_COMMON (decl)\n+      /* Don't protect if using user section, often vars placed\n+\t into user section from multiple TUs are then assumed\n+\t to be an array of such vars, putting padding in there\n+\t breaks this assumption.  */\n+      || (DECL_SECTION_NAME (decl) != NULL_TREE\n+\t  && !DECL_HAS_IMPLICIT_SECTION_NAME_P (decl))\n+      || DECL_SIZE (decl) == 0\n+      || ASAN_RED_ZONE_SIZE * BITS_PER_UNIT > MAX_OFILE_ALIGNMENT\n+      || !valid_constant_size_p (DECL_SIZE_UNIT (decl))\n+      || DECL_ALIGN_UNIT (decl) > 2 * ASAN_RED_ZONE_SIZE)\n+    return false;\n+\n+  rtl = DECL_RTL (decl);\n+  if (!MEM_P (rtl) || GET_CODE (XEXP (rtl, 0)) != SYMBOL_REF)\n+    return false;\n+  symbol = XEXP (rtl, 0);\n+\n+  if (CONSTANT_POOL_ADDRESS_P (symbol)\n+      || TREE_CONSTANT_POOL_ADDRESS_P (symbol))\n+    return false;\n+\n+  sect = get_variable_section (decl, false);\n+  if (sect->common.flags & SECTION_COMMON)\n+    return false;\n+\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n+    return false;\n+\n+#ifndef ASM_OUTPUT_DEF\n+  if (asan_needs_local_alias (decl))\n+    return false;\n+#endif\n+\n+  return true;    \n+}\n+\n /* Construct a function tree for __asan_report_{load,store}{1,2,4,8,16}.\n    IS_STORE is either 1 (for a store) or 0 (for a load).\n    SIZE_IN_BYTES is one of 1, 2, 4, 8, 16.  */\n@@ -657,6 +778,105 @@ transform_statements (void)\n     }\n }\n \n+/* Build\n+   struct __asan_global\n+   {\n+     const void *__beg;\n+     uptr __size;\n+     uptr __size_with_redzone;\n+     const void *__name;\n+     uptr __has_dynamic_init;\n+   } type.  */\n+\n+static tree\n+asan_global_struct (void)\n+{\n+  static const char *field_names[5]\n+    = { \"__beg\", \"__size\", \"__size_with_redzone\",\n+\t\"__name\", \"__has_dynamic_init\" };\n+  tree fields[5], ret;\n+  int i;\n+\n+  ret = make_node (RECORD_TYPE);\n+  for (i = 0; i < 5; i++)\n+    {\n+      fields[i]\n+\t= build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t      get_identifier (field_names[i]),\n+\t\t      (i == 0 || i == 3) ? const_ptr_type_node\n+\t\t      : build_nonstandard_integer_type (POINTER_SIZE, 1));\n+      DECL_CONTEXT (fields[i]) = ret;\n+      if (i)\n+\tDECL_CHAIN (fields[i - 1]) = fields[i];\n+    }\n+  TYPE_FIELDS (ret) = fields[0];\n+  TYPE_NAME (ret) = get_identifier (\"__asan_global\");\n+  layout_type (ret);\n+  return ret;\n+}\n+\n+/* Append description of a single global DECL into vector V.\n+   TYPE is __asan_global struct type as returned by asan_global_struct.  */\n+\n+static void\n+asan_add_global (tree decl, tree type, VEC(constructor_elt, gc) *v)\n+{\n+  tree init, uptr = TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (type)));\n+  unsigned HOST_WIDE_INT size;\n+  tree str_cst, refdecl = decl;\n+  VEC(constructor_elt, gc) *vinner = NULL;\n+\n+  if (!asan_pp_initialized)\n+    asan_pp_initialize ();\n+\n+  pp_clear_output_area (&asan_pp);\n+  if (DECL_NAME (decl))\n+    pp_base_tree_identifier (&asan_pp, DECL_NAME (decl));\n+  else\n+    pp_string (&asan_pp, \"<unknown>\");\n+  pp_space (&asan_pp);\n+  pp_left_paren (&asan_pp);\n+  pp_string (&asan_pp, main_input_filename);\n+  pp_right_paren (&asan_pp);\n+  str_cst = asan_pp_string ();\n+\n+  if (asan_needs_local_alias (decl))\n+    {\n+      char buf[20];\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LASAN\",\n+\t\t\t\t   VEC_length (constructor_elt, v) + 1);\n+      refdecl = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t\t    VAR_DECL, get_identifier (buf), TREE_TYPE (decl));\n+      TREE_ADDRESSABLE (refdecl) = TREE_ADDRESSABLE (decl);\n+      TREE_READONLY (refdecl) = TREE_READONLY (decl);\n+      TREE_THIS_VOLATILE (refdecl) = TREE_THIS_VOLATILE (decl);\n+      DECL_GIMPLE_REG_P (refdecl) = DECL_GIMPLE_REG_P (decl);\n+      DECL_ARTIFICIAL (refdecl) = DECL_ARTIFICIAL (decl);\n+      DECL_IGNORED_P (refdecl) = DECL_IGNORED_P (decl);\n+      TREE_STATIC (refdecl) = 1;\n+      TREE_PUBLIC (refdecl) = 0;\n+      TREE_USED (refdecl) = 1;\n+      assemble_alias (refdecl, DECL_ASSEMBLER_NAME (decl));\n+    }\n+\n+  CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n+\t\t\t  fold_convert (const_ptr_type_node,\n+\t\t\t\t\tbuild_fold_addr_expr (refdecl)));\n+  size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+  CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE, build_int_cst (uptr, size));\n+  size += asan_red_zone_size (size);\n+  CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE, build_int_cst (uptr, size));\n+  CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n+\t\t\t  fold_convert (const_ptr_type_node, str_cst));\n+  CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE, build_int_cst (uptr, 0));\n+  init = build_constructor (type, vinner);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);\n+}\n+\n+/* Needs to be GTY(()), because cgraph_build_static_cdtor may\n+   invoke ggc_collect.  */\n+static GTY(()) tree asan_ctor_statements;\n+\n /* Module-level instrumentation.\n    - Insert __asan_init() into the list of CTORs.\n    - TODO: insert redzones around globals.\n@@ -665,11 +885,61 @@ transform_statements (void)\n void\n asan_finish_file (void)\n {\n-  tree ctor_statements = NULL_TREE;\n+  struct varpool_node *vnode;\n+  unsigned HOST_WIDE_INT gcount = 0;\n+\n   append_to_statement_list (build_call_expr (asan_init_func (), 0),\n-                            &ctor_statements);\n-  cgraph_build_static_cdtor ('I', ctor_statements,\n-                             MAX_RESERVED_INIT_PRIORITY - 1);\n+\t\t\t    &asan_ctor_statements);\n+  FOR_EACH_DEFINED_VARIABLE (vnode)\n+    if (asan_protect_global (vnode->symbol.decl))\n+      ++gcount;\n+  if (gcount)\n+    {\n+      tree type = asan_global_struct (), var, ctor, decl;\n+      tree uptr = build_nonstandard_integer_type (POINTER_SIZE, 1);\n+      tree dtor_statements = NULL_TREE;\n+      VEC(constructor_elt, gc) *v;\n+      char buf[20];\n+\n+      type = build_array_type_nelts (type, gcount);\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LASAN\", 0);\n+      var = build_decl (UNKNOWN_LOCATION, VAR_DECL, get_identifier (buf),\n+\t\t\ttype);\n+      TREE_STATIC (var) = 1;\n+      TREE_PUBLIC (var) = 0;\n+      DECL_ARTIFICIAL (var) = 1;\n+      DECL_IGNORED_P (var) = 1;\n+      v = VEC_alloc (constructor_elt, gc, gcount);\n+      FOR_EACH_DEFINED_VARIABLE (vnode)\n+\tif (asan_protect_global (vnode->symbol.decl))\n+\t  asan_add_global (vnode->symbol.decl, TREE_TYPE (type), v);\n+      ctor = build_constructor (type, v);\n+      TREE_CONSTANT (ctor) = 1;\n+      TREE_STATIC (ctor) = 1;\n+      DECL_INITIAL (var) = ctor;\n+      varpool_assemble_decl (varpool_node_for_decl (var));\n+\n+      type = build_function_type_list (void_type_node,\n+\t\t\t\t       build_pointer_type (TREE_TYPE (type)),\n+\t\t\t\t       uptr, NULL_TREE);\n+      decl = build_fn_decl (\"__asan_register_globals\", type);\n+      TREE_NOTHROW (decl) = 1;\n+      append_to_statement_list (build_call_expr (decl, 2,\n+\t\t\t\t\t\t build_fold_addr_expr (var),\n+\t\t\t\t\t\t build_int_cst (uptr, gcount)),\n+\t\t\t\t&asan_ctor_statements);\n+\n+      decl = build_fn_decl (\"__asan_unregister_globals\", type);\n+      TREE_NOTHROW (decl) = 1;\n+      append_to_statement_list (build_call_expr (decl, 2,\n+\t\t\t\t\t\t build_fold_addr_expr (var),\n+\t\t\t\t\t\t build_int_cst (uptr, gcount)),\n+\t\t\t\t&dtor_statements);\n+      cgraph_build_static_cdtor ('D', dtor_statements,\n+\t\t\t\t MAX_RESERVED_INIT_PRIORITY - 1);\n+    }\n+  cgraph_build_static_cdtor ('I', asan_ctor_statements,\n+\t\t\t     MAX_RESERVED_INIT_PRIORITY - 1);\n }\n \n /* Initialize shadow_ptr_types array.  */"}, {"sha": "d9368a8bfd158eff1cf0c827b07326724c888261", "filename": "gcc/asan.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8240018b0c5da12a6e6df5689055983e76768151/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8240018b0c5da12a6e6df5689055983e76768151/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=8240018b0c5da12a6e6df5689055983e76768151", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n \n extern void asan_finish_file (void);\n extern rtx asan_emit_stack_protection (rtx, HOST_WIDE_INT *, tree *, int);\n+extern bool asan_protect_global (tree);\n \n /* Alias set for accessing the shadow memory.  */\n extern alias_set_type asan_shadow_set;\n@@ -56,4 +57,14 @@ asan_protect_stack_decl (tree decl)\n   return DECL_P (decl) && !DECL_ARTIFICIAL (decl);\n }\n \n+/* Return the size of padding needed to insert after a protected\n+   decl of SIZE.  */\n+\n+static inline unsigned int\n+asan_red_zone_size (unsigned int size)\n+{\n+  unsigned int c = size & (ASAN_RED_ZONE_SIZE - 1);\n+  return c ? 2 * ASAN_RED_ZONE_SIZE - c : ASAN_RED_ZONE_SIZE;\n+}\n+\n #endif /* TREE_ASAN */"}, {"sha": "641ce0c43e84526e2efaf18ae6879e895d447f77", "filename": "gcc/varasm.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8240018b0c5da12a6e6df5689055983e76768151/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8240018b0c5da12a6e6df5689055983e76768151/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=8240018b0c5da12a6e6df5689055983e76768151", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-mudflap.h\"\n #include \"cgraph.h\"\n #include \"pointer-set.h\"\n+#include \"asan.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -1831,6 +1832,9 @@ assemble_noswitch_variable (tree decl, const char *name, section *sect)\n   size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n   rounded = size;\n \n+  if (flag_asan && asan_protect_global (decl))\n+    size += asan_red_zone_size (size);\n+\n   /* Don't allocate zero bytes of common,\n      since that means \"undefined external\" in the linker.  */\n   if (size == 0)\n@@ -1897,6 +1901,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   const char *name;\n   rtx decl_rtl, symbol;\n   section *sect;\n+  bool asan_protected = false;\n \n   /* This function is supposed to handle VARIABLES.  Ensure we have one.  */\n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n@@ -1984,6 +1989,15 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   /* Compute the alignment of this data.  */\n \n   align_variable (decl, dont_output_data);\n+\n+  if (flag_asan\n+      && asan_protect_global (decl))\n+    {\n+      asan_protected = true;\n+      DECL_ALIGN (decl) = MAX (DECL_ALIGN (decl), \n+                               ASAN_RED_ZONE_SIZE * BITS_PER_UNIT);\n+    }\n+\n   set_mem_align (decl_rtl, DECL_ALIGN (decl));\n \n   if (TREE_PUBLIC (decl))\n@@ -2022,6 +2036,12 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n       if (DECL_ALIGN (decl) > BITS_PER_UNIT)\n \tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (DECL_ALIGN_UNIT (decl)));\n       assemble_variable_contents (decl, name, dont_output_data);\n+      if (asan_protected)\n+\t{\n+\t  unsigned HOST_WIDE_INT int size\n+\t    = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+\t  assemble_zeros (asan_red_zone_size (size));\n+\t}\n     }\n }\n \n@@ -6926,6 +6946,8 @@ place_block_symbol (rtx symbol)\n       decl = SYMBOL_REF_DECL (symbol);\n       alignment = DECL_ALIGN (decl);\n       size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+      if (flag_asan && asan_protect_global (decl))\n+\tsize += asan_red_zone_size (size);\n     }\n \n   /* Calculate the object's offset from the start of the block.  */"}]}