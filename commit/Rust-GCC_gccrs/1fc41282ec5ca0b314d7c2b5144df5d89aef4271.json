{"sha": "1fc41282ec5ca0b314d7c2b5144df5d89aef4271", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZjNDEyODJlYzVjYTBiMzE0ZDdjMmI1MTQ0ZGY1ZDg5YWVmNDI3MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-07-02T22:56:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-07-02T22:56:21Z"}, "message": "tree-ssa-dce.c (bb_contains_live_stmts): New bitmap.\n\n\t* tree-ssa-dce.c (bb_contains_live_stmts): New bitmap.\n\t(mark_stmt_necessary): Set it.\n\t(mark_operand_necessary): Set it.\n\t(mark_control_dependent_edges_necessary): Set it.\n\t(mark_virtual_phi_result_for_renaming): New function.\n\t(get_live_post_dom): New function.\n\t(forward_edge_to_pdom): New function.\n\t(remove_dead_stmt): Fix handling of control dependences.\n\t(tree_dce_init): Init new bitmap.\n\t(tree_dce_done): Free it.\n\nFrom-SVN: r149199", "tree": {"sha": "1d9bdbd53840567d935dad776d171d929046d438", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d9bdbd53840567d935dad776d171d929046d438"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fc41282ec5ca0b314d7c2b5144df5d89aef4271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc41282ec5ca0b314d7c2b5144df5d89aef4271", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fc41282ec5ca0b314d7c2b5144df5d89aef4271", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc41282ec5ca0b314d7c2b5144df5d89aef4271/comments", "author": null, "committer": null, "parents": [{"sha": "bc21bfa5e3bc9f06ac92b2b9b43ae55116850f1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc21bfa5e3bc9f06ac92b2b9b43ae55116850f1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc21bfa5e3bc9f06ac92b2b9b43ae55116850f1b"}], "stats": {"total": 212, "additions": 164, "deletions": 48}, "files": [{"sha": "24d7676f874512cb77341d220f75ee1395c8d47e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc41282ec5ca0b314d7c2b5144df5d89aef4271/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc41282ec5ca0b314d7c2b5144df5d89aef4271/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1fc41282ec5ca0b314d7c2b5144df5d89aef4271", "patch": "@@ -1,3 +1,16 @@\n+2009-07-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-dce.c (bb_contains_live_stmts): New bitmap.\n+\t(mark_stmt_necessary): Set it.\n+\t(mark_operand_necessary): Set it.\n+\t(mark_control_dependent_edges_necessary): Set it.\n+\t(mark_virtual_phi_result_for_renaming): New function.\n+\t(get_live_post_dom): New function.\n+\t(forward_edge_to_pdom): New function.\n+\t(remove_dead_stmt): Fix handling of control dependences.\n+\t(tree_dce_init): Init new bitmap.\n+\t(tree_dce_done): Free it.\n+\n 2009-07-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR bootstrap/40617"}, {"sha": "1bb2adc6a370fbbc390d57f1e2dd5b8c1cbb0134", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 151, "deletions": 48, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc41282ec5ca0b314d7c2b5144df5d89aef4271/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc41282ec5ca0b314d7c2b5144df5d89aef4271/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=1fc41282ec5ca0b314d7c2b5144df5d89aef4271", "patch": "@@ -87,6 +87,9 @@ static sbitmap processed;\n    marked as necessary.  */\n static sbitmap last_stmt_necessary;\n \n+/* Vector indicating that BB contains statements that are live.  */\n+static sbitmap bb_contains_live_stmts;\n+\n /* Before we can determine whether a control branch is dead, we need to\n    compute which blocks are control dependent on which edges.\n \n@@ -218,6 +221,8 @@ mark_stmt_necessary (gimple stmt, bool add_to_worklist)\n   gimple_set_plf (stmt, STMT_NECESSARY, true);\n   if (add_to_worklist)\n     VEC_safe_push (gimple, heap, worklist, stmt);\n+  if (bb_contains_live_stmts)\n+    SET_BIT (bb_contains_live_stmts, gimple_bb (stmt)->index);\n }\n \n \n@@ -256,6 +261,8 @@ mark_operand_necessary (tree op)\n     }\n \n   gimple_set_plf (stmt, STMT_NECESSARY, true);\n+  if (bb_contains_live_stmts)\n+    SET_BIT (bb_contains_live_stmts, gimple_bb (stmt)->index);\n   VEC_safe_push (gimple, heap, worklist, stmt);\n }\n \n@@ -385,6 +392,7 @@ mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el)\n       if (TEST_BIT (last_stmt_necessary, cd_bb->index))\n \tcontinue;\n       SET_BIT (last_stmt_necessary, cd_bb->index);\n+      SET_BIT (bb_contains_live_stmts, cd_bb->index);\n \n       stmt = last_stmt (cd_bb);\n       if (stmt && is_ctrl_stmt (stmt))\n@@ -764,6 +772,35 @@ propagate_necessity (struct edge_list *el)\n     }\n }\n \n+/* Replace all uses of result of PHI by underlying variable and mark it\n+   for renaming.  */\n+\n+static void\n+mark_virtual_phi_result_for_renaming (gimple phi)\n+{\n+  bool used = false;\n+  imm_use_iterator iter;\n+  use_operand_p use_p;\n+  gimple stmt;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Marking result for renaming : \");\n+      print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  FOR_EACH_IMM_USE_STMT (stmt, iter, gimple_phi_result (phi))\n+    {\n+      if (gimple_code (stmt) != GIMPLE_PHI\n+\t  && !gimple_plf (stmt, STMT_NECESSARY))\n+        continue;\n+      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+        SET_USE (use_p, SSA_NAME_VAR (gimple_phi_result (phi)));\n+      update_stmt (stmt);\n+      used = true;\n+    }\n+  if (used)\n+    mark_sym_for_renaming (SSA_NAME_VAR (PHI_RESULT (phi)));\n+}\n \n /* Remove dead PHI nodes from block BB.  */\n \n@@ -835,6 +872,88 @@ remove_dead_phis (basic_block bb)\n   return something_changed;\n }\n \n+/* Find first live post dominator of BB.  */\n+\n+static basic_block\n+get_live_post_dom (basic_block bb)\n+{\n+  basic_block post_dom_bb;\n+\n+\n+  /* The post dominance info has to be up-to-date.  */\n+  gcc_assert (dom_info_state (CDI_POST_DOMINATORS) == DOM_OK);\n+\n+  /* Get the immediate post dominator of bb.  */\n+  post_dom_bb = get_immediate_dominator (CDI_POST_DOMINATORS, bb);\n+  /* And look for first live one.  */\n+  while (post_dom_bb != EXIT_BLOCK_PTR\n+\t && !TEST_BIT (bb_contains_live_stmts, post_dom_bb->index))\n+    post_dom_bb = get_immediate_dominator (CDI_POST_DOMINATORS, post_dom_bb);\n+\n+  return post_dom_bb;\n+}\n+\n+/* Forward edge E to respective POST_DOM_BB and update PHIs.  */\n+\n+static edge\n+forward_edge_to_pdom (edge e, basic_block post_dom_bb)\n+{\n+  gimple_stmt_iterator gsi;\n+  edge e2;\n+  edge_iterator ei;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Redirecting edge %i->%i to %i\\n\", e->src->index,\n+\t     e->dest->index, post_dom_bb->index);\n+\n+  e2 = redirect_edge_and_branch (e, post_dom_bb);\n+  cfg_altered = true;\n+\n+  /* If edge was already around, no updating is neccesary.  */\n+  if (e2 != e)\n+    return e2;\n+\n+  if (phi_nodes (post_dom_bb))\n+    {\n+      /* We are sure that for every live PHI we are seeing control dependent BB.\n+         This means that we can look up the end of control dependent path leading\n+         to the PHI itself.  */\n+      FOR_EACH_EDGE (e2, ei, post_dom_bb->preds)\n+\tif (e2 != e && dominated_by_p (CDI_POST_DOMINATORS, e->src, e2->src))\n+\t  break;\n+      for (gsi = gsi_start_phis (post_dom_bb); !gsi_end_p (gsi);)\n+\t{\n+\t  gimple phi = gsi_stmt (gsi);\n+\n+\t  /* Dead PHI do not imply control dependency.  */\n+          if (!gimple_plf (phi, STMT_NECESSARY)\n+\t      && is_gimple_reg (gimple_phi_result (phi)))\n+\t    {\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n+\t  if (gimple_phi_arg_def (phi, e->dest_idx))\n+\t    {\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n+\n+\t  /* We didn't find edge to update.  This can happen for PHIs on virtuals\n+\t     since there is no control dependency relation on them.  We are lost\n+\t     here and must force renaming of the symbol.  */\n+\t  if (!is_gimple_reg (gimple_phi_result (phi)))\n+\t    {\n+\t      mark_virtual_phi_result_for_renaming (phi);\n+\t      remove_phi_node (&gsi, true);\n+\t      continue;\n+\t    }\n+          gcc_assert (e2);\n+\t  add_phi_arg (phi, gimple_phi_arg_def (phi, e2->dest_idx), e);\n+\t  gsi_next (&gsi);\n+\t}\n+    }\n+  return e;\n+}\n \n /* Remove dead statement pointed to by iterator I.  Receives the basic block BB\n    containing I so that we don't have to look it up.  */\n@@ -862,63 +981,43 @@ remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n   if (is_ctrl_stmt (stmt))\n     {\n       basic_block post_dom_bb;\n+      edge e, e2;\n+      edge_iterator ei;\n \n-      /* The post dominance info has to be up-to-date.  */\n-      gcc_assert (dom_info_state (CDI_POST_DOMINATORS) == DOM_OK);\n-      /* Get the immediate post dominator of bb.  */\n-      post_dom_bb = get_immediate_dominator (CDI_POST_DOMINATORS, bb);\n-\n-      /* There are three particularly problematical cases.\n-\n-\t 1. Blocks that do not have an immediate post dominator.  This\n-\t    can happen with infinite loops.\n+      post_dom_bb = get_live_post_dom (bb);\n \n-\t 2. Blocks that are only post dominated by the exit block.  These\n-\t    can also happen for infinite loops as we create fake edges\n-\t    in the dominator tree.\n+      e = find_edge (bb, post_dom_bb);\n \n-\t 3. If the post dominator has PHI nodes we may be able to compute\n-\t    the right PHI args for them.\n-\n-\t In each of these cases we must remove the control statement\n-\t as it may reference SSA_NAMEs which are going to be removed and\n-\t we remove all but one outgoing edge from the block.  */\n-      if (! post_dom_bb\n-\t  || post_dom_bb == EXIT_BLOCK_PTR\n-\t  || phi_nodes (post_dom_bb))\n-\t;\n+      /* If edge is already there, try to use it.  This avoids need to update\n+         PHI nodes.  Also watch for cases where post dominator does not exists\n+\t or is exit block.  These can happen for infinite loops as we create\n+\t fake edges in the dominator tree.  */\n+      if (e)\n+        ;\n+      else if (! post_dom_bb || post_dom_bb == EXIT_BLOCK_PTR)\n+\te = EDGE_SUCC (bb, 0);\n       else\n-\t{\n-\t  /* Redirect the first edge out of BB to reach POST_DOM_BB.  */\n-\t  redirect_edge_and_branch (EDGE_SUCC (bb, 0), post_dom_bb);\n-\t  PENDING_STMT (EDGE_SUCC (bb, 0)) = NULL;\n-\n-\t  /* It is not sufficient to set cfg_altered below during edge\n-\t     removal, in case BB has two successors and one of them\n-\t     is POST_DOM_BB.  */\n-\t  cfg_altered = true;\n-\t}\n-      EDGE_SUCC (bb, 0)->probability = REG_BR_PROB_BASE;\n-      EDGE_SUCC (bb, 0)->count = bb->count;\n+        e = forward_edge_to_pdom (EDGE_SUCC (bb, 0), post_dom_bb);\n+      gcc_assert (e);\n+      e->probability = REG_BR_PROB_BASE;\n+      e->count = bb->count;\n \n       /* The edge is no longer associated with a conditional, so it does\n \t not have TRUE/FALSE flags.  */\n-      EDGE_SUCC (bb, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+      e->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n \n       /* The lone outgoing edge from BB will be a fallthru edge.  */\n-      EDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n-\n-      /* Remove the remaining the outgoing edges.  */\n-      while (!single_succ_p (bb))\n-\t{\n-\t  /* FIXME.  When we remove the edge, we modify the CFG, which\n-\t     in turn modifies the dominator and post-dominator tree.\n-\t     Is it safe to postpone recomputing the dominator and\n-\t     post-dominator tree until the end of this pass given that\n-\t     the post-dominators are used above?  */\n-\t  cfg_altered = true;\n-          remove_edge (EDGE_SUCC (bb, 1));\n-\t}\n+      e->flags |= EDGE_FALLTHRU;\n+\n+      /* Remove the remaining outgoing edges.  */\n+      for (ei = ei_start (bb->succs); (e2 = ei_safe_edge (ei)); )\n+\tif (e != e2)\n+\t  {\n+\t    cfg_altered = true;\n+            remove_edge (e2);\n+\t  }\n+\telse\n+\t  ei_next (&ei);\n     }\n \n   unlink_stmt_vdef (stmt);\n@@ -1043,6 +1142,8 @@ tree_dce_init (bool aggressive)\n \n       last_stmt_necessary = sbitmap_alloc (last_basic_block);\n       sbitmap_zero (last_stmt_necessary);\n+      bb_contains_live_stmts = sbitmap_alloc (last_basic_block);\n+      sbitmap_zero (bb_contains_live_stmts);\n     }\n \n   processed = sbitmap_alloc (num_ssa_names + 1);\n@@ -1067,6 +1168,8 @@ tree_dce_done (bool aggressive)\n \n       sbitmap_free (visited_control_parents);\n       sbitmap_free (last_stmt_necessary);\n+      sbitmap_free (bb_contains_live_stmts);\n+      bb_contains_live_stmts = NULL;\n     }\n \n   sbitmap_free (processed);"}]}