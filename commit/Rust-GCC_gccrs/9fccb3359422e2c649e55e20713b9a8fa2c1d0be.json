{"sha": "9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZjY2IzMzU5NDIyZTJjNjQ5ZTU1ZTIwNzEzYjlhOGZhMmMxZDBiZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-05-19T07:09:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-05-19T07:09:42Z"}, "message": "rtl.def (REG): Change format to \"r\".\n\ngcc/\n\t* rtl.def (REG): Change format to \"r\".\n\t* rtl.h (rtunion): Remove rt_reg.\n\t(reg_info): New structure.\n\t(rtx_def): Add reg field to main union.\n\t(X0REGATTR): Delete.\n\t(REG_CHECK): New macro.\n\t(SET_REGNO_RAW, rhs_regno, REG_ATTRS): Use it.\n\t* rtl.c (rtx_format): Document \"r\".\n\t(rtx_code_size): Handle REG specially.\n\t* gengenrtl.c (special_format): Return true for formats\n\tthat include 'r'.\n\t* gengtype.c (adjust_field_rtx_def): Handle 'r' fields.\n\tDeal with REG_ATTRS after the field loop.\n\t* emit-rtl.c (gen_raw_REG): Call rtx_alloc_stat directly.\n\t* expmed.c (init_expmed): Call gen_raw_REG instead of\n\tgen_rtx_raw_REG.\n\t* expr.c (init_expr_target): Likewise.\n\t* regcprop.c (maybe_mode_change): Likewise.\n\t* varasm.c (make_decl_rtl): Likewise.\n\t* final.c (leaf_renumber_regs_insn): Return early after\n\thandling REGs.\n\t* genemit.c (gen_exp): Handle 'r' fields.\n\t* genpeep.c (match_rtx): Likewise.\n\t* gensupport.c (subst_pattern_match): Likewise.\n\t(get_alternatives_number, collect_insn_data, alter_predicate_for_insn)\n\t(alter_constraints, subst_dup): Likewise.\n\t* read-rtl.c (read_rtx_code): Likewise.\n\t* print-rtl.c (print_rtx): Likewise.\n\t* genrecog.c (find_operand, find_matching_operand): Likewise.\n\t(validate_pattern, match_pattern_2): Likewise.\n\t(parameter::UINT, rtx_test::REGNO_FIELD): New enum values.\n\t(rtx_test::regno_field): New function.\n\t(operator ==, safe_to_hoist_p, transition_parameter_type)\n\t(parameter_type_string, print_parameter_value)\n\t(print_nonbool_test, print_test): Handle new enum values.\n\t* cselib.c (rtx_equal_for_cselib_1): Handle REG specially.\n\t* lra-constraints.c (operands_match_p): Likewise.\n\nFrom-SVN: r223339", "tree": {"sha": "96439177c2e9d6b824d800f99d19534a317db681", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96439177c2e9d6b824d800f99d19534a317db681"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1a2b02198c93716fd4695d6ed61c20cfc933d1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1a2b02198c93716fd4695d6ed61c20cfc933d1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1a2b02198c93716fd4695d6ed61c20cfc933d1d"}], "stats": {"total": 280, "additions": 210, "deletions": 70}, "files": [{"sha": "ac4591dcfe4ab6d6efa2807fc58e92ca3f66aeb8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -1,3 +1,43 @@\n+2015-05-19  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* rtl.def (REG): Change format to \"r\".\n+\t* rtl.h (rtunion): Remove rt_reg.\n+\t(reg_info): New structure.\n+\t(rtx_def): Add reg field to main union.\n+\t(X0REGATTR): Delete.\n+\t(REG_CHECK): New macro.\n+\t(SET_REGNO_RAW, rhs_regno, REG_ATTRS): Use it.\n+\t* rtl.c (rtx_format): Document \"r\".\n+\t(rtx_code_size): Handle REG specially.\n+\t* gengenrtl.c (special_format): Return true for formats\n+\tthat include 'r'.\n+\t* gengtype.c (adjust_field_rtx_def): Handle 'r' fields.\n+\tDeal with REG_ATTRS after the field loop.\n+\t* emit-rtl.c (gen_raw_REG): Call rtx_alloc_stat directly.\n+\t* expmed.c (init_expmed): Call gen_raw_REG instead of\n+\tgen_rtx_raw_REG.\n+\t* expr.c (init_expr_target): Likewise.\n+\t* regcprop.c (maybe_mode_change): Likewise.\n+\t* varasm.c (make_decl_rtl): Likewise.\n+\t* final.c (leaf_renumber_regs_insn): Return early after\n+\thandling REGs.\n+\t* genemit.c (gen_exp): Handle 'r' fields.\n+\t* genpeep.c (match_rtx): Likewise.\n+\t* gensupport.c (subst_pattern_match): Likewise.\n+\t(get_alternatives_number, collect_insn_data, alter_predicate_for_insn)\n+\t(alter_constraints, subst_dup): Likewise.\n+\t* read-rtl.c (read_rtx_code): Likewise.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* genrecog.c (find_operand, find_matching_operand): Likewise.\n+\t(validate_pattern, match_pattern_2): Likewise.\n+\t(parameter::UINT, rtx_test::REGNO_FIELD): New enum values.\n+\t(rtx_test::regno_field): New function.\n+\t(operator ==, safe_to_hoist_p, transition_parameter_type)\n+\t(parameter_type_string, print_parameter_value)\n+\t(print_nonbool_test, print_test): Handle new enum values.\n+\t* cselib.c (rtx_equal_for_cselib_1): Handle REG specially.\n+\t* lra-constraints.c (operands_match_p): Likewise.\n+\n 2015-05-19  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* df.h (df_ref_change_reg_with_loc): Remove old_regno parameter."}, {"sha": "7a50f5055bd5e3967cdd9881e59fe3c7861b4510", "filename": "gcc/cselib.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -976,6 +976,9 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode)\n     case LABEL_REF:\n       return LABEL_REF_LABEL (x) == LABEL_REF_LABEL (y);\n \n+    case REG:\n+      return REGNO (x) == REGNO (y);\n+\n     case MEM:\n       /* We have to compare any autoinc operations in the addresses\n \t using this MEM's mode.  */"}, {"sha": "ae67e7a66df77f731cf82d5f6b0abe5a20bb55ec", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -437,7 +437,10 @@ gen_blockage (void)\n rtx\n gen_raw_REG (machine_mode mode, int regno)\n {\n-  rtx x = gen_rtx_raw_REG (mode, regno);\n+  rtx x = rtx_alloc_stat (REG PASS_MEM_STAT);\n+  PUT_MODE (x, mode);\n+  SET_REGNO_RAW (x, regno);\n+  REG_ATTRS (x) = NULL;\n   ORIGINAL_REGNO (x) = regno;\n   return x;\n }"}, {"sha": "634263dabc95abdbfb3ebc02ccb282da46d06470", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -260,7 +260,7 @@ init_expmed (void)\n     }\n \n   /* Avoid using hard regs in ways which may be unsupported.  */\n-  all.reg = gen_rtx_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1);\n+  all.reg = gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1);\n   all.plus = gen_rtx_PLUS (mode, all.reg, all.reg);\n   all.neg = gen_rtx_NEG (mode, all.reg);\n   all.mult = gen_rtx_MULT (mode, all.reg, all.reg);"}, {"sha": "6694fc184d40bb5056bffc2a09e2b2b164f9fbf2", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -258,7 +258,7 @@ init_expr_target (void)\n \t  }\n     }\n \n-  mem = gen_rtx_MEM (VOIDmode, gen_rtx_raw_REG (Pmode, 10000));\n+  mem = gen_rtx_MEM (VOIDmode, gen_raw_REG (Pmode, FIRST_PSEUDO_REGISTER));\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))"}, {"sha": "e145f6d9feb848fb01c53fc47c732b0a66acdece", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -4423,6 +4423,7 @@ leaf_renumber_regs_insn (rtx in_rtx)\n       df_set_regs_ever_live (newreg, true);\n       SET_REGNO (in_rtx, newreg);\n       in_rtx->used = 1;\n+      return;\n     }\n \n   if (INSN_P (in_rtx))"}, {"sha": "3f5dd825a1e7efd7130866906f8d8b1aad2e7457", "filename": "gcc/genemit.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -240,6 +240,10 @@ gen_exp (rtx x, enum rtx_code subroutine_type, char *used)\n \t  printf (\"%u\", XINT (x, i));\n \t  break;\n \n+\tcase 'r':\n+\t  printf (\"%u\", REGNO (x));\n+\t  break;\n+\n \tcase 's':\n \t  printf (\"\\\"%s\\\"\", XSTR (x, i));\n \t  break;"}, {"sha": "7df99e8657d574bc280ab784ccaf72f984de56fe", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -113,7 +113,8 @@ special_format (const char *fmt)\n   return (strchr (fmt, '*') != 0\n \t  || strchr (fmt, 'V') != 0\n \t  || strchr (fmt, 'S') != 0\n-\t  || strchr (fmt, 'n') != 0);\n+\t  || strchr (fmt, 'n') != 0\n+\t  || strchr (fmt, 'r') != 0);\n }\n \n /* Return true if CODE always has VOIDmode.  */"}, {"sha": "5d219c37e27e87c8fd08843e18c1ab05aae5c93e", "filename": "gcc/gengtype.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -1241,6 +1241,7 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t    case 'i':\n \t    case 'n':\n \t    case 'w':\n+\t    case 'r':\n \t      t = scalar_tp;\n \t      subname = \"rt_int\";\n \t      break;\n@@ -1268,8 +1269,6 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t\tt = scalar_tp, subname = \"rt_int\";\n \t      else if (i == DEBUG_EXPR && aindex == 0)\n \t\tt = tree_tp, subname = \"rt_tree\";\n-\t      else if (i == REG && aindex == 1)\n-\t\tt = reg_attrs_tp, subname = \"rt_reg\";\n \t      else if (i == SYMBOL_REF && aindex == 1)\n \t\tt = symbol_union_tp, subname = \"\";\n \t      else if (i == JUMP_TABLE_DATA && aindex >= 4)\n@@ -1344,6 +1343,9 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t\t\t\t    \"CONSTANT_POOL_ADDRESS_P (&%0)\");\n \t}\n \n+      if (i == REG)\n+\tsubfields = create_field (subfields, reg_attrs_tp, \"reg.attrs\");\n+\n       if (i == SYMBOL_REF)\n \t{\n \t  /* Add the \"block_sym\" field if SYMBOL_REF_HAS_BLOCK_INFO_P"}, {"sha": "3ba930c8a0547b3f497e216c65947d991f3e9031", "filename": "gcc/genpeep.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -276,6 +276,12 @@ match_rtx (rtx x, struct link *path, int fail_label)\n \t  printf (\"  if (XINT (x, %d) != %d) goto L%d;\\n\",\n \t\t  i, XINT (x, i), fail_label);\n \t}\n+      else if (fmt[i] == 'r')\n+\t{\n+\t  gcc_assert (i == 0);\n+\t  printf (\"  if (REGNO (x) != %d) goto L%d;\\n\",\n+\t\t  REGNO (x), fail_label);\n+\t}\n       else if (fmt[i] == 'w')\n \t{\n \t  /* Make sure that at run time `x' is the RTX we want to test.  */"}, {"sha": "b8325006bfca7c04e28c34bea64b5a10a6813092", "filename": "gcc/genrecog.c", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -396,7 +396,7 @@ find_operand (rtx pattern, int n, rtx stop)\n \t      return r;\n \t  break;\n \n-\tcase 'i': case 'w': case '0': case 's':\n+\tcase 'i': case 'r': case 'w': case '0': case 's':\n \t  break;\n \n \tdefault:\n@@ -447,7 +447,7 @@ find_matching_operand (rtx pattern, int n)\n \t      return r;\n \t  break;\n \n-\tcase 'i': case 'w': case '0': case 's':\n+\tcase 'i': case 'r': case 'w': case '0': case 's':\n \t  break;\n \n \tdefault:\n@@ -747,7 +747,7 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t    validate_pattern (XVECEXP (pattern, i, j), insn, NULL_RTX, 0);\n \t  break;\n \n-\tcase 'i': case 'w': case '0': case 's':\n+\tcase 'i': case 'r': case 'w': case '0': case 's':\n \t  break;\n \n \tdefault:\n@@ -967,6 +967,9 @@ struct parameter\n     /* An int parameter.  */\n     INT,\n \n+    /* An unsigned int parameter.  */\n+    UINT,\n+\n     /* A HOST_WIDE_INT parameter.  */\n     WIDE_INT\n   };\n@@ -1063,6 +1066,9 @@ struct rtx_test\n     /* Check GET_MODE (X) == LABEL.  */\n     MODE,\n \n+    /* Check REGNO (X) == LABEL.  */\n+    REGNO_FIELD,\n+\n     /* Check XINT (X, u.opno) == LABEL.  */\n     INT_FIELD,\n \n@@ -1142,6 +1148,7 @@ struct rtx_test\n \n   static rtx_test code (position *);\n   static rtx_test mode (position *);\n+  static rtx_test regno_field (position *);\n   static rtx_test int_field (position *, int);\n   static rtx_test wide_int_field (position *, int);\n   static rtx_test veclen (position *);\n@@ -1179,6 +1186,13 @@ rtx_test::mode (position *pos)\n   return rtx_test (pos, rtx_test::MODE);\n }\n \n+rtx_test\n+rtx_test::regno_field (position *pos)\n+{\n+  rtx_test res (pos, rtx_test::REGNO_FIELD);\n+  return res;\n+}\n+\n rtx_test\n rtx_test::int_field (position *pos, int opno)\n {\n@@ -1299,6 +1313,7 @@ operator == (const rtx_test &a, const rtx_test &b)\n     {\n     case rtx_test::CODE:\n     case rtx_test::MODE:\n+    case rtx_test::REGNO_FIELD:\n     case rtx_test::VECLEN:\n     case rtx_test::HAVE_NUM_CLOBBERS:\n       return true;\n@@ -1753,6 +1768,7 @@ safe_to_hoist_p (decision *d, const rtx_test &test, known_conditions *kc)\n \t}\n       gcc_unreachable ();\n \n+    case rtx_test::REGNO_FIELD:\n     case rtx_test::INT_FIELD:\n     case rtx_test::WIDE_INT_FIELD:\n     case rtx_test::VECLEN:\n@@ -1959,6 +1975,9 @@ transition_parameter_type (rtx_test::kind_enum kind)\n     case rtx_test::MODE:\n       return parameter::MODE;\n \n+    case rtx_test::REGNO_FIELD:\n+      return parameter::UINT;\n+\n     case rtx_test::INT_FIELD:\n     case rtx_test::VECLEN:\n     case rtx_test::PATTERN:\n@@ -3970,6 +3989,13 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n \t\t\t\t      XINT (pattern, i), false);\n \t\t    break;\n \n+\t\t  case 'r':\n+\t\t    /* Make sure that REGNO (X) has the right value.  */\n+\t\t    gcc_assert (i == 0);\n+\t\t    s = add_decision (s, rtx_test::regno_field (pos),\n+\t\t\t\t      REGNO (pattern), false);\n+\t\t    break;\n+\n \t\t  case 'w':\n \t\t    /* Make sure that XWINT (X, I) has the right value.  */\n \t\t    s = add_decision (s, rtx_test::wide_int_field (pos, i),\n@@ -4232,6 +4258,9 @@ parameter_type_string (parameter::type_enum type)\n     case parameter::INT:\n       return \"int\";\n \n+    case parameter::UINT:\n+      return \"unsigned int\";\n+\n     case parameter::WIDE_INT:\n       return \"HOST_WIDE_INT\";\n     }\n@@ -4451,6 +4480,10 @@ print_parameter_value (const parameter &param)\n \tprintf (\"%d\", (int) param.value);\n \tbreak;\n \n+      case parameter::UINT:\n+\tprintf (\"%u\", (unsigned int) param.value);\n+\tbreak;\n+\n       case parameter::WIDE_INT:\n \tprint_host_wide_int (param.value);\n \tbreak;\n@@ -4499,6 +4532,12 @@ print_nonbool_test (output_state *os, const rtx_test &test)\n       printf (\", %d)\", test.u.opno);\n       break;\n \n+    case rtx_test::REGNO_FIELD:\n+      printf (\"REGNO (\");\n+      print_test_rtx (os, test);\n+      printf (\")\");\n+      break;\n+\n     case rtx_test::WIDE_INT_FIELD:\n       printf (\"XWINT (\");\n       print_test_rtx (os, test);\n@@ -4572,6 +4611,7 @@ print_test (output_state *os, const rtx_test &test, bool is_param,\n     case rtx_test::CODE:\n     case rtx_test::MODE:\n     case rtx_test::VECLEN:\n+    case rtx_test::REGNO_FIELD:\n     case rtx_test::INT_FIELD:\n     case rtx_test::WIDE_INT_FIELD:\n     case rtx_test::PATTERN:"}, {"sha": "2955d297c54b794de8c80020d0d3c356138d5a85", "filename": "gcc/gensupport.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -880,7 +880,7 @@ subst_pattern_match (rtx x, rtx pt, int lineno)\n \n       switch (fmt[i])\n \t{\n-\tcase 'i': case 'w': case 's':\n+\tcase 'i': case 'r': case 'w': case 's':\n \t  continue;\n \n \tcase 'e': case 'u':\n@@ -1045,7 +1045,7 @@ get_alternatives_number (rtx pattern, int *n_alt, int lineno)\n \t\treturn 0;\n \t  break;\n \n-\tcase 'i': case 'w': case '0': case 's': case 'S': case 'T':\n+\tcase 'i': case 'r': case 'w': case '0': case 's': case 'S': case 'T':\n \t  break;\n \n \tdefault:\n@@ -1104,7 +1104,7 @@ collect_insn_data (rtx pattern, int *palt, int *pmax)\n \t    collect_insn_data (XVECEXP (pattern, i, j), palt, pmax);\n \t  break;\n \n-\tcase 'i': case 'w': case '0': case 's': case 'S': case 'T':\n+\tcase 'i': case 'r': case 'w': case '0': case 's': case 'S': case 'T':\n \t  break;\n \n \tdefault:\n@@ -1188,7 +1188,7 @@ alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n \t    }\n \t  break;\n \n-\tcase 'i': case 'w': case '0': case 's':\n+\tcase 'i': case 'r': case 'w': case '0': case 's':\n \t  break;\n \n \tdefault:\n@@ -1246,7 +1246,7 @@ alter_constraints (rtx pattern, int n_dup, constraints_handler_t alter)\n \t    }\n \t  break;\n \n-\tcase 'i': case 'w': case '0': case 's':\n+\tcase 'i': case 'r': case 'w': case '0': case 's':\n \t  break;\n \n \tdefault:\n@@ -2184,7 +2184,7 @@ subst_dup (rtx pattern, int n_alt, int n_subst_alt)\n \t\t\t\t\t\t   n_alt, n_subst_alt);\n \t  break;\n \n-\tcase 'i': case 'w': case '0': case 's': case 'S': case 'T':\n+\tcase 'i': case 'r': case 'w': case '0': case 's': case 'S': case 'T':\n \t  break;\n \n \tdefault:"}, {"sha": "122d4bb72af589164e9ac1fcb3fe6773ff4a777d", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -749,6 +749,9 @@ operands_match_p (rtx x, rtx y, int y_hard_regno)\n \n  slow:\n \n+  if (code == REG && REG_P (y))\n+    return REGNO (x) == REGNO (y);\n+\n   if (code == REG && GET_CODE (y) == SUBREG && REG_P (SUBREG_REG (y))\n       && x == SUBREG_REG (y))\n     return true;"}, {"sha": "882f808b1a2815e188cf82dcf33c3b6bfefd64d2", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -462,55 +462,12 @@ print_rtx (const_rtx in_rtx)\n \t    int value = XINT (in_rtx, i);\n \t    const char *name;\n \n-#ifndef GENERATOR_FILE\n-\t    if (REG_P (in_rtx) && (unsigned) value < FIRST_PSEUDO_REGISTER)\n-\t      fprintf (outfile, \" %d %s\", value, reg_names[value]);\n-\t    else if (REG_P (in_rtx)\n-\t\t     && (unsigned) value <= LAST_VIRTUAL_REGISTER)\n-\t      {\n-\t\tif (value == VIRTUAL_INCOMING_ARGS_REGNUM)\n-\t\t  fprintf (outfile, \" %d virtual-incoming-args\", value);\n-\t\telse if (value == VIRTUAL_STACK_VARS_REGNUM)\n-\t\t  fprintf (outfile, \" %d virtual-stack-vars\", value);\n-\t\telse if (value == VIRTUAL_STACK_DYNAMIC_REGNUM)\n-\t\t  fprintf (outfile, \" %d virtual-stack-dynamic\", value);\n-\t\telse if (value == VIRTUAL_OUTGOING_ARGS_REGNUM)\n-\t\t  fprintf (outfile, \" %d virtual-outgoing-args\", value);\n-\t\telse if (value == VIRTUAL_CFA_REGNUM)\n-\t\t  fprintf (outfile, \" %d virtual-cfa\", value);\n-\t\telse if (value == VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM)\n-\t\t  fprintf (outfile, \" %d virtual-preferred-stack-boundary\",\n-\t\t\t   value);\n-\t\telse\n-\t\t  fprintf (outfile, \" %d virtual-reg-%d\", value,\n-\t\t\t   value-FIRST_VIRTUAL_REGISTER);\n-\t      }\n-\t    else\n-#endif\n-\t      if (flag_dump_unnumbered\n-\t\t     && (is_insn || NOTE_P (in_rtx)))\n+\t    if (flag_dump_unnumbered\n+\t\t&& (is_insn || NOTE_P (in_rtx)))\n \t      fputc ('#', outfile);\n \t    else\n \t      fprintf (outfile, \" %d\", value);\n \n-#ifndef GENERATOR_FILE\n-\t    if (REG_P (in_rtx) && REG_ATTRS (in_rtx))\n-\t      {\n-\t\tfputs (\" [\", outfile);\n-\t\tif (ORIGINAL_REGNO (in_rtx) != REGNO (in_rtx))\n-\t\t  fprintf (outfile, \"orig:%i\", ORIGINAL_REGNO (in_rtx));\n-\t\tif (REG_EXPR (in_rtx))\n-\t\t  print_mem_expr (outfile, REG_EXPR (in_rtx));\n-\n-\t\tif (REG_OFFSET (in_rtx))\n-\t\t  fprintf (outfile, \"+\" HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t   REG_OFFSET (in_rtx));\n-\t\tfputs (\" ]\", outfile);\n-\t      }\n-\t    if (REG_P (in_rtx) && REGNO (in_rtx) != ORIGINAL_REGNO (in_rtx))\n-\t      fprintf (outfile, \" [%d]\", ORIGINAL_REGNO (in_rtx));\n-#endif\n-\n \t    if (is_insn && &INSN_CODE (in_rtx) == &XINT (in_rtx, i)\n \t\t&& XINT (in_rtx, i) >= 0\n \t\t&& (name = get_insn_name (XINT (in_rtx, i))) != NULL)\n@@ -519,6 +476,58 @@ print_rtx (const_rtx in_rtx)\n \t  }\n \tbreak;\n \n+      case 'r':\n+\t{\n+\t  unsigned int regno = REGNO (in_rtx);\n+#ifndef GENERATOR_FILE\n+\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t    fprintf (outfile, \" %d %s\", regno, reg_names[regno]);\n+\t  else if (regno <= LAST_VIRTUAL_REGISTER)\n+\t    {\n+\t      if (regno == VIRTUAL_INCOMING_ARGS_REGNUM)\n+\t\tfprintf (outfile, \" %d virtual-incoming-args\", regno);\n+\t      else if (regno == VIRTUAL_STACK_VARS_REGNUM)\n+\t\tfprintf (outfile, \" %d virtual-stack-vars\", regno);\n+\t      else if (regno == VIRTUAL_STACK_DYNAMIC_REGNUM)\n+\t\tfprintf (outfile, \" %d virtual-stack-dynamic\", regno);\n+\t      else if (regno == VIRTUAL_OUTGOING_ARGS_REGNUM)\n+\t\tfprintf (outfile, \" %d virtual-outgoing-args\", regno);\n+\t      else if (regno == VIRTUAL_CFA_REGNUM)\n+\t\tfprintf (outfile, \" %d virtual-cfa\", regno);\n+\t      else if (regno == VIRTUAL_PREFERRED_STACK_BOUNDARY_REGNUM)\n+\t\tfprintf (outfile, \" %d virtual-preferred-stack-boundary\",\n+\t\t\t regno);\n+\t      else\n+\t\tfprintf (outfile, \" %d virtual-reg-%d\", regno,\n+\t\t\t regno-FIRST_VIRTUAL_REGISTER);\n+\t    }\n+\t  else\n+#endif\n+\t    if (flag_dump_unnumbered && is_insn)\n+\t      fputc ('#', outfile);\n+\t    else\n+\t      fprintf (outfile, \" %d\", regno);\n+\n+#ifndef GENERATOR_FILE\n+\t  if (REG_ATTRS (in_rtx))\n+\t    {\n+\t      fputs (\" [\", outfile);\n+\t      if (regno != ORIGINAL_REGNO (in_rtx))\n+\t\tfprintf (outfile, \"orig:%i\", ORIGINAL_REGNO (in_rtx));\n+\t      if (REG_EXPR (in_rtx))\n+\t\tprint_mem_expr (outfile, REG_EXPR (in_rtx));\n+\n+\t      if (REG_OFFSET (in_rtx))\n+\t\tfprintf (outfile, \"+\" HOST_WIDE_INT_PRINT_DEC,\n+\t\t\t REG_OFFSET (in_rtx));\n+\t      fputs (\" ]\", outfile);\n+\t    }\n+\t  if (regno != ORIGINAL_REGNO (in_rtx))\n+\t    fprintf (outfile, \" [%d]\", ORIGINAL_REGNO (in_rtx));\n+#endif\n+\t  break;\n+\t}\n+\n       /* Print NOTE_INSN names rather than integer codes.  */\n \n       case 'n':"}, {"sha": "a1ff48d06678179aa3ffd567e7efe9e0234ae24d", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -1346,6 +1346,13 @@ read_rtx_code (const char *code_name)\n \t\t\t\t       name.string);\n \tbreak;\n \n+      case 'r':\n+\tread_name (&name);\n+\tvalidate_const_int (name.string);\n+\tSET_REGNO_RAW (return_rtx, atoi (name.string));\n+\tREG_ATTRS (return_rtx) = NULL;\n+\tbreak;\n+\n       default:\n \tgcc_unreachable ();\n       }"}, {"sha": "7d7a9a09c2029a53a9b802ea946a6394afa23b39", "filename": "gcc/regcprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -410,7 +410,7 @@ maybe_mode_change (machine_mode orig_mode, machine_mode copy_mode,\n     return NULL_RTX;\n \n   if (orig_mode == new_mode)\n-    return gen_rtx_raw_REG (new_mode, regno);\n+    return gen_raw_REG (new_mode, regno);\n   else if (mode_change_ok (orig_mode, new_mode, regno))\n     {\n       int copy_nregs = hard_regno_nregs[copy_regno][copy_mode];\n@@ -426,7 +426,7 @@ maybe_mode_change (machine_mode orig_mode, machine_mode copy_mode,\n \t\t+ (BYTES_BIG_ENDIAN ? byteoffset : 0));\n       regno += subreg_regno_offset (regno, orig_mode, offset, new_mode);\n       if (HARD_REGNO_MODE_OK (regno, new_mode))\n-\treturn gen_rtx_raw_REG (new_mode, regno);\n+\treturn gen_raw_REG (new_mode, regno);\n     }\n   return NULL_RTX;\n }"}, {"sha": "998f0254fdcb4874c0d64638bb576b18f40d4b9a", "filename": "gcc/rtl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -89,7 +89,8 @@ const char * const rtx_format[NUM_RTX_CODE] = {\n          prints the uid of the insn.\n      \"b\" is a pointer to a bitmap header.\n      \"B\" is a basic block pointer.\n-     \"t\" is a tree pointer.  */\n+     \"t\" is a tree pointer.\n+     \"r\" a register.  */\n \n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   FORMAT ,\n #include \"rtl.def\"\t\t/* rtl expressions are defined here */\n@@ -112,6 +113,8 @@ const unsigned char rtx_code_size[NUM_RTX_CODE] = {\n   (((ENUM) == CONST_INT || (ENUM) == CONST_DOUBLE\t\t\t\\\n     || (ENUM) == CONST_FIXED || (ENUM) == CONST_WIDE_INT)\t\t\\\n    ? RTX_HDR_SIZE + (sizeof FORMAT - 1) * sizeof (HOST_WIDE_INT)\t\\\n+   : (ENUM) == REG\t\t\t\t\t\t\t\\\n+   ? RTX_HDR_SIZE + sizeof (reg_info)\t\t\t\t\t\\\n    : RTX_HDR_SIZE + (sizeof FORMAT - 1) * sizeof (rtunion)),\n \n #include \"rtl.def\""}, {"sha": "cca469dafc5eec269ad9f3febc4f3c400a396295", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -381,7 +381,7 @@ DEF_RTL_EXPR(PC, \"pc\", \"\", RTX_OBJ)\n    points to a reg_attrs structure.\n    This rtx needs to have as many (or more) fields as a MEM, since we\n    can change REG rtx's into MEMs during reload.  */\n-DEF_RTL_EXPR(REG, \"reg\", \"i0\", RTX_OBJ)\n+DEF_RTL_EXPR(REG, \"reg\", \"r\", RTX_OBJ)\n \n /* A scratch register.  This represents a register used only within a\n    single insn.  It will be replaced by a REG during register allocation"}, {"sha": "88aab6d3156fe672a2ce1c64bb20c7bca2312064", "filename": "gcc/rtl.h", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -201,11 +201,21 @@ union rtunion\n   tree rt_tree;\n   basic_block rt_bb;\n   mem_attrs *rt_mem;\n-  reg_attrs *rt_reg;\n   struct constant_descriptor_rtx *rt_constant;\n   struct dw_cfi_node *rt_cfi;\n };\n \n+/* Describes the properties of a REG.  */\n+struct GTY(()) reg_info {\n+  /* The value of REGNO.  */\n+  unsigned int regno;\n+\n+  unsigned int unused : 32;\n+\n+  /* The value of REG_ATTRS.  */\n+  reg_attrs *attrs;\n+};\n+\n /* This structure remembers the position of a SYMBOL_REF within an\n    object_block structure.  A SYMBOL_REF only provides this information\n    if SYMBOL_REF_HAS_BLOCK_INFO_P is true.  */\n@@ -395,6 +405,7 @@ struct GTY((desc(\"0\"), tag(\"0\"),\n   union u {\n     rtunion fld[1];\n     HOST_WIDE_INT hwint[1];\n+    struct reg_info reg;\n     struct block_symbol block_sym;\n     struct real_value rv;\n     struct fixed_value fv;\n@@ -1070,6 +1081,13 @@ is_a_helper <rtx_note *>::test (rtx_insn *insn)\n \t\t\t\t __LINE__, __FUNCTION__);\t\t\\\n    &_rtx->u.fv; })\n \n+#define REG_CHECK(RTX) __extension__\t\t\t\t\t\\\n+({ __typeof (RTX) const _rtx = (RTX);\t\t\t\t\t\\\n+   if (GET_CODE (_rtx) != REG)\t\t\t\t\t\t\\\n+     rtl_check_failed_code1 (_rtx, REG,  __FILE__, __LINE__,\t\t\\\n+\t\t\t     __FUNCTION__);\t\t\t\t\\\n+   &_rtx->u.reg; })\n+\n #define BLOCK_SYMBOL_CHECK(RTX) __extension__\t\t\t\t\\\n ({ __typeof (RTX) const _symbol = (RTX);\t\t\t\t\\\n    const unsigned int flags = SYMBOL_REF_FLAGS (_symbol);\t\t\\\n@@ -1124,6 +1142,7 @@ extern void rtvec_check_failed_bounds (const_rtvec, int, const char *, int,\n #define XCNMWINT(RTX, N, C, M)\t    ((RTX)->u.hwint[N])\n #define XCNMPRV(RTX, C, M)\t    (&(RTX)->u.rv)\n #define XCNMPFV(RTX, C, M)\t    (&(RTX)->u.fv)\n+#define REG_CHECK(RTX)\t\t    (&(RTX)->u.reg)\n #define BLOCK_SYMBOL_CHECK(RTX)\t    (&(RTX)->u.block_sym)\n #define HWIVEC_CHECK(RTX,C)\t    (&(RTX)->u.hwiv)\n \n@@ -1248,7 +1267,6 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n #define X0ADVFLAGS(RTX, N) (RTL_CHECK1 (RTX, N, '0').rt_addr_diff_vec_flags)\n #define X0CSELIB(RTX, N)   (RTL_CHECK1 (RTX, N, '0').rt_cselib)\n #define X0MEMATTR(RTX, N)  (RTL_CHECKC1 (RTX, N, MEM).rt_mem)\n-#define X0REGATTR(RTX, N)  (RTL_CHECKC1 (RTX, N, REG).rt_reg)\n #define X0CONSTANT(RTX, N) (RTL_CHECK1 (RTX, N, '0').rt_constant)\n \n /* Access a '0' field with any type.  */\n@@ -1694,7 +1712,7 @@ inline rtx_insn *JUMP_LABEL_AS_INSN (const rtx_insn *insn)\n    be used on RHS.  Use SET_REGNO to change the value.  */\n #define REGNO(RTX) (rhs_regno(RTX))\n #define SET_REGNO(RTX, N) (df_ref_change_reg_with_loc (RTX, N))\n-#define SET_REGNO_RAW(RTX, N) (XCUINT (RTX, 0, REG) = N)\n+#define SET_REGNO_RAW(RTX, N) (REG_CHECK (RTX)->regno = N)\n \n /* Return the number of consecutive registers in a REG.  This is always\n    1 for pseudo registers and is determined by HARD_REGNO_NREGS for\n@@ -1714,7 +1732,7 @@ inline rtx_insn *JUMP_LABEL_AS_INSN (const rtx_insn *insn)\n static inline unsigned int\n rhs_regno (const_rtx x)\n {\n-  return XCUINT (x, 0, REG);\n+  return REG_CHECK (x)->regno;\n }\n \n \n@@ -2271,7 +2289,7 @@ do {\t\t\t\t\t\t\t\t        \\\n \n /* The register attribute block.  We provide access macros for each value\n    in the block and provide defaults if none specified.  */\n-#define REG_ATTRS(RTX) X0REGATTR (RTX, 1)\n+#define REG_ATTRS(RTX) (REG_CHECK (RTX)->attrs)\n \n #ifndef GENERATOR_FILE\n /* For a MEM rtx, the alias set.  If 0, this MEM is not in any alias"}, {"sha": "93b9699404df5ec4350d8f2c1679a5689e17569e", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fccb3359422e2c649e55e20713b9a8fa2c1d0be/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=9fccb3359422e2c649e55e20713b9a8fa2c1d0be", "patch": "@@ -1429,7 +1429,7 @@ make_decl_rtl (tree decl)\n \t     confused with that register and be eliminated.  This usage is\n \t     somewhat suspect...  */\n \n-\t  SET_DECL_RTL (decl, gen_rtx_raw_REG (mode, reg_number));\n+\t  SET_DECL_RTL (decl, gen_raw_REG (mode, reg_number));\n \t  ORIGINAL_REGNO (DECL_RTL (decl)) = reg_number;\n \t  REG_USERVAR_P (DECL_RTL (decl)) = 1;\n "}]}