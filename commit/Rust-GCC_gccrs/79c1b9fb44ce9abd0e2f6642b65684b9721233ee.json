{"sha": "79c1b9fb44ce9abd0e2f6642b65684b9721233ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzljMWI5ZmI0NGNlOWFiZDBlMmY2NjQyYjY1Njg0Yjk3MjEyMzNlZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-09T18:46:58Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-10T13:21:52Z"}, "message": "c++: name-lookup cleanups\n\nName-lookup is the most changed piece of the front end for modules.\nHere are some preparatort cleanups and API extensions.\n\n\tgcc/cp/\n\t* name-lookup.h (set_class_bindings): Return vector, take signed\n\t'extra' parm.\n\t* name-lookup.c (maybe_lazily_declare): Break out ...\n\t(get_class_binding): .. of here, call it.\n\t(find_member_slot): Adjust get_class_bindings call.\n\t(set_class_bindings): Allow -ve extra.  Return the vector.\n\t(set_identifier_type_value_with_scope): Remove checking assert.\n\t(lookup_using_decl): Set decl's context.\n\t(do_pushtag): Adjust set_identifier_type_value_with_scope handling.", "tree": {"sha": "5627ac7623fde38782d6babcb853ee7608814be0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5627ac7623fde38782d6babcb853ee7608814be0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79c1b9fb44ce9abd0e2f6642b65684b9721233ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c1b9fb44ce9abd0e2f6642b65684b9721233ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79c1b9fb44ce9abd0e2f6642b65684b9721233ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c1b9fb44ce9abd0e2f6642b65684b9721233ee/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e6562043c48c0ae6bc9823d438685269eb11aab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e6562043c48c0ae6bc9823d438685269eb11aab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e6562043c48c0ae6bc9823d438685269eb11aab"}], "stats": {"total": 107, "additions": 53, "deletions": 54}, "files": [{"sha": "fa37281034934768d9448fb3db6db84f906f6135", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c1b9fb44ce9abd0e2f6642b65684b9721233ee/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c1b9fb44ce9abd0e2f6642b65684b9721233ee/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=79c1b9fb44ce9abd0e2f6642b65684b9721233ee", "patch": "@@ -1338,6 +1338,36 @@ get_class_binding_direct (tree klass, tree name, bool want_type)\n   return val;\n }\n \n+/* We're about to lookup NAME in KLASS.  Make sure any lazily declared\n+   members are now declared.  */\n+\n+static void\n+maybe_lazily_declare (tree klass, tree name)\n+{\n+  /* Lazily declare functions, if we're going to search these.  */\n+  if (IDENTIFIER_CTOR_P (name))\n+    {\n+      if (CLASSTYPE_LAZY_DEFAULT_CTOR (klass))\n+\tlazily_declare_fn (sfk_constructor, klass);\n+      if (CLASSTYPE_LAZY_COPY_CTOR (klass))\n+\tlazily_declare_fn (sfk_copy_constructor, klass);\n+      if (CLASSTYPE_LAZY_MOVE_CTOR (klass))\n+\tlazily_declare_fn (sfk_move_constructor, klass);\n+    }\n+  else if (IDENTIFIER_DTOR_P (name))\n+    {\n+      if (CLASSTYPE_LAZY_DESTRUCTOR (klass))\n+\tlazily_declare_fn (sfk_destructor, klass);\n+    }\n+  else if (name == assign_op_identifier)\n+    {\n+      if (CLASSTYPE_LAZY_COPY_ASSIGN (klass))\n+\tlazily_declare_fn (sfk_copy_assignment, klass);\n+      if (CLASSTYPE_LAZY_MOVE_ASSIGN (klass))\n+\tlazily_declare_fn (sfk_move_assignment, klass);\n+    }\n+}\n+\n /* Look for NAME's binding in exactly KLASS.  See\n    get_class_binding_direct for argument description.  Does lazy\n    special function creation as necessary.  */\n@@ -1348,30 +1378,7 @@ get_class_binding (tree klass, tree name, bool want_type /*=false*/)\n   klass = complete_type (klass);\n \n   if (COMPLETE_TYPE_P (klass))\n-    {\n-      /* Lazily declare functions, if we're going to search these.  */\n-      if (IDENTIFIER_CTOR_P (name))\n-\t{\n-\t  if (CLASSTYPE_LAZY_DEFAULT_CTOR (klass))\n-\t    lazily_declare_fn (sfk_constructor, klass);\n-\t  if (CLASSTYPE_LAZY_COPY_CTOR (klass))\n-\t    lazily_declare_fn (sfk_copy_constructor, klass);\n-\t  if (CLASSTYPE_LAZY_MOVE_CTOR (klass))\n-\t    lazily_declare_fn (sfk_move_constructor, klass);\n-\t}\n-      else if (IDENTIFIER_DTOR_P (name))\n-\t{\n-\t  if (CLASSTYPE_LAZY_DESTRUCTOR (klass))\n-\t    lazily_declare_fn (sfk_destructor, klass);\n-\t}\n-      else if (name == assign_op_identifier)\n-\t{\n-\t  if (CLASSTYPE_LAZY_COPY_ASSIGN (klass))\n-\t    lazily_declare_fn (sfk_copy_assignment, klass);\n-\t  if (CLASSTYPE_LAZY_MOVE_ASSIGN (klass))\n-\t    lazily_declare_fn (sfk_move_assignment, klass);\n-\t}\n-    }\n+    maybe_lazily_declare (klass, name);\n \n   return get_class_binding_direct (klass, name, want_type);\n }\n@@ -1392,14 +1399,11 @@ find_member_slot (tree klass, tree name)\n       vec_alloc (member_vec, 8);\n       CLASSTYPE_MEMBER_VEC (klass) = member_vec;\n       if (complete_p)\n-\t{\n-\t  /* If the class is complete but had no member_vec, we need\n-\t     to add the TYPE_FIELDS into it.  We're also most likely\n-\t     to be adding ctors & dtors, so ask for 6 spare slots (the\n-\t     abstract cdtors and their clones).  */\n-\t  set_class_bindings (klass, 6);\n-\t  member_vec = CLASSTYPE_MEMBER_VEC (klass);\n-\t}\n+\t/* If the class is complete but had no member_vec, we need to\n+\t   add the TYPE_FIELDS into it.  We're also most likely to be\n+\t   adding ctors & dtors, so ask for 6 spare slots (the\n+\t   abstract cdtors and their clones).  */\n+\tmember_vec = set_class_bindings (klass, 6);\n     }\n \n   if (IDENTIFIER_CONV_OP_P (name))\n@@ -1741,18 +1745,18 @@ member_vec_dedup (vec<tree, va_gc> *member_vec)\n    no existing MEMBER_VEC and fewer than 8 fields, do nothing.  We\n    know there must be at least 1 field -- the self-reference\n    TYPE_DECL, except for anon aggregates, which will have at least\n-   one field anyway.  */\n+   one field anyway.  If EXTRA < 0, always create the vector.  */\n \n-void \n-set_class_bindings (tree klass, unsigned extra)\n+vec<tree, va_gc> *\n+set_class_bindings (tree klass, int extra)\n {\n   unsigned n_fields = count_class_fields (klass);\n   vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (klass);\n \n-  if (member_vec || n_fields >= 8)\n+  if (member_vec || n_fields >= 8 || extra < 0)\n     {\n       /* Append the new fields.  */\n-      vec_safe_reserve_exact (member_vec, extra + n_fields);\n+      vec_safe_reserve_exact (member_vec, n_fields + (extra >= 0 ? extra : 0));\n       member_vec_append_class_fields (member_vec, klass);\n     }\n \n@@ -1762,6 +1766,8 @@ set_class_bindings (tree klass, unsigned extra)\n       member_vec->qsort (member_name_cmp);\n       member_vec_dedup (member_vec);\n     }\n+\n+  return member_vec;\n }\n \n /* Insert lately defined enum ENUMTYPE into KLASS for the sorted case.  */\n@@ -3717,13 +3723,6 @@ set_identifier_type_value_with_scope (tree id, tree decl, cp_binding_level *b)\n   else\n     {\n       gcc_assert (decl);\n-      if (CHECKING_P)\n-\t{\n-\t  tree *slot = find_namespace_slot (current_namespace, id);\n-\t  gcc_checking_assert (slot\n-\t\t\t       && (decl == MAYBE_STAT_TYPE (*slot)\n-\t\t\t\t   || decl == MAYBE_STAT_DECL (*slot)));\n-\t}\n \n       /* Store marker instead of real type.  */\n       type = global_type_node;\n@@ -4547,7 +4546,8 @@ push_class_level_binding (tree name, tree x)\n }\n \n /* Process and lookup a using decl SCOPE::lookup.name, filling in\n-   lookup.values & lookup.type.  Return true if ok.  */\n+   lookup.values & lookup.type.  Return a USING_DECL, or NULL_TREE on\n+   failure.  */\n \n static tree\n lookup_using_decl (tree scope, name_lookup &lookup)\n@@ -4757,6 +4757,7 @@ lookup_using_decl (tree scope, name_lookup &lookup)\n   USING_DECL_SCOPE (using_decl) = scope;\n   USING_DECL_DECLS (using_decl) = lookup.value;\n   DECL_DEPENDENT_P (using_decl) = dependent_p;\n+  DECL_CONTEXT (using_decl) = current;\n   if (TYPE_P (current) && b_kind == bk_not_base)\n     USING_DECL_UNRELATED_P (using_decl) = true;\n \n@@ -6918,7 +6919,6 @@ do_pushtag (tree name, tree type, TAG_how how)\n   if (identifier_type_value_1 (name) != type)\n     {\n       tree tdef;\n-      int in_class = 0;\n       tree context = TYPE_CONTEXT (type);\n \n       if (! context)\n@@ -6949,20 +6949,17 @@ do_pushtag (tree name, tree type, TAG_how how)\n       if (!context)\n \tcontext = current_namespace;\n \n-      if (b->kind == sk_class\n-\t  || (b->kind == sk_template_parms\n-\t      && b->level_chain->kind == sk_class))\n-\tin_class = 1;\n-\n       tdef = create_implicit_typedef (name, type);\n       DECL_CONTEXT (tdef) = FROB_CONTEXT (context);\n       decl = maybe_process_template_type_declaration\n \t(type, how == TAG_how::HIDDEN_FRIEND, b);\n       if (decl == error_mark_node)\n \treturn decl;\n \n+      bool in_class = false;\n       if (b->kind == sk_class)\n \t{\n+\t  in_class = true;\n \t  if (!TYPE_BEING_DEFINED (current_class_type))\n \t    /* Don't push anywhere if the class is complete; a lambda in an\n \t       NSDMI is not a member of the class.  */\n@@ -6976,7 +6973,9 @@ do_pushtag (tree name, tree type, TAG_how how)\n \t  else\n \t    pushdecl_class_level (decl);\n \t}\n-      else if (b->kind != sk_template_parms)\n+      else if (b->kind == sk_template_parms)\n+\tin_class = b->level_chain->kind == sk_class;\n+      else\n \t{\n \t  decl = do_pushdecl_with_scope\n \t    (decl, b, /*hiding=*/(how == TAG_how::HIDDEN_FRIEND));\n@@ -6993,7 +6992,7 @@ do_pushtag (tree name, tree type, TAG_how how)\n \t    }\n \t}\n \n-      if (! in_class)\n+      if (!in_class)\n \tset_identifier_type_value_with_scope (name, tdef, b);\n \n       TYPE_CONTEXT (type) = DECL_CONTEXT (decl);"}, {"sha": "671977ffc92aeae0c5c3837d7704871b33c0bbb0", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c1b9fb44ce9abd0e2f6642b65684b9721233ee/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c1b9fb44ce9abd0e2f6642b65684b9721233ee/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=79c1b9fb44ce9abd0e2f6642b65684b9721233ee", "patch": "@@ -457,7 +457,7 @@ extern tree *find_member_slot (tree klass, tree name);\n extern tree *add_member_slot (tree klass, tree name);\n extern void resort_type_member_vec (void *, void *,\n \t\t\t\t    gt_pointer_operator, void *);\n-extern void set_class_bindings (tree, unsigned extra = 0);\n+extern vec<tree, va_gc> *set_class_bindings (tree, int extra = 0);\n extern void insert_late_enum_def_bindings (tree, tree);\n extern tree innermost_non_namespace_value (tree);\n extern cxx_binding *outer_binding (tree, cxx_binding *, bool);"}]}