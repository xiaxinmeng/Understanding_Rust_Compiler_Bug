{"sha": "3ae1d4c240f91dc62b85be2addb733fb773956b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FlMWQ0YzI0MGY5MWRjNjJiODViZTJhZGRiNzMzZmI3NzM5NTZiOQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-06-02T01:41:05Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-06-02T01:41:05Z"}, "message": "builtin-attrs.def (ATTR_ASM_FPRINTF): New.\n\n\t* builtin-attrs.def (ATTR_ASM_FPRINTF): New.\n\t* c-format.c (enum format_type): Add asm_fprintf_format_type.\n\t(NOARGUMENTS, asm_fprintf_length_specs, asm_fprintf_flag_specs,\n\tasm_fprintf_flag_pairs, asm_fprintf_char_table): New.\n\t(format_types_orig): Renamed from format_types.  Add new data.\n\t(format_types): Declare as pointer.\n\t(handle_format_attribute): Move later in file so we have all\n\tnecessary declarations.  Add section to capture HOST_WIDE_INT.\n\t* output.h (ATTRIBUTE_ASM_FPRINTF, __gcc_host_wide_int__): New.\n\t(asm_fprintf): Mark with ATTRIBUTE_ASM_FPRINTF.\n\nFrom-SVN: r67319", "tree": {"sha": "b762abdd19228fe192566d3e6ab942e566cf8072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b762abdd19228fe192566d3e6ab942e566cf8072"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ae1d4c240f91dc62b85be2addb733fb773956b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ae1d4c240f91dc62b85be2addb733fb773956b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ae1d4c240f91dc62b85be2addb733fb773956b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ae1d4c240f91dc62b85be2addb733fb773956b9/comments", "author": null, "committer": null, "parents": [{"sha": "069093f524d68bf436a86ec35a4004cb983f4d87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/069093f524d68bf436a86ec35a4004cb983f4d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/069093f524d68bf436a86ec35a4004cb983f4d87"}], "stats": {"total": 273, "additions": 200, "deletions": 73}, "files": [{"sha": "a27d56ff6f8eb609046698371b8c94302a1391f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae1d4c240f91dc62b85be2addb733fb773956b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae1d4c240f91dc62b85be2addb733fb773956b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ae1d4c240f91dc62b85be2addb733fb773956b9", "patch": "@@ -1,3 +1,16 @@\n+2003-06-01  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtin-attrs.def (ATTR_ASM_FPRINTF): New.\n+\t* c-format.c (enum format_type): Add asm_fprintf_format_type.\n+\t(NOARGUMENTS, asm_fprintf_length_specs, asm_fprintf_flag_specs,\n+\tasm_fprintf_flag_pairs, asm_fprintf_char_table): New.\n+\t(format_types_orig): Renamed from format_types.  Add new data.\n+\t(format_types): Declare as pointer.\n+\t(handle_format_attribute): Move later in file so we have all\n+\tnecessary declarations.  Add section to capture HOST_WIDE_INT.\n+\t* output.h (ATTRIBUTE_ASM_FPRINTF, __gcc_host_wide_int__): New.\n+\t(asm_fprintf): Mark with ATTRIBUTE_ASM_FPRINTF.\n+\n 2003-06-01  Andreas Jaeger  <aj@suse.de>\n \n \t* doc/tm.texi (Storage Layout): Remove ROUND_TYPE_SIZE and"}, {"sha": "8314b88cdca2885efe485efc8169411bc6d1ce52", "filename": "gcc/builtin-attrs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae1d4c240f91dc62b85be2addb733fb773956b9/gcc%2Fbuiltin-attrs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae1d4c240f91dc62b85be2addb733fb773956b9/gcc%2Fbuiltin-attrs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-attrs.def?ref=3ae1d4c240f91dc62b85be2addb733fb773956b9", "patch": "@@ -86,6 +86,7 @@ DEF_ATTR_IDENT (ATTR_NONNULL, \"nonnull\")\n DEF_ATTR_IDENT (ATTR_NORETURN, \"noreturn\")\n DEF_ATTR_IDENT (ATTR_NOTHROW, \"nothrow\")\n DEF_ATTR_IDENT (ATTR_PRINTF, \"printf\")\n+DEF_ATTR_IDENT (ATTR_ASM_FPRINTF, \"asm_fprintf\")\n DEF_ATTR_IDENT (ATTR_PURE, \"pure\")\n DEF_ATTR_IDENT (ATTR_SCANF, \"scanf\")\n DEF_ATTR_IDENT (ATTR_STRFMON, \"strfmon\")"}, {"sha": "a6ae983196df186b7c75e455cecd5afcaa7a2b45", "filename": "gcc/c-format.c", "status": "modified", "additions": 175, "deletions": 72, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae1d4c240f91dc62b85be2addb733fb773956b9/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae1d4c240f91dc62b85be2addb733fb773956b9/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=3ae1d4c240f91dc62b85be2addb733fb773956b9", "patch": "@@ -56,9 +56,9 @@ set_Wformat (setting)\n \n /* This must be in the same order as format_types, with format_type_error\n    last.  */\n-enum format_type { printf_format_type, scanf_format_type,\n-\t\t   strftime_format_type, strfmon_format_type,\n-\t\t   format_type_error };\n+enum format_type { printf_format_type, asm_fprintf_format_type,\n+\t\t   scanf_format_type, strftime_format_type,\n+\t\t   strfmon_format_type, format_type_error };\n \n typedef struct function_format_info\n {\n@@ -71,74 +71,6 @@ static bool decode_format_attr\t\tPARAMS ((tree,\n \t\t\t\t\t\t function_format_info *, int));\n static enum format_type decode_format_type\tPARAMS ((const char *));\n \n-/* Handle a \"format\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-tree\n-handle_format_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args;\n-     int flags;\n-     bool *no_add_attrs;\n-{\n-  tree type = *node;\n-  function_format_info info;\n-  tree argument;\n-  unsigned HOST_WIDE_INT arg_num;\n-\n-  if (!decode_format_attr (args, &info, 0))\n-    {\n-      *no_add_attrs = true;\n-      return NULL_TREE;\n-    }\n-\n-  /* If a parameter list is specified, verify that the format_num\n-     argument is actually a string, in case the format attribute\n-     is in error.  */\n-  argument = TYPE_ARG_TYPES (type);\n-  if (argument)\n-    {\n-      for (arg_num = 1; argument != 0 && arg_num != info.format_num;\n-\t   ++arg_num, argument = TREE_CHAIN (argument))\n-\t;\n-\n-      if (! argument\n-\t  || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n-\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n-\t      != char_type_node))\n-\t{\n-\t  if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n-\t    error (\"format string arg not a string type\");\n-\t  *no_add_attrs = true;\n-\t  return NULL_TREE;\n-\t}\n-\n-      else if (info.first_arg_num != 0)\n-\t{\n-\t  /* Verify that first_arg_num points to the last arg,\n-\t     the ...  */\n-\t  while (argument)\n-\t    arg_num++, argument = TREE_CHAIN (argument);\n-\n-\t  if (arg_num != info.first_arg_num)\n-\t    {\n-\t      if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n-\t\terror (\"args to be formatted is not '...'\");\n-\t      *no_add_attrs = true;\n-\t      return NULL_TREE;\n-\t    }\n-\t}\n-    }\n-\n-  if (info.format_type == strftime_format_type && info.first_arg_num != 0)\n-    {\n-      error (\"strftime formats cannot format arguments\");\n-      *no_add_attrs = true;\n-      return NULL_TREE;\n-    }\n-\n-  return NULL_TREE;\n-}\n \n \n /* Handle a \"format_arg\" attribute; arguments as in\n@@ -402,6 +334,7 @@ typedef struct\n \n \n /* Macros to fill out tables of these.  */\n+#define NOARGUMENTS\t{ T89_V, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n #define BADLEN\t{ 0, NULL, NULL }\n #define NOLENGTHS\t{ BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n \n@@ -574,6 +507,13 @@ static const format_length_info printf_length_specs[] =\n   { NULL, 0, 0, NULL, 0, 0 }\n };\n \n+/* Length specifiers valid for asm_fprintf.  */\n+static const format_length_info asm_fprintf_length_specs[] =\n+{\n+  { \"l\", FMT_LEN_l, STD_C89, \"ll\", FMT_LEN_ll, STD_C89 },\n+  { \"w\", FMT_LEN_none, STD_C89, NULL, 0, 0 },\n+  { NULL, 0, 0, NULL, 0, 0 }\n+};\n \n /* This differs from printf_length_specs only in that \"Z\" is not accepted.  */\n static const format_length_info scanf_length_specs[] =\n@@ -622,6 +562,26 @@ static const format_flag_pair printf_flag_pairs[] =\n   { 0, 0, 0, 0 }\n };\n \n+static const format_flag_spec asm_fprintf_flag_specs[] =\n+{\n+  { ' ',  0, 0, N_(\"` ' flag\"),        N_(\"the ` ' printf flag\"),              STD_C89 },\n+  { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' printf flag\"),              STD_C89 },\n+  { '#',  0, 0, N_(\"`#' flag\"),        N_(\"the `#' printf flag\"),              STD_C89 },\n+  { '0',  0, 0, N_(\"`0' flag\"),        N_(\"the `0' printf flag\"),              STD_C89 },\n+  { '-',  0, 0, N_(\"`-' flag\"),        N_(\"the `-' printf flag\"),              STD_C89 },\n+  { 'w',  0, 0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n+  { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n+  { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n+  { 0, 0, 0, NULL, NULL, 0 }\n+};\n+\n+static const format_flag_pair asm_fprintf_flag_pairs[] =\n+{\n+  { ' ', '+', 1, 0   },\n+  { '0', '-', 1, 0   },\n+  { '0', 'p', 1, 'i' },\n+  { 0, 0, 0, 0 }\n+};\n \n static const format_flag_spec scanf_flag_specs[] =\n {\n@@ -767,6 +727,26 @@ static const format_char_info print_char_table[] =\n   { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n };\n \n+static const format_char_info asm_fprintf_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +\",  \"i\" },\n+  { \"oxX\", 0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0#\",   \"i\" },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0\",    \"i\" },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\",       \"\" },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\",    \"cR\" },\n+\n+  /* asm_fprintf conversion specifiers.  */\n+  { \"O\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"R\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"I\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"L\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"U\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"r\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\" },\n+  { \"@\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n+};\n+\n static const format_char_info scan_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n@@ -822,14 +802,20 @@ static const format_char_info monetary_char_table[] =\n \n \n /* This must be in the same order as enum format_type.  */\n-static const format_kind_info format_types[] =\n+static const format_kind_info format_types_orig[] =\n {\n   { \"printf\",   printf_length_specs,  print_char_table, \" +#0-'I\", NULL, \n     printf_flag_specs, printf_flag_pairs,\n     FMT_FLAG_ARG_CONVERT|FMT_FLAG_DOLLAR_MULTIPLE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_EMPTY_PREC_OK,\n     'w', 0, 'p', 0, 'L',\n     &integer_type_node, &integer_type_node\n   },\n+  { \"asm_fprintf\",   asm_fprintf_length_specs,  asm_fprintf_char_table, \" +#0-\", NULL, \n+    asm_fprintf_flag_specs, asm_fprintf_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT|FMT_FLAG_EMPTY_PREC_OK,\n+    'w', 0, 'p', 0, 'L',\n+    &integer_type_node, &integer_type_node\n+  },\n   { \"scanf\",    scanf_length_specs,   scan_char_table,  \"*'I\", NULL, \n     scanf_flag_specs, scanf_flag_pairs,\n     FMT_FLAG_ARG_CONVERT|FMT_FLAG_SCANF_A_KLUDGE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_ZERO_WIDTH_BAD|FMT_FLAG_DOLLAR_GAP_POINTER_OK,\n@@ -848,6 +834,10 @@ static const format_kind_info format_types[] =\n   }\n };\n \n+/* This layer of indirection allows GCC to reassign format_types with\n+   new data if necessary, while still allowing the original data to be\n+   const.  */\n+static const format_kind_info *format_types = format_types_orig;\n \n /* Structure detailing the results of checking a format function call\n    where the format expression may be a conditional expression with\n@@ -2359,3 +2349,116 @@ check_format_types (status, types)\n       }\n     }\n }\n+\n+/* Handle a \"format\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+tree\n+handle_format_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree type = *node;\n+  function_format_info info;\n+  tree argument;\n+  unsigned HOST_WIDE_INT arg_num;\n+\n+  if (!decode_format_attr (args, &info, 0))\n+    {\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* If a parameter list is specified, verify that the format_num\n+     argument is actually a string, in case the format attribute\n+     is in error.  */\n+  argument = TYPE_ARG_TYPES (type);\n+  if (argument)\n+    {\n+      for (arg_num = 1; argument != 0 && arg_num != info.format_num;\n+\t   ++arg_num, argument = TREE_CHAIN (argument))\n+\t;\n+\n+      if (! argument\n+\t  || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n+\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n+\t      != char_type_node))\n+\t{\n+\t  if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n+\t    error (\"format string arg not a string type\");\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+\n+      else if (info.first_arg_num != 0)\n+\t{\n+\t  /* Verify that first_arg_num points to the last arg,\n+\t     the ...  */\n+\t  while (argument)\n+\t    arg_num++, argument = TREE_CHAIN (argument);\n+\n+\t  if (arg_num != info.first_arg_num)\n+\t    {\n+\t      if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n+\t\terror (\"args to be formatted is not '...'\");\n+\t      *no_add_attrs = true;\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+    }\n+\n+  if (info.format_type == strftime_format_type && info.first_arg_num != 0)\n+    {\n+      error (\"strftime formats cannot format arguments\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* If this is format type __asm_fprintf__, we have to initialize\n+     GCC's notion of HOST_WIDE_INT for checking %wd.  */\n+  if (info.format_type == asm_fprintf_format_type)\n+    {\n+      static tree hwi;\n+      tree orig;\n+      \n+      /* For this custom check to work, one must have issued:\n+\t \"typedef HOST_WIDE_INT __gcc_host_wide_int__;\"\n+\t in your source code prior to using this attribute.  */\n+      if (!hwi)\n+        {\n+\t  format_kind_info *new_format_types;\n+\t  format_length_info *new_asm_fprintf_length_specs;\n+\t  \n+\t  if (!(hwi = maybe_get_identifier (\"__gcc_host_wide_int__\")))\n+\t    abort ();\n+\n+\t  /* Create a new (writable) copy of asm_fprintf_length_specs.  */\n+\t  new_asm_fprintf_length_specs =\n+\t    xmalloc (sizeof (asm_fprintf_length_specs));\n+\t  memcpy (new_asm_fprintf_length_specs, asm_fprintf_length_specs,\n+\t\t  sizeof (asm_fprintf_length_specs));\n+\n+\t  /* Create a new (writable) copy of format_types.  */\n+\t  new_format_types = xmalloc (sizeof (format_types_orig));\n+\t  memcpy (new_format_types, format_types_orig, sizeof (format_types_orig));\n+\t  \n+\t  /* Find the underlying type for HOST_WIDE_INT.  */\n+\t  orig = DECL_ORIGINAL_TYPE (identifier_global_value (hwi));\n+\t  if (orig == long_integer_type_node)\n+\t    new_asm_fprintf_length_specs[1].index = FMT_LEN_l;\n+\t  else if (orig == long_long_integer_type_node)\n+\t    new_asm_fprintf_length_specs[1].index = FMT_LEN_ll;\n+\t  else\n+\t    abort ();\n+\n+\t  /* Assign the new data for use.  */\n+\t  new_format_types[asm_fprintf_format_type].length_char_specs =\n+\t    new_asm_fprintf_length_specs;\n+\t  format_types = new_format_types;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}"}, {"sha": "dcbcee691397135407d3aca8f14ea41e89aebf90", "filename": "gcc/output.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae1d4c240f91dc62b85be2addb733fb773956b9/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae1d4c240f91dc62b85be2addb733fb773956b9/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=3ae1d4c240f91dc62b85be2addb733fb773956b9", "patch": "@@ -105,7 +105,17 @@ extern void output_addr_const PARAMS ((FILE *, rtx));\n \n /* Output a string of assembler code, substituting numbers, strings\n    and fixed syntactic prefixes.  */\n-extern void asm_fprintf\t\tPARAMS ((FILE *file, const char *p, ...));\n+#if GCC_VERSION >= 3004\n+#define ATTRIBUTE_ASM_FPRINTF(m, n) __attribute__ ((__format__ (__asm_fprintf__, m, n))) ATTRIBUTE_NONNULL(m)\n+/* This is a magic identifier which allows GCC to figure out the type\n+   of HOST_WIDE_INT for %wd specifier checks.  You must issue this\n+   typedef before using the __asm_fprintf__ format attribute.  */\n+typedef HOST_WIDE_INT __gcc_host_wide_int__;\n+#else\n+#define ATTRIBUTE_ASM_FPRINTF(m, n) ATTRIBUTE_NONNULL(m)\n+#endif\n+\n+extern void asm_fprintf\t\tPARAMS ((FILE *file, const char *p, ...)) ATTRIBUTE_ASM_FPRINTF(2, 3);\n \n /* Split up a CONST_DOUBLE or integer constant rtx into two rtx's for single\n    words.  */"}]}