{"sha": "c50502ca4ebb4d4bd2df9edf1eb5c53aacfa0a1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUwNTAyY2E0ZWJiNGQ0YmQyZGY5ZWRmMWViNWM1M2FhY2ZhMGExZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-06T09:30:53Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-07T06:43:23Z"}, "message": "fix LTO streaming order dependence on randomness\n\nThis fixes the sorting of to copy symbols in lto_output introduced\nwith GCC 10 to not depend on the actual values of the randomness\nwe append to LTO section names but instead on the order they appear\nin the unsorted array.\n\nThis fixed observed debug info differences due to tree merging\nprevailing different early debug pointers.\n\n2020-07-06  Richard Biener  <rguenther@suse.de>\n\n\t* lto-streamer-out.c (cmp_symbol_files): Use the computed\n\torder map to sort symbols from the same sub-file together.\n\t(lto_output): Compute a map of sub-file to an order number\n\tit appears in the symbol output array.", "tree": {"sha": "b909dd68ef2f33ca47fa985fd00ba12435d66aaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b909dd68ef2f33ca47fa985fd00ba12435d66aaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c50502ca4ebb4d4bd2df9edf1eb5c53aacfa0a1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c50502ca4ebb4d4bd2df9edf1eb5c53aacfa0a1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c50502ca4ebb4d4bd2df9edf1eb5c53aacfa0a1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c50502ca4ebb4d4bd2df9edf1eb5c53aacfa0a1e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4077d74c6d8946b667f5544bb3dedf32d451aa2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4077d74c6d8946b667f5544bb3dedf32d451aa2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4077d74c6d8946b667f5544bb3dedf32d451aa2f"}], "stats": {"total": 29, "additions": 21, "deletions": 8}, "files": [{"sha": "ec28928b56abc9e452bbe0e726201509a849e5cc", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50502ca4ebb4d4bd2df9edf1eb5c53aacfa0a1e/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50502ca4ebb4d4bd2df9edf1eb5c53aacfa0a1e/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=c50502ca4ebb4d4bd2df9edf1eb5c53aacfa0a1e", "patch": "@@ -2614,10 +2614,12 @@ produce_lto_section ()\n /* Compare symbols to get them sorted by filename (to optimize streaming)  */\n \n static int\n-cmp_symbol_files (const void *pn1, const void *pn2)\n+cmp_symbol_files (const void *pn1, const void *pn2, void *id_map_)\n {\n   const symtab_node *n1 = *(const symtab_node * const *)pn1;\n   const symtab_node *n2 = *(const symtab_node * const *)pn2;\n+  hash_map<lto_file_decl_data *, int> *id_map\n+    = (hash_map<lto_file_decl_data *, int> *)id_map_;\n \n   int file_order1 = n1->lto_file_data ? n1->lto_file_data->order : -1;\n   int file_order2 = n2->lto_file_data ? n2->lto_file_data->order : -1;\n@@ -2629,12 +2631,7 @@ cmp_symbol_files (const void *pn1, const void *pn2)\n \n   /* Order within static library.  */\n   if (n1->lto_file_data && n1->lto_file_data->id != n2->lto_file_data->id)\n-    {\n-      if (n1->lto_file_data->id > n2->lto_file_data->id)\n-\treturn 1;\n-      if (n1->lto_file_data->id < n2->lto_file_data->id)\n-\treturn -1;\n-    }\n+    return *id_map->get (n1->lto_file_data) - *id_map->get (n2->lto_file_data);\n \n   /* And finaly order by the definition order.  */\n   return n1->order - n2->order;\n@@ -2690,7 +2687,23 @@ lto_output (void)\n \t    symbols_to_copy.safe_push (node);\n \t}\n     }\n-  symbols_to_copy.qsort (cmp_symbol_files);\n+  /* Map the section hash to an order it appears in symbols_to_copy\n+     since we want to sort same ID symbols next to each other but need\n+     to avoid making overall order depend on the actual hash value.  */\n+  int order = 0;\n+  hash_map<lto_file_decl_data *, int> id_map;\n+  for (i = 0; i < symbols_to_copy.length (); ++i)\n+    {\n+      symtab_node *snode = symbols_to_copy[i];\n+      if (snode->lto_file_data)\n+\t{\n+\t  bool existed_p = false;\n+\t  int &ord = id_map.get_or_insert (snode->lto_file_data, &existed_p);\n+\t  if (!existed_p)\n+\t    ord = order++;\n+\t}\n+    }\n+  symbols_to_copy.sort (cmp_symbol_files, (void *)&id_map);\n   for (i = 0; i < symbols_to_copy.length (); i++)\n     {\n       symtab_node *snode = symbols_to_copy[i];"}]}