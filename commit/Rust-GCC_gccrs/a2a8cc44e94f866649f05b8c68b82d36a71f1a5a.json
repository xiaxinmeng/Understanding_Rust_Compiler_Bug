{"sha": "a2a8cc44e94f866649f05b8c68b82d36a71f1a5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJhOGNjNDRlOTRmODY2NjQ5ZjA1YjhjNjhiODJkMzZhNzFmMWE1YQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-02-04T06:12:54Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-02-04T06:12:54Z"}, "message": "emit-rtl.c (gen_rtx): Remove.\n\n\t* emit-rtl.c (gen_rtx): Remove.\n\t* genattrtab.c: Don't mention gen_rtx in a comment.\n\t* rtl.h: Remove the prototype for gen_rtx.\n\t* doc/md.texi: Replace gen_rtx with gen_rtx_REG.\n\nFrom-SVN: r77224", "tree": {"sha": "763fd168a4e83cbf18b4e87455b7eb2ea89cb2f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/763fd168a4e83cbf18b4e87455b7eb2ea89cb2f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/comments", "author": null, "committer": null, "parents": [{"sha": "f61c92c3908acaeb636aee8c0271339d3e9ec291", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f61c92c3908acaeb636aee8c0271339d3e9ec291", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f61c92c3908acaeb636aee8c0271339d3e9ec291"}], "stats": {"total": 143, "additions": 18, "deletions": 125}, "files": [{"sha": "7a8ff1f424195ae6adff41c29d2542369a2b459f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2a8cc44e94f866649f05b8c68b82d36a71f1a5a", "patch": "@@ -1,3 +1,10 @@\n+2004-02-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* emit-rtl.c (gen_rtx): Remove.\n+\t* genattrtab.c: Don't mention gen_rtx in a comment.\n+\t* rtl.h: Remove the prototype for gen_rtx.\n+\t* doc/md.texi: Replace gen_rtx with gen_rtx_REG.\n+\n 2004-02-04  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/arc/arc.h, config/fr30/fr30.h"}, {"sha": "f8bf54ef7b93b7ef8b764d99b7fb1d18f95f4afe", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=a2a8cc44e94f866649f05b8c68b82d36a71f1a5a", "patch": "@@ -4595,7 +4595,7 @@ Here is an example, taken from the 68000 machine description:\n   \"FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])\"\n @{\n   rtx xoperands[2];\n-  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n #ifdef MOTOROLA\n   output_asm_insn (\"move.l %1,(sp)\", xoperands);\n   output_asm_insn (\"move.l %1,-(sp)\", operands);"}, {"sha": "12e54bdfd5334b4f26fa93e22c718815ff11eb66", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 120, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a2a8cc44e94f866649f05b8c68b82d36a71f1a5a", "patch": "@@ -22,18 +22,19 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Middle-to-low level generation of rtx code and insns.\n \n-   This file contains the functions `gen_rtx', `gen_reg_rtx'\n-   and `gen_label_rtx' that are the usual ways of creating rtl\n-   expressions for most purposes.\n+   This file contains the functions `gen_reg_rtx' and `gen_label_rtx'\n+   that are the usual ways of creating rtl expressions for most\n+   purposes.\n \n    It also has the functions for creating insns and linking\n    them in the doubly-linked chain.\n \n    The patterns of the insns are created by machine-dependent\n    routines in insn-emit.c, which is generated automatically from\n-   the machine description.  These routines use `gen_rtx' to make\n-   the individual rtx's of the pattern; what is machine dependent\n-   is the kind of rtx's they make and what arguments they use.  */\n+   the machine description.  These routines use `gen_rtx_fmt_ee' and\n+   others to make the individual rtx's of the pattern; what is machine\n+   dependent is the kind of rtx's they make and what arguments they\n+   use.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -645,119 +646,6 @@ gen_lowpart_SUBREG (enum machine_mode mode, rtx reg)\n \t\t\t subreg_lowpart_offset (mode, inmode));\n }\n \f\n-/* rtx gen_rtx (code, mode, [element1, ..., elementn])\n-**\n-**\t    This routine generates an RTX of the size specified by\n-**\t<code>, which is an RTX code.   The RTX structure is initialized\n-**\tfrom the arguments <element1> through <elementn>, which are\n-**\tinterpreted according to the specific RTX type's format.   The\n-**\tspecial machine mode associated with the rtx (if any) is specified\n-**\tin <mode>.\n-**\n-**\t    gen_rtx can be invoked in a way which resembles the lisp-like\n-**\trtx it will generate.   For example, the following rtx structure:\n-**\n-**\t      (plus:QI (mem:QI (reg:SI 1))\n-**\t\t       (mem:QI (plusw:SI (reg:SI 2) (reg:SI 3))))\n-**\n-**\t\t...would be generated by the following C code:\n-**\n-**\t\tgen_rtx_PLUS (QImode,\n-**\t\t    gen_rtx_MEM (QImode,\n-**\t\t\tgen_rtx_REG (SImode, 1)),\n-**\t\t    gen_rtx_MEM (QImode,\n-**\t\t\tgen_rtx_PLUS (SImode,\n-**\t\t\t    gen_rtx_REG (SImode, 2),\n-**\t\t\t    gen_rtx_REG (SImode, 3)))),\n-*/\n-\n-/*VARARGS2*/\n-rtx\n-gen_rtx (enum rtx_code code, enum machine_mode mode, ...)\n-{\n-  int i;\t\t/* Array indices...\t\t\t*/\n-  const char *fmt;\t/* Current rtx's format...\t\t*/\n-  rtx rt_val;\t\t/* RTX to return to caller...\t\t*/\n-  va_list p;\n-\n-  va_start (p, mode);\n-\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      rt_val = gen_rtx_CONST_INT (mode, va_arg (p, HOST_WIDE_INT));\n-      break;\n-\n-    case CONST_DOUBLE:\n-      {\n-\tHOST_WIDE_INT arg0 = va_arg (p, HOST_WIDE_INT);\n-\tHOST_WIDE_INT arg1 = va_arg (p, HOST_WIDE_INT);\n-\n-\trt_val = immed_double_const (arg0, arg1, mode);\n-      }\n-      break;\n-\n-    case REG:\n-      rt_val = gen_rtx_REG (mode, va_arg (p, int));\n-      break;\n-\n-    case MEM:\n-      rt_val = gen_rtx_MEM (mode, va_arg (p, rtx));\n-      break;\n-\n-    default:\n-      rt_val = rtx_alloc (code);\t/* Allocate the storage space.  */\n-      rt_val->mode = mode;\t\t/* Store the machine mode...  */\n-\n-      fmt = GET_RTX_FORMAT (code);\t/* Find the right format...  */\n-      for (i = 0; i < GET_RTX_LENGTH (code); i++)\n-\t{\n-\t  switch (*fmt++)\n-\t    {\n-\t    case '0':\t\t/* Field with unknown use.  Zero it.  */\n-\t      X0EXP (rt_val, i) = NULL_RTX;\n-\t      break;\n-\n-\t    case 'i':\t\t/* An integer?  */\n-\t      XINT (rt_val, i) = va_arg (p, int);\n-\t      break;\n-\n-\t    case 'w':\t\t/* A wide integer? */\n-\t      XWINT (rt_val, i) = va_arg (p, HOST_WIDE_INT);\n-\t      break;\n-\n-\t    case 's':\t\t/* A string?  */\n-\t      XSTR (rt_val, i) = va_arg (p, char *);\n-\t      break;\n-\n-\t    case 'e':\t\t/* An expression?  */\n-\t    case 'u':\t\t/* An insn?  Same except when printing.  */\n-\t      XEXP (rt_val, i) = va_arg (p, rtx);\n-\t      break;\n-\n-\t    case 'E':\t\t/* An RTX vector?  */\n-\t      XVEC (rt_val, i) = va_arg (p, rtvec);\n-\t      break;\n-\n-\t    case 'b':           /* A bitmap? */\n-\t      XBITMAP (rt_val, i) = va_arg (p, bitmap);\n-\t      break;\n-\n-\t    case 't':           /* A tree? */\n-\t      XTREE (rt_val, i) = va_arg (p, tree);\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n-\t    }\n-\t}\n-      break;\n-    }\n-\n-  va_end (p);\n-  return rt_val;\n-}\n-\n /* gen_rtvec (n, [rt1, ..., rtn])\n **\n **\t    This routine creates an rtvec and stores within it the\n@@ -5389,7 +5277,7 @@ init_emit_once (int line_numbers)\n \n   /* Create the unique rtx's for certain rtx codes and operand values.  */\n \n-  /* Don't use gen_rtx here since gen_rtx in this case\n+  /* Don't use gen_rtx_CONST_INT here since gen_rtx_CONST_INT in this case\n      tries to use these variables.  */\n   for (i = - MAX_SAVED_CONST_INT; i <= MAX_SAVED_CONST_INT; i++)\n     const_int_rtx[i + MAX_SAVED_CONST_INT] ="}, {"sha": "e1a3e728826bb8adb4f0d69d516000fdb1844bcb", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=a2a8cc44e94f866649f05b8c68b82d36a71f1a5a", "patch": "@@ -549,7 +549,7 @@ attr_hash_add_string (int hashcode, char *str)\n    In some cases we cannot uniquify; then we return an ordinary\n    impermanent rtx with ATTR_PERMANENT_P clear.\n \n-   Args are like gen_rtx, but without the mode:\n+   Args are as follows:\n \n    rtx attr_rtx (code, [element1, ..., elementn])  */\n "}, {"sha": "13fd72ba26fa3bcc92289b710f70fcece498effb", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2a8cc44e94f866649f05b8c68b82d36a71f1a5a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a2a8cc44e94f866649f05b8c68b82d36a71f1a5a", "patch": "@@ -1445,7 +1445,6 @@ extern rtx plus_constant_for_output_wide (rtx, HOST_WIDE_INT);\n extern void optimize_save_area_alloca (rtx);\n \n /* In emit-rtl.c */\n-extern rtx gen_rtx (enum rtx_code, enum machine_mode, ...);\n extern rtvec gen_rtvec (int, ...);\n extern rtx copy_insn_1 (rtx);\n extern rtx copy_insn (rtx);\n@@ -1874,8 +1873,7 @@ extern GTY(()) rtx return_address_pointer_rtx;\n \n /* There are some RTL codes that require special attention; the\n    generation functions included above do the raw handling.  If you\n-   add to this list, modify special_rtx in gengenrtl.c as well.  You\n-   should also modify gen_rtx to use the special function.  */\n+   add to this list, modify special_rtx in gengenrtl.c as well.  */\n \n extern rtx gen_rtx_CONST_INT (enum machine_mode, HOST_WIDE_INT);\n extern rtx gen_rtx_CONST_VECTOR (enum machine_mode, rtvec);"}]}