{"sha": "d77613be8b4729d32825609d5e95e055b236c53a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc3NjEzYmU4YjQ3MjlkMzI4MjU2MDlkNWU5NWUwNTViMjM2YzUzYQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-08-22T18:38:07Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-08-22T18:38:07Z"}, "message": "re GNATS gcj/30 (gcj not reporting unimplemented methods)\n\nSun Aug 22 11:07:41 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (check_method_redefinition): Changed leading comment.\n\t(check_abstract_method_definitions): New function.\n\t(java_check_abstract_method_definitions): New function.\n\t(java_check_regular_methods): Call it.\n\t(verify_constructor_super): Fixed indentation.\n\t(lookup_method_invoke): Likewise.\n\n(This fixes the Java net PR #30,\n http://sourceware.cygnus.com/ml/java-prs/1999-q3/msg00034.html)\n\nFrom-SVN: r28805", "tree": {"sha": "768c1eb1b46e0cf93bc35c2e49b5c1aeb3af6ad2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/768c1eb1b46e0cf93bc35c2e49b5c1aeb3af6ad2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d77613be8b4729d32825609d5e95e055b236c53a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d77613be8b4729d32825609d5e95e055b236c53a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d77613be8b4729d32825609d5e95e055b236c53a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d77613be8b4729d32825609d5e95e055b236c53a/comments", "author": null, "committer": null, "parents": [{"sha": "9d9169deaa2a0835754ea0b957d452ffa9690fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d9169deaa2a0835754ea0b957d452ffa9690fa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d9169deaa2a0835754ea0b957d452ffa9690fa7"}], "stats": {"total": 281, "additions": 267, "deletions": 14}, "files": [{"sha": "b44dae02b8afe41cc7120305111f488d1a10f478", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77613be8b4729d32825609d5e95e055b236c53a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77613be8b4729d32825609d5e95e055b236c53a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d77613be8b4729d32825609d5e95e055b236c53a", "patch": "@@ -1,3 +1,12 @@\n+Sun Aug 22 11:07:41 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (check_method_redefinition): Changed leading comment.\n+\t(check_abstract_method_definitions): New function.\n+\t(java_check_abstract_method_definitions): New function.\n+\t(java_check_regular_methods): Call it.\n+\t(verify_constructor_super): Fixed indentation.\n+\t(lookup_method_invoke): Likewise.\n+\n Thu Aug 19 10:26:18 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (method_header): Return a null pointer if the current"}, {"sha": "ba242a2f8b15251e7afa1e3adafd98af1e604fe4", "filename": "gcc/java/parse.c", "status": "modified", "additions": 129, "deletions": 7, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77613be8b4729d32825609d5e95e055b236c53a/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77613be8b4729d32825609d5e95e055b236c53a/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=d77613be8b4729d32825609d5e95e055b236c53a", "patch": "@@ -7134,7 +7134,7 @@ java_get_real_method_name (method_decl)\n \n /* Track method being redefined inside the same class. As a side\n    effect, set DECL_NAME to an IDENTIFIER (prior entering this\n-   function it's a FWL, so we can track errors more accurately */\n+   function it's a FWL, so we can track errors more accurately.)  */\n \n static int\n check_method_redefinition (class, method)\n@@ -7170,9 +7170,126 @@ check_method_redefinition (class, method)\n   return 0;\n }\n \n-/* Check all the methods of CLASS. Methods are first completed then\n-   checked according to regular method existance rules.\n-   If no constructor were encountered, then build its declaration. */\n+static void\n+check_abstract_method_definitions (do_interface, class_decl, type)\n+     int do_interface;\n+     tree class_decl, type;\n+{\n+  tree class = TREE_TYPE (class_decl);\n+  tree method, end_type;\n+\n+  end_type = (do_interface ? object_type_node : type);\n+  for (method = TYPE_METHODS (type); method; method = TREE_CHAIN (method))\n+    {\n+      tree other_super, other_method, method_sig, method_name;\n+      int found = 0;\n+      \n+      if (!METHOD_ABSTRACT (method) || METHOD_FINAL (method))\n+\tcontinue;\n+      \n+      /* Now verify that somewhere in between TYPE and CLASS,\n+\t abstract method METHOD gets a non abstract definition\n+\t that is inherited by CLASS.  */\n+      \n+      method_sig = build_java_signature (TREE_TYPE (method));\n+      method_name = DECL_NAME (method);\n+      if (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION)\n+\tmethod_name = EXPR_WFL_NODE (method_name);\n+\n+      for (other_super = class; other_super != end_type; \n+\t   other_super = CLASSTYPE_SUPER (other_super))\n+\t{\n+\t  for (other_method = TYPE_METHODS (other_super); other_method;\n+\t       other_method = TREE_CHAIN (other_method))\n+\t    {\n+\t      tree s = build_java_signature (TREE_TYPE (other_method));\n+\t      tree other_name = DECL_NAME (other_method);\n+\n+\t      if (TREE_CODE (other_name) == EXPR_WITH_FILE_LOCATION)\n+\t\tother_name = EXPR_WFL_NODE (other_name);\n+\t      if (!IS_CLINIT (other_method)\n+\t\t  && !DECL_CONSTRUCTOR_P (other_method)\n+\t\t  && method_name == other_name && method_sig == s)\n+\t\t{\n+\t\t  found = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      \n+      /* Report that abstract METHOD didn't find an implementation\n+\t that CLASS can use. */\n+      if (!found)\n+\t{\n+\t  char *t = strdup (lang_printable_name \n+\t\t\t    (TREE_TYPE (TREE_TYPE (method)), 0));\n+\t  tree ccn = DECL_NAME (TYPE_NAME (DECL_CONTEXT (method)));\n+\t  tree saved_wfl = NULL_TREE;\n+\t  \n+\t  if (TREE_CODE (DECL_NAME (method)) == EXPR_WITH_FILE_LOCATION)\n+\t    {\n+\t      saved_wfl = DECL_NAME (method);\n+\t      DECL_NAME (method) = EXPR_WFL_NODE (DECL_NAME (method));\n+\t    }\n+\t  \n+\t  parse_error_context \n+\t    (lookup_cl (class_decl),\n+\t     \"Class `%s' doesn't define the abstract method `%s %s' from \"\n+\t     \"%s `%s'. This method must be defined or %s `%s' must be \"\n+\t     \"declared abstract\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n+\t     t, lang_printable_name (method, 0), \n+\t     (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))) ? \n+\t      \"interface\" : \"class\"),\n+\t     IDENTIFIER_POINTER (ccn),\n+\t     (CLASS_INTERFACE (class_decl) ? \"interface\" : \"class\"),\n+\t     IDENTIFIER_POINTER (DECL_NAME (class_decl)));\n+\t  \n+\t  free (t);\n+\t  \n+\t  if (saved_wfl)\n+\t    DECL_NAME (method) = saved_wfl;\n+\t}\n+    }\n+}\n+\n+/* Check that CLASS_DECL somehoow implements all inherited abstract\n+   methods.  */\n+\n+static void\n+java_check_abstract_method_definitions (class_decl)\n+     tree class_decl;\n+{\n+  tree class = TREE_TYPE (class_decl);\n+  tree super, vector;\n+  int i;\n+\n+  if (CLASS_ABSTRACT (class_decl))\n+    return;\n+\n+  /* Check for inherited types */\n+  for (super = CLASSTYPE_SUPER (class); super != object_type_node; \n+       super = CLASSTYPE_SUPER (super))\n+    {\n+      if (!CLASS_ABSTRACT (TYPE_NAME (super)))\n+\tcontinue;\n+\n+      check_abstract_method_definitions (0, class_decl, super);\n+    }\n+\n+  /* Check for implemented interfaces. */\n+  vector = TYPE_BINFO_BASETYPES (class);\n+  for (i = 1; i < TREE_VEC_LENGTH (vector); i++)\n+    {\n+      super = BINFO_TYPE (TREE_VEC_ELT (vector, i));\n+      check_abstract_method_definitions (1, class_decl, super);\n+    }\n+}\n+\n+/* Check all the methods of CLASS_DECL. Methods are first completed\n+   then checked according to regular method existance rules.  If no\n+   constructor for CLASS_DECL were encountered, then build its\n+   declaration.  */\n \n static void\n java_check_regular_methods (class_decl)\n@@ -7348,14 +7465,18 @@ java_check_regular_methods (class_decl)\n   \n   /* Don't forget eventual pending found and saved_found_wfl. Take\n      into account that we might have exited because we saw an\n-     aritifical method as the last entry. */\n+     artificial method as the last entry. */\n \n   if (found && !DECL_ARTIFICIAL (found) && saved_found_wfl)\n     DECL_NAME (found) = saved_found_wfl;\n \n   if (!TYPE_NVIRTUALS (class))\n     TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n+  /* Search for inherited abstract method not yet implemented in this\n+     class.  */\n+  java_check_abstract_method_definitions (class_decl);\n+\n   if (!saw_constructor)\n     {\n       /* No constructor seen, we craft one, at line 0. Since this\n@@ -8692,7 +8813,8 @@ verify_constructor_super ()\n       for (mdecl = TYPE_METHODS (class); mdecl; mdecl = TREE_CHAIN (mdecl))\n \t{\n \t  if (DECL_CONSTRUCTOR_P (mdecl)\n-\t      && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))) == end_params_node)\n+\t      && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))) \n+\t         == end_params_node)\n \t    return 0;\n \t}\n     }\n@@ -10027,7 +10149,7 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n   parse_error_context (cl, \"Can't find %s `%s(%s)' in class `%s'%s\",\n \t\t       (lc ? \"constructor\" : \"method\"),\n \t\t       (lc ? \n-\t\t\tIDENTIFIER_POINTER(DECL_NAME (TYPE_NAME (class))) :\n+\t\t\tIDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))) :\n \t\t\tIDENTIFIER_POINTER (name)),\n \t\t       IDENTIFIER_POINTER (signature),\n \t\t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))),"}, {"sha": "06426ba4a684540f8d58bc1ad8596e1d5e4c9f79", "filename": "gcc/java/parse.y", "status": "modified", "additions": 129, "deletions": 7, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77613be8b4729d32825609d5e95e055b236c53a/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77613be8b4729d32825609d5e95e055b236c53a/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=d77613be8b4729d32825609d5e95e055b236c53a", "patch": "@@ -4547,7 +4547,7 @@ java_get_real_method_name (method_decl)\n \n /* Track method being redefined inside the same class. As a side\n    effect, set DECL_NAME to an IDENTIFIER (prior entering this\n-   function it's a FWL, so we can track errors more accurately */\n+   function it's a FWL, so we can track errors more accurately.)  */\n \n static int\n check_method_redefinition (class, method)\n@@ -4583,9 +4583,126 @@ check_method_redefinition (class, method)\n   return 0;\n }\n \n-/* Check all the methods of CLASS. Methods are first completed then\n-   checked according to regular method existance rules.\n-   If no constructor were encountered, then build its declaration. */\n+static void\n+check_abstract_method_definitions (do_interface, class_decl, type)\n+     int do_interface;\n+     tree class_decl, type;\n+{\n+  tree class = TREE_TYPE (class_decl);\n+  tree method, end_type;\n+\n+  end_type = (do_interface ? object_type_node : type);\n+  for (method = TYPE_METHODS (type); method; method = TREE_CHAIN (method))\n+    {\n+      tree other_super, other_method, method_sig, method_name;\n+      int found = 0;\n+      \n+      if (!METHOD_ABSTRACT (method) || METHOD_FINAL (method))\n+\tcontinue;\n+      \n+      /* Now verify that somewhere in between TYPE and CLASS,\n+\t abstract method METHOD gets a non abstract definition\n+\t that is inherited by CLASS.  */\n+      \n+      method_sig = build_java_signature (TREE_TYPE (method));\n+      method_name = DECL_NAME (method);\n+      if (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION)\n+\tmethod_name = EXPR_WFL_NODE (method_name);\n+\n+      for (other_super = class; other_super != end_type; \n+\t   other_super = CLASSTYPE_SUPER (other_super))\n+\t{\n+\t  for (other_method = TYPE_METHODS (other_super); other_method;\n+\t       other_method = TREE_CHAIN (other_method))\n+\t    {\n+\t      tree s = build_java_signature (TREE_TYPE (other_method));\n+\t      tree other_name = DECL_NAME (other_method);\n+\n+\t      if (TREE_CODE (other_name) == EXPR_WITH_FILE_LOCATION)\n+\t\tother_name = EXPR_WFL_NODE (other_name);\n+\t      if (!IS_CLINIT (other_method)\n+\t\t  && !DECL_CONSTRUCTOR_P (other_method)\n+\t\t  && method_name == other_name && method_sig == s)\n+\t\t{\n+\t\t  found = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      \n+      /* Report that abstract METHOD didn't find an implementation\n+\t that CLASS can use. */\n+      if (!found)\n+\t{\n+\t  char *t = strdup (lang_printable_name \n+\t\t\t    (TREE_TYPE (TREE_TYPE (method)), 0));\n+\t  tree ccn = DECL_NAME (TYPE_NAME (DECL_CONTEXT (method)));\n+\t  tree saved_wfl = NULL_TREE;\n+\t  \n+\t  if (TREE_CODE (DECL_NAME (method)) == EXPR_WITH_FILE_LOCATION)\n+\t    {\n+\t      saved_wfl = DECL_NAME (method);\n+\t      DECL_NAME (method) = EXPR_WFL_NODE (DECL_NAME (method));\n+\t    }\n+\t  \n+\t  parse_error_context \n+\t    (lookup_cl (class_decl),\n+\t     \"Class `%s' doesn't define the abstract method `%s %s' from \"\n+\t     \"%s `%s'. This method must be defined or %s `%s' must be \"\n+\t     \"declared abstract\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n+\t     t, lang_printable_name (method, 0), \n+\t     (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))) ? \n+\t      \"interface\" : \"class\"),\n+\t     IDENTIFIER_POINTER (ccn),\n+\t     (CLASS_INTERFACE (class_decl) ? \"interface\" : \"class\"),\n+\t     IDENTIFIER_POINTER (DECL_NAME (class_decl)));\n+\t  \n+\t  free (t);\n+\t  \n+\t  if (saved_wfl)\n+\t    DECL_NAME (method) = saved_wfl;\n+\t}\n+    }\n+}\n+\n+/* Check that CLASS_DECL somehoow implements all inherited abstract\n+   methods.  */\n+\n+static void\n+java_check_abstract_method_definitions (class_decl)\n+     tree class_decl;\n+{\n+  tree class = TREE_TYPE (class_decl);\n+  tree super, vector;\n+  int i;\n+\n+  if (CLASS_ABSTRACT (class_decl))\n+    return;\n+\n+  /* Check for inherited types */\n+  for (super = CLASSTYPE_SUPER (class); super != object_type_node; \n+       super = CLASSTYPE_SUPER (super))\n+    {\n+      if (!CLASS_ABSTRACT (TYPE_NAME (super)))\n+\tcontinue;\n+\n+      check_abstract_method_definitions (0, class_decl, super);\n+    }\n+\n+  /* Check for implemented interfaces. */\n+  vector = TYPE_BINFO_BASETYPES (class);\n+  for (i = 1; i < TREE_VEC_LENGTH (vector); i++)\n+    {\n+      super = BINFO_TYPE (TREE_VEC_ELT (vector, i));\n+      check_abstract_method_definitions (1, class_decl, super);\n+    }\n+}\n+\n+/* Check all the methods of CLASS_DECL. Methods are first completed\n+   then checked according to regular method existance rules.  If no\n+   constructor for CLASS_DECL were encountered, then build its\n+   declaration.  */\n \n static void\n java_check_regular_methods (class_decl)\n@@ -4761,14 +4878,18 @@ java_check_regular_methods (class_decl)\n   \n   /* Don't forget eventual pending found and saved_found_wfl. Take\n      into account that we might have exited because we saw an\n-     aritifical method as the last entry. */\n+     artificial method as the last entry. */\n \n   if (found && !DECL_ARTIFICIAL (found) && saved_found_wfl)\n     DECL_NAME (found) = saved_found_wfl;\n \n   if (!TYPE_NVIRTUALS (class))\n     TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n+  /* Search for inherited abstract method not yet implemented in this\n+     class.  */\n+  java_check_abstract_method_definitions (class_decl);\n+\n   if (!saw_constructor)\n     {\n       /* No constructor seen, we craft one, at line 0. Since this\n@@ -6105,7 +6226,8 @@ verify_constructor_super ()\n       for (mdecl = TYPE_METHODS (class); mdecl; mdecl = TREE_CHAIN (mdecl))\n \t{\n \t  if (DECL_CONSTRUCTOR_P (mdecl)\n-\t      && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))) == end_params_node)\n+\t      && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))) \n+\t         == end_params_node)\n \t    return 0;\n \t}\n     }\n@@ -7440,7 +7562,7 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n   parse_error_context (cl, \"Can't find %s `%s(%s)' in class `%s'%s\",\n \t\t       (lc ? \"constructor\" : \"method\"),\n \t\t       (lc ? \n-\t\t\tIDENTIFIER_POINTER(DECL_NAME (TYPE_NAME (class))) :\n+\t\t\tIDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))) :\n \t\t\tIDENTIFIER_POINTER (name)),\n \t\t       IDENTIFIER_POINTER (signature),\n \t\t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))),"}]}