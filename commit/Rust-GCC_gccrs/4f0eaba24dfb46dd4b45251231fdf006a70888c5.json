{"sha": "4f0eaba24dfb46dd4b45251231fdf006a70888c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYwZWFiYTI0ZGZiNDZkZDRiNDUyNTEyMzFmZGYwMDZhNzA4ODhjNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-09-09T19:06:46Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-09-09T19:06:46Z"}, "message": "compiler: traverse types of constant expressions\n    \n    We forgot to ever traverse types of constant expressions.  This rarely\n    makes a difference--evidently, since nobody noticed--but it does\n    matter when we inline constant expressions: we need to ensure that the\n    type is visible to the importing code.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/194317\n\nFrom-SVN: r275539", "tree": {"sha": "d0782d4967aee04144404ec19460fdcae467cf4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0782d4967aee04144404ec19460fdcae467cf4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f0eaba24dfb46dd4b45251231fdf006a70888c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0eaba24dfb46dd4b45251231fdf006a70888c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f0eaba24dfb46dd4b45251231fdf006a70888c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0eaba24dfb46dd4b45251231fdf006a70888c5/comments", "author": null, "committer": null, "parents": [{"sha": "0b0310e9a0e0d553bbe9f961c52e0851328aa8b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b0310e9a0e0d553bbe9f961c52e0851328aa8b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b0310e9a0e0d553bbe9f961c52e0851328aa8b0"}], "stats": {"total": 72, "additions": 71, "deletions": 1}, "files": [{"sha": "d966638c2ea7dc94e4543d67a7d026ffeb0ba970", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0eaba24dfb46dd4b45251231fdf006a70888c5/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0eaba24dfb46dd4b45251231fdf006a70888c5/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=4f0eaba24dfb46dd4b45251231fdf006a70888c5", "patch": "@@ -1,4 +1,4 @@\n-8f2b844acda70330f7c50b360f8c983d2676ecbb\n+28c9053b3d507bef7bd56cb01c6b22deea354cdd\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "cb09ec0bcbe42e32bc7cd843fc595830c4476045", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0eaba24dfb46dd4b45251231fdf006a70888c5/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0eaba24dfb46dd4b45251231fdf006a70888c5/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=4f0eaba24dfb46dd4b45251231fdf006a70888c5", "patch": "@@ -1812,6 +1812,9 @@ class Boolean_expression : public Expression\n   do_import(Import_expression*, Location);\n \n  protected:\n+  int\n+  do_traverse(Traverse*);\n+\n   bool\n   do_is_constant() const\n   { return true; }\n@@ -1864,6 +1867,17 @@ class Boolean_expression : public Expression\n   Type* type_;\n };\n \n+// Traverse a boolean expression.  We just need to traverse the type\n+// if there is one.\n+\n+int\n+Boolean_expression::do_traverse(Traverse* traverse)\n+{\n+  if (this->type_ != NULL)\n+    return Type::traverse(this->type_, traverse);\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Get the type.\n \n Type*\n@@ -1916,6 +1930,17 @@ Expression::make_boolean(bool val, Location location)\n \n // Class String_expression.\n \n+// Traverse a string expression.  We just need to traverse the type\n+// if there is one.\n+\n+int\n+String_expression::do_traverse(Traverse* traverse)\n+{\n+  if (this->type_ != NULL)\n+    return Type::traverse(this->type_, traverse);\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Get the type.\n \n Type*\n@@ -2290,6 +2315,9 @@ class Integer_expression : public Expression\n   dump_integer(Ast_dump_context* ast_dump_context, const mpz_t val);\n \n  protected:\n+  int\n+  do_traverse(Traverse*);\n+\n   bool\n   do_is_constant() const\n   { return true; }\n@@ -2353,6 +2381,17 @@ class Integer_expression : public Expression\n   bool is_character_constant_;\n };\n \n+// Traverse an integer expression.  We just need to traverse the type\n+// if there is one.\n+\n+int\n+Integer_expression::do_traverse(Traverse* traverse)\n+{\n+  if (this->type_ != NULL)\n+    return Type::traverse(this->type_, traverse);\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Return a numeric constant for this expression.  We have to mark\n // this as a character when appropriate.\n \n@@ -2714,6 +2753,9 @@ class Float_expression : public Expression\n   dump_float(Ast_dump_context* ast_dump_context, const mpfr_t val);\n \n  protected:\n+  int\n+  do_traverse(Traverse*);\n+\n   bool\n   do_is_constant() const\n   { return true; }\n@@ -2773,6 +2815,17 @@ class Float_expression : public Expression\n   Type* type_;\n };\n \n+// Traverse a float expression.  We just need to traverse the type if\n+// there is one.\n+\n+int\n+Float_expression::do_traverse(Traverse* traverse)\n+{\n+  if (this->type_ != NULL)\n+    return Type::traverse(this->type_, traverse);\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Return the current type.  If we haven't set the type yet, we return\n // an abstract float type.\n \n@@ -2932,6 +2985,9 @@ class Complex_expression : public Expression\n   dump_complex(Ast_dump_context* ast_dump_context, const mpc_t val);\n \n  protected:\n+  int\n+  do_traverse(Traverse*);\n+\n   bool\n   do_is_constant() const\n   { return true; }\n@@ -2995,6 +3051,17 @@ class Complex_expression : public Expression\n   Type* type_;\n };\n \n+// Traverse a complex expression.  We just need to traverse the type\n+// if there is one.\n+\n+int\n+Complex_expression::do_traverse(Traverse* traverse)\n+{\n+  if (this->type_ != NULL)\n+    return Type::traverse(this->type_, traverse);\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Return the current type.  If we haven't set the type yet, we return\n // an abstract complex type.\n "}, {"sha": "2e3d1e0ccf6b6750fc171d37bf89b9e0dee9e37d", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0eaba24dfb46dd4b45251231fdf006a70888c5/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0eaba24dfb46dd4b45251231fdf006a70888c5/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=4f0eaba24dfb46dd4b45251231fdf006a70888c5", "patch": "@@ -1670,6 +1670,9 @@ class String_expression : public Expression\n   do_import(Import_expression*, Location);\n \n  protected:\n+  int\n+  do_traverse(Traverse*);\n+\n   bool\n   do_is_constant() const\n   { return true; }"}]}