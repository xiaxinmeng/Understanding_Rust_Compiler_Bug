{"sha": "0abbfd21897f5c2f45d513d6d3212dae188e2bd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFiYmZkMjE4OTdmNWMyZjQ1ZDUxM2Q2ZDMyMTJkYWUxODhlMmJkNw==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2012-11-29T09:21:17Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2012-11-29T09:21:17Z"}, "message": "re PR target/55171 (incorrect virtual thunk on mingw)\n\n        PR target/55171\n        * i386.c (get_scratch_register_on_entry): Handle\n        thiscall-convention.\n        (split_stack_prologue_scratch_regno): Likewise.\n        (ix86_static_chain): Likewise.\n        (x86_output_mi_thunk): Likewise.\n\nFrom-SVN: r193926", "tree": {"sha": "011bfcbbda2c911cb07ba96485215e837b59b8aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/011bfcbbda2c911cb07ba96485215e837b59b8aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0abbfd21897f5c2f45d513d6d3212dae188e2bd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0abbfd21897f5c2f45d513d6d3212dae188e2bd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0abbfd21897f5c2f45d513d6d3212dae188e2bd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0abbfd21897f5c2f45d513d6d3212dae188e2bd7/comments", "author": null, "committer": null, "parents": [{"sha": "45d5889a070819486a619ca2a2664c186537cb40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d5889a070819486a619ca2a2664c186537cb40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d5889a070819486a619ca2a2664c186537cb40"}], "stats": {"total": 44, "additions": 39, "deletions": 5}, "files": [{"sha": "9494df0b0729712cb0c5fdaf1758bdeb826d520d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abbfd21897f5c2f45d513d6d3212dae188e2bd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abbfd21897f5c2f45d513d6d3212dae188e2bd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0abbfd21897f5c2f45d513d6d3212dae188e2bd7", "patch": "@@ -1,3 +1,12 @@\n+2012-11-29  Kai Tietz  <ktietz@redhat.com>\n+\n+\tPR target/55171\n+\t* i386.c (get_scratch_register_on_entry): Handle\n+\tthiscall-convention.\n+\t(split_stack_prologue_scratch_regno): Likewise.\n+\t(ix86_static_chain): Likewise.\n+\t(x86_output_mi_thunk): Likewise.\n+\n 2012-11-29  Marek Polacek  <polacek@redhat.com>\n \n \t* cprop.c (bypass_block): Improve debug message."}, {"sha": "812e6bf3cfd013104a6d87532605fe169a716c5d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0abbfd21897f5c2f45d513d6d3212dae188e2bd7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0abbfd21897f5c2f45d513d6d3212dae188e2bd7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0abbfd21897f5c2f45d513d6d3212dae188e2bd7", "patch": "@@ -9655,6 +9655,8 @@ get_scratch_register_on_entry (struct scratch_reg *sr)\n       tree decl = current_function_decl, fntype = TREE_TYPE (decl);\n       bool fastcall_p\n \t= lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (fntype)) != NULL_TREE;\n+      bool thiscall_p\n+\t= lookup_attribute (\"thiscall\", TYPE_ATTRIBUTES (fntype)) != NULL_TREE;\n       bool static_chain_p = DECL_STATIC_CHAIN (decl);\n       int regparm = ix86_function_regparm (fntype, decl);\n       int drap_regno\n@@ -9665,10 +9667,15 @@ get_scratch_register_on_entry (struct scratch_reg *sr)\n       if ((regparm < 1 || (fastcall_p && !static_chain_p))\n \t  && drap_regno != AX_REG)\n \tregno = AX_REG;\n-      else if (regparm < 2 && drap_regno != DX_REG)\n+      /* 'thiscall' sets regparm to 1, uses ecx for arguments and edx\n+\t  for the static chain register.  */\n+      else if (thiscall_p && !static_chain_p && drap_regno != AX_REG)\n+        regno = AX_REG;\n+      else if (regparm < 2 && !thiscall_p && drap_regno != DX_REG)\n \tregno = DX_REG;\n       /* ecx is the static chain register.  */\n-      else if (regparm < 3 && !fastcall_p && !static_chain_p\n+      else if (regparm < 3 && !fastcall_p && !thiscall_p\n+\t       && !static_chain_p\n \t       && drap_regno != CX_REG)\n \tregno = CX_REG;\n       else if (ix86_save_reg (BX_REG, true))\n@@ -11180,12 +11187,15 @@ split_stack_prologue_scratch_regno (void)\n     return R11_REG;\n   else\n     {\n-      bool is_fastcall;\n+      bool is_fastcall, is_thiscall;\n       int regparm;\n \n       is_fastcall = (lookup_attribute (\"fastcall\",\n \t\t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (cfun->decl)))\n \t\t     != NULL);\n+      is_thiscall = (lookup_attribute (\"thiscall\",\n+\t\t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (cfun->decl)))\n+\t\t     != NULL);\n       regparm = ix86_function_regparm (TREE_TYPE (cfun->decl), cfun->decl);\n \n       if (is_fastcall)\n@@ -11198,6 +11208,12 @@ split_stack_prologue_scratch_regno (void)\n \t    }\n \t  return AX_REG;\n \t}\n+      else if (is_thiscall)\n+        {\n+\t  if (!DECL_STATIC_CHAIN (cfun->decl))\n+\t    return DX_REG;\n+\t  return AX_REG;\n+\t}\n       else if (regparm < 3)\n \t{\n \t  if (!DECL_STATIC_CHAIN (cfun->decl))\n@@ -25134,14 +25150,21 @@ ix86_static_chain (const_tree fndecl, bool incoming_p)\n \n       fntype = TREE_TYPE (fndecl);\n       ccvt = ix86_get_callcvt (fntype);\n-      if ((ccvt & (IX86_CALLCVT_FASTCALL | IX86_CALLCVT_THISCALL)) != 0)\n+      if ((ccvt & IX86_CALLCVT_FASTCALL) != 0)\n \t{\n \t  /* Fastcall functions use ecx/edx for arguments, which leaves\n \t     us with EAX for the static chain.\n \t     Thiscall functions use ecx for arguments, which also\n \t     leaves us with EAX for the static chain.  */\n \t  regno = AX_REG;\n \t}\n+      else if ((ccvt & IX86_CALLCVT_THISCALL) != 0)\n+\t{\n+\t  /* Thiscall functions use ecx for arguments, which leaves\n+\t     us with EAX and EDX for the static chain.\n+\t     We are using for abi-compatibility EAX.  */\n+\t  regno = AX_REG;\n+\t}\n       else if (ix86_function_regparm (fntype, fndecl) == 3)\n \t{\n \t  /* For regparm 3, we have no free call-clobbered registers in\n@@ -34799,8 +34822,10 @@ x86_output_mi_thunk (FILE *file,\n   else\n     {\n       unsigned int ccvt = ix86_get_callcvt (TREE_TYPE (function));\n-      if ((ccvt & (IX86_CALLCVT_FASTCALL | IX86_CALLCVT_THISCALL)) != 0)\n+      if ((ccvt & IX86_CALLCVT_FASTCALL) != 0)\n \ttmp_regno = AX_REG;\n+      else if ((ccvt & IX86_CALLCVT_THISCALL) != 0)\n+\ttmp_regno = DX_REG;\n       else\n \ttmp_regno = CX_REG;\n     }"}]}