{"sha": "e66cf626c72d5872fc3181e81535afbff7263287", "node_id": "C_kwDOANBUbNoAKGU2NmNmNjI2YzcyZDU4NzJmYzMxODFlODE1MzVhZmJmZjcyNjMyODc", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-18T13:49:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-22T06:17:24Z"}, "message": "Improve uninit analysis\n\nThe following reduces the number of false positives in uninit analysis\nby providing fallback for situations the current analysis gives up\nand thus warns because it cannot prove initialization.\n\nThe first situation is when compute_control_dep_chain gives up walking\nbecause it runs into either param_uninit_control_dep_attempts or\nMAX_CHAIN_LEN.  If in the process it did not collect a single path\nfrom function entry to the interesting PHI edge then we'll give up\nand diagnose.  The following patch insteads provides a sparse path\nincluding only those predicates that always hold when the PHI edge\nis reached in that case.  That's cheap to produce but may in some\nodd cases prove less precise than what the code tries now (enumerating\nall possible paths from function entry to the PHI edge, but only\nuse the first N of those and only require unreachability of those N).\n\nThe second situation is when the set of predicates computed to hold\non the use stmt was formed from multiple paths (there's a similar\nenumeration of all paths and their predicates from the PHI def to the\nuse).  In that case use_preds.use_cannot_happen gives up because\nit doesn't know which of the predicates from which path from PHI to\nthe use it can use to prove unreachability of the PHI edge that has\nthe uninitialized def.  The patch for this case simply computes\nthe intersection of the predicates and uses that for further analysis,\nbut in a crude way since the predicate vectors are not sorted.\nFortunately the total size is limited - we have max MAX_NUM_CHAINS\nnumber of predicates each of length MAX_CHAIN_LEN so the brute\nforce intersection code should behave quite reasonable in practice.\n\n\t* gimple-predicate-analysis.cc (predicate::use_cannot_happen):\n\tIf the use is guarded with multiple predicate paths compute\n\tthe predicates intersection before going forward.  When\n\tcompute_control_dep_chain wasn't able to come up with at\n\tleast one path from function entry to the PHI edge compute\n\ta conservative sparse path instead.", "tree": {"sha": "8c548abd89ddf6462f2760048dd467becb97eaf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c548abd89ddf6462f2760048dd467becb97eaf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e66cf626c72d5872fc3181e81535afbff7263287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66cf626c72d5872fc3181e81535afbff7263287", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e66cf626c72d5872fc3181e81535afbff7263287", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66cf626c72d5872fc3181e81535afbff7263287/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac9230fbe9f52f3c23d1429a28e736428e6b7b0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9230fbe9f52f3c23d1429a28e736428e6b7b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac9230fbe9f52f3c23d1429a28e736428e6b7b0d"}], "stats": {"total": 64, "additions": 56, "deletions": 8}, "files": [{"sha": "820a9bde28ac9b54bb7313fc1ed3fe5667a3f3fd", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66cf626c72d5872fc3181e81535afbff7263287/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66cf626c72d5872fc3181e81535afbff7263287/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=e66cf626c72d5872fc3181e81535afbff7263287", "patch": "@@ -40,6 +40,7 @@\n #include \"builtins.h\"\n #include \"calls.h\"\n #include \"value-query.h\"\n+#include \"cfganal.h\"\n \n #include \"gimple-predicate-analysis.h\"\n \n@@ -1224,13 +1225,36 @@ predicate::use_cannot_happen (gphi *phi, unsigned opnds)\n \n   /* PHI_USE_GUARDS are OR'ed together.  If we have more than one\n      possible guard, there's no way of knowing which guard was true.\n-     Since we need to be absolutely sure that the uninitialized\n-     operands will be invalidated, bail.  */\n+     In that case compute the intersection of all use predicates\n+     and use that.  */\n   const pred_chain_union &phi_use_guards = m_preds;\n+  const pred_chain *use_guard = &phi_use_guards[0];\n+  pred_chain phi_use_guard_intersection = vNULL;\n   if (phi_use_guards.length () != 1)\n-    return false;\n-\n-  const pred_chain &use_guard = phi_use_guards[0];\n+    {\n+      phi_use_guard_intersection = use_guard->copy ();\n+      for (unsigned i = 1; i < phi_use_guards.length (); ++i)\n+\t{\n+\t  for (unsigned j = 0; j < phi_use_guard_intersection.length ();)\n+\t    {\n+\t      unsigned k;\n+\t      for (k = 0; k < phi_use_guards[i].length (); ++k)\n+\t\tif (pred_equal_p (phi_use_guards[i][k],\n+\t\t\t\t  phi_use_guard_intersection[j]))\n+\t\t  break;\n+\t      if (k == phi_use_guards[i].length ())\n+\t\tphi_use_guard_intersection.unordered_remove (j);\n+\t      else\n+\t\tj++;\n+\t    }\n+\t}\n+      if (phi_use_guard_intersection.is_empty ())\n+\t{\n+\t  phi_use_guard_intersection.release ();\n+\t  return false;\n+\t}\n+      use_guard = &phi_use_guard_intersection;\n+    }\n \n   /* Look for the control dependencies of all the interesting operands\n      and build guard predicates describing them.  */\n@@ -1250,7 +1274,27 @@ predicate::use_cannot_happen (gphi *phi, unsigned opnds)\n       if (!compute_control_dep_chain (ENTRY_BLOCK_PTR_FOR_FN (cfun),\n \t\t\t\t      e->src, dep_chains, &num_chains,\n \t\t\t\t      cur_chain, &num_calls))\n-\treturn false;\n+\t{\n+\t  gcc_assert (num_chains == 0);\n+\t  /* If compute_control_dep_chain bailed out due to limits\n+\t     build a partial sparse path using dominators.  Collect\n+\t     only edges whose predicates are always true when reaching E.  */\n+\t  cur_chain.truncate (0);\n+\t  cur_chain.quick_push (e);\n+\t  basic_block src = e->src;\n+\t  while (src->index != ENTRY_BLOCK\n+\t\t && cur_chain.length () <= MAX_CHAIN_LEN)\n+\t    {\n+\t      basic_block dest = src;\n+\t      src = get_immediate_dominator (CDI_DOMINATORS, src);\n+\t      edge pred_e;\n+\t      if (single_pred_p (dest)\n+\t\t  && (pred_e = find_edge (src, dest)))\n+\t\tcur_chain.quick_push (pred_e);\n+\t    }\n+\t  dep_chains[0] = cur_chain.copy ();\n+\t  num_chains++;\n+\t}\n \n       if (DEBUG_PREDICATE_ANALYZER && dump_file)\n \t{\n@@ -1272,10 +1316,14 @@ predicate::use_cannot_happen (gphi *phi, unsigned opnds)\n \n       /* Can the guard for this PHI argument be negated by the one\n \t guarding the PHI use?  */\n-      if (!can_be_invalidated_p (def_preds.chain (), use_guard))\n-\treturn false;\n+      if (!can_be_invalidated_p (def_preds.chain (), *use_guard))\n+\t{\n+\t  phi_use_guard_intersection.release ();\n+\t  return false;\n+\t}\n     }\n \n+  phi_use_guard_intersection.release ();\n   return true;\n }\n "}]}