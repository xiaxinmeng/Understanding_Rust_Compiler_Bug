{"sha": "0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQwZTRhMDNlOThjZjhjM2RiYjFkYzFhM2JhMTVkMmQ5YTZhNTkxMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-12-01T13:58:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-12-01T13:58:10Z"}, "message": "gimple.h (gimple_build_assign_stat): Remove prototype.\n\n\t* gimple.h (gimple_build_assign_stat): Remove prototype.\n\t(gimple_build_assign): Remove define.  Add overload prototypes\n\twith tree lhs and either a tree rhs, or enum tree_code and\n\t1, 2 or 3 tree operands.\n\t* gimple.c (gimple_build_assign_stat): Renamed to...\n\t(gimple_build_assign): ... this.  Add overloads with\n\tenum tree_code and 1, 2 or 3 tree operands.\n\t(gimple_build_assign_with_ops): Remove 1 and 2 operand overloads.\n\tRename the 3 operand overload to ...\n\t(gimple_build_assign_1): ... this.  Make it static inline.\n\t* tree-ssa-strlen.c (get_string_length): Use gimple_build_assign\n\tinstead of gimple_build_assign_with_ops, swap the order of first\n\ttwo arguments and adjust formatting where necessary.\n\t* tree-vect-slp.c (vect_get_constant_vectors,\n\tvect_create_mask_and_perm): Likewise.\n\t* tree-ssa-forwprop.c (simplify_rotate): Likewise.\n\t* asan.c (build_shadow_mem_access, maybe_create_ssa_name,\n\tmaybe_cast_to_ptrmode, asan_expand_check_ifn): Likewise.\n\t* tsan.c (instrument_builtin_call): Likewise.\n\t* tree-chkp.c (chkp_compute_bounds_for_assignment,\n\tchkp_generate_extern_var_bounds): Likewise.\n\t* tree-loop-distribution.c (generate_memset_builtin): Likewise.\n\t* tree-ssa-loop-im.c (rewrite_reciprocal): Likewise.\n\t* gimple-builder.c (build_assign, build_type_cast): Likewise.\n\t* tree-vect-loop-manip.c (vect_create_cond_for_align_checks): Likewise.\n\t* value-prof.c (gimple_divmod_fixed_value, gimple_mod_pow2,\n\tgimple_mod_subtract): Likewise.\n\t* gimple-match-head.c (maybe_push_res_to_seq): Likewise.\n\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern,\n\tvect_recog_sad_pattern, vect_handle_widen_op_by_const,\n\tvect_recog_widen_mult_pattern, vect_recog_pow_pattern,\n\tvect_recog_widen_sum_pattern, vect_operation_fits_smaller_type,\n\tvect_recog_over_widening_pattern, vect_recog_widen_shift_pattern,\n\tvect_recog_rotate_pattern, vect_recog_vector_vector_shift_pattern,\n\tvect_recog_divmod_pattern, vect_recog_mixed_size_cond_pattern,\n\tadjust_bool_pattern_cast, adjust_bool_pattern,\n\tvect_recog_bool_pattern): Likewise.\n\t* gimple-ssa-strength-reduction.c (create_add_on_incoming_edge,\n\tinsert_initializers, introduce_cast_before_cand,\n\treplace_one_candidate): Likewise.\n\t* tree-ssa-math-opts.c (insert_reciprocals, powi_as_mults_1,\n\tpowi_as_mults, build_and_insert_binop, build_and_insert_cast,\n\tpass_cse_sincos::execute, bswap_replace, convert_mult_to_fma):\n\tLikewise.\n\t* tree-tailcall.c (adjust_return_value_with_ops,\n\tupdate_accumulator_with_ops): Likewise.\n\t* tree-predcom.c (reassociate_to_the_same_stmt): Likewise.\n\t* tree-ssa-reassoc.c (build_and_add_sum,\n\toptimize_range_tests_to_bit_test, update_ops,\n\tmaybe_optimize_range_tests, rewrite_expr_tree, linearize_expr,\n\tnegate_value, repropagate_negates, attempt_builtin_powi,\n\treassociate_bb): Likewise.\n\t* tree-vect-loop.c (vect_is_simple_reduction_1,\n\tget_initial_def_for_induction, vect_create_epilog_for_reduction):\n\tLikewise.\n\t* ipa-split.c (split_function): Likewise.\n\t* tree-ssa-phiopt.c (conditional_replacement, minmax_replacement,\n\tabs_replacement, neg_replacement): Likewise.\n\t* tree-profile.c (gimple_gen_edge_profiler): Likewise.\n\t* tree-vrp.c (simplify_truth_ops_using_ranges,\n\tsimplify_float_conversion_using_ranges,\n\tsimplify_internal_call_using_ranges): Likewise.\n\t* gimple-fold.c (rewrite_to_defined_overflow, gimple_build): Likewise.\n\t* tree-vect-generic.c (expand_vector_divmod,\n\toptimize_vector_constructor): Likewise.\n\t* ubsan.c (ubsan_expand_null_ifn, ubsan_expand_objsize_ifn,\n\tinstrument_bool_enum_load): Likewise.\n\t* tree-ssa-loop-manip.c (create_iv): Likewise.\n\t* omp-low.c (lower_rec_input_clauses, expand_omp_for_generic,\n\texpand_omp_for_static_nochunk, expand_omp_for_static_chunk,\n\texpand_cilk_for, simd_clone_adjust): Likewise.\n\t* trans-mem.c (expand_transaction): Likewise.\n\t* tree-vect-data-refs.c (bump_vector_ptr, vect_permute_store_chain,\n\tvect_setup_realignment, vect_permute_load_chain,\n\tvect_shift_permute_load_chain): Likewise.\n\t* tree-vect-stmts.c (vect_init_vector, vectorizable_mask_load_store,\n\tvectorizable_simd_clone_call, vect_gen_widened_results_half,\n\tvect_create_vectorized_demotion_stmts, vectorizable_conversion,\n\tvectorizable_shift, vectorizable_operation, vectorizable_store,\n\tpermute_vec_elements, vectorizable_load): Likewise.\n\nFrom-SVN: r218216", "tree": {"sha": "c094c055e477dd57b664cc7132206465d1b8cf55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c094c055e477dd57b664cc7132206465d1b8cf55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b55fa54d4f8040c8f01acd3c725670000640538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b55fa54d4f8040c8f01acd3c725670000640538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b55fa54d4f8040c8f01acd3c725670000640538"}], "stats": {"total": 1108, "additions": 534, "deletions": 574}, "files": [{"sha": "ff430be99084dd6c703fd1d7aefc524c64ddc9bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -1,3 +1,86 @@\n+2014-12-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimple.h (gimple_build_assign_stat): Remove prototype.\n+\t(gimple_build_assign): Remove define.  Add overload prototypes\n+\twith tree lhs and either a tree rhs, or enum tree_code and\n+\t1, 2 or 3 tree operands.\n+\t* gimple.c (gimple_build_assign_stat): Renamed to...\n+\t(gimple_build_assign): ... this.  Add overloads with\n+\tenum tree_code and 1, 2 or 3 tree operands.\n+\t(gimple_build_assign_with_ops): Remove 1 and 2 operand overloads.\n+\tRename the 3 operand overload to ...\n+\t(gimple_build_assign_1): ... this.  Make it static inline.\n+\t* tree-ssa-strlen.c (get_string_length): Use gimple_build_assign\n+\tinstead of gimple_build_assign_with_ops, swap the order of first\n+\ttwo arguments and adjust formatting where necessary.\n+\t* tree-vect-slp.c (vect_get_constant_vectors,\n+\tvect_create_mask_and_perm): Likewise.\n+\t* tree-ssa-forwprop.c (simplify_rotate): Likewise.\n+\t* asan.c (build_shadow_mem_access, maybe_create_ssa_name,\n+\tmaybe_cast_to_ptrmode, asan_expand_check_ifn): Likewise.\n+\t* tsan.c (instrument_builtin_call): Likewise.\n+\t* tree-chkp.c (chkp_compute_bounds_for_assignment,\n+\tchkp_generate_extern_var_bounds): Likewise.\n+\t* tree-loop-distribution.c (generate_memset_builtin): Likewise.\n+\t* tree-ssa-loop-im.c (rewrite_reciprocal): Likewise.\n+\t* gimple-builder.c (build_assign, build_type_cast): Likewise.\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_align_checks): Likewise.\n+\t* value-prof.c (gimple_divmod_fixed_value, gimple_mod_pow2,\n+\tgimple_mod_subtract): Likewise.\n+\t* gimple-match-head.c (maybe_push_res_to_seq): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern,\n+\tvect_recog_sad_pattern, vect_handle_widen_op_by_const,\n+\tvect_recog_widen_mult_pattern, vect_recog_pow_pattern,\n+\tvect_recog_widen_sum_pattern, vect_operation_fits_smaller_type,\n+\tvect_recog_over_widening_pattern, vect_recog_widen_shift_pattern,\n+\tvect_recog_rotate_pattern, vect_recog_vector_vector_shift_pattern,\n+\tvect_recog_divmod_pattern, vect_recog_mixed_size_cond_pattern,\n+\tadjust_bool_pattern_cast, adjust_bool_pattern,\n+\tvect_recog_bool_pattern): Likewise.\n+\t* gimple-ssa-strength-reduction.c (create_add_on_incoming_edge,\n+\tinsert_initializers, introduce_cast_before_cand,\n+\treplace_one_candidate): Likewise.\n+\t* tree-ssa-math-opts.c (insert_reciprocals, powi_as_mults_1,\n+\tpowi_as_mults, build_and_insert_binop, build_and_insert_cast,\n+\tpass_cse_sincos::execute, bswap_replace, convert_mult_to_fma):\n+\tLikewise.\n+\t* tree-tailcall.c (adjust_return_value_with_ops,\n+\tupdate_accumulator_with_ops): Likewise.\n+\t* tree-predcom.c (reassociate_to_the_same_stmt): Likewise.\n+\t* tree-ssa-reassoc.c (build_and_add_sum,\n+\toptimize_range_tests_to_bit_test, update_ops,\n+\tmaybe_optimize_range_tests, rewrite_expr_tree, linearize_expr,\n+\tnegate_value, repropagate_negates, attempt_builtin_powi,\n+\treassociate_bb): Likewise.\n+\t* tree-vect-loop.c (vect_is_simple_reduction_1,\n+\tget_initial_def_for_induction, vect_create_epilog_for_reduction):\n+\tLikewise.\n+\t* ipa-split.c (split_function): Likewise.\n+\t* tree-ssa-phiopt.c (conditional_replacement, minmax_replacement,\n+\tabs_replacement, neg_replacement): Likewise.\n+\t* tree-profile.c (gimple_gen_edge_profiler): Likewise.\n+\t* tree-vrp.c (simplify_truth_ops_using_ranges,\n+\tsimplify_float_conversion_using_ranges,\n+\tsimplify_internal_call_using_ranges): Likewise.\n+\t* gimple-fold.c (rewrite_to_defined_overflow, gimple_build): Likewise.\n+\t* tree-vect-generic.c (expand_vector_divmod,\n+\toptimize_vector_constructor): Likewise.\n+\t* ubsan.c (ubsan_expand_null_ifn, ubsan_expand_objsize_ifn,\n+\tinstrument_bool_enum_load): Likewise.\n+\t* tree-ssa-loop-manip.c (create_iv): Likewise.\n+\t* omp-low.c (lower_rec_input_clauses, expand_omp_for_generic,\n+\texpand_omp_for_static_nochunk, expand_omp_for_static_chunk,\n+\texpand_cilk_for, simd_clone_adjust): Likewise.\n+\t* trans-mem.c (expand_transaction): Likewise.\n+\t* tree-vect-data-refs.c (bump_vector_ptr, vect_permute_store_chain,\n+\tvect_setup_realignment, vect_permute_load_chain,\n+\tvect_shift_permute_load_chain): Likewise.\n+\t* tree-vect-stmts.c (vect_init_vector, vectorizable_mask_load_store,\n+\tvectorizable_simd_clone_call, vect_gen_widened_results_half,\n+\tvect_create_vectorized_demotion_stmts, vectorizable_conversion,\n+\tvectorizable_shift, vectorizable_operation, vectorizable_store,\n+\tpermute_vec_elements, vectorizable_load): Likewise.\n+\n 2014-12-01  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/64111"}, {"sha": "a8987b78206f859d13be3d8accd8a267649a2af0", "filename": "gcc/asan.c", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -1585,25 +1585,25 @@ build_shadow_mem_access (gimple_stmt_iterator *gsi, location_t location,\n   gimple g;\n \n   t = build_int_cst (uintptr_type, ASAN_SHADOW_SHIFT);\n-  g = gimple_build_assign_with_ops (RSHIFT_EXPR, make_ssa_name (uintptr_type),\n-\t\t\t\t    base_addr, t);\n+  g = gimple_build_assign (make_ssa_name (uintptr_type), RSHIFT_EXPR,\n+\t\t\t   base_addr, t);\n   gimple_set_location (g, location);\n   gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \n   t = build_int_cst (uintptr_type, asan_shadow_offset ());\n-  g = gimple_build_assign_with_ops (PLUS_EXPR, make_ssa_name (uintptr_type),\n-\t\t\t\t    gimple_assign_lhs (g), t);\n+  g = gimple_build_assign (make_ssa_name (uintptr_type), PLUS_EXPR,\n+\t\t\t   gimple_assign_lhs (g), t);\n   gimple_set_location (g, location);\n   gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \n-  g = gimple_build_assign_with_ops (NOP_EXPR, make_ssa_name (shadow_ptr_type),\n-\t\t\t\t    gimple_assign_lhs (g));\n+  g = gimple_build_assign (make_ssa_name (shadow_ptr_type), NOP_EXPR,\n+\t\t\t   gimple_assign_lhs (g));\n   gimple_set_location (g, location);\n   gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \n   t = build2 (MEM_REF, shadow_type, gimple_assign_lhs (g),\n \t      build_int_cst (shadow_ptr_type, 0));\n-  g = gimple_build_assign_with_ops (MEM_REF, make_ssa_name (shadow_type), t);\n+  g = gimple_build_assign (make_ssa_name (shadow_type), MEM_REF, t);\n   gimple_set_location (g, location);\n   gsi_insert_after (gsi, g, GSI_NEW_STMT);\n   return gimple_assign_lhs (g);\n@@ -1618,9 +1618,8 @@ maybe_create_ssa_name (location_t loc, tree base, gimple_stmt_iterator *iter,\n {\n   if (TREE_CODE (base) == SSA_NAME)\n     return base;\n-  gimple g\n-    = gimple_build_assign_with_ops (TREE_CODE (base),\n-\t\t\t\t    make_ssa_name (TREE_TYPE (base)), base);\n+  gimple g = gimple_build_assign (make_ssa_name (TREE_TYPE (base)),\n+\t\t\t\t  TREE_CODE (base), base);\n   gimple_set_location (g, loc);\n   if (before_p)\n     gsi_insert_before (iter, g, GSI_SAME_STMT);\n@@ -1638,10 +1637,8 @@ maybe_cast_to_ptrmode (location_t loc, tree len, gimple_stmt_iterator *iter,\n {\n   if (ptrofftype_p (len))\n     return len;\n-  gimple g\n-    = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    make_ssa_name (pointer_sized_int_node),\n-\t\t\t\t    len);\n+  gimple g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t\t  NOP_EXPR, len);\n   gimple_set_location (g, loc);\n   if (before_p)\n     gsi_insert_before (iter, g, GSI_SAME_STMT);\n@@ -2542,10 +2539,8 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n   if (use_calls)\n     {\n       /* Instrument using callbacks.  */\n-      gimple g\n-\t= gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\tmake_ssa_name (pointer_sized_int_node),\n-\t\t\t\t\tbase);\n+      gimple g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t\t      NOP_EXPR, base);\n       gimple_set_location (g, loc);\n       gsi_insert_before (iter, g, GSI_SAME_STMT);\n       tree base_addr = gimple_assign_lhs (g);\n@@ -2557,9 +2552,8 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n       else\n \t{\n \t  gcc_assert (nargs == 2);\n-\t  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t    make_ssa_name (pointer_sized_int_node),\n-\t\t\t\t\t    len);\n+\t  g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t\t   NOP_EXPR, len);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (iter, g, GSI_SAME_STMT);\n \t  tree sz_arg = gimple_assign_lhs (g);\n@@ -2616,9 +2610,8 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n \t\t\t\t  &then_bb,\n \t\t\t\t  &else_bb);\n \n-  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    make_ssa_name (pointer_sized_int_node),\n-\t\t\t\t    base);\n+  g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t   NOP_EXPR, base);\n   gimple_set_location (g, loc);\n   gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n   tree base_addr = gimple_assign_lhs (g);\n@@ -2670,17 +2663,14 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n        check first and last byte.  */\n       if (size_in_bytes == -1)\n \t{\n-\t  g = gimple_build_assign_with_ops (MINUS_EXPR,\n-\t\t\t\t\t    make_ssa_name (pointer_sized_int_node),\n-\t\t\t\t\t    len,\n-\t\t\t\t\t    build_int_cst (pointer_sized_int_node, 1));\n+\t  g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t\t   MINUS_EXPR, len,\n+\t\t\t\t   build_int_cst (pointer_sized_int_node, 1));\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \t  tree last = gimple_assign_lhs (g);\n-\t  g = gimple_build_assign_with_ops (PLUS_EXPR,\n-\t\t\t\t\t    make_ssa_name (pointer_sized_int_node),\n-\t\t\t\t\t    base_addr,\n-\t\t\t\t\t    last);\n+\t  g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t\t   PLUS_EXPR, base_addr, last);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n \t  tree base_end_addr = gimple_assign_lhs (g);"}, {"sha": "8a0a9c2dab6c4c754bf26f720da0b3aaa39b163f", "filename": "gcc/gimple-builder.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-builder.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -66,7 +66,7 @@ build_assign (enum tree_code code, tree op1, int val, tree lhs)\n   tree op2 = build_int_cst (TREE_TYPE (op1), val);\n   if (lhs == NULL_TREE)\n     lhs = make_ssa_name (get_expr_type (code, op1));\n-  return gimple_build_assign_with_ops (code, lhs, op1, op2);\n+  return gimple_build_assign (lhs, code, op1, op2);\n }\n \n gassign *\n@@ -89,7 +89,7 @@ build_assign (enum tree_code code, tree op1, tree op2, tree lhs)\n {\n   if (lhs == NULL_TREE)\n     lhs = make_ssa_name (get_expr_type (code, op1));\n-  return gimple_build_assign_with_ops (code, lhs, op1, op2);\n+  return gimple_build_assign (lhs, code, op1, op2);\n }\n \n gassign *\n@@ -120,7 +120,7 @@ build_type_cast (tree to_type, tree op, tree lhs)\n {\n   if (lhs == NULL_TREE)\n     lhs = make_ssa_name (to_type);\n-  return gimple_build_assign_with_ops (NOP_EXPR, lhs, op);\n+  return gimple_build_assign (lhs, NOP_EXPR, op);\n }\n \n gassign *"}, {"sha": "4374c1d7ef11c62a342767dc95cc87170bce3bec", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -5642,8 +5642,7 @@ rewrite_to_defined_overflow (gimple stmt)\n   if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n     gimple_assign_set_rhs_code (stmt, PLUS_EXPR);\n   gimple_seq_add_stmt (&stmts, stmt);\n-  gimple cvt = gimple_build_assign_with_ops (NOP_EXPR, lhs,\n-\t\t\t\t\t     gimple_assign_lhs (stmt));\n+  gimple cvt = gimple_build_assign (lhs, NOP_EXPR, gimple_assign_lhs (stmt));\n   gimple_seq_add_stmt (&stmts, cvt);\n \n   return stmts;\n@@ -5672,10 +5671,9 @@ gimple_build (gimple_seq *seq, location_t loc,\n       if (code == REALPART_EXPR\n \t  || code == IMAGPART_EXPR\n \t  || code == VIEW_CONVERT_EXPR)\n-\tstmt = gimple_build_assign_with_ops (code, res,\n-\t\t\t\t\t     build1 (code, type, op0));\n+\tstmt = gimple_build_assign (res, code, build1 (code, type, op0));\n       else\n-\tstmt = gimple_build_assign_with_ops (code, res, op0);\n+\tstmt = gimple_build_assign (res, code, op0);\n       gimple_set_location (stmt, loc);\n       gimple_seq_add_stmt_without_update (seq, stmt);\n     }\n@@ -5700,7 +5698,7 @@ gimple_build (gimple_seq *seq, location_t loc,\n \tres = make_ssa_name (type);\n       else\n \tres = create_tmp_reg (type);\n-      gimple stmt = gimple_build_assign_with_ops (code, res, op0, op1);\n+      gimple stmt = gimple_build_assign (res, code, op0, op1);\n       gimple_set_location (stmt, loc);\n       gimple_seq_add_stmt_without_update (seq, stmt);\n     }\n@@ -5728,11 +5726,10 @@ gimple_build (gimple_seq *seq, location_t loc,\n \tres = create_tmp_reg (type);\n       gimple stmt;\n       if (code == BIT_FIELD_REF)\n-\tstmt = gimple_build_assign_with_ops (code, res,\n-\t\t\t\t\t     build3 (BIT_FIELD_REF, type,\n-\t\t\t\t\t\t     op0, op1, op2));\n+\tstmt = gimple_build_assign (res, code,\n+\t\t\t\t    build3 (code, type, op0, op1, op2));\n       else\n-\tstmt = gimple_build_assign_with_ops (code, res, op0, op1, op2);\n+\tstmt = gimple_build_assign (res, code, op0, op1, op2);\n       gimple_set_location (stmt, loc);\n       gimple_seq_add_stmt_without_update (seq, stmt);\n     }"}, {"sha": "d708132e5716891d8f3a42b0b1a4b2e59dbf15d3", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -332,8 +332,8 @@ maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n       if (!res)\n \tres = make_ssa_name (type);\n       maybe_build_generic_op (rcode, type, &ops[0], ops[1], ops[2]);\n-      gimple new_stmt = gimple_build_assign_with_ops (rcode, res,\n-\t\t\t\t\t\t      ops[0], ops[1], ops[2]);\n+      gimple new_stmt = gimple_build_assign (res, rcode,\n+\t\t\t\t\t     ops[0], ops[1], ops[2]);\n       gimple_seq_add_stmt_without_update (seq, new_stmt);\n       return res;\n     }"}, {"sha": "547327c404aa6e24960c725826f3a60c2658b9fa", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -2186,8 +2186,7 @@ create_add_on_incoming_edge (slsr_cand_t c, tree basis_name,\n \t}\n \n       bump_tree = wide_int_to_tree (basis_type, bump);\n-      new_stmt = gimple_build_assign_with_ops (code, lhs, basis_name,\n-\t\t\t\t\t       bump_tree);\n+      new_stmt = gimple_build_assign (lhs, code, basis_name, bump_tree);\n     }\n   else\n     {\n@@ -2199,15 +2198,14 @@ create_add_on_incoming_edge (slsr_cand_t c, tree basis_name,\n       if (incr_vec[i].initializer)\n \t{\n \t  enum tree_code code = negate_incr ? MINUS_EXPR : PLUS_EXPR;\n-\t  new_stmt = gimple_build_assign_with_ops (code, lhs, basis_name,\n-\t\t\t\t\t\t   incr_vec[i].initializer);\n+\t  new_stmt = gimple_build_assign (lhs, code, basis_name,\n+\t\t\t\t\t  incr_vec[i].initializer);\n \t}\n       else if (increment == 1)\n-\tnew_stmt = gimple_build_assign_with_ops (PLUS_EXPR, lhs, basis_name,\n-\t\t\t\t\t\t c->stride);\n+\tnew_stmt = gimple_build_assign (lhs, PLUS_EXPR, basis_name, c->stride);\n       else if (increment == -1)\n-\tnew_stmt = gimple_build_assign_with_ops (MINUS_EXPR, lhs, basis_name,\n-\t\t\t\t\t\t c->stride);\n+\tnew_stmt = gimple_build_assign (lhs, MINUS_EXPR, basis_name,\n+\t\t\t\t\tc->stride);\n       else\n \tgcc_unreachable ();\n     }\n@@ -3160,8 +3158,8 @@ insert_initializers (slsr_cand_t c)\n       /* Create the initializer and insert it in the latest possible\n \t dominating position.  */\n       incr_tree = wide_int_to_tree (stride_type, incr);\n-      init_stmt = gimple_build_assign_with_ops (MULT_EXPR, new_name,\n-\t\t\t\t\t\tc->stride, incr_tree);\n+      init_stmt = gimple_build_assign (new_name, MULT_EXPR,\n+\t\t\t\t       c->stride, incr_tree);\n       if (where)\n \t{\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (where->cand_stmt);\n@@ -3264,7 +3262,7 @@ introduce_cast_before_cand (slsr_cand_t c, tree to_type, tree from_expr)\n   gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n \n   cast_lhs = make_temp_ssa_name (to_type, NULL, \"slsr\");\n-  cast_stmt = gimple_build_assign_with_ops (NOP_EXPR, cast_lhs, from_expr);\n+  cast_stmt = gimple_build_assign (cast_lhs, NOP_EXPR, from_expr);\n   gimple_set_location (cast_stmt, gimple_location (c->cand_stmt));\n   gsi_insert_before (&gsi, cast_stmt, GSI_SAME_STMT);\n \n@@ -3433,8 +3431,7 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)\n       else\n \t{\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n-\t  gassign *cast_stmt = gimple_build_assign_with_ops (NOP_EXPR, lhs,\n-\t\t\t\t\t\t\t     basis_name);\n+\t  gassign *cast_stmt = gimple_build_assign (lhs, NOP_EXPR, basis_name);\n \t  gimple_set_location (cast_stmt, gimple_location (c->cand_stmt));\n \t  gsi_replace (&gsi, cast_stmt, false);\n \t  c->cand_stmt = cast_stmt;"}, {"sha": "c25fffab0a3ac39b8da5d0a40567cf8b2be5428b", "filename": "gcc/gimple.c", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -399,24 +399,22 @@ gimple_build_call_from_tree (tree t)\n    RHS of the assignment which can be unary or binary.  */\n \n gassign *\n-gimple_build_assign_stat (tree lhs, tree rhs MEM_STAT_DECL)\n+gimple_build_assign (tree lhs, tree rhs MEM_STAT_DECL)\n {\n   enum tree_code subcode;\n   tree op1, op2, op3;\n \n   extract_ops_from_tree_1 (rhs, &subcode, &op1, &op2, &op3);\n-  return gimple_build_assign_with_ops (subcode, lhs, op1, op2, op3\n-\t\t\t\t       PASS_MEM_STAT);\n+  return gimple_build_assign (lhs, subcode, op1, op2, op3 PASS_MEM_STAT);\n }\n \n \n /* Build a GIMPLE_ASSIGN statement with subcode SUBCODE and operands\n-   OP1 and OP2.  If OP2 is NULL then SUBCODE must be of class\n-   GIMPLE_UNARY_RHS or GIMPLE_SINGLE_RHS.  */\n+   OP1, OP2 and OP3.  */\n \n-gassign *\n-gimple_build_assign_with_ops (enum tree_code subcode, tree lhs, tree op1,\n-\t\t\t      tree op2, tree op3 MEM_STAT_DECL)\n+static inline gassign *\n+gimple_build_assign_1 (tree lhs, enum tree_code subcode, tree op1,\n+\t\t       tree op2, tree op3 MEM_STAT_DECL)\n {\n   unsigned num_ops;\n   gassign *p;\n@@ -445,20 +443,34 @@ gimple_build_assign_with_ops (enum tree_code subcode, tree lhs, tree op1,\n   return p;\n }\n \n+/* Build a GIMPLE_ASSIGN statement with subcode SUBCODE and operands\n+   OP1, OP2 and OP3.  */\n+\n+gassign *\n+gimple_build_assign (tree lhs, enum tree_code subcode, tree op1,\n+\t\t     tree op2, tree op3 MEM_STAT_DECL)\n+{\n+  return gimple_build_assign_1 (lhs, subcode, op1, op2, op3 PASS_MEM_STAT);\n+}\n+\n+/* Build a GIMPLE_ASSIGN statement with subcode SUBCODE and operands\n+   OP1 and OP2.  */\n+\n gassign *\n-gimple_build_assign_with_ops (enum tree_code subcode, tree lhs, tree op1,\n-\t\t\t      tree op2 MEM_STAT_DECL)\n+gimple_build_assign (tree lhs, enum tree_code subcode, tree op1,\n+\t\t     tree op2 MEM_STAT_DECL)\n {\n-  return gimple_build_assign_with_ops (subcode, lhs, op1, op2, NULL_TREE\n-\t\t\t\t       PASS_MEM_STAT);\n+  return gimple_build_assign_1 (lhs, subcode, op1, op2, NULL_TREE\n+\t\t\t\tPASS_MEM_STAT);\n }\n \n+/* Build a GIMPLE_ASSIGN statement with subcode SUBCODE and operand OP1.  */\n+\n gassign *\n-gimple_build_assign_with_ops (enum tree_code subcode, tree lhs, tree op1\n-\t\t\t      MEM_STAT_DECL)\n+gimple_build_assign (tree lhs, enum tree_code subcode, tree op1 MEM_STAT_DECL)\n {\n-  return gimple_build_assign_with_ops (subcode, lhs, op1, NULL_TREE, NULL_TREE\n-\t\t\t\t       PASS_MEM_STAT);\n+  return gimple_build_assign_1 (lhs, subcode, op1, NULL_TREE, NULL_TREE\n+\t\t\t\tPASS_MEM_STAT);\n }\n \n "}, {"sha": "04403f1d2bda52af556bef98ee514d84653e8e4d", "filename": "gcc/gimple.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -1296,14 +1296,12 @@ gcall *gimple_build_call_valist (tree, unsigned, va_list);\n gcall *gimple_build_call_internal (enum internal_fn, unsigned, ...);\n gcall *gimple_build_call_internal_vec (enum internal_fn, vec<tree> );\n gcall *gimple_build_call_from_tree (tree);\n-gassign *gimple_build_assign_stat (tree, tree MEM_STAT_DECL);\n-#define gimple_build_assign(l,r) gimple_build_assign_stat (l, r MEM_STAT_INFO)\n-gassign *gimple_build_assign_with_ops (enum tree_code, tree,\n-\t\t\t\t       tree, tree, tree CXX_MEM_STAT_INFO);\n-gassign *gimple_build_assign_with_ops (enum tree_code, tree,\n-\t\t\t\t       tree, tree CXX_MEM_STAT_INFO);\n-gassign *gimple_build_assign_with_ops (enum tree_code, tree,\n-\t\t\t\t       tree CXX_MEM_STAT_INFO);\n+gassign *gimple_build_assign (tree, tree CXX_MEM_STAT_DECL);\n+gassign *gimple_build_assign (tree, enum tree_code,\n+\t\t\t      tree, tree, tree CXX_MEM_STAT_INFO);\n+gassign *gimple_build_assign (tree, enum tree_code,\n+\t\t\t      tree, tree CXX_MEM_STAT_INFO);\n+gassign *gimple_build_assign (tree, enum tree_code, tree CXX_MEM_STAT_INFO);\n gcond *gimple_build_cond (enum tree_code, tree, tree, tree, tree);\n gcond *gimple_build_cond_from_tree (tree, tree, tree);\n void gimple_cond_set_condition_from_tree (gcond *, tree);"}, {"sha": "276de3c5dfb164a86c68c14cf3946aa6f2d3de6a", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -1586,8 +1586,7 @@ split_function (struct split_point *split_point)\n \t\t      gimple cpy;\n \t\t      tree tem = create_tmp_reg (restype);\n \t\t      tem = make_ssa_name (tem, call);\n-\t\t      cpy = gimple_build_assign_with_ops (NOP_EXPR, retval,\n-\t\t\t\t\t\t\t  tem);\n+\t\t      cpy = gimple_build_assign (retval, NOP_EXPR, tem);\n \t\t      gsi_insert_after (&gsi, cpy, GSI_NEW_STMT);\n \t\t      retval = tem;\n \t\t    }"}, {"sha": "a5cf9251973317ffa29efabd92a13c5ac7cebee1", "filename": "gcc/omp-low.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -3635,7 +3635,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t  enum tree_code code = PLUS_EXPR;\n \t\t\t  if (POINTER_TYPE_P (TREE_TYPE (new_var)))\n \t\t\t    code = POINTER_PLUS_EXPR;\n-\t\t\t  g = gimple_build_assign_with_ops (code, iv, iv, t);\n+\t\t\t  g = gimple_build_assign (iv, code, iv, t);\n \t\t\t  gsi_insert_before_without_update (&gsi, g,\n \t\t\t\t\t\t\t    GSI_SAME_STMT);\n \t\t\t  break;\n@@ -3845,8 +3845,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n       OMP_CLAUSE__SIMDUID__DECL (c) = uid;\n       OMP_CLAUSE_CHAIN (c) = gimple_omp_for_clauses (ctx->stmt);\n       gimple_omp_for_set_clauses (ctx->stmt, c);\n-      g = gimple_build_assign_with_ops (INTEGER_CST, lane,\n-\t\t\t\t\tbuild_int_cst (unsigned_type_node, 0));\n+      g = gimple_build_assign (lane, INTEGER_CST,\n+\t\t\t       build_int_cst (unsigned_type_node, 0));\n       gimple_seq_add_stmt (ilist, g);\n       for (int i = 0; i < 2; i++)\n \tif (llist[i])\n@@ -3857,7 +3857,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t    gimple_seq *seq = i == 0 ? ilist : dlist;\n \t    gimple_seq_add_stmt (seq, g);\n \t    tree t = build_int_cst (unsigned_type_node, 0);\n-\t    g = gimple_build_assign_with_ops (INTEGER_CST, idx, t);\n+\t    g = gimple_build_assign (idx, INTEGER_CST, t);\n \t    gimple_seq_add_stmt (seq, g);\n \t    tree body = create_artificial_label (UNKNOWN_LOCATION);\n \t    tree header = create_artificial_label (UNKNOWN_LOCATION);\n@@ -3866,7 +3866,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t    gimple_seq_add_stmt (seq, gimple_build_label (body));\n \t    gimple_seq_add_seq (seq, llist[i]);\n \t    t = build_int_cst (unsigned_type_node, 1);\n-\t    g = gimple_build_assign_with_ops (PLUS_EXPR, idx, idx, t);\n+\t    g = gimple_build_assign (idx, PLUS_EXPR, idx, t);\n \t    gimple_seq_add_stmt (seq, g);\n \t    gimple_seq_add_stmt (seq, gimple_build_label (header));\n \t    g = gimple_build_cond (LT_EXPR, idx, vf, body, end);\n@@ -5856,7 +5856,7 @@ expand_omp_for_generic (struct omp_region *region,\n       if (useless_type_conversion_p (TREE_TYPE (fd->loop.v), TREE_TYPE (iend)))\n \tassign_stmt = gimple_build_assign (fd->loop.v, iend);\n       else\n-\tassign_stmt = gimple_build_assign_with_ops (NOP_EXPR, fd->loop.v, iend);\n+\tassign_stmt = gimple_build_assign (fd->loop.v, NOP_EXPR, iend);\n       gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n     }\n   if (fd->collapse > 1)\n@@ -6206,8 +6206,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   gsi_insert_before (&gsi, gimple_build_assign (tt, build_int_cst (itype, 0)),\n \t\t     GSI_SAME_STMT);\n   gassign *assign_stmt\n-    = gimple_build_assign_with_ops (PLUS_EXPR, q, q,\n-\t\t\t\t    build_int_cst (itype, 1));\n+    = gimple_build_assign (q, PLUS_EXPR, q, build_int_cst (itype, 1));\n   gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n   third_bb = split_block (second_bb, assign_stmt)->dest;\n@@ -6276,7 +6275,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       if (useless_type_conversion_p (TREE_TYPE (fd->loop.v), TREE_TYPE (e)))\n \tassign_stmt = gimple_build_assign (fd->loop.v, e);\n       else\n-\tassign_stmt = gimple_build_assign_with_ops (NOP_EXPR, fd->loop.v, e);\n+\tassign_stmt = gimple_build_assign (fd->loop.v, NOP_EXPR, e);\n       gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n     }\n   if (fd->collapse > 1)\n@@ -6666,7 +6665,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       if (useless_type_conversion_p (TREE_TYPE (fd->loop.v), TREE_TYPE (e)))\n \tassign_stmt = gimple_build_assign (fd->loop.v, e);\n       else\n-\tassign_stmt = gimple_build_assign_with_ops (NOP_EXPR, fd->loop.v, e);\n+\tassign_stmt = gimple_build_assign (fd->loop.v, NOP_EXPR, e);\n       gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n     }\n   if (fd->collapse > 1)\n@@ -6934,8 +6933,8 @@ expand_cilk_for (struct omp_region *region, struct omp_for_data *fd)\n       gsi = gsi_last_bb (cont_bb);\n       stmt = gsi_stmt (gsi);\n       gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n-      stmt = gimple_build_assign_with_ops (PLUS_EXPR, ind_var, ind_var,\n-\t\t\t\t\t   build_one_cst (type));\n+      stmt = gimple_build_assign (ind_var, PLUS_EXPR, ind_var,\n+\t\t\t\t  build_one_cst (type));\n \n       /* Replace GIMPLE_OMP_CONTINUE.  */\n       gsi_replace (&gsi, stmt, true);\n@@ -12121,9 +12120,8 @@ simd_clone_adjust (struct cgraph_node *node)\n   edge e = make_edge (incr_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n   e->probability = REG_BR_PROB_BASE;\n   gsi = gsi_last_bb (incr_bb);\n-  gimple g = gimple_build_assign_with_ops (PLUS_EXPR, iter2, iter1,\n-\t\t\t\t\t   build_int_cst (unsigned_type_node,\n-\t\t\t\t\t\t\t  1));\n+  gimple g = gimple_build_assign (iter2, PLUS_EXPR, iter1,\n+\t\t\t\t  build_int_cst (unsigned_type_node, 1));\n   gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n \n   /* Mostly annotate the loop for the vectorizer (the rest is done below).  */\n@@ -12239,8 +12237,7 @@ simd_clone_adjust (struct cgraph_node *node)\n \t    if (need_cvt)\n \t      {\n \t\tt = make_ssa_name (orig_arg);\n-\t\tg = gimple_build_assign_with_ops (NOP_EXPR, t,\n-\t\t\t\t\t\t  gimple_call_lhs (g));\n+\t\tg = gimple_build_assign (t, NOP_EXPR, gimple_call_lhs (g));\n \t\tgimple_seq_add_stmt_without_update (&seq, g);\n \t      }\n \t    gsi_insert_seq_on_edge_immediate\n@@ -12284,7 +12281,7 @@ simd_clone_adjust (struct cgraph_node *node)\n \t\t\t   ? TREE_TYPE (orig_arg) : sizetype;\n \t    tree addcst\n \t      = build_int_cst (addtype, node->simdclone->args[i].linear_step);\n-\t    g = gimple_build_assign_with_ops (code, iter2, iter1, addcst);\n+\t    g = gimple_build_assign (iter2, code, iter1, addcst);\n \t    gsi = gsi_last_bb (incr_bb);\n \t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n "}, {"sha": "a81bf87b1b4631cdf00a86da0f8291657ecb978e", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -2807,8 +2807,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n \n       tree t1 = create_tmp_reg (tm_state_type);\n       tree t2 = build_int_cst (tm_state_type, A_RESTORELIVEVARIABLES);\n-      gimple stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, t1,\n-\t\t\t\t\t\t  tm_state, t2);\n+      gimple stmt = gimple_build_assign (t1, BIT_AND_EXPR, tm_state, t2);\n       gimple_stmt_iterator gsi = gsi_last_bb (test_bb);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n@@ -2848,8 +2847,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n \n       tree t1 = create_tmp_reg (tm_state_type);\n       tree t2 = build_int_cst (tm_state_type, A_ABORTTRANSACTION);\n-      gimple stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, t1,\n-\t\t\t\t\t\t  tm_state, t2);\n+      gimple stmt = gimple_build_assign (t1, BIT_AND_EXPR, tm_state, t2);\n       gimple_stmt_iterator gsi = gsi_last_bb (test_bb);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n@@ -2891,8 +2889,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       tree t1 = create_tmp_reg (tm_state_type);\n       tree t2 = build_int_cst (tm_state_type, A_RUNUNINSTRUMENTEDCODE);\n \n-      gimple stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, t1,\n-\t\t\t\t\t\t  tm_state, t2);\n+      gimple stmt = gimple_build_assign (t1, BIT_AND_EXPR, tm_state, t2);\n       gimple_stmt_iterator gsi = gsi_last_bb (test_bb);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n "}, {"sha": "56bc3037d5fa588fba5d8e28496b93a93a102f45", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -2538,8 +2538,7 @@ chkp_compute_bounds_for_assignment (tree node, gimple assign)\n \t    rhs1 = unshare_expr (rhs1);\n \n \t    bounds = chkp_get_tmp_reg (assign);\n-\t    stmt = gimple_build_assign_with_ops (COND_EXPR, bounds,\n-\t\t\t\t\t\t  rhs1, bnd1, bnd2);\n+\t    stmt = gimple_build_assign (bounds, COND_EXPR, rhs1, bnd1, bnd2);\n \t    gsi_insert_after (&iter, stmt, GSI_SAME_STMT);\n \n \t    if (!chkp_valid_bounds (bnd1) && !chkp_valid_bounds (bnd2))\n@@ -2565,8 +2564,7 @@ chkp_compute_bounds_for_assignment (tree node, gimple assign)\n \t    tree cond = build2 (rhs_code == MAX_EXPR ? GT_EXPR : LT_EXPR,\n \t\t\t\tboolean_type_node, rhs1, rhs2);\n \t    bounds = chkp_get_tmp_reg (assign);\n-\t    stmt = gimple_build_assign_with_ops (COND_EXPR, bounds,\n-\t\t\t\t\t\t  cond, bnd1, bnd2);\n+\t    stmt = gimple_build_assign (bounds, COND_EXPR, cond, bnd1, bnd2);\n \n \t    gsi_insert_after (&iter, stmt, GSI_SAME_STMT);\n \n@@ -2842,9 +2840,9 @@ chkp_generate_extern_var_bounds (tree var)\n \t\t\t fold_convert (chkp_uintptr_type, lb));\n       max_size = chkp_force_gimple_call_op (max_size, &seq);\n \n-      cond = build2 (NE_EXPR, boolean_type_node, size_reloc, integer_zero_node);\n-      stmt = gimple_build_assign_with_ops (COND_EXPR, size,\n-\t\t\t\t\t   cond, size_reloc, max_size);\n+      cond = build2 (NE_EXPR, boolean_type_node,\n+\t\t     size_reloc, integer_zero_node);\n+      stmt = gimple_build_assign (size, COND_EXPR, cond, size_reloc, max_size);\n       gimple_seq_add_stmt (&seq, stmt);\n     }\n   else"}, {"sha": "f2d63d74f59479a2faca008739e15076990c641a", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -823,7 +823,7 @@ generate_memset_builtin (struct loop *loop, partition_t partition)\n   else if (!useless_type_conversion_p (integer_type_node, TREE_TYPE (val)))\n     {\n       tree tem = make_ssa_name (integer_type_node);\n-      gimple cstmt = gimple_build_assign_with_ops (NOP_EXPR, tem, val);\n+      gimple cstmt = gimple_build_assign (tem, NOP_EXPR, val);\n       gsi_insert_after (&gsi, cstmt, GSI_CONTINUE_LINKING);\n       val = tem;\n     }"}, {"sha": "3482bf096039eee27713170c18414fab901285b2", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -2192,18 +2192,17 @@ reassociate_to_the_same_stmt (tree name1, tree name2)\n      combine it with the rhs of S1.  */\n   var = create_tmp_reg (type, \"predreastmp\");\n   new_name = make_ssa_name (var);\n-  new_stmt = gimple_build_assign_with_ops (code, new_name, name1, name2);\n+  new_stmt = gimple_build_assign (new_name, code, name1, name2);\n \n   var = create_tmp_reg (type, \"predreastmp\");\n   tmp_name = make_ssa_name (var);\n \n   /* Rhs of S1 may now be either a binary expression with operation\n      CODE, or gimple_val (in case that stmt1 == s1 or stmt2 == s1,\n      so that name1 or name2 was removed from it).  */\n-  tmp_stmt = gimple_build_assign_with_ops (gimple_assign_rhs_code (s1),\n-\t\t\t\t\t   tmp_name,\n-\t\t\t\t\t   gimple_assign_rhs1 (s1),\n-\t\t\t\t\t   gimple_assign_rhs2 (s1));\n+  tmp_stmt = gimple_build_assign (tmp_name, gimple_assign_rhs_code (s1),\n+\t\t\t\t  gimple_assign_rhs1 (s1),\n+\t\t\t\t  gimple_assign_rhs2 (s1));\n \n   bsi = gsi_for_stmt (s1);\n   gimple_assign_set_rhs_with_ops (&bsi, code, new_name, tmp_name);"}, {"sha": "dd38af797bff34a91e02f0aef8927d93bd4f0a52", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -315,8 +315,8 @@ gimple_gen_edge_profiler (int edgeno, edge e)\n   stmt1 = gimple_build_assign (gcov_type_tmp_var, ref);\n   gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,\n \t\t\t\t\t  NULL, \"PROF_edge_counter\");\n-  stmt2 = gimple_build_assign_with_ops (PLUS_EXPR, gcov_type_tmp_var,\n-\t\t\t\t\tgimple_assign_lhs (stmt1), one);\n+  stmt2 = gimple_build_assign (gcov_type_tmp_var, PLUS_EXPR,\n+\t\t\t       gimple_assign_lhs (stmt1), one);\n   stmt3 = gimple_build_assign (unshare_expr (ref), gimple_assign_lhs (stmt2));\n   gsi_insert_on_edge (e, stmt1);\n   gsi_insert_on_edge (e, stmt2);"}, {"sha": "6c14e135f5ead689e2dfc433f9720bf3acf7258e", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -1722,23 +1722,21 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n   if (!useless_type_conversion_p (TREE_TYPE (def_arg2[0]),\n \t\t\t\t  TREE_TYPE (rotcnt)))\n     {\n-      g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\tmake_ssa_name (TREE_TYPE (def_arg2[0])),\n-\t\t\t\t\trotcnt);\n+      g = gimple_build_assign (make_ssa_name (TREE_TYPE (def_arg2[0])),\n+\t\t\t       NOP_EXPR, rotcnt);\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);\n       rotcnt = gimple_assign_lhs (g);\n     }\n   lhs = gimple_assign_lhs (stmt);\n   if (!useless_type_conversion_p (rtype, TREE_TYPE (def_arg1[0])))\n     lhs = make_ssa_name (TREE_TYPE (def_arg1[0]));\n-  g = gimple_build_assign_with_ops (((def_code[0] == LSHIFT_EXPR) ^ swapped_p)\n-\t\t\t\t    ? LROTATE_EXPR : RROTATE_EXPR,\n-\t\t\t\t    lhs, def_arg1[0], rotcnt);\n+  g = gimple_build_assign (lhs,\n+\t\t\t   ((def_code[0] == LSHIFT_EXPR) ^ swapped_p)\n+\t\t\t   ? LROTATE_EXPR : RROTATE_EXPR, def_arg1[0], rotcnt);\n   if (!useless_type_conversion_p (rtype, TREE_TYPE (def_arg1[0])))\n     {\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);\n-      g = gimple_build_assign_with_ops (NOP_EXPR, gimple_assign_lhs (stmt),\n-\t\t\t\t\tlhs);\n+      g = gimple_build_assign (gimple_assign_lhs (stmt), NOP_EXPR, lhs);\n     }\n   gsi_replace (gsi, g, false);\n   return true;"}, {"sha": "2c676e379407f9e5ab67f330090cf8de891442f8", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -898,11 +898,10 @@ rewrite_reciprocal (gimple_stmt_iterator *bsi)\n   real_one = build_one_cst (type);\n \n   name = make_temp_ssa_name (type, NULL, \"reciptmp\");\n-  stmt1 = gimple_build_assign_with_ops (RDIV_EXPR, name, real_one,\n-\t\t\t\t\tgimple_assign_rhs2 (stmt));\n-\n-  stmt2 = gimple_build_assign_with_ops (MULT_EXPR, lhs, name,\n-\t\t\t\t\tgimple_assign_rhs1 (stmt));\n+  stmt1 = gimple_build_assign (name, RDIV_EXPR, real_one,\n+\t\t\t       gimple_assign_rhs2 (stmt));\n+  stmt2 = gimple_build_assign (lhs, MULT_EXPR, name,\n+\t\t\t       gimple_assign_rhs1 (stmt));\n \n   /* Replace division stmt with reciprocal and multiply stmts.\n      The multiply stmt is not invariant, so update iterator\n@@ -1215,9 +1214,8 @@ move_computations_dom_walker::before_dom_children (basic_block bb)\n       if (gimple_phi_num_args (stmt) == 1)\n \t{\n \t  tree arg = PHI_ARG_DEF (stmt, 0);\n-\t  new_stmt = gimple_build_assign_with_ops (TREE_CODE (arg),\n-\t\t\t\t\t\t   gimple_phi_result (stmt),\n-\t\t\t\t\t\t   arg);\n+\t  new_stmt = gimple_build_assign (gimple_phi_result (stmt),\n+\t\t\t\t\t  TREE_CODE (arg), arg);\n \t}\n       else\n \t{\n@@ -1230,9 +1228,8 @@ move_computations_dom_walker::before_dom_children (basic_block bb)\n \t  gcc_assert (arg0 && arg1);\n \t  t = build2 (gimple_cond_code (cond), boolean_type_node,\n \t\t      gimple_cond_lhs (cond), gimple_cond_rhs (cond));\n-\t  new_stmt = gimple_build_assign_with_ops (COND_EXPR,\n-\t\t\t\t\t\t   gimple_phi_result (stmt),\n-\t\t\t\t\t\t   t, arg0, arg1);\n+\t  new_stmt = gimple_build_assign (gimple_phi_result (stmt),\n+\t\t\t\t\t  COND_EXPR, t, arg0, arg1);\n \t  todo_ |= TODO_cleanup_cfg;\n \t}\n       gsi_insert_on_edge (loop_preheader_edge (level), new_stmt);"}, {"sha": "124b67adc3604891a4c747ab2c6c601e8a34e160", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -145,7 +145,7 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n   if (stmts)\n     gsi_insert_seq_on_edge_immediate (pe, stmts);\n \n-  stmt = gimple_build_assign_with_ops (incr_op, va, vb, step);\n+  stmt = gimple_build_assign (va, incr_op, vb, step);\n   if (after)\n     gsi_insert_after (incr_pos, stmt, GSI_NEW_STMT);\n   else"}, {"sha": "4b95ee48377adfb1fe4916483eb4ed2f12d4a79f", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -378,8 +378,8 @@ insert_reciprocals (gimple_stmt_iterator *def_gsi, struct occurrence *occ,\n       /* Make a variable with the replacement and substitute it.  */\n       type = TREE_TYPE (def);\n       recip_def = create_tmp_reg (type, \"reciptmp\");\n-      new_stmt = gimple_build_assign_with_ops (RDIV_EXPR, recip_def,\n-\t\t\t\t\t       build_one_cst (type), def);\n+      new_stmt = gimple_build_assign (recip_def, RDIV_EXPR,\n+\t\t\t\t      build_one_cst (type), def);\n \n       if (occ->bb_has_division)\n         {\n@@ -1009,7 +1009,7 @@ powi_as_mults_1 (gimple_stmt_iterator *gsi, location_t loc, tree type,\n       op1 = op0;\n     }\n \n-  mult_stmt = gimple_build_assign_with_ops (MULT_EXPR, ssa_target, op0, op1);\n+  mult_stmt = gimple_build_assign (ssa_target, MULT_EXPR, op0, op1);\n   gimple_set_location (mult_stmt, loc);\n   gsi_insert_before (gsi, mult_stmt, GSI_SAME_STMT);\n \n@@ -1039,9 +1039,8 @@ powi_as_mults (gimple_stmt_iterator *gsi, location_t loc,\n \n   /* If the original exponent was negative, reciprocate the result.  */\n   target = make_temp_ssa_name (type, NULL, \"powmult\");\n-  div_stmt = gimple_build_assign_with_ops (RDIV_EXPR, target, \n-\t\t\t\t\t   build_real (type, dconst1),\n-\t\t\t\t\t   result);\n+  div_stmt = gimple_build_assign (target, RDIV_EXPR,\n+\t\t\t\t  build_real (type, dconst1), result);\n   gimple_set_location (div_stmt, loc);\n   gsi_insert_before (gsi, div_stmt, GSI_SAME_STMT);\n \n@@ -1100,7 +1099,7 @@ build_and_insert_binop (gimple_stmt_iterator *gsi, location_t loc,\n \t\t\ttree arg0, tree arg1)\n {\n   tree result = make_temp_ssa_name (TREE_TYPE (arg0), NULL, name);\n-  gassign *stmt = gimple_build_assign_with_ops (code, result, arg0, arg1);\n+  gassign *stmt = gimple_build_assign (result, code, arg0, arg1);\n   gimple_set_location (stmt, loc);\n   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n   return result;\n@@ -1130,7 +1129,7 @@ build_and_insert_cast (gimple_stmt_iterator *gsi, location_t loc,\n \t\t       tree type, tree val)\n {\n   tree result = make_ssa_name (type);\n-  gassign *stmt = gimple_build_assign_with_ops (NOP_EXPR, result, val);\n+  gassign *stmt = gimple_build_assign (result, NOP_EXPR, val);\n   gimple_set_location (stmt, loc);\n   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n   return result;\n@@ -1533,17 +1532,14 @@ pass_cse_sincos::execute (function *fun)\n \t\t      minus_one = build_real (t0, dconstm1);\n \n \t\t      cond = make_temp_ssa_name (t1, NULL, \"powi_cond\");\n-\t\t      stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, cond,\n-\t\t\t\t\t\t\t   arg1,\n-\t\t\t\t\t\t\t   build_int_cst (t1,\n-\t\t\t\t\t\t\t\t\t  1));\n+\t\t      stmt = gimple_build_assign (cond, BIT_AND_EXPR,\n+\t\t\t\t\t\t  arg1, build_int_cst (t1, 1));\n \t\t      gimple_set_location (stmt, loc);\n \t\t      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n \n \t\t      result = make_temp_ssa_name (t0, NULL, \"powi\");\n-\t\t      stmt = gimple_build_assign_with_ops (COND_EXPR, result,\n-\t\t\t\t\t\t\t   cond,\n-\t\t\t\t\t\t\t   minus_one, one);\n+\t\t      stmt = gimple_build_assign (result, COND_EXPR, cond,\n+\t\t\t\t\t\t  minus_one, one);\n \t\t      gimple_set_location (stmt, loc);\n \t\t      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n \t\t    }\n@@ -2318,7 +2314,7 @@ bswap_replace (gimple cur_stmt, gimple src_stmt, tree fndecl, tree bswap_type,\n \t{\n \t  gimple convert_stmt;\n \t  tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapsrc\");\n-\t  convert_stmt = gimple_build_assign_with_ops (NOP_EXPR, tmp, src);\n+\t  convert_stmt = gimple_build_assign (tmp, NOP_EXPR, src);\n \t  gsi_insert_before (&gsi, convert_stmt, GSI_SAME_STMT);\n \t}\n \n@@ -2332,7 +2328,7 @@ bswap_replace (gimple cur_stmt, gimple src_stmt, tree fndecl, tree bswap_type,\n     {\n       gimple convert_stmt;\n       tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapdst\");\n-      convert_stmt = gimple_build_assign_with_ops (NOP_EXPR, tgt, tmp);\n+      convert_stmt = gimple_build_assign (tgt, NOP_EXPR, tmp);\n       gsi_insert_after (&gsi, convert_stmt, GSI_SAME_STMT);\n     }\n \n@@ -3174,9 +3170,8 @@ convert_mult_to_fma (gimple mul_stmt, tree op1, tree op2)\n \t\t\t\t\t   true, NULL_TREE, true,\n \t\t\t\t\t   GSI_SAME_STMT);\n \n-      fma_stmt = gimple_build_assign_with_ops (FMA_EXPR,\n-\t\t\t\t\t       gimple_assign_lhs (use_stmt),\n-\t\t\t\t\t       mulop1, op2, addop);\n+      fma_stmt = gimple_build_assign (gimple_assign_lhs (use_stmt),\n+\t\t\t\t      FMA_EXPR, mulop1, op2, addop);\n       gsi_replace (&gsi, fma_stmt, true);\n       widen_mul_stats.fmas_inserted++;\n     }"}, {"sha": "5a3519d3b52d72c867f8fe2c0af182f6e3a869da", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -537,8 +537,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n       source_location locus_0, locus_1;\n \n       new_var2 = make_ssa_name (TREE_TYPE (result));\n-      new_stmt = gimple_build_assign_with_ops (CONVERT_EXPR, new_var2,\n-\t\t\t\t\t       new_var);\n+      new_stmt = gimple_build_assign (new_var2, CONVERT_EXPR, new_var);\n       gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n       new_var = new_var2;\n \n@@ -1151,7 +1150,7 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   /* Emit the statement to compute min/max.  */\n   result = duplicate_ssa_name (PHI_RESULT (phi), NULL);\n-  new_stmt = gimple_build_assign_with_ops (minmax, result, arg0, arg1);\n+  new_stmt = gimple_build_assign (result, minmax, arg0, arg1);\n   gsi = gsi_last_bb (cond_bb);\n   gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);\n \n@@ -1258,7 +1257,7 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n     lhs = result;\n \n   /* Build the modify expression with abs expression.  */\n-  new_stmt = gimple_build_assign_with_ops (ABS_EXPR, lhs, rhs);\n+  new_stmt = gimple_build_assign (lhs, ABS_EXPR, rhs);\n \n   gsi = gsi_last_bb (cond_bb);\n   gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);\n@@ -1268,7 +1267,7 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n       /* Get the right GSI.  We want to insert after the recently\n \t added ABS_EXPR statement (which we know is the first statement\n \t in the block.  */\n-      new_stmt = gimple_build_assign_with_ops (NEGATE_EXPR, result, lhs);\n+      new_stmt = gimple_build_assign (result, NEGATE_EXPR, lhs);\n \n       gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n     }\n@@ -1371,9 +1370,9 @@ neg_replacement (basic_block cond_bb, basic_block middle_bb,\n     }\n \n   tree cond_val = make_ssa_name (boolean_type_node);\n-  new_stmt = gimple_build_assign_with_ops (cond_code, cond_val,\n-\t\t\t\t\t   gimple_cond_lhs (cond),\n-\t\t\t\t\t   gimple_cond_rhs (cond));\n+  new_stmt = gimple_build_assign (cond_val, cond_code,\n+\t\t\t\t  gimple_cond_lhs (cond),\n+\t\t\t\t  gimple_cond_rhs (cond));\n   gsi = gsi_last_bb (cond_bb);\n   gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);\n \n@@ -1382,32 +1381,30 @@ neg_replacement (basic_block cond_bb, basic_block middle_bb,\n   if (invert)\n     {\n       tree tmp = make_ssa_name (boolean_type_node);\n-      new_stmt = gimple_build_assign_with_ops (BIT_XOR_EXPR, tmp,\n-\t\t\t\t\t       cond_val, boolean_true_node);\n+      new_stmt = gimple_build_assign (tmp, BIT_XOR_EXPR, cond_val,\n+\t\t\t\t      boolean_true_node);\n       gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n       cond_val = tmp;\n     }\n \n   /* Get the condition in the right type so that we can perform\n      logical and arithmetic operations on it.  */\n   tree cond_val_converted = make_ssa_name (TREE_TYPE (rhs));\n-  new_stmt = gimple_build_assign_with_ops (NOP_EXPR, cond_val_converted,\n-\t\t\t\t\t   cond_val);\n+  new_stmt = gimple_build_assign (cond_val_converted, NOP_EXPR, cond_val);\n   gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n \n   tree neg_cond_val_converted = make_ssa_name (TREE_TYPE (rhs));\n-  new_stmt = gimple_build_assign_with_ops (NEGATE_EXPR, neg_cond_val_converted,\n-\t\t\t\t\t   cond_val_converted);\n+  new_stmt = gimple_build_assign (neg_cond_val_converted, NEGATE_EXPR,\n+\t\t\t\t  cond_val_converted);\n   gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n \n   tree tmp = make_ssa_name (TREE_TYPE (rhs));\n-  new_stmt = gimple_build_assign_with_ops (BIT_XOR_EXPR, tmp,\n-\t\t\t\t\t   rhs, neg_cond_val_converted);\n+  new_stmt = gimple_build_assign (tmp, BIT_XOR_EXPR, rhs,\n+\t\t\t\t  neg_cond_val_converted);\n   gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n \n   tree new_lhs = make_ssa_name (TREE_TYPE (rhs));\n-  new_stmt = gimple_build_assign_with_ops (PLUS_EXPR, new_lhs,\n-\t\t\t\t\t   tmp, cond_val_converted);\n+  new_stmt = gimple_build_assign (new_lhs, PLUS_EXPR, tmp, cond_val_converted);\n   gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n \n   replace_phi_edge_with_variable (cond_bb, e1, phi, new_lhs);"}, {"sha": "68a67b65f53eeed8b8e061c4272cdd65ca1c98df", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -1342,7 +1342,7 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n \n   /* Create the addition statement.  */\n   op = make_ssa_name (type);\n-  sum = gimple_build_assign_with_ops (opcode, op, op1, op2);\n+  sum = gimple_build_assign (op, opcode, op1, op2);\n \n   /* Find an insertion place and insert.  */\n   if (TREE_CODE (op1) == SSA_NAME)\n@@ -2592,9 +2592,8 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n \t  gimple_seq_add_seq_without_update (&seq, seq2);\n \t  gcc_assert (TREE_CODE (exp) == SSA_NAME);\n \t  gimple_set_visited (SSA_NAME_DEF_STMT (exp), true);\n-\t  gimple g\n-\t    = gimple_build_assign_with_ops (BIT_IOR_EXPR,\n-\t\t\t\t\t    make_ssa_name (optype), tem, exp);\n+\t  gimple g = gimple_build_assign (make_ssa_name (optype),\n+\t\t\t\t\t  BIT_IOR_EXPR, tem, exp);\n \t  gimple_set_location (g, loc);\n \t  gimple_seq_add_stmt_without_update (&seq, g);\n \t  exp = gimple_assign_lhs (g);\n@@ -2999,8 +2998,8 @@ update_ops (tree var, enum tree_code code, vec<operand_entry_t> ops,\n     {\n       gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n       var = make_ssa_name (TREE_TYPE (var));\n-      gassign *g = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n-\t\t\t\t\t\t var, rhs[2], rhs[3]);\n+      gassign *g = gimple_build_assign (var, gimple_assign_rhs_code (stmt),\n+\t\t\t\t\trhs[2], rhs[3]);\n       gimple_set_uid (g, gimple_uid (stmt));\n       gimple_set_visited (g, true);\n       gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n@@ -3305,8 +3304,7 @@ maybe_optimize_range_tests (gimple stmt)\n \t\t\t  g = gimple_build_assign (new_lhs, new_op);\n \t\t\t}\n \t\t      else\n-\t\t\tg = gimple_build_assign_with_ops (rhs_code, new_lhs,\n-\t\t\t\t\t\t\t  new_op);\n+\t\t\tg = gimple_build_assign (new_lhs, rhs_code, new_op);\n \t\t      gimple_stmt_iterator gsi = gsi_for_stmt (cast_stmt);\n \t\t      gimple_set_uid (g, gimple_uid (cast_stmt));\n \t\t      gimple_set_visited (g, true);\n@@ -3519,8 +3517,8 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t      gimple insert_point = find_insert_point (stmt, oe1->op, oe2->op);\n \t      lhs = make_ssa_name (TREE_TYPE (lhs));\n \t      stmt\n-\t\t= gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n-\t\t\t\t\t\tlhs, oe1->op, oe2->op);\n+\t\t= gimple_build_assign (lhs, gimple_assign_rhs_code (stmt),\n+\t\t\t\t       oe1->op, oe2->op);\n \t      gimple_set_uid (stmt, uid);\n \t      gimple_set_visited (stmt, true);\n \t      if (insert_point == gsi_stmt (gsi))\n@@ -3583,8 +3581,8 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t  gimple insert_point = find_insert_point (stmt, new_rhs1, oe->op);\n \n \t  lhs = make_ssa_name (TREE_TYPE (lhs));\n-\t  stmt = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n-\t\t\t\t\t       lhs, new_rhs1, oe->op);\n+\t  stmt = gimple_build_assign (lhs, gimple_assign_rhs_code (stmt),\n+\t\t\t\t      new_rhs1, oe->op);\n \t  gimple_set_uid (stmt, uid);\n \t  gimple_set_visited (stmt, true);\n \t  if (insert_point == gsi_stmt (gsi))\n@@ -3800,10 +3798,10 @@ linearize_expr (gimple stmt)\n   gsi = gsi_for_stmt (stmt);\n \n   gimple_assign_set_rhs2 (stmt, gimple_assign_rhs1 (binrhs));\n-  binrhs = gimple_build_assign_with_ops (gimple_assign_rhs_code (binrhs),\n-\t\t\t\t\t make_ssa_name (TREE_TYPE (lhs)),\n-\t\t\t\t\t gimple_assign_lhs (binlhs),\n-\t\t\t\t\t gimple_assign_rhs2 (binrhs));\n+  binrhs = gimple_build_assign (make_ssa_name (TREE_TYPE (lhs)),\n+\t\t\t\tgimple_assign_rhs_code (binrhs),\n+\t\t\t\tgimple_assign_lhs (binlhs),\n+\t\t\t\tgimple_assign_rhs2 (binrhs));\n   gimple_assign_set_rhs1 (stmt, gimple_assign_lhs (binrhs));\n   gsi_insert_before (&gsi, binrhs, GSI_SAME_STMT);\n   gimple_set_uid (binrhs, gimple_uid (stmt));\n@@ -3891,7 +3889,7 @@ negate_value (tree tonegate, gimple_stmt_iterator *gsip)\n       gsi = gsi_for_stmt (negatedefstmt);\n       lhs = make_ssa_name (TREE_TYPE (lhs));\n       gimple_set_visited (negatedefstmt, true);\n-      g = gimple_build_assign_with_ops (PLUS_EXPR, lhs, rhs1, rhs2);\n+      g = gimple_build_assign (lhs, PLUS_EXPR, rhs1, rhs2);\n       gimple_set_uid (g, gimple_uid (negatedefstmt));\n       gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n       return lhs;\n@@ -4217,7 +4215,7 @@ repropagate_negates (void)\n \t      gimple_stmt_iterator gsi = gsi_for_stmt (feed);\n \t      gimple_stmt_iterator gsi2 = gsi_for_stmt (user);\n \t      tree x = make_ssa_name (TREE_TYPE (gimple_assign_lhs (feed)));\n-\t      gimple g = gimple_build_assign_with_ops (PLUS_EXPR, x, a, b);\n+\t      gimple g = gimple_build_assign (x, PLUS_EXPR, a, b);\n \t      gsi_insert_before (&gsi2, g, GSI_SAME_STMT);\n \t      gimple_assign_set_rhs_with_ops (&gsi2, NEGATE_EXPR, x);\n \t      user = gsi_stmt (gsi2);\n@@ -4570,9 +4568,8 @@ attempt_builtin_powi (gimple stmt, vec<operand_entry_t> *ops)\n \t\t  op2 = rf2->repr;\n \n \t\t  target_ssa = make_temp_ssa_name (type, NULL, \"reassocpow\");\n-\t\t  mul_stmt = gimple_build_assign_with_ops (MULT_EXPR,\n-\t\t\t\t\t\t\t   target_ssa,\n-\t\t\t\t\t\t\t   op1, op2);\n+\t\t  mul_stmt = gimple_build_assign (target_ssa, MULT_EXPR,\n+\t\t\t\t\t\t  op1, op2);\n \t\t  gimple_set_location (mul_stmt, gimple_location (stmt));\n \t\t  gsi_insert_before (&gsi, mul_stmt, GSI_SAME_STMT);\n \t\t  rf1->repr = target_ssa;\n@@ -4599,8 +4596,8 @@ attempt_builtin_powi (gimple stmt, vec<operand_entry_t> *ops)\n       if (result)\n \t{\n \t  tree new_result = make_temp_ssa_name (type, NULL, \"reassocpow\");\n-\t  mul_stmt = gimple_build_assign_with_ops (MULT_EXPR, new_result,\n-\t\t\t\t\t\t   result, iter_result);\n+\t  mul_stmt = gimple_build_assign (new_result, MULT_EXPR,\n+\t\t\t\t\t  result, iter_result);\n \t  gimple_set_location (mul_stmt, gimple_location (stmt));\n \t  gsi_insert_before (&gsi, mul_stmt, GSI_SAME_STMT);\n \t  gimple_set_visited (mul_stmt, true);\n@@ -4857,9 +4854,8 @@ reassociate_bb (basic_block bb)\n \t\t      update_stmt (lhs_stmt);\n \t\t      if (lhs != new_lhs)\n \t\t\ttarget_ssa = new_lhs;\n-\t\t      mul_stmt = gimple_build_assign_with_ops (MULT_EXPR, lhs,\n-\t\t\t\t\t\t\t       powi_result,\n-\t\t\t\t\t\t\t       target_ssa);\n+\t\t      mul_stmt = gimple_build_assign (lhs, MULT_EXPR,\n+\t\t\t\t\t\t      powi_result, target_ssa);\n \t\t      gimple_set_location (mul_stmt, gimple_location (stmt));\n \t\t      gsi_insert_after (&gsi, mul_stmt, GSI_NEW_STMT);\n \t\t    }"}, {"sha": "c2f3493367f4c3a5e22e9e1ab9d6bc37816ec4ff", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -465,11 +465,9 @@ get_string_length (strinfo si)\n               lhs = force_gimple_operand_gsi (&gsi, lhs, true, NULL_TREE,\n                                               true, GSI_SAME_STMT);\n             }\n-\t  lenstmt\n-\t    = gimple_build_assign_with_ops\n-\t        (POINTER_PLUS_EXPR,\n-\t\t make_ssa_name (TREE_TYPE (gimple_call_arg (stmt, 0))),\n-\t\t tem, lhs);\n+\t  lenstmt = gimple_build_assign\n+\t\t\t(make_ssa_name (TREE_TYPE (gimple_call_arg (stmt, 0))),\n+\t\t\t POINTER_PLUS_EXPR,tem, lhs);\n \t  gsi_insert_before (&gsi, lenstmt, GSI_SAME_STMT);\n \t  gimple_call_set_arg (stmt, 0, gimple_assign_lhs (lenstmt));\n \t  lhs = NULL_TREE;"}, {"sha": "8f5c773ecf2744c2da784abd27f4a9907ca1c983", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -665,7 +665,7 @@ adjust_return_value_with_ops (enum tree_code code, const char *label,\n     }\n   if (types_compatible_p (TREE_TYPE (acc), TREE_TYPE (op1))\n       && code != POINTER_PLUS_EXPR)\n-    stmt = gimple_build_assign_with_ops (code, result, acc, op1);\n+    stmt = gimple_build_assign (result, code, acc, op1);\n   else\n     {\n       tree tem;\n@@ -696,7 +696,7 @@ update_accumulator_with_ops (enum tree_code code, tree acc, tree op1,\n   gassign *stmt;\n   tree var = copy_ssa_name (acc);\n   if (types_compatible_p (TREE_TYPE (acc), TREE_TYPE (op1)))\n-    stmt = gimple_build_assign_with_ops (code, var, acc, op1);\n+    stmt = gimple_build_assign (var, code, acc, op1);\n   else\n     {\n       tree rhs = fold_convert (TREE_TYPE (acc),"}, {"sha": "f7b192f966ccf3629a52a2d077c0bd4c3b0279c5", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 46, "deletions": 57, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -4348,8 +4348,8 @@ bump_vector_ptr (tree dataref_ptr, gimple ptr_incr, gimple_stmt_iterator *gsi,\n     update = bump;\n \n   new_dataref_ptr = copy_ssa_name (dataref_ptr);\n-  incr_stmt = gimple_build_assign_with_ops (POINTER_PLUS_EXPR, new_dataref_ptr,\n-\t\t\t\t\t    dataref_ptr, update);\n+  incr_stmt = gimple_build_assign (new_dataref_ptr, POINTER_PLUS_EXPR,\n+\t\t\t\t   dataref_ptr, update);\n   vect_finish_stmt_generation (stmt, incr_stmt, gsi);\n \n   /* Copy the points-to information if it exists. */\n@@ -4640,9 +4640,8 @@ vect_permute_store_chain (vec<tree> dr_chain,\n \t\t\t\t  {j, nelt, *, j + 1, nelt + j + 1, *,\n \t\t\t\t   j + 2, nelt + j + 2, *, ...}>  */\n \t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle3_low\");\n-\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t    vect1, vect2,\n-\t\t\t\t\t\t    perm3_mask_low);\n+\t  perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR, vect1,\n+\t\t\t\t\t   vect2, perm3_mask_low);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \n \t  vect1 = data_ref;\n@@ -4652,9 +4651,8 @@ vect_permute_store_chain (vec<tree> dr_chain,\n \t\t\t\t  {0, 1, nelt + j, 3, 4, nelt + j + 1,\n \t\t\t\t   6, 7, nelt + j + 2, ...}>  */\n \t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle3_high\");\n-\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t    vect1, vect2,\n-\t\t\t\t\t\t    perm3_mask_high);\n+\t  perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR, vect1,\n+\t\t\t\t\t   vect2, perm3_mask_high);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t  (*result_chain)[j] = data_ref;\n \t}\n@@ -4686,9 +4684,8 @@ vect_permute_store_chain (vec<tree> dr_chain,\n \t\t   high = VEC_PERM_EXPR <vect1, vect2, {0, nelt, 1, nelt+1,\n \t\t\t\t\t\t\t...}>  */\n \t\thigh = make_temp_ssa_name (vectype, NULL, \"vect_inter_high\");\n-\t\tperm_stmt\n-\t\t  = gimple_build_assign_with_ops (VEC_PERM_EXPR, high,\n-\t\t\t\t\t\t  vect1, vect2, perm_mask_high);\n+\t\tperm_stmt = gimple_build_assign (high, VEC_PERM_EXPR, vect1,\n+\t\t\t\t\t\t vect2, perm_mask_high);\n \t\tvect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t\t(*result_chain)[2*j] = high;\n \n@@ -4697,9 +4694,8 @@ vect_permute_store_chain (vec<tree> dr_chain,\n \t\t\t\t\t{nelt/2, nelt*3/2, nelt/2+1, nelt*3/2+1,\n \t\t\t\t\t ...}>  */\n \t\tlow = make_temp_ssa_name (vectype, NULL, \"vect_inter_low\");\n-\t\tperm_stmt\n-\t\t  = gimple_build_assign_with_ops (VEC_PERM_EXPR, low,\n-\t\t\t\t\t\t  vect1, vect2, perm_mask_low);\n+\t\tperm_stmt = gimple_build_assign (low, VEC_PERM_EXPR, vect1,\n+\t\t\t\t\t\t vect2, perm_mask_low);\n \t\tvect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t\t(*result_chain)[2*j+1] = low;\n \t      }\n@@ -4880,8 +4876,8 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t      NULL_TREE, &init_addr, NULL, &inc,\n \t\t\t\t      true, &inv_p);\n       new_temp = copy_ssa_name (ptr);\n-      new_stmt = gimple_build_assign_with_ops\n-\t\t   (BIT_AND_EXPR, new_temp, ptr,\n+      new_stmt = gimple_build_assign\n+\t\t   (new_temp, BIT_AND_EXPR, ptr,\n \t\t    build_int_cst (TREE_TYPE (ptr),\n \t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n       new_bb = gsi_insert_on_edge_immediate (pe, new_stmt);\n@@ -5194,9 +5190,8 @@ vect_permute_load_chain (vec<tree> dr_chain,\n \t     low = VEC_PERM_EXPR <first_vect, second_vect2, {k, 3 + k, 6 + k,\n \t\t\t\t\t\t\t     ...}>  */\n \t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle3_low\");\n-\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t    first_vect, second_vect,\n-\t\t\t\t\t\t    perm3_mask_low);\n+\t  perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR, first_vect,\n+\t\t\t\t\t   second_vect, perm3_mask_low);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \n \t  /* Create interleaving stmt (high part of):\n@@ -5205,9 +5200,8 @@ vect_permute_load_chain (vec<tree> dr_chain,\n \t  first_vect = data_ref;\n \t  second_vect = dr_chain[2];\n \t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle3_high\");\n-\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t    first_vect, second_vect,\n-\t\t\t\t\t\t    perm3_mask_high);\n+\t  perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR, first_vect,\n+\t\t\t\t\t   second_vect, perm3_mask_high);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t  (*result_chain)[k] = data_ref;\n \t}\n@@ -5234,17 +5228,17 @@ vect_permute_load_chain (vec<tree> dr_chain,\n \n \t      /* data_ref = permute_even (first_data_ref, second_data_ref);  */\n \t      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_perm_even\");\n-\t      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t\tfirst_vect, second_vect,\n-\t\t\t\t\t\t\tperm_mask_even);\n+\t      perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR,\n+\t\t\t\t\t       first_vect, second_vect,\n+\t\t\t\t\t       perm_mask_even);\n \t      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t      (*result_chain)[j/2] = data_ref;\n \n \t      /* data_ref = permute_odd (first_data_ref, second_data_ref);  */\n \t      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_perm_odd\");\n-\t      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t\tfirst_vect, second_vect,\n-\t\t\t\t\t\t\tperm_mask_odd);\n+\t      perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR,\n+\t\t\t\t\t       first_vect, second_vect,\n+\t\t\t\t\t       perm_mask_odd);\n \t      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t      (*result_chain)[j/2+length/2] = data_ref;\n \t    }\n@@ -5431,30 +5425,28 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t      second_vect = dr_chain[j + 1];\n \n \t      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle2\");\n-\t      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t\tfirst_vect, first_vect,\n-\t\t\t\t\t\t\tperm2_mask1);\n+\t      perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR,\n+\t\t\t\t\t       first_vect, first_vect,\n+\t\t\t\t\t       perm2_mask1);\n \t      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t      vect[0] = data_ref;\n \n \t      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle2\");\n-\t      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t\tsecond_vect, second_vect,\n-\t\t\t\t\t\t\tperm2_mask2);\n+\t      perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR,\n+\t\t\t\t\t       second_vect, second_vect,\n+\t\t\t\t\t       perm2_mask2);\n \t      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t      vect[1] = data_ref;\n \n \t      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shift\");\n-\t      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t\tvect[0], vect[1],\n-\t\t\t\t\t\t\tshift1_mask);\n+\t      perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR,\n+\t\t\t\t\t       vect[0], vect[1], shift1_mask);\n \t      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t      (*result_chain)[j/2 + length/2] = data_ref;\n \n \t      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_select\");\n-\t      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t\tvect[0], vect[1],\n-\t\t\t\t\t\t\tselect_mask);\n+\t      perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR,\n+\t\t\t\t\t       vect[0], vect[1], select_mask);\n \t      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t      (*result_chain)[j/2] = data_ref;\n \t    }\n@@ -5544,48 +5536,45 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n       for (k = 0; k < 3; k++)\n \t{\n \t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle3\");\n-\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t    dr_chain[k], dr_chain[k],\n-\t\t\t\t\t\t    perm3_mask);\n+\t  perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR,\n+\t\t\t\t\t   dr_chain[k], dr_chain[k],\n+\t\t\t\t\t   perm3_mask);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t  vect[k] = data_ref;\n \t}\n \n       for (k = 0; k < 3; k++)\n \t{\n \t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shift1\");\n-\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t    vect[k % 3],\n-\t\t\t\t\t\t    vect[(k + 1) % 3],\n-\t\t\t\t\t\t    shift1_mask);\n+\t  perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR,\n+\t\t\t\t\t   vect[k % 3], vect[(k + 1) % 3],\n+\t\t\t\t\t   shift1_mask);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t  vect_shift[k] = data_ref;\n \t}\n \n       for (k = 0; k < 3; k++)\n \t{\n \t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shift2\");\n-\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\t    vect_shift[(4 - k) % 3],\n-\t\t\t\t\t\t    vect_shift[(3 - k) % 3],\n-\t\t\t\t\t\t    shift2_mask);\n+\t  perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR,\n+\t\t\t\t\t   vect_shift[(4 - k) % 3],\n+\t\t\t\t\t   vect_shift[(3 - k) % 3],\n+\t\t\t\t\t   shift2_mask);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t  vect[k] = data_ref;\n \t}\n \n       (*result_chain)[3 - (nelt % 3)] = vect[2];\n \n       data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shift3\");\n-      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\tvect[0], vect[0],\n-\t\t\t\t\t\tshift3_mask);\n+      perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR, vect[0],\n+\t\t\t\t       vect[0], shift3_mask);\n       vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n       (*result_chain)[nelt % 3] = data_ref;\n \n       data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shift4\");\n-      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t\tvect[1], vect[1],\n-\t\t\t\t\t\tshift4_mask);\n+      perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR, vect[1],\n+\t\t\t\t       vect[1], shift4_mask);\n       vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n       (*result_chain)[0] = data_ref;\n       return true;"}, {"sha": "a8a8ecde6dc7eb7f3e5f3863296d1dcf7f5a5398", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -640,8 +640,8 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t\t\t\t\t << shifts[i]) - 1);\n \t      cst = build_vector (type, vec);\n \t      addend = make_ssa_name (type);\n-\t      stmt = gimple_build_assign_with_ops (VEC_COND_EXPR, addend,\n-\t\t\t\t\t\t   cond, cst, zero);\n+\t      stmt = gimple_build_assign (addend, VEC_COND_EXPR, cond,\n+\t\t\t\t\t  cst, zero);\n \t      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n \t    }\n \t}\n@@ -1082,8 +1082,8 @@ optimize_vector_constructor (gimple_stmt_iterator *gsi)\n     CONSTRUCTOR_ELT (rhs, i)->value = base;\n   g = gimple_build_assign (make_ssa_name (type), rhs);\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n-  g = gimple_build_assign_with_ops (PLUS_EXPR, lhs, gimple_assign_lhs (g),\n-\t\t\t\t    build_vector (type, cst));\n+  g = gimple_build_assign (lhs, PLUS_EXPR, gimple_assign_lhs (g),\n+\t\t\t   build_vector (type, cst));\n   gsi_replace (gsi, g, false);\n }\n \f"}, {"sha": "a318a7ee044742fd268bca9da7204cbcd9607151", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -2157,8 +2157,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n \n       sprintf (tmp_name, \"addr2int%d\", i);\n       addr_tmp_name = make_temp_ssa_name (int_ptrsize_type, NULL, tmp_name);\n-      addr_stmt = gimple_build_assign_with_ops (NOP_EXPR, addr_tmp_name,\n-\t\t\t\t\t\taddr_base);\n+      addr_stmt = gimple_build_assign (addr_tmp_name, NOP_EXPR, addr_base);\n       gimple_seq_add_stmt (cond_expr_stmt_list, addr_stmt);\n \n       /* The addresses are OR together.  */\n@@ -2168,9 +2167,8 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n           /* create: or_tmp = or_tmp | addr_tmp */\n           sprintf (tmp_name, \"orptrs%d\", i);\n \t  new_or_tmp_name = make_temp_ssa_name (int_ptrsize_type, NULL, tmp_name);\n-\t  or_stmt = gimple_build_assign_with_ops (BIT_IOR_EXPR,\n-\t\t\t\t\t\t  new_or_tmp_name,\n-\t\t\t\t\t\t  or_tmp_name, addr_tmp_name);\n+\t  or_stmt = gimple_build_assign (new_or_tmp_name, BIT_IOR_EXPR,\n+\t\t\t\t\t or_tmp_name, addr_tmp_name);\n \t  gimple_seq_add_stmt (cond_expr_stmt_list, or_stmt);\n           or_tmp_name = new_or_tmp_name;\n         }\n@@ -2184,8 +2182,8 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n   /* create: and_tmp = or_tmp & mask  */\n   and_tmp_name = make_temp_ssa_name (int_ptrsize_type, NULL, \"andmask\");\n \n-  and_stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, and_tmp_name,\n-\t\t\t\t\t   or_tmp_name, mask_cst);\n+  and_stmt = gimple_build_assign (and_tmp_name, BIT_AND_EXPR,\n+\t\t\t\t  or_tmp_name, mask_cst);\n   gimple_seq_add_stmt (cond_expr_stmt_list, and_stmt);\n \n   /* Make and_tmp the left operand of the conditional test against zero."}, {"sha": "d1d45967c7088d07117adf6c8ec63bd9a1726a0d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -2503,8 +2503,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n     {\n       tree rhs = gimple_assign_rhs2 (def_stmt);\n       tree negrhs = make_ssa_name (TREE_TYPE (rhs));\n-      gimple negate_stmt = gimple_build_assign_with_ops (NEGATE_EXPR, negrhs,\n-\t\t\t\t\t\t\t rhs);\n+      gimple negate_stmt = gimple_build_assign (negrhs, NEGATE_EXPR, rhs);\n       gimple_stmt_iterator gsi = gsi_for_stmt (def_stmt);\n       set_vinfo_for_stmt (negate_stmt, new_stmt_vec_info (negate_stmt, \n \t\t\t\t\t\t\t  loop_info, NULL));\n@@ -3380,10 +3379,13 @@ get_initial_def_for_induction (gimple iv_phi)\n       /* If the initial value is not of proper type, convert it.  */\n       if (!useless_type_conversion_p (vectype, TREE_TYPE (vec_init)))\n \t{\n-\t  new_stmt = gimple_build_assign_with_ops\n-\t      (VIEW_CONVERT_EXPR,\n-\t       vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\"),\n-\t       build1 (VIEW_CONVERT_EXPR, vectype, vec_init));\n+\t  new_stmt\n+\t    = gimple_build_assign (vect_get_new_vect_var (vectype,\n+\t\t\t\t\t\t\t  vect_simple_var,\n+\t\t\t\t\t\t\t  \"vec_iv_\"),\n+\t\t\t\t   VIEW_CONVERT_EXPR,\n+\t\t\t\t   build1 (VIEW_CONVERT_EXPR, vectype,\n+\t\t\t\t\t   vec_init));\n \t  vec_init = make_ssa_name (gimple_assign_lhs (new_stmt), new_stmt);\n \t  gimple_assign_set_lhs (new_stmt, vec_init);\n \t  new_bb = gsi_insert_on_edge_immediate (loop_preheader_edge (iv_loop),\n@@ -3496,8 +3498,7 @@ get_initial_def_for_induction (gimple iv_phi)\n   induc_def = PHI_RESULT (induction_phi);\n \n   /* Create the iv update inside the loop  */\n-  new_stmt = gimple_build_assign_with_ops (PLUS_EXPR, vec_dest,\n-\t\t\t\t\t   induc_def, vec_step);\n+  new_stmt = gimple_build_assign (vec_dest, PLUS_EXPR, induc_def, vec_step);\n   vec_def = make_ssa_name (vec_dest, new_stmt);\n   gimple_assign_set_lhs (new_stmt, vec_def);\n   gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n@@ -3546,20 +3547,21 @@ get_initial_def_for_induction (gimple iv_phi)\n       for (i = 1; i < ncopies; i++)\n \t{\n \t  /* vec_i = vec_prev + vec_step  */\n-\t  new_stmt = gimple_build_assign_with_ops (PLUS_EXPR, vec_dest,\n-\t\t\t\t\t\t   vec_def, vec_step);\n+\t  new_stmt = gimple_build_assign (vec_dest, PLUS_EXPR,\n+\t\t\t\t\t  vec_def, vec_step);\n \t  vec_def = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_assign_set_lhs (new_stmt, vec_def);\n  \n \t  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n \t  if (!useless_type_conversion_p (resvectype, vectype))\n \t    {\n-\t      new_stmt = gimple_build_assign_with_ops\n-\t\t  (VIEW_CONVERT_EXPR,\n-\t\t   vect_get_new_vect_var (resvectype, vect_simple_var,\n-\t\t\t\t\t  \"vec_iv_\"),\n-\t\t   build1 (VIEW_CONVERT_EXPR, resvectype,\n-\t\t\t   gimple_assign_lhs (new_stmt)));\n+\t      new_stmt\n+\t\t= gimple_build_assign\n+\t\t\t(vect_get_new_vect_var (resvectype, vect_simple_var,\n+\t\t\t\t\t\t\"vec_iv_\"),\n+\t\t\t VIEW_CONVERT_EXPR,\n+\t\t\t build1 (VIEW_CONVERT_EXPR, resvectype,\n+\t\t\t\t gimple_assign_lhs (new_stmt)));\n \t      gimple_assign_set_lhs (new_stmt,\n \t\t\t\t     make_ssa_name\n \t\t\t\t       (gimple_assign_lhs (new_stmt), new_stmt));\n@@ -3623,10 +3625,12 @@ get_initial_def_for_induction (gimple iv_phi)\n   STMT_VINFO_VEC_STMT (phi_info) = induction_phi;\n   if (!useless_type_conversion_p (resvectype, vectype))\n     {\n-      new_stmt = gimple_build_assign_with_ops\n-\t (VIEW_CONVERT_EXPR,\n-\t  vect_get_new_vect_var (resvectype, vect_simple_var, \"vec_iv_\"),\n-\t  build1 (VIEW_CONVERT_EXPR, resvectype, induc_def));\n+      new_stmt = gimple_build_assign (vect_get_new_vect_var (resvectype,\n+\t\t\t\t\t\t\t     vect_simple_var,\n+\t\t\t\t\t\t\t     \"vec_iv_\"),\n+\t\t\t\t      VIEW_CONVERT_EXPR,\n+\t\t\t\t      build1 (VIEW_CONVERT_EXPR, resvectype,\n+\t\t\t\t\t      induc_def));\n       induc_def = make_ssa_name (gimple_assign_lhs (new_stmt), new_stmt);\n       gimple_assign_set_lhs (new_stmt, induc_def);\n       si = gsi_after_labels (bb);\n@@ -4299,15 +4303,14 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n             {\n               calc_vec_perm_mask_for_shift (mode, elt_offset, sel);\n               tree mask = vect_gen_perm_mask_any (vectype, sel);\n-\t      epilog_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR,\n-\t\t\t\t\t\t\t  vec_dest, new_temp,\n-\t\t\t\t\t\t\t  zero_vec, mask);\n+\t      epilog_stmt = gimple_build_assign (vec_dest, VEC_PERM_EXPR,\n+\t\t\t\t\t\t new_temp, zero_vec, mask);\n               new_name = make_ssa_name (vec_dest, epilog_stmt);\n               gimple_assign_set_lhs (epilog_stmt, new_name);\n               gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n \n-              epilog_stmt = gimple_build_assign_with_ops (code, vec_dest,\n-                                                          new_name, new_temp);\n+\t      epilog_stmt = gimple_build_assign (vec_dest, code, new_name,\n+\t\t\t\t\t\t new_temp);\n               new_temp = make_ssa_name (vec_dest, epilog_stmt);\n               gimple_assign_set_lhs (epilog_stmt, new_temp);\n               gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n@@ -4386,8 +4389,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n                     }\n                   else\n                     {\n-                      epilog_stmt = gimple_build_assign_with_ops (code,\n-                                          new_scalar_dest, new_name, new_temp);\n+\t\t      epilog_stmt = gimple_build_assign (new_scalar_dest, code,\n+\t\t\t\t\t\t\t new_name, new_temp);\n                       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n                       gimple_assign_set_lhs (epilog_stmt, new_temp);\n                       gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n@@ -4409,8 +4412,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n                    j++)\n                 {\n                   first_res = scalar_results[j % group_size];\n-                  new_stmt = gimple_build_assign_with_ops (code,\n-                                              new_scalar_dest, first_res, res);\n+\t\t  new_stmt = gimple_build_assign (new_scalar_dest, code,\n+\t\t\t\t\t\t  first_res, res);\n                   new_res = make_ssa_name (new_scalar_dest, new_stmt);\n                   gimple_assign_set_lhs (new_stmt, new_res);\n                   gsi_insert_before (&exit_gsi, new_stmt, GSI_SAME_STMT);"}, {"sha": "d5effab186bc3b65eff5683834434cd0f2e7cd03", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 109, "deletions": 161, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -439,8 +439,8 @@ vect_recog_dot_prod_pattern (vec<gimple> *stmts, tree *type_in,\n \n   /* Pattern detected. Create a stmt to be used to replace the pattern: */\n   var = vect_recog_temp_ssa_var (type, NULL);\n-  pattern_stmt = gimple_build_assign_with_ops (DOT_PROD_EXPR, var,\n-\t\t\t\t\t       oprnd00, oprnd01, oprnd1);\n+  pattern_stmt = gimple_build_assign (var, DOT_PROD_EXPR,\n+\t\t\t\t      oprnd00, oprnd01, oprnd1);\n \n   if (dump_enabled_p ())\n     {\n@@ -673,8 +673,8 @@ vect_recog_sad_pattern (vec<gimple> *stmts, tree *type_in,\n \n   /* Pattern detected. Create a stmt to be used to replace the pattern: */\n   tree var = vect_recog_temp_ssa_var (sum_type, NULL);\n-  gimple pattern_stmt = gimple_build_assign_with_ops\n-                          (SAD_EXPR, var, sad_oprnd0, sad_oprnd1, plus_oprnd1);\n+  gimple pattern_stmt = gimple_build_assign (var, SAD_EXPR, sad_oprnd0,\n+\t\t\t\t\t     sad_oprnd1, plus_oprnd1);\n \n   if (dump_enabled_p ())\n     {\n@@ -760,7 +760,7 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n       /* Create a_T = (NEW_TYPE) a_t;  */\n       *oprnd = gimple_assign_rhs1 (def_stmt);\n       new_oprnd = make_ssa_name (new_type);\n-      new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd, *oprnd);\n+      new_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, *oprnd);\n       STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)) = new_stmt;\n       stmts->safe_push (def_stmt);\n       *oprnd = new_oprnd;\n@@ -933,8 +933,7 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,\n \n         tree old_oprnd = gimple_assign_rhs1 (def_stmt);\n \ttree new_oprnd = make_ssa_name (half_type0);\n-        new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n-\t\t\t\t\t\t old_oprnd);\n+\tnew_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, old_oprnd);\n         *oprnd = new_oprnd;\n     }\n \n@@ -999,8 +998,7 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,\n \n   /* Pattern supported. Create a stmt to be used to replace the pattern: */\n   var = vect_recog_temp_ssa_var (itype, NULL);\n-  pattern_stmt = gimple_build_assign_with_ops (WIDEN_MULT_EXPR, var, oprnd0,\n-\t\t\t\t\t       oprnd1);\n+  pattern_stmt = gimple_build_assign (var, WIDEN_MULT_EXPR, oprnd0, oprnd1);\n \n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n@@ -1028,10 +1026,9 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,\n         = new_stmt_vec_info (pattern_stmt, loop_vinfo, bb_vinfo);\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n       STMT_VINFO_VECTYPE (pattern_stmt_info) = vecitype;\n-      pattern_stmt\n-        = gimple_build_assign_with_ops (NOP_EXPR,\n-                                        vect_recog_temp_ssa_var (type, NULL),\n-\t\t\t\t\tgimple_assign_lhs (pattern_stmt));\n+      pattern_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n+\t\t\t\t\t  NOP_EXPR,\n+\t\t\t\t\t  gimple_assign_lhs (pattern_stmt));\n     }\n \n   if (dump_enabled_p ())\n@@ -1115,7 +1112,7 @@ vect_recog_pow_pattern (vec<gimple> *stmts, tree *type_in,\n       *type_in = TREE_TYPE (base);\n \n       var = vect_recog_temp_ssa_var (TREE_TYPE (base), NULL);\n-      stmt = gimple_build_assign_with_ops (MULT_EXPR, var, base, base);\n+      stmt = gimple_build_assign (var, MULT_EXPR, base, base);\n       return stmt;\n     }\n \n@@ -1244,8 +1241,7 @@ vect_recog_widen_sum_pattern (vec<gimple> *stmts, tree *type_in,\n \n   /* Pattern detected. Create a stmt to be used to replace the pattern: */\n   var = vect_recog_temp_ssa_var (type, NULL);\n-  pattern_stmt = gimple_build_assign_with_ops (WIDEN_SUM_EXPR, var,\n-\t\t\t\t\t       oprnd0, oprnd1);\n+  pattern_stmt = gimple_build_assign (var, WIDEN_SUM_EXPR, oprnd0, oprnd1);\n \n   if (dump_enabled_p ())\n     {\n@@ -1440,8 +1436,7 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n               /* Create NEW_OPRND = (INTERM_TYPE) OPRND.  */\n               oprnd = gimple_assign_rhs1 (def_stmt);\n \t      new_oprnd = make_ssa_name (interm_type);\n-              new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n-\t\t\t\t\t\t       oprnd);\n+\t      new_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, oprnd);\n               STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)) = new_stmt;\n               stmts->safe_push (def_stmt);\n               oprnd = new_oprnd;\n@@ -1459,8 +1454,7 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n         {\n           /* Create a type conversion HALF_TYPE->INTERM_TYPE.  */\n \t  new_oprnd = make_ssa_name (interm_type);\n-          new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n-\t\t\t\t\t\t   oprnd);\n+\t  new_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, oprnd);\n           oprnd = new_oprnd;\n           *new_def_stmt = new_stmt;\n         }\n@@ -1548,8 +1542,7 @@ vect_recog_over_widening_pattern (vec<gimple> *stmts,\n \n       var = vect_recog_temp_ssa_var (new_type, NULL);\n       pattern_stmt\n-\t= gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt), var,\n-\t\t\t\t\top0, op1);\n+\t= gimple_build_assign (var, gimple_assign_rhs_code (stmt), op0, op1);\n       STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt)) = pattern_stmt;\n       new_pattern_def_seq (vinfo_for_stmt (stmt), new_def_stmt);\n \n@@ -1591,8 +1584,7 @@ vect_recog_over_widening_pattern (vec<gimple> *stmts,\n         {\n           /* Create NEW_TYPE->USE_TYPE conversion.  */\n \t  new_oprnd = make_ssa_name (use_type);\n-          pattern_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n-\t\t\t\t\t\t       var);\n+\t  pattern_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, var);\n           STMT_VINFO_RELATED_STMT (vinfo_for_stmt (use_stmt)) = pattern_stmt;\n \n           *type_in = get_vectype_for_scalar_type (new_type);\n@@ -1781,7 +1773,7 @@ vect_recog_widen_shift_pattern (vec<gimple> *stmts,\n   /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n   var = vect_recog_temp_ssa_var (type, NULL);\n   pattern_stmt =\n-    gimple_build_assign_with_ops (WIDEN_LSHIFT_EXPR, var, oprnd0, oprnd1);\n+    gimple_build_assign (var, WIDEN_LSHIFT_EXPR, oprnd0, oprnd1);\n \n   if (dump_enabled_p ())\n     dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n@@ -1944,7 +1936,7 @@ vect_recog_rotate_pattern (vec<gimple> *stmts, tree *type_in, tree *type_out)\n   if (def == NULL_TREE)\n     {\n       def = vect_recog_temp_ssa_var (type, NULL);\n-      def_stmt = gimple_build_assign_with_ops (NOP_EXPR, def, oprnd1);\n+      def_stmt = gimple_build_assign (def, NOP_EXPR, oprnd1);\n       if (ext_def)\n \t{\n \t  basic_block new_bb\n@@ -1974,7 +1966,7 @@ vect_recog_rotate_pattern (vec<gimple> *stmts, tree *type_in, tree *type_out)\n       if (vecstype == NULL_TREE)\n \treturn NULL;\n       def2 = vect_recog_temp_ssa_var (stype, NULL);\n-      def_stmt = gimple_build_assign_with_ops (NEGATE_EXPR, def2, def);\n+      def_stmt = gimple_build_assign (def2, NEGATE_EXPR, def);\n       if (ext_def)\n \t{\n \t  basic_block new_bb\n@@ -1992,9 +1984,8 @@ vect_recog_rotate_pattern (vec<gimple> *stmts, tree *type_in, tree *type_out)\n       def2 = vect_recog_temp_ssa_var (stype, NULL);\n       tree mask\n \t= build_int_cst (stype, GET_MODE_PRECISION (TYPE_MODE (stype)) - 1);\n-      def_stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, def2,\n-\t\t\t\t\t       gimple_assign_lhs (def_stmt),\n-\t\t\t\t\t       mask);\n+      def_stmt = gimple_build_assign (def2, BIT_AND_EXPR,\n+\t\t\t\t      gimple_assign_lhs (def_stmt), mask);\n       if (ext_def)\n \t{\n \t  basic_block new_bb\n@@ -2011,15 +2002,15 @@ vect_recog_rotate_pattern (vec<gimple> *stmts, tree *type_in, tree *type_out)\n     }\n \n   var1 = vect_recog_temp_ssa_var (type, NULL);\n-  def_stmt = gimple_build_assign_with_ops (rhs_code == LROTATE_EXPR\n-\t\t\t\t\t   ? LSHIFT_EXPR : RSHIFT_EXPR,\n-\t\t\t\t\t   var1, oprnd0, def);\n+  def_stmt = gimple_build_assign (var1, rhs_code == LROTATE_EXPR\n+\t\t\t\t\t? LSHIFT_EXPR : RSHIFT_EXPR,\n+\t\t\t\t  oprnd0, def);\n   append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n   var2 = vect_recog_temp_ssa_var (type, NULL);\n-  def_stmt = gimple_build_assign_with_ops (rhs_code == LROTATE_EXPR\n-\t\t\t\t\t   ? RSHIFT_EXPR : LSHIFT_EXPR,\n-\t\t\t\t\t   var2, oprnd0, def2);\n+  def_stmt = gimple_build_assign (var2, rhs_code == LROTATE_EXPR\n+\t\t\t\t\t? RSHIFT_EXPR : LSHIFT_EXPR,\n+\t\t\t\t  oprnd0, def2);\n   append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n   /* Pattern detected.  */\n@@ -2029,7 +2020,7 @@ vect_recog_rotate_pattern (vec<gimple> *stmts, tree *type_in, tree *type_out)\n \n   /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n   var = vect_recog_temp_ssa_var (type, NULL);\n-  pattern_stmt = gimple_build_assign_with_ops (BIT_IOR_EXPR, var, var1, var2);\n+  pattern_stmt = gimple_build_assign (var, BIT_IOR_EXPR, var1, var2);\n \n   if (dump_enabled_p ())\n     dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n@@ -2147,7 +2138,7 @@ vect_recog_vector_vector_shift_pattern (vec<gimple> *stmts,\n   if (def == NULL_TREE)\n     {\n       def = vect_recog_temp_ssa_var (TREE_TYPE (oprnd0), NULL);\n-      def_stmt = gimple_build_assign_with_ops (NOP_EXPR, def, oprnd1);\n+      def_stmt = gimple_build_assign (def, NOP_EXPR, oprnd1);\n       new_pattern_def_seq (stmt_vinfo, def_stmt);\n     }\n \n@@ -2158,7 +2149,7 @@ vect_recog_vector_vector_shift_pattern (vec<gimple> *stmts,\n \n   /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n   var = vect_recog_temp_ssa_var (TREE_TYPE (oprnd0), NULL);\n-  pattern_stmt = gimple_build_assign_with_ops (rhs_code, var, oprnd0, def);\n+  pattern_stmt = gimple_build_assign (var, rhs_code, oprnd0, def);\n \n   if (dump_enabled_p ())\n     dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n@@ -2281,25 +2272,21 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n \t  tree var = vect_recog_temp_ssa_var (itype, NULL);\n \t  tree shift;\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (COND_EXPR, var, cond,\n-\t\t\t\t\t    fold_build2 (MINUS_EXPR, itype,\n-\t\t\t\t\t\t\t oprnd1,\n-\t\t\t\t\t\t\t build_int_cst (itype,\n-\t\t\t\t\t\t\t\t\t1)),\n-\t\t\t\t\t    build_int_cst (itype, 0));\n+\t    = gimple_build_assign (var, COND_EXPR, cond,\n+\t\t\t\t   fold_build2 (MINUS_EXPR, itype, oprnd1,\n+\t\t\t\t\t\tbuild_int_cst (itype, 1)),\n+\t\t\t\t   build_int_cst (itype, 0));\n \t  new_pattern_def_seq (stmt_vinfo, def_stmt);\n \t  var = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (PLUS_EXPR, var, oprnd0,\n-\t\t\t\t\t    gimple_assign_lhs (def_stmt));\n+\t    = gimple_build_assign (var, PLUS_EXPR, oprnd0,\n+\t\t\t\t   gimple_assign_lhs (def_stmt));\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n \t  shift = build_int_cst (itype, tree_log2 (oprnd1));\n \t  pattern_stmt\n-\t    = gimple_build_assign_with_ops (RSHIFT_EXPR,\n-\t\t\t\t\t    vect_recog_temp_ssa_var (itype,\n-\t\t\t\t\t\t\t\t     NULL),\n-\t\t\t\t\t    var, shift);\n+\t    = gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t   RSHIFT_EXPR, var, shift);\n \t}\n       else\n \t{\n@@ -2308,10 +2295,9 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n \t  if (compare_tree_int (oprnd1, 2) == 0)\n \t    {\n \t      signmask = vect_recog_temp_ssa_var (itype, NULL);\n-\t      def_stmt\n-\t\t= gimple_build_assign_with_ops (COND_EXPR, signmask, cond,\n-\t\t\t\t\t\tbuild_int_cst (itype, 1),\n-\t\t\t\t\t\tbuild_int_cst (itype, 0));\n+\t      def_stmt = gimple_build_assign (signmask, COND_EXPR, cond,\n+\t\t\t\t\t      build_int_cst (itype, 1),\n+\t\t\t\t\t      build_int_cst (itype, 0));\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t    }\n \t  else\n@@ -2324,53 +2310,43 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n \t\t\t\t\t- tree_log2 (oprnd1));\n \t      tree var = vect_recog_temp_ssa_var (utype, NULL);\n \n-\t      def_stmt\n-\t\t= gimple_build_assign_with_ops (COND_EXPR, var, cond,\n-\t\t\t\t\t\tbuild_int_cst (utype, -1),\n-\t\t\t\t\t\tbuild_int_cst (utype, 0));\n+\t      def_stmt = gimple_build_assign (var, COND_EXPR, cond,\n+\t\t\t\t\t      build_int_cst (utype, -1),\n+\t\t\t\t\t      build_int_cst (utype, 0));\n \t      def_stmt_vinfo\n \t\t= new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n \t      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n \t      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t      var = vect_recog_temp_ssa_var (utype, NULL);\n-\t      def_stmt\n-\t\t= gimple_build_assign_with_ops (RSHIFT_EXPR, var,\n-\t\t\t\t\t\tgimple_assign_lhs (def_stmt),\n-\t\t\t\t\t\tshift);\n+\t      def_stmt = gimple_build_assign (var, RSHIFT_EXPR,\n+\t\t\t\t\t      gimple_assign_lhs (def_stmt),\n+\t\t\t\t\t      shift);\n \t      def_stmt_vinfo\n \t\t= new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n \t      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n \t      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t      signmask = vect_recog_temp_ssa_var (itype, NULL);\n \t      def_stmt\n-\t\t= gimple_build_assign_with_ops (NOP_EXPR, signmask, var);\n+\t\t= gimple_build_assign (signmask, NOP_EXPR, var);\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t    }\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (PLUS_EXPR,\n-\t\t\t\t\t    vect_recog_temp_ssa_var (itype,\n-\t\t\t\t\t\t\t\t     NULL),\n-\t\t\t\t\t    oprnd0, signmask);\n+\t    = gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t   PLUS_EXPR, oprnd0, signmask);\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (BIT_AND_EXPR,\n-\t\t\t\t\t    vect_recog_temp_ssa_var (itype,\n-\t\t\t\t\t\t\t\t     NULL),\n-\t\t\t\t\t    gimple_assign_lhs (def_stmt),\n-\t\t\t\t\t    fold_build2 (MINUS_EXPR, itype,\n-\t\t\t\t\t\t\t oprnd1,\n-\t\t\t\t\t\t\t build_int_cst (itype,\n-\t\t\t\t\t\t\t\t\t1)));\n+\t    = gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t   BIT_AND_EXPR, gimple_assign_lhs (def_stmt),\n+\t\t\t\t   fold_build2 (MINUS_EXPR, itype, oprnd1,\n+\t\t\t\t\t\tbuild_int_cst (itype, 1)));\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n \t  pattern_stmt\n-\t    = gimple_build_assign_with_ops (MINUS_EXPR,\n-\t\t\t\t\t    vect_recog_temp_ssa_var (itype,\n-\t\t\t\t\t\t\t\t     NULL),\n-\t\t\t\t\t    gimple_assign_lhs (def_stmt),\n-\t\t\t\t\t    signmask);\n+\t    = gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t   MINUS_EXPR, gimple_assign_lhs (def_stmt),\n+\t\t\t\t   signmask);\n \t}\n \n       if (dump_enabled_p ())\n@@ -2432,36 +2408,32 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n \t     t4 = t1 + t3;\n \t     q = t4 >> (post_shift - 1);  */\n \t  t1 = vect_recog_temp_ssa_var (itype, NULL);\n-\t  def_stmt\n-\t    = gimple_build_assign_with_ops (MULT_HIGHPART_EXPR, t1, oprnd0,\n-\t\t\t\t\t    build_int_cst (itype, ml));\n+\t  def_stmt = gimple_build_assign (t1, MULT_HIGHPART_EXPR, oprnd0,\n+\t\t\t\t\t  build_int_cst (itype, ml));\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n \t  t2 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (MINUS_EXPR, t2, oprnd0, t1);\n+\t    = gimple_build_assign (t2, MINUS_EXPR, oprnd0, t1);\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n \t  t3 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t3, t2,\n-\t\t\t\t\t    integer_one_node);\n+\t    = gimple_build_assign (t3, RSHIFT_EXPR, t2, integer_one_node);\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n \t  t4 = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n-\t    = gimple_build_assign_with_ops (PLUS_EXPR, t4, t1, t3);\n+\t    = gimple_build_assign (t4, PLUS_EXPR, t1, t3);\n \n \t  if (post_shift != 1)\n \t    {\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n \t      q = vect_recog_temp_ssa_var (itype, NULL);\n \t      pattern_stmt\n-\t\t= gimple_build_assign_with_ops (RSHIFT_EXPR, q, t4,\n-\t\t\t\t\t\tbuild_int_cst (itype,\n-\t\t\t\t\t\t\t       post_shift\n-\t\t\t\t\t\t\t       - 1));\n+\t\t= gimple_build_assign (q, RSHIFT_EXPR, t4,\n+\t\t\t\t       build_int_cst (itype, post_shift - 1));\n \t    }\n \t  else\n \t    {\n@@ -2481,28 +2453,25 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n \t    {\n \t      t1 = vect_recog_temp_ssa_var (itype, NULL);\n \t      def_stmt\n-\t\t= gimple_build_assign_with_ops (RSHIFT_EXPR, t1, oprnd0,\n-\t\t\t\t\t\tbuild_int_cst (NULL,\n-\t\t\t\t\t\t\t       pre_shift));\n+\t\t= gimple_build_assign (t1, RSHIFT_EXPR, oprnd0,\n+\t\t\t\t       build_int_cst (NULL, pre_shift));\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t    }\n \t  else\n \t    t1 = oprnd0;\n \n \t  t2 = vect_recog_temp_ssa_var (itype, NULL);\n-\t  def_stmt\n-\t    = gimple_build_assign_with_ops (MULT_HIGHPART_EXPR, t2, t1,\n-\t\t\t\t\t    build_int_cst (itype, ml));\n+\t  def_stmt = gimple_build_assign (t2, MULT_HIGHPART_EXPR, t1,\n+\t\t\t\t\t  build_int_cst (itype, ml));\n \n \t  if (post_shift)\n \t    {\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n \t      q = vect_recog_temp_ssa_var (itype, NULL);\n \t      def_stmt\n-\t\t= gimple_build_assign_with_ops (RSHIFT_EXPR, q, t2,\n-\t\t\t\t\t\tbuild_int_cst (itype,\n-\t\t\t\t\t\t\t       post_shift));\n+\t\t= gimple_build_assign (q, RSHIFT_EXPR, t2,\n+\t\t\t\t       build_int_cst (itype, post_shift));\n \t    }\n \t  else\n \t    q = t2;\n@@ -2552,17 +2521,15 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n \n       /* t1 = oprnd0 h* ml;  */\n       t1 = vect_recog_temp_ssa_var (itype, NULL);\n-      def_stmt\n-\t= gimple_build_assign_with_ops (MULT_HIGHPART_EXPR, t1, oprnd0,\n-\t\t\t\t\tbuild_int_cst (itype, ml));\n+      def_stmt = gimple_build_assign (t1, MULT_HIGHPART_EXPR, oprnd0,\n+\t\t\t\t      build_int_cst (itype, ml));\n \n       if (add)\n \t{\n \t  /* t2 = t1 + oprnd0;  */\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t  t2 = vect_recog_temp_ssa_var (itype, NULL);\n-\t  def_stmt\n-\t    = gimple_build_assign_with_ops (PLUS_EXPR, t2, t1, oprnd0);\n+\t  def_stmt = gimple_build_assign (t2, PLUS_EXPR, t1, oprnd0);\n \t}\n       else\n \tt2 = t1;\n@@ -2572,9 +2539,8 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n \t  /* t3 = t2 >> post_shift;  */\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t  t3 = vect_recog_temp_ssa_var (itype, NULL);\n-\t  def_stmt\n-\t    = gimple_build_assign_with_ops (RSHIFT_EXPR, t3, t2,\n-\t\t\t\t\t    build_int_cst (itype, post_shift));\n+\t  def_stmt = gimple_build_assign (t3, RSHIFT_EXPR, t2,\n+\t\t\t\t\t  build_int_cst (itype, post_shift));\n \t}\n       else\n \tt3 = t2;\n@@ -2605,20 +2571,17 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t  t4 = vect_recog_temp_ssa_var (itype, NULL);\n \t  if (msb != 1)\n-\t    def_stmt\n-\t      = gimple_build_assign_with_ops (INTEGER_CST,\n-\t\t\t\t\t      t4, build_int_cst (itype, msb));\n+\t    def_stmt = gimple_build_assign (t4, INTEGER_CST,\n+\t\t\t\t\t    build_int_cst (itype, msb));\n \t  else\n-\t    def_stmt\n-\t      = gimple_build_assign_with_ops (RSHIFT_EXPR, t4, oprnd0,\n-\t\t\t\t\t      build_int_cst (itype, prec - 1));\n+\t    def_stmt = gimple_build_assign (t4, RSHIFT_EXPR, oprnd0,\n+\t\t\t\t\t    build_int_cst (itype, prec - 1));\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n \t  /* q = t3 - t4;  or q = t4 - t3;  */\n \t  q = vect_recog_temp_ssa_var (itype, NULL);\n-\t  pattern_stmt\n-\t    = gimple_build_assign_with_ops (MINUS_EXPR, q, d < 0 ? t4 : t3,\n-\t\t\t\t\t    d < 0 ? t3 : t4);\n+\t  pattern_stmt = gimple_build_assign (q, MINUS_EXPR, d < 0 ? t4 : t3,\n+\t\t\t\t\t      d < 0 ? t3 : t4);\n \t}\n     }\n \n@@ -2632,13 +2595,11 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n       append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n \n       t1 = vect_recog_temp_ssa_var (itype, NULL);\n-      def_stmt\n-\t= gimple_build_assign_with_ops (MULT_EXPR, t1, q, oprnd1);\n+      def_stmt = gimple_build_assign (t1, MULT_EXPR, q, oprnd1);\n       append_pattern_def_seq (stmt_vinfo, def_stmt);\n \n       r = vect_recog_temp_ssa_var (itype, NULL);\n-      pattern_stmt\n-\t= gimple_build_assign_with_ops (MINUS_EXPR, r, oprnd0, t1);\n+      pattern_stmt = gimple_build_assign (r, MINUS_EXPR, oprnd0, t1);\n     }\n \n   /* Pattern detected.  */\n@@ -2793,16 +2754,12 @@ vect_recog_mixed_size_cond_pattern (vec<gimple> *stmts, tree *type_in,\n \treturn NULL;\n     }\n \n-  def_stmt\n-    = gimple_build_assign_with_ops (COND_EXPR,\n-\t\t\t\t    vect_recog_temp_ssa_var (itype, NULL),\n-\t\t\t\t    unshare_expr (cond_expr),\n-\t\t\t\t    fold_convert (itype, then_clause),\n-\t\t\t\t    fold_convert (itype, else_clause));\n-  pattern_stmt\n-    = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    vect_recog_temp_ssa_var (type, NULL),\n-\t\t\t\t    gimple_assign_lhs (def_stmt));\n+  def_stmt = gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t  COND_EXPR, unshare_expr (cond_expr),\n+\t\t\t\t  fold_convert (itype, then_clause),\n+\t\t\t\t  fold_convert (itype, else_clause));\n+  pattern_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n+\t\t\t\t      NOP_EXPR, gimple_assign_lhs (def_stmt));\n \n   new_pattern_def_seq (stmt_vinfo, def_stmt);\n   def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n@@ -2913,10 +2870,8 @@ adjust_bool_pattern_cast (tree type, tree var)\n   gcc_assert (!STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo));\n   pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n   new_pattern_def_seq (stmt_vinfo, pattern_stmt);\n-  cast_stmt\n-    = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    vect_recog_temp_ssa_var (type, NULL),\n-\t\t\t\t    gimple_assign_lhs (pattern_stmt));\n+  cast_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n+\t\t\t\t   NOP_EXPR, gimple_assign_lhs (pattern_stmt));\n   STMT_VINFO_RELATED_STMT (stmt_vinfo) = cast_stmt;\n   return gimple_assign_lhs (cast_stmt);\n }\n@@ -2951,18 +2906,16 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n       irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n       itype = TREE_TYPE (irhs1);\n       pattern_stmt\n-\t= gimple_build_assign_with_ops (SSA_NAME,\n-\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n-\t\t\t\t\tirhs1);\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t       SSA_NAME, irhs1);\n       break;\n \n     case BIT_NOT_EXPR:\n       irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n       itype = TREE_TYPE (irhs1);\n       pattern_stmt\n-\t= gimple_build_assign_with_ops (BIT_XOR_EXPR,\n-\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n-\t\t\t\t\tirhs1, build_int_cst (itype, 1));\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t       BIT_XOR_EXPR, irhs1, build_int_cst (itype, 1));\n       break;\n \n     case BIT_AND_EXPR:\n@@ -3073,9 +3026,8 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n \t}\n       itype = TREE_TYPE (irhs1);\n       pattern_stmt\n-\t= gimple_build_assign_with_ops (rhs_code,\n-\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n-\t\t\t\t\tirhs1, irhs2);\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t       rhs_code, irhs1, irhs2);\n       break;\n \n     default:\n@@ -3098,10 +3050,9 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n \tgcc_checking_assert (useless_type_conversion_p (itype,\n \t\t\t\t\t\t\tTREE_TYPE (trueval)));\n       pattern_stmt\n-\t= gimple_build_assign_with_ops (COND_EXPR,\n-\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n-\t\t\t\t\tcond_expr, trueval,\n-\t\t\t\t\tbuild_int_cst (itype, 0));\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t       COND_EXPR, cond_expr, trueval,\n+\t\t\t       build_int_cst (itype, 0));\n       break;\n     }\n \n@@ -3200,11 +3151,10 @@ vect_recog_bool_pattern (vec<gimple> *stmts, tree *type_in,\n       rhs = adjust_bool_pattern (var, TREE_TYPE (lhs), NULL_TREE, stmts);\n       lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n       if (useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n-\tpattern_stmt\n-\t  = gimple_build_assign_with_ops (SSA_NAME, lhs, rhs);\n+\tpattern_stmt = gimple_build_assign (lhs, SSA_NAME, rhs);\n       else\n \tpattern_stmt\n-\t  = gimple_build_assign_with_ops (NOP_EXPR, lhs, rhs);\n+\t  = gimple_build_assign (lhs, NOP_EXPR, rhs);\n       *type_out = vectype;\n       *type_in = vectype;\n       stmts->safe_push (last_stmt);\n@@ -3239,11 +3189,11 @@ vect_recog_bool_pattern (vec<gimple> *stmts, tree *type_in,\n       rhs = adjust_bool_pattern (var, type, NULL_TREE, stmts);\n       lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n       pattern_stmt \n-\t  = gimple_build_assign_with_ops (COND_EXPR, lhs,\n-\t\t\t\t\t  build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t\t  rhs, build_int_cst (type, 0)),\n-\t\t\t\t\t  gimple_assign_rhs2 (last_stmt),\n-\t\t\t\t\t  gimple_assign_rhs3 (last_stmt));\n+\t  = gimple_build_assign (lhs, COND_EXPR,\n+\t\t\t\t build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t\t rhs, build_int_cst (type, 0)),\n+\t\t\t\t gimple_assign_rhs2 (last_stmt),\n+\t\t\t\t gimple_assign_rhs3 (last_stmt));\n       *type_out = vectype;\n       *type_in = vectype;\n       stmts->safe_push (last_stmt);\n@@ -3269,13 +3219,11 @@ vect_recog_bool_pattern (vec<gimple> *stmts, tree *type_in,\n       if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n \t{\n \t  tree rhs2 = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n-\t  gimple cast_stmt\n-\t    = gimple_build_assign_with_ops (NOP_EXPR, rhs2, rhs);\n+\t  gimple cast_stmt = gimple_build_assign (rhs2, NOP_EXPR, rhs);\n \t  new_pattern_def_seq (stmt_vinfo, cast_stmt);\n \t  rhs = rhs2;\n \t}\n-      pattern_stmt\n-\t= gimple_build_assign_with_ops (SSA_NAME, lhs, rhs);\n+      pattern_stmt = gimple_build_assign (lhs, SSA_NAME, rhs);\n       pattern_stmt_info = new_stmt_vec_info (pattern_stmt, loop_vinfo,\n \t\t\t\t\t\tbb_vinfo);\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);"}, {"sha": "f43b72476f782c385727899602e826e29dd57106", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -2671,11 +2671,9 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \t\t{\n \t\t  tree new_temp = make_ssa_name (TREE_TYPE (vector_type));\n \t\t  gimple init_stmt;\n-\t\t  op = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (vector_type),\n-\t\t\t       op);\t\t  \n+\t\t  op = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (vector_type), op);\n \t\t  init_stmt\n-\t\t    = gimple_build_assign_with_ops (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t    new_temp, op);\n+\t\t    = gimple_build_assign (new_temp, VIEW_CONVERT_EXPR, op);\n \t\t  gimple_seq_add_stmt (&ctor_seq, init_stmt);\n \t\t  op = new_temp;\n \t\t}\n@@ -2899,8 +2897,8 @@ vect_create_mask_and_perm (gimple stmt, gimple next_scalar_stmt,\n       second_vec = dr_chain[second_vec_indx];\n \n       /* Generate the permute statement.  */\n-      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, perm_dest,\n-\t\t\t\t\t\tfirst_vec, second_vec, mask);\n+      perm_stmt = gimple_build_assign (perm_dest, VEC_PERM_EXPR,\n+\t\t\t\t       first_vec, second_vec, mask);\n       data_ref = make_ssa_name (perm_dest, perm_stmt);\n       gimple_set_lhs (perm_stmt, data_ref);\n       vect_finish_stmt_generation (stmt, perm_stmt, gsi);"}, {"sha": "6903f0a2e00abeb2335b520d8c55eec3da681816", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 32, "deletions": 43, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -1332,8 +1332,7 @@ vect_init_vector (gimple stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n \t  else\n \t    {\n \t      new_temp = make_ssa_name (TREE_TYPE (type));\n-\t      init_stmt = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t\t\tnew_temp, val);\n+\t      init_stmt = gimple_build_assign (new_temp, NOP_EXPR, val);\n \t      vect_init_vector_1 (stmt, init_stmt, gsi);\n \t      val = new_temp;\n \t    }\n@@ -1969,7 +1968,7 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n \t      var = make_ssa_name (var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n \t      new_stmt\n-\t\t= gimple_build_assign_with_ops (VIEW_CONVERT_EXPR, var, op);\n+\t\t= gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      op = var;\n \t    }\n@@ -1998,8 +1997,7 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t  var = make_ssa_name (var);\n \t\t  mask_op = build1 (VIEW_CONVERT_EXPR, masktype, mask_op);\n \t\t  new_stmt\n-\t\t    = gimple_build_assign_with_ops (VIEW_CONVERT_EXPR, var,\n-\t\t\t\t\t\t    mask_op);\n+\t\t    = gimple_build_assign (var, VIEW_CONVERT_EXPR, mask_op);\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  mask_op = var;\n \t\t}\n@@ -2019,8 +2017,7 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      var = make_ssa_name (vec_dest);\n \t      op = build1 (VIEW_CONVERT_EXPR, vectype, op);\n-\t      new_stmt\n-\t\t= gimple_build_assign_with_ops (VIEW_CONVERT_EXPR, var, op);\n+\t      new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n \t    }\n \t  else\n \t    {\n@@ -3049,8 +3046,8 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t\t       ncopies * nunits);\n \t\t  tree tcst = wide_int_to_tree (type, cst);\n \t\t  tree phi_arg = copy_ssa_name (op);\n-\t\t  new_stmt = gimple_build_assign_with_ops (code, phi_arg,\n-\t\t\t\t\t\t\t   phi_res, tcst);\n+\t\t  new_stmt\n+\t\t    = gimple_build_assign (phi_arg, code, phi_res, tcst);\n \t\t  gimple_stmt_iterator si = gsi_after_labels (loop->header);\n \t\t  gsi_insert_after (&si, new_stmt, GSI_NEW_STMT);\n \t\t  set_vinfo_for_stmt (new_stmt,\n@@ -3073,9 +3070,8 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t\t       j * nunits);\n \t\t  tree tcst = wide_int_to_tree (type, cst);\n \t\t  new_temp = make_ssa_name (TREE_TYPE (op));\n-\t\t  new_stmt\n-\t\t    = gimple_build_assign_with_ops (code, new_temp,\n-\t\t\t\t\t\t    arginfo[i].op, tcst);\n+\t\t  new_stmt = gimple_build_assign (new_temp, code,\n+\t\t\t\t\t\t  arginfo[i].op, tcst);\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  vargs.safe_push (new_temp);\n \t\t}\n@@ -3275,8 +3271,7 @@ vect_gen_widened_results_half (enum tree_code code,\n       gcc_assert (op_type == TREE_CODE_LENGTH (code));\n       if (op_type != binary_op)\n \tvec_oprnd1 = NULL;\n-      new_stmt = gimple_build_assign_with_ops (code, vec_dest, vec_oprnd0,\n-\t\t\t\t\t       vec_oprnd1);\n+      new_stmt = gimple_build_assign (vec_dest, code, vec_oprnd0, vec_oprnd1);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_temp);\n     }\n@@ -3346,7 +3341,7 @@ vect_create_vectorized_demotion_stmts (vec<tree> *vec_oprnds,\n       /* Create demotion operation.  */\n       vop0 = (*vec_oprnds)[i];\n       vop1 = (*vec_oprnds)[i + 1];\n-      new_stmt = gimple_build_assign_with_ops (code, vec_dest, vop0, vop1);\n+      new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1);\n       new_tmp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_tmp);\n       vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -3826,8 +3821,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t      else\n \t\t{\n \t\t  gcc_assert (TREE_CODE_LENGTH (code1) == unary_op);\n-\t\t  new_stmt = gimple_build_assign_with_ops (code1, vec_dest,\n-\t\t\t\t\t\t\t   vop0);\n+\t\t  new_stmt = gimple_build_assign (vec_dest, code1, vop0);\n \t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t\t  gimple_assign_set_lhs (new_stmt, new_temp);\n \t\t}\n@@ -3938,8 +3932,8 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t    {\n \t\t      gcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n \t\t      new_temp = make_ssa_name (vec_dest);\n-\t\t      new_stmt = gimple_build_assign_with_ops (codecvt1,\n-\t\t\t\t\t\t\t       new_temp, vop0);\n+\t\t      new_stmt = gimple_build_assign (new_temp, codecvt1,\n+\t\t\t\t\t\t      vop0);\n \t\t    }\n \n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -3995,8 +3989,8 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t  {\n \t\t    gcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n \t\t    new_temp = make_ssa_name (vec_dest);\n-\t\t    new_stmt = gimple_build_assign_with_ops (codecvt1, new_temp,\n-\t\t\t\t\t\t\t     vop0);\n+\t\t    new_stmt = gimple_build_assign (new_temp, codecvt1,\n+\t\t\t\t\t\t    vop0);\n \t\t  }\n \n \t\tvect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -4557,7 +4551,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n       FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n         {\n           vop1 = vec_oprnds1[i];\n-          new_stmt = gimple_build_assign_with_ops (code, vec_dest, vop0, vop1);\n+\t  new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1);\n           new_temp = make_ssa_name (vec_dest, new_stmt);\n           gimple_assign_set_lhs (new_stmt, new_temp);\n           vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -4910,8 +4904,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t  ? vec_oprnds1[i] : NULL_TREE);\n \t  vop2 = ((op_type == ternary_op)\n \t\t  ? vec_oprnds2[i] : NULL_TREE);\n-\t  new_stmt = gimple_build_assign_with_ops (code, vec_dest,\n-\t\t\t\t\t\t   vop0, vop1, vop2);\n+\t  new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1, vop2);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_assign_set_lhs (new_stmt, new_temp);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -5467,9 +5460,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n \t\t  /* Generate the permute statement.  */\n \t\t  gimple perm_stmt \n-\t\t    = gimple_build_assign_with_ops (VEC_PERM_EXPR, new_temp,\n-\t\t\t\t\t\t    vec_oprnd, vec_oprnd,\n-\t\t\t\t\t\t    perm_mask);\n+\t\t    = gimple_build_assign (new_temp, VEC_PERM_EXPR, vec_oprnd,\n+\t\t\t\t\t   vec_oprnd, perm_mask);\n \t\t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \n \t\t  perm_stmt = SSA_NAME_DEF_STMT (new_temp);\n@@ -5558,8 +5550,7 @@ permute_vec_elements (tree x, tree y, tree mask_vec, gimple stmt,\n   data_ref = make_ssa_name (perm_dest);\n \n   /* Generate the permute statement.  */\n-  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n-\t\t\t\t\t    x, y, mask_vec);\n+  perm_stmt = gimple_build_assign (data_ref, VEC_PERM_EXPR, x, y, mask_vec);\n   vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \n   return data_ref;\n@@ -5994,7 +5985,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      var = make_ssa_name (var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n \t      new_stmt\n-\t\t= gimple_build_assign_with_ops (VIEW_CONVERT_EXPR, var, op);\n+\t\t= gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      op = var;\n \t    }\n@@ -6013,7 +6004,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      var = make_ssa_name (vec_dest);\n \t      op = build1 (VIEW_CONVERT_EXPR, vectype, op);\n \t      new_stmt\n-\t\t= gimple_build_assign_with_ops (VIEW_CONVERT_EXPR, var, op);\n+\t\t= gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n \t    }\n \t  else\n \t    {\n@@ -6117,8 +6108,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t\t\t GSI_SAME_STMT);\n \t      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, newref);\n \t      newoff = copy_ssa_name (running_off);\n-\t      incr = gimple_build_assign_with_ops (POINTER_PLUS_EXPR, newoff,\n-\t\t\t\t\t\t   running_off, stride_step);\n+\t      incr = gimple_build_assign (newoff, POINTER_PLUS_EXPR,\n+\t\t\t\t\t  running_off, stride_step);\n \t      vect_finish_stmt_generation (stmt, incr, gsi);\n \n \t      running_off = newoff;\n@@ -6456,8 +6447,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t\t\t    dataref_ptr, NULL);\n \n \t\t    ptr = copy_ssa_name (dataref_ptr);\n-\t\t    new_stmt = gimple_build_assign_with_ops\n-\t\t\t\t (BIT_AND_EXPR, ptr, dataref_ptr,\n+\t\t    new_stmt = gimple_build_assign\n+\t\t\t\t (ptr, BIT_AND_EXPR, dataref_ptr,\n \t\t\t\t  build_int_cst\n \t\t\t\t  (TREE_TYPE (dataref_ptr),\n \t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n@@ -6479,8 +6470,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t    bump = size_binop (MULT_EXPR, vs_minus_1,\n \t\t\t\t       TYPE_SIZE_UNIT (elem_type));\n \t\t    ptr = bump_vector_ptr (dataref_ptr, NULL, gsi, stmt, bump);\n-\t\t    new_stmt = gimple_build_assign_with_ops\n-\t\t\t\t (BIT_AND_EXPR, NULL_TREE, ptr,\n+\t\t    new_stmt = gimple_build_assign\n+\t\t\t\t (NULL_TREE, BIT_AND_EXPR, ptr,\n \t\t\t\t  build_int_cst\n \t\t\t\t  (TREE_TYPE (ptr),\n \t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n@@ -6495,8 +6486,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t  }\n \t\tcase dr_explicit_realign_optimized:\n \t\t  new_temp = copy_ssa_name (dataref_ptr);\n-\t\t  new_stmt = gimple_build_assign_with_ops\n-\t\t\t       (BIT_AND_EXPR, new_temp, dataref_ptr,\n+\t\t  new_stmt = gimple_build_assign\n+\t\t\t       (new_temp, BIT_AND_EXPR, dataref_ptr,\n \t\t\t\tbuild_int_cst\n \t\t\t\t  (TREE_TYPE (dataref_ptr),\n \t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n@@ -6525,10 +6516,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t  if (!realignment_token)\n \t\t    realignment_token = dataref_ptr;\n \t\t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-\t\t  new_stmt\n-\t\t    = gimple_build_assign_with_ops (REALIGN_LOAD_EXPR,\n-\t\t\t\t\t\t    vec_dest, msq, lsq,\n-\t\t\t\t\t\t    realignment_token);\n+\t\t  new_stmt = gimple_build_assign (vec_dest, REALIGN_LOAD_EXPR,\n+\t\t\t\t\t\t  msq, lsq, realignment_token);\n \t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t\t  gimple_assign_set_lhs (new_stmt, new_temp);\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);"}, {"sha": "bd238d57700d254dab64b17cf53209ea861987f9", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -8968,7 +8968,7 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n     {\n       tree tem = make_ssa_name (TREE_TYPE (op0));\n       gassign *newop\n-\t= gimple_build_assign_with_ops (BIT_XOR_EXPR, tem, op0, op1);\n+\t= gimple_build_assign (tem, BIT_XOR_EXPR, op0, op1);\n       gsi_insert_before (gsi, newop, GSI_SAME_STMT);\n       gimple_assign_set_rhs_with_ops (gsi, NOP_EXPR, tem);\n     }\n@@ -9735,7 +9735,7 @@ simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n      float conversion.  */\n   tem = make_ssa_name (build_nonstandard_integer_type\n \t\t\t  (GET_MODE_PRECISION (mode), 0));\n-  conv = gimple_build_assign_with_ops (NOP_EXPR, tem, rhs1);\n+  conv = gimple_build_assign (tem, NOP_EXPR, rhs1);\n   gsi_insert_before (gsi, conv, GSI_SAME_STMT);\n   gimple_assign_set_rhs1 (stmt, tem);\n   update_stmt (stmt);\n@@ -9794,8 +9794,7 @@ simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n   gimple g;\n   location_t loc = gimple_location (stmt);\n   if (is_ubsan)\n-    g = gimple_build_assign_with_ops (subcode, gimple_call_lhs (stmt),\n-\t\t\t\t      op0, op1);\n+    g = gimple_build_assign (gimple_call_lhs (stmt), subcode, op0, op1);\n   else\n     {\n       int prec = TYPE_PRECISION (type);\n@@ -9808,8 +9807,7 @@ simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n \top0 = fold_convert (utype, op0);\n       else if (!useless_type_conversion_p (utype, TREE_TYPE (op0)))\n \t{\n-\t  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t    make_ssa_name (utype), op0);\n+\t  g = gimple_build_assign (make_ssa_name (utype), NOP_EXPR, op0);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \t  op0 = gimple_assign_lhs (g);\n@@ -9818,26 +9816,24 @@ simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n \top1 = fold_convert (utype, op1);\n       else if (!useless_type_conversion_p (utype, TREE_TYPE (op1)))\n \t{\n-\t  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t    make_ssa_name (utype), op1);\n+\t  g = gimple_build_assign (make_ssa_name (utype), NOP_EXPR, op1);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \t  op1 = gimple_assign_lhs (g);\n \t}\n-      g = gimple_build_assign_with_ops (subcode, make_ssa_name (utype),\n-\t\t\t\t\top0, op1);\n+      g = gimple_build_assign (make_ssa_name (utype), subcode, op0, op1);\n       gimple_set_location (g, loc);\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);\n       if (utype != type)\n \t{\n-\t  g = gimple_build_assign_with_ops (NOP_EXPR, make_ssa_name (type),\n-\t\t\t\t\t    gimple_assign_lhs (g));\n+\t  g = gimple_build_assign (make_ssa_name (type), NOP_EXPR,\n+\t\t\t\t   gimple_assign_lhs (g));\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \t}\n-      g = gimple_build_assign_with_ops (COMPLEX_EXPR, gimple_call_lhs (stmt),\n-\t\t\t\t\tgimple_assign_lhs (g),\n-\t\t\t\t\tbuild_int_cst (type, ovf));\n+      g = gimple_build_assign (gimple_call_lhs (stmt), COMPLEX_EXPR,\n+\t\t\t       gimple_assign_lhs (g),\n+\t\t\t       build_int_cst (type, ovf));\n     }\n   gimple_set_location (g, loc);\n   gsi_replace (gsi, g, false);"}, {"sha": "d221e4565452fed120f654883c06a17bdc74f6f7", "filename": "gcc/tsan.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -500,7 +500,7 @@ instrument_builtin_call (gimple_stmt_iterator *gsi)\n \t\t\t\t\t\tTREE_TYPE (args[1])))\n \t\t  {\n \t\t    tree var = make_ssa_name (TREE_TYPE (lhs));\n-\t\t    g = gimple_build_assign_with_ops (NOP_EXPR, var, args[1]);\n+\t\t    g = gimple_build_assign (var, NOP_EXPR, args[1]);\n \t\t    gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \t\t    args[1] = var;\n \t\t  }\n@@ -509,17 +509,14 @@ instrument_builtin_call (gimple_stmt_iterator *gsi)\n \t\tif (tsan_atomic_table[i].code == BIT_NOT_EXPR)\n \t\t  {\n \t\t    tree var = make_ssa_name (TREE_TYPE (lhs));\n-\t\t    g = gimple_build_assign_with_ops (BIT_AND_EXPR, var,\n-\t\t\t\t\t\t      gimple_call_lhs (stmt),\n-\t\t\t\t\t\t      args[1]);\n+\t\t    g = gimple_build_assign (var, BIT_AND_EXPR,\n+\t\t\t\t\t     gimple_call_lhs (stmt), args[1]);\n \t\t    gsi_insert_after (gsi, g, GSI_NEW_STMT);\n-\t\t    g = gimple_build_assign_with_ops (BIT_NOT_EXPR, lhs, var);\n+\t\t    g = gimple_build_assign (lhs, BIT_NOT_EXPR, var);\n \t\t  }\n \t\telse\n-\t\t  g = gimple_build_assign_with_ops (tsan_atomic_table[i].code,\n-\t\t\t\t\t\t    lhs,\n-\t\t\t\t\t\t    gimple_call_lhs (stmt),\n-\t\t\t\t\t\t    args[1]);\n+\t\t  g = gimple_build_assign (lhs, tsan_atomic_table[i].code,\n+\t\t\t\t\t   gimple_call_lhs (stmt), args[1]);\n \t\tupdate_stmt (stmt);\n \t\tgsi_insert_after (gsi, g, GSI_NEW_STMT);\n \t      }\n@@ -553,9 +550,8 @@ instrument_builtin_call (gimple_stmt_iterator *gsi)\n \t    if (!useless_type_conversion_p (TREE_TYPE (t),\n \t\t\t\t\t    TREE_TYPE (args[1])))\n \t      {\n-\t\tg = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t\t  make_ssa_name (TREE_TYPE (t)),\n-\t\t\t\t\t\t  args[1]);\n+\t\tg = gimple_build_assign (make_ssa_name (TREE_TYPE (t)),\n+\t\t\t\t\t NOP_EXPR, args[1]);\n \t\tgsi_insert_before (gsi, g, GSI_SAME_STMT);\n \t\targs[1] = gimple_assign_lhs (g);\n \t      }\n@@ -577,9 +573,8 @@ instrument_builtin_call (gimple_stmt_iterator *gsi)\n \t\tt = make_ssa_name (TREE_TYPE (TREE_TYPE (decl)), stmt);\n \t\tcond = build2 (NE_EXPR, boolean_type_node, t,\n \t\t\t       build_int_cst (TREE_TYPE (t), 0));\n-\t\tg = gimple_build_assign_with_ops (COND_EXPR, lhs, cond,\n-\t\t\t\t\t\t  args[1],\n-\t\t\t\t\t\t  gimple_assign_lhs (g));\n+\t\tg = gimple_build_assign (lhs, COND_EXPR, cond, args[1],\n+\t\t\t\t\t gimple_assign_lhs (g));\n \t\tgimple_call_set_lhs (stmt, t);\n \t\tupdate_stmt (stmt);\n \t\tgsi_insert_after (gsi, g, GSI_NEW_STMT);"}, {"sha": "6d3caeefb389bf04f2f6c6585b551804f266ef1b", "filename": "gcc/ubsan.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -748,7 +748,7 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n       if (compare_tree_int (align, ptralign) == 1)\n \t{\n \t  check_align = make_ssa_name (pointer_sized_int_node);\n-\t  g = gimple_build_assign_with_ops (NOP_EXPR, check_align, ptr);\n+\t  g = gimple_build_assign (check_align, NOP_EXPR, ptr);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n \t}\n@@ -870,9 +870,8 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n \n       tree mask = build_int_cst (pointer_sized_int_node,\n \t\t\t\t tree_to_uhwi (align) - 1);\n-      g = gimple_build_assign_with_ops (BIT_AND_EXPR,\n-\t\t\t\t\tmake_ssa_name (pointer_sized_int_node),\n-\t\t\t\t\tcheck_align, mask);\n+      g = gimple_build_assign (make_ssa_name (pointer_sized_int_node),\n+\t\t\t       BIT_AND_EXPR, check_align, mask);\n       gimple_set_location (g, loc);\n       if (check_null)\n \tgsi_insert_after (&gsi2, g, GSI_NEW_STMT);\n@@ -944,7 +943,7 @@ ubsan_expand_objsize_ifn (gimple_stmt_iterator *gsi)\n \t      ? BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH\n \t      : BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_ABORT;\n \t  tree p = make_ssa_name (pointer_sized_int_node);\n-\t  g = gimple_build_assign_with_ops (NOP_EXPR, p, ptr);\n+\t  g = gimple_build_assign (p, NOP_EXPR, ptr);\n \t  gimple_set_location (g, loc);\n \t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \t  g = gimple_build_call (builtin_decl_explicit (bcode), 2, data, p);\n@@ -1185,7 +1184,7 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n   if (can_throw)\n     {\n       gimple_assign_set_lhs (stmt, urhs);\n-      g = gimple_build_assign_with_ops (NOP_EXPR, lhs, urhs);\n+      g = gimple_build_assign (lhs, NOP_EXPR, urhs);\n       gimple_set_location (g, loc);\n       edge e = find_fallthru_edge (gimple_bb (stmt)->succs);\n       gsi_insert_on_edge_immediate (e, g);\n@@ -1204,8 +1203,7 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n   maxv = fold_convert (utype, maxv);\n   if (!integer_zerop (minv))\n     {\n-      g = gimple_build_assign_with_ops (MINUS_EXPR, make_ssa_name (utype),\n-\t\t\t\t\turhs, minv);\n+      g = gimple_build_assign (make_ssa_name (utype), MINUS_EXPR, urhs, minv);\n       gimple_set_location (g, loc);\n       gsi_insert_before (gsi, g, GSI_SAME_STMT);\n     }"}, {"sha": "82a144fd21ef0e1f9ba6f16f7aa11d468f5f06eb", "filename": "gcc/value-prof.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=0d0e4a03e98cf8c3dbb1dc1a3ba15d2d9a6a5912", "patch": "@@ -775,13 +775,11 @@ gimple_divmod_fixed_value (gassign *stmt, tree value, int prob,\n   bb1end = stmt3;\n \n   tmp2 = create_tmp_reg (optype, \"PROF\");\n-  stmt1 = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt), tmp2,\n-\t\t\t\t\top1, tmp0);\n+  stmt1 = gimple_build_assign (tmp2, gimple_assign_rhs_code (stmt), op1, tmp0);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   bb2end = stmt1;\n \n-  stmt1 = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt), tmp2,\n-\t\t\t\t\top1, op2);\n+  stmt1 = gimple_build_assign (tmp2, gimple_assign_rhs_code (stmt), op1, op2);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   bb3end = stmt1;\n \n@@ -930,9 +928,9 @@ gimple_mod_pow2 (gassign *stmt, int prob, gcov_type count, gcov_type all)\n   result = create_tmp_reg (optype, \"PROF\");\n   tmp2 = make_temp_ssa_name (optype, NULL, \"PROF\");\n   tmp3 = make_temp_ssa_name (optype, NULL, \"PROF\");\n-  stmt2 = gimple_build_assign_with_ops (PLUS_EXPR, tmp2, op2,\n-\t\t\t\t\tbuild_int_cst (optype, -1));\n-  stmt3 = gimple_build_assign_with_ops (BIT_AND_EXPR, tmp3, tmp2, op2);\n+  stmt2 = gimple_build_assign (tmp2, PLUS_EXPR, op2,\n+\t\t\t       build_int_cst (optype, -1));\n+  stmt3 = gimple_build_assign (tmp3, BIT_AND_EXPR, tmp2, op2);\n   stmt4 = gimple_build_cond (NE_EXPR, tmp3, build_int_cst (optype, 0),\n \t\t\t     NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n@@ -941,12 +939,12 @@ gimple_mod_pow2 (gassign *stmt, int prob, gcov_type count, gcov_type all)\n   bb1end = stmt4;\n \n   /* tmp2 == op2-1 inherited from previous block.  */\n-  stmt1 = gimple_build_assign_with_ops (BIT_AND_EXPR, result, op1, tmp2);\n+  stmt1 = gimple_build_assign (result, BIT_AND_EXPR, op1, tmp2);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   bb2end = stmt1;\n \n-  stmt1 = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt), result,\n-\t\t\t\t\top1, op2);\n+  stmt1 = gimple_build_assign (result, gimple_assign_rhs_code (stmt),\n+\t\t\t       op1, op2);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   bb3end = stmt1;\n \n@@ -1094,16 +1092,16 @@ gimple_mod_subtract (gassign *stmt, int prob1, int prob2, int ncounts,\n \n   if (ncounts)\t/* Assumed to be 0 or 1 */\n     {\n-      stmt1 = gimple_build_assign_with_ops (MINUS_EXPR, result, result, tmp1);\n+      stmt1 = gimple_build_assign (result, MINUS_EXPR, result, tmp1);\n       stmt2 = gimple_build_cond (LT_EXPR, result, tmp1, NULL_TREE, NULL_TREE);\n       gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n       gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n       bb2end = stmt2;\n     }\n \n   /* Fallback case. */\n-  stmt1 = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt), result,\n-\t\t\t\t\tresult, tmp1);\n+  stmt1 = gimple_build_assign (result, gimple_assign_rhs_code (stmt),\n+\t\t\t       result, tmp1);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   bb3end = stmt1;\n "}]}