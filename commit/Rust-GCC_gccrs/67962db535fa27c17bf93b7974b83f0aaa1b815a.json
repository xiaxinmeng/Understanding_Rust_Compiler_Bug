{"sha": "67962db535fa27c17bf93b7974b83f0aaa1b815a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc5NjJkYjUzNWZhMjdjMTdiZjkzYjc5NzRiODNmMGFhYTFiODE1YQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-03-12T17:38:30Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-03-12T17:38:30Z"}, "message": "combine.c (unmentioned_reg_p): New function to check whether an expression is a \"specialization\" of another, i.e.\n\n\n\t* combine.c (unmentioned_reg_p): New function to check whether an\n\texpression is a \"specialization\" of another, i.e. that there are\n\tno registers or memory references mentioned in the first that don't\n\tappear in the second.\n\t(unmentioned_reg_p_1): New helper subroutine of unmentioned_reg_p.\n\t(combine_instructions): Also try combining instructions using the\n\tREG_EQUAL note from a preceding log-linked instruction.\n\nFrom-SVN: r79398", "tree": {"sha": "4583547ab2a563ddc71a04db0660fe8ef047105a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4583547ab2a563ddc71a04db0660fe8ef047105a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67962db535fa27c17bf93b7974b83f0aaa1b815a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67962db535fa27c17bf93b7974b83f0aaa1b815a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67962db535fa27c17bf93b7974b83f0aaa1b815a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67962db535fa27c17bf93b7974b83f0aaa1b815a/comments", "author": null, "committer": null, "parents": [{"sha": "8937b6a2095b723cbdb1fd2be7cd6011c52fce1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8937b6a2095b723cbdb1fd2be7cd6011c52fce1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8937b6a2095b723cbdb1fd2be7cd6011c52fce1a"}], "stats": {"total": 64, "additions": 64, "deletions": 0}, "files": [{"sha": "70c720cc760c8aefcc84359ea3ed7fc5b7837180", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67962db535fa27c17bf93b7974b83f0aaa1b815a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67962db535fa27c17bf93b7974b83f0aaa1b815a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67962db535fa27c17bf93b7974b83f0aaa1b815a", "patch": "@@ -1,3 +1,13 @@\n+2004-03-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* combine.c (unmentioned_reg_p): New function to check whether an\n+\texpression is a \"specialization\" of another, i.e. that there are\n+\tno registers or memory references mentioned in the first that don't\n+\tappear in the second.\n+\t(unmentioned_reg_p_1): New helper subroutine of unmentioned_reg_p.\n+\t(combine_instructions): Also try combining instructions using the\n+\tREG_EQUAL note from a preceding log-linked instruction.\n+\n 2004-03-12  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.c (ix86_split_ashrdi): Optimize shift by 63."}, {"sha": "a32e479132ea81d48325c5708c927a51e2b016aa", "filename": "gcc/combine.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67962db535fa27c17bf93b7974b83f0aaa1b815a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67962db535fa27c17bf93b7974b83f0aaa1b815a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=67962db535fa27c17bf93b7974b83f0aaa1b815a", "patch": "@@ -407,6 +407,8 @@ static int insn_cuid (rtx);\n static void record_promoted_value (rtx, rtx);\n static rtx reversed_comparison (rtx, enum machine_mode, rtx, rtx);\n static enum rtx_code combine_reversed_comparison_code (rtx);\n+static int unmentioned_reg_p_1 (rtx *, void *);\n+static bool unmentioned_reg_p (rtx, rtx);\n \f\n /* Substitute NEWVAL, an rtx expression, into INTO, a place in some\n    insn.  The substitution can be undone by undo_all.  If INTO is already\n@@ -720,6 +722,31 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t\t\t\t   &new_direct_jump_p)) != 0)\n \t\t    goto retry;\n \n+\t      /* Try this insn with each REG_EQUAL note it links back to.  */\n+\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n+\t\t{\n+\t\t  rtx set, note;\n+\t\t  rtx temp = XEXP (links, 0);\n+\t\t  if ((set = single_set (temp)) != 0\n+\t\t      && (note = find_reg_equal_equiv_note (temp)) != 0\n+\t\t      && GET_CODE (XEXP (note, 0)) != EXPR_LIST\n+\t\t      /* Avoid using a register that may already been marked\n+\t\t\t dead by an earlier instruction.  */\n+\t\t      && ! unmentioned_reg_p (XEXP (note, 0), SET_SRC (set)))\n+\t\t    {\n+\t\t      /* Temporarily replace the set's source with the\n+\t\t\t contents of the REG_EQUAL note.  The insn will\n+\t\t\t be deleted or recognized by try_combine.  */\n+\t\t      rtx orig = SET_SRC (set);\n+\t\t      SET_SRC (set) = XEXP (note, 0);\n+\t\t      next = try_combine (insn, temp, NULL_RTX,\n+\t\t\t\t\t  &new_direct_jump_p);\n+\t\t      if (next)\n+\t\t\tgoto retry;\n+\t\t      SET_SRC (set) = orig;\n+\t\t    }\n+\t\t}\n+\n \t      if (GET_CODE (insn) != NOTE)\n \t\trecord_dead_and_set_regs (insn);\n \n@@ -12979,6 +13006,33 @@ distribute_links (rtx links)\n     }\n }\n \f\n+/* Subroutine of unmentioned_reg_p and callback from for_each_rtx.\n+   Check whether the expression pointer to by LOC is a register or\n+   memory, and if so return 1 if it isn't mentioned in the rtx EXPR.\n+   Otherwise return zero.  */\n+\n+static int\n+unmentioned_reg_p_1 (rtx *loc, void *expr)\n+{\n+  rtx x = *loc;\n+\n+  if (x != NULL_RTX\n+      && (GET_CODE (x) == REG || GET_CODE (x) == MEM)\n+      && ! reg_mentioned_p (x, (rtx) expr))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Check for any register or memory mentioned in EQUIV that is not\n+   mentioned in EXPR.  This is used to restrict EQUIV to \"specializations\"\n+   of EXPR where some registers may have been replaced by constants.  */\n+\n+static bool\n+unmentioned_reg_p (rtx equiv, rtx expr)\n+{\n+  return for_each_rtx (&equiv, unmentioned_reg_p_1, expr);\n+}\n+\f\n /* Compute INSN_CUID for INSN, which is an insn made by combine.  */\n \n static int"}]}