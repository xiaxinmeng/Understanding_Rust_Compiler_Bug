{"sha": "6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAxOWMwZmM2MmIyMGRiNzRlMWY5ZjEwZWUwMGUxMDA1MzEzY2IwYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-08-23T20:41:32Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-08-23T20:41:32Z"}, "message": "rs6000.c (rs6000_expand_vector_init): Set initialization of all 0's to the 0 constant, instead of directly generating XOR.\n\n[gcc]\n2016-08-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_init): Set\n\tinitialization of all 0's to the 0 constant, instead of directly\n\tgenerating XOR.  Add support for V4SImode vector initialization on\n\t64-bit systems with direct move, and rework the ISA 3.0 V4SImode\n\tinitialization.  Change variables used in V4SFmode vector\n\tintialization.  For V4SFmode vector splat on ISA 3.0, make sure\n\tany memory addresses are in index form.  Add support for using\n\tVSPLTH/VSPLTB to initialize vector short and vector char vectors\n\twith all of the same element.\n\t(regno_or_subregno): New helper function to return a register\n\tnumber for either REG or SUBREG.\n\t(rs6000_adjust_vec_address): Do not generate ADDI <reg>,R0,<num>.\n\tUse regno_or_subregno where possible.\n\t(rs6000_split_v4si_init_di_reg): New helper function to build up a\n\tDImode value from two SImode values in order to generate V4SImode\n\tvector initialization on 64-bit systems with direct move.\n\t(rs6000_split_v4si_init): Split up the insns for a V4SImode vector\n\tinitialization.\n\t(rtx_is_swappable_p): V4SImode vector initialization insn is not\n\tswappable.\n\t* config/rs6000/rs6000-protos.h (rs6000_split_v4si_init): Add\n\tdeclaration.\n\t* config/rs6000/vsx.md (VSX_SPLAT_I): New mode iterators and\n\tattributes to initialize V8HImode and V16QImode vectors with the\n\tsame element.\n\t(VSX_SPLAT_COUNT): Likewise.\n\t(VSX_SPLAT_SUFFIX): Likewise.\n\t(UNSPEC_VSX_VEC_INIT): New unspec.\n\t(vsx_concat_v2sf): Eliminate using 'preferred' register classes.\n\tAllow SFmode values to come from Altivec registers.\n\t(vsx_init_v4si): New insn/split for V4SImode vector initialization\n\ton 64-bit systems with direct move.\n\t(vsx_splat_<mode>, VSX_W iterator): Rework V4SImode and V4SFmode\n\tvector initializations, to allow V4SImode vector initializations\n\ton 64-bit systems with direct move.\n\t(vsx_splat_v4si): Likewise.\n\t(vsx_splat_v4si_di): Likewise.\n\t(vsx_splat_v4sf): Likewise.\n\t(vsx_splat_v4sf_internal): Likewise.\n\t(vsx_xxspltw_<mode>, VSX_W iterator): Eliminate using 'preferred'\n\tregister classes.\n\t(vsx_xxspltw_<mode>_direct, VSX_W iterator): Likewise.\n\t(vsx_vsplt<VSX_SPLAT_SUFFIX>_di): New insns to support\n\tinitializing V8HImode and V16QImode vectors with the same\n\telement.\n\t* config/rs6000/rs6000.h (TARGET_DIRECT_MOVE_64BIT): Disallow\n\toptimization if -maltivec=be.\n\n[gcc/testsuite]\n2016-08-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vec-init-1.c: Add tests where the vector is\n\tbeing created from pointers to memory locations.\n\t* gcc.target/powerpc/vec-init-2.c: Likewise.\n\nFrom-SVN: r239712", "tree": {"sha": "8bb881234d48d0170f62ad64e7a492375c407713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bb881234d48d0170f62ad64e7a492375c407713"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/comments", "author": null, "committer": null, "parents": [{"sha": "d672cded1fc033ff53b3b644272512822364703c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d672cded1fc033ff53b3b644272512822364703c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d672cded1fc033ff53b3b644272512822364703c"}], "stats": {"total": 417, "additions": 365, "deletions": 52}, "files": [{"sha": "e1ecbed5e151e165df0bc15c2f6b27bd82bf7cf0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "patch": "@@ -1,3 +1,53 @@\n+2016-08-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_init): Set\n+\tinitialization of all 0's to the 0 constant, instead of directly\n+\tgenerating XOR.  Add support for V4SImode vector initialization on\n+\t64-bit systems with direct move, and rework the ISA 3.0 V4SImode\n+\tinitialization.  Change variables used in V4SFmode vector\n+\tintialization.  For V4SFmode vector splat on ISA 3.0, make sure\n+\tany memory addresses are in index form.  Add support for using\n+\tVSPLTH/VSPLTB to initialize vector short and vector char vectors\n+\twith all of the same element.\n+\t(regno_or_subregno): New helper function to return a register\n+\tnumber for either REG or SUBREG.\n+\t(rs6000_adjust_vec_address): Do not generate ADDI <reg>,R0,<num>.\n+\tUse regno_or_subregno where possible.\n+\t(rs6000_split_v4si_init_di_reg): New helper function to build up a\n+\tDImode value from two SImode values in order to generate V4SImode\n+\tvector initialization on 64-bit systems with direct move.\n+\t(rs6000_split_v4si_init): Split up the insns for a V4SImode vector\n+\tinitialization.\n+\t(rtx_is_swappable_p): V4SImode vector initialization insn is not\n+\tswappable.\n+\t* config/rs6000/rs6000-protos.h (rs6000_split_v4si_init): Add\n+\tdeclaration.\n+\t* config/rs6000/vsx.md (VSX_SPLAT_I): New mode iterators and\n+\tattributes to initialize V8HImode and V16QImode vectors with the\n+\tsame element.\n+\t(VSX_SPLAT_COUNT): Likewise.\n+\t(VSX_SPLAT_SUFFIX): Likewise.\n+\t(UNSPEC_VSX_VEC_INIT): New unspec.\n+\t(vsx_concat_v2sf): Eliminate using 'preferred' register classes.\n+\tAllow SFmode values to come from Altivec registers.\n+\t(vsx_init_v4si): New insn/split for V4SImode vector initialization\n+\ton 64-bit systems with direct move.\n+\t(vsx_splat_<mode>, VSX_W iterator): Rework V4SImode and V4SFmode\n+\tvector initializations, to allow V4SImode vector initializations\n+\ton 64-bit systems with direct move.\n+\t(vsx_splat_v4si): Likewise.\n+\t(vsx_splat_v4si_di): Likewise.\n+\t(vsx_splat_v4sf): Likewise.\n+\t(vsx_splat_v4sf_internal): Likewise.\n+\t(vsx_xxspltw_<mode>, VSX_W iterator): Eliminate using 'preferred'\n+\tregister classes.\n+\t(vsx_xxspltw_<mode>_direct, VSX_W iterator): Likewise.\n+\t(vsx_vsplt<VSX_SPLAT_SUFFIX>_di): New insns to support\n+\tinitializing V8HImode and V16QImode vectors with the same\n+\telement.\n+\t* config/rs6000/rs6000.h (TARGET_DIRECT_MOVE_64BIT): Disallow\n+\toptimization if -maltivec=be.\n+\n 2016-08-23  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* config/arm/arm.md (arm_movqi_insn): Swap predicable_short_it"}, {"sha": "6ed7024da1648d6dfefdf910a4771bca5a1af32d", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "patch": "@@ -65,6 +65,7 @@ extern void rs6000_expand_vector_set (rtx, rtx, int);\n extern void rs6000_expand_vector_extract (rtx, rtx, rtx);\n extern void rs6000_split_vec_extract_var (rtx, rtx, rtx, rtx, rtx);\n extern rtx rs6000_adjust_vec_address (rtx, rtx, rtx, rtx, machine_mode);\n+extern void rs6000_split_v4si_init (rtx []);\n extern bool altivec_expand_vec_perm_const (rtx op[4]);\n extern void altivec_expand_vec_perm_le (rtx op[4]);\n extern bool rs6000_expand_vec_perm_const (rtx op[4]);"}, {"sha": "4de70ea86efd09d3df0d8d39091cce8d6b4c4743", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 185, "deletions": 21, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "patch": "@@ -6695,7 +6695,7 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n       if ((int_vector_p || TARGET_VSX) && all_const_zero)\n \t{\n \t  /* Zero register.  */\n-\t  emit_insn (gen_rtx_SET (target, gen_rtx_XOR (mode, target, target)));\n+\t  emit_move_insn (target, CONST0_RTX (mode));\n \t  return;\n \t}\n       else if (int_vector_p && easy_vector_constant (const_vec, mode))\n@@ -6738,32 +6738,69 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n       return;\n     }\n \n-  /* Word values on ISA 3.0 can use mtvsrws, lxvwsx, or vspltisw.  V4SF is\n-     complicated since scalars are stored as doubles in the registers.  */\n-  if (TARGET_P9_VECTOR && mode == V4SImode && all_same\n-      && VECTOR_MEM_VSX_P (mode))\n+  /* Special case initializing vector int if we are on 64-bit systems with\n+     direct move or we have the ISA 3.0 instructions.  */\n+  if (mode == V4SImode  && VECTOR_MEM_VSX_P (V4SImode)\n+      && TARGET_DIRECT_MOVE_64BIT)\n     {\n-      emit_insn (gen_vsx_splat_v4si (target, XVECEXP (vals, 0, 0)));\n-      return;\n+      if (all_same)\n+\t{\n+\t  rtx element0 = XVECEXP (vals, 0, 0);\n+\t  if (MEM_P (element0))\n+\t    element0 = rs6000_address_for_fpconvert (element0);\n+\t  else\n+\t    element0 = force_reg (SImode, element0);\n+\n+\t  if (TARGET_P9_VECTOR)\n+\t    emit_insn (gen_vsx_splat_v4si (target, element0));\n+\t  else\n+\t    {\n+\t      rtx tmp = gen_reg_rtx (DImode);\n+\t      emit_insn (gen_zero_extendsidi2 (tmp, element0));\n+\t      emit_insn (gen_vsx_splat_v4si_di (target, tmp));\n+\t    }\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  rtx elements[4];\n+\t  size_t i;\n+\n+\t  for (i = 0; i < 4; i++)\n+\t    {\n+\t      elements[i] = XVECEXP (vals, 0, i);\n+\t      if (!CONST_INT_P (elements[i]) && !REG_P (elements[i]))\n+\t\telements[i] = copy_to_mode_reg (SImode, elements[i]);\n+\t    }\n+\n+\t  emit_insn (gen_vsx_init_v4si (target, elements[0], elements[1],\n+\t\t\t\t\telements[2], elements[3]));\n+\t  return;\n+\t}\n     }\n \n   /* With single precision floating point on VSX, know that internally single\n      precision is actually represented as a double, and either make 2 V2DF\n      vectors, and convert these vectors to single precision, or do one\n      conversion, and splat the result to the other elements.  */\n-  if (mode == V4SFmode && VECTOR_MEM_VSX_P (mode))\n+  if (mode == V4SFmode && VECTOR_MEM_VSX_P (V4SFmode))\n     {\n       if (all_same)\n \t{\n-\t  rtx op0 = XVECEXP (vals, 0, 0);\n+\t  rtx element0 = XVECEXP (vals, 0, 0);\n \n \t  if (TARGET_P9_VECTOR)\n-\t    emit_insn (gen_vsx_splat_v4sf (target, op0));\n+\t    {\n+\t      if (MEM_P (element0))\n+\t\telement0 = rs6000_address_for_fpconvert (element0);\n+\n+\t      emit_insn (gen_vsx_splat_v4sf (target, element0));\n+\t    }\n \n \t  else\n \t    {\n \t      rtx freg = gen_reg_rtx (V4SFmode);\n-\t      rtx sreg = force_reg (SFmode, op0);\n+\t      rtx sreg = force_reg (SFmode, element0);\n \t      rtx cvt  = (TARGET_XSCVDPSPN\n \t\t\t  ? gen_vsx_xscvdpspn_scalar (freg, sreg)\n \t\t\t  : gen_vsx_xscvdpsp_scalar (freg, sreg));\n@@ -6793,6 +6830,32 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n       return;\n     }\n \n+  /* Special case initializing vector short/char that are splats if we are on\n+     64-bit systems with direct move.  */\n+  if (all_same && TARGET_DIRECT_MOVE_64BIT\n+      && (mode == V16QImode || mode == V8HImode))\n+    {\n+      rtx op0 = XVECEXP (vals, 0, 0);\n+      rtx di_tmp = gen_reg_rtx (DImode);\n+\n+      if (!REG_P (op0))\n+\top0 = force_reg (GET_MODE_INNER (mode), op0);\n+\n+      if (mode == V16QImode)\n+\t{\n+\t  emit_insn (gen_zero_extendqidi2 (di_tmp, op0));\n+\t  emit_insn (gen_vsx_vspltb_di (target, di_tmp));\n+\t  return;\n+\t}\n+\n+      if (mode == V8HImode)\n+\t{\n+\t  emit_insn (gen_zero_extendhidi2 (di_tmp, op0));\n+\t  emit_insn (gen_vsx_vsplth_di (target, di_tmp));\n+\t  return;\n+\t}\n+    }\n+\n   /* Store value to stack temp.  Load vector element.  Splat.  However, splat\n      of 64-bit items is not supported on Altivec.  */\n   if (all_same && GET_MODE_SIZE (inner_mode) <= 4)\n@@ -7032,6 +7095,18 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n   emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));\n }\n \n+/* Helper function to return the register number of a RTX.  */\n+static inline int\n+regno_or_subregno (rtx op)\n+{\n+  if (REG_P (op))\n+    return REGNO (op);\n+  else if (SUBREG_P (op))\n+    return subreg_regno (op);\n+  else\n+    gcc_unreachable ();\n+}\n+\n /* Adjust a memory address (MEM) of a vector type to point to a scalar field\n    within the vector (ELEMENT) with a mode (SCALAR_MODE).  Use a base register\n    temporary (BASE_TMP) to fixup the address.  Return the new memory address\n@@ -7111,14 +7186,22 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n \t}\n       else\n \t{\n-\t  if (REG_P (op1) || SUBREG_P (op1))\n+\t  bool op1_reg_p = (REG_P (op1) || SUBREG_P (op1));\n+\t  bool ele_reg_p = (REG_P (element_offset) || SUBREG_P (element_offset));\n+\n+\t  /* Note, ADDI requires the register being added to be a base\n+\t     register.  If the register was R0, load it up into the temporary\n+\t     and do the add.  */\n+\t  if (op1_reg_p\n+\t      && (ele_reg_p || reg_or_subregno (op1) != FIRST_GPR_REGNO))\n \t    {\n \t      insn = gen_add3_insn (base_tmp, op1, element_offset);\n \t      gcc_assert (insn != NULL_RTX);\n \t      emit_insn (insn);\n \t    }\n \n-\t  else if (REG_P (element_offset) || SUBREG_P (element_offset))\n+\t  else if (ele_reg_p\n+\t\t   && reg_or_subregno (element_offset) != FIRST_GPR_REGNO)\n \t    {\n \t      insn = gen_add3_insn (base_tmp, element_offset, op1);\n \t      gcc_assert (insn != NULL_RTX);\n@@ -7147,14 +7230,7 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n     {\n       rtx op1 = XEXP (new_addr, 1);\n       addr_mask_type addr_mask;\n-      int scalar_regno;\n-\n-      if (REG_P (scalar_reg))\n-\tscalar_regno = REGNO (scalar_reg);\n-      else if (SUBREG_P (scalar_reg))\n-\tscalar_regno = subreg_regno (scalar_reg);\n-      else\n-\tgcc_unreachable ();\n+      int scalar_regno = regno_or_subregno (scalar_reg);\n \n       gcc_assert (scalar_regno < FIRST_PSEUDO_REGISTER);\n       if (INT_REGNO_P (scalar_regno))\n@@ -7321,6 +7397,93 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n     gcc_unreachable ();\n  }\n \n+/* Helper function for rs6000_split_v4si_init to build up a DImode value from\n+   two SImode values.  */\n+\n+static void\n+rs6000_split_v4si_init_di_reg (rtx dest, rtx si1, rtx si2, rtx tmp)\n+{\n+  const unsigned HOST_WIDE_INT mask_32bit = HOST_WIDE_INT_C (0xffffffff);\n+\n+  if (CONST_INT_P (si1) && CONST_INT_P (si2))\n+    {\n+      unsigned HOST_WIDE_INT const1 = (UINTVAL (si1) & mask_32bit) << 32;\n+      unsigned HOST_WIDE_INT const2 = UINTVAL (si2) & mask_32bit;\n+\n+      emit_move_insn (dest, GEN_INT (const1 | const2));\n+      return;\n+    }\n+\n+  /* Put si1 into upper 32-bits of dest.  */\n+  if (CONST_INT_P (si1))\n+    emit_move_insn (dest, GEN_INT ((UINTVAL (si1) & mask_32bit) << 32));\n+  else\n+    {\n+      /* Generate RLDIC.  */\n+      rtx si1_di = gen_rtx_REG (DImode, regno_or_subregno (si1));\n+      rtx shift_rtx = gen_rtx_ASHIFT (DImode, si1_di, GEN_INT (32));\n+      rtx mask_rtx = GEN_INT (mask_32bit << 32);\n+      rtx and_rtx = gen_rtx_AND (DImode, shift_rtx, mask_rtx);\n+      gcc_assert (!reg_overlap_mentioned_p (dest, si1));\n+      emit_insn (gen_rtx_SET (dest, and_rtx));\n+    }\n+\n+  /* Put si2 into the temporary.  */\n+  gcc_assert (!reg_overlap_mentioned_p (dest, tmp));\n+  if (CONST_INT_P (si2))\n+    emit_move_insn (tmp, GEN_INT (UINTVAL (si2) & mask_32bit));\n+  else\n+    emit_insn (gen_zero_extendsidi2 (tmp, si2));\n+\n+  /* Combine the two parts.  */\n+  emit_insn (gen_iordi3 (dest, dest, tmp));\n+  return;\n+}\n+\n+/* Split a V4SI initialization.  */\n+\n+void\n+rs6000_split_v4si_init (rtx operands[])\n+{\n+  rtx dest = operands[0];\n+\n+  /* Destination is a GPR, build up the two DImode parts in place.  */\n+  if (REG_P (dest) || SUBREG_P (dest))\n+    {\n+      int d_regno = regno_or_subregno (dest);\n+      rtx scalar1 = operands[1];\n+      rtx scalar2 = operands[2];\n+      rtx scalar3 = operands[3];\n+      rtx scalar4 = operands[4];\n+      rtx tmp1 = operands[5];\n+      rtx tmp2 = operands[6];\n+\n+      /* Even though we only need one temporary (plus the destination, which\n+\t has an early clobber constraint, try to use two temporaries, one for\n+\t each double word created.  That way the 2nd insn scheduling pass can\n+\t rearrange things so the two parts are done in parallel.  */\n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  rtx di_lo = gen_rtx_REG (DImode, d_regno);\n+\t  rtx di_hi = gen_rtx_REG (DImode, d_regno + 1);\n+\t  rs6000_split_v4si_init_di_reg (di_lo, scalar1, scalar2, tmp1);\n+\t  rs6000_split_v4si_init_di_reg (di_hi, scalar3, scalar4, tmp2);\n+\t}\n+      else\n+\t{\n+\t  rtx di_lo = gen_rtx_REG (DImode, d_regno + 1);\n+\t  rtx di_hi = gen_rtx_REG (DImode, d_regno);\n+\t  gcc_assert (!VECTOR_ELT_ORDER_BIG);\n+\t  rs6000_split_v4si_init_di_reg (di_lo, scalar4, scalar3, tmp1);\n+\t  rs6000_split_v4si_init_di_reg (di_hi, scalar2, scalar1, tmp2);\n+\t}\n+      return;\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+}\n+\n /* Return TRUE if OP is an invalid SUBREG operation on the e500.  */\n \n bool\n@@ -39054,6 +39217,7 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n \t  case UNSPEC_VSX_CVSPDPN:\n \t  case UNSPEC_VSX_EXTRACT:\n \t  case UNSPEC_VSX_VSLO:\n+\t  case UNSPEC_VSX_VEC_INIT:\n \t    return 0;\n \t  case UNSPEC_VSPLT_DIRECT:\n \t    *special = SH_SPLAT;"}, {"sha": "1609abd68bc0da9da6a8a59e90fc5f5ec175ef23", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "patch": "@@ -760,13 +760,15 @@ extern int rs6000_vector_align[];\n \t\t\t\t && TARGET_SINGLE_FLOAT\t\t\t\\\n \t\t\t\t && TARGET_DOUBLE_FLOAT)\n \n-/* Macro to say whether we can do optimization where we need to do parts of the\n-   calculation in 64-bit GPRs and then is transfered to the vector\n-   registers.  */\n+/* Macro to say whether we can do optimizations where we need to do parts of\n+   the calculation in 64-bit GPRs and then is transfered to the vector\n+   registers.  Do not allow -maltivec=be for these optimizations, because it\n+   adds to the complexity of the code.  */\n #define TARGET_DIRECT_MOVE_64BIT\t(TARGET_DIRECT_MOVE\t\t\\\n \t\t\t\t\t && TARGET_P8_VECTOR\t\t\\\n \t\t\t\t\t && TARGET_POWERPC64\t\t\\\n-\t\t\t\t\t && TARGET_UPPER_REGS_DI)\n+\t\t\t\t\t && TARGET_UPPER_REGS_DI\t\\\n+\t\t\t\t\t && (rs6000_altivec_element_order != 2))\n \n /* Whether the various reciprocal divide/square root estimate instructions\n    exist, and whether we should automatically generate code for the instruction"}, {"sha": "60917c541c727afa7673640ca8fb7b7c95563338", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 69, "deletions": 27, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "patch": "@@ -281,6 +281,16 @@\n \t\t\t  (V8HI  \"v\")\n \t\t\t  (V4SI  \"wa\")])\n \n+;; Iterator for the 2 short vector types to do a splat from an integer\n+(define_mode_iterator VSX_SPLAT_I [V16QI V8HI])\n+\n+;; Mode attribute to give the count for the splat instruction to splat\n+;; the value in the 64-bit integer slot\n+(define_mode_attr VSX_SPLAT_COUNT [(V16QI \"7\") (V8HI \"3\")])\n+\n+;; Mode attribute to give the suffix for the splat instruction\n+(define_mode_attr VSX_SPLAT_SUFFIX [(V16QI \"b\") (V8HI \"h\")])\n+\n ;; Constants for creating unspecs\n (define_c_enum \"unspec\"\n   [UNSPEC_VSX_CONCAT\n@@ -323,6 +333,7 @@\n    UNSPEC_VSX_VXSIG\n    UNSPEC_VSX_VIEXP\n    UNSPEC_VSX_VTSTDC\n+   UNSPEC_VSX_VEC_INIT\n   ])\n \n ;; VSX moves\n@@ -1950,10 +1961,10 @@\n ;; together, relying on the fact that internally scalar floats are represented\n ;; as doubles.  This is used to initialize a V4SF vector with 4 floats\n (define_insn \"vsx_concat_v2sf\"\n-  [(set (match_operand:V2DF 0 \"vsx_register_operand\" \"=wd,?wa\")\n+  [(set (match_operand:V2DF 0 \"vsx_register_operand\" \"=wa\")\n \t(unspec:V2DF\n-\t [(match_operand:SF 1 \"vsx_register_operand\" \"f,f\")\n-\t  (match_operand:SF 2 \"vsx_register_operand\" \"f,f\")]\n+\t [(match_operand:SF 1 \"vsx_register_operand\" \"ww\")\n+\t  (match_operand:SF 2 \"vsx_register_operand\" \"ww\")]\n \t UNSPEC_VSX_CONCAT))]\n   \"VECTOR_MEM_VSX_P (V2DFmode)\"\n {\n@@ -1964,6 +1975,26 @@\n }\n   [(set_attr \"type\" \"vecperm\")])\n \n+;; V4SImode initialization splitter\n+(define_insn_and_split \"vsx_init_v4si\"\n+  [(set (match_operand:V4SI 0 \"gpc_reg_operand\" \"=&r\")\n+\t(unspec:V4SI\n+\t [(match_operand:SI 1 \"reg_or_cint_operand\" \"rn\")\n+\t  (match_operand:SI 2 \"reg_or_cint_operand\" \"rn\")\n+\t  (match_operand:SI 3 \"reg_or_cint_operand\" \"rn\")\n+\t  (match_operand:SI 4 \"reg_or_cint_operand\" \"rn\")]\n+\t UNSPEC_VSX_VEC_INIT))\n+   (clobber (match_scratch:DI 5 \"=&r\"))\n+   (clobber (match_scratch:DI 6 \"=&r\"))]\n+   \"VECTOR_MEM_VSX_P (V4SImode) && TARGET_DIRECT_MOVE_64BIT\"\n+   \"#\"\n+   \"&& reload_completed\"\n+   [(const_int 0)]\n+{\n+  rs6000_split_v4si_init (operands);\n+  DONE;\n+})\n+\n ;; xxpermdi for little endian loads and stores.  We need several of\n ;; these since the form of the PARALLEL differs by mode.\n (define_insn \"*vsx_xxpermdi2_le_<mode>\"\n@@ -2674,32 +2705,33 @@\n    mtvsrdd %x0,%1,%1\"\n   [(set_attr \"type\" \"vecperm,vecload,vecperm\")])\n \n-;; V4SI splat (ISA 3.0)\n-;; When SI's are allowed in VSX registers, add XXSPLTW support\n-(define_expand \"vsx_splat_<mode>\"\n-  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"\")\n-\t(vec_duplicate:VSX_W\n-\t (match_operand:<VS_scalar> 1 \"splat_input_operand\" \"\")))]\n-  \"TARGET_P9_VECTOR\"\n-{\n-  if (MEM_P (operands[1]))\n-    operands[1] = rs6000_address_for_fpconvert (operands[1]);\n-  else if (!REG_P (operands[1]))\n-    operands[1] = force_reg (<VS_scalar>mode, operands[1]);\n-})\n-\n-(define_insn \"*vsx_splat_v4si_internal\"\n-  [(set (match_operand:V4SI 0 \"vsx_register_operand\" \"=wa,wa\")\n+;; V4SI splat support\n+(define_insn \"vsx_splat_v4si\"\n+  [(set (match_operand:V4SI 0 \"vsx_register_operand\" \"=we,we\")\n \t(vec_duplicate:V4SI\n \t (match_operand:SI 1 \"splat_input_operand\" \"r,Z\")))]\n   \"TARGET_P9_VECTOR\"\n   \"@\n    mtvsrws %x0,%1\n    lxvwsx %x0,%y1\"\n-  [(set_attr \"type\" \"mftgpr,vecload\")])\n+  [(set_attr \"type\" \"vecperm,vecload\")])\n+\n+;; SImode is not currently allowed in vector registers.  This pattern\n+;; allows us to use direct move to get the value in a vector register\n+;; so that we can use XXSPLTW\n+(define_insn \"vsx_splat_v4si_di\"\n+  [(set (match_operand:V4SI 0 \"vsx_register_operand\" \"=wa,we\")\n+\t(vec_duplicate:V4SI\n+\t (truncate:SI\n+\t  (match_operand:DI 1 \"gpc_reg_operand\" \"wj,r\"))))]\n+  \"VECTOR_MEM_VSX_P (V4SImode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"@\n+   xxspltw %x0,%x1,1\n+   mtvsrws %x0,%1\"\n+  [(set_attr \"type\" \"vecperm\")])\n \n ;; V4SF splat (ISA 3.0)\n-(define_insn_and_split \"*vsx_splat_v4sf_internal\"\n+(define_insn_and_split \"vsx_splat_v4sf\"\n   [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=wa,wa,wa\")\n \t(vec_duplicate:V4SF\n \t (match_operand:SF 1 \"splat_input_operand\" \"Z,wy,r\")))]\n@@ -2720,12 +2752,12 @@\n \n ;; V4SF/V4SI splat from a vector element\n (define_insn \"vsx_xxspltw_<mode>\"\n-  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?<VSa>\")\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=<VSa>\")\n \t(vec_duplicate:VSX_W\n \t (vec_select:<VS_scalar>\n-\t  (match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,<VSa>\")\n+\t  (match_operand:VSX_W 1 \"vsx_register_operand\" \"<VSa>\")\n \t  (parallel\n-\t   [(match_operand:QI 2 \"u5bit_cint_operand\" \"i,i\")]))))]\n+\t   [(match_operand:QI 2 \"u5bit_cint_operand\" \"n\")]))))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n   if (!BYTES_BIG_ENDIAN)\n@@ -2736,14 +2768,24 @@\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"vsx_xxspltw_<mode>_direct\"\n-  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?<VSa>\")\n-        (unspec:VSX_W [(match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,<VSa>\")\n-                       (match_operand:QI 2 \"u5bit_cint_operand\" \"i,i\")]\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=<VSa>\")\n+        (unspec:VSX_W [(match_operand:VSX_W 1 \"vsx_register_operand\" \"<VSa>\")\n+                       (match_operand:QI 2 \"u5bit_cint_operand\" \"i\")]\n                       UNSPEC_VSX_XXSPLTW))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxspltw %x0,%x1,%2\"\n   [(set_attr \"type\" \"vecperm\")])\n \n+;; V16QI/V8HI splat support on ISA 2.07\n+(define_insn \"vsx_vsplt<VSX_SPLAT_SUFFIX>_di\"\n+  [(set (match_operand:VSX_SPLAT_I 0 \"altivec_register_operand\" \"=v\")\n+\t(vec_duplicate:VSX_SPLAT_I\n+\t (truncate:<VS_scalar>\n+\t  (match_operand:DI 1 \"altivec_register_operand\" \"v\"))))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"vsplt<VSX_SPLAT_SUFFIX> %0,%1,<VSX_SPLAT_COUNT>\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n ;; V2DF/V2DI splat for use by vec_splat builtin\n (define_insn \"vsx_xxspltd_<mode>\"\n   [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa\")"}, {"sha": "2812daad28f21b4af2d778a6bcc99e590fb86fb8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "patch": "@@ -1,3 +1,9 @@\n+2016-08-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vec-init-1.c: Add tests where the vector is\n+\tbeing created from pointers to memory locations.\n+\t* gcc.target/powerpc/vec-init-2.c: Likewise.\n+\n 2016-08-23  Fritz Reese  <fritzoreese@gmail.com>\n \n \t* gfortran.dg/dec_structure_12.f90: New testcase."}, {"sha": "079e6d843b48ba6c7f03112650bbdaa392f01b13", "filename": "gcc/testsuite/gcc.target/powerpc/vec-init-1.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-init-1.c?ref=6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "patch": "@@ -24,6 +24,9 @@ extern void check_splat (vector int a)\n extern vector int pack_reg (int a, int b, int c, int d)\n   __attribute__((__noinline__));\n \n+extern vector int pack_from_ptr (int *p_a, int *p_b, int *p_c, int *p_d)\n+  __attribute__((__noinline__));\n+\n extern vector int pack_const (void)\n   __attribute__((__noinline__));\n \n@@ -39,6 +42,9 @@ extern void pack_global (int a, int b, int c, int d)\n extern vector int splat_reg (int a)\n   __attribute__((__noinline__));\n \n+extern vector int splat_from_ptr (int *p)\n+  __attribute__((__noinline__));\n+\n extern vector int splat_const (void)\n   __attribute__((__noinline__));\n \n@@ -77,6 +83,12 @@ pack_reg (int a, int b, int c, int d)\n   return (vector int) { a, b, c, d };\n }\n \n+vector int\n+pack_from_ptr (int *p_a, int *p_b, int *p_c, int *p_d)\n+{\n+  return (vector int) { *p_a, *p_b, *p_c, *p_d };\n+}\n+\n vector int\n pack_const (void)\n {\n@@ -107,6 +119,12 @@ splat_reg (int a)\n   return (vector int) { a, a, a, a };\n }\n \n+vector int\n+splat_from_ptr (int *p)\n+{\n+  return (vector int) { *p, *p, *p, *p };\n+}\n+\n vector int\n splat_const (void)\n {\n@@ -134,11 +152,15 @@ splat_global (int a)\n int main (void)\n {\n   vector int sv2, sv3;\n+  int mem = SPLAT;\n+  int mem2[4] = { ELEMENTS };\n \n   check (sv);\n \n   check (pack_reg (ELEMENTS));\n \n+  check (pack_from_ptr (&mem2[0], &mem2[1], &mem2[2], &mem2[3]));\n+\n   check (pack_const ());\n \n   pack_ptr (&sv2, ELEMENTS);\n@@ -154,6 +176,8 @@ int main (void)\n \n   check_splat (splat_reg (SPLAT));\n \n+  check_splat (splat_from_ptr (&mem));\n+\n   check_splat (splat_const ());\n \n   splat_ptr (&sv2, SPLAT);"}, {"sha": "ddd41e280ee02395efe96f843a16267239ea39c4", "filename": "gcc/testsuite/gcc.target/powerpc/vec-init-2.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6019c0fc62b20db74e1f9f10ee00e1005313cb0a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-init-2.c?ref=6019c0fc62b20db74e1f9f10ee00e1005313cb0a", "patch": "@@ -24,6 +24,9 @@ extern void check_splat (vector long a)\n extern vector long pack_reg (long a, long b)\n   __attribute__((__noinline__));\n \n+extern vector long pack_from_ptr (long *p_a, long *p_b)\n+  __attribute__((__noinline__));\n+\n extern vector long pack_const (void)\n   __attribute__((__noinline__));\n \n@@ -39,6 +42,9 @@ extern void pack_global (long a, long b)\n extern vector long splat_reg (long a)\n   __attribute__((__noinline__));\n \n+extern vector long splat_from_ptr (long *p)\n+  __attribute__((__noinline__));\n+\n extern vector long splat_const (void)\n   __attribute__((__noinline__));\n \n@@ -77,6 +83,12 @@ pack_reg (long a, long b)\n   return (vector long) { a, b };\n }\n \n+vector long\n+pack_from_ptr (long *p_a, long *p_b)\n+{\n+  return (vector long) { *p_a, *p_b };\n+}\n+\n vector long\n pack_const (void)\n {\n@@ -107,6 +119,12 @@ splat_reg (long a)\n   return (vector long) { a, a };\n }\n \n+vector long\n+splat_from_ptr (long *p)\n+{\n+  return (vector long) { *p, *p };\n+}\n+\n vector long\n splat_const (void)\n {\n@@ -134,11 +152,15 @@ splat_global (long a)\n int  main (void)\n {\n   vector long sv2, sv3;\n+  long mem = SPLAT;\n+  long mem2[2] = { ELEMENTS };\n \n   check (sv);\n \n   check (pack_reg (ELEMENTS));\n \n+  check (pack_from_ptr (&mem2[0], &mem2[1]));\n+\n   check (pack_const ());\n \n   pack_ptr (&sv2, ELEMENTS);\n@@ -154,6 +176,8 @@ int  main (void)\n \n   check_splat (splat_reg (SPLAT));\n \n+  check_splat (splat_from_ptr (&mem));\n+\n   check_splat (splat_const ());\n \n   splat_ptr (&sv2, SPLAT);"}]}