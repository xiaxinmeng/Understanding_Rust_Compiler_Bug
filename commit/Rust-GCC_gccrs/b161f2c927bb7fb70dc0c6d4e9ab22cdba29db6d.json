{"sha": "b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE2MWYyYzkyN2JiN2ZiNzBkYzBjNmQ0ZTlhYjIyY2RiYTI5ZGI2ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-18T15:39:21Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-18T15:39:21Z"}, "message": "Include phis in SLP unrolling calculation\n\nWithout this we'd pick an unrolling factor based purely on longs,\nignoring the ints.  It's posssible that vect_get_smallest_scalar_type\nshould also handle shifts, but I think we'd still want this as a\nbelt-and-braces fix.\n\n2017-09-18  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vect-slp.c (vect_record_max_nunits): New function,\n\tsplit out from...\n\t(vect_build_slp_tree_1): ...here.\n\t(vect_build_slp_tree_2): Call it for phis too.\n\ngcc/testsuite/\n\t* gcc.dg/vect/slp-multitypes-13.c: New test.\n\nFrom-SVN: r252933", "tree": {"sha": "30eeafa2f81a3088be424e987665fa1e20be71ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30eeafa2f81a3088be424e987665fa1e20be71ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d/comments", "author": null, "committer": null, "parents": [{"sha": "7251b0bfbf09fae831bb5d3d2d7a311e9d37b398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7251b0bfbf09fae831bb5d3d2d7a311e9d37b398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7251b0bfbf09fae831bb5d3d2d7a311e9d37b398"}], "stats": {"total": 100, "additions": 73, "deletions": 27}, "files": [{"sha": "130793eaf5a0c28cfe3728ed514fbcee0641b0ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d", "patch": "@@ -1,3 +1,10 @@\n+2017-09-18  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vect-slp.c (vect_record_max_nunits): New function,\n+\tsplit out from...\n+\t(vect_build_slp_tree_1): ...here.\n+\t(vect_build_slp_tree_2): Call it for phis too.\n+\n 2017-09-18  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vect-stmts.c (vectorizable_mask_load_store): Pass mask_vectype"}, {"sha": "c0de42aa5a60cdea005d50064880e3394cb4f012", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d", "patch": "@@ -1,3 +1,7 @@\n+2017-09-18  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/vect/slp-multitypes-13.c: New test.\n+\n 2017-09-18  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gfortran.dg/vect/mask-store-1.f90: New test."}, {"sha": "bbbbb2c64b415711b1b52c3bc07b4eb360fc4a78", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-13.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-13.c?ref=b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+\n+void\n+f (long *x, int n)\n+{\n+  for (int i = 0; i < n; i++)\n+    {\n+      x[i * 2] = 1L << i;\n+      x[i * 2 + 1] = 1L << i;\n+    }\n+}"}, {"sha": "0168f8bdeb8d962f51379aff3be8848074f23dd9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=b161f2c927bb7fb70dc0c6d4e9ab22cdba29db6d", "patch": "@@ -480,6 +480,48 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n   return 0;\n }\n \n+/* A subroutine of vect_build_slp_tree for checking VECTYPE, which is the\n+   caller's attempt to find the vector type in STMT with the narrowest\n+   element type.  Return true if VECTYPE is nonnull and if it is valid\n+   for VINFO.  When returning true, update MAX_NUNITS to reflect the\n+   number of units in VECTYPE.  VINFO, GORUP_SIZE and MAX_NUNITS are\n+   as for vect_build_slp_tree.  */\n+\n+static bool\n+vect_record_max_nunits (vec_info *vinfo, gimple *stmt, unsigned int group_size,\n+\t\t\ttree vectype, unsigned int *max_nunits)\n+{\n+  if (!vectype)\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"Build SLP failed: unsupported data-type in \");\n+\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t}\n+      /* Fatal mismatch.  */\n+      return false;\n+    }\n+\n+  /* If populating the vector type requires unrolling then fail\n+     before adjusting *max_nunits for basic-block vectorization.  */\n+  if (is_a <bb_vec_info> (vinfo)\n+      && TYPE_VECTOR_SUBPARTS (vectype) > group_size)\n+    {\n+      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t       \"Build SLP failed: unrolling required \"\n+\t\t       \"in basic block SLP\\n\");\n+      /* Fatal mismatch.  */\n+      return false;\n+    }\n+\n+  /* In case of multiple types we need to detect the smallest type.  */\n+  if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n+    *max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\n+  return true;\n+}\n \n /* Verify if the scalar stmts STMTS are isomorphic, require data\n    permutation or are of unsupported types of operation.  Return\n@@ -560,38 +602,14 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \n       scalar_type = vect_get_smallest_scalar_type (stmt, &dummy, &dummy);\n       vectype = get_vectype_for_scalar_type (scalar_type);\n-      if (!vectype)\n-        {\n-          if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t       \"Build SLP failed: unsupported data-type \");\n-              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t scalar_type);\n-              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-            }\n+      if (!vect_record_max_nunits (vinfo, stmt, group_size, vectype,\n+\t\t\t\t   max_nunits))\n+\t{\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n           return false;\n         }\n \n-      /* If populating the vector type requires unrolling then fail\n-         before adjusting *max_nunits for basic-block vectorization.  */\n-      if (is_a <bb_vec_info> (vinfo)\n-\t  && TYPE_VECTOR_SUBPARTS (vectype) > group_size)\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t   \"Build SLP failed: unrolling required \"\n-\t\t\t   \"in basic block SLP\\n\");\n-\t  /* Fatal mismatch.  */\n-\t  matches[0] = false;\n-\t  return false;\n-\t}\n-\n-      /* In case of multiple types we need to detect the smallest type.  */\n-      if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n-\t*max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-\n       if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t{\n \t  rhs_code = CALL_EXPR;\n@@ -1018,6 +1036,12 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n      the recursion.  */\n   if (gimple_code (stmt) == GIMPLE_PHI)\n     {\n+      tree scalar_type = TREE_TYPE (PHI_RESULT (stmt));\n+      tree vectype = get_vectype_for_scalar_type (scalar_type);\n+      if (!vect_record_max_nunits (vinfo, stmt, group_size, vectype,\n+\t\t\t\t   max_nunits))\n+\treturn NULL;\n+\n       vect_def_type def_type = STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt));\n       /* Induction from different IVs is not supported.  */\n       if (def_type == vect_induction_def)"}]}