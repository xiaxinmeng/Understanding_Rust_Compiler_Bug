{"sha": "57632c515316283817fa2f96d3c938e984086f43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc2MzJjNTE1MzE2MjgzODE3ZmEyZjk2ZDNjOTM4ZTk4NDA4NmY0Mw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-12T08:25:33Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-12T08:25:33Z"}, "message": "(simplify_subtraction): New function.\n\nFrom-SVN: r2404", "tree": {"sha": "27079f80fdecc2d1195a97608205ac911f2bf958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27079f80fdecc2d1195a97608205ac911f2bf958"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57632c515316283817fa2f96d3c938e984086f43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57632c515316283817fa2f96d3c938e984086f43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57632c515316283817fa2f96d3c938e984086f43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57632c515316283817fa2f96d3c938e984086f43/comments", "author": null, "committer": null, "parents": [{"sha": "1f1fd3b1f4fab5806976d2ea98c0176840061c50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f1fd3b1f4fab5806976d2ea98c0176840061c50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f1fd3b1f4fab5806976d2ea98c0176840061c50"}], "stats": {"total": 100, "additions": 82, "deletions": 18}, "files": [{"sha": "f2bcb26dc18919752cc5627280e744ecc566575a", "filename": "gcc/varasm.c", "status": "modified", "additions": 82, "deletions": 18, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57632c515316283817fa2f96d3c938e984086f43/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57632c515316283817fa2f96d3c938e984086f43/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=57632c515316283817fa2f96d3c938e984086f43", "patch": "@@ -32,6 +32,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n+#include \"function.h\"\n #include \"expr.h\"\n #include \"hard-reg-set.h\"\n #include \"regs.h\"\n@@ -1228,7 +1229,10 @@ assemble_real (d, mode)\n    They are chained through the CONST_DOUBLE_CHAIN.\n    A CONST_DOUBLE rtx has CONST_DOUBLE_MEM != cc0_rtx iff it is on this chain.\n    In that case, CONST_DOUBLE_MEM is either a MEM,\n-   or const0_rtx if no MEM has been made for this CONST_DOUBLE yet.  */\n+   or const0_rtx if no MEM has been made for this CONST_DOUBLE yet.\n+\n+   (CONST_DOUBLE_MEM is used only for top-level functions.\n+   See force_const_mem for explanation.)  */\n \n static rtx const_double_chain;\n \n@@ -1409,6 +1413,11 @@ clear_const_double_mem ()\n {\n   register rtx r, next;\n \n+  /* Don't touch CONST_DOUBLE_MEM for nested functions.\n+     See force_const_mem for explanation.  */\n+  if (outer_function_chain != 0)\n+    return;\n+\n   for (r = const_double_chain; r; r = next)\n     {\n       next = CONST_DOUBLE_CHAIN (r);\n@@ -2007,7 +2016,7 @@ output_constant_def (exp)\n    inlining, so they do not need to be allocated permanently.  */\n \n #define MAX_RTX_HASH_TABLE 61\n-static struct constant_descriptor *const_rtx_hash_table[MAX_RTX_HASH_TABLE];\n+static struct constant_descriptor **const_rtx_hash_table;\n \n /* Structure to represent sufficient information about a constant so that\n    it can be output when the constant pool is output, so that function\n@@ -2044,7 +2053,7 @@ struct pool_sym\n   struct pool_sym *next;\n };\n \n-static struct pool_sym *const_rtx_sym_hash_table[MAX_RTX_HASH_TABLE];\n+static struct pool_sym **const_rtx_sym_hash_table;\n \n /* Hash code for a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true.\n    The argument is XSTR (... , 0)  */\n@@ -2057,13 +2066,45 @@ static struct pool_sym *const_rtx_sym_hash_table[MAX_RTX_HASH_TABLE];\n void\n init_const_rtx_hash_table ()\n {\n-  bzero (const_rtx_hash_table, sizeof const_rtx_hash_table);\n-  bzero (const_rtx_sym_hash_table, sizeof const_rtx_sym_hash_table);\n+  const_rtx_hash_table\n+    = ((struct constant_descriptor **)\n+       oballoc (MAX_RTX_HASH_TABLE * sizeof (struct constant_descriptor *)));\n+  const_rtx_sym_hash_table\n+    = ((struct pool_sym **)\n+       oballoc (MAX_RTX_HASH_TABLE * sizeof (struct pool_sym *)));\n+  bzero (const_rtx_hash_table,\n+\t MAX_RTX_HASH_TABLE * sizeof (struct constant_descriptor *));\n+  bzero (const_rtx_sym_hash_table,\n+\t MAX_RTX_HASH_TABLE * sizeof (struct pool_sym *));\n \n   first_pool = last_pool = 0;\n   pool_offset = 0;\n }\n \n+/* Save and restore it for a nested function.  */\n+\n+void\n+save_varasm_status (p)\n+     struct function *p;\n+{\n+  p->const_rtx_hash_table = const_rtx_hash_table;\n+  p->const_rtx_sym_hash_table = const_rtx_sym_hash_table;\n+  p->first_pool = first_pool;\n+  p->last_pool = last_pool;\n+  p->pool_offset = pool_offset;\n+}\n+\n+void\n+restore_varasm_status (p)\n+     struct function *p;\n+{\n+  const_rtx_hash_table = p->const_rtx_hash_table;\n+  const_rtx_sym_hash_table = p->const_rtx_sym_hash_table;\n+  first_pool = p->first_pool;\n+  last_pool = p->last_pool;\n+  pool_offset = p->pool_offset;\n+}\n+\f\n enum kind { RTX_DOUBLE, RTX_INT };\n \n struct rtx_const\n@@ -2156,6 +2197,23 @@ decode_rtx_const (mode, x, value)\n       }\n }\n \n+/* Given a MINUS expression, simplify it if both sides\n+   include the same symbol.  */\n+\n+rtx\n+simplify_subtraction (x)\n+     rtx x;\n+{\n+  struct rtx_const val0, val1;\n+\n+  decode_rtx_const (GET_MODE (x), XEXP (x, 0), &val0);\n+  decode_rtx_const (GET_MODE (x), XEXP (x, 1), &val1);\n+\n+  if (val0.un.addr.base == val1.un.addr.base)\n+    return GEN_INT (val0.un.addr.offset - val1.un.addr.offset);\n+  return x;\n+}\n+\n /* Compute a hash code for a constant RTL expression.  */\n \n int\n@@ -2249,10 +2307,15 @@ force_const_mem (mode, x)\n      modes in an alternating fashion, we will allocate a lot of different\n      memory locations, but this should be extremely rare.  */\n \n-  if (GET_CODE (x) == CONST_DOUBLE\n-      && GET_CODE (CONST_DOUBLE_MEM (x)) == MEM\n-      && GET_MODE (CONST_DOUBLE_MEM (x)) == mode)\n-    return CONST_DOUBLE_MEM (x);\n+  /* Don't use CONST_DOUBLE_MEM in a nested function.\n+     Nested functions have their own constant pools,\n+     so they can't share the same values in CONST_DOUBLE_MEM\n+     with the containing function.  */\n+  if (outer_function_chain == 0)\n+    if (GET_CODE (x) == CONST_DOUBLE\n+\t&& GET_CODE (CONST_DOUBLE_MEM (x)) == MEM\n+\t&& GET_MODE (CONST_DOUBLE_MEM (x)) == mode)\n+      return CONST_DOUBLE_MEM (x);\n \n   /* Compute hash code of X.  Search the descriptors for that hash code\n      to see if any of them describes X.  If yes, the descriptor records\n@@ -2335,15 +2398,16 @@ force_const_mem (mode, x)\n   CONSTANT_POOL_ADDRESS_P (XEXP (def, 0)) = 1;\n   current_function_uses_const_pool = 1;\n \n-  if (GET_CODE (x) == CONST_DOUBLE)\n-    {\n-      if (CONST_DOUBLE_MEM (x) == cc0_rtx)\n-\t{\n-\t  CONST_DOUBLE_CHAIN (x) = const_double_chain;\n-\t  const_double_chain = x;\n-\t}\n-      CONST_DOUBLE_MEM (x) = def;\n-    }\n+  if (outer_function_chain == 0)\n+    if (GET_CODE (x) == CONST_DOUBLE)\n+      {\n+\tif (CONST_DOUBLE_MEM (x) == cc0_rtx)\n+\t  {\n+\t    CONST_DOUBLE_CHAIN (x) = const_double_chain;\n+\t    const_double_chain = x;\n+\t  }\n+\tCONST_DOUBLE_MEM (x) = def;\n+      }\n \n   return def;\n }"}]}