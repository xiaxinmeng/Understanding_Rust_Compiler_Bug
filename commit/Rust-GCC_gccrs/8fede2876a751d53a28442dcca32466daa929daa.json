{"sha": "8fede2876a751d53a28442dcca32466daa929daa", "node_id": "C_kwDOANBUbNoAKDhmZWRlMjg3NmE3NTFkNTNhMjg0NDJkY2NhMzI0NjZkYWE5MjlkYWE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-03-02T07:55:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-03-02T14:08:49Z"}, "message": "rtl-optimization/104686 - speedup IRA allocno conflict test\n\nIn this PR allocnos_conflict_p takes 90% of the compile-time via\nthe calls from update_conflict_hard_regno_costs.  This is due to\nthe high number of conflicts recorded in the dense bitvector\nrepresentation.  Fortunately we can take advantage of the bitvector\nrepresentation here and turn the O(n) conflict test into an O(1) one,\ngreatly speeding up the compile of the testcase from 39s to just 4s\n(93% IRA time to 26% IRA time).\n\nWhile for the testcase in question the first allocno is almost always\nthe nice one the patch tries a more systematic approach to finding\nthe allocno to iterate object conflicts over.  That does reduce\nthe actual number of compares for the testcase but it doesn't make\na measurable difference wall-clock wise.  That's not guaranteed\nthough I think so I've kept this systematic way of choosing the\ncheapest allocno.\n\n2022-03-02  Richard Biener  <rguenther@suse.de>\n\n\tPR rtl-optimization/104686\n\t* ira-color.cc (object_conflicts_with_allocno_p): New function\n\tusing a bitvector test instead of iterating when possible.\n\t(allocnos_conflict_p): Choose the best allocno to iterate over\n\tobject conflicts.\n\t(update_conflict_hard_regno_costs): Do allocnos_conflict_p test\n\tlast.", "tree": {"sha": "09c5198e8f99f04d4eb9e23c4378ea4603f7d3e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09c5198e8f99f04d4eb9e23c4378ea4603f7d3e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fede2876a751d53a28442dcca32466daa929daa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fede2876a751d53a28442dcca32466daa929daa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fede2876a751d53a28442dcca32466daa929daa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fede2876a751d53a28442dcca32466daa929daa/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ced22c51baaa3fe84d14d5baef60c4440a35b4be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced22c51baaa3fe84d14d5baef60c4440a35b4be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ced22c51baaa3fe84d14d5baef60c4440a35b4be"}], "stats": {"total": 75, "additions": 57, "deletions": 18}, "files": [{"sha": "e01d1841a08c1a0eab61a6da67bbcea87387446e", "filename": "gcc/ira-color.cc", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fede2876a751d53a28442dcca32466daa929daa/gcc%2Fira-color.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fede2876a751d53a28442dcca32466daa929daa/gcc%2Fira-color.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.cc?ref=8fede2876a751d53a28442dcca32466daa929daa", "patch": "@@ -1338,26 +1338,65 @@ update_allocno_cost (ira_allocno_t allocno, int hard_regno,\n   return true;\n }\n \n+/* Return TRUE if the object OBJ conflicts with the allocno A.  */\n+static bool\n+object_conflicts_with_allocno_p (ira_object_t obj, ira_allocno_t a)\n+{\n+  if  (!OBJECT_CONFLICT_VEC_P (obj))\n+    for (int word = 0; word < ALLOCNO_NUM_OBJECTS (a); word++)\n+      {\n+\tira_object_t another_obj = ALLOCNO_OBJECT (a, word);\n+\tif (OBJECT_CONFLICT_ID (another_obj) >= OBJECT_MIN (obj)\n+\t    && OBJECT_CONFLICT_ID (another_obj) <= OBJECT_MAX (obj)\n+\t    && TEST_MINMAX_SET_BIT (OBJECT_CONFLICT_BITVEC (obj),\n+\t\t\t\t    OBJECT_CONFLICT_ID (another_obj),\n+\t\t\t\t    OBJECT_MIN (obj), OBJECT_MAX (obj)))\n+\t  return true;\n+      }\n+  else\n+    {\n+      /* If this linear walk ever becomes a bottleneck we could add a\n+\t conflict_vec_sorted_p flag and if not set, sort the conflicts after\n+\t their ID so we can use a binary search.  That would also require\n+\t tracking the actual number of conflicts in the vector to not rely\n+\t on the NULL termination.  */\n+      ira_object_conflict_iterator oci;\n+      ira_object_t conflict_obj;\n+      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n+\tif (OBJECT_ALLOCNO (conflict_obj) == a)\n+\t  return true;\n+    }\n+  return false;\n+}\n+\n /* Return TRUE if allocnos A1 and A2 conflicts. Here we are\n-   interesting only in conflicts of allocnos with intersected allocno\n-   classes. */\n+   interested only in conflicts of allocnos with intersecting allocno\n+   classes.  */\n static bool\n allocnos_conflict_p (ira_allocno_t a1, ira_allocno_t a2)\n {\n-  ira_object_t obj, conflict_obj;\n-  ira_object_conflict_iterator oci;\n-  int word, nwords = ALLOCNO_NUM_OBJECTS (a1);\n-  \n-  for (word = 0; word < nwords; word++)\n+  /* Compute the upper bound for the linear iteration when the object\n+     conflicts are represented as a sparse vector.  In particular this\n+     will make sure we prefer O(1) bitvector testing.  */\n+  int num_conflicts_in_vec1 = 0, num_conflicts_in_vec2 = 0;\n+  for (int word = 0; word < ALLOCNO_NUM_OBJECTS (a1); ++word)\n+    if (OBJECT_CONFLICT_VEC_P (ALLOCNO_OBJECT (a1, word)))\n+      num_conflicts_in_vec1 += OBJECT_NUM_CONFLICTS (ALLOCNO_OBJECT (a1, word));\n+  for (int word = 0; word < ALLOCNO_NUM_OBJECTS (a2); ++word)\n+    if (OBJECT_CONFLICT_VEC_P (ALLOCNO_OBJECT (a2, word)))\n+      num_conflicts_in_vec2 += OBJECT_NUM_CONFLICTS (ALLOCNO_OBJECT (a2, word));\n+  if (num_conflicts_in_vec2 < num_conflicts_in_vec1)\n+    std::swap (a1, a2);\n+\n+  for (int word = 0; word < ALLOCNO_NUM_OBJECTS (a1); word++)\n     {\n-      obj = ALLOCNO_OBJECT (a1, word);\n+      ira_object_t obj = ALLOCNO_OBJECT (a1, word);\n       /* Take preferences of conflicting allocnos into account.  */\n-      FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n-\tif (OBJECT_ALLOCNO (conflict_obj) == a2)\n-\t  return true;\n+      if (object_conflicts_with_allocno_p (obj, a2))\n+\treturn true;\n     }\n   return false;\n-}  \n+}\n \n /* Update (decrease if DECR_P) HARD_REGNO cost of allocnos connected\n    by copies to ALLOCNO to increase chances to remove some copies as\n@@ -1572,15 +1611,15 @@ update_conflict_hard_regno_costs (int *costs, enum reg_class aclass,\n \telse\n \t  gcc_unreachable ();\n \n+\tanother_aclass = ALLOCNO_CLASS (another_allocno);\n \tif (another_allocno == from\n-\t    || allocnos_conflict_p (another_allocno, start))\n-\t  continue;\n-\n- \tanother_aclass = ALLOCNO_CLASS (another_allocno);\n- \tif (! ira_reg_classes_intersect_p[aclass][another_aclass]\n \t    || ALLOCNO_ASSIGNED_P (another_allocno)\n-\t    || ALLOCNO_COLOR_DATA (another_allocno)->may_be_spilled_p)\n+\t    || ALLOCNO_COLOR_DATA (another_allocno)->may_be_spilled_p\n+\t    || ! ira_reg_classes_intersect_p[aclass][another_aclass])\n+\t  continue;\n+\tif (allocnos_conflict_p (another_allocno, start))\n \t  continue;\n+\n \tclass_size = ira_class_hard_regs_num[another_aclass];\n \tira_allocate_and_copy_costs\n \t  (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),"}]}