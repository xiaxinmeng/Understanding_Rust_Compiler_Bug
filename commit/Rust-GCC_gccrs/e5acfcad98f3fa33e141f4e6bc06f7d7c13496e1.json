{"sha": "e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1", "node_id": "C_kwDOANBUbNoAKGU1YWNmY2FkOThmM2ZhMzNlMTQxZjRlNmJjMDZmN2Q3YzEzNDk2ZTE", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-29T20:46:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-29T20:46:21Z"}, "message": "tree-ssa-dce: Fix up -fcompare-debug failures in make_forwarders_with_degenerate_phis [PR103742]\n\nmake_forwarders_with_degenerate_phis causes a -fcompare-debug failure on the\nfollowing testcase.\nThe problem is that on:\n  # iftmp.4_8 = PHI <&D.2582(6), &D.2583(4), &D.2582(7), &D.2583(5)>\nthe exact DECL_UIDs are different between -g and -g0 (which is ok, with -g\nthe decls can have larger gaps in between the uids), which means\niterative_hash_expr is different and because there are 2 pairs of edges\nwith matching phi arguments, the function processes them in different\norders.\nThe following patch fixes it by using the iterative_hash_expr order\nonly to determine which arguments are the same, then replaces the hashes\nwith the minimum dest_idx in the set of matching arguments and qsorts\nagain (which makes it stable for -fcompare-debug) and only splits edges etc.\non that stable order.\nAs a small optimization, if no arguments are equal, it doesn't do the\nsecond qsort and continues, and if all arguments of the PHI are\nconstants or SSA_NAMEs (I think that is a pretty common case for many\nPHIs), then it doesn't do the second qsort either, because in that case\nthe hash values will be stable, only computed from the constant values or\nSSA_NAME_VERSIONs.\n\n2021-12-29  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/103742\n\t* tree-ssa-dce.c (make_forwarders_with_degenerate_phis): If any phi\n\targument is not CONSTANT_CLASS_P or SSA_NAME and any arguments are\n\tequal, change second from hash value to lowest dest_idx from the\n\tedges which have equal argument and resort to ensure -fcompare-debug\n\tstability.\n\n\t* g++.dg/opt/pr103742.C: New test.", "tree": {"sha": "25558ab6ffe309cf1f937d291cf5739ead8290ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25558ab6ffe309cf1f937d291cf5739ead8290ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ade9130f50905e82c8557c3df049cd1147c11986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade9130f50905e82c8557c3df049cd1147c11986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ade9130f50905e82c8557c3df049cd1147c11986"}], "stats": {"total": 74, "additions": 70, "deletions": 4}, "files": [{"sha": "6155d2221bff384fe15bedeb897476242858be2f", "filename": "gcc/testsuite/g++.dg/opt/pr103742.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr103742.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr103742.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr103742.C?ref=e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1", "patch": "@@ -0,0 +1,36 @@\n+// PR debug/103742\n+// { dg-do compile { target c++17 } }\n+// { dg-options \"-O2 -fnon-call-exceptions --param=early-inlining-insns=82 -fcompare-debug\" }\n+\n+template <typename T> T max(T a, T b) { return a >= b ? a : b; }\n+template <typename T> T abs(T);\n+template <int T, int U> struct A {\n+  long a;\n+  A(A &x) { a = x.a; }\n+  A(long);\n+  A foo(A) {\n+    if (abs(a) && a == a)\n+      a = a ? U : T;\n+    else\n+      a += a;\n+    return *this;\n+  }\n+  bool operator>=(A) { return a; }\n+};\n+struct B {};\n+struct C {\n+  A<2147483647, 0> c;\n+};\n+struct D {\n+  A<2147483647, 0> d;\n+  C e[];\n+};\n+struct E : D{} * f;\n+A<2147483647, 0> bar() {\n+  A<2147483647, 0> g = g.foo(f->d);\n+  return max(g, (A<2147483647, 0>)1);\n+}\n+E *h;\n+void baz() {\n+  h->e[0].c = bar();\n+}"}, {"sha": "6a6da0963b2814b1a5364f4098709d0245efee6b", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=e5acfcad98f3fa33e141f4e6bc06f7d7c13496e1", "patch": "@@ -1671,6 +1671,7 @@ make_forwarders_with_degenerate_phis (function *fn)\n \tcontinue;\n       gphi *phi = gsi.phi ();\n       auto_vec<std::pair<edge, hashval_t>, 8> args;\n+      bool need_resort = false;\n       for (unsigned i = 0; i < gimple_phi_num_args (phi); ++i)\n \t{\n \t  edge e = gimple_phi_arg_edge (phi, i);\n@@ -1682,12 +1683,42 @@ make_forwarders_with_degenerate_phis (function *fn)\n \t  if (loops_state_satisfies_p (LOOP_CLOSED_SSA)\n \t      && loop_exit_edge_p (e->src->loop_father, e))\n \t    continue;\n-\t  args.safe_push (std::make_pair (e, iterative_hash_expr\n-\t\t\t\t\t     (gimple_phi_arg_def (phi, i), 0)));\n+\n+\t  tree arg = gimple_phi_arg_def (phi, i);\n+\t  if (!CONSTANT_CLASS_P (arg) && TREE_CODE (arg) != SSA_NAME)\n+\t    need_resort = true;\n+\t  args.safe_push (std::make_pair (e, iterative_hash_expr (arg, 0)));\n \t}\n       if (args.length () < 2)\n \tcontinue;\n       args.qsort (sort_phi_args);\n+      /* The above sorting can be different between -g and -g0, as e.g. decls\n+\t can have different uids (-g could have bigger gaps in between them).\n+\t So, only use that to determine which args are equal, then change\n+\t second from hash value to smallest dest_idx of the edges which have\n+\t equal argument and sort again.  If all the phi arguments are\n+\t constants or SSA_NAME, there is no need for the second sort, the hash\n+\t values are stable in that case.  */\n+      hashval_t hash = args[0].second;\n+      args[0].second = args[0].first->dest_idx;\n+      bool any_equal = false;\n+      for (unsigned i = 1; i < args.length (); ++i)\n+\tif (hash == args[i].second\n+\t    && operand_equal_p (PHI_ARG_DEF_FROM_EDGE (phi, args[i - 1].first),\n+\t\t\t\tPHI_ARG_DEF_FROM_EDGE (phi, args[i].first)))\n+\t  {\n+\t    args[i].second = args[i - 1].second;\n+\t    any_equal = true;\n+\t  }\n+\telse\n+\t  {\n+\t    hash = args[i].second;\n+\t    args[i].second = args[i].first->dest_idx;\n+\t  }\n+      if (!any_equal)\n+\tcontinue;\n+      if (need_resort)\n+\targs.qsort (sort_phi_args);\n \n       /* From the candidates vector now verify true candidates for\n \t forwarders and create them.  */\n@@ -1697,8 +1728,7 @@ make_forwarders_with_degenerate_phis (function *fn)\n \t{\n \t  unsigned i;\n \t  for (i = start + 1; i < args.length (); ++i)\n-\t    if (!operand_equal_p (PHI_ARG_DEF_FROM_EDGE (phi, args[start].first),\n-\t\t\t\t  PHI_ARG_DEF_FROM_EDGE (phi, args[i].first)))\n+\t    if (args[start].second != args[i].second)\n \t      break;\n \t  /* args[start]..args[i-1] are equal.  */\n \t  if (start != i - 1)"}]}