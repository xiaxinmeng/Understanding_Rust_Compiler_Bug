{"sha": "cd3410cc7b57fe3745f0fe764f5c322e0265ea1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QzNDEwY2M3YjU3ZmUzNzQ1ZjBmZTc2NGY1YzMyMmUwMjY1ZWExYQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2018-01-10T15:37:49Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2018-01-10T15:37:49Z"}, "message": "i386: Also adjust stack frame for stack slot alignment\n\nWe should also adjust stack_realign_offset for the largest alignment of\nstack slot actually used when stack realignment isn't needed.  This is\nrequired to keep stack frame properly aligned to satisfy the largest\nalignment of stack slots.\n\nTested on Linux/i686 and Linux/x86-64.\n\ngcc/\n\n\tPR target/83735\n\t* config/i386/i386.c (ix86_compute_frame_layout): Always adjust\n\tstack_realign_offset for the largest alignment of stack slot\n\tactually used.\n\t(ix86_find_max_used_stack_alignment): New function.\n\t(ix86_finalize_stack_frame_flags): Use it.  Set\n\tmax_used_stack_alignment if we don't realign stack.\n\t* config/i386/i386.h (machine_function): Add\n\tmax_used_stack_alignment.\n\ngcc/testsuite/\n\n\tPR target/83735\n\t* gcc.target/i386/pr83735.c: New test.\n\nFrom-SVN: r256436", "tree": {"sha": "d9cd7bd70788dd6f5be507a805dca0f462a6563d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9cd7bd70788dd6f5be507a805dca0f462a6563d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "447fb74d97f0fecbfe363cda7760df231e9b4c27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447fb74d97f0fecbfe363cda7760df231e9b4c27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/447fb74d97f0fecbfe363cda7760df231e9b4c27"}], "stats": {"total": 195, "additions": 148, "deletions": 47}, "files": [{"sha": "cacb95c58bf4a28d2c074165ec5ae4c4f184ad27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd3410cc7b57fe3745f0fe764f5c322e0265ea1a", "patch": "@@ -1,3 +1,15 @@\n+2018-01-10  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/83735\n+\t* config/i386/i386.c (ix86_compute_frame_layout): Always adjust\n+\tstack_realign_offset for the largest alignment of stack slot\n+\tactually used.\n+\t(ix86_find_max_used_stack_alignment): New function.\n+\t(ix86_finalize_stack_frame_flags): Use it.  Set\n+\tmax_used_stack_alignment if we don't realign stack.\n+\t* config/i386/i386.h (machine_function): Add\n+\tmax_used_stack_alignment.\n+\n 2018-01-10  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* config/arm/arm.opt (-mbranch-cost): New option."}, {"sha": "5e17b694d7fa1a5fdfad596d4cc77c845d679a09", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 73, "deletions": 47, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cd3410cc7b57fe3745f0fe764f5c322e0265ea1a", "patch": "@@ -11259,7 +11259,11 @@ ix86_compute_frame_layout (void)\n   /* Calculate the size of the va-arg area (not including padding, if any).  */\n   frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;\n \n-  if (stack_realign_fp)\n+  /* Also adjust stack_realign_offset for the largest alignment of\n+     stack slot actually used.  */\n+  if (stack_realign_fp\n+      || (cfun->machine->max_used_stack_alignment != 0\n+\t  && (offset % cfun->machine->max_used_stack_alignment) != 0))\n     {\n       /* We may need a 16-byte aligned stack for the remainder of the\n \t register save area, but the stack frame for the local function\n@@ -12668,6 +12672,62 @@ output_probe_stack_range (rtx reg, rtx end)\n   return \"\";\n }\n \n+/* Return true if stack frame is required.  Update STACK_ALIGNMENT\n+   to the largest alignment, in bits, of stack slot used if stack\n+   frame is required and CHECK_STACK_SLOT is true.  */\n+\n+static bool\n+ix86_find_max_used_stack_alignment (unsigned int &stack_alignment,\n+\t\t\t\t    bool check_stack_slot)\n+{\n+  HARD_REG_SET set_up_by_prologue, prologue_used;\n+  basic_block bb;\n+\n+  CLEAR_HARD_REG_SET (prologue_used);\n+  CLEAR_HARD_REG_SET (set_up_by_prologue);\n+  add_to_hard_reg_set (&set_up_by_prologue, Pmode, STACK_POINTER_REGNUM);\n+  add_to_hard_reg_set (&set_up_by_prologue, Pmode, ARG_POINTER_REGNUM);\n+  add_to_hard_reg_set (&set_up_by_prologue, Pmode,\n+\t\t       HARD_FRAME_POINTER_REGNUM);\n+\n+  /* The preferred stack alignment is the minimum stack alignment.  */\n+  if (stack_alignment > crtl->preferred_stack_boundary)\n+    stack_alignment = crtl->preferred_stack_boundary;\n+\n+  bool require_stack_frame = false;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      rtx_insn *insn;\n+      FOR_BB_INSNS (bb, insn)\n+\tif (NONDEBUG_INSN_P (insn)\n+\t    && requires_stack_frame_p (insn, prologue_used,\n+\t\t\t\t       set_up_by_prologue))\n+\t  {\n+\t    require_stack_frame = true;\n+\n+\t    if (check_stack_slot)\n+\t      {\n+\t\t/* Find the maximum stack alignment.  */\n+\t\tsubrtx_iterator::array_type array;\n+\t\tFOR_EACH_SUBRTX (iter, array, PATTERN (insn), ALL)\n+\t\t  if (MEM_P (*iter)\n+\t\t      && (reg_mentioned_p (stack_pointer_rtx,\n+\t\t\t\t\t   *iter)\n+\t\t\t  || reg_mentioned_p (frame_pointer_rtx,\n+\t\t\t\t\t      *iter)))\n+\t\t    {\n+\t\t      unsigned int alignment = MEM_ALIGN (*iter);\n+\t\t      if (alignment > stack_alignment)\n+\t\t\tstack_alignment = alignment;\n+\t\t    }\n+\t      }\n+\t  }\n+    }\n+\n+  return require_stack_frame;\n+}\n+\n /* Finalize stack_realign_needed and frame_pointer_needed flags, which\n    will guide prologue/epilogue to be generated in correct form.  */\n \n@@ -12718,52 +12778,8 @@ ix86_finalize_stack_frame_flags (void)\n       && ix86_nsaved_sseregs () == 0\n       && ix86_varargs_gpr_size + ix86_varargs_fpr_size == 0)\n     {\n-      HARD_REG_SET set_up_by_prologue, prologue_used;\n-      basic_block bb;\n-\n-      CLEAR_HARD_REG_SET (prologue_used);\n-      CLEAR_HARD_REG_SET (set_up_by_prologue);\n-      add_to_hard_reg_set (&set_up_by_prologue, Pmode, STACK_POINTER_REGNUM);\n-      add_to_hard_reg_set (&set_up_by_prologue, Pmode, ARG_POINTER_REGNUM);\n-      add_to_hard_reg_set (&set_up_by_prologue, Pmode,\n-\t\t\t   HARD_FRAME_POINTER_REGNUM);\n-\n-      /* The preferred stack alignment is the minimum stack alignment.  */\n-      if (stack_alignment > crtl->preferred_stack_boundary)\n-\tstack_alignment = crtl->preferred_stack_boundary;\n-\n-      bool require_stack_frame = false;\n-\n-      FOR_EACH_BB_FN (bb, cfun)\n-        {\n-          rtx_insn *insn;\n-\t  FOR_BB_INSNS (bb, insn)\n-\t    if (NONDEBUG_INSN_P (insn)\n-\t\t&& requires_stack_frame_p (insn, prologue_used,\n-\t\t\t\t\t   set_up_by_prologue))\n-\t      {\n-\t\trequire_stack_frame = true;\n-\n-\t\tif (stack_realign)\n-\t\t  {\n-\t\t    /* Find the maximum stack alignment.  */\n-\t\t    subrtx_iterator::array_type array;\n-\t\t    FOR_EACH_SUBRTX (iter, array, PATTERN (insn), ALL)\n-\t\t      if (MEM_P (*iter)\n-\t\t\t  && (reg_mentioned_p (stack_pointer_rtx,\n-\t\t\t\t\t       *iter)\n-\t\t\t      || reg_mentioned_p (frame_pointer_rtx,\n-\t\t\t\t\t\t  *iter)))\n-\t\t\t{\n-\t\t\t  unsigned int alignment = MEM_ALIGN (*iter);\n-\t\t\t  if (alignment > stack_alignment)\n-\t\t\t    stack_alignment = alignment;\n-\t\t\t}\n-\t\t  }\n-\t      }\n-\t}\n-\n-      if (require_stack_frame)\n+      if (ix86_find_max_used_stack_alignment (stack_alignment,\n+\t\t\t\t\t      stack_realign))\n \t{\n \t  /* Stack frame is required.  If stack alignment needed is less\n \t     than incoming stack boundary, don't realign stack.  */\n@@ -12851,6 +12867,16 @@ ix86_finalize_stack_frame_flags (void)\n \t  recompute_frame_layout_p = true;\n \t}\n     }\n+  else if (crtl->max_used_stack_slot_alignment\n+\t   > crtl->preferred_stack_boundary)\n+    {\n+      /* We don't need to realign stack.  But we still need to keep\n+\t stack frame properly aligned to satisfy the largest alignment\n+\t of stack slots.  */\n+      if (ix86_find_max_used_stack_alignment (stack_alignment, true))\n+\tcfun->machine->max_used_stack_alignment\n+\t  = stack_alignment / BITS_PER_UNIT;\n+    }\n \n   if (crtl->stack_realign_needed != stack_realign)\n     recompute_frame_layout_p = true;"}, {"sha": "933f261ea66365ac4c395378e5bf62e925325ddd", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=cd3410cc7b57fe3745f0fe764f5c322e0265ea1a", "patch": "@@ -2598,6 +2598,9 @@ struct GTY(()) machine_function {\n   /* Nonzero if the function places outgoing arguments on stack.  */\n   BOOL_BITFIELD outgoing_args_on_stack : 1;\n \n+  /* The largest alignment, in bytes, of stack slot actually used.  */\n+  unsigned int max_used_stack_alignment;\n+\n   /* During prologue/epilogue generation, the current frame state.\n      Otherwise, the frame state at the end of the prologue.  */\n   struct machine_frame_state fs;"}, {"sha": "a46a5ee6722e57d128dc2bf14fbb262697f55c0e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd3410cc7b57fe3745f0fe764f5c322e0265ea1a", "patch": "@@ -1,3 +1,8 @@\n+2018-01-10  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/83735\n+\t* gcc.target/i386/pr83735.c: New test.\n+\n 2018-01-10  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* lib/target-supports.exp (check_effective_target_branch_cost):"}, {"sha": "786c90a583949825ec4fe1bf962260f923c7fe36", "filename": "gcc/testsuite/gcc.target/i386/pr83735.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83735.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3410cc7b57fe3745f0fe764f5c322e0265ea1a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83735.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr83735.c?ref=cd3410cc7b57fe3745f0fe764f5c322e0265ea1a", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O3 -mavx\" } */\n+\n+#include <stdlib.h>\n+#include \"cpuid.h\"\n+#include \"m256-check.h\"\n+#include \"avx-os-support.h\"\n+\n+static void __attribute__((constructor))\n+check_avx (void)\n+{\n+  unsigned int eax, ebx, ecx, edx;\n+ \n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    exit (0);\n+\n+  /* Run AVX test only if host has AVX support.  */\n+  if (((ecx & (bit_AVX | bit_OSXSAVE)) == (bit_AVX | bit_OSXSAVE))\n+      && avx_os_support ())\n+    return;\n+\n+  exit (0);\n+}\n+\n+struct S\n+{\n+  short b;\n+  long c;\n+  char d;\n+  long e;\n+  unsigned:8;\n+};\n+\n+int f, h, k, l;\n+int g[10];\n+volatile struct S j;\n+char m;\n+\n+int\n+main (void)\n+{\n+  int i;\n+  struct S n;\n+  for (i = 0; i < 6; i++)\n+    {\n+      for (f = 0; f < 10; f++)\n+\tg[f] = 4;\n+      n = j;\n+      h = m == 0 ? 1 : 5 % m;\n+      if (l)\n+\tn.b = k;\n+    }\n+  return n.b;\n+}"}]}