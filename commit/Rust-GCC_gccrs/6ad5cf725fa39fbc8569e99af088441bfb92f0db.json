{"sha": "6ad5cf725fa39fbc8569e99af088441bfb92f0db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFkNWNmNzI1ZmEzOWZiYzg1NjllOTlhZjA4ODQ0MWJmYjkyZjBkYg==", "commit": {"author": {"name": "Christopher D. Rickett", "email": "crickett@lanl.gov", "date": "2007-07-21T23:45:44Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-07-21T23:45:44Z"}, "message": "re PR fortran/32627 ([ISO Bind C] Accept c_f_pointer for TYPE)\n\n2007-07-21  Christopher D. Rickett  <crickett@lanl.gov>\n\n        PR fortran/32627\n        * resolve.c (set_name_and_label): Set kind number for character\n        version of c_f_pointer.\n        (gfc_iso_c_sub_interface): Set the kind of the SHAPE formal arg to\n        that of the actual SHAPE arg.\n        * symbol.c (gen_shape_param): Initialize kind for SHAPE arg.\n\n2007-07-21  Christopher D. Rickett  <crickett@lanl.gov>\n\n        PR fortran/32627\n        * libgfortran/intrinsics/iso_c_generated_procs.c: Add c_f_pointer\n        for character/string arguments.\n        * libgfortran/intrinsic/iso_c_binding.c (c_f_pointer_u0): Allow\n        the optional SHAPE arg to be any valid integer kind.\n        * libgfortran/gfortran.map: Add c_f_pointer_s0.\n        * libgfortran/mk-kinds-h.sh: Save smallest integer kind as default\n        character kind.\n        * libgfortran/intrinsics/iso_c_generated_procs.c: Add versions of\n        c_f_pointer for complex and logical types.\n        * libgfortran/gfortran.map: Add c_f_pointer versions for logical\n        and complex types.\n\n2007-07-21  Christopher D. Rickett  <crickett@lanl.gov>\n\n        PR fortran/32627\n        * gfortran.dg/pr32627_driver.c: Driver for pr32627.\n        * gfortran.dg/pr32627.f03: New test case.\n        * gfortran.dg/c_f_pointer_logical.f03: New test case.\n        * gfortran.dg/c_f_pointer_logical_driver.c: Driver for\n        c_f_pointer_logical.\n        * gfortran.dg/c_f_pointer_complex_driver.c: Driver for\n        c_f_pointer_complex.\n        * gfortran.dg/c_f_pointer_complex.f03: New test case.\n        * gfortran.dg/c_f_pointer_shape_tests_2_driver.c: Driver for\n        c_f_pointer_shape_tests_2.\n        * gfortran.dg/c_f_pointer_shape_tests_2.f03: New test case.\n\nFrom-SVN: r126817", "tree": {"sha": "a0c66745a59e2ad6d40022ec11f867e11ccaa8fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0c66745a59e2ad6d40022ec11f867e11ccaa8fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ad5cf725fa39fbc8569e99af088441bfb92f0db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ad5cf725fa39fbc8569e99af088441bfb92f0db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ad5cf725fa39fbc8569e99af088441bfb92f0db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ad5cf725fa39fbc8569e99af088441bfb92f0db/comments", "author": null, "committer": null, "parents": [{"sha": "8e4c6d8802234d9b885d1f3286b5363484bee1f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4c6d8802234d9b885d1f3286b5363484bee1f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e4c6d8802234d9b885d1f3286b5363484bee1f5"}], "stats": {"total": 632, "additions": 630, "deletions": 2}, "files": [{"sha": "2e627da7a52db1db023ebc09d57811c20a0adc32", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -1,3 +1,12 @@\n+2007-07-21  Christopher D. Rickett  <crickett@lanl.gov>\n+\n+\tPR fortran/32627\n+\t* resolve.c (set_name_and_label): Set kind number for character\n+\tversion of c_f_pointer.\n+\t(gfc_iso_c_sub_interface): Set the kind of the SHAPE formal arg to\n+\tthat of the actual SHAPE arg.\n+\t* symbol.c (gen_shape_param): Initialize kind for SHAPE arg.\n+\n 2007-07-21  Christopher D. Rickett  <crickett@lanl.gov>\n \n \tPR fortran/32801"}, {"sha": "45a49e2f0fdaa16801745f84c5b8fecb3a1ecfa8", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -2282,6 +2282,11 @@ set_name_and_label (gfc_code *c, gfc_symbol *sym,\n           type = gfc_type_letter (arg->ts.type);\n           kind = arg->ts.kind;\n         }\n+\n+      if (arg->ts.type == BT_CHARACTER)\n+\t/* Kind info for character strings not needed.\t*/\n+\tkind = 0;\n+\n       sprintf (name, \"%s_%c%d\", sym->name, type, kind);\n       /* Set up the binding label as the given symbol's label plus\n          the type and kind.  */\n@@ -2356,6 +2361,13 @@ gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n \t  /* the 1 means to add the optional arg to formal list */\n \t  new_sym = get_iso_c_sym (sym, name, binding_label, 1);\n \t \n+\t  /* Set the kind for the SHAPE array to that of the actual\n+\t     (if given).  */\n+\t  if (c->ext.actual != NULL && c->ext.actual->next != NULL\n+\t      && c->ext.actual->next->expr->rank != 0)\n+\t    new_sym->formal->next->next->sym->ts.kind =\n+\t      c->ext.actual->next->next->expr->ts.kind;\n+\t \n \t  /* for error reporting, say it's declared where the original was */\n \t  new_sym->declared_at = sym->declared_at;\n \t}"}, {"sha": "474de8e5564b4d8b59258b936db52d7a44ab5355", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -3421,6 +3421,9 @@ gen_shape_param (gfc_formal_arglist **head,\n \n   /* Integer array, rank 1, describing the shape of the object.  */\n   param_sym->ts.type = BT_INTEGER;\n+  /* Initialize the kind to default integer.  However, it will be overriden\n+     during resolution to match the kind of the SHAPE parameter given as\n+     the actual argument (to allow for any valid integer kind).  */\n   param_sym->ts.kind = gfc_default_integer_kind;   \n   param_sym->as = gfc_get_array_spec ();\n "}, {"sha": "17280f45a1a97b92c39e8a9e07f96d147b06ee5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -1,4 +1,20 @@\n-2007-07-19  Christopher D. Rickett  <crickett@lanl.gov>\n+2007-07-21  Christopher D. Rickett  <crickett@lanl.gov>\n+\n+\tPR fortran/32627\n+\t* gfortran.dg/pr32627_driver.c: Driver for pr32627.\n+\t* gfortran.dg/pr32627.f03: New test case.\n+\n+\t* gfortran.dg/c_f_pointer_logical.f03: New test case.\n+\t* gfortran.dg/c_f_pointer_logical_driver.c: Driver for\n+\tc_f_pointer_logical.\n+\t* gfortran.dg/c_f_pointer_complex_driver.c: Driver for\n+\tc_f_pointer_complex.\n+\t* gfortran.dg/c_f_pointer_complex.f03: New test case.\n+\t* gfortran.dg/c_f_pointer_shape_tests_2_driver.c: Driver for\n+\tc_f_pointer_shape_tests_2.\n+\t* gfortran.dg/c_f_pointer_shape_tests_2.f03: New test case.\n+\n+2007-07-21  Christopher D. Rickett  <crickett@lanl.gov>\n \n \tPR fortran/32804\n \t* gfortran.dg/c_loc_tests_9.f03: New test case."}, {"sha": "fd9703139e5c976625979bc20004b9714b41bb22", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_complex.f03", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_complex.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_complex.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_complex.f03?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+! { dg-additional-sources c_f_pointer_complex_driver.c }\n+! { dg-options \"-std=gnu -w\" }\n+! Test c_f_pointer for the different types of interoperable complex values.\n+module c_f_pointer_complex\n+  use, intrinsic :: iso_c_binding, only: c_float_complex, c_double_complex, &\n+       c_long_double_complex, c_f_pointer, c_ptr, c_long_double, c_int\n+  implicit none\n+\n+contains\n+  subroutine test_complex_scalars(my_c_float_complex, my_c_double_complex, &\n+       my_c_long_double_complex) bind(c)\n+    type(c_ptr), value :: my_c_float_complex\n+    type(c_ptr), value :: my_c_double_complex\n+    type(c_ptr), value :: my_c_long_double_complex\n+    complex(c_float_complex), pointer :: my_f03_float_complex\n+    complex(c_double_complex), pointer :: my_f03_double_complex\n+    complex(c_long_double_complex), pointer :: my_f03_long_double_complex\n+    \n+    call c_f_pointer(my_c_float_complex, my_f03_float_complex)\n+    call c_f_pointer(my_c_double_complex, my_f03_double_complex)\n+    call c_f_pointer(my_c_long_double_complex, my_f03_long_double_complex)\n+\n+    if(my_f03_float_complex /= (1.0, 0.0)) call abort ()\n+    if(my_f03_double_complex /= (2.0d0, 0.0d0)) call abort ()\n+    if(my_f03_long_double_complex /= (3.0_c_long_double, &\n+         0.0_c_long_double)) call abort ()\n+  end subroutine test_complex_scalars\n+\n+  subroutine test_complex_arrays(float_complex_array, double_complex_array, &\n+       long_double_complex_array, num_elems) bind(c)\n+    type(c_ptr), value :: float_complex_array\n+    type(c_ptr), value :: double_complex_array\n+    type(c_ptr), value :: long_double_complex_array    \n+    complex(c_float_complex), pointer, dimension(:) :: f03_float_complex_array\n+    complex(c_double_complex), pointer, dimension(:) :: &\n+         f03_double_complex_array\n+    complex(c_long_double_complex), pointer, dimension(:) :: &\n+         f03_long_double_complex_array\n+    integer(c_int), value :: num_elems\n+    integer :: i\n+\n+    call c_f_pointer(float_complex_array, f03_float_complex_array, &\n+         (/ num_elems /))\n+    call c_f_pointer(double_complex_array, f03_double_complex_array, &\n+         (/ num_elems /))\n+    call c_f_pointer(long_double_complex_array, &\n+         f03_long_double_complex_array, (/ num_elems /))\n+\n+    do i = 1, num_elems\n+       if(f03_float_complex_array(i) &\n+            /= (i*(1.0, 0.0))) call abort ()\n+       if(f03_double_complex_array(i) &\n+            /= (i*(1.0d0, 0.0d0))) call abort ()\n+       if(f03_long_double_complex_array(i) &\n+            /= (i*(1.0_c_long_double, 0.0_c_long_double))) call abort ()\n+    end do\n+  end subroutine test_complex_arrays\n+end module c_f_pointer_complex\n+! { dg-final { cleanup-modules \"c_f_pointer_complex\" } }\n+"}, {"sha": "6286c34111938affdc3ee358f15995ac3d99893a", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_complex_driver.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_complex_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_complex_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_complex_driver.c?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-options \"-std=c99 -w\" } */\n+/* From c_by_val.c in gfortran.dg.  */\n+#define _Complex_I (1.0iF)\n+\n+#define NUM_ELEMS 10\n+\n+void test_complex_scalars (float _Complex *float_complex_ptr,\n+                           double _Complex *double_complex_ptr,\n+                           long double _Complex *long_double_complex_ptr);\n+void test_complex_arrays (float _Complex *float_complex_array,\n+                          double _Complex *double_complex_array,\n+                          long double _Complex *long_double_complex_array,\n+                          int num_elems);\n+\n+int main (int argc, char **argv)\n+{\n+  float _Complex c1;\n+  double _Complex c2;\n+  long double _Complex c3;\n+  float _Complex c1_array[NUM_ELEMS];\n+  double _Complex c2_array[NUM_ELEMS];\n+  long double _Complex c3_array[NUM_ELEMS];\n+  int i;\n+\n+  c1 = 1.0 + 0.0 * _Complex_I;\n+  c2 = 2.0 + 0.0 * _Complex_I;\n+  c3 = 3.0 + 0.0 * _Complex_I;\n+\n+  test_complex_scalars (&c1, &c2, &c3);\n+\n+  for (i = 0; i < NUM_ELEMS; i++)\n+    {\n+      c1_array[i] = 1.0 * (i+1) + 0.0 * _Complex_I;\n+      c2_array[i] = 1.0 * (i+1) + 0.0 * _Complex_I;\n+      c3_array[i] = 1.0 * (i+1) + 0.0 * _Complex_I;\n+    }\n+\n+  test_complex_arrays (c1_array, c2_array, c3_array, NUM_ELEMS);\n+\n+  return 0;\n+}"}, {"sha": "977c4cb070d03435d790e3c147b95e0ab2c98ab5", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_logical.f03", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_logical.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_logical.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_logical.f03?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+! { dg-additional-sources c_f_pointer_logical_driver.c }\n+! Verify that c_f_pointer exists for C logicals (_Bool).\n+module c_f_pointer_logical\n+  use, intrinsic :: iso_c_binding, only: c_bool, c_f_pointer, c_ptr, c_int\n+contains\n+  subroutine test_scalar(c_logical_ptr) bind(c)\n+    type(c_ptr), value :: c_logical_ptr\n+    logical(c_bool), pointer :: f03_logical_ptr\n+    call c_f_pointer(c_logical_ptr, f03_logical_ptr)\n+    \n+    if(f03_logical_ptr .neqv. .true.) call abort ()\n+  end subroutine test_scalar\n+\n+  subroutine test_array(c_logical_array, num_elems) bind(c)\n+    type(c_ptr), value :: c_logical_array\n+    integer(c_int), value :: num_elems\n+    logical(c_bool), pointer, dimension(:) :: f03_logical_array\n+    integer :: i\n+\n+    call c_f_pointer(c_logical_array, f03_logical_array, (/ num_elems /))\n+\n+    ! Odd numbered locations are true (even numbered offsets in C)\n+    do i = 1, num_elems, 2\n+       if(f03_logical_array(i) .neqv. .true.) call abort ()\n+    end do\n+    \n+    ! Even numbered locations are false.\n+    do i = 2, num_elems, 2\n+       if(f03_logical_array(i) .neqv. .false.) call abort ()\n+    end do\n+  end subroutine test_array\n+end module c_f_pointer_logical\n+! { dg-final { cleanup-modules \"c_f_pointer_logical\" } }"}, {"sha": "e3044c92e436e11ef9c6599b2780ca5d849f27c1", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_logical_driver.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_logical_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_logical_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_logical_driver.c?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-std=c99 -w\" } */\n+\n+#include <stdbool.h>\n+\n+#define NUM_ELEMS 10\n+\n+void test_scalar(_Bool *my_c_bool_ptr);\n+void test_array(_Bool *my_bool_array, int num_elems);\n+\n+int main(int argc, char **argv)\n+{\n+  _Bool my_bool = true;\n+  _Bool my_bool_array[NUM_ELEMS];\n+  int i;\n+\n+  test_scalar(&my_bool);\n+\n+  for(i = 0; i < NUM_ELEMS; i+=2)\n+    my_bool_array[i] = true;\n+  for(i = 1; i < NUM_ELEMS; i+=2)\n+    my_bool_array[i] = false;\n+\n+  test_array(my_bool_array, NUM_ELEMS);\n+  \n+  return 0;\n+}"}, {"sha": "5d6acc2f5741a3bcfd0b42dac4717a13659e57be", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_shape_tests_2.f03", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_2.f03?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -0,0 +1,91 @@\n+! { dg-do run }\n+! { dg-additional-sources c_f_pointer_shape_tests_2_driver.c }\n+! Verify that the optional SHAPE parameter to c_f_pointer can be of any\n+! valid integer kind.  We don't test all kinds here since it would be \n+! difficult to know what kinds are valid for the architecture we're running on.\n+! However, testing ones that should be different should be sufficient.\n+module c_f_pointer_shape_tests_2\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+contains\n+  subroutine test_long_long_1d(cPtr, num_elems) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_elems\n+    integer, dimension(:), pointer :: myArrayPtr\n+    integer(c_long_long), dimension(1) :: shape\n+    integer :: i\n+    \n+    shape(1) = num_elems\n+    call c_f_pointer(cPtr, myArrayPtr, shape) \n+    do i = 1, num_elems\n+       if(myArrayPtr(i) /= (i-1)) call abort ()\n+    end do\n+  end subroutine test_long_long_1d\n+\n+  subroutine test_long_long_2d(cPtr, num_rows, num_cols) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_rows\n+    integer(c_int), value :: num_cols\n+    integer, dimension(:,:), pointer :: myArrayPtr\n+    integer(c_long_long), dimension(2) :: shape\n+    integer :: i,j\n+    \n+    shape(1) = num_rows\n+    shape(2) = num_cols\n+    call c_f_pointer(cPtr, myArrayPtr, shape) \n+    do j = 1, num_cols\n+       do i = 1, num_rows\n+          if(myArrayPtr(i,j) /= ((j-1)*num_rows)+(i-1)) call abort ()\n+       end do\n+    end do\n+  end subroutine test_long_long_2d\n+\n+  subroutine test_long_1d(cPtr, num_elems) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_elems\n+    integer, dimension(:), pointer :: myArrayPtr\n+    integer(c_long), dimension(1) :: shape\n+    integer :: i\n+    \n+    shape(1) = num_elems\n+    call c_f_pointer(cPtr, myArrayPtr, shape) \n+    do i = 1, num_elems\n+       if(myArrayPtr(i) /= (i-1)) call abort ()\n+    end do\n+  end subroutine test_long_1d\n+\n+  subroutine test_int_1d(cPtr, num_elems) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_elems\n+    integer, dimension(:), pointer :: myArrayPtr\n+    integer(c_int), dimension(1) :: shape\n+    integer :: i\n+    \n+    shape(1) = num_elems\n+    call c_f_pointer(cPtr, myArrayPtr, shape) \n+    do i = 1, num_elems\n+       if(myArrayPtr(i) /= (i-1)) call abort ()\n+    end do\n+  end subroutine test_int_1d\n+\n+  subroutine test_short_1d(cPtr, num_elems) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_elems\n+    integer, dimension(:), pointer :: myArrayPtr\n+    integer(c_short), dimension(1) :: shape\n+    integer :: i\n+    \n+    shape(1) = num_elems\n+    call c_f_pointer(cPtr, myArrayPtr, shape) \n+    do i = 1, num_elems\n+       if(myArrayPtr(i) /= (i-1)) call abort ()\n+    end do\n+  end subroutine test_short_1d\n+end module c_f_pointer_shape_tests_2\n+! { dg-final { cleanup-modules \"c_f_pointer_shape_tests_2\" } } \n+"}, {"sha": "686ae8fe2898789c0512e86ce6dc9c60a4473601", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_shape_tests_2_driver.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_2_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_2_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_2_driver.c?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -0,0 +1,41 @@\n+#define NUM_ELEMS 10\n+#define NUM_ROWS 2\n+#define NUM_COLS 3\n+\n+void test_long_long_1d(int *array, int num_elems);\n+void test_long_long_2d(int *array, int num_rows, int num_cols);\n+void test_long_1d(int *array, int num_elems);\n+void test_int_1d(int *array, int num_elems);\n+void test_short_1d(int *array, int num_elems);\n+\n+int main(int argc, char **argv)\n+{\n+  int my_array[NUM_ELEMS];\n+  int my_2d_array[NUM_ROWS][NUM_COLS];\n+  int i, j;\n+\n+  for(i = 0; i < NUM_ELEMS; i++)\n+    my_array[i] = i;\n+\n+  for(i = 0; i < NUM_ROWS; i++)\n+    for(j = 0; j < NUM_COLS; j++)\n+      my_2d_array[i][j] = (i*NUM_COLS) + j;\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_long_long.  */\n+  test_long_long_1d(my_array, NUM_ELEMS);\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_long_long.  \n+     The indices are transposed for Fortran.  */\n+  test_long_long_2d(my_2d_array[0], NUM_COLS, NUM_ROWS);\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_long.  */\n+  test_long_1d(my_array, NUM_ELEMS);\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_int.  */\n+  test_int_1d(my_array, NUM_ELEMS);\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_short.  */\n+  test_short_1d(my_array, NUM_ELEMS);\n+  \n+  return 0;\n+}"}, {"sha": "f8695e00642d2d09eb59d61bc7f2a82de60c0931", "filename": "gcc/testsuite/gfortran.dg/pr32627.f03", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32627.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32627.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32627.f03?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+! { dg-additional-sources pr32627_driver.c }\n+! Verify that c_f_pointer exists for string arguments.\n+program main\n+  use iso_c_binding\n+  implicit none\n+  interface\n+     function get_c_string() bind(c)\n+       use, intrinsic :: iso_c_binding, only: c_ptr\n+       type(c_ptr) :: get_c_string\n+     end function get_c_string\n+  end interface\n+\n+  type, bind( c ) :: A\n+    integer( c_int ) :: xc, yc\n+    type( c_ptr )    :: str\n+  end type\n+  type( c_ptr )               :: x\n+  type( A ), pointer          :: fptr\n+  type( A ), target           :: my_a_type\n+  character( len=9 ), pointer :: strptr\n+\n+  fptr => my_a_type\n+\n+  fptr%str = get_c_string()\n+\n+  call c_f_pointer( fptr%str, strptr )\n+\n+  print *, 'strptr is: ', strptr\n+end program main\n+\n+  "}, {"sha": "24b7872ed6e74e6a5097a09a441ed30a715d6c45", "filename": "gcc/testsuite/gfortran.dg/pr32627_driver.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32627_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32627_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32627_driver.c?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -0,0 +1,4 @@\n+char *get_c_string()\n+{\n+  return \"c_string\";\n+}"}, {"sha": "56c5fcdcdbe0bd032a04df61231f49d627c423bd", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -1,3 +1,18 @@\n+2007-07-21  Christopher D. Rickett  <crickett@lanl.gov>\n+\n+\tPR fortran/32627\n+\t* libgfortran/intrinsics/iso_c_generated_procs.c: Add c_f_pointer\n+\tfor character/string arguments.\n+\t* libgfortran/intrinsic/iso_c_binding.c (c_f_pointer_u0): Allow\n+\tthe optional SHAPE arg to be any valid integer kind.\n+\t* libgfortran/gfortran.map: Add c_f_pointer_s0.\n+\t* libgfortran/mk-kinds-h.sh: Save smallest integer kind as default\n+\tcharacter kind.\n+\t* libgfortran/intrinsics/iso_c_generated_procs.c: Add versions of\n+\tc_f_pointer for complex and logical types.\n+\t* libgfortran/gfortran.map: Add c_f_pointer versions for logical\n+\tand complex types.\n+\n 2007-07-19  Christopher D. Rickett  <crickett@lanl.gov>\n \n \tPR fortran/32600"}, {"sha": "f118bf3277ceacc3739aae537aa6ab60e8cc99de", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -1016,6 +1016,15 @@ GFORTRAN_1.0 {\n     __iso_c_binding_c_f_pointer_r8;\n     __iso_c_binding_c_f_pointer_r10;\n     __iso_c_binding_c_f_pointer_r16;\n+    __iso_c_binding_c_f_pointer_c4;\n+    __iso_c_binding_c_f_pointer_c8;\n+    __iso_c_binding_c_f_pointer_c10;\n+    __iso_c_binding_c_f_pointer_c16;\n+    __iso_c_binding_c_f_pointer_s0;\n+    __iso_c_binding_c_f_pointer_l1;\n+    __iso_c_binding_c_f_pointer_l2;\n+    __iso_c_binding_c_f_pointer_l4;\n+    __iso_c_binding_c_f_pointer_l8;\n     __iso_c_binding_c_f_pointer_u0;\n     __iso_c_binding_c_f_procpointer;\n     __iso_c_binding_c_funloc;"}, {"sha": "101cc4e003975629b985377f40cd0ac3a55a37a2", "filename": "libgfortran/intrinsics/iso_c_binding.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/libgfortran%2Fintrinsics%2Fiso_c_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/libgfortran%2Fintrinsics%2Fiso_c_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_binding.c?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -109,7 +109,28 @@ ISO_C_BINDING_PREFIX (c_f_pointer_u0) (void *c_ptr_in,\n         {\n           /* Lower bound is 1, as specified by the draft.  */\n           f_ptr_out->dim[i].lbound = 1;\n-          f_ptr_out->dim[i].ubound = ((int *) (shape->data))[i];\n+          /* Have to allow for the SHAPE array to be any valid kind for\n+             an INTEGER type.  */\n+#ifdef HAVE_GFC_INTEGER_1\n+\t  if (GFC_DESCRIPTOR_SIZE (shape) == 1)\n+\t    f_ptr_out->dim[i].ubound = ((GFC_INTEGER_1 *) (shape->data))[i];\n+#endif\n+#ifdef HAVE_GFC_INTEGER_2\n+\t  if (GFC_DESCRIPTOR_SIZE (shape) == 2)\n+\t    f_ptr_out->dim[i].ubound = ((GFC_INTEGER_2 *) (shape->data))[i];\n+#endif\n+#ifdef HAVE_GFC_INTEGER_4\n+\t  if (GFC_DESCRIPTOR_SIZE (shape) == 4)\n+\t    f_ptr_out->dim[i].ubound = ((GFC_INTEGER_4 *) (shape->data))[i];\n+#endif\n+#ifdef HAVE_GFC_INTEGER_8\n+\t  if (GFC_DESCRIPTOR_SIZE (shape) == 8)\n+\t    f_ptr_out->dim[i].ubound = ((GFC_INTEGER_8 *) (shape->data))[i];\n+#endif\n+#ifdef HAVE_GFC_INTEGER_16\n+\t  if (GFC_DESCRIPTOR_SIZE (shape) == 16)\n+\t    f_ptr_out->dim[i].ubound = ((GFC_INTEGER_16 *) (shape->data))[i];\n+#endif\t\t\n         }\n \n       /* Set the offset and strides."}, {"sha": "aee0e57fef13bb8e4f359d806ad3fad827ab7a88", "filename": "libgfortran/intrinsics/iso_c_generated_procs.c", "status": "modified", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/libgfortran%2Fintrinsics%2Fiso_c_generated_procs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/libgfortran%2Fintrinsics%2Fiso_c_generated_procs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_generated_procs.c?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -75,11 +75,57 @@ void ISO_C_BINDING_PREFIX (c_f_pointer_r8) (void *, gfc_array_void *,\n void ISO_C_BINDING_PREFIX (c_f_pointer_r10) (void *, gfc_array_void *,\n \t\t\t\t\t     const array_t *);\n #endif\n+\n #ifdef HAVE_GFC_REAL_16\n void ISO_C_BINDING_PREFIX (c_f_pointer_r16) (void *, gfc_array_void *,\n \t\t\t\t\t     const array_t *);\n #endif\n \n+#ifdef HAVE_GFC_COMPLEX_4\n+void ISO_C_BINDING_PREFIX (c_f_pointer_c4) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_8\n+void ISO_C_BINDING_PREFIX (c_f_pointer_c8) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+void ISO_C_BINDING_PREFIX (c_f_pointer_c10) (void *, gfc_array_void *,\n+\t\t\t\t\t     const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+void ISO_C_BINDING_PREFIX (c_f_pointer_c16) (void *, gfc_array_void *,\n+\t\t\t\t\t     const array_t *);\n+#endif\n+\n+#ifdef GFC_DEFAULT_CHAR\n+void ISO_C_BINDING_PREFIX (c_f_pointer_s0) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_LOGICAL_1\n+void ISO_C_BINDING_PREFIX (c_f_pointer_l1) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_LOGICAL_2\n+void ISO_C_BINDING_PREFIX (c_f_pointer_l2) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_LOGICAL_4\n+void ISO_C_BINDING_PREFIX (c_f_pointer_l4) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_LOGICAL_8\n+void ISO_C_BINDING_PREFIX (c_f_pointer_l8) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n \n #ifdef HAVE_GFC_INTEGER_1\n /* Set the given Fortran pointer, 'f_ptr_out', to point to the given C\n@@ -262,3 +308,164 @@ ISO_C_BINDING_PREFIX (c_f_pointer_r16) (void *c_ptr_in,\n \t\t\t\t      (int) sizeof (GFC_REAL_16));\n }\n #endif\n+\n+\n+#ifdef HAVE_GFC_COMPLEX_4\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type complex and\n+   kind=4.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_c4) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have an complex(kind=4).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_COMPLEX,\n+\t\t\t\t      (int) sizeof (GFC_COMPLEX_4));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_COMPLEX_8\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type complex and\n+   kind=8.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_c8) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have an complex(kind=8).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_COMPLEX,\n+\t\t\t\t      (int) sizeof (GFC_COMPLEX_8));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type complex and\n+   kind=10.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_c10) (void *c_ptr_in,\n+\t\t\t\t\tgfc_array_void *f_ptr_out,\n+\t\t\t\t\tconst array_t *shape)\n+{\n+  /* Here we have an complex(kind=10).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_COMPLEX,\n+\t\t\t\t      (int) sizeof (GFC_COMPLEX_10));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type complex and\n+   kind=16.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_c16) (void *c_ptr_in,\n+\t\t\t\t\tgfc_array_void *f_ptr_out,\n+\t\t\t\t\tconst array_t *shape)\n+{\n+  /* Here we have an complex(kind=16).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_COMPLEX,\n+\t\t\t\t      (int) sizeof (GFC_COMPLEX_16));\n+}\n+#endif\n+\n+\n+#ifdef GFC_DEFAULT_CHAR\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type character.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_s0) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have a character string of len=1.  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_CHARACTER,\n+\t\t\t\t      (int) sizeof (char));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_LOGICAL_1\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type logical, kind=1.\t*/\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_l1) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have a logical of kind=1.\t*/\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_LOGICAL,\n+\t\t\t\t      (int) sizeof (GFC_LOGICAL_1));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_LOGICAL_2\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type logical, kind=2.\t*/\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_l2) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have a logical of kind=2.\t*/\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_LOGICAL,\n+\t\t\t\t      (int) sizeof (GFC_LOGICAL_2));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_LOGICAL_4\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type logical, kind=4.\t*/\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_l4) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have a logical of kind=4.\t*/\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_LOGICAL,\n+\t\t\t\t      (int) sizeof (GFC_LOGICAL_4));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_LOGICAL_8\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type logical, kind=8.\t*/\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_l8) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have a logical of kind=8.\t*/\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_LOGICAL,\n+\t\t\t\t      (int) sizeof (GFC_LOGICAL_8));\n+}\n+#endif"}, {"sha": "ccd073844c9b2928ad22ab86b941dcda1bd04144", "filename": "libgfortran/mk-kinds-h.sh", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad5cf725fa39fbc8569e99af088441bfb92f0db/libgfortran%2Fmk-kinds-h.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad5cf725fa39fbc8569e99af088441bfb92f0db/libgfortran%2Fmk-kinds-h.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fmk-kinds-h.sh?ref=6ad5cf725fa39fbc8569e99af088441bfb92f0db", "patch": "@@ -8,6 +8,7 @@ possible_real_kinds=\"4 8 10 16\"\n \n \n largest=\"\"\n+smallest=\"\"\n for k in $possible_integer_kinds; do\n   echo \"  integer (kind=$k) :: i\" > tmp$$.f90\n   echo \"  end\" >> tmp$$.f90\n@@ -21,6 +22,10 @@ for k in $possible_integer_kinds; do\n       prefix=\"\"\n     fi\n \n+    if [ \"$smallest\" = \"\" ]; then\n+\tsmallest=\"$k\"\n+    fi\n+\n     echo \"typedef ${prefix}int${s}_t GFC_INTEGER_${k};\"\n     echo \"typedef ${prefix}uint${s}_t GFC_UINTEGER_${k};\"\n     echo \"typedef GFC_INTEGER_${k} GFC_LOGICAL_${k};\"\n@@ -32,6 +37,7 @@ done\n \n echo \"#define GFC_INTEGER_LARGEST GFC_INTEGER_${largest}\"\n echo \"#define GFC_UINTEGER_LARGEST GFC_UINTEGER_${largest}\"\n+echo \"#define GFC_DEFAULT_CHAR ${smallest}\"\n echo \"\"\n \n "}]}