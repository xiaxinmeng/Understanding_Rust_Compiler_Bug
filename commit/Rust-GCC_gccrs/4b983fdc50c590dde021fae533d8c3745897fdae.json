{"sha": "4b983fdc50c590dde021fae533d8c3745897fdae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI5ODNmZGM1MGM1OTBkZGUwMjFmYWU1MzNkOGMzNzQ1ODk3ZmRhZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-07-28T17:46:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-07-28T17:46:18Z"}, "message": "cse.c (canon_hash): Handle PRE_MODIFY/POST_MODIFY.\n\n\t* cse.c (canon_hash): Handle PRE_MODIFY/POST_MODIFY.\n\t(cse_insn): Likewise.\n\t(addr_affects_sp_p): Likewise.\n\t* expr.c (move_by_pieces): Likewise.\n\t(clear_by_pieces): Likewise.\n\t* gcse.c (oprs_unchanged_p): Likewise.\n\t* haifa-sched.c (sched_analyze_2): Likewise.\n\t* recog.c (offsettable_address_p): Likewise.\n\t* regclass.c (record_address_regs): Likewise.\n\t* reload.c (find_reusable_reload): Likewise.\n\t(push_reload): Likewise.\n\t(operands_match_p): Likewise.\n\t(decompose): Likewise.\n\t(find_reloads_address_1): Likewise.\n\t(find_inc_amount): Likewise.\n\t* reload1.c (elimination_effects): Likewise.\n\t* resource.c (mark_set_resources): Likewise.\n\t* flow.c (attempt_auto_inc): New function; mostly broken out\n\tof find_auto_inc.\n\t(find_auto_inc): Split into two functions and enhanced to\n\tgenerate POST_MODIFY.\n\t* rtl.def (PRE_MODIFY, POST_MODIFY): Adjust comment.\n\t* rtl.h (count_all_occurrences):  Declare.\n\t(HAVE_{PRE,POST}_MODIFY_{DISP,REG}): Provide default of 0 if not\n\tdefined.\n\t* rtlanal.c (count_all_occurrences): New function.\n\t* tm.texi (HAVE_POST_MODIFY_DISP, HAVE_PRE_MODIFY_DISP,\n\tHAVE_POST_MODIFY_REG, HAVE_PRE_MODIFY_REG): Document.\n\n\t* config/ia64/ia64-protos.h (destination_operand): Declare.\n\t* config/ia64/ia64.c (destination_operand): New function.\n\t(ia64_print_operand): Handle POST_MODIFY.\n\t(rtx_needs_barrier): Likewise.\n\t* config/ia64/ia64.h (HAVE_POST_MODIFY_DISP): Define to 1.\n\t(HAVE_POST_MODIFY_REG): Define to 1.\n\t(MAX_REGS_PER_ADDRESS): Change to 2.\n\t(GO_IF_LEGITIMATE_ADDRESS): Accept POST_MODIFY too.\n\t(LEGITIMATE_ADDRESS_REG): New helper macro.\n\t(LEGITIMATE_ADDRESS_DISP): Likewise.\n\t(PREDICATE_CODES): Add entry for destination_operand.\n\t* config/ia64/ia64.md (all mov patterns): Use destination_operand\n\tpredicate for operand 0.\n\nFrom-SVN: r35321", "tree": {"sha": "c6bbf69024ca51b064647b9762f5100f294e8b2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6bbf69024ca51b064647b9762f5100f294e8b2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b983fdc50c590dde021fae533d8c3745897fdae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b983fdc50c590dde021fae533d8c3745897fdae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b983fdc50c590dde021fae533d8c3745897fdae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b983fdc50c590dde021fae533d8c3745897fdae/comments", "author": null, "committer": null, "parents": [{"sha": "777ba8d110978fc69481e5f50ebcca1fd39a8542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777ba8d110978fc69481e5f50ebcca1fd39a8542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777ba8d110978fc69481e5f50ebcca1fd39a8542"}], "stats": {"total": 1001, "additions": 670, "deletions": 331}, "files": [{"sha": "af5255c24643ff8c95a2aab0571def1221a67993", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -1,3 +1,52 @@\n+2000-07-28  Richard Henderson  <rth@cygnus.com>\n+\n+\t* emit-rtl.c (gen_lowpart_common): Add missing 'c' variable.\n+\n+2000-07-28  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* cse.c (canon_hash): Handle PRE_MODIFY/POST_MODIFY.\n+\t(cse_insn): Likewise.\n+\t(addr_affects_sp_p): Likewise.\n+\t* expr.c (move_by_pieces): Likewise.\n+\t(clear_by_pieces): Likewise.\n+\t* gcse.c (oprs_unchanged_p): Likewise.\n+\t* haifa-sched.c (sched_analyze_2): Likewise.\n+\t* recog.c (offsettable_address_p): Likewise.\n+\t* regclass.c (record_address_regs): Likewise.\n+\t* reload.c (find_reusable_reload): Likewise.\n+\t(push_reload): Likewise.\n+\t(operands_match_p): Likewise.\n+\t(decompose): Likewise.\n+\t(find_reloads_address_1): Likewise.\n+\t(find_inc_amount): Likewise.\n+\t* reload1.c (elimination_effects): Likewise.\n+\t* resource.c (mark_set_resources): Likewise.\n+\t* flow.c (attempt_auto_inc): New function; mostly broken out\n+\tof find_auto_inc.\n+\t(find_auto_inc): Split into two functions and enhanced to\n+\tgenerate POST_MODIFY.\n+\t* rtl.def (PRE_MODIFY, POST_MODIFY): Adjust comment.\n+\t* rtl.h (count_all_occurrences):  Declare.\n+\t(HAVE_{PRE,POST}_MODIFY_{DISP,REG}): Provide default of 0 if not\n+\tdefined.\n+\t* rtlanal.c (count_all_occurrences): New function.\n+\t* tm.texi (HAVE_POST_MODIFY_DISP, HAVE_PRE_MODIFY_DISP,\n+\tHAVE_POST_MODIFY_REG, HAVE_PRE_MODIFY_REG): Document.\n+\n+\t* config/ia64/ia64-protos.h (destination_operand): Declare.\n+\t* config/ia64/ia64.c (destination_operand): New function.\n+\t(ia64_print_operand): Handle POST_MODIFY.\n+\t(rtx_needs_barrier): Likewise.\n+\t* config/ia64/ia64.h (HAVE_POST_MODIFY_DISP): Define to 1.\n+\t(HAVE_POST_MODIFY_REG): Define to 1.\n+\t(MAX_REGS_PER_ADDRESS): Change to 2.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Accept POST_MODIFY too.\n+\t(LEGITIMATE_ADDRESS_REG): New helper macro.\n+\t(LEGITIMATE_ADDRESS_DISP): Likewise.\n+\t(PREDICATE_CODES): Add entry for destination_operand.\n+\t* config/ia64/ia64.md (all mov patterns): Use destination_operand\n+\tpredicate for operand 0.\n+\n 2000-07-28  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* dwarf2out.c: Indent #error directive.\n@@ -311,8 +360,8 @@ Mon Jul 24 02:04:52 2000  Jeffrey A Law  (law@cygnus.com)\n \n Sun Jul 23 14:49:12 2000  Jason Eckhardt  <jle@cygnus.com> \n \n-        * config/i860/i860.md (untyped_call expander): Use GEN_CALL \n-        instead of gen_call.\n+\t* config/i860/i860.md (untyped_call expander): Use GEN_CALL \n+\tinstead of gen_call.\n \n Sun Jul 23 11:52:03 2000  George Helffrich (george@gly.bris.ac.uk)\n "}, {"sha": "83213d1e88187c87071ace5d6ca752a3a0347907", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -1374,7 +1374,7 @@ alias.o : alias.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h \\\n    $(REGS_H) toplev.h output.h $(EXPR_H) insn-flags.h $(GGC_H) function.h \\\n    cselib.h $(TREE_H)\n regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n-   $(RECOG_H) output.h reload.h $(REGS_H) hard-reg-set.h flags.h function.h \\\n+   $(RECOG_H) output.h $(REGS_H) hard-reg-set.h flags.h function.h \\\n    $(EXPR_H) insn-flags.h $(BASIC_BLOCK_H) toplev.h\n haifa-sched.o : haifa-sched.c $(CONFIG_H) system.h $(RTL_H) \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\"}, {"sha": "00421f8a4f17f5e179ddf814304005506e0e2d8b", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -49,6 +49,15 @@ extern int reg_or_fp01_operand PARAMS((rtx, enum machine_mode));\n extern int normal_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int adjusted_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int call_multiple_values_operation PARAMS((rtx, enum machine_mode));\n+extern int destination_operand PARAMS((rtx, enum machine_mode));\n+extern int ia64_rap_fp_offset PARAMS((void));\n+extern unsigned int ia64_compute_frame_size PARAMS((int));\n+extern void save_restore_insns PARAMS((int));\n+extern void ia64_expand_prologue PARAMS((void));\n+extern void ia64_expand_epilogue PARAMS((void));\n+extern void ia64_function_prologue PARAMS((FILE *, int));\n+extern void ia64_funtion_epilogue PARAMS((FILE *, int));\n+extern int ia64_direct_return PARAMS((void));\n extern int predicate_operator PARAMS((rtx, enum machine_mode));\n extern int ia64_move_ok PARAMS((rtx, rtx));\n "}, {"sha": "c8de224beba1691fd8a1f71f0ddf945713be05c1", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -469,6 +469,23 @@ reg_or_fp01_operand (op, mode)\n \t  || register_operand (op, mode));\n }\n \n+/* Like nonimmediate_operand, but don't allow MEMs that try to use a\n+   POST_MODIFY with a REG as displacement.  */\n+\n+int\n+destination_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (! nonimmediate_operand (op, mode))\n+    return 0;\n+  if (GET_CODE (op) == MEM\n+      && GET_CODE (XEXP (op, 0)) == POST_MODIFY\n+      && GET_CODE (XEXP (XEXP (XEXP (op, 0), 1), 1)) == REG)\n+    return 0;\n+  return 1;\n+}\n+\n /* Return 1 if this is a comparison operator, which accepts an normal 8-bit\n    signed immediate operand.  */\n \n@@ -1971,28 +1988,47 @@ ia64_print_operand (file, x, code)\n \n     case 'P':\n       {\n-\tint value;\n+\tHOST_WIDE_INT value;\n \n-\tif (GET_CODE (XEXP (x, 0)) != POST_INC\n-\t    && GET_CODE (XEXP (x, 0)) != POST_DEC)\n-\t  return;\n+\tswitch (GET_CODE (XEXP (x, 0)))\n+\t  {\n+\t  default:\n+\t    return;\n \n-\tfputs (\", \", file);\n+\t  case POST_MODIFY:\n+\t    x = XEXP (XEXP (XEXP (x, 0), 1), 1);\n+\t    if (GET_CODE (x) == CONST_INT)\n+\t      value = INTVAL (y);\n+\t    else if (GET_CODE (x) == REG)\n+\t      {\n+\t\tfprintf (file, \", %s\", reg_names[REGNO (y)]);\n+\t\treturn;\n+\t      }\n+\t    else\n+\t      abort ();\n+\t    break;\n \n-\tvalue = GET_MODE_SIZE (GET_MODE (x));\n+\t  case POST_INC:\n+\t    value = GET_MODE_SIZE (GET_MODE (x));\n \n-\t/* ??? This is for ldf.fill and stf.spill which use XFmode, but which\n-\t   actually need 16 bytes increments.  Perhaps we can change them\n-\t   to use TFmode instead.  Or don't use POST_DEC/POST_INC for them.\n-\t   Currently, there are no other uses of XFmode, so hacking it here\n-\t   is no problem.  */\n-\tif (value == 12)\n-\t  value = 16;\n+\t    /* ??? This is for ldf.fill and stf.spill which use XFmode,\n+\t       but which actually need 16 bytes increments.  Perhaps we\n+\t       can change them to use TFmode instead.  Or don't use\n+\t       POST_DEC/POST_INC for them.  */\n+\t    if (value == 12)\n+\t      value = 16;\n+\t    break;\n \n-\tif (GET_CODE (XEXP (x, 0)) == POST_DEC)\n-\t  value = -value;\n+\t  case POST_DEC:\n+\t    value = - GET_MODE_SIZE (GET_MODE (x));\n+\t    if (value == -12)\n+\t      value = -16;\n+\t    break;\n+\t  }\n \n-\tfprintf (file, \"%d\", value);\n+\tputc (',', file);\n+\tputc (' ', file);\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, value);\n \treturn;\n       }\n \n@@ -2074,8 +2110,6 @@ ia64_print_operand (file, x, code)\n \t  unsigned int regno = REGNO (XEXP (x, 0));\n \t  if (GET_CODE (x) == EQ)\n \t    regno += 1;\n-\t  if (code == 'j')\n-\t    regno ^= 1;\n           fprintf (file, \"(%s) \", reg_names [regno]);\n \t}\n       return;\n@@ -2089,6 +2123,8 @@ ia64_print_operand (file, x, code)\n     {\n       /* This happens for the spill/restore instructions.  */\n     case POST_INC:\n+    case POST_DEC:\n+    case POST_MODIFY:\n       x = XEXP (x, 0);\n       /* ... fall through ... */\n \n@@ -2099,7 +2135,7 @@ ia64_print_operand (file, x, code)\n     case MEM:\n       {\n \trtx addr = XEXP (x, 0);\n-\tif (GET_CODE (addr) == POST_INC || GET_CODE (addr) == POST_DEC)\n+\tif (GET_RTX_CLASS (GET_CODE (addr)) == 'a')\n \t  addr = XEXP (addr, 0);\n \tfprintf (file, \"[%s]\", reg_names [REGNO (addr)]);\n \tbreak;\n@@ -2749,6 +2785,17 @@ rtx_needs_barrier (x, flags, pred)\n       need_barrier |= rws_access_reg (REGNO (XEXP (x, 0)), new_flags, pred);\n       break;\n \n+    case POST_MODIFY:\n+      if (GET_CODE (XEXP (x, 0)) != REG)\n+\tabort ();\n+\n+      new_flags.is_write = 0;\n+      need_barrier  = rws_access_reg (REGNO (XEXP (x, 0)), new_flags, pred);\n+      need_barrier |= rtx_needs_barrier (XEXP (x, 1), new_flags, pred);\n+      new_flags.is_write = 1;\n+      need_barrier |= rws_access_reg (REGNO (XEXP (x, 0)), new_flags, pred);\n+      break;\n+\n       /* Handle common unary and binary ops for efficiency.  */\n     case COMPARE:  case PLUS:    case MINUS:   case MULT:      case DIV:\n     case MOD:      case UDIV:    case UMOD:    case AND:       case IOR:"}, {"sha": "6379ae7bc430ad6630132b6c44d3b788426813ab", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -1790,6 +1790,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define HAVE_POST_INCREMENT 1\n #define HAVE_POST_DECREMENT 1\n+#define HAVE_POST_MODIFY_DISP 1\n+#define HAVE_POST_MODIFY_REG 1\n \n /* A C expression that is 1 if the RTX X is a constant which is a valid\n    address.  */\n@@ -1798,31 +1800,38 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* The max number of registers that can appear in a valid memory address.  */\n \n-#define MAX_REGS_PER_ADDRESS 1\n+#define MAX_REGS_PER_ADDRESS 2\n \n /* A C compound statement with a conditional `goto LABEL;' executed if X (an\n    RTX) is a legitimate memory address on the target machine for a memory\n    operand of mode MODE.  */\n \n-/* ??? IA64 post increment addressing mode is much more powerful than this.  */\n+#define LEGITIMATE_ADDRESS_REG(X)\t\t\t\t\t\\\n+  ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n+   || (GET_CODE (X) == SUBREG && GET_CODE (XEXP (X, 0)) == REG\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (X, 0))))\n+\n+#define LEGITIMATE_ADDRESS_DISP(R, X)\t\t\t\t\t\\\n+  (GET_CODE (X) == PLUS\t\t\t\t\t\t\t\\\n+   && rtx_equal_p (R, XEXP (X, 0))\t\t\t\t\t\\\n+   && (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\t\\\n+       || (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+\t   && INTVAL (XEXP (X, 1)) >= -512\t\t\t\t\\\n+\t   && INTVAL (XEXP (X, 1)) < 512)))\n \n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n+  if (LEGITIMATE_ADDRESS_REG (X))\t\t\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == SUBREG && GET_CODE (XEXP (X, 0)) == REG\t\\\n-\t   && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\t\\\n+  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == POST_DEC)\t\\\n+\t   && LEGITIMATE_ADDRESS_REG (XEXP (X, 0))\t\t\t\\\n+\t   && XEXP (X, 0) != arg_pointer_rtx)\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == POST_MODIFY\t\t\t\t\t\\\n+\t   && LEGITIMATE_ADDRESS_REG (XEXP (X, 0))\t\t\t\\\n+\t   && XEXP (X, 0) != arg_pointer_rtx\t\t\t\t\\\n+\t   && LEGITIMATE_ADDRESS_DISP (XEXP (X, 0), XEXP (X, 1)))\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == POST_INC || GET_CODE (X) == POST_DEC)\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\t\\\n-\tgoto LABEL;\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (X, 0)) == SUBREG\t\t\t\t\\\n-\t       && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\\\n-\t       && REG_OK_FOR_BASE_P (XEXP (XEXP (X, 0), 0)))\t\t\\\n-\tgoto LABEL;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n /* A C expression that is nonzero if X (assumed to be a `reg' RTX) is valid for\n@@ -2719,6 +2728,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"symbolic_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n { \"function_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n { \"setjmp_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n+{ \"destination_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n { \"move_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n \t\t     CONSTANT_P_RTX, SYMBOL_REF, CONST, LABEL_REF}},\t\\\n { \"reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\"}, {"sha": "872ef6bc753193b95d54b6a5d584e335f23b7bc3", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -201,8 +201,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movqi_internal_astep\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*f,*f\")\n-\t(match_operand:QI 1 \"move_operand\"         \"rO,J,m,rO,*f,rO,*f\"))]\n+  [(set (match_operand:QI 0 \"destination_operand\" \"=r,r,r, m, r,*f,*f\")\n+\t(match_operand:QI 1 \"move_operand\"        \"rO,J,m,rO,*f,rO,*f\"))]\n   \"TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n    mov %0 = %r1\n@@ -216,8 +216,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*f,*f\")\n-\t(match_operand:QI 1 \"move_operand\"         \"rO,J,m,rO,*f,rO,*f\"))]\n+  [(set (match_operand:QI 0 \"destination_operand\" \"=r,r,r, m, r,*f,*f\")\n+\t(match_operand:QI 1 \"move_operand\"        \"rO,J,m,rO,*f,rO,*f\"))]\n   \"! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n    mov %0 = %r1\n@@ -259,8 +259,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movhi_internal_astep\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*f,*f\")\n-\t(match_operand:HI 1 \"move_operand\"         \"rO,J,m,rO,*f,rO,*f\"))]\n+  [(set (match_operand:HI 0 \"destination_operand\" \"=r,r,r, m, r,*f,*f\")\n+\t(match_operand:HI 1 \"move_operand\"        \"rO,J,m,rO,*f,rO,*f\"))]\n   \"TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n    mov %0 = %r1\n@@ -274,8 +274,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*f,*f\")\n-\t(match_operand:HI 1 \"move_operand\"         \"rO,J,m,rO,*f,rO,*f\"))]\n+  [(set (match_operand:HI 0 \"destination_operand\" \"=r,r,r, m, r,*f,*f\")\n+\t(match_operand:HI 1 \"move_operand\"        \"rO,J,m,rO,*f,rO,*f\"))]\n   \"! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n    mov %0 = %r1\n@@ -318,8 +318,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movsi_internal_astep\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r, m, r,*f,*f\")\n-\t(match_operand:SI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f\"))]\n+  [(set (match_operand:SI 0 \"destination_operand\" \"=r,r,r,r, m, r,*f,*f\")\n+\t(match_operand:SI 1 \"move_operand\"        \"rO,J,i,m,rO,*f,rO,*f\"))]\n   \"TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %r1\n@@ -334,8 +334,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r, m, r,*f,*f\")\n-\t(match_operand:SI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f\"))]\n+  [(set (match_operand:SI 0 \"destination_operand\" \"=r,r,r,r, m, r,*f,*f\")\n+\t(match_operand:SI 1 \"move_operand\"        \"rO,J,i,m,rO,*f,rO,*f\"))]\n   \"! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %r1\n@@ -407,8 +407,10 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movdi_internal_astep\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r, m,r,*f,*f,*f,Q, r,*b\")\n-\t(match_operand:DI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f,Q,*f,*b,rO\"))]\n+  [(set (match_operand:DI 0 \"destination_operand\"\n+\t\t\t    \"=r,r,r,r, m, r,*f,*f,*f, Q, r,*b\")\n+\t(match_operand:DI 1 \"move_operand\"\n+\t\t\t    \"rO,J,i,m,rO,*f,rO,*f, Q,*f,*b,rO\"))]\n   \"TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"*\n {\n@@ -437,8 +439,10 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movdi_internal\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r, m,r,*f,*f,*f,Q, r,*b\")\n-\t(match_operand:DI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f,Q,*f,*b,rO\"))]\n+  [(set (match_operand:DI 0 \"destination_operand\"\n+\t\t\t    \"=r,r,r,r, m, r,*f,*f,*f, Q, r,*b\")\n+\t(match_operand:DI 1 \"move_operand\"\n+\t\t\t    \"rO,J,i,m,rO,*f,rO,*f, Q,*f,*b,rO\"))]\n   \"! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"*\n {\n@@ -573,8 +577,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movsf_internal_astep\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n-\t(match_operand:SF 1 \"general_operand\"      \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n+  [(set (match_operand:SF 0 \"destination_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n+\t(match_operand:SF 1 \"general_operand\"     \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n   \"TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %F1\n@@ -589,8 +593,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movsf_internal\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n-\t(match_operand:SF 1 \"general_operand\"      \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n+  [(set (match_operand:SF 0 \"destination_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n+\t(match_operand:SF 1 \"general_operand\"     \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n   \"! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %F1\n@@ -632,8 +636,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movdf_internal_astep\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n-\t(match_operand:DF 1 \"general_operand\"      \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n+  [(set (match_operand:DF 0 \"destination_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n+\t(match_operand:DF 1 \"general_operand\"     \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n   \"TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %F1\n@@ -648,8 +652,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movdf_internal\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n-\t(match_operand:DF 1 \"general_operand\"      \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n+  [(set (match_operand:DF 0 \"destination_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n+\t(match_operand:DF 1 \"general_operand\"     \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n   \"! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %F1\n@@ -689,8 +693,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movxf_internal_astep\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,f, m\")\n-\t(match_operand:XF 1 \"general_operand\"      \"fG,m,fG\"))]\n+  [(set (match_operand:XF 0 \"destination_operand\" \"=f,f, m\")\n+\t(match_operand:XF 1 \"general_operand\"     \"fG,m,fG\"))]\n   \"TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %F1\n@@ -700,8 +704,8 @@\n    (set_attr \"predicable\" \"no\")])\n \n (define_insn \"*movxf_internal\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,f, m\")\n-\t(match_operand:XF 1 \"general_operand\"      \"fG,m,fG\"))]\n+  [(set (match_operand:XF 0 \"destination_operand\" \"=f,f, m\")\n+\t(match_operand:XF 1 \"general_operand\"     \"fG,m,fG\"))]\n   \"! TARGET_A_STEP && ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %F1"}, {"sha": "69ef933b66ec7599f4a0472bded0da830bd7ab16", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -2271,6 +2271,8 @@ canon_hash (x, mode)\n     case PRE_INC:\n     case POST_DEC:\n     case POST_INC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n     case PC:\n     case CC0:\n     case CALL:\n@@ -5472,8 +5474,7 @@ cse_insn (insn, libcall_insn)\n #ifdef PUSH_ROUNDING\n \t  /* Stack pushes invalidate the stack pointer.  */\n \t  rtx addr = XEXP (dest, 0);\n-\t  if ((GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == PRE_INC\n-\t       || GET_CODE (addr) == POST_DEC || GET_CODE (addr) == POST_INC)\n+\t  if (GET_RTX_CLASS (GET_CODE (addr)) == 'a'\n \t      && XEXP (addr, 0) == stack_pointer_rtx)\n \t    invalidate (stack_pointer_rtx, Pmode);\n #endif\n@@ -6085,8 +6086,7 @@ static int\n addr_affects_sp_p (addr)\n      register rtx addr;\n {\n-  if ((GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == PRE_INC\n-       || GET_CODE (addr) == POST_DEC || GET_CODE (addr) == POST_INC)\n+  if (GET_RTX_CLASS (GET_CODE (addr)) == 'a'\n       && GET_CODE (XEXP (addr, 0)) == REG\n       && REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n     {"}, {"sha": "7749d89bc98bb828d403b9935a55eecf63b03c96", "filename": "gcc/flow.c", "status": "modified", "additions": 214, "deletions": 158, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -372,6 +372,8 @@ static rtx not_reg_cond\t\t\tPARAMS ((rtx));\n static rtx nand_reg_cond\t\tPARAMS ((rtx, rtx));\n #endif\n #ifdef AUTO_INC_DEC\n+static void attempt_auto_inc\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t rtx, rtx, rtx, rtx, rtx));\n static void find_auto_inc\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx, rtx));\n static int try_pre_increment_1\t\tPARAMS ((struct propagate_block_info *,\n@@ -4800,6 +4802,156 @@ nand_reg_cond (old, x)\n \f\n #ifdef AUTO_INC_DEC\n \n+/* Try to substitute the auto-inc expression INC as the address inside\n+   MEM which occurs in INSN.  Currently, the address of MEM is an expression\n+   involving INCR_REG, and INCR is the next use of INCR_REG; it is an insn\n+   that has a single set whose source is a PLUS of INCR_REG and something\n+   else.  */\n+\n+static void\n+attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n+     struct propagate_block_info *pbi;\n+     rtx inc, insn, mem, incr, incr_reg;\n+{\n+  int regno = REGNO (incr_reg);\n+  rtx set = single_set (incr);\n+  rtx q = SET_DEST (set);\n+  rtx y = SET_SRC (set);\n+  int opnum = XEXP (y, 0) == incr_reg ? 0 : 1;\n+\n+  /* Make sure this reg appears only once in this insn.  */\n+  if (count_occurrences (PATTERN (insn), incr_reg, 1) != 1)\n+    return;\n+\n+  if (dead_or_set_p (incr, incr_reg)\n+      /* Mustn't autoinc an eliminable register.  */\n+      && (regno >= FIRST_PSEUDO_REGISTER\n+\t  || ! TEST_HARD_REG_BIT (elim_reg_set, regno)))\n+    {\n+      /* This is the simple case.  Try to make the auto-inc.  If\n+\t we can't, we are done.  Otherwise, we will do any\n+\t needed updates below.  */\n+      if (! validate_change (insn, &XEXP (mem, 0), inc, 0))\n+\treturn;\n+    }\n+  else if (GET_CODE (q) == REG\n+\t   /* PREV_INSN used here to check the semi-open interval\n+\t      [insn,incr).  */\n+\t   && ! reg_used_between_p (q,  PREV_INSN (insn), incr)\n+\t   /* We must also check for sets of q as q may be\n+\t      a call clobbered hard register and there may\n+\t      be a call between PREV_INSN (insn) and incr.  */\n+\t   && ! reg_set_between_p (q,  PREV_INSN (insn), incr))\n+    {\n+      /* We have *p followed sometime later by q = p+size.\n+\t Both p and q must be live afterward,\n+\t and q is not used between INSN and its assignment.\n+\t Change it to q = p, ...*q..., q = q+size.\n+\t Then fall into the usual case.  */\n+      rtx insns, temp;\n+      basic_block bb;\n+\n+      start_sequence ();\n+      emit_move_insn (q, incr_reg);\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      if (basic_block_for_insn)\n+\tfor (temp = insns; temp; temp = NEXT_INSN (temp))\n+\t  set_block_for_insn (temp, pbi->bb);\n+\n+      /* If we can't make the auto-inc, or can't make the\n+\t replacement into Y, exit.  There's no point in making\n+\t the change below if we can't do the auto-inc and doing\n+\t so is not correct in the pre-inc case.  */\n+\n+      XEXP (inc, 0) = q;\n+      validate_change (insn, &XEXP (mem, 0), inc, 1);\n+      validate_change (incr, &XEXP (y, opnum), q, 1);\n+      if (! apply_change_group ())\n+\treturn;\n+\n+      /* We now know we'll be doing this change, so emit the\n+\t new insn(s) and do the updates.  */\n+      emit_insns_before (insns, insn);\n+\n+      if (pbi->bb->head == insn)\n+\tpbi->bb->head = insns;\n+\n+      /* INCR will become a NOTE and INSN won't contain a\n+\t use of INCR_REG.  If a use of INCR_REG was just placed in\n+\t the insn before INSN, make that the next use. \n+\t Otherwise, invalidate it.  */\n+      if (GET_CODE (PREV_INSN (insn)) == INSN\n+\t  && GET_CODE (PATTERN (PREV_INSN (insn))) == SET\n+\t  && SET_SRC (PATTERN (PREV_INSN (insn))) == incr_reg)\n+\tpbi->reg_next_use[regno] = PREV_INSN (insn);\n+      else\n+\tpbi->reg_next_use[regno] = 0;\n+\n+      incr_reg = q;\n+      regno = REGNO (q);\n+\n+      /* REGNO is now used in INCR which is below INSN, but\n+\t it previously wasn't live here.  If we don't mark\n+\t it as live, we'll put a REG_DEAD note for it\n+\t on this insn, which is incorrect.  */\n+      SET_REGNO_REG_SET (pbi->reg_live, regno);\n+\n+      /* If there are any calls between INSN and INCR, show\n+\t that REGNO now crosses them.  */\n+      for (temp = insn; temp != incr; temp = NEXT_INSN (temp))\n+\tif (GET_CODE (temp) == CALL_INSN)\n+\t  REG_N_CALLS_CROSSED (regno)++;\n+    }\n+  else\n+    return;\n+\n+  /* If we haven't returned, it means we were able to make the\n+     auto-inc, so update the status.  First, record that this insn\n+     has an implicit side effect.  */\n+\n+  REG_NOTES (insn)\n+    = alloc_EXPR_LIST (REG_INC, incr_reg, REG_NOTES (insn));\n+\n+  /* Modify the old increment-insn to simply copy\n+     the already-incremented value of our register.  */\n+  if (! validate_change (incr, &SET_SRC (set), incr_reg, 0))\n+    abort ();\n+\n+  /* If that makes it a no-op (copying the register into itself) delete\n+     it so it won't appear to be a \"use\" and a \"set\" of this\n+     register.  */\n+  if (REGNO (SET_DEST (set)) == REGNO (incr_reg))\n+    {\n+      /* If the original source was dead, it's dead now.  */\n+      rtx note;\n+      \n+      while (note = find_reg_note (incr, REG_DEAD, NULL_RTX))\n+\t{\n+\t  remove_note (incr, note);\n+\t  if (XEXP (note, 0) != incr_reg)\n+\t    CLEAR_REGNO_REG_SET (pbi->reg_live, REGNO (XEXP (note, 0)));\n+\t}\n+\n+      PUT_CODE (incr, NOTE);\n+      NOTE_LINE_NUMBER (incr) = NOTE_INSN_DELETED;\n+      NOTE_SOURCE_FILE (incr) = 0;\n+    }\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      /* Count an extra reference to the reg.  When a reg is\n+\t incremented, spilling it is worse, so we want to make\n+\t that less likely.  */\n+      REG_N_REFS (regno) += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n+\n+      /* Count the increment as a setting of the register,\n+\t even though it isn't a SET in rtl.  */\n+      REG_N_SETS (regno)++;\n+    }\n+}\n+\n /* X is a MEM found in INSN.  See if we can convert it into an auto-increment\n    reference.  */\n \n@@ -4811,178 +4963,82 @@ find_auto_inc (pbi, x, insn)\n {\n   rtx addr = XEXP (x, 0);\n   HOST_WIDE_INT offset = 0;\n-  rtx set;\n+  rtx set, y, incr, inc_val;\n+  int regno;\n+  int size = GET_MODE_SIZE (GET_MODE (x));\n+\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    return;\n \n   /* Here we detect use of an index register which might be good for\n      postincrement, postdecrement, preincrement, or predecrement.  */\n \n   if (GET_CODE (addr) == PLUS && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n     offset = INTVAL (XEXP (addr, 1)), addr = XEXP (addr, 0);\n \n-  if (GET_CODE (addr) == REG)\n-    {\n-      register rtx y;\n-      register int size = GET_MODE_SIZE (GET_MODE (x));\n-      rtx use;\n-      rtx incr;\n-      int regno = REGNO (addr);\n-\n-      /* Is the next use an increment that might make auto-increment? */\n-      if ((incr = pbi->reg_next_use[regno]) != 0\n-\t  && (set = single_set (incr)) != 0\n-\t  && GET_CODE (set) == SET\n-\t  && BLOCK_NUM (incr) == BLOCK_NUM (insn)\n-\t  /* Can't add side effects to jumps; if reg is spilled and\n-\t     reloaded, there's no way to store back the altered value.  */\n-\t  && GET_CODE (insn) != JUMP_INSN\n-\t  && (y = SET_SRC (set), GET_CODE (y) == PLUS)\n-\t  && XEXP (y, 0) == addr\n-\t  && GET_CODE (XEXP (y, 1)) == CONST_INT\n-\t  && ((HAVE_POST_INCREMENT\n-\t       && (INTVAL (XEXP (y, 1)) == size && offset == 0))\n-\t      || (HAVE_POST_DECREMENT\n-\t\t  && (INTVAL (XEXP (y, 1)) == - size && offset == 0))\n-\t      || (HAVE_PRE_INCREMENT\n-\t\t  && (INTVAL (XEXP (y, 1)) == size && offset == size))\n-\t      || (HAVE_PRE_DECREMENT\n-\t\t  && (INTVAL (XEXP (y, 1)) == - size && offset == - size)))\n-\t  /* Make sure this reg appears only once in this insn.  */\n-\t  && (use = find_use_as_address (PATTERN (insn), addr, offset),\n-\t      use != 0 && use != (rtx) 1))\n-\t{\n-\t  rtx q = SET_DEST (set);\n-\t  enum rtx_code inc_code = (INTVAL (XEXP (y, 1)) == size\n-\t\t\t\t    ? (offset ? PRE_INC : POST_INC)\n-\t\t\t\t    : (offset ? PRE_DEC : POST_DEC));\n-\n-\t  if (dead_or_set_p (incr, addr)\n-\t      /* Mustn't autoinc an eliminable register.  */\n-\t      && (regno >= FIRST_PSEUDO_REGISTER\n-\t          || ! TEST_HARD_REG_BIT (elim_reg_set, regno)))\n-\t    {\n-\t      /* This is the simple case.  Try to make the auto-inc.  If\n-\t\t we can't, we are done.  Otherwise, we will do any\n-\t\t needed updates below.  */\n-\t      if (! validate_change (insn, &XEXP (x, 0),\n-\t\t\t\t     gen_rtx_fmt_e (inc_code, Pmode, addr),\n-\t\t\t\t     0))\n-\t\treturn;\n-\t    }\n-\t  else if (GET_CODE (q) == REG\n-\t\t   /* PREV_INSN used here to check the semi-open interval\n-\t\t      [insn,incr).  */\n-\t\t   && ! reg_used_between_p (q,  PREV_INSN (insn), incr)\n-\t\t   /* We must also check for sets of q as q may be\n-\t\t      a call clobbered hard register and there may\n-\t\t      be a call between PREV_INSN (insn) and incr.  */\n-\t\t   && ! reg_set_between_p (q,  PREV_INSN (insn), incr))\n-\t    {\n-\t      /* We have *p followed sometime later by q = p+size.\n-\t\t Both p and q must be live afterward,\n-\t\t and q is not used between INSN and its assignment.\n-\t\t Change it to q = p, ...*q..., q = q+size.\n-\t\t Then fall into the usual case.  */\n-\t      rtx insns, temp;\n-\n-\t      start_sequence ();\n-\t      emit_move_insn (q, addr);\n-\t      insns = get_insns ();\n-\t      end_sequence ();\n-\n-\t      if (basic_block_for_insn)\n-\t\tfor (temp = insns; temp; temp = NEXT_INSN (temp))\n-\t\t  set_block_for_insn (temp, pbi->bb);\n-\n-\t      /* If we can't make the auto-inc, or can't make the\n-\t\t replacement into Y, exit.  There's no point in making\n-\t\t the change below if we can't do the auto-inc and doing\n-\t\t so is not correct in the pre-inc case.  */\n-\n-\t      validate_change (insn, &XEXP (x, 0),\n-\t\t\t       gen_rtx_fmt_e (inc_code, Pmode, q),\n-\t\t\t       1);\n-\t      validate_change (incr, &XEXP (y, 0), q, 1);\n-\t      if (! apply_change_group ())\n-\t\treturn;\n-\n-\t      /* We now know we'll be doing this change, so emit the\n-\t\t new insn(s) and do the updates.  */\n-\t      emit_insns_before (insns, insn);\n-\n-\t      if (pbi->bb->head == insn)\n-\t\tpbi->bb->head = insns;\n-\n-\t      /* INCR will become a NOTE and INSN won't contain a\n-\t\t use of ADDR.  If a use of ADDR was just placed in\n-\t\t the insn before INSN, make that the next use. \n-\t\t Otherwise, invalidate it.  */\n-\t      if (GET_CODE (PREV_INSN (insn)) == INSN\n-\t\t  && GET_CODE (PATTERN (PREV_INSN (insn))) == SET\n-\t\t  && SET_SRC (PATTERN (PREV_INSN (insn))) == addr)\n-\t\tpbi->reg_next_use[regno] = PREV_INSN (insn);\n-\t      else\n-\t\tpbi->reg_next_use[regno] = 0;\n-\n-\t      addr = q;\n-\t      regno = REGNO (q);\n-\n-\t      /* REGNO is now used in INCR which is below INSN, but it\n-\t\t previously wasn't live here.  If we don't mark it as\n-\t\t live, we'll put a REG_DEAD note for it on this insn,\n-\t\t which is incorrect.  */\n-\t      SET_REGNO_REG_SET (pbi->reg_live, regno);\n-\n-\t      /* If there are any calls between INSN and INCR, show\n-\t\t that REGNO now crosses them.  */\n-\t      for (temp = insn; temp != incr; temp = NEXT_INSN (temp))\n-\t\tif (GET_CODE (temp) == CALL_INSN)\n-\t\t  REG_N_CALLS_CROSSED (regno)++;\n-\t    }\n-\t  else\n-\t    return;\n-\n-\t  /* If we haven't returned, it means we were able to make the\n-\t     auto-inc, so update the status.  First, record that this insn\n-\t     has an implicit side effect.  */\n+  if (GET_CODE (addr) != REG)\n+    return;\n \n-\t  REG_NOTES (insn)\n-\t    = alloc_EXPR_LIST (REG_INC, addr, REG_NOTES (insn));\n+  regno = REGNO (addr);\n \n-\t  /* Modify the old increment-insn to simply copy\n-\t     the already-incremented value of our register.  */\n-\t  if (! validate_change (incr, &SET_SRC (set), addr, 0))\n-\t    abort ();\n+  /* Is the next use an increment that might make auto-increment? */\n+  incr = pbi->reg_next_use[regno];\n+  if (incr == 0 || BLOCK_NUM (incr) != BLOCK_NUM (insn))\n+    return;\n+  set = single_set (incr);\n+  if (set == 0 || GET_CODE (set) != SET)\n+    return;\n+  y = SET_SRC (set);\n \n-\t  /* If that makes it a no-op (copying the register into itself) delete\n-\t     it so it won't appear to be a \"use\" and a \"set\" of this\n-\t     register.  */\n-\t  if (SET_DEST (set) == addr)\n-\t    {\n-\t      /* If the original source was dead, it's dead now.  */\n-\t      rtx note = find_reg_note (incr, REG_DEAD, NULL_RTX);\n-\t      if (note && XEXP (note, 0) != addr)\n-\t\tCLEAR_REGNO_REG_SET (pbi->reg_live, REGNO (XEXP (note, 0)));\n-\t      \n-\t      PUT_CODE (incr, NOTE);\n-\t      NOTE_LINE_NUMBER (incr) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (incr) = 0;\n-\t    }\n+  if (GET_CODE (y) != PLUS)\n+    return;\n \n-\t  if (regno >= FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      /* Count an extra reference to the reg.  When a reg is\n-\t\t incremented, spilling it is worse, so we want to make\n-\t\t that less likely.  */\n-\t      REG_N_REFS (regno) += (optimize_size ? 1\n-\t\t\t\t     : pbi->bb->loop_depth + 1);\n+  if (REGNO (XEXP (y, 0)) == REGNO (addr))\n+    inc_val = XEXP (y, 1);\n+  else if (REGNO (XEXP (y, 1)) == REGNO (addr))\n+    inc_val = XEXP (y, 0);\n+  else\n+    abort ();\n \n-\t      /* Count the increment as a setting of the register,\n-\t\t even though it isn't a SET in rtl.  */\n-\t      REG_N_SETS (regno)++;\n-\t    }\n-\t}\n+  if (GET_CODE (inc_val) == CONST_INT)\n+    {\n+      if (HAVE_POST_INCREMENT\n+\t  && (INTVAL (inc_val) == size && offset == 0))\n+\tattempt_auto_inc (pbi, gen_rtx_POST_INC (Pmode, addr), insn, x,\n+\t\t\t  incr, addr);\n+      else if (HAVE_POST_DECREMENT\n+\t       && (INTVAL (inc_val) == - size && offset == 0))\n+\tattempt_auto_inc (pbi, gen_rtx_POST_DEC (Pmode, addr), insn, x,\n+\t\t\t  incr, addr);\n+      else if (HAVE_PRE_INCREMENT\n+\t       && (INTVAL (inc_val) == size && offset == size))\n+\tattempt_auto_inc (pbi, gen_rtx_PRE_INC (Pmode, addr), insn, x,\n+\t\t\t  incr, addr);\n+      else if (HAVE_PRE_DECREMENT\n+\t       && (INTVAL (inc_val) == - size && offset == - size))\n+\tattempt_auto_inc (pbi, gen_rtx_PRE_DEC (Pmode, addr), insn, x,\n+\t\t\t  incr, addr);\n+      else if (HAVE_POST_MODIFY_DISP && offset == 0)\n+\tattempt_auto_inc (pbi, gen_rtx_POST_MODIFY (Pmode, addr,\n+\t\t\t\t\t\t    gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t\t  addr,\n+\t\t\t\t\t\t\t\t  inc_val)),\n+\t\t\t  insn, x, incr, addr);\n+    }\n+  else if (GET_CODE (inc_val) == REG\n+\t   && ! reg_set_between_p (inc_val, PREV_INSN (insn),\n+\t\t\t\t   NEXT_INSN (incr)))\n+\n+    {\n+      if (HAVE_POST_MODIFY_REG && offset == 0)\n+\tattempt_auto_inc (pbi, gen_rtx_POST_MODIFY (Pmode, addr,\n+\t\t\t\t\t\t    gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t\t  addr,\n+\t\t\t\t\t\t\t\t  inc_val)),\n+\t\t\t  insn, x, incr, addr);\n     }\n }\n+\n #endif /* AUTO_INC_DEC */\n \f\n static void"}, {"sha": "cec2c88ab8201442459a80ca2c61b94ccc92b737", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -1250,6 +1250,8 @@ oprs_unchanged_p (x, insn, avail_p)\n     case PRE_INC:\n     case POST_DEC:\n     case POST_INC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n       return 0;\n \n     case PC:"}, {"sha": "8878ccac39b52a4a9142e2ae403a0998735bdad2", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -3625,6 +3625,14 @@ sched_analyze_2 (deps, x, insn)\n       sched_analyze_1 (deps, x, insn);\n       return;\n \n+    case POST_MODIFY:\n+    case PRE_MODIFY:\n+      /* op0 = op0 + op1 */\n+      sched_analyze_2 (deps, XEXP (x, 0), insn);\n+      sched_analyze_2 (deps, XEXP (x, 1), insn);\n+      sched_analyze_1 (deps, x, insn);\n+      return;\n+\n     default:\n       break;\n     }"}, {"sha": "db1c913dd0401b38e7fb1b2eb4d270b4f708e012", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -1885,8 +1885,7 @@ offsettable_address_p (strictp, mode, y)\n       return good;\n     }\n \n-  if (ycode == PRE_DEC || ycode == PRE_INC\n-      || ycode == POST_DEC || ycode == POST_INC)\n+  if (GET_RTX_CLASS (ycode) == 'a')\n     return 0;\n \n   /* The offset added here is chosen as the maximum offset that"}, {"sha": "4439857a4037534b2748cf108ad04667013fa4b8", "filename": "gcc/regclass.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -1952,6 +1952,17 @@ record_address_regs (x, class, scale)\n       }\n       break;\n \n+      /* Double the importance of a pseudo register that is incremented\n+\t or decremented, since it would take two extra insns\n+\t if it ends up in the wrong place.  */\n+    case POST_MODIFY:\n+    case PRE_MODIFY:\n+      record_address_regs (XEXP (x, 0), BASE_REG_CLASS, 2 * scale);\n+      if (REG_P (XEXP (XEXP (x, 1), 1)))\n+\trecord_address_regs (XEXP (XEXP (x, 1), 1),\n+\t\t\t     INDEX_REG_CLASS, 2 * scale);\n+      break;\n+\n     case POST_INC:\n     case PRE_INC:\n     case POST_DEC:"}, {"sha": "69d7f88ed96b1b4018778d4ffbf7325c7c157c4f", "filename": "gcc/regmove.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -32,7 +32,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"output.h\"\n-#include \"reload.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n@@ -1185,7 +1184,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\tcontinue;\n \n \t      if (match.early_clobber[match_no]\n-\t\t  && count_occurrences (PATTERN (insn), src) > 1)\n+\t\t  && count_occurrences (PATTERN (insn), src, 0) > 1)\n \t\tcontinue;\n \n \t      /* Make sure match_operand is the destination.  */\n@@ -1289,7 +1288,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\tcontinue;\n \n \t      if (match.early_clobber[match_no]\n-\t\t  && count_occurrences (PATTERN (insn), src) > 1)\n+\t\t  && count_occurrences (PATTERN (insn), src, 0) > 1)\n \t\tcontinue;\n \n \t      /* Make sure match_no is the destination.  */"}, {"sha": "01286ba94c9f9d87b128c570310f52e2ec13fdf0", "filename": "gcc/reload.c", "status": "modified", "additions": 118, "deletions": 16, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -748,18 +748,11 @@ find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n \t\t\t\t  true_regnum (rld[i].reg_rtx)))\n \t&& out == 0 && rld[i].out == 0 && rld[i].in != 0\n \t&& ((GET_CODE (in) == REG\n-\t     && (GET_CODE (rld[i].in) == POST_INC\n-\t\t || GET_CODE (rld[i].in) == POST_DEC\n-\t\t || GET_CODE (rld[i].in) == PRE_INC\n-\t\t || GET_CODE (rld[i].in) == PRE_DEC)\n+\t     && GET_RTX_CLASS (GET_CODE (rld[i].in)) == 'a'\n \t     && MATCHES (XEXP (rld[i].in, 0), in))\n-\t    ||\n-\t    (GET_CODE (rld[i].in) == REG\n-\t     && (GET_CODE (in) == POST_INC\n-\t\t || GET_CODE (in) == POST_DEC\n-\t\t || GET_CODE (in) == PRE_INC\n-\t\t || GET_CODE (in) == PRE_DEC)\n-\t     && MATCHES (XEXP (in, 0), rld[i].in)))\n+\t    || (GET_CODE (rld[i].in) == REG\n+\t\t&& GET_RTX_CLASS (GET_CODE (in)) == 'a'\n+\t\t&& MATCHES (XEXP (in, 0), rld[i].in)))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n \t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n \t&& MERGABLE_RELOADS (type, rld[i].when_needed,\n@@ -865,15 +858,17 @@ push_reload (in, out, inloc, outloc, class,\n   if (in != 0 && out != 0 && GET_CODE (in) == MEM && rtx_equal_p (in, out))\n     {\n       if (GET_CODE (XEXP (in, 0)) == POST_INC\n-\t  || GET_CODE (XEXP (in, 0)) == POST_DEC)\n+\t  || GET_CODE (XEXP (in, 0)) == POST_DEC\n+\t  || GET_CODE (XEXP (in, 0)) == POST_MODIFY)\n \t{\n \t  rtx new = gen_rtx_MEM (GET_MODE (in), XEXP (XEXP (in, 0), 0));\n \n \t  MEM_COPY_ATTRIBUTES (new, in);\n \t  in = new;\n \t}\n       if (GET_CODE (XEXP (in, 0)) == PRE_INC\n-\t  || GET_CODE (XEXP (in, 0)) == PRE_DEC)\n+\t  || GET_CODE (XEXP (in, 0)) == PRE_DEC\n+\t  || GET_CODE (XEXP (in, 0)) == PRE_MODIFY)\n \t{\n \t  rtx new = gen_rtx_MEM (GET_MODE (out), XEXP (XEXP (out, 0), 0));\n \n@@ -2052,15 +2047,16 @@ operands_match_p (x, y)\n      because the assembler insn would increment only once.\n      On the other hand, an postincrement matches ordinary indexing\n      if the postincrement is the output operand.  */\n-  if (code == POST_DEC || code == POST_INC)\n+  if (code == POST_DEC || code == POST_INC || code == POST_MODIFY)\n     return operands_match_p (XEXP (x, 0), y);\n   /* Two preincrements are invalid\n      because the assembler insn would increment only once.\n      On the other hand, an preincrement matches ordinary indexing\n      if the preincrement is the input operand.\n      In this case, return 2, since some callers need to do special\n      things when this happens.  */\n-  if (GET_CODE (y) == PRE_DEC || GET_CODE (y) == PRE_INC)\n+  if (GET_CODE (y) == PRE_DEC || GET_CODE (y) == PRE_INC\n+      || GET_CODE (y) == PRE_MODIFY)\n     return operands_match_p (x, XEXP (y, 0)) ? 2 : 0;\n \n  slow:\n@@ -2168,6 +2164,20 @@ decompose (x)\n \t  return val;\n \t}\n \n+      if (GET_CODE (addr) == PRE_MODIFY || GET_CODE (addr) == POST_MODIFY)\n+ \t{\n+ \t  if (GET_CODE (XEXP (addr, 1)) == PLUS\n+\t      && XEXP (addr, 0) == XEXP (XEXP (addr, 1), 0)\n+\t      && CONSTANT_P (XEXP (XEXP (addr, 1), 1)))\n+ \t    {\n+ \t      val.base  = XEXP (addr, 0);\n+ \t      val.start = -INTVAL (XEXP (XEXP (addr, 1), 1));\n+ \t      val.end   = INTVAL (XEXP (XEXP (addr, 1), 1));\n+ \t      val.safe  = REGNO (val.base) == STACK_POINTER_REGNUM;\n+ \t      return val;\n+ \t    }\n+ \t}\n+      \n       if (GET_CODE (addr) == CONST)\n \t{\n \t  addr = XEXP (addr, 0);\n@@ -5095,6 +5105,86 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \n       return 0;\n \n+    case POST_MODIFY:\n+    case PRE_MODIFY:\n+      {\n+\trtx op0 = XEXP (x, 0);\n+\trtx op1 = XEXP (x, 1);\n+\n+\tif (GET_CODE (op1) != PLUS && GET_CODE (op1) != MINUS)\n+\t  return 0;\n+\n+\t/* Currently, we only support {PRE,POST}_MODIFY constructs\n+\t   where a base register is {inc,dec}remented by the contents\n+\t   of another register or by a constant value.  Thus, these\n+\t   operands must match.  */\n+\tif (op0 != XEXP (op1, 0))\n+\t  abort();\n+\n+\t/* Require index register (or constant).  Let's just handle the\n+\t   register case in the meantime... If the target allows\n+\t   auto-modify by a constant then we could try replacing a pseudo\n+\t   register with its equivalent constant where applicable. */\n+\tif (REG_P (XEXP (op1, 1)))\n+\t  if (!REGNO_OK_FOR_INDEX_P (REGNO (XEXP (op1, 1))))\n+\t    find_reloads_address_1 (mode, XEXP (op1, 1), 1, &XEXP (op1, 1),\n+\t\t\t\t    opnum, type, ind_levels, insn);\n+\n+\tif (REG_P (XEXP (op1, 0)))\n+\t  {\n+\t    register int regno = REGNO (XEXP (op1, 0));\n+\n+\t    /* A register that is incremented cannot be constant!  */\n+\t    if (regno >= FIRST_PSEUDO_REGISTER\n+\t\t&& reg_equiv_constant[regno] != 0)\n+\t      abort ();\n+\n+\t    /* Handle a register that is equivalent to a memory location\n+\t       which cannot be addressed directly.  */\n+ \t    if (reg_equiv_memory_loc[regno] != 0\n+\t\t&& (reg_equiv_address[regno] != 0\n+\t\t    || num_not_at_initial_offset))\n+\t      {\n+\t\trtx tem = make_memloc (XEXP (x, 0), regno);\n+\n+\t\tif (reg_equiv_address[regno]\n+\t\t    || ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n+\t\t  {\n+\t\t    /* First reload the memory location's address.\n+\t\t       We can't use ADDR_TYPE (type) here, because we need to\n+\t\t       write back the value after reading it, hence we actually\n+\t\t       need two registers.  */\n+\t\t    find_reloads_address (GET_MODE (tem), 0, XEXP (tem, 0),\n+\t\t\t\t\t  &XEXP (tem, 0), opnum, type,\n+\t\t\t\t\t  ind_levels, insn);\n+\n+\t\t    /* Then reload the memory location into a base\n+\t\t       register.  */\n+\t\t    push_reload (tem, tem, &XEXP (x, 0), &XEXP (op1, 0),\n+\t\t\t\t BASE_REG_CLASS, GET_MODE (x), GET_MODE (x),\n+\t\t\t\t 0, 0, opnum, RELOAD_OTHER);\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\n+\t    if (reg_renumber[regno] >= 0)\n+\t      regno = reg_renumber[regno];\n+\n+\t    /* We require a base register here...  */\n+\t    if (!REGNO_MODE_OK_FOR_BASE_P (regno, GET_MODE (x)))\n+\t      {\n+\t\tpush_reload (XEXP (op1, 0), XEXP (x, 0),\n+\t\t\t     &XEXP (op1, 0), &XEXP (x, 0), \n+\t\t\t     BASE_REG_CLASS,\n+\t\t\t     GET_MODE (x), GET_MODE (x), 0, 0,\n+\t\t\t     opnum, RELOAD_OTHER);\n+\t      }\n+\t  }\n+\telse\n+\t  abort();\n+      }\n+      return 0;\n+\n     case POST_INC:\n     case POST_DEC:\n     case PRE_INC:\n@@ -5988,6 +6078,8 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \tcase PRE_INC:\n \tcase POST_DEC:\n \tcase PRE_DEC:\n+\tcase POST_MODIFY:\n+\tcase PRE_MODIFY:\n \t  return 0;\n \tdefault:\n \t  break;\n@@ -6407,7 +6499,17 @@ find_inc_amount (x, inced)\n \t   || GET_CODE (addr) == POST_INC)\n \t  && XEXP (addr, 0) == inced)\n \treturn GET_MODE_SIZE (GET_MODE (x));\n-    }\n+      else if ((GET_CODE (addr) == PRE_MODIFY\n+\t\t|| GET_CODE (addr) == POST_MODIFY)\n+\t       && GET_CODE (XEXP (addr, 1)) == PLUS\n+\t       && XEXP (addr, 0) == XEXP (XEXP (addr, 1), 0)\n+\t       && XEXP (addr, 0) == inced\n+\t       && GET_CODE (XEXP (XEXP (addr, 1), 1)) == CONST_INT)\n+ \t{ \n+ \t  i = INTVAL (XEXP (XEXP (addr, 1), 1));\n+ \t  return i < 0 ? -i : i;\n+ \t}\n+   }\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)"}, {"sha": "25bc37c86609f72a372c31f52fdea0cc541b9261", "filename": "gcc/reload.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -344,8 +344,6 @@ int earlyclobber_operand_p PARAMS ((rtx));\n \n extern int reloads_conflict\t\tPARAMS ((int, int));\n \n-int count_occurrences            PARAMS ((rtx, rtx));\n-\n /* Initialize the reload pass once per compilation.  */\n extern void init_reload PARAMS ((void));\n "}, {"sha": "35fbc9ecac7a2f77a164c7c6dd6731e881e11708", "filename": "gcc/reload1.c", "status": "modified", "additions": 17, "deletions": 73, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -2633,6 +2633,8 @@ elimination_effects (x, mem_mode)\n     case POST_INC:\n     case PRE_DEC:\n     case POST_DEC:\n+    case POST_MODIFY:\n+    case PRE_MODIFY:\n       for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n \tif (ep->to_rtx == XEXP (x, 0))\n \t  {\n@@ -2645,10 +2647,19 @@ elimination_effects (x, mem_mode)\n #endif\n \t    if (code == PRE_DEC || code == POST_DEC)\n \t      ep->offset += size;\n-\t    else\n+\t    else if (code == PRE_INC || code == POST_INC)\n \t      ep->offset -= size;\n+\t    else if ((code == PRE_MODIFY || code == POST_MODIFY)\n+\t\t     && GET_CODE (XEXP (x, 1)) == PLUS\n+\t\t     && XEXP (x, 0) == XEXP (XEXP (x, 1), 0)\n+\t\t     && CONSTANT_P (XEXP (XEXP (x, 1), 1)))\n+\t      ep->offset -= INTVAL (XEXP (XEXP (x, 1), 1));\n \t  }\n \n+      /* These two aren't unary operators.  */\n+      if (code == POST_MODIFY || code == PRE_MODIFY)\n+\tbreak;\n+\n       /* Fall through to generic unary operation case.  */\n     case STRICT_LOW_PART:\n     case NEG:          case NOT:\n@@ -3884,7 +3895,7 @@ reload_as_needed (live_known)\n \t\t\t     use PATTERN (p) as argument to reg_set_p .  */\n \t\t\t  if (reg_set_p (reload_reg, PATTERN (p)))\n \t\t\t    break;\n-\t\t\t  n = count_occurrences (PATTERN (p), reload_reg);\n+\t\t\t  n = count_occurrences (PATTERN (p), reload_reg, 0);\n \t\t\t  if (! n)\n \t\t\t    continue;\n \t\t\t  if (n == 1)\n@@ -6190,7 +6201,7 @@ emit_input_reload_insns (chain, rl, old, j)\n \t\t\t\t       reloadreg)\n \t  /* This is unsafe if operand occurs more than once in current\n \t     insn.  Perhaps some occurrences aren't reloaded.  */\n-\t  && count_occurrences (PATTERN (insn), old) == 1\n+\t  && count_occurrences (PATTERN (insn), old, 0) == 1\n \t  /* Don't risk splitting a matching pair of operands.  */\n \t  && ! reg_mentioned_p (old, SET_SRC (PATTERN (temp))))\n \t{\n@@ -6653,7 +6664,7 @@ do_input_reload (chain, rl, j)\n       && TEST_HARD_REG_BIT (reg_reloaded_valid, reload_spill_index[j]))\n     {\n       expect_occurrences\n-\t= count_occurrences (PATTERN (insn), rl->in) == 1 ? 0 : -1;\n+\t= count_occurrences (PATTERN (insn), rl->in, 0) == 1 ? 0 : -1;\n       rl->in\n \t= regno_reg_rtx[reg_reloaded_contents[reload_spill_index[j]]];\n     }\n@@ -7415,9 +7426,9 @@ delete_output_reload (insn, j, last_reload_reg)\n \t    return;\n \t}\n     }\n-  n_occurrences = count_occurrences (PATTERN (insn), reg);\n+  n_occurrences = count_occurrences (PATTERN (insn), reg, 0);\n   if (substed)\n-    n_occurrences += count_occurrences (PATTERN (insn), substed);\n+    n_occurrences += count_occurrences (PATTERN (insn), substed, 0);\n   if (n_occurrences > n_inherited)\n     return;\n \n@@ -7824,73 +7835,6 @@ constraint_accepts_reg_p (string, reg)\n       }\n }\n \f\n-/* Return the number of places FIND appears within X, but don't count\n-   an occurrence if some SET_DEST is FIND.  */\n-\n-int\n-count_occurrences (x, find)\n-     register rtx x, find;\n-{\n-  register int i, j;\n-  register enum rtx_code code;\n-  register const char *format_ptr;\n-  int count;\n-\n-  if (x == find)\n-    return 1;\n-  if (x == 0)\n-    return 0;\n-\n-  code = GET_CODE (x);\n-\n-  switch (code)\n-    {\n-    case REG:\n-    case QUEUED:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case SYMBOL_REF:\n-    case CODE_LABEL:\n-    case PC:\n-    case CC0:\n-      return 0;\n-\n-    case MEM:\n-      if (GET_CODE (find) == MEM && rtx_equal_p (x, find))\n-\treturn 1;\n-      break;\n-    case SET:\n-      if (SET_DEST (x) == find)\n-\treturn count_occurrences (SET_SRC (x), find);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  format_ptr = GET_RTX_FORMAT (code);\n-  count = 0;\n-\n-  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n-    {\n-      switch (*format_ptr++)\n-\t{\n-\tcase 'e':\n-\t  count += count_occurrences (XEXP (x, i), find);\n-\t  break;\n-\n-\tcase 'E':\n-\t  if (XVEC (x, i) != NULL)\n-\t    {\n-\t      for (j = 0; j < XVECLEN (x, i); j++)\n-\t\tcount += count_occurrences (XVECEXP (x, i, j), find);\n-\t    }\n-\t  break;\n-\t}\n-    }\n-  return count;\n-}\n-\f\n /* INSN is a no-op; delete it.\n    If this sets the return value of the function, we must keep a USE around,\n    in case this is in a different basic block than the final USE.  Otherwise,"}, {"sha": "606e2e97547e9985579f31bef87e4840aacb0c5c", "filename": "gcc/resource.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -721,6 +721,13 @@ mark_set_resources (x, res, in_dest, mark_type)\n       mark_set_resources (XEXP (x, 0), res, 1, MARK_SRC_DEST);\n       return;\n \n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      mark_set_resources (XEXP (x, 0), res, 1, 0);\n+      mark_set_resources (XEXP (XEXP (x, 1), 0), res, 0, 0);\n+      mark_set_resources (XEXP (XEXP (x, 1), 1), res, 0, 0);\n+      return;\n+\n     case SIGN_EXTRACT:\n     case ZERO_EXTRACT:\n       if (! (mark_type == MARK_DEST && in_dest))"}, {"sha": "fcad7ec4b212248463836e0bedc3b0a59d1618b9", "filename": "gcc/rtl.def", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -56,6 +56,7 @@ Boston, MA 02111-1307, USA.  */\n      \"i\" an rtx code for a machine insn (INSN, JUMP_INSN, CALL_INSN)\n      \"m\" an rtx code for something that matches in insns (e.g, MATCH_DUP)\n      \"g\" an rtx code for grouping insns together (e.g, GROUP_PARALLEL)\n+     \"a\" an rtx code for autoincrement addressing modes (e.g. POST_DEC)\n      \"x\" everything else\n      \n    */\n@@ -756,18 +757,25 @@ DEF_RTL_EXPR(UMAX, \"umax\", \"ee\", 'c')\n    containing MEM.  These operations exist in only two cases:\n    1. pushes onto the stack.\n    2. created automatically by the life_analysis pass in flow.c.  */\n-DEF_RTL_EXPR(PRE_DEC, \"pre_dec\", \"e\", 'x')\n-DEF_RTL_EXPR(PRE_INC, \"pre_inc\", \"e\", 'x')\n-DEF_RTL_EXPR(POST_DEC, \"post_dec\", \"e\", 'x')\n-DEF_RTL_EXPR(POST_INC, \"post_inc\", \"e\", 'x')\n+DEF_RTL_EXPR(PRE_DEC, \"pre_dec\", \"e\", 'a')\n+DEF_RTL_EXPR(PRE_INC, \"pre_inc\", \"e\", 'a')\n+DEF_RTL_EXPR(POST_DEC, \"post_dec\", \"e\", 'a')\n+DEF_RTL_EXPR(POST_INC, \"post_inc\", \"e\", 'a')\n \n /* These binary operations are used to represent generic address\n    side-effects in memory addresses, except for simple incrementation\n    or decrementation which use the above operations.  They are\n-   created automatically by the life_analysis pass in flow.c. \n-   (Note that these operators are currently placeholders.)  */\n-DEF_RTL_EXPR(PRE_MODIFY, \"pre_modify\", \"ee\", 'x')\n-DEF_RTL_EXPR(POST_MODIFY, \"post_modify\", \"ee\", 'x')\n+   created automatically by the life_analysis pass in flow.c.\n+   The first operand is a REG which is used as the address.\n+   The second operand is an expression that is assigned to the\n+   register, either before (PRE_MODIFY) or after (POST_MODIFY)\n+   evaluating the address.\n+   Currently, the compiler can only handle second operands of the\n+   form (plus (reg) (reg)) and (plus (reg) (const_int)), where\n+   the first operand of the PLUS has to be the same register as\n+   the first operand of the *_MODIFY.  */\n+DEF_RTL_EXPR(PRE_MODIFY, \"pre_modify\", \"ee\", 'a')\n+DEF_RTL_EXPR(POST_MODIFY, \"post_modify\", \"ee\", 'a')\n \n /* Comparison operations.  The ordered comparisons exist in two\n    flavors, signed and unsigned.  */"}, {"sha": "1a20ae4246bb49e9761db4bab4398cd9f43ffb9a", "filename": "gcc/rtl.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -892,6 +892,22 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n #define HAVE_POST_DECREMENT 0\n #endif\n \n+#ifndef HAVE_POST_MODIFY_DISP\n+#define HAVE_POST_MODIFY_DISP 0\n+#endif\n+\n+#ifndef HAVE_POST_MODIFY_REG\n+#define HAVE_POST_MODIFY_REG 0\n+#endif\n+\n+#ifndef HAVE_PRE_MODIFY_DISP\n+#define HAVE_PRE_MODIFY_DISP 0\n+#endif\n+\n+#ifndef HAVE_PRE_MODIFY_REG\n+#define HAVE_PRE_MODIFY_REG 0\n+#endif\n+\n \n /* Some architectures do not have complete pre/post increment/decrement\n    instruction sets, or only move some modes efficiently.  These macros\n@@ -1260,6 +1276,7 @@ extern int rtx_addr_varies_p\t\tPARAMS ((rtx));\n extern HOST_WIDE_INT get_integer_term\tPARAMS ((rtx));\n extern rtx get_related_value\t\tPARAMS ((rtx));\n extern int reg_mentioned_p\t\tPARAMS ((rtx, rtx));\n+extern int count_occurrences\t\tPARAMS ((rtx, rtx, int));\n extern int reg_referenced_p\t\tPARAMS ((rtx, rtx));\n extern int reg_used_between_p\t\tPARAMS ((rtx, rtx, rtx));\n extern int reg_referenced_between_p\tPARAMS ((rtx, rtx, rtx));"}, {"sha": "247807a400004436ead30b2018990b0a36037e4a", "filename": "gcc/rtl.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -165,6 +165,10 @@ An RTX code for an entire instruction:  @code{INSN}, @code{JUMP_INSN}, and\n An RTX code for something that matches in insns, such as\n @code{MATCH_DUP}.  These only occur in machine descriptions.\n \n+@item a\n+An RTX code for an auto-increment addressing mode, such as\n+@code{POST_INC}.\n+\n @item x\n All other RTX codes.  This category includes the remaining codes used\n only in machine descriptions (@code{DEFINE_*}, etc.).  It also includes"}, {"sha": "105c39a94c43aa8b09464eb8f79b29811ed3165e", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -246,6 +246,69 @@ get_related_value (x)\n   return 0;\n }\n \f\n+/* Return the number of places FIND appears within X.  If COUNT_DEST is\n+   zero, we do not count occurrences inside the destination of a SET.  */\n+\n+int\n+count_occurrences (x, find, count_dest)\n+     rtx x, find;\n+     int count_dest;\n+{\n+  int i, j;\n+  enum rtx_code code;\n+  const char *format_ptr;\n+  int count;\n+\n+  if (x == find)\n+    return 1;\n+\n+  code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+      return 0;\n+\n+    case MEM:\n+      if (GET_CODE (find) == MEM && rtx_equal_p (x, find))\n+\treturn 1;\n+      break;\n+\n+    case SET:\n+      if (SET_DEST (x) == find && ! count_dest)\n+\treturn count_occurrences (SET_SRC (x), find, count_dest);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  format_ptr = GET_RTX_FORMAT (code);\n+  count = 0;\n+\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  count += count_occurrences (XEXP (x, i), find, count_dest);\n+\t  break;\n+\n+\tcase 'E':\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    count += count_occurrences (XVECEXP (x, i, j), find, count_dest);\n+\t  break;\n+\t}\n+    }\n+  return count;\n+}\n+\f\n /* Nonzero if register REG appears somewhere within IN.\n    Also works if REG is not a register; in this case it checks\n    for a subexpression of IN that is Lisp \"equal\" to REG.  */"}, {"sha": "2e79a8a1eb8f314d2bb6dedb715cb39c0f776cdc", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b983fdc50c590dde021fae533d8c3745897fdae/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=4b983fdc50c590dde021fae533d8c3745897fdae", "patch": "@@ -2535,6 +2535,8 @@ hash_rtx (x, mode, create)\n     case PRE_INC:\n     case POST_DEC:\n     case POST_INC:\n+    case POST_MODIFY:\n+    case PRE_MODIFY:\n     case PC:\n     case CC0:\n     case CALL:"}]}