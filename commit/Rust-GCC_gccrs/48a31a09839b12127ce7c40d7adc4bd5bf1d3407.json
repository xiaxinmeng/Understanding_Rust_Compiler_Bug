{"sha": "48a31a09839b12127ce7c40d7adc4bd5bf1d3407", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhhMzFhMDk4MzliMTIxMjdjZTdjNDBkN2FkYzRiZDViZjFkMzQwNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-08-26T10:35:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-08-26T10:35:59Z"}, "message": "re PR target/91522 (STV is slow)\n\n2019-08-26  Richard Biener  <rguenther@suse.de>\n\n\tPR target/91522\n\tPR target/91527\n\t* config/i386/i386-features.h (general_scalar_chain::defs_map):\n\tNew member.\n\t(general_scalar_chain::replace_with_subreg): Remove.\n\t(general_scalar_chain::replace_with_subreg_in_insn): Likewise.\n\t(general_scalar_chain::convert_reg): Adjust signature.\n\t* config/i386/i386-features.c (scalar_chain::add_insn): Do not\n\titerate over all defs of a reg.\n\t(general_scalar_chain::replace_with_subreg): Remove.\n\t(general_scalar_chain::replace_with_subreg_in_insn): Likewise.\n\t(general_scalar_chain::make_vector_copies): Populate defs_map,\n\tplace copy only after defs that are used as vectors in the chain.\n\t(general_scalar_chain::convert_reg): Emit a copy for a specific\n\tdef in a specific instruction.\n\t(general_scalar_chain::convert_op): All reg uses are converted here.\n\t(general_scalar_chain::convert_insn): Emit copies for scalar\n\tuses of defs here.  Replace uses with the copies we created.\n\tReplace and convert the def.  Adjust REG_DEAD notes, remove\n\tREG_EQUIV/EQUAL notes.\n\t(general_scalar_chain::convert_registers): Only handle copies\n\tinto the chain here.\n\nFrom-SVN: r274926", "tree": {"sha": "cabb6c75d7ebdfca9c7ea3fb0cd24cc550f99327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cabb6c75d7ebdfca9c7ea3fb0cd24cc550f99327"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48a31a09839b12127ce7c40d7adc4bd5bf1d3407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48a31a09839b12127ce7c40d7adc4bd5bf1d3407", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48a31a09839b12127ce7c40d7adc4bd5bf1d3407", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48a31a09839b12127ce7c40d7adc4bd5bf1d3407/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df7d46d925c7baca7bf9961aee900876d8aef225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7d46d925c7baca7bf9961aee900876d8aef225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df7d46d925c7baca7bf9961aee900876d8aef225"}], "stats": {"total": 449, "additions": 200, "deletions": 249}, "files": [{"sha": "f4e291950aaf01581aa5a3daaf81c47d5782a348", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48a31a09839b12127ce7c40d7adc4bd5bf1d3407/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48a31a09839b12127ce7c40d7adc4bd5bf1d3407/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48a31a09839b12127ce7c40d7adc4bd5bf1d3407", "patch": "@@ -1,3 +1,28 @@\n+2019-08-26  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/91522\n+\tPR target/91527\n+\t* config/i386/i386-features.h (general_scalar_chain::defs_map):\n+\tNew member.\n+\t(general_scalar_chain::replace_with_subreg): Remove.\n+\t(general_scalar_chain::replace_with_subreg_in_insn): Likewise.\n+\t(general_scalar_chain::convert_reg): Adjust signature.\n+\t* config/i386/i386-features.c (scalar_chain::add_insn): Do not\n+\titerate over all defs of a reg.\n+\t(general_scalar_chain::replace_with_subreg): Remove.\n+\t(general_scalar_chain::replace_with_subreg_in_insn): Likewise.\n+\t(general_scalar_chain::make_vector_copies): Populate defs_map,\n+\tplace copy only after defs that are used as vectors in the chain.\n+\t(general_scalar_chain::convert_reg): Emit a copy for a specific\n+\tdef in a specific instruction.\n+\t(general_scalar_chain::convert_op): All reg uses are converted here.\n+\t(general_scalar_chain::convert_insn): Emit copies for scalar\n+\tuses of defs here.  Replace uses with the copies we created.\n+\tReplace and convert the def.  Adjust REG_DEAD notes, remove\n+\tREG_EQUIV/EQUAL notes.\n+\t(general_scalar_chain::convert_registers): Only handle copies\n+\tinto the chain here.\n+\n 2019-08-26  Robin Dapp  <rdapp@linux.ibm.com>\n \n \t* match.pd: Add (T)(A) + CST -> (T)(A + CST)."}, {"sha": "b70757e3fefb08aaa77b8e0f535926173c3a1929", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 173, "deletions": 246, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48a31a09839b12127ce7c40d7adc4bd5bf1d3407/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48a31a09839b12127ce7c40d7adc4bd5bf1d3407/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=48a31a09839b12127ce7c40d7adc4bd5bf1d3407", "patch": "@@ -416,13 +416,9 @@ scalar_chain::add_insn (bitmap candidates, unsigned int insn_uid)\n      iterates over all refs to look for dual-mode regs.  Instead this\n      should be done separately for all regs mentioned in the chain once.  */\n   df_ref ref;\n-  df_ref def;\n   for (ref = DF_INSN_UID_DEFS (insn_uid); ref; ref = DF_REF_NEXT_LOC (ref))\n     if (!HARD_REGISTER_P (DF_REF_REG (ref)))\n-      for (def = DF_REG_DEF_CHAIN (DF_REF_REGNO (ref));\n-\t   def;\n-\t   def = DF_REF_NEXT_REG (def))\n-\tanalyze_register_chain (candidates, def);\n+      analyze_register_chain (candidates, ref);\n   for (ref = DF_INSN_UID_USES (insn_uid); ref; ref = DF_REF_NEXT_LOC (ref))\n     if (!DF_REF_REG_MEM_P (ref))\n       analyze_register_chain (candidates, ref);\n@@ -605,42 +601,6 @@ general_scalar_chain::compute_convert_gain ()\n   return gain;\n }\n \n-/* Replace REG in X with a V2DI subreg of NEW_REG.  */\n-\n-rtx\n-general_scalar_chain::replace_with_subreg (rtx x, rtx reg, rtx new_reg)\n-{\n-  if (x == reg)\n-    return gen_rtx_SUBREG (vmode, new_reg, 0);\n-\n-  /* But not in memory addresses.  */\n-  if (MEM_P (x))\n-    return x;\n-\n-  const char *fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  int i, j;\n-  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tXEXP (x, i) = replace_with_subreg (XEXP (x, i), reg, new_reg);\n-      else if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  XVECEXP (x, i, j) = replace_with_subreg (XVECEXP (x, i, j),\n-\t\t\t\t\t\t   reg, new_reg);\n-    }\n-\n-  return x;\n-}\n-\n-/* Replace REG in INSN with a V2DI subreg of NEW_REG.  */\n-\n-void\n-general_scalar_chain::replace_with_subreg_in_insn (rtx_insn *insn,\n-\t\t\t\t\t\t  rtx reg, rtx new_reg)\n-{\n-  replace_with_subreg (single_set (insn), reg, new_reg);\n-}\n-\n /* Insert generated conversion instruction sequence INSNS\n    after instruction AFTER.  New BB may be required in case\n    instruction has EH region attached.  */\n@@ -691,204 +651,147 @@ general_scalar_chain::make_vector_copies (unsigned regno)\n   rtx vreg = gen_reg_rtx (smode);\n   df_ref ref;\n \n-  for (ref = DF_REG_DEF_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n-    if (!bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))\n-      {\n-\tstart_sequence ();\n-\tif (!TARGET_INTER_UNIT_MOVES_TO_VEC)\n-\t  {\n-\t    rtx tmp = assign_386_stack_local (smode, SLOT_STV_TEMP);\n-\t    if (smode == DImode && !TARGET_64BIT)\n-\t      {\n-\t\temit_move_insn (adjust_address (tmp, SImode, 0),\n-\t\t\t\tgen_rtx_SUBREG (SImode, reg, 0));\n-\t\temit_move_insn (adjust_address (tmp, SImode, 4),\n-\t\t\t\tgen_rtx_SUBREG (SImode, reg, 4));\n-\t      }\n-\t    else\n-\t      emit_move_insn (copy_rtx (tmp), reg);\n-\t    emit_insn (gen_rtx_SET (gen_rtx_SUBREG (vmode, vreg, 0),\n-\t\t\t\t    gen_gpr_to_xmm_move_src (vmode, tmp)));\n-\t  }\n-\telse if (!TARGET_64BIT && smode == DImode)\n-\t  {\n-\t    if (TARGET_SSE4_1)\n-\t      {\n-\t\temit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\t    CONST0_RTX (V4SImode),\n-\t\t\t\t\t    gen_rtx_SUBREG (SImode, reg, 0)));\n-\t\temit_insn (gen_sse4_1_pinsrd (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\t      gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\t      gen_rtx_SUBREG (SImode, reg, 4),\n-\t\t\t\t\t      GEN_INT (2)));\n-\t      }\n-\t    else\n-\t      {\n-\t\trtx tmp = gen_reg_rtx (DImode);\n-\t\temit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\t    CONST0_RTX (V4SImode),\n-\t\t\t\t\t    gen_rtx_SUBREG (SImode, reg, 0)));\n-\t\temit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, tmp, 0),\n-\t\t\t\t\t    CONST0_RTX (V4SImode),\n-\t\t\t\t\t    gen_rtx_SUBREG (SImode, reg, 4)));\n-\t\temit_insn (gen_vec_interleave_lowv4si\n-\t\t\t   (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t    gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t    gen_rtx_SUBREG (V4SImode, tmp, 0)));\n-\t      }\n-\t  }\n-\telse\n-\t  emit_insn (gen_rtx_SET (gen_rtx_SUBREG (vmode, vreg, 0),\n-\t\t\t\t  gen_gpr_to_xmm_move_src (vmode, reg)));\n-\trtx_insn *seq = get_insns ();\n-\tend_sequence ();\n-\trtx_insn *insn = DF_REF_INSN (ref);\n-\temit_conversion_insns (seq, insn);\n-\n-\tif (dump_file)\n-\t  fprintf (dump_file,\n-\t\t   \"  Copied r%d to a vector register r%d for insn %d\\n\",\n-\t\t   regno, REGNO (vreg), INSN_UID (insn));\n-      }\n-\n-  for (ref = DF_REG_USE_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n-    if (bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))\n-      {\n-\trtx_insn *insn = DF_REF_INSN (ref);\n-\treplace_with_subreg_in_insn (insn, reg, vreg);\n-\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"  Replaced r%d with r%d in insn %d\\n\",\n-\t\t   regno, REGNO (vreg), INSN_UID (insn));\n-      }\n-}\n-\n-/* Convert all definitions of register REGNO\n-   and fix its uses.  Scalar copies may be created\n-   in case register is used in not convertible insn.  */\n-\n-void\n-general_scalar_chain::convert_reg (unsigned regno)\n-{\n-  bool scalar_copy = bitmap_bit_p (defs_conv, regno);\n-  rtx reg = regno_reg_rtx[regno];\n-  rtx scopy = NULL_RTX;\n-  df_ref ref;\n-  bitmap conv;\n-\n-  conv = BITMAP_ALLOC (NULL);\n-  bitmap_copy (conv, insns);\n-\n-  if (scalar_copy)\n-    scopy = gen_reg_rtx (smode);\n+  defs_map.put (reg, vreg);\n \n+  /* For each insn defining REGNO, see if it is defined by an insn\n+     not part of the chain but with uses in insns part of the chain\n+     and insert a copy in that case.  */\n   for (ref = DF_REG_DEF_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n     {\n-      rtx_insn *insn = DF_REF_INSN (ref);\n-      rtx def_set = single_set (insn);\n-      rtx src = SET_SRC (def_set);\n-      rtx reg = DF_REF_REG (ref);\n+      if (bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))\n+\tcontinue;\n+      df_link *use;\n+      for (use = DF_REF_CHAIN (ref); use; use = use->next)\n+\tif (!DF_REF_REG_MEM_P (use->ref)\n+\t    && bitmap_bit_p (insns, DF_REF_INSN_UID (use->ref)))\n+\t  break;\n+      if (!use)\n+\tcontinue;\n \n-      if (!MEM_P (src))\n+      start_sequence ();\n+      if (!TARGET_INTER_UNIT_MOVES_TO_VEC)\n \t{\n-\t  replace_with_subreg_in_insn (insn, reg, reg);\n-\t  bitmap_clear_bit (conv, INSN_UID (insn));\n+\t  rtx tmp = assign_386_stack_local (smode, SLOT_STV_TEMP);\n+\t  if (smode == DImode && !TARGET_64BIT)\n+\t    {\n+\t      emit_move_insn (adjust_address (tmp, SImode, 0),\n+\t\t\t      gen_rtx_SUBREG (SImode, reg, 0));\n+\t      emit_move_insn (adjust_address (tmp, SImode, 4),\n+\t\t\t      gen_rtx_SUBREG (SImode, reg, 4));\n+\t    }\n+\t  else\n+\t    emit_move_insn (copy_rtx (tmp), reg);\n+\t  emit_insn (gen_rtx_SET (gen_rtx_SUBREG (vmode, vreg, 0),\n+\t\t\t\t  gen_gpr_to_xmm_move_src (vmode, tmp)));\n \t}\n-\n-      if (scalar_copy)\n+      else if (!TARGET_64BIT && smode == DImode)\n \t{\n-\t  start_sequence ();\n-\t  if (!TARGET_INTER_UNIT_MOVES_FROM_VEC)\n+\t  if (TARGET_SSE4_1)\n \t    {\n-\t      rtx tmp = assign_386_stack_local (smode, SLOT_STV_TEMP);\n-\t      emit_move_insn (tmp, reg);\n-\t      if (!TARGET_64BIT && smode == DImode)\n-\t\t{\n-\t\t  emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 0),\n-\t\t\t\t  adjust_address (tmp, SImode, 0));\n-\t\t  emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 4),\n-\t\t\t\t  adjust_address (tmp, SImode, 4));\n-\t\t}\n-\t      else\n-\t\temit_move_insn (scopy, copy_rtx (tmp));\n+\t      emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\t  CONST0_RTX (V4SImode),\n+\t\t\t\t\t  gen_rtx_SUBREG (SImode, reg, 0)));\n+\t      emit_insn (gen_sse4_1_pinsrd (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\t    gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\t    gen_rtx_SUBREG (SImode, reg, 4),\n+\t\t\t\t\t    GEN_INT (2)));\n \t    }\n-\t  else if (!TARGET_64BIT && smode == DImode)\n+\t  else\n \t    {\n-\t      if (TARGET_SSE4_1)\n-\t\t{\n-\t\t  rtx tmp = gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t\t\t      gen_rtvec (1, const0_rtx));\n-\t\t  emit_insn\n-\t\t    (gen_rtx_SET\n-\t\t       (gen_rtx_SUBREG (SImode, scopy, 0),\n-\t\t\tgen_rtx_VEC_SELECT (SImode,\n-\t\t\t\t\t    gen_rtx_SUBREG (V4SImode, reg, 0),\n-\t\t\t\t\t    tmp)));\n-\n-\t\t  tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, const1_rtx));\n-\t\t  emit_insn\n-\t\t    (gen_rtx_SET\n-\t\t       (gen_rtx_SUBREG (SImode, scopy, 4),\n-\t\t\tgen_rtx_VEC_SELECT (SImode,\n-\t\t\t\t\t    gen_rtx_SUBREG (V4SImode, reg, 0),\n-\t\t\t\t\t    tmp)));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  rtx vcopy = gen_reg_rtx (V2DImode);\n-\t\t  emit_move_insn (vcopy, gen_rtx_SUBREG (V2DImode, reg, 0));\n-\t\t  emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 0),\n-\t\t\t\t  gen_rtx_SUBREG (SImode, vcopy, 0));\n-\t\t  emit_move_insn (vcopy,\n-\t\t\t\t  gen_rtx_LSHIFTRT (V2DImode,\n-\t\t\t\t\t\t    vcopy, GEN_INT (32)));\n-\t\t  emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 4),\n-\t\t\t\t  gen_rtx_SUBREG (SImode, vcopy, 0));\n-\t\t}\n+\t      rtx tmp = gen_reg_rtx (DImode);\n+\t      emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\t  CONST0_RTX (V4SImode),\n+\t\t\t\t\t  gen_rtx_SUBREG (SImode, reg, 0)));\n+\t      emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, tmp, 0),\n+\t\t\t\t\t  CONST0_RTX (V4SImode),\n+\t\t\t\t\t  gen_rtx_SUBREG (SImode, reg, 4)));\n+\t      emit_insn (gen_vec_interleave_lowv4si\n+\t\t\t (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t  gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t  gen_rtx_SUBREG (V4SImode, tmp, 0)));\n \t    }\n-\t  else\n-\t    emit_move_insn (scopy, reg);\n-\n-\t  rtx_insn *seq = get_insns ();\n-\t  end_sequence ();\n-\t  emit_conversion_insns (seq, insn);\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"  Copied r%d to a scalar register r%d for insn %d\\n\",\n-\t\t     regno, REGNO (scopy), INSN_UID (insn));\n \t}\n-    }\n-\n-  for (ref = DF_REG_USE_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n-    if (bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))\n-      {\n-\tif (bitmap_bit_p (conv, DF_REF_INSN_UID (ref)))\n-\t  {\n-\t    rtx_insn *insn = DF_REF_INSN (ref);\n+      else\n+\temit_insn (gen_rtx_SET (gen_rtx_SUBREG (vmode, vreg, 0),\n+\t\t\t\tgen_gpr_to_xmm_move_src (vmode, reg)));\n+      rtx_insn *seq = get_insns ();\n+      end_sequence ();\n+      rtx_insn *insn = DF_REF_INSN (ref);\n+      emit_conversion_insns (seq, insn);\n \n-\t    rtx def_set = single_set (insn);\n-\t    gcc_assert (def_set);\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"  Copied r%d to a vector register r%d for insn %d\\n\",\n+\t\t regno, REGNO (vreg), INSN_UID (insn));\n+    }\n+}\n \n-\t    rtx src = SET_SRC (def_set);\n-\t    rtx dst = SET_DEST (def_set);\n+/* Copy the definition SRC of INSN inside the chain to DST for\n+   scalar uses outside of the chain.  */\n \n-\t    if (!MEM_P (dst) || !REG_P (src))\n-\t      replace_with_subreg_in_insn (insn, reg, reg);\n+void\n+general_scalar_chain::convert_reg (rtx_insn *insn, rtx dst, rtx src)\n+{\n+  start_sequence ();\n+  if (!TARGET_INTER_UNIT_MOVES_FROM_VEC)\n+    {\n+      rtx tmp = assign_386_stack_local (smode, SLOT_STV_TEMP);\n+      emit_move_insn (tmp, src);\n+      if (!TARGET_64BIT && smode == DImode)\n+\t{\n+\t  emit_move_insn (gen_rtx_SUBREG (SImode, dst, 0),\n+\t\t\t  adjust_address (tmp, SImode, 0));\n+\t  emit_move_insn (gen_rtx_SUBREG (SImode, dst, 4),\n+\t\t\t  adjust_address (tmp, SImode, 4));\n+\t}\n+      else\n+\temit_move_insn (dst, copy_rtx (tmp));\n+    }\n+  else if (!TARGET_64BIT && smode == DImode)\n+    {\n+      if (TARGET_SSE4_1)\n+\t{\n+\t  rtx tmp = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t      gen_rtvec (1, const0_rtx));\n+\t  emit_insn\n+\t      (gen_rtx_SET\n+\t       (gen_rtx_SUBREG (SImode, dst, 0),\n+\t\tgen_rtx_VEC_SELECT (SImode,\n+\t\t\t\t    gen_rtx_SUBREG (V4SImode, src, 0),\n+\t\t\t\t    tmp)));\n+\n+\t  tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, const1_rtx));\n+\t  emit_insn\n+\t      (gen_rtx_SET\n+\t       (gen_rtx_SUBREG (SImode, dst, 4),\n+\t\tgen_rtx_VEC_SELECT (SImode,\n+\t\t\t\t    gen_rtx_SUBREG (V4SImode, src, 0),\n+\t\t\t\t    tmp)));\n+\t}\n+      else\n+\t{\n+\t  rtx vcopy = gen_reg_rtx (V2DImode);\n+\t  emit_move_insn (vcopy, gen_rtx_SUBREG (V2DImode, src, 0));\n+\t  emit_move_insn (gen_rtx_SUBREG (SImode, dst, 0),\n+\t\t\t  gen_rtx_SUBREG (SImode, vcopy, 0));\n+\t  emit_move_insn (vcopy,\n+\t\t\t  gen_rtx_LSHIFTRT (V2DImode,\n+\t\t\t\t\t    vcopy, GEN_INT (32)));\n+\t  emit_move_insn (gen_rtx_SUBREG (SImode, dst, 4),\n+\t\t\t  gen_rtx_SUBREG (SImode, vcopy, 0));\n+\t}\n+    }\n+  else\n+    emit_move_insn (dst, src);\n \n-\t    bitmap_clear_bit (conv, INSN_UID (insn));\n-\t  }\n-      }\n-    /* Skip debug insns and uninitialized uses.  */\n-    else if (DF_REF_CHAIN (ref)\n-\t     && NONDEBUG_INSN_P (DF_REF_INSN (ref)))\n-      {\n-\tgcc_assert (scopy);\n-\treplace_rtx (DF_REF_INSN (ref), reg, scopy);\n-\tdf_insn_rescan (DF_REF_INSN (ref));\n-      }\n+  rtx_insn *seq = get_insns ();\n+  end_sequence ();\n+  emit_conversion_insns (seq, insn);\n \n-  BITMAP_FREE (conv);\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"  Copied r%d to a scalar register r%d for insn %d\\n\",\n+\t     REGNO (src), REGNO (dst), INSN_UID (insn));\n }\n \n /* Convert operand OP in INSN.  We should handle\n@@ -921,16 +824,6 @@ general_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n     }\n   else if (REG_P (*op))\n     {\n-      /* We may have not converted register usage in case\n-\t this register has no definition.  Otherwise it\n-\t should be converted in convert_reg.  */\n-      df_ref ref;\n-      FOR_EACH_INSN_USE (ref, insn)\n-\tif (DF_REF_REGNO (ref) == REGNO (*op))\n-\t  {\n-\t    gcc_assert (!DF_REF_CHAIN (ref));\n-\t    break;\n-\t  }\n       *op = gen_rtx_SUBREG (vmode, *op, 0);\n     }\n   else if (CONST_INT_P (*op))\n@@ -975,6 +868,32 @@ general_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n void\n general_scalar_chain::convert_insn (rtx_insn *insn)\n {\n+  /* Generate copies for out-of-chain uses of defs.  */\n+  for (df_ref ref = DF_INSN_DEFS (insn); ref; ref = DF_REF_NEXT_LOC (ref))\n+    if (bitmap_bit_p (defs_conv, DF_REF_REGNO (ref)))\n+      {\n+\tdf_link *use;\n+\tfor (use = DF_REF_CHAIN (ref); use; use = use->next)\n+\t  if (DF_REF_REG_MEM_P (use->ref)\n+\t      || !bitmap_bit_p (insns, DF_REF_INSN_UID (use->ref)))\n+\t    break;\n+\tif (use)\n+\t  convert_reg (insn, DF_REF_REG (ref),\n+\t\t       *defs_map.get (regno_reg_rtx [DF_REF_REGNO (ref)]));\n+      }\n+\n+  /* Replace uses in this insn with the defs we use in the chain.  */\n+  for (df_ref ref = DF_INSN_USES (insn); ref; ref = DF_REF_NEXT_LOC (ref))\n+    if (!DF_REF_REG_MEM_P (ref))\n+      if (rtx *vreg = defs_map.get (regno_reg_rtx[DF_REF_REGNO (ref)]))\n+\t{\n+\t  /* Also update a corresponding REG_DEAD note.  */\n+\t  rtx note = find_reg_note (insn, REG_DEAD, DF_REF_REG (ref));\n+\t  if (note)\n+\t    XEXP (note, 0) = *vreg;\n+\t  *DF_REF_REAL_LOC (ref) = *vreg;\n+\t}\n+\n   rtx def_set = single_set (insn);\n   rtx src = SET_SRC (def_set);\n   rtx dst = SET_DEST (def_set);\n@@ -988,6 +907,20 @@ general_scalar_chain::convert_insn (rtx_insn *insn)\n       emit_conversion_insns (gen_move_insn (dst, tmp), insn);\n       dst = gen_rtx_SUBREG (vmode, tmp, 0);\n     }\n+  else if (REG_P (dst))\n+    {\n+      /* Replace the definition with a SUBREG to the definition we\n+         use inside the chain.  */\n+      rtx *vdef = defs_map.get (dst);\n+      if (vdef)\n+\tdst = *vdef;\n+      dst = gen_rtx_SUBREG (vmode, dst, 0);\n+      /* IRA doesn't like to have REG_EQUAL/EQUIV notes when the SET_DEST\n+         is a non-REG_P.  So kill those off.  */\n+      rtx note = find_reg_equal_equiv_note (insn);\n+      if (note)\n+\tremove_note (insn, note);\n+    }\n \n   switch (GET_CODE (src))\n     {\n@@ -1045,20 +978,15 @@ general_scalar_chain::convert_insn (rtx_insn *insn)\n     case COMPARE:\n       src = SUBREG_REG (XEXP (XEXP (src, 0), 0));\n \n-      gcc_assert ((REG_P (src) && GET_MODE (src) == DImode)\n-\t\t  || (SUBREG_P (src) && GET_MODE (src) == V2DImode));\n-\n-      if (REG_P (src))\n-\tsubreg = gen_rtx_SUBREG (V2DImode, src, 0);\n-      else\n-\tsubreg = copy_rtx_if_shared (src);\n+      gcc_assert (REG_P (src) && GET_MODE (src) == DImode);\n+      subreg = gen_rtx_SUBREG (V2DImode, src, 0);\n       emit_insn_before (gen_vec_interleave_lowv2di (copy_rtx_if_shared (subreg),\n \t\t\t\t\t\t    copy_rtx_if_shared (subreg),\n \t\t\t\t\t\t    copy_rtx_if_shared (subreg)),\n \t\t\tinsn);\n       dst = gen_rtx_REG (CCmode, FLAGS_REG);\n-      src = gen_rtx_UNSPEC (CCmode, gen_rtvec (2, copy_rtx_if_shared (src),\n-\t\t\t\t\t       copy_rtx_if_shared (src)),\n+      src = gen_rtx_UNSPEC (CCmode, gen_rtvec (2, copy_rtx_if_shared (subreg),\n+\t\t\t\t\t       copy_rtx_if_shared (subreg)),\n \t\t\t    UNSPEC_PTEST);\n       break;\n \n@@ -1217,16 +1145,15 @@ timode_scalar_chain::convert_insn (rtx_insn *insn)\n   df_insn_rescan (insn);\n }\n \n+/* Generate copies from defs used by the chain but not defined therein.\n+   Also populates defs_map which is used later by convert_insn.  */\n+\n void\n general_scalar_chain::convert_registers ()\n {\n   bitmap_iterator bi;\n   unsigned id;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (defs, 0, id, bi)\n-    convert_reg (id);\n-\n-  EXECUTE_IF_AND_COMPL_IN_BITMAP (defs_conv, defs, 0, id, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (defs_conv, 0, id, bi)\n     make_vector_copies (id);\n }\n "}, {"sha": "8381efe812c1f45f61209c5c5ad33c4d1de542ea", "filename": "gcc/config/i386/i386-features.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48a31a09839b12127ce7c40d7adc4bd5bf1d3407/gcc%2Fconfig%2Fi386%2Fi386-features.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48a31a09839b12127ce7c40d7adc4bd5bf1d3407/gcc%2Fconfig%2Fi386%2Fi386-features.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.h?ref=48a31a09839b12127ce7c40d7adc4bd5bf1d3407", "patch": "@@ -171,12 +171,11 @@ class general_scalar_chain : public scalar_chain\n     : scalar_chain (smode_, vmode_) {}\n   int compute_convert_gain ();\n  private:\n+  hash_map<rtx, rtx> defs_map;\n   void mark_dual_mode_def (df_ref def);\n-  rtx replace_with_subreg (rtx x, rtx reg, rtx subreg);\n-  void replace_with_subreg_in_insn (rtx_insn *insn, rtx reg, rtx subreg);\n   void convert_insn (rtx_insn *insn);\n   void convert_op (rtx *op, rtx_insn *insn);\n-  void convert_reg (unsigned regno);\n+  void convert_reg (rtx_insn *insn, rtx dst, rtx src);\n   void make_vector_copies (unsigned regno);\n   void convert_registers ();\n   int vector_const_cost (rtx exp);"}]}