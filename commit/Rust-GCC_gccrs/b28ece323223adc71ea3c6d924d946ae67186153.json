{"sha": "b28ece323223adc71ea3c6d924d946ae67186153", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI4ZWNlMzIzMjIzYWRjNzFlYTNjNmQ5MjRkOTQ2YWU2NzE4NjE1Mw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2012-11-23T01:29:07Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2012-11-23T01:29:07Z"}, "message": "re PR middle-end/55430 (LRA miscompilation of ree.c)\n\n2012-11-22  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR middle-end/55430\n\t* lra.c: Move #include \"hard-reg-set.h\" before #include \"rtl.h\".\n\t(new_insn_reg): Update biggest_mode.\n\t(collect_non_operand_hard_regs): Check eliminable regs too.\n\t(initialize_lra_reg_info_element): Initialize biggest_mode.\n\t(add_regs_to_insn_regno_info): Ignore non-allocatable\n\tnon-eliminable hard regs.\n\t(lra.c): Move setting lra_no_alloc_regs before\n\tinit_insn_recog_data.\n\t* lra-constraints.c (simplify_operand_subreg): Add a comment.\n\t(lra_constraints): Ignore equivalent memory of\n\tregs occuring in paradoxical subregs.\n\t* lra-lives.c (lra_create_live_ranges): Add a comment.\n\nFrom-SVN: r193742", "tree": {"sha": "c75c3eaee2df7bd4f719de0d47556e7ab346e8eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c75c3eaee2df7bd4f719de0d47556e7ab346e8eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b28ece323223adc71ea3c6d924d946ae67186153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b28ece323223adc71ea3c6d924d946ae67186153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b28ece323223adc71ea3c6d924d946ae67186153", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b28ece323223adc71ea3c6d924d946ae67186153/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64548f3b797617cde14f01874e56c498fe7b5a48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64548f3b797617cde14f01874e56c498fe7b5a48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64548f3b797617cde14f01874e56c498fe7b5a48"}], "stats": {"total": 50, "additions": 44, "deletions": 6}, "files": [{"sha": "8a2fc8f556f7323388f0c20a082b4806d05c2129", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ece323223adc71ea3c6d924d946ae67186153/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ece323223adc71ea3c6d924d946ae67186153/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b28ece323223adc71ea3c6d924d946ae67186153", "patch": "@@ -1,3 +1,19 @@\n+2012-11-22  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR middle-end/55430\n+\t* lra.c: Move #include \"hard-reg-set.h\" before #include \"rtl.h\".\n+\t(new_insn_reg): Update biggest_mode.\n+\t(collect_non_operand_hard_regs): Check eliminable regs too.\n+\t(initialize_lra_reg_info_element): Initialize biggest_mode.\n+\t(add_regs_to_insn_regno_info): Ignore non-allocatable\n+\tnon-eliminable hard regs.\n+\t(lra.c): Move setting lra_no_alloc_regs before\n+\tinit_insn_recog_data.\n+\t* lra-constraints.c (simplify_operand_subreg): Add a comment.\n+\t(lra_constraints): Ignore equivalent memory of\n+\tregs occuring in paradoxical subregs.\n+\t* lra-lives.c (lra_create_live_ranges): Add a comment.\n+\n 2012-11-22  Dmitry Vyukov  <dvyukov@google.com>\n \t    Wei Mi  <wmi@google.com>\n "}, {"sha": "e381c7042277ed715ec7b109617f9fd30bb66fde", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ece323223adc71ea3c6d924d946ae67186153/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ece323223adc71ea3c6d924d946ae67186153/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=b28ece323223adc71ea3c6d924d946ae67186153", "patch": "@@ -1146,7 +1146,12 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)\n   reg = SUBREG_REG (operand);\n   /* If we change address for paradoxical subreg of memory, the\n      address might violate the necessary alignment or the access might\n-     be slow.  So take this into consideration.\t */\n+     be slow.  So take this into consideration.  We should not worry\n+     about access beyond allocated memory for paradoxical memory\n+     subregs as we don't substitute such equiv memory (see processing\n+     equivalences in function lra_constraints) and because for spilled\n+     pseudos we allocate stack memory enough for the biggest\n+     corresponding paradoxical subreg.  */\n   if ((MEM_P (reg)\n        && (! SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (reg))\n \t   || MEM_ALIGN (reg) >= GET_MODE_ALIGNMENT (mode)))\n@@ -3363,7 +3368,12 @@ lra_constraints (bool first_p)\n \t\t       && (set = single_set (insn)) != NULL_RTX\n \t\t       && REG_P (SET_DEST (set))\n \t\t       && (int) REGNO (SET_DEST (set)) == i)\n-\t\t    && init_insn_rhs_dead_pseudo_p (i)))\n+\t\t    && init_insn_rhs_dead_pseudo_p (i))\n+\t\t/* Prevent access beyond equivalent memory for\n+\t\t   paradoxical subregs.  */\n+\t\t|| (MEM_P (x)\n+\t\t    && (GET_MODE_SIZE (lra_reg_info[i].biggest_mode)\n+\t\t\t> GET_MODE_SIZE (GET_MODE (x)))))\n \t      ira_reg_equiv[i].defined_p = false;\n \t    if (contains_reg_p (x, false, true))\n \t      ira_reg_equiv[i].profitable_p = false;"}, {"sha": "c79b95bf5362d90b32791f1de30aedabd2ea50a4", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ece323223adc71ea3c6d924d946ae67186153/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ece323223adc71ea3c6d924d946ae67186153/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=b28ece323223adc71ea3c6d924d946ae67186153", "patch": "@@ -935,6 +935,10 @@ lra_create_live_ranges (bool all_p)\n #ifdef STACK_REGS\n       lra_reg_info[i].no_stack_p = false;\n #endif\n+      /* The biggest mode is already set but its value might be to\n+\t conservative because of recent transformation.  Here in this\n+\t file we recalculate it again as it costs practically\n+\t nothing.  */\n       if (regno_reg_rtx[i] != NULL_RTX)\n \tlra_reg_info[i].biggest_mode = GET_MODE (regno_reg_rtx[i]);\n       else"}, {"sha": "80bf4328d9bcbb442feafbcb6749322413162bdf", "filename": "gcc/lra.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ece323223adc71ea3c6d924d946ae67186153/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ece323223adc71ea3c6d924d946ae67186153/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=b28ece323223adc71ea3c6d924d946ae67186153", "patch": "@@ -97,6 +97,7 @@ along with GCC; see the file COPYING3.\tIf not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"hard-reg-set.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n #include \"regs.h\"\n@@ -105,7 +106,6 @@ along with GCC; see the file COPYING3.\tIf not see\n #include \"recog.h\"\n #include \"output.h\"\n #include \"addresses.h\"\n-#include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"function.h\"\n #include \"expr.h\"\n@@ -461,6 +461,8 @@ new_insn_reg (int regno, enum op_type type, enum machine_mode mode,\n   ir = (struct lra_insn_reg *) pool_alloc (insn_reg_pool);\n   ir->type = type;\n   ir->biggest_mode = mode;\n+  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (lra_reg_info[regno].biggest_mode))\n+    lra_reg_info[regno].biggest_mode = mode;\n   ir->subreg_p = subreg_p;\n   ir->early_clobber = early_clobber;\n   ir->regno = regno;\n@@ -916,7 +918,8 @@ collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n       for (last = regno + hard_regno_nregs[regno][mode];\n \t   regno < last;\n \t   regno++)\n-\tif (! TEST_HARD_REG_BIT (lra_no_alloc_regs, regno))\n+\tif (! TEST_HARD_REG_BIT (lra_no_alloc_regs, regno)\n+\t    || TEST_HARD_REG_BIT (eliminable_regset, regno))\n \t  {\n \t    for (curr = list; curr != NULL; curr = curr->next)\n \t      if (curr->regno == regno && curr->subreg_p == subreg_p\n@@ -1384,6 +1387,7 @@ initialize_lra_reg_info_element (int i)\n   lra_reg_info[i].preferred_hard_regno2 = -1;\n   lra_reg_info[i].preferred_hard_regno_profit1 = 0;\n   lra_reg_info[i].preferred_hard_regno_profit2 = 0;\n+  lra_reg_info[i].biggest_mode = VOIDmode;\n   lra_reg_info[i].live_ranges = NULL;\n   lra_reg_info[i].nrefs = lra_reg_info[i].freq = 0;\n   lra_reg_info[i].last_reload = 0;\n@@ -1530,6 +1534,10 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n   if (REG_P (x))\n     {\n       regno = REGNO (x);\n+      if (regno < FIRST_PSEUDO_REGISTER\n+\t  && TEST_HARD_REG_BIT (lra_no_alloc_regs, regno)\n+\t  && ! TEST_HARD_REG_BIT (eliminable_regset, regno))\n+\treturn;\n       expand_reg_info ();\n       if (bitmap_set_bit (&lra_reg_info[regno].insn_bitmap, uid))\n \t{\n@@ -2202,14 +2210,14 @@ lra (FILE *f)\n \n   timevar_push (TV_LRA);\n \n+  COPY_HARD_REG_SET (lra_no_alloc_regs, ira_no_alloc_regs);\n+\n   init_insn_recog_data ();\n \n #ifdef ENABLE_CHECKING\n   check_rtl (false);\n #endif\n \n-  COPY_HARD_REG_SET (lra_no_alloc_regs, ira_no_alloc_regs);\n-\n   lra_live_range_iter = lra_coalesce_iter = 0;\n   lra_constraint_iter = lra_constraint_iter_after_spill = 0;\n   lra_inheritance_iter = lra_undo_inheritance_iter = 0;"}]}