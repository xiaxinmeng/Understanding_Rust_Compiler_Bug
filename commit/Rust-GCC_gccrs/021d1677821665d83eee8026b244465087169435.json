{"sha": "021d1677821665d83eee8026b244465087169435", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIxZDE2Nzc4MjE2NjVkODNlZWU4MDI2YjI0NDQ2NTA4NzE2OTQzNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-08-07T17:05:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-08-07T17:05:46Z"}, "message": "global.c (build_insn_chain): Use EXECUTE_IF_SET_IN_REG_SET to invert loops.\n\n        * global.c (build_insn_chain): Use EXECUTE_IF_SET_IN_REG_SET\n        to invert loops.  Simplify block scanning.\n\nFrom-SVN: r28583", "tree": {"sha": "49e302416153d9ef93e54ddb74a85fa43063707f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49e302416153d9ef93e54ddb74a85fa43063707f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/021d1677821665d83eee8026b244465087169435", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021d1677821665d83eee8026b244465087169435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/021d1677821665d83eee8026b244465087169435", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021d1677821665d83eee8026b244465087169435/comments", "author": null, "committer": null, "parents": [{"sha": "05f6f07cc6e8ca6e28a662c592801c59e96e269f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05f6f07cc6e8ca6e28a662c592801c59e96e269f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05f6f07cc6e8ca6e28a662c592801c59e96e269f"}], "stats": {"total": 141, "additions": 69, "deletions": 72}, "files": [{"sha": "d3715d620a3ae7da53ce84a49cd4d5dec16dd22d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021d1677821665d83eee8026b244465087169435/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021d1677821665d83eee8026b244465087169435/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=021d1677821665d83eee8026b244465087169435", "patch": "@@ -1,3 +1,8 @@\n+Sat Aug  7 17:09:36 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* global.c (build_insn_chain): Use EXECUTE_IF_SET_IN_REG_SET\n+\tto invert loops.  Simplify block scanning.\n+\n Sat Aug  7 02:11:13 1999  Bernd Schmidt <bernds@cygnus.co.uk>\n \n \t* gcse.c (hash_scan_set): Treat SYMBOL_REFs like CONST_INTs."}, {"sha": "138b32b6a3195d7f74d8efa3b58a0e3f72fca49c", "filename": "gcc/global.c", "status": "modified", "additions": 64, "deletions": 72, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021d1677821665d83eee8026b244465087169435/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021d1677821665d83eee8026b244465087169435/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=021d1677821665d83eee8026b244465087169435", "patch": "@@ -271,7 +271,7 @@ static void set_preference\tPROTO((rtx, rtx));\n static void dump_conflicts\tPROTO((FILE *));\n static void reg_becomes_live\tPROTO((rtx, rtx));\n static void reg_dies\t\tPROTO((int, enum machine_mode));\n-static void build_insn_chain\tPROTO((rtx));\n+static void build_insn_chain\tPROTO((void));\n \f\n /* Perform allocation of pseudo-registers not allocated by local_alloc.\n    FILE is a file to output debugging information on,\n@@ -578,7 +578,7 @@ global_alloc (file)\n   if (n_basic_blocks > 0)\n #endif\n     {\n-      build_insn_chain (get_insns ());\n+      build_insn_chain ();\n       retval = reload (get_insns (), 1, file);\n     }\n \n@@ -1667,96 +1667,88 @@ reg_dies (regno, mode)\n /* Walk the insns of the current function and build reload_insn_chain,\n    and record register life information.  */\n static void\n-build_insn_chain (first)\n-     rtx first;\n+build_insn_chain ()\n {\n   struct insn_chain **p = &reload_insn_chain;\n   struct insn_chain *prev = 0;\n-  int b = 0;\n+  int b;\n \n   live_relevant_regs = ALLOCA_REG_SET ();\n \n-  for (; first; first = NEXT_INSN (first))\n+  for (b = n_basic_blocks - 1; b >= 0; --b)\n     {\n-      struct insn_chain *c;\n+      basic_block bb = BASIC_BLOCK (b);\n+      rtx insn, end;\n+      int i;\n \n-      if (first == BLOCK_HEAD (b))\n-\t{\n-\t  int i;\n-\t  CLEAR_REG_SET (live_relevant_regs);\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, i)\n-\t\t&& ! TEST_HARD_REG_BIT (eliminable_regset, i))\n-\t      SET_REGNO_REG_SET (live_relevant_regs, i);\n-\n-\t  for (; i < max_regno; i++)\n-\t    if (reg_renumber[i] >= 0\n-\t\t&& REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, i))\n-\t      SET_REGNO_REG_SET (live_relevant_regs, i);\n-\t}\n+      CLEAR_REG_SET (live_relevant_regs);\n \n-      if (GET_CODE (first) != NOTE && GET_CODE (first) != BARRIER)\n+      EXECUTE_IF_SET_IN_REG_SET (bb->global_live_at_start, 0, i,\n \t{\n-\t  c = new_insn_chain ();\n-\t  c->prev = prev;\n-\t  prev = c;\n-\t  *p = c;\n-\t  p = &c->next;\n-\t  c->insn = first;\n-\t  c->block = b;\n-\n-\t  COPY_REG_SET (c->live_before, live_relevant_regs);\n+\t  if ((i < FIRST_PSEUDO_REGISTER\n+\t       && ! TEST_HARD_REG_BIT (eliminable_regset, i))\n+\t      || (i >= FIRST_PSEUDO_REGISTER\n+\t\t  && reg_renumber[i] >= 0))\n+\t    SET_REGNO_REG_SET (live_relevant_regs, i);\n+\t});\n+\n+      insn = bb->head, end = bb->end;\n+      while (1)\n+\t{\n+\t  struct insn_chain *c;\n \n-\t  if (GET_RTX_CLASS (GET_CODE (first)) == 'i')\n+\t  if (GET_CODE (insn) != NOTE)\n \t    {\n-\t      rtx link;\n-\n-\t      /* Mark the death of everything that dies in this instruction.  */\n+\t      c = new_insn_chain ();\n+\t      c->prev = prev;\n+\t      prev = c;\n+\t      *p = c;\n+\t      p = &c->next;\n+\t      c->insn = insn;\n+\t      c->block = b;\n \n-\t      for (link = REG_NOTES (first); link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_DEAD\n-\t\t    && GET_CODE (XEXP (link, 0)) == REG)\n-\t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)));\n+\t      COPY_REG_SET (c->live_before, live_relevant_regs);\n \n-\t      /* Mark everything born in this instruction as live.  */\n-\n-\t      note_stores (PATTERN (first), reg_becomes_live);\n-\t    }\n-\n-\t  /* Remember which registers are live at the end of the insn, before\n-\t     killing those with REG_UNUSED notes.  */\n-\t  COPY_REG_SET (c->live_after, live_relevant_regs);\n-\n-\t  if (GET_RTX_CLASS (GET_CODE (first)) == 'i')\n-\t    {\n-\t      rtx link;\n+\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t\t{\n+\t\t  rtx link;\n+\n+\t\t  /* Mark the death of everything that dies in this\n+\t\t     instruction.  */\n+\t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\t    if (REG_NOTE_KIND (link) == REG_DEAD\n+\t\t\t&& GET_CODE (XEXP (link, 0)) == REG)\n+\t\t      reg_dies (REGNO (XEXP (link, 0)),\n+\t\t\t\tGET_MODE (XEXP (link, 0)));\n+\n+\t\t  /* Mark everything born in this instruction as live.  */\n+\t\t  note_stores (PATTERN (insn), reg_becomes_live);\n+\t\t}\n \n-\t      /* Mark anything that is set in this insn and then unused as dying.  */\n+\t      /* Remember which registers are live at the end of the insn,\n+\t\t before killing those with REG_UNUSED notes.  */\n+\t      COPY_REG_SET (c->live_after, live_relevant_regs);\n \n-\t      for (link = REG_NOTES (first); link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_UNUSED\n-\t\t    && GET_CODE (XEXP (link, 0)) == REG)\n-\t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)));\n+\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t\t{\n+\t\t  rtx link;\n+\n+\t\t  /* Mark anything that is set in this insn and then unused\n+\t\t     as dying.  */\n+\t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\t    if (REG_NOTE_KIND (link) == REG_UNUSED\n+\t\t\t&& GET_CODE (XEXP (link, 0)) == REG)\n+\t\t      reg_dies (REGNO (XEXP (link, 0)),\n+\t\t\t\tGET_MODE (XEXP (link, 0)));\n+\t\t}\n \t    }\n-\t}\n-\n-      if (first == BLOCK_END (b))\n-\tb++;\n \n-      /* Stop after we pass the end of the last basic block.  Verify that\n-\t no real insns are after the end of the last basic block.\n-\n-\t We may want to reorganize the loop somewhat since this test should\n-\t always be the right exit test.  */\n-      if (b == n_basic_blocks)\n-\t{\n-\t  for (first = NEXT_INSN (first) ; first; first = NEXT_INSN (first))\n-\t    if (GET_RTX_CLASS (GET_CODE (first)) == 'i'\n-\t\t&& GET_CODE (PATTERN (first)) != USE)\n-\t      abort ();\n-\t  break;\n+\t  if (insn == end)\n+\t    break;\n+\t  insn = NEXT_INSN (insn);\n \t}\n     }\n+\n   FREE_REG_SET (live_relevant_regs);\n   *p = 0;\n }"}]}