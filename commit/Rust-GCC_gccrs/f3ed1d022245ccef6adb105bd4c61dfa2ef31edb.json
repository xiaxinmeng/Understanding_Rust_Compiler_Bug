{"sha": "f3ed1d022245ccef6adb105bd4c61dfa2ef31edb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNlZDFkMDIyMjQ1Y2NlZjZhZGIxMDViZDRjNjFkZmEyZWYzMWVkYg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2009-03-22T11:32:29Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2009-03-22T11:32:29Z"}, "message": "Revert part of patch accidentally committed to trunk rather than fortran-dev (I hate svn)\n\nFrom-SVN: r144994", "tree": {"sha": "8474dfc61c5f221722e7a16263fff853402d1b3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8474dfc61c5f221722e7a16263fff853402d1b3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb/comments", "author": null, "committer": null, "parents": [{"sha": "9e544d738ad9dd9251db1eb43592c5306270e230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e544d738ad9dd9251db1eb43592c5306270e230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e544d738ad9dd9251db1eb43592c5306270e230"}], "stats": {"total": 970, "additions": 440, "deletions": 530}, "files": [{"sha": "1993158ef589f3ef1b27c788e3934ba9d0af4484", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 45, "deletions": 81, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=f3ed1d022245ccef6adb105bd4c61dfa2ef31edb", "patch": "@@ -49,59 +49,34 @@ struct st_parameter_dt;\n \n typedef struct stream\n {\n-  ssize_t (*read) (struct stream *, void *, ssize_t);\n-  ssize_t (*write) (struct stream *, const void *, ssize_t);\n-  off_t (*seek) (struct stream *, off_t, int);\n-  off_t (*tell) (struct stream *);\n-  int (*truncate) (struct stream *, off_t);\n-  int (*flush) (struct stream *);\n-  int (*close) (struct stream *);\n+  char *(*alloc_w_at) (struct stream *, int *);\n+  try (*sfree) (struct stream *);\n+  try (*close) (struct stream *);\n+  try (*seek) (struct stream *, gfc_offset);\n+  try (*trunc) (struct stream *);\n+  int (*read) (struct stream *, void *, size_t *);\n+  int (*write) (struct stream *, const void *, size_t *);\n+  try (*set) (struct stream *, int, size_t);\n }\n stream;\n \n-/* Inline functions for doing file I/O given a stream.  */\n-static inline ssize_t\n-sread (stream * s, void * buf, ssize_t nbyte)\n-{\n-  return s->read (s, buf, nbyte);\n-}\n+typedef enum\n+{ SYNC_BUFFERED, SYNC_UNBUFFERED, ASYNC }\n+io_mode;\n \n-static inline ssize_t\n-swrite (stream * s, const void * buf, ssize_t nbyte)\n-{\n-  return s->write (s, buf, nbyte);\n-}\n+/* Macros for doing file I/O given a stream.  */\n \n-static inline off_t\n-sseek (stream * s, off_t offset, int whence)\n-{\n-  return s->seek (s, offset, whence);\n-}\n+#define sfree(s) ((s)->sfree)(s)\n+#define sclose(s) ((s)->close)(s)\n \n-static inline off_t\n-stell (stream * s)\n-{\n-  return s->tell (s);\n-}\n+#define salloc_w(s, len) ((s)->alloc_w_at)(s, len)\n \n-static inline int\n-struncate (stream * s, off_t length)\n-{\n-  return s->truncate (s, length);\n-}\n-\n-static inline int\n-sflush (stream * s)\n-{\n-  return s->flush (s);\n-}\n-\n-static inline int\n-sclose (stream * s)\n-{\n-  return s->close (s);\n-}\n+#define sseek(s, pos) ((s)->seek)(s, pos)\n+#define struncate(s) ((s)->trunc)(s)\n+#define sread(s, buf, nbytes) ((s)->read)(s, buf, nbytes)\n+#define swrite(s, buf, nbytes) ((s)->write)(s, buf, nbytes)\n \n+#define sset(s, c, n) ((s)->set)(s, c, n)\n \n /* Macros for testing what kinds of I/O we are doing.  */\n \n@@ -563,9 +538,10 @@ unit_flags;\n typedef struct fbuf\n {\n   char *buf;\t\t\t/* Start of buffer.  */\n-  int len;\t\t\t/* Length of buffer.  */\n-  int act;\t\t\t/* Active bytes in buffer.  */\n-  int pos;\t\t\t/* Current position in buffer.  */\n+  size_t len;\t\t\t/* Length of buffer.  */\n+  size_t act;\t\t\t/* Active bytes in buffer.  */\n+  size_t flushed;\t\t/* Flushed bytes from beginning of buffer.  */\n+  size_t pos;\t\t\t/* Current position in buffer.  */\n }\n fbuf;\n \n@@ -707,12 +683,6 @@ internal_proto(open_external);\n extern stream *open_internal (char *, int, gfc_offset);\n internal_proto(open_internal);\n \n-extern char * mem_alloc_w (stream *, int *);\n-internal_proto(mem_alloc_w);\n-\n-extern char * mem_alloc_r (stream *, int *);\n-internal_proto(mem_alloc_w);\n-\n extern stream *input_stream (void);\n internal_proto(input_stream);\n \n@@ -728,6 +698,12 @@ internal_proto(compare_file_filename);\n extern gfc_unit *find_file (const char *file, gfc_charlen_type file_len);\n internal_proto(find_file);\n \n+extern int stream_at_bof (stream *);\n+internal_proto(stream_at_bof);\n+\n+extern int stream_at_eof (stream *);\n+internal_proto(stream_at_eof);\n+\n extern int delete_file (gfc_unit *);\n internal_proto(delete_file);\n \n@@ -758,6 +734,9 @@ internal_proto(inquire_readwrite);\n extern gfc_offset file_length (stream *);\n internal_proto(file_length);\n \n+extern gfc_offset file_position (stream *);\n+internal_proto(file_position);\n+\n extern int is_seekable (stream *);\n internal_proto(is_seekable);\n \n@@ -773,12 +752,18 @@ internal_proto(flush_if_preconnected);\n extern void empty_internal_buffer(stream *);\n internal_proto(empty_internal_buffer);\n \n+extern try flush (stream *);\n+internal_proto(flush);\n+\n extern int stream_isatty (stream *);\n internal_proto(stream_isatty);\n \n extern char * stream_ttyname (stream *);\n internal_proto(stream_ttyname);\n \n+extern gfc_offset stream_offset (stream *s);\n+internal_proto(stream_offset);\n+\n extern int unpack_filename (char *, const char *, int);\n internal_proto(unpack_filename);\n \n@@ -822,9 +807,6 @@ internal_proto(update_position);\n extern void finish_last_advance_record (gfc_unit *u);\n internal_proto (finish_last_advance_record);\n \n-extern int unit_truncate (gfc_unit *, gfc_offset, st_parameter_common *);\n-internal_proto (unit_truncate);\n-\n /* open.c */\n \n extern gfc_unit *new_unit (st_parameter_open *, gfc_unit *, unit_flags *);\n@@ -854,7 +836,7 @@ internal_proto(free_format_data);\n extern const char *type_name (bt);\n internal_proto(type_name);\n \n-extern void * read_block_form (st_parameter_dt *, int *);\n+extern try read_block_form (st_parameter_dt *, void *, size_t *);\n internal_proto(read_block_form);\n \n extern char *read_sf (st_parameter_dt *, int *, int);\n@@ -880,9 +862,6 @@ internal_proto (reverse_memcpy);\n extern void st_wait (st_parameter_wait *);\n export_proto(st_wait);\n \n-extern void hit_eof (st_parameter_dt *);\n-internal_proto(hit_eof);\n-\n /* read.c */\n \n extern void set_integer (void *, GFC_INTEGER_LARGEST, int);\n@@ -989,39 +968,24 @@ extern size_t size_from_complex_kind (int);\n internal_proto(size_from_complex_kind);\n \n /* fbuf.c */\n-extern void fbuf_init (gfc_unit *, int);\n+extern void fbuf_init (gfc_unit *, size_t);\n internal_proto(fbuf_init);\n \n extern void fbuf_destroy (gfc_unit *);\n internal_proto(fbuf_destroy);\n \n-extern int fbuf_reset (gfc_unit *);\n+extern void fbuf_reset (gfc_unit *);\n internal_proto(fbuf_reset);\n \n-extern char * fbuf_alloc (gfc_unit *, int);\n+extern char * fbuf_alloc (gfc_unit *, size_t);\n internal_proto(fbuf_alloc);\n \n-extern int fbuf_flush (gfc_unit *, unit_mode);\n+extern int fbuf_flush (gfc_unit *, int);\n internal_proto(fbuf_flush);\n \n-extern int fbuf_seek (gfc_unit *, int, int);\n+extern int fbuf_seek (gfc_unit *, gfc_offset);\n internal_proto(fbuf_seek);\n \n-extern char * fbuf_read (gfc_unit *, int *);\n-internal_proto(fbuf_read);\n-\n-/* Never call this function, only use fbuf_getc().  */\n-extern int fbuf_getc_refill (gfc_unit *);\n-internal_proto(fbuf_getc_refill);\n-\n-static inline int\n-fbuf_getc (gfc_unit * u)\n-{\n-  if (u->fbuf->pos < u->fbuf->act)\n-    return (unsigned char) u->fbuf->buf[u->fbuf->pos++];\n-  return fbuf_getc_refill (u);\n-}\n-\n /* lock.c */\n extern void free_ionml (st_parameter_dt *);\n internal_proto(free_ionml);"}, {"sha": "1f1023c10d22defdf6d03d3b34a218b0d6d37f06", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=f3ed1d022245ccef6adb105bd4c61dfa2ef31edb", "patch": "@@ -33,7 +33,6 @@ Boston, MA 02110-1301, USA.  */\n \n #include \"io.h\"\n #include <string.h>\n-#include <stdlib.h>\n #include <ctype.h>\n \n \n@@ -80,8 +79,9 @@ push_char (st_parameter_dt *dtp, char c)\n \n   if (dtp->u.p.saved_string == NULL)\n     {\n-      dtp->u.p.saved_string = get_mem (SCRATCH_SIZE);\n-      // memset below should be commented out.\n+      if (dtp->u.p.scratch == NULL)\n+\tdtp->u.p.scratch = get_mem (SCRATCH_SIZE);\n+      dtp->u.p.saved_string = dtp->u.p.scratch;\n       memset (dtp->u.p.saved_string, 0, SCRATCH_SIZE);\n       dtp->u.p.saved_length = SCRATCH_SIZE;\n       dtp->u.p.saved_used = 0;\n@@ -90,15 +90,15 @@ push_char (st_parameter_dt *dtp, char c)\n   if (dtp->u.p.saved_used >= dtp->u.p.saved_length)\n     {\n       dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;\n-      new = realloc (dtp->u.p.saved_string, dtp->u.p.saved_length);\n-      if (new == NULL)\n-\tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n-      dtp->u.p.saved_string = new;\n-      \n-      // Also this should not be necessary.\n-      memset (new + dtp->u.p.saved_used, 0, \n-\t      dtp->u.p.saved_length - dtp->u.p.saved_used);\n+      new = get_mem (2 * dtp->u.p.saved_length);\n \n+      memset (new, 0, 2 * dtp->u.p.saved_length);\n+\n+      memcpy (new, dtp->u.p.saved_string, dtp->u.p.saved_used);\n+      if (dtp->u.p.saved_string != dtp->u.p.scratch)\n+\tfree_mem (dtp->u.p.saved_string);\n+\n+      dtp->u.p.saved_string = new;\n     }\n \n   dtp->u.p.saved_string[dtp->u.p.saved_used++] = c;\n@@ -113,7 +113,8 @@ free_saved (st_parameter_dt *dtp)\n   if (dtp->u.p.saved_string == NULL)\n     return;\n \n-  free_mem (dtp->u.p.saved_string);\n+  if (dtp->u.p.saved_string != dtp->u.p.scratch)\n+    free_mem (dtp->u.p.saved_string);\n \n   dtp->u.p.saved_string = NULL;\n   dtp->u.p.saved_used = 0;\n@@ -139,10 +140,9 @@ free_line (st_parameter_dt *dtp)\n static char\n next_char (st_parameter_dt *dtp)\n {\n-  ssize_t length;\n+  size_t length;\n   gfc_offset record;\n   char c;\n-  int cc;\n \n   if (dtp->u.p.last_char != '\\0')\n     {\n@@ -194,7 +194,7 @@ next_char (st_parameter_dt *dtp)\n \t    }\n \n \t  record *= dtp->u.p.current_unit->recl;\n-\t  if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n+\t  if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n \t    longjmp (*dtp->u.p.eof_jump, 1);\n \n \t  dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n@@ -204,15 +204,19 @@ next_char (st_parameter_dt *dtp)\n \n   /* Get the next character and handle end-of-record conditions.  */\n \n-  if (is_internal_unit (dtp))\n+  length = 1;\n+\n+  if (sread (dtp->u.p.current_unit->s, &c, &length) != 0)\n     {\n-      length = sread (dtp->u.p.current_unit->s, &c, 1);\n-      if (length < 0)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  return '\\0';\n-\t}\n+\tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n+\treturn '\\0';\n+    }\n   \n+  if (is_stream_io (dtp) && length == 1)\n+    dtp->u.p.current_unit->strm_pos++;\n+\n+  if (is_internal_unit (dtp))\n+    {\n       if (is_array_io (dtp))\n \t{\n \t  /* Check whether we hit EOF.  */ \n@@ -236,20 +240,13 @@ next_char (st_parameter_dt *dtp)\n     }\n   else\n     {\n-      cc = fbuf_getc (dtp->u.p.current_unit);\n-\n-      if (cc == EOF)\n+      if (length == 0)\n \t{\n \t  if (dtp->u.p.current_unit->endfile == AT_ENDFILE)\n \t    longjmp (*dtp->u.p.eof_jump, 1);\n \t  dtp->u.p.current_unit->endfile = AT_ENDFILE;\n \t  c = '\\n';\n \t}\n-      else\n-\tc = (char) cc;\n-      if (is_stream_io (dtp) && cc != EOF)\n-\tdtp->u.p.current_unit->strm_pos++;\n-\n     }\n done:\n   dtp->u.p.at_eol = (c == '\\n' || c == '\\r');\n@@ -1701,7 +1698,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, volatile bt type, void *p,\n       dtp->u.p.input_complete = 0;\n       dtp->u.p.repeat_count = 1;\n       dtp->u.p.at_eol = 0;\n-      \n+\n       c = eat_spaces (dtp);\n       if (is_separator (c))\n \t{\n@@ -1856,8 +1853,6 @@ finish_list_read (st_parameter_dt *dtp)\n \n   free_saved (dtp);\n \n-  fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n-\n   if (dtp->u.p.at_eol)\n     {\n       dtp->u.p.at_eol = 0;\n@@ -2266,8 +2261,8 @@ nml_query (st_parameter_dt *dtp, char c)\n \n       /* Flush the stream to force immediate output.  */\n \n-      fbuf_flush (dtp->u.p.current_unit, WRITING);\n-      sflush (dtp->u.p.current_unit->s);\n+      fbuf_flush (dtp->u.p.current_unit, 1);\n+      flush (dtp->u.p.current_unit->s);\n       unlock_unit (dtp->u.p.current_unit);\n     }\n \n@@ -2908,7 +2903,7 @@ namelist_read (st_parameter_dt *dtp)\n \t  st_printf (\"%s\\n\", nml_err_msg);\n \t  if (u != NULL)\n \t    {\n-\t      sflush (u->s);\n+\t      flush (u->s);\n \t      unlock_unit (u);\n \t    }\n         }"}, {"sha": "d50641bcce59fb2934b6e2210e10afff6fa89392", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 353, "deletions": 351, "changes": 704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=f3ed1d022245ccef6adb105bd4c61dfa2ef31edb", "patch": "@@ -37,7 +37,6 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include <assert.h>\n #include <stdlib.h>\n-#include <errno.h>\n \n \n /* Calling conventions:  Data transfer statements are unlike other\n@@ -184,58 +183,60 @@ current_mode (st_parameter_dt *dtp)\n    heap.  Hopefully this won't happen very often.  */\n \n char *\n-read_sf (st_parameter_dt *dtp, int * length, int no_error)\n+read_sf (st_parameter_dt *dtp, int *length, int no_error)\n {\n-  static char *empty_string[0];\n   char *base, *p, q;\n-  int n, lorig, memread, seen_comma;\n+  int n, crlf;\n+  gfc_offset pos;\n+  size_t readlen;\n \n-  /* If we hit EOF previously with the no_error flag set (i.e. X, T,\n-     TR edit descriptors), and we now try to read again, this time\n-     without setting no_error.  */\n-  if (!no_error && dtp->u.p.at_eof)\n-    {\n-      *length = 0;\n-      hit_eof (dtp);\n-      return NULL;\n-    }\n+  if (*length > SCRATCH_SIZE)\n+    dtp->u.p.line_buffer = get_mem (*length);\n+  p = base = dtp->u.p.line_buffer;\n \n   /* If we have seen an eor previously, return a length of 0.  The\n      caller is responsible for correctly padding the input field.  */\n   if (dtp->u.p.sf_seen_eor)\n     {\n       *length = 0;\n-      /* Just return something that isn't a NULL pointer, otherwise the\n-         caller thinks an error occured.  */\n-      return (char*) empty_string;\n+      return base;\n     }\n \n   if (is_internal_unit (dtp))\n     {\n-      memread = *length;\n-      base = mem_alloc_r (dtp->u.p.current_unit->s, length);\n-      if (unlikely (memread > *length))\n+      readlen = *length;\n+      if (unlikely (sread (dtp->u.p.current_unit->s, p, &readlen) != 0\n+\t\t    || readlen < (size_t) *length))\n \t{\n-          hit_eof (dtp);\n+\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t  return NULL;\n \t}\n-      n = *length;\n+\t\n       goto done;\n     }\n \n-  n = seen_comma = 0;\n+  readlen = 1;\n+  n = 0;\n \n-  /* Read data into format buffer and scan through it.  */\n-  lorig = *length;\n-  base = p = fbuf_read (dtp->u.p.current_unit, length);\n-  if (base == NULL)\n-    return NULL;\n-\n-  while (n < *length)\n+  do\n     {\n-      q = *p;\n+      if (unlikely (sread (dtp->u.p.current_unit->s, &q, &readlen) != 0))\n+        {\n+\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n+\t  return NULL;\n+\t}\n \n-      if (q == '\\n' || q == '\\r')\n+      /* If we have a line without a terminating \\n, drop through to\n+\t EOR below.  */\n+      if (readlen < 1 && n == 0)\n+\t{\n+\t  if (likely (no_error))\n+\t    break;\n+\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n+\t  return NULL;\n+\t}\n+\n+      if (readlen < 1 || q == '\\n' || q == '\\r')\n \t{\n \t  /* Unexpected end of line.  */\n \n@@ -244,14 +245,23 @@ read_sf (st_parameter_dt *dtp, int * length, int no_error)\n \t  if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)\n \t    dtp->u.p.eor_condition = 1;\n \n+\t  crlf = 0;\n \t  /* If we encounter a CR, it might be a CRLF.  */\n \t  if (q == '\\r') /* Probably a CRLF */\n \t    {\n-\t      if (n < *length && *(p + 1) == '\\n')\n-\t\tdtp->u.p.sf_seen_eor = 2;\n+\t      readlen = 1;\n+\t      pos = stream_offset (dtp->u.p.current_unit->s);\n+\t      if (unlikely (sread (dtp->u.p.current_unit->s, &q, &readlen)\n+\t\t\t    != 0))\n+\t        {\n+\t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n+\t\t  return NULL;\n+\t\t}\n+\t      if (q != '\\n' && readlen == 1) /* Not a CRLF after all.  */\n+\t\tsseek (dtp->u.p.current_unit->s, pos);\n+\t      else\n+\t\tcrlf = 1;\n \t    }\n-          else\n-            dtp->u.p.sf_seen_eor = 1;\n \n \t  /* Without padding, terminate the I/O statement without assigning\n \t     the value.  With padding, the value still needs to be assigned,\n@@ -265,6 +275,7 @@ read_sf (st_parameter_dt *dtp, int * length, int no_error)\n \t    }\n \n \t  *length = n;\n+\t  dtp->u.p.sf_seen_eor = (crlf ? 2 : 1);\n \t  break;\n \t}\n       /*  Short circuit the read if a comma is found during numeric input.\n@@ -273,39 +284,23 @@ read_sf (st_parameter_dt *dtp, int * length, int no_error)\n       if (q == ',')\n \tif (dtp->u.p.sf_read_comma == 1)\n \t  {\n-            seen_comma = 1;\n \t    notify_std (&dtp->common, GFC_STD_GNU,\n \t\t\t\"Comma in formatted numeric read.\");\n \t    *length = n;\n \t    break;\n \t  }\n \n       n++;\n-      p++;\n-    } \n-\n-  fbuf_seek (dtp->u.p.current_unit, n + dtp->u.p.sf_seen_eor + seen_comma, \n-             SEEK_CUR);\n-\n-  /* A short read implies we hit EOF, unless we hit EOR, a comma, or\n-     some other stuff. Set the relevant flags.  */\n-  if (lorig > *length && !dtp->u.p.sf_seen_eor && !seen_comma)\n-    {\n-      if (no_error)\n-        dtp->u.p.at_eof = 1;\n-      else\n-        {\n-          hit_eof (dtp);\n-          return NULL;\n-        }\n+      *p++ = q;\n+      dtp->u.p.sf_seen_eor = 0;\n     }\n+  while (n < *length);\n \n  done:\n-\n-  dtp->u.p.current_unit->bytes_left -= n;\n+  dtp->u.p.current_unit->bytes_left -= *length;\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    dtp->u.p.size_used += (GFC_IO_INT) n;\n+    dtp->u.p.size_used += (GFC_IO_INT) *length;\n \n   return base;\n }\n@@ -321,11 +316,12 @@ read_sf (st_parameter_dt *dtp, int * length, int no_error)\n    opened with PAD=YES.  The caller must assume tailing spaces for\n    short reads.  */\n \n-void *\n-read_block_form (st_parameter_dt *dtp, int * nbytes)\n+try\n+read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n {\n   char *source;\n-  int norig;\n+  size_t nread;\n+  int nb;\n \n   if (!is_stream_io (dtp))\n     {\n@@ -342,14 +338,15 @@ read_block_form (st_parameter_dt *dtp, int * nbytes)\n \t\t{\n \t\t  /* Not enough data left.  */\n \t\t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n-\t\t  return NULL;\n+\t\t  return FAILURE;\n \t\t}\n \t    }\n \n \t  if (unlikely (dtp->u.p.current_unit->bytes_left == 0))\n \t    {\n-              hit_eof (dtp);\n-\t      return NULL;\n+\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\t      generate_error (&dtp->common, LIBERROR_END, NULL);\n+\t      return FAILURE;\n \t    }\n \n \t  *nbytes = dtp->u.p.current_unit->bytes_left;\n@@ -360,36 +357,42 @@ read_block_form (st_parameter_dt *dtp, int * nbytes)\n       (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL ||\n        dtp->u.p.current_unit->flags.access == ACCESS_STREAM))\n     {\n-      source = read_sf (dtp, nbytes, 0);\n+      nb = *nbytes;\n+      source = read_sf (dtp, &nb, 0);\n+      *nbytes = nb;\n       dtp->u.p.current_unit->strm_pos +=\n \t(gfc_offset) (*nbytes + dtp->u.p.sf_seen_eor);\n-      return source;\n+      if (source == NULL)\n+\treturn FAILURE;\n+      memcpy (buf, source, *nbytes);\n+      return SUCCESS;\n     }\n-\n-  /* If we reach here, we can assume it's direct access.  */\n-\n   dtp->u.p.current_unit->bytes_left -= (gfc_offset) *nbytes;\n \n-  norig = *nbytes;\n-  source = fbuf_read (dtp->u.p.current_unit, nbytes);\n-  fbuf_seek (dtp->u.p.current_unit, *nbytes, SEEK_CUR);\n+  nread = *nbytes;\n+  if (unlikely (sread (dtp->u.p.current_unit->s, buf, &nread) != 0))\n+    {\n+      generate_error (&dtp->common, LIBERROR_OS, NULL);\n+      return FAILURE;\n+    }\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    dtp->u.p.size_used += (GFC_IO_INT) *nbytes;\n+    dtp->u.p.size_used += (GFC_IO_INT) nread;\n \n-  if (norig != *nbytes)\n-    {\t\t\t\t\n-      /* Short read, this shouldn't happen.  */\n-      if (!dtp->u.p.current_unit->pad_status == PAD_YES)\n+  if (nread != *nbytes)\n+    {\t\t\t\t/* Short read, this shouldn't happen.  */\n+      if (likely (dtp->u.p.current_unit->pad_status == PAD_YES))\n+\t*nbytes = nread;\n+      else\n \t{\n \t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n \t  source = NULL;\n \t}\n     }\n \n-  dtp->u.p.current_unit->strm_pos += (gfc_offset) *nbytes;\n+  dtp->u.p.current_unit->strm_pos += (gfc_offset) nread;\n \n-  return source;\n+  return SUCCESS;\n }\n \n \n@@ -399,18 +402,18 @@ read_block_form (st_parameter_dt *dtp, int * nbytes)\n static void\n read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n {\n-  ssize_t to_read_record;\n-  ssize_t have_read_record;\n-  ssize_t to_read_subrecord;\n-  ssize_t have_read_subrecord;\n+  size_t to_read_record;\n+  size_t have_read_record;\n+  size_t to_read_subrecord;\n+  size_t have_read_subrecord;\n   int short_record;\n \n   if (is_stream_io (dtp))\n     {\n       to_read_record = *nbytes;\n-      have_read_record = sread (dtp->u.p.current_unit->s, buf, \n-\t\t\t\tto_read_record);\n-      if (unlikely (have_read_record < 0))\n+      have_read_record = to_read_record;\n+      if (unlikely (sread (dtp->u.p.current_unit->s, buf, &have_read_record)\n+\t\t    != 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n@@ -422,7 +425,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t{\n \t  /* Short read,  e.g. if we hit EOF.  For stream files,\n \t   we have to set the end-of-file condition.  */\n-          hit_eof (dtp);\n+\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t  return;\n \t}\n       return;\n@@ -445,14 +448,14 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       dtp->u.p.current_unit->bytes_left -= to_read_record;\n \n-      to_read_record = sread (dtp->u.p.current_unit->s, buf, to_read_record);\n-      if (unlikely (to_read_record < 0))\n+      if (unlikely (sread (dtp->u.p.current_unit->s, buf, &to_read_record)\n+\t\t    != 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n \t}\n \n-      if (to_read_record != (ssize_t) *nbytes)  \n+      if (to_read_record != *nbytes)  \n \t{\n \t  /* Short read, e.g. if we hit EOF.  Apparently, we read\n \t   more than was written to the last record.  */\n@@ -472,12 +475,18 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n      until the request has been fulfilled or the record has run out\n      of continuation subrecords.  */\n \n+  if (unlikely (dtp->u.p.current_unit->endfile == AT_ENDFILE))\n+    {\n+      generate_error (&dtp->common, LIBERROR_END, NULL);\n+      return;\n+    }\n+\n   /* Check whether we exceed the total record length.  */\n \n   if (dtp->u.p.current_unit->flags.has_recl\n       && (*nbytes > (size_t) dtp->u.p.current_unit->bytes_left))\n     {\n-      to_read_record = (ssize_t) dtp->u.p.current_unit->bytes_left;\n+      to_read_record = (size_t) dtp->u.p.current_unit->bytes_left;\n       short_record = 1;\n     }\n   else\n@@ -492,7 +501,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n       if (dtp->u.p.current_unit->bytes_left_subrecord\n \t  < (gfc_offset) to_read_record)\n \t{\n-\t  to_read_subrecord = (ssize_t) dtp->u.p.current_unit->bytes_left_subrecord;\n+\t  to_read_subrecord = (size_t) dtp->u.p.current_unit->bytes_left_subrecord;\n \t  to_read_record -= to_read_subrecord;\n \t}\n       else\n@@ -503,9 +512,9 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       dtp->u.p.current_unit->bytes_left_subrecord -= to_read_subrecord;\n \n-      have_read_subrecord = sread (dtp->u.p.current_unit->s, \n-\t\t\t\t   buf + have_read_record, to_read_subrecord);\n-      if (unlikely (have_read_subrecord) < 0)\n+      have_read_subrecord = to_read_subrecord;\n+      if (unlikely (sread (dtp->u.p.current_unit->s, buf + have_read_record,\n+\t\t\t   &have_read_subrecord) != 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n@@ -594,7 +603,7 @@ write_block (st_parameter_dt *dtp, int length)\n \n   if (is_internal_unit (dtp))\n     {\n-    dest = mem_alloc_w (dtp->u.p.current_unit->s, &length);\n+    dest = salloc_w (dtp->u.p.current_unit->s, &length);\n \n     if (dest == NULL)\n       {\n@@ -632,22 +641,20 @@ static try\n write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n {\n \n-  ssize_t have_written;\n-  ssize_t to_write_subrecord;\n+  size_t have_written, to_write_subrecord;\n   int short_record;\n \n   /* Stream I/O.  */\n \n   if (is_stream_io (dtp))\n     {\n-      have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes);\n-      if (unlikely (have_written < 0))\n+      if (unlikely (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written; \n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes; \n \n       return SUCCESS;\n     }\n@@ -665,15 +672,14 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       if (buf == NULL && nbytes == 0)\n \treturn SUCCESS;\n \n-      have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes); \n-      if (unlikely (have_written < 0))\n+      if (unlikely (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written;\n-      dtp->u.p.current_unit->bytes_left -= (gfc_offset) have_written;\n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes;\n+      dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;\n \n       return SUCCESS;\n     }\n@@ -703,9 +709,8 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       dtp->u.p.current_unit->bytes_left_subrecord -=\n \t(gfc_offset) to_write_subrecord;\n \n-      to_write_subrecord = swrite (dtp->u.p.current_unit->s, \n-\t\t\t\t   buf + have_written, to_write_subrecord);\n-      if (unlikely (to_write_subrecord < 0))\n+      if (unlikely (swrite (dtp->u.p.current_unit->s, buf + have_written,\n+\t\t\t    &to_write_subrecord) != 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n@@ -927,6 +932,7 @@ static void\n formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t\t\t   size_t size)\n {\n+  char scratch[SCRATCH_SIZE];\n   int pos, bytes_used;\n   const fnode *f;\n   format_token t;\n@@ -953,6 +959,8 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n   dtp->u.p.sf_read_comma =\n     dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA ? 0 : 1;\n \n+  dtp->u.p.line_buffer = scratch;\n+\n   for (;;)\n     {\n       /* If reversion has occurred and there is another real data item,\n@@ -1002,7 +1010,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n               if (is_internal_unit (dtp))  \n \t        move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n               else\n-                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips, SEEK_CUR);\n+                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips);\n \t      dtp->u.p.current_unit->bytes_left -= (gfc_offset) dtp->u.p.skips;\n \t    }\n \t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n@@ -1213,7 +1221,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t\tbreak;\n \t      case BT_REAL:\n \t\tif (f->u.real.w == 0)\n-                  write_real_g0 (dtp, p, kind, f->u.real.d);\n+\t\t  write_real_g0 (dtp, p, kind, f->u.real.d);\n \t\telse\n \t\t  write_d (dtp, f, p, kind);\n \t\tbreak;\n@@ -1243,6 +1251,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t  dtp->u.p.skips += f->u.n;\n \t  pos = bytes_used + dtp->u.p.skips - 1;\n \t  dtp->u.p.pending_spaces = pos - dtp->u.p.max_pos + 1;\n+\n \t  /* Writes occur just before the switch on f->format, above, so\n \t     that trailing blanks are suppressed, unless we are doing a\n \t     non-advancing write in which case we want to output the blanks\n@@ -1307,17 +1316,24 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t      /* Adjust everything for end-of-record condition */\n \t      if (dtp->u.p.sf_seen_eor && !is_internal_unit (dtp))\n \t\t{\n-                  dtp->u.p.current_unit->bytes_left -= dtp->u.p.sf_seen_eor;\n-                  dtp->u.p.skips -= dtp->u.p.sf_seen_eor;\n+\t\t  if (dtp->u.p.sf_seen_eor == 2)\n+\t\t    {\n+\t\t      /* The EOR was a CRLF (two bytes wide).  */\n+\t\t      dtp->u.p.current_unit->bytes_left -= 2;\n+\t\t      dtp->u.p.skips -= 2;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* The EOR marker was only one byte wide.  */\n+\t\t      dtp->u.p.current_unit->bytes_left--;\n+\t\t      dtp->u.p.skips--;\n+\t\t    }\n \t\t  bytes_used = pos;\n \t\t  dtp->u.p.sf_seen_eor = 0;\n \t\t}\n \t      if (dtp->u.p.skips < 0)\n \t\t{\n-                  if (is_internal_unit (dtp))  \n-                    move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n-                  else\n-                    fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips, SEEK_CUR);\n+\t\t  move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n \t\t  dtp->u.p.current_unit->bytes_left\n \t\t    -= (gfc_offset) dtp->u.p.skips;\n \t\t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n@@ -1393,6 +1409,16 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t  internal_error (&dtp->common, \"Bad format node\");\n \t}\n \n+      /* Free a buffer that we had to allocate during a sequential\n+\t formatted read of a block that was larger than the static\n+\t buffer.  */\n+\n+      if (dtp->u.p.line_buffer != scratch)\n+\t{\n+\t  free_mem (dtp->u.p.line_buffer);\n+\t  dtp->u.p.line_buffer = scratch;\n+\t}\n+\n       /* Adjust the item count and data pointer.  */\n \n       if ((consume_data_flag > 0) && (n > 0))\n@@ -1631,28 +1657,34 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n static void\n us_read (st_parameter_dt *dtp, int continued)\n {\n-  ssize_t n, nr;\n+  size_t n, nr;\n   GFC_INTEGER_4 i4;\n   GFC_INTEGER_8 i8;\n   gfc_offset i;\n \n+  if (dtp->u.p.current_unit->endfile == AT_ENDFILE)\n+    return;\n+\n   if (compile_options.record_marker == 0)\n     n = sizeof (GFC_INTEGER_4);\n   else\n     n = compile_options.record_marker;\n \n-  nr = sread (dtp->u.p.current_unit->s, &i, n);\n-  if (unlikely (nr < 0))\n+  nr = n;\n+\n+  if (unlikely (sread (dtp->u.p.current_unit->s, &i, &n) != 0))\n     {\n       generate_error (&dtp->common, LIBERROR_BAD_US, NULL);\n       return;\n     }\n-  else if (nr == 0)\n+\n+  if (n == 0)\n     {\n-      hit_eof (dtp);\n+      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n       return;  /* end of file */\n     }\n-  else if (unlikely (n != nr))\n+\n+  if (unlikely (n != nr))\n     {\n       generate_error (&dtp->common, LIBERROR_BAD_US, NULL);\n       return;\n@@ -1718,7 +1750,7 @@ us_read (st_parameter_dt *dtp, int continued)\n static void\n us_write (st_parameter_dt *dtp, int continued)\n {\n-  ssize_t nbytes;\n+  size_t nbytes;\n   gfc_offset dummy;\n \n   dummy = 0;\n@@ -1728,7 +1760,7 @@ us_write (st_parameter_dt *dtp, int continued)\n   else\n     nbytes = compile_options.record_marker ;\n \n-  if (swrite (dtp->u.p.current_unit->s, &dummy, nbytes) != nbytes)\n+  if (swrite (dtp->u.p.current_unit->s, &dummy, &nbytes) != 0)\n     generate_error (&dtp->common, LIBERROR_OS, NULL);\n \n   /* For sequential unformatted, if RECL= was not specified in the OPEN\n@@ -1930,7 +1962,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       return;\n     }\n \n-  /* Check the record or position number.  */\n+  /* Check the record number.  */\n \n   if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT\n       && (cf & IOPARM_DT_HAS_REC) == 0)\n@@ -2079,71 +2111,65 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   \n   if (dtp->u.p.current_unit->pad_status == PAD_UNSPECIFIED)\n \tdtp->u.p.current_unit->pad_status = dtp->u.p.current_unit->flags.pad;\n-\n-  /* Check to see if we might be reading what we wrote before  */\n-\n-  if (dtp->u.p.mode != dtp->u.p.current_unit->mode\n-      && !is_internal_unit (dtp))\n-    {\n-      int pos = fbuf_reset (dtp->u.p.current_unit);\n-      if (pos != 0)\n-        sseek (dtp->u.p.current_unit->s, pos, SEEK_CUR);\n-      sflush(dtp->u.p.current_unit->s);\n-    }\n-\n+  \n   /* Check the POS= specifier: that it is in range and that it is used with a\n      unit that has been connected for STREAM access. F2003 9.5.1.10.  */\n   \n   if (((cf & IOPARM_DT_HAS_POS) != 0))\n     {\n       if (is_stream_io (dtp))\n-        {\n-          \n-          if (dtp->pos <= 0)\n-            {\n-              generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n-                              \"POS=specifier must be positive\");\n-              return;\n-            }\n-          \n-          if (dtp->pos >= dtp->u.p.current_unit->maxrec)\n-            {\n-              generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n-                              \"POS=specifier too large\");\n-              return;\n-            }\n-          \n-          dtp->rec = dtp->pos;\n-          \n-          if (dtp->u.p.mode == READING)\n-            {\n-              /* Reset the endfile flag; if we hit EOF during reading\n-                 we'll set the flag and generate an error at that point\n-                 rather than worrying about it here.  */\n-              dtp->u.p.current_unit->endfile = NO_ENDFILE;\n-            }\n-         \n-          if (dtp->pos != dtp->u.p.current_unit->strm_pos)\n-            {\n-              fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n-              sflush (dtp->u.p.current_unit->s);\n-              if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1, SEEK_SET) < 0)\n-                {\n-                  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-                  return;\n-                }\n-              dtp->u.p.current_unit->strm_pos = dtp->pos;\n-            }\n-        }\n+\t{\n+\n+\t  if (dtp->pos <= 0)\n+\t    {\n+\t      generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+\t\t\t      \"POS=specifier must be positive\");\n+\t      return;\n+\t    }\n+\n+\t  if (dtp->pos >= dtp->u.p.current_unit->maxrec)\n+\t    {\n+\t      generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+\t\t\t      \"POS=specifier too large\");\n+\t      return;\n+\t    }\n+\n+\t  dtp->rec = dtp->pos;\n+\n+\t  if (dtp->u.p.mode == READING)\n+\t    {\n+\t      /* Required for compatibility between 4.3 and 4.4 runtime. Check\n+\t      to see if we might be reading what we wrote before  */\n+\t      if (dtp->u.p.current_unit->mode == WRITING)\n+\t\t{\n+\t\t  fbuf_flush (dtp->u.p.current_unit, 1);      \n+\t\t  flush(dtp->u.p.current_unit->s);\n+\t\t}\n+\n+\t      if (dtp->pos < file_length (dtp->u.p.current_unit->s))\n+\t\tdtp->u.p.current_unit->endfile = NO_ENDFILE;\n+\t    }\n+\n+\t  if (dtp->pos != dtp->u.p.current_unit->strm_pos)\n+\t    {\n+\t      fbuf_flush (dtp->u.p.current_unit, 1);\n+\t      flush (dtp->u.p.current_unit->s);\n+\t      if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1) == FAILURE)\n+\t\t{\n+\t\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t\t  return;\n+\t\t}\n+\t      dtp->u.p.current_unit->strm_pos = dtp->pos;\n+\t    }\n+\t}\n       else\n-        {\n-          generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n-                          \"POS=specifier not allowed, \"\n-                          \"Try OPEN with ACCESS='stream'\");\n-          return;\n-        }\n+\t{\n+\t  generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+\t\t\t  \"POS=specifier not allowed, \"\n+\t\t\t  \"Try OPEN with ACCESS='stream'\");\n+\t  return;\n+\t}\n     }\n-  \n \n   /* Sanity checks on the record number.  */\n   if ((cf & IOPARM_DT_HAS_REC) != 0)\n@@ -2162,10 +2188,15 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t  return;\n \t}\n \n-      /* Make sure format buffer is reset.  */\n-      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED)\n-        fbuf_reset (dtp->u.p.current_unit);\n+      /* Check to see if we might be reading what we wrote before  */\n \n+      if (dtp->u.p.mode == READING\n+\t  && dtp->u.p.current_unit->mode == WRITING\n+\t  && !is_internal_unit (dtp))\n+\t{\n+\t  fbuf_flush (dtp->u.p.current_unit, 1);      \n+\t  flush(dtp->u.p.current_unit->s);\n+\t}\n \n       /* Check whether the record exists to be read.  Only\n \t a partial record needs to exist.  */\n@@ -2180,28 +2211,37 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n       /* Position the file.  */\n       if (sseek (dtp->u.p.current_unit->s, (gfc_offset) (dtp->rec - 1)\n-                 * dtp->u.p.current_unit->recl, SEEK_SET) < 0)\n-        {\n-          generate_error (&dtp->common, LIBERROR_OS, NULL);\n-          return;\n-        }\n+\t\t * dtp->u.p.current_unit->recl) == FAILURE)\n+\t{\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t  return;\n+\t}\n \n       /* TODO: This is required to maintain compatibility between\n-         4.3 and 4.4 runtime. Remove when ABI changes from 4.3 */\n+\t 4.3 and 4.4 runtime. Remove when ABI changes from 4.3 */\n \n       if (is_stream_io (dtp))\n-        dtp->u.p.current_unit->strm_pos = dtp->rec;\n-\n+\tdtp->u.p.current_unit->strm_pos = dtp->rec;\n+      \n       /* TODO: Un-comment this code when ABI changes from 4.3.\n       if (dtp->u.p.current_unit->flags.access == ACCESS_STREAM)\n-       {\n-         generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n-                     \"Record number not allowed for stream access \"\n-                     \"data transfer\");\n-         return;\n-       }  */\n+\t{\n+\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t      \"Record number not allowed for stream access \"\n+\t\t      \"data transfer\");\n+\t  return;\n+\t}  */\n+\n     }\n \n+  /* Overwriting an existing sequential file ?\n+     it is always safe to truncate the file on the first write */\n+  if (dtp->u.p.mode == WRITING\n+      && dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n+      && dtp->u.p.current_unit->last_record == 0 \n+      && !is_preconnected(dtp->u.p.current_unit->s))\n+\tstruncate(dtp->u.p.current_unit->s);\n+\n   /* Bugware for badly written mixed C-Fortran I/O.  */\n   flush_if_preconnected(dtp->u.p.current_unit->s);\n \n@@ -2354,8 +2394,8 @@ next_array_record (st_parameter_dt *dtp, array_loop_spec *ls, int *finished)\n static void\n skip_record (st_parameter_dt *dtp, size_t bytes)\n {\n+  gfc_offset new;\n   size_t rlength;\n-  ssize_t readb;\n   static const size_t MAX_READ = 4096;\n   char p[MAX_READ];\n \n@@ -2365,28 +2405,29 @@ skip_record (st_parameter_dt *dtp, size_t bytes)\n \n   if (is_seekable (dtp->u.p.current_unit->s))\n     {\n+      new = file_position (dtp->u.p.current_unit->s)\n+\t+ dtp->u.p.current_unit->bytes_left_subrecord;\n+\n       /* Direct access files do not generate END conditions,\n \t only I/O errors.  */\n-      if (sseek (dtp->u.p.current_unit->s, \n-\t\t dtp->u.p.current_unit->bytes_left_subrecord, SEEK_CUR) < 0)\n+      if (sseek (dtp->u.p.current_unit->s, new) == FAILURE)\n \tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n     }\n   else\n     {\t\t\t/* Seek by reading data.  */\n       while (dtp->u.p.current_unit->bytes_left_subrecord > 0)\n \t{\n \t  rlength = \n-\t    (MAX_READ < (size_t) dtp->u.p.current_unit->bytes_left_subrecord) ?\n+\t    (MAX_READ > (size_t) dtp->u.p.current_unit->bytes_left_subrecord) ?\n \t    MAX_READ : (size_t) dtp->u.p.current_unit->bytes_left_subrecord;\n \n-\t  readb = sread (dtp->u.p.current_unit->s, p, rlength);\n-\t  if (readb < 0)\n+\t  if (sread (dtp->u.p.current_unit->s, p, &rlength) != 0)\n \t    {\n \t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t      return;\n \t    }\n \n-\t  dtp->u.p.current_unit->bytes_left_subrecord -= readb;\n+\t  dtp->u.p.current_unit->bytes_left_subrecord -= rlength;\n \t}\n     }\n \n@@ -2434,8 +2475,8 @@ next_record_r (st_parameter_dt *dtp)\n {\n   gfc_offset record;\n   int bytes_left;\n+  size_t length;\n   char p;\n-  int cc;\n \n   switch (current_mode (dtp))\n     {\n@@ -2455,12 +2496,11 @@ next_record_r (st_parameter_dt *dtp)\n \n     case FORMATTED_STREAM:\n     case FORMATTED_SEQUENTIAL:\n-      /* read_sf has already terminated input because of an '\\n', or\n-         we have hit EOF.  */\n-      if (dtp->u.p.sf_seen_eor || dtp->u.p.at_eof)\n+      length = 1;\n+      /* sf_read has already terminated input because of an '\\n'  */\n+      if (dtp->u.p.sf_seen_eor)\n \t{\n \t  dtp->u.p.sf_seen_eor = 0;\n-          dtp->u.p.at_eof = 0;\n \t  break;\n \t}\n \n@@ -2475,7 +2515,7 @@ next_record_r (st_parameter_dt *dtp)\n \n \t      /* Now seek to this record.  */\n \t      record = record * dtp->u.p.current_unit->recl;\n-\t      if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n+\t      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  break;\n@@ -2487,9 +2527,10 @@ next_record_r (st_parameter_dt *dtp)\n \t      bytes_left = (int) dtp->u.p.current_unit->bytes_left;\n \t      bytes_left = min_off (bytes_left, \n \t\t      file_length (dtp->u.p.current_unit->s)\n-\t\t      - stell (dtp->u.p.current_unit->s));\n+\t\t      - file_position (dtp->u.p.current_unit->s));\n \t      if (sseek (dtp->u.p.current_unit->s, \n-\t\t\t bytes_left, SEEK_CUR) < 0)\n+\t\t\t  file_position (dtp->u.p.current_unit->s) \n+\t\t\t  + bytes_left) == FAILURE)\n \t        {\n \t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  break;\n@@ -2499,37 +2540,42 @@ next_record_r (st_parameter_dt *dtp)\n \t    } \n \t  break;\n \t}\n-      else \n+      else do\n \t{\n-\t  do\n+\t  if (sread (dtp->u.p.current_unit->s, &p, &length) != 0) \n \t    {\n-              errno = 0;\n-              cc = fbuf_getc (dtp->u.p.current_unit);\n-\t      if (cc == EOF) \n-\t\t{\n-                  if (errno != 0)\n-                    generate_error (&dtp->common, LIBERROR_OS, NULL);\n-                  else\n-                    hit_eof (dtp);\n-\t\t  break;\n-                }\n-\t      \n-\t      if (is_stream_io (dtp))\n-\t\tdtp->u.p.current_unit->strm_pos++;\n-              \n-              p = (char) cc;\n+\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t      break;\n \t    }\n-\t  while (p != '\\n');\n+\n+\t  if (length == 0)\n+\t    {\n+\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\t      break;\n+\t    }\n+\n+\t  if (is_stream_io (dtp))\n+\t    dtp->u.p.current_unit->strm_pos++;\n \t}\n+      while (p != '\\n');\n+\n       break;\n     }\n+\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n+      && !dtp->u.p.namelist_mode\n+      && dtp->u.p.current_unit->endfile == NO_ENDFILE\n+      && (file_length (dtp->u.p.current_unit->s) ==\n+\t file_position (dtp->u.p.current_unit->s)))\n+    dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\n }\n \n \n /* Small utility function to write a record marker, taking care of\n    byte swapping and of choosing the correct size.  */\n \n-static int\n+inline static int\n write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n {\n   size_t len;\n@@ -2549,12 +2595,12 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n \t{\n \tcase sizeof (GFC_INTEGER_4):\n \t  buf4 = buf;\n-\t  return swrite (dtp->u.p.current_unit->s, &buf4, len);\n+\t  return swrite (dtp->u.p.current_unit->s, &buf4, &len);\n \t  break;\n \n \tcase sizeof (GFC_INTEGER_8):\n \t  buf8 = buf;\n-\t  return swrite (dtp->u.p.current_unit->s, &buf8, len);\n+\t  return swrite (dtp->u.p.current_unit->s, &buf8, &len);\n \t  break;\n \n \tdefault:\n@@ -2569,13 +2615,13 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n \tcase sizeof (GFC_INTEGER_4):\n \t  buf4 = buf;\n \t  reverse_memcpy (p, &buf4, sizeof (GFC_INTEGER_4));\n-\t  return swrite (dtp->u.p.current_unit->s, p, len);\n+\t  return swrite (dtp->u.p.current_unit->s, p, &len);\n \t  break;\n \n \tcase sizeof (GFC_INTEGER_8):\n \t  buf8 = buf;\n \t  reverse_memcpy (p, &buf8, sizeof (GFC_INTEGER_8));\n-\t  return swrite (dtp->u.p.current_unit->s, p, len);\n+\t  return swrite (dtp->u.p.current_unit->s, p, &len);\n \t  break;\n \n \tdefault:\n@@ -2598,7 +2644,7 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   /* Bytes written.  */\n   m = dtp->u.p.current_unit->recl_subrecord\n     - dtp->u.p.current_unit->bytes_left_subrecord;\n-  c = stell (dtp->u.p.current_unit->s);\n+  c = file_position (dtp->u.p.current_unit->s);\n \n   /* Write the length tail.  If we finish a record containing\n      subrecords, we write out the negative length.  */\n@@ -2608,7 +2654,7 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   else\n     m_write = m;\n \n-  if (unlikely (write_us_marker (dtp, m_write) < 0))\n+  if (unlikely (write_us_marker (dtp, m_write) != 0))\n     goto io_error;\n \n   if (compile_options.record_marker == 0)\n@@ -2619,22 +2665,22 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   /* Seek to the head and overwrite the bogus length with the real\n      length.  */\n \n-  if (unlikely (sseek (dtp->u.p.current_unit->s, c - m - record_marker, \n-\t\t       SEEK_SET) < 0))\n+  if (unlikely (sseek (dtp->u.p.current_unit->s, c - m - record_marker)\n+\t\t== FAILURE))\n     goto io_error;\n \n   if (next_subrecord)\n     m_write = -m;\n   else\n     m_write = m;\n \n-  if (unlikely (write_us_marker (dtp, m_write) < 0))\n+  if (unlikely (write_us_marker (dtp, m_write) != 0))\n     goto io_error;\n \n   /* Seek past the end of the current record.  */\n \n-  if (unlikely (sseek (dtp->u.p.current_unit->s, c + record_marker, \n-\t\t       SEEK_SET) < 0))\n+  if (unlikely (sseek (dtp->u.p.current_unit->s, c + record_marker)\n+\t\t== FAILURE))\n     goto io_error;\n \n   return;\n@@ -2645,35 +2691,6 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n \n }\n \n-\n-/* Utility function like memset() but operating on streams. Return\n-   value is same as for POSIX write().  */\n-\n-static ssize_t\n-sset (stream * s, int c, ssize_t nbyte)\n-{\n-  static const int WRITE_CHUNK = 256;\n-  char p[WRITE_CHUNK];\n-  ssize_t bytes_left, trans;\n-\n-  if (nbyte < WRITE_CHUNK)\n-    memset (p, c, nbyte);\n-  else\n-    memset (p, c, WRITE_CHUNK);\n-\n-  bytes_left = nbyte;\n-  while (bytes_left > 0)\n-    {\n-      trans = (bytes_left < WRITE_CHUNK) ? bytes_left : WRITE_CHUNK;\n-      trans = swrite (s, p, trans);\n-      if (trans < 0)\n-\treturn trans;\n-      bytes_left -= trans;\n-    }\n-\t       \n-  return nbyte - bytes_left;\n-}\n-\n /* Position to the next record in write mode.  */\n \n static void\n@@ -2682,6 +2699,9 @@ next_record_w (st_parameter_dt *dtp, int done)\n   gfc_offset m, record, max_pos;\n   int length;\n \n+  /* Flush and reset the format buffer.  */\n+  fbuf_flush (dtp->u.p.current_unit, 1);\n+  \n   /* Zero counters for X- and T-editing.  */\n   max_pos = dtp->u.p.max_pos;\n   dtp->u.p.max_pos = dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n@@ -2696,11 +2716,8 @@ next_record_w (st_parameter_dt *dtp, int done)\n       if (dtp->u.p.current_unit->bytes_left == 0)\n \tbreak;\n \n-      fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n-      fbuf_flush (dtp->u.p.current_unit, WRITING);\n       if (sset (dtp->u.p.current_unit->s, ' ', \n-\t\tdtp->u.p.current_unit->bytes_left) \n-\t  != dtp->u.p.current_unit->bytes_left)\n+\t\tdtp->u.p.current_unit->bytes_left) == FAILURE)\n \tgoto io_error;\n \n       break;\n@@ -2709,7 +2726,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n       if (dtp->u.p.current_unit->bytes_left > 0)\n \t{\n \t  length = (int) dtp->u.p.current_unit->bytes_left;\n-\t  if (sset (dtp->u.p.current_unit->s, 0, length) != length)\n+\t  if (sset (dtp->u.p.current_unit->s, 0, length) == FAILURE)\n \t    goto io_error;\n \t}\n       break;\n@@ -2740,15 +2757,16 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t{\n \t\t  length = (int) (max_pos - m);\n \t\t  if (sseek (dtp->u.p.current_unit->s, \n-\t\t\t     length, SEEK_CUR) < 0)\n+\t\t\t      file_position (dtp->u.p.current_unit->s) \n+\t\t\t      + length) == FAILURE)\n \t\t    {\n \t\t      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t      return;\n \t\t    }\n \t\t  length = (int) (dtp->u.p.current_unit->recl - max_pos);\n \t\t}\n \n-\t      if (sset (dtp->u.p.current_unit->s, ' ', length) != length)\n+\t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t\t  return;\n@@ -2764,7 +2782,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t      /* Now seek to this record */\n \t      record = record * dtp->u.p.current_unit->recl;\n \n-\t      if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n+\t      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  return;\n@@ -2787,7 +2805,8 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t    {\n \t\t      length = (int) (max_pos - m);\n \t\t      if (sseek (dtp->u.p.current_unit->s, \n-\t\t\t\t length, SEEK_CUR) < 0)\n+\t\t\t\t  file_position (dtp->u.p.current_unit->s)\n+\t\t\t\t  + length) == FAILURE)\n \t\t        {\n \t\t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t\t  return;\n@@ -2798,7 +2817,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t    length = (int) dtp->u.p.current_unit->bytes_left;\n \t\t}\n \n-\t      if (sset (dtp->u.p.current_unit->s, ' ', length) != length)\n+\t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t\t  return;\n@@ -2807,27 +2826,23 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t}\n       else\n \t{\n+\t  size_t len;\n+\t  const char crlf[] = \"\\r\\n\";\n+\n #ifdef HAVE_CRLF\n-\t  const int len = 2;\n+\t  len = 2;\n #else\n-\t  const int len = 1;\n-#endif\n-          fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n-          char * p = fbuf_alloc (dtp->u.p.current_unit, len);\n-          if (!p)\n-            goto io_error;\n-#ifdef HAVE_CRLF\n-          *(p++) = '\\r';\n+\t  len = 1;\n #endif\n-          *p = '\\n';\n+\t  if (swrite (dtp->u.p.current_unit->s, &crlf[2-len], &len) != 0)\n+\t    goto io_error;\n+\t  \n \t  if (is_stream_io (dtp))\n \t    {\n \t      dtp->u.p.current_unit->strm_pos += len;\n \t      if (dtp->u.p.current_unit->strm_pos\n \t\t  < file_length (dtp->u.p.current_unit->s))\n-\t\tunit_truncate (dtp->u.p.current_unit,\n-                               dtp->u.p.current_unit->strm_pos - 1,\n-                               &dtp->common);\n+\t\tstruncate (dtp->u.p.current_unit->s);\n \t    }\n \t}\n \n@@ -2865,7 +2880,7 @@ next_record (st_parameter_dt *dtp, int done)\n       dtp->u.p.current_unit->current_record = 0;\n       if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n \t{\n-\t  fp = stell (dtp->u.p.current_unit->s);\n+\t  fp = file_position (dtp->u.p.current_unit->s);\n \t  /* Calculate next record, rounding up partial records.  */\n \t  dtp->u.p.current_unit->last_record =\n \t    (fp + dtp->u.p.current_unit->recl - 1) /\n@@ -2877,8 +2892,6 @@ next_record (st_parameter_dt *dtp, int done)\n \n   if (!done)\n     pre_position (dtp);\n-\n-  fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n }\n \n \n@@ -2927,6 +2940,7 @@ finalize_transfer (st_parameter_dt *dtp)\n   if ((cf & IOPARM_DT_LIST_FORMAT) != 0 && dtp->u.p.mode == READING)\n     {\n       finish_list_read (dtp);\n+      sfree (dtp->u.p.current_unit->s);\n       return;\n     }\n \n@@ -2941,9 +2955,10 @@ finalize_transfer (st_parameter_dt *dtp)\n \tnext_record (dtp, 1);\n \n       if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED\n-\t  && stell (dtp->u.p.current_unit->s) >= dtp->rec)\n+\t  && file_position (dtp->u.p.current_unit->s) >= dtp->rec)\n \t{\n-\t  sflush (dtp->u.p.current_unit->s);\n+\t  flush (dtp->u.p.current_unit->s);\n+\t  sfree (dtp->u.p.current_unit->s);\n \t}\n       return;\n     }\n@@ -2952,8 +2967,9 @@ finalize_transfer (st_parameter_dt *dtp)\n \n   if (!is_internal_unit (dtp) && dtp->u.p.seen_dollar)\n     {\n-      fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n       dtp->u.p.seen_dollar = 0;\n+      fbuf_flush (dtp->u.p.current_unit, 1);\n+      sfree (dtp->u.p.current_unit->s);\n       return;\n     }\n \n@@ -2965,17 +2981,15 @@ finalize_transfer (st_parameter_dt *dtp)\n \t- dtp->u.p.current_unit->bytes_left);\n       dtp->u.p.current_unit->saved_pos =\n \tdtp->u.p.max_pos > 0 ? dtp->u.p.max_pos - bytes_written : 0;\n-      fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n-      sflush (dtp->u.p.current_unit->s);\n+      fbuf_flush (dtp->u.p.current_unit, 0);\n+      flush (dtp->u.p.current_unit->s);\n       return;\n     }\n-  else if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED \n-           && dtp->u.p.mode == WRITING && !is_internal_unit (dtp))\n-      fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);    \n \n   dtp->u.p.current_unit->saved_pos = 0;\n \n   next_record (dtp, 1);\n+  sfree (dtp->u.p.current_unit->s);\n }\n \n /* Transfer function for IOLENGTH. It doesn't actually do any\n@@ -3032,6 +3046,8 @@ void\n st_iolength_done (st_parameter_dt *dtp __attribute__((unused)))\n {\n   free_ionml (dtp);\n+  if (dtp->u.p.scratch != NULL)\n+    free_mem (dtp->u.p.scratch);\n   library_end ();\n }\n \n@@ -3047,6 +3063,29 @@ st_read (st_parameter_dt *dtp)\n   library_start (&dtp->common);\n \n   data_transfer_init (dtp, 1);\n+\n+  /* Handle complications dealing with the endfile record.  */\n+\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+    switch (dtp->u.p.current_unit->endfile)\n+      {\n+      case NO_ENDFILE:\n+\tbreak;\n+\n+      case AT_ENDFILE:\n+\tif (!is_internal_unit (dtp))\n+\t  {\n+\t    generate_error (&dtp->common, LIBERROR_END, NULL);\n+\t    dtp->u.p.current_unit->endfile = AFTER_ENDFILE;\n+\t    dtp->u.p.current_unit->current_record = 0;\n+\t  }\n+\tbreak;\n+\n+      case AFTER_ENDFILE:\n+\tgenerate_error (&dtp->common, LIBERROR_ENDFILE, NULL);\n+\tdtp->u.p.current_unit->current_record = 0;\n+\tbreak;\n+      }\n }\n \n extern void st_read_done (st_parameter_dt *);\n@@ -3058,6 +3097,8 @@ st_read_done (st_parameter_dt *dtp)\n   finalize_transfer (dtp);\n   free_format_data (dtp);\n   free_ionml (dtp);\n+  if (dtp->u.p.scratch != NULL)\n+    free_mem (dtp->u.p.scratch);\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n \n@@ -3100,15 +3141,19 @@ st_write_done (st_parameter_dt *dtp)\n       case NO_ENDFILE:\n \t/* Get rid of whatever is after this record.  */\n         if (!is_internal_unit (dtp))\n-          unit_truncate (dtp->u.p.current_unit, \n-                         stell (dtp->u.p.current_unit->s),\n-                         &dtp->common);\n+\t  {\n+\t    flush (dtp->u.p.current_unit->s);\n+\t    if (struncate (dtp->u.p.current_unit->s) == FAILURE)\n+\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t  }\n \tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n \tbreak;\n       }\n \n   free_format_data (dtp);\n   free_ionml (dtp);\n+  if (dtp->u.p.scratch != NULL)\n+    free_mem (dtp->u.p.scratch);\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n   \n@@ -3222,46 +3267,3 @@ void reverse_memcpy (void *dest, const void *src, size_t n)\n   for (i=0; i<n; i++)\n       *(d++) = *(s--);\n }\n-\n-\n-/* Once upon a time, a poor innocent Fortran program was reading a\n-   file, when suddenly it hit the end-of-file (EOF).  Unfortunately\n-   the OS doesn't tell whether we're at the EOF or whether we already\n-   went past it.  Luckily our hero, libgfortran, keeps track of this.\n-   Call this function when you detect an EOF condition.  See Section\n-   9.10.2 in F2003.  */\n-\n-void\n-hit_eof (st_parameter_dt * dtp)\n-{\n-  dtp->u.p.current_unit->flags.position = POSITION_APPEND;\n-\n-  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n-    switch (dtp->u.p.current_unit->endfile)\n-      {\n-      case NO_ENDFILE:\n-      case AT_ENDFILE:\n-        generate_error (&dtp->common, LIBERROR_END, NULL);\n-\tif (!is_internal_unit (dtp))\n-\t  {\n-\t    dtp->u.p.current_unit->endfile = AFTER_ENDFILE;\n-\t    dtp->u.p.current_unit->current_record = 0;\n-\t  }\n-        else\n-          dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\tbreak;\n-        \n-      case AFTER_ENDFILE:\n-\tgenerate_error (&dtp->common, LIBERROR_ENDFILE, NULL);\n-\tdtp->u.p.current_unit->current_record = 0;\n-\tbreak;\n-      }\n-  else\n-    {\n-      /* Non-sequential files don't have an ENDFILE record, so we\n-         can't be at AFTER_ENDFILE.  */\n-      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-      generate_error (&dtp->common, LIBERROR_END, NULL);\n-      dtp->u.p.current_unit->current_record = 0;\n-    }\n-}"}, {"sha": "0af002d1a95cefd48c9ed49ff1b27664fa0cbfea", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 11, "deletions": 62, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ed1d022245ccef6adb105bd4c61dfa2ef31edb/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=f3ed1d022245ccef6adb105bd4c61dfa2ef31edb", "patch": "@@ -540,8 +540,6 @@ init_units (void)\n       u->file_len = strlen (stdin_name);\n       u->file = get_mem (u->file_len);\n       memmove (u->file, stdin_name, u->file_len);\n-\n-      fbuf_init (u, 0);\n     \n       __gthread_mutex_unlock (&u->lock);\n     }\n@@ -699,62 +697,15 @@ close_units (void)\n void\n update_position (gfc_unit *u)\n {\n-  if (stell (u->s) == 0)\n+  if (file_position (u->s) == 0)\n     u->flags.position = POSITION_REWIND;\n-  else if (file_length (u->s) == stell (u->s))\n+  else if (file_length (u->s) == file_position (u->s))\n     u->flags.position = POSITION_APPEND;\n   else\n     u->flags.position = POSITION_ASIS;\n }\n \n \n-/* High level interface to truncate a file safely, i.e. flush format\n-   buffers, check that it's a regular file, and generate error if that\n-   occurs.  Just like POSIX ftruncate, returns 0 on success, -1 on\n-   failure.  */\n-\n-int\n-unit_truncate (gfc_unit * u, gfc_offset pos, st_parameter_common * common)\n-{\n-  int ret;\n-\n-  /* Make sure format buffer is flushed.  */\n-  if (u->flags.form == FORM_FORMATTED)\n-    {\n-      if (u->mode == READING)\n-\tpos += fbuf_reset (u);\n-      else\n-\tfbuf_flush (u, u->mode);\n-    }\n-  \n-  /* Don't try to truncate a special file, just pretend that it\n-     succeeds.  */\n-  if (is_special (u->s) || !is_seekable (u->s))\n-    {\n-      sflush (u->s);\n-      return 0;\n-    }\n-\n-  /* struncate() should flush the stream buffer if necessary, so don't\n-     bother calling sflush() here.  */\n-  ret = struncate (u->s, pos);\n-\n-  if (ret != 0)\n-    {\n-      generate_error (common, LIBERROR_OS, NULL);\n-      u->endfile = NO_ENDFILE;\n-      u->flags.position = POSITION_ASIS;\n-    }\n-  else\n-    {\n-      u->endfile = AT_ENDFILE;\n-      u->flags.position = POSITION_APPEND;\n-    }\n-\n-  return ret;\n-}\n-\n-\n /* filename_from_unit()-- If the unit_number exists, return a pointer to the\n    name of the associated file, otherwise return the empty string.  The caller\n    must free memory allocated for the filename string.  */\n@@ -795,25 +746,23 @@ finish_last_advance_record (gfc_unit *u)\n {\n   \n   if (u->saved_pos > 0)\n-    fbuf_seek (u, u->saved_pos, SEEK_CUR);\n+    fbuf_seek (u, u->saved_pos);\n+    \n+  fbuf_flush (u, 1);\n \n   if (!(u->unit_number == options.stdout_unit\n \t|| u->unit_number == options.stderr_unit))\n     {\n+      size_t len;\n+\n+      const char crlf[] = \"\\r\\n\";\n #ifdef HAVE_CRLF\n-      const int len = 2;\n+      len = 2;\n #else\n-      const int len = 1;\n+      len = 1;\n #endif\n-      char *p = fbuf_alloc (u, len);\n-      if (!p)\n+      if (swrite (u->s, &crlf[2-len], &len) != 0)\n \tos_error (\"Completing record after ADVANCE_NO failed\");\n-#ifdef HAVE_CRLF\n-      *(p++) = '\\r';\n-#endif\n-      *p = '\\n';\n     }\n-\n-  fbuf_flush (u, u->mode);\n }\n "}]}