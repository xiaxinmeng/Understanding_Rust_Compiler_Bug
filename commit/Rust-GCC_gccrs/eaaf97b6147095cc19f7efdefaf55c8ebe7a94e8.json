{"sha": "eaaf97b6147095cc19f7efdefaf55c8ebe7a94e8", "node_id": "C_kwDOANBUbNoAKGVhYWY5N2I2MTQ3MDk1Y2MxOWY3ZWZkZWZhZjU1YzhlYmU3YTk0ZTg", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-12-01T02:26:43Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-12-01T02:26:43Z"}, "message": "analyzer: fix i18n issues in symbolic out-of-bounds [PR106626]\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106626\n\t* bounds-checking.cc\n\t(symbolic_past_the_end::describe_final_event): Delete, moving to\n\tsymbolic_buffer_overflow::describe_final_event and\n\tsymbolic_buffer_over_read::describe_final_event, eliminating\n\tcomposition of text strings via \"byte_str\" and \"m_dir_str\".\n\t(symbolic_past_the_end::m_dir_str): Delete field.\n\t(symbolic_buffer_overflow::symbolic_buffer_overflow): Drop\n\tm_dir_str.\n\t(symbolic_buffer_overflow::describe_final_event): New, as noted\n\tabove.\n\t(symbolic_buffer_over_read::symbolic_buffer_overflow): Drop\n\tm_dir_str.\n\t(symbolic_buffer_over_read::describe_final_event): New, as noted\n\tabove.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "94124b9ddcf872c78a791da2d9aca0590b129803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94124b9ddcf872c78a791da2d9aca0590b129803"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaaf97b6147095cc19f7efdefaf55c8ebe7a94e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaaf97b6147095cc19f7efdefaf55c8ebe7a94e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaaf97b6147095cc19f7efdefaf55c8ebe7a94e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaaf97b6147095cc19f7efdefaf55c8ebe7a94e8/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bc9e4ee874ea3618780413b79b51412dcc40363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bc9e4ee874ea3618780413b79b51412dcc40363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bc9e4ee874ea3618780413b79b51412dcc40363"}], "stats": {"total": 192, "additions": 138, "deletions": 54}, "files": [{"sha": "1c44790f86d022ca7a265fa0a7bfe042a7d98db4", "filename": "gcc/analyzer/bounds-checking.cc", "status": "modified", "additions": 138, "deletions": 54, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaaf97b6147095cc19f7efdefaf55c8ebe7a94e8/gcc%2Fanalyzer%2Fbounds-checking.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaaf97b6147095cc19f7efdefaf55c8ebe7a94e8/gcc%2Fanalyzer%2Fbounds-checking.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fbounds-checking.cc?ref=eaaf97b6147095cc19f7efdefaf55c8ebe7a94e8", "patch": "@@ -544,62 +544,10 @@ class symbolic_past_the_end : public out_of_bounds\n     return label_text ();\n   }\n \n-  label_text\n-  describe_final_event (const evdesc::final_event &ev) final override\n-  {\n-    const char *byte_str;\n-    if (pending_diagnostic::same_tree_p (m_num_bytes, integer_one_node))\n-      byte_str = \"byte\";\n-    else\n-      byte_str = \"bytes\";\n-\n-    if (m_offset)\n-      {\n-\tif (m_num_bytes && TREE_CODE (m_num_bytes) == INTEGER_CST)\n-\t  {\n-\t    if (m_diag_arg)\n-\t      return ev.formatted_print (\"%s of %E %s at offset %qE\"\n-\t\t\t\t\t \" exceeds %qE\", m_dir_str,\n-\t\t\t\t\t m_num_bytes, byte_str,\n-\t\t\t\t\t m_offset, m_diag_arg);\n-\t    else\n-\t      return ev.formatted_print (\"%s of %E %s at offset %qE\"\n-\t\t\t\t\t \" exceeds the buffer\", m_dir_str,\n-\t\t\t\t\t m_num_bytes, byte_str, m_offset);\n-\t  }\n-\telse if (m_num_bytes)\n-\t  {\n-\t    if (m_diag_arg)\n-\t      return ev.formatted_print (\"%s of %qE %s at offset %qE\"\n-\t\t\t\t\t \" exceeds %qE\", m_dir_str,\n-\t\t\t\t\t m_num_bytes, byte_str,\n-\t\t\t\t\t m_offset, m_diag_arg);\n-\t    else\n-\t      return ev.formatted_print (\"%s of %qE %s at offset %qE\"\n-\t\t\t\t\t \" exceeds the buffer\", m_dir_str,\n-\t\t\t\t\t m_num_bytes, byte_str, m_offset);\n-\t  }\n-\telse\n-\t  {\n-\t    if (m_diag_arg)\n-\t      return ev.formatted_print (\"%s at offset %qE exceeds %qE\",\n-\t\t\t\t\t m_dir_str, m_offset, m_diag_arg);\n-\t    else\n-\t      return ev.formatted_print (\"%s at offset %qE exceeds the\"\n-\t\t\t\t\t \" buffer\", m_dir_str, m_offset);\n-\t  }\n-      }\n-    if (m_diag_arg)\n-      return ev.formatted_print (\"out-of-bounds %s on %qE\",\n-\t\t\t\t m_dir_str, m_diag_arg);\n-    return ev.formatted_print (\"out-of-bounds %s\", m_dir_str);\n-  }\n-\n protected:\n   tree m_offset;\n   tree m_num_bytes;\n   tree m_capacity;\n-  const char *m_dir_str;\n };\n \n /* Concrete subclass to complain about overflows with symbolic values.  */\n@@ -611,7 +559,6 @@ class symbolic_buffer_overflow : public symbolic_past_the_end\n \t\t\t    tree num_bytes, tree capacity)\n   : symbolic_past_the_end (reg, diag_arg, offset, num_bytes, capacity)\n   {\n-    m_dir_str = \"write\";\n   }\n \n   const char *get_kind () const final override\n@@ -638,6 +585,75 @@ class symbolic_buffer_overflow : public symbolic_past_the_end\n \t\t\t     \"heap-based buffer overflow\");\n       }\n   }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    if (m_offset)\n+      {\n+\t/* Known offset.  */\n+\tif (m_num_bytes)\n+\t  {\n+\t    /* Known offset, known size.  */\n+\t    if (TREE_CODE (m_num_bytes) == INTEGER_CST)\n+\t      {\n+\t\t/* Known offset, known constant size.  */\n+\t\tif (pending_diagnostic::same_tree_p (m_num_bytes,\n+\t\t\t\t\t\t     integer_one_node))\n+\t\t  {\n+\t\t    /* Singular m_num_bytes.  */\n+\t\t    if (m_diag_arg)\n+\t\t      return ev.formatted_print\n+\t\t\t(\"write of %E byte at offset %qE exceeds %qE\",\n+\t\t\t m_num_bytes, m_offset, m_diag_arg);\n+\t\t    else\n+\t\t      return ev.formatted_print\n+\t\t\t(\"write of %E byte at offset %qE exceeds the buffer\",\n+\t\t\t m_num_bytes, m_offset);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Plural m_num_bytes.  */\n+\t\t    if (m_diag_arg)\n+\t\t      return ev.formatted_print\n+\t\t\t(\"write of %E bytes at offset %qE exceeds %qE\",\n+\t\t\t m_num_bytes, m_offset, m_diag_arg);\n+\t\t    else\n+\t\t      return ev.formatted_print\n+\t\t\t(\"write of %E bytes at offset %qE exceeds the buffer\",\n+\t\t\t m_num_bytes, m_offset);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Known offset, known symbolic size.  */\n+\t\tif (m_diag_arg)\n+\t\t  return ev.formatted_print\n+\t\t    (\"write of %qE bytes at offset %qE exceeds %qE\",\n+\t\t     m_num_bytes, m_offset, m_diag_arg);\n+\t\telse\n+\t\t  return ev.formatted_print\n+\t\t    (\"write of %qE bytes at offset %qE exceeds the buffer\",\n+\t\t     m_num_bytes, m_offset);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    /* Known offset, unknown size.  */\n+\t    if (m_diag_arg)\n+\t      return ev.formatted_print (\"write at offset %qE exceeds %qE\",\n+\t\t\t\t\t m_offset, m_diag_arg);\n+\t    else\n+\t      return ev.formatted_print (\"write at offset %qE exceeds the\"\n+\t\t\t\t\t \" buffer\", m_offset);\n+\t  }\n+      }\n+    /* Unknown offset.  */\n+    if (m_diag_arg)\n+      return ev.formatted_print (\"out-of-bounds write on %qE\",\n+\t\t\t\t m_diag_arg);\n+    return ev.formatted_print (\"out-of-bounds write\");\n+  }\n };\n \n /* Concrete subclass to complain about over-reads with symbolic values.  */\n@@ -649,7 +665,6 @@ class symbolic_buffer_over_read : public symbolic_past_the_end\n \t\t\t     tree num_bytes, tree capacity)\n   : symbolic_past_the_end (reg, diag_arg, offset, num_bytes, capacity)\n   {\n-    m_dir_str = \"read\";\n   }\n \n   const char *get_kind () const final override\n@@ -677,6 +692,75 @@ class symbolic_buffer_over_read : public symbolic_past_the_end\n \t\t\t     \"heap-based buffer over-read\");\n       }\n   }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    if (m_offset)\n+      {\n+\t/* Known offset.  */\n+\tif (m_num_bytes)\n+\t  {\n+\t    /* Known offset, known size.  */\n+\t    if (TREE_CODE (m_num_bytes) == INTEGER_CST)\n+\t      {\n+\t\t/* Known offset, known constant size.  */\n+\t\tif (pending_diagnostic::same_tree_p (m_num_bytes,\n+\t\t\t\t\t\t     integer_one_node))\n+\t\t  {\n+\t\t    /* Singular m_num_bytes.  */\n+\t\t    if (m_diag_arg)\n+\t\t      return ev.formatted_print\n+\t\t\t(\"read of %E byte at offset %qE exceeds %qE\",\n+\t\t\t m_num_bytes, m_offset, m_diag_arg);\n+\t\t    else\n+\t\t      return ev.formatted_print\n+\t\t\t(\"read of %E byte at offset %qE exceeds the buffer\",\n+\t\t\t m_num_bytes, m_offset);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Plural m_num_bytes.  */\n+\t\t    if (m_diag_arg)\n+\t\t      return ev.formatted_print\n+\t\t\t(\"read of %E bytes at offset %qE exceeds %qE\",\n+\t\t\t m_num_bytes, m_offset, m_diag_arg);\n+\t\t    else\n+\t\t      return ev.formatted_print\n+\t\t\t(\"read of %E bytes at offset %qE exceeds the buffer\",\n+\t\t\t m_num_bytes, m_offset);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Known offset, known symbolic size.  */\n+\t\tif (m_diag_arg)\n+\t\t  return ev.formatted_print\n+\t\t    (\"read of %qE bytes at offset %qE exceeds %qE\",\n+\t\t     m_num_bytes, m_offset, m_diag_arg);\n+\t\telse\n+\t\t  return ev.formatted_print\n+\t\t    (\"read of %qE bytes at offset %qE exceeds the buffer\",\n+\t\t     m_num_bytes, m_offset);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    /* Known offset, unknown size.  */\n+\t    if (m_diag_arg)\n+\t      return ev.formatted_print (\"read at offset %qE exceeds %qE\",\n+\t\t\t\t\t m_offset, m_diag_arg);\n+\t    else\n+\t      return ev.formatted_print (\"read at offset %qE exceeds the\"\n+\t\t\t\t\t \" buffer\", m_offset);\n+\t  }\n+      }\n+    /* Unknown offset.  */\n+    if (m_diag_arg)\n+      return ev.formatted_print (\"out-of-bounds read on %qE\",\n+\t\t\t\t m_diag_arg);\n+    return ev.formatted_print (\"out-of-bounds read\");\n+  }\n };\n \n /* Check whether an access is past the end of the BASE_REG.  */"}]}