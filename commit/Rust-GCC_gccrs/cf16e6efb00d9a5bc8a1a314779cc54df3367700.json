{"sha": "cf16e6efb00d9a5bc8a1a314779cc54df3367700", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YxNmU2ZWZiMDBkOWE1YmM4YTFhMzE0Nzc5Y2M1NGRmMzM2NzcwMA==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-09-11T19:50:48Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-09-11T19:50:48Z"}, "message": "Remove dead code from graphite-optimize-isl.c\n\nThe variable `static bool enable_polly_vector' is always assigned to false.\nThis results in dead code in optimize-isl.c.  No functional change intended.\n\nPasses bootstrap and regtest.\n\ngcc/ChangeLog:\n\n2015-09-11  Aditya Kumar  <aditya.k7@samsung.com>\n\n\t* graphite-optimize-isl.c (disable_tiling): Remove.\n\t(get_schedule_for_band): Do not use disable_tiling.\n\t(get_prevector_map): Delete function.\n\t(enable_polly_vector): Remove.\n\t(get_schedule_for_band_list): Remove dead code.\n\nFrom-SVN: r227696", "tree": {"sha": "8e7ef3ddfa2dd5035679e8093e2f28f53711fdaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e7ef3ddfa2dd5035679e8093e2f28f53711fdaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf16e6efb00d9a5bc8a1a314779cc54df3367700", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf16e6efb00d9a5bc8a1a314779cc54df3367700", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf16e6efb00d9a5bc8a1a314779cc54df3367700", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf16e6efb00d9a5bc8a1a314779cc54df3367700/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec62c3731d43ad68536a6ce262df34a3f08e36a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec62c3731d43ad68536a6ce262df34a3f08e36a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec62c3731d43ad68536a6ce262df34a3f08e36a3"}], "stats": {"total": 150, "additions": 12, "deletions": 138}, "files": [{"sha": "45f3b151864fa46abbf4165cf23d9fca38d2c94d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16e6efb00d9a5bc8a1a314779cc54df3367700/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16e6efb00d9a5bc8a1a314779cc54df3367700/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf16e6efb00d9a5bc8a1a314779cc54df3367700", "patch": "@@ -1,3 +1,11 @@\n+2015-09-11  Aditya Kumar  <aditya.k7@samsung.com>\n+\n+        * graphite-optimize-isl.c (disable_tiling): Remove.\n+\t(get_schedule_for_band): Do not use disable_tiling.\n+\t(get_prevector_map): Delete function.\n+\t(enable_polly_vector): Remove.\n+        (get_schedule_for_band_list): Remove dead code.\n+\n 2015-09-11  Aditya Kumar  <aditya.k7@samsung.com>\n \n         * graphite-optimize-isl.c (get_tile_map): Refactor."}, {"sha": "bd13978f42d7b3266255fc2712c1b5a19babe28e", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 4, "deletions": 138, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16e6efb00d9a5bc8a1a314779cc54df3367700/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16e6efb00d9a5bc8a1a314779cc54df3367700/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=cf16e6efb00d9a5bc8a1a314779cc54df3367700", "patch": "@@ -50,9 +50,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"dumpfile.h\"\n \n-/* Set this to true to disable tiling of nested loops.  */\n-static bool disable_tiling = false;\n-\n static isl_union_set *\n scop_get_domains (scop_p scop ATTRIBUTE_UNUSED)\n {\n@@ -177,9 +174,6 @@ get_schedule_for_band (isl_band *band, int *dimensions)\n   partial_schedule = isl_band_get_partial_schedule (band);\n   *dimensions = isl_band_n_member (band);\n \n-  if (disable_tiling)\n-    return partial_schedule;\n-\n   /* It does not make any sense to tile a band with just one dimension.  */\n   if (*dimensions == 1)\n     {\n@@ -204,119 +198,13 @@ get_schedule_for_band (isl_band *band, int *dimensions)\n   return isl_union_map_apply_range (partial_schedule, tile_umap);\n }\n \n-/* Create a map that pre-vectorizes one scheduling dimension.\n-\n-   get_prevector_map creates a map that maps each input dimension to the same\n-   output dimension, except for the dimension DIM_TO_VECTORIZE.\n-   DIM_TO_VECTORIZE is\n-   strip mined by 'VECTOR_WIDTH' and the newly created point loop of\n-   DIM_TO_VECTORIZE is moved to the innermost level.\n-\n-   Example (DIM_TO_VECTORIZE=0, SCHEDULE_DIMENSIONS=2,VECTOR_WIDTH=4):\n-\n-   | Before transformation\n-   |\n-   | A[i,j] -> [i,j]\n-   |\n-   | for (i = 0; i < 128; i++)\n-   |    for (j = 0; j < 128; j++)\n-   |      A(i,j);\n-\n-     Prevector map:\n-     [i,j] -> [it,j,ip] : it % 4 = 0 and it <= ip <= it + 3 and i = ip\n-\n-   | After transformation:\n-   |\n-   | A[i,j] -> [it,j,ip] : it % 4 = 0 and it <= ip <= it + 3 and i = ip\n-   |\n-   | for (it = 0; it < 128; it+=4)\n-   |    for (j = 0; j < 128; j++)\n-   |      for (ip = max(0,it); ip < min(128, it + 3); ip++)\n-   |        A(ip,j);\n-\n-   The goal of this transformation is to create a trivially vectorizable loop.\n-   This means a parallel loop at the innermost level that has a constant number\n-   of iterations corresponding to the target vector width.\n-\n-   This transformation creates a loop at the innermost level. The loop has a\n-   constant number of iterations, if the number of loop iterations at\n-   DIM_TO_VECTORIZE can be devided by VECTOR_WIDTH. The default VECTOR_WIDTH is\n-   currently constant and not yet target specific. This function does not\n-   reason about parallelism.  */\n-static isl_map *\n-get_prevector_map (isl_ctx *ctx, int dim_to_vectorize, int schedule_dimensions,\n-\t\t   int vector_width)\n-{\n-  isl_space *space;\n-  isl_local_space *local_space, *local_space_range;\n-  isl_set *modulo;\n-  isl_map *tiling_map;\n-  isl_constraint *c;\n-  isl_aff *aff;\n-  int point_dimension; /* ip */\n-  int tile_dimension;  /* it */\n-  isl_val *vector_widthMP;\n-  int i;\n-\n-  /* assert (0 <= DimToVectorize && DimToVectorize < ScheduleDimensions);*/\n-\n-  space\n-    = isl_space_alloc (ctx, 0, schedule_dimensions, schedule_dimensions + 1);\n-  tiling_map = isl_map_universe (isl_space_copy (space));\n-  local_space = isl_local_space_from_space (space);\n-  point_dimension = schedule_dimensions;\n-  tile_dimension = dim_to_vectorize;\n-\n-  /* Create an identity map for everything except DimToVectorize and map\n-     DimToVectorize to the point loop at the innermost dimension.  */\n-  for (i = 0; i < schedule_dimensions; i++)\n-    {\n-      c = isl_equality_alloc (isl_local_space_copy (local_space));\n-      isl_constraint_set_coefficient_si (c, isl_dim_in, i, -1);\n-\n-      if (i == dim_to_vectorize)\n-\tisl_constraint_set_coefficient_si (c, isl_dim_out, point_dimension, 1);\n-      else\n-\tisl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n-\n-      tiling_map = isl_map_add_constraint (tiling_map, c);\n-    }\n-\n-  /* it % 'VectorWidth' = 0  */\n-  local_space_range\n-    = isl_local_space_range (isl_local_space_copy (local_space));\n-  aff = isl_aff_zero_on_domain (local_space_range);\n-  aff = isl_aff_set_constant_si (aff, vector_width);\n-  aff = isl_aff_set_coefficient_si (aff, isl_dim_in, tile_dimension, 1);\n-\n-  vector_widthMP = isl_val_int_from_si (ctx, vector_width);\n-  aff = isl_aff_mod_val (aff, vector_widthMP);\n-  modulo = isl_pw_aff_zero_set (isl_pw_aff_from_aff (aff));\n-  tiling_map = isl_map_intersect_range (tiling_map, modulo);\n-\n-  /* it <= ip */\n-  c = isl_inequality_alloc (isl_local_space_copy (local_space));\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, tile_dimension, -1);\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, point_dimension, 1);\n-  tiling_map = isl_map_add_constraint (tiling_map, c);\n-\n-  /* ip <= it + ('VectorWidth' - 1) */\n-  c = isl_inequality_alloc (local_space);\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, tile_dimension, 1);\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, point_dimension, -1);\n-  isl_constraint_set_constant_si (c, vector_width - 1);\n-  tiling_map = isl_map_add_constraint (tiling_map, c);\n-\n-  return tiling_map;\n-}\n-\n-static bool enable_polly_vector = false;\n \n /* get_schedule_for_band_list - Get the scheduling map for a list of bands.\n \n    We walk recursively the forest of bands to combine the schedules of the\n    individual bands to the overall schedule.  In case tiling is requested,\n    the individual bands are tiled.  */\n+\n static isl_union_map *\n get_schedule_for_band_list (isl_band_list *band_list)\n {\n@@ -349,31 +237,6 @@ get_schedule_for_band_list (isl_band_list *band_list)\n \t\t\t\t\t\tsuffixSchedule);\n \t  isl_band_list_free (children);\n \t}\n-      else if (enable_polly_vector)\n-\t{\n-\t  for (i = schedule_dimensions - 1; i >= 0; i--)\n-\t    {\n-#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE\n-\t      if (isl_band_member_is_coincident (band, i))\n-#else\n-\t      if (isl_band_member_is_zero_distance (band, i))\n-#endif\n-\t\t{\n-\t\t  /* FIXME: The default VECTOR_WIDTH is currently constant and\n-\t\t   * not yet target specific.  */\n-\t\t  isl_map *tile_map\n-\t\t    = get_prevector_map (ctx, i, schedule_dimensions, 4);\n-\t\t  isl_union_map *tile_umap = isl_union_map_from_map (tile_map);\n-\t\t  tile_umap\n-\t\t    = isl_union_map_align_params (tile_umap,\n-\t\t\t\t\t\t  isl_space_copy (space));\n-\t\t  partial_schedule\n-\t\t    = isl_union_map_apply_range (partial_schedule,\n-\t\t\t\t\t\t tile_umap);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n \n       schedule = isl_union_map_union (schedule, partial_schedule);\n \n@@ -424,6 +287,9 @@ apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map)\n \n static const int CONSTANT_BOUND = 20;\n \n+/* Compute the schedule for SCOP based on its parameters, domain and set of\n+   constraints.  Then apply the schedule to SCOP.  */\n+\n bool\n optimize_isl (scop_p scop)\n {"}]}