{"sha": "686d09844fd59ffdb2d49c1c5da0a46594d06778", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg2ZDA5ODQ0ZmQ1OWZmZGIyZDQ5YzFjNWRhMGE0NjU5NGQwNjc3OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T10:38:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T10:38:26Z"}, "message": "[multiple changes]\n\n2011-08-03  Robert Dewar  <dewar@adacore.com>\n\n\t* gnatcmd.adb, prj-proc.adb, mlib-prj.adb, prj.adb, makeutl.ads,\n\tprj-util.adb, prj-util.ads, prj-conf.adb, prj-env.adb: Minor\n\treformatting.\n\n2011-08-03  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_util.adb (Is_VM_By_Copy_Actual): Include N_Slide nodes as actuals\n\tthat must be passed by copy in VM targets.\n\n2011-08-03  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj.ads, prj-nmsc.adb (Files_Htable): removed this htable, which\n\tduplicates a similar htable now in the project tree.\n\n2011-08-03  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.adb, a-cfhama.adb, a-cfhase.adb, a-cforma.adb, a-cforse.adb,\n\ta-cofove.adb (\"=\", Length, Is_Empty, Clear, Assign, Copy, Element,\n\tReplace_Element, Query_Element, Update_Element, Move, Insert, Prepend,\n\tAppend, Delete, Delete_First, Delete_Last, Reverse_Element, Swap,\n\tSplice, First, First_Element, Last, Last_Element, Next, Previous, Find,\n\tReverse_Find, Contains, Has_Element, Iterate, Reverse_Iterate, Capacity,\n\tReserve_Length, Length, Strict_Equal, Left, Right): Data-structure\n\tupdate.\n\n2011-08-03  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-taprop-posix.adb, s-taprop-linux.adb, s-taprop-tru64.adb\n\t(ATCB_Key): Removed, not always used.\n\t* s-tpopsp-posix.adb, s-tpopsp-posix-foreign.adb (ATCB_Key): Moved from\n\ts-taprop-posix.adb.\n\t* s-tpopsp-tls.adb: New file.\n\t* gcc-interface/Makefile.in: Use TLS implementation of s-tpopsp.adb on\n\tx86/x64/ia64/powerpc/sparc Linux.\n\n2011-08-03  Arnaud Charlet  <charlet@adacore.com>\n\n\t* system-aix.ads, system-aix64.ads: Set ZCX_By_Default to True.\n\t* gcc-interface/Makefile.in: Switch to ZCX by default on AIX ports.\n\n2011-08-03  Thomas Quinot  <quinot@adacore.com>\n\n\t* rtsfind.ads, exp_dist.adb, exp_dist.ads\n\t(Build_From_Any_Call, Build_To_Any_Call, Build_TypeCode_Call):\n\tFix type selection for mapping integer types to PolyORB types.\n\n2011-08-03  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch7.adb: Minor comment clarification.\n\n2011-08-03  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Enumeration_Representation_Clause): If we get\n\tan error analyzing a choice, skip further processing. Further\n\tprocessing could cause a crash or cascade errors.\n\nFrom-SVN: r177262", "tree": {"sha": "fc7be1c9704d0d4e2e74847db194b13f6d7fc48a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc7be1c9704d0d4e2e74847db194b13f6d7fc48a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/686d09844fd59ffdb2d49c1c5da0a46594d06778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686d09844fd59ffdb2d49c1c5da0a46594d06778", "html_url": "https://github.com/Rust-GCC/gccrs/commit/686d09844fd59ffdb2d49c1c5da0a46594d06778", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686d09844fd59ffdb2d49c1c5da0a46594d06778/comments", "author": null, "committer": null, "parents": [{"sha": "40ecf2f5d19ba2b046c65168aa8acc80ad399a08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40ecf2f5d19ba2b046c65168aa8acc80ad399a08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40ecf2f5d19ba2b046c65168aa8acc80ad399a08"}], "stats": {"total": 7286, "additions": 2209, "deletions": 5077}, "files": [{"sha": "763881a98ad1c1e934038aec0ed194a0c1a715d8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -1,3 +1,61 @@\n+2011-08-03  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnatcmd.adb, prj-proc.adb, mlib-prj.adb, prj.adb, makeutl.ads,\n+\tprj-util.adb, prj-util.ads, prj-conf.adb, prj-env.adb: Minor\n+\treformatting.\n+\n+2011-08-03  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_util.adb (Is_VM_By_Copy_Actual): Include N_Slide nodes as actuals\n+\tthat must be passed by copy in VM targets.\n+\n+2011-08-03  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj.ads, prj-nmsc.adb (Files_Htable): removed this htable, which\n+\tduplicates a similar htable now in the project tree.\n+\n+2011-08-03  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.adb, a-cfhama.adb, a-cfhase.adb, a-cforma.adb, a-cforse.adb,\n+\ta-cofove.adb (\"=\", Length, Is_Empty, Clear, Assign, Copy, Element,\n+\tReplace_Element, Query_Element, Update_Element, Move, Insert, Prepend,\n+\tAppend, Delete, Delete_First, Delete_Last, Reverse_Element, Swap,\n+\tSplice, First, First_Element, Last, Last_Element, Next, Previous, Find,\n+\tReverse_Find, Contains, Has_Element, Iterate, Reverse_Iterate, Capacity,\n+\tReserve_Length, Length, Strict_Equal, Left, Right): Data-structure\n+\tupdate.\n+\n+2011-08-03  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-taprop-posix.adb, s-taprop-linux.adb, s-taprop-tru64.adb\n+\t(ATCB_Key): Removed, not always used.\n+\t* s-tpopsp-posix.adb, s-tpopsp-posix-foreign.adb (ATCB_Key): Moved from\n+\ts-taprop-posix.adb.\n+\t* s-tpopsp-tls.adb: New file.\n+\t* gcc-interface/Makefile.in: Use TLS implementation of s-tpopsp.adb on\n+\tx86/x64/ia64/powerpc/sparc Linux.\n+\n+2011-08-03  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* system-aix.ads, system-aix64.ads: Set ZCX_By_Default to True.\n+\t* gcc-interface/Makefile.in: Switch to ZCX by default on AIX ports.\n+\n+2011-08-03  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* rtsfind.ads, exp_dist.adb, exp_dist.ads\n+\t(Build_From_Any_Call, Build_To_Any_Call, Build_TypeCode_Call):\n+\tFix type selection for mapping integer types to PolyORB types.\n+\n+2011-08-03  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch7.adb: Minor comment clarification.\n+\n+2011-08-03  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Enumeration_Representation_Clause): If we get\n+\tan error analyzing a choice, skip further processing. Further\n+\tprocessing could cause a crash or cascade errors.\n+\n 2011-08-03  Emmanuel Briot  <briot@adacore.com>\n \n \t* gnatcmd.adb, prj-proc.adb, prj-proc.ads, make.adb, mlib-prj.adb,"}, {"sha": "d72566a03e1be76ed5603c13100d2509294b4fef", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 666, "deletions": 1105, "changes": 1771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--          Copyright (C) 2010-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,71 +42,17 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n      (Container : in out List;\n       New_Node  : out Count_Type);\n \n-   function Copy\n-     (Source   : Plain_List;\n-      Capacity : Count_Type := 0) return PList_Access;\n-\n-   function Find_Between\n-     (Container : Plain_List;\n-      Item      : Element_Type;\n-      From      : Count_Type;\n-      To        : Count_Type;\n-      Bg        : Count_Type) return Cursor;\n-\n-   function Element_Unchecked\n-     (Container : List;\n-      Position  : Count_Type) return Element_Type;\n-\n    procedure Free\n-     (Container : in out Plain_List;\n+     (Container : in out List;\n       X         : Count_Type);\n \n-   function Has_Element_Base\n-     (Container : Plain_List;\n-      Position  : Cursor) return Boolean;\n-\n    procedure Insert_Internal\n      (Container : in out List;\n       Before    : Count_Type;\n       New_Node  : Count_Type);\n \n-   procedure Iterate_Between\n-     (Container : List;\n-      From      : Count_Type;\n-      To        : Count_Type;\n-      Process   :\n-        not null access procedure (Container : List; Position : Cursor));\n-\n-   function Next_Unchecked\n-     (Container : List;\n-      Position  : Count_Type) return Count_Type;\n-\n-   procedure Query_Element_Plain\n-     (Container : Plain_List; Position : Cursor;\n-      Process   : not null access procedure (Element : Element_Type));\n-\n-   function Reverse_Find_Between\n-     (Container : Plain_List;\n-      Item      : Element_Type;\n-      From      : Count_Type;\n-      To        : Count_Type) return Cursor;\n-\n-   procedure Reverse_Iterate_Between\n-     (Container : List;\n-      From      : Count_Type;\n-      To        : Count_Type;\n-      Process   :\n-        not null access procedure (Container : List; Position : Cursor));\n-\n    function Vet (L : List; Position : Cursor) return Boolean;\n \n-   procedure Write_Between\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Plain_List;\n-      Length : Count_Type;\n-      From   : Count_Type;\n-      To     : Count_Type);\n-\n    ---------\n    -- \"=\" --\n    ---------\n@@ -124,14 +70,14 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       end if;\n \n       LI := Left.First;\n-      RI := Right.First;\n+      RI := Left.First;\n       while LI /= 0 loop\n-         if Element_Unchecked (Left, LI) /= Element_Unchecked (Right, LI) then\n+         if Left.Nodes (LI).Element /= Right.Nodes (LI).Element then\n             return False;\n          end if;\n \n-         LI := Next_Unchecked (Left, LI);\n-         RI := Next_Unchecked (Right, RI);\n+         LI := Left.Nodes (LI).Next;\n+         RI := Right.Nodes (RI).Next;\n       end loop;\n \n       return True;\n@@ -146,52 +92,36 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       New_Item  : Element_Type;\n       New_Node  : out Count_Type)\n    is\n-      ContainerP : Plain_List renames Container.Plain.all;\n-   begin\n-      if Container.K /= Plain then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n-\n-      declare\n-         N : Node_Array renames Container.Plain.all.Nodes;\n+      N : Node_Array renames Container.Nodes;\n \n-      begin\n-         if ContainerP.Free >= 0 then\n-            New_Node := ContainerP.Free;\n-            N (New_Node).Element := New_Item;\n-            ContainerP.Free := N (New_Node).Next;\n+   begin\n+      if Container.Free >= 0 then\n+         New_Node := Container.Free;\n+         N (New_Node).Element := New_Item;\n+         Container.Free := N (New_Node).Next;\n \n-         else\n-            New_Node := abs ContainerP.Free;\n-            N (New_Node).Element := New_Item;\n-            ContainerP.Free := ContainerP.Free - 1;\n-         end if;\n-      end;\n+      else\n+         New_Node := abs Container.Free;\n+         N (New_Node).Element := New_Item;\n+         Container.Free := Container.Free - 1;\n+      end if;\n    end Allocate;\n \n    procedure Allocate\n      (Container : in out List;\n       New_Node  : out Count_Type)\n    is\n-      ContainerP : Plain_List renames Container.Plain.all;\n-   begin\n-      if Container.K /= Plain then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n-\n-      declare\n-         N : Node_Array renames ContainerP.Nodes;\n+      N : Node_Array renames Container.Nodes;\n \n-      begin\n-         if ContainerP.Free >= 0 then\n-            New_Node := ContainerP.Free;\n-            ContainerP.Free := N (New_Node).Next;\n+   begin\n+      if Container.Free >= 0 then\n+         New_Node := Container.Free;\n+         Container.Free := N (New_Node).Next;\n \n-         else\n-            New_Node := abs ContainerP.Free;\n-            ContainerP.Free := ContainerP.Free - 1;\n-         end if;\n-      end;\n+      else\n+         New_Node := abs Container.Free;\n+         Container.Free := Container.Free - 1;\n+      end if;\n    end Allocate;\n \n    ------------\n@@ -212,87 +142,73 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    ------------\n \n    procedure Assign (Target : in out List; Source : List) is\n+      N : Node_Array renames Source.Nodes;\n+      J : Count_Type;\n+\n    begin\n-      if Target.K /= Plain or Source.K /= Plain then\n-         raise Program_Error with \"cannot modify part of container\";\n+      if Target'Address = Source'Address then\n+         return;\n       end if;\n \n-      declare\n-         N : Node_Array renames Source.Plain.Nodes;\n-         J : Count_Type;\n-\n-      begin\n-         if Target'Address = Source'Address then\n-            return;\n-         end if;\n-\n-         if Target.Capacity < Source.Length then\n-            raise Constraint_Error with  -- ???\n-              \"Source length exceeds Target capacity\";\n-         end if;\n+      if Target.Capacity < Source.Length then\n+         raise Constraint_Error with  -- ???\n+           \"Source length exceeds Target capacity\";\n+      end if;\n \n-         Clear (Target);\n+      Clear (Target);\n \n-         J := Source.First;\n-         while J /= 0 loop\n-            Append (Target, N (J).Element);\n-            J := N (J).Next;\n-         end loop;\n-      end;\n+      J := Source.First;\n+      while J /= 0 loop\n+         Append (Target, N (J).Element);\n+         J := N (J).Next;\n+      end loop;\n    end Assign;\n \n    -----------\n    -- Clear --\n    -----------\n \n    procedure Clear (Container : in out List) is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error;\n+      if Container.Length = 0 then\n+         pragma Assert (Container.First = 0);\n+         pragma Assert (Container.Last = 0);\n+         pragma Assert (Container.Busy = 0);\n+         pragma Assert (Container.Lock = 0);\n+         return;\n       end if;\n \n-      declare\n-         N : Node_Array renames Container.Plain.Nodes;\n-         X : Count_Type;\n-\n-      begin\n-         if Container.Length = 0 then\n-            pragma Assert (Container.First = 0);\n-            pragma Assert (Container.Last = 0);\n-            pragma Assert (Container.Plain.Busy = 0);\n-            pragma Assert (Container.Plain.Lock = 0);\n-            return;\n-         end if;\n-\n-         pragma Assert (Container.First >= 1);\n-         pragma Assert (Container.Last >= 1);\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n+      pragma Assert (Container.First >= 1);\n+      pragma Assert (Container.Last >= 1);\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n \n-         if Container.Plain.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (list is busy)\";\n-         end if;\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n+      end if;\n \n-         while Container.Length > 1 loop\n-            X := Container.First;\n+      while Container.Length > 1 loop\n+         X := Container.First;\n \n-            Container.First := N (X).Next;\n-            N (Container.First).Prev := 0;\n+         Container.First := N (X).Next;\n+         N (Container.First).Prev := 0;\n \n-            Container.Length := Container.Length - 1;\n+         Container.Length := Container.Length - 1;\n \n-            Free (Container.Plain.all, X);\n-         end loop;\n+         Free (Container, X);\n+      end loop;\n \n-         X := Container.First;\n+      X := Container.First;\n \n-         Container.First := 0;\n-         Container.Last := 0;\n-         Container.Length := 0;\n+      Container.First := 0;\n+      Container.Last := 0;\n+      Container.Length := 0;\n \n-         Free (Container.Plain.all, X);\n-      end;\n+      Free (Container, X);\n    end Clear;\n \n    --------------\n@@ -312,76 +228,33 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    ----------\n \n    function Copy\n-     (Source   : Plain_List;\n-      Capacity : Count_Type := 0) return PList_Access\n+     (Source   : List;\n+      Capacity : Count_Type := 0) return List\n    is\n       C : constant Count_Type := Count_Type'Max (Source.Capacity, Capacity);\n-      P : PList_Access;\n       N : Count_Type := 1;\n+      P : List (C);\n    begin\n-      P := new Plain_List (C);\n       while N <= Source.Capacity loop\n          P.Nodes (N).Prev := Source.Nodes (N).Prev;\n          P.Nodes (N).Next := Source.Nodes (N).Next;\n          P.Nodes (N).Element := Source.Nodes (N).Element;\n          N := N + 1;\n       end loop;\n       P.Free := Source.Free;\n+      P.Length := Source.Length;\n+      P.First := Source.First;\n+      P.Last := Source.Last;\n       if P.Free >= 0 then\n          N := Source.Capacity + 1;\n          while N <= C loop\n-            Free (P.all, N);\n+            Free (P, N);\n             N := N + 1;\n          end loop;\n       end if;\n       return P;\n    end Copy;\n \n-   function Copy\n-     (Source   : List;\n-      Capacity : Count_Type := 0) return List\n-   is\n-      Cap : constant Count_Type := Count_Type'Max (Source.Capacity, Capacity);\n-   begin\n-      case Source.K is\n-         when Plain =>\n-            return (Capacity => Cap,\n-                    Length   => Source.Length,\n-                    Plain    => Copy (Source.Plain.all, Cap),\n-                    First    => Source.First,\n-                    Last     => Source.Last,\n-                    others   => <>);\n-         when Part =>\n-            declare\n-               Target : List (Capacity => Cap);\n-               C      : Cursor;\n-               P      : Cursor;\n-            begin\n-               Target := (Capacity => Cap,\n-                          Length   => Source.Part.LLength,\n-                          Plain    => Copy (Source.Plain.all, Cap),\n-                          First    => Source.Part.LFirst,\n-                          Last     => Source.Part.LLast,\n-                          others   => <>);\n-               C := (Node => Target.First);\n-               while C.Node /= Source.First loop\n-                  P := Next (Target, C);\n-                  Delete (Container => Target, Position => C);\n-                  C := P;\n-               end loop;\n-               if Source.Last /= 0 then\n-                  C := (Node => Source.Plain.all.Nodes (Source.Last).Next);\n-                  while C.Node /= 0 loop\n-                     P := Next (Target, C);\n-                     Delete (Container => Target, Position => C);\n-                     C := P;\n-                  end loop;\n-               end if;\n-               return Target;\n-            end;\n-      end case;\n-   end Copy;\n-\n    ------------\n    -- Delete --\n    ------------\n@@ -391,70 +264,63 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       Position  : in out Cursor;\n       Count     : Count_Type := 1)\n    is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n    begin\n-      if Container.K /= Plain then\n-         raise Program_Error with \"cannot modify part of container\";\n+      if not Has_Element (Container => Container,\n+                          Position  => Position) then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n-      declare\n-         N : Node_Array renames Container.Plain.Nodes;\n-         X : Count_Type;\n-\n-      begin\n-         if not Has_Element (Container => Container,\n-                             Position  => Position) then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-\n-         pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n-         pragma Assert (Container.First >= 1);\n-         pragma Assert (Container.Last >= 1);\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n+      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n+      pragma Assert (Container.First >= 1);\n+      pragma Assert (Container.Last >= 1);\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n \n-         if Position.Node = Container.First then\n-            Delete_First (Container, Count);\n-            Position := No_Element;\n-            return;\n-         end if;\n+      if Position.Node = Container.First then\n+         Delete_First (Container, Count);\n+         Position := No_Element;\n+         return;\n+      end if;\n \n-         if Count = 0 then\n-            Position := No_Element;\n-            return;\n-         end if;\n+      if Count = 0 then\n+         Position := No_Element;\n+         return;\n+      end if;\n \n-         if Container.Plain.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (list is busy)\";\n-         end if;\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n+      end if;\n \n-         for Index in 1 .. Count loop\n-            pragma Assert (Container.Length >= 2);\n+      for Index in 1 .. Count loop\n+         pragma Assert (Container.Length >= 2);\n \n-            X := Position.Node;\n-            Container.Length := Container.Length - 1;\n+         X := Position.Node;\n+         Container.Length := Container.Length - 1;\n \n-            if X = Container.Last then\n-               Position := No_Element;\n+         if X = Container.Last then\n+            Position := No_Element;\n \n-               Container.Last := N (X).Prev;\n-               N (Container.Last).Next := 0;\n+            Container.Last := N (X).Prev;\n+            N (Container.Last).Next := 0;\n \n-               Free (Container.Plain.all, X);\n-               return;\n-            end if;\n+            Free (Container, X);\n+            return;\n+         end if;\n \n-            Position.Node := N (X).Next;\n-            pragma Assert (N (Position.Node).Prev >= 0);\n+         Position.Node := N (X).Next;\n+         pragma Assert (N (Position.Node).Prev >= 0);\n \n-            N (N (X).Next).Prev := N (X).Prev;\n-            N (N (X).Prev).Next := N (X).Next;\n+         N (N (X).Next).Prev := N (X).Prev;\n+         N (N (X).Prev).Next := N (X).Next;\n \n-            Free (Container.Plain.all, X);\n-         end loop;\n-         Position := No_Element;\n-      end;\n+         Free (Container, X);\n+      end loop;\n+      Position := No_Element;\n    end Delete;\n \n    ------------------\n@@ -465,42 +331,35 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n      (Container : in out List;\n       Count     : Count_Type := 1)\n    is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n    begin\n-      if Container.K /= Plain then\n-         raise Program_Error with \"cannot modify part of container\";\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n       end if;\n \n-      declare\n-         N : Node_Array renames Container.Plain.Nodes;\n-         X : Count_Type;\n-\n-      begin\n-         if Count >= Container.Length then\n-            Clear (Container);\n-            return;\n-         end if;\n-\n-         if Count = 0 then\n-            return;\n-         end if;\n+      if Count = 0 then\n+         return;\n+      end if;\n \n-         if Container.Plain.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (list is busy)\";\n-         end if;\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n+      end if;\n \n-         for I in 1 .. Count loop\n-            X := Container.First;\n-            pragma Assert (N (N (X).Next).Prev = Container.First);\n+      for I in 1 .. Count loop\n+         X := Container.First;\n+         pragma Assert (N (N (X).Next).Prev = Container.First);\n \n-            Container.First := N (X).Next;\n-            N (Container.First).Prev := 0;\n+         Container.First := N (X).Next;\n+         N (Container.First).Prev := 0;\n \n-            Container.Length := Container.Length - 1;\n+         Container.Length := Container.Length - 1;\n \n-            Free (Container.Plain.all, X);\n-         end loop;\n-      end;\n+         Free (Container, X);\n+      end loop;\n    end Delete_First;\n \n    -----------------\n@@ -511,60 +370,41 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n      (Container : in out List;\n       Count     : Count_Type := 1)\n    is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n    begin\n-      if Container.K /= Plain then\n-         raise Program_Error with \"cannot modify part of container\";\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n       end if;\n \n-      declare\n-         N : Node_Array renames Container.Plain.Nodes;\n-         X : Count_Type;\n-\n-      begin\n-         if Count >= Container.Length then\n-            Clear (Container);\n-            return;\n-         end if;\n-\n-         if Count = 0 then\n-            return;\n-         end if;\n+      if Count = 0 then\n+         return;\n+      end if;\n \n-         if Container.Plain.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (list is busy)\";\n-         end if;\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n+      end if;\n \n-         for I in 1 .. Count loop\n-            X := Container.Last;\n-            pragma Assert (N (N (X).Prev).Next = Container.Last);\n+      for I in 1 .. Count loop\n+         X := Container.Last;\n+         pragma Assert (N (N (X).Prev).Next = Container.Last);\n \n-            Container.Last := N (X).Prev;\n-            N (Container.Last).Next := 0;\n+         Container.Last := N (X).Prev;\n+         N (Container.Last).Next := 0;\n \n-            Container.Length := Container.Length - 1;\n+         Container.Length := Container.Length - 1;\n \n-            Free (Container.Plain.all, X);\n-         end loop;\n-      end;\n+         Free (Container, X);\n+      end loop;\n    end Delete_Last;\n \n    -------------\n    -- Element --\n    -------------\n \n-   function Element_Unchecked\n-     (Container : List;\n-      Position  : Count_Type) return Element_Type is\n-   begin\n-      case Container.K is\n-         when Plain =>\n-            return Container.Plain.Nodes (Position).Element;\n-         when others =>\n-            return Container.Plain.all.Nodes (Position).Element;\n-      end case;\n-   end Element_Unchecked;\n-\n    function Element\n      (Container : List;\n       Position  : Cursor) return Element_Type is\n@@ -574,41 +414,13 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n            \"Position cursor has no element\";\n       end if;\n \n-      return Element_Unchecked (Container => Container,\n-                                Position  => Position.Node);\n+      return Container.Nodes (Position.Node).Element;\n    end Element;\n \n    ----------\n    -- Find --\n    ----------\n \n-   function Find_Between\n-     (Container : Plain_List;\n-      Item      : Element_Type;\n-      From      : Count_Type;\n-      To        : Count_Type;\n-      Bg        : Count_Type) return Cursor\n-   is\n-      Nodes : Node_Array renames Container.Nodes;\n-      Node  : Count_Type := Bg;\n-   begin\n-      while Node /= From loop\n-         if Node = 0 or else Node = To then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-         Node := Nodes (Node).Next;\n-      end loop;\n-      while Node /= Nodes (To).Next loop\n-         if Nodes (Node).Element = Item then\n-            return (Node => Node);\n-         end if;\n-         Node := Nodes (Node).Next;\n-      end loop;\n-\n-      return No_Element;\n-   end Find_Between;\n-\n    function Find\n      (Container : List;\n       Item      : Element_Type;\n@@ -623,15 +435,19 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          From := Container.First;\n       end if;\n       if Position.Node /= 0 and then\n-        not Has_Element_Base (Container.Plain.all, Position) then\n+        not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n-      return Find_Between (Container => Container.Plain.all,\n-                           Item      => Item,\n-                           From      => From,\n-                           To        => Container.Last,\n-                           Bg        => Container.First);\n+\n+      while From /= 0 loop\n+         if Container.Nodes (From).Element = Item then\n+            return (Node => From);\n+         end if;\n+         From := Container.Nodes (From).Next;\n+      end loop;\n+\n+      return No_Element;\n    end Find;\n \n    -----------\n@@ -656,7 +472,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if F = 0 then\n          raise Constraint_Error with \"list is empty\";\n       else\n-         return Element_Unchecked (Container, F);\n+         return Container.Nodes (F).Element;\n       end if;\n    end First_Element;\n \n@@ -665,7 +481,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    ----------\n \n    procedure Free\n-     (Container : in out Plain_List;\n+     (Container : in out List;\n       X         : Count_Type)\n    is\n       pragma Assert (X > 0);\n@@ -714,7 +530,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       ---------------\n \n       function Is_Sorted (Container : List) return Boolean is\n-         Nodes : Node_Array renames Container.Plain.all.Nodes;\n+         Nodes : Node_Array renames Container.Nodes;\n          Node  : Count_Type := Container.First;\n       begin\n          for I in 2 .. Container.Length loop\n@@ -736,164 +552,150 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n         (Target : in out List;\n          Source : in out List)\n       is\n+         LN : Node_Array renames Target.Nodes;\n+         RN : Node_Array renames Source.Nodes;\n+         LI : Cursor;\n+         RI : Cursor;\n+\n       begin\n-         if Target.K /= Plain or Source.K /= Plain then\n-            raise Program_Error with \"cannot modify part of container\";\n+         if Target'Address = Source'Address then\n+            return;\n          end if;\n \n-         declare\n-            LN : Node_Array renames Target.Plain.Nodes;\n-            RN : Node_Array renames Source.Plain.Nodes;\n-            LI : Cursor;\n-            RI : Cursor;\n+         if Target.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors of Target (list is busy)\";\n+         end if;\n \n-         begin\n-            if Target'Address = Source'Address then\n-               return;\n-            end if;\n+         if Source.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors of Source (list is busy)\";\n+         end if;\n \n-            if Target.Plain.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors of Target (list is busy)\";\n-            end if;\n+         LI := First (Target);\n+         RI := First (Source);\n+         while RI.Node /= 0 loop\n+            pragma Assert (RN (RI.Node).Next = 0\n+              or else not (RN (RN (RI.Node).Next).Element <\n+                  RN (RI.Node).Element));\n \n-            if Source.Plain.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors of Source (list is busy)\";\n+            if LI.Node = 0 then\n+               Splice (Target, No_Element, Source);\n+               return;\n             end if;\n \n-            LI := First (Target);\n-            RI := First (Source);\n-            while RI.Node /= 0 loop\n-               pragma Assert (RN (RI.Node).Next = 0\n-                 or else not (RN (RN (RI.Node).Next).Element <\n-                     RN (RI.Node).Element));\n-\n-               if LI.Node = 0 then\n-                  Splice (Target, No_Element, Source);\n-                  return;\n-               end if;\n-\n-               pragma Assert (LN (LI.Node).Next = 0\n-                 or else not (LN (LN (LI.Node).Next).Element <\n-                     LN (LI.Node).Element));\n+            pragma Assert (LN (LI.Node).Next = 0\n+              or else not (LN (LN (LI.Node).Next).Element <\n+                  LN (LI.Node).Element));\n \n-               if RN (RI.Node).Element < LN (LI.Node).Element then\n-                  declare\n-                     RJ : Cursor := RI;\n-                     pragma Warnings (Off, RJ);\n-                  begin\n-                     RI.Node := RN (RI.Node).Next;\n-                     Splice (Target, LI, Source, RJ);\n-                  end;\n+            if RN (RI.Node).Element < LN (LI.Node).Element then\n+               declare\n+                  RJ : Cursor := RI;\n+                  pragma Warnings (Off, RJ);\n+               begin\n+                  RI.Node := RN (RI.Node).Next;\n+                  Splice (Target, LI, Source, RJ);\n+               end;\n \n-               else\n-                  LI.Node := LN (LI.Node).Next;\n-               end if;\n-            end loop;\n-         end;\n+            else\n+               LI.Node := LN (LI.Node).Next;\n+            end if;\n+         end loop;\n       end Merge;\n \n       ----------\n       -- Sort --\n       ----------\n \n       procedure Sort (Container : in out List) is\n-      begin\n-         if Container.K /= Plain then\n-            raise Program_Error with \"cannot modify part of container\";\n-         end if;\n-\n-         declare\n-            N : Node_Array renames Container.Plain.Nodes;\n-\n-            procedure Partition (Pivot, Back : Count_Type);\n-            procedure Sort (Front, Back : Count_Type);\n+         N : Node_Array renames Container.Nodes;\n \n-            ---------------\n-            -- Partition --\n-            ---------------\n+         procedure Partition (Pivot, Back : Count_Type);\n+         procedure Sort (Front, Back : Count_Type);\n \n-            procedure Partition (Pivot, Back : Count_Type) is\n-               Node : Count_Type := N (Pivot).Next;\n+         ---------------\n+         -- Partition --\n+         ---------------\n \n-            begin\n-               while Node /= Back loop\n-                  if N (Node).Element < N (Pivot).Element then\n-                     declare\n-                        Prev : constant Count_Type := N (Node).Prev;\n-                        Next : constant Count_Type := N (Node).Next;\n+         procedure Partition (Pivot, Back : Count_Type) is\n+            Node : Count_Type := N (Pivot).Next;\n \n-                     begin\n-                        N (Prev).Next := Next;\n-\n-                        if Next = 0 then\n-                           Container.Last := Prev;\n-                        else\n-                           N (Next).Prev := Prev;\n-                        end if;\n-\n-                        N (Node).Next := Pivot;\n-                        N (Node).Prev := N (Pivot).Prev;\n+         begin\n+            while Node /= Back loop\n+               if N (Node).Element < N (Pivot).Element then\n+                  declare\n+                     Prev : constant Count_Type := N (Node).Prev;\n+                     Next : constant Count_Type := N (Node).Next;\n \n-                        N (Pivot).Prev := Node;\n+                  begin\n+                     N (Prev).Next := Next;\n \n-                        if N (Node).Prev = 0 then\n-                           Container.First := Node;\n-                        else\n-                           N (N (Node).Prev).Next := Node;\n-                        end if;\n+                     if Next = 0 then\n+                        Container.Last := Prev;\n+                     else\n+                        N (Next).Prev := Prev;\n+                     end if;\n \n-                        Node := Next;\n-                     end;\n+                     N (Node).Next := Pivot;\n+                     N (Node).Prev := N (Pivot).Prev;\n \n-                  else\n-                     Node := N (Node).Next;\n-                  end if;\n-               end loop;\n-            end Partition;\n+                     N (Pivot).Prev := Node;\n \n-            ----------\n-            -- Sort --\n-            ----------\n+                     if N (Node).Prev = 0 then\n+                        Container.First := Node;\n+                     else\n+                        N (N (Node).Prev).Next := Node;\n+                     end if;\n \n-            procedure Sort (Front, Back : Count_Type) is\n-               Pivot : Count_Type;\n+                     Node := Next;\n+                  end;\n \n-            begin\n-               if Front = 0 then\n-                  Pivot := Container.First;\n                else\n-                  Pivot := N (Front).Next;\n+                  Node := N (Node).Next;\n                end if;\n+            end loop;\n+         end Partition;\n \n-               if Pivot /= Back then\n-                  Partition (Pivot, Back);\n-                  Sort (Front, Pivot);\n-                  Sort (Pivot, Back);\n-               end if;\n-            end Sort;\n+         ----------\n+         -- Sort --\n+         ----------\n \n-            --  Start of processing for Sort\n+         procedure Sort (Front, Back : Count_Type) is\n+            Pivot : Count_Type;\n \n          begin\n-            if Container.Length <= 1 then\n-               return;\n+            if Front = 0 then\n+               Pivot := Container.First;\n+            else\n+               Pivot := N (Front).Next;\n             end if;\n \n-            pragma Assert (N (Container.First).Prev = 0);\n-            pragma Assert (N (Container.Last).Next = 0);\n-\n-            if Container.Plain.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with elements (list is busy)\";\n+            if Pivot /= Back then\n+               Partition (Pivot, Back);\n+               Sort (Front, Pivot);\n+               Sort (Pivot, Back);\n             end if;\n+         end Sort;\n \n-            Sort (Front => 0, Back => 0);\n+         --  Start of processing for Sort\n \n-            pragma Assert (N (Container.First).Prev = 0);\n-            pragma Assert (N (Container.Last).Next = 0);\n-         end;\n+      begin\n+         if Container.Length <= 1 then\n+            return;\n+         end if;\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         if Container.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n+         end if;\n+\n+         Sort (Front => 0, Back => 0);\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n       end Sort;\n \n    end Generic_Sorting;\n@@ -902,38 +704,12 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    -- Has_Element --\n    -----------------\n \n-   function Has_Element_Base (Container : Plain_List; Position : Cursor)\n-                              return Boolean\n-   is\n-   begin\n-      return Container.Nodes (Position.Node).Prev /= -1;\n-   end Has_Element_Base;\n-\n    function Has_Element (Container : List; Position : Cursor) return Boolean is\n    begin\n       if Position.Node = 0 then\n          return False;\n       end if;\n-\n-      case Container.K is\n-         when Plain =>\n-            return Container.Plain.Nodes (Position.Node).Prev /= -1;\n-         when Part =>\n-            declare\n-               Current : Count_Type := Container.First;\n-            begin\n-               if Container.Plain.Nodes (Position.Node).Prev = -1 then\n-                  return False;\n-               end if;\n-               while Current /= 0 loop\n-                  if Current = Position.Node then\n-                     return True;\n-                  end if;\n-                  Current := Next_Unchecked (Container, Current);\n-               end loop;\n-               return False;\n-            end;\n-      end case;\n+      return Container.Nodes (Position.Node).Prev /= -1;\n    end Has_Element;\n \n    ------------\n@@ -951,10 +727,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n-\n       if Before.Node /= 0 then\n          null;\n          pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n@@ -969,7 +741,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          raise Constraint_Error with \"new length exceeds capacity\";\n       end if;\n \n-      if Container.Plain.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (list is busy)\";\n       end if;\n@@ -1006,10 +778,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n-\n       if Before.Node /= 0 then\n          null;\n          pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n@@ -1024,7 +792,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          raise Constraint_Error with \"new length exceeds capacity\";\n       end if;\n \n-      if Container.Plain.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (list is busy)\";\n       end if;\n@@ -1048,57 +816,50 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       Before    : Count_Type;\n       New_Node  : Count_Type)\n    is\n-   begin\n-      if Container.K /= Plain then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n-\n-      declare\n-         N : Node_Array renames Container.Plain.Nodes;\n+      N : Node_Array renames Container.Nodes;\n \n-      begin\n-         if Container.Length = 0 then\n-            pragma Assert (Before = 0);\n-            pragma Assert (Container.First = 0);\n-            pragma Assert (Container.Last = 0);\n+   begin\n+      if Container.Length = 0 then\n+         pragma Assert (Before = 0);\n+         pragma Assert (Container.First = 0);\n+         pragma Assert (Container.Last = 0);\n \n-            Container.First := New_Node;\n-            Container.Last := New_Node;\n+         Container.First := New_Node;\n+         Container.Last := New_Node;\n \n-            N (Container.First).Prev := 0;\n-            N (Container.Last).Next := 0;\n+         N (Container.First).Prev := 0;\n+         N (Container.Last).Next := 0;\n \n-         elsif Before = 0 then\n-            pragma Assert (N (Container.Last).Next = 0);\n+      elsif Before = 0 then\n+         pragma Assert (N (Container.Last).Next = 0);\n \n-            N (Container.Last).Next := New_Node;\n-            N (New_Node).Prev := Container.Last;\n+         N (Container.Last).Next := New_Node;\n+         N (New_Node).Prev := Container.Last;\n \n-            Container.Last := New_Node;\n-            N (Container.Last).Next := 0;\n+         Container.Last := New_Node;\n+         N (Container.Last).Next := 0;\n \n-         elsif Before = Container.First then\n-            pragma Assert (N (Container.First).Prev = 0);\n+      elsif Before = Container.First then\n+         pragma Assert (N (Container.First).Prev = 0);\n \n-            N (Container.First).Prev := New_Node;\n-            N (New_Node).Next := Container.First;\n+         N (Container.First).Prev := New_Node;\n+         N (New_Node).Next := Container.First;\n \n-            Container.First := New_Node;\n-            N (Container.First).Prev := 0;\n+         Container.First := New_Node;\n+         N (Container.First).Prev := 0;\n \n-         else\n-            pragma Assert (N (Container.First).Prev = 0);\n-            pragma Assert (N (Container.Last).Next = 0);\n+      else\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n \n-            N (New_Node).Next := Before;\n-            N (New_Node).Prev := N (Before).Prev;\n+         N (New_Node).Next := Before;\n+         N (New_Node).Prev := N (Before).Prev;\n \n-            N (N (Before).Prev).Next := New_Node;\n-            N (Before).Prev := New_Node;\n-         end if;\n+         N (N (Before).Prev).Next := New_Node;\n+         N (Before).Prev := New_Node;\n+      end if;\n \n-         Container.Length := Container.Length + 1;\n-      end;\n+      Container.Length := Container.Length + 1;\n    end Insert_Internal;\n \n    --------------\n@@ -1114,27 +875,23 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    -- Iterate --\n    -------------\n \n-   procedure Iterate_Between\n+   procedure Iterate\n      (Container : List;\n-      From      : Count_Type;\n-      To        : Count_Type;\n       Process   :\n-        not null access procedure (Container : List; Position : Cursor))\n+      not null access procedure (Container : List; Position : Cursor))\n    is\n-      C : Plain_List renames Container.Plain.all;\n-      N : Node_Array renames C.Nodes;\n+      C : List renames Container'Unrestricted_Access.all;\n       B : Natural renames C.Busy;\n \n-      Node : Count_Type := From;\n+      Node : Count_Type := Container.First;\n \n    begin\n       B := B + 1;\n \n       begin\n-         while Node /= N (To).Next loop\n-            pragma Assert (N (Node).Prev >= 0);\n-            Process (Container, Position => (Node => Node));\n-            Node := N (Node).Next;\n+         while Node /= 0 loop\n+            Process (Container, (Node => Node));\n+            Node := Container.Nodes (Node).Next;\n          end loop;\n       exception\n          when others =>\n@@ -1143,18 +900,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       end;\n \n       B := B - 1;\n-   end Iterate_Between;\n-\n-   procedure Iterate\n-     (Container : List;\n-      Process   :\n-        not null access procedure (Container : List; Position : Cursor))\n-   is\n-   begin\n-      if Container.Length = 0 then\n-         return;\n-      end if;\n-      Iterate_Between (Container, Container.First, Container.Last, Process);\n    end Iterate;\n \n    ----------\n@@ -1179,7 +924,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if L = 0 then\n          raise Constraint_Error with \"list is empty\";\n       else\n-         return Element_Unchecked (Container, L);\n+         return Container.Nodes (L).Element;\n       end if;\n    end Last_Element;\n \n@@ -1188,57 +933,23 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    ----------\n \n    function Left (Container : List; Position : Cursor) return List is\n-      L   : Count_Type := 0;\n-      C   : Count_Type := Container.First;\n-      LLe : Count_Type;\n-      LF  : Count_Type;\n-      LLa : Count_Type;\n+      Curs : Cursor := Position;\n+      C : List (Container.Capacity) := Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n    begin\n-      case Container.K is\n-         when Plain =>\n-            LLe := Container.Length;\n-            LF := Container.First;\n-            LLa := Container.Last;\n-         when Part =>\n-            LLe := Container.Part.LLength;\n-            LF := Container.Part.LFirst;\n-            LLa := Container.Part.LLast;\n-      end case;\n-      if Position.Node = 0 then\n-         return (Capacity => Container.Capacity,\n-                 K        => Part,\n-                 Length   => Container.Length,\n-                 First    => Container.First,\n-                 Last     => Container.Last,\n-                 Plain    => Container.Plain,\n-                 Part     => (LLength => LLe, LFirst => LF, LLast => LLa));\n-      else\n-         while C /= Position.Node loop\n-            if C = Container.Last or C = 0 then\n-               raise Constraint_Error with\n-                 \"Position cursor has no element\";\n-            end if;\n-            C := Next_Unchecked (Container, C);\n-            L := L + 1;\n-         end loop;\n-         if L = 0 then\n-            return (Capacity => Container.Capacity,\n-                    K        => Part,\n-                    Length   => 0,\n-                    First    => 0,\n-                    Last     => 0,\n-                    Plain    => Container.Plain,\n-                    Part     => (LLength => LLe, LFirst => LF, LLast => LLa));\n-         else\n-            return (Capacity => Container.Capacity,\n-                    K        => Part,\n-                    Length   => L,\n-                    First    => Container.First,\n-                    Last     => Container.Plain.Nodes (C).Prev,\n-                    Plain    => Container.Plain,\n-                    Part     => (LLength => LLe, LFirst => LF, LLast => LLa));\n-         end if;\n+      if Curs = No_Element then\n+         return C;\n       end if;\n+      if not Has_Element (Container, Curs) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= 0 loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+      return C;\n    end Left;\n \n    ------------\n@@ -1258,44 +969,36 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n      (Target : in out List;\n       Source : in out List)\n    is\n+      N : Node_Array renames Source.Nodes;\n+      X : Count_Type;\n+\n    begin\n-      if Target.K /= Plain or Source.K /= Plain  then\n-         raise Program_Error with \"cannot modify part of container\";\n+      if Target'Address = Source'Address then\n+         return;\n       end if;\n \n-      declare\n-\n-         N : Node_Array renames Source.Plain.Nodes;\n-         X : Count_Type;\n-\n-      begin\n-         if Target'Address = Source'Address then\n-            return;\n-         end if;\n-\n-         if Target.Capacity < Source.Length then\n-            raise Constraint_Error with  -- ???\n-              \"Source length exceeds Target capacity\";\n-         end if;\n+      if Target.Capacity < Source.Length then\n+         raise Constraint_Error with  -- ???\n+           \"Source length exceeds Target capacity\";\n+      end if;\n \n-         if Source.Plain.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Source (list is busy)\";\n-         end if;\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Source (list is busy)\";\n+      end if;\n \n-         Clear (Target);\n+      Clear (Target);\n \n-         while Source.Length > 0 loop\n-            X := Source.First;\n-            Append (Target, N (X).Element);  -- optimize away???\n+      while Source.Length > 0 loop\n+         X := Source.First;\n+         Append (Target, N (X).Element);  -- optimize away???\n \n-            Source.First := N (X).Next;\n-            N (Source.First).Prev := 0;\n+         Source.First := N (X).Next;\n+         N (Source.First).Prev := 0;\n \n-            Source.Length := Source.Length - 1;\n-            Free (Source.Plain.all, X);\n-         end loop;\n-      end;\n+         Source.Length := Source.Length - 1;\n+         Free (Source, X);\n+      end loop;\n    end Move;\n \n    ----------\n@@ -1315,25 +1018,9 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if not Has_Element (Container, Position) then\n          raise Program_Error with \"Position cursor has no element\";\n       end if;\n-      return (Node => Next_Unchecked (Container, Position.Node));\n+      return (Node => Container.Nodes (Position.Node).Next);\n    end Next;\n \n-   function Next_Unchecked (Container : List; Position : Count_Type)\n-                            return Count_Type\n-   is\n-   begin\n-      case Container.K is\n-         when Plain =>\n-            return Container.Plain.Nodes (Position).Next;\n-         when Part =>\n-            if Position = Container.Last then\n-               return 0;\n-            else\n-               return Container.Plain.Nodes (Position).Next;\n-            end if;\n-      end case;\n-   end Next_Unchecked;\n-\n    -------------\n    -- Prepend --\n    -------------\n@@ -1365,32 +1052,27 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if not Has_Element (Container, Position) then\n          raise Program_Error with \"Position cursor has no element\";\n       end if;\n-\n-      case Container.K is\n-         when Plain =>\n-            return (Node => Container.Plain.Nodes (Position.Node).Prev);\n-         when Part =>\n-            if Container.First = Position.Node then\n-               return No_Element;\n-            else\n-               return (Node => Container.Plain.Nodes (Position.Node).Prev);\n-            end if;\n-      end case;\n+      return (Node => Container.Nodes (Position.Node).Prev);\n    end Previous;\n \n    -------------------\n    -- Query_Element --\n    -------------------\n \n-   procedure Query_Element_Plain\n-     (Container : Plain_List; Position : Cursor;\n+   procedure Query_Element\n+     (Container : List; Position : Cursor;\n       Process   : not null access procedure (Element : Element_Type))\n    is\n-      C : Plain_List renames Container'Unrestricted_Access.all;\n+      C : List renames Container'Unrestricted_Access.all;\n       B : Natural renames C.Busy;\n       L : Natural renames C.Lock;\n \n    begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n       B := B + 1;\n       L := L + 1;\n \n@@ -1407,18 +1089,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n       L := L - 1;\n       B := B - 1;\n-   end Query_Element_Plain;\n-\n-   procedure Query_Element\n-     (Container : List; Position : Cursor;\n-      Process   : not null access procedure (Element : Element_Type))\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor has no element\";\n-      end if;\n-      Query_Element_Plain (Container.Plain.all, Position, Process);\n    end Query_Element;\n \n    ----------\n@@ -1471,15 +1141,12 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Container.K /= Plain  then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Container.Plain.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (list is locked)\";\n       end if;\n@@ -1488,7 +1155,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n                      \"bad cursor in Replace_Element\");\n \n       declare\n-         N : Node_Array renames Container.Plain.Nodes;\n+         N : Node_Array renames Container.Nodes;\n       begin\n          N (Position.Node).Element := New_Item;\n       end;\n@@ -1499,119 +1166,93 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    ----------------------\n \n    procedure Reverse_Elements (Container : in out List) is\n-   begin\n-      if Container.K /= Plain  then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n-\n-      declare\n-         N : Node_Array renames Container.Plain.Nodes;\n-         I : Count_Type := Container.First;\n-         J : Count_Type := Container.Last;\n+      N : Node_Array renames Container.Nodes;\n+      I : Count_Type := Container.First;\n+      J : Count_Type := Container.Last;\n \n-         procedure Swap (L, R : Count_Type);\n+      procedure Swap (L, R : Count_Type);\n \n-         ----------\n-         -- Swap --\n-         ----------\n+      ----------\n+      -- Swap --\n+      ----------\n \n-         procedure Swap (L, R : Count_Type) is\n-            LN : constant Count_Type := N (L).Next;\n-            LP : constant Count_Type := N (L).Prev;\n+      procedure Swap (L, R : Count_Type) is\n+         LN : constant Count_Type := N (L).Next;\n+         LP : constant Count_Type := N (L).Prev;\n \n-            RN : constant Count_Type := N (R).Next;\n-            RP : constant Count_Type := N (R).Prev;\n+         RN : constant Count_Type := N (R).Next;\n+         RP : constant Count_Type := N (R).Prev;\n \n-         begin\n-            if LP /= 0 then\n-               N (LP).Next := R;\n-            end if;\n+      begin\n+         if LP /= 0 then\n+            N (LP).Next := R;\n+         end if;\n \n-            if RN /= 0 then\n-               N (RN).Prev := L;\n-            end if;\n+         if RN /= 0 then\n+            N (RN).Prev := L;\n+         end if;\n \n-            N (L).Next := RN;\n-            N (R).Prev := LP;\n+         N (L).Next := RN;\n+         N (R).Prev := LP;\n \n-            if LN = R then\n-               pragma Assert (RP = L);\n+         if LN = R then\n+            pragma Assert (RP = L);\n \n-               N (L).Prev := R;\n-               N (R).Next := L;\n+            N (L).Prev := R;\n+            N (R).Next := L;\n \n-            else\n-               N (L).Prev := RP;\n-               N (RP).Next := L;\n+         else\n+            N (L).Prev := RP;\n+            N (RP).Next := L;\n \n-               N (R).Next := LN;\n-               N (LN).Prev := R;\n-            end if;\n-         end Swap;\n+            N (R).Next := LN;\n+            N (LN).Prev := R;\n+         end if;\n+      end Swap;\n \n-         --  Start of processing for Reverse_Elements\n+      --  Start of processing for Reverse_Elements\n \n-      begin\n-         if Container.Length <= 1 then\n-            return;\n-         end if;\n+   begin\n+      if Container.Length <= 1 then\n+         return;\n+      end if;\n \n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n \n-         if Container.Plain.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (list is busy)\";\n-         end if;\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n+      end if;\n \n-         Container.First := J;\n-         Container.Last := I;\n-         loop\n-            Swap (L => I, R => J);\n+      Container.First := J;\n+      Container.Last := I;\n+      loop\n+         Swap (L => I, R => J);\n \n-            J := N (J).Next;\n-            exit when I = J;\n+         J := N (J).Next;\n+         exit when I = J;\n \n-            I := N (I).Prev;\n-            exit when I = J;\n+         I := N (I).Prev;\n+         exit when I = J;\n \n-            Swap (L => J, R => I);\n+         Swap (L => J, R => I);\n \n-            I := N (I).Next;\n-            exit when I = J;\n+         I := N (I).Next;\n+         exit when I = J;\n \n-            J := N (J).Prev;\n-            exit when I = J;\n-         end loop;\n+         J := N (J).Prev;\n+         exit when I = J;\n+      end loop;\n \n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-      end;\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n    end Reverse_Elements;\n \n    ------------------\n    -- Reverse_Find --\n    ------------------\n \n-   function Reverse_Find_Between\n-     (Container : Plain_List;\n-      Item      : Element_Type;\n-      From      : Count_Type;\n-      To        : Count_Type) return Cursor\n-   is\n-      Nodes : Node_Array renames Container.Nodes;\n-      Node  : Count_Type := To;\n-   begin\n-      while Node /= Nodes (From).Prev loop\n-         if Nodes (Node).Element = Item then\n-            return (Node => Node);\n-         end if;\n-         Node := Nodes (Node).Prev;\n-      end loop;\n-\n-      return No_Element;\n-   end Reverse_Find_Between;\n-\n    function Reverse_Find\n      (Container : List;\n       Item      : Element_Type;\n@@ -1626,37 +1267,38 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if Container.Length = 0 then\n          return No_Element;\n       end if;\n-      return Reverse_Find_Between (Container => Container.Plain.all,\n-                                   Item      => Item,\n-                                   From      => CFirst,\n-                                   To        => Container.Last);\n+\n+      while CFirst /= 0 loop\n+         if Container.Nodes (CFirst).Element = Item then\n+            return (Node => CFirst);\n+         end if;\n+         CFirst := Container.Nodes (CFirst).Prev;\n+      end loop;\n+\n+      return No_Element;\n    end Reverse_Find;\n \n    ---------------------\n    -- Reverse_Iterate --\n    ---------------------\n \n-   procedure Reverse_Iterate_Between\n+   procedure Reverse_Iterate\n      (Container : List;\n-      From      : Count_Type;\n-      To        : Count_Type;\n       Process   :\n-        not null access procedure (Container : List; Position : Cursor))\n+      not null access procedure (Container : List; Position : Cursor))\n    is\n-      C : Plain_List renames Container.Plain.all;\n-      N : Node_Array renames C.Nodes;\n+      C : List renames Container'Unrestricted_Access.all;\n       B : Natural renames C.Busy;\n \n-      Node : Count_Type := To;\n+      Node : Count_Type := Container.Last;\n \n    begin\n       B := B + 1;\n \n       begin\n-         while Node /= N (From).Prev loop\n-            pragma Assert (N (Node).Prev >= 0);\n-            Process (Container, Position => (Node => Node));\n-            Node := N (Node).Prev;\n+         while Node /= 0 loop\n+            Process (Container, (Node => Node));\n+            Node := Container.Nodes (Node).Prev;\n          end loop;\n \n       exception\n@@ -1666,67 +1308,31 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       end;\n \n       B := B - 1;\n-   end Reverse_Iterate_Between;\n-\n-   procedure Reverse_Iterate\n-     (Container : List;\n-      Process   :\n-        not null access procedure (Container : List; Position : Cursor))\n-   is\n-   begin\n-      if Container.Length = 0 then\n-         return;\n-      end if;\n-      Reverse_Iterate_Between\n-        (Container, Container.First, Container.Last, Process);\n    end Reverse_Iterate;\n \n    -----------\n    -- Right --\n    -----------\n \n    function Right (Container : List; Position : Cursor) return List is\n-      L   : Count_Type := 0;\n-      C   : Count_Type := Container.First;\n-      LLe : Count_Type;\n-      LF  : Count_Type;\n-      LLa : Count_Type;\n+      Curs : Cursor := First (Container);\n+      C : List (Container.Capacity) := Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n    begin\n-      case Container.K is\n-         when Plain =>\n-            LLe := Container.Length;\n-            LF := Container.First;\n-            LLa := Container.Last;\n-         when Part =>\n-            LLe := Container.Part.LLength;\n-            LF := Container.Part.LFirst;\n-            LLa := Container.Part.LLast;\n-      end case;\n-      if Position.Node = 0 then\n-         return (Capacity => Container.Capacity,\n-                 K        => Part,\n-                 Length   => 0,\n-                 First    => 0,\n-                 Last     => 0,\n-                 Plain    => Container.Plain,\n-                 Part     => (LLength => LLe, LFirst => LF, LLast => LLa));\n-      else\n-         while C /= Position.Node loop\n-            if C = Container.Last or C = 0 then\n-               raise Constraint_Error with\n-                 \"Position cursor has no element\";\n-            end if;\n-            C := Next_Unchecked (Container, C);\n-            L := L + 1;\n-         end loop;\n-         return (Capacity => Container.Capacity,\n-                 K        => Part,\n-                 Length   => Container.Length - L,\n-                 First    => Position.Node,\n-                 Last     => Container.Last,\n-                 Plain    => Container.Plain,\n-                 Part     => (LLength => LLe, LFirst => LF, LLast => LLa));\n+      if Curs = No_Element then\n+         Clear (C);\n+         return C;\n       end if;\n+      if Position /= No_Element and not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= Position.Node loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+      return C;\n    end Right;\n \n    ------------\n@@ -1738,53 +1344,46 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       Before : Cursor;\n       Source : in out List)\n    is\n+      SN : Node_Array renames Source.Nodes;\n+\n    begin\n-      if Target.K /= Plain or Source.K /= Plain then\n-         raise Program_Error with \"cannot modify part of container\";\n+      if Before.Node /= 0 then\n+         null;\n+         pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n       end if;\n \n-      declare\n-         SN : Node_Array renames Source.Plain.Nodes;\n-\n-      begin\n-         if Before.Node /= 0 then\n-            null;\n-            pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n-         end if;\n-\n-         if Target'Address = Source'Address\n-           or else Source.Length = 0\n-         then\n-            return;\n-         end if;\n+      if Target'Address = Source'Address\n+        or else Source.Length = 0\n+      then\n+         return;\n+      end if;\n \n-         pragma Assert (SN (Source.First).Prev = 0);\n-         pragma Assert (SN (Source.Last).Next = 0);\n+      pragma Assert (SN (Source.First).Prev = 0);\n+      pragma Assert (SN (Source.Last).Next = 0);\n \n-         if Target.Length > Count_Type'Base'Last - Source.Length then\n-            raise Constraint_Error with \"new length exceeds maximum\";\n-         end if;\n+      if Target.Length > Count_Type'Base'Last - Source.Length then\n+         raise Constraint_Error with \"new length exceeds maximum\";\n+      end if;\n \n-         if Target.Length + Source.Length > Target.Capacity then\n-            raise Constraint_Error;\n-         end if;\n+      if Target.Length + Source.Length > Target.Capacity then\n+         raise Constraint_Error;\n+      end if;\n \n-         if Target.Plain.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Target (list is busy)\";\n-         end if;\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Target (list is busy)\";\n+      end if;\n \n-         if Source.Plain.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors of Source (list is busy)\";\n-         end if;\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors of Source (list is busy)\";\n+      end if;\n \n-         loop\n-            Insert (Target, Before, SN (Source.Last).Element);\n-            Delete_Last (Source);\n-            exit when Is_Empty (Source);\n-         end loop;\n-      end;\n+      loop\n+         Insert (Target, Before, SN (Source.Last).Element);\n+         Delete_Last (Source);\n+         exit when Is_Empty (Source);\n+      end loop;\n    end Splice;\n \n    procedure Splice\n@@ -1796,9 +1395,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       Target_Position : Cursor;\n \n    begin\n-      if Target.K /= Plain or Source.K /= Plain  then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n \n       if Target'Address = Source'Address then\n          Splice (Target, Before, Position);\n@@ -1815,20 +1411,20 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          raise Constraint_Error;\n       end if;\n \n-      if Target.Plain.Busy > 0 then\n+      if Target.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Target (list is busy)\";\n       end if;\n \n-      if Source.Plain.Busy > 0 then\n+      if Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n       Insert\n         (Container => Target,\n          Before    => Before,\n-         New_Item  => Source.Plain.Nodes (Position.Node).Element,\n+         New_Item  => Source.Nodes (Position.Node).Element,\n          Position  => Target_Position);\n \n       Delete (Source, Position);\n@@ -1840,105 +1436,98 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       Before    : Cursor;\n       Position  : Cursor)\n    is\n+      N : Node_Array renames Container.Nodes;\n+\n    begin\n-      if Container.K /= Plain  then\n-         raise Program_Error with \"cannot modify part of container\";\n+      if Before.Node /= 0 then\n+         null;\n+         pragma Assert (Vet (Container, Before),\n+                        \"bad Before cursor in Splice\");\n       end if;\n \n-      declare\n-         N : Node_Array renames Container.Plain.Nodes;\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n \n-      begin\n-         if Before.Node /= 0 then\n-            null;\n-            pragma Assert (Vet (Container, Before),\n-                           \"bad Before cursor in Splice\");\n-         end if;\n+      pragma Assert (Vet (Container, Position),\n+                     \"bad Position cursor in Splice\");\n \n-         if Position.Node = 0 then\n-            raise Constraint_Error with \"Position cursor has no element\";\n-         end if;\n+      if Position.Node = Before.Node\n+        or else N (Position.Node).Next = Before.Node\n+      then\n+         return;\n+      end if;\n \n-         pragma Assert (Vet (Container, Position),\n-                        \"bad Position cursor in Splice\");\n+      pragma Assert (Container.Length >= 2);\n \n-         if Position.Node = Before.Node\n-           or else N (Position.Node).Next = Before.Node\n-         then\n-            return;\n-         end if;\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n+      end if;\n \n-         pragma Assert (Container.Length >= 2);\n+      if Before.Node = 0 then\n+         pragma Assert (Position.Node /= Container.Last);\n \n-         if Container.Plain.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (list is busy)\";\n+         if Position.Node = Container.First then\n+            Container.First := N (Position.Node).Next;\n+            N (Container.First).Prev := 0;\n+\n+         else\n+            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n          end if;\n \n-         if Before.Node = 0 then\n-            pragma Assert (Position.Node /= Container.Last);\n+         N (Container.Last).Next := Position.Node;\n+         N (Position.Node).Prev := Container.Last;\n \n-            if Position.Node = Container.First then\n-               Container.First := N (Position.Node).Next;\n-               N (Container.First).Prev := 0;\n+         Container.Last := Position.Node;\n+         N (Container.Last).Next := 0;\n \n-            else\n-               N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-               N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-            end if;\n+         return;\n+      end if;\n \n-            N (Container.Last).Next := Position.Node;\n-            N (Position.Node).Prev := Container.Last;\n+      if Before.Node = Container.First then\n+         pragma Assert (Position.Node /= Container.First);\n \n-            Container.Last := Position.Node;\n+         if Position.Node = Container.Last then\n+            Container.Last := N (Position.Node).Prev;\n             N (Container.Last).Next := 0;\n \n-            return;\n+         else\n+            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n          end if;\n \n-         if Before.Node = Container.First then\n-            pragma Assert (Position.Node /= Container.First);\n-\n-            if Position.Node = Container.Last then\n-               Container.Last := N (Position.Node).Prev;\n-               N (Container.Last).Next := 0;\n-\n-            else\n-               N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-               N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-            end if;\n+         N (Container.First).Prev := Position.Node;\n+         N (Position.Node).Next := Container.First;\n \n-            N (Container.First).Prev := Position.Node;\n-            N (Position.Node).Next := Container.First;\n+         Container.First := Position.Node;\n+         N (Container.First).Prev := 0;\n \n-            Container.First := Position.Node;\n-            N (Container.First).Prev := 0;\n-\n-            return;\n-         end if;\n+         return;\n+      end if;\n \n-         if Position.Node = Container.First then\n-            Container.First := N (Position.Node).Next;\n-            N (Container.First).Prev := 0;\n+      if Position.Node = Container.First then\n+         Container.First := N (Position.Node).Next;\n+         N (Container.First).Prev := 0;\n \n-         elsif Position.Node = Container.Last then\n-            Container.Last := N (Position.Node).Prev;\n-            N (Container.Last).Next := 0;\n+      elsif Position.Node = Container.Last then\n+         Container.Last := N (Position.Node).Prev;\n+         N (Container.Last).Next := 0;\n \n-         else\n-            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-         end if;\n+      else\n+         N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+         N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+      end if;\n \n-         N (N (Before.Node).Prev).Next := Position.Node;\n-         N (Position.Node).Prev := N (Before.Node).Prev;\n+      N (N (Before.Node).Prev).Next := Position.Node;\n+      N (Position.Node).Prev := N (Before.Node).Prev;\n \n-         N (Before.Node).Prev := Position.Node;\n-         N (Position.Node).Next := Before.Node;\n+      N (Before.Node).Prev := Position.Node;\n+      N (Position.Node).Next := Before.Node;\n \n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-      end;\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n    end Splice;\n \n    ------------------\n@@ -1951,11 +1540,11 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    begin\n       while CL /= 0 or CR /= 0 loop\n          if CL /= CR or else\n-           Element_Unchecked (Left, CL) /= Element_Unchecked (Right, CL) then\n+           Left.Nodes (CL).Element /= Right.Nodes (CL).Element then\n             return False;\n          end if;\n-         CL := Next_Unchecked (Left, CL);\n-         CR := Next_Unchecked (Right, CR);\n+         CL := Left.Nodes (CL).Next;\n+         CR := Right.Nodes (CR).Next;\n       end loop;\n       return True;\n    end Strict_Equal;\n@@ -1969,9 +1558,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if Container.K /= Plain  then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n \n       if I.Node = 0 then\n          raise Constraint_Error with \"I cursor has no element\";\n@@ -1985,7 +1571,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Plain.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (list is locked)\";\n       end if;\n@@ -1994,7 +1580,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       pragma Assert (Vet (Container, J), \"bad J cursor in Swap\");\n \n       declare\n-         NN : Node_Array renames Container.Plain.Nodes;\n+         NN : Node_Array renames Container.Nodes;\n          NI : Node_Type renames NN (I.Node);\n          NJ : Node_Type renames NN (J.Node);\n \n@@ -2017,9 +1603,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       I_Next, J_Next : Cursor;\n \n    begin\n-      if Container.K /= Plain  then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n \n       if I.Node = 0 then\n          raise Constraint_Error with \"I cursor has no element\";\n@@ -2033,7 +1616,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Container.Plain.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (list is busy)\";\n       end if;\n@@ -2070,9 +1653,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-      if Container.K /= Plain  then\n-         raise Program_Error with \"cannot modify part of container\";\n-      end if;\n \n       if Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor has no element\";\n@@ -2082,15 +1662,15 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n                      \"bad cursor in Update_Element\");\n \n       declare\n-         B : Natural renames Container.Plain.Busy;\n-         L : Natural renames Container.Plain.Lock;\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n \n       begin\n          B := B + 1;\n          L := L + 1;\n \n          declare\n-            N : Node_Type renames Container.Plain.Nodes (Position.Node);\n+            N : Node_Type renames Container.Nodes (Position.Node);\n          begin\n             Process (N.Element);\n          exception\n@@ -2110,174 +1690,155 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    ---------\n \n    function Vet (L : List; Position : Cursor) return Boolean is\n+      N : Node_Array renames L.Nodes;\n+\n    begin\n-      if L.K /= Plain  then\n-         raise Program_Error with \"cannot modify part of container\";\n+      if L.Length = 0 then\n+         return False;\n       end if;\n \n-      declare\n-         N : Node_Array renames L.Plain.Nodes;\n+      if L.First = 0 then\n+         return False;\n+      end if;\n \n-      begin\n-         if L.Length = 0 then\n-            return False;\n-         end if;\n+      if L.Last = 0 then\n+         return False;\n+      end if;\n \n-         if L.First = 0 then\n-            return False;\n-         end if;\n+      if Position.Node > L.Capacity then\n+         return False;\n+      end if;\n \n-         if L.Last = 0 then\n-            return False;\n-         end if;\n+      if N (Position.Node).Prev < 0\n+        or else N (Position.Node).Prev > L.Capacity\n+      then\n+         return False;\n+      end if;\n \n-         if Position.Node > L.Capacity then\n-            return False;\n-         end if;\n+      if N (Position.Node).Next > L.Capacity then\n+         return False;\n+      end if;\n \n-         if N (Position.Node).Prev < 0\n-           or else N (Position.Node).Prev > L.Capacity\n-         then\n-            return False;\n-         end if;\n+      if N (L.First).Prev /= 0 then\n+         return False;\n+      end if;\n \n-         if N (Position.Node).Next > L.Capacity then\n-            return False;\n-         end if;\n+      if N (L.Last).Next /= 0 then\n+         return False;\n+      end if;\n \n-         if N (L.First).Prev /= 0 then\n-            return False;\n-         end if;\n+      if N (Position.Node).Prev = 0\n+        and then Position.Node /= L.First\n+      then\n+         return False;\n+      end if;\n \n-         if N (L.Last).Next /= 0 then\n-            return False;\n-         end if;\n+      if N (Position.Node).Next = 0\n+        and then Position.Node /= L.Last\n+      then\n+         return False;\n+      end if;\n \n-         if N (Position.Node).Prev = 0\n-           and then Position.Node /= L.First\n-         then\n-            return False;\n-         end if;\n+      if L.Length = 1 then\n+         return L.First = L.Last;\n+      end if;\n \n-         if N (Position.Node).Next = 0\n-           and then Position.Node /= L.Last\n-         then\n-            return False;\n-         end if;\n+      if L.First = L.Last then\n+         return False;\n+      end if;\n \n-         if L.Length = 1 then\n-            return L.First = L.Last;\n-         end if;\n+      if N (L.First).Next = 0 then\n+         return False;\n+      end if;\n \n-         if L.First = L.Last then\n-            return False;\n-         end if;\n+      if N (L.Last).Prev = 0 then\n+         return False;\n+      end if;\n \n-         if N (L.First).Next = 0 then\n-            return False;\n-         end if;\n+      if N (N (L.First).Next).Prev /= L.First then\n+         return False;\n+      end if;\n \n-         if N (L.Last).Prev = 0 then\n-            return False;\n-         end if;\n+      if N (N (L.Last).Prev).Next /= L.Last then\n+         return False;\n+      end if;\n \n-         if N (N (L.First).Next).Prev /= L.First then\n+      if L.Length = 2 then\n+         if N (L.First).Next /= L.Last then\n             return False;\n          end if;\n \n-         if N (N (L.Last).Prev).Next /= L.Last then\n+         if N (L.Last).Prev /= L.First then\n             return False;\n          end if;\n \n-         if L.Length = 2 then\n-            if N (L.First).Next /= L.Last then\n-               return False;\n-            end if;\n+         return True;\n+      end if;\n \n-            if N (L.Last).Prev /= L.First then\n-               return False;\n-            end if;\n+      if N (L.First).Next = L.Last then\n+         return False;\n+      end if;\n \n-            return True;\n-         end if;\n+      if N (L.Last).Prev = L.First then\n+         return False;\n+      end if;\n \n-         if N (L.First).Next = L.Last then\n-            return False;\n-         end if;\n+      if Position.Node = L.First then\n+         return True;\n+      end if;\n \n-         if N (L.Last).Prev = L.First then\n-            return False;\n-         end if;\n+      if Position.Node = L.Last then\n+         return True;\n+      end if;\n \n-         if Position.Node = L.First then\n-            return True;\n-         end if;\n+      if N (Position.Node).Next = 0 then\n+         return False;\n+      end if;\n \n-         if Position.Node = L.Last then\n-            return True;\n-         end if;\n+      if N (Position.Node).Prev = 0 then\n+         return False;\n+      end if;\n \n-         if N (Position.Node).Next = 0 then\n-            return False;\n-         end if;\n+      if N (N (Position.Node).Next).Prev /= Position.Node then\n+         return False;\n+      end if;\n \n-         if N (Position.Node).Prev = 0 then\n-            return False;\n-         end if;\n+      if N (N (Position.Node).Prev).Next /= Position.Node then\n+         return False;\n+      end if;\n \n-         if N (N (Position.Node).Next).Prev /= Position.Node then\n+      if L.Length = 3 then\n+         if N (L.First).Next /= Position.Node then\n             return False;\n          end if;\n \n-         if N (N (Position.Node).Prev).Next /= Position.Node then\n+         if N (L.Last).Prev /= Position.Node then\n             return False;\n          end if;\n+      end if;\n \n-         if L.Length = 3 then\n-            if N (L.First).Next /= Position.Node then\n-               return False;\n-            end if;\n-\n-            if N (L.Last).Prev /= Position.Node then\n-               return False;\n-            end if;\n-         end if;\n-\n-         return True;\n-      end;\n+      return True;\n    end Vet;\n \n    -----------\n    -- Write --\n    -----------\n \n-   procedure Write_Between\n+   procedure Write\n      (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Plain_List;\n-      Length : Count_Type;\n-      From   : Count_Type;\n-      To     : Count_Type) is\n-\n+      Item   : List)\n+   is\n       N    : Node_Array renames Item.Nodes;\n       Node : Count_Type;\n \n    begin\n-      Count_Type'Base'Write (Stream, Length);\n+      Count_Type'Base'Write (Stream, Item.Length);\n \n-      Node := From;\n-      while Node /= N (To).Next loop\n+      Node := Item.First;\n+      while Node /= 0 loop\n          Element_Type'Write (Stream, N (Node).Element);\n          Node := N (Node).Next;\n       end loop;\n-   end Write_Between;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : List)\n-   is\n-   begin\n-      Write_Between\n-        (Stream, Item.Plain.all, Item.Length, Item.First, Item.Last);\n    end Write;\n \n    procedure Write"}, {"sha": "714ce6761f45124b4049df33cc64693e87c6032b", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -251,33 +251,14 @@ private\n    type Node_Array is array (Count_Type range <>) of Node_Type;\n    function \"=\" (L, R : Node_Array) return Boolean is abstract;\n \n-   type List_Access is access all List;\n-   for List_Access'Storage_Size use 0;\n-\n-   type Kind is (Plain, Part);\n-\n-   type Plain_List (Capacity : Count_Type) is record\n+   type List (Capacity : Count_Type) is tagged record\n       Nodes  : Node_Array (1 .. Capacity) := (others => <>);\n       Free   : Count_Type'Base := -1;\n       Busy   : Natural := 0;\n       Lock   : Natural := 0;\n-   end record;\n-\n-   type PList_Access is access Plain_List;\n-\n-   type Part_List is record\n-      LLength : Count_Type := 0;\n-      LFirst  : Count_Type := 0;\n-      LLast   : Count_Type := 0;\n-   end record;\n-\n-   type List (Capacity : Count_Type) is tagged record\n-      K      : Kind := Plain;\n       Length : Count_Type := 0;\n       First  : Count_Type := 0;\n       Last   : Count_Type := 0;\n-      Part   : Part_List;\n-      Plain  : PList_Access := new Plain_List'(Capacity, others => <>);\n    end record;\n \n    use Ada.Streams;"}, {"sha": "5bcafe2d293452fc56a499b960f2e6a7d1df0106", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 192, "deletions": 521, "changes": 713, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--          Copyright (C) 2010-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,29 +46,19 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Node : Node_Type) return Boolean;\n    pragma Inline (Equivalent_Keys);\n \n-   function Find_Between\n-     (HT   : Hash_Table_Type;\n-      Key  : Key_Type;\n-      From : Count_Type;\n-      To   : Count_Type) return Count_Type;\n-\n    procedure Free\n-     (HT : in out Hash_Table_Type;\n+     (HT : in out Map;\n       X  : Count_Type);\n \n    generic\n       with procedure Set_Element (Node : in out Node_Type);\n    procedure Generic_Allocate\n-     (HT   : in out Hash_Table_Type;\n+     (HT   : in out Map;\n       Node : out Count_Type);\n \n    function Hash_Node (Node : Node_Type) return Hash_Type;\n    pragma Inline (Hash_Node);\n \n-   function Next_Unchecked\n-     (Container : Map;\n-      Position  : Cursor) return Cursor;\n-\n    function Next (Node : Node_Type) return Count_Type;\n    pragma Inline (Next);\n \n@@ -113,27 +103,20 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       end if;\n \n       declare\n-         Node  : Count_Type := First (Left).Node;\n+         Node  : Count_Type := Left.First.Node;\n          ENode : Count_Type;\n-         Last  : Count_Type;\n       begin\n \n-         if Left.K = Plain then\n-            Last := 0;\n-         else\n-            Last := HT_Ops.Next (Left.HT.all, Left.Last);\n-         end if;\n-\n-         while Node /= Last loop\n+         while Node /= 0 loop\n             ENode := Find (Container => Right,\n-                           Key       => Left.HT.Nodes (Node).Key).Node;\n+                           Key       => Left.Nodes (Node).Key).Node;\n             if ENode = 0 or else\n-              Right.HT.Nodes (ENode).Element /= Left.HT.Nodes (Node).Element\n+              Right.Nodes (ENode).Element /= Left.Nodes (Node).Element\n             then\n                return False;\n             end if;\n \n-            Node := HT_Ops.Next (Left.HT.all, Node);\n+            Node := HT_Ops.Next (Left, Node);\n          end loop;\n \n          return True;\n@@ -158,18 +141,14 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       --------------------\n \n       procedure Insert_Element (Source_Node : Count_Type) is\n-         N : Node_Type renames Source.HT.Nodes (Source_Node);\n+         N : Node_Type renames Source.Nodes (Source_Node);\n       begin\n          Target.Insert (N.Key, N.Element);\n       end Insert_Element;\n \n       --  Start of processing for Assign\n \n    begin\n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Target'Address = Source'Address then\n          return;\n@@ -182,19 +161,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n       Clear (Target);  -- checks busy bits\n \n-      case Source.K is\n-         when Plain =>\n-            Insert_Elements (Source.HT.all);\n-         when Part =>\n-            declare\n-               N : Count_Type := Source.First;\n-            begin\n-               while N /= HT_Ops.Next (Source.HT.all, Source.Last) loop\n-                  Insert_Element (N);\n-                  N := HT_Ops.Next (Source.HT.all, N);\n-               end loop;\n-            end;\n-      end case;\n+      Insert_Elements (Source);\n    end Assign;\n \n    --------------\n@@ -203,7 +170,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    function Capacity (Container : Map) return Count_Type is\n    begin\n-      return Container.HT.Nodes'Length;\n+      return Container.Nodes'Length;\n    end Capacity;\n \n    -----------\n@@ -212,13 +179,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    procedure Clear (Container : in out Map) is\n    begin\n-\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      HT_Ops.Clear (Container.HT.all);\n+      HT_Ops.Clear (Container);\n    end Clear;\n \n    --------------\n@@ -245,40 +206,22 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Target : Map (C, Source.Modulus);\n       Cu     : Cursor;\n    begin\n-      if (Source.K = Part and Source.Length = 0) or\n-        Source.HT.Length = 0 then\n-         return Target;\n-      end if;\n \n-      Target.HT.Length := Source.HT.Length;\n-      Target.HT.Free := Source.HT.Free;\n+      Target.Length := Source.Length;\n+      Target.Free := Source.Free;\n       while H <= Source.Modulus loop\n-         Target.HT.Buckets (H) := Source.HT.Buckets (H);\n+         Target.Buckets (H) := Source.Buckets (H);\n          H := H + 1;\n       end loop;\n       while N <= Source.Capacity loop\n-         Target.HT.Nodes (N) := Source.HT.Nodes (N);\n+         Target.Nodes (N) := Source.Nodes (N);\n          N := N + 1;\n       end loop;\n       while N <= C loop\n          Cu := (Node => N);\n-         Free (Target.HT.all, Cu.Node);\n+         Free (Target, Cu.Node);\n          N := N + 1;\n       end loop;\n-      if Source.K = Part then\n-         N := HT_Ops.First (Target.HT.all);\n-         while N /= Source.First loop\n-            Cu := (Node => N);\n-            N := HT_Ops.Next (Target.HT.all, N);\n-            Delete (Target, Cu);\n-         end loop;\n-         N := HT_Ops.Next (Target.HT.all, Source.Last);\n-         while N /= 0 loop\n-            Cu := (Node => N);\n-            N := HT_Ops.Next (Target.HT.all, N);\n-            Delete (Target, Cu);\n-         end loop;\n-      end if;\n       return Target;\n    end Copy;\n \n@@ -300,43 +243,33 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      Key_Ops.Delete_Key_Sans_Free (Container.HT.all, Key, X);\n+      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n \n       if X = 0 then\n          raise Constraint_Error with \"attempt to delete key not in map\";\n       end if;\n \n-      Free (Container.HT.all, X);\n+      Free (Container, X);\n    end Delete;\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Delete has no element\";\n       end if;\n \n-      if Container.HT.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"Delete attempted to tamper with elements (map is busy)\";\n       end if;\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n \n-      HT_Ops.Delete_Node_Sans_Free (Container.HT.all, Position.Node);\n+      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n \n-      Free (Container.HT.all, Position.Node);\n+      Free (Container, Position.Node);\n    end Delete;\n \n    -------------\n@@ -352,7 +285,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n            \"no element available because key not in map\";\n       end if;\n \n-      return Container.HT.Nodes (Node).Element;\n+      return Container.Nodes (Node).Element;\n    end Element;\n \n    function Element (Container : Map; Position : Cursor) return Element_Type is\n@@ -364,7 +297,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       pragma Assert (Vet (Container, Position),\n                      \"bad cursor in function Element\");\n \n-      return Container.HT.Nodes (Position.Node).Element;\n+      return Container.Nodes (Position.Node).Element;\n    end Element;\n \n    ---------------------\n@@ -398,11 +331,9 @@ package body Ada.Containers.Formal_Hashed_Maps is\n                      \"Right cursor of Equivalent_Keys is bad\");\n \n       declare\n-         LT : Hash_Table_Type renames Left.HT.all;\n-         RT : Hash_Table_Type renames Right.HT.all;\n \n-         LN : Node_Type renames LT.Nodes (CLeft.Node);\n-         RN : Node_Type renames RT.Nodes (CRight.Node);\n+         LN : Node_Type renames Left.Nodes (CLeft.Node);\n+         RN : Node_Type renames Right.Nodes (CRight.Node);\n \n       begin\n          return Equivalent_Keys (LN.Key, RN.Key);\n@@ -423,8 +354,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n                      \"Left cursor in Equivalent_Keys is bad\");\n \n       declare\n-         LT : Hash_Table_Type renames Left.HT.all;\n-         LN : Node_Type renames LT.Nodes (CLeft.Node);\n+         LN : Node_Type renames Left.Nodes (CLeft.Node);\n \n       begin\n          return Equivalent_Keys (LN.Key, Right);\n@@ -445,8 +375,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n                      \"Right cursor of Equivalent_Keys is bad\");\n \n       declare\n-         RT : Hash_Table_Type renames Right.HT.all;\n-         RN : Node_Type renames RT.Nodes (CRight.Node);\n+         RN : Node_Type renames Right.Nodes (CRight.Node);\n \n       begin\n          return Equivalent_Keys (Left, RN.Key);\n@@ -460,125 +389,48 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    procedure Exclude (Container : in out Map; Key : Key_Type) is\n       X : Count_Type;\n    begin\n-\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      Key_Ops.Delete_Key_Sans_Free (Container.HT.all, Key, X);\n-      Free (Container.HT.all, X);\n+      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+      Free (Container, X);\n    end Exclude;\n \n    ----------\n    -- Find --\n    ----------\n-   function Find_Between\n-     (HT   : Hash_Table_Type;\n-      Key  : Key_Type;\n-      From : Count_Type;\n-      To   : Count_Type) return Count_Type is\n-\n-      Indx      : Hash_Type;\n-      Indx_From : constant Hash_Type :=\n-        Key_Ops.Index (HT, HT.Nodes (From).Key);\n-      Indx_To   : constant Hash_Type :=\n-        Key_Ops.Index (HT, HT.Nodes (To).Key);\n-      Node      : Count_Type;\n-      To_Node   : Count_Type;\n-\n-   begin\n-\n-      Indx := Key_Ops.Index (HT, Key);\n-\n-      if Indx < Indx_From or Indx > Indx_To then\n-         return 0;\n-      end if;\n-\n-      if Indx = Indx_From then\n-         Node := From;\n-      else\n-         Node := HT.Buckets (Indx);\n-      end if;\n-\n-      if Indx = Indx_To then\n-         To_Node := HT.Nodes (To).Next;\n-      else\n-         To_Node := 0;\n-      end if;\n-\n-      while Node /= To_Node loop\n-         if Equivalent_Keys (Key, HT.Nodes (Node)) then\n-            return Node;\n-         end if;\n-         Node := HT.Nodes (Node).Next;\n-      end loop;\n-      return 0;\n-   end Find_Between;\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n+      Node : constant Count_Type :=\n+        Key_Ops.Find (Container, Key);\n+\n    begin\n-      case Container.K is\n-         when Plain =>\n-            declare\n-               Node : constant Count_Type :=\n-                        Key_Ops.Find (Container.HT.all, Key);\n-\n-            begin\n-               if Node = 0 then\n-                  return No_Element;\n-               end if;\n-\n-               return (Node => Node);\n-            end;\n-         when Part =>\n-            if Container.Length = 0 then\n-               return No_Element;\n-            end if;\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n \n-            return (Node => Find_Between (Container.HT.all, Key,\n-                    Container.First, Container.Last));\n-      end case;\n+      return (Node => Node);\n    end Find;\n \n    -----------\n    -- First --\n    -----------\n \n    function First (Container : Map) return Cursor is\n+      Node : constant Count_Type := HT_Ops.First (Container);\n+\n    begin\n-      case Container.K is\n-         when Plain =>\n-            declare\n-               Node : constant Count_Type := HT_Ops.First (Container.HT.all);\n-\n-            begin\n-               if Node = 0 then\n-                  return No_Element;\n-               end if;\n-\n-               return (Node => Node);\n-            end;\n-         when Part =>\n-            declare\n-               Node : constant Count_Type := Container.First;\n-\n-            begin\n-               if Node = 0 then\n-                  return No_Element;\n-               end if;\n-\n-               return (Node => Node);\n-            end;\n-      end case;\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return (Node => Node);\n+\n    end First;\n \n    ----------\n    -- Free --\n    ----------\n \n    procedure Free\n-     (HT : in out Hash_Table_Type;\n+     (HT : in out Map;\n       X  : Count_Type)\n    is\n    begin\n@@ -591,7 +443,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    ----------------------\n \n    procedure Generic_Allocate\n-     (HT   : in out Hash_Table_Type;\n+     (HT   : in out Map;\n       Node : out Count_Type)\n    is\n \n@@ -610,57 +462,10 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    function Has_Element (Container : Map; Position : Cursor) return Boolean is\n    begin\n       if Position.Node = 0 or else\n-        not Container.HT.Nodes (Position.Node).Has_Element then\n+        not Container.Nodes (Position.Node).Has_Element then\n          return False;\n       end if;\n-\n-      if Container.K = Plain then\n-         return True;\n-      end if;\n-\n-      declare\n-         Lst_Index : constant Hash_Type :=\n-                       Key_Ops.Index (Container.HT.all,\n-                                      Container.HT.Nodes (Container.Last).Key);\n-         Fst_Index : constant Hash_Type :=\n-                       Key_Ops.Index (Container.HT.all,\n-                                     Container.HT.Nodes (Container.First).Key);\n-         Index     : constant Hash_Type :=\n-                       Key_Ops.Index (Container.HT.all,\n-                                      Container.HT.Nodes (Position.Node).Key);\n-         Lst_Node  : Count_Type;\n-         Node      : Count_Type;\n-      begin\n-\n-         if Index < Fst_Index or Index > Lst_Index then\n-            return False;\n-         end if;\n-\n-         if Index > Fst_Index and Index < Lst_Index then\n-            return True;\n-         end if;\n-\n-         if Index = Fst_Index then\n-            Node := Container.First;\n-         else\n-            Node := Container.HT.Buckets (Index);\n-         end if;\n-\n-         if Index = Lst_Index then\n-            Lst_Node := Container.HT.Nodes (Container.Last).Next;\n-         else\n-            Lst_Node := 0;\n-         end if;\n-\n-         while Node /= Lst_Node loop\n-            if Position.Node = Node then\n-               return True;\n-            end if;\n-            Node := HT_Ops.Next (Container.HT.all, Node);\n-         end loop;\n-\n-         return False;\n-      end;\n+      return True;\n    end Has_Element;\n \n    ---------------\n@@ -689,13 +494,13 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.HT.Lock > 0 then\n+         if Container.Lock > 0 then\n             raise Program_Error with\n               \"Include attempted to tamper with cursors (map is locked)\";\n          end if;\n \n          declare\n-            N : Node_Type renames Container.HT.Nodes (Position.Node);\n+            N : Node_Type renames Container.Nodes (Position.Node);\n          begin\n             N.Key := Key;\n             N.Element := New_Item;\n@@ -713,52 +518,44 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    is\n-   begin\n+      procedure Assign_Key (Node : in out Node_Type);\n+      pragma Inline (Assign_Key);\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-      declare\n-         procedure Assign_Key (Node : in out Node_Type);\n-         pragma Inline (Assign_Key);\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n \n-         function New_Node return Count_Type;\n-         pragma Inline (New_Node);\n+      procedure Local_Insert is\n+        new Key_Ops.Generic_Conditional_Insert (New_Node);\n \n-         procedure Local_Insert is\n-           new Key_Ops.Generic_Conditional_Insert (New_Node);\n-\n-         procedure Allocate is\n-           new Generic_Allocate (Assign_Key);\n+      procedure Allocate is\n+        new Generic_Allocate (Assign_Key);\n \n-         -----------------\n-         --  Assign_Key --\n-         -----------------\n+      -----------------\n+      --  Assign_Key --\n+      -----------------\n \n-         procedure Assign_Key (Node : in out Node_Type) is\n-         begin\n-            Node.Key := Key;\n-            --  Node.Element := New_Item;\n-         end Assign_Key;\n+      procedure Assign_Key (Node : in out Node_Type) is\n+      begin\n+         Node.Key := Key;\n+         --  Node.Element := New_Item;\n+      end Assign_Key;\n \n-         --------------\n-         -- New_Node --\n-         --------------\n+      --------------\n+      -- New_Node --\n+      --------------\n \n-         function New_Node return Count_Type is\n-            Result : Count_Type;\n-         begin\n-            Allocate (Container.HT.all, Result);\n-            return Result;\n-         end New_Node;\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+      begin\n+         Allocate (Container, Result);\n+         return Result;\n+      end New_Node;\n \n-         --  Start of processing for Insert\n+      --  Start of processing for Insert\n \n-      begin\n+   begin\n \n-         Local_Insert (Container.HT.all, Key, Position.Node, Inserted);\n-      end;\n+      Local_Insert (Container, Key, Position.Node, Inserted);\n    end Insert;\n \n    procedure Insert\n@@ -768,52 +565,44 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    is\n-   begin\n-\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-      declare\n-         procedure Assign_Key (Node : in out Node_Type);\n-         pragma Inline (Assign_Key);\n+      procedure Assign_Key (Node : in out Node_Type);\n+      pragma Inline (Assign_Key);\n \n-         function New_Node return Count_Type;\n-         pragma Inline (New_Node);\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n \n-         procedure Local_Insert is\n-           new Key_Ops.Generic_Conditional_Insert (New_Node);\n+      procedure Local_Insert is\n+        new Key_Ops.Generic_Conditional_Insert (New_Node);\n \n-         procedure Allocate is\n-           new Generic_Allocate (Assign_Key);\n+      procedure Allocate is\n+        new Generic_Allocate (Assign_Key);\n \n-         -----------------\n-         --  Assign_Key --\n-         -----------------\n+      -----------------\n+      --  Assign_Key --\n+      -----------------\n \n-         procedure Assign_Key (Node : in out Node_Type) is\n-         begin\n-            Node.Key := Key;\n-            Node.Element := New_Item;\n-         end Assign_Key;\n+      procedure Assign_Key (Node : in out Node_Type) is\n+      begin\n+         Node.Key := Key;\n+         Node.Element := New_Item;\n+      end Assign_Key;\n \n-         --------------\n-         -- New_Node --\n-         --------------\n+      --------------\n+      -- New_Node --\n+      --------------\n \n-         function New_Node return Count_Type is\n-            Result : Count_Type;\n-         begin\n-            Allocate (Container.HT.all, Result);\n-            return Result;\n-         end New_Node;\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+      begin\n+         Allocate (Container, Result);\n+         return Result;\n+      end New_Node;\n \n-         --  Start of processing for Insert\n+      --  Start of processing for Insert\n \n-      begin\n+   begin\n \n-         Local_Insert (Container.HT.all, Key, Position.Node, Inserted);\n-      end;\n+      Local_Insert (Container, Key, Position.Node, Inserted);\n    end Insert;\n \n    procedure Insert\n@@ -867,32 +656,15 @@ package body Ada.Containers.Formal_Hashed_Maps is\n          Process (Container, (Node => Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.HT.Busy;\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n \n       --  Start of processing for Iterate\n \n    begin\n       B := B + 1;\n \n       begin\n-         case Container.K is\n-            when Plain =>\n-               Local_Iterate (Container.HT.all);\n-            when Part =>\n-\n-               if Container.Length = 0 then\n-                  return;\n-               end if;\n-\n-               declare\n-                  Node : Count_Type := Container.First;\n-               begin\n-                  while Node /= Container.HT.Nodes (Container.Last).Next loop\n-                     Process_Node (Node);\n-                     Node := HT_Ops.Next (Container.HT.all, Node);\n-                  end loop;\n-               end;\n-         end case;\n+         Local_Iterate (Container);\n       exception\n          when others =>\n             B := B - 1;\n@@ -915,45 +687,32 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in function Key\");\n \n-      return Container.HT.Nodes (Position.Node).Key;\n+      return Container.Nodes (Position.Node).Key;\n    end Key;\n \n    ----------\n    -- Left --\n    ----------\n \n    function Left (Container : Map; Position : Cursor) return Map is\n-      Lst : Count_Type;\n-      Fst : constant Count_Type := First (Container).Node;\n-      L   : Count_Type := 0;\n-      C   : Count_Type := Fst;\n+      Curs : Cursor := Position;\n+      C : Map (Container.Capacity, Container.Modulus) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n    begin\n-      while C /= Position.Node loop\n-         if C = 0 or C = Container.Last then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-         Lst := C;\n-         C := HT_Ops.Next (Container.HT.all, C);\n-         L := L + 1;\n-      end loop;\n-      if L = 0 then\n-         return (Capacity => Container.Capacity,\n-                 Modulus  => Container.Modulus,\n-                 K        => Part,\n-                 HT       => Container.HT,\n-                 Length   => 0,\n-                 First    => 0,\n-                 Last     => 0);\n-      else\n-         return (Capacity => Container.Capacity,\n-                 Modulus  => Container.Modulus,\n-                 K        => Part,\n-                 HT       => Container.HT,\n-                 Length   => L,\n-                 First    => Fst,\n-                 Last     => Lst);\n+      if Curs = No_Element then\n+         return C;\n       end if;\n+      if not Has_Element (Container, Curs) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= 0 loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+      return C;\n    end Left;\n \n    ------------\n@@ -962,12 +721,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    function Length (Container : Map) return Count_Type is\n    begin\n-      case Container.K is\n-         when Plain =>\n-            return Container.HT.Length;\n-         when Part =>\n-            return Container.Length;\n-      end case;\n+      return Container.Length;\n    end Length;\n \n    ----------\n@@ -978,17 +732,11 @@ package body Ada.Containers.Formal_Hashed_Maps is\n      (Target : in out Map;\n       Source : in out Map)\n    is\n-      HT   : HT_Types.Hash_Table_Type renames Source.HT.all;\n-      NN   : HT_Types.Nodes_Type renames HT.Nodes;\n+      NN   : HT_Types.Nodes_Type renames Source.Nodes;\n       X, Y : Count_Type;\n \n    begin\n \n-      if Target.K /= Plain or Source.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -998,25 +746,25 @@ package body Ada.Containers.Formal_Hashed_Maps is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      if HT.Busy > 0 then\n+      if Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n       Clear (Target);\n \n-      if HT.Length = 0 then\n+      if Source.Length = 0 then\n          return;\n       end if;\n \n-      X := HT_Ops.First (HT);\n+      X := HT_Ops.First (Source);\n       while X /= 0 loop\n          Insert (Target, NN (X).Key, NN (X).Element);  -- optimize???\n \n-         Y := HT_Ops.Next (HT, X);\n+         Y := HT_Ops.Next (Source, X);\n \n-         HT_Ops.Delete_Node_Sans_Free (HT, X);\n-         Free (HT, X);\n+         HT_Ops.Delete_Node_Sans_Free (Source, X);\n+         Free (Source, X);\n \n          X := Y;\n       end loop;\n@@ -1031,25 +779,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       return Node.Next;\n    end Next;\n \n-   function Next_Unchecked\n-     (Container : Map;\n-      Position  : Cursor) return Cursor\n-   is\n-      HT   : Hash_Table_Type renames Container.HT.all;\n-      Node : constant Count_Type := HT_Ops.Next (HT, Position.Node);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if Container.K = Part and then Container.Last = Position.Node then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Next_Unchecked;\n-\n    function Next (Container : Map; Position : Cursor) return Cursor is\n    begin\n       if Position.Node = 0 then\n@@ -1063,7 +792,16 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in function Next\");\n \n-      return Next_Unchecked (Container, Position);\n+      declare\n+         Node : constant Count_Type := HT_Ops.Next (Container, Position.Node);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return (Node => Node);\n+      end;\n    end Next;\n \n    procedure Next (Container : Map; Position : in out Cursor) is\n@@ -1077,8 +815,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n    function Overlap (Left, Right : Map) return Boolean is\n       Left_Node  : Count_Type;\n-      Left_Nodes : Nodes_Type renames Left.HT.Nodes;\n-      To_Node    : Count_Type;\n+      Left_Nodes : Nodes_Type renames Left.Nodes;\n    begin\n       if Length (Right) = 0 or Length (Left) = 0 then\n          return False;\n@@ -1090,13 +827,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n       Left_Node := First (Left).Node;\n \n-      if Left.K = Plain then\n-         To_Node := 0;\n-      else\n-         To_Node := Left.HT.Nodes (Left.Last).Next;\n-      end if;\n-\n-      while Left_Node /= To_Node loop\n+      while Left_Node /= 0 loop\n          declare\n             N : Node_Type renames Left_Nodes (Left_Node);\n             E : Key_Type renames N.Key;\n@@ -1107,7 +838,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n             end if;\n          end;\n \n-         Left_Node := HT_Ops.Next (Left.HT.all, Left_Node);\n+         Left_Node := HT_Ops.Next (Left, Left_Node);\n       end loop;\n \n       return False;\n@@ -1124,10 +855,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n         procedure (Key : Key_Type; Element : Element_Type))\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n@@ -1137,11 +864,10 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       pragma Assert (Vet (Container, Position), \"bad cursor in Query_Element\");\n \n       declare\n-         HT : Hash_Table_Type renames Container.HT.all;\n-         N  : Node_Type renames HT.Nodes (Position.Node);\n+         N  : Node_Type renames Container.Nodes (Position.Node);\n \n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n \n       begin\n          B := B + 1;\n@@ -1202,26 +928,13 @@ package body Ada.Containers.Formal_Hashed_Maps is\n          --  Start of processing for Read_Node\n \n       begin\n-         Allocate (Container.HT.all, Node);\n+         Allocate (Container, Node);\n          return Node;\n       end Read_Node;\n \n       --  Start of processing for Read\n-      Result : HT_Access;\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error;\n-      end if;\n-\n-      if Container.HT = null then\n-         Result := new HT_Types.Hash_Table_Type (Container.Capacity,\n-                                                 Container.Modulus);\n-      else\n-         Result := Container.HT;\n-      end if;\n-\n-      Read_Nodes (Stream, Result.all);\n-      Container.HT := Result;\n+      Read_Nodes (Stream, Container);\n    end Read;\n \n    procedure Read\n@@ -1241,26 +954,22 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    is\n-      Node : constant Count_Type := Key_Ops.Find (Container.HT.all, Key);\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace key not in map\";\n       end if;\n \n-      if Container.HT.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error with\n            \"Replace attempted to tamper with cursors (map is locked)\";\n       end if;\n \n       declare\n-         N : Node_Type renames Container.HT.Nodes (Node);\n+         N : Node_Type renames Container.Nodes (Node);\n       begin\n          N.Key := Key;\n          N.Element := New_Item;\n@@ -1277,25 +986,21 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element has no element\";\n       end if;\n \n-      if Container.HT.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error with\n            \"Replace_Element attempted to tamper with cursors (map is locked)\";\n       end if;\n \n       pragma Assert (Vet (Container, Position),\n                      \"bad cursor in Replace_Element\");\n \n-      Container.HT.Nodes (Position.Node).Element := New_Item;\n+      Container.Nodes (Position.Node).Element := New_Item;\n    end Replace_Element;\n \n    ----------------------\n@@ -1307,10 +1012,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Capacity  : Count_Type)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Capacity > Container.Capacity then\n          raise Capacity_Error with \"requested capacity is too large\";\n@@ -1322,50 +1023,25 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    -----------\n \n    function Right (Container : Map; Position : Cursor) return Map is\n-      Last : Count_Type;\n-      Lst  : Count_Type;\n-      L    : Count_Type := 0;\n-      C    : Count_Type := Position.Node;\n+      Curs : Cursor := First (Container);\n+      C : Map (Container.Capacity, Container.Modulus) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n    begin\n-\n-      if C = 0 then\n-         return (Capacity => Container.Capacity,\n-                 Modulus  => Container.Modulus,\n-                 K        => Part,\n-                 HT       => Container.HT,\n-                 Length   => 0,\n-                 First    => 0,\n-                 Last     => 0);\n-      end if;\n-\n-      if Container.K = Plain then\n-         Lst := 0;\n-      else\n-         Lst := HT_Ops.Next (Container.HT.all, Container.Last);\n+      if Curs = No_Element then\n+         Clear (C);\n+         return C;\n       end if;\n-\n-      if C = Lst then\n-         raise Constraint_Error with\n-           \"Position cursor has no element\";\n+      if Position /= No_Element and not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n       end if;\n \n-      while C /= Lst loop\n-         if C = 0 then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-         Last := C;\n-         C := HT_Ops.Next (Container.HT.all, C);\n-         L := L + 1;\n+      while Curs.Node /= Position.Node loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n       end loop;\n-\n-      return (Capacity => Container.Capacity,\n-              Modulus  => Container.Modulus,\n-              K        => Part,\n-              HT       => Container.HT,\n-              Length   => L,\n-              First    => Position.Node,\n-              Last     => Last);\n+      return C;\n    end Right;\n \n    --------------\n@@ -1391,14 +1067,14 @@ package body Ada.Containers.Formal_Hashed_Maps is\n \n       while CuL.Node /= 0 or CuR.Node /= 0 loop\n          if CuL.Node /= CuR.Node or else\n-           (Left.HT.Nodes (CuL.Node).Element /=\n-              Right.HT.Nodes (CuR.Node).Element or\n-              Left.HT.Nodes (CuL.Node).Key /=\n-              Right.HT.Nodes (CuR.Node).Key) then\n+           (Left.Nodes (CuL.Node).Element /=\n+              Right.Nodes (CuR.Node).Element or\n+              Left.Nodes (CuL.Node).Key /=\n+              Right.Nodes (CuR.Node).Key) then\n             return False;\n          end if;\n-         CuL := Next_Unchecked (Left, CuL);\n-         CuR := Next_Unchecked (Right, CuR);\n+         CuL := Next (Left, CuL);\n+         CuR := Next (Right, CuR);\n       end loop;\n \n       return True;\n@@ -1415,11 +1091,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n                                              Element : in out Element_Type))\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Update_Element has no element\";\n@@ -1429,16 +1100,15 @@ package body Ada.Containers.Formal_Hashed_Maps is\n                      \"bad cursor in Update_Element\");\n \n       declare\n-         HT : Hash_Table_Type renames Container.HT.all;\n-         B  : Natural renames HT.Busy;\n-         L  : Natural renames HT.Lock;\n+         B  : Natural renames Container.Busy;\n+         L  : Natural renames Container.Lock;\n \n       begin\n          B := B + 1;\n          L := L + 1;\n \n          declare\n-            N : Node_Type renames HT.Nodes (Position.Node);\n+            N : Node_Type renames Container.Nodes (Position.Node);\n             K : Key_Type renames N.Key;\n             E : Element_Type renames N.Element;\n \n@@ -1467,33 +1137,33 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       end if;\n \n       declare\n-         M : HT_Types.Hash_Table_Type renames Container.HT.all;\n          X : Count_Type;\n \n       begin\n-         if M.Length = 0 then\n+         if Container.Length = 0 then\n             return False;\n          end if;\n \n-         if M.Capacity = 0 then\n+         if Container.Capacity = 0 then\n             return False;\n          end if;\n \n-         if M.Buckets'Length = 0 then\n+         if Container.Buckets'Length = 0 then\n             return False;\n          end if;\n \n-         if Position.Node > M.Capacity then\n+         if Position.Node > Container.Capacity then\n             return False;\n          end if;\n \n-         if M.Nodes (Position.Node).Next = Position.Node then\n+         if Container.Nodes (Position.Node).Next = Position.Node then\n             return False;\n          end if;\n \n-         X := M.Buckets (Key_Ops.Index (M, M.Nodes (Position.Node).Key));\n+         X := Container.Buckets\n+           (Key_Ops.Index (Container, Container.Nodes (Position.Node).Key));\n \n-         for J in 1 .. M.Length loop\n+         for J in 1 .. Container.Length loop\n             if X = Position.Node then\n                return True;\n             end if;\n@@ -1502,11 +1172,12 @@ package body Ada.Containers.Formal_Hashed_Maps is\n                return False;\n             end if;\n \n-            if X = M.Nodes (X).Next then  --  to prevent unnecessary looping\n+            if X = Container.Nodes (X).Next then\n+               --  to prevent unnecessary looping\n                return False;\n             end if;\n \n-            X := M.Nodes (X).Next;\n+            X := Container.Nodes (X).Next;\n          end loop;\n \n          return False;\n@@ -1544,7 +1215,7 @@ package body Ada.Containers.Formal_Hashed_Maps is\n    --  Start of processing for Write\n \n    begin\n-      Write_Nodes (Stream, Container.HT.all);\n+      Write_Nodes (Stream, Container);\n    end Write;\n \n    procedure Write"}, {"sha": "c076d4072d5233abe6443c8da305ea1f531190df", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -66,8 +66,7 @@ package Ada.Containers.Formal_Hashed_Maps is\n    pragma Pure;\n \n    type Map (Capacity : Count_Type; Modulus : Hash_Type) is tagged private;\n-   --  pragma Preelaborable_Initialization (Map);\n-   --  why is this commented out???\n+   pragma Preelaborable_Initialization (Map);\n \n    type Cursor is private;\n    pragma Preelaborable_Initialization (Cursor);\n@@ -232,19 +231,10 @@ private\n \n    package HT_Types is new\n      Ada.Containers.Hash_Tables.Generic_Bounded_Hash_Table_Types\n-     (Node_Type);\n+       (Node_Type);\n \n-   type HT_Access is access all HT_Types.Hash_Table_Type;\n-\n-   type Kind is (Plain, Part);\n-\n-   type Map (Capacity : Count_Type; Modulus : Hash_Type) is tagged record\n-      HT     : HT_Access := new HT_Types.Hash_Table_Type (Capacity, Modulus);\n-      K      : Kind := Plain;\n-      Length : Count_Type := 0;\n-      First  : Count_Type := 0;\n-      Last   : Count_Type := 0;\n-   end record;\n+   type Map (Capacity : Count_Type; Modulus : Hash_Type) is\n+      new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n \n    use HT_Types;\n    use Ada.Streams;"}, {"sha": "2a79b046266314472dd2dc528a93aa8d28993a99", "filename": "gcc/ada/a-cfhase.adb", "status": "modified", "additions": 236, "deletions": 831, "changes": 1067, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--          Copyright (C) 2010-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,49 +43,45 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    procedure Difference\n      (Left, Right : Set;\n-      Target      : in out Hash_Table_Type);\n+      Target      : in out Set);\n \n    function Equivalent_Keys\n      (Key  : Element_Type;\n       Node : Node_Type) return Boolean;\n    pragma Inline (Equivalent_Keys);\n \n    procedure Free\n-     (HT : in out Hash_Table_Type;\n+     (HT : in out Set;\n       X  : Count_Type);\n \n    generic\n       with procedure Set_Element (Node : in out Node_Type);\n    procedure Generic_Allocate\n-     (HT   : in out Hash_Table_Type;\n+     (HT   : in out Set;\n       Node : out Count_Type);\n \n    function Hash_Node (Node : Node_Type) return Hash_Type;\n    pragma Inline (Hash_Node);\n \n    procedure Insert\n-     (Container       : in out Hash_Table_Type;\n+     (Container       : in out Set;\n       New_Item : Element_Type;\n       Node     : out Count_Type;\n       Inserted : out Boolean);\n \n    procedure Intersection\n-     (Left   : Hash_Table_Type;\n+     (Left   : Set;\n       Right  : Set;\n-      Target : in out Hash_Table_Type);\n+      Target : in out Set);\n \n    function Is_In\n-     (HT  : HT_Types.Hash_Table_Type;\n+     (HT  : Set;\n       Key : Node_Type) return Boolean;\n    pragma Inline (Is_In);\n \n    procedure Set_Element (Node : in out Node_Type; Item : Element_Type);\n    pragma Inline (Set_Element);\n \n-   function Next_Unchecked\n-     (Container : Set;\n-      Position  : Cursor) return Cursor;\n-\n    function Next (Node : Node_Type) return Count_Type;\n    pragma Inline (Next);\n \n@@ -133,25 +129,18 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       declare\n          Node  : Count_Type := First (Left).Node;\n          ENode : Count_Type;\n-         Last  : Count_Type;\n       begin\n \n-         if Left.K = Plain then\n-            Last := 0;\n-         else\n-            Last := HT_Ops.Next (Left.HT.all, Left.Last);\n-         end if;\n-\n-         while Node /= Last loop\n+         while Node /= 0 loop\n             ENode := Find (Container => Right,\n-                           Item      => Left.HT.Nodes (Node).Element).Node;\n+                           Item      => Left.Nodes (Node).Element).Node;\n             if ENode = 0  or else\n-              Right.HT.Nodes (ENode).Element /= Left.HT.Nodes (Node).Element\n+              Right.Nodes (ENode).Element /= Left.Nodes (Node).Element\n             then\n                return False;\n             end if;\n \n-            Node := HT_Ops.Next (Left.HT.all, Node);\n+            Node := HT_Ops.Next (Left, Node);\n          end loop;\n \n          return True;\n@@ -175,22 +164,18 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       --------------------\n \n       procedure Insert_Element (Source_Node : Count_Type) is\n-         N : Node_Type renames Source.HT.Nodes (Source_Node);\n+         N : Node_Type renames Source.Nodes (Source_Node);\n          X : Count_Type;\n          B : Boolean;\n \n       begin\n-         Insert (Target.HT.all, N.Element, X, B);\n+         Insert (Target, N.Element, X, B);\n          pragma Assert (B);\n       end Insert_Element;\n \n       --  Start of processing for Assign\n \n    begin\n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Target'Address = Source'Address then\n          return;\n@@ -200,21 +185,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n       end if;\n \n-      HT_Ops.Clear (Target.HT.all);\n-\n-      case Source.K is\n-         when Plain =>\n-            Insert_Elements (Source.HT.all);\n-         when Part =>\n-            declare\n-               N : Count_Type := Source.First;\n-            begin\n-               while N /= HT_Ops.Next (Source.HT.all, Source.Last) loop\n-                  Insert_Element (N);\n-                  N := HT_Ops.Next (Source.HT.all, N);\n-               end loop;\n-            end;\n-      end case;\n+      HT_Ops.Clear (Target);\n+      Insert_Elements (Source);\n    end Assign;\n \n    --------------\n@@ -223,7 +195,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function Capacity (Container : Set) return Count_Type is\n    begin\n-      return Container.HT.Nodes'Length;\n+      return Container.Nodes'Length;\n    end Capacity;\n \n    -----------\n@@ -233,12 +205,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    procedure Clear (Container : in out Set) is\n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      HT_Ops.Clear (Container.HT.all);\n+      HT_Ops.Clear (Container);\n    end Clear;\n \n    --------------\n@@ -265,40 +232,22 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       Target : Set (C, Source.Modulus);\n       Cu     : Cursor;\n    begin\n-      if (Source.K = Part and Source.Length = 0) or\n-        Source.HT.Length = 0 then\n-         return Target;\n-      end if;\n \n-      Target.HT.Length := Source.HT.Length;\n-      Target.HT.Free := Source.HT.Free;\n+      Target.Length := Source.Length;\n+      Target.Free := Source.Free;\n       while H <= Source.Modulus loop\n-         Target.HT.Buckets (H) := Source.HT.Buckets (H);\n+         Target.Buckets (H) := Source.Buckets (H);\n          H := H + 1;\n       end loop;\n       while N <= Source.Capacity loop\n-         Target.HT.Nodes (N) := Source.HT.Nodes (N);\n+         Target.Nodes (N) := Source.Nodes (N);\n          N := N + 1;\n       end loop;\n       while N <= C loop\n          Cu := (Node => N);\n-         Free (Target.HT.all, Cu.Node);\n+         Free (Target, Cu.Node);\n          N := N + 1;\n       end loop;\n-      if Source.K = Part then\n-         N := HT_Ops.First (Target.HT.all);\n-         while N /= Source.First loop\n-            Cu := (Node => N);\n-            N := HT_Ops.Next (Target.HT.all, N);\n-            Delete (Target, Cu);\n-         end loop;\n-         N := HT_Ops.Next (Target.HT.all, Source.Last);\n-         while N /= 0 loop\n-            Cu := (Node => N);\n-            N := HT_Ops.Next (Target.HT.all, N);\n-            Delete (Target, Cu);\n-         end loop;\n-      end if;\n       return Target;\n    end Copy;\n \n@@ -323,17 +272,12 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      Element_Keys.Delete_Key_Sans_Free (Container.HT.all, Item, X);\n+      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n \n       if X = 0 then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n-      Free (Container.HT.all, X);\n+      Free (Container, X);\n    end Delete;\n \n    procedure Delete\n@@ -342,24 +286,19 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    is\n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Container.HT.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n \n-      HT_Ops.Delete_Node_Sans_Free (Container.HT.all, Position.Node);\n-      Free (Container.HT.all, Position.Node);\n+      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+      Free (Container, Position.Node);\n \n       Position := No_Element;\n    end Delete;\n@@ -374,80 +313,65 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    is\n       Tgt_Node, Src_Node, Src_Last, Src_Length : Count_Type;\n \n-      TN : Nodes_Type renames Target.HT.Nodes;\n-      SN : Nodes_Type renames Source.HT.Nodes;\n+      TN : Nodes_Type renames Target.Nodes;\n+      SN : Nodes_Type renames Source.Nodes;\n \n    begin\n \n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n \n-      case Source.K is\n-         when Plain =>\n-            Src_Length := Source.HT.Length;\n-         when Part =>\n-            Src_Length := Source.Length;\n-      end case;\n+      Src_Length := Source.Length;\n \n       if Src_Length = 0 then\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n+      if Target.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n-      case Source.K is\n-         when Plain =>\n-            if Src_Length >= Target.HT.Length then\n-               Tgt_Node := HT_Ops.First (Target.HT.all);\n-               while Tgt_Node /= 0 loop\n-                  if Element_Keys.Find (Source.HT.all,\n-                                        TN (Tgt_Node).Element) /= 0 then\n-                     declare\n-                        X : constant Count_Type := Tgt_Node;\n-                     begin\n-                        Tgt_Node := HT_Ops.Next (Target.HT.all, Tgt_Node);\n-                        HT_Ops.Delete_Node_Sans_Free (Target.HT.all, X);\n-                        Free (Target.HT.all, X);\n-                     end;\n-                  else\n-                     Tgt_Node := HT_Ops.Next (Target.HT.all, Tgt_Node);\n-                  end if;\n-               end loop;\n-               return;\n+      if Src_Length >= Target.Length then\n+         Tgt_Node := HT_Ops.First (Target);\n+         while Tgt_Node /= 0 loop\n+            if Element_Keys.Find (Source,\n+                                  TN (Tgt_Node).Element) /= 0 then\n+               declare\n+                  X : constant Count_Type := Tgt_Node;\n+               begin\n+                  Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+                  HT_Ops.Delete_Node_Sans_Free (Target, X);\n+                  Free (Target, X);\n+               end;\n             else\n-               Src_Node := HT_Ops.First (Source.HT.all);\n-               Src_Last := 0;\n+               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n             end if;\n-         when Part =>\n-            Src_Node := Source.First;\n-            Src_Last := HT_Ops.Next (Source.HT.all, Source.Last);\n-      end case;\n+         end loop;\n+         return;\n+      else\n+         Src_Node := HT_Ops.First (Source);\n+         Src_Last := 0;\n+      end if;\n+\n       while Src_Node /= Src_Last loop\n          Tgt_Node := Element_Keys.Find\n-           (Target.HT.all, SN (Src_Node).Element);\n+           (Target, SN (Src_Node).Element);\n \n          if Tgt_Node /= 0 then\n-            HT_Ops.Delete_Node_Sans_Free (Target.HT.all, Tgt_Node);\n-            Free (Target.HT.all, Tgt_Node);\n+            HT_Ops.Delete_Node_Sans_Free (Target, Tgt_Node);\n+            Free (Target, Tgt_Node);\n          end if;\n \n-         Src_Node := HT_Ops.Next (Source.HT.all, Src_Node);\n+         Src_Node := HT_Ops.Next (Source, Src_Node);\n       end loop;\n    end Difference;\n \n    procedure Difference\n      (Left, Right : Set;\n-      Target      : in out Hash_Table_Type)\n+      Target      : in out Set)\n    is\n       procedure Process (L_Node : Count_Type);\n \n@@ -459,7 +383,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       -------------\n \n       procedure Process (L_Node : Count_Type) is\n-         E : Element_Type renames Left.HT.Nodes (L_Node).Element;\n+         E : Element_Type renames Left.Nodes (L_Node).Element;\n          X : Count_Type;\n          B : Boolean;\n \n@@ -473,29 +397,12 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       --  Start of processing for Difference\n \n    begin\n-      if Left.K = Plain then\n-         Iterate (Left.HT.all);\n-      else\n-\n-         if Left.Length = 0 then\n-            return;\n-         end if;\n-\n-         declare\n-            Node : Count_Type := Left.First;\n-         begin\n-            while Node /= Left.HT.Nodes (Left.Last).Next loop\n-               Process (Node);\n-               Node := HT_Ops.Next (Left.HT.all, Node);\n-            end loop;\n-         end;\n-      end if;\n+      Iterate (Left);\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n       C : Count_Type;\n       H : Hash_Type;\n-      S : Set (C, H);\n    begin\n       if Left'Address = Right'Address then\n          return Empty_Set;\n@@ -511,8 +418,9 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n       C := Length (Left);\n       H := Default_Modulus (C);\n-      Difference (Left, Right, Target => S.HT.all);\n-      return S;\n+      return S : Set (C, H) do\n+         Difference (Left, Right, Target => S);\n+      end return;\n    end Difference;\n \n    -------------\n@@ -530,130 +438,57 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       pragma Assert (Vet (Container, Position),\n                      \"bad cursor in function Element\");\n \n-      declare\n-         HT : Hash_Table_Type renames Container.HT.all;\n-      begin\n-         return HT.Nodes (Position.Node).Element;\n-      end;\n+      return Container.Nodes (Position.Node).Element;\n    end Element;\n \n    ---------------------\n    -- Equivalent_Sets --\n    ---------------------\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean is\n-   begin\n-      if Left.K = Plain and Right.K = Plain then\n-         declare\n-\n-            function Find_Equivalent_Key\n-              (R_HT   : Hash_Table_Type'Class;\n-               L_Node : Node_Type) return Boolean;\n-            pragma Inline (Find_Equivalent_Key);\n-\n-            function Is_Equivalent is\n-              new HT_Ops.Generic_Equal (Find_Equivalent_Key);\n-\n-            -------------------------\n-            -- Find_Equivalent_Key --\n-            -------------------------\n-\n-            function Find_Equivalent_Key\n-              (R_HT   : Hash_Table_Type'Class;\n-               L_Node : Node_Type) return Boolean\n-            is\n-               R_Index : constant Hash_Type :=\n-                 Element_Keys.Index (R_HT, L_Node.Element);\n-\n-               R_Node  : Count_Type := R_HT.Buckets (R_Index);\n-\n-               RN      : Nodes_Type renames R_HT.Nodes;\n-\n-            begin\n-               loop\n-                  if R_Node = 0 then\n-                     return False;\n-                  end if;\n-\n-                  if Equivalent_Elements (L_Node.Element,\n-                                          RN (R_Node).Element) then\n-                     return True;\n-                  end if;\n-\n-                  R_Node := HT_Ops.Next (R_HT, R_Node);\n-               end loop;\n-            end Find_Equivalent_Key;\n-\n-            --  Start of processing of Equivalent_Sets\n-\n-         begin\n-            return Is_Equivalent (Left.HT.all, Right.HT.all);\n-         end;\n-      else\n-         declare\n \n-            function Equal_Between\n-              (L    : Hash_Table_Type; R : Set;\n-               From : Count_Type; To : Count_Type) return Boolean;\n+      function Find_Equivalent_Key\n+        (R_HT   : Hash_Table_Type'Class;\n+         L_Node : Node_Type) return Boolean;\n+      pragma Inline (Find_Equivalent_Key);\n \n-            --  To and From are valid and Length are equal\n-            function Equal_Between\n-              (L    : Hash_Table_Type; R : Set;\n-               From : Count_Type; To : Count_Type) return Boolean\n-            is\n-               L_Index  : Hash_Type;\n-               To_Index : constant Hash_Type :=\n-                 Element_Keys.Index (L, L.Nodes (To).Element);\n-               L_Node   : Count_Type := From;\n+      function Is_Equivalent is\n+        new HT_Ops.Generic_Equal (Find_Equivalent_Key);\n \n-            begin\n-\n-               L_Index := Element_Keys.Index (L, L.Nodes (From).Element);\n-\n-               --  For each node of hash table L, search for an equivalent\n-               --  node in hash table R.\n-\n-               while L_Index /= To_Index or else\n-                 L_Node /= HT_Ops.Next (L, To) loop\n-                  pragma Assert (L_Node /= 0);\n+      -------------------------\n+      -- Find_Equivalent_Key --\n+      -------------------------\n \n-                  if Find (R, L.Nodes (L_Node).Element).Node = 0 then\n-                     return False;\n-                  end if;\n+      function Find_Equivalent_Key\n+        (R_HT   : Hash_Table_Type'Class;\n+         L_Node : Node_Type) return Boolean\n+      is\n+         R_Index : constant Hash_Type :=\n+           Element_Keys.Index (R_HT, L_Node.Element);\n \n-                  L_Node := L.Nodes (L_Node).Next;\n+         R_Node  : Count_Type := R_HT.Buckets (R_Index);\n \n-                  if L_Node = 0 then\n-                     --  We have exhausted the nodes in this bucket\n-                     --  Find the next bucket\n+         RN      : Nodes_Type renames R_HT.Nodes;\n \n-                     loop\n-                        L_Index := L_Index + 1;\n-                        L_Node := L.Buckets (L_Index);\n-                        exit when L_Node /= 0;\n-                     end loop;\n-                  end if;\n-               end loop;\n-\n-               return True;\n-            end Equal_Between;\n-\n-         begin\n-            if Length (Left) /= Length (Right) then\n+      begin\n+         loop\n+            if R_Node = 0 then\n                return False;\n             end if;\n-            if Length (Left) = 0 then\n+\n+            if Equivalent_Elements (L_Node.Element,\n+                                    RN (R_Node).Element) then\n                return True;\n             end if;\n-            if Left.K = Part then\n-               return Equal_Between (Left.HT.all, Right,\n-                                     Left.First, Left.Last);\n-            else\n-               return Equal_Between (Right.HT.all, Left,\n-                                     Right.First, Right.Last);\n-            end if;\n-         end;\n-      end if;\n+\n+            R_Node := HT_Ops.Next (R_HT, R_Node);\n+         end loop;\n+      end Find_Equivalent_Key;\n+\n+      --  Start of processing of Equivalent_Sets\n+\n+   begin\n+      return Is_Equivalent (Left, Right);\n    end Equivalent_Sets;\n \n    -------------------------\n@@ -680,8 +515,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n                      \"bad Right cursor in Equivalent_Elements\");\n \n       declare\n-         LN : Node_Type renames Left.HT.Nodes (CLeft.Node);\n-         RN : Node_Type renames Right.HT.Nodes (CRight.Node);\n+         LN : Node_Type renames Left.Nodes (CLeft.Node);\n+         RN : Node_Type renames Right.Nodes (CRight.Node);\n       begin\n          return Equivalent_Elements (LN.Element, RN.Element);\n       end;\n@@ -701,7 +536,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n                      \"Left cursor in Equivalent_Elements is bad\");\n \n       declare\n-         LN : Node_Type renames Left.HT.Nodes (CLeft.Node);\n+         LN : Node_Type renames Left.Nodes (CLeft.Node);\n       begin\n          return Equivalent_Elements (LN.Element, Right);\n       end;\n@@ -722,7 +557,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          \"Right cursor of Equivalent_Elements is bad\");\n \n       declare\n-         RN : Node_Type renames Right.HT.Nodes (CRight.Node);\n+         RN : Node_Type renames Right.Nodes (CRight.Node);\n       begin\n          return Equivalent_Elements (Left, RN.Element);\n       end;\n@@ -750,12 +585,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    is\n       X : Count_Type;\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-      Element_Keys.Delete_Key_Sans_Free (Container.HT.all, Item, X);\n-      Free (Container.HT.all, X);\n+      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n+      Free (Container, X);\n    end Exclude;\n \n    ----------\n@@ -766,121 +597,38 @@ package body Ada.Containers.Formal_Hashed_Sets is\n      (Container : Set;\n       Item      : Element_Type) return Cursor\n    is\n-   begin\n-      case Container.K is\n-         when Plain =>\n-            declare\n-               Node : constant Count_Type :=\n-                 Element_Keys.Find (Container.HT.all, Item);\n-\n-            begin\n-               if Node = 0 then\n-                  return No_Element;\n-               end if;\n-               return (Node => Node);\n-            end;\n-         when Part =>\n-            declare\n-               function Find_Between\n-                 (HT   : Hash_Table_Type;\n-                  Key  : Element_Type;\n-                  From : Count_Type;\n-                  To   : Count_Type) return Count_Type;\n-\n-               function Find_Between\n-                 (HT   : Hash_Table_Type;\n-                  Key  : Element_Type;\n-                  From : Count_Type;\n-                  To   : Count_Type) return Count_Type is\n-\n-                  Indx      : Hash_Type;\n-                  Indx_From : constant Hash_Type :=\n-                    Element_Keys.Index (HT,\n-                                        HT.Nodes (From).Element);\n-                  Indx_To   : constant Hash_Type :=\n-                    Element_Keys.Index (HT,\n-                                        HT.Nodes (To).Element);\n-                  Node      : Count_Type;\n-                  To_Node   : Count_Type;\n-\n-               begin\n-\n-                  Indx := Element_Keys.Index (HT, Key);\n-\n-                  if Indx < Indx_From or Indx > Indx_To then\n-                     return 0;\n-                  end if;\n-\n-                  if Indx = Indx_From then\n-                     Node := From;\n-                  else\n-                     Node := HT.Buckets (Indx);\n-                  end if;\n-\n-                  if Indx = Indx_To then\n-                     To_Node := HT.Nodes (To).Next;\n-                  else\n-                     To_Node := 0;\n-                  end if;\n-\n-                  while Node /= To_Node loop\n-                     if Equivalent_Keys (Key, HT.Nodes (Node)) then\n-                        return Node;\n-                     end if;\n-                     Node := HT.Nodes (Node).Next;\n-                  end loop;\n-                  return 0;\n-               end Find_Between;\n-            begin\n+      Node : constant Count_Type :=\n+        Element_Keys.Find (Container, Item);\n \n-               if Container.Length = 0 then\n-                  return No_Element;\n-               end if;\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+      return (Node => Node);\n \n-               return (Node => Find_Between (Container.HT.all, Item,\n-                       Container.First, Container.Last));\n-            end;\n-      end case;\n    end Find;\n \n    -----------\n    -- First --\n    -----------\n \n    function First (Container : Set) return Cursor is\n+      Node : constant Count_Type := HT_Ops.First (Container);\n    begin\n-      case Container.K is\n-         when Plain =>\n-            declare\n-               Node : constant Count_Type := HT_Ops.First (Container.HT.all);\n-\n-            begin\n-               if Node = 0 then\n-                  return No_Element;\n-               end if;\n-\n-               return (Node => Node);\n-            end;\n-         when Part =>\n-            declare\n-               Node : constant Count_Type := Container.First;\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n \n-            begin\n-               if Node = 0 then\n-                  return No_Element;\n-               end if;\n+      return (Node => Node);\n \n-               return (Node => Node);\n-            end;\n-      end case;\n    end First;\n \n    ----------\n    -- Free --\n    ----------\n \n    procedure Free\n-     (HT : in out Hash_Table_Type;\n+     (HT : in out Set;\n       X  : Count_Type)\n    is\n    begin\n@@ -893,7 +641,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    ----------------------\n \n    procedure Generic_Allocate\n-     (HT   : in out Hash_Table_Type;\n+     (HT   : in out Set;\n       Node : out Count_Type)\n    is\n \n@@ -912,60 +660,10 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    function Has_Element (Container : Set; Position : Cursor) return Boolean is\n    begin\n       if Position.Node = 0 or else\n-        not Container.HT.Nodes (Position.Node).Has_Element then\n+        not Container.Nodes (Position.Node).Has_Element then\n          return False;\n       end if;\n-\n-      if Container.K = Plain then\n-         return True;\n-      end if;\n-\n-      declare\n-         Lst_Index : constant Hash_Type :=\n-           Element_Keys.Index (Container.HT.all,\n-                               Container.HT.Nodes\n-                                 (Container.Last).Element);\n-         Fst_Index : constant Hash_Type :=\n-           Element_Keys.Index (Container.HT.all,\n-                               Container.HT.Nodes\n-                                 (Container.First).Element);\n-         Index     : constant Hash_Type :=\n-           Element_Keys.Index (Container.HT.all,\n-                               Container.HT.Nodes\n-                                 (Position.Node).Element);\n-         Lst_Node  : Count_Type;\n-         Node      : Count_Type;\n-      begin\n-\n-         if Index < Fst_Index or Index > Lst_Index then\n-            return False;\n-         end if;\n-\n-         if Index > Fst_Index and Index < Lst_Index then\n-            return True;\n-         end if;\n-\n-         if Index = Fst_Index then\n-            Node := Container.First;\n-         else\n-            Node := Container.HT.Buckets (Index);\n-         end if;\n-\n-         if Index = Lst_Index then\n-            Lst_Node := Container.HT.Nodes (Container.Last).Next;\n-         else\n-            Lst_Node := 0;\n-         end if;\n-\n-         while Node /= Lst_Node loop\n-            if Position.Node = Node then\n-               return True;\n-            end if;\n-            Node := HT_Ops.Next (Container.HT.all, Node);\n-         end loop;\n-\n-         return False;\n-      end;\n+      return True;\n    end Has_Element;\n \n    ---------------\n@@ -992,12 +690,12 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.HT.Lock > 0 then\n+         if Container.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n-         Container.HT.Nodes (Position.Node).Element := New_Item;\n+         Container.Nodes (Position.Node).Element := New_Item;\n       end if;\n    end Include;\n \n@@ -1012,12 +710,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       Inserted  : out Boolean)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      Insert (Container.HT.all, New_Item, Position.Node, Inserted);\n+      Insert (Container, New_Item, Position.Node, Inserted);\n    end Insert;\n \n    procedure Insert\n@@ -1037,7 +730,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    end Insert;\n \n    procedure Insert\n-     (Container : in out Hash_Table_Type;\n+     (Container : in out Set;\n       New_Item  : Element_Type;\n       Node      : out Count_Type;\n       Inserted  : out Boolean)\n@@ -1091,49 +784,45 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       Source : Set)\n    is\n       Tgt_Node : Count_Type;\n-      TN       : Nodes_Type renames Target.HT.Nodes;\n+      TN       : Nodes_Type renames Target.Nodes;\n \n    begin\n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Target'Address = Source'Address then\n          return;\n       end if;\n \n-      if Source.HT.Length = 0 then\n+      if Source.Length = 0 then\n          Clear (Target);\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n+      if Target.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n-      Tgt_Node := HT_Ops.First (Target.HT.all);\n+      Tgt_Node := HT_Ops.First (Target);\n       while Tgt_Node /= 0 loop\n          if Find (Source, TN (Tgt_Node).Element).Node /= 0 then\n-            Tgt_Node := HT_Ops.Next (Target.HT.all, Tgt_Node);\n+            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n \n          else\n             declare\n                X : constant Count_Type := Tgt_Node;\n             begin\n-               Tgt_Node := HT_Ops.Next (Target.HT.all, Tgt_Node);\n-               HT_Ops.Delete_Node_Sans_Free (Target.HT.all, X);\n-               Free (Target.HT.all, X);\n+               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target, X);\n+               Free (Target, X);\n             end;\n          end if;\n       end loop;\n    end Intersection;\n \n    procedure Intersection\n-     (Left   : Hash_Table_Type;\n+     (Left   : Set;\n       Right  : Set;\n-      Target : in out Hash_Table_Type)\n+      Target : in out Set)\n    is\n       procedure Process (L_Node : Count_Type);\n \n@@ -1165,8 +854,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    function Intersection (Left, Right : Set) return Set is\n       C : Count_Type;\n       H : Hash_Type;\n-      X : Count_Type;\n-      B : Boolean;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -1177,19 +864,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       H := Default_Modulus (C);\n       return S : Set (C, H) do\n          if Length (Left) /= 0 and Length (Right) /= 0 then\n-            if Left.K = Plain then\n-               Intersection (Left.HT.all, Right, Target => S.HT.all);\n-            else\n-               C := Left.First;\n-               while C /= Left.HT.Nodes (Left.Last).Next loop\n-                  pragma Assert (C /= 0);\n-                  if Find (Right, Left.HT.Nodes (C).Element).Node /= 0 then\n-                     Insert (S.HT.all, Left.HT.Nodes (C).Element, X, B);\n-                     pragma Assert (B);\n-                  end if;\n-                  C := Left.HT.Nodes (C).Next;\n-               end loop;\n-            end if;\n+               Intersection (Left, Right, Target => S);\n          end if;\n       end return;\n    end Intersection;\n@@ -1207,7 +882,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    -- Is_In --\n    -----------\n \n-   function Is_In (HT : HT_Types.Hash_Table_Type;\n+   function Is_In (HT : Set;\n                    Key : Node_Type) return Boolean is\n    begin\n       return Element_Keys.Find (HT, Key.Element) /= 0;\n@@ -1219,8 +894,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n       Subset_Node  : Count_Type;\n-      Subset_Nodes : Nodes_Type renames Subset.HT.Nodes;\n-      To_Node      : Count_Type;\n+      Subset_Nodes : Nodes_Type renames Subset.Nodes;\n    begin\n       if Subset'Address = Of_Set'Address then\n          return True;\n@@ -1232,13 +906,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n       Subset_Node := First (Subset).Node;\n \n-      if Subset.K = Plain then\n-         To_Node := 0;\n-      else\n-         To_Node := Subset.HT.Nodes (Subset.Last).Next;\n-      end if;\n-\n-      while Subset_Node /= To_Node loop\n+      while Subset_Node /= 0 loop\n          declare\n             N : Node_Type renames Subset_Nodes (Subset_Node);\n             E : Element_Type renames N.Element;\n@@ -1249,7 +917,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n             end if;\n          end;\n \n-         Subset_Node := HT_Ops.Next (Subset.HT.all, Subset_Node);\n+         Subset_Node := HT_Ops.Next (Subset, Subset_Node);\n       end loop;\n \n       return True;\n@@ -1279,32 +947,15 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          Process (Container, (Node => Node));\n       end Process_Node;\n \n-      B : Natural renames Container'Unrestricted_Access.HT.Busy;\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n \n       --  Start of processing for Iterate\n \n    begin\n       B := B + 1;\n \n       begin\n-         case Container.K is\n-            when Plain =>\n-               Iterate (Container.HT.all);\n-            when Part =>\n-\n-               if Container.Length = 0 then\n-                  return;\n-               end if;\n-\n-               declare\n-                  Node : Count_Type := Container.First;\n-               begin\n-                  while Node /= Container.HT.Nodes (Container.Last).Next loop\n-                     Process_Node (Node);\n-                     Node := HT_Ops.Next (Container.HT.all, Node);\n-                  end loop;\n-               end;\n-         end case;\n+         Iterate (Container);\n       exception\n          when others =>\n             B := B - 1;\n@@ -1319,37 +970,24 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    ----------\n \n    function Left (Container : Set; Position : Cursor) return Set is\n-      Lst : Count_Type;\n-      Fst : constant Count_Type := First (Container).Node;\n-      L   : Count_Type := 0;\n-      C   : Count_Type := Fst;\n+      Curs : Cursor := Position;\n+      C : Set (Container.Capacity, Container.Modulus) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n    begin\n-      while C /= Position.Node loop\n-         if C = 0 or C = Container.Last then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-         Lst := C;\n-         C := HT_Ops.Next (Container.HT.all, C);\n-         L := L + 1;\n-      end loop;\n-      if L = 0 then\n-         return (Capacity => Container.Capacity,\n-                 Modulus  => Container.Modulus,\n-                 K        => Part,\n-                 HT       => Container.HT,\n-                 Length   => 0,\n-                 First    => 0,\n-                 Last     => 0);\n-      else\n-         return (Capacity => Container.Capacity,\n-                 Modulus  => Container.Modulus,\n-                 K        => Part,\n-                 HT       => Container.HT,\n-                 Length   => L,\n-                 First    => Fst,\n-                 Last     => Lst);\n+      if Curs = No_Element then\n+         return C;\n+      end if;\n+      if not Has_Element (Container, Curs) then\n+         raise Constraint_Error;\n       end if;\n+\n+      while Curs.Node /= 0 loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+      return C;\n    end Left;\n \n    ------------\n@@ -1358,30 +996,19 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function Length (Container : Set) return Count_Type is\n    begin\n-      case Container.K is\n-         when Plain =>\n-            return Container.HT.Length;\n-         when Part =>\n-            return Container.Length;\n-      end case;\n+      return Container.Length;\n    end Length;\n \n    ----------\n    -- Move --\n    ----------\n \n    procedure Move (Target : in out Set; Source : in out Set) is\n-      HT   : HT_Types.Hash_Table_Type renames Source.HT.all;\n-      NN   : HT_Types.Nodes_Type renames HT.Nodes;\n+      NN   : HT_Types.Nodes_Type renames Source.Nodes;\n       X, Y : Count_Type;\n \n    begin\n \n-      if Target.K /= Plain or Source.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -1391,25 +1018,25 @@ package body Ada.Containers.Formal_Hashed_Sets is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      if HT.Busy > 0 then\n+      if Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n       Clear (Target);\n \n-      if HT.Length = 0 then\n+      if Source.Length = 0 then\n          return;\n       end if;\n \n-      X := HT_Ops.First (HT);\n+      X := HT_Ops.First (Source);\n       while X /= 0 loop\n          Insert (Target, NN (X).Element);  -- optimize???\n \n-         Y := HT_Ops.Next (HT, X);\n+         Y := HT_Ops.Next (Source, X);\n \n-         HT_Ops.Delete_Node_Sans_Free (HT, X);\n-         Free (HT, X);\n+         HT_Ops.Delete_Node_Sans_Free (Source, X);\n+         Free (Source, X);\n \n          X := Y;\n       end loop;\n@@ -1424,25 +1051,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       return Node.Next;\n    end Next;\n \n-   function Next_Unchecked\n-     (Container : Set;\n-      Position  : Cursor) return Cursor\n-   is\n-      HT   : Hash_Table_Type renames Container.HT.all;\n-      Node : constant Count_Type := HT_Ops.Next (HT, Position.Node);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if Container.K = Part and then Container.Last = Position.Node then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Next_Unchecked;\n-\n    function Next (Container : Set; Position : Cursor) return Cursor is\n    begin\n       if Position.Node = 0 then\n@@ -1456,7 +1064,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in Next\");\n \n-      return Next_Unchecked (Container, Position);\n+      return (Node => HT_Ops.Next (Container, Position.Node));\n    end Next;\n \n    procedure Next (Container : Set; Position : in out Cursor) is\n@@ -1470,8 +1078,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    function Overlap (Left, Right : Set) return Boolean is\n       Left_Node  : Count_Type;\n-      Left_Nodes : Nodes_Type renames Left.HT.Nodes;\n-      To_Node    : Count_Type;\n+      Left_Nodes : Nodes_Type renames Left.Nodes;\n    begin\n       if Length (Right) = 0 or Length (Left) = 0 then\n          return False;\n@@ -1483,13 +1090,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n       Left_Node := First (Left).Node;\n \n-      if Left.K = Plain then\n-         To_Node := 0;\n-      else\n-         To_Node := Left.HT.Nodes (Left.Last).Next;\n-      end if;\n-\n-      while Left_Node /= To_Node loop\n+      while Left_Node /= 0 loop\n          declare\n             N : Node_Type renames Left_Nodes (Left_Node);\n             E : Element_Type renames N.Element;\n@@ -1500,7 +1101,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n             end if;\n          end;\n \n-         Left_Node := HT_Ops.Next (Left.HT.all, Left_Node);\n+         Left_Node := HT_Ops.Next (Left, Left_Node);\n       end loop;\n \n       return False;\n@@ -1516,11 +1117,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       Process   : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element has no element\";\n@@ -1529,17 +1125,16 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       pragma Assert (Vet (Container, Position), \"bad cursor in Query_Element\");\n \n       declare\n-         HT : Hash_Table_Type renames Container.HT.all;\n \n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n \n       begin\n          B := B + 1;\n          L := L + 1;\n \n          begin\n-            Process (HT.Nodes (Position.Node).Element);\n+            Process (Container.Nodes (Position.Node).Element);\n          exception\n             when others =>\n                L := L - 1;\n@@ -1589,26 +1184,14 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          --  Start of processing for Read_Node\n \n       begin\n-         Allocate (Container.HT.all, Node);\n+         Allocate (Container, Node);\n          return Node;\n       end Read_Node;\n \n       --  Start of processing for Read\n-      Result : HT_Access;\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error;\n-      end if;\n \n-      if Container.HT = null then\n-         Result := new HT_Types.Hash_Table_Type (Container.Capacity,\n-                                                 Container.Modulus);\n-      else\n-         Result := Container.HT;\n-      end if;\n-\n-      Read_Nodes (Stream, Result.all);\n-      Container.HT := Result;\n+      Read_Nodes (Stream, Container);\n    end Read;\n \n    procedure Read\n@@ -1628,25 +1211,21 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       New_Item  : Element_Type)\n    is\n       Node : constant Count_Type :=\n-        Element_Keys.Find (Container.HT.all, New_Item);\n+        Element_Keys.Find (Container, New_Item);\n \n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      if Container.HT.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (set is locked)\";\n       end if;\n \n-      Container.HT.Nodes (Node).Element := New_Item;\n+      Container.Nodes (Node).Element := New_Item;\n    end Replace;\n \n    ---------------------\n@@ -1659,10 +1238,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n@@ -1672,7 +1247,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       pragma Assert (Vet (Container, Position),\n                      \"bad cursor in Replace_Element\");\n \n-      Replace_Element (Container.HT.all, Position.Node, New_Item);\n+      Replace_Element (Container, Position.Node, New_Item);\n    end Replace_Element;\n \n    ----------------------\n@@ -1684,10 +1259,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       Capacity  : Count_Type)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n       if Capacity > Container.Capacity then\n          raise Constraint_Error with \"requested capacity is too large\";\n       end if;\n@@ -1698,50 +1269,25 @@ package body Ada.Containers.Formal_Hashed_Sets is\n    -----------\n \n    function Right (Container : Set; Position : Cursor) return Set is\n-      Last : Count_Type;\n-      Lst  : Count_Type;\n-      L    : Count_Type := 0;\n-      C    : Count_Type := Position.Node;\n+      Curs : Cursor := First (Container);\n+      C : Set (Container.Capacity, Container.Modulus) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n    begin\n-\n-      if C = 0 then\n-         return (Capacity => Container.Capacity,\n-                 Modulus  => Container.Modulus,\n-                 K        => Part,\n-                 HT       => Container.HT,\n-                 Length   => 0,\n-                 First    => 0,\n-                 Last     => 0);\n-      end if;\n-\n-      if Container.K = Plain then\n-         Lst := 0;\n-      else\n-         Lst := HT_Ops.Next (Container.HT.all, Container.Last);\n+      if Curs = No_Element then\n+         Clear (C);\n+         return C;\n       end if;\n-\n-      if C = Lst then\n-         raise Constraint_Error with\n-           \"Position cursor has no element\";\n+      if Position /= No_Element and not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n       end if;\n \n-      while C /= Lst loop\n-         if C = 0 then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-         Last := C;\n-         C := HT_Ops.Next (Container.HT.all, C);\n-         L := L + 1;\n+      while Curs.Node /= Position.Node loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n       end loop;\n-\n-      return (Capacity => Container.Capacity,\n-              Modulus  => Container.Modulus,\n-              K        => Part,\n-              HT       => Container.HT,\n-              Length   => L,\n-              First    => Position.Node,\n-              Last     => Last);\n+      return C;\n    end Right;\n \n    ------------------\n@@ -1776,12 +1322,12 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n       while CuL.Node /= 0 or CuR.Node /= 0 loop\n          if CuL.Node /= CuR.Node or else\n-           Left.HT.Nodes (CuL.Node).Element /=\n-           Right.HT.Nodes (CuR.Node).Element then\n+           Left.Nodes (CuL.Node).Element /=\n+           Right.Nodes (CuR.Node).Element then\n             return False;\n          end if;\n-         CuL := Next_Unchecked (Left, CuL);\n-         CuR := Next_Unchecked (Right, CuR);\n+         CuL := Next (Left, CuL);\n+         CuR := Next (Right, CuR);\n       end loop;\n \n       return True;\n@@ -1806,26 +1352,22 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       -------------\n \n       procedure Process (Source_Node : Count_Type) is\n-         N : Node_Type renames Source.HT.Nodes (Source_Node);\n+         N : Node_Type renames Source.Nodes (Source_Node);\n          X : Count_Type;\n          B : Boolean;\n \n       begin\n-         if Is_In (Target.HT.all, N) then\n+         if Is_In (Target, N) then\n             Delete (Target, N.Element);\n          else\n-            Insert (Target.HT.all, N.Element, X, B);\n+            Insert (Target, N.Element, X, B);\n             pragma Assert (B);\n          end if;\n       end Process;\n \n       --  Start of processing for Symmetric_Difference\n \n    begin\n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Target'Address = Source'Address then\n          Clear (Target);\n@@ -1837,28 +1379,11 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n+      if Target.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (set is busy)\";\n       end if;\n-\n-      if Source.K = Plain then\n-         Iterate (Source.HT.all);\n-      else\n-\n-         if Source.Length = 0 then\n-            return;\n-         end if;\n-\n-         declare\n-            Node : Count_Type := Source.First;\n-         begin\n-            while Node /= Source.HT.Nodes (Source.Last).Next loop\n-               Process (Node);\n-               Node := HT_Ops.Next (Source.HT.all, Node);\n-            end loop;\n-         end;\n-      end if;\n+      Iterate (Source);\n \n    end Symmetric_Difference;\n \n@@ -1882,8 +1407,8 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       C := Length (Left) + Length (Right);\n       H := Default_Modulus (C);\n       return S : Set (C, H) do\n-         Difference (Left, Right, S.HT.all);\n-         Difference (Right, Left, S.HT.all);\n+         Difference (Left, Right, S);\n+         Difference (Right, Left, S);\n       end return;\n    end Symmetric_Difference;\n \n@@ -1897,7 +1422,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n    begin\n       return S : Set (Capacity => 1, Modulus => 1) do\n-         Insert (S.HT.all, New_Item, X, B);\n+         Insert (S, New_Item, X, B);\n          pragma Assert (B);\n       end return;\n    end To_Set;\n@@ -1920,51 +1445,29 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       -------------\n \n       procedure Process (Src_Node : Count_Type) is\n-         N : Node_Type renames Source.HT.Nodes (Src_Node);\n+         N : Node_Type renames Source.Nodes (Src_Node);\n          E : Element_Type renames N.Element;\n \n          X : Count_Type;\n          B : Boolean;\n \n       begin\n-         Insert (Target.HT.all, E, X, B);\n+         Insert (Target, E, X, B);\n       end Process;\n \n       --  Start of processing for Union\n \n    begin\n \n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n+      if Target.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (set is busy)\";\n       end if;\n-\n-      if Source.K = Plain then\n-         Iterate (Source.HT.all);\n-      else\n-\n-         if Source.Length = 0 then\n-            return;\n-         end if;\n-\n-         declare\n-            Node : Count_Type := Source.First;\n-         begin\n-            while Node /= Source.HT.Nodes (Source.Last).Next loop\n-               Process (Node);\n-               Node := HT_Ops.Next (Source.HT.all, Node);\n-            end loop;\n-         end;\n-      end if;\n+      Iterate (Source);\n    end Union;\n \n    function Union (Left, Right : Set) return Set is\n@@ -2004,7 +1507,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n       declare\n          S : Set renames Container;\n-         N : Nodes_Type renames S.HT.Nodes;\n+         N : Nodes_Type renames S.Nodes;\n          X : Count_Type;\n \n       begin\n@@ -2020,7 +1523,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n             return False;\n          end if;\n \n-         X := S.HT.Buckets (Element_Keys.Index (S.HT.all,\n+         X := S.Buckets (Element_Keys.Index (S,\n            N (Position.Node).Element));\n \n          for J in 1 .. S.Length loop\n@@ -2074,7 +1577,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       --  Start of processing for Write\n \n    begin\n-      Write_Nodes (Stream, Container.HT.all);\n+      Write_Nodes (Stream, Container);\n    end Write;\n \n    procedure Write\n@@ -2131,18 +1634,14 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          X : Count_Type;\n \n       begin\n-         if Container.K /= Plain then\n-            raise Constraint_Error\n-              with \"Can't modify part of container\";\n-         end if;\n \n-         Key_Keys.Delete_Key_Sans_Free (Container.HT.all, Key, X);\n+         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n \n          if X = 0 then\n             raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n-         Free (Container.HT.all, X);\n+         Free (Container, X);\n       end Delete;\n \n       -------------\n@@ -2160,7 +1659,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n             raise Constraint_Error with \"key not in map\";\n          end if;\n \n-         return Container.HT.Nodes (Node).Element;\n+         return Container.Nodes (Node).Element;\n       end Element;\n \n       -------------------------\n@@ -2185,13 +1684,9 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       is\n          X : Count_Type;\n       begin\n-         if Container.K /= Plain then\n-            raise Constraint_Error\n-              with \"Can't modify part of container\";\n-         end if;\n \n-         Key_Keys.Delete_Key_Sans_Free (Container.HT.all, Key, X);\n-         Free (Container.HT.all, X);\n+         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+         Free (Container, X);\n       end Exclude;\n \n       ----------\n@@ -2202,82 +1697,16 @@ package body Ada.Containers.Formal_Hashed_Sets is\n         (Container : Set;\n          Key       : Key_Type) return Cursor\n       is\n-      begin\n-         if Container.K = Plain then\n-            declare\n-               Node : constant Count_Type :=\n-                 Key_Keys.Find (Container.HT.all, Key);\n-\n-            begin\n-               if Node = 0 then\n-                  return No_Element;\n-               end if;\n-\n-               return (Node => Node);\n-            end;\n-         else\n-            declare\n-               function Find_Between\n-                 (HT   : Hash_Table_Type;\n-                  Key  : Key_Type;\n-                  From : Count_Type;\n-                  To   : Count_Type) return Count_Type;\n-\n-               function Find_Between\n-                 (HT   : Hash_Table_Type;\n-                  Key  : Key_Type;\n-                  From : Count_Type;\n-                  To   : Count_Type) return Count_Type is\n-\n-                  Indx      : Hash_Type;\n-                  Indx_From : constant Hash_Type :=\n-                    Key_Keys.Index (HT, Generic_Keys.Key\n-                                    (HT.Nodes (From).Element));\n-                  Indx_To   : constant Hash_Type :=\n-                    Key_Keys.Index (HT, Generic_Keys.Key\n-                                    (HT.Nodes (To).Element));\n-                  Node      : Count_Type;\n-                  To_Node   : Count_Type;\n-\n-               begin\n-\n-                  Indx := Key_Keys.Index (HT, Key);\n-\n-                  if Indx < Indx_From or Indx > Indx_To then\n-                     return 0;\n-                  end if;\n-\n-                  if Indx = Indx_From then\n-                     Node := From;\n-                  else\n-                     Node := HT.Buckets (Indx);\n-                  end if;\n-\n-                  if Indx = Indx_To then\n-                     To_Node := HT.Nodes (To).Next;\n-                  else\n-                     To_Node := 0;\n-                  end if;\n-\n-                  while Node /= To_Node loop\n-                     if Equivalent_Key_Node (Key, HT.Nodes (Node)) then\n-                        return Node;\n-                     end if;\n-                     Node := HT.Nodes (Node).Next;\n-                  end loop;\n+         Node : constant Count_Type :=\n+           Key_Keys.Find (Container, Key);\n \n-                  return 0;\n-               end Find_Between;\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n \n-            begin\n-               if Container.Length = 0 then\n-                  return No_Element;\n-               end if;\n+         return (Node => Node);\n \n-               return (Node => Find_Between (Container.HT.all, Key,\n-                       Container.First, Container.Last));\n-            end;\n-         end if;\n       end Find;\n \n       ---------\n@@ -2295,8 +1724,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n                         \"bad cursor in function Key\");\n \n          declare\n-            HT : Hash_Table_Type renames Container.HT.all;\n-            N  : Node_Type renames HT.Nodes (Position.Node);\n+            N  : Node_Type renames Container.Nodes (Position.Node);\n          begin\n             return Key (N.Element);\n          end;\n@@ -2311,24 +1739,16 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          Key       : Key_Type;\n          New_Item  : Element_Type)\n       is\n+         Node : constant Count_Type :=\n+           Key_Keys.Find (Container, Key);\n+\n       begin\n-         if Container.K /= Plain then\n-            raise Constraint_Error\n-              with \"Can't modify part of container\";\n+         if Node = 0 then\n+            raise Constraint_Error with\n+              \"attempt to replace key not in set\";\n          end if;\n \n-         declare\n-            Node : constant Count_Type :=\n-              Key_Keys.Find (Container.HT.all, Key);\n-\n-         begin\n-            if Node = 0 then\n-               raise Constraint_Error with\n-                 \"attempt to replace key not in set\";\n-            end if;\n-\n-            Replace_Element (Container.HT.all, Node, New_Item);\n-         end;\n+         Replace_Element (Container, Node, New_Item);\n       end Replace;\n \n       -----------------------------------\n@@ -2342,43 +1762,28 @@ package body Ada.Containers.Formal_Hashed_Sets is\n            procedure (Element : in out Element_Type))\n       is\n          Indx : Hash_Type;\n-         N    : Nodes_Type renames Container.HT.Nodes;\n+         N    : Nodes_Type renames Container.Nodes;\n \n       begin\n \n-         if Container.K /= Plain then\n-            raise Constraint_Error\n-              with \"Can't modify part of container\";\n-         end if;\n-\n          if Position.Node = 0 then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";\n          end if;\n \n-         --  ???\n-         --  if HT.Buckets = null\n-         --    or else HT.Buckets'Length = 0\n-         --    or else HT.Length = 0\n-         --    or else Position.Node.Next = Position.Node\n-         --  then\n-         --     raise Program_Error with\n-         --        \"Position cursor is bad (set is empty)\";\n-         --  end if;\n-\n          pragma Assert\n            (Vet (Container, Position),\n             \"bad cursor in Update_Element_Preserving_Key\");\n \n          --  Record bucket now, in case key is changed.\n-         Indx := HT_Ops.Index (Container.HT.Buckets, N (Position.Node));\n+         Indx := HT_Ops.Index (Container.Buckets, N (Position.Node));\n \n          declare\n             E : Element_Type renames N (Position.Node).Element;\n             K : constant Key_Type := Key (E);\n \n-            B : Natural renames Container.HT.Busy;\n-            L : Natural renames Container.HT.Lock;\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n \n          begin\n             B := B + 1;\n@@ -2404,12 +1809,12 @@ package body Ada.Containers.Formal_Hashed_Sets is\n \n          --  Key was modified, so remove this node from set.\n \n-         if Container.HT.Buckets (Indx) = Position.Node then\n-            Container.HT.Buckets (Indx) := N (Position.Node).Next;\n+         if Container.Buckets (Indx) = Position.Node then\n+            Container.Buckets (Indx) := N (Position.Node).Next;\n \n          else\n             declare\n-               Prev : Count_Type := Container.HT.Buckets (Indx);\n+               Prev : Count_Type := Container.Buckets (Indx);\n \n             begin\n                while N (Prev).Next /= Position.Node loop\n@@ -2426,7 +1831,7 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          end if;\n \n          Container.Length := Container.Length - 1;\n-         Free (Container.HT.all, Position.Node);\n+         Free (Container, Position.Node);\n \n          raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;"}, {"sha": "ea77968afea938a309d4a13d6ede6ddeec76abb0", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -257,19 +257,8 @@ private\n    package HT_Types is new\n      Ada.Containers.Hash_Tables.Generic_Bounded_Hash_Table_Types (Node_Type);\n \n-   type HT_Access is access all HT_Types.Hash_Table_Type;\n-\n-   type Kind is (Plain, Part);\n-\n-   type Set (Capacity : Count_Type; Modulus : Hash_Type) is tagged record\n-      HT     : HT_Access :=\n-                 new HT_Types.Hash_Table_Type'(Capacity, Modulus,\n-                                               others => <>);\n-      K      : Kind := Plain;\n-      Length : Count_Type := 0;\n-      First  : Count_Type := 0;\n-      Last   : Count_Type := 0;\n-   end record;\n+   type Set (Capacity : Count_Type; Modulus : Hash_Type) is\n+      new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n \n    use HT_Types;\n    use Ada.Streams;"}, {"sha": "ecd8de5f87c90fc6c91a56287e9cef77dc893069", "filename": "gcc/ada/a-cforma.adb", "status": "modified", "additions": 209, "deletions": 526, "changes": 735, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--          Copyright (C) 2010-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -80,7 +80,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n      (Tree : in out Tree_Types.Tree_Type'Class;\n       Node : out Count_Type);\n \n-   procedure Free (Tree : in out Tree_Types.Tree_Type; X : Count_Type);\n+   procedure Free (Tree : in out Map; X : Count_Type);\n \n    function Is_Greater_Key_Node\n      (Left  : Key_Type;\n@@ -92,10 +92,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       Right : Node_Type) return Boolean;\n    pragma Inline (Is_Less_Key_Node);\n \n-   function Next_Unchecked\n-     (Container : Map;\n-      Position  : Count_Type) return Count_Type;\n-\n    --------------------------\n    -- Local Instantiations --\n    --------------------------\n@@ -133,15 +129,15 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          return True;\n       end if;\n \n-      Lst := Next (Left.Tree.all, Last (Left).Node);\n+      Lst := Next (Left, Last (Left).Node);\n       while Node /= Lst loop\n-         ENode := Find (Right, Left.Tree.Nodes (Node).Key).Node;\n+         ENode := Find (Right, Left.Nodes (Node).Key).Node;\n          if ENode = 0 or else\n-           Left.Tree.Nodes (Node).Element /= Right.Tree.Nodes (ENode).Element\n+           Left.Nodes (Node).Element /= Right.Nodes (ENode).Element\n          then\n             return False;\n          end if;\n-         Node := Next (Left.Tree.all, Node);\n+         Node := Next (Left, Node);\n       end loop;\n \n       return True;\n@@ -163,7 +159,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       --------------------\n \n       procedure Append_Element (Source_Node : Count_Type) is\n-         SN : Node_Type renames Source.Tree.Nodes (Source_Node);\n+         SN : Node_Type renames Source.Nodes (Source_Node);\n \n          procedure Set_Element (Node : in out Node_Type);\n          pragma Inline (Set_Element);\n@@ -193,7 +189,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n             Result : Count_Type;\n \n          begin\n-            Allocate (Target.Tree.all, Result);\n+            Allocate (Target, Result);\n             return Result;\n          end New_Node;\n \n@@ -213,7 +209,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n       begin\n          Unconditional_Insert_Avec_Hint\n-           (Tree  => Target.Tree.all,\n+           (Tree  => Target,\n             Hint  => 0,\n             Key   => SN.Key,\n             Node  => Target_Node);\n@@ -222,10 +218,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    --  Start of processing for Assign\n \n    begin\n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Target'Address = Source'Address then\n          return;\n@@ -235,55 +227,25 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n       end if;\n \n-      Tree_Operations.Clear_Tree (Target.Tree.all);\n-\n-      if Source.K = Plain then\n-         Append_Elements (Source.Tree.all);\n-      else\n-         declare\n-            X : Count_Type;\n-         begin\n-            X := Source.First;\n-            while X /= Next (Source.Tree.all, Source.Last) loop\n-               Append_Element (X);\n-               X := Next (Source.Tree.all, X);\n-            end loop;\n-         end;\n-      end if;\n+      Tree_Operations.Clear_Tree (Target);\n+      Append_Elements (Source);\n    end Assign;\n \n    -------------\n    -- Ceiling --\n    -------------\n \n    function Ceiling (Container : Map; Key : Key_Type) return Cursor is\n-   begin\n \n-      if Container.K = Part then\n-         if Container.Length = 0 then\n-            return No_Element;\n-         end if;\n+      Node : constant Count_Type :=\n+        Key_Ops.Ceiling (Container, Key);\n \n-         if Key < Container.Tree.Nodes (Container.First).Key then\n-            return (Node => Container.First);\n-         end if;\n-\n-         if Container.Tree.Nodes (Container.Last).Key < Key then\n-            return No_Element;\n-         end if;\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n       end if;\n \n-      declare\n-         Node : constant Count_Type :=\n-                  Key_Ops.Ceiling (Container.Tree.all, Key);\n-\n-      begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-      end;\n+      return (Node => Node);\n    end Ceiling;\n \n    -----------\n@@ -292,12 +254,8 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    procedure Clear (Container : in out Map) is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n-      Tree_Operations.Clear_Tree (Container.Tree.all);\n+      Tree_Operations.Clear_Tree (Container);\n    end Clear;\n \n    -----------\n@@ -325,56 +283,38 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    function Copy (Source : Map; Capacity : Count_Type := 0) return Map is\n       Node : Count_Type := 1;\n       N    : Count_Type;\n-      Cu   : Cursor;\n    begin\n       return Target : Map (Count_Type'Max (Source.Capacity, Capacity)) do\n          if Length (Source) > 0 then\n-            Target.Tree.Length := Source.Tree.Length;\n-            Target.Tree.Root := Source.Tree.Root;\n-            Target.Tree.First := Source.Tree.First;\n-            Target.Tree.Last := Source.Tree.Last;\n-            Target.Tree.Free := Source.Tree.Free;\n+            Target.Length := Source.Length;\n+            Target.Root := Source.Root;\n+            Target.First := Source.First;\n+            Target.Last := Source.Last;\n+            Target.Free := Source.Free;\n \n             while Node <= Source.Capacity loop\n-               Target.Tree.Nodes (Node).Element :=\n-                 Source.Tree.Nodes (Node).Element;\n-               Target.Tree.Nodes (Node).Key :=\n-                 Source.Tree.Nodes (Node).Key;\n-               Target.Tree.Nodes (Node).Parent :=\n-                 Source.Tree.Nodes (Node).Parent;\n-               Target.Tree.Nodes (Node).Left :=\n-                 Source.Tree.Nodes (Node).Left;\n-               Target.Tree.Nodes (Node).Right :=\n-                 Source.Tree.Nodes (Node).Right;\n-               Target.Tree.Nodes (Node).Color :=\n-                 Source.Tree.Nodes (Node).Color;\n-               Target.Tree.Nodes (Node).Has_Element :=\n-                 Source.Tree.Nodes (Node).Has_Element;\n+               Target.Nodes (Node).Element :=\n+                 Source.Nodes (Node).Element;\n+               Target.Nodes (Node).Key :=\n+                 Source.Nodes (Node).Key;\n+               Target.Nodes (Node).Parent :=\n+                 Source.Nodes (Node).Parent;\n+               Target.Nodes (Node).Left :=\n+                 Source.Nodes (Node).Left;\n+               Target.Nodes (Node).Right :=\n+                 Source.Nodes (Node).Right;\n+               Target.Nodes (Node).Color :=\n+                 Source.Nodes (Node).Color;\n+               Target.Nodes (Node).Has_Element :=\n+                 Source.Nodes (Node).Has_Element;\n                Node := Node + 1;\n             end loop;\n \n             while Node <= Target.Capacity loop\n                N := Node;\n-               Formal_Ordered_Maps.Free (Tree => Target.Tree.all, X => N);\n+               Formal_Ordered_Maps.Free (Tree => Target, X => N);\n                Node := Node + 1;\n             end loop;\n-\n-            if Source.K = Part then\n-               Node := Target.Tree.First;\n-               while Node /= Source.First loop\n-                  Cu := (Node => Node);\n-                  Node := Next (Target.Tree.all, Node);\n-                  Delete (Target, Cu);\n-               end loop;\n-\n-               Node := Next (Target.Tree.all, Source.Last);\n-\n-               while Node /= 0 loop\n-                  Cu := (Node => Node);\n-                  Node := Next (Target.Tree.all, Node);\n-                  Delete (Target, Cu);\n-               end loop;\n-            end if;\n          end if;\n       end return;\n    end Copy;\n@@ -385,41 +325,31 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Delete has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"Position cursor of Delete is bad\");\n \n-      Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all,\n+      Tree_Operations.Delete_Node_Sans_Free (Container,\n                                              Position.Node);\n-      Formal_Ordered_Maps.Free (Container.Tree.all, Position.Node);\n+      Formal_Ordered_Maps.Free (Container, Position.Node);\n    end Delete;\n \n    procedure Delete (Container : in out Map; Key : Key_Type) is\n+\n+      X : constant Node_Access := Key_Ops.Find (Container, Key);\n+\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n+      if X = 0 then\n+         raise Constraint_Error with \"key not in map\";\n       end if;\n-      declare\n-         X : constant Node_Access := Key_Ops.Find (Container.Tree.all, Key);\n-\n-      begin\n-         if X = 0 then\n-            raise Constraint_Error with \"key not in map\";\n-         end if;\n \n-         Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n-         Formal_Ordered_Maps.Free (Container.Tree.all, X);\n-      end;\n+      Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+      Formal_Ordered_Maps.Free (Container, X);\n    end Delete;\n \n    ------------------\n@@ -430,14 +360,10 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       X : constant Node_Access := First (Container).Node;\n \n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n-         Formal_Ordered_Maps.Free (Container.Tree.all, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Formal_Ordered_Maps.Free (Container, X);\n       end if;\n    end Delete_First;\n \n@@ -449,14 +375,10 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       X : constant Node_Access := Last (Container).Node;\n \n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n-         Formal_Ordered_Maps.Free (Container.Tree.all, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Formal_Ordered_Maps.Free (Container, X);\n       end if;\n    end Delete_Last;\n \n@@ -471,10 +393,10 @@ package body Ada.Containers.Formal_Ordered_Maps is\n            \"Position cursor of function Element has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"Position cursor of function Element is bad\");\n \n-      return Container.Tree.Nodes (Position.Node).Element;\n+      return Container.Nodes (Position.Node).Element;\n \n    end Element;\n \n@@ -486,7 +408,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      return Container.Tree.Nodes (Node).Element;\n+      return Container.Nodes (Node).Element;\n    end Element;\n \n    ---------------------\n@@ -509,17 +431,13 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    -------------\n \n    procedure Exclude (Container : in out Map; Key : Key_Type) is\n-      X : constant Node_Access := Key_Ops.Find (Container.Tree.all, Key);\n+      X : constant Node_Access := Key_Ops.Find (Container, Key);\n \n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n-         Formal_Ordered_Maps.Free (Container.Tree.all, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Formal_Ordered_Maps.Free (Container, X);\n       end if;\n    end Exclude;\n \n@@ -528,29 +446,16 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    ----------\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n-   begin\n-      if Container.K = Part then\n-         if Container.Length = 0 then\n-            return No_Element;\n-         end if;\n \n-         if Key < Container.Tree.Nodes (Container.First).Key or\n-           Container.Tree.Nodes (Container.Last).Key < Key then\n-            return No_Element;\n-         end if;\n-      end if;\n-\n-      declare\n-         Node : constant Count_Type :=\n-                  Key_Ops.Find (Container.Tree.all, Key);\n+      Node : constant Count_Type :=\n+        Key_Ops.Find (Container, Key);\n \n-      begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n \n-         return (Node => Node);\n-      end;\n+      return (Node => Node);\n    end Find;\n \n    -----------\n@@ -563,11 +468,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          return No_Element;\n       end if;\n \n-      if Container.K = Plain then\n-         return (Node => Container.Tree.First);\n-      else\n-         return (Node => Container.First);\n-      end if;\n+      return (Node => Container.First);\n \n    end First;\n \n@@ -581,7 +482,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          raise Constraint_Error with \"map is empty\";\n       end if;\n \n-      return Container.Tree.Nodes (First (Container).Node).Element;\n+      return Container.Nodes (First (Container).Node).Element;\n    end First_Element;\n \n    ---------------\n@@ -594,49 +495,32 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          raise Constraint_Error with \"map is empty\";\n       end if;\n \n-      return Container.Tree.Nodes (First (Container).Node).Key;\n+      return Container.Nodes (First (Container).Node).Key;\n    end First_Key;\n \n    -----------\n    -- Floor --\n    -----------\n \n    function Floor (Container : Map; Key : Key_Type) return Cursor is\n-   begin\n-\n-      if Container.K = Part then\n-         if Container.Length = 0 then\n-            return No_Element;\n-         end if;\n \n-         if Key < Container.Tree.Nodes (Container.First).Key then\n-            return No_Element;\n-         end if;\n+      Node : constant Count_Type :=\n+        Key_Ops.Floor (Container, Key);\n \n-         if Container.Tree.Nodes (Container.Last).Key < Key then\n-            return (Node => Container.Last);\n-         end if;\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n       end if;\n \n-      declare\n-         Node : constant Count_Type :=\n-                  Key_Ops.Floor (Container.Tree.all, Key);\n-\n-      begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-      end;\n+      return (Node => Node);\n    end Floor;\n \n    ----------\n    -- Free --\n    ----------\n \n    procedure Free\n-     (Tree : in out Tree_Types.Tree_Type;\n+     (Tree : in out Map;\n       X  : Count_Type)\n    is\n    begin\n@@ -671,25 +555,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          return False;\n       end if;\n \n-      if not Container.Tree.Nodes (Position.Node).Has_Element then\n-         return False;\n-      end if;\n-\n-      if Container.K = Plain then\n-         return True;\n-      end if;\n-\n-      declare\n-         Key : constant Key_Type := Container.Tree.Nodes (Position.Node).Key;\n-      begin\n-\n-         if Key < Container.Tree.Nodes (Container.First).Key or\n-           Container.Tree.Nodes (Container.Last).Key < Key then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end;\n+      return Container.Nodes (Position.Node).Has_Element;\n    end Has_Element;\n \n    -------------\n@@ -708,13 +574,13 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Tree.Lock > 0 then\n+         if Container.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors (map is locked)\";\n          end if;\n \n          declare\n-            N : Node_Type renames Container.Tree.Nodes (Position.Node);\n+            N : Node_Type renames Container.Nodes (Position.Node);\n          begin\n             N.Key := Key;\n             N.Element := New_Item;\n@@ -729,51 +595,43 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    is\n-   begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n+      function New_Node return Node_Access;\n \n-      declare\n-         function New_Node return Node_Access;\n-\n-         procedure Insert_Post is\n-           new Key_Ops.Generic_Insert_Post (New_Node);\n-\n-         procedure Insert_Sans_Hint is\n-           new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n-\n-         --------------\n-         -- New_Node --\n-         --------------\n+      procedure Insert_Post is\n+        new Key_Ops.Generic_Insert_Post (New_Node);\n \n-         function New_Node return Node_Access is\n-            procedure Initialize (Node : in out Node_Type);\n-            procedure Allocate_Node is new Generic_Allocate (Initialize);\n+      procedure Insert_Sans_Hint is\n+        new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n \n-            procedure Initialize (Node : in out Node_Type) is\n-            begin\n-               Node.Key := Key;\n-               Node.Element := New_Item;\n-            end Initialize;\n+      --------------\n+      -- New_Node --\n+      --------------\n \n-            X : Node_Access;\n+      function New_Node return Node_Access is\n+         procedure Initialize (Node : in out Node_Type);\n+         procedure Allocate_Node is new Generic_Allocate (Initialize);\n \n+         procedure Initialize (Node : in out Node_Type) is\n          begin\n-            Allocate_Node (Container.Tree.all, X);\n-            return X;\n-         end New_Node;\n+            Node.Key := Key;\n+            Node.Element := New_Item;\n+         end Initialize;\n \n-         --  Start of processing for Insert\n+         X : Node_Access;\n \n       begin\n-         Insert_Sans_Hint\n-           (Container.Tree.all,\n-            Key,\n-            Position.Node,\n-            Inserted);\n-      end;\n+         Allocate_Node (Container, X);\n+         return X;\n+      end New_Node;\n+\n+      --  Start of processing for Insert\n+\n+   begin\n+      Insert_Sans_Hint\n+        (Container,\n+         Key,\n+         Position.Node,\n+         Inserted);\n    end Insert;\n \n    procedure Insert\n@@ -802,50 +660,42 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    is\n-   begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      declare\n-         function New_Node return Node_Access;\n-\n-         procedure Insert_Post is\n-           new Key_Ops.Generic_Insert_Post (New_Node);\n-\n-         procedure Insert_Sans_Hint is\n-           new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n+      function New_Node return Node_Access;\n \n-         --------------\n-         -- New_Node --\n-         --------------\n+      procedure Insert_Post is\n+        new Key_Ops.Generic_Insert_Post (New_Node);\n \n-         function New_Node return Node_Access is\n-            procedure Initialize (Node : in out Node_Type);\n-            procedure Allocate_Node is new Generic_Allocate (Initialize);\n+      procedure Insert_Sans_Hint is\n+        new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n \n-            procedure Initialize (Node : in out Node_Type) is\n-            begin\n-               Node.Key := Key;\n-            end Initialize;\n+      --------------\n+      -- New_Node --\n+      --------------\n \n-            X : Node_Access;\n+      function New_Node return Node_Access is\n+         procedure Initialize (Node : in out Node_Type);\n+         procedure Allocate_Node is new Generic_Allocate (Initialize);\n \n+         procedure Initialize (Node : in out Node_Type) is\n          begin\n-            Allocate_Node (Container.Tree.all, X);\n-            return X;\n-         end New_Node;\n+            Node.Key := Key;\n+         end Initialize;\n \n-         --  Start of processing for Insert\n+         X : Node_Access;\n \n       begin\n-         Insert_Sans_Hint\n-           (Container.Tree.all,\n-            Key,\n-            Position.Node,\n-            Inserted);\n-      end;\n+         Allocate_Node (Container, X);\n+         return X;\n+      end New_Node;\n+\n+      --  Start of processing for Insert\n+\n+   begin\n+      Insert_Sans_Hint\n+        (Container,\n+         Key,\n+         Position.Node,\n+         Inserted);\n    end Insert;\n \n    --------------\n@@ -907,52 +757,15 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          Process (Container, (Node => Node));\n       end Process_Node;\n \n-      B : Natural renames Container.Tree.all.Busy;\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n \n       --  Start of processing for Iterate\n \n    begin\n       B := B + 1;\n \n       begin\n-\n-         if Container.K = Plain then\n-            Local_Iterate (Container.Tree.all);\n-            return;\n-         end if;\n-\n-         if Container.Length = 0 then\n-            return;\n-         end if;\n-\n-         declare\n-            FElt : constant Key_Type :=\n-              Container.Tree.Nodes (Container.First).Key;\n-            TElt : constant Key_Type :=\n-              Container.Tree.Nodes (Container.Last).Key;\n-\n-            procedure Iterate (P : Count_Type);\n-\n-            procedure Iterate (P : Count_Type) is\n-               X : Count_Type := P;\n-            begin\n-               while X /= 0 loop\n-                  if Container.Tree.Nodes (X).Key < FElt then\n-                     X := Container.Tree.Nodes (X).Right;\n-                  elsif TElt < Container.Tree.Nodes (X).Key then\n-                     X := Container.Tree.Nodes (X).Left;\n-                  else\n-                     Iterate (Container.Tree.Nodes (X).Left);\n-                     Process_Node (X);\n-                     X := Container.Tree.Nodes (X).Right;\n-                  end if;\n-               end loop;\n-            end Iterate;\n-\n-         begin\n-            Iterate (Container.Tree.Root);\n-         end;\n-\n+         Local_Iterate (Container);\n       exception\n          when others =>\n             B := B - 1;\n@@ -973,10 +786,10 @@ package body Ada.Containers.Formal_Ordered_Maps is\n            \"Position cursor of function Key has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"Position cursor of function Key is bad\");\n \n-      return Container.Tree.Nodes (Position.Node).Key;\n+      return Container.Nodes (Position.Node).Key;\n    end Key;\n \n    ----------\n@@ -988,11 +801,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       if Length (Container) = 0 then\n          return No_Element;\n       end if;\n-\n-      if Container.K = Plain then\n-         return (Node => Container.Tree.Last);\n-      end if;\n-\n       return (Node => Container.Last);\n    end Last;\n \n@@ -1006,7 +814,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          raise Constraint_Error with \"map is empty\";\n       end if;\n \n-      return Container.Tree.Nodes (Last (Container).Node).Element;\n+      return Container.Nodes (Last (Container).Node).Element;\n    end Last_Element;\n \n    --------------\n@@ -1019,43 +827,32 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          raise Constraint_Error with \"map is empty\";\n       end if;\n \n-      return Container.Tree.Nodes (Last (Container).Node).Key;\n+      return Container.Nodes (Last (Container).Node).Key;\n    end Last_Key;\n \n    ----------\n    -- Left --\n    ----------\n \n    function Left (Container : Map; Position : Cursor) return Map is\n-      Lst : Count_Type;\n-      Fst : constant Count_Type := First (Container).Node;\n-      L   : Count_Type := 0;\n-      C   : Count_Type := Fst;\n+      Curs : Cursor := Position;\n+      C : Map (Container.Capacity) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n    begin\n-      while C /= Position.Node loop\n-         if C = Last (Container).Node or C = 0 then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-         Lst := C;\n-         C := Next (Container.Tree.all, C);\n-         L := L + 1;\n-      end loop;\n-      if L = 0 then\n-         return (Capacity => Container.Capacity,\n-                 K        => Part,\n-                 Tree     => Container.Tree,\n-                 Length   => 0,\n-                 First    => 0,\n-                 Last     => 0);\n-      else\n-         return (Capacity => Container.Capacity,\n-                 K        => Part,\n-                 Tree     => Container.Tree,\n-                 Length   => L,\n-                 First    => Fst,\n-                 Last     => Lst);\n+      if Curs = No_Element then\n+         return C;\n       end if;\n+      if not Has_Element (Container, Curs) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= 0 loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+      return C;\n    end Left;\n \n    --------------\n@@ -1073,26 +870,18 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n    function Length (Container : Map) return Count_Type is\n    begin\n-      if Container.K = Plain then\n-         return Container.Tree.Length;\n-      else\n-         return Container.Length;\n-      end if;\n+      return Container.Length;\n    end Length;\n \n    ----------\n    -- Move --\n    ----------\n \n    procedure Move (Target : in out Map; Source : in out Map) is\n-      NN : Tree_Types.Nodes_Type renames Source.Tree.Nodes;\n+      NN : Tree_Types.Nodes_Type renames Source.Nodes;\n       X  : Node_Access;\n \n    begin\n-      if Target.K /= Plain or Source.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Target'Address = Source'Address then\n          return;\n@@ -1103,7 +892,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      if Source.Tree.Busy > 0 then\n+      if Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n@@ -1121,28 +910,15 @@ package body Ada.Containers.Formal_Ordered_Maps is\n \n          Insert (Target, NN (X).Key, NN (X).Element);  -- optimize???\n \n-         Tree_Operations.Delete_Node_Sans_Free (Source.Tree.all, X);\n-         Formal_Ordered_Maps.Free (Source.Tree.all, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Source, X);\n+         Formal_Ordered_Maps.Free (Source, X);\n       end loop;\n    end Move;\n \n    ----------\n    -- Next --\n    ----------\n \n-   function Next_Unchecked\n-     (Container : Map;\n-      Position  : Count_Type) return Count_Type is\n-   begin\n-\n-      if Container.K = Part and then\n-        (Container.Length = 0 or Position = Container.Last) then\n-         return 0;\n-      end if;\n-\n-      return Tree_Operations.Next (Container.Tree.all, Position);\n-   end Next_Unchecked;\n-\n    procedure Next (Container : Map; Position : in out Cursor) is\n    begin\n       Position := Next (Container, Position);\n@@ -1158,10 +934,10 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          raise Constraint_Error;\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Next\");\n \n-      return (Node => Next_Unchecked (Container, Position.Node));\n+      return (Node => Tree_Operations.Next (Container, Position.Node));\n    end Next;\n \n    -------------\n@@ -1181,9 +957,9 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          R_Node : Count_Type := First (Right).Node;\n \n          L_Last : constant Count_Type :=\n-                    Next (Left.Tree.all, Last (Left).Node);\n+                    Next (Left, Last (Left).Node);\n          R_Last : constant Count_Type :=\n-                    Next (Right.Tree.all, Last (Right).Node);\n+                    Next (Right, Last (Right).Node);\n \n       begin\n          if Left'Address = Right'Address then\n@@ -1197,12 +973,12 @@ package body Ada.Containers.Formal_Ordered_Maps is\n                return False;\n             end if;\n \n-            if Left.Tree.Nodes (L_Node).Key\n-              < Right.Tree.Nodes (R_Node).Key then\n-               L_Node := Next (Left.Tree.all, L_Node);\n-            elsif Right.Tree.Nodes (R_Node).Key\n-              < Left.Tree.Nodes (L_Node).Key then\n-               R_Node := Next (Right.Tree.all, R_Node);\n+            if Left.Nodes (L_Node).Key\n+              < Right.Nodes (R_Node).Key then\n+               L_Node := Next (Left, L_Node);\n+            elsif Right.Nodes (R_Node).Key\n+              < Left.Nodes (L_Node).Key then\n+               R_Node := Next (Right, R_Node);\n \n             else\n                return True;\n@@ -1239,18 +1015,12 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          raise Constraint_Error;\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Previous\");\n \n-      if Container.K = Part and then\n-        (Container.Length = 0 or Position.Node = Container.First) then\n-         return No_Element;\n-      end if;\n-\n       declare\n-         Tree : Tree_Types.Tree_Type renames Container.Tree.all;\n          Node : constant Count_Type :=\n-                  Tree_Operations.Previous (Tree, Position.Node);\n+                  Tree_Operations.Previous (Container, Position.Node);\n \n       begin\n          if Node = 0 then\n@@ -1272,31 +1042,26 @@ package body Ada.Containers.Formal_Ordered_Maps is\n                                              Element : Element_Type))\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"Position cursor of Query_Element is bad\");\n \n       declare\n-         T : Tree_Types.Tree_Type renames Container.Tree.all;\n \n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n \n       begin\n          B := B + 1;\n          L := L + 1;\n \n          declare\n-            N  : Node_Type renames T.Nodes (Position.Node);\n+            N  : Node_Type renames Container.Nodes (Position.Node);\n             K  : Key_Type renames N.Key;\n             E  : Element_Type renames N.Element;\n \n@@ -1342,20 +1107,9 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       end Read_Element;\n \n       --  Start of processing for Read\n-      Result : Tree_Type_Access;\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error;\n-      end if;\n-\n-      if Container.Tree = null then\n-         Result := new Tree_Types.Tree_Type (Container.Capacity);\n-      else\n-         Result := Container.Tree;\n-      end if;\n \n-      Read_Elements (Stream, Result.all);\n-      Container.Tree := Result;\n+      Read_Elements (Stream, Container);\n    end Read;\n \n    procedure Read\n@@ -1377,26 +1131,21 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    is\n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       declare\n-         Node : constant Node_Access := Key_Ops.Find (Container.Tree.all, Key);\n+         Node : constant Node_Access := Key_Ops.Find (Container, Key);\n \n       begin\n          if Node = 0 then\n             raise Constraint_Error with \"key not in map\";\n          end if;\n \n-         if Container.Tree.Lock > 0 then\n+         if Container.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors (map is locked)\";\n          end if;\n \n          declare\n-            N : Node_Type renames Container.Tree.Nodes (Node);\n+            N : Node_Type renames Container.Nodes (Node);\n          begin\n             N.Key := Key;\n             N.Element := New_Item;\n@@ -1414,25 +1163,21 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element has no element\";\n       end if;\n \n-      if Container.Tree.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (map is locked)\";\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"Position cursor of Replace_Element is bad\");\n \n-      Container.Tree.Nodes (Position.Node).Element := New_Item;\n+      Container.Nodes (Position.Node).Element := New_Item;\n    end Replace_Element;\n \n    ---------------------\n@@ -1459,51 +1204,15 @@ package body Ada.Containers.Formal_Ordered_Maps is\n          Process (Container, (Node => Node));\n       end Process_Node;\n \n-      B : Natural renames Container.Tree.Busy;\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n \n       --  Start of processing for Reverse_Iterate\n \n    begin\n       B := B + 1;\n \n       begin\n-\n-         if Container.K = Plain then\n-            Local_Reverse_Iterate (Container.Tree.all);\n-            return;\n-         end if;\n-\n-         if Container.Length = 0 then\n-            return;\n-         end if;\n-\n-         declare\n-            FElt : constant Key_Type :=\n-              Container.Tree.Nodes (Container.First).Key;\n-            TElt : constant Key_Type :=\n-              Container.Tree.Nodes (Container.Last).Key;\n-\n-            procedure Iterate (P : Count_Type);\n-\n-            procedure Iterate (P : Count_Type) is\n-               X : Count_Type := P;\n-            begin\n-               while X /= 0 loop\n-                  if Container.Tree.Nodes (X).Key < FElt then\n-                     X := Container.Tree.Nodes (X).Right;\n-                  elsif TElt < Container.Tree.Nodes (X).Key then\n-                     X := Container.Tree.Nodes (X).Left;\n-                  else\n-                     Iterate (Container.Tree.Nodes (X).Right);\n-                     Process_Node (X);\n-                     X := Container.Tree.Nodes (X).Left;\n-                  end if;\n-               end loop;\n-            end Iterate;\n-\n-         begin\n-            Iterate (Container.Tree.Root);\n-         end;\n+         Local_Reverse_Iterate (Container);\n \n       exception\n          when others =>\n@@ -1519,46 +1228,25 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    -----------\n \n    function Right (Container : Map; Position : Cursor) return Map is\n-      Lst : Count_Type;\n-      L   : Count_Type := 0;\n-      C   : Count_Type := Position.Node;\n+      Curs : Cursor := First (Container);\n+      C : Map (Container.Capacity) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n    begin\n-\n-      if C = 0 then\n-         return (Capacity => Container.Capacity,\n-                 K        => Part,\n-                 Tree     => Container.Tree,\n-                 Length   => 0,\n-                 First    => 0,\n-                 Last     => 0);\n-      end if;\n-\n-      if Container.K = Plain then\n-         Lst := 0;\n-      else\n-         Lst := Next (Container.Tree.all, Container.Last);\n+      if Curs = No_Element then\n+         Clear (C);\n+         return C;\n       end if;\n-\n-      if C = Lst then\n-         raise Constraint_Error with\n-           \"Position cursor has no element\";\n+      if Position /= No_Element and not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n       end if;\n \n-      while C /= Lst loop\n-         if C = 0 then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-         C := Next (Container.Tree.all, C);\n-         L := L + 1;\n+      while Curs.Node /= Position.Node loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n       end loop;\n-\n-      return (Capacity => Container.Capacity,\n-              K        => Part,\n-              Tree     => Container.Tree,\n-              Length   => L,\n-              First    => Position.Node,\n-              Last     => Last (Container).Node);\n+      return C;\n    end Right;\n \n    ---------------\n@@ -1626,14 +1314,14 @@ package body Ada.Containers.Formal_Ordered_Maps is\n             return True;\n          end if;\n \n-         if Left.Tree.Nodes (LNode).Element /=\n-           Right.Tree.Nodes (RNode).Element or\n-           Left.Tree.Nodes (LNode).Key /= Right.Tree.Nodes (RNode).Key then\n+         if Left.Nodes (LNode).Element /=\n+           Right.Nodes (RNode).Element or\n+           Left.Nodes (LNode).Key /= Right.Nodes (RNode).Key then\n             exit;\n          end if;\n \n-         LNode := Next_Unchecked (Left, LNode);\n-         RNode := Next_Unchecked (Right, RNode);\n+         LNode := Next (Left, LNode);\n+         RNode := Next (Right, RNode);\n       end loop;\n       return False;\n    end Strict_Equal;\n@@ -1649,31 +1337,26 @@ package body Ada.Containers.Formal_Ordered_Maps is\n                                              Element : in out Element_Type))\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Update_Element has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"Position cursor of Update_Element is bad\");\n \n       declare\n-         T : Tree_Types.Tree_Type renames Container.Tree.all;\n \n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n \n       begin\n          B := B + 1;\n          L := L + 1;\n \n          declare\n-            N : Node_Type renames T.Nodes (Position.Node);\n+            N : Node_Type renames Container.Nodes (Position.Node);\n             K : Key_Type renames N.Key;\n             E : Element_Type renames N.Element;\n \n@@ -1723,7 +1406,7 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    --  Start of processing for Write\n \n    begin\n-      Write_Nodes (Stream, Container.Tree.all);\n+      Write_Nodes (Stream, Container);\n    end Write;\n \n    procedure Write"}, {"sha": "145ff513d3dfa9d7a1ea190db83e46a475cc6cab", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -69,7 +69,7 @@ package Ada.Containers.Formal_Ordered_Maps is\n    function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n    type Map (Capacity : Count_Type) is tagged private;\n-   --  pragma Preelaborable_Initialization (Map);\n+   pragma Preelaborable_Initialization (Map);\n \n    type Cursor is private;\n    pragma Preelaborable_Initialization (Cursor);\n@@ -220,34 +220,22 @@ private\n \n    type Node_Type is record\n       Has_Element : Boolean := False;\n-      Parent  : Node_Access;\n-      Left    : Node_Access;\n-      Right   : Node_Access;\n+      Parent  : Node_Access := 0;\n+      Left    : Node_Access := 0;\n+      Right   : Node_Access := 0;\n       Color   : Red_Black_Trees.Color_Type := Red;\n       Key     : Key_Type;\n       Element : Element_Type;\n    end record;\n \n-   type Kind is (Plain, Part);\n-\n    package Tree_Types is\n      new Ada.Containers.Red_Black_Trees.Generic_Bounded_Tree_Types (Node_Type);\n \n-   type Tree_Type_Access is access all Tree_Types.Tree_Type;\n-\n-   type Map (Capacity : Count_Type) is tagged record\n-      Tree   : Tree_Type_Access := new Tree_Types.Tree_Type (Capacity);\n-      K      : Kind := Plain;\n-      Length : Count_Type := 0;\n-      First  : Count_Type := 0;\n-      Last   : Count_Type := 0;\n-   end record;\n+   type Map (Capacity : Count_Type) is\n+      new Tree_Types.Tree_Type (Capacity) with null record;\n \n    use Ada.Streams;\n \n-   type Map_Access is access all Map;\n-   for Map_Access'Storage_Size use 0;\n-\n    type Cursor is record\n       Node : Node_Access;\n    end record;"}, {"sha": "59f4efe8230e84e4dad2f55acaa115068b7f7f98", "filename": "gcc/ada/a-cforse.adb", "status": "modified", "additions": 205, "deletions": 1233, "changes": 1438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--          Copyright (C) 2010-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -83,21 +83,16 @@ package body Ada.Containers.Formal_Ordered_Sets is\n      (Tree : in out Tree_Types.Tree_Type'Class;\n       Node : out Count_Type);\n \n-   procedure Assign (Target : in out Tree_Types.Tree_Type;\n-                     Source : Tree_Types.Tree_Type);\n-\n-   procedure Clear (Container : in out Tree_Types.Tree_Type);\n-\n-   procedure Free (Tree : in out Tree_Types.Tree_Type; X : Count_Type);\n+   procedure Free (Tree : in out Set; X : Count_Type);\n \n    procedure Insert_Sans_Hint\n-     (Container : in out Tree_Types.Tree_Type;\n+     (Container : in out Set;\n       New_Item  : Element_Type;\n       Node      : out Count_Type;\n       Inserted  : out Boolean);\n \n    procedure Insert_With_Hint\n-     (Dst_Set  : in out Tree_Types.Tree_Type;\n+     (Dst_Set  : in out Set;\n       Dst_Hint : Count_Type;\n       Src_Node : Node_Type;\n       Dst_Node : out Count_Type);\n@@ -115,18 +110,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    function Is_Less_Node_Node (L, R : Node_Type) return Boolean;\n    pragma Inline (Is_Less_Node_Node);\n \n-   generic\n-      with procedure Process (Node : Count_Type) is <>;\n-   procedure Iterate_Between (Tree : Tree_Types.Tree_Type;\n-                              From : Count_Type;\n-                              To   : Count_Type);\n-\n-   function Next_Unchecked\n-     (Container : Set;\n-      Position  : Count_Type) return Count_Type;\n-\n    procedure Replace_Element\n-     (Tree : in out Tree_Types.Tree_Type;\n+     (Tree : in out Set;\n       Node : Count_Type;\n       Item : Element_Type);\n \n@@ -152,7 +137,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    package Set_Ops is\n      new Red_Black_Trees.Generic_Bounded_Set_Operations\n        (Tree_Operations  => Tree_Operations,\n-        Set_Type         => Tree_Types.Tree_Type,\n+        Set_Type         => Set,\n         Assign           => Assign,\n         Insert_With_Hint => Insert_With_Hint,\n         Is_Less          => Is_Less_Node_Node);\n@@ -175,15 +160,15 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          return True;\n       end if;\n \n-      Lst := Next (Left.Tree.all, Last (Left).Node);\n+      Lst := Next (Left, Last (Left).Node);\n       while Node /= Lst loop\n-         ENode := Find (Right, Left.Tree.Nodes (Node).Element).Node;\n+         ENode := Find (Right, Left.Nodes (Node).Element).Node;\n          if ENode = 0 or else\n-           Left.Tree.Nodes (Node).Element /= Right.Tree.Nodes (ENode).Element\n+           Left.Nodes (Node).Element /= Right.Nodes (ENode).Element\n          then\n             return False;\n          end if;\n-         Node := Next (Left.Tree.all, Node);\n+         Node := Next (Left, Node);\n       end loop;\n \n       return True;\n@@ -194,8 +179,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    -- Assign --\n    ------------\n \n-   procedure Assign (Target : in out Tree_Types.Tree_Type;\n-                     Source : Tree_Types.Tree_Type) is\n+   procedure Assign (Target : in out Set; Source : Set) is\n       procedure Append_Element (Source_Node : Count_Type);\n \n       procedure Append_Elements is\n@@ -277,145 +261,30 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Append_Elements (Source);\n    end Assign;\n \n-   procedure Assign (Target : in out Set; Source : Set) is\n-      X : Count_Type;\n-   begin\n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Target.Capacity < Length (Source) then\n-         raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n-      end if;\n-\n-      if Source.K = Plain then\n-         Assign (Target => Target.Tree.all, Source => Source.Tree.all);\n-      else\n-         declare\n-            procedure Append_Element (Source_Node : Count_Type);\n-\n-            procedure Append_Element (Source_Node : Count_Type) is\n-               SN : Node_Type renames Source.Tree.Nodes (Source_Node);\n-\n-               procedure Set_Element (Node : in out Node_Type);\n-               pragma Inline (Set_Element);\n-\n-               function New_Node return Count_Type;\n-               pragma Inline (New_Node);\n-\n-               procedure Insert_Post is\n-                 new Element_Keys.Generic_Insert_Post (New_Node);\n-\n-               procedure Unconditional_Insert_Sans_Hint is\n-                 new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n-\n-               procedure Unconditional_Insert_Avec_Hint is\n-                 new Element_Keys.Generic_Unconditional_Insert_With_Hint\n-                   (Insert_Post,\n-                    Unconditional_Insert_Sans_Hint);\n-\n-               procedure Allocate is\n-                 new Generic_Allocate (Set_Element);\n-\n-               --------------\n-               -- New_Node --\n-               --------------\n-\n-               function New_Node return Count_Type is\n-                  Result : Count_Type;\n-\n-               begin\n-                  Allocate (Target.Tree.all, Result);\n-                  return Result;\n-               end New_Node;\n-\n-               -----------------\n-               -- Set_Element --\n-               -----------------\n-\n-               procedure Set_Element (Node : in out Node_Type) is\n-               begin\n-                  Node.Element := SN.Element;\n-               end Set_Element;\n-\n-               Target_Node : Count_Type;\n-\n-               --  Start of processing for Append_Element\n-\n-            begin\n-               Unconditional_Insert_Avec_Hint\n-                 (Tree  => Target.Tree.all,\n-                  Hint  => 0,\n-                  Key   => SN.Element,\n-                  Node  => Target_Node);\n-            end Append_Element;\n-         begin\n-            Tree_Operations.Clear_Tree (Target.Tree.all);\n-            X := Source.First;\n-            while X /= Next (Source.Tree.all, Source.Last) loop\n-               Append_Element (X);\n-               X := Next (Source.Tree.all, X);\n-            end loop;\n-         end;\n-      end if;\n-   end Assign;\n-\n    -------------\n    -- Ceiling --\n    -------------\n \n    function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n-   begin\n \n-      if Container.K = Part then\n-         if Container.Length = 0 then\n-            return No_Element;\n-         end if;\n+      Node : constant Count_Type := Element_Keys.Ceiling (Container, Item);\n \n-         if Item < Container.Tree.Nodes (Container.First).Element then\n-            return (Node => Container.First);\n-         end if;\n-\n-         if Container.Tree.Nodes (Container.Last).Element < Item then\n-            return No_Element;\n-         end if;\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n       end if;\n \n-      declare\n-         Node : constant Count_Type :=\n-           Element_Keys.Ceiling (Container.Tree.all, Item);\n+      return (Node => Node);\n \n-      begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-      end;\n    end Ceiling;\n \n    -----------\n    -- Clear --\n    -----------\n \n-   procedure Clear (Container : in out Tree_Types.Tree_Type) is\n-   begin\n-      Tree_Operations.Clear_Tree (Container);\n-   end Clear;\n-\n    procedure Clear (Container : in out Set) is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      Clear (Container.Tree.all);\n+      Tree_Operations.Clear_Tree (Container);\n    end Clear;\n \n    -----------\n@@ -446,56 +315,36 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    function Copy (Source : Set; Capacity : Count_Type := 0) return Set is\n       Node : Count_Type := 1;\n       N    : Count_Type;\n-      Cu   : Cursor;\n       Target : Set (Count_Type'Max (Source.Capacity, Capacity));\n    begin\n       if Length (Source) > 0 then\n-         Target.Tree.Length := Source.Tree.Length;\n-         Target.Tree.Root := Source.Tree.Root;\n-         Target.Tree.First := Source.Tree.First;\n-         Target.Tree.Last := Source.Tree.Last;\n-         Target.Tree.Free := Source.Tree.Free;\n+         Target.Length := Source.Length;\n+         Target.Root := Source.Root;\n+         Target.First := Source.First;\n+         Target.Last := Source.Last;\n+         Target.Free := Source.Free;\n \n          while Node <= Source.Capacity loop\n-            Target.Tree.Nodes (Node).Element :=\n-              Source.Tree.Nodes (Node).Element;\n-            Target.Tree.Nodes (Node).Parent :=\n-              Source.Tree.Nodes (Node).Parent;\n-            Target.Tree.Nodes (Node).Left :=\n-              Source.Tree.Nodes (Node).Left;\n-            Target.Tree.Nodes (Node).Right :=\n-              Source.Tree.Nodes (Node).Right;\n-            Target.Tree.Nodes (Node).Color :=\n-              Source.Tree.Nodes (Node).Color;\n-            Target.Tree.Nodes (Node).Has_Element :=\n-              Source.Tree.Nodes (Node).Has_Element;\n+            Target.Nodes (Node).Element :=\n+              Source.Nodes (Node).Element;\n+            Target.Nodes (Node).Parent :=\n+              Source.Nodes (Node).Parent;\n+            Target.Nodes (Node).Left :=\n+              Source.Nodes (Node).Left;\n+            Target.Nodes (Node).Right :=\n+              Source.Nodes (Node).Right;\n+            Target.Nodes (Node).Color :=\n+              Source.Nodes (Node).Color;\n+            Target.Nodes (Node).Has_Element :=\n+              Source.Nodes (Node).Has_Element;\n             Node := Node + 1;\n          end loop;\n \n          while Node <= Target.Capacity loop\n             N := Node;\n-            Formal_Ordered_Sets.Free (Tree => Target.Tree.all, X => N);\n+            Formal_Ordered_Sets.Free (Tree => Target, X => N);\n             Node := Node + 1;\n          end loop;\n-\n-         if Source.K = Part then\n-            Node := Target.Tree.First;\n-            while Node /= Source.First loop\n-               Cu := (Node => Node);\n-               Node := Next (Target.Tree.all, Node);\n-               Delete (Target, Cu);\n-            end loop;\n-\n-            Node := Next (Target.Tree.all, Source.Last);\n-\n-            while Node /= 0 loop\n-               Cu := (Node => Node);\n-               Node := Next (Target.Tree.all, Node);\n-               Delete (Target, Cu);\n-            end loop;\n-         end if;\n-         Node := 1;\n-\n       end if;\n       return Target;\n    end Copy;\n@@ -506,58 +355,45 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Delete\");\n \n-      Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all,\n+      Tree_Operations.Delete_Node_Sans_Free (Container,\n                                              Position.Node);\n-      Formal_Ordered_Sets.Free (Container.Tree.all, Position.Node);\n+      Formal_Ordered_Sets.Free (Container, Position.Node);\n       Position := No_Element;\n    end Delete;\n \n    procedure Delete (Container : in out Set; Item : Element_Type) is\n-      X : constant Count_Type := Element_Keys.Find (Container.Tree.all, Item);\n+      X : constant Count_Type := Element_Keys.Find (Container, Item);\n \n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if X = 0 then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n-      Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n-      Formal_Ordered_Sets.Free (Container.Tree.all, X);\n+      Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+      Formal_Ordered_Sets.Free (Container, X);\n    end Delete;\n \n    ------------------\n    -- Delete_First --\n    ------------------\n \n    procedure Delete_First (Container : in out Set) is\n-      Tree : Tree_Types.Tree_Type renames Container.Tree.all;\n-      X    : constant Count_Type := Tree.First;\n+      X    : constant Count_Type := Container.First;\n \n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n-         Formal_Ordered_Sets.Free (Tree, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Formal_Ordered_Sets.Free (Container, X);\n       end if;\n    end Delete_First;\n \n@@ -566,18 +402,13 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    -----------------\n \n    procedure Delete_Last (Container : in out Set) is\n-      Tree : Tree_Types.Tree_Type renames Container.Tree.all;\n-      X    : constant Count_Type := Tree.Last;\n+      X    : constant Count_Type := Container.Last;\n \n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n-         Formal_Ordered_Sets.Free (Tree, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Formal_Ordered_Sets.Free (Container, X);\n       end if;\n    end Delete_Last;\n \n@@ -587,68 +418,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Difference (Target : in out Set; Source : Set) is\n    begin\n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      if Source.K = Plain then\n-         Set_Ops.Set_Difference (Target.Tree.all, Source.Tree.all);\n-      else\n-         declare\n-            Tgt : Count_Type := Target.Tree.First;\n-            Src : Count_Type := Source.First;\n-         begin\n-            if Target'Address = Source'Address then\n-               if Target.Tree.Busy > 0 then\n-                  raise Program_Error with\n-                    \"attempt to tamper with cursors (container is busy)\";\n-               end if;\n-\n-               Clear (Target.Tree.all);\n-               return;\n-            end if;\n-\n-            if Source.Length = 0 then\n-               return;\n-            end if;\n+      Set_Ops.Set_Difference (Target, Source);\n \n-            if Target.Tree.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors (container is busy)\";\n-            end if;\n-\n-            loop\n-               if Tgt = 0 then\n-                  return;\n-               end if;\n-\n-               if Src = Next (Source.Tree.all, Source.Last) then\n-                  return;\n-               end if;\n-\n-               if Target.Tree.Nodes (Tgt).Element <\n-                 Source.Tree.Nodes (Src).Element then\n-                  Tgt := Next (Target.Tree.all, Tgt);\n-\n-               elsif Source.Tree.Nodes (Src).Element <\n-                 Target.Tree.Nodes (Tgt).Element then\n-                  Src := Next (Source.Tree.all, Src);\n-\n-               else\n-                  declare\n-                     X : constant Count_Type := Tgt;\n-                  begin\n-                     Tgt := Next (Target.Tree.all, Tgt);\n-                     Delete_Node_Sans_Free (Target.Tree.all, X);\n-                     Formal_Ordered_Sets.Free (Target.Tree.all, X);\n-                  end;\n-\n-                  Src := Next (Source.Tree.all, Src);\n-               end if;\n-            end loop;\n-         end;\n-      end if;\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n@@ -666,65 +437,9 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       return S : Set (Length (Left)) do\n-         if Left.K = Plain and Right.K = Plain then\n-            Assign (S.Tree.all,\n-                    Set_Ops.Set_Difference (Left.Tree.all, Right.Tree.all));\n-         else\n-            declare\n-               Tree : Tree_Types.Tree_Type renames S.Tree.all;\n-\n-               L_Node : Count_Type := First (Left).Node;\n-               R_Node : Count_Type := First (Right).Node;\n-\n-               L_Last : constant Count_Type := Next (Left.Tree.all,\n-                                                     Last (Left).Node);\n-               R_Last : constant Count_Type := Next (Right.Tree.all,\n-                                                     Last (Right).Node);\n+            Assign (S,\n+                    Set_Ops.Set_Difference (Left, Right));\n \n-               Dst_Node : Count_Type;\n-\n-            begin\n-               loop\n-                  if L_Node = L_Last then\n-                     return;\n-                  end if;\n-\n-                  if R_Node = R_Last then\n-                     while L_Node /= L_Last loop\n-                        Insert_With_Hint\n-                          (Dst_Set  => Tree,\n-                           Dst_Hint => 0,\n-                           Src_Node => Left.Tree.Nodes (L_Node),\n-                           Dst_Node => Dst_Node);\n-\n-                        L_Node := Next (Left.Tree.all, L_Node);\n-\n-                     end loop;\n-\n-                     return;\n-                  end if;\n-\n-                  if Left.Tree.Nodes (L_Node).Element <\n-                    Right.Tree.Nodes (R_Node).Element then\n-                     Insert_With_Hint\n-                       (Dst_Set  => Tree,\n-                        Dst_Hint => 0,\n-                        Src_Node => Left.Tree.Nodes (L_Node),\n-                        Dst_Node => Dst_Node);\n-\n-                     L_Node := Next (Left.Tree.all, L_Node);\n-\n-                  elsif Right.Tree.Nodes (R_Node).Element <\n-                    Left.Tree.Nodes (L_Node).Element then\n-                     R_Node := Next (Right.Tree.all, R_Node);\n-\n-                  else\n-                     L_Node := Next (Left.Tree.all, L_Node);\n-                     R_Node := Next (Right.Tree.all, R_Node);\n-                  end if;\n-               end loop;\n-            end;\n-         end if;\n       end return;\n    end Difference;\n \n@@ -738,11 +453,11 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Element\");\n \n       declare\n-         N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+         N : Tree_Types.Nodes_Type renames Container.Nodes;\n       begin\n          return N (Position.Node).Element;\n       end;\n@@ -793,62 +508,21 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       --  Start of processing for Equivalent_Sets\n \n    begin\n-      if Left.K = Plain and Right.K = Plain then\n-         return Is_Equivalent (Left.Tree.all, Right.Tree.all);\n-      end if;\n-\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return True;\n-      end if;\n-\n-      declare\n-         L_Node : Count_Type;\n-         R_Node : Count_Type;\n-\n-         L_Last : constant Count_Type := Next (Left.Tree.all,\n-                                               Last (Left).Node);\n-      begin\n-\n-         L_Node := First (Left).Node;\n-         R_Node := First (Right).Node;\n-         while L_Node /= L_Last loop\n-            if not Is_Equivalent_Node_Node (Left.Tree.Nodes (L_Node),\n-                                            Right.Tree.Nodes (R_Node)) then\n-               return False;\n-            end if;\n-\n-            L_Node := Next (Left.Tree.all, L_Node);\n-            R_Node := Next (Right.Tree.all, R_Node);\n-         end loop;\n-\n-         return True;\n-      end;\n+      return Is_Equivalent (Left, Right);\n    end Equivalent_Sets;\n \n    -------------\n    -- Exclude --\n    -------------\n \n    procedure Exclude (Container : in out Set; Item : Element_Type) is\n-      X : constant Count_Type := Element_Keys.Find (Container.Tree.all, Item);\n+      X : constant Count_Type := Element_Keys.Find (Container, Item);\n \n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Tree.all, X);\n-         Formal_Ordered_Sets.Free (Container.Tree.all, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Formal_Ordered_Sets.Free (Container, X);\n       end if;\n    end Exclude;\n \n@@ -857,30 +531,17 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    ----------\n \n    function Find (Container : Set; Item : Element_Type) return Cursor is\n-   begin\n \n-      if Container.K = Part then\n-         if Container.Length = 0 then\n-            return No_Element;\n-         end if;\n+      Node : constant Count_Type :=\n+        Element_Keys.Find (Container, Item);\n \n-         if Item < Container.Tree.Nodes (Container.First).Element or\n-           Container.Tree.Nodes (Container.Last).Element < Item then\n-            return No_Element;\n-         end if;\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n       end if;\n \n-      declare\n-         Node : constant Count_Type :=\n-           Element_Keys.Find (Container.Tree.all, Item);\n+      return (Node => Node);\n \n-      begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-      end;\n    end Find;\n \n    -----------\n@@ -893,11 +554,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      if Container.K = Plain then\n-         return (Node => Container.Tree.First);\n-      else\n-         return (Node => Container.First);\n-      end if;\n+      return (Node => Container.First);\n \n    end First;\n \n@@ -913,7 +570,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       declare\n-         N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+         N : Tree_Types.Nodes_Type renames Container.Nodes;\n       begin\n          return N (Fst).Element;\n       end;\n@@ -926,23 +583,9 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    function Floor (Container : Set; Item : Element_Type) return Cursor is\n    begin\n \n-      if Container.K = Part then\n-         if Container.Length = 0 then\n-            return No_Element;\n-         end if;\n-\n-         if Item < Container.Tree.Nodes (Container.First).Element then\n-            return No_Element;\n-         end if;\n-\n-         if Container.Tree.Nodes (Container.Last).Element < Item then\n-            return (Node => Container.Last);\n-         end if;\n-      end if;\n-\n       declare\n          Node : constant Count_Type :=\n-           Element_Keys.Floor (Container.Tree.all, Item);\n+           Element_Keys.Floor (Container, Item);\n \n       begin\n          if Node = 0 then\n@@ -958,7 +601,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    ----------\n \n    procedure Free\n-     (Tree : in out Tree_Types.Tree_Type;\n+     (Tree : in out Set;\n       X  : Count_Type)\n    is\n    begin\n@@ -1019,35 +662,15 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       -------------\n \n       function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n-      begin\n-\n-         if Container.K = Part then\n-            if Container.Length = 0 then\n-               return No_Element;\n-            end if;\n-\n-            if Key < Generic_Keys.Key\n-              (Container.Tree.Nodes (Container.First).Element) then\n-               return (Node => Container.First);\n-            end if;\n+         Node : constant Count_Type :=\n+           Key_Keys.Ceiling (Container, Key);\n \n-            if Generic_Keys.Key\n-              (Container.Tree.Nodes (Container.Last).Element) < Key then\n-               return No_Element;\n-            end if;\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n          end if;\n \n-         declare\n-            Node : constant Count_Type :=\n-              Key_Keys.Ceiling (Container.Tree.all, Key);\n-\n-         begin\n-            if Node = 0 then\n-               return No_Element;\n-            end if;\n-\n-            return (Node => Node);\n-         end;\n+         return (Node => Node);\n       end Ceiling;\n \n       --------------\n@@ -1064,56 +687,35 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       ------------\n \n       procedure Delete (Container : in out Set; Key : Key_Type) is\n-      begin\n-         if Container.K /= Plain then\n-            raise Constraint_Error\n-              with \"Can't modify part of container\";\n-         end if;\n \n-         declare\n-            X : constant Count_Type := Key_Keys.Find (Container.Tree.all, Key);\n+         X : constant Count_Type := Key_Keys.Find (Container, Key);\n \n-         begin\n-            if X = 0 then\n-               raise Constraint_Error with \"attempt to delete key not in set\";\n-            end if;\n+      begin\n+         if X = 0 then\n+            raise Constraint_Error with \"attempt to delete key not in set\";\n+         end if;\n \n-            Delete_Node_Sans_Free (Container.Tree.all, X);\n-            Formal_Ordered_Sets.Free (Container.Tree.all, X);\n-         end;\n+         Delete_Node_Sans_Free (Container, X);\n+         Formal_Ordered_Sets.Free (Container, X);\n       end Delete;\n \n       -------------\n       -- Element --\n       -------------\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type is\n-      begin\n+         Node : constant Count_Type :=\n+           Key_Keys.Find (Container, Key);\n \n-         if Container.K = Part then\n-            if Container.Length = 0 or else\n-              (Key < Generic_Keys.Key\n-                 (Container.Tree.Nodes (Container.First).Element) or\n-                 Generic_Keys.Key\n-                   (Container.Tree.Nodes (Container.Last).Element) < Key) then\n-               raise Constraint_Error with \"key not in set\";\n-            end if;\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with \"key not in set\";\n          end if;\n \n          declare\n-            Node : constant Count_Type :=\n-              Key_Keys.Find (Container.Tree.all, Key);\n-\n+            N : Tree_Types.Nodes_Type renames Container.Nodes;\n          begin\n-            if Node = 0 then\n-               raise Constraint_Error with \"key not in set\";\n-            end if;\n-\n-            declare\n-               N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n-            begin\n-               return N (Node).Element;\n-            end;\n+            return N (Node).Element;\n          end;\n       end Element;\n \n@@ -1137,85 +739,48 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       -------------\n \n       procedure Exclude (Container : in out Set; Key : Key_Type) is\n-      begin\n-         if Container.K /= Plain then\n-            raise Constraint_Error\n-              with \"Can't modify part of container\";\n-         end if;\n-\n-         declare\n \n-            X : constant Count_Type := Key_Keys.Find (Container.Tree.all, Key);\n+         X : constant Count_Type := Key_Keys.Find (Container, Key);\n \n-         begin\n-            if X /= 0 then\n-               Delete_Node_Sans_Free (Container.Tree.all, X);\n-               Formal_Ordered_Sets.Free (Container.Tree.all, X);\n-            end if;\n-         end;\n+      begin\n+         if X /= 0 then\n+            Delete_Node_Sans_Free (Container, X);\n+            Formal_Ordered_Sets.Free (Container, X);\n+         end if;\n       end Exclude;\n \n       ----------\n       -- Find --\n       ----------\n \n       function Find (Container : Set; Key : Key_Type) return Cursor is\n-      begin\n-\n-         if Container.K = Part then\n-            if Container.Length = 0 or else\n-              (Key < Generic_Keys.Key\n-                 (Container.Tree.Nodes (Container.First).Element) or\n-                 Generic_Keys.Key\n-                   (Container.Tree.Nodes (Container.Last).Element) < Key) then\n-               return No_Element;\n-            end if;\n-         end if;\n \n-         declare\n-\n-            Node : constant Count_Type := Key_Keys.Find (Container.Tree.all,\n-                                                         Key);\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n-         begin\n-            if Node = 0 then\n-               return No_Element;\n-            end if;\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n \n-            return (Node => Node);\n-         end;\n+         return (Node => Node);\n       end Find;\n \n       -----------\n       -- Floor --\n       -----------\n \n       function Floor (Container : Set; Key : Key_Type) return Cursor is\n-      begin\n-         if Container.K = Part then\n-            if Container.Length = 0 or else\n-              Key < Generic_Keys.Key\n-                (Container.Tree.Nodes (Container.First).Element) then\n-               return No_Element;\n-            end if;\n \n-            if Generic_Keys.Key\n-              (Container.Tree.Nodes (Container.Last).Element) < Key then\n-               return (Node => Container.Last);\n-            end if;\n-         end if;\n+         Node : constant Count_Type :=\n+           Key_Keys.Floor (Container, Key);\n \n-         declare\n-            Node : constant Count_Type :=\n-              Key_Keys.Floor (Container.Tree.all, Key);\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n \n-         begin\n-            if Node = 0 then\n-               return No_Element;\n-            end if;\n+         return (Node => Node);\n \n-            return (Node => Node);\n-         end;\n       end Floor;\n \n       -------------------------\n@@ -1253,11 +818,11 @@ package body Ada.Containers.Formal_Ordered_Sets is\n               \"Position cursor has no element\";\n          end if;\n \n-         pragma Assert (Vet (Container.Tree.all, Position.Node),\n+         pragma Assert (Vet (Container, Position.Node),\n                         \"bad cursor in Key\");\n \n          declare\n-            N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+            N : Tree_Types.Nodes_Type renames Container.Nodes;\n          begin\n             return Key (N (Position.Node).Element);\n          end;\n@@ -1272,20 +837,16 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Key       : Key_Type;\n          New_Item  : Element_Type)\n       is\n-         Node : constant Count_Type := Key_Keys.Find (Container.Tree.all, Key);\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n-         if Container.K /= Plain then\n-            raise Constraint_Error\n-              with \"Can't modify part of container\";\n-         end if;\n \n          if not Has_Element (Container, (Node => Node)) then\n             raise Constraint_Error with\n               \"attempt to replace key not in set\";\n          end if;\n \n-         Replace_Element (Container.Tree.all, Node, New_Item);\n+         Replace_Element (Container, Node, New_Item);\n       end Replace;\n \n       -----------------------------------\n@@ -1297,30 +858,24 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Position  : Cursor;\n          Process   : not null access procedure (Element : in out Element_Type))\n       is\n-         Tree : Tree_Types.Tree_Type renames Container.Tree.all;\n-\n       begin\n-         if Container.K /= Plain then\n-            raise Constraint_Error\n-              with \"Can't modify part of container\";\n-         end if;\n \n          if not Has_Element (Container, Position) then\n             raise Constraint_Error with\n               \"Position cursor has no element\";\n          end if;\n \n-         pragma Assert (Vet (Container.Tree.all, Position.Node),\n+         pragma Assert (Vet (Container, Position.Node),\n                         \"bad cursor in Update_Element_Preserving_Key\");\n \n          declare\n-            N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+            N : Tree_Types.Nodes_Type renames Container.Nodes;\n \n             E : Element_Type renames N (Position.Node).Element;\n             K : constant Key_Type := Key (E);\n \n-            B : Natural renames Tree.Busy;\n-            L : Natural renames Tree.Lock;\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n \n          begin\n             B := B + 1;\n@@ -1346,8 +901,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          declare\n             X : constant Count_Type := Position.Node;\n          begin\n-            Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n-            Formal_Ordered_Sets.Free (Tree, X);\n+            Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+            Formal_Ordered_Sets.Free (Container, X);\n          end;\n \n          raise Program_Error with \"key was modified\";\n@@ -1365,26 +920,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          return False;\n       end if;\n \n-      if not Container.Tree.Nodes (Position.Node).Has_Element then\n-         return False;\n-      end if;\n-\n-      if Container.K = Plain then\n-         return True;\n-      end if;\n-\n-      declare\n-         Elt : constant Element_Type :=\n-           Container.Tree.Nodes (Position.Node).Element;\n-      begin\n-\n-         if Elt < Container.Tree.Nodes (Container.First).Element or\n-           Container.Tree.Nodes (Container.Last).Element < Elt then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end;\n+      return Container.Nodes (Position.Node).Has_Element;\n    end Has_Element;\n \n    -------------\n@@ -1399,13 +935,13 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         if Container.Tree.Lock > 0 then\n+         if Container.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n          declare\n-            N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+            N : Tree_Types.Nodes_Type renames Container.Nodes;\n          begin\n             N (Position.Node).Element := New_Item;\n          end;\n@@ -1423,13 +959,9 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Inserted  : out Boolean)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       Insert_Sans_Hint\n-        (Container.Tree.all,\n+        (Container,\n          New_Item,\n          Position.Node,\n          Inserted);\n@@ -1457,7 +989,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    ----------------------\n \n    procedure Insert_Sans_Hint\n-     (Container : in out Tree_Types.Tree_Type;\n+     (Container : in out Set;\n       New_Item  : Element_Type;\n       Node      : out Count_Type;\n       Inserted  : out Boolean)\n@@ -1513,7 +1045,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    ----------------------\n \n    procedure Insert_With_Hint\n-     (Dst_Set  : in out Tree_Types.Tree_Type;\n+     (Dst_Set  : in out Set;\n       Dst_Hint : Count_Type;\n       Src_Node : Node_Type;\n       Dst_Node : out Count_Type)\n@@ -1578,70 +1110,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Intersection (Target : in out Set; Source : Set) is\n    begin\n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      if Source.K = Plain then\n-         Set_Ops.Set_Intersection (Target.Tree.all, Source.Tree.all);\n-      else\n-         declare\n-            Tgt : Count_Type := Target.First;\n-            Src : Count_Type := Source.First;\n-\n-            S_Last : constant Count_Type :=\n-              Next (Source.Tree.all, Source.Last);\n-\n-         begin\n-            if Target'Address = Source'Address then\n-               return;\n-            end if;\n-\n-            if Target.Tree.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors (container is busy)\";\n-            end if;\n-\n-            if Source.Length = 0 then\n-               Clear (Target);\n-               return;\n-            end if;\n-\n-            while Tgt /= 0\n-              and then Src /= S_Last\n-            loop\n-               if Target.Tree.Nodes (Tgt).Element <\n-                 Source.Tree.Nodes (Src).Element then\n-                  declare\n-                     X : constant Count_Type := Tgt;\n-                  begin\n-                     Tgt := Next (Target.Tree.all, Tgt);\n-                     Delete_Node_Sans_Free (Target.Tree.all, X);\n-                     Formal_Ordered_Sets.Free (Target.Tree.all, X);\n-                  end;\n-\n-               elsif Source.Tree.Nodes (Src).Element <\n-                 Target.Tree.Nodes (Tgt).Element then\n-                  Src := Next (Source.Tree.all, Src);\n-\n-               else\n-                  Tgt := Next (Target.Tree.all, Tgt);\n-                  Src := Next (Source.Tree.all, Src);\n-               end if;\n-            end loop;\n-\n-            while Tgt /= 0 loop\n-               declare\n-                  X : constant Count_Type := Tgt;\n-               begin\n-                  Tgt := Next (Target.Tree.all, Tgt);\n-                  Delete_Node_Sans_Free (Target.Tree.all, X);\n-                  Formal_Ordered_Sets.Free (Target.Tree.all, X);\n-               end;\n-            end loop;\n-         end;\n-      end if;\n+      Set_Ops.Set_Intersection (Target, Source);\n    end Intersection;\n \n    function Intersection (Left, Right : Set) return Set is\n@@ -1651,55 +1120,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       return S : Set (Count_Type'Min (Length (Left), Length (Right))) do\n-         if Left.K = Plain and Right.K = Plain then\n-            Assign (S.Tree.all, Set_Ops.Set_Intersection\n-                    (Left.Tree.all, Right.Tree.all));\n-            return;\n-         end if;\n-\n-         if Length (Left) = 0 or Length (Right) = 0 then\n-            return;\n-         end if;\n-\n-         declare\n-\n-            L_Node : Count_Type := First (Left).Node;\n-            R_Node : Count_Type := First (Right).Node;\n-\n-            L_Last : constant Count_Type :=\n-              Next (Left.Tree.all, Last (Left).Node);\n-            R_Last : constant Count_Type :=\n-              Next (Right.Tree.all, Last (Right).Node);\n-\n-            Dst_Node : Count_Type;\n-\n-         begin\n-            loop\n-\n-               if L_Node = L_Last or R_Node = R_Last then\n-                  return;\n-               end if;\n-\n-               if Left.Tree.Nodes (L_Node).Element <\n-                 Right.Tree.Nodes (R_Node).Element then\n-                  L_Node := Next (Left.Tree.all, L_Node);\n-\n-               elsif Right.Tree.Nodes (R_Node).Element <\n-                 Left.Tree.Nodes (L_Node).Element then\n-                  R_Node := Next (Right.Tree.all, R_Node);\n-\n-               else\n-                  Insert_With_Hint\n-                    (Dst_Set  => S.Tree.all,\n-                     Dst_Hint => 0,\n-                     Src_Node => Left.Tree.Nodes (L_Node),\n-                     Dst_Node => Dst_Node);\n-\n-                  L_Node := Next (Left.Tree.all, L_Node);\n-                  R_Node := Next (Right.Tree.all, R_Node);\n-               end if;\n-            end loop;\n-         end;\n+            Assign (S, Set_Ops.Set_Intersection\n+                    (Left, Right));\n       end return;\n    end Intersection;\n \n@@ -1753,52 +1175,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n    begin\n-      if Subset.K = Plain and Of_Set.K = Plain then\n-         return Set_Ops.Set_Subset (Subset.Tree.all,\n-                                    Of_Set => Of_Set.Tree.all);\n-      end if;\n-\n-      if Subset'Address = Of_Set'Address then\n-         return True;\n-      end if;\n-\n-      if Length (Subset) > Length (Of_Set) then\n-         return False;\n-      end if;\n-\n-      declare\n-         Subset_Node : Count_Type := First (Subset).Node;\n-         Set_Node    : Count_Type := First (Of_Set).Node;\n-\n-         Subset_Last : constant Count_Type :=\n-           Next (Subset.Tree.all, Last (Subset).Node);\n-         Set_Last    : constant Count_Type :=\n-           Next (Of_Set.Tree.all, Last (Of_Set).Node);\n-\n-      begin\n-         loop\n-            if Set_Node = Set_Last then\n-               return Subset_Node = 0;\n-            end if;\n-\n-            if Subset_Node = Subset_Last then\n-               return True;\n-            end if;\n-\n-            if Subset.Tree.Nodes (Subset_Node).Element <\n-              Of_Set.Tree.Nodes (Set_Node).Element then\n-               return False;\n-            end if;\n-\n-            if Of_Set.Tree.Nodes (Set_Node).Element <\n-              Subset.Tree.Nodes (Subset_Node).Element then\n-               Set_Node := Next (Of_Set.Tree.all, Set_Node);\n-            else\n-               Set_Node := Next (Of_Set.Tree.all, Set_Node);\n-               Subset_Node := Next (Subset.Tree.all, Subset_Node);\n-            end if;\n-         end loop;\n-      end;\n+      return Set_Ops.Set_Subset (Subset,\n+                                 Of_Set => Of_Set);\n    end Is_Subset;\n \n    -------------\n@@ -1816,9 +1194,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       procedure Local_Iterate is\n         new Tree_Operations.Generic_Iteration (Process_Node);\n \n-      procedure Local_Iterate_Between is\n-        new Iterate_Between (Process_Node);\n-\n       ------------------\n       -- Process_Node --\n       ------------------\n@@ -1828,26 +1203,15 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Process (Container, (Node => Node));\n       end Process_Node;\n \n-      T : Tree_Types.Tree_Type renames Container.Tree.all;\n-      B : Natural renames T.Busy;\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n \n       --  Start of prccessing for Iterate\n \n    begin\n       B := B + 1;\n \n       begin\n-         if Container.K = Plain then\n-            Local_Iterate (T);\n-            return;\n-         end if;\n-\n-         if Container.Length = 0 then\n-            return;\n-         end if;\n-\n-         Local_Iterate_Between (T, Container.First, Container.Last);\n-\n+         Local_Iterate (Container);\n       exception\n          when others =>\n             B := B - 1;\n@@ -1857,42 +1221,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       B := B - 1;\n    end Iterate;\n \n-   ---------------------\n-   -- Iterate_Between --\n-   ---------------------\n-\n-   procedure Iterate_Between (Tree : Tree_Types.Tree_Type;\n-                              From : Count_Type;\n-                              To   : Count_Type) is\n-\n-      FElt : constant Element_Type := Tree.Nodes (From).Element;\n-      TElt : constant Element_Type := Tree.Nodes (To).Element;\n-      procedure Iterate (P : Count_Type);\n-\n-      -------------\n-      -- Iterate --\n-      -------------\n-\n-      procedure Iterate (P : Count_Type) is\n-         X : Count_Type := P;\n-      begin\n-         while X /= 0 loop\n-            if Tree.Nodes (X).Element < FElt then\n-               X := Tree.Nodes (X).Right;\n-            elsif TElt < Tree.Nodes (X).Element then\n-               X := Tree.Nodes (X).Left;\n-            else\n-               Iterate (Tree.Nodes (X).Left);\n-               Process (X);\n-               X := Tree.Nodes (X).Right;\n-            end if;\n-         end loop;\n-      end Iterate;\n-\n-   begin\n-      Iterate (Tree.Root);\n-   end Iterate_Between;\n-\n    ----------\n    -- Last --\n    ----------\n@@ -1903,11 +1231,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      if Container.K = Plain then\n-         return (Node => Container.Tree.Last);\n-      end if;\n-\n       return (Node => Container.Last);\n+\n    end Last;\n \n    ------------------\n@@ -1921,7 +1246,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       declare\n-         N : Tree_Types.Nodes_Type renames Container.Tree.Nodes;\n+         N : Tree_Types.Nodes_Type renames Container.Nodes;\n       begin\n          return N (Last (Container).Node).Element;\n       end;\n@@ -1932,35 +1257,24 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    ----------\n \n    function Left (Container : Set; Position : Cursor) return Set is\n-      Lst : Count_Type;\n-      Fst : constant Count_Type := First (Container).Node;\n-      L   : Count_Type := 0;\n-      C   : Count_Type := Fst;\n+      Curs : Cursor := Position;\n+      C : Set (Container.Capacity) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n    begin\n-      while C /= Position.Node loop\n-         if C = Last (Container).Node or C = 0 then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-         Lst := C;\n-         C := Next (Container.Tree.all, C);\n-         L := L + 1;\n-      end loop;\n-      if L = 0 then\n-         return (Capacity => Container.Capacity,\n-                 K        => Part,\n-                 Tree     => Container.Tree,\n-                 Length   => 0,\n-                 First    => 0,\n-                 Last     => 0);\n-      else\n-         return (Capacity => Container.Capacity,\n-                 K        => Part,\n-                 Tree     => Container.Tree,\n-                 Length   => L,\n-                 First    => Fst,\n-                 Last     => Lst);\n+      if Curs = No_Element then\n+         return C;\n+      end if;\n+      if not Has_Element (Container, Curs) then\n+         raise Constraint_Error;\n       end if;\n+\n+      while Curs.Node /= 0 loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+      return C;\n    end Left;\n \n    --------------\n@@ -1978,27 +1292,18 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function Length (Container : Set) return Count_Type is\n    begin\n-      if Container.K = Plain then\n-         return Container.Tree.Length;\n-      else\n-         return Container.Length;\n-      end if;\n+      return Container.Length;\n    end Length;\n \n    ----------\n    -- Move --\n    ----------\n \n    procedure Move (Target : in out Set; Source : in out Set) is\n-      S : Tree_Types.Tree_Type renames Source.Tree.all;\n-      N : Tree_Types.Nodes_Type renames S.Nodes;\n+      N : Tree_Types.Nodes_Type renames Source.Nodes;\n       X : Count_Type;\n \n    begin\n-      if Target.K /= Plain or Source.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Target'Address = Source'Address then\n          return;\n@@ -2009,41 +1314,28 @@ package body Ada.Containers.Formal_Ordered_Sets is\n            \"Source length exceeds Target capacity\";\n       end if;\n \n-      if S.Busy > 0 then\n+      if Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n       Clear (Target);\n \n       loop\n-         X := S.First;\n+         X := Source.First;\n          exit when X = 0;\n \n          Insert (Target, N (X).Element);  -- optimize???\n \n-         Tree_Operations.Delete_Node_Sans_Free (S, X);\n-         Formal_Ordered_Sets.Free (S, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Source, X);\n+         Formal_Ordered_Sets.Free (Source, X);\n       end loop;\n    end Move;\n \n    ----------\n    -- Next --\n    ----------\n \n-   function Next_Unchecked\n-     (Container : Set;\n-      Position  : Count_Type) return Count_Type is\n-   begin\n-\n-      if Container.K = Part and then\n-        (Container.Length = 0 or Position = Container.Last) then\n-         return 0;\n-      end if;\n-\n-      return Tree_Operations.Next (Container.Tree.all, Position);\n-   end Next_Unchecked;\n-\n    function Next (Container : Set; Position : Cursor) return Cursor is\n    begin\n       if Position = No_Element then\n@@ -2054,9 +1346,9 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          raise Constraint_Error;\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Next\");\n-      return (Node => Next_Unchecked (Container, Position.Node));\n+      return (Node => Tree_Operations.Next (Container, Position.Node));\n    end Next;\n \n    procedure Next (Container : Set; Position : in out Cursor) is\n@@ -2070,49 +1362,8 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    function Overlap (Left, Right : Set) return Boolean is\n    begin\n-      if Left.K = Plain and Right.K = Plain then\n-         return Set_Ops.Set_Overlap (Left.Tree.all, Right.Tree.all);\n-      end if;\n-\n-      if Length (Left) = 0 or Length (Right) = 0 then\n-         return False;\n-      end if;\n-\n-      declare\n-\n-         L_Node : Count_Type := First (Left).Node;\n-         R_Node : Count_Type := First (Right).Node;\n+      return Set_Ops.Set_Overlap (Left, Right);\n \n-         L_Last : constant Count_Type :=\n-           Next (Left.Tree.all, Last (Left).Node);\n-         R_Last : constant Count_Type :=\n-           Next (Right.Tree.all, Last (Right).Node);\n-\n-      begin\n-         if Left'Address = Right'Address then\n-            return True;\n-         end if;\n-\n-         loop\n-            if L_Node = L_Last\n-              or else R_Node = R_Last\n-            then\n-               return False;\n-            end if;\n-\n-            if Left.Tree.Nodes (L_Node).Element <\n-              Right.Tree.Nodes (R_Node).Element then\n-               L_Node := Next (Left.Tree.all, L_Node);\n-\n-            elsif Right.Tree.Nodes (R_Node).Element <\n-              Left.Tree.Nodes (L_Node).Element then\n-               R_Node := Next (Right.Tree.all, R_Node);\n-\n-            else\n-               return True;\n-            end if;\n-         end loop;\n-      end;\n    end Overlap;\n \n    ------------\n@@ -2138,18 +1389,12 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          raise Constraint_Error;\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Previous\");\n \n-      if Container.K = Part and then\n-        (Container.Length = 0 or Position.Node = Container.First) then\n-         return No_Element;\n-      end if;\n-\n       declare\n-         Tree : Tree_Types.Tree_Type renames Container.Tree.all;\n          Node : constant Count_Type :=\n-           Tree_Operations.Previous (Tree, Position.Node);\n+           Tree_Operations.Previous (Container, Position.Node);\n \n       begin\n          if Node = 0 then\n@@ -2175,30 +1420,25 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Process   : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Query_Element\");\n \n       declare\n-         T : Tree_Types.Tree_Type renames Container.Tree.all;\n \n-         B : Natural renames T.Busy;\n-         L : Natural renames T.Lock;\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n \n       begin\n          B := B + 1;\n          L := L + 1;\n \n          begin\n-            Process (T.Nodes (Position.Node).Element);\n+            Process (Container.Nodes (Position.Node).Element);\n          exception\n             when others =>\n                L := L - 1;\n@@ -2238,20 +1478,9 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end Read_Element;\n \n       --  Start of processing for Read\n-      Result : Tree_Type_Access;\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error;\n-      end if;\n \n-      if Container.Tree = null then\n-         Result := new Tree_Types.Tree_Type (Container.Capacity);\n-      else\n-         Result := Container.Tree;\n-      end if;\n-\n-      Read_Elements (Stream, Result.all);\n-      Container.Tree := Result;\n+      Read_Elements (Stream, Container);\n    end Read;\n \n    procedure Read\n@@ -2267,37 +1496,30 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    -------------\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type) is\n-   begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n-      declare\n-         Node : constant Count_Type :=\n-           Element_Keys.Find (Container.Tree.all, New_Item);\n+      Node : constant Count_Type :=\n+        Element_Keys.Find (Container, New_Item);\n \n-      begin\n-         if Node = 0 then\n-            raise Constraint_Error with\n-              \"attempt to replace element not in set\";\n-         end if;\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"attempt to replace element not in set\";\n+      end if;\n \n-         if Container.Tree.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (set is locked)\";\n-         end if;\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is locked)\";\n+      end if;\n \n-         Container.Tree.Nodes (Node).Element := New_Item;\n-      end;\n+      Container.Nodes (Node).Element := New_Item;\n    end Replace;\n \n    ---------------------\n    -- Replace_Element --\n    ---------------------\n \n    procedure Replace_Element\n-     (Tree : in out Tree_Types.Tree_Type;\n+     (Tree : in out Set;\n       Node : Count_Type;\n       Item : Element_Type)\n    is\n@@ -2398,20 +1620,16 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container.Tree.all, Position.Node),\n+      pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Replace_Element\");\n \n-      Replace_Element (Container.Tree.all, Position.Node, New_Item);\n+      Replace_Element (Container, Position.Node, New_Item);\n    end Replace_Element;\n \n    ---------------------\n@@ -2438,38 +1656,15 @@ package body Ada.Containers.Formal_Ordered_Sets is\n          Process (Container, (Node => Node));\n       end Process_Node;\n \n-      T : Tree_Types.Tree_Type renames Container.Tree.all;\n-      B : Natural renames T.Busy;\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n \n       --  Start of processing for Reverse_Iterate\n \n    begin\n       B := B + 1;\n \n       begin\n-         if Container.K = Plain then\n-            Local_Reverse_Iterate (T);\n-            return;\n-         end if;\n-\n-         if Container.Length = 0 then\n-            return;\n-         end if;\n-\n-         declare\n-            Node  : Count_Type := Container.Last;\n-            First : constant Count_Type :=\n-              Previous (Container.Tree.all, Container.First);\n-\n-         begin\n-\n-            while Node /= First loop\n-               Process_Node (Node);\n-               Node := Previous (Container.Tree.all, Node);\n-            end loop;\n-\n-         end;\n-\n+         Local_Reverse_Iterate (Container);\n       exception\n          when others =>\n             B := B - 1;\n@@ -2484,46 +1679,25 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    -----------\n \n    function Right (Container : Set; Position : Cursor) return Set is\n-      Lst : Count_Type;\n-      L   : Count_Type := 0;\n-      C   : Count_Type := Position.Node;\n-   begin\n-\n-      if C = 0 then\n-         return (Capacity => Container.Capacity,\n-                 K        => Part,\n-                 Tree     => Container.Tree,\n-                 Length   => 0,\n-                 First    => 0,\n-                 Last     => 0);\n-      end if;\n-\n-      if Container.K = Plain then\n-         Lst := 0;\n-      else\n-         Lst := Next (Container.Tree.all, Container.Last);\n+      Curs : Cursor := First (Container);\n+      C : Set (Container.Capacity) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+   begin\n+      if Curs = No_Element then\n+         Clear (C);\n+         return C;\n       end if;\n-\n-      if C = Lst then\n-         raise Constraint_Error with\n-           \"Position cursor has no element\";\n+      if Position /= No_Element and not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n       end if;\n \n-      while C /= Lst loop\n-         if C = 0 then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-         C := Next (Container.Tree.all, C);\n-         L := L + 1;\n+      while Curs.Node /= Position.Node loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n       end loop;\n-\n-      return (Capacity => Container.Capacity,\n-              K        => Part,\n-              Tree     => Container.Tree,\n-              Length   => L,\n-              First    => Position.Node,\n-              Last     => Last (Container).Node);\n+      return C;\n    end Right;\n \n    ---------------\n@@ -2591,13 +1765,13 @@ package body Ada.Containers.Formal_Ordered_Sets is\n             return True;\n          end if;\n \n-         if Left.Tree.Nodes (LNode).Element /=\n-           Right.Tree.Nodes (RNode).Element then\n+         if Left.Nodes (LNode).Element /=\n+           Right.Nodes (RNode).Element then\n             exit;\n          end if;\n \n-         LNode := Next_Unchecked (Left, LNode);\n-         RNode := Next_Unchecked (Right, RNode);\n+         LNode := Next (Left, LNode);\n+         RNode := Next (Right, RNode);\n       end loop;\n       return False;\n \n@@ -2609,86 +1783,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n    begin\n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      if Source.K = Plain then\n-         Set_Ops.Set_Symmetric_Difference (Target.Tree.all, Source.Tree.all);\n-         return;\n-      end if;\n-\n-      if Source.Length = 0 then\n-         return;\n-      end if;\n-\n-      declare\n-\n-         Tgt : Count_Type := Target.First;\n-         Src : Count_Type := Source.First;\n-\n-         SLast : constant Count_Type := Next (Source.Tree.all, Source.Last);\n-\n-         New_Tgt_Node : Count_Type;\n-\n-      begin\n-         if Target.Tree.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (container is busy)\";\n-         end if;\n-\n-         if Target'Address = Source'Address then\n-            Clear (Target);\n-            return;\n-         end if;\n-\n-         loop\n-            if Tgt = 0 then\n-               while Src /= SLast loop\n-                  Insert_With_Hint\n-                    (Dst_Set  => Target.Tree.all,\n-                     Dst_Hint => 0,\n-                     Src_Node => Source.Tree.Nodes (Src),\n-                     Dst_Node => New_Tgt_Node);\n-\n-                  Src := Next (Source.Tree.all, Src);\n-               end loop;\n-\n-               return;\n-            end if;\n-\n-            if Src = SLast then\n-               return;\n-            end if;\n-\n-            if Target.Tree.Nodes (Tgt).Element <\n-              Source.Tree.Nodes (Src).Element then\n-               Tgt := Next (Target.Tree.all, Tgt);\n-\n-            elsif Source.Tree.Nodes (Src).Element <\n-              Target.Tree.Nodes (Tgt).Element then\n-               Insert_With_Hint\n-                 (Dst_Set  => Target.Tree.all,\n-                  Dst_Hint => Tgt,\n-                  Src_Node => Source.Tree.Nodes (Src),\n-                  Dst_Node => New_Tgt_Node);\n-\n-               Src := Next (Source.Tree.all, Src);\n-\n-            else\n-               declare\n-                  X : constant Count_Type := Tgt;\n-               begin\n-                  Tgt := Next (Target.Tree.all, Tgt);\n-                  Delete_Node_Sans_Free (Target.Tree.all, X);\n-                  Formal_Ordered_Sets.Free (Target.Tree.all, X);\n-               end;\n-\n-               Src := Next (Source.Tree.all, Src);\n-            end if;\n-         end loop;\n-      end;\n+      Set_Ops.Set_Symmetric_Difference (Target, Source);\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left, Right : Set) return Set is\n@@ -2706,84 +1801,9 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end if;\n \n       return S : Set (Length (Left) + Length (Right)) do\n-         if Left.K = Plain and Right.K = Plain then\n-            Assign (S.Tree.all,\n-              Set_Ops.Set_Symmetric_Difference (Left.Tree.all,\n-                Right.Tree.all));\n-            return;\n-         end if;\n-\n-         declare\n-\n-            Tree : Tree_Types.Tree_Type renames S.Tree.all;\n-\n-            L_Node : Count_Type := First (Left).Node;\n-            R_Node : Count_Type := First (Right).Node;\n-\n-            L_Last : constant Count_Type :=\n-              Next (Left.Tree.all, Last (Left).Node);\n-            R_Last : constant Count_Type :=\n-              Next (Right.Tree.all, Last (Right).Node);\n-\n-            Dst_Node : Count_Type;\n-\n-         begin\n-            loop\n-               if L_Node = L_Last then\n-                  while R_Node /= R_Last loop\n-                     Insert_With_Hint\n-                       (Dst_Set  => Tree,\n-                        Dst_Hint => 0,\n-                        Src_Node => Right.Tree.Nodes (R_Node),\n-                        Dst_Node => Dst_Node);\n-\n-                     R_Node := Next (Right.Tree.all, R_Node);\n-                  end loop;\n-\n-                  return;\n-               end if;\n-\n-               if R_Node = R_Last then\n-                  while L_Node /= L_Last  loop\n-                     Insert_With_Hint\n-                       (Dst_Set  => Tree,\n-                        Dst_Hint => 0,\n-                        Src_Node => Left.Tree.Nodes (L_Node),\n-                        Dst_Node => Dst_Node);\n-\n-                     L_Node := Next (Left.Tree.all, L_Node);\n-                  end loop;\n-\n-                  return;\n-               end if;\n-\n-               if Left.Tree.Nodes (L_Node).Element <\n-                 Right.Tree.Nodes (R_Node).Element then\n-                  Insert_With_Hint\n-                    (Dst_Set  => Tree,\n-                     Dst_Hint => 0,\n-                     Src_Node => Left.Tree.Nodes (L_Node),\n-                     Dst_Node => Dst_Node);\n-\n-                  L_Node := Next (Left.Tree.all, L_Node);\n-\n-               elsif Right.Tree.Nodes (R_Node).Element <\n-                 Left.Tree.Nodes (L_Node).Element then\n-                  Insert_With_Hint\n-                    (Dst_Set  => Tree,\n-                     Dst_Hint => 0,\n-                     Src_Node => Right.Tree.Nodes (R_Node),\n-                     Dst_Node => Dst_Node);\n-\n-                  R_Node := Next (Right.Tree.all, R_Node);\n-\n-               else\n-                  L_Node := Next (Left.Tree.all, L_Node);\n-                  R_Node := Next (Right.Tree.all, R_Node);\n-               end if;\n-            end loop;\n-         end;\n-\n+            Assign (S,\n+              Set_Ops.Set_Symmetric_Difference (Left,\n+                Right));\n       end return;\n    end Symmetric_Difference;\n \n@@ -2797,7 +1817,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    begin\n       return S : Set (Capacity => 1) do\n-         Insert_Sans_Hint (S.Tree.all, New_Item, Node, Inserted);\n+         Insert_Sans_Hint (S, New_Item, Node, Inserted);\n          pragma Assert (Inserted);\n       end return;\n    end To_Set;\n@@ -2808,55 +1828,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Union (Target : in out Set; Source : Set) is\n    begin\n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      if Source.K = Plain then\n-         Set_Ops.Set_Union (Target.Tree.all, Source.Tree.all);\n-         return;\n-      end if;\n-\n-      if Source.Length = 0 then\n-         return;\n-      end if;\n-\n-      declare\n-         Hint : Count_Type := 0;\n-\n-         procedure Process (Node : Count_Type);\n-         pragma Inline (Process);\n-\n-         procedure Iterate is new Iterate_Between (Process);\n-\n-         -------------\n-         -- Process --\n-         -------------\n-\n-         procedure Process (Node : Count_Type) is\n-         begin\n-            Insert_With_Hint\n-              (Dst_Set  => Target.Tree.all,\n-               Dst_Hint => Hint,\n-               Src_Node => Source.Tree.Nodes (Node),\n-               Dst_Node => Hint);\n-         end Process;\n-\n-         --  Start of processing for Union\n-\n-      begin\n-         if Target'Address = Source'Address then\n-            return;\n-         end if;\n-\n-         if Target.Tree.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (container is busy)\";\n-         end if;\n-\n-         Iterate (Source.Tree.all, Source.First, Source.Last);\n-      end;\n+      Set_Ops.Set_Union (Target, Source);\n    end Union;\n \n    function Union (Left, Right : Set) return Set is\n@@ -2910,7 +1882,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       --  Start of processing for Write\n \n    begin\n-      Write_Elements (Stream, Container.Tree.all);\n+      Write_Elements (Stream, Container);\n    end Write;\n \n    procedure Write"}, {"sha": "acca6b94726547590226cec7186a22b425362b68", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -265,27 +265,18 @@ private\n \n    type Node_Type is record\n       Has_Element : Boolean := False;\n-      Parent  : Count_Type;\n-      Left    : Count_Type;\n-      Right   : Count_Type;\n+      Parent  : Count_Type := 0;\n+      Left    : Count_Type := 0;\n+      Right   : Count_Type := 0;\n       Color   : Red_Black_Trees.Color_Type;\n       Element : Element_Type;\n    end record;\n \n-   type Kind is (Plain, Part);\n-\n    package Tree_Types is\n      new Red_Black_Trees.Generic_Bounded_Tree_Types (Node_Type);\n \n-   type Tree_Type_Access is access all Tree_Types.Tree_Type;\n-\n-   type Set (Capacity : Count_Type) is tagged record\n-      Tree   : Tree_Type_Access := new Tree_Types.Tree_Type (Capacity);\n-      K      : Kind := Plain;\n-      Length : Count_Type := 0;\n-      First  : Count_Type := 0;\n-      Last   : Count_Type := 0;\n-   end record;\n+   type Set (Capacity : Count_Type) is\n+      new Tree_Types.Tree_Type (Capacity) with null record;\n \n    use Red_Black_Trees;\n    use Ada.Streams;"}, {"sha": "86b827f421d37b7b4593e1375d096318a1225ca6", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 159, "deletions": 396, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010, Free Software Foundation, Inc.              --\n+--          Copyright (C) 2010-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,55 +44,29 @@ package body Ada.Containers.Formal_Vectors is\n    function \"&\" (Left, Right : Vector) return Vector is\n       LN : constant Count_Type := Length (Left);\n       RN : constant Count_Type := Length (Right);\n-\n-      RFst : Count_Type;\n-      RLst : Count_Type;\n-      LFst : Count_Type;\n-      LLst : Count_Type;\n-\n    begin\n \n-      if Right.K = Plain then\n-         RFst := 1;\n-         RLst := RN;\n-      else\n-         RFst := Right.First;\n-         RLst := Right.First + RN - 1;\n-      end if;\n-\n-      if Left.K = Plain then\n-         LFst := 1;\n-         LLst := LN;\n-      else\n-         LFst := Left.First;\n-         LLst := Left.First + LN - 1;\n-      end if;\n-\n       if LN = 0 then\n          if RN = 0 then\n             return Empty_Vector;\n          end if;\n \n          declare\n             E : constant Elements_Array (1 .. Length (Right)) :=\n-              Right.Plain.Elements (RFst .. RLst);\n+              Right.Elements (1 .. RN);\n          begin\n-            return (Length (Right),\n-              new Plain_Vector'(Length (Right), E,\n-                Last => Right.Plain.Last, others => <>),\n-              others => <>);\n+            return (Length (Right), E,\n+                    Last => Right.Last, others => <>);\n          end;\n       end if;\n \n       if RN = 0 then\n          declare\n             E : constant Elements_Array (1 .. Length (Left)) :=\n-              Left.Plain.Elements (LFst .. LLst);\n+              Left.Elements (1 .. LN);\n          begin\n-            return (Length (Left),\n-                    new Plain_Vector'(Length (Left), E,\n-                          Last => Left.Plain.Last, others => <>),\n-                    others => <>);\n+            return (Length (Left), E,\n+                    Last => Left.Last, others => <>);\n          end;\n \n       end if;\n@@ -117,34 +91,28 @@ package body Ada.Containers.Formal_Vectors is\n          declare\n             Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-            LE : constant Elements_Array (1 .. Length (Left)) :=\n-              Left.Plain.Elements (LFst .. LLst);\n+            LE : constant Elements_Array (1 .. LN) :=\n+              Left.Elements (1 .. LN);\n \n-            RE : Elements_Array renames Right.Plain.Elements (RFst .. RLst);\n+            RE : Elements_Array renames Right.Elements (1 .. RN);\n \n             Capacity : constant Count_Type := Length (Left) + Length (Right);\n \n          begin\n-            return (Capacity,\n-                    new Plain_Vector'(Capacity, LE & RE,\n-                          Last => Last, others => <>),\n-                    others => <>);\n+            return (Capacity, LE & RE,\n+                    Last => Last, others => <>);\n          end;\n       end;\n    end \"&\";\n \n    function \"&\" (Left  : Vector; Right : Element_Type) return Vector is\n       LN          : constant Count_Type := Length (Left);\n       Last_As_Int : Int'Base;\n-      LFst        : Count_Type;\n-      LLst        : Count_Type;\n \n    begin\n       if LN = 0 then\n-         return (1,\n-                 new Plain_Vector'(1, (1 .. 1 => Right),\n-                       Index_Type'First, others => <>),\n-                 others => <>);\n+         return (1, (1 .. 1 => Right),\n+                 Index_Type'First, others => <>);\n       end if;\n \n       if Int (Index_Type'First) > Int'Last - Int (LN) then\n@@ -157,27 +125,17 @@ package body Ada.Containers.Formal_Vectors is\n          raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n-      if Left.K = Plain then\n-         LFst := 1;\n-         LLst := LN;\n-      else\n-         LFst := Left.First;\n-         LLst := Left.First + LN - 1;\n-      end if;\n-\n       declare\n          Last : constant Index_Type := Index_Type (Last_As_Int);\n \n          LE : constant Elements_Array (1 .. LN) :=\n-           Left.Plain.Elements (LFst .. LLst);\n+           Left.Elements (1 .. LN);\n \n          Capacity : constant Count_Type := Length (Left) + 1;\n \n       begin\n-         return (Capacity,\n-                 new Plain_Vector'(Capacity, LE & Right,\n-                       Last => Last, others => <>),\n-                 others => <>);\n+         return (Capacity, LE & Right,\n+                 Last => Last, others => <>);\n       end;\n \n    end \"&\";\n@@ -186,15 +144,10 @@ package body Ada.Containers.Formal_Vectors is\n       RN          : constant Count_Type := Length (Right);\n       Last_As_Int : Int'Base;\n \n-      RFst : Count_Type;\n-      RLst : Count_Type;\n-\n    begin\n       if RN = 0 then\n-         return (1,\n-                 new Plain_Vector'(1, (1 .. 1 => Left),\n-                       Index_Type'First, others => <>),\n-                 others => <>);\n+         return (1, (1 .. 1 => Left),\n+                 Index_Type'First, others => <>);\n       end if;\n \n       if Int (Index_Type'First) > Int'Last - Int (RN) then\n@@ -207,26 +160,16 @@ package body Ada.Containers.Formal_Vectors is\n          raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n-      if Right.K = Plain then\n-         RFst := 1;\n-         RLst := RN;\n-      else\n-         RFst := Right.First;\n-         RLst := Right.First + RN - 1;\n-      end if;\n-\n       declare\n          Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-         RE : Elements_Array renames Right.Plain.Elements (RFst .. RLst);\n+         RE : Elements_Array renames Right.Elements (1 .. RN);\n \n          Capacity : constant Count_Type := 1 + Length (Right);\n \n       begin\n-         return (Capacity,\n-                 new Plain_Vector'(Capacity, Left & RE,\n-                       Last => Last, others => <>),\n-                 others => <>);\n+         return (Capacity, Left & RE,\n+                 Last => Last, others => <>);\n       end;\n    end \"&\";\n \n@@ -240,10 +183,8 @@ package body Ada.Containers.Formal_Vectors is\n          Last : constant Index_Type := Index_Type'First + 1;\n \n       begin\n-         return (2,\n-                 new Plain_Vector'(2, (Left, Right),\n-                       Last => Last, others => <>),\n-                 others => <>);\n+         return (2, (Left, Right),\n+                 Last => Last, others => <>);\n       end;\n    end \"&\";\n \n@@ -277,22 +218,17 @@ package body Ada.Containers.Formal_Vectors is\n    procedure Append (Container : in out Vector; New_Item : Vector) is\n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Is_Empty (New_Item) then\n          return;\n       end if;\n \n-      if Container.Plain.Last = Index_Type'Last then\n+      if Container.Last = Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n       end if;\n \n       Insert\n         (Container,\n-         Container.Plain.Last + 1,\n+         Container.Last + 1,\n          New_Item);\n    end Append;\n \n@@ -303,24 +239,19 @@ package body Ada.Containers.Formal_Vectors is\n    is\n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Count = 0 then\n          return;\n       end if;\n \n-      if Container.Plain.Last = Index_Type'Last then\n+      if Container.Last = Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n       end if;\n \n       --  TODO: should check whether length > max capacity (cnt_t'last)  ???\n \n       Insert\n         (Container,\n-         Container.Plain.Last + 1,\n+         Container.Last + 1,\n          New_Item,\n          Count);\n    end Append;\n@@ -333,11 +264,6 @@ package body Ada.Containers.Formal_Vectors is\n       LS : constant Count_Type := Length (Source);\n    begin\n \n-      if Target.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -348,15 +274,9 @@ package body Ada.Containers.Formal_Vectors is\n \n       Target.Clear;\n \n-      if Source.K = Plain then\n-         Target.Plain.Elements (1 .. LS) :=\n-           Source.Plain.Elements (1 .. LS);\n-         Target.Plain.Last := Source.Plain.Last;\n-      else\n-         Target.Plain.Elements (1 .. LS) :=\n-           Source.Plain.Elements (Source.First .. (Source.First + LS - 1));\n-         Target.Plain.Last := Source.Last;\n-      end if;\n+         Target.Elements (1 .. LS) :=\n+           Source.Elements (1 .. LS);\n+         Target.Last := Source.Last;\n \n    end Assign;\n \n@@ -366,7 +286,7 @@ package body Ada.Containers.Formal_Vectors is\n \n    function Capacity (Container : Vector) return Capacity_Subtype is\n    begin\n-      return Container.Plain.Elements'Length;\n+      return Container.Elements'Length;\n    end Capacity;\n \n    -----------\n@@ -376,17 +296,12 @@ package body Ada.Containers.Formal_Vectors is\n    procedure Clear (Container : in out Vector) is\n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n-      if Container.Plain.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n-      Container.Plain.Last := No_Index;\n+      Container.Last := No_Index;\n    end Clear;\n \n    --------------\n@@ -424,15 +339,9 @@ package body Ada.Containers.Formal_Vectors is\n       end if;\n \n       return Target                   : Vector (C) do\n-         if Source.K = Plain then\n-            Target.Plain.Elements (1 .. LS) :=\n-              Source.Plain.Elements (1 .. LS);\n-            Target.Plain.Last := Source.Plain.Last;\n-         else\n-            Target.Plain.Elements (1 .. LS) :=\n-              Source.Plain.Elements (Source.First .. (Source.First + LS - 1));\n-            Target.Plain.Last := Source.Last;\n-         end if;\n+         Target.Elements (1 .. LS) :=\n+           Source.Elements (1 .. LS);\n+         Target.Last := Source.Last;\n \n       end return;\n    end Copy;\n@@ -448,17 +357,12 @@ package body Ada.Containers.Formal_Vectors is\n    is\n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Index < Index_Type'First then\n          raise Constraint_Error with \"Index is out of range (too small)\";\n       end if;\n \n-      if Index > Container.Plain.Last then\n-         if Index > Container.Plain.Last + 1 then\n+      if Index > Container.Last then\n+         if Index > Container.Last + 1 then\n             raise Constraint_Error with \"Index is out of range (too large)\";\n          end if;\n \n@@ -469,15 +373,15 @@ package body Ada.Containers.Formal_Vectors is\n          return;\n       end if;\n \n-      if Container.Plain.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       declare\n          I_As_Int        : constant Int := Int (Index);\n          Old_Last_As_Int : constant Int :=\n-                             Index_Type'Pos (Container.Plain.Last);\n+                             Index_Type'Pos (Container.Last);\n \n          Count1 : constant Int'Base := Count_Type'Pos (Count);\n          Count2 : constant Int'Base := Old_Last_As_Int - I_As_Int + 1;\n@@ -487,11 +391,11 @@ package body Ada.Containers.Formal_Vectors is\n \n       begin\n          if J_As_Int > Old_Last_As_Int then\n-            Container.Plain.Last := Index - 1;\n+            Container.Last := Index - 1;\n \n          else\n             declare\n-               EA : Elements_Array renames Container.Plain.Elements;\n+               EA : Elements_Array renames Container.Elements;\n \n                II : constant Int'Base := I_As_Int - Int (No_Index);\n                I  : constant Count_Type := Count_Type (II);\n@@ -508,7 +412,7 @@ package body Ada.Containers.Formal_Vectors is\n \n             begin\n                EA (I .. K) := EA (J .. Length (Container));\n-               Container.Plain.Last := New_Last;\n+               Container.Last := New_Last;\n             end;\n          end if;\n       end;\n@@ -521,16 +425,11 @@ package body Ada.Containers.Formal_Vectors is\n    is\n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if not Position.Valid then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Index > Container.Plain.Last then\n+      if Position.Index > Container.Last then\n          raise Program_Error with \"Position index is out of range\";\n       end if;\n \n@@ -548,11 +447,6 @@ package body Ada.Containers.Formal_Vectors is\n    is\n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Count = 0 then\n          return;\n       end if;\n@@ -577,26 +471,21 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Count = 0 then\n          return;\n       end if;\n \n-      if Container.Plain.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n-      Index := Int'Base (Container.Plain.Last) - Int'Base (Count);\n+      Index := Int'Base (Container.Last) - Int'Base (Count);\n \n       if Index < Index_Type'Pos (Index_Type'First) then\n-         Container.Plain.Last := No_Index;\n+         Container.Last := No_Index;\n       else\n-         Container.Plain.Last := Index_Type (Index);\n+         Container.Last := Index_Type (Index);\n       end if;\n    end Delete_Last;\n \n@@ -609,7 +498,7 @@ package body Ada.Containers.Formal_Vectors is\n       Index     : Index_Type) return Element_Type\n    is\n    begin\n-      if Index > Container.Plain.Last then\n+      if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n@@ -619,11 +508,6 @@ package body Ada.Containers.Formal_Vectors is\n \n       begin\n \n-         if Container.K = Part and then\n-           (I > Length (Container)) then\n-            raise Constraint_Error with \"Index is out of range\";\n-         end if;\n-\n          return Get_Element (Container, I);\n       end;\n    end Element;\n@@ -760,7 +644,7 @@ package body Ada.Containers.Formal_Vectors is\n          Last : constant Index_Type := Last_Index (Container);\n       begin\n \n-         if Container.Plain.Last <= Last then\n+         if Container.Last <= Last then\n             return True;\n          end if;\n \n@@ -786,14 +670,9 @@ package body Ada.Containers.Formal_Vectors is\n       procedure Merge (Target, Source : in out Vector) is\n       begin\n \n-         if Target.K /= Plain or Source.K /= Plain then\n-            raise Constraint_Error\n-              with \"Can't modify part of container\";\n-         end if;\n-\n          declare\n-            TA : Elements_Array renames Target.Plain.Elements;\n-            SA : Elements_Array renames Source.Plain.Elements;\n+            TA : Elements_Array renames Target.Elements;\n+            SA : Elements_Array renames Source.Elements;\n \n             I, J : Count_Type;\n \n@@ -808,17 +687,17 @@ package body Ada.Containers.Formal_Vectors is\n                return;\n             end if;\n \n-            if Source.Plain.Last < Index_Type'First then\n+            if Source.Last < Index_Type'First then\n                return;\n             end if;\n \n             --  I think we're missing this check in a-convec.adb...  ???\n-            if Target.Plain.Busy > 0 then\n+            if Target.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with elements (vector is busy)\";\n             end if;\n \n-            if Source.Plain.Busy > 0 then\n+            if Source.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with elements (vector is busy)\";\n             end if;\n@@ -834,7 +713,7 @@ package body Ada.Containers.Formal_Vectors is\n \n                if I = 0 then\n                   TA (1 .. J) := SA (1 .. Length (Source));\n-                  Source.Plain.Last := No_Index;\n+                  Source.Last := No_Index;\n                   return;\n                end if;\n \n@@ -847,7 +726,7 @@ package body Ada.Containers.Formal_Vectors is\n \n                else\n                   TA (J) := SA (Length (Source));\n-                  Source.Plain.Last := Source.Plain.Last - 1;\n+                  Source.Last := Source.Last - 1;\n                end if;\n \n                J := J - 1;\n@@ -867,24 +746,18 @@ package body Ada.Containers.Formal_Vectors is\n               Element_Type => Element_Type,\n               Array_Type   => Elements_Array,\n               \"<\"          => \"<\");\n-\n       begin\n \n-         if Container.K /= Plain then\n-            raise Constraint_Error\n-              with \"Can't modify part of container\";\n-         end if;\n-\n-         if Container.Plain.Last <= Index_Type'First then\n+         if Container.Last <= Index_Type'First then\n             return;\n          end if;\n \n-         if Container.Plain.Lock > 0 then\n+         if Container.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors (vector is locked)\";\n          end if;\n \n-         Sort (Container.Plain.Elements (1 .. Length (Container)));\n+         Sort (Container.Elements (1 .. Length (Container)));\n       end Sort;\n \n    end Generic_Sorting;\n@@ -897,11 +770,9 @@ package body Ada.Containers.Formal_Vectors is\n      (Container : Vector;\n       Position  : Count_Type) return Element_Type is\n    begin\n-      if Container.K = Plain then\n-         return Container.Plain.Elements (Position);\n-      end if;\n \n-      return Container.Plain.Elements (Position + Container.First - 1);\n+      return Container.Elements (Position);\n+\n    end Get_Element;\n \n    -----------------\n@@ -939,18 +810,13 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Before < Index_Type'First then\n          raise Constraint_Error with\n            \"Before index is out of range (too small)\";\n       end if;\n \n-      if Before > Container.Plain.Last\n-        and then Before > Container.Plain.Last + 1\n+      if Before > Container.Last\n+        and then Before > Container.Last + 1\n       then\n          raise Constraint_Error with\n            \"Before index is out of range (too large)\";\n@@ -961,7 +827,7 @@ package body Ada.Containers.Formal_Vectors is\n       end if;\n \n       declare\n-         Old_Last_As_Int : constant Int := Int (Container.Plain.Last);\n+         Old_Last_As_Int : constant Int := Int (Container.Last);\n \n       begin\n          if Old_Last_As_Int > Int'Last - N then\n@@ -985,13 +851,13 @@ package body Ada.Containers.Formal_Vectors is\n          --  Resolve issue of capacity vs. max index  ???\n       end;\n \n-      if Container.Plain.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       declare\n-         EA : Elements_Array renames Container.Plain.Elements;\n+         EA : Elements_Array renames Container.Elements;\n \n          BB : constant Int'Base := Int (Before) - Int (No_Index);\n          B  : constant Count_Type := Count_Type (BB);\n@@ -1000,7 +866,7 @@ package body Ada.Containers.Formal_Vectors is\n          L  : constant Count_Type := Count_Type (LL);\n \n       begin\n-         if Before <= Container.Plain.Last then\n+         if Before <= Container.Last then\n             declare\n                II : constant Int'Base := BB + N;\n                I  : constant Count_Type := Count_Type (II);\n@@ -1015,7 +881,7 @@ package body Ada.Containers.Formal_Vectors is\n          end if;\n       end;\n \n-      Container.Plain.Last := New_Last;\n+      Container.Last := New_Last;\n    end Insert;\n \n    procedure Insert\n@@ -1027,18 +893,13 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Before < Index_Type'First then\n          raise Constraint_Error with\n            \"Before index is out of range (too small)\";\n       end if;\n \n-      if Before > Container.Plain.Last\n-        and then Before > Container.Plain.Last + 1\n+      if Before > Container.Last\n+        and then Before > Container.Last + 1\n       then\n          raise Constraint_Error with\n            \"Before index is out of range (too large)\";\n@@ -1056,37 +917,26 @@ package body Ada.Containers.Formal_Vectors is\n \n          Dst_Last : constant Count_Type := Count_Type (Dst_Last_As_Int);\n \n-         Src_Fst : Count_Type;\n-         Src_Lst : Count_Type;\n-\n          BB : constant Int'Base := Int (Before) - Int (No_Index);\n          B  : constant Count_Type := Count_Type (BB);\n \n       begin\n \n-         if Container.K = Plain then\n-            Src_Fst := 1;\n-            Src_Lst := N;\n-         else\n-            Src_Fst := New_Item.First;\n-            Src_Lst := N + New_Item.First - 1;\n-         end if;\n-\n          if Container'Address /= New_Item'Address then\n-            Container.Plain.Elements (B .. Dst_Last) :=\n-              New_Item.Plain.Elements (Src_Fst .. Src_Lst);\n+            Container.Elements (B .. Dst_Last) :=\n+              New_Item.Elements (1 .. N);\n \n             return;\n          end if;\n \n          declare\n-            Src : Elements_Array renames Container.Plain.Elements (1 .. B - 1);\n+            Src : Elements_Array renames Container.Elements (1 .. B - 1);\n \n             Index_As_Int : constant Int'Base := BB + Src'Length - 1;\n \n             Index : constant Count_Type := Count_Type (Index_As_Int);\n \n-            Dst : Elements_Array renames Container.Plain.Elements (B .. Index);\n+            Dst : Elements_Array renames Container.Elements (B .. Index);\n \n          begin\n             Dst := Src;\n@@ -1098,7 +948,7 @@ package body Ada.Containers.Formal_Vectors is\n \n          declare\n             Src : Elements_Array renames\n-                    Container.Plain.Elements\n+                    Container.Elements\n                       (Dst_Last + 1 .. Length (Container));\n \n             Index_As_Int : constant Int'Base :=\n@@ -1107,7 +957,7 @@ package body Ada.Containers.Formal_Vectors is\n             Index : constant Count_Type := Count_Type (Index_As_Int);\n \n             Dst : Elements_Array renames\n-                    Container.Plain.Elements (Index .. Dst_Last);\n+                    Container.Elements (Index .. Dst_Last);\n \n          begin\n             Dst := Src;\n@@ -1124,24 +974,19 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Is_Empty (New_Item) then\n          return;\n       end if;\n \n       if not Before.Valid\n-        or else Before.Index > Container.Plain.Last\n+        or else Before.Index > Container.Last\n       then\n-         if Container.Plain.Last = Index_Type'Last then\n+         if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n \n-         Index := Container.Plain.Last + 1;\n+         Index := Container.Last + 1;\n \n       else\n          Index := Before.Index;\n@@ -1160,14 +1005,9 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Is_Empty (New_Item) then\n          if not Before.Valid\n-           or else Before.Index > Container.Plain.Last\n+           or else Before.Index > Container.Last\n          then\n             Position := No_Element;\n          else\n@@ -1178,14 +1018,14 @@ package body Ada.Containers.Formal_Vectors is\n       end if;\n \n       if not Before.Valid\n-        or else Before.Index > Container.Plain.Last\n+        or else Before.Index > Container.Last\n       then\n-         if Container.Plain.Last = Index_Type'Last then\n+         if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n \n-         Index := Container.Plain.Last + 1;\n+         Index := Container.Last + 1;\n \n       else\n          Index := Before.Index;\n@@ -1206,24 +1046,19 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Count = 0 then\n          return;\n       end if;\n \n       if not Before.Valid\n-        or else Before.Index > Container.Plain.Last\n+        or else Before.Index > Container.Last\n       then\n-         if Container.Plain.Last = Index_Type'Last then\n+         if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n \n-         Index := Container.Plain.Last + 1;\n+         Index := Container.Last + 1;\n \n       else\n          Index := Before.Index;\n@@ -1243,14 +1078,9 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Count = 0 then\n          if not Before.Valid\n-           or else Before.Index > Container.Plain.Last\n+           or else Before.Index > Container.Last\n          then\n             Position := No_Element;\n          else\n@@ -1261,14 +1091,14 @@ package body Ada.Containers.Formal_Vectors is\n       end if;\n \n       if not Before.Valid\n-        or else Before.Index > Container.Plain.Last\n+        or else Before.Index > Container.Last\n       then\n-         if Container.Plain.Last = Index_Type'Last then\n+         if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n \n-         Index := Container.Plain.Last + 1;\n+         Index := Container.Last + 1;\n \n       else\n          Index := Before.Index;\n@@ -1323,18 +1153,13 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Before < Index_Type'First then\n          raise Constraint_Error with\n            \"Before index is out of range (too small)\";\n       end if;\n \n-      if Before > Container.Plain.Last\n-        and then Before > Container.Plain.Last + 1\n+      if Before > Container.Last\n+        and then Before > Container.Last + 1\n       then\n          raise Constraint_Error with\n            \"Before index is out of range (too large)\";\n@@ -1345,7 +1170,7 @@ package body Ada.Containers.Formal_Vectors is\n       end if;\n \n       declare\n-         Old_Last_As_Int : constant Int := Int (Container.Plain.Last);\n+         Old_Last_As_Int : constant Int := Int (Container.Last);\n \n       begin\n          if Old_Last_As_Int > Int'Last - N then\n@@ -1369,13 +1194,13 @@ package body Ada.Containers.Formal_Vectors is\n          --  Resolve issue of capacity vs. max index  ???\n       end;\n \n-      if Container.Plain.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       declare\n-         EA : Elements_Array renames Container.Plain.Elements;\n+         EA : Elements_Array renames Container.Elements;\n \n          BB : constant Int'Base := Int (Before) - Int (No_Index);\n          B  : constant Count_Type := Count_Type (BB);\n@@ -1384,7 +1209,7 @@ package body Ada.Containers.Formal_Vectors is\n          L  : constant Count_Type := Count_Type (LL);\n \n       begin\n-         if Before <= Container.Plain.Last then\n+         if Before <= Container.Last then\n             declare\n                II : constant Int'Base := BB + N;\n                I  : constant Count_Type := Count_Type (II);\n@@ -1395,7 +1220,7 @@ package body Ada.Containers.Formal_Vectors is\n          end if;\n       end;\n \n-      Container.Plain.Last := New_Last;\n+      Container.Last := New_Last;\n    end Insert_Space;\n \n    procedure Insert_Space\n@@ -1408,14 +1233,9 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n \n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Count = 0 then\n          if not Before.Valid\n-           or else Before.Index > Container.Plain.Last\n+           or else Before.Index > Container.Last\n          then\n             Position := No_Element;\n          else\n@@ -1426,14 +1246,14 @@ package body Ada.Containers.Formal_Vectors is\n       end if;\n \n       if not Before.Valid\n-        or else Before.Index > Container.Plain.Last\n+        or else Before.Index > Container.Last\n       then\n-         if Container.Plain.Last = Index_Type'Last then\n+         if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n \n-         Index := Container.Plain.Last + 1;\n+         Index := Container.Last + 1;\n \n       else\n          Index := Before.Index;\n@@ -1463,7 +1283,7 @@ package body Ada.Containers.Formal_Vectors is\n         not null access procedure (Container : Vector; Position : Cursor))\n    is\n       V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Plain.Busy;\n+      B : Natural renames V.Busy;\n \n    begin\n       B := B + 1;\n@@ -1513,11 +1333,7 @@ package body Ada.Containers.Formal_Vectors is\n \n    function Last_Index (Container : Vector) return Extended_Index is\n    begin\n-      if Container.K = Plain then\n-         return Container.Plain.Last;\n-      else\n-         return Container.Last;\n-      end if;\n+      return Container.Last;\n    end Last_Index;\n \n    ------------\n@@ -1538,26 +1354,20 @@ package body Ada.Containers.Formal_Vectors is\n    ----------\n \n    function Left (Container : Vector; Position : Cursor) return Vector is\n-      Fst : Count_Type;\n+      C : Vector (Container.Capacity) :=\n+        Copy (Container, Container.Capacity);\n    begin\n-      if Container.K = Plain then\n-         Fst := 1;\n-      else\n-         Fst := Container.First;\n-      end if;\n-\n-      if not Position.Valid then\n-         return (Container.Capacity, Container.Plain, Part, Fst,\n-                 Last_Index (Container));\n+      if Position = No_Element then\n+         return C;\n       end if;\n-\n-      if Position.Index > Last_Index (Container) then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too large)\";\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n       end if;\n \n-      return (Container.Capacity, Container.Plain, Part, Fst,\n-              (Position.Index - 1));\n+      while C.Last /= Position.Index - 1 loop\n+         Delete_Last (C);\n+      end loop;\n+      return C;\n    end Left;\n \n    ----------\n@@ -1572,21 +1382,16 @@ package body Ada.Containers.Formal_Vectors is\n \n    begin\n \n-      if Target.K /= Plain or Source.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n \n-      if Target.Plain.Busy > 0 then\n+      if Target.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (Target is busy)\";\n       end if;\n \n-      if Source.Plain.Busy > 0 then\n+      if Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (Source is busy)\";\n       end if;\n@@ -1599,11 +1404,11 @@ package body Ada.Containers.Formal_Vectors is\n       --  We could also write this as a loop, and incrementally\n       --  copy elements from source to target.\n \n-      Target.Plain.Last := No_Index;  -- in case array assignment files\n-      Target.Plain.Elements (1 .. N) := Source.Plain.Elements (1 .. N);\n+      Target.Last := No_Index;  -- in case array assignment files\n+      Target.Elements (1 .. N) := Source.Elements (1 .. N);\n \n-      Target.Plain.Last := Source.Plain.Last;\n-      Source.Plain.Last := No_Index;\n+      Target.Last := Source.Last;\n+      Source.Last := No_Index;\n    end Move;\n \n    ----------\n@@ -1703,8 +1508,8 @@ package body Ada.Containers.Formal_Vectors is\n       Process   : not null access procedure (Element : Element_Type))\n    is\n       V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Plain.Busy;\n-      L : Natural renames V.Plain.Lock;\n+      B : Natural renames V.Busy;\n+      L : Natural renames V.Lock;\n \n    begin\n       if Index > Last_Index (Container) then\n@@ -1770,8 +1575,8 @@ package body Ada.Containers.Formal_Vectors is\n \n       for J in Count_Type range 1 .. Length loop\n          Last := Last + 1;\n-         Element_Type'Read (Stream, Container.Plain.Elements (J));\n-         Container.Plain.Last := Last;\n+         Element_Type'Read (Stream, Container.Elements (J));\n+         Container.Last := Last;\n       end loop;\n    end Read;\n \n@@ -1793,16 +1598,12 @@ package body Ada.Containers.Formal_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n-      if Index > Container.Plain.Last then\n+      if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      if Container.Plain.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n@@ -1812,7 +1613,7 @@ package body Ada.Containers.Formal_Vectors is\n          I  : constant Count_Type := Count_Type (II);\n \n       begin\n-         Container.Plain.Elements (I) := New_Item;\n+         Container.Elements (I) := New_Item;\n       end;\n    end Replace_Element;\n \n@@ -1822,20 +1623,16 @@ package body Ada.Containers.Formal_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not Position.Valid then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Index > Container.Plain.Last then\n+      if Position.Index > Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n       end if;\n \n-      if Container.Plain.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n@@ -1845,7 +1642,7 @@ package body Ada.Containers.Formal_Vectors is\n          I  : constant Count_Type := Count_Type (II);\n \n       begin\n-         Container.Plain.Elements (I) := New_Item;\n+         Container.Elements (I) := New_Item;\n       end;\n    end Replace_Element;\n \n@@ -1858,10 +1655,6 @@ package body Ada.Containers.Formal_Vectors is\n       Capacity  : Capacity_Subtype)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Capacity > Container.Capacity then\n          raise Constraint_Error;  -- ???\n@@ -1874,23 +1667,19 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Reverse_Elements (Container : in out Vector) is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Length (Container) <= 1 then\n          return;\n       end if;\n \n-      if Container.Plain.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n \n       declare\n          I, J : Count_Type;\n-         E    : Elements_Array renames Container.Plain.Elements;\n+         E    : Elements_Array renames Container.Elements;\n \n       begin\n          I := 1;\n@@ -1983,7 +1772,7 @@ package body Ada.Containers.Formal_Vectors is\n         not null access procedure (Container : Vector; Position : Cursor))\n    is\n       V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Plain.Busy;\n+      B : Natural renames V.Busy;\n \n    begin\n       B := B + 1;\n@@ -2006,27 +1795,21 @@ package body Ada.Containers.Formal_Vectors is\n    -----------\n \n    function Right (Container : Vector; Position : Cursor) return Vector is\n-      Fst : Count_Type;\n+      C : Vector (Container.Capacity) :=\n+        Copy (Container, Container.Capacity);\n    begin\n-      if Container.K = Plain then\n-         Fst := 1;\n-      else\n-         Fst := Container.First;\n+      if Position = No_Element then\n+         Clear (C);\n+         return C;\n       end if;\n-\n-      if not Position.Valid then\n-         return (Container.Capacity, Container.Plain, Part, Fst, No_Index);\n-      end if;\n-\n-      if Position.Index > Last_Index (Container) then\n-         raise Constraint_Error with\n-           \"Position index is out of range (too large)\";\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error;\n       end if;\n \n-      Fst := Fst + Count_Type (Int (Position.Index) - Int (No_Index)) - 1;\n-\n-      return (Container.Capacity, Container.Plain, Part, Fst,\n-              (Last_Index (Container) - Position.Index + 1));\n+      while C.Last /= Container.Last - Position.Index + 1 loop\n+         Delete_First (C);\n+      end loop;\n+      return C;\n    end Right;\n \n    ----------------\n@@ -2038,16 +1821,12 @@ package body Ada.Containers.Formal_Vectors is\n       Length    : Capacity_Subtype)\n    is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if Length = Formal_Vectors.Length (Container) then\n          return;\n       end if;\n \n-      if Container.Plain.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is busy)\";\n       end if;\n@@ -2060,7 +1839,7 @@ package body Ada.Containers.Formal_Vectors is\n          Last_As_Int : constant Int'Base :=\n                          Int (Index_Type'First) + Int (Length) - 1;\n       begin\n-         Container.Plain.Last := Index_Type'Base (Last_As_Int);\n+         Container.Last := Index_Type'Base (Last_As_Int);\n       end;\n    end Set_Length;\n \n@@ -2070,24 +1849,20 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n-      if I > Container.Plain.Last then\n+      if I > Container.Last then\n          raise Constraint_Error with \"I index is out of range\";\n       end if;\n \n-      if J > Container.Plain.Last then\n+      if J > Container.Last then\n          raise Constraint_Error with \"J index is out of range\";\n       end if;\n \n       if I = J then\n          return;\n       end if;\n \n-      if Container.Plain.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n@@ -2096,8 +1871,8 @@ package body Ada.Containers.Formal_Vectors is\n          II : constant Int'Base := Int (I) - Int (No_Index);\n          JJ : constant Int'Base := Int (J) - Int (No_Index);\n \n-         EI : Element_Type renames Container.Plain.Elements (Count_Type (II));\n-         EJ : Element_Type renames Container.Plain.Elements (Count_Type (JJ));\n+         EI : Element_Type renames Container.Elements (Count_Type (II));\n+         EJ : Element_Type renames Container.Elements (Count_Type (JJ));\n \n          EI_Copy : constant Element_Type := EI;\n \n@@ -2109,10 +1884,6 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Cursor) is\n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n       if not I.Valid then\n          raise Constraint_Error with \"I cursor has no element\";\n@@ -2176,9 +1947,7 @@ package body Ada.Containers.Formal_Vectors is\n \n          Last := Index_Type (Last_As_Int);\n \n-         return (Length,\n-                 new Plain_Vector'(Length, (others => <>), Last => Last,\n-                                   others => <>),\n+         return (Length, (others => <>), Last => Last,\n                  others => <>);\n       end;\n    end To_Vector;\n@@ -2204,9 +1973,7 @@ package body Ada.Containers.Formal_Vectors is\n \n          Last := Index_Type (Last_As_Int);\n \n-         return (Length,\n-                 new Plain_Vector'(Length, (others => New_Item), Last => Last,\n-                                   others => <>),\n+         return (Length, (others => New_Item), Last => Last,\n                  others => <>);\n       end;\n    end To_Vector;\n@@ -2220,16 +1987,12 @@ package body Ada.Containers.Formal_Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n-      B : Natural renames Container.Plain.Busy;\n-      L : Natural renames Container.Plain.Lock;\n+      B : Natural renames Container.Busy;\n+      L : Natural renames Container.Lock;\n \n    begin\n-      if Container.K /= Plain then\n-         raise Constraint_Error\n-           with \"Can't modify part of container\";\n-      end if;\n \n-      if Index > Container.Plain.Last then\n+      if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n@@ -2241,7 +2004,7 @@ package body Ada.Containers.Formal_Vectors is\n          I  : constant Count_Type := Count_Type (II);\n \n       begin\n-         Process (Container.Plain.Elements (I));\n+         Process (Container.Elements (I));\n       exception\n          when others =>\n             L := L - 1;\n@@ -2278,7 +2041,7 @@ package body Ada.Containers.Formal_Vectors is\n       Count_Type'Base'Write (Stream, Length (Container));\n \n       for J in 1 .. Length (Container) loop\n-         Element_Type'Write (Stream, Container.Plain.Elements (J));\n+         Element_Type'Write (Stream, Container.Elements (J));\n       end loop;\n    end Write;\n "}, {"sha": "8dcb7475163d1902b67c7de760153171619e311e", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -366,24 +366,13 @@ private\n    type Elements_Array is array (Count_Type range <>) of Element_Type;\n    function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n-   type Kind is (Plain, Part);\n-\n-   type Plain_Vector (Capacity : Capacity_Subtype) is record\n+   type Vector (Capacity : Capacity_Subtype) is tagged record\n       Elements : Elements_Array (1 .. Capacity);\n       Last     : Extended_Index := No_Index;\n       Busy     : Natural := 0;\n       Lock     : Natural := 0;\n    end record;\n \n-   type Plain_Access is access all Plain_Vector;\n-\n-   type Vector (Capacity : Capacity_Subtype) is tagged record\n-      Plain : Plain_Access := new Plain_Vector (Capacity);\n-      K     : Kind := Formal_Vectors.Plain;\n-      First : Count_Type := 0;\n-      Last  : Index_Type'Base := No_Index;\n-   end record;\n-\n    use Ada.Streams;\n \n    procedure Write"}, {"sha": "0b25f1a8c0f0a4a316dd68ee24df6d347730909a", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 70, "deletions": 94, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -8280,9 +8280,9 @@ package body Exp_Dist is\n \n          function Find_Numeric_Representation\n            (Typ : Entity_Id) return Entity_Id;\n-         --  Given a numeric type Typ, return the smallest integer or floating\n-         --  point type from Standard, or the smallest unsigned (modular) type\n-         --  from System.Unsigned_Types, whose range encompasses that of Typ.\n+         --  Given a numeric type Typ, return the smallest integer or modular\n+         --  type from Interfaces, or the smallest floating point type from\n+         --  Standard whose range encompasses that of Typ.\n \n          function Make_Helper_Function_Name\n            (Loc : Source_Ptr;\n@@ -8583,37 +8583,31 @@ package body Exp_Dist is\n \n             --  Integer types\n \n-            elsif U_Type = Etype (Standard_Short_Short_Integer) then\n-                  Lib_RE := RE_FA_SSI;\n+            elsif U_Type = RTE (RE_Integer_8) then\n+                  Lib_RE := RE_FA_I8;\n \n-            elsif U_Type = Etype (Standard_Short_Integer) then\n-               Lib_RE := RE_FA_SI;\n+            elsif U_Type = RTE (RE_Integer_16) then\n+               Lib_RE := RE_FA_I16;\n \n-            elsif U_Type = Etype (Standard_Integer) then\n-               Lib_RE := RE_FA_I;\n+            elsif U_Type = RTE (RE_Integer_32) then\n+               Lib_RE := RE_FA_I32;\n \n-            elsif U_Type = Etype (Standard_Long_Integer) then\n-               Lib_RE := RE_FA_LI;\n-\n-            elsif U_Type = Etype (Standard_Long_Long_Integer) then\n-               Lib_RE := RE_FA_LLI;\n+            elsif U_Type = RTE (RE_Integer_64) then\n+               Lib_RE := RE_FA_I64;\n \n             --  Unsigned integer types\n \n-            elsif U_Type = RTE (RE_Short_Short_Unsigned) then\n-               Lib_RE := RE_FA_SSU;\n-\n-            elsif U_Type = RTE (RE_Short_Unsigned) then\n-               Lib_RE := RE_FA_SU;\n+            elsif U_Type = RTE (RE_Unsigned_8) then\n+               Lib_RE := RE_FA_U8;\n \n-            elsif U_Type = RTE (RE_Unsigned) then\n-               Lib_RE := RE_FA_U;\n+            elsif U_Type = RTE (RE_Unsigned_16) then\n+               Lib_RE := RE_FA_U16;\n \n-            elsif U_Type = RTE (RE_Long_Unsigned) then\n-               Lib_RE := RE_FA_LU;\n+            elsif U_Type = RTE (RE_Unsigned_32) then\n+               Lib_RE := RE_FA_U32;\n \n-            elsif U_Type = RTE (RE_Long_Long_Unsigned) then\n-               Lib_RE := RE_FA_LLU;\n+            elsif U_Type = RTE (RE_Unsigned_64) then\n+               Lib_RE := RE_FA_U64;\n \n             elsif Is_RTE (U_Type, RE_Unbounded_String) then\n                Lib_RE := RE_FA_String;\n@@ -9213,7 +9207,7 @@ package body Exp_Dist is\n                     Make_Object_Declaration (Loc,\n                       Defining_Identifier => Counter,\n                       Object_Definition =>\n-                        New_Occurrence_Of (RTE (RE_Long_Unsigned), Loc),\n+                        New_Occurrence_Of (RTE (RE_Unsigned_32), Loc),\n                       Expression =>\n                         Make_Integer_Literal (Loc, Initial_Counter_Value)));\n \n@@ -9398,37 +9392,31 @@ package body Exp_Dist is\n \n             --  Integer types\n \n-            elsif U_Type = Etype (Standard_Short_Short_Integer) then\n-                  Lib_RE := RE_TA_SSI;\n-\n-            elsif U_Type = Etype (Standard_Short_Integer) then\n-               Lib_RE := RE_TA_SI;\n+            elsif U_Type = RTE (RE_Integer_8) then\n+               Lib_RE := RE_TA_I8;\n \n-            elsif U_Type = Etype (Standard_Integer) then\n-               Lib_RE := RE_TA_I;\n+            elsif U_Type = RTE (RE_Integer_16) then\n+               Lib_RE := RE_TA_I16;\n \n-            elsif U_Type = Etype (Standard_Long_Integer) then\n-               Lib_RE := RE_TA_LI;\n+            elsif U_Type = RTE (RE_Integer_32) then\n+               Lib_RE := RE_TA_I32;\n \n-            elsif U_Type = Etype (Standard_Long_Long_Integer) then\n-               Lib_RE := RE_TA_LLI;\n+            elsif U_Type = RTE (RE_Integer_64) then\n+               Lib_RE := RE_TA_I64;\n \n             --  Unsigned integer types\n \n-            elsif U_Type = RTE (RE_Short_Short_Unsigned) then\n-               Lib_RE := RE_TA_SSU;\n+            elsif U_Type = RTE (RE_Unsigned_8) then\n+               Lib_RE := RE_TA_U8;\n \n-            elsif U_Type = RTE (RE_Short_Unsigned) then\n-               Lib_RE := RE_TA_SU;\n+            elsif U_Type = RTE (RE_Unsigned_16) then\n+               Lib_RE := RE_TA_U16;\n \n-            elsif U_Type = RTE (RE_Unsigned) then\n-               Lib_RE := RE_TA_U;\n+            elsif U_Type = RTE (RE_Unsigned_32) then\n+               Lib_RE := RE_TA_U32;\n \n-            elsif U_Type = RTE (RE_Long_Unsigned) then\n-               Lib_RE := RE_TA_LU;\n-\n-            elsif U_Type = RTE (RE_Long_Long_Unsigned) then\n-               Lib_RE := RE_TA_LLU;\n+            elsif U_Type = RTE (RE_Unsigned_64) then\n+               Lib_RE := RE_TA_U64;\n \n             elsif Is_RTE (U_Type, RE_Unbounded_String) then\n                Lib_RE := RE_TA_String;\n@@ -10176,37 +10164,31 @@ package body Exp_Dist is\n \n                --  Integer types (walk back to the base type)\n \n-               elsif U_Type = Etype (Standard_Short_Short_Integer) then\n-                     Lib_RE := RE_TC_SSI;\n-\n-               elsif U_Type = Etype (Standard_Short_Integer) then\n-                  Lib_RE := RE_TC_SI;\n+               elsif U_Type = RTE (RE_Integer_8) then\n+                     Lib_RE := RE_TC_I8;\n \n-               elsif U_Type = Etype (Standard_Integer) then\n-                  Lib_RE := RE_TC_I;\n+               elsif U_Type = RTE (RE_Integer_16) then\n+                  Lib_RE := RE_TC_I16;\n \n-               elsif U_Type = Etype (Standard_Long_Integer) then\n-                  Lib_RE := RE_TC_LI;\n+               elsif U_Type = RTE (RE_Integer_32) then\n+                  Lib_RE := RE_TC_I32;\n \n-               elsif U_Type = Etype (Standard_Long_Long_Integer) then\n-                  Lib_RE := RE_TC_LLI;\n+               elsif U_Type = RTE (RE_Integer_64) then\n+                  Lib_RE := RE_TC_I64;\n \n                --  Unsigned integer types\n \n-               elsif U_Type = RTE (RE_Short_Short_Unsigned) then\n-                  Lib_RE := RE_TC_SSU;\n+               elsif U_Type = RTE (RE_Unsigned_8) then\n+                  Lib_RE := RE_TC_U8;\n \n-               elsif U_Type = RTE (RE_Short_Unsigned) then\n-                  Lib_RE := RE_TC_SU;\n+               elsif U_Type = RTE (RE_Unsigned_16) then\n+                  Lib_RE := RE_TC_U16;\n \n-               elsif U_Type = RTE (RE_Unsigned) then\n-                  Lib_RE := RE_TC_U;\n+               elsif U_Type = RTE (RE_Unsigned_32) then\n+                  Lib_RE := RE_TC_U32;\n \n-               elsif U_Type = RTE (RE_Long_Unsigned) then\n-                  Lib_RE := RE_TC_LU;\n-\n-               elsif U_Type = RTE (RE_Long_Long_Unsigned) then\n-                  Lib_RE := RE_TC_LLU;\n+               elsif U_Type = RTE (RE_Unsigned_64) then\n+                  Lib_RE := RE_TC_U64;\n \n                elsif Is_RTE (U_Type, RE_Unbounded_String) then\n                   Lib_RE := RE_TC_String;\n@@ -10339,7 +10321,7 @@ package body Exp_Dist is\n             begin\n                Append_To (Parameter_List,\n                  Make_Function_Call (Loc,\n-                   Name => New_Occurrence_Of (RTE (RE_TA_LI), Loc),\n+                   Name => New_Occurrence_Of (RTE (RE_TA_I32), Loc),\n                    Parameter_Associations => New_List (Expr_Node)));\n             end Add_Long_Parameter;\n \n@@ -10584,7 +10566,7 @@ package body Exp_Dist is\n                                       Make_Function_Call (Loc,\n                                        Name =>\n                                          New_Occurrence_Of\n-                                           (RTE (RE_TA_LI), Loc),\n+                                           (RTE (RE_TA_I32), Loc),\n                                        Parameter_Associations =>\n                                          New_List (\n                                            Make_Integer_Literal\n@@ -10795,7 +10777,7 @@ package body Exp_Dist is\n                         Inner_TypeCode := Make_Constructed_TypeCode\n                           (RTE (RE_TC_Array), New_List (\n                             Build_To_Any_Call (\n-                              OK_Convert_To (RTE (RE_Long_Unsigned),\n+                              OK_Convert_To (RTE (RE_Unsigned_32),\n                                 Make_Attribute_Reference (Loc,\n                                   Prefix => New_Occurrence_Of (Typ, Loc),\n                                   Attribute_Name => Name_Length,\n@@ -10821,7 +10803,7 @@ package body Exp_Dist is\n                         Inner_TypeCode := Make_Constructed_TypeCode\n                           (RTE (RE_TC_Sequence), New_List (\n                             Build_To_Any_Call (\n-                              OK_Convert_To (RTE (RE_Long_Unsigned),\n+                              OK_Convert_To (RTE (RE_Unsigned_32),\n                                 Make_Integer_Literal (Loc, 0)),\n                               Decls),\n                             Build_To_Any_Call (Inner_TypeCode, Decls)));\n@@ -10867,37 +10849,31 @@ package body Exp_Dist is\n \n          begin\n             if Is_Unsigned_Type (Typ) then\n-               if P_Size <= Standard_Short_Short_Integer_Size then\n-                  return RTE (RE_Short_Short_Unsigned);\n+               if P_Size <= 8 then\n+                  return RTE (RE_Unsigned_8);\n \n-               elsif P_Size <= Standard_Short_Integer_Size then\n-                  return RTE (RE_Short_Unsigned);\n+               elsif P_Size <= 16 then\n+                  return RTE (RE_Unsigned_16);\n \n-               elsif P_Size <= Standard_Integer_Size then\n-                  return RTE (RE_Unsigned);\n-\n-               elsif P_Size <= Standard_Long_Integer_Size then\n-                  return RTE (RE_Long_Unsigned);\n+               elsif P_Size <= 32 then\n+                  return RTE (RE_Unsigned_32);\n \n                else\n-                  return RTE (RE_Long_Long_Unsigned);\n+                  return RTE (RE_Unsigned_64);\n                end if;\n \n             elsif Is_Integer_Type (Typ) then\n-               if P_Size <= Standard_Short_Short_Integer_Size then\n-                  return Standard_Short_Short_Integer;\n+               if P_Size <= 8 then\n+                  return RTE (RE_Integer_8);\n \n                elsif P_Size <= Standard_Short_Integer_Size then\n-                  return Standard_Short_Integer;\n+                  return RTE (RE_Integer_16);\n \n                elsif P_Size <= Standard_Integer_Size then\n-                  return Standard_Integer;\n-\n-               elsif P_Size <= Standard_Long_Integer_Size then\n-                  return Standard_Long_Integer;\n+                  return RTE (RE_Integer_32);\n \n                else\n-                  return Standard_Long_Long_Integer;\n+                  return RTE (RE_Integer_64);\n                end if;\n \n             elsif Is_Floating_Point_Type (Typ) then\n@@ -11086,7 +11062,7 @@ package body Exp_Dist is\n                     Make_Object_Declaration (Loc,\n                       Defining_Identifier => Inner_Counter,\n                       Object_Definition   =>\n-                        New_Occurrence_Of (RTE (RE_Long_Unsigned), Loc),\n+                        New_Occurrence_Of (RTE (RE_Unsigned_32), Loc),\n                       Expression          =>\n                         Make_Integer_Literal (Loc, 0)));\n                end if;\n@@ -11097,7 +11073,7 @@ package body Exp_Dist is\n                         Attribute_Name => Name_Length,\n                         Expressions    =>\n                           New_List (Make_Integer_Literal (Loc, Depth)));\n-                  Set_Etype (Length_Node, RTE (RE_Long_Unsigned));\n+                  Set_Etype (Length_Node, RTE (RE_Unsigned_32));\n \n                   Add_Process_Element (Dimen_Stmts,\n                     Datum   => Length_Node,"}, {"sha": "49b96a8d03e173da1515ea0b9fbe1c9e4a8ee3a5", "filename": "gcc/ada/exp_dist.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fexp_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fexp_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,7 +35,7 @@ package Exp_Dist is\n    PCS_Version_Number : constant array (PCS_Names) of Int :=\n                           (Name_No_DSA      => 1,\n                            Name_GARLIC_DSA  => 1,\n-                           Name_PolyORB_DSA => 4);\n+                           Name_PolyORB_DSA => 5);\n    --  PCS interface version. This is used to check for consistency between the\n    --  compiler used to generate distribution stubs and the PCS implementation.\n    --  It must be incremented whenever a change is made to the generated code"}, {"sha": "1be16c1d2d5ba181b6a4c34241df88cea1f61bc3", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -3568,9 +3568,12 @@ package body Exp_Util is\n    function Is_VM_By_Copy_Actual (N : Node_Id) return Boolean is\n    begin\n       return VM_Target /= No_VM\n-        and then Nkind (N) = N_Identifier\n-        and then Present (Renamed_Object (Entity (N)))\n-        and then Nkind (Renamed_Object (Entity (N))) = N_Slice;\n+        and then (Nkind (N) = N_Slice\n+                    or else\n+                      (Nkind (N) = N_Identifier\n+                         and then Present (Renamed_Object (Entity (N)))\n+                         and then Nkind (Renamed_Object (Entity (N)))\n+                                    = N_Slice));\n    end Is_VM_By_Copy_Actual;\n \n    --------------------"}, {"sha": "fe89cb1b375aa16cbd7a2e1449181a7efb0688f2", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -2256,31 +2256,33 @@ ada/exp_dist.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\\n    ada/atree.adb ada/casing.ads ada/csets.ads ada/debug.ads \\\n    ada/debug_a.ads ada/einfo.ads ada/einfo.adb ada/elists.ads \\\n-   ada/elists.adb ada/err_vars.ads ada/errout.ads ada/erroutc.ads \\\n-   ada/exp_atag.ads ada/exp_ch7.ads ada/exp_disp.ads ada/exp_dist.ads \\\n-   ada/exp_dist.adb ada/exp_strm.ads ada/exp_tss.ads ada/exp_util.ads \\\n-   ada/expander.ads ada/fname.ads ada/fname-uf.ads ada/get_targ.ads \\\n-   ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads ada/hlo.ads \\\n-   ada/hostparm.ads ada/inline.ads ada/inline.adb ada/interfac.ads \\\n-   ada/lib.ads ada/lib.adb ada/lib-list.adb ada/lib-load.ads \\\n-   ada/lib-sort.adb ada/namet.ads ada/namet.adb ada/nlists.ads \\\n-   ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n-   ada/restrict.ads ada/rident.ads ada/rtsfind.ads ada/sem.ads ada/sem.adb \\\n-   ada/sem_attr.ads ada/sem_aux.ads ada/sem_aux.adb ada/sem_cat.ads \\\n-   ada/sem_ch10.ads ada/sem_ch11.ads ada/sem_ch12.ads ada/sem_ch13.ads \\\n-   ada/sem_ch2.ads ada/sem_ch3.ads ada/sem_ch4.ads ada/sem_ch5.ads \\\n-   ada/sem_ch6.ads ada/sem_ch7.ads ada/sem_ch8.ads ada/sem_ch9.ads \\\n-   ada/sem_dist.ads ada/sem_eval.ads ada/sem_prag.ads ada/sem_util.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n-   ada/stringt.ads ada/stringt.adb ada/system.ads ada/s-exctab.ads \\\n-   ada/s-htable.ads ada/s-htable.adb ada/s-imenne.ads ada/s-memory.ads \\\n-   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n-   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n-   ada/s-stoele.adb ada/s-strhas.ads ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n-   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n+   ada/elists.adb ada/err_vars.ads ada/errout.ads ada/errout.adb \\\n+   ada/erroutc.ads ada/erroutc.adb ada/exp_atag.ads ada/exp_ch7.ads \\\n+   ada/exp_disp.ads ada/exp_dist.ads ada/exp_dist.adb ada/exp_strm.ads \\\n+   ada/exp_tss.ads ada/exp_util.ads ada/expander.ads ada/fname.ads \\\n+   ada/fname-uf.ads ada/get_targ.ads ada/gnat.ads ada/g-hesorg.ads \\\n+   ada/g-htable.ads ada/gnatvsn.ads ada/hlo.ads ada/hostparm.ads \\\n+   ada/inline.ads ada/inline.adb ada/interfac.ads ada/lib.ads ada/lib.adb \\\n+   ada/lib-list.adb ada/lib-load.ads ada/lib-sort.adb ada/namet.ads \\\n+   ada/namet.adb ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb \\\n+   ada/opt.ads ada/output.ads ada/restrict.ads ada/rident.ads \\\n+   ada/rtsfind.ads ada/scans.ads ada/sem.ads ada/sem.adb ada/sem_attr.ads \\\n+   ada/sem_aux.ads ada/sem_aux.adb ada/sem_cat.ads ada/sem_ch10.ads \\\n+   ada/sem_ch11.ads ada/sem_ch12.ads ada/sem_ch13.ads ada/sem_ch2.ads \\\n+   ada/sem_ch3.ads ada/sem_ch4.ads ada/sem_ch5.ads ada/sem_ch6.ads \\\n+   ada/sem_ch7.ads ada/sem_ch8.ads ada/sem_ch9.ads ada/sem_dist.ads \\\n+   ada/sem_eval.ads ada/sem_prag.ads ada/sem_util.ads ada/sinfo.ads \\\n+   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n+   ada/stringt.ads ada/stringt.adb ada/stylesw.ads ada/system.ads \\\n+   ada/s-exctab.ads ada/s-htable.ads ada/s-htable.adb ada/s-imenne.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n+   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-strhas.ads ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n+   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n+   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/urealp.ads ada/widechar.ads \n \n ada/exp_fixd.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\\n@@ -2872,14 +2874,14 @@ ada/inline.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/sem_ch13.ads ada/sem_ch2.ads ada/sem_ch3.ads ada/sem_ch4.ads \\\n    ada/sem_ch5.ads ada/sem_ch6.ads ada/sem_ch7.ads ada/sem_ch8.ads \\\n    ada/sem_ch9.ads ada/sem_prag.ads ada/sem_util.ads ada/sinfo.ads \\\n-   ada/sinfo.adb ada/sinput.ads ada/sinput.adb ada/snames.ads \\\n-   ada/stand.ads ada/stringt.ads ada/stylesw.ads ada/system.ads \\\n-   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n-   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n-   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n-   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n-   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n+   ada/stringt.ads ada/stylesw.ads ada/system.ads ada/s-exctab.ads \\\n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/targparm.ads ada/tree_io.ads \\\n+   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/instpar.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n@@ -3329,13 +3331,13 @@ ada/repinfo.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n \n ada/restrict.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/atree.ads \\\n-   ada/atree.adb ada/casing.ads ada/csets.ads ada/debug.ads ada/einfo.ads \\\n-   ada/einfo.adb ada/err_vars.ads ada/errout.ads ada/errout.adb \\\n-   ada/erroutc.ads ada/erroutc.adb ada/fname.ads ada/fname-uf.ads \\\n-   ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads ada/gnatvsn.ads \\\n-   ada/hostparm.ads ada/interfac.ads ada/lib.ads ada/lib.adb \\\n-   ada/lib-list.adb ada/lib-sort.adb ada/namet.ads ada/namet.adb \\\n-   ada/nlists.ads ada/nlists.adb ada/opt.ads ada/output.ads \\\n+   ada/atree.adb ada/casing.ads ada/casing.adb ada/csets.ads ada/debug.ads \\\n+   ada/einfo.ads ada/einfo.adb ada/err_vars.ads ada/errout.ads \\\n+   ada/errout.adb ada/erroutc.ads ada/erroutc.adb ada/fname.ads \\\n+   ada/fname-uf.ads ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads \\\n+   ada/gnatvsn.ads ada/hostparm.ads ada/interfac.ads ada/lib.ads \\\n+   ada/lib.adb ada/lib-list.adb ada/lib-sort.adb ada/namet.ads \\\n+   ada/namet.adb ada/nlists.ads ada/nlists.adb ada/opt.ads ada/output.ads \\\n    ada/restrict.ads ada/restrict.adb ada/rident.ads ada/scans.ads \\\n    ada/sem_aux.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n    ada/sinput.adb ada/snames.ads ada/stand.ads ada/stringt.ads \\"}, {"sha": "fa153f6de92cacbd8dcf1f927a5f2433b1d9aba1", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -529,13 +529,15 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n         s-vxwext.adb<s-vxwext-kernel-smp.adb \\\n         system.ads<system-vxworks-ppc-kernel.ads\n \n+        EH_MECHANISM=-gcc\n         EXTRA_GNATRTL_TASKING_OBJS=affinity.o\n       else\n         LIBGNAT_TARGET_PAIRS += \\\n         s-interr.adb<s-interr-hwint.adb \\\n         s-tpopsp.adb<s-tpopsp-vxworks.adb\n \n         ifeq ($(strip $(filter-out kernel,$(THREAD_KIND))),)\n+          EH_MECHANISM=-gcc\n           LIBGNAT_TARGET_PAIRS += \\\n           s-vxwext.ads<s-vxwext-kernel.ads \\\n           s-vxwext.adb<s-vxwext-kernel.adb \\\n@@ -1072,7 +1074,7 @@ ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n   g-bytswa.adb<g-bytswa-x86.adb \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n   s-intman.adb<s-intman-posix.adb \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  s-tpopsp.adb<s-tpopsp-tls.adb \\\n   g-sercom.adb<g-sercom-linux.adb\n \n   ifeq ($(strip $(filter-out marte,$(THREAD_KIND))),)\n@@ -1383,7 +1385,7 @@ ifeq ($(strip $(filter-out ibm aix%,$(manu) $(osys))),)\n   endif\n \n   THREADSLIB = -lpthreads\n-\n+  EH_MECHANISM=-gcc\n   TOOLS_TARGET_PAIRS = \\\n   mlib-tgt-specific.adb<mlib-tgt-specific-aix.adb \\\n   indepsw.adb<indepsw-aix.adb\n@@ -1800,7 +1802,7 @@ ifeq ($(strip $(filter-out powerpc% linux%,$(arch) $(osys))),)\n   s-intman.adb<s-intman-posix.adb \\\n   s-linux.ads<s-linux.ads \\\n   s-osinte.adb<s-osinte-posix.adb \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  s-tpopsp.adb<s-tpopsp-tls.adb \\\n   g-sercom.adb<g-sercom-linux.adb \\\n   $(ATOMICS_TARGET_PAIRS)\n \n@@ -1898,7 +1900,7 @@ ifeq ($(strip $(filter-out sparc% linux%,$(arch) $(osys))),)\n   s-tasinf.ads<s-tasinf-linux.ads \\\n   s-tasinf.adb<s-tasinf-linux.adb \\\n   s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb\n+  s-tpopsp.adb<s-tpopsp-tls.adb\n \n   LIBGNAT_TARGET_PAIRS_32 = \\\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n@@ -2002,7 +2004,7 @@ ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n   s-taprop.adb<s-taprop-linux.adb \\\n   s-tasinf.ads<s-tasinf-linux.ads \\\n   s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  s-tpopsp.adb<s-tpopsp-tls.adb \\\n   s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n   g-sercom.adb<g-sercom-linux.adb \\\n   system.ads<system-linux-ia64.ads \\\n@@ -2094,7 +2096,7 @@ ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n   s-taprop.adb<s-taprop-linux.adb \\\n   s-tasinf.ads<s-tasinf-linux.ads \\\n   s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  s-tpopsp.adb<s-tpopsp-tls.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n   g-sercom.adb<g-sercom-linux.adb \\\n   system.ads<system-linux-x86_64.ads \\"}, {"sha": "1f0ce8b575860b56e4473c9180cbcf14c8f9fbdc", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -470,7 +470,7 @@ procedure GNATCmd is\n                            end if;\n \n                            Main := Project_Tree.Shared.String_Elements.Table\n-                             (Main).Next;\n+                                     (Main).Next;\n                         end loop;\n \n                         if Proj.Project.Library then\n@@ -1241,6 +1241,7 @@ procedure GNATCmd is\n       Libraries_Present : in out Boolean)\n    is\n       pragma Unreferenced (Tree);\n+\n       Path_Option : constant String_Access :=\n                       MLib.Linker_Library_Path_Option;\n \n@@ -2307,7 +2308,8 @@ begin\n                                 Attribute_Or_Array_Name =>\n                                   Name_Local_Config_File,\n                                 In_Package              => Pkg,\n-                                Shared                 => Project_Tree.Shared);\n+                                Shared                  =>\n+                                  Project_Tree.Shared);\n                         end if;\n \n                         if Variable /= Nil_Variable_Value"}, {"sha": "73113aebf7ebd4490706fe5ecadfec3a2df481c8", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -36,12 +36,13 @@ with GNAT.OS_Lib; use GNAT.OS_Lib;\n package Makeutl is\n \n    type Fail_Proc is access procedure (S : String);\n+\n    Do_Fail : Fail_Proc := Osint.Fail'Access;\n    --  Failing procedure called from procedure Test_If_Relative_Path below. May\n    --  be redirected.\n \n    Project_Tree : constant Project_Tree_Ref :=\n-     new Project_Tree_Data (Is_Root_Tree => True);\n+                    new Project_Tree_Data (Is_Root_Tree => True);\n    --  The project tree\n \n    Source_Info_Option : constant String := \"--source-info=\";"}, {"sha": "9ac12e740617f0b210952fe999b33a8605069c5f", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -1304,8 +1304,8 @@ package body MLib.Prj is\n \n          Lib_Dirpath  :=\n            new String'(Get_Name_String (For_Project.Library_Dir.Display_Name));\n-         Lib_Filename := new String'\n-           (Get_Name_String (For_Project.Library_Name));\n+         Lib_Filename :=\n+           new String'(Get_Name_String (For_Project.Library_Name));\n \n          case For_Project.Library_Kind is\n             when Static =>"}, {"sha": "c9b526340ebac6649ae7ac361329b2d859430cea", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -102,8 +102,8 @@ package body Prj.Conf is\n    --  Raises exception Invalid_Config with given message\n \n    procedure Apply_Config_File\n-     (Config_File       : Prj.Project_Id;\n-      Project_Tree      : Prj.Project_Tree_Ref);\n+     (Config_File  : Prj.Project_Id;\n+      Project_Tree : Prj.Project_Tree_Ref);\n    --  Apply the configuration file settings to all the projects in the\n    --  project tree. The Project_Tree must have been parsed first, and\n    --  processed through the first phase so that all its projects are known.\n@@ -174,20 +174,19 @@ package body Prj.Conf is\n \n                   String_Element_Table.Increment_Last\n                     (Shared.String_Elements);\n-                  New_List := String_Element_Table.Last\n-                    (Shared.String_Elements);\n+                  New_List :=\n+                    String_Element_Table.Last (Shared.String_Elements);\n \n                   --  Value of attribute is new list\n \n                   User_Attr.Value.Values := New_List;\n                   Shared.Variable_Elements.Table (User_Attr_Id) := User_Attr;\n \n                   loop\n-\n                      --  Get each element of configuration list\n \n                      Conf_Elem := Shared.String_Elements.Table (Conf_List);\n-                     New_Elem := Conf_Elem;\n+                     New_Elem  := Conf_Elem;\n                      Conf_List := Conf_Elem.Next;\n \n                      if Conf_List = Nil_String then\n@@ -240,9 +239,9 @@ package body Prj.Conf is\n             User_Decl.Arrays := Array_Table.Last (Shared.Arrays);\n             Shared.Arrays.Table (User_Decl.Arrays) := User_Array;\n \n-         else\n-            --  Otherwise, check each array element\n+         --  Otherwise, check each array element\n \n+         else\n             Conf_Array_Elem_Id := Conf_Array.Value;\n             while Conf_Array_Elem_Id /= No_Array_Element loop\n                Conf_Array_Elem :=\n@@ -256,9 +255,8 @@ package body Prj.Conf is\n                   User_Array_Elem_Id := User_Array_Elem.Next;\n                end loop;\n \n-               --  If the array element does not exist in the user array,\n-               --  insert a shallow copy of the conf array element in the\n-               --  user array.\n+               --  If the array element doesn't exist in the user array, insert\n+               --  a shallow copy of the conf array element in the user array.\n \n                if User_Array_Elem_Id = No_Array_Element then\n                   Array_Element_Table.Increment_Last (Shared.Array_Elements);\n@@ -270,8 +268,8 @@ package body Prj.Conf is\n                     User_Array_Elem;\n                   Shared.Arrays.Table (User_Array_Id) := User_Array;\n \n-               --  Otherwise, if the value is a string list, prepend the\n-               --  user array element with the conf array element value.\n+               --  Otherwise, if the value is a string list, prepend the conf\n+               --  array element value to the array element.\n \n                elsif Conf_Array_Elem.Value.Kind = List then\n                   Conf_List := Conf_Array_Elem.Value.Values;\n@@ -351,12 +349,13 @@ package body Prj.Conf is\n          Index : String := \"\";\n          Pkg   : Project_Node_Id := Empty_Node)\n       is\n-         Attr       : Project_Node_Id;\n+         Attr : Project_Node_Id;\n          pragma Unreferenced (Attr);\n \n          Expr   : Name_Id         := No_Name;\n          Val    : Name_Id         := No_Name;\n          Parent : Project_Node_Id := Config_File;\n+\n       begin\n          if Index /= \"\" then\n             Name_Len := Index'Length;\n@@ -456,10 +455,11 @@ package body Prj.Conf is\n    -----------------------\n \n    procedure Apply_Config_File\n-     (Config_File       : Prj.Project_Id;\n-      Project_Tree      : Prj.Project_Tree_Ref)\n+     (Config_File  : Prj.Project_Id;\n+      Project_Tree : Prj.Project_Tree_Ref)\n    is\n       Shared : constant Shared_Project_Tree_Data_Access := Project_Tree.Shared;\n+\n       Conf_Decl    : constant Declarations := Config_File.Decl;\n       Conf_Pack_Id : Package_Id;\n       Conf_Pack    : Package_Element;"}, {"sha": "d58f87e540bd5eb5cffaf7793a732dbd024b264f", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -208,6 +208,7 @@ package body Prj.Env is\n          Dummy   : in out Boolean)\n       is\n          pragma Unreferenced (Dummy, In_Tree);\n+\n          Path : constant Path_Name_Type :=\n                   Get_Object_Directory\n                     (Project,\n@@ -509,6 +510,7 @@ package body Prj.Env is\n          State   : in out Integer)\n       is\n          pragma Unreferenced (State, In_Tree);\n+\n          Lang   : constant Language_Ptr :=\n                     Get_Language_From_Name (Project, \"ada\");\n          Naming : Lang_Naming_Data;\n@@ -821,6 +823,7 @@ package body Prj.Env is\n          State   : in out Integer)\n       is\n          pragma Unreferenced (State);\n+\n          Source : Source_Id;\n          Suffix : File_Name_Type;\n          Iter   : Source_Iterator;\n@@ -1224,6 +1227,7 @@ package body Prj.Env is\n          Dummy : in out Integer)\n       is\n          pragma Unreferenced (Dummy, Tree);\n+\n       begin\n          --  ??? Set_Ada_Paths has a different behavior for library project\n          --  files, should we have the same ?\n@@ -1268,6 +1272,7 @@ package body Prj.Env is\n          Dummy   : in out Integer)\n       is\n          pragma Unreferenced (Dummy);\n+\n          Current    : String_List_Id := Prj.Source_Dirs;\n          The_String : String_Element;\n "}, {"sha": "0362277df5c9416794ce3dc43890f596f1d92e28", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 48, "deletions": 52, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -150,20 +150,9 @@ package body Prj.Nmsc is\n    --  information which is only useful while processing the project, and can\n    --  be discarded as soon as we have finished processing the project\n \n-   package Files_Htable is new GNAT.Dynamic_HTables.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Source_Id,\n-      No_Element => No_Source,\n-      Key        => File_Name_Type,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-   --  Mapping from base file names to Source_Id (containing full info about\n-   --  the source).\n-\n    type Tree_Processing_Data is record\n       Tree           : Project_Tree_Ref;\n       Node_Tree      : Prj.Tree.Project_Node_Tree_Ref;\n-      File_To_Source : Files_Htable.Instance;\n       Flags          : Prj.Processing_Flags;\n    end record;\n    --  Temporary data which is needed while parsing a project. It does not need\n@@ -673,7 +662,8 @@ package body Prj.Nmsc is\n          Source := Prev_Unit.File_Names (Kind);\n \n       else\n-         Source  := Files_Htable.Get (Data.File_To_Source, File_Name);\n+         Source := Source_Files_Htable.Get\n+           (Data.Tree.Source_Files_HT, File_Name);\n \n          if Source /= No_Source\n            and then Source.Index = Index\n@@ -900,8 +890,6 @@ package body Prj.Nmsc is\n          Data.Tree.Replaced_Source_Number :=\n            Data.Tree.Replaced_Source_Number - 1;\n       end if;\n-\n-      Files_Htable.Set (Data.File_To_Source, File_Name, Id);\n    end Add_Source;\n \n    ------------------------------\n@@ -932,7 +920,6 @@ package body Prj.Nmsc is\n       Data : Tree_Processing_Data :=\n                (Tree           => Tree,\n                 Node_Tree      => Node_Tree,\n-                File_To_Source => Files_Htable.Nil,\n                 Flags          => Flags);\n \n       Project_Files : constant Prj.Variable_Value :=\n@@ -6366,31 +6353,52 @@ package body Prj.Nmsc is\n          Source : Source_Id;\n          Iter   : Source_Iterator;\n          Found  : Boolean := False;\n-         Path   : Path_Information;\n \n       begin\n          Iter := For_Each_Source (Data.Tree, Project.Project);\n          loop\n             Source := Prj.Element (Iter);\n             exit when Source = No_Source;\n \n+            --  If the full source path is unknown for this source_id, there\n+            --  could be several reasons:\n+            --    * we simply did not find the file itself, this is an error\n+            --    * we have a multi-unit source file. Another Source_Id from\n+            --      the same file has received the full path, so we need to\n+            --      propagate it.\n+\n             if Source.Naming_Exception\n               and then Source.Path = No_Path_Information\n             then\n                if Source.Unit /= No_Unit_Index then\n                   Found := False;\n \n-                  --  For multi-unit source files, source_id gets duplicated\n-                  --  once for every unit. Only the first source_id got its\n-                  --  full path set.\n+                  if Source.Index /= 0 then  --  Only multi-unit files\n+                     declare\n+                        S : Source_Id :=\n+                          Source_Files_Htable.Get\n+                            (Data.Tree.Source_Files_HT, Source.File);\n+                     begin\n+                        while S /= null loop\n+                           if S.Path /= No_Path_Information then\n+                              Source.Path := S.Path;\n+                              Found := True;\n \n-                  if Source.Index /= 0 then\n-                     Path := Files_Htable.Get\n-                       (Data.File_To_Source, Source.File).Path;\n+                              if Current_Verbosity = High then\n+                                 Debug_Output\n+                                   (\"Setting full path for \"\n+                                    & Get_Name_String (Source.File)\n+                                    & \" at\" & Source.Index'Img\n+                                    & \" to \"\n+                                    & Get_Name_String (Source.Path.Name));\n+                              end if;\n \n-                     if Path /= No_Path_Information then\n-                        Found := True;\n-                     end if;\n+                              exit;\n+                           end if;\n+\n+                           S := S.Next_With_File_Name;\n+                        end loop;\n+                     end;\n                   end if;\n \n                   if not Found then\n@@ -6400,21 +6408,6 @@ package body Prj.Nmsc is\n                        (Data.Flags, Data.Flags.Missing_Source_Files,\n                         \"source file %% for unit %% not found\",\n                         No_Location, Project.Project);\n-\n-                  else\n-                     Source.Path := Path;\n-\n-                     if Current_Verbosity = High then\n-                        Debug_Indent;\n-\n-                        if Source.Path /= No_Path_Information then\n-                           Write_Line (\"Setting full path for \"\n-                                       & Get_Name_String (Source.File)\n-                                       & \" at\" & Source.Index'Img\n-                                       & \" to \"\n-                                       & Get_Name_String (Path.Name));\n-                        end if;\n-                     end if;\n                   end if;\n                end if;\n \n@@ -6472,7 +6465,6 @@ package body Prj.Nmsc is\n       Flags     : Prj.Processing_Flags)\n    is\n    begin\n-      Files_Htable.Reset (Data.File_To_Source);\n       Data.Tree      := Tree;\n       Data.Node_Tree := Node_Tree;\n       Data.Flags     := Flags;\n@@ -6483,8 +6475,9 @@ package body Prj.Nmsc is\n    ----------\n \n    procedure Free (Data : in out Tree_Processing_Data) is\n+      pragma Unreferenced (Data);\n    begin\n-      Files_Htable.Reset (Data.File_To_Source);\n+      null;\n    end Free;\n \n    ----------------\n@@ -6666,6 +6659,7 @@ package body Prj.Nmsc is\n       then\n          Debug_Output (\"Override kind for \"\n                        & Get_Name_String (Source.File)\n+                       & \" idx=\" & Source.Index'Img\n                        & \" kind=\" & Source.Kind'Img);\n       end if;\n \n@@ -6736,12 +6730,20 @@ package body Prj.Nmsc is\n                Check_Name := True;\n \n             else\n+               --  Set the full path for the source_id (which might have been\n+               --  created when parsing the naming exceptions, and therefore\n+               --  might not have the full path).\n+               --  We only set this for this source_id, but not for other\n+               --  source_id in the same file (case of multi-unit source files)\n+               --  For the latter, they will be set in Find_Sources when we\n+               --  check that all source_id have known full paths.\n+               --  Doing this later saves one htable lookup per file in the\n+               --  common case where the user is not using multi-unit files.\n+\n                Name_Loc.Source.Path := (Path, Display_Path);\n \n                Source_Paths_Htable.Set\n-                 (Data.Tree.Source_Paths_HT,\n-                  Path,\n-                  Name_Loc.Source);\n+                 (Data.Tree.Source_Paths_HT, Path, Name_Loc.Source);\n \n                --  Check if this is a subunit\n \n@@ -6755,9 +6757,6 @@ package body Prj.Nmsc is\n                      Override_Kind (Name_Loc.Source, Sep);\n                   end if;\n                end if;\n-\n-               Files_Htable.Set\n-                 (Data.File_To_Source, File_Name, Name_Loc.Source);\n             end if;\n          end if;\n       end if;\n@@ -7427,7 +7426,7 @@ package body Prj.Nmsc is\n \n       procedure Get_Sources_From_Source_Info;\n       --  Get the source information from the tables that were created when a\n-      --  source info fie was read.\n+      --  source info file was read.\n \n       ---------------------------\n       -- Check_Missing_Sources --\n@@ -7720,7 +7719,6 @@ package body Prj.Nmsc is\n \n             Id.Language            := Lang_Id;\n             Id.Kind                := Src.Kind;\n-\n             Id.Index               := Src.Index;\n \n             Id.Path :=\n@@ -7783,8 +7781,6 @@ package body Prj.Nmsc is\n             Id.Next_In_Lang := Id.Language.First_Source;\n             Id.Language.First_Source := Id;\n \n-            Files_Htable.Set (Data.File_To_Source, Id.File, Id);\n-\n             Next (Iter);\n          end loop;\n       end Get_Sources_From_Source_Info;"}, {"sha": "366dfced32d48b33faab008d7d2234546d886d3b", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -154,6 +154,7 @@ package body Prj.Proc is\n    --  as processed, call itself recursively for all imported projects and a\n    --  extended project, if any. Then process the declarative items of the\n    --  project.\n+   --\n    --  Is_Root_Project should be true only for the project that the user\n    --  explicitly loaded. In the context of aggregate projects, only that\n    --  project is allowed to modify the environment that will be used to load\n@@ -268,8 +269,9 @@ package body Prj.Proc is\n                  (Next  => Decl.Attributes,\n                   Name  => Attribute_Name_Of (The_Attribute),\n                   Value => New_Attribute);\n-               Decl.Attributes := Variable_Element_Table.Last\n-                 (Shared.Variable_Elements);\n+               Decl.Attributes :=\n+                 Variable_Element_Table.Last\n+                   (Shared.Variable_Elements);\n             end;\n          end if;\n \n@@ -610,16 +612,17 @@ package body Prj.Proc is\n                         --  This literal string list is the first term in a\n                         --  string list expression\n \n-                        Result.Values := String_Element_Table.Last\n-                          (Shared.String_Elements);\n+                        Result.Values :=\n+                          String_Element_Table.Last\n+                            (Shared.String_Elements);\n \n                      else\n                         Shared.String_Elements.Table (Last).Next :=\n                           String_Element_Table.Last (Shared.String_Elements);\n                      end if;\n \n-                     Last := String_Element_Table.Last\n-                       (Shared.String_Elements);\n+                     Last :=\n+                       String_Element_Table.Last (Shared.String_Elements);\n \n                      Shared.String_Elements.Table (Last) :=\n                        (Value    => Value.Value,\n@@ -706,8 +709,8 @@ package body Prj.Proc is\n \n                      The_Name :=\n                        Name_Of (Term_Package, From_Project_Node_Tree);\n-                     The_Package := The_Project.Decl.Packages;\n \n+                     The_Package := The_Project.Decl.Packages;\n                      while The_Package /= No_Package\n                        and then Shared.Packages.Table (The_Package).Name /=\n                           The_Name\n@@ -760,10 +763,11 @@ package body Prj.Proc is\n \n                         while The_Variable_Id /= No_Variable\n                           and then Shared.Variable_Elements.Table\n-                            (The_Variable_Id).Name /= The_Name\n+                                     (The_Variable_Id).Name /= The_Name\n                         loop\n-                           The_Variable_Id := Shared.Variable_Elements.Table\n-                             (The_Variable_Id).Next;\n+                           The_Variable_Id :=\n+                             Shared.Variable_Elements.Table\n+                               (The_Variable_Id).Next;\n                         end loop;\n \n                      end if;\n@@ -808,15 +812,15 @@ package body Prj.Proc is\n \n                      begin\n                         if The_Package /= No_Package then\n-                           The_Array := Shared.Packages.Table\n-                             (The_Package).Decl.Arrays;\n+                           The_Array :=\n+                             Shared.Packages.Table (The_Package).Decl.Arrays;\n                         else\n                            The_Array := The_Project.Decl.Arrays;\n                         end if;\n \n                         while The_Array /= No_Array\n                           and then Shared.Arrays.Table (The_Array).Name /=\n-                          The_Name\n+                                                                    The_Name\n                         loop\n                            The_Array := Shared.Arrays.Table (The_Array).Next;\n                         end loop;\n@@ -835,19 +839,18 @@ package body Prj.Proc is\n                                         (The_Element).Index /= Array_Index\n                            loop\n                               The_Element :=\n-                                Shared.Array_Elements.Table\n-                                  (The_Element).Next;\n+                                Shared.Array_Elements.Table (The_Element).Next;\n                            end loop;\n \n                         end if;\n \n                         if The_Element /= No_Array_Element then\n-                           The_Variable := Shared.Array_Elements.Table\n-                             (The_Element).Value;\n+                           The_Variable :=\n+                             Shared.Array_Elements.Table (The_Element).Value;\n \n                         else\n                            if Expression_Kind_Of\n-                             (The_Current_Term, From_Project_Node_Tree) =\n+                                (The_Current_Term, From_Project_Node_Tree) =\n                                                                         List\n                            then\n                               The_Variable :=\n@@ -1085,12 +1088,13 @@ package body Prj.Proc is\n                            end if;\n \n                            if not Done then\n-                              --  Count the number of string\n+\n+                              --  Count the number of strings\n \n                               declare\n                                  Saved : constant Positive := First;\n-                              begin\n \n+                              begin\n                                  Nmb := 1;\n                                  loop\n                                     Lst :=\n@@ -1479,11 +1483,13 @@ package body Prj.Proc is\n                      Error_Msg\n                        (Env.Flags, \"value %% is illegal for typed string %%\",\n                         Loc, Project);\n+\n                   when Warning =>\n                      Error_Msg\n                        (Env.Flags, \"?value %% is illegal for typed string %%\",\n                         Loc, Project);\n                      Reset_Value := True;\n+\n                   when Silent =>\n                      Reset_Value := True;\n                end case;"}, {"sha": "deec6769e24efd70fb6c9bb03c4399ba15173cd6", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -1025,7 +1025,7 @@ package body Prj.Util is\n    function Value_Of\n      (Variable_Name : Name_Id;\n       In_Variables  : Variable_Id;\n-      Shared      : Shared_Project_Tree_Data_Access) return Variable_Value\n+      Shared        : Shared_Project_Tree_Data_Access) return Variable_Value\n    is\n       Current      : Variable_Id;\n       The_Variable : Variable;"}, {"sha": "cd2629db5c67b707c08613d6a684e7f67a085db6", "filename": "gcc/ada/prj-util.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj-util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -141,7 +141,7 @@ package Prj.Util is\n    function Value_Of\n      (Variable_Name : Name_Id;\n       In_Variables  : Variable_Id;\n-      Shared      : Shared_Project_Tree_Data_Access) return Variable_Value;\n+      Shared        : Shared_Project_Tree_Data_Access) return Variable_Value;\n    --  Returns a specified variable in a variable list. Returns null if\n    --  In_Variables is null or if Variable_Name is not the name of a\n    --  variable in In_Variables. Caller must ensure that Name is lower case."}, {"sha": "86a864266b4de8fc9c7e65efde2555c41c779949", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -413,7 +413,8 @@ package body Prj is\n       Seen : Project_Boolean_Htable.Instance := Project_Boolean_Htable.Nil;\n \n       procedure Recursive_Check\n-        (Project : Project_Id; Tree : Project_Tree_Ref);\n+        (Project : Project_Id;\n+         Tree    : Project_Tree_Ref);\n       --  Check if a project has already been seen. If not seen, mark it as\n       --  Seen, Call Action, and check all its imported projects.\n \n@@ -422,7 +423,8 @@ package body Prj is\n       ---------------------\n \n       procedure Recursive_Check\n-        (Project : Project_Id; Tree : Project_Tree_Ref)\n+        (Project : Project_Id;\n+         Tree    : Project_Tree_Ref)\n       is\n          List : Project_List;\n          Agg  : Aggregated_Project_List;\n@@ -937,23 +939,25 @@ package body Prj is\n       --  Visible tables\n \n       if Tree.Is_Root_Tree then\n+\n          --  We cannot use 'Access here:\n          --    \"illegal attribute for discriminant-dependent component\"\n          --  However, we know this is valid since Shared and Shared_Data have\n          --  the same lifetime and will always exist concurrently.\n+\n          Tree.Shared := Tree.Shared_Data'Unrestricted_Access;\n-         Name_List_Table.Init          (Tree.Shared.Name_Lists);\n-         Number_List_Table.Init        (Tree.Shared.Number_Lists);\n-         String_Element_Table.Init     (Tree.Shared.String_Elements);\n-         Variable_Element_Table.Init   (Tree.Shared.Variable_Elements);\n-         Array_Element_Table.Init      (Tree.Shared.Array_Elements);\n-         Array_Table.Init              (Tree.Shared.Arrays);\n-         Package_Table.Init            (Tree.Shared.Packages);\n+         Name_List_Table.Init        (Tree.Shared.Name_Lists);\n+         Number_List_Table.Init      (Tree.Shared.Number_Lists);\n+         String_Element_Table.Init   (Tree.Shared.String_Elements);\n+         Variable_Element_Table.Init (Tree.Shared.Variable_Elements);\n+         Array_Element_Table.Init    (Tree.Shared.Array_Elements);\n+         Array_Table.Init            (Tree.Shared.Arrays);\n+         Package_Table.Init          (Tree.Shared.Packages);\n       end if;\n \n-      Source_Paths_Htable.Reset     (Tree.Source_Paths_HT);\n-      Source_Files_Htable.Reset     (Tree.Source_Files_HT);\n-      Replaced_Source_HTable.Reset  (Tree.Replaced_Sources);\n+      Source_Paths_Htable.Reset    (Tree.Source_Paths_HT);\n+      Source_Files_Htable.Reset    (Tree.Source_Files_HT);\n+      Replaced_Source_HTable.Reset (Tree.Replaced_Sources);\n \n       Tree.Replaced_Source_Number := 0;\n \n@@ -962,7 +966,7 @@ package body Prj is\n \n       --  Private part table\n \n-      Temp_Files_Table.Init       (Tree.Private_Part.Temp_Files);\n+      Temp_Files_Table.Init (Tree.Private_Part.Temp_Files);\n \n       Tree.Private_Part.Current_Source_Path_File := No_Path;\n       Tree.Private_Part.Current_Object_Path_File := No_Path;"}, {"sha": "670e690ec72f4dd74603db72d03889fc6f04ae50", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -1442,6 +1442,8 @@ package Prj is\n \n       Source_Paths_HT : Source_Paths_Htable.Instance;\n       --  Full path to Source_Id\n+      --  ??? What is behavior for multi-unit source files, where there are\n+      --  several source_id per file ?\n \n       Source_Info_File_Name : String_Access := null;\n       --  The name of the source info file, if specified by the builder"}, {"sha": "29257dc4c25151e3b5edb93846c92b59570f2489", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 55, "deletions": 61, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -639,6 +639,9 @@ package Rtsfind is\n      RE_Current_Task,                    -- Ada.Task_Identification\n      RO_AT_Task_Id,                      -- Ada.Task_Identification\n \n+     RE_Integer_8,                       -- Interfaces\n+     RE_Integer_16,                      -- Interfaces\n+     RE_Integer_32,                      -- Interfaces\n      RE_Integer_64,                      -- Interfaces\n      RE_Unsigned_8,                      -- Interfaces\n      RE_Unsigned_16,                     -- Interfaces\n@@ -1210,19 +1213,17 @@ package Rtsfind is\n      RE_FA_B,                            -- System.Partition_Interface\n      RE_FA_C,                            -- System.Partition_Interface\n      RE_FA_F,                            -- System.Partition_Interface\n-     RE_FA_I,                            -- System.Partition_Interface\n+     RE_FA_I8,                           -- System.Partition_Interface\n+     RE_FA_I16,                          -- System.Partition_Interface\n+     RE_FA_I32,                          -- System.Partition_Interface\n+     RE_FA_I64,                          -- System.Partition_Interface\n      RE_FA_LF,                           -- System.Partition_Interface\n-     RE_FA_LI,                           -- System.Partition_Interface\n      RE_FA_LLF,                          -- System.Partition_Interface\n-     RE_FA_LLI,                          -- System.Partition_Interface\n-     RE_FA_LLU,                          -- System.Partition_Interface\n-     RE_FA_LU,                           -- System.Partition_Interface\n      RE_FA_SF,                           -- System.Partition_Interface\n-     RE_FA_SI,                           -- System.Partition_Interface\n-     RE_FA_SSI,                          -- System.Partition_Interface\n-     RE_FA_SSU,                          -- System.Partition_Interface\n-     RE_FA_SU,                           -- System.Partition_Interface\n-     RE_FA_U,                            -- System.Partition_Interface\n+     RE_FA_U8,                           -- System.Partition_Interface\n+     RE_FA_U16,                          -- System.Partition_Interface\n+     RE_FA_U32,                          -- System.Partition_Interface\n+     RE_FA_U64,                          -- System.Partition_Interface\n      RE_FA_WC,                           -- System.Partition_Interface\n      RE_FA_WWC,                          -- System.Partition_Interface\n      RE_FA_String,                       -- System.Partition_Interface\n@@ -1232,19 +1233,17 @@ package Rtsfind is\n      RE_TA_B,                            -- System.Partition_Interface\n      RE_TA_C,                            -- System.Partition_Interface\n      RE_TA_F,                            -- System.Partition_Interface\n-     RE_TA_I,                            -- System.Partition_Interface\n+     RE_TA_I8,                           -- System.Partition_Interface\n+     RE_TA_I16,                          -- System.Partition_Interface\n+     RE_TA_I32,                          -- System.Partition_Interface\n+     RE_TA_I64,                          -- System.Partition_Interface\n      RE_TA_LF,                           -- System.Partition_Interface\n-     RE_TA_LI,                           -- System.Partition_Interface\n      RE_TA_LLF,                          -- System.Partition_Interface\n-     RE_TA_LLI,                          -- System.Partition_Interface\n-     RE_TA_LLU,                          -- System.Partition_Interface\n-     RE_TA_LU,                           -- System.Partition_Interface\n      RE_TA_SF,                           -- System.Partition_Interface\n-     RE_TA_SI,                           -- System.Partition_Interface\n-     RE_TA_SSI,                          -- System.Partition_Interface\n-     RE_TA_SSU,                          -- System.Partition_Interface\n-     RE_TA_SU,                           -- System.Partition_Interface\n-     RE_TA_U,                            -- System.Partition_Interface\n+     RE_TA_U8,                           -- System.Partition_Interface\n+     RE_TA_U16,                          -- System.Partition_Interface\n+     RE_TA_U32,                          -- System.Partition_Interface\n+     RE_TA_U64,                          -- System.Partition_Interface\n      RE_TA_WC,                           -- System.Partition_Interface\n      RE_TA_WWC,                          -- System.Partition_Interface\n      RE_TA_String,                       -- System.Partition_Interface\n@@ -1260,19 +1259,17 @@ package Rtsfind is\n      RE_TC_B,                            -- System.Partition_Interface\n      RE_TC_C,                            -- System.Partition_Interface\n      RE_TC_F,                            -- System.Partition_Interface\n-     RE_TC_I,                            -- System.Partition_Interface\n+     RE_TC_I8,                           -- System.Partition_Interface\n+     RE_TC_I16,                          -- System.Partition_Interface\n+     RE_TC_I32,                          -- System.Partition_Interface\n+     RE_TC_I64,                          -- System.Partition_Interface\n      RE_TC_LF,                           -- System.Partition_Interface\n-     RE_TC_LI,                           -- System.Partition_Interface\n      RE_TC_LLF,                          -- System.Partition_Interface\n-     RE_TC_LLI,                          -- System.Partition_Interface\n-     RE_TC_LLU,                          -- System.Partition_Interface\n-     RE_TC_LU,                           -- System.Partition_Interface\n      RE_TC_SF,                           -- System.Partition_Interface\n-     RE_TC_SI,                           -- System.Partition_Interface\n-     RE_TC_SSI,                          -- System.Partition_Interface\n-     RE_TC_SSU,                          -- System.Partition_Interface\n-     RE_TC_SU,                           -- System.Partition_Interface\n-     RE_TC_U,                            -- System.Partition_Interface\n+     RE_TC_U8,                           -- System.Partition_Interface\n+     RE_TC_U16,                          -- System.Partition_Interface\n+     RE_TC_U32,                          -- System.Partition_Interface\n+     RE_TC_U64,                          -- System.Partition_Interface\n      RE_TC_Void,                         -- System.Partition_Interface\n      RE_TC_Opaque,                       -- System.Partition_Interface\n      RE_TC_WC,                           -- System.Partition_Interface\n@@ -1819,6 +1816,9 @@ package Rtsfind is\n      RE_Current_Task                     => Ada_Task_Identification,\n      RO_AT_Task_Id                       => Ada_Task_Identification,\n \n+     RE_Integer_8                        => Interfaces,\n+     RE_Integer_16                       => Interfaces,\n+     RE_Integer_32                       => Interfaces,\n      RE_Integer_64                       => Interfaces,\n      RE_Unsigned_8                       => Interfaces,\n      RE_Unsigned_16                      => Interfaces,\n@@ -2381,19 +2381,17 @@ package Rtsfind is\n      RE_FA_B                             => System_Partition_Interface,\n      RE_FA_C                             => System_Partition_Interface,\n      RE_FA_F                             => System_Partition_Interface,\n-     RE_FA_I                             => System_Partition_Interface,\n+     RE_FA_I8                            => System_Partition_Interface,\n+     RE_FA_I16                           => System_Partition_Interface,\n+     RE_FA_I32                           => System_Partition_Interface,\n+     RE_FA_I64                           => System_Partition_Interface,\n      RE_FA_LF                            => System_Partition_Interface,\n-     RE_FA_LI                            => System_Partition_Interface,\n      RE_FA_LLF                           => System_Partition_Interface,\n-     RE_FA_LLI                           => System_Partition_Interface,\n-     RE_FA_LLU                           => System_Partition_Interface,\n-     RE_FA_LU                            => System_Partition_Interface,\n      RE_FA_SF                            => System_Partition_Interface,\n-     RE_FA_SI                            => System_Partition_Interface,\n-     RE_FA_SSI                           => System_Partition_Interface,\n-     RE_FA_SSU                           => System_Partition_Interface,\n-     RE_FA_SU                            => System_Partition_Interface,\n-     RE_FA_U                             => System_Partition_Interface,\n+     RE_FA_U8                            => System_Partition_Interface,\n+     RE_FA_U16                           => System_Partition_Interface,\n+     RE_FA_U32                           => System_Partition_Interface,\n+     RE_FA_U64                           => System_Partition_Interface,\n      RE_FA_WC                            => System_Partition_Interface,\n      RE_FA_WWC                           => System_Partition_Interface,\n      RE_FA_String                        => System_Partition_Interface,\n@@ -2403,19 +2401,17 @@ package Rtsfind is\n      RE_TA_B                             => System_Partition_Interface,\n      RE_TA_C                             => System_Partition_Interface,\n      RE_TA_F                             => System_Partition_Interface,\n-     RE_TA_I                             => System_Partition_Interface,\n+     RE_TA_I8                            => System_Partition_Interface,\n+     RE_TA_I16                           => System_Partition_Interface,\n+     RE_TA_I32                           => System_Partition_Interface,\n+     RE_TA_I64                           => System_Partition_Interface,\n      RE_TA_LF                            => System_Partition_Interface,\n-     RE_TA_LI                            => System_Partition_Interface,\n      RE_TA_LLF                           => System_Partition_Interface,\n-     RE_TA_LLI                           => System_Partition_Interface,\n-     RE_TA_LLU                           => System_Partition_Interface,\n-     RE_TA_LU                            => System_Partition_Interface,\n      RE_TA_SF                            => System_Partition_Interface,\n-     RE_TA_SI                            => System_Partition_Interface,\n-     RE_TA_SSI                           => System_Partition_Interface,\n-     RE_TA_SSU                           => System_Partition_Interface,\n-     RE_TA_SU                            => System_Partition_Interface,\n-     RE_TA_U                             => System_Partition_Interface,\n+     RE_TA_U8                            => System_Partition_Interface,\n+     RE_TA_U16                           => System_Partition_Interface,\n+     RE_TA_U32                           => System_Partition_Interface,\n+     RE_TA_U64                           => System_Partition_Interface,\n      RE_TA_WC                            => System_Partition_Interface,\n      RE_TA_WWC                           => System_Partition_Interface,\n      RE_TA_String                        => System_Partition_Interface,\n@@ -2431,19 +2427,17 @@ package Rtsfind is\n      RE_TC_B                             => System_Partition_Interface,\n      RE_TC_C                             => System_Partition_Interface,\n      RE_TC_F                             => System_Partition_Interface,\n-     RE_TC_I                             => System_Partition_Interface,\n+     RE_TC_I8                            => System_Partition_Interface,\n+     RE_TC_I16                           => System_Partition_Interface,\n+     RE_TC_I32                           => System_Partition_Interface,\n+     RE_TC_I64                           => System_Partition_Interface,\n      RE_TC_LF                            => System_Partition_Interface,\n-     RE_TC_LI                            => System_Partition_Interface,\n      RE_TC_LLF                           => System_Partition_Interface,\n-     RE_TC_LLI                           => System_Partition_Interface,\n-     RE_TC_LLU                           => System_Partition_Interface,\n-     RE_TC_LU                            => System_Partition_Interface,\n      RE_TC_SF                            => System_Partition_Interface,\n-     RE_TC_SI                            => System_Partition_Interface,\n-     RE_TC_SSI                           => System_Partition_Interface,\n-     RE_TC_SSU                           => System_Partition_Interface,\n-     RE_TC_SU                            => System_Partition_Interface,\n-     RE_TC_U                             => System_Partition_Interface,\n+     RE_TC_U8                            => System_Partition_Interface,\n+     RE_TC_U16                           => System_Partition_Interface,\n+     RE_TC_U32                           => System_Partition_Interface,\n+     RE_TC_U64                           => System_Partition_Interface,\n      RE_TC_Void                          => System_Partition_Interface,\n      RE_TC_Opaque                        => System_Partition_Interface,\n      RE_TC_WC                            => System_Partition_Interface,"}, {"sha": "8d46cbd98c16f5d2082c922ac5f079ece6056c85", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2010, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,9 +81,6 @@ package body System.Task_Primitives.Operations is\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n-   ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_Id associated with a thread\n-\n    Environment_Task_Id : Task_Id;\n    --  A variable to hold Task_Id for the environment task\n "}, {"sha": "705e8a514348135dcf8e808d9faa309dc7acd44c", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -83,9 +83,6 @@ package body System.Task_Primitives.Operations is\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n-   ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_Id associated with a thread\n-\n    Environment_Task_Id : Task_Id;\n    --  A variable to hold Task_Id for the environment task\n "}, {"sha": "cd6daca128f04e0f82078ea3b6cd0dffac563afb", "filename": "gcc/ada/s-taprop-tru64.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-taprop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-taprop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-tru64.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2009, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -77,9 +77,6 @@ package body System.Task_Primitives.Operations is\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n-   ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_Id associated with a thread\n-\n    Environment_Task_Id : Task_Id;\n    --  A variable to hold Task_Id for the environment task\n "}, {"sha": "485abc5c9539a5302f98101851f737612277c423", "filename": "gcc/ada/s-tpopsp-posix-foreign.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-tpopsp-posix-foreign.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-tpopsp-posix-foreign.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-posix-foreign.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                B o d y                                   --\n --                                                                          --\n---         Copyright (C) 1992-2009, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,12 +32,12 @@\n --  This is a POSIX version of this package where foreign threads are\n --  recognized.\n \n---  Currently, DEC Unix, SCO UnixWare, Solaris pthread, HPUX pthread and\n---  GNU/Linux threads use this version.\n-\n separate (System.Task_Primitives.Operations)\n package body Specific is\n \n+   ATCB_Key : aliased pthread_key_t;\n+   --  Key used to find the Ada Task_Id associated with a thread\n+\n    ----------------\n    -- Initialize --\n    ----------------"}, {"sha": "af068e0bc225c8d9071388783ddf51db619c17a3", "filename": "gcc/ada/s-tpopsp-posix.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-tpopsp-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-tpopsp-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-posix.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,6 +34,9 @@\n separate (System.Task_Primitives.Operations)\n package body Specific is\n \n+   ATCB_Key : aliased pthread_key_t;\n+   --  Key used to find the Ada Task_Id associated with a thread\n+\n    ----------------\n    -- Initialize --\n    ----------------"}, {"sha": "a82f7f38d3e412729f8a37402cfb0d1f0d78ef69", "filename": "gcc/ada/s-tpopsp-tls.adb", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-tpopsp-tls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fs-tpopsp-tls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-tls.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -0,0 +1,97 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--                SYSTEM.TASK_PRIMITIVES.OPERATIONS.SPECIFIC                --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--         Copyright (C) 1992-2011, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a version of this package using TLS and where foreign threads are\n+--  recognized.\n+\n+separate (System.Task_Primitives.Operations)\n+package body Specific is\n+\n+   ATCB : aliased Task_Id := null;\n+   pragma Thread_Local_Storage (ATCB);\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_Id) is\n+   begin\n+      ATCB := Environment_Task;\n+   end Initialize;\n+\n+   -------------------\n+   -- Is_Valid_Task --\n+   -------------------\n+\n+   function Is_Valid_Task return Boolean is\n+   begin\n+      return ATCB /= null;\n+   end Is_Valid_Task;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set (Self_Id : Task_Id) is\n+   begin\n+      ATCB := Self_Id;\n+   end Set;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   --  To make Ada tasks and C threads interoperate better, we have added some\n+   --  functionality to Self. Suppose a C main program (with threads) calls an\n+   --  Ada procedure and the Ada procedure calls the tasking runtime system.\n+   --  Eventually, a call will be made to self. Since the call is not coming\n+   --  from an Ada task, there will be no corresponding ATCB.\n+\n+   --  What we do in Self is to catch references that do not come from\n+   --  recognized Ada tasks, and create an ATCB for the calling thread.\n+\n+   --  The new ATCB will be \"detached\" from the normal Ada task master\n+   --  hierarchy, much like the existing implicitly created signal-server\n+   --  tasks.\n+\n+   function Self return Task_Id is\n+      Result : constant Task_Id := ATCB;\n+   begin\n+      if Result /= null then\n+         return Result;\n+      else\n+         --  If the value is Null then it is a non-Ada task\n+\n+         return Register_Foreign_Thread;\n+      end if;\n+   end Self;\n+\n+end Specific;"}, {"sha": "15689c33344245df26a1bb8dc5760becf23744cb", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -2841,6 +2841,7 @@ package body Sem_Ch13 is\n       Choice   : Node_Id;\n       Val      : Uint;\n       Err      : Boolean := False;\n+      --  Set True to avoid cascade errors and crashes on incorrect source code\n \n       Lo : constant Uint := Expr_Value (Type_Low_Bound (Universal_Integer));\n       Hi : constant Uint := Expr_Value (Type_High_Bound (Universal_Integer));\n@@ -2985,45 +2986,51 @@ package body Sem_Ch13 is\n \n             else\n                Analyze_And_Resolve (Choice, Enumtype);\n-\n-               if Is_Entity_Name (Choice)\n-                 and then Is_Type (Entity (Choice))\n-               then\n-                  Error_Msg_N (\"subtype name not allowed here\", Choice);\n+               if Error_Posted (Choice) then\n                   Err := True;\n-                  --  ??? should allow static subtype with zero/one entry\n+               end if;\n \n-               elsif Etype (Choice) = Base_Type (Enumtype) then\n-                  if not Is_Static_Expression (Choice) then\n-                     Flag_Non_Static_Expr\n-                       (\"non-static expression used for choice!\", Choice);\n+               if not Err then\n+                  if Is_Entity_Name (Choice)\n+                    and then Is_Type (Entity (Choice))\n+                  then\n+                     Error_Msg_N (\"subtype name not allowed here\", Choice);\n                      Err := True;\n+                     --  ??? should allow static subtype with zero/one entry\n \n-                  else\n-                     Elit := Expr_Value_E (Choice);\n-\n-                     if Present (Enumeration_Rep_Expr (Elit)) then\n-                        Error_Msg_Sloc := Sloc (Enumeration_Rep_Expr (Elit));\n-                        Error_Msg_NE\n-                          (\"representation for& previously given#\",\n-                           Choice, Elit);\n+                  elsif Etype (Choice) = Base_Type (Enumtype) then\n+                     if not Is_Static_Expression (Choice) then\n+                        Flag_Non_Static_Expr\n+                          (\"non-static expression used for choice!\", Choice);\n                         Err := True;\n-                     end if;\n \n-                     Set_Enumeration_Rep_Expr (Elit, Expression (Assoc));\n+                     else\n+                        Elit := Expr_Value_E (Choice);\n+\n+                        if Present (Enumeration_Rep_Expr (Elit)) then\n+                           Error_Msg_Sloc :=\n+                             Sloc (Enumeration_Rep_Expr (Elit));\n+                           Error_Msg_NE\n+                             (\"representation for& previously given#\",\n+                              Choice, Elit);\n+                           Err := True;\n+                        end if;\n \n-                     Expr := Expression (Assoc);\n-                     Val := Static_Integer (Expr);\n+                        Set_Enumeration_Rep_Expr (Elit, Expression (Assoc));\n \n-                     if Val = No_Uint then\n-                        Err := True;\n+                        Expr := Expression (Assoc);\n+                        Val := Static_Integer (Expr);\n \n-                     elsif Val < Lo or else Hi < Val then\n-                        Error_Msg_N (\"value outside permitted range\", Expr);\n-                        Err := True;\n-                     end if;\n+                        if Val = No_Uint then\n+                           Err := True;\n+\n+                        elsif Val < Lo or else Hi < Val then\n+                           Error_Msg_N (\"value outside permitted range\", Expr);\n+                           Err := True;\n+                        end if;\n \n-                     Set_Enumeration_Rep (Elit, Val);\n+                        Set_Enumeration_Rep (Elit, Val);\n+                     end if;\n                   end if;\n                end if;\n             end if;"}, {"sha": "62f4abd0f0a5a361ed878ebdbbe0516546090103", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -1516,8 +1516,8 @@ package body Sem_Ch7 is\n    procedure Declare_Inherited_Private_Subprograms (Id : Entity_Id) is\n \n       function Is_Primitive_Of (T : Entity_Id; S : Entity_Id) return Boolean;\n-      --  Check whether an inherited subprogram is an operation of an untagged\n-      --  derived type.\n+      --  Check whether an inherited subprogram S is an operation of an\n+      --  untagged derived type T.\n \n       ---------------------\n       -- Is_Primitive_Of --"}, {"sha": "a24b1f089022ceb21bde280b707da74a29ef2dae", "filename": "gcc/ada/system-aix.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fsystem-aix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fsystem-aix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-aix.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                            (AIX/PPC Version)                             --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -149,7 +149,7 @@ private\n    Always_Compatible_Rep     : constant Boolean := True;\n    Suppress_Standard_Library : constant Boolean := False;\n    Use_Ada_Main_Program_Name : constant Boolean := False;\n-   ZCX_By_Default            : constant Boolean := False;\n-   GCC_ZCX_Support           : constant Boolean := True;  --  Post GCC 4 only\n+   ZCX_By_Default            : constant Boolean := True;\n+   GCC_ZCX_Support           : constant Boolean := True;\n \n end System;"}, {"sha": "8b2a4e91e476ea9477f7d29f1733478a679a6872", "filename": "gcc/ada/system-aix64.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fsystem-aix64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686d09844fd59ffdb2d49c1c5da0a46594d06778/gcc%2Fada%2Fsystem-aix64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-aix64.ads?ref=686d09844fd59ffdb2d49c1c5da0a46594d06778", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                           (PPC/AIX64 Version)                            --\n --                                                                          --\n---            Copyright (C) 2009, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -149,7 +149,7 @@ private\n    Always_Compatible_Rep     : constant Boolean := True;\n    Suppress_Standard_Library : constant Boolean := False;\n    Use_Ada_Main_Program_Name : constant Boolean := False;\n-   ZCX_By_Default            : constant Boolean := False;\n-   GCC_ZCX_Support           : constant Boolean := True;  --  Post GCC 4 only\n+   ZCX_By_Default            : constant Boolean := True;\n+   GCC_ZCX_Support           : constant Boolean := True;\n \n end System;"}]}