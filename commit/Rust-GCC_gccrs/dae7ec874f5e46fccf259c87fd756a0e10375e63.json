{"sha": "dae7ec874f5e46fccf259c87fd756a0e10375e63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFlN2VjODc0ZjVlNDZmY2NmMjU5Yzg3ZmQ3NTZhMGUxMDM3NWU2Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2006-02-09T09:54:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2006-02-09T09:54:36Z"}, "message": "re PR c++/25979 (incorrect codegen for conditional [SVO issue])\n\n        PR c++/25979\n        * tree.def: Elaborate on difference from MODIFY_EXPR.\n        * doc/c-tree.texi (INIT_EXPR): Likewise.\n        * gimplify.c (internal_get_tmp_var): Use INIT_EXPR.\n        (gimplify_decl_expr, gimplify_init_ctor_eval): Likewise.\n        (gimplify_target_expr): Likewise.\n        (gimplify_cond_expr): Remove target handling.\n        (gimplify_modify_expr): Don't clobber INIT_EXPR code here.\n        (gimplify_expr): Clobber it here.\n        (gimplify_modify_expr_rhs): Push assignment into COND_EXPR here.\n        Do return slot optimization if we have an INIT_EXPR.\n\n        PR tree-opt/24365\n        * tree-inline.c (declare_return_variable): Also clear\n        DECL_COMPLEX_GIMPLE_REG_P as needed in the modify_dest case.\n\n        PR c++/16405\n        * gimplify.c (gimplify_modify_expr_rhs): Re-enable *& handling.\n\n        PR middle-end/22439\n        * gimplify.c (gimplify_one_sizepos): Fix typo.\n\nFrom-SVN: r110789", "tree": {"sha": "2e7796711ab7dc7b1bc13550933b9b8d077c098e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e7796711ab7dc7b1bc13550933b9b8d077c098e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dae7ec874f5e46fccf259c87fd756a0e10375e63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae7ec874f5e46fccf259c87fd756a0e10375e63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dae7ec874f5e46fccf259c87fd756a0e10375e63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae7ec874f5e46fccf259c87fd756a0e10375e63/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "845d2a4b7d4a91d82624d9877e275b46746511fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/845d2a4b7d4a91d82624d9877e275b46746511fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/845d2a4b7d4a91d82624d9877e275b46746511fe"}], "stats": {"total": 155, "additions": 107, "deletions": 48}, "files": [{"sha": "83b801fd6ba451f21f11d9ee86ff7fa500df8f65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dae7ec874f5e46fccf259c87fd756a0e10375e63", "patch": "@@ -1,3 +1,27 @@\n+2006-02-08  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/25979\n+\t* tree.def: Elaborate on difference from MODIFY_EXPR.\n+\t* doc/c-tree.texi (INIT_EXPR): Likewise.\n+\t* gimplify.c (internal_get_tmp_var): Use INIT_EXPR.\n+\t(gimplify_decl_expr, gimplify_init_ctor_eval): Likewise.\n+\t(gimplify_target_expr): Likewise.\n+\t(gimplify_cond_expr): Remove target handling.\n+\t(gimplify_modify_expr): Don't clobber INIT_EXPR code here.\n+\t(gimplify_expr): Clobber it here.\n+\t(gimplify_modify_expr_rhs): Push assignment into COND_EXPR here.\n+\tDo return slot optimization if we have an INIT_EXPR.\n+\n+\tPR tree-opt/24365\n+\t* tree-inline.c (declare_return_variable): Also clear \n+\tDECL_COMPLEX_GIMPLE_REG_P as needed in the modify_dest case.\n+\n+\tPR c++/16405\n+\t* gimplify.c (gimplify_modify_expr_rhs): Re-enable *& handling.\n+\n+\tPR middle-end/22439\n+\t* gimplify.c (gimplify_one_sizepos): Fix typo.\n+\n 2006-02-08  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/21417"}, {"sha": "74071c91e904a7d784c44eb46a3fedbec0463f2e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dae7ec874f5e46fccf259c87fd756a0e10375e63", "patch": "@@ -1,3 +1,10 @@\n+2006-02-08  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/25979\n+\t* cp-gimplify.c (cp_gimplify_expr): Don't call\n+\tcp_gimplify_init_expr for MODIFY_EXPRs.\n+\t* typeck2.c (split_nonconstant_init_1): Use INIT_EXPR.\n+\n 2006-02-08  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/26071"}, {"sha": "a9fb7bf28e6a10e24693a4b18f71b125946655cf", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=dae7ec874f5e46fccf259c87fd756a0e10375e63", "patch": "@@ -477,8 +477,10 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       ret = GS_OK;\n       break;\n \n+      /* We used to do this for MODIFY_EXPR as well, but that's unsafe; the\n+\t LHS of an assignment might also be involved in the RHS, as in bug\n+\t 25979.  */\n     case INIT_EXPR:\n-    case MODIFY_EXPR:\n       cp_gimplify_init_expr (expr_p, pre_p, post_p);\n       ret = GS_OK;\n       break;"}, {"sha": "49c58f8e51ee3ff189768269b7582d01ffc2d4e4", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=dae7ec874f5e46fccf259c87fd756a0e10375e63", "patch": "@@ -502,7 +502,7 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t\tsub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n \t\t\t      NULL_TREE);\n \n-\t      code = build2 (MODIFY_EXPR, inner_type, sub, value);\n+\t      code = build2 (INIT_EXPR, inner_type, sub, value);\n \t      code = build_stmt (EXPR_STMT, code);\n \t      add_stmt (code);\n \t      continue;"}, {"sha": "62e7738054cb17c90fb9ad2461053e1b5d2f47b1", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=dae7ec874f5e46fccf259c87fd756a0e10375e63", "patch": "@@ -2350,7 +2350,10 @@ just like that for @samp{i = i + 3}.\n \n @item INIT_EXPR\n These nodes are just like @code{MODIFY_EXPR}, but are used only when a\n-variable is initialized, rather than assigned to subsequently.\n+variable is initialized, rather than assigned to subsequently.  This\n+means that we can assume that the target of the initialization is not\n+used in computing its own value; any reference to the lhs in computing\n+the rhs is undefined.\n \n @item COMPONENT_REF\n These nodes represent non-static data member accesses.  The first"}, {"sha": "710569888ec32e50ff31adb4683fb4ee1f2a152f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=dae7ec874f5e46fccf259c87fd756a0e10375e63", "patch": "@@ -606,7 +606,7 @@ internal_get_tmp_var (tree val, tree *pre_p, tree *post_p, bool is_formal)\n   if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE)\n     DECL_COMPLEX_GIMPLE_REG_P (t) = 1;\n \n-  mod = build2 (MODIFY_EXPR, TREE_TYPE (t), t, val);\n+  mod = build2 (INIT_EXPR, TREE_TYPE (t), t, val);\n \n   if (EXPR_HAS_LOCATION (val))\n     SET_EXPR_LOCUS (mod, EXPR_LOCUS (val));\n@@ -1204,7 +1204,7 @@ gimplify_decl_expr (tree *stmt_p)\n \t  if (!TREE_STATIC (decl))\n \t    {\n \t      DECL_INITIAL (decl) = NULL_TREE;\n-\t      init = build2 (MODIFY_EXPR, void_type_node, decl, init);\n+\t      init = build2 (INIT_EXPR, void_type_node, decl, init);\n \t      gimplify_and_add (init, stmt_p);\n \t    }\n \t  else\n@@ -2341,14 +2341,10 @@ gimple_boolify (tree expr)\n     TARGET is the tree for T1 above.\n \n     PRE_P points to the list where side effects that must happen before\n-\t*EXPR_P should be stored.\n-\n-   POST_P points to the list where side effects that must happen after\n-     *EXPR_P should be stored.  */\n+      *EXPR_P should be stored.  */\n \n static enum gimplify_status\n-gimplify_cond_expr (tree *expr_p, tree *pre_p, tree *post_p, tree target,\n-\t\t    fallback_t fallback)\n+gimplify_cond_expr (tree *expr_p, tree *pre_p, fallback_t fallback)\n {\n   tree expr = *expr_p;\n   tree tmp, tmp2, type;\n@@ -2362,16 +2358,7 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, tree *post_p, tree target,\n     {\n       tree result;\n \n-      if (target)\n-\t{\n-\t  ret = gimplify_expr (&target, pre_p, post_p,\n-\t\t\t       is_gimple_min_lval, fb_lvalue);\n-\t  if (ret != GS_ERROR)\n-\t    ret = GS_OK;\n-\t  result = tmp = target;\n-\t  tmp2 = unshare_expr (target);\n-\t}\n-      else if ((fallback & fb_lvalue) == 0)\n+      if ((fallback & fb_lvalue) == 0)\n \t{\n \t  result = tmp2 = tmp = create_tmp_var (TREE_TYPE (expr), \"iftmp\");\n \t  ret = GS_ALL_DONE;\n@@ -2836,7 +2823,7 @@ gimplify_init_ctor_eval (tree object, VEC(constructor_elt,gc) *elts,\n \t\t\t\t pre_p, cleared);\n       else\n \t{\n-\t  init = build2 (MODIFY_EXPR, TREE_TYPE (cref), cref, value);\n+\t  init = build2 (INIT_EXPR, TREE_TYPE (cref), cref, value);\n \t  gimplify_and_add (init, pre_p);\n \t}\n     }\n@@ -3190,7 +3177,6 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n   while (ret != GS_UNHANDLED)\n     switch (TREE_CODE (*from_p))\n       {\n-#if 0\n       case INDIRECT_REF:\n \t{\n \t  /* If we have code like \n@@ -3212,7 +3198,6 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \t    ret = GS_UNHANDLED;\n \t  break;\n \t}\n-#endif\n \n       case TARGET_EXPR:\n \t{\n@@ -3257,9 +3242,36 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \t   copy in other cases as well.  */\n \tif (!is_gimple_reg_type (TREE_TYPE (*from_p)))\n \t  {\n-\t    *expr_p = *from_p;\n-\t    return gimplify_cond_expr (expr_p, pre_p, post_p, *to_p,\n-\t\t\t\t       fb_rvalue);\n+\t    /* This code should mirror the code in gimplify_cond_expr. */\n+\t    enum tree_code code = TREE_CODE (*expr_p);\n+\t    tree cond = *from_p;\n+\t    tree result = *to_p;\n+\n+\t    ret = gimplify_expr (&result, pre_p, post_p,\n+\t\t\t\t is_gimple_min_lval, fb_lvalue);\n+\t    if (ret != GS_ERROR)\n+\t      ret = GS_OK;\n+\n+\t    if (TREE_TYPE (TREE_OPERAND (cond, 1)) != void_type_node)\n+\t      TREE_OPERAND (cond, 1)\n+\t\t= build2 (code, void_type_node, result,\n+\t\t\t  TREE_OPERAND (cond, 1));\n+\t    if (TREE_TYPE (TREE_OPERAND (cond, 2)) != void_type_node)\n+\t      TREE_OPERAND (cond, 2)\n+\t\t= build2 (code, void_type_node, unshare_expr (result),\n+\t\t\t  TREE_OPERAND (cond, 2));\n+\n+\t    TREE_TYPE (cond) = void_type_node;\n+\t    recalculate_side_effects (cond);\n+\n+\t    if (want_value)\n+\t      {\n+\t\tgimplify_and_add (cond, pre_p);\n+\t\t*expr_p = unshare_expr (result);\n+\t      }\n+\t    else\n+\t      *expr_p = cond;\n+\t    return ret;\n \t  }\n \telse\n \t  ret = GS_UNHANDLED;\n@@ -3273,11 +3285,26 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \t  {\n \t    bool use_target;\n \n-\t    if (TREE_CODE (*to_p) == RESULT_DECL\n-\t\t&& DECL_NAME (*to_p) == NULL_TREE\n-\t\t&& needs_to_live_in_memory (*to_p))\n+\t    if (!(rhs_predicate_for (*to_p))(*from_p))\n+\t      /* If we need a temporary, *to_p isn't accurate.  */\n+\t      use_target = false;\n+\t    else if (TREE_CODE (*to_p) == RESULT_DECL\n+\t\t     && DECL_NAME (*to_p) == NULL_TREE\n+\t\t     && needs_to_live_in_memory (*to_p))\n \t      /* It's OK to use the return slot directly unless it's an NRV. */\n \t      use_target = true;\n+\t    else if (is_gimple_reg_type (TREE_TYPE (*to_p)))\n+\t      /* Don't force regs into memory.  */\n+\t      use_target = false;\n+\t    else if (TREE_CODE (*to_p) == VAR_DECL\n+\t\t     && DECL_GIMPLE_FORMAL_TEMP_P (*to_p))\n+\t      /* Don't use the original target if it's a formal temp; we\n+\t\t don't want to take their addresses.  */\n+\t      use_target = false;\n+\t    else if (TREE_CODE (*expr_p) == INIT_EXPR)\n+\t      /* It's OK to use the target directly if it's being\n+\t\t initialized. */\n+\t      use_target = true;\n \t    else if (!is_gimple_non_addressable (*to_p))\n \t      /* Don't use the original target if it's already addressable;\n \t\t if its address escapes, and the called function uses the\n@@ -3286,14 +3313,6 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \t\t When optimizing, the return_slot pass marks more functions\n \t\t as safe after we have escape info.  */\n \t      use_target = false;\n-\t    else if (TREE_CODE (*to_p) != PARM_DECL \n-\t\t     && DECL_GIMPLE_FORMAL_TEMP_P (*to_p))\n-\t      /* Don't use the original target if it's a formal temp; we\n-\t\t don't want to take their addresses.  */\n-\t      use_target = false;\n-\t    else if (is_gimple_reg_type (TREE_TYPE (*to_p)))\n-\t      /* Also don't force regs into memory.  */\n-\t      use_target = false;\n \t    else\n \t      use_target = true;\n \n@@ -3379,10 +3398,6 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n   gcc_assert (TREE_CODE (*expr_p) == MODIFY_EXPR\n \t      || TREE_CODE (*expr_p) == INIT_EXPR);\n \n-  /* The distinction between MODIFY_EXPR and INIT_EXPR is no longer useful.  */\n-  if (TREE_CODE (*expr_p) == INIT_EXPR)\n-    TREE_SET_CODE (*expr_p, MODIFY_EXPR);\n-  \n   /* For zero sized types only gimplify the left hand side and right hand side\n      as statements and throw away the assignment.  */\n   if (zero_sized_type (TREE_TYPE (*from_p)))\n@@ -4072,7 +4087,7 @@ gimplify_target_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \t    gimplify_bind_expr (&init, temp, pre_p);\n \t  if (init != temp)\n \t    {\n-\t      init = build2 (MODIFY_EXPR, void_type_node, temp, init);\n+\t      init = build2 (INIT_EXPR, void_type_node, temp, init);\n \t      ret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt,\n \t\t\t\t   fb_none);\n \t    }\n@@ -5216,8 +5231,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase COND_EXPR:\n-\t  ret = gimplify_cond_expr (expr_p, pre_p, post_p, NULL_TREE,\n-\t\t\t\t    fallback);\n+\t  ret = gimplify_cond_expr (expr_p, pre_p, fallback);\n \t  /* C99 code may assign to an array in a structure value of a\n \t     conditional expression, and this has undefined behavior\n \t     only on execution, so create a temporary if an lvalue is\n@@ -5253,6 +5267,11 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \tcase INIT_EXPR:\n \t  ret = gimplify_modify_expr (expr_p, pre_p, post_p,\n \t\t\t\t      fallback != fb_none);\n+\n+\t  /* The distinction between MODIFY_EXPR and INIT_EXPR is no longer\n+\t     useful.  */\n+\t  if (*expr_p && TREE_CODE (*expr_p) == INIT_EXPR)\n+\t    TREE_SET_CODE (*expr_p, MODIFY_EXPR);\n \t  break;\n \n \tcase TRUTH_ANDIF_EXPR:\n@@ -5889,7 +5908,7 @@ gimplify_one_sizepos (tree *expr_p, tree *stmt_p)\n \n       *expr_p = create_tmp_var (type, NULL);\n       tmp = build1 (NOP_EXPR, type, expr);\n-      tmp = build2 (MODIFY_EXPR, type, *expr_p, expr);\n+      tmp = build2 (MODIFY_EXPR, type, *expr_p, tmp);\n       if (EXPR_HAS_LOCATION (expr))\n \tSET_EXPR_LOCUS (tmp, EXPR_LOCUS (expr));\n       else"}, {"sha": "b822dc464fe19ebdbbd5148b4fe6ce421919b694", "filename": "gcc/testsuite/g++.dg/opt/temp1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemp1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemp1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Ftemp1.C?ref=dae7ec874f5e46fccf259c87fd756a0e10375e63", "patch": "@@ -1,6 +1,6 @@\n // PR c++/16405\n // { dg-options \"-O2\" } \n-// { dg-do run { xfail *-*-* } }\n+// { dg-do run }\n \n // There should be exactly one temporary generated for the code in \"f\"\n // below when optimizing -- for the result of \"b + c\".  We have no"}, {"sha": "f9ce09bbe356b5a83c0678e3bf4b0cc66134ccf6", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=dae7ec874f5e46fccf259c87fd756a0e10375e63", "patch": "@@ -1222,6 +1222,9 @@ declare_return_variable (copy_body_data *id, tree return_slot_addr,\n \t    use_it = false;\n \t  else if (is_global_var (base_m))\n \t    use_it = false;\n+\t  else if (TREE_CODE (TREE_TYPE (base_m)) == COMPLEX_TYPE\n+\t\t   && !DECL_COMPLEX_GIMPLE_REG_P (result))\n+\t    DECL_COMPLEX_GIMPLE_REG_P (base_m) = 0;\n \t  else if (!TREE_ADDRESSABLE (base_m))\n \t    use_it = true;\n \t}"}, {"sha": "14c15a76d5c4935876964f548824209dcf3a32db", "filename": "gcc/tree.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae7ec874f5e46fccf259c87fd756a0e10375e63/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=dae7ec874f5e46fccf259c87fd756a0e10375e63", "patch": "@@ -465,7 +465,8 @@ DEFTREECODE (COMPOUND_EXPR, \"compound_expr\", tcc_expression, 2)\n DEFTREECODE (MODIFY_EXPR, \"modify_expr\", tcc_expression, 2)\n \n /* Initialization expression.  Operand 0 is the variable to initialize;\n-   Operand 1 is the initializer.  */\n+   Operand 1 is the initializer.  This differs from MODIFY_EXPR in that any\n+   reference to the referent of operand 0 within operand 1 is undefined.  */\n DEFTREECODE (INIT_EXPR, \"init_expr\", tcc_expression, 2)\n \n /* For TARGET_EXPR, operand 0 is the target of an initialization,"}]}