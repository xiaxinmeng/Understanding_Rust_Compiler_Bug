{"sha": "83310f568883d4daceeb365fe86d44cdb24110ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMzMTBmNTY4ODgzZDRkYWNlZWIzNjVmZTg2ZDQ0Y2RiMjQxMTBjZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-21T18:01:29Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-21T18:01:29Z"}, "message": "v850-protos.h: Remove the prototypes for reg_or_int9_operand...\n\n\t* config/v850/v850-protos.h: Remove the prototypes for\n\treg_or_int9_operand, reg_or_const_operand,\n\tpattern_is_ok_for_prepare, pattern_is_ok_for_dispose,\n\treg_or_0_operand, reg_or_int5_operand, call_address_operand,\n\tmovsi_source_operand, power_of_two_operand,\n\tnot_power_of_two_operand, special_symbolref_operand,\n\tpattern_is_ok_for_prologue, pattern_is_ok_for_epilogue, and\n\tregister_is_ok_for_epilogue.\n\t* config/v850/v850.c (reg_or_0_operand, reg_or_int5_operand,\n\treg_or_int9_operand, reg_or_const_operand,\n\tcall_address_operand, special_symbolref_operand,\n\tmovsi_source_operand, power_of_two_operand,\n\tnot_power_of_two_operand, register_is_ok_for_epilogue,\n\tpattern_is_ok_for_epilogue, pattern_is_ok_for_prologue,\n\tpattern_is_ok_for_dispose, pattern_is_ok_for_prepare): Move to\n\tpredicates.md.\n\t* config/v850/v850.h (PREDICATE_CODES): Remove.\n\t* config/v850/v850.md: Include predicates.md.\n\t* config/v850/predicates.md: New.\n\nFrom-SVN: r96822", "tree": {"sha": "4b7eb16eb0e044e4279433c45d2895a812452741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b7eb16eb0e044e4279433c45d2895a812452741"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83310f568883d4daceeb365fe86d44cdb24110ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83310f568883d4daceeb365fe86d44cdb24110ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83310f568883d4daceeb365fe86d44cdb24110ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83310f568883d4daceeb365fe86d44cdb24110ce/comments", "author": null, "committer": null, "parents": [{"sha": "f08dd1f8f36924447dc8e3add062acbdf457b417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f08dd1f8f36924447dc8e3add062acbdf457b417", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f08dd1f8f36924447dc8e3add062acbdf457b417"}], "stats": {"total": 918, "additions": 467, "deletions": 451}, "files": [{"sha": "a6642c7a1f9f78b7f3f5cc798b4b09219cd3fa9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83310f568883d4daceeb365fe86d44cdb24110ce", "patch": "@@ -1,3 +1,25 @@\n+2005-03-21  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/v850/v850-protos.h: Remove the prototypes for\n+\treg_or_int9_operand, reg_or_const_operand,\n+\tpattern_is_ok_for_prepare, pattern_is_ok_for_dispose,\n+\treg_or_0_operand, reg_or_int5_operand, call_address_operand,\n+\tmovsi_source_operand, power_of_two_operand,\n+\tnot_power_of_two_operand, special_symbolref_operand,\n+\tpattern_is_ok_for_prologue, pattern_is_ok_for_epilogue, and\n+\tregister_is_ok_for_epilogue.\n+\t* config/v850/v850.c (reg_or_0_operand, reg_or_int5_operand,\n+\treg_or_int9_operand, reg_or_const_operand,\n+\tcall_address_operand, special_symbolref_operand,\n+\tmovsi_source_operand, power_of_two_operand,\n+\tnot_power_of_two_operand, register_is_ok_for_epilogue,\n+\tpattern_is_ok_for_epilogue, pattern_is_ok_for_prologue,\n+\tpattern_is_ok_for_dispose, pattern_is_ok_for_prepare): Move to\n+\tpredicates.md.\n+\t* config/v850/v850.h (PREDICATE_CODES): Remove.\n+\t* config/v850/v850.md: Include predicates.md.\n+\t* config/v850/predicates.md: New.\n+\n 2005-03-21  Zack Weinberg  <zack@codesourcery.com>\n \n \t* Makefile.in (BASEVER, DEVPHASE, DATESTAMP)"}, {"sha": "a878fdc01fd6670df56fd80ae0d33105e326ab23", "filename": "gcc/config/v850/predicates.md", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2Fconfig%2Fv850%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2Fconfig%2Fv850%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fpredicates.md?ref=83310f568883d4daceeb365fe86d44cdb24110ce", "patch": "@@ -0,0 +1,439 @@\n+;; Predicate definitions for NEC V850.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Return true if OP is either a register or 0.\n+\n+(define_predicate \"reg_or_0_operand\"\n+  (match_code \"reg,subreg,const_int,const_double\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return INTVAL (op) == 0;\n+\n+  else if (GET_CODE (op) == CONST_DOUBLE)\n+    return CONST_DOUBLE_OK_FOR_G (op);\n+\n+  else\n+    return register_operand (op, mode);\n+})\n+\n+;; Return true if OP is either a register or a signed five bit\n+;; integer.\n+\n+(define_predicate \"reg_or_int5_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return CONST_OK_FOR_J (INTVAL (op));\n+\n+  else\n+    return register_operand (op, mode);\n+})\n+\n+;; Return true if OP is either a register or a signed nine bit\n+;; integer.\n+\n+(define_predicate \"reg_or_int9_operand\"\n+  (match_code \"reg,subreg,const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return CONST_OK_FOR_O (INTVAL (op));\n+\n+  return register_operand (op, mode);\n+})\n+\n+;; Return true if OP is either a register or a const integer.\n+\n+(define_predicate \"reg_or_const_operand\"\n+  (match_code \"reg,const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return TRUE;\n+\n+  return register_operand (op, mode);\n+})\n+\n+;; Return true if OP is a valid call operand.\n+\n+(define_predicate \"call_address_operand\"\n+  (match_code \"reg,symbol_ref\")\n+{\n+  /* Only registers are valid call operands if TARGET_LONG_CALLS.  */\n+  if (TARGET_LONG_CALLS)\n+    return GET_CODE (op) == REG;\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"movsi_source_operand\"\n+  (match_code \"label_ref,symbol_ref,const_int,const_double,const,high,mem,reg,subreg\")\n+{\n+  /* Some constants, as well as symbolic operands\n+     must be done with HIGH & LO_SUM patterns.  */\n+  if (CONSTANT_P (op)\n+      && GET_CODE (op) != HIGH\n+      && !(GET_CODE (op) == CONST_INT\n+           && (CONST_OK_FOR_J (INTVAL (op))\n+               || CONST_OK_FOR_K (INTVAL (op))\n+               || CONST_OK_FOR_L (INTVAL (op)))))\n+    return special_symbolref_operand (op, mode);\n+  else\n+    return general_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"special_symbolref_operand\"\n+  (match_code \"symbol_ref\")\n+{\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+      && CONST_OK_FOR_K (INTVAL (XEXP (XEXP (op, 0), 1))))\n+    op = XEXP (XEXP (op, 0), 0);\n+\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return (SYMBOL_REF_FLAGS (op)\n+\t    & (SYMBOL_FLAG_ZDA | SYMBOL_FLAG_TDA | SYMBOL_FLAG_SDA)) != 0;\n+\n+  return FALSE;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"power_of_two_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  if (exact_log2 (INTVAL (op)) == -1)\n+    return 0;\n+  return 1;\n+})\n+\n+;; Return nonzero if the given RTX is suitable for collapsing into a\n+;; jump to a function prologue.\n+\n+(define_predicate \"pattern_is_ok_for_prologue\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+  rtx vector_element;\n+\n+  /* If there are no registers to save then the function prologue\n+     is not suitable.  */\n+  if (count <= 2)\n+    return 0;\n+\n+  /* The pattern matching has already established that we are adjusting the\n+     stack and pushing at least one register.  We must now check that the\n+     remaining entries in the vector to make sure that they are also register\n+     pushes, except for the last entry which should be a CLOBBER of r10.\n+\n+     The test below performs the C equivalent of this machine description\n+     pattern match:\n+\n+     (set (mem:SI (plus:SI (reg:SI 3)\n+      (match_operand:SI 2 \"immediate_operand\" \"i\")))\n+      (match_operand:SI 3 \"register_is_ok_for_epilogue\" \"r\"))\n+\n+     */\n+\n+  for (i = 2; i < count - (TARGET_LONG_CALLS ? 2: 1); i++)\n+    {\n+      rtx dest;\n+      rtx src;\n+      rtx plus;\n+\n+      vector_element = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (vector_element) != SET)\n+\treturn 0;\n+\n+      dest = SET_DEST (vector_element);\n+      src = SET_SRC (vector_element);\n+\n+      if (GET_CODE (dest) != MEM\n+\t  || GET_MODE (dest) != SImode\n+\t  || GET_CODE (src) != REG\n+\t  || GET_MODE (src) != SImode\n+\t  || ! register_is_ok_for_epilogue (src, SImode))\n+\treturn 0;\n+\n+      plus = XEXP (dest, 0);\n+\n+      if ( GET_CODE (plus) != PLUS\n+\t  || GET_CODE (XEXP (plus, 0)) != REG\n+\t  || GET_MODE (XEXP (plus, 0)) != SImode\n+\t  || REGNO (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n+\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n+\treturn 0;\n+\n+      /* If the register is being pushed somewhere other than the stack\n+\t space just acquired by the first operand then abandon this quest.\n+\t Note: the test is <= because both values are negative.\t */\n+      if (INTVAL (XEXP (plus, 1))\n+\t  <= INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)))\n+\t{\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* Make sure that the last entries in the vector are clobbers.  */\n+  for (; i < count; i++)\n+    {\n+      vector_element = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (vector_element) != CLOBBER\n+\t  || GET_CODE (XEXP (vector_element, 0)) != REG\n+\t  || !(REGNO (XEXP (vector_element, 0)) == 10\n+\t       || (TARGET_LONG_CALLS ? (REGNO (XEXP (vector_element, 0)) == 11) : 0 )))\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n+;; Return nonzero if the given RTX is suitable for collapsing into\n+;; jump to a function epilogue.\n+\n+(define_predicate \"pattern_is_ok_for_epilogue\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+\n+  /* If there are no registers to restore then the function epilogue\n+     is not suitable.  */\n+  if (count <= 2)\n+    return 0;\n+\n+  /* The pattern matching has already established that we are performing a\n+     function epilogue and that we are popping at least one register.  We must\n+     now check the remaining entries in the vector to make sure that they are\n+     also register pops.  There is no good reason why there should ever be\n+     anything else in this vector, but being paranoid always helps...\n+\n+     The test below performs the C equivalent of this machine description\n+     pattern match:\n+\n+        (set (match_operand:SI n \"register_is_ok_for_epilogue\" \"r\")\n+\t  (mem:SI (plus:SI (reg:SI 3) (match_operand:SI n \"immediate_operand\" \"i\"))))\n+     */\n+\n+  for (i = 3; i < count; i++)\n+    {\n+      rtx vector_element = XVECEXP (op, 0, i);\n+      rtx dest;\n+      rtx src;\n+      rtx plus;\n+\n+      if (GET_CODE (vector_element) != SET)\n+\treturn 0;\n+\n+      dest = SET_DEST (vector_element);\n+      src = SET_SRC (vector_element);\n+\n+      if (GET_CODE (dest) != REG\n+\t  || GET_MODE (dest) != SImode\n+\t  || ! register_is_ok_for_epilogue (dest, SImode)\n+\t  || GET_CODE (src) != MEM\n+\t  || GET_MODE (src) != SImode)\n+\treturn 0;\n+\n+      plus = XEXP (src, 0);\n+\n+      if (GET_CODE (plus) != PLUS\n+\t  || GET_CODE (XEXP (plus, 0)) != REG\n+\t  || GET_MODE (XEXP (plus, 0)) != SImode\n+\t  || REGNO (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n+\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n+;; Return true if the given RTX is a register which can be restored by\n+;; a function epilogue.\n+\n+(define_predicate \"register_is_ok_for_epilogue\"\n+  (match_code \"reg\")\n+{\n+  /* The save/restore routines can only cope with registers 20 - 31.  */\n+  return ((GET_CODE (op) == REG)\n+          && (((REGNO (op) >= 20) && REGNO (op) <= 31)));\n+})\n+\n+;; Return nonzero if the given RTX is suitable for collapsing into a\n+;; DISPOSE instruction.\n+\n+(define_predicate \"pattern_is_ok_for_dispose\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+\n+  /* If there are no registers to restore then\n+     the dispose instruction is not suitable.  */\n+  if (count <= 2)\n+    return 0;\n+\n+  /* The pattern matching has already established that we are performing a\n+     function epilogue and that we are popping at least one register.  We must\n+     now check the remaining entries in the vector to make sure that they are\n+     also register pops.  There is no good reason why there should ever be\n+     anything else in this vector, but being paranoid always helps...\n+\n+     The test below performs the C equivalent of this machine description\n+     pattern match:\n+\n+        (set (match_operand:SI n \"register_is_ok_for_epilogue\" \"r\")\n+\t  (mem:SI (plus:SI (reg:SI 3)\n+\t    (match_operand:SI n \"immediate_operand\" \"i\"))))\n+     */\n+\n+  for (i = 3; i < count; i++)\n+    {\n+      rtx vector_element = XVECEXP (op, 0, i);\n+      rtx dest;\n+      rtx src;\n+      rtx plus;\n+\n+      if (GET_CODE (vector_element) != SET)\n+\treturn 0;\n+\n+      dest = SET_DEST (vector_element);\n+      src  = SET_SRC (vector_element);\n+\n+      if (   GET_CODE (dest) != REG\n+\t  || GET_MODE (dest) != SImode\n+\t  || ! register_is_ok_for_epilogue (dest, SImode)\n+\t  || GET_CODE (src) != MEM\n+\t  || GET_MODE (src) != SImode)\n+\treturn 0;\n+\n+      plus = XEXP (src, 0);\n+\n+      if (   GET_CODE (plus) != PLUS\n+\t  || GET_CODE (XEXP (plus, 0)) != REG\n+\t  || GET_MODE (XEXP (plus, 0)) != SImode\n+\t  || REGNO    (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n+\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n+;; Return nonzero if the given RTX is suitable for collapsing into a\n+;; PREPARE instruction.\n+\n+(define_predicate \"pattern_is_ok_for_prepare\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+\n+  /* If there are no registers to restore then the prepare instruction\n+     is not suitable.  */\n+  if (count <= 1)\n+    return 0;\n+\n+  /* The pattern matching has already established that we are adjusting the\n+     stack and pushing at least one register.  We must now check that the\n+     remaining entries in the vector to make sure that they are also register\n+     pushes.\n+\n+     The test below performs the C equivalent of this machine description\n+     pattern match:\n+\n+     (set (mem:SI (plus:SI (reg:SI 3)\n+       (match_operand:SI 2 \"immediate_operand\" \"i\")))\n+         (match_operand:SI 3 \"register_is_ok_for_epilogue\" \"r\"))\n+\n+     */\n+\n+  for (i = 2; i < count; i++)\n+    {\n+      rtx vector_element = XVECEXP (op, 0, i);\n+      rtx dest;\n+      rtx src;\n+      rtx plus;\n+\n+      if (GET_CODE (vector_element) != SET)\n+\treturn 0;\n+\n+      dest = SET_DEST (vector_element);\n+      src  = SET_SRC (vector_element);\n+\n+      if (   GET_CODE (dest) != MEM\n+\t  || GET_MODE (dest) != SImode\n+\t  || GET_CODE (src) != REG\n+\t  || GET_MODE (src) != SImode\n+\t  || ! register_is_ok_for_epilogue (src, SImode)\n+\t     )\n+\treturn 0;\n+\n+      plus = XEXP (dest, 0);\n+\n+      if (   GET_CODE (plus) != PLUS\n+\t  || GET_CODE (XEXP (plus, 0)) != REG\n+\t  || GET_MODE (XEXP (plus, 0)) != SImode\n+\t  || REGNO    (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n+\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n+\treturn 0;\n+\n+      /* If the register is being pushed somewhere other than the stack\n+\t space just acquired by the first operand then abandon this quest.\n+\t Note: the test is <= because both values are negative.\t */\n+      if (INTVAL (XEXP (plus, 1))\n+\t  <= INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)))\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"not_power_of_two_operand\"\n+  (match_code \"const_int\")\n+{\n+  unsigned int mask;\n+\n+  if (mode == QImode)\n+    mask = 0xff;\n+  else if (mode == HImode)\n+    mask = 0xffff;\n+  else if (mode == SImode)\n+    mask = 0xffffffff;\n+  else\n+    return 0;\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  if (exact_log2 (~INTVAL (op) & mask) == -1)\n+    return 0;\n+  return 1;\n+})"}, {"sha": "5512c7e42a7f76920e3814cadb6b491d0fd9883c", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=83310f568883d4daceeb365fe86d44cdb24110ce", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes for v850.c functions used in the md file & elsewhere.\n-   Copyright (C) 1999, 2000, 2002, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2002, 2004, 2005 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -51,23 +51,9 @@ extern void   notice_update_cc              (rtx, rtx);\n extern char * construct_save_jarl           (rtx);\n extern char * construct_restore_jr          (rtx);\n #ifdef HAVE_MACHINE_MODES\n-extern int    reg_or_int9_operand           (rtx, Mmode);\n-extern int    reg_or_const_operand          (rtx, Mmode);\n extern char * construct_dispose_instruction (rtx);\n extern char * construct_prepare_instruction (rtx);\n-extern int    pattern_is_ok_for_prepare     (rtx, Mmode);\n-extern int    pattern_is_ok_for_dispose     (rtx, Mmode);\n extern int    ep_memory_operand             (rtx, Mmode, int);\n-extern int    reg_or_0_operand              (rtx, Mmode);\n-extern int    reg_or_int5_operand           (rtx, Mmode);\n-extern int    call_address_operand          (rtx, Mmode);\n-extern int    movsi_source_operand          (rtx, Mmode);\n-extern int    power_of_two_operand          (rtx, Mmode);\n-extern int    not_power_of_two_operand      (rtx, Mmode);\n-extern int    special_symbolref_operand     (rtx, Mmode);\n-extern int    pattern_is_ok_for_prologue    (rtx, Mmode);\n-extern int    pattern_is_ok_for_epilogue    (rtx, Mmode);\n-extern int    register_is_ok_for_epilogue   (rtx, Mmode);\n #ifdef TREE_CODE\n extern rtx    function_arg                  (CUMULATIVE_ARGS *, Mmode, tree, int);\n #endif"}, {"sha": "9026fa850a234f65431f09b4809328d935d19723", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 1, "deletions": 409, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=83310f568883d4daceeb365fe86d44cdb24110ce", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for NEC V850 series\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n@@ -1078,132 +1078,6 @@ ep_memory_operand (rtx op, enum machine_mode mode, int unsigned_load)\n \n   return FALSE;\n }\n-\n-/* Return true if OP is either a register or 0 */\n-\n-int\n-reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return INTVAL (op) == 0;\n-\n-  else if (GET_CODE (op) == CONST_DOUBLE)\n-    return CONST_DOUBLE_OK_FOR_G (op);\n-\n-  else\n-    return register_operand (op, mode);\n-}\n-\n-/* Return true if OP is either a register or a signed five bit integer */\n-\n-int\n-reg_or_int5_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return CONST_OK_FOR_J (INTVAL (op));\n-\n-  else\n-    return register_operand (op, mode);\n-}\n-\n-/* Return true if OP is either a register or a signed nine bit integer.  */\n-\n-int\n-reg_or_int9_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return CONST_OK_FOR_O (INTVAL (op));\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return true if OP is either a register or a const integer.  */\n-\n-int\n-reg_or_const_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return TRUE;\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return true if OP is a valid call operand.  */\n-\n-int\n-call_address_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  /* Only registers are valid call operands if TARGET_LONG_CALLS.  */\n-  if (TARGET_LONG_CALLS)\n-    return GET_CODE (op) == REG;\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n-}\n-\n-int\n-special_symbolref_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == CONST\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-      && CONST_OK_FOR_K (INTVAL (XEXP (XEXP (op, 0), 1))))\n-    op = XEXP (XEXP (op, 0), 0);\n-\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    return (SYMBOL_REF_FLAGS (op)\n-\t    & (SYMBOL_FLAG_ZDA | SYMBOL_FLAG_TDA | SYMBOL_FLAG_SDA)) != 0;\n-\n-  return FALSE;\n-}\n-\n-int\n-movsi_source_operand (rtx op, enum machine_mode mode)\n-{\n-  /* Some constants, as well as symbolic operands\n-     must be done with HIGH & LO_SUM patterns.  */\n-  if (CONSTANT_P (op)\n-      && GET_CODE (op) != HIGH\n-      && !(GET_CODE (op) == CONST_INT\n-           && (CONST_OK_FOR_J (INTVAL (op))\n-               || CONST_OK_FOR_K (INTVAL (op))\n-               || CONST_OK_FOR_L (INTVAL (op)))))\n-    return special_symbolref_operand (op, mode);\n-  else\n-    return general_operand (op, mode);\n-}\n-\n-int\n-power_of_two_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  if (exact_log2 (INTVAL (op)) == -1)\n-    return 0;\n-  return 1;\n-}\n-\n-int\n-not_power_of_two_operand (rtx op, enum machine_mode mode)\n-{\n-  unsigned int mask;\n-\n-  if (mode == QImode)\n-    mask = 0xff;\n-  else if (mode == HImode)\n-    mask = 0xffff;\n-  else if (mode == SImode)\n-    mask = 0xffffffff;\n-  else\n-    return 0;\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  if (exact_log2 (~INTVAL (op) & mask) == -1)\n-    return 0;\n-  return 1;\n-}\n-\n \f\n /* Substitute memory references involving a pointer, to use the ep pointer,\n    taking care to save and preserve the ep.  */\n@@ -2366,75 +2240,6 @@ v850_encode_section_info (tree decl, rtx rtl, int first)\n     v850_encode_data_area (decl, XEXP (rtl, 0));\n }\n \n-/* Return true if the given RTX is a register which can be restored\n-   by a function epilogue.  */\n-int\n-register_is_ok_for_epilogue (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  /* The save/restore routines can only cope with registers 20 - 31.  */\n-  return ((GET_CODE (op) == REG)\n-          && (((REGNO (op) >= 20) && REGNO (op) <= 31)));\n-}\n-\n-/* Return nonzero if the given RTX is suitable for collapsing into\n-   jump to a function epilogue.  */\n-int\n-pattern_is_ok_for_epilogue (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  int i;\n-  \n-  /* If there are no registers to restore then the function epilogue\n-     is not suitable.  */\n-  if (count <= 2)\n-    return 0;\n-\n-  /* The pattern matching has already established that we are performing a\n-     function epilogue and that we are popping at least one register.  We must\n-     now check the remaining entries in the vector to make sure that they are\n-     also register pops.  There is no good reason why there should ever be\n-     anything else in this vector, but being paranoid always helps...\n-\n-     The test below performs the C equivalent of this machine description\n-     pattern match:\n-\n-        (set (match_operand:SI n \"register_is_ok_for_epilogue\" \"r\")\n-\t  (mem:SI (plus:SI (reg:SI 3) (match_operand:SI n \"immediate_operand\" \"i\"))))\n-     */\n-\n-  for (i = 3; i < count; i++)\n-    {\n-      rtx vector_element = XVECEXP (op, 0, i);\n-      rtx dest;\n-      rtx src;\n-      rtx plus;\n-      \n-      if (GET_CODE (vector_element) != SET)\n-\treturn 0;\n-      \n-      dest = SET_DEST (vector_element);\n-      src = SET_SRC (vector_element);\n-\n-      if (GET_CODE (dest) != REG\n-\t  || GET_MODE (dest) != SImode\n-\t  || ! register_is_ok_for_epilogue (dest, SImode)\n-\t  || GET_CODE (src) != MEM\n-\t  || GET_MODE (src) != SImode)\n-\treturn 0;\n-\n-      plus = XEXP (src, 0);\n-\n-      if (GET_CODE (plus) != PLUS\n-\t  || GET_CODE (XEXP (plus, 0)) != REG\n-\t  || GET_MODE (XEXP (plus, 0)) != SImode\n-\t  || REGNO (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n-\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n /* Construct a JR instruction to a routine that will perform the equivalent of\n    the RTL passed in as an argument.  This RTL is a function epilogue that\n    pops registers off the stack and possibly releases some extra stack space\n@@ -2552,89 +2357,6 @@ construct_restore_jr (rtx op)\n }\n \n \n-/* Return nonzero if the given RTX is suitable for collapsing into\n-   a jump to a function prologue.  */\n-int\n-pattern_is_ok_for_prologue (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  int i; \n-  rtx vector_element;\n- \n-  /* If there are no registers to save then the function prologue\n-     is not suitable.  */\n-  if (count <= 2)\n-    return 0;\n-\n-  /* The pattern matching has already established that we are adjusting the\n-     stack and pushing at least one register.  We must now check that the\n-     remaining entries in the vector to make sure that they are also register\n-     pushes, except for the last entry which should be a CLOBBER of r10.\n-\n-     The test below performs the C equivalent of this machine description\n-     pattern match:\n-\n-     (set (mem:SI (plus:SI (reg:SI 3)\n-      (match_operand:SI 2 \"immediate_operand\" \"i\")))\n-      (match_operand:SI 3 \"register_is_ok_for_epilogue\" \"r\"))\n-\n-     */\n-\n-  for (i = 2; i < count - (TARGET_LONG_CALLS ? 2: 1); i++)\n-    {\n-      rtx dest;\n-      rtx src;\n-      rtx plus;\n-      \n-      vector_element = XVECEXP (op, 0, i);\n-      \n-      if (GET_CODE (vector_element) != SET)\n-\treturn 0;\n-      \n-      dest = SET_DEST (vector_element);\n-      src = SET_SRC (vector_element);\n-\n-      if (GET_CODE (dest) != MEM\n-\t  || GET_MODE (dest) != SImode\n-\t  || GET_CODE (src) != REG\n-\t  || GET_MODE (src) != SImode\n-\t  || ! register_is_ok_for_epilogue (src, SImode))\n-\treturn 0;\n-\n-      plus = XEXP (dest, 0);\n-\n-      if ( GET_CODE (plus) != PLUS\n-\t  || GET_CODE (XEXP (plus, 0)) != REG\n-\t  || GET_MODE (XEXP (plus, 0)) != SImode\n-\t  || REGNO (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n-\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n-\treturn 0;\n-\n-      /* If the register is being pushed somewhere other than the stack\n-\t space just acquired by the first operand then abandon this quest.\n-\t Note: the test is <= because both values are negative.\t */\n-      if (INTVAL (XEXP (plus, 1))\n-\t  <= INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)))\n-\t{\n-\t  return 0;\n-\t}\n-    }\n-\n-  /* Make sure that the last entries in the vector are clobbers.  */\n-  for (; i < count; i++)\n-    {\n-      vector_element = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (vector_element) != CLOBBER\n-\t  || GET_CODE (XEXP (vector_element, 0)) != REG\n-\t  || !(REGNO (XEXP (vector_element, 0)) == 10\n-\t       || (TARGET_LONG_CALLS ? (REGNO (XEXP (vector_element, 0)) == 11) : 0 )))\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n /* Construct a JARL instruction to a routine that will perform the equivalent\n    of the RTL passed as a parameter.  This RTL is a function prologue that\n    saves some of the registers r20 - r31 onto the stack, and possibly acquires\n@@ -2946,67 +2668,6 @@ v850_insert_attributes (tree decl, tree * attr_ptr ATTRIBUTE_UNUSED )\n     }\n }\n \n-/* Return nonzero if the given RTX is suitable\n-   for collapsing into a DISPOSE instruction.  */\n-\n-int\n-pattern_is_ok_for_dispose (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  int i;\n-  \n-  /* If there are no registers to restore then\n-     the dispose instruction is not suitable.  */\n-  if (count <= 2)\n-    return 0;\n-\n-  /* The pattern matching has already established that we are performing a\n-     function epilogue and that we are popping at least one register.  We must\n-     now check the remaining entries in the vector to make sure that they are\n-     also register pops.  There is no good reason why there should ever be\n-     anything else in this vector, but being paranoid always helps...\n-\n-     The test below performs the C equivalent of this machine description\n-     pattern match:\n-\n-        (set (match_operand:SI n \"register_is_ok_for_epilogue\" \"r\")\n-\t  (mem:SI (plus:SI (reg:SI 3)\n-\t    (match_operand:SI n \"immediate_operand\" \"i\"))))\n-     */\n-\n-  for (i = 3; i < count; i++)\n-    {\n-      rtx vector_element = XVECEXP (op, 0, i);\n-      rtx dest;\n-      rtx src;\n-      rtx plus;\n-      \n-      if (GET_CODE (vector_element) != SET)\n-\treturn 0;\n-      \n-      dest = SET_DEST (vector_element);\n-      src  = SET_SRC (vector_element);\n-\n-      if (   GET_CODE (dest) != REG\n-\t  || GET_MODE (dest) != SImode\n-\t  || ! register_is_ok_for_epilogue (dest, SImode)\n-\t  || GET_CODE (src) != MEM\n-\t  || GET_MODE (src) != SImode)\n-\treturn 0;\n-\n-      plus = XEXP (src, 0);\n-\n-      if (   GET_CODE (plus) != PLUS\n-\t  || GET_CODE (XEXP (plus, 0)) != REG\n-\t  || GET_MODE (XEXP (plus, 0)) != SImode\n-\t  || REGNO    (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n-\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n /* Construct a DISPOSE instruction that is the equivalent of\n    the given RTX.  We have already verified that this should\n    be possible.  */\n@@ -3133,75 +2794,6 @@ construct_dispose_instruction (rtx op)\n   return buff;\n }\n \n-/* Return nonzero if the given RTX is suitable\n-   for collapsing into a PREPARE instruction.  */\n-\n-int\n-pattern_is_ok_for_prepare (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int count = XVECLEN (op, 0);\n-  int i;\n-  \n-  /* If there are no registers to restore then the prepare instruction\n-     is not suitable.  */\n-  if (count <= 1)\n-    return 0;\n-\n-  /* The pattern matching has already established that we are adjusting the\n-     stack and pushing at least one register.  We must now check that the\n-     remaining entries in the vector to make sure that they are also register\n-     pushes.\n-\n-     The test below performs the C equivalent of this machine description\n-     pattern match:\n-\n-     (set (mem:SI (plus:SI (reg:SI 3)\n-       (match_operand:SI 2 \"immediate_operand\" \"i\")))\n-         (match_operand:SI 3 \"register_is_ok_for_epilogue\" \"r\"))\n-\n-     */\n-\n-  for (i = 2; i < count; i++)\n-    {\n-      rtx vector_element = XVECEXP (op, 0, i);\n-      rtx dest;\n-      rtx src;\n-      rtx plus;\n-      \n-      if (GET_CODE (vector_element) != SET)\n-\treturn 0;\n-      \n-      dest = SET_DEST (vector_element);\n-      src  = SET_SRC (vector_element);\n-\n-      if (   GET_CODE (dest) != MEM\n-\t  || GET_MODE (dest) != SImode\n-\t  || GET_CODE (src) != REG\n-\t  || GET_MODE (src) != SImode\n-\t  || ! register_is_ok_for_epilogue (src, SImode)\n-\t     )\n-\treturn 0;\n-\n-      plus = XEXP (dest, 0);\n-\n-      if (   GET_CODE (plus) != PLUS\n-\t  || GET_CODE (XEXP (plus, 0)) != REG\n-\t  || GET_MODE (XEXP (plus, 0)) != SImode\n-\t  || REGNO    (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n-\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n-\treturn 0;\n-\n-      /* If the register is being pushed somewhere other than the stack\n-\t space just acquired by the first operand then abandon this quest.\n-\t Note: the test is <= because both values are negative.\t */\n-      if (INTVAL (XEXP (plus, 1))\n-\t  <= INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)))\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n /* Construct a PREPARE instruction that is the equivalent of\n    the given RTL.  We have already verified that this should\n    be possible.  */"}, {"sha": "1d2b91c10f93e800de6a0b22d378b42eb3ea29c1", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=83310f568883d4daceeb365fe86d44cdb24110ce", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler. NEC V850 series\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n@@ -1368,29 +1368,4 @@ extern union tree_node * GHS_current_section_names [(int) COUNT_OF_GHS_SECTION_K\n #define SYMBOL_REF_TDA_P(X)\t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_TDA) != 0)\n #define SYMBOL_REF_SDA_P(X)\t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_SDA) != 0)\n \n-/* Define this if you have defined special-purpose predicates in the\n-   file `MACHINE.c'.  This macro is called within an initializer of an\n-   array of structures.  The first field in the structure is the name\n-   of a predicate and the second field is an array of rtl codes.  For\n-   each predicate, list all rtl codes that can be in expressions\n-   matched by the predicate.  The list should have a trailing comma.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-{ \"reg_or_0_operand\",\t\t{ REG, SUBREG, CONST_INT, CONST_DOUBLE }}, \\\n-{ \"reg_or_int5_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n-{ \"reg_or_int9_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n-{ \"reg_or_const_operand\",       { REG, CONST_INT }},\t\t\t\\\n-{ \"call_address_operand\",\t{ REG, SYMBOL_REF }},\t\t\t\\\n-{ \"movsi_source_operand\",\t{ LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n-\t\t\t\t  CONST_DOUBLE, CONST, HIGH, MEM,\t\\\n-\t\t\t\t  REG, SUBREG }},\t\t\t\\\n-{ \"special_symbolref_operand\",\t{ SYMBOL_REF }},\t\t\t\\\n-{ \"power_of_two_operand\",\t{ CONST_INT }},\t\t\t\t\\\n-{ \"pattern_is_ok_for_prologue\",\t{ PARALLEL }},\t\t\t\t\\\n-{ \"pattern_is_ok_for_epilogue\",\t{ PARALLEL }},\t\t\t\t\\\n-{ \"register_is_ok_for_epilogue\",{ REG }},\t\t\t\t\\\n-{ \"pattern_is_ok_for_dispose\",\t{ PARALLEL }},\t\t\t\t\\\n-{ \"pattern_is_ok_for_prepare\",\t{ PARALLEL }},\t\t\t\t\\\n-{ \"not_power_of_two_operand\",\t{ CONST_INT }},\n-  \n #endif /* ! GCC_V850_H */"}, {"sha": "b4dd0285c8d46f50aa670bd3a824a5d91f0df5e3", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83310f568883d4daceeb365fe86d44cdb24110ce/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=83310f568883d4daceeb365fe86d44cdb24110ce", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for NEC V850\n-;; Copyright (C) 1996, 1997, 1998, 1999, 2002, 2004\n+;; Copyright (C) 1996, 1997, 1998, 1999, 2002, 2004, 2005\n ;; Free Software Foundation, Inc.\n ;; Contributed by Jeff Law (law@cygnus.com).\n \n@@ -71,6 +71,8 @@\n (define_insn_reservation \"v850_memory\" 2\n \t\t\t (eq_attr \"type\" \"load\")\n \t\t\t \"nothing\")\n+\n+(include \"predicates.md\")\n \f\n ;; ----------------------------------------------------------------------\n ;; MOVE INSTRUCTIONS"}]}