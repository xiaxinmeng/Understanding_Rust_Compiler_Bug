{"sha": "39a7b603380c6f4383357a6ae1d6c516dc677f29", "node_id": "C_kwDOANBUbNoAKDM5YTdiNjAzMzgwYzZmNDM4MzM1N2E2YWUxZDZjNTE2ZGM2NzdmMjk", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2023-01-07T21:05:58Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2023-01-16T14:44:55Z"}, "message": "ada: Use static references to tag in more cases for interface objects\n\nThis extends the use of static references to the interface tag in more cases\nfor (class-wide) interface objects, e.g. for initialization expressions that\nare qualified aggregates or nondispatching calls returning a specific tagged\ntype implementing the interface.\n\ngcc/ada/\n\n\t* exp_util.ads (Has_Tag_Of_Type): Declare.\n\t* exp_util.adb (Has_Tag_Of_Type): Move to package level.  Recurse on\n\tqualified expressions.\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Use a static reference\n\tto the interface tag in more cases for class-wide interface objects.", "tree": {"sha": "a178a36edc550e9e6cdb4eb883920afc6843c1bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a178a36edc550e9e6cdb4eb883920afc6843c1bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39a7b603380c6f4383357a6ae1d6c516dc677f29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39a7b603380c6f4383357a6ae1d6c516dc677f29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39a7b603380c6f4383357a6ae1d6c516dc677f29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39a7b603380c6f4383357a6ae1d6c516dc677f29/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7ed6c43a80e06082baad5336be0fa943a878d40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7ed6c43a80e06082baad5336be0fa943a878d40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7ed6c43a80e06082baad5336be0fa943a878d40"}], "stats": {"total": 188, "additions": 95, "deletions": 93}, "files": [{"sha": "6bc76aec5d10235e05020db489c1f8fef3ac9f5f", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39a7b603380c6f4383357a6ae1d6c516dc677f29/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39a7b603380c6f4383357a6ae1d6c516dc677f29/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=39a7b603380c6f4383357a6ae1d6c516dc677f29", "patch": "@@ -7564,7 +7564,7 @@ package body Exp_Ch3 is\n                Expr_Q := Expr;\n             end if;\n \n-            --  We may use a renaming if the initializing expression is a\n+            --  We may use a renaming if the initialization expression is a\n             --  captured function call that meets a few conditions.\n \n             Rewrite_As_Renaming := Is_Renamable_Function_Call (Expr_Q);\n@@ -7621,41 +7621,6 @@ package body Exp_Ch3 is\n \n                   Obj_Id := Make_Temporary (Loc, 'D', Expr_Q);\n \n-                  --  Replace\n-                  --     CW : I'Class := Obj;\n-                  --  by\n-                  --     Dnn : Typ := Obj;\n-                  --     type Ityp is not null access I'Class;\n-                  --     Rnn : constant Ityp := Ityp (Dnn.I_Tag'Address);\n-                  --     CW  : I'Class renames Rnn.all;\n-\n-                  if Comes_From_Source (Expr_Q)\n-                    and then Is_Entity_Name (Expr_Q)\n-                    and then not Is_Interface (Expr_Typ)\n-                    and then Interface_Present_In_Ancestor (Expr_Typ, Typ)\n-                    and then (Expr_Typ = Etype (Expr_Typ)\n-                               or else not\n-                                 Is_Variable_Size_Record (Etype (Expr_Typ)))\n-                  then\n-                     --  Copy the object\n-\n-                     Insert_Action (N,\n-                       Make_Object_Declaration (Loc,\n-                         Defining_Identifier => Obj_Id,\n-                         Object_Definition   =>\n-                           New_Occurrence_Of (Expr_Typ, Loc),\n-                         Expression          => Relocate_Node (Expr_Q)));\n-\n-                     --  Statically reference the tag associated with the\n-                     --  interface\n-\n-                     Tag_Comp :=\n-                       Make_Selected_Component (Loc,\n-                         Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n-                         Selector_Name =>\n-                           New_Occurrence_Of\n-                             (Find_Interface_Tag (Expr_Typ, Iface), Loc));\n-\n                   --  Replace\n                   --     IW : I'Class := Expr;\n                   --  by\n@@ -7665,7 +7630,7 @@ package body Exp_Ch3 is\n                   --             Ityp!(Displace (Dnn'Address, I'Tag));\n                   --     IW : I'Class renames Rnn.all;\n \n-                  elsif Rewrite_As_Renaming then\n+                  if Rewrite_As_Renaming then\n                      New_Expr :=\n                        Make_Explicit_Dereference (Loc,\n                          Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n@@ -7697,6 +7662,37 @@ package body Exp_Ch3 is\n                              (Node (First_Elmt (Access_Disp_Table (Iface))),\n                               Loc)));\n \n+                  --  Replace\n+                  --     IW : I'Class := Expr;\n+                  --  by\n+                  --     Dnn : Typ := Expr;\n+                  --     type Ityp is not null access I'Class;\n+                  --     Rnn : constant Ityp := Ityp (Dnn.I_Tag'Address);\n+                  --     IW  : I'Class renames Rnn.all;\n+\n+                  elsif Has_Tag_Of_Type (Expr_Q)\n+                    and then Interface_Present_In_Ancestor (Expr_Typ, Typ)\n+                    and then (Expr_Typ = Etype (Expr_Typ)\n+                               or else not\n+                                 Is_Variable_Size_Record (Etype (Expr_Typ)))\n+                  then\n+                     Insert_Action (N,\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier => Obj_Id,\n+                         Object_Definition   =>\n+                           New_Occurrence_Of (Expr_Typ, Loc),\n+                         Expression          => Relocate_Node (Expr_Q)));\n+\n+                     --  Statically reference the tag associated with the\n+                     --  interface\n+\n+                     Tag_Comp :=\n+                       Make_Selected_Component (Loc,\n+                         Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n+                         Selector_Name =>\n+                           New_Occurrence_Of\n+                             (Find_Interface_Tag (Expr_Typ, Iface), Loc));\n+\n                   --  Replace\n                   --     IW : I'Class := Expr;\n                   --  by\n@@ -7977,7 +7973,7 @@ package body Exp_Ch3 is\n                 and then not (Is_Array_Type (Typ)\n                                and then Is_Constr_Subt_For_UN_Aliased (Typ))\n \n-                --  We may use a renaming if the initializing expression is a\n+                --  We may use a renaming if the initialization expression is a\n                 --  captured function call that meets a few conditions.\n \n                 and then"}, {"sha": "80c01bf40fd27cd639bb9d7d7ed11fbb076e03b5", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39a7b603380c6f4383357a6ae1d6c516dc677f29/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39a7b603380c6f4383357a6ae1d6c516dc677f29/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=39a7b603380c6f4383357a6ae1d6c516dc677f29", "patch": "@@ -7186,6 +7186,63 @@ package body Exp_Util is\n       end if;\n    end Has_Access_Constraint;\n \n+   ---------------------\n+   -- Has_Tag_Of_Type --\n+   ---------------------\n+\n+   function Has_Tag_Of_Type (Exp : Node_Id) return Boolean is\n+      Typ : constant Entity_Id := Etype (Exp);\n+\n+   begin\n+      pragma Assert (Is_Tagged_Type (Typ));\n+\n+      --  The tag of an object of a class-wide type is that of its\n+      --  initialization expression.\n+\n+      if Is_Class_Wide_Type (Typ) then\n+         return False;\n+      end if;\n+\n+      --  The tag of a stand-alone object of a specific tagged type T\n+      --  identifies T.\n+\n+      if Is_Entity_Name (Exp)\n+        and then Ekind (Entity (Exp)) in E_Constant | E_Variable\n+      then\n+         return True;\n+\n+      else\n+         case Nkind (Exp) is\n+            --  The tag of a component or an aggregate of a specific tagged\n+            --  type T identifies T.\n+\n+            when N_Indexed_Component\n+              |  N_Selected_Component\n+              |  N_Aggregate\n+            =>\n+               return True;\n+\n+            --  The tag of the result returned by a function whose result\n+            --  type is a specific tagged type T identifies T.\n+\n+            when N_Function_Call =>\n+               return True;\n+\n+            when N_Explicit_Dereference =>\n+               return Is_Captured_Function_Call (Exp);\n+\n+            --  For a tagged type, the operand of a qualified expression\n+            --  shall resolve to be of the type of the expression.\n+\n+            when N_Qualified_Expression =>\n+               return Has_Tag_Of_Type (Expression (Exp));\n+\n+            when others =>\n+               return False;\n+         end case;\n+      end if;\n+   end Has_Tag_Of_Type;\n+\n    --------------------\n    -- Homonym_Number --\n    --------------------\n@@ -9491,61 +9548,6 @@ package body Exp_Util is\n       Size_Attr   : Node_Id;\n       Size_Expr   : Node_Id;\n \n-      function Has_Tag_Of_Type (Exp : Node_Id) return Boolean;\n-      --  Return True if expression Exp of a tagged type is known to statically\n-      --  have the tag of this tagged type as specified by RM 3.9(19-25).\n-\n-      ---------------------\n-      -- Has_Tag_Of_Type --\n-      ---------------------\n-\n-      function Has_Tag_Of_Type (Exp : Node_Id) return Boolean is\n-         Typ : constant Entity_Id := Etype (Exp);\n-\n-      begin\n-         pragma Assert (Is_Tagged_Type (Typ));\n-\n-         --  The tag of an object of a class-wide type is that of its\n-         --  initialization expression.\n-\n-         if Is_Class_Wide_Type (Typ) then\n-            return False;\n-         end if;\n-\n-         --  The tag of a stand-alone object of a specific tagged type T\n-         --  identifies T.\n-\n-         if Is_Entity_Name (Exp)\n-           and then Ekind (Entity (Exp)) in E_Constant | E_Variable\n-         then\n-            return True;\n-\n-         else\n-            case Nkind (Exp) is\n-               --  The tag of a component or an aggregate of a specific tagged\n-               --  type T identifies T.\n-\n-               when N_Indexed_Component\n-                 |  N_Selected_Component\n-                 |  N_Aggregate\n-               =>\n-                  return True;\n-\n-               --  The tag of the result returned by a function whose result\n-               --  type is a specific tagged type T identifies T.\n-\n-               when N_Function_Call =>\n-                  return True;\n-\n-               when N_Explicit_Dereference =>\n-                  return Is_Captured_Function_Call (Exp);\n-\n-               when others =>\n-                  return False;\n-            end case;\n-         end if;\n-      end Has_Tag_Of_Type;\n-\n    begin\n       --  If the root type is already constrained, there are no discriminants\n       --  in the expression."}, {"sha": "3dd10d77cea4a5401950b28c698a2ea46c0c9195", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39a7b603380c6f4383357a6ae1d6c516dc677f29/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39a7b603380c6f4383357a6ae1d6c516dc677f29/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=39a7b603380c6f4383357a6ae1d6c516dc677f29", "patch": "@@ -732,6 +732,10 @@ package Exp_Util is\n    function Has_Access_Constraint (E : Entity_Id) return Boolean;\n    --  Given object or type E, determine if a discriminant is of an access type\n \n+   function Has_Tag_Of_Type (Exp : Node_Id) return Boolean;\n+   --  Return True if expression Exp of a tagged type is known to statically\n+   --  have the tag of this tagged type as specified by RM 3.9(19-25).\n+\n    function Homonym_Number (Subp : Entity_Id) return Pos;\n    --  Here subp is the entity for a subprogram. This routine returns the\n    --  homonym number used to disambiguate overloaded subprograms in the same"}]}