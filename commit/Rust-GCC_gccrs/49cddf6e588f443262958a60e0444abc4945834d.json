{"sha": "49cddf6e588f443262958a60e0444abc4945834d", "node_id": "C_kwDOANBUbNoAKDQ5Y2RkZjZlNTg4ZjQ0MzI2Mjk1OGE2MGUwNDQ0YWJjNDk0NTgzNGQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T10:15:27Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T12:20:09Z"}, "message": "Fix up missing jump_target handling\n\nThis adds in missed ported code for handling VAR_DECLS and jump's within\nstatement lists.", "tree": {"sha": "43e37fe09af272a4a34eb2abb1db3869a9f7ef1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43e37fe09af272a4a34eb2abb1db3869a9f7ef1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49cddf6e588f443262958a60e0444abc4945834d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49cddf6e588f443262958a60e0444abc4945834d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49cddf6e588f443262958a60e0444abc4945834d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49cddf6e588f443262958a60e0444abc4945834d/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3e1361d1ac1ae892d25737e0ee21e71db423a07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3e1361d1ac1ae892d25737e0ee21e71db423a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3e1361d1ac1ae892d25737e0ee21e71db423a07"}], "stats": {"total": 194, "additions": 157, "deletions": 37}, "files": [{"sha": "87b1a8434931428ea8a4540712ab310158337840", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 135, "deletions": 37, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49cddf6e588f443262958a60e0444abc4945834d/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49cddf6e588f443262958a60e0444abc4945834d/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=49cddf6e588f443262958a60e0444abc4945834d", "patch": "@@ -88,6 +88,15 @@ unshare_constructor (tree t MEM_STAT_DECL);\n void\n maybe_save_constexpr_fundef (tree fun);\n \n+static bool\n+returns (tree *jump_target);\n+static bool\n+breaks (tree *jump_target);\n+static bool\n+continues (tree *jump_target);\n+static bool\n+switches (tree *jump_target);\n+\n struct constexpr_global_ctx\n {\n   /* Values for any temporaries or local variables within the\n@@ -1800,11 +1809,95 @@ eval_component_reference (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t\t   overflow_p);\n }\n \n+/* Subroutine of cxx_eval_statement_list.  Determine whether the statement\n+   STMT matches *jump_target.  If we're looking for a case label and we see\n+   the default label, note it in ctx->css_state.  */\n+\n+static bool\n+label_matches (const constexpr_ctx *ctx, tree *jump_target, tree stmt)\n+{\n+  switch (TREE_CODE (*jump_target))\n+    {\n+    case LABEL_DECL:\n+      if (TREE_CODE (stmt) == LABEL_EXPR\n+\t  && LABEL_EXPR_LABEL (stmt) == *jump_target)\n+\treturn true;\n+      break;\n+\n+    case INTEGER_CST:\n+      if (TREE_CODE (stmt) == CASE_LABEL_EXPR)\n+\t{\n+\t  gcc_assert (ctx->css_state != NULL);\n+\t  if (!CASE_LOW (stmt))\n+\t    {\n+\t      /* default: should appear just once in a SWITCH_EXPR\n+\t\t body (excluding nested SWITCH_EXPR).  */\n+\t      gcc_assert (*ctx->css_state != css_default_seen);\n+\t      /* When evaluating SWITCH_EXPR body for the second time,\n+\t\t return true for the default: label.  */\n+\t      if (*ctx->css_state == css_default_processing)\n+\t\treturn true;\n+\t      *ctx->css_state = css_default_seen;\n+\t    }\n+\t  else if (CASE_HIGH (stmt))\n+\t    {\n+\t      if (tree_int_cst_le (CASE_LOW (stmt), *jump_target)\n+\t\t  && tree_int_cst_le (*jump_target, CASE_HIGH (stmt)))\n+\t\treturn true;\n+\t    }\n+\t  else if (tree_int_cst_equal (*jump_target, CASE_LOW (stmt)))\n+\t    return true;\n+\t}\n+      break;\n+\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      /* These two are handled directly in cxx_eval_loop_expr by testing\n+\t breaks (jump_target) or continues (jump_target).  */\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return false;\n+}\n+\n static tree\n eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p,\n \t\t\t  tree *jump_target /* = NULL */)\n {\n+  if (jump_target && *jump_target)\n+    {\n+      /* If we are jumping, ignore all statements/expressions except those\n+\t that could have LABEL_EXPR or CASE_LABEL_EXPR in their bodies.  */\n+      switch (TREE_CODE (t))\n+\t{\n+\tcase BIND_EXPR:\n+\tcase STATEMENT_LIST:\n+\tcase LOOP_EXPR:\n+\tcase COND_EXPR:\n+\tcase IF_STMT:\n+\tcase DO_STMT:\n+\tcase WHILE_STMT:\n+\tcase FOR_STMT:\n+\t  break;\n+\tcase LABEL_EXPR:\n+\tcase CASE_LABEL_EXPR:\n+\t  if (label_matches (ctx, jump_target, t))\n+\t    /* Found it.  */\n+\t    *jump_target = NULL_TREE;\n+\t  return NULL_TREE;\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+    }\n+  if (error_operand_p (t))\n+    {\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n   location_t loc = EXPR_LOCATION (t);\n \n   if (CONSTANT_CLASS_P (t))\n@@ -1835,7 +1928,28 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n   tree_code tcode = TREE_CODE (t);\n   switch (tcode)\n     {\n+    case VAR_DECL:\n+      if (DECL_HAS_VALUE_EXPR_P (t))\n+\t{\n+\t  r = DECL_VALUE_EXPR (t);\n+\t  return eval_constant_expression (ctx, r, lval, non_constant_p,\n+\t\t\t\t\t   overflow_p);\n+\t}\n+      /* fall through */\n       case CONST_DECL: {\n+\t/* We used to not check lval for CONST_DECL, but darwin.cc uses\n+\t   CONST_DECL for aggregate constants.  */\n+\tif (lval)\n+\t  return t;\n+\telse if (t == ctx->object)\n+\t  return ctx->ctor;\n+\tif (VAR_P (t))\n+\t  if (tree *p = ctx->global->values.get (t))\n+\t    if (*p != NULL_TREE)\n+\t      {\n+\t\tr = *p;\n+\t\tbreak;\n+\t      }\n \tr = decl_constant_value (t, /*unshare_p=*/false);\n \tif (TREE_CODE (r) == TARGET_EXPR\n \t    && TREE_CODE (TARGET_EXPR_INITIAL (r)) == CONSTRUCTOR)\n@@ -1848,18 +1962,6 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       }\n       break;\n \n-    case VAR_DECL:\n-      if (DECL_HAS_VALUE_EXPR_P (t))\n-\t{\n-\t  r = DECL_VALUE_EXPR (t);\n-\t  return eval_constant_expression (ctx, r, lval, non_constant_p,\n-\t\t\t\t\t   overflow_p);\n-\t}\n-      else\n-\tr = DECL_VALUE_EXPR (t);\n-      return eval_constant_expression (ctx, r, lval, non_constant_p,\n-\t\t\t\t       overflow_p);\n-\n     case PARM_DECL:\n       if (lval && !TYPE_REF_P (TREE_TYPE (t)))\n \t/* glvalue use.  */;\n@@ -1923,7 +2025,7 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n     case LTGT_EXPR:\n     case RANGE_EXPR:\n     case COMPLEX_EXPR:\n-      r = eval_binary_expression (ctx, t, false, non_constant_p, overflow_p);\n+      r = eval_binary_expression (ctx, t, lval, non_constant_p, overflow_p);\n       break;\n \n       /* fold can introduce non-IF versions of these; still treat them as\n@@ -2004,15 +2106,14 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       break;\n \n     case CALL_EXPR:\n-      r = eval_call_expression (ctx, t, false, non_constant_p, overflow_p);\n+      r = eval_call_expression (ctx, t, lval, non_constant_p, overflow_p);\n       break;\n \n     case RETURN_EXPR:\n-      rust_assert (TREE_OPERAND (t, 0) != NULL_TREE);\n-      r = eval_constant_expression (ctx, TREE_OPERAND (t, 0), false,\n-\t\t\t\t    non_constant_p, overflow_p);\n-      break;\n-\n+      if (TREE_OPERAND (t, 0) != NULL_TREE)\n+\tr = eval_constant_expression (ctx, TREE_OPERAND (t, 0), lval,\n+\t\t\t\t      non_constant_p, overflow_p);\n+      /* FALLTHRU */\n     case BREAK_STMT:\n     case CONTINUE_STMT:\n       if (jump_target)\n@@ -2085,9 +2186,9 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       break;\n \n     case STATEMENT_LIST:\n-      // new_ctx = *ctx;\n-      // new_ctx.ctor = new_ctx.object = NULL_TREE;\n-      return eval_statement_list (ctx, t, non_constant_p, overflow_p,\n+      new_ctx = *ctx;\n+      new_ctx.ctor = new_ctx.object = NULL_TREE;\n+      return eval_statement_list (&new_ctx, t, non_constant_p, overflow_p,\n \t\t\t\t  jump_target);\n \n     case BIND_EXPR:\n@@ -3365,8 +3466,7 @@ eval_call_expression (const constexpr_ctx *ctx, tree t, bool lval,\n   if (depth_ok && !non_constant_args && ctx->strict)\n     {\n       new_call.hash = constexpr_fundef_hasher::hash (new_call.fundef);\n-      // new_call.hash\n-      //   = iterative_hash_template_arg (new_call.bindings, new_call.hash);\n+      new_call.hash = iterative_hash_object (new_call.bindings, new_call.hash);\n       new_call.hash\n \t= iterative_hash_object (ctx->manifestly_const_eval, new_call.hash);\n \n@@ -4555,24 +4655,22 @@ eval_statement_list (const constexpr_ctx *ctx, tree t, bool *non_constant_p,\n     {\n       /* We've found a continue, so skip everything until we reach\n \t the label its jumping to.  */\n-      // FIXME\n-      // if (continues (jump_target))\n-      //   {\n-      //     if (label_matches (ctx, jump_target, stmt))\n-      //       /* Found it.  */\n-      //       *jump_target = NULL_TREE;\n-      //     else\n-      //       continue;\n-      //   }\n+      if (continues (jump_target))\n+\t{\n+\t  if (label_matches (ctx, jump_target, stmt))\n+\t    /* Found it.  */\n+\t    *jump_target = NULL_TREE;\n+\t  else\n+\t    continue;\n+\t}\n       if (TREE_CODE (stmt) == DEBUG_BEGIN_STMT)\n \tcontinue;\n       r = eval_constant_expression (ctx, stmt, false, non_constant_p,\n \t\t\t\t    overflow_p, jump_target);\n       if (*non_constant_p)\n \tbreak;\n-      // FIXME\n-      // if (returns (jump_target) || breaks (jump_target))\n-      //   break;\n+      if (returns (jump_target) || breaks (jump_target))\n+\tbreak;\n     }\n   if (*jump_target && jump_target == &local_target)\n     {\n@@ -4621,7 +4719,7 @@ eval_conditional_expression (const constexpr_ctx *ctx, tree t, bool lval,\n     val = TREE_OPERAND (t, 2);\n   else\n     val = TREE_OPERAND (t, 1);\n-  if (TREE_CODE (t) == IF_STMT && !val)\n+  if (/*TREE_CODE (t) == IF_STMT && */ !val)\n     val = void_node;\n   return eval_constant_expression (ctx, val, lval, non_constant_p, overflow_p,\n \t\t\t\t   jump_target);"}, {"sha": "17beedefc303476b7fc03e8403205d978a584099", "filename": "gcc/testsuite/rust/compile/const4.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49cddf6e588f443262958a60e0444abc4945834d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49cddf6e588f443262958a60e0444abc4945834d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst4.rs?ref=49cddf6e588f443262958a60e0444abc4945834d", "patch": "@@ -0,0 +1,22 @@\n+// { dg-options \"-w -O0 -fdump-tree-gimple\" }\n+const A: i32 = 1;\n+\n+const fn test(a: i32) -> i32 {\n+    let b = A + a;\n+    if b == 2 {\n+        return b + 2;\n+    }\n+    a\n+}\n+\n+const B: i32 = test(1);\n+const C: i32 = test(12);\n+\n+fn main() {\n+    // { dg-final { scan-tree-dump-times {a = 1} 1 gimple } }\n+    let a = A;\n+    // { dg-final { scan-tree-dump-times {b = 4} 1 gimple } }\n+    let b = B;\n+    // { dg-final { scan-tree-dump-times {c = 12} 1 gimple } }\n+    let c = C;\n+}"}]}