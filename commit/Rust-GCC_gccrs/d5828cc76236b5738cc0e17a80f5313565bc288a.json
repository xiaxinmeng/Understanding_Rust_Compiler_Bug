{"sha": "d5828cc76236b5738cc0e17a80f5313565bc288a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU4MjhjYzc2MjM2YjU3MzhjYzBlMTdhODBmNTMxMzU2NWJjMjg4YQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2011-06-03T14:53:27Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2011-06-03T14:53:27Z"}, "message": "lto-streamer-in.c (get_resolution): Move to lto/lto.c.\n\n\t* lto-streamer-in.c (get_resolution): Move to lto/lto.c.\n\t(lto_register_var_decl_in_symtab): Likewise.\n\t(lto_register_function_decl_in_symtab): Likewise.\n\t(lto_read_tree): Move VAR_DECL and FUNCTION_DECL registration\n\tlogic to lto_read_decls.\n\nlto/ChangeLog\n\n\t* lto.c (get_resolution): Move from lto-streamer-in.c.\n\t(lto_register_var_decl_in_symtab): Likewise.\n\t(lto_register_function_decl_in_symtab): Likewise.\n\t(uniquify_nodes): Call lto_register_var_decl and\n\tlto_register_function_decl_in_symtab after reading a new\n\tVAR_DECL or FUNCTION_DECL.\n\nFrom-SVN: r174604", "tree": {"sha": "efd955ba1af7996c630fd1c8364572be4727c96e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efd955ba1af7996c630fd1c8364572be4727c96e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5828cc76236b5738cc0e17a80f5313565bc288a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5828cc76236b5738cc0e17a80f5313565bc288a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5828cc76236b5738cc0e17a80f5313565bc288a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5828cc76236b5738cc0e17a80f5313565bc288a/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ee33b5f0b2008e95f4a35308edc348ebb4ba07fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee33b5f0b2008e95f4a35308edc348ebb4ba07fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee33b5f0b2008e95f4a35308edc348ebb4ba07fa"}], "stats": {"total": 309, "additions": 163, "deletions": 146}, "files": [{"sha": "86245dd79b138aeb27d76144c95b58bdbb8f87ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5828cc76236b5738cc0e17a80f5313565bc288a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5828cc76236b5738cc0e17a80f5313565bc288a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5828cc76236b5738cc0e17a80f5313565bc288a", "patch": "@@ -1,3 +1,11 @@\n+2011-06-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* lto-streamer-in.c (get_resolution): Move to lto/lto.c.\n+\t(lto_register_var_decl_in_symtab): Likewise.\n+\t(lto_register_function_decl_in_symtab): Likewise.\n+\t(lto_read_tree): Move VAR_DECL and FUNCTION_DECL registration\n+\tlogic to lto_read_decls.\n+\n 2011-06-03  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/alpha/t-osf5: Remove."}, {"sha": "a0c5509fcffef8837162548a45980cf412977bd8", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5828cc76236b5738cc0e17a80f5313565bc288a/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5828cc76236b5738cc0e17a80f5313565bc288a/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=d5828cc76236b5738cc0e17a80f5313565bc288a", "patch": "@@ -1533,31 +1533,6 @@ lto_input_constructors_and_inits (struct lto_file_decl_data *file_data,\n }\n \n \n-/* Return the resolution for the decl with index INDEX from DATA_IN. */\n-\n-static enum ld_plugin_symbol_resolution\n-get_resolution (struct data_in *data_in, unsigned index)\n-{\n-  if (data_in->globals_resolution)\n-    {\n-      ld_plugin_symbol_resolution_t ret;\n-      /* We can have references to not emitted functions in\n-\t DECL_FUNCTION_PERSONALITY at least.  So we can and have\n-\t to indeed return LDPR_UNKNOWN in some cases.   */\n-      if (VEC_length (ld_plugin_symbol_resolution_t,\n-\t\t      data_in->globals_resolution) <= index)\n-\treturn LDPR_UNKNOWN;\n-      ret = VEC_index (ld_plugin_symbol_resolution_t,\n-\t\t       data_in->globals_resolution,\n-\t\t       index);\n-      return ret;\n-    }\n-  else\n-    /* Delay resolution finding until decl merging.  */\n-    return LDPR_UNKNOWN;\n-}\n-\n-\n /* Unpack all the non-pointer fields of the TS_BASE structure of\n    expression EXPR from bitpack BP.  */\n \n@@ -2473,117 +2448,6 @@ lto_input_tree_pointers (struct lto_input_block *ib, struct data_in *data_in,\n }\n \n \n-/* Register DECL with the global symbol table and change its\n-   name if necessary to avoid name clashes for static globals across\n-   different files.  */\n-\n-static void\n-lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl)\n-{\n-  tree context;\n-\n-  /* Variable has file scope, not local. Need to ensure static variables\n-     between different files don't clash unexpectedly.  */\n-  if (!TREE_PUBLIC (decl)\n-      && !((context = decl_function_context (decl))\n-\t   && auto_var_in_fn_p (decl, context)))\n-    {\n-      /* ??? We normally pre-mangle names before we serialize them\n-\t out.  Here, in lto1, we do not know the language, and\n-\t thus cannot do the mangling again. Instead, we just\n-\t append a suffix to the mangled name.  The resulting name,\n-\t however, is not a properly-formed mangled name, and will\n-\t confuse any attempt to unmangle it.  */\n-      const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-      char *label;\n-\n-      ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n-      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n-      rest_of_decl_compilation (decl, 1, 0);\n-\n-      VEC_safe_push (tree, gc, lto_global_var_decls, decl);\n-    }\n-\n-  /* If this variable has already been declared, queue the\n-     declaration for merging.  */\n-  if (TREE_PUBLIC (decl))\n-    {\n-      unsigned ix;\n-      if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n-\tgcc_unreachable ();\n-      lto_symtab_register_decl (decl, get_resolution (data_in, ix),\n-\t\t\t\tdata_in->file_data);\n-    }\n-}\n-\n-\n-\n-/* Register DECL with the global symbol table and change its\n-   name if necessary to avoid name clashes for static globals across\n-   different files.  DATA_IN contains descriptors and tables for the\n-   file being read.  */\n-\n-static void\n-lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n-{\n-  /* Need to ensure static entities between different files\n-     don't clash unexpectedly.  */\n-  if (!TREE_PUBLIC (decl))\n-    {\n-      /* We must not use the DECL_ASSEMBLER_NAME macro here, as it\n-\t may set the assembler name where it was previously empty.  */\n-      tree old_assembler_name = decl->decl_with_vis.assembler_name;\n-\n-      /* FIXME lto: We normally pre-mangle names before we serialize\n-\t them out.  Here, in lto1, we do not know the language, and\n-\t thus cannot do the mangling again. Instead, we just append a\n-\t suffix to the mangled name.  The resulting name, however, is\n-\t not a properly-formed mangled name, and will confuse any\n-\t attempt to unmangle it.  */\n-      const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-      char *label;\n-\n-      ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n-      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n-\n-      /* We may arrive here with the old assembler name not set\n-\t if the function body is not needed, e.g., it has been\n-\t inlined away and does not appear in the cgraph.  */\n-      if (old_assembler_name)\n-\t{\n-\t  tree new_assembler_name = DECL_ASSEMBLER_NAME (decl);\n-\n-\t  /* Make the original assembler name available for later use.\n-\t     We may have used it to indicate the section within its\n-\t     object file where the function body may be found.\n-\t     FIXME lto: Find a better way to maintain the function decl\n-\t     to body section mapping so we don't need this hack.  */\n-\t  lto_record_renamed_decl (data_in->file_data,\n-\t\t\t\t   IDENTIFIER_POINTER (old_assembler_name),\n-\t\t\t\t   IDENTIFIER_POINTER (new_assembler_name));\n-\n-\t  /* Also register the reverse mapping so that we can find the\n-\t     new name given to an existing assembler name (used when\n-\t     restoring alias pairs in input_constructors_or_inits.  */\n-\t  lto_record_renamed_decl (data_in->file_data,\n-\t\t\t\t   IDENTIFIER_POINTER (new_assembler_name),\n-\t\t\t\t   IDENTIFIER_POINTER (old_assembler_name));\n-\t}\n-    }\n-\n-  /* If this variable has already been declared, queue the\n-     declaration for merging.  */\n-  if (TREE_PUBLIC (decl) && !DECL_ABSTRACT (decl))\n-    {\n-      unsigned ix;\n-      if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n-\tgcc_unreachable ();\n-      lto_symtab_register_decl (decl, get_resolution (data_in, ix),\n-\t\t\t\tdata_in->file_data);\n-    }\n-}\n-\n-\n /* Read an index IX from input block IB and return the tree node at\n    DATA_IN->FILE_DATA->GLOBALS_INDEX[IX].  */\n \n@@ -2665,11 +2529,6 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n   if (TREE_CODE (result) == FUNCTION_DECL)\n     gcc_assert (!lto_stream_as_builtin_p (result));\n \n-  if (TREE_CODE (result) == VAR_DECL)\n-    lto_register_var_decl_in_symtab (data_in, result);\n-  else if (TREE_CODE (result) == FUNCTION_DECL && !DECL_BUILT_IN (result))\n-    lto_register_function_decl_in_symtab (data_in, result);\n-\n   /* end_marker = */ lto_input_1_unsigned (ib);\n \n #ifdef LTO_STREAMER_DEBUG"}, {"sha": "b247dbbdd0758b5d969b55ff84649b3ea589437e", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5828cc76236b5738cc0e17a80f5313565bc288a/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5828cc76236b5738cc0e17a80f5313565bc288a/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=d5828cc76236b5738cc0e17a80f5313565bc288a", "patch": "@@ -1,3 +1,12 @@\n+2011-06-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* lto.c (get_resolution): Move from lto-streamer-in.c.\n+\t(lto_register_var_decl_in_symtab): Likewise.\n+\t(lto_register_function_decl_in_symtab): Likewise.\n+\t(uniquify_nodes): Call lto_register_var_decl and\n+\tlto_register_function_decl_in_symtab after reading a new\n+\tVAR_DECL or FUNCTION_DECL.\n+\n 2011-06-01  Richard Guenther  <rguenther@suse.de>\n \n \t* lto-lang.c (lto_register_canonical_types): New function."}, {"sha": "70d5bdee4580119900d734f092fa293fef9dbe20", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 146, "deletions": 5, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5828cc76236b5738cc0e17a80f5313565bc288a/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5828cc76236b5738cc0e17a80f5313565bc288a/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=d5828cc76236b5738cc0e17a80f5313565bc288a", "patch": "@@ -501,6 +501,141 @@ lto_fixup_types (tree t)\n     }\n }\n \n+\n+/* Return the resolution for the decl with index INDEX from DATA_IN. */\n+\n+static enum ld_plugin_symbol_resolution\n+get_resolution (struct data_in *data_in, unsigned index)\n+{\n+  if (data_in->globals_resolution)\n+    {\n+      ld_plugin_symbol_resolution_t ret;\n+      /* We can have references to not emitted functions in\n+\t DECL_FUNCTION_PERSONALITY at least.  So we can and have\n+\t to indeed return LDPR_UNKNOWN in some cases.   */\n+      if (VEC_length (ld_plugin_symbol_resolution_t,\n+\t\t      data_in->globals_resolution) <= index)\n+\treturn LDPR_UNKNOWN;\n+      ret = VEC_index (ld_plugin_symbol_resolution_t,\n+\t\t       data_in->globals_resolution,\n+\t\t       index);\n+      return ret;\n+    }\n+  else\n+    /* Delay resolution finding until decl merging.  */\n+    return LDPR_UNKNOWN;\n+}\n+\n+\n+/* Register DECL with the global symbol table and change its\n+   name if necessary to avoid name clashes for static globals across\n+   different files.  */\n+\n+static void\n+lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl)\n+{\n+  tree context;\n+\n+  /* Variable has file scope, not local. Need to ensure static variables\n+     between different files don't clash unexpectedly.  */\n+  if (!TREE_PUBLIC (decl)\n+      && !((context = decl_function_context (decl))\n+\t   && auto_var_in_fn_p (decl, context)))\n+    {\n+      /* ??? We normally pre-mangle names before we serialize them\n+\t out.  Here, in lto1, we do not know the language, and\n+\t thus cannot do the mangling again. Instead, we just\n+\t append a suffix to the mangled name.  The resulting name,\n+\t however, is not a properly-formed mangled name, and will\n+\t confuse any attempt to unmangle it.  */\n+      const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+      char *label;\n+\n+      ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n+      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n+      rest_of_decl_compilation (decl, 1, 0);\n+      VEC_safe_push (tree, gc, lto_global_var_decls, decl);\n+    }\n+\n+  /* If this variable has already been declared, queue the\n+     declaration for merging.  */\n+  if (TREE_PUBLIC (decl))\n+    {\n+      unsigned ix;\n+      if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n+\tgcc_unreachable ();\n+      lto_symtab_register_decl (decl, get_resolution (data_in, ix),\n+\t\t\t\tdata_in->file_data);\n+    }\n+}\n+\n+\n+/* Register DECL with the global symbol table and change its\n+   name if necessary to avoid name clashes for static globals across\n+   different files.  DATA_IN contains descriptors and tables for the\n+   file being read.  */\n+\n+static void\n+lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n+{\n+  /* Need to ensure static entities between different files\n+     don't clash unexpectedly.  */\n+  if (!TREE_PUBLIC (decl))\n+    {\n+      /* We must not use the DECL_ASSEMBLER_NAME macro here, as it\n+\t may set the assembler name where it was previously empty.  */\n+      tree old_assembler_name = decl->decl_with_vis.assembler_name;\n+\n+      /* FIXME lto: We normally pre-mangle names before we serialize\n+\t them out.  Here, in lto1, we do not know the language, and\n+\t thus cannot do the mangling again. Instead, we just append a\n+\t suffix to the mangled name.  The resulting name, however, is\n+\t not a properly-formed mangled name, and will confuse any\n+\t attempt to unmangle it.  */\n+      const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+      char *label;\n+\n+      ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n+      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (label));\n+\n+      /* We may arrive here with the old assembler name not set\n+\t if the function body is not needed, e.g., it has been\n+\t inlined away and does not appear in the cgraph.  */\n+      if (old_assembler_name)\n+\t{\n+\t  tree new_assembler_name = DECL_ASSEMBLER_NAME (decl);\n+\n+\t  /* Make the original assembler name available for later use.\n+\t     We may have used it to indicate the section within its\n+\t     object file where the function body may be found.\n+\t     FIXME lto: Find a better way to maintain the function decl\n+\t     to body section mapping so we don't need this hack.  */\n+\t  lto_record_renamed_decl (data_in->file_data,\n+\t\t\t\t   IDENTIFIER_POINTER (old_assembler_name),\n+\t\t\t\t   IDENTIFIER_POINTER (new_assembler_name));\n+\n+\t  /* Also register the reverse mapping so that we can find the\n+\t     new name given to an existing assembler name (used when\n+\t     restoring alias pairs in input_constructors_or_inits.  */\n+\t  lto_record_renamed_decl (data_in->file_data,\n+\t\t\t\t   IDENTIFIER_POINTER (new_assembler_name),\n+\t\t\t\t   IDENTIFIER_POINTER (old_assembler_name));\n+\t}\n+    }\n+\n+  /* If this variable has already been declared, queue the\n+     declaration for merging.  */\n+  if (TREE_PUBLIC (decl) && !DECL_ABSTRACT (decl))\n+    {\n+      unsigned ix;\n+      if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n+\tgcc_unreachable ();\n+      lto_symtab_register_decl (decl, get_resolution (data_in, ix),\n+\t\t\t\tdata_in->file_data);\n+    }\n+}\n+\n+\n /* Given a streamer cache structure DATA_IN (holding a sequence of trees\n    for one compilation unit) go over all trees starting at index FROM until the\n    end of the sequence and replace fields of those trees, and the trees\n@@ -513,20 +648,25 @@ uniquify_nodes (struct data_in *data_in, unsigned from)\n   unsigned len = VEC_length (tree, cache->nodes);\n   unsigned i;\n \n-  /* Go backwards because childs streamed for the first time come\n+  /* Go backwards because children streamed for the first time come\n      as part of their parents, and hence are created after them.  */\n \n-  /* First register all types in the cache.\n+  /* First register all declarations and types in the cache.\n      This makes sure to have the original structure in the type cycles\n      when registering them and computing hashes.  */\n   for (i = len; i-- > from;)\n     {\n       tree t = VEC_index (tree, cache->nodes, i);\n-      if (!t\n-\t  || !TYPE_P (t))\n+\n+      if (t == NULL_TREE)\n \tcontinue;\n \n-      gimple_register_type (t);\n+      if (TREE_CODE (t) == VAR_DECL)\n+\tlto_register_var_decl_in_symtab (data_in, t);\n+      else if (TREE_CODE (t) == FUNCTION_DECL && !DECL_BUILT_IN (t))\n+\tlto_register_function_decl_in_symtab (data_in, t);\n+      else if (TYPE_P (t))\n+\tgimple_register_type (t);\n     }\n \n   /* Second fixup all trees in the new cache entries.  */\n@@ -665,6 +805,7 @@ uniquify_nodes (struct data_in *data_in, unsigned from)\n     }\n }\n \n+\n /* Read all the symbols from buffer DATA, using descriptors in DECL_DATA.\n    RESOLUTIONS is the set of symbols picked by the linker (read from the\n    resolution file when the linker plugin is being used).  */"}]}