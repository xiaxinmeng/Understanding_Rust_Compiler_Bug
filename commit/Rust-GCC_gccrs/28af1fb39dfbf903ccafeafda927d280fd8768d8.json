{"sha": "28af1fb39dfbf903ccafeafda927d280fd8768d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhhZjFmYjM5ZGZiZjkwM2NjYWZlYWZkYTkyN2QyODBmZDg3NjhkOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-01-16T23:38:35Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-01-16T23:38:35Z"}, "message": "Implement C++11 <codecvt> header.\n\n\t* config/abi/pre/gnu.ver: Export new symbols.\n\t* include/Makefile.am: Add codecvt.\n\t* include/Makefile.in: Regenerate.\n\t* include/std/codecvt: New header.\n\t* src/c++11/codecvt.cc (__codecvt_utf8_base, __codecvt_utf16_base,\n\t__codecvt_utf8_utf16_base): Define specializations.\n\t* testsuite/22_locale/codecvt/codecvt_utf8/requirements/1.cc: New.\n\t* testsuite/22_locale/codecvt/codecvt_utf16/requirements/1.cc: New.\n\t* testsuite/22_locale/codecvt/codecvt_utf8_utf16/requirements/1.cc:\n\tNew.\n\nFrom-SVN: r219779", "tree": {"sha": "8c798f7195e89e40829e60d3b8f2b3e02730a5ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c798f7195e89e40829e60d3b8f2b3e02730a5ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28af1fb39dfbf903ccafeafda927d280fd8768d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28af1fb39dfbf903ccafeafda927d280fd8768d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28af1fb39dfbf903ccafeafda927d280fd8768d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28af1fb39dfbf903ccafeafda927d280fd8768d8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f59f5c12003e547e7557cc09da39c2abd63403d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f59f5c12003e547e7557cc09da39c2abd63403d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f59f5c12003e547e7557cc09da39c2abd63403d"}], "stats": {"total": 1345, "additions": 1304, "deletions": 41}, "files": [{"sha": "cd4f0891ad486eaae0c1c80c6616c07bf2cdf250", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=28af1fb39dfbf903ccafeafda927d280fd8768d8", "patch": "@@ -1,3 +1,16 @@\n+2015-01-16  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* config/abi/pre/gnu.ver: Export new symbols.\n+\t* include/Makefile.am: Add codecvt.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/std/codecvt: New header.\n+\t* src/c++11/codecvt.cc (__codecvt_utf8_base, __codecvt_utf16_base,\n+\t__codecvt_utf8_utf16_base): Define specializations.\n+\t* testsuite/22_locale/codecvt/codecvt_utf8/requirements/1.cc: New.\n+\t* testsuite/22_locale/codecvt/codecvt_utf16/requirements/1.cc: New.\n+\t* testsuite/22_locale/codecvt/codecvt_utf8_utf16/requirements/1.cc:\n+\tNew.\n+\n 2015-01-16  Torvald Riegel  <triegel@redhat.com>\n \n \t* src/c++11/futex.cc: New file."}, {"sha": "d23306e7c76f7ef9935e7412356faeebee386f92", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=28af1fb39dfbf903ccafeafda927d280fd8768d8", "patch": "@@ -1769,6 +1769,17 @@ GLIBCXX_3.4.21 {\n       std::__atomic_futex_unsigned_base*;\n     };\n \n+    # codecvt_utf8 etc.\n+    _ZNKSt19__codecvt_utf8_base*;\n+    _ZNSt19__codecvt_utf8_base*;\n+    _ZT[ISV]St19__codecvt_utf8_base*;\n+    _ZNKSt20__codecvt_utf16_base*;\n+    _ZNSt20__codecvt_utf16_base*;\n+    _ZT[ISV]St20__codecvt_utf16_base*;\n+    _ZNKSt25__codecvt_utf8_utf16_base*;\n+    _ZNSt25__codecvt_utf8_utf16_base*;\n+    _ZT[ISV]St25__codecvt_utf8_utf16_base*;\n+\n } GLIBCXX_3.4.20;\n \n "}, {"sha": "285a504dbf906c21c98a33362f203e426e8dfdb4", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=28af1fb39dfbf903ccafeafda927d280fd8768d8", "patch": "@@ -31,6 +31,7 @@ std_headers = \\\n \t${std_srcdir}/atomic \\\n \t${std_srcdir}/bitset \\\n \t${std_srcdir}/chrono \\\n+\t${std_srcdir}/codecvt \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/condition_variable \\\n \t${std_srcdir}/deque \\"}, {"sha": "5c2ea1496c98271e527c997678d1cb94cfce69d1", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=28af1fb39dfbf903ccafeafda927d280fd8768d8", "patch": "@@ -299,6 +299,7 @@ std_headers = \\\n \t${std_srcdir}/atomic \\\n \t${std_srcdir}/bitset \\\n \t${std_srcdir}/chrono \\\n+\t${std_srcdir}/codecvt \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/condition_variable \\\n \t${std_srcdir}/deque \\"}, {"sha": "d58a0ecd673c72749188ecdb90331d54079fd750", "filename": "libstdc++-v3/include/std/codecvt", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcodecvt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcodecvt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcodecvt?ref=28af1fb39dfbf903ccafeafda927d280fd8768d8", "patch": "@@ -0,0 +1,179 @@\n+// <codecvt> -*- C++ -*-\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+// ISO C++ 14882: 22.5  Standard code conversion facets\n+\n+/** @file include/codecvt\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_CODECVT\n+#define _GLIBCXX_CODECVT 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#include <bits/locale_classes.h>\n+#include <bits/codecvt.h>\n+\n+#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  enum codecvt_mode\n+  {\n+    consume_header = 4,\n+    generate_header = 2,\n+    little_endian = 1\n+  };\n+\n+  template<typename _Elem, unsigned long _Maxcode = 0x10ffff,\n+\t   codecvt_mode _Mode = (codecvt_mode)0>\n+    class codecvt_utf8 : public codecvt<_Elem, char, mbstate_t>\n+    {\n+    public:\n+      explicit\n+      codecvt_utf8(size_t __refs = 0);\n+\n+      ~codecvt_utf8();\n+    };\n+\n+  template<typename _Elem, unsigned long _Maxcode = 0x10ffff,\n+\t   codecvt_mode _Mode = (codecvt_mode)0>\n+    class codecvt_utf16 : public codecvt<_Elem, char, mbstate_t>\n+    {\n+    public:\n+      explicit\n+      codecvt_utf16(size_t __refs = 0);\n+\n+      ~codecvt_utf16();\n+    };\n+\n+  template<typename _Elem, unsigned long _Maxcode = 0x10ffff,\n+\t   codecvt_mode _Mode = (codecvt_mode)0>\n+    class codecvt_utf8_utf16 : public codecvt<_Elem, char, mbstate_t>\n+    {\n+    public:\n+      explicit\n+      codecvt_utf8_utf16(size_t __refs = 0);\n+\n+      ~codecvt_utf8_utf16();\n+    };\n+\n+#define _GLIBCXX_CODECVT_SPECIALIZATION2(_NAME, _ELEM) \\\n+  template<> \\\n+    class _NAME<_ELEM> \\\n+    : public codecvt<_ELEM, char, mbstate_t> \\\n+    { \\\n+    public: \\\n+      typedef _ELEM\t\t\tintern_type; \\\n+      typedef char\t\t\textern_type; \\\n+      typedef mbstate_t\t\t\tstate_type; \\\n+ \\\n+    protected: \\\n+      _NAME(unsigned long __maxcode, codecvt_mode __mode, size_t __refs) \\\n+      : codecvt(__refs), _M_maxcode(__maxcode), _M_mode(__mode) { } \\\n+ \\\n+      virtual \\\n+      ~_NAME(); \\\n+ \\\n+      virtual result \\\n+      do_out(state_type& __state, const intern_type* __from, \\\n+\t     const intern_type* __from_end, const intern_type*& __from_next, \\\n+\t     extern_type* __to, extern_type* __to_end, \\\n+\t     extern_type*& __to_next) const; \\\n+ \\\n+      virtual result \\\n+      do_unshift(state_type& __state, \\\n+\t\t extern_type* __to, extern_type* __to_end, \\\n+\t\t extern_type*& __to_next) const; \\\n+ \\\n+      virtual result \\\n+      do_in(state_type& __state, \\\n+\t     const extern_type* __from, const extern_type* __from_end, \\\n+\t     const extern_type*& __from_next, \\\n+\t     intern_type* __to, intern_type* __to_end, \\\n+\t     intern_type*& __to_next) const; \\\n+ \\\n+      virtual \\\n+      int do_encoding() const throw(); \\\n+ \\\n+      virtual \\\n+      bool do_always_noconv() const throw(); \\\n+ \\\n+      virtual \\\n+      int do_length(state_type&, const extern_type* __from, \\\n+\t\t    const extern_type* __end, size_t __max) const; \\\n+ \\\n+      virtual int \\\n+      do_max_length() const throw(); \\\n+ \\\n+    private: \\\n+      unsigned long\t_M_maxcode; \\\n+      codecvt_mode\t_M_mode; \\\n+    }\n+\n+#define _GLIBCXX_CODECVT_SPECIALIZATION(_NAME, _ELEM) \\\n+  _GLIBCXX_CODECVT_SPECIALIZATION2(__ ## _NAME ## _base, _ELEM); \\\n+  template<unsigned long _Maxcode, codecvt_mode _Mode> \\\n+    class _NAME<_ELEM, _Maxcode, _Mode> \\\n+    : public __ ## _NAME ## _base<_ELEM> \\\n+    { \\\n+    public: \\\n+      explicit \\\n+      _NAME(size_t __refs = 0) \\\n+      : __ ## _NAME ## _base<_ELEM>(_Maxcode, _Mode, __refs) { } \\\n+    }\n+\n+  template<typename _Elem> class __codecvt_utf8_base;\n+  template<typename _Elem> class __codecvt_utf16_base;\n+  template<typename _Elem> class __codecvt_utf8_utf16_base;\n+\n+  _GLIBCXX_CODECVT_SPECIALIZATION(codecvt_utf8, char16_t);\n+  _GLIBCXX_CODECVT_SPECIALIZATION(codecvt_utf16, char16_t);\n+  _GLIBCXX_CODECVT_SPECIALIZATION(codecvt_utf8_utf16, char16_t);\n+\n+  _GLIBCXX_CODECVT_SPECIALIZATION(codecvt_utf8, char32_t);\n+  _GLIBCXX_CODECVT_SPECIALIZATION(codecvt_utf16, char32_t);\n+  _GLIBCXX_CODECVT_SPECIALIZATION(codecvt_utf8_utf16, char32_t);\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  _GLIBCXX_CODECVT_SPECIALIZATION(codecvt_utf8, wchar_t);\n+  _GLIBCXX_CODECVT_SPECIALIZATION(codecvt_utf16, wchar_t);\n+  _GLIBCXX_CODECVT_SPECIALIZATION(codecvt_utf8_utf16, wchar_t);\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+\n+#endif // _GLIBCXX_USE_C99_STDINT_TR1\n+\n+#endif\n+\n+#endif /* _GLIBCXX_CODECVT */"}, {"sha": "7eed903bc0cdcecb2c0067fd448e309c84eed438", "filename": "libstdc++-v3/src/c++11/codecvt.cc", "status": "modified", "additions": 988, "deletions": 41, "changes": 1029, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc?ref=28af1fb39dfbf903ccafeafda927d280fd8768d8", "patch": "@@ -22,10 +22,9 @@\n // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // <http://www.gnu.org/licenses/>.\n \n-#include <bits/locale_classes.h>\n-#include <bits/codecvt.h>\n-#include <bits/stl_algobase.h>\t// std::max\n+#include <codecvt>\n #include <cstring>\t\t// std::memcpy, std::memcmp\n+#include <bits/stl_algobase.h>\t// std::max\n \n #ifdef _GLIBCXX_USE_C99_STDINT_TR1\n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -51,6 +50,88 @@ namespace\n       size_t size() const { return end - next; }\n     };\n \n+  // Multibyte sequences can have \"header\" consisting of Byte Order Mark\n+  const unsigned char utf8_bom[3] = { 0xEF, 0xBB, 0xBF };\n+  const unsigned char utf16_bom[4] = { 0xFE, 0xFF };\n+  const unsigned char utf16le_bom[4] = { 0xFF, 0xFE };\n+\n+  template<size_t N>\n+    inline bool\n+    write_bom(range<char>& to, const unsigned char (&bom)[N])\n+    {\n+      if (to.size() < N)\n+\treturn false;\n+      memcpy(to.next, bom, N);\n+      to.next += N;\n+      return true;\n+    }\n+\n+  // If generate_header is set in mode write out UTF-8 BOM.\n+  bool\n+  write_utf8_bom(range<char>& to, codecvt_mode mode)\n+  {\n+    if (mode & generate_header)\n+      return write_bom(to, utf8_bom);\n+    return true;\n+  }\n+\n+  // If generate_header is set in mode write out the UTF-16 BOM indicated\n+  // by whether little_endian is set in mode.\n+  bool\n+  write_utf16_bom(range<char16_t>& to, codecvt_mode mode)\n+  {\n+    if (mode & generate_header)\n+    {\n+      if (!to.size())\n+\treturn false;\n+      auto* bom = (mode & little_endian) ? utf16le_bom : utf16_bom;\n+      std::memcpy(to.next, bom, 2);\n+      ++to.next;\n+    }\n+    return true;\n+  }\n+\n+  template<size_t N>\n+    inline bool\n+    read_bom(range<const char>& from, const unsigned char (&bom)[N])\n+    {\n+      if (from.size() >= N && !memcmp(from.next, bom, N))\n+\t{\n+\t  from.next += N;\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  // If consume_header is set in mode update from.next to after any BOM.\n+  void\n+  read_utf8_bom(range<const char>& from, codecvt_mode mode)\n+  {\n+    if (mode & consume_header)\n+      read_bom(from, utf8_bom);\n+  }\n+\n+  // If consume_header is set in mode update from.next to after any BOM.\n+  // Return little_endian iff the UTF-16LE BOM was present.\n+  codecvt_mode\n+  read_utf16_bom(range<const char16_t>& from, codecvt_mode mode)\n+  {\n+    if (mode & consume_header && from.size())\n+      {\n+\tif (*from.next == 0xFEFF)\n+\t  ++from.next;\n+\telse if (*from.next == 0xFFFE)\n+\t  {\n+\t    ++from.next;\n+\t    return little_endian;\n+\t  }\n+      }\n+    return {};\n+  }\n+\n+  // Read a codepoint from a UTF-8 multibyte sequence.\n+  // Updates from.next if the codepoint is not greater than maxcode.\n+  // Returns -1 if there is an invalid or incomplete multibyte character.\n   char32_t\n   read_utf8_code_point(range<const char>& from, unsigned long maxcode)\n   {\n@@ -74,9 +155,8 @@ namespace\n       if ((c2 & 0xC0) != 0x80)\n \treturn -1;\n       char32_t c = (c1 << 6) + c2 - 0x3080;\n-      if (c > maxcode)\n-\treturn -1;\n-      from.next += 2;\n+      if (c <= maxcode)\n+\tfrom.next += 2;\n       return c;\n     }\n     else if (c1 < 0xF0) // 3-byte sequence\n@@ -92,9 +172,8 @@ namespace\n       if ((c3 & 0xC0) != 0x80)\n \treturn -1;\n       char32_t c = (c1 << 12) + (c2 << 6) + c3 - 0xE2080;\n-      if (c > maxcode)\n-\treturn -1;\n-      from.next += 3;\n+      if (c <= maxcode)\n+\tfrom.next += 3;\n       return c;\n     }\n     else if (c1 < 0xF5) // 4-byte sequence\n@@ -115,9 +194,8 @@ namespace\n       if ((c4 & 0xC0) != 0x80)\n \treturn -1;\n       char32_t c = (c1 << 18) + (c2 << 12) + (c3 << 6) + c4 - 0x3C82080;\n-      if (c > maxcode)\n-\treturn -1;\n-      from.next += 4;\n+      if (c <= maxcode)\n+\tfrom.next += 4;\n       return c;\n     }\n     else // > U+10FFFF\n@@ -162,9 +240,48 @@ namespace\n     return true;\n   }\n \n+  inline char16_t\n+  adjust_byte_order(char16_t c, codecvt_mode mode)\n+  {\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+    return (mode & little_endian) ? __builtin_bswap16(c) : c;\n+#else\n+    return (mode & little_endian) ? c : __builtin_bswap16(c);\n+#endif\n+  }\n+\n+  // Read a codepoint from a UTF-16 multibyte sequence.\n+  // The sequence's endianness is indicated by (mode & little_endian).\n+  // Updates from.next if the codepoint is not greater than maxcode.\n+  // Returns -1 if there is an incomplete multibyte character.\n+  char32_t\n+  read_utf16_code_point(range<const char16_t>& from, unsigned long maxcode,\n+\t\t\tcodecvt_mode mode)\n+  {\n+    int inc = 1;\n+    char32_t c = adjust_byte_order(from.next[0], mode);\n+    if (c >= 0xD800 && c <= 0xDBFF)\n+      {\n+\tif (from.size() < 2)\n+\t  return -1;\n+\tconst char16_t c2 = adjust_byte_order(from.next[1], mode);\n+\tif (c2 >= 0xDC00 && c2 <= 0xDFFF)\n+\t  {\n+\t    c = (c << 10) + c2 - 0x35FDC00;\n+\t    inc = 2;\n+\t  }\n+      }\n+    if (c <= maxcode)\n+      from.next += inc;\n+    return c;\n+  }\n+\n+  template<typename C>\n   bool\n-  write_utf16_code_point(range<char16_t>& to, char32_t codepoint)\n+  write_utf16_code_point(range<C>& to, char32_t codepoint, codecvt_mode mode)\n   {\n+    static_assert(sizeof(C) >= 2, \"a code unit must be at least 16-bit\");\n+\n     if (codepoint < max_single_utf16_unit)\n       {\n \tif (to.size() > 0)\n@@ -183,8 +300,8 @@ namespace\n \tchar16_t trail = 0xDC00 + (codepoint & 0x3FF);\n \tchar32_t utf16bytes = (lead << 10) + trail + SURROGATE_OFFSET;\n \n-\tto.next[0] = utf16bytes >> 16;\n-\tto.next[1] = utf16bytes & 0xFFFF;\n+\tto.next[0] = adjust_byte_order(utf16bytes >> 16, mode);\n+\tto.next[1] = adjust_byte_order(utf16bytes & 0xFFFF, mode);\n \tto.next += 2;\n \treturn true;\n       }\n@@ -194,12 +311,15 @@ namespace\n   // utf8 -> ucs4\n   codecvt_base::result\n   ucs4_in(range<const char>& from, range<char32_t>& to,\n-          unsigned long maxcode = max_code_point)\n+          unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n   {\n+    read_utf8_bom(from, mode);\n     while (from.size() && to.size())\n       {\n \tconst char32_t codepoint = read_utf8_code_point(from, maxcode);\n-\tif (codepoint == char32_t(-1) || codepoint > maxcode)\n+\tif (codepoint == char32_t(-1))\n+\t  break;\n+\tif (codepoint > maxcode)\n \t  return codecvt_base::error;\n \t*to.next++ = codepoint;\n       }\n@@ -209,8 +329,10 @@ namespace\n   // ucs4 -> utf8\n   codecvt_base::result\n   ucs4_out(range<const char32_t>& from, range<char>& to,\n-           unsigned long maxcode = max_code_point)\n+           unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n   {\n+    if (!write_utf8_bom(to, mode))\n+      return codecvt_base::partial;\n     while (from.size())\n       {\n \tconst char32_t c = from.next[0];\n@@ -223,20 +345,62 @@ namespace\n     return codecvt_base::ok;\n   }\n \n+  // utf16 -> ucs4\n+  codecvt_base::result\n+  ucs4_in(range<const char16_t>& from, range<char32_t>& to,\n+          unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n+  {\n+    if (read_utf16_bom(from, mode) == little_endian)\n+      mode = codecvt_mode(mode & little_endian);\n+    while (from.size() && to.size())\n+      {\n+\tconst char32_t codepoint = read_utf16_code_point(from, maxcode, mode);\n+\tif (codepoint == char32_t(-1))\n+\t  break;\n+\tif (codepoint > maxcode)\n+\t  return codecvt_base::error;\n+\t*to.next++ = codepoint;\n+      }\n+    return from.size() ? codecvt_base::partial : codecvt_base::ok;\n+  }\n+\n+  // ucs4 -> utf16\n+  codecvt_base::result\n+  ucs4_out(range<const char32_t>& from, range<char16_t>& to,\n+           unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n+  {\n+    if (!write_utf16_bom(to, mode))\n+      return codecvt_base::partial;\n+    while (from.size())\n+      {\n+\tconst char32_t c = from.next[0];\n+\tif (c > maxcode)\n+\t  return codecvt_base::error;\n+\tif (!write_utf16_code_point(to, c, mode))\n+\t  return codecvt_base::partial;\n+\t++from.next;\n+      }\n+    return codecvt_base::ok;\n+  }\n+\n   // utf8 -> utf16\n+  template<typename C>\n   codecvt_base::result\n-  utf16_in(range<const char>& from, range<char16_t>& to,\n-           unsigned long maxcode = max_code_point)\n+  utf16_in(range<const char>& from, range<C>& to,\n+           unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n   {\n+    read_utf8_bom(from, mode);\n     while (from.size() && to.size())\n       {\n \tconst char* first = from.next;\n \tif ((unsigned char)*first >= 0xF0 && to.size() < 2)\n \t  return codecvt_base::partial;\n \tconst char32_t codepoint = read_utf8_code_point(from, maxcode);\n-\tif (codepoint == char32_t(-1) || codepoint > maxcode)\n+\tif (codepoint == char32_t(-1))\n+\t  return codecvt_base::partial;\n+\tif (codepoint > maxcode)\n \t  return codecvt_base::error;\n-\tif (!write_utf16_code_point(to, codepoint))\n+\tif (!write_utf16_code_point(to, codepoint, {}))\n \t  {\n \t    from.next = first;\n \t    return codecvt_base::partial;\n@@ -246,15 +410,18 @@ namespace\n   }\n \n   // utf16 -> utf8\n+  template<typename C>\n   codecvt_base::result\n-  utf16_out(range<const char16_t>& from, range<char>& to,\n-            unsigned long maxcode = max_code_point)\n+  utf16_out(range<const C>& from, range<char>& to,\n+            unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n   {\n+    if (!write_utf8_bom(to, mode))\n+      return codecvt_base::partial;\n     while (from.size())\n       {\n \tchar32_t c = from.next[0];\n \tint inc = 1;\n-\tif (c >= 0xD800 && c < 0xDBFF) // start of surrogate pair\n+\tif (c >= 0xD800 && c <= 0xDBFF) // start of surrogate pair\n \t  {\n \t    if (from.size() < 2)\n \t      return codecvt_base::ok; // stop converting at this point\n@@ -278,11 +445,12 @@ namespace\n   }\n \n   // return pos such that [begin,pos) is valid UTF-16 string no longer than max\n-  int\n-  utf16_len(const char* begin, const char* end, size_t max,\n-            char32_t maxcode = max_code_point)\n+  const char*\n+  utf16_span(const char* begin, const char* end, size_t max,\n+\t     char32_t maxcode = max_code_point, codecvt_mode mode = {})\n   {\n     range<const char> from{ begin, end };\n+    read_utf8_bom(from, mode);\n     size_t count = 0;\n     while (count+1 < max)\n       {\n@@ -295,24 +463,117 @@ namespace\n       }\n     if (count+1 == max) // take one more character if it fits in a single unit\n       read_utf8_code_point(from, std::max(max_single_utf16_unit, maxcode));\n-    return from.next - begin;\n+    return from.next;\n   }\n \n-  // return pos such that [begin,pos) is valid UCS-4 string no longer than max\n-  int\n-  ucs4_len(const char* begin, const char* end, size_t max,\n-            char32_t maxcode = max_code_point)\n+  // utf8 -> ucs2\n+  codecvt_base::result\n+  ucs2_in(range<const char>& from, range<char16_t>& to,\n+\t  char32_t maxcode = max_code_point, codecvt_mode mode = {})\n   {\n-    range<const char> from{ begin, end };\n-    size_t count = 0;\n-    while (count < max)\n+    return utf16_in(from, to, std::max(max_single_utf16_unit, maxcode), mode);\n+  }\n+\n+  // ucs2 -> utf8\n+  codecvt_base::result\n+  ucs2_out(range<const char16_t>& from, range<char>& to,\n+\t   char32_t maxcode = max_code_point, codecvt_mode mode = {})\n+  {\n+    return utf16_out(from, to, std::max(max_single_utf16_unit, maxcode), mode);\n+  }\n+\n+  // ucs2 -> utf16\n+  codecvt_base::result\n+  ucs2_out(range<const char16_t>& from, range<char16_t>& to,\n+\t   char32_t maxcode = max_code_point, codecvt_mode mode = {})\n+  {\n+    if (!write_utf16_bom(to, mode))\n+      return codecvt_base::partial;\n+    while (from.size() && to.size())\n       {\n-\tchar32_t c = read_utf8_code_point(from, maxcode);\n+\tchar16_t c = from.next[0];\n+\tif (c >= 0xD800 && c <= 0xDBFF) // start of surrogate pair\n+\t  return codecvt_base::error;\n+\tif (c > maxcode)\n+\t  return codecvt_base::error;\n+\t*to.next++ = adjust_byte_order(c, mode);\n+\t++from.next;\n+      }\n+    return from.size() == 0 ? codecvt_base::ok : codecvt_base::partial;\n+  }\n+\n+  // utf16 -> ucs2\n+  codecvt_base::result\n+  ucs2_in(range<const char16_t>& from, range<char16_t>& to,\n+\t  char32_t maxcode = max_code_point, codecvt_mode mode = {})\n+  {\n+    if (read_utf16_bom(from, mode) == little_endian)\n+      mode = codecvt_mode(mode & little_endian);\n+    maxcode = std::max(max_single_utf16_unit, maxcode);\n+    while (from.size() && to.size())\n+      {\n+\tconst char32_t c = read_utf16_code_point(from, maxcode, mode);\n \tif (c == char32_t(-1))\n \t  break;\n-\t++count;\n+\tif (c >= maxcode)\n+\t  return codecvt_base::error;\n+\t*to.next++ = c;\n       }\n-    return from.next - begin;\n+    return from.size() == 0 ? codecvt_base::ok : codecvt_base::partial;\n+  }\n+\n+  const char16_t*\n+  ucs2_span(const char16_t* begin, const char16_t* end, size_t max,\n+            char32_t maxcode, codecvt_mode mode)\n+  {\n+    range<const char16_t> from{ begin, end };\n+    if (read_utf16_bom(from, mode) == little_endian)\n+      mode = codecvt_mode(mode & little_endian);\n+    maxcode = std::max(max_single_utf16_unit, maxcode);\n+    char32_t c = 0;\n+    while (max-- && c <= maxcode)\n+      c = read_utf16_code_point(from, maxcode, mode);\n+    return from.next;\n+  }\n+\n+  const char*\n+  ucs2_span(const char* begin, const char* end, size_t max,\n+            char32_t maxcode, codecvt_mode mode)\n+  {\n+    range<const char> from{ begin, end };\n+    read_utf8_bom(from, mode);\n+    maxcode = std::max(max_single_utf16_unit, maxcode);\n+    char32_t c = 0;\n+    while (max-- && c <= maxcode)\n+      c = read_utf8_code_point(from, maxcode);\n+    return from.next;\n+  }\n+\n+  // return pos such that [begin,pos) is valid UCS-4 string no longer than max\n+  const char*\n+  ucs4_span(const char* begin, const char* end, size_t max,\n+            char32_t maxcode = max_code_point, codecvt_mode mode = {})\n+  {\n+    range<const char> from{ begin, end };\n+    read_utf8_bom(from, mode);\n+    char32_t c = 0;\n+    while (max-- && c <= maxcode)\n+      c = read_utf8_code_point(from, maxcode);\n+    return from.next;\n+  }\n+\n+  // return pos such that [begin,pos) is valid UCS-4 string no longer than max\n+  const char16_t*\n+  ucs4_span(const char16_t* begin, const char16_t* end, size_t max,\n+            char32_t maxcode = max_code_point, codecvt_mode mode = {})\n+  {\n+    range<const char16_t> from{ begin, end };\n+    if (read_utf16_bom(from, mode) == little_endian)\n+      mode = codecvt_mode(mode & little_endian);\n+    char32_t c = 0;\n+    while (max-- && c <= maxcode)\n+      c = read_utf16_code_point(from, maxcode, mode);\n+    return from.next;\n   }\n }\n \n@@ -376,7 +637,8 @@ codecvt<char16_t, char, mbstate_t>::\n do_length(state_type&, const extern_type* __from,\n \t  const extern_type* __end, size_t __max) const\n {\n-  return utf16_len(__from, __end, __max);\n+  __end = utf16_span(__from, __end, __max);\n+  return __end - __from;\n }\n \n int\n@@ -446,13 +708,698 @@ codecvt<char32_t, char, mbstate_t>::\n do_length(state_type&, const extern_type* __from,\n \t  const extern_type* __end, size_t __max) const\n {\n-  return ucs4_len(__from, __end, __max);\n+  __end = ucs4_span(__from, __end, __max);\n+  return __end - __from;\n }\n \n int\n codecvt<char32_t, char, mbstate_t>::do_max_length() const throw()\n { return 4; }\n \n+// Define members of codecvt_utf8<char16_t> base class implementation.\n+// Converts from UTF-8 to UCS-2.\n+\n+__codecvt_utf8_base<char16_t>::~__codecvt_utf8_base() { }\n+\n+codecvt_base::result\n+__codecvt_utf8_base<char16_t>::\n+do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n+       const intern_type*& __from_next,\n+       extern_type* __to, extern_type* __to_end,\n+       extern_type*& __to_next) const\n+{\n+  range<const char16_t> from{ __from, __from_end };\n+  range<char> to{ __to, __to_end };\n+  auto res = ucs2_out(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_base<char16_t>::\n+do_unshift(state_type&, extern_type* __to, extern_type*,\n+\t   extern_type*& __to_next) const\n+{\n+  __to_next = __to;\n+  return noconv;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_base<char16_t>::\n+do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n+      const extern_type*& __from_next,\n+      intern_type* __to, intern_type* __to_end,\n+      intern_type*& __to_next) const\n+{\n+  range<const char> from{ __from, __from_end };\n+  range<char16_t> to{ __to, __to_end };\n+  auto res = ucs2_in(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+int\n+__codecvt_utf8_base<char16_t>::do_encoding() const throw()\n+{ return 0; }\n+\n+bool\n+__codecvt_utf8_base<char16_t>::do_always_noconv() const throw()\n+{ return false; }\n+\n+int\n+__codecvt_utf8_base<char16_t>::\n+do_length(state_type&, const extern_type* __from,\n+\t  const extern_type* __end, size_t __max) const\n+{\n+  __end = ucs2_span(__from, __end, __max, _M_maxcode, _M_mode);\n+  return __end - __from;\n+}\n+\n+int\n+__codecvt_utf8_base<char16_t>::do_max_length() const throw()\n+{ return 3; }\n+\n+// Define members of codecvt_utf8<char32_t> base class implementation.\n+// Converts from UTF-8 to UTF-32 (aka UCS-4).\n+\n+__codecvt_utf8_base<char32_t>::~__codecvt_utf8_base() { }\n+\n+codecvt_base::result\n+__codecvt_utf8_base<char32_t>::\n+do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n+       const intern_type*& __from_next,\n+       extern_type* __to, extern_type* __to_end,\n+       extern_type*& __to_next) const\n+{\n+  range<const char32_t> from{ __from, __from_end };\n+  range<char> to{ __to, __to_end };\n+  auto res = ucs4_out(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_base<char32_t>::\n+do_unshift(state_type&, extern_type* __to, extern_type*,\n+\t   extern_type*& __to_next) const\n+{\n+  __to_next = __to;\n+  return noconv;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_base<char32_t>::\n+do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n+      const extern_type*& __from_next,\n+      intern_type* __to, intern_type* __to_end,\n+      intern_type*& __to_next) const\n+{\n+  range<const char> from{ __from, __from_end };\n+  range<char32_t> to{ __to, __to_end };\n+  auto res = ucs4_in(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+int\n+__codecvt_utf8_base<char32_t>::do_encoding() const throw()\n+{ return 0; }\n+\n+bool\n+__codecvt_utf8_base<char32_t>::do_always_noconv() const throw()\n+{ return false; }\n+\n+int\n+__codecvt_utf8_base<char32_t>::\n+do_length(state_type&, const extern_type* __from,\n+\t  const extern_type* __end, size_t __max) const\n+{\n+  __end = ucs4_span(__from, __end, __max, _M_maxcode, _M_mode);\n+  return __end - __from;\n+}\n+\n+int\n+__codecvt_utf8_base<char32_t>::do_max_length() const throw()\n+{ return 4; }\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+// Define members of codecvt_utf8<wchar_t> base class implementation.\n+// Converts from UTF-8 to UCS-2 or UCS-4 depending on sizeof(wchar_t).\n+\n+__codecvt_utf8_base<wchar_t>::~__codecvt_utf8_base() { }\n+\n+codecvt_base::result\n+__codecvt_utf8_base<wchar_t>::\n+do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n+       const intern_type*& __from_next,\n+       extern_type* __to, extern_type* __to_end,\n+       extern_type*& __to_next) const\n+{\n+  range<char> to{ __to, __to_end };\n+#if __SIZEOF_WCHAR_T__ == 2\n+  range<const char16_t> from{\n+    reinterpret_cast<const char16_t*>(__from),\n+    reinterpret_cast<const char16_t*>(__from_end)\n+  };\n+  auto res = ucs2_out(from, to, _M_maxcode, _M_mode);\n+#elif __SIZEOF_WCHAR_T__ == 4\n+  range<const char32_t> from{\n+    reinterpret_cast<const char32_t*>(__from),\n+    reinterpret_cast<const char32_t*>(__from_end)\n+  };\n+  auto res = ucs4_out(from, to, _M_maxcode, _M_mode);\n+#else\n+  return codecvt_base::error;\n+#endif\n+  __from_next = reinterpret_cast<const wchar_t*>(from.next);\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_base<wchar_t>::\n+do_unshift(state_type&, extern_type* __to, extern_type*,\n+\t   extern_type*& __to_next) const\n+{\n+  __to_next = __to;\n+  return noconv;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_base<wchar_t>::\n+do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n+      const extern_type*& __from_next,\n+      intern_type* __to, intern_type* __to_end,\n+      intern_type*& __to_next) const\n+{\n+  range<const char> from{ __from, __from_end };\n+#if __SIZEOF_WCHAR_T__ == 2\n+  range<char16_t> to{\n+    reinterpret_cast<char16_t*>(__to),\n+    reinterpret_cast<char16_t*>(__to_end)\n+  };\n+  auto res = ucs2_in(from, to, _M_maxcode, _M_mode);\n+#elif __SIZEOF_WCHAR_T__ == 4\n+  range<char32_t> to{\n+    reinterpret_cast<char32_t*>(__to),\n+    reinterpret_cast<char32_t*>(__to_end)\n+  };\n+  auto res = ucs4_in(from, to, _M_maxcode, _M_mode);\n+#else\n+  return codecvt_base::error;\n+#endif\n+  __from_next = from.next;\n+  __to_next = reinterpret_cast<wchar_t*>(to.next);\n+  return res;\n+}\n+\n+int\n+__codecvt_utf8_base<wchar_t>::do_encoding() const throw()\n+{ return 0; }\n+\n+bool\n+__codecvt_utf8_base<wchar_t>::do_always_noconv() const throw()\n+{ return false; }\n+\n+int\n+__codecvt_utf8_base<wchar_t>::\n+do_length(state_type&, const extern_type* __from,\n+\t  const extern_type* __end, size_t __max) const\n+{\n+#if __SIZEOF_WCHAR_T__ == 2\n+  __end = ucs2_span(__from, __end, __max, _M_maxcode, _M_mode);\n+#elif __SIZEOF_WCHAR_T__ == 4\n+  __end = ucs4_span(__from, __end, __max, _M_maxcode, _M_mode);\n+#else\n+  __end = __from;\n+#endif\n+  return __end - __from;\n+}\n+\n+int\n+__codecvt_utf8_base<wchar_t>::do_max_length() const throw()\n+{ return 4; }\n+#endif\n+\n+// Define members of codecvt_utf16<char16_t> base class implementation.\n+// Converts from UTF-16 to UCS-2.\n+\n+__codecvt_utf16_base<char16_t>::~__codecvt_utf16_base() { }\n+\n+codecvt_base::result\n+__codecvt_utf16_base<char16_t>::\n+do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n+       const intern_type*& __from_next,\n+       extern_type* __to, extern_type* __to_end,\n+       extern_type*& __to_next) const\n+{\n+  range<const char16_t> from{ __from, __from_end };\n+  range<char16_t> to{\n+    reinterpret_cast<char16_t*>(__to),\n+    reinterpret_cast<char16_t*>(__to_end)\n+  };\n+  auto res = ucs2_out(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = reinterpret_cast<char*>(to.next);\n+  return res;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf16_base<char16_t>::\n+do_unshift(state_type&, extern_type* __to, extern_type*,\n+\t   extern_type*& __to_next) const\n+{\n+  __to_next = __to;\n+  return noconv;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf16_base<char16_t>::\n+do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n+      const extern_type*& __from_next,\n+      intern_type* __to, intern_type* __to_end,\n+      intern_type*& __to_next) const\n+{\n+  range<const char16_t> from{\n+    reinterpret_cast<const char16_t*>(__from),\n+    reinterpret_cast<const char16_t*>(__from_end)\n+  };\n+  range<char16_t> to{ __to, __to_end };\n+  auto res = ucs2_in(from, to, _M_maxcode, _M_mode);\n+  __from_next = reinterpret_cast<const char*>(from.next);\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+int\n+__codecvt_utf16_base<char16_t>::do_encoding() const throw()\n+{ return 1; }\n+\n+bool\n+__codecvt_utf16_base<char16_t>::do_always_noconv() const throw()\n+{ return false; }\n+\n+int\n+__codecvt_utf16_base<char16_t>::\n+do_length(state_type&, const extern_type* __from,\n+\t  const extern_type* __end, size_t __max) const\n+{\n+  auto next = reinterpret_cast<const char16_t*>(__from);\n+  next = ucs2_span(next, reinterpret_cast<const char16_t*>(__end), __max,\n+\t\t   _M_maxcode, _M_mode);\n+  return reinterpret_cast<const char*>(next) - __from;\n+}\n+\n+int\n+__codecvt_utf16_base<char16_t>::do_max_length() const throw()\n+{ return 3; }\n+\n+// Define members of codecvt_utf16<char32_t> base class implementation.\n+// Converts from UTF-16 to UTF-32 (aka UCS-4).\n+\n+__codecvt_utf16_base<char32_t>::~__codecvt_utf16_base() { }\n+\n+codecvt_base::result\n+__codecvt_utf16_base<char32_t>::\n+do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n+       const intern_type*& __from_next,\n+       extern_type* __to, extern_type* __to_end,\n+       extern_type*& __to_next) const\n+{\n+  range<const char32_t> from{ __from, __from_end };\n+  range<char16_t> to{\n+    reinterpret_cast<char16_t*>(__to),\n+    reinterpret_cast<char16_t*>(__to_end)\n+  };\n+  auto res = ucs4_out(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = reinterpret_cast<char*>(to.next);\n+  return res;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf16_base<char32_t>::\n+do_unshift(state_type&, extern_type* __to, extern_type*,\n+\t   extern_type*& __to_next) const\n+{\n+  __to_next = __to;\n+  return noconv;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf16_base<char32_t>::\n+do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n+      const extern_type*& __from_next,\n+      intern_type* __to, intern_type* __to_end,\n+      intern_type*& __to_next) const\n+{\n+  range<const char16_t> from{\n+    reinterpret_cast<const char16_t*>(__from),\n+    reinterpret_cast<const char16_t*>(__from_end)\n+  };\n+  range<char32_t> to{ __to, __to_end };\n+  auto res = ucs4_in(from, to, _M_maxcode, _M_mode);\n+  __from_next = reinterpret_cast<const char*>(from.next);\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+int\n+__codecvt_utf16_base<char32_t>::do_encoding() const throw()\n+{ return 0; }\n+\n+bool\n+__codecvt_utf16_base<char32_t>::do_always_noconv() const throw()\n+{ return false; }\n+\n+int\n+__codecvt_utf16_base<char32_t>::\n+do_length(state_type&, const extern_type* __from,\n+\t  const extern_type* __end, size_t __max) const\n+{\n+  auto next = reinterpret_cast<const char16_t*>(__from);\n+  next = ucs4_span(next, reinterpret_cast<const char16_t*>(__end), __max,\n+\t\t   _M_maxcode, _M_mode);\n+  return reinterpret_cast<const char*>(next) - __from;\n+}\n+\n+int\n+__codecvt_utf16_base<char32_t>::do_max_length() const throw()\n+{ return 3; }\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+// Define members of codecvt_utf16<wchar_t> base class implementation.\n+// Converts from UTF-8 to UCS-2 or UCS-4 depending on sizeof(wchar_t).\n+\n+__codecvt_utf16_base<wchar_t>::~__codecvt_utf16_base() { }\n+\n+codecvt_base::result\n+__codecvt_utf16_base<wchar_t>::\n+do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n+       const intern_type*& __from_next,\n+       extern_type* __to, extern_type* __to_end,\n+       extern_type*& __to_next) const\n+{\n+  range<char> to{ __to, __to_end };\n+#if __SIZEOF_WCHAR_T__ == 2\n+  range<const char16_t> from{\n+    reinterpret_cast<const char16_t*>(__from),\n+    reinterpret_cast<const char16_t*>(__from_end)\n+  };\n+  auto res = ucs2_out(from, to, _M_maxcode, _M_mode);\n+#elif __SIZEOF_WCHAR_T__ == 4\n+  range<const char32_t> from{\n+    reinterpret_cast<const char32_t*>(__from),\n+    reinterpret_cast<const char32_t*>(__from_end)\n+  };\n+  auto res = ucs4_out(from, to, _M_maxcode, _M_mode);\n+#else\n+  return codecvt_base::error;\n+#endif\n+  __from_next = reinterpret_cast<const wchar_t*>(from.next);\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf16_base<wchar_t>::\n+do_unshift(state_type&, extern_type* __to, extern_type*,\n+\t   extern_type*& __to_next) const\n+{\n+  __to_next = __to;\n+  return noconv;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf16_base<wchar_t>::\n+do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n+      const extern_type*& __from_next,\n+      intern_type* __to, intern_type* __to_end,\n+      intern_type*& __to_next) const\n+{\n+  range<const char> from{ __from, __from_end };\n+#if __SIZEOF_WCHAR_T__ == 2\n+  range<char16_t> to{\n+    reinterpret_cast<char16_t*>(__to),\n+    reinterpret_cast<char16_t*>(__to_end)\n+  };\n+  auto res = ucs2_in(from, to, _M_maxcode, _M_mode);\n+#elif __SIZEOF_WCHAR_T__ == 4\n+  range<char32_t> to{\n+    reinterpret_cast<char32_t*>(__to),\n+    reinterpret_cast<char32_t*>(__to_end)\n+  };\n+  auto res = ucs4_in(from, to, _M_maxcode, _M_mode);\n+#else\n+  return codecvt_base::error;\n+#endif\n+  __from_next = from.next;\n+  __to_next = reinterpret_cast<wchar_t*>(to.next);\n+  return res;\n+}\n+\n+int\n+__codecvt_utf16_base<wchar_t>::do_encoding() const throw()\n+{ return 0; }\n+\n+bool\n+__codecvt_utf16_base<wchar_t>::do_always_noconv() const throw()\n+{ return false; }\n+\n+int\n+__codecvt_utf16_base<wchar_t>::\n+do_length(state_type&, const extern_type* __from,\n+\t  const extern_type* __end, size_t __max) const\n+{\n+  auto next = reinterpret_cast<const char16_t*>(__from);\n+#if __SIZEOF_WCHAR_T__ == 2\n+  next = ucs2_span(next, reinterpret_cast<const char16_t*>(__end), __max,\n+\t\t   _M_maxcode, _M_mode);\n+#elif __SIZEOF_WCHAR_T__ == 4\n+  next = ucs4_span(next, reinterpret_cast<const char16_t*>(__end), __max,\n+\t\t   _M_maxcode, _M_mode);\n+#endif\n+  return reinterpret_cast<const char*>(next) - __from;\n+}\n+\n+int\n+__codecvt_utf16_base<wchar_t>::do_max_length() const throw()\n+{ return 4; }\n+#endif\n+\n+// Define members of codecvt_utf8_utf16<char16_t> base class implementation.\n+// Converts from UTF-8 to UTF-16.\n+\n+__codecvt_utf8_utf16_base<char16_t>::~__codecvt_utf8_utf16_base() { }\n+\n+codecvt_base::result\n+__codecvt_utf8_utf16_base<char16_t>::\n+do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n+       const intern_type*& __from_next,\n+       extern_type* __to, extern_type* __to_end,\n+       extern_type*& __to_next) const\n+{\n+  range<const char16_t> from{ __from, __from_end };\n+  range<char> to{ __to, __to_end };\n+  auto res = utf16_out(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_utf16_base<char16_t>::\n+do_unshift(state_type&, extern_type* __to, extern_type*,\n+\t   extern_type*& __to_next) const\n+{\n+  __to_next = __to;\n+  return noconv;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_utf16_base<char16_t>::\n+do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n+      const extern_type*& __from_next,\n+      intern_type* __to, intern_type* __to_end,\n+      intern_type*& __to_next) const\n+{\n+  range<const char> from{ __from, __from_end };\n+  range<char16_t> to{ __to, __to_end };\n+  auto res = utf16_in(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+int\n+__codecvt_utf8_utf16_base<char16_t>::do_encoding() const throw()\n+{ return 0; }\n+\n+bool\n+__codecvt_utf8_utf16_base<char16_t>::do_always_noconv() const throw()\n+{ return false; }\n+\n+int\n+__codecvt_utf8_utf16_base<char16_t>::\n+do_length(state_type&, const extern_type* __from,\n+\t  const extern_type* __end, size_t __max) const\n+{\n+  __end = utf16_span(__from, __end, __max, _M_maxcode, _M_mode);\n+  return __end - __from;\n+}\n+\n+int\n+__codecvt_utf8_utf16_base<char16_t>::do_max_length() const throw()\n+{\n+  // Any valid UTF-8 sequence of 3 bytes fits in a single 16-bit code unit,\n+  // whereas 4 byte sequences require two 16-bit code units.\n+  return 3;\n+}\n+\n+// Define members of codecvt_utf8_utf16<char32_t> base class implementation.\n+// Converts from UTF-8 to UTF-16.\n+\n+__codecvt_utf8_utf16_base<char32_t>::~__codecvt_utf8_utf16_base() { }\n+\n+codecvt_base::result\n+__codecvt_utf8_utf16_base<char32_t>::\n+do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n+       const intern_type*& __from_next,\n+       extern_type* __to, extern_type* __to_end,\n+       extern_type*& __to_next) const\n+{\n+  range<const char32_t> from{ __from, __from_end };\n+  range<char> to{ __to, __to_end };\n+  auto res = utf16_out(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_utf16_base<char32_t>::\n+do_unshift(state_type&, extern_type* __to, extern_type*,\n+\t   extern_type*& __to_next) const\n+{\n+  __to_next = __to;\n+  return noconv;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_utf16_base<char32_t>::\n+do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n+      const extern_type*& __from_next,\n+      intern_type* __to, intern_type* __to_end,\n+      intern_type*& __to_next) const\n+{\n+  range<const char> from{ __from, __from_end };\n+  range<char32_t> to{ __to, __to_end };\n+  auto res = utf16_in(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+int\n+__codecvt_utf8_utf16_base<char32_t>::do_encoding() const throw()\n+{ return 0; }\n+\n+bool\n+__codecvt_utf8_utf16_base<char32_t>::do_always_noconv() const throw()\n+{ return false; }\n+\n+int\n+__codecvt_utf8_utf16_base<char32_t>::\n+do_length(state_type&, const extern_type* __from,\n+\t  const extern_type* __end, size_t __max) const\n+{\n+  __end = utf16_span(__from, __end, __max, _M_maxcode, _M_mode);\n+  return __end - __from;\n+}\n+\n+int\n+__codecvt_utf8_utf16_base<char32_t>::do_max_length() const throw()\n+{\n+  // Any valid UTF-8 sequence of 3 bytes fits in a single 16-bit code unit,\n+  // whereas 4 byte sequences require two 16-bit code units.\n+  return 3;\n+}\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+// Define members of codecvt_utf8_utf16<wchar_t> base class implementation.\n+// Converts from UTF-8 to UTF-16.\n+\n+__codecvt_utf8_utf16_base<wchar_t>::~__codecvt_utf8_utf16_base() { }\n+\n+codecvt_base::result\n+__codecvt_utf8_utf16_base<wchar_t>::\n+do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n+       const intern_type*& __from_next,\n+       extern_type* __to, extern_type* __to_end,\n+       extern_type*& __to_next) const\n+{\n+  range<const wchar_t> from{ __from, __from_end };\n+  range<char> to{ __to, __to_end };\n+  auto res = utf16_out(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_utf16_base<wchar_t>::\n+do_unshift(state_type&, extern_type* __to, extern_type*,\n+\t   extern_type*& __to_next) const\n+{\n+  __to_next = __to;\n+  return noconv;\n+}\n+\n+codecvt_base::result\n+__codecvt_utf8_utf16_base<wchar_t>::\n+do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n+      const extern_type*& __from_next,\n+      intern_type* __to, intern_type* __to_end,\n+      intern_type*& __to_next) const\n+{\n+  range<const char> from{ __from, __from_end };\n+  range<wchar_t> to{ __to, __to_end };\n+  auto res = utf16_in(from, to, _M_maxcode, _M_mode);\n+  __from_next = from.next;\n+  __to_next = to.next;\n+  return res;\n+}\n+\n+int\n+__codecvt_utf8_utf16_base<wchar_t>::do_encoding() const throw()\n+{ return 0; }\n+\n+bool\n+__codecvt_utf8_utf16_base<wchar_t>::do_always_noconv() const throw()\n+{ return false; }\n+\n+int\n+__codecvt_utf8_utf16_base<wchar_t>::\n+do_length(state_type&, const extern_type* __from,\n+\t  const extern_type* __end, size_t __max) const\n+{\n+  __end = utf16_span(__from, __end, __max, _M_maxcode, _M_mode);\n+  return __end - __from;\n+}\n+\n+int\n+__codecvt_utf8_utf16_base<wchar_t>::do_max_length() const throw()\n+{\n+  // Any valid UTF-8 sequence of 3 bytes fits in a single 16-bit code unit,\n+  // whereas 4 byte sequences require two 16-bit code units.\n+  return 3;\n+}\n+#endif\n+\n inline template class __codecvt_abstract_base<char16_t, char, mbstate_t>;\n inline template class __codecvt_abstract_base<char32_t, char, mbstate_t>;\n "}, {"sha": "38bb393aed83a7c234ceb1110f888f826e261d34", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf16/requirements/1.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2Frequirements%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2Frequirements%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2Frequirements%2F1.cc?ref=28af1fb39dfbf903ccafeafda927d280fd8768d8", "patch": "@@ -0,0 +1,37 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-require-cstdint \"\" }\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+#include <codecvt>\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+\n+template<typename C>\n+  using codecvt = std::codecvt<C, char, std::mbstate_t>;\n+\n+using std::is_base_of;\n+\n+static_assert(\n+    is_base_of<codecvt<char16_t>, std::codecvt_utf16<char16_t>>::value,\n+    \"codecvt_utf16<char16_t> has wrong base class\");\n+\n+static_assert(\n+    is_base_of<codecvt<char32_t>, std::codecvt_utf16<char32_t>>::value,\n+    \"codecvt_utf16<char32_t> has wrong base class\");"}, {"sha": "6bc241858ad414972a4352ba36a4c53ae929c0fb", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/requirements/1.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf8%2Frequirements%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf8%2Frequirements%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf8%2Frequirements%2F1.cc?ref=28af1fb39dfbf903ccafeafda927d280fd8768d8", "patch": "@@ -0,0 +1,37 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-require-cstdint \"\" }\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+#include <codecvt>\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+\n+template<typename C>\n+  using codecvt = std::codecvt<C, char, std::mbstate_t>;\n+\n+using std::is_base_of;\n+\n+static_assert(\n+    is_base_of<codecvt<char16_t>, std::codecvt_utf8<char16_t>>::value,\n+    \"codecvt_utf8<char16_t> has wrong base class\");\n+\n+static_assert(\n+    is_base_of<codecvt<char32_t>, std::codecvt_utf8<char32_t>>::value,\n+    \"codecvt_utf8<char32_t> has wrong base class\");"}, {"sha": "5e5f8dd9fee67baee3875a5e83166b38d5eab61b", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/requirements/1.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf8_utf16%2Frequirements%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28af1fb39dfbf903ccafeafda927d280fd8768d8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf8_utf16%2Frequirements%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf8_utf16%2Frequirements%2F1.cc?ref=28af1fb39dfbf903ccafeafda927d280fd8768d8", "patch": "@@ -0,0 +1,37 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-require-cstdint \"\" }\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+#include <codecvt>\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+\n+template<typename C>\n+  using codecvt = std::codecvt<C, char, std::mbstate_t>;\n+\n+using std::is_base_of;\n+\n+static_assert(\n+    is_base_of<codecvt<char16_t>, std::codecvt_utf8_utf16<char16_t>>::value,\n+    \"codecvt_utf8_utf16<char16_t> has wrong base class\");\n+\n+static_assert(\n+    is_base_of<codecvt<char32_t>, std::codecvt_utf8_utf16<char32_t>>::value,\n+    \"codecvt_utf8_utf16<char32_t> has wrong base class\");"}]}