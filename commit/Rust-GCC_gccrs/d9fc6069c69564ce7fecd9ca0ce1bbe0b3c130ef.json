{"sha": "d9fc6069c69564ce7fecd9ca0ce1bbe0b3c130ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDlmYzYwNjljNjk1NjRjZTdmZWNkOWNhMGNlMWJiZTBiM2MxMzBlZg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-09-15T02:03:22Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-09-15T02:03:22Z"}, "message": "(valid_compound_expr_initializer): New function.\n\n(digest_init): Handle compound expressions as initializers when\npedantic.\n\nFrom-SVN: r5323", "tree": {"sha": "da37e4404423e54044b0d16536a0cc4b463ec6a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da37e4404423e54044b0d16536a0cc4b463ec6a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9fc6069c69564ce7fecd9ca0ce1bbe0b3c130ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9fc6069c69564ce7fecd9ca0ce1bbe0b3c130ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9fc6069c69564ce7fecd9ca0ce1bbe0b3c130ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9fc6069c69564ce7fecd9ca0ce1bbe0b3c130ef/comments", "author": null, "committer": null, "parents": [{"sha": "179bb78c239573cbd4ea5b8577c56ba9b755183f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/179bb78c239573cbd4ea5b8577c56ba9b755183f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/179bb78c239573cbd4ea5b8577c56ba9b755183f"}], "stats": {"total": 46, "additions": 45, "deletions": 1}, "files": [{"sha": "3dd7288a68a93ea391934a92efb4785f3ec28b23", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9fc6069c69564ce7fecd9ca0ce1bbe0b3c130ef/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9fc6069c69564ce7fecd9ca0ce1bbe0b3c130ef/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=d9fc6069c69564ce7fecd9ca0ce1bbe0b3c130ef", "patch": "@@ -4579,6 +4579,32 @@ initializer_constant_valid_p (value, endtype)\n \n   return 0;\n }\n+\n+/* If VALUE is a compound expr all of whose expressions are constant, then\n+   return its value.  Otherwise, return error_mark_node.\n+\n+   This is for handling COMPOUND_EXPRs as initializer elements\n+   which is allowed with a warning when -pedantic is specified.  */\n+\n+static tree\n+valid_compound_expr_initializer (value, endtype)\n+     tree value;\n+     tree endtype;\n+{\n+  if (TREE_CODE (value) == COMPOUND_EXPR)\n+    {\n+      if (valid_compound_expr_initializer (TREE_OPERAND (value, 0), endtype)\n+\t  == error_mark_node)\n+\treturn error_mark_node;\n+      return valid_compound_expr_initializer (TREE_OPERAND (value, 1),\n+\t\t\t\t\t      endtype);\n+    }\n+  else if (! TREE_CONSTANT (value)\n+\t   && ! initializer_constant_valid_p (value, endtype))\n+    return error_mark_node;\n+  else\n+    return value;\n+}\n \f\n /* Perform appropriate conversions on the initial value of a variable,\n    store it in the declaration DECL,\n@@ -4969,7 +4995,25 @@ digest_init (type, init, require_constant, constructor_constant)\n \t  && TREE_CODE (inside_init) == VAR_DECL)\n \tinside_init = decl_constant_value (inside_init);\n \n-      if (require_constant && ! TREE_CONSTANT (inside_init))\n+      /* Compound expressions can only occur here if -pedantic or\n+\t -pedantic-errors is specified.  In the later case, we always want\n+\t an error.  In the former case, we simply want a warning.  */\n+      if (require_constant && pedantic\n+\t  && TREE_CODE (inside_init) == COMPOUND_EXPR)\n+\t{\n+\t  inside_init\n+\t    = valid_compound_expr_initializer (inside_init,\n+\t\t\t\t\t       TREE_TYPE (inside_init));\n+\t  if (inside_init == error_mark_node)\n+\t    error_init (\"initializer element%s is not constant\",\n+\t\t\t\" for `%s'\", NULL);\n+\t  else\n+\t    pedwarn_init (\"initializer element%s is not constant\",\n+\t\t\t  \" for `%s'\", NULL);\n+\t  if (flag_pedantic_errors)\n+\t    inside_init = error_mark_node;\n+\t}\n+      else if (require_constant && ! TREE_CONSTANT (inside_init))\n \t{\n \t  error_init (\"initializer element%s is not constant\",\n \t\t      \" for `%s'\", NULL);"}]}