{"sha": "04482133da7cc90eb44c16e1abe6223e2014fc1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ0ODIxMzNkYTdjYzkwZWI0NGMxNmUxYWJlNjIyM2UyMDE0ZmMxZQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2004-12-13T21:03:47Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2004-12-13T21:03:47Z"}, "message": "re PR tree-optimization/16951 (ICE in make_decl_rtl with recursion in C++ constructor (-O1))\n\ngcc/ChangeLog:\nPR tree-opt/16951\n* tree-inline.c (setup_one_parameter): Don't directly map a\nparameter to the address of another variable of the same\nfunction.\ngcc/testsuite/ChangeLog:\nPR tree-opt/16951\n* gcc.c-torture/compile/20041211-1.c: New.\n\nFrom-SVN: r92106", "tree": {"sha": "acff1e0e903850d88412936e41046a30e559dc43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acff1e0e903850d88412936e41046a30e559dc43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04482133da7cc90eb44c16e1abe6223e2014fc1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04482133da7cc90eb44c16e1abe6223e2014fc1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04482133da7cc90eb44c16e1abe6223e2014fc1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04482133da7cc90eb44c16e1abe6223e2014fc1e/comments", "author": null, "committer": null, "parents": [{"sha": "b4418614a16dd989b74e2454cb1099b5913895fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4418614a16dd989b74e2454cb1099b5913895fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4418614a16dd989b74e2454cb1099b5913895fa"}], "stats": {"total": 49, "additions": 48, "deletions": 1}, "files": [{"sha": "e12edaf40d9ec80aab2e0eb22b2ff42beb3ece51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04482133da7cc90eb44c16e1abe6223e2014fc1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04482133da7cc90eb44c16e1abe6223e2014fc1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=04482133da7cc90eb44c16e1abe6223e2014fc1e", "patch": "@@ -1,3 +1,10 @@\n+2004-12-13  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR tree-opt/16951\n+\t* tree-inline.c (setup_one_parameter): Don't directly map a\n+\tparameter to the address of another variable of the same\n+\tfunction.\n+\n 2004-13-12  Steven Bosscher  <stevenb@suse.de>\n \n \t* basic-block.h (PROP_POSTRELOAD): Do not include PROP_AUTOINC, we"}, {"sha": "647411ef7fe05fed28e97e5c3934643b0f244b79", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04482133da7cc90eb44c16e1abe6223e2014fc1e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04482133da7cc90eb44c16e1abe6223e2014fc1e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=04482133da7cc90eb44c16e1abe6223e2014fc1e", "patch": "@@ -1,3 +1,8 @@\n+2004-12-13  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR tree-opt/16951\n+\t* gcc.c-torture/compile/20041211-1.c: New.\n+\n 2004-12-12  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR middle-end/17564"}, {"sha": "5b9c1d069d9530aa74dad8ed271e5e073f1f7f8c", "filename": "gcc/testsuite/gcc.c-torture/compile/20041211-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04482133da7cc90eb44c16e1abe6223e2014fc1e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20041211-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04482133da7cc90eb44c16e1abe6223e2014fc1e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20041211-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20041211-1.c?ref=04482133da7cc90eb44c16e1abe6223e2014fc1e", "patch": "@@ -0,0 +1,13 @@\n+/* PR tree-optimization/16951 */\n+\n+void dummy_use(const char *p);\n+\n+__inline void f(const char *const p) {\n+  const char q;\n+  dummy_use(p);\n+  f(&q);\n+}\n+\n+void crash() {\n+  f(0);\n+}"}, {"sha": "db2b2361874cbab83259787f640bd0a929fd7537", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04482133da7cc90eb44c16e1abe6223e2014fc1e/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04482133da7cc90eb44c16e1abe6223e2014fc1e/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=04482133da7cc90eb44c16e1abe6223e2014fc1e", "patch": "@@ -655,6 +655,22 @@ copy_body (inline_data *id)\n   return body;\n }\n \n+/* Return true if VALUE is an ADDR_EXPR of an automatic variable\n+   defined in function FN, or of a data member thereof.  */\n+\n+static bool\n+self_inlining_addr_expr (tree value, tree fn)\n+{\n+  tree var;\n+\n+  if (TREE_CODE (value) != ADDR_EXPR)\n+    return false;\n+\n+  var = get_base_address (TREE_OPERAND (value, 0));\n+\t      \n+  return var && lang_hooks.tree_inlining.auto_var_in_fn_p (var, fn);\n+}\n+\n static void\n setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n \t\t     tree *init_stmts, tree *vars, bool *gimplify_init_stmts_p)\n@@ -679,7 +695,13 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n \t It is not big deal to prohibit constant propagation here as\n \t we will constant propagate in DOM1 pass anyway.  */\n       if (is_gimple_min_invariant (value)\n-\t  && lang_hooks.types_compatible_p (TREE_TYPE (value), TREE_TYPE (p)))\n+\t  && lang_hooks.types_compatible_p (TREE_TYPE (value), TREE_TYPE (p))\n+\t  /* We have to be very careful about ADDR_EXPR.  Make sure\n+\t     the base variable isn't a local variable of the inlined\n+\t     function, e.g., when doing recursive inlining, direct or\n+\t     mutually-recursive or whatever, which is why we don't\n+\t     just test whether fn == current_function_decl.  */\n+\t  && ! self_inlining_addr_expr (value, fn))\n \t{\n \t  insert_decl_map (id, p, value);\n \t  return;"}]}