{"sha": "d5c724c4e7d07d86cb9d70f712586d992817ff85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVjNzI0YzRlN2QwN2Q4NmNiOWQ3MGY3MTI1ODZkOTkyODE3ZmY4NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-12T11:58:29Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-12T11:58:29Z"}, "message": "(dialect_number): New variable.\n\n(init_final): Initialize it.\n(output_asm_insn, asm_fprintf): Support ASSEMBLER_DIALECT.\n\nFrom-SVN: r5744", "tree": {"sha": "95f43024f7623c82ba1c0b6c61ee30143c86fc1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95f43024f7623c82ba1c0b6c61ee30143c86fc1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5c724c4e7d07d86cb9d70f712586d992817ff85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c724c4e7d07d86cb9d70f712586d992817ff85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c724c4e7d07d86cb9d70f712586d992817ff85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c724c4e7d07d86cb9d70f712586d992817ff85/comments", "author": null, "committer": null, "parents": [{"sha": "bfe3c3615affe97ab94036b5274ff51afc485e1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe3c3615affe97ab94036b5274ff51afc485e1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfe3c3615affe97ab94036b5274ff51afc485e1c"}], "stats": {"total": 251, "additions": 156, "deletions": 95}, "files": [{"sha": "4c19f113ab54f1a64da29846d0cc3c56e4a8ad78", "filename": "gcc/final.c", "status": "modified", "additions": 156, "deletions": 95, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c724c4e7d07d86cb9d70f712586d992817ff85/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c724c4e7d07d86cb9d70f712586d992817ff85/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=d5c724c4e7d07d86cb9d70f712586d992817ff85", "patch": "@@ -1,5 +1,5 @@\n /* Convert RTL to assembler code and output it, for GNU compiler.\n-   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1989, 1992, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -241,6 +241,12 @@ static int app_on;\n \n rtx final_sequence;\n \n+#ifdef ASSEMBLER_DIALECT\n+\n+/* Number of the assembler dialect to use, starting at 0.  */\n+static int dialect_number;\n+#endif\n+\n /* Indexed by line number, nonzero if there is a note for that line.  */\n \n static char *line_note_exists;\n@@ -287,6 +293,10 @@ init_final (filename)\n   max_block_depth = 20;\n   pending_blocks = (int *) xmalloc (20 * sizeof *pending_blocks);\n   final_sequence = 0;\n+\n+#ifdef ASSEMBLER_DIALECT\n+  dialect_number = ASSEMBLER_DIALECT;\n+#endif\n }\n \n /* Called at end of source file,\n@@ -2298,7 +2308,7 @@ output_asm_insn (template, operands)\n      rtx *operands;\n {\n   register char *p;\n-  register int c;\n+  register int c, i;\n \n   /* An insn may return a null string template\n      in a case where no assembler code is needed.  */\n@@ -2313,106 +2323,130 @@ output_asm_insn (template, operands)\n #endif\n \n   while (c = *p++)\n-    {\n+    switch (c)\n+      {\n #ifdef ASM_OUTPUT_OPCODE\n-      if (c == '\\n')\n-\t{\n-\t  putc (c, asm_out_file);\n-\t  while ((c = *p) == '\\t')\n-\t    {\n-\t      putc (c, asm_out_file);\n-\t      p++;\n-\t    }\n-\t  ASM_OUTPUT_OPCODE (asm_out_file, p);\n-\t}\n-      else\n-#endif\n-      if (c != '%')\n+      case '\\n':\n \tputc (c, asm_out_file);\n-      else\n-\t{\n-\t  /* %% outputs a single %.  */\n-\t  if (*p == '%')\n-\t    {\n-\t      p++;\n-\t      putc (c, asm_out_file);\n-\t    }\n-\t  /* %= outputs a number which is unique to each insn in the entire\n-\t     compilation.  This is useful for making local labels that are\n-\t     referred to more than once in a given insn.  */\n-\t  else if (*p == '=')\n-\t    {\n+\twhile ((c = *p) == '\\t')\n+\t  {\n+\t    putc (c, asm_out_file);\n+\t    p++;\n+\t  }\n+\tASM_OUTPUT_OPCODE (asm_out_file, p);\n+\tbreak;\n+#endif\n+\n+#ifdef ASSEMBLER_DIALECT\n+      case '{':\n+\t/* If we want the first dialect, do nothing.  Otherwise, skip\n+\t   DIALECT_NUMBER of strings ending with '|'.  */\n+\tfor (i = 0; i < dialect_number; i++)\n+\t  {\n+\t    while (*p && *p++ != '|')\n+\t      ;\n+\n+\t    if (*p == '|')\n \t      p++;\n-\t      fprintf (asm_out_file, \"%d\", insn_counter);\n-\t    }\n-\t  /* % followed by a letter and some digits\n-\t     outputs an operand in a special way depending on the letter.\n-\t     Letters `acln' are implemented directly.\n-\t     Other letters are passed to `output_operand' so that\n-\t     the PRINT_OPERAND macro can define them.  */\n-\t  else if ((*p >= 'a' && *p <= 'z')\n-\t\t   || (*p >= 'A' && *p <= 'Z'))\n-\t    {\n-\t      int letter = *p++;\n-\t      c = atoi (p);\n-\n-\t      if (! (*p >= '0' && *p <= '9'))\n-\t\toutput_operand_lossage (\"operand number missing after %-letter\");\n-\t      else if (this_is_asm_operands && c >= (unsigned) insn_noperands)\n-\t\toutput_operand_lossage (\"operand number out of range\");\n-\t      else if (letter == 'l')\n-\t\toutput_asm_label (operands[c]);\n-\t      else if (letter == 'a')\n-\t\toutput_address (operands[c]);\n-\t      else if (letter == 'c')\n-\t\t{\n-\t\t  if (CONSTANT_ADDRESS_P (operands[c]))\n-\t\t    output_addr_const (asm_out_file, operands[c]);\n-\t\t  else\n-\t\t    output_operand (operands[c], 'c');\n-\t\t}\n-\t      else if (letter == 'n')\n-\t\t{\n-\t\t  if (GET_CODE (operands[c]) == CONST_INT)\n-\t\t    fprintf (asm_out_file,\n+\t  }\n+\tbreak;\n+\n+      case '|':\n+\t/* Skip to close brace.  */\n+\twhile (*p && *p++ != '}')\n+\t  ;\n+\tbreak;\n+\n+      case '}':\n+\tbreak;\n+#endif\n+\n+      case '%':\n+\t/* %% outputs a single %.  */\n+\tif (*p == '%')\n+\t  {\n+\t    p++;\n+\t    putc (c, asm_out_file);\n+\t  }\n+\t/* %= outputs a number which is unique to each insn in the entire\n+\t   compilation.  This is useful for making local labels that are\n+\t   referred to more than once in a given insn.  */\n+\telse if (*p == '=')\n+\t  {\n+\t    p++;\n+\t    fprintf (asm_out_file, \"%d\", insn_counter);\n+\t  }\n+\t/* % followed by a letter and some digits\n+\t   outputs an operand in a special way depending on the letter.\n+\t   Letters `acln' are implemented directly.\n+\t   Other letters are passed to `output_operand' so that\n+\t   the PRINT_OPERAND macro can define them.  */\n+\telse if ((*p >= 'a' && *p <= 'z')\n+\t\t || (*p >= 'A' && *p <= 'Z'))\n+\t  {\n+\t    int letter = *p++;\n+\t    c = atoi (p);\n+\n+\t    if (! (*p >= '0' && *p <= '9'))\n+\t      output_operand_lossage (\"operand number missing after %-letter\");\n+\t    else if (this_is_asm_operands && c >= (unsigned) insn_noperands)\n+\t      output_operand_lossage (\"operand number out of range\");\n+\t    else if (letter == 'l')\n+\t      output_asm_label (operands[c]);\n+\t    else if (letter == 'a')\n+\t      output_address (operands[c]);\n+\t    else if (letter == 'c')\n+\t      {\n+\t\tif (CONSTANT_ADDRESS_P (operands[c]))\n+\t\t  output_addr_const (asm_out_file, operands[c]);\n+\t\telse\n+\t\t  output_operand (operands[c], 'c');\n+\t      }\n+\t    else if (letter == 'n')\n+\t      {\n+\t\tif (GET_CODE (operands[c]) == CONST_INT)\n+\t\t  fprintf (asm_out_file,\n #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\t\t\t     \"%d\",\n+\t\t\t   \"%d\",\n #else\n-\t\t\t     \"%ld\",\n+\t\t\t   \"%ld\",\n #endif\n-\t\t\t     - INTVAL (operands[c]));\n-\t\t  else\n-\t\t    {\n-\t\t      putc ('-', asm_out_file);\n-\t\t      output_addr_const (asm_out_file, operands[c]);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\toutput_operand (operands[c], letter);\n-\n-\t      while ((c = *p) >= '0' && c <= '9') p++;\n-\t    }\n-\t  /* % followed by a digit outputs an operand the default way.  */\n-\t  else if (*p >= '0' && *p <= '9')\n-\t    {\n-\t      c = atoi (p);\n-\t      if (this_is_asm_operands && c >= (unsigned) insn_noperands)\n-\t\toutput_operand_lossage (\"operand number out of range\");\n-\t      else\n-\t\toutput_operand (operands[c], 0);\n-\t      while ((c = *p) >= '0' && c <= '9') p++;\n-\t    }\n-\t  /* % followed by punctuation: output something for that\n-\t     punctuation character alone, with no operand.\n-\t     The PRINT_OPERAND macro decides what is actually done.  */\n+\t\t\t   - INTVAL (operands[c]));\n+\t\telse\n+\t\t  {\n+\t\t    putc ('-', asm_out_file);\n+\t\t    output_addr_const (asm_out_file, operands[c]);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      output_operand (operands[c], letter);\n+\t    \n+\t    while ((c = *p) >= '0' && c <= '9') p++;\n+\t  }\n+\t/* % followed by a digit outputs an operand the default way.  */\n+\telse if (*p >= '0' && *p <= '9')\n+\t  {\n+\t    c = atoi (p);\n+\t    if (this_is_asm_operands && c >= (unsigned) insn_noperands)\n+\t      output_operand_lossage (\"operand number out of range\");\n+\t    else\n+\t      output_operand (operands[c], 0);\n+\t    while ((c = *p) >= '0' && c <= '9') p++;\n+\t  }\n+\t/* % followed by punctuation: output something for that\n+\t   punctuation character alone, with no operand.\n+\t   The PRINT_OPERAND macro decides what is actually done.  */\n #ifdef PRINT_OPERAND_PUNCT_VALID_P\n-\t  else if (PRINT_OPERAND_PUNCT_VALID_P (*p))\n-\t    output_operand (NULL_RTX, *p++);\n+\telse if (PRINT_OPERAND_PUNCT_VALID_P (*p))\n+\t  output_operand (NULL_RTX, *p++);\n #endif\n-\t  else\n-\t    output_operand_lossage (\"invalid %%-code\");\n-\t}\n-    }\n+\telse\n+\t  output_operand_lossage (\"invalid %%-code\");\n+\tbreak;\n+\n+      default:\n+\tputc (c, asm_out_file);\n+      }\n \n   if (flag_print_asm_name)\n     {\n@@ -2640,7 +2674,9 @@ output_addr_const (file, x)\n    %U prints the value of USER_LABEL_PREFIX.\n    %I prints the value of IMMEDIATE_PREFIX.\n    %O runs ASM_OUTPUT_OPCODE to transform what follows in the string.\n-   Also supported are %d, %x, %s, %e, %f, %g and %%.  */\n+   Also supported are %d, %x, %s, %e, %f, %g and %%.\n+\n+   We handle alternate assembler dialects here, just like output_asm_insn.  */\n \n void\n asm_fprintf (va_alist)\n@@ -2650,6 +2686,7 @@ asm_fprintf (va_alist)\n   FILE *file;\n   char buf[10];\n   char *p, *q, c;\n+  int i;\n \n   va_start (argptr);\n \n@@ -2660,6 +2697,30 @@ asm_fprintf (va_alist)\n   while (c = *p++)\n     switch (c)\n       {\n+#ifdef ASSEMBLER_DIALECT\n+      case '{':\n+\t/* If we want the first dialect, do nothing.  Otherwise, skip\n+\t   DIALECT_NUMBER of strings ending with '|'.  */\n+\tfor (i = 0; i < dialect_number; i++)\n+\t  {\n+\t    while (*p && *p++ != '|')\n+\t      ;\n+\n+\t    if (*p == '|')\n+\t      p++;\n+\t  }\n+\tbreak;\n+\n+      case '|':\n+\t/* Skip to close brace.  */\n+\twhile (*p && *p++ != '}')\n+\t  ;\n+\tbreak;\n+\n+      case '}':\n+\tbreak;\n+#endif\n+\n       case '%':\n \tc = *p++;\n \tq = &buf[1];"}]}