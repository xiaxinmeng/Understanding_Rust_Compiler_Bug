{"sha": "374035cb20b323d0e95559499fc0089aa4cedff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc0MDM1Y2IyMGIzMjNkMGU5NTU1OTQ5OWZjMDA4OWFhNGNlZGZmOQ==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-08-13T10:01:52Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-08-13T10:01:52Z"}, "message": "re PR c/35635 (-Wconversion problematic with bitfields)\n\n2008-08-13  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\n\tPR 35635\n\t* c-common.c (conversion_warning): Use a switch. Ignore boolean\n\texpressions except for conversions to signed:1 bitfields. Handle\n\tCOND_EXPR with constant operands.\ntestsuite/\n\t* gcc.dg/pr35635.c: New.\n\t* gcc.dg/Wconversion-integer.c: Update.\n\t* gcc.dg/Wconversion-integer-no-sign.c: Update.\n\t* gcc.dg/Wsign-conversion.c: Update.\n\t* g++.dg/warn/pr35635.C: New.\n\t* g++.dg/warn/Wconversion-integer.C: Update.\n\t* g++.dg/warn/Wsign-conversion.C: Update.\n\nFrom-SVN: r139049", "tree": {"sha": "c369a65444f35bfe20b1e10fe92aa6089f0b2b5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c369a65444f35bfe20b1e10fe92aa6089f0b2b5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/374035cb20b323d0e95559499fc0089aa4cedff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/374035cb20b323d0e95559499fc0089aa4cedff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/374035cb20b323d0e95559499fc0089aa4cedff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/374035cb20b323d0e95559499fc0089aa4cedff9/comments", "author": null, "committer": null, "parents": [{"sha": "25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f"}], "stats": {"total": 334, "additions": 289, "deletions": 45}, "files": [{"sha": "4e03620f40d2fa59a8eb4d66c9ec1423af0feeb0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=374035cb20b323d0e95559499fc0089aa4cedff9", "patch": "@@ -1,3 +1,10 @@\n+2008-08-13  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 35635\n+\t* c-common.c (conversion_warning): Use a switch. Ignore boolean\n+\texpressions except for conversions to signed:1 bitfields. Handle\n+\tCOND_EXPR with constant operands.\n+\t\n 2008-08-13  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/15255"}, {"sha": "93021820cd68e4e6ea891ba5f7ec19b54af4a1f7", "filename": "gcc/c-common.c", "status": "modified", "additions": 76, "deletions": 29, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=374035cb20b323d0e95559499fc0089aa4cedff9", "patch": "@@ -1559,48 +1559,72 @@ conversion_warning (tree type, tree expr)\n {\n   bool give_warning = false;\n \n-  unsigned int formal_prec = TYPE_PRECISION (type);\n+  tree expr_type = TREE_TYPE (expr);\n \n   if (!warn_conversion && !warn_sign_conversion)\n     return;\n \n-  if (TREE_CODE (expr) == REAL_CST || TREE_CODE (expr) == INTEGER_CST)\n+  switch (TREE_CODE (expr))\n     {\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case TRUTH_NOT_EXPR:\n+      /* Conversion from boolean to a signed:1 bit-field (which only\n+\t can hold the values 0 and -1) doesn't lose information - but\n+\t it does change the value.  */\n+      if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type)) \n+\twarning (OPT_Wconversion,\n+                 \"conversion to %qT from boolean expression\", type);\n+      return;\n+\n+    case REAL_CST:\n+    case INTEGER_CST:\n+\n       /* Warn for real constant that is not an exact integer converted\n          to integer type.  */\n-      if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+      if (TREE_CODE (expr_type) == REAL_TYPE\n           && TREE_CODE (type) == INTEGER_TYPE)\n         {\n-          if (!real_isinteger (TREE_REAL_CST_PTR (expr), TYPE_MODE (TREE_TYPE (expr))))\n+          if (!real_isinteger (TREE_REAL_CST_PTR (expr), TYPE_MODE (expr_type)))\n             give_warning = true;\n         }\n       /* Warn for an integer constant that does not fit into integer type.  */\n-      else if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n+      else if (TREE_CODE (expr_type) == INTEGER_TYPE\n                && TREE_CODE (type) == INTEGER_TYPE\n                && !int_fits_type_p (expr, type))\n         {\n-          if (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (TREE_TYPE (expr)))\n+          if (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type) \n+\t      && tree_int_cst_sgn (expr) < 0)\n \t    warning (OPT_Wsign_conversion,\n \t\t     \"negative integer implicitly converted to unsigned type\");\n-          else if (!TYPE_UNSIGNED (type) && TYPE_UNSIGNED (TREE_TYPE (expr)))\n-\t    warning (OPT_Wsign_conversion,\n-\t\t     \"conversion of unsigned constant value to negative integer\");\n+          else if (!TYPE_UNSIGNED (type) && TYPE_UNSIGNED (expr_type))\n+\t    warning (OPT_Wsign_conversion,  \"conversion of unsigned constant \"\n+\t\t     \"value to negative integer\");\n \t  else\n \t    give_warning = true;\n         }\n       else if (TREE_CODE (type) == REAL_TYPE)\n         {\n           /* Warn for an integer constant that does not fit into real type.  */\n-          if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE)\n+          if (TREE_CODE (expr_type) == INTEGER_TYPE)\n             {\n               REAL_VALUE_TYPE a = real_value_from_int_cst (0, expr);\n               if (!exact_real_truncate (TYPE_MODE (type), &a))\n                 give_warning = true;\n             }\n           /* Warn for a real constant that does not fit into a smaller\n              real type.  */\n-          else if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n-                   && formal_prec < TYPE_PRECISION (TREE_TYPE (expr)))\n+          else if (TREE_CODE (expr_type) == REAL_TYPE\n+                   && TYPE_PRECISION (type) < TYPE_PRECISION (expr_type))\n             {\n               REAL_VALUE_TYPE a = TREE_REAL_CST (expr);\n               if (!exact_real_truncate (TYPE_MODE (type), &a))\n@@ -1611,11 +1635,31 @@ conversion_warning (tree type, tree expr)\n       if (give_warning)\n         warning (OPT_Wconversion,\n                  \"conversion to %qT alters %qT constant value\",\n-                 type, TREE_TYPE (expr));\n-    }\n-  else /* 'expr' is not a constant.  */\n-    {\n-      tree expr_type = TREE_TYPE (expr);\n+                 type, expr_type);\n+\n+      return;\n+\n+    case COND_EXPR:\n+      {\n+\t/* In case of COND_EXPR, if both operands are constants or\n+\t   COND_EXPR, then we do not care about the type of COND_EXPR,\n+\t   only about the conversion of each operand.  */\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\ttree op2 = TREE_OPERAND (expr, 2);\n+\n+\tif ((TREE_CODE (op1) == REAL_CST || TREE_CODE (op1) == INTEGER_CST \n+\t     || TREE_CODE (op1) == COND_EXPR)\n+\t    && (TREE_CODE (op2) == REAL_CST || TREE_CODE (op2) == INTEGER_CST\n+\t\t|| TREE_CODE (op2) == COND_EXPR))\n+\t  {\n+\t    conversion_warning (type, op1);\n+\t    conversion_warning (type, op2);\n+\t    return;\n+\t  }\n+\t/* Fall through.  */\n+      }\n+\n+    default: /* 'expr' is not a constant.  */\n \n       /* Warn for real types converted to integer types.  */\n       if (TREE_CODE (expr_type) == REAL_TYPE\n@@ -1631,11 +1675,11 @@ conversion_warning (tree type, tree expr)\n \n \t  /* Don't warn for short y; short x = ((int)y & 0xff);  */\n \t  if (TREE_CODE (expr) == BIT_AND_EXPR \n-\t      || TREE_CODE (expr) == BIT_IOR_EXPR \n+\t\t|| TREE_CODE (expr) == BIT_IOR_EXPR \n \t      || TREE_CODE (expr) == BIT_XOR_EXPR)\n \t    {\n-\t    /* It both args were extended from a shortest type, use\n-\t       that type if that is safe.  */\n+\t      /* If both args were extended from a shortest type,\n+\t\t use that type if that is safe.  */\n \t      expr_type = shorten_binary_op (expr_type, \n \t\t\t\t\t     TREE_OPERAND (expr, 0), \n \t\t\t\t\t     TREE_OPERAND (expr, 1), \n@@ -1652,25 +1696,26 @@ conversion_warning (tree type, tree expr)\n \t\t       && int_fits_type_p (op0, c_common_signed_type (type))\n \t\t       && int_fits_type_p (op0, c_common_unsigned_type (type)))\n \t\t      || (TREE_CODE (op1) == INTEGER_CST\n-\t\t       && int_fits_type_p (op1, c_common_signed_type (type))\n-\t\t       && int_fits_type_p (op1, c_common_unsigned_type (type))))\n+\t\t\t  && int_fits_type_p (op1, c_common_signed_type (type))\n+\t\t\t  && int_fits_type_p (op1, \n+\t\t\t\t\t      c_common_unsigned_type (type))))\n \t\t    return;\n \t\t}\n \t    }\n           /* Warn for integer types converted to smaller integer types.  */\n-          if (formal_prec < TYPE_PRECISION (expr_type)) \n+\t  if (TYPE_PRECISION (type) < TYPE_PRECISION (expr_type)) \n \t    give_warning = true;\n \n \t  /* When they are the same width but different signedness,\n \t     then the value may change.  */\n-\t  else if ((formal_prec == TYPE_PRECISION (expr_type)\n+\t  else if ((TYPE_PRECISION (type) == TYPE_PRECISION (expr_type)\n \t\t    && TYPE_UNSIGNED (expr_type) != TYPE_UNSIGNED (type))\n \t\t   /* Even when converted to a bigger type, if the type is\n \t\t      unsigned but expr is signed, then negative values\n \t\t      will be changed.  */\n \t\t   || (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type)))\n-\t    warning (OPT_Wsign_conversion,\n-\t\t     \"conversion to %qT from %qT may change the sign of the result\",\n+\t    warning (OPT_Wsign_conversion, \"conversion to %qT from %qT \"\n+\t\t     \"may change the sign of the result\",\n \t\t     type, expr_type);\n         }\n \n@@ -1682,8 +1727,10 @@ conversion_warning (tree type, tree expr)\n         {\n           tree type_low_bound = TYPE_MIN_VALUE (expr_type);\n           tree type_high_bound = TYPE_MAX_VALUE (expr_type);\n-          REAL_VALUE_TYPE real_low_bound = real_value_from_int_cst (0, type_low_bound);\n-          REAL_VALUE_TYPE real_high_bound = real_value_from_int_cst (0, type_high_bound);\n+          REAL_VALUE_TYPE real_low_bound \n+\t    = real_value_from_int_cst (0, type_low_bound);\n+          REAL_VALUE_TYPE real_high_bound \n+\t    = real_value_from_int_cst (0, type_high_bound);\n \n           if (!exact_real_truncate (TYPE_MODE (type), &real_low_bound)\n               || !exact_real_truncate (TYPE_MODE (type), &real_high_bound))\n@@ -1693,7 +1740,7 @@ conversion_warning (tree type, tree expr)\n       /* Warn for real types converted to smaller real types.  */\n       else if (TREE_CODE (expr_type) == REAL_TYPE\n                && TREE_CODE (type) == REAL_TYPE\n-               && formal_prec < TYPE_PRECISION (expr_type))\n+               && TYPE_PRECISION (type) < TYPE_PRECISION (expr_type))\n         give_warning = true;\n \n "}, {"sha": "50096c9bbc71c9db80f4fc7d4358239dc479d50a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=374035cb20b323d0e95559499fc0089aa4cedff9", "patch": "@@ -1,3 +1,14 @@\n+2008-08-13  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 35635\n+\t* gcc.dg/pr35635.c: New.\n+\t* gcc.dg/Wconversion-integer.c: Update.\n+\t* gcc.dg/Wconversion-integer-no-sign.c: Update.\n+\t* gcc.dg/Wsign-conversion.c: Update.\n+\t* g++.dg/warn/pr35635.C: New.\n+\t* g++.dg/warn/Wconversion-integer.C: Update.\n+\t* g++.dg/warn/Wsign-conversion.C: Update.\n+\t\n 2008-08-13  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/15255"}, {"sha": "42d9cb00044b2664f9ba191fa5b35fca7c3d0e7d", "filename": "gcc/testsuite/g++.dg/warn/Wconversion-integer.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-integer.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-integer.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-integer.C?ref=374035cb20b323d0e95559499fc0089aa4cedff9", "patch": "@@ -42,8 +42,8 @@ void h (int x)\n \n   uc = x ? 1U : -1; /* { dg-warning \"conversion\" } */\n   uc = x ? SCHAR_MIN : 1U; /* { dg-warning \"conversion\" } */\n-  uc = x ? 1 : -1; /* { dg-warning \"conversion\" } */\n-  uc = x ? SCHAR_MIN : 1; /* { dg-warning \"conversion\" } */\n+  uc = x ? 1 : -1; /* Warned by -Wsign-conversion.  */\n+  uc = x ? SCHAR_MIN : 1; /* Warned by -Wsign-conversion.  */\n   ui = x ? 1U : -1; /* Warned by -Wsign-conversion.  */\n   ui = x ? INT_MIN : 1U; /* Warned by -Wsign-conversion.  */\n   ui = ui ? SCHAR_MIN : 1U; /* Warned by -Wsign-conversion.  */"}, {"sha": "83fe2ed660b41c4a0a2fa09fa3da79508c3987a6", "filename": "gcc/testsuite/g++.dg/warn/Wsign-conversion.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsign-conversion.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsign-conversion.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsign-conversion.C?ref=374035cb20b323d0e95559499fc0089aa4cedff9", "patch": "@@ -42,15 +42,15 @@ void h (int x)\n \n   uc = x ? 1U : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   uc = x ? SCHAR_MIN : 1U;  /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  uc = x ? 1 : -1; \n-  uc = x ? SCHAR_MIN : 1; \n+  uc = x ? 1 : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  uc = x ? SCHAR_MIN : 1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = x ? 1U : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = x ? INT_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = ui ? SCHAR_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = 1U * -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = ui + INT_MIN; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  ui = x ? 1 : -1; /* { dg-warning \"conversion\" } */\n-  ui = ui ? SCHAR_MIN : 1; /* { dg-warning \"conversion\" } */\n+  ui = x ? 1 : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = ui ? SCHAR_MIN : 1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n \n   fuc (-1); /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   uc = -1;  /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */"}, {"sha": "d3b39a2b0c855b2e51cdee7db04009b4b82bf2b3", "filename": "gcc/testsuite/g++.dg/warn/pr35635.C", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr35635.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr35635.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr35635.C?ref=374035cb20b323d0e95559499fc0089aa4cedff9", "patch": "@@ -0,0 +1,89 @@\n+/* PR 35635 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wconversion -Wsign-conversion\" } */\n+\n+struct unsigned_bit {\n+  unsigned int x:1;\n+} unsigned_bit;\n+struct signed_bit {\n+  int x:1;\n+} signed_bit;\n+int bar;\n+int bar2;\n+\n+void func1()\n+{\n+  /* The result of boolean operators fits in unsiged int:1, thus do\n+     not warn.  */\n+  unsigned_bit.x = (bar != 0); /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar == 0); /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar <= 0); /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar >= 0); /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar < 0);  /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar > 0);  /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = !bar;       /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar || bar2); /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar && bar2); /* { dg-bogus \"conversion\" } */\n+\n+  /* Both branches of ? fit in the destination, thus do not warn.  */\n+  unsigned_bit.x = bar != 0 ? 1 : 0; /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = bar != 0 ? 1.0 : 0.0;  /* { dg-bogus \"conversion\" } */\n+\n+  /* At least one branch of ? does not fit in the destination, thus\n+     warn.  */\n+  unsigned_bit.x = bar != 0 ? 2 : 0; /* { dg-warning \"conversion\" } */\n+  unsigned_bit.x = bar != 0 ? 0 : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+}\n+\n+void func2()\n+{\n+  signed char schar_x;\n+\n+  /* Both branches of ? fit in the destination, thus do not warn.  */\n+  schar_x = bar != 0 ? 1 : 0; /* { dg-bogus \"conversion\" } */\n+  schar_x = bar != 0 ? 2.0 : 10; /* { dg-bogus \"conversion\" } */\n+\n+  /* At least one branch of ? does not fit in the destination, thus\n+     warn.  */\n+  schar_x = bar != 0 ? 2.1 : 10; /* { dg-warning \"conversion\" } */\n+  schar_x = bar != 0 ? (signed char) 1024: -1024; /* { dg-warning \"conversion\" } */\n+}\n+\n+\n+\n+void func3()\n+{\n+  unsigned char uchar_x;\n+\n+  /* Both branches of ? fit in the destination, thus do not warn.  */\n+  uchar_x = bar != 0 ? 1 : 0;\n+  uchar_x = bar != 0 ? 2.0 : 10;\n+\n+  /* At least one branch of ? does not fit in the destination, thus\n+     warn.  */\n+  uchar_x = bar != 0 ? 2.1 : 10; /* { dg-warning \"conversion\" } */\n+  uchar_x = bar != 0 \n+    ? (unsigned char) 1024 \n+    : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+}\n+\n+void func4()\n+{\n+  signed_bit.x = -1; /* { dg-bogus \"conversion\" } */\n+  signed_bit.x = bar != 0 ? -1.0 : 0.0;  /* { dg-bogus \"conversion\" } */\n+  signed_bit.x = bar != 0 ? -1 : 0; /* { dg-bogus \"conversion\" } */\n+  \n+  signed_bit.x = 1;          /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar != 0); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar == 0); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar <= 0); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar >= 0); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar < 0);  /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar > 0);  /* { dg-warning \"conversion\" } */\n+  signed_bit.x = !bar;       /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar || bar2); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar && bar2); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = bar != 0 ? 1 : 0; /* { dg-warning \"conversion\" } */\n+  signed_bit.x = bar != 0 ? 2 : 0; /* { dg-warning \"conversion\" } */\n+}\n+"}, {"sha": "c17d502d8f33f7dcdd3081640311069d72deba18", "filename": "gcc/testsuite/gcc.dg/Wconversion-integer-no-sign.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-integer-no-sign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-integer-no-sign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-integer-no-sign.c?ref=374035cb20b323d0e95559499fc0089aa4cedff9", "patch": "@@ -42,8 +42,8 @@ void h (int x)\n \n   uc = x ? 1U : -1; /* { dg-warning \"conversion\" } */\n   uc = x ? SCHAR_MIN : 1U; /* { dg-warning \"conversion\" } */\n-  uc = x ? 1 : -1; /* { dg-warning \"conversion\" } */\n-  uc = x ? SCHAR_MIN : 1; /* { dg-warning \"conversion\" } */\n+  uc = x ? 1 : -1; /* Warned by -Wsign-conversion.  */\n+  uc = x ? SCHAR_MIN : 1; /* Warned by -Wsign-conversion.  */\n   ui = x ? 1U : -1; /* Warned by -Wsign-conversion.  */\n   ui = x ? INT_MIN : 1U; /* Warned by -Wsign-conversion.  */\n   ui = ui ? SCHAR_MIN : 1U; /* Warned by -Wsign-conversion.  */"}, {"sha": "b2101076f9383de72883b68d988b429b807a2a69", "filename": "gcc/testsuite/gcc.dg/Wconversion-integer.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-integer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-integer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-integer.c?ref=374035cb20b323d0e95559499fc0089aa4cedff9", "patch": "@@ -44,15 +44,15 @@ void h (int x)\n   /* { dg-warning \"negative integer implicitly converted to unsigned type\" \"\" { target *-*-* } 43 } */\n   uc = x ? SCHAR_MIN : 1U; /* { dg-warning \"conversion\" } */\n   /* { dg-warning \"negative integer implicitly converted to unsigned type\" \"\" { target *-*-* } 45 } */\n-  uc = x ? 1 : -1; /* { dg-warning \"conversion\" } */\n-  uc = x ? SCHAR_MIN : 1; /* { dg-warning \"conversion\" } */\n+  uc = x ? 1 : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  uc = x ? SCHAR_MIN : 1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = x ? 1U : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = x ? INT_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = ui ? SCHAR_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = 1U * -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = ui + INT_MIN; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  ui = x ? 1 : -1; /* { dg-warning \"conversion\" } */\n-  ui = ui ? SCHAR_MIN : 1; /* { dg-warning \"conversion\" } */\n+  ui = x ? 1 : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = ui ? SCHAR_MIN : 1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n \n   fuc (-1); /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   uc = -1;  /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */"}, {"sha": "0300850f904a3f5f4f3edf7779712a4630c8b41d", "filename": "gcc/testsuite/gcc.dg/Wsign-conversion.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fgcc.dg%2FWsign-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fgcc.dg%2FWsign-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWsign-conversion.c?ref=374035cb20b323d0e95559499fc0089aa4cedff9", "patch": "@@ -42,15 +42,15 @@ void h (int x)\n \n   uc = x ? 1U : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   uc = x ? SCHAR_MIN : 1U;  /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  uc = x ? 1 : -1; \n-  uc = x ? SCHAR_MIN : 1; \n+  uc = x ? 1 : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  uc = x ? SCHAR_MIN : 1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = x ? 1U : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = x ? INT_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = ui ? SCHAR_MIN : 1U; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = 1U * -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   ui = ui + INT_MIN; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-  ui = x ? 1 : -1; /* { dg-warning \"conversion\" } */\n-  ui = ui ? SCHAR_MIN : 1; /* { dg-warning \"conversion\" } */\n+  ui = x ? 1 : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+  ui = ui ? SCHAR_MIN : 1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n \n   fuc (-1); /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n   uc = -1;  /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */"}, {"sha": "45d10a67bd39b8991bf1cf42c944a31678358d24", "filename": "gcc/testsuite/gcc.dg/pr35635.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr35635.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374035cb20b323d0e95559499fc0089aa4cedff9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr35635.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr35635.c?ref=374035cb20b323d0e95559499fc0089aa4cedff9", "patch": "@@ -0,0 +1,90 @@\n+/* PR 35635 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wconversion -Wsign-conversion\" } */\n+\n+struct unsigned_bit {\n+  unsigned int x:1;\n+} unsigned_bit;\n+struct signed_bit {\n+  int x:1;\n+} signed_bit;\n+int bar;\n+int bar2;\n+\n+void func1()\n+{\n+  /* The result of boolean operators fits in unsiged int:1, thus do\n+     not warn.  */\n+  unsigned_bit.x = (bar != 0); /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar == 0); /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar <= 0); /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar >= 0); /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar < 0);  /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar > 0);  /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = !bar;       /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar || bar2); /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = (bar && bar2); /* { dg-bogus \"conversion\" } */\n+\n+  /* Both branches of ? fit in the destination, thus do not warn.  */\n+  unsigned_bit.x = bar != 0 ? 1 : 0; /* { dg-bogus \"conversion\" } */\n+  unsigned_bit.x = bar != 0 ? 1.0 : 0.0;  /* { dg-bogus \"conversion\" } */\n+\n+  /* At least one branch of ? does not fit in the destination, thus\n+     warn.  */\n+  unsigned_bit.x = bar != 0 ? 2 : 0; /* { dg-warning \"conversion\" } */\n+  unsigned_bit.x = bar != 0 ? 0 : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+}\n+\n+void func2()\n+{\n+  signed char schar_x;\n+\n+  /* Both branches of ? fit in the destination, thus do not warn.  */\n+  schar_x = bar != 0 ? 1 : 0; /* { dg-bogus \"conversion\" } */\n+  schar_x = bar != 0 ? 2.0 : 10; /* { dg-bogus \"conversion\" } */\n+\n+  /* At least one branch of ? does not fit in the destination, thus\n+     warn.  */\n+  schar_x = bar != 0 ? 2.1 : 10; /* { dg-warning \"conversion\" } */\n+  schar_x = bar != 0 ? (signed char) 1024: -1024; /* { dg-warning \"conversion\" } */\n+}\n+\n+\n+\n+void func3()\n+{\n+  unsigned char uchar_x;\n+\n+  /* Both branches of ? fit in the destination, thus do not warn.  */\n+  uchar_x = bar != 0 ? 1 : 0;\n+  uchar_x = bar != 0 ? 2.0 : 10;\n+\n+  /* At least one branch of ? does not fit in the destination, thus\n+     warn.  */\n+  uchar_x = bar != 0 ? 2.1 : 10; /* { dg-warning \"conversion\" } */\n+  uchar_x = bar != 0 \n+    ? (unsigned char) 1024 \n+    : -1; /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+}\n+\n+void func4()\n+{\n+  signed_bit.x = -1; /* { dg-bogus \"conversion\" } */\n+  signed_bit.x = bar != 0 ? -1.0 : 0.0;  /* { dg-bogus \"conversion\" } */\n+  signed_bit.x = bar != 0 ? -1 : 0; /* { dg-bogus \"conversion\" } */\n+\n+  \n+  signed_bit.x = 1;          /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar != 0); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar == 0); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar <= 0); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar >= 0); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar < 0);  /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar > 0);  /* { dg-warning \"conversion\" } */\n+  signed_bit.x = !bar;       /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar || bar2); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = (bar && bar2); /* { dg-warning \"conversion\" } */\n+  signed_bit.x = bar != 0 ? 1 : 0; /* { dg-warning \"conversion\" } */\n+  signed_bit.x = bar != 0 ? 2 : 0; /* { dg-warning \"conversion\" } */\n+}\n+"}]}