{"sha": "ac1605d6d3a0a049524738c35aacfc1641b2c065", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMxNjA1ZDZkM2EwYTA0OTUyNDczOGMzNWFhY2ZjMTY0MWIyYzA2NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-10-06T17:48:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-10-06T17:48:25Z"}, "message": "mips.c (mips_arg_info): If MUST_PASS_IN_STACK, skip any remaining register arguments.\n\n\t* config/mips/mips.c (mips_arg_info): If MUST_PASS_IN_STACK,\n\tskip any remaining register arguments.\n\nFrom-SVN: r72156", "tree": {"sha": "9b271bc4f202d0133b93916213935d34aef71195", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b271bc4f202d0133b93916213935d34aef71195"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac1605d6d3a0a049524738c35aacfc1641b2c065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1605d6d3a0a049524738c35aacfc1641b2c065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1605d6d3a0a049524738c35aacfc1641b2c065", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1605d6d3a0a049524738c35aacfc1641b2c065/comments", "author": null, "committer": null, "parents": [{"sha": "6357135a0e6e8d95d05b370f15e6daff39d7dfee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6357135a0e6e8d95d05b370f15e6daff39d7dfee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6357135a0e6e8d95d05b370f15e6daff39d7dfee"}], "stats": {"total": 28, "additions": 20, "deletions": 8}, "files": [{"sha": "5e01a062a6de948926b5562bf17a92855c43b0d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1605d6d3a0a049524738c35aacfc1641b2c065/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1605d6d3a0a049524738c35aacfc1641b2c065/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac1605d6d3a0a049524738c35aacfc1641b2c065", "patch": "@@ -1,3 +1,8 @@\n+2003-10-06  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_arg_info): If MUST_PASS_IN_STACK,\n+\tskip any remaining register arguments.\n+\n 2003-10-06  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* reload.c (find_reloads_subreg_address): Use correct offset for"}, {"sha": "bcd9586c9554c89d48e64a490d491b9a17efb605", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1605d6d3a0a049524738c35aacfc1641b2c065/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1605d6d3a0a049524738c35aacfc1641b2c065/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ac1605d6d3a0a049524738c35aacfc1641b2c065", "patch": "@@ -3644,15 +3644,22 @@ mips_arg_info (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \teven_reg_p = true;\n     }\n \n-  /* Set REG_OFFSET to the register count we're interested in.\n-     The EABI allocates the floating-point registers separately,\n-     but the other ABIs allocate them like integer registers.  */\n-  info->reg_offset = (mips_abi == ABI_EABI && info->fpr_p\n-\t\t      ? cum->num_fprs\n-\t\t      : cum->num_gprs);\n+  if (mips_abi != ABI_EABI && MUST_PASS_IN_STACK (mode, type))\n+    /* This argument must be passed on the stack.  Eat up all the\n+       remaining registers.  */\n+    info->reg_offset = MAX_ARGS_IN_REGISTERS;\n+  else\n+    {\n+      /* Set REG_OFFSET to the register count we're interested in.\n+\t The EABI allocates the floating-point registers separately,\n+\t but the other ABIs allocate them like integer registers.  */\n+      info->reg_offset = (mips_abi == ABI_EABI && info->fpr_p\n+\t\t\t  ? cum->num_fprs\n+\t\t\t  : cum->num_gprs);\n \n-  if (even_reg_p)\n-    info->reg_offset += info->reg_offset & 1;\n+      if (even_reg_p)\n+\tinfo->reg_offset += info->reg_offset & 1;\n+    }\n \n   /* The alignment applied to registers is also applied to stack arguments.  */\n   info->stack_offset = cum->stack_words;"}]}