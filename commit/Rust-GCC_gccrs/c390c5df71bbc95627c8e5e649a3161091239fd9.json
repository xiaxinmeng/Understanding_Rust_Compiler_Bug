{"sha": "c390c5df71bbc95627c8e5e649a3161091239fd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM5MGM1ZGY3MWJiYzk1NjI3YzhlNWU2NDlhMzE2MTA5MTIzOWZkOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-03T20:38:20Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-03T20:45:32Z"}, "message": "c++: Defer cloning to post-loading [PR 99170]\n\nIt turns out that cloning can cause use to load things. Specifically when\nchecking paramter shadows (this is avoidable), and also the delete\noperator of a deleting dtor (not avoidable).  Doing that in the middle of\nloading is a bad thing.  This defers it to a post-load worklist.  If it\ncauses more loading at that point there is no problem, as we've completed\nthe first set of loads, bar this bit of cleanup.\n\nAgain, this doesn't fix 99170, but is a step towards a solution.\n\n\tPR c++/99170\n\tgcc/cp/\n\t* module.cc (post_load_decls): New.\n\t(lazy_snum, recursive_lazy): Move earlier.\n\t(module_state::read_cluster): Push cloning onto post_load_decls.\n\t(post_load_processing): New.  Do the cloning here.\n\t(module_state::read_inits): Call post_load_processing.\n\t(module_state::read_language): Likewise.\n\t(lazy_load_binding, lazy_load_specializations): Likewise\n\t(lazy_load_members): Likewise", "tree": {"sha": "db107ec94a89ca234e0f18a178cda7adf8be4c89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db107ec94a89ca234e0f18a178cda7adf8be4c89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c390c5df71bbc95627c8e5e649a3161091239fd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c390c5df71bbc95627c8e5e649a3161091239fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c390c5df71bbc95627c8e5e649a3161091239fd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c390c5df71bbc95627c8e5e649a3161091239fd9/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49df367b17995c54fabe5bca290eede7dfab05b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49df367b17995c54fabe5bca290eede7dfab05b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49df367b17995c54fabe5bca290eede7dfab05b3"}], "stats": {"total": 90, "additions": 61, "deletions": 29}, "files": [{"sha": "b7b9c3734f2b444522fdcae87cb328a093bc59c3", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c390c5df71bbc95627c8e5e649a3161091239fd9/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c390c5df71bbc95627c8e5e649a3161091239fd9/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=c390c5df71bbc95627c8e5e649a3161091239fd9", "patch": "@@ -2644,6 +2644,10 @@ depset *depset::make_entity (tree entity, entity_kind ek, bool is_defn)\n   return r;\n }\n \n+/* Decls that need some post processing once a batch of lazy loads has\n+   completed.  */\n+vec<tree, va_heap, vl_embed> *post_load_decls;\n+\n /* Values keyed to some unsigned integer.  This is not GTY'd, so if\n    T is tree they must be reachable via some other path.  */\n \n@@ -14023,6 +14027,21 @@ make_mapper (location_t loc)\n   return mapper;\n }\n \n+static unsigned lazy_snum;\n+\n+static bool\n+recursive_lazy (unsigned snum = ~0u)\n+{\n+  if (lazy_snum)\n+    {\n+      error_at (input_location, \"recursive lazy load\");\n+      return true;\n+    }\n+\n+  lazy_snum = snum;\n+  return false;\n+}\n+\n /* If THIS is the current purview, issue an import error and return false.  */\n \n bool\n@@ -15016,11 +15035,7 @@ module_state::read_cluster (unsigned snum)\n       if (abstract)\n \t;\n       else if (DECL_ABSTRACT_P (decl))\n-\t{\n-\t  bool cloned = maybe_clone_body (decl);\n-\t  if (!cloned)\n-\t    from ()->set_error ();\n-\t}\n+\tvec_safe_push (post_load_decls, decl);\n       else\n \t{\n \t  bool aggr = aggregate_value_p (DECL_RESULT (decl), decl);\n@@ -17267,6 +17282,33 @@ module_state::write_inits (elf_out *to, depset::hash &table, unsigned *crc_ptr)\n   return count;\n }\n \n+/* We have to defer some post-load processing until we've completed\n+   reading, because they can cause more reading.  */\n+\n+static void\n+post_load_processing ()\n+{\n+  if (!post_load_decls)\n+    return;\n+\n+  tree old_cfd = current_function_decl;\n+  struct function *old_cfun = cfun;\n+  while (post_load_decls->length ())\n+    {\n+      tree decl = post_load_decls->pop ();\n+\n+      dump () && dump (\"Post-load processing of %N\", decl);\n+\n+      gcc_checking_assert (DECL_ABSTRACT_P (decl));\n+      /* Cloning can cause loading -- specifically operator delete for\n+\t the deleting dtor.  */\n+      maybe_clone_body (decl);\n+    }\n+\n+  cfun = old_cfun;\n+  current_function_decl = old_cfd;\n+}\n+\n bool\n module_state::read_inits (unsigned count)\n {\n@@ -17276,6 +17318,7 @@ module_state::read_inits (unsigned count)\n   dump () && dump (\"Reading %u initializers\", count);\n   dump.indent ();\n \n+  lazy_snum = ~0u;\n   for (unsigned ix = 0; ix != count; ix++)\n     {\n       /* Merely referencing the decl causes its initializer to be read\n@@ -17287,6 +17330,8 @@ module_state::read_inits (unsigned count)\n       if (decl)\n \tdump (\"Initializer:%u for %N\", count, decl);\n     }\n+  lazy_snum = 0;\n+  post_load_processing ();\n   dump.outdent ();\n   if (!sec.end (from ()))\n     return false;  \n@@ -18025,21 +18070,6 @@ module_state::read_preprocessor (bool outermost)\n   return check_read (outermost, ok);\n }\n \n-static unsigned lazy_snum;\n-\n-static bool\n-recursive_lazy (unsigned snum = ~0u)\n-{\n-  if (lazy_snum)\n-    {\n-      error_at (input_location, \"recursive lazy load\");\n-      return true;\n-    }\n-\n-  lazy_snum = snum;\n-  return false;\n-}\n-\n /* Read language state.  */\n \n bool\n@@ -18114,16 +18144,15 @@ module_state::read_language (bool outermost)\n \n       unsigned hwm = counts[MSC_sec_hwm];\n       for (unsigned ix = counts[MSC_sec_lwm]; ok && ix != hwm; ix++)\n-\t{\n-\t  if (!load_section (ix, NULL))\n-\t    {\n-\t      ok = false;\n-\t      break;\n-\t    }\n-\t  ggc_collect ();\n-\t}\n-\n+\tif (!load_section (ix, NULL))\n+\t  {\n+\t    ok = false;\n+\t    break;\n+\t  }\n       lazy_snum = 0;\n+      post_load_processing ();\n+\n+      ggc_collect ();\n \n       if (ok && CHECKING_P)\n \tfor (unsigned ix = 0; ix != entity_num; ix++)\n@@ -18873,6 +18902,7 @@ lazy_load_binding (unsigned mod, tree ns, tree id, binding_slot *mslot)\n     {\n       ok = module->load_section (snum, mslot);\n       lazy_snum = 0;\n+      post_load_processing ();\n     }\n \n   dump.pop (n);\n@@ -18929,6 +18959,7 @@ lazy_load_specializations (tree tmpl)\n \t  function_depth--;\n \t}\n       lazy_snum = 0;\n+      post_load_processing ();\n     }\n \n   timevar_stop (TV_MODULE_IMPORT);\n@@ -18969,6 +19000,7 @@ lazy_load_members (tree decl)\n \t\t       set->num, import_entity_module (ident),\n \t\t       ident - import_entity_module (ident)->entity_lwm, decl);\n       pendset_lazy_load (set, false);\n+      post_load_processing ();\n       dump.pop (n);\n \n       function_depth--;"}]}