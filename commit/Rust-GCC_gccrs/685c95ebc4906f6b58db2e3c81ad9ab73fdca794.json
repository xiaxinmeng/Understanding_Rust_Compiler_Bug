{"sha": "685c95ebc4906f6b58db2e3c81ad9ab73fdca794", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg1Yzk1ZWJjNDkwNmY2YjU4ZGIyZTNjODFhZDlhYjczZmRjYTc5NA==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-09-18T12:03:13Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-09-18T12:03:13Z"}, "message": "MSP430: Fix CFA generation during function epilogues\n\nThere is no CFA information generated for instructions that manipulate the\nstack during function epilogues. This means a debugger cannot determine the\nposition of variables on the stack whilst the epilogue is in progress.\n\nThis can cause the debugger to give erroneous information when printing a\nbacktrace whilst stepping through the epilogue, or cause software watchpoints\nset on stack variables to become invalidated after a function epilogue\nis executed.\n\nThe patch fixes this by marking stack manipulation insns as\nframe_related, and adding reg_note RTXs to stack pop instructions in the\nepilogue.\n\ngcc/ChangeLog:\n\n\t* config/msp430/msp430.c (increment_stack): Mark insns which increment\n\tthe stack as frame_related.\n\t(msp430_expand_prologue): Add comments.\n\t(msp430_expand_epilogue): Mark insns which decrement\n\tthe stack as frame_related.\n\tAdd reg_note to stack pop insns describing position of register\n\tvariables on the stack.", "tree": {"sha": "f88db1c197d7e1f28908a7977405180bfdbda918", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f88db1c197d7e1f28908a7977405180bfdbda918"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/685c95ebc4906f6b58db2e3c81ad9ab73fdca794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685c95ebc4906f6b58db2e3c81ad9ab73fdca794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/685c95ebc4906f6b58db2e3c81ad9ab73fdca794", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685c95ebc4906f6b58db2e3c81ad9ab73fdca794/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "220724c311473b8b0f2418350c2b64e796e92bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220724c311473b8b0f2418350c2b64e796e92bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/220724c311473b8b0f2418350c2b64e796e92bda"}], "stats": {"total": 72, "additions": 59, "deletions": 13}, "files": [{"sha": "68a67bd8c987d77ba5f40e5188224c1e90d909e9", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685c95ebc4906f6b58db2e3c81ad9ab73fdca794/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685c95ebc4906f6b58db2e3c81ad9ab73fdca794/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=685c95ebc4906f6b58db2e3c81ad9ab73fdca794", "patch": "@@ -1695,9 +1695,9 @@ increment_stack (HOST_WIDE_INT amount)\n     {\n       inc = GEN_INT (amount);\n       if (TARGET_LARGE)\n-\temit_insn (gen_addpsi3 (sp, sp, inc));\n+\tF (emit_insn (gen_addpsi3 (sp, sp, inc)));\n       else\n-\temit_insn (gen_addhi3 (sp, sp, inc));\n+\tF (emit_insn (gen_addhi3 (sp, sp, inc)));\n     }\n }\n \n@@ -2408,6 +2408,8 @@ msp430_expand_prologue (void)\n   for (i = 15; i >= 4; i--)\n     if (cfun->machine->need_to_save[i])\n       {\n+\t/* We need to save COUNT sequential registers starting from regnum\n+\t   I.  */\n \tint seq, count;\n \trtx note;\n \n@@ -2422,6 +2424,7 @@ msp430_expand_prologue (void)\n \t    p = F (emit_insn (gen_pushm (gen_rtx_REG (Pmode, i),\n \t\t\t\t\t GEN_INT (count))));\n \n+\t    /* Document the stack decrement as a result of PUSHM.  */\n \t    note = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (count + 1));\n \n \t    XVECEXP (note, 0, 0)\n@@ -2470,8 +2473,10 @@ msp430_expand_prologue (void)\n void\n msp430_expand_epilogue (int is_eh)\n {\n-  int i;\n+  int i, j;\n   int fs;\n+  rtx sp = stack_pointer_rtx;\n+  rtx p;\n   int helper_n = 0;\n \n   if (is_naked_func ())\n@@ -2540,19 +2545,27 @@ msp430_expand_epilogue (int is_eh)\n   for (i = 4; i <= 15; i++)\n     if (cfun->machine->need_to_save[i])\n       {\n-\tint seq, count;\n+\t/* We need to restore COUNT sequential registers starting from regnum\n+\t   I.  */\n+\tint seq;\n+\tint count = 1;\n+\tint helper_used = 0;\n+\trtx note, addr;\n \n-\tfor (seq = i + 1; seq <= 15 && cfun->machine->need_to_save[seq]; seq ++)\n-\t  ;\n-\tcount = seq - i;\n+\tif (msp430x)\n+\t  {\n+\t    for (seq = i + 1; seq <= 15 && cfun->machine->need_to_save[seq];\n+\t\t seq++)\n+\t      ;\n+\t    count = seq - i;\n+\t  }\n \n \tif (msp430x)\n \t  {\n \t    /* Note: With TARGET_LARGE we still use\n \t       POPM as POPX.A is two bytes bigger.  */\n-\t    emit_insn (gen_popm (stack_pointer_rtx, GEN_INT (seq - 1),\n-\t\t\t\t GEN_INT (count)));\n-\t    i += count - 1;\n+\t    p = F (emit_insn (gen_popm (stack_pointer_rtx, GEN_INT (seq - 1),\n+\t\t\t\t\tGEN_INT (count))));\n \t  }\n \telse if (i == 11 - helper_n\n \t\t && ! msp430_is_interrupt_func ()\n@@ -2564,11 +2577,44 @@ msp430_expand_epilogue (int is_eh)\n \t\t && helper_n > 1\n \t\t && !is_eh)\n \t  {\n-\t    emit_jump_insn (gen_epilogue_helper (GEN_INT (helper_n)));\n-\t    return;\n+\t    p = F (emit_jump_insn (gen_epilogue_helper (GEN_INT (helper_n))));\n+\t    count = helper_n;\n+\t    helper_used = 1;\n \t  }\n \telse\n-\t  emit_insn (gen_pop (gen_rtx_REG (Pmode, i)));\n+\t  p = F (emit_insn (gen_pop (gen_rtx_REG (Pmode, i))));\n+\n+\t/* Document the stack increment as a result of POPM.  */\n+\tnote = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (count + 1));\n+\n+\taddr = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t     GEN_INT (count * (TARGET_LARGE ? 4 : 2)));\n+\n+\tXVECEXP (note, 0, 0) = F (gen_rtx_SET (stack_pointer_rtx, addr));\n+\n+\n+\t/* *sp++ = R[i+j] */\n+\t/* sp\tR4\n+\t   ...\n+\t   sp+N\tR10.  */\n+\tfor (j = 0; j < count; j++)\n+\t  {\n+\t    int ofs = j * (TARGET_LARGE ? 4 : 2);\n+\n+\t    if (ofs)\n+\t      addr = gen_rtx_PLUS (Pmode, sp, GEN_INT (ofs));\n+\t    else\n+\t      addr = stack_pointer_rtx;\n+\n+\t    XVECEXP (note, 0, j + 1)\n+\t      = F (gen_rtx_SET (gen_rtx_MEM (Pmode, addr),\n+\t\t\t\tgen_rtx_REG (Pmode, i + j)));\n+\t  }\n+\tadd_reg_note (p, REG_FRAME_RELATED_EXPR, note);\n+\ti += count - 1;\n+\n+\tif (helper_used)\n+\t  return;\n       }\n \n   if (is_eh)"}]}