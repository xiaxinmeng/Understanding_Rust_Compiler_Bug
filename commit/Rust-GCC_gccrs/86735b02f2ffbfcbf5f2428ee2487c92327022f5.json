{"sha": "86735b02f2ffbfcbf5f2428ee2487c92327022f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY3MzViMDJmMmZmYmZjYmY1ZjI0MjhlZTI0ODdjOTIzMjcwMjJmNQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-10-19T00:27:08Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-10-19T00:27:08Z"}, "message": "sparc.c (sparc_frame_info): Combine members gp_sp_offset and fp_sp_offset into reg_offset.\n\n\t* sparc.c (sparc_frame_info): Combine members gp_sp_offset and\n\tfp_sp_offset into reg_offset.  All uses changed.\n\t(RETURN_ADDR_REGNUM): New macro.\n\t(RETURN_ADDR_MASK, FRAME_POINTER_MASK): New macros.\n\t(sparc_flat_compute_frame_info): Rename local mask to gmask.\n\tOnly ensure reg save area is 8 byte aligned if necessary.\n\t(sparc_flat_save_restore): New arguments base_reg, offset, gmask,\n\tand fmask.  All callers changed.  No longer use %g2 to save regs\n\tin big stack frame.\n\t(sparc_flat_output_function_prologue): Delete local tsize.\n\tReorder storing of previous frame pointer and return address reg to\n\tmake it easier for gdb to identify flat functions.  Decrement %sp\n\ttwice when saving call-saved regs in big frames.\n\t(sparc_flat_output_function_epilogue): Likewise when restoring\n\tcall-saved regs.\n\nFrom-SVN: r8310", "tree": {"sha": "4d2fe97ad07abc01fdc6df679add944fcf7318a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d2fe97ad07abc01fdc6df679add944fcf7318a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86735b02f2ffbfcbf5f2428ee2487c92327022f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86735b02f2ffbfcbf5f2428ee2487c92327022f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86735b02f2ffbfcbf5f2428ee2487c92327022f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86735b02f2ffbfcbf5f2428ee2487c92327022f5/comments", "author": null, "committer": null, "parents": [{"sha": "a061b9fa1ba5fa26292f074194e5f9cd30e744b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a061b9fa1ba5fa26292f074194e5f9cd30e744b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a061b9fa1ba5fa26292f074194e5f9cd30e744b1"}], "stats": {"total": 477, "additions": 306, "deletions": 171}, "files": [{"sha": "fb3811baa329db5c8a6364369a3a7e9dfb1aacab", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 306, "deletions": 171, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86735b02f2ffbfcbf5f2428ee2487c92327022f5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86735b02f2ffbfcbf5f2428ee2487c92327022f5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=86735b02f2ffbfcbf5f2428ee2487c92327022f5", "patch": "@@ -2831,6 +2831,7 @@ compute_frame_size (size, leaf_function)\n }\n \n /* Build a (32 bit) big number in a register.  */\n+/* ??? We may be able to use the set macro here too.  */\n \n static void\n build_big_number (file, num, reg)\n@@ -4145,60 +4146,59 @@ sparc64_initialize_trampoline (tramp, fnaddr, cxt)\n \n              Before call\t\t        After call\n         +-----------------------+\t+-----------------------+\n-   high |\t\t\t|       |      \t\t\t|\n-   mem. |\t\t        |\t|\t\t\t|\n-        |  caller's temps.    \t|       |  caller's temps.    \t|\n+   high |\t\t        |\t|\t\t\t|\n+   mem  |  caller's temps.    \t|       |  caller's temps.    \t|\n \t|       \t\t|       |       \t        |\n         +-----------------------+\t+-----------------------+\n  \t|       \t\t|\t|\t\t        |\n         |  arguments on stack.  |\t|  arguments on stack.  |\n-\t|       \t\t|FP+92->|\t\t\t|\n-        +-----------------------+\t+-----------------------+\n+\t|       \t\t|      \t|\t\t\t|\n+        +-----------------------+FP+92->+-----------------------+\n  \t|  6 words to save     \t|\t|  6 words to save\t|\n \t|  arguments passed\t|\t|  arguments passed\t|\n \t|  in registers, even\t|\t|  in registers, even\t|\n- SP+68->|  if not passed.       |FP+68->|  if not passed.\t|\n-\t+-----------------------+       +-----------------------+\n-\t| 1 word struct addr\t|FP+64->| 1 word struct addr\t|\n-\t+-----------------------+       +-----------------------+\n-\t|\t\t\t|\t|\t\t\t|\n-\t| 16 word reg save area\t|\t| 16 word reg save area |\n-    SP->|\t\t\t|   FP->|\t\t\t|\n-\t+-----------------------+\t+-----------------------+\n-\t\t\t\t\t| 4 word area for\t|\n-\t\t\t\t FP-16->| fp/alu reg moves\t|\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t|  local variables\t|\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t        |\n+       \t|  if not passed.       |      \t|  if not passed.\t|\n+ SP+68->+-----------------------+FP+68->+-----------------------+\n+        | 1 word struct addr\t|      \t| 1 word struct addr\t|\n+        +-----------------------+FP+64->+-----------------------+\n+        |\t\t\t|\t|\t\t\t|\n+        | 16 word reg save area\t|\t| 16 word reg save area |\n+       \t|                       |      \t|\t\t\t|\n+    SP->+-----------------------+   FP->+-----------------------+\n+\t\t\t\t        | 4 word area for\t|\n+\t\t\t\t       \t| fp/alu reg moves\t|\n+\t\t\t\t FP-16->+-----------------------+\n+\t\t\t\t        |\t\t\t|\n+\t\t\t\t        |  local variables\t|\n+\t\t\t\t        |\t\t\t|\n+\t\t\t\t        +-----------------------+\n+\t\t\t\t        |\t\t        |\n                                         |  fp register save     |\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t        |\n+\t\t\t\t        |\t\t\t|\n+\t\t\t\t        +-----------------------+\n+\t\t\t\t        |\t\t        |\n                                         |  gp register save     |\n                                         |       \t\t|\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t\t|\n+\t\t\t\t        +-----------------------+\n+\t\t\t\t        |\t\t\t|\n                                         |  alloca allocations   |\n-        \t\t\t\t|\t\t\t|\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t\t|\n+        \t\t\t        |\t\t\t|\n+\t\t\t\t        +-----------------------+\n+\t\t\t\t        |\t\t\t|\n                                         |  arguments on stack   |\n-        \t\t\t SP+92->|\t\t        |\n-\t\t\t\t\t+-----------------------+\n+        \t\t\t       \t|\t\t        |\n+\t\t\t\t SP+92->+-----------------------+\n                                         |  6 words to save      |\n-\t\t\t\t\t|  arguments passed     |\n+\t\t\t\t        |  arguments passed     |\n                                         |  in registers, even   |\n-   low                           SP+68->|  if not passed.       |\n-   memory        \t\t\t+-----------------------+\n-\t\t\t\t SP+64->| 1 word struct addr\t|\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\tI 16 word reg save area |\n-\t\t\t\t    SP->|\t\t\t|\n-\t\t\t\t\t+-----------------------+  */\n+   low                                 \t|  if not passed.       |\n+   memory        \t\t SP+68->+-----------------------+\n+\t\t\t\t       \t| 1 word struct addr\t|\n+\t\t\t\t SP+64->+-----------------------+\n+\t\t\t\t        |\t\t\t|\n+\t\t\t\t        I 16 word reg save area |\n+\t\t\t\t       \t|\t\t\t|\n+\t\t\t\t    SP->+-----------------------+  */\n \n /* Structure to be filled in by sparc_flat_compute_frame_size with register\n    save masks, and offsets for the current function.  */\n@@ -4211,10 +4211,9 @@ struct sparc_frame_info\n   unsigned long extra_size;\t/* # bytes of extra gunk.  */\n   unsigned int  gp_reg_size;\t/* # bytes needed to store gp regs.  */\n   unsigned int  fp_reg_size;\t/* # bytes needed to store fp regs.  */\n-  unsigned long mask;\t\t/* Mask of saved gp registers.  */\n+  unsigned long gmask;\t\t/* Mask of saved gp registers.  */\n   unsigned long fmask;\t\t/* Mask of saved fp registers.  */\n-  unsigned long gp_sp_offset;\t/* Offset from new sp to store gp regs.  */\n-  unsigned long fp_sp_offset;\t/* Offset from new sp to store fp regs.  */\n+  unsigned long reg_offset;\t/* Offset from new sp to store regs.  */\n   int\t\tinitialized;\t/* Nonzero if frame size already calculated.  */\n };\n \n@@ -4226,10 +4225,14 @@ struct sparc_frame_info zero_frame_info;\n \n /* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n \n+#define RETURN_ADDR_REGNUM 15\n+#define FRAME_POINTER_MASK (1 << (FRAME_POINTER_REGNUM))\n+#define RETURN_ADDR_MASK (1 << (RETURN_ADDR_REGNUM))\n+\n #define MUST_SAVE_REGISTER(regno) \\\n  ((regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n   || (regno == FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n-  || (regno == 15 && regs_ever_live[15]))\n+  || (regno == RETURN_ADDR_REGNUM && regs_ever_live[RETURN_ADDR_REGNUM]))\n \n /* Return the bytes needed to compute the frame pointer from the current\n    stack pointer.  */\n@@ -4245,46 +4248,48 @@ sparc_flat_compute_frame_size (size)\n   unsigned long extra_size;\t/* # extra bytes.  */\n   unsigned int  gp_reg_size;\t/* # bytes needed to store gp regs.  */\n   unsigned int  fp_reg_size;\t/* # bytes needed to store fp regs.  */\n-  unsigned long mask;\t\t/* Mask of saved gp registers.  */\n+  unsigned long gmask;\t\t/* Mask of saved gp registers.  */\n   unsigned long fmask;\t\t/* Mask of saved fp registers.  */\n+  unsigned long reg_offset;\t/* Offset to register save area.  */\n+  int           need_aligned_p;\t/* 1 if need the save area 8 byte aligned.  */\n \n   /* This is the size of the 16 word reg save area, 1 word struct addr\n      area, and 4 word fp/alu register copy area.  */\n-  /* ??? Is the stack bias taken into account here?  */\n   extra_size\t = -STARTING_FRAME_OFFSET + FIRST_PARM_OFFSET(0);\n   var_size\t = size;\n   /* Also include the size needed for the 6 parameter registers.  */\n   args_size\t = current_function_outgoing_args_size + 24;\n   total_size\t = var_size + args_size + extra_size;\n   gp_reg_size\t = 0;\n   fp_reg_size\t = 0;\n-  mask\t\t = 0;\n+  gmask\t\t = 0;\n   fmask\t\t = 0;\n+  reg_offset\t = 0;\n+  need_aligned_p = 0;\n \n   /* Calculate space needed for gp registers.  */\n   for (regno = 1; regno <= 31; regno++)\n     {\n       if (MUST_SAVE_REGISTER (regno))\n \t{\n+\t  /* If we need to save two regs in a row, ensure there's room to bump\n+\t     up the address to align it to a doubleword boundary.  */\n \t  if ((regno & 0x1) == 0 && MUST_SAVE_REGISTER (regno+1))\n \t    {\n \t      if (gp_reg_size % 8 != 0)\n-\t\tgp_reg_size += UNITS_PER_WORD;\n+\t\tgp_reg_size += 4;\n \t      gp_reg_size += 2 * UNITS_PER_WORD;\n-\t      mask |= 3 << regno;\n+\t      gmask |= 3 << regno;\n \t      regno++;\n+\t      need_aligned_p = 1;\n \t    }\n \t  else\n \t    {\n \t      gp_reg_size += UNITS_PER_WORD;\n-\t      mask |= 1 << regno;\n+\t      gmask |= 1 << regno;\n \t    }\n \t}\n     }\n-  /* Add extra word in case we have to align the space to a double word\n-     boundary.  */\n-  if (gp_reg_size != 0)\n-    gp_reg_size += UNITS_PER_WORD;\n \n   /* Calculate space needed for fp registers.  */\n   for (regno = 32; regno <= 63; regno++)\n@@ -4296,8 +4301,21 @@ sparc_flat_compute_frame_size (size)\n \t}\n     }\n \n-  total_size += gp_reg_size + fp_reg_size;\n+  if (gmask || fmask)\n+    {\n+      int n;\n+      reg_offset = FIRST_PARM_OFFSET(0) + args_size;\n+      /* Ensure save area is 8 byte aligned if we need it.  */\n+      n = reg_offset % 8;\n+      if (need_aligned_p && n != 0)\n+\t{\n+\t  total_size += 8 - n;\n+\t  reg_offset += 8 - n;\n+\t}\n+      total_size += gp_reg_size + fp_reg_size;\n+    }\n \n+  /* ??? This looks a little suspicious.  Clarify.  */\n   if (total_size == extra_size)\n     total_size = extra_size = 0;\n \n@@ -4310,105 +4328,83 @@ sparc_flat_compute_frame_size (size)\n   current_frame_info.extra_size  = extra_size;\n   current_frame_info.gp_reg_size = gp_reg_size;\n   current_frame_info.fp_reg_size = fp_reg_size;\n-  current_frame_info.mask\t = mask;\n+  current_frame_info.gmask\t = gmask;\n   current_frame_info.fmask\t = fmask;\n+  current_frame_info.reg_offset\t = reg_offset;\n   current_frame_info.initialized = reload_completed;\n \n-  if (mask)\n-    {\n-      unsigned long offset = args_size;\n-      if (extra_size)\n-\toffset += FIRST_PARM_OFFSET(0);\n-      current_frame_info.gp_sp_offset = offset;\n-    }\n-\n-  if (fmask)\n-    {\n-      unsigned long offset = args_size + gp_reg_size;\n-      if (extra_size)\n-\toffset += FIRST_PARM_OFFSET(0);\n-      current_frame_info.fp_sp_offset = offset;\n-    }\n-\n   /* Ok, we're done.  */\n   return total_size;\n }\n \f\n-/* Common code to save/restore registers.  */\n+/* Save/restore registers in GMASK and FMASK at register BASE_REG plus offset\n+   OFFSET.\n+\n+   BASE_REG must be 8 byte aligned.  This allows us to test OFFSET for\n+   appropriate alignment and use DOUBLEWORD_OP when we can.  We assume\n+   [BASE_REG+OFFSET] will always be a valid address.\n+\n+   WORD_OP is either \"st\" for save, \"ld\" for restore.\n+   DOUBLEWORD_OP is either \"std\" for save, \"ldd\" for restore.  */\n \n void\n-sparc_flat_save_restore (file, word_op, doubleword_op)\n-     FILE *file;\t\t/* Stream to write to.  */\n-     char *word_op;\t\t/* Operation to do for one word.  */\n-     char *doubleword_op;\t/* Operation to do for doubleword.  */\n+sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op, doubleword_op)\n+     FILE *file;\n+     char *base_reg;\n+     unsigned int offset;\n+     unsigned long gmask;\n+     unsigned long fmask;\n+     char *word_op;\n+     char *doubleword_op;\n {\n   int regno;\n-  unsigned long mask\t  = current_frame_info.mask;\n-  unsigned long fmask\t  = current_frame_info.fmask;\n-  unsigned long gp_offset;\n-  unsigned long fp_offset;\n-  unsigned long max_offset;\n-  char *base_reg;\n-\n-  if (mask == 0 && fmask == 0)\n-    return;\n \n-  base_reg   = reg_names[STACK_POINTER_REGNUM];\n-  gp_offset  = current_frame_info.gp_sp_offset;\n-  fp_offset  = current_frame_info.fp_sp_offset;\n-  max_offset = (gp_offset > fp_offset) ? gp_offset : fp_offset;\n-\n-  /* Deal with calling functions with a large structure.  */\n-  if (max_offset >= 4096)\n-    {\n-      char *temp = \"%g2\";\n-      fprintf (file, \"\\tset %ld,%s\\n\", max_offset, temp);\n-      fprintf (file, \"\\tadd %s,%s,%s\\n\", temp, base_reg, temp);\n-      base_reg = temp;\n-      gp_offset = max_offset - gp_offset;\n-      fp_offset = max_offset - fp_offset;\n-    }\n+  if (gmask == 0 && fmask == 0)\n+    return;\n \n-  /* Save registers starting from high to low.  The debuggers prefer\n-     at least the return register be stored at func+4, and also it\n-     allows us not to need a nop in the epilog if at least one\n-     register is reloaded in addition to return address.  */\n+  /* Save registers starting from high to low.  We've already saved the\n+     previous frame pointer and previous return address for the debugger's\n+     sake.  The debugger allows us to not need a nop in the epilog if at least\n+     one register is reloaded in addition to return address.  */\n \n-  if (mask || frame_pointer_needed)\n+  if (gmask)\n     {\n       for (regno = 1; regno <= 31; regno++)\n \t{\n-\t  if ((mask & (1L << regno)) != 0\n-\t      || (regno == FRAME_POINTER_REGNUM && frame_pointer_needed))\n+\t  if ((gmask & (1L << regno)) != 0)\n \t    {\n-\t      if ((regno & 0x1) == 0 && ((mask & (1L << (regno+1))) != 0))\n+\t      if ((regno & 0x1) == 0 && ((gmask & (1L << (regno+1))) != 0))\n \t\t{\n-\t\t  if (gp_offset % 8 != 0)\n-\t\t    gp_offset += UNITS_PER_WORD;\n-\t\t  \n+\t\t  /* We can save two registers in a row.  If we're not at a\n+\t\t     double word boundary, move to one.\n+\t\t     sparc_flat_compute_frame_size ensures there's room to do\n+\t\t     this.  */\n+\t\t  if (offset % 8 != 0)\n+\t\t    offset += UNITS_PER_WORD;\n+\n \t\t  if (word_op[0] == 's')\n \t\t    fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n \t\t\t     doubleword_op, reg_names[regno],\n-\t\t\t     base_reg, gp_offset);\n+\t\t\t     base_reg, offset);\n \t\t  else\n \t\t    fprintf (file, \"\\t%s [%s+%d],%s\\n\",\n-\t\t\t     doubleword_op, base_reg, gp_offset,\n+\t\t\t     doubleword_op, base_reg, offset,\n \t\t\t     reg_names[regno]);\n \n-\t\t  gp_offset += 2 * UNITS_PER_WORD;\n+\t\t  offset += 2 * UNITS_PER_WORD;\n \t\t  regno++;\n \t\t}\n \t      else\n \t\t{\n \t\t  if (word_op[0] == 's')\n \t\t    fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n \t\t\t     word_op, reg_names[regno],\n-\t\t\t     base_reg, gp_offset);\n+\t\t\t     base_reg, offset);\n \t\t  else\n \t\t    fprintf (file, \"\\t%s [%s+%d],%s\\n\",\n-\t\t\t     word_op, base_reg, gp_offset, reg_names[regno]);\n+\t\t\t     word_op, base_reg, offset, reg_names[regno]);\n \n-\t\t  gp_offset += UNITS_PER_WORD;\n+\t\t  offset += UNITS_PER_WORD;\n \t\t}\n \t    }\n \t}\n@@ -4423,12 +4419,12 @@ sparc_flat_save_restore (file, word_op, doubleword_op)\n \t      if (word_op[0] == 's')\n \t\tfprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n \t\t\t word_op, reg_names[regno],\n-\t\t\t base_reg, gp_offset);\n+\t\t\t base_reg, offset);\n \t      else\n \t\tfprintf (file, \"\\t%s [%s+%d],%s\\n\",\n-\t\t\t word_op, base_reg, gp_offset, reg_names[regno]);\n+\t\t\t word_op, base_reg, offset, reg_names[regno]);\n \n-\t      fp_offset += UNITS_PER_WORD;\n+\t      offset += UNITS_PER_WORD;\n \t    }\n \t}\n     }\n@@ -4441,50 +4437,140 @@ sparc_flat_output_function_prologue (file, size)\n      FILE *file;\n      int size;\n {\n-  int tsize;\n   char *sp_str = reg_names[STACK_POINTER_REGNUM];\n+  unsigned long gmask = current_frame_info.gmask;\n \n   /* This is only for the human reader.  */\n   fprintf (file, \"\\t!#PROLOGUE# 0\\n\");\n+  fprintf (file, \"\\t!# vars= %d, regs= %d/%d, args= %d, extra= %d\\n\",\n+\t   current_frame_info.var_size,\n+\t   current_frame_info.gp_reg_size / 4,\n+\t   current_frame_info.fp_reg_size / 8,\n+\t   current_function_outgoing_args_size,\n+\t   current_frame_info.extra_size);\n \n   size = SPARC_STACK_ALIGN (size);\n-  tsize = (! current_frame_info.initialized\n-\t   ? sparc_flat_compute_frame_size (size)\n-\t   : current_frame_info.total_size);\n+  size = (! current_frame_info.initialized\n+\t  ? sparc_flat_compute_frame_size (size)\n+\t  : current_frame_info.total_size);\n \n-  if (tsize > 0)\n-    {\n-      if (tsize <= 4095)\n-\tfprintf (file,\n-\t\t \"\\tsub %s,%d,%s\\t\\t!# vars= %d, regs= %d/%d, args = %d, extra= %d\\n\",\n-\t\t sp_str, tsize, sp_str, current_frame_info.var_size,\n-\t\t current_frame_info.gp_reg_size / 4,\n-\t\t current_frame_info.fp_reg_size / 8,\n-\t\t current_function_outgoing_args_size,\n-\t\t current_frame_info.extra_size);\n-      else\n-\tfprintf (file,\n-\t\t \"\\tset %d,%s\\n\\tsub\\t%s,%s,%s\\t\\t!# vars= %d, regs= %d/%d, args = %d, sfo= %d\\n\",\n-\t\t tsize, \"%g1\", sp_str, \"%g1\",\n-\t\t sp_str, current_frame_info.var_size,\n-\t\t current_frame_info.gp_reg_size / 4,\n-\t\t current_frame_info.fp_reg_size / 8,\n-\t\t current_function_outgoing_args_size,\n-\t\t current_frame_info.extra_size);\n-    }\n-\n-  sparc_flat_save_restore (file, \"st\", \"std\");\n+  /* These cases shouldn't happen.  Catch them now.  */\n+  if (size == 0 && (gmask || current_frame_info.fmask))\n+    abort ();\n \n-  if (frame_pointer_needed)\n+  /* Allocate our stack frame by decrementing %sp.\n+     At present, the only algorithm gdb can use to determine if this is a\n+     flat frame is if we always set %i7 if we set %sp.  This can be optimized\n+     in the future by putting in some sort of debugging information that says\n+     this is a `flat' function.  However, there is still the case of debugging\n+     code without such debugging information (including cases where most fns\n+     have such info, but there is one that doesn't).  So, always do this now\n+     so we don't get a lot of code out there that gdb can't handle.\n+     If the frame pointer isn't needn't then that's ok - gdb won't be able to\n+     distinguish us from a non-flat function but there won't (and shouldn't)\n+     be any differences anyway.  The return pc is saved (if necessary) right\n+     after %i7 so gdb won't have to look too far to find it.  */\n+  if (size > 0)\n     {\n+      unsigned int reg_offset = current_frame_info.reg_offset;\n       char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n-\n-      if (tsize <= 4095)\n-\tfprintf (file, \"\\tadd %s,%d,%s\\t!# set up frame pointer\\n\", sp_str,\n-\t\t tsize, fp_str);\n+      char *t1_str = \"%g1\";\n+\n+      /* Things get a little tricky if local variables take up more than ~4096\n+\t bytes and outgoing arguments take up more than ~4096 bytes.  When that\n+\t happens, the register save area can't be accessed from either end of\n+\t the frame.  Handle this by decrementing %sp to the start of the gp\n+\t register save area, save the regs, update %i7, and then set %sp to its\n+\t final value.  Given that we only have one scratch register to play\n+\t with it is the cheapest solution, and it helps gdb out as it won't\n+\t slow down recognition of flat functions.\n+\t Don't change the order of insns emitted here without checking with\n+\t the gdb folk first.  */\n+\n+      /* Is the entire register save area offsetable from %sp?  */\n+      if (reg_offset < 4096 - 64 * UNITS_PER_WORD)\n+\t{\n+\t  if (size <= 4096)\n+\t    {\n+\t      fprintf (file, \"\\tadd %s,%d,%s\\n\",\n+\t\t       sp_str, -size, sp_str);\n+\t      if (gmask & FRAME_POINTER_MASK)\n+\t\t{\n+\t\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n+\t\t\t   fp_str, sp_str, reg_offset);\n+\t\t  fprintf (file, \"\\tsub %s,%d,%s\\t!# set up frame pointer\\n\",\n+\t\t\t   sp_str, -size, fp_str);\n+\t\t  reg_offset += 4;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (file, \"\\tset %d,%s\\n\\tsub %s,%s,%s\\n\",\n+\t\t       size, t1_str, sp_str, t1_str, sp_str);\n+\t      if (gmask & FRAME_POINTER_MASK)\n+\t\t{\n+\t\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n+\t\t\t   fp_str, sp_str, reg_offset);\n+\t\t  fprintf (file, \"\\tadd %s,%s,%s\\t!# set up frame pointer\\n\",\n+\t\t\t   sp_str, t1_str, fp_str);\n+\t\t  reg_offset += 4;\n+\t\t}\n+\t    }\n+\t  if (gmask & RETURN_ADDR_MASK)\n+\t    {\n+\t      fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n+\t\t       reg_names[RETURN_ADDR_REGNUM], sp_str, reg_offset);\n+\t      reg_offset += 4;\n+\t    }\n+\t  sparc_flat_save_restore (file, sp_str, reg_offset,\n+\t\t\t\t   gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n+\t\t\t\t   current_frame_info.fmask,\n+\t\t\t\t   \"st\", \"std\");\n+\t}\n       else\n-\tfprintf (file, \"\\tadd %s,%s,%s\\t!# set up frame pointer\\n\", sp_str,\n-\t\t \"%g1\", fp_str);\n+\t{\n+\t  /* Subtract %sp in two steps, but make sure there is always a\n+\t     64 byte register save area, and %sp is properly aligned.  */\n+\t  /* Amount to decrement %sp by, the first time.  */\n+\t  unsigned int size1 = ((size - reg_offset + 64) + 15) & -16;\n+\t  /* Offset to register save area from %sp.  */\n+\t  unsigned int offset = size1 - (size - reg_offset);\n+\t  \n+\t  if (size1 <= 4096)\n+\t    {\n+\t      fprintf (file, \"\\tadd %s,%d,%s\\n\",\n+\t\t       sp_str, -size1, sp_str);\n+\t      if (gmask & FRAME_POINTER_MASK)\n+\t\t{\n+\t\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\\tsub %s,%d,%s\\t!# set up frame pointer\\n\",\n+\t\t\t   fp_str, sp_str, offset, sp_str, -size1, fp_str);\n+\t\t  offset += 4;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (file, \"\\tset %d,%s\\n\\tsub %s,%s,%s\\n\",\n+\t\t       size1, t1_str, sp_str, t1_str, sp_str);\n+\t      if (gmask & FRAME_POINTER_MASK)\n+\t\t{\n+\t\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\\tadd %s,%s,%s\\t!# set up frame pointer\\n\",\n+\t\t\t   fp_str, sp_str, offset, sp_str, t1_str, fp_str);\n+\t\t  offset += 4;\n+\t\t}\n+\t    }\n+\t  if (gmask & RETURN_ADDR_MASK)\n+\t    {\n+\t      fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n+\t\t       reg_names[RETURN_ADDR_REGNUM], sp_str, offset);\n+\t      offset += 4;\n+\t    }\n+\t  sparc_flat_save_restore (file, sp_str, offset,\n+\t\t\t\t   gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n+\t\t\t\t   current_frame_info.fmask,\n+\t\t\t\t   \"st\", \"std\");\n+\t  fprintf (file, \"\\tset %d,%s\\n\\tsub %s,%s,%s\\n\",\n+\t\t   size - size1, t1_str, sp_str, t1_str, sp_str);\n+\t}\n     }\n \n   fprintf (file, \"\\t!#PROLOGUE# 1\\n\");\n@@ -4498,9 +4584,6 @@ sparc_flat_output_function_epilogue (file, size)\n      FILE *file;\n      int size;\n {\n-  int tsize;\n-  char *sp_str = reg_names[STACK_POINTER_REGNUM];\n-  char *t1_str = \"%g1\";\n   rtx epilogue_delay = current_function_epilogue_delay_list;\n   int noepilogue = FALSE;\n \n@@ -4513,11 +4596,11 @@ sparc_flat_output_function_epilogue (file, size)\n      multiply and divide).  */\n \n   size = SPARC_STACK_ALIGN (size);\n-  tsize = (!current_frame_info.initialized\n+  size = (!current_frame_info.initialized\n \t   ? sparc_flat_compute_frame_size (size)\n \t   : current_frame_info.total_size);\n \n-  if (tsize == 0 && epilogue_delay == 0)\n+  if (size == 0 && epilogue_delay == 0)\n     {\n       rtx insn = get_last_insn ();\n \n@@ -4531,25 +4614,77 @@ sparc_flat_output_function_epilogue (file, size)\n \n   if (!noepilogue)\n     {\n+      unsigned int reg_offset = current_frame_info.reg_offset;\n+      unsigned int size1;\n+      char *sp_str = reg_names[STACK_POINTER_REGNUM];\n+      char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n+      char *t1_str = \"%g1\";\n+\n       /* In the reload sequence, we don't need to fill the load delay\n \t slots for most of the loads, also see if we can fill the final\n \t delay slot if not otherwise filled by the reload sequence.  */\n \n-      if (tsize > 4095)\n-\tfprintf (file, \"\\tset %d,%s\\n\", tsize, t1_str);\n+      if (size > 4095)\n+\tfprintf (file, \"\\tset %d,%s\\n\", size, t1_str);\n \n       if (frame_pointer_needed)\n \t{\n-\t  char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n-\t  if (tsize > 4095)\n-\t    fprintf (file,\"\\tsub %s,%s,%s\\t\\t!# sp not trusted  here\\n\",\n+\t  if (size > 4095)\n+\t    fprintf (file,\"\\tsub %s,%s,%s\\t\\t!# sp not trusted here\\n\",\n \t\t     fp_str, t1_str, sp_str);\n \t  else\n-\t    fprintf (file,\"\\tsub %s,%d,%s\\t\\t!# sp not trusted  here\\n\",\n-\t\t     fp_str, tsize, sp_str);\n+\t    fprintf (file,\"\\tsub %s,%d,%s\\t\\t!# sp not trusted here\\n\",\n+\t\t     fp_str, size, sp_str);\n \t}\n \n-      sparc_flat_save_restore (file, \"ld\", \"ldd\");\n+      /* Is the entire register save area offsetable from %sp?  */\n+      if (reg_offset < 4096 - 64 * UNITS_PER_WORD)\n+\t{\n+\t  size1 = 0;\n+\t}\n+      else\n+\t{\n+\t  /* Restore %sp in two steps, but make sure there is always a\n+\t     64 byte register save area, and %sp is properly aligned.  */\n+\t  /* Amount to increment %sp by, the first time.  */\n+\t  size1 = ((reg_offset - 64 - 16) + 15) & -16;\n+\t  /* Offset to register save area from %sp.  */\n+\t  reg_offset = size1 - reg_offset;\n+\n+\t  fprintf (file, \"\\tset %d,%s\\n\\tadd %s,%s,%s\\n\",\n+\t\t   size1, t1_str, sp_str, t1_str, sp_str);\n+\t}\n+\n+      /* We must restore the frame pointer and return address reg first\n+\t because they are treated specially by the prologue output code.  */\n+      if (current_frame_info.gmask & FRAME_POINTER_MASK)\n+\t{\n+\t  fprintf (file, \"\\tld [%s+%d],%s\\n\",\n+\t\t   sp_str, reg_offset, fp_str);\n+\t  reg_offset += 4;\n+\t}\n+      if (current_frame_info.gmask & RETURN_ADDR_MASK)\n+\t{\n+\t  fprintf (file, \"\\tld [%s+%d],%s\\n\",\n+\t\t   sp_str, reg_offset, reg_names[RETURN_ADDR_REGNUM]);\n+\t  reg_offset += 4;\n+\t}\n+\n+      /* Restore any remaining saved registers.  */\n+      sparc_flat_save_restore (file, sp_str, reg_offset,\n+\t\t\t       current_frame_info.gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n+\t\t\t       current_frame_info.fmask,\n+\t\t\t       \"ld\", \"ldd\");\n+\n+      /* If we had to increment %sp in two steps, record it so the second\n+\t restoration in the epilogue finishes up.  */\n+      if (size1 > 0)\n+\t{\n+\t  size -= size1;\n+\t  if (size > 4095)\n+\t    fprintf (file, \"\\tset %d,%s\\n\",\n+\t\t     size, t1_str);\n+\t}\n \n       if (current_function_returns_struct)\n \tfprintf (file, \"\\tjmp %%o7+12\\n\");\n@@ -4563,16 +4698,16 @@ sparc_flat_output_function_epilogue (file, size)\n \n       if (epilogue_delay)\n \t{\n-\t  if (tsize)\n+\t  if (size)\n \t    abort ();\n \t  final_scan_insn (XEXP (epilogue_delay, 0), file, 1, -2, 1);\n \t}\n \n-      else if (tsize > 4095)\n+      else if (size > 4095)\n \tfprintf (file, \"\\tadd %s,%s,%s\\n\", sp_str, t1_str, sp_str);\n \n-      else if (tsize > 0)\n-\tfprintf (file, \"\\tadd %s,%d,%s\\n\", sp_str, tsize, sp_str);\n+      else if (size > 0)\n+\tfprintf (file, \"\\tadd %s,%d,%s\\n\", sp_str, size, sp_str);\n \n       else\n \tfprintf (file, \"\\tnop\\n\");"}]}