{"sha": "e8de5bad250909c9599da49d07f09fb9a8cabd0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThkZTViYWQyNTA5MDljOTU5OWRhNDlkMDdmMDlmYjlhOGNhYmQwZg==", "commit": {"author": {"name": "Ankur Saini", "email": "arsenic@sourceware.org", "date": "2021-07-25T09:17:53Z"}, "committer": {"name": "Ankur Saini", "email": "arsenic@sourceware.org", "date": "2021-07-29T03:07:49Z"}, "message": "analyzer: : Refactor callstring to work with pairs of supernodes.\n\n2021-07-25  Ankur Saini  <arsenic@sourceware.org>\n\ngcc/analyzer/ChangeLog:\n\t* call-string.cc (call_string::element_t::operator==): New operator.\n\t(call_String::element_t::operator!=): New operator.\n\t(call_string::element_t::get_caller_function): New function.\n\t(call_string::element_t::get_callee_function): New function.\n\t(call_string::call_string): Refactor to Initialise m_elements.\n\t(call_string::operator=): Refactor to work with m_elements.\n\t(call_string::operator==): Likewise.\n\t(call_string::to_json): Likewise.\n\t(call_string::hash): Refactor to hash e.m_caller.\n\t(call_string::push_call): Refactor to work with m_elements.\n\t(call_string::push_call): New overload to push call via supernodes.\n\t(call_string::pop): Refactor to work with m_elements.\n\t(call_string::calc_recursion_depth): Likewise.\n\t(call_string::cmp): Likewise.\n\t(call_string::validate): Likewise.\n\t(call_string::operator[]): Likewise.\n\t* call-string.h (class supernode): New forward decl.\n\t(struct call_string::element_t): New struct.\n\t(call_string::call_string): Refactor to initialise m_elements.\n\t(call_string::bool empty_p): Refactor to work with m_elements.\n\t(call_string::get_callee_node): New decl.\n\t(call_string::get_caller_node): New decl.\n\t(m_elements): Replaces m_return_edges.\n\t* program-point.cc (program_point::get_function_at_depth): Refactor to\n\twork with new call-string format.\n\t(program_point::validate): Likewise.\n\t(program_point::on_edge): Likewise.", "tree": {"sha": "d48f853a61c2594bb22af5bb39a55a41f7be42b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d48f853a61c2594bb22af5bb39a55a41f7be42b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8de5bad250909c9599da49d07f09fb9a8cabd0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8de5bad250909c9599da49d07f09fb9a8cabd0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8de5bad250909c9599da49d07f09fb9a8cabd0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8de5bad250909c9599da49d07f09fb9a8cabd0f/comments", "author": null, "committer": null, "parents": [{"sha": "7d11da87a1e3c7e0d274788ca43519513dae4bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d11da87a1e3c7e0d274788ca43519513dae4bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d11da87a1e3c7e0d274788ca43519513dae4bfe"}], "stats": {"total": 205, "additions": 154, "deletions": 51}, "files": [{"sha": "1e652a08a5ad259d0cc6119b805f525b9a0c9ce0", "filename": "gcc/analyzer/call-string.cc", "status": "modified", "additions": 105, "deletions": 38, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8de5bad250909c9599da49d07f09fb9a8cabd0f/gcc%2Fanalyzer%2Fcall-string.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8de5bad250909c9599da49d07f09fb9a8cabd0f/gcc%2Fanalyzer%2Fcall-string.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.cc?ref=e8de5bad250909c9599da49d07f09fb9a8cabd0f", "patch": "@@ -45,13 +45,42 @@ along with GCC; see the file COPYING3.  If not see\n \n /* class call_string.  */\n \n+/* struct call_string::element_t.  */\n+\n+/* call_string::element_t's equality operator.  */\n+\n+bool\n+call_string::element_t::operator== (const call_string::element_t &other) const\n+{\n+  return (m_caller == other.m_caller && m_callee == other.m_callee);\n+}\n+\n+/* call_string::element_t's inequality operator.  */\n+bool\n+call_string::element_t::operator!= (const call_string::element_t &other) const\n+{\n+  return !(*this == other);\n+}\n+\n+function *\n+call_string::element_t::get_caller_function () const\n+{\n+  return m_caller->get_function ();\n+}\n+\n+function *\n+call_string::element_t::get_callee_function () const\n+{\n+  return m_callee->get_function ();\n+}\n+\n /* call_string's copy ctor.  */\n \n call_string::call_string (const call_string &other)\n-: m_return_edges (other.m_return_edges.length ())\n+: m_elements (other.m_elements.length ())\n {\n-  for (const return_superedge *e : other.m_return_edges)\n-    m_return_edges.quick_push (e);\n+  for (const call_string::element_t &e : other.m_elements)\n+    m_elements.quick_push (e);\n }\n \n /* call_string's assignment operator.  */\n@@ -60,12 +89,12 @@ call_string&\n call_string::operator= (const call_string &other)\n {\n   // would be much simpler if we could rely on vec<> assignment op\n-  m_return_edges.truncate (0);\n-  m_return_edges.reserve (other.m_return_edges.length (), true);\n-  const return_superedge *e;\n+  m_elements.truncate (0);\n+  m_elements.reserve (other.m_elements.length (), true);\n+  call_string::element_t *e;\n   int i;\n-  FOR_EACH_VEC_ELT (other.m_return_edges, i, e)\n-    m_return_edges.quick_push (e);\n+  FOR_EACH_VEC_ELT (other.m_elements, i, e)\n+    m_elements.quick_push (*e);\n   return *this;\n }\n \n@@ -74,12 +103,12 @@ call_string::operator= (const call_string &other)\n bool\n call_string::operator== (const call_string &other) const\n {\n-  if (m_return_edges.length () != other.m_return_edges.length ())\n+  if (m_elements.length () != other.m_elements.length ())\n     return false;\n-  const return_superedge *e;\n+  call_string::element_t *e;\n   int i;\n-  FOR_EACH_VEC_ELT (m_return_edges, i, e)\n-    if (e != other.m_return_edges[i])\n+  FOR_EACH_VEC_ELT (m_elements, i, e)\n+    if (*e != other.m_elements[i])\n       return false;\n   return true;\n }\n@@ -91,15 +120,15 @@ call_string::print (pretty_printer *pp) const\n {\n   pp_string (pp, \"[\");\n \n-  const return_superedge *e;\n+  call_string::element_t *e;\n   int i;\n-  FOR_EACH_VEC_ELT (m_return_edges, i, e)\n+  FOR_EACH_VEC_ELT (m_elements, i, e)\n     {\n       if (i > 0)\n \tpp_string (pp, \", \");\n       pp_printf (pp, \"(SN: %i -> SN: %i in %s)\",\n-\t\t e->m_src->m_index, e->m_dest->m_index,\n-\t\t function_name (e->m_dest->m_fun));\n+\t\t e->m_callee->m_index, e->m_caller->m_index,\n+\t\t function_name (e->m_caller->m_fun));\n     }\n \n   pp_string (pp, \"]\");\n@@ -109,22 +138,22 @@ call_string::print (pretty_printer *pp) const\n    [{\"src_snode_idx\" : int,\n      \"dst_snode_idx\" : int,\n      \"funcname\" : str},\n-     ...for each return_superedge in the callstring].  */\n+     ...for each element in the callstring].  */\n \n json::value *\n call_string::to_json () const\n {\n   json::array *arr = new json::array ();\n \n-  for (const return_superedge *e : m_return_edges)\n+  for (const call_string::element_t &e : m_elements)\n     {\n       json::object *e_obj = new json::object ();\n       e_obj->set (\"src_snode_idx\",\n-\t\t  new json::integer_number (e->m_src->m_index));\n+\t\t  new json::integer_number (e.m_callee->m_index));\n       e_obj->set (\"dst_snode_idx\",\n-\t\t  new json::integer_number (e->m_dest->m_index));\n+\t\t  new json::integer_number (e.m_caller->m_index));\n       e_obj->set (\"funcname\",\n-\t\t  new json::string (function_name (e->m_dest->m_fun)));\n+\t\t  new json::string (function_name (e.m_caller->m_fun)));\n       arr->append (e_obj);\n     }\n \n@@ -137,8 +166,8 @@ hashval_t\n call_string::hash () const\n {\n   inchash::hash hstate;\n-  for (const return_superedge *e : m_return_edges)\n-    hstate.add_ptr (e);\n+  for (const call_string::element_t &e : m_elements)\n+    hstate.add_ptr (e.m_caller);\n   return hstate.end ();\n }\n \n@@ -152,22 +181,36 @@ call_string::push_call (const supergraph &sg,\n   gcc_assert (call_sedge);\n   const return_superedge *return_sedge = call_sedge->get_edge_for_return (sg);\n   gcc_assert (return_sedge);\n-  m_return_edges.safe_push (return_sedge);\n+  call_string::element_t e (return_sedge->m_dest, return_sedge->m_src);\n+  m_elements.safe_push (e);\n+}\n+\n+void\n+call_string::push_call (const supernode *caller,\n+\t\t\tconst supernode *callee)\n+{\n+  call_string::element_t e (caller, callee);\n+  m_elements.safe_push (e);\n+}\n+\n+call_string::element_t\n+call_string::pop ()\n+{\n+  return m_elements.pop();\n }\n \n /* Count the number of times the top-most call site appears in the\n    stack.  */\n-\n int\n call_string::calc_recursion_depth () const\n {\n-  if (m_return_edges.is_empty ())\n+  if (m_elements.is_empty ())\n     return 0;\n-  const return_superedge *top_return_sedge\n-    = m_return_edges[m_return_edges.length () - 1];\n+  const call_string::element_t top_return_sedge \n+    = m_elements[m_elements.length () - 1];\n \n   int result = 0;\n-  for (const return_superedge *e : m_return_edges)\n+  for (const call_string::element_t &e : m_elements)\n     if (e == top_return_sedge)\n       ++result;\n   return result;\n@@ -201,20 +244,42 @@ call_string::cmp (const call_string &a,\n       if (i >= len_b)\n \treturn -1;\n \n-      /* Otherwise, compare the edges.  */\n-      const return_superedge *edge_a = a[i];\n-      const return_superedge *edge_b = b[i];\n-      int src_cmp = edge_a->m_src->m_index - edge_b->m_src->m_index;\n+      /* Otherwise, compare the node pairs.  */\n+      const call_string::element_t a_node_pair = a[i];\n+      const call_string::element_t b_node_pair = b[i];\n+      int src_cmp \n+      \t= a_node_pair.m_callee->m_index - b_node_pair.m_callee->m_index;\n       if (src_cmp)\n \treturn src_cmp;\n-      int dest_cmp = edge_a->m_dest->m_index - edge_b->m_dest->m_index;\n+      int dest_cmp \n+      \t= a_node_pair.m_caller->m_index - b_node_pair.m_caller->m_index;\n       if (dest_cmp)\n \treturn dest_cmp;\n       i++;\n       // TODO: test coverage for this\n     }\n }\n \n+/* Return the pointer to callee of the topmost call in the stack,\n+   or NULL if stack is empty.  */\n+const supernode *\n+call_string::get_callee_node () const\n+{\n+  if(m_elements.is_empty ())\n+    return NULL;\n+  return m_elements[m_elements.length () - 1].m_callee;\n+}\n+\n+/* Return the pointer to caller of the topmost call in the stack,\n+   or NULL if stack is empty.  */\n+const supernode * \n+call_string::get_caller_node () const\n+{\n+  if(m_elements.is_empty ())\n+    return NULL;\n+  return m_elements[m_elements.length () - 1].m_caller;\n+}\n+\n /* Assert that this object is sane.  */\n \n void\n@@ -226,12 +291,14 @@ call_string::validate () const\n #endif\n \n   /* Each entry's \"caller\" should be the \"callee\" of the previous entry.  */\n-  const return_superedge *e;\n+  call_string::element_t *e;\n   int i;\n-  FOR_EACH_VEC_ELT (m_return_edges, i, e)\n+  FOR_EACH_VEC_ELT (m_elements, i, e)\n     if (i > 0)\n-      gcc_assert (e->get_caller_function ()\n-\t\t  == m_return_edges[i - 1]->get_callee_function ());\n+    {\n+      gcc_assert (e->get_caller_function () == \n+      \t\t  m_elements[i - 1].get_callee_function ());\n+    }\n }\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "a1ac60db4e9bc5c59a76349a2f4c541cb1333c7f", "filename": "gcc/analyzer/call-string.h", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8de5bad250909c9599da49d07f09fb9a8cabd0f/gcc%2Fanalyzer%2Fcall-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8de5bad250909c9599da49d07f09fb9a8cabd0f/gcc%2Fanalyzer%2Fcall-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.h?ref=e8de5bad250909c9599da49d07f09fb9a8cabd0f", "patch": "@@ -24,22 +24,48 @@ along with GCC; see the file COPYING3.  If not see\n namespace ana {\n \n class supergraph;\n+class supernode;\n class call_superedge;\n class return_superedge;\n \n+\n /* A string of return_superedge pointers, representing a call stack\n    at a program point.\n \n    This is used to ensure that we generate interprocedurally valid paths\n    i.e. that we return to the same callsite that called us.\n \n-   The class actually stores the return edges, rather than the call edges,\n-   since that's what we need to compare against.  */\n+   The class stores returning calls ( which may be represented by a\n+   returning superedge ). We do so because this is what we need to compare \n+   against.  */\n \n class call_string\n {\n public:\n-  call_string () : m_return_edges () {}\n+  /* A struct representing an element in the call_string.\n+\n+   Each element represents a path from m_callee to m_caller which represents\n+   returning from function.  */\n+\n+  struct element_t\n+  {\n+    element_t (const supernode *caller, const supernode *callee)\n+    :  m_caller (caller), m_callee (callee)\n+    {\n+    }\n+\n+    bool operator== (const element_t &other) const;\n+    bool operator!= (const element_t &other) const;\n+\n+    /* Accessors */\n+    function *get_caller_function () const;\n+    function *get_callee_function () const;\n+    \n+    const supernode *m_caller;\n+    const supernode *m_callee;\n+  };\n+\n+  call_string () : m_elements () {}\n   call_string (const call_string &other);\n   call_string& operator= (const call_string &other);\n \n@@ -51,27 +77,35 @@ class call_string\n \n   hashval_t hash () const;\n \n-  bool empty_p () const { return m_return_edges.is_empty (); }\n+  bool empty_p () const { return m_elements.is_empty (); }\n \n   void push_call (const supergraph &sg,\n \t\t  const call_superedge *sedge);\n-  const return_superedge *pop () { return m_return_edges.pop (); }\n+\n+  void push_call (const supernode *src, \n+    const supernode *dest);\n+\n+  element_t pop ();\n \n   int calc_recursion_depth () const;\n \n   static int cmp (const call_string &a,\n \t\t  const call_string &b);\n \n-  unsigned length () const { return m_return_edges.length (); }\n-  const return_superedge *operator[] (unsigned idx) const\n+  /* Accessors */\n+\n+  const supernode *get_callee_node () const;\n+  const supernode *get_caller_node () const;\n+  unsigned length () const { return m_elements.length (); }\n+  element_t operator[] (unsigned idx) const\n   {\n-    return m_return_edges[idx];\n+    return m_elements[idx];\n   }\n \n   void validate () const;\n \n private:\n-  auto_vec<const return_superedge *> m_return_edges;\n+  auto_vec<element_t> m_elements;\n };\n \n } // namespace ana"}, {"sha": "d9f50daeb3c34d234c28ef04dda09facddef99ea", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8de5bad250909c9599da49d07f09fb9a8cabd0f/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8de5bad250909c9599da49d07f09fb9a8cabd0f/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=e8de5bad250909c9599da49d07f09fb9a8cabd0f", "patch": "@@ -350,7 +350,7 @@ program_point::get_function_at_depth (unsigned depth) const\n   if (depth == m_call_string.length ())\n     return m_function_point.get_function ();\n   else\n-    return m_call_string[depth]->get_caller_function ();\n+    return m_call_string[depth].get_caller_function ();\n }\n \n /* Assert that this object is sane.  */\n@@ -367,7 +367,7 @@ program_point::validate () const\n   /* The \"callee\" of the final entry in the callstring should be the\n      function of the m_function_point.  */\n   if (m_call_string.length () > 0)\n-    gcc_assert (m_call_string[m_call_string.length () - 1]->get_callee_function ()\n+    gcc_assert (m_call_string[m_call_string.length () - 1].get_callee_function ()\n \t\t== get_function ());\n }\n \n@@ -438,8 +438,10 @@ program_point::on_edge (exploded_graph &eg,\n \t      logger->log (\"rejecting return edge: empty call string\");\n \t    return false;\n \t  }\n-\tconst return_superedge *top_of_stack = m_call_string.pop ();\n-\tif (top_of_stack != succ)\n+\tconst call_string::element_t top_of_stack = m_call_string.pop ();\n+\tcall_string::element_t current_call_string_element (succ->m_dest,\n+\t\t\t\t\t\t\t    succ->m_src);\n+\tif (top_of_stack != current_call_string_element)\n \t  {\n \t    if (logger)\n \t      logger->log (\"rejecting return edge: return to wrong callsite\");"}]}