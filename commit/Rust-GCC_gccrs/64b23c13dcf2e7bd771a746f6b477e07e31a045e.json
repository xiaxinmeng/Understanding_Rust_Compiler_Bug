{"sha": "64b23c13dcf2e7bd771a746f6b477e07e31a045e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRiMjNjMTNkY2YyZTdiZDc3MWE3NDZmNmI0NzdlMDdlMzFhMDQ1ZQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-03-04T15:50:27Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-03-04T15:50:27Z"}, "message": "PR c/68187: fix overzealous -Wmisleading-indentation (comment #1)\n\ngcc/c-family/ChangeLog:\n\tPR c/68187\n\t* c-indentation.c (get_visual_column): Move code to determine next\n\ttab stop to...\n\t(next_tab_stop): ...this new function.\n\t(line_contains_hash_if): Delete function.\n\t(detect_preprocessor_logic): Delete function.\n\t(get_first_nws_vis_column): New function.\n\t(detect_intervening_unindent): New function.\n\t(should_warn_for_misleading_indentation): Replace call to\n\tdetect_preprocessor_logic with a call to\n\tdetect_intervening_unindent.\n\ngcc/testsuite/ChangeLog:\n\tPR c/68187\n\t* c-c++-common/Wmisleading-indentation.c (fn_42_a): New test\n\tfunction.\n\t(fn_42_b): Likewise.\n\t(fn_42_c): Likewise.\n\nFrom-SVN: r233972", "tree": {"sha": "24010d29aad3b44205b89c06002db41c9964abd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24010d29aad3b44205b89c06002db41c9964abd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64b23c13dcf2e7bd771a746f6b477e07e31a045e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b23c13dcf2e7bd771a746f6b477e07e31a045e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b23c13dcf2e7bd771a746f6b477e07e31a045e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b23c13dcf2e7bd771a746f6b477e07e31a045e/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "729526f5d4399d141458ca0026490a1231149338", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729526f5d4399d141458ca0026490a1231149338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/729526f5d4399d141458ca0026490a1231149338"}], "stats": {"total": 235, "additions": 174, "deletions": 61}, "files": [{"sha": "f285c8b62be633de045d067e725ea89033d35831", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b23c13dcf2e7bd771a746f6b477e07e31a045e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b23c13dcf2e7bd771a746f6b477e07e31a045e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=64b23c13dcf2e7bd771a746f6b477e07e31a045e", "patch": "@@ -1,3 +1,17 @@\n+2016-03-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/68187\n+\t* c-indentation.c (get_visual_column): Move code to determine next\n+\ttab stop to...\n+\t(next_tab_stop): ...this new function.\n+\t(line_contains_hash_if): Delete function.\n+\t(detect_preprocessor_logic): Delete function.\n+\t(get_first_nws_vis_column): New function.\n+\t(detect_intervening_unindent): New function.\n+\t(should_warn_for_misleading_indentation): Replace call to\n+\tdetect_preprocessor_logic with a call to\n+\tdetect_intervening_unindent.\n+\n 2016-03-04  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/68187"}, {"sha": "b84fbf408e3e45731768746f6e6462efb0e45c4f", "filename": "gcc/c-family/c-indentation.c", "status": "modified", "additions": 80, "deletions": 61, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b23c13dcf2e7bd771a746f6b477e07e31a045e/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b23c13dcf2e7bd771a746f6b477e07e31a045e/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=64b23c13dcf2e7bd771a746f6b477e07e31a045e", "patch": "@@ -26,6 +26,16 @@ along with GCC; see the file COPYING3.  If not see\n \n extern cpp_options *cpp_opts;\n \n+/* Round up VIS_COLUMN to nearest tab stop. */\n+\n+static unsigned int\n+next_tab_stop (unsigned int vis_column)\n+{\n+  const unsigned int tab_width = cpp_opts->tabstop;\n+  vis_column = ((vis_column + tab_width) / tab_width) * tab_width;\n+  return vis_column;\n+}\n+\n /* Convert libcpp's notion of a column (a 1-based char count) to\n    the \"visual column\" (0-based column, respecting tabs), by reading the\n    relevant line.\n@@ -77,11 +87,7 @@ get_visual_column (expanded_location exploc, location_t loc,\n \t}\n \n       if (ch == '\\t')\n-       {\n-\t /* Round up to nearest tab stop. */\n-\t const unsigned int tab_width = cpp_opts->tabstop;\n-\t vis_column = ((vis_column + tab_width) / tab_width) * tab_width;\n-       }\n+\tvis_column = next_tab_stop (vis_column);\n       else\n        vis_column++;\n     }\n@@ -93,54 +99,49 @@ get_visual_column (expanded_location exploc, location_t loc,\n   return true;\n }\n \n-/* Does the given source line appear to contain a #if directive?\n-   (or #ifdef/#ifndef).  Ignore the possibility of it being inside a\n-   comment, for simplicity.\n-   Helper function for detect_preprocessor_logic.  */\n+/* Attempt to determine the first non-whitespace character in line LINE_NUM\n+   of source line FILE.\n+\n+   If this is possible, return true and write its \"visual column\" to\n+   *FIRST_NWS.\n+   Otherwise, return false, leaving *FIRST_NWS untouched.  */\n \n static bool\n-line_contains_hash_if (const char *file, int line_num)\n+get_first_nws_vis_column (const char *file, int line_num,\n+\t\t\t  unsigned int *first_nws)\n {\n+  gcc_assert (first_nws);\n+\n   int line_len;\n   const char *line = location_get_source_line (file, line_num, &line_len);\n   if (!line)\n     return false;\n+  unsigned int vis_column = 0;\n+  for (int i = 1; i < line_len; i++)\n+    {\n+      unsigned char ch = line[i - 1];\n \n-  int idx;\n-\n-  /* Skip leading whitespace.  */\n-  for (idx = 0; idx < line_len; idx++)\n-    if (!ISSPACE (line[idx]))\n-      break;\n-  if (idx == line_len)\n-    return false;\n-\n-  /* Require a '#' character.  */\n-  if (line[idx] != '#')\n-    return false;\n-  idx++;\n+      if (!ISSPACE (ch))\n+\t{\n+\t  *first_nws = vis_column;\n+\t  return true;\n+\t}\n \n-  /* Skip whitespace.  */\n-  while (idx < line_len)\n-    {\n-      if (!ISSPACE (line[idx]))\n-\tbreak;\n-      idx++;\n+      if (ch == '\\t')\n+\tvis_column = next_tab_stop (vis_column);\n+      else\n+\tvis_column++;\n     }\n \n-  /* Match #if/#ifdef/#ifndef.  */\n-  if (idx + 2 <= line_len)\n-    if (line[idx] == 'i')\n-      if (line[idx + 1] == 'f')\n-\treturn true;\n-\n+  /* No non-whitespace characters found.  */\n   return false;\n }\n \n-\n-/* Determine if there is preprocessor logic between\n+/* Determine if there is an unindent/outdent between\n    BODY_EXPLOC and NEXT_STMT_EXPLOC, to ensure that we don't\n-   issue a warning for cases like this:\n+   issue a warning for cases like the following:\n+\n+   (1) Preprocessor logic\n \n \tif (flagA)\n \t  foo ();\n@@ -151,31 +152,47 @@ line_contains_hash_if (const char *file, int line_num)\n \t  bar ();\n \t  ^ NEXT_STMT_EXPLOC\n \n-   despite \"bar ();\" being visually aligned below \"foo ();\" and\n-   being (as far as the parser sees) the next token.\n+   \"bar ();\" is visually aligned below \"foo ();\" and\n+   is (as far as the parser sees) the next token, but\n+   this isn't misleading to a human reader.\n \n-   Return true if such logic is detected.  */\n+   (2) Empty macro with bad indentation\n \n-static bool\n-detect_preprocessor_logic (expanded_location body_exploc,\n-\t\t\t   expanded_location next_stmt_exploc)\n-{\n-  gcc_assert (next_stmt_exploc.file == body_exploc.file);\n-  gcc_assert (next_stmt_exploc.line > body_exploc.line);\n+   In the following, the\n+     \"if (i > 0)\"\n+   is poorly indented, and ought to be on the same column as\n+      \"engine_ref_debug(e, 0, -1)\"\n+   However, it is not misleadingly indented, due to the presence\n+   of that macro.\n \n-  if (next_stmt_exploc.line - body_exploc.line < 4)\n-    return false;\n+      #define engine_ref_debug(X, Y, Z)\n+\n+      if (locked)\n+        i = foo (0);\n+      else\n+        i = foo (1);\n+      engine_ref_debug(e, 0, -1)\n+        if (i > 0)\n+        return 1;\n \n-  /* Is there a #if/#ifdef/#ifndef directive somewhere in the lines\n-     between the given locations?\n+   Return true if such an unindent/outdent is detected.  */\n \n-     This is something of a layering violation, but by necessity,\n-     given the nature of what we're testing for.  For example,\n-     in theory we could be fooled by a #if within a comment, but\n-     it's unlikely to matter.  */\n-  for (int line = body_exploc.line + 1; line < next_stmt_exploc.line; line++)\n-    if (line_contains_hash_if (body_exploc.file, line))\n-      return true;\n+static bool\n+detect_intervening_unindent (const char *file,\n+\t\t\t     int body_line,\n+\t\t\t     int next_stmt_line,\n+\t\t\t     unsigned int vis_column)\n+{\n+  gcc_assert (file);\n+  gcc_assert (next_stmt_line > body_line);\n+\n+  for (int line = body_line + 1; line < next_stmt_line; line++)\n+    {\n+      unsigned int line_vis_column;\n+      if (get_first_nws_vis_column (file, line, &line_vis_column))\n+\tif (line_vis_column < vis_column)\n+\t  return true;\n+    }\n \n   /* Not found.  */\n   return false;\n@@ -467,9 +484,11 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t  if (body_vis_column <= guard_line_first_nws)\n \t    return false;\n \n-\t  /* Don't warn if there is multiline preprocessor logic between\n-\t     the two statements. */\n-\t  if (detect_preprocessor_logic (body_exploc, next_stmt_exploc))\n+\t  /* Don't warn if there is an unindent between the two statements. */\n+\t  int vis_column = MIN (next_stmt_vis_column, body_vis_column);\n+\t  if (detect_intervening_unindent (body_exploc.file, body_exploc.line,\n+\t\t\t\t\t   next_stmt_exploc.line,\n+\t\t\t\t\t   vis_column))\n \t    return false;\n \n \t  /* Otherwise, they are visually aligned: issue a warning.  */"}, {"sha": "3c5caacb9f11f4355dcb926f8957afad3e4a5e73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b23c13dcf2e7bd771a746f6b477e07e31a045e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b23c13dcf2e7bd771a746f6b477e07e31a045e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=64b23c13dcf2e7bd771a746f6b477e07e31a045e", "patch": "@@ -1,3 +1,11 @@\n+2016-03-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/68187\n+\t* c-c++-common/Wmisleading-indentation.c (fn_42_a): New test\n+\tfunction.\n+\t(fn_42_b): Likewise.\n+\t(fn_42_c): Likewise.\n+\n 2016-03-04  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/68187"}, {"sha": "7b499d410fc3f8612dbaabbffdf433ae58364671", "filename": "gcc/testsuite/c-c++-common/Wmisleading-indentation.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b23c13dcf2e7bd771a746f6b477e07e31a045e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b23c13dcf2e7bd771a746f6b477e07e31a045e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c?ref=64b23c13dcf2e7bd771a746f6b477e07e31a045e", "patch": "@@ -982,3 +982,75 @@ fn_41_b (void)\n   if (!flagC)\n     goto fail;\n }\n+\n+/* In the following, the\n+     \"if (i > 0)\"\n+   is poorly indented, and ought to be on the same column as\n+      \"engine_ref_debug(e, 0, -1)\"\n+   However, it is not misleadingly indented, due to the presence\n+   of that macro.  Verify that we do not emit a warning about it\n+   not being guarded by the \"else\" clause above.\n+\n+   Based on an example seen in OpenSSL 1.0.1, which was filed as\n+   PR c/68187 in comment #1, though it's arguably a separate bug to\n+   the one in comment #0.  */\n+\n+int\n+fn_42_a (int locked)\n+{\n+#define engine_ref_debug(X, Y, Z)\n+\n+    int i;\n+\n+    if (locked)\n+        i = foo (0);\n+    else\n+        i = foo (1);\n+    engine_ref_debug(e, 0, -1)\n+        if (i > 0)\n+        return 1;\n+    return 0;\n+#undef engine_ref_debug\n+}\n+\n+/* As above, but the empty macro is at the same indentation level.\n+   This *is* misleading; verify that we do emit a warning about it.  */\n+\n+int\n+fn_42_b (int locked)\n+{\n+#define engine_ref_debug(X, Y, Z)\n+\n+    int i;\n+\n+    if (locked)\n+        i = foo (0);\n+    else /* { dg-message \"...this .else. clause\" } */\n+        i = foo (1);\n+        engine_ref_debug(e, 0, -1)\n+        if (i > 0) /* { dg-warning \"statement is indented\" } */\n+        return 1;\n+    return 0;\n+#undef engine_ref_debug\n+}\n+\n+/* As above, but where the body is a semicolon \"hidden\" by a preceding\n+   comment, where the semicolon is not in the same column as the successor\n+   \"if\" statement, but the empty macro expansion is at the same indentation\n+   level as the guard.\n+   This is poor indentation, but not misleading; verify that we don't emit a\n+   warning about it.  */\n+\n+int\n+fn_42_c (int locked, int i)\n+{\n+#define engine_ref_debug(X, Y, Z)\n+\n+    if (locked)\n+        /* blah */;\n+    engine_ref_debug(e, 0, -1)\n+        if (i > 0)\n+        return 1;\n+    return 0;\n+#undef engine_ref_debug\n+}"}]}