{"sha": "cc7b5acf3761c358bf9705f58b4fcf9625c49b0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M3YjVhY2YzNzYxYzM1OGJmOTcwNWY1OGI0ZmNmOTYyNWM0OWIwZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-11T13:23:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-11T13:23:26Z"}, "message": "match.pd: Implement patterns from associate_plusminus and factor in differences from the...\n\n2014-11-11  Richard Biener  <rguenther@suse.de>\n\n\t* match.pd: Implement patterns from associate_plusminus\n\tand factor in differences from the fold-const.c implementation.\n\t* fold-const.c (fold_binary_loc): Remove patterns here.\n\t* tree-ssa-forwprop.c (associate_plusminus): Remove.\n\t(pass_forwprop::execute): Don't call it.\n\t* tree.c (tree_nop_conversion_p): New function, factored\n\tfrom tree_nop_conversion.\n\t* tree.h (tree_nop_conversion_p): Declare.\n\nFrom-SVN: r217349", "tree": {"sha": "97ff581f26d92d0c274ac9fe16ef63b259ee439a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97ff581f26d92d0c274ac9fe16ef63b259ee439a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9310366b70c4953aff526ec62d0405dc729d5edf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9310366b70c4953aff526ec62d0405dc729d5edf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9310366b70c4953aff526ec62d0405dc729d5edf"}], "stats": {"total": 583, "additions": 147, "deletions": 436}, "files": [{"sha": "2d57bd3cc931aaaaad666c28a1f74ff6f0b97f7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc7b5acf3761c358bf9705f58b4fcf9625c49b0e", "patch": "@@ -1,3 +1,14 @@\n+2014-11-11  Richard Biener  <rguenther@suse.de>\n+\n+\t* match.pd: Implement patterns from associate_plusminus\n+\tand factor in differences from the fold-const.c implementation.\n+\t* fold-const.c (fold_binary_loc): Remove patterns here.\n+\t* tree-ssa-forwprop.c (associate_plusminus): Remove.\n+\t(pass_forwprop::execute): Don't call it.\n+\t* tree.c (tree_nop_conversion_p): New function, factored\n+\tfrom tree_nop_conversion.\n+\t* tree.h (tree_nop_conversion_p): Declare.\n+\n 2014-11-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* system.h: Include algorithm and utility."}, {"sha": "f3562ffd408f456fc8e4447c639612663dfb640c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=cc7b5acf3761c358bf9705f58b4fcf9625c49b0e", "patch": "@@ -9939,59 +9939,8 @@ fold_binary_loc (location_t loc,\n       return NULL_TREE;\n \n     case PLUS_EXPR:\n-      /* A + (-B) -> A - B */\n-      if (TREE_CODE (arg1) == NEGATE_EXPR\n-\t  && (flag_sanitize & SANITIZE_SI_OVERFLOW) == 0)\n-\treturn fold_build2_loc (loc, MINUS_EXPR, type,\n-\t\t\t    fold_convert_loc (loc, type, arg0),\n-\t\t\t    fold_convert_loc (loc, type,\n-\t\t\t\t\t      TREE_OPERAND (arg1, 0)));\n-      /* (-A) + B -> B - A */\n-      if (TREE_CODE (arg0) == NEGATE_EXPR\n-\t  && reorder_operands_p (TREE_OPERAND (arg0, 0), arg1)\n-\t  && (flag_sanitize & SANITIZE_SI_OVERFLOW) == 0)\n-\treturn fold_build2_loc (loc, MINUS_EXPR, type,\n-\t\t\t    fold_convert_loc (loc, type, arg1),\n-\t\t\t    fold_convert_loc (loc, type,\n-\t\t\t\t\t      TREE_OPERAND (arg0, 0)));\n-\n       if (INTEGRAL_TYPE_P (type) || VECTOR_INTEGER_TYPE_P (type))\n \t{\n-\t  /* Convert ~A + 1 to -A.  */\n-\t  if (TREE_CODE (arg0) == BIT_NOT_EXPR\n-\t      && integer_each_onep (arg1))\n-\t    return fold_build1_loc (loc, NEGATE_EXPR, type,\n-\t\t\t\tfold_convert_loc (loc, type,\n-\t\t\t\t\t\t  TREE_OPERAND (arg0, 0)));\n-\n-\t  /* ~X + X is -1.  */\n-\t  if (TREE_CODE (arg0) == BIT_NOT_EXPR\n-\t      && !TYPE_OVERFLOW_TRAPS (type))\n-\t    {\n-\t      tree tem = TREE_OPERAND (arg0, 0);\n-\n-\t      STRIP_NOPS (tem);\n-\t      if (operand_equal_p (tem, arg1, 0))\n-\t\t{\n-\t\t  t1 = build_all_ones_cst (type);\n-\t\t  return omit_one_operand_loc (loc, type, t1, arg1);\n-\t\t}\n-\t    }\n-\n-\t  /* X + ~X is -1.  */\n-\t  if (TREE_CODE (arg1) == BIT_NOT_EXPR\n-\t      && !TYPE_OVERFLOW_TRAPS (type))\n-\t    {\n-\t      tree tem = TREE_OPERAND (arg1, 0);\n-\n-\t      STRIP_NOPS (tem);\n-\t      if (operand_equal_p (arg0, tem, 0))\n-\t\t{\n-\t\t  t1 = build_all_ones_cst (type);\n-\t\t  return omit_one_operand_loc (loc, type, t1, arg0);\n-\t\t}\n-\t    }\n-\n \t  /* X + (X / CST) * -CST is X % CST.  */\n \t  if (TREE_CODE (arg1) == MULT_EXPR\n \t      && TREE_CODE (TREE_OPERAND (arg1, 0)) == TRUNC_DIV_EXPR\n@@ -10469,11 +10418,6 @@ fold_binary_loc (location_t loc,\n \t\treturn fold_build2_loc (loc, MINUS_EXPR, type, tmp, arg11);\n \t    }\n \t}\n-      /* A - (-B) -> A + B */\n-      if (TREE_CODE (arg1) == NEGATE_EXPR)\n-\treturn fold_build2_loc (loc, PLUS_EXPR, type, op0,\n-\t\t\t    fold_convert_loc (loc, type,\n-\t\t\t\t\t      TREE_OPERAND (arg1, 0)));\n       /* (-A) - B -> (-B) - A  where B is easily negated and we can swap.  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR\n \t  && negate_expr_p (arg1)"}, {"sha": "29b5ab298724caa9ed1e36390d04c2473fb271be", "filename": "gcc/match.pd", "status": "modified", "additions": 113, "deletions": 6, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=cc7b5acf3761c358bf9705f58b4fcf9625c49b0e", "patch": "@@ -25,8 +25,9 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Generic tree predicates we inherit.  */\n (define_predicates\n-   integer_onep integer_zerop integer_all_onesp\n-   real_zerop real_onep\n+   integer_onep integer_zerop integer_all_onesp integer_minus_onep\n+   integer_each_onep\n+   real_zerop real_onep real_minus_onep\n    CONSTANT_CLASS_P\n    tree_expr_nonnegative_p)\n \n@@ -239,10 +240,6 @@ along with GCC; see the file COPYING3.  If not see\n   (bit_not (bit_not @0))\n   @0)\n \n-(simplify\n- (negate (negate @0))\n- @0)\n-\n \n /* Associate (p +p off1) +p off2 as (p +p (off1 + off2)).  */\n (simplify\n@@ -278,6 +275,116 @@ along with GCC; see the file COPYING3.  If not see\n    (bit_and @0 { algn; })))\n \n \n+/* We can't reassociate at all for saturating types.  */\n+(if (!TYPE_SATURATING (type))\n+\n+ /* Contract negates.  */\n+ /* A + (-B) -> A - B */\n+ (simplify\n+  (plus:c (convert1? @0) (convert2? (negate @1)))\n+  /* Apply STRIP_NOPS on @0 and the negate.  */\n+  (if (tree_nop_conversion_p (type, TREE_TYPE (@0))\n+       && tree_nop_conversion_p (type, TREE_TYPE (@1))\n+       && (flag_sanitize & SANITIZE_SI_OVERFLOW) == 0)\n+   (minus (convert @0) (convert @1))))\n+ /* A - (-B) -> A + B */\n+ (simplify\n+  (minus (convert1? @0) (convert2? (negate @1)))\n+  (if (tree_nop_conversion_p (type, TREE_TYPE (@0))\n+       && tree_nop_conversion_p (type, TREE_TYPE (@1)))\n+   (plus (convert @0) (convert @1))))\n+ /* -(-A) -> A */\n+ (simplify\n+  (negate (convert? (negate @1)))\n+  (if (tree_nop_conversion_p (type, TREE_TYPE (@1))\n+       && (TYPE_OVERFLOW_WRAPS (type)\n+\t   || (flag_sanitize & SANITIZE_SI_OVERFLOW) == 0))\n+   @1))\n+\n+ /* We can't reassociate floating-point or fixed-point plus or minus\n+    because of saturation to +-Inf.  */\n+ (if (!FLOAT_TYPE_P (type) && !FIXED_POINT_TYPE_P (type))\n+\n+  /* Match patterns that allow contracting a plus-minus pair\n+     irrespective of overflow issues.  */\n+  /* (A +- B) - A       ->  +- B */\n+  /* (A +- B) -+ B      ->  A */\n+  /* A - (A +- B)       -> -+ B */\n+  /* A +- (B -+ A)      ->  +- B */\n+  (simplify\n+    (minus (plus:c @0 @1) @0)\n+    @1)\n+  (simplify\n+    (minus (minus @0 @1) @0)\n+    (negate @1))\n+  (simplify\n+    (plus:c (minus @0 @1) @1)\n+    @0)\n+  (simplify\n+   (minus @0 (plus:c @0 @1))\n+   (negate @1))\n+  (simplify\n+   (minus @0 (minus @0 @1))\n+   @1)\n+\n+  /* (A +- CST) +- CST -> A + CST  */\n+  (for outer_op (plus minus)\n+   (for inner_op (plus minus)\n+    (simplify\n+     (outer_op (inner_op @0 CONSTANT_CLASS_P@1) CONSTANT_CLASS_P@2)\n+     /* If the constant operation overflows we cannot do the transform\n+\tas we would introduce undefined overflow, for example\n+\twith (a - 1) + INT_MIN.  */\n+     (with { tree cst = fold_binary (outer_op == inner_op\n+\t\t\t\t     ? PLUS_EXPR : MINUS_EXPR, type, @1, @2); }\n+      (if (cst && !TREE_OVERFLOW (cst))\n+       (inner_op @0 { cst; } ))))))\n+\n+  /* (CST - A) +- CST -> CST - A  */\n+  (for outer_op (plus minus)\n+   (simplify\n+    (outer_op (minus CONSTANT_CLASS_P@1 @0) CONSTANT_CLASS_P@2)\n+    (with { tree cst = fold_binary (outer_op, type, @1, @2); }\n+     (if (cst && !TREE_OVERFLOW (cst))\n+      (minus { cst; } @0)))))\n+\n+  /* ~A + A -> -1 */\n+  (simplify\n+   (plus:c (bit_not @0) @0)\n+   (if (!TYPE_OVERFLOW_TRAPS (type))\n+    { build_all_ones_cst (type); }))\n+\n+  /* ~A + 1 -> -A */\n+  (simplify\n+   (plus (bit_not @0) integer_each_onep)\n+   (negate @0))\n+\n+  /* (T)(P + A) - (T)P -> (T) A */\n+  (for add (plus pointer_plus)\n+   (simplify\n+    (minus (convert (add @0 @1))\n+     (convert @0))\n+    (if (TYPE_PRECISION (type) <= TYPE_PRECISION (TREE_TYPE (@1))\n+\t /* For integer types, if A has a smaller type\n+\t    than T the result depends on the possible\n+\t    overflow in P + A.\n+\t    E.g. T=size_t, A=(unsigned)429497295, P>0.\n+\t    However, if an overflow in P + A would cause\n+\t    undefined behavior, we can assume that there\n+\t    is no overflow.  */\n+\t || (INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+\t     && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (@0)))\n+\t /* For pointer types, if the conversion of A to the\n+\t    final type requires a sign- or zero-extension,\n+\t    then we have to punt - it is not defined which\n+\t    one is correct.  */\n+\t || (POINTER_TYPE_P (TREE_TYPE (@0))\n+\t     && TREE_CODE (@1) == INTEGER_CST\n+\t     && tree_int_cst_sign_bit (@1) == 0))\n+     (convert @1))))))\n+\n+\n+\n /* Simplifications of conversions.  */\n \n /* Basic strip-useless-type-conversions / strip_nops.  */"}, {"sha": "b47f7e202518a48de8d9f99d1662b574f4e9b957", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 0, "deletions": 361, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=cc7b5acf3761c358bf9705f58b4fcf9625c49b0e", "patch": "@@ -1920,359 +1920,6 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n   return true;\n }\n \n-/* Perform re-associations of the plus or minus statement STMT that are\n-   always permitted.  Returns true if the CFG was changed.  */\n-\n-static bool\n-associate_plusminus (gimple_stmt_iterator *gsi)\n-{\n-  gimple stmt = gsi_stmt (*gsi);\n-  tree rhs1 = gimple_assign_rhs1 (stmt);\n-  tree rhs2 = gimple_assign_rhs2 (stmt);\n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-  bool changed;\n-\n-  /* We can't reassociate at all for saturating types.  */\n-  if (TYPE_SATURATING (TREE_TYPE (rhs1)))\n-    return false;\n-\n-  /* First contract negates.  */\n-  do\n-    {\n-      changed = false;\n-\n-      /* A +- (-B) -> A -+ B.  */\n-      if (TREE_CODE (rhs2) == SSA_NAME)\n-\t{\n-\t  gimple def_stmt = SSA_NAME_DEF_STMT (rhs2);\n-\t  if (is_gimple_assign (def_stmt)\n-\t      && gimple_assign_rhs_code (def_stmt) == NEGATE_EXPR\n-\t      && can_propagate_from (def_stmt))\n-\t    {\n-\t      code = (code == MINUS_EXPR) ? PLUS_EXPR : MINUS_EXPR;\n-\t      gimple_assign_set_rhs_code (stmt, code);\n-\t      rhs2 = gimple_assign_rhs1 (def_stmt);\n-\t      gimple_assign_set_rhs2 (stmt, rhs2);\n-\t      gimple_set_modified (stmt, true);\n-\t      changed = true;\n-\t    }\n-\t}\n-\n-      /* (-A) + B -> B - A.  */\n-      if (TREE_CODE (rhs1) == SSA_NAME\n-\t  && code == PLUS_EXPR)\n-\t{\n-\t  gimple def_stmt = SSA_NAME_DEF_STMT (rhs1);\n-\t  if (is_gimple_assign (def_stmt)\n-\t      && gimple_assign_rhs_code (def_stmt) == NEGATE_EXPR\n-\t      && can_propagate_from (def_stmt))\n-\t    {\n-\t      code = MINUS_EXPR;\n-\t      gimple_assign_set_rhs_code (stmt, code);\n-\t      rhs1 = rhs2;\n-\t      gimple_assign_set_rhs1 (stmt, rhs1);\n-\t      rhs2 = gimple_assign_rhs1 (def_stmt);\n-\t      gimple_assign_set_rhs2 (stmt, rhs2);\n-\t      gimple_set_modified (stmt, true);\n-\t      changed = true;\n-\t    }\n-\t}\n-    }\n-  while (changed);\n-\n-  /* We can't reassociate floating-point or fixed-point plus or minus\n-     because of saturation to +-Inf.  */\n-  if (FLOAT_TYPE_P (TREE_TYPE (rhs1))\n-      || FIXED_POINT_TYPE_P (TREE_TYPE (rhs1)))\n-    goto out;\n-\n-  /* Second match patterns that allow contracting a plus-minus pair\n-     irrespective of overflow issues.\n-\n-\t(A +- B) - A       ->  +- B\n-\t(A +- B) -+ B      ->  A\n-\t(CST +- A) +- CST  ->  CST +- A\n-\t(A +- CST) +- CST  ->  A +- CST\n-\t~A + A             ->  -1\n-\t~A + 1             ->  -A \n-\tA - (A +- B)       ->  -+ B\n-\tA +- (B +- A)      ->  +- B\n-\tCST +- (CST +- A)  ->  CST +- A\n-\tCST +- (A +- CST)  ->  CST +- A\n-\tA + ~A             ->  -1\n-\t(T)(P + A) - (T)P  -> (T)A\n-\n-     via commutating the addition and contracting operations to zero\n-     by reassociation.  */\n-\n-  if (TREE_CODE (rhs1) == SSA_NAME)\n-    {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (rhs1);\n-      if (is_gimple_assign (def_stmt) && can_propagate_from (def_stmt))\n-\t{\n-\t  enum tree_code def_code = gimple_assign_rhs_code (def_stmt);\n-\t  if (def_code == PLUS_EXPR\n-\t      || def_code == MINUS_EXPR)\n-\t    {\n-\t      tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n-\t      tree def_rhs2 = gimple_assign_rhs2 (def_stmt);\n-\t      if (operand_equal_p (def_rhs1, rhs2, 0)\n-\t\t  && code == MINUS_EXPR)\n-\t\t{\n-\t\t  /* (A +- B) - A -> +- B.  */\n-\t\t  code = ((def_code == PLUS_EXPR)\n-\t\t\t  ? TREE_CODE (def_rhs2) : NEGATE_EXPR);\n-\t\t  rhs1 = def_rhs2;\n-\t\t  rhs2 = NULL_TREE;\n-\t\t  gimple_assign_set_rhs_with_ops (gsi, code, rhs1, NULL_TREE);\n-\t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t\t  gimple_set_modified (stmt, true);\n-\t\t}\n-\t      else if (operand_equal_p (def_rhs2, rhs2, 0)\n-\t\t       && code != def_code)\n-\t\t{\n-\t\t  /* (A +- B) -+ B -> A.  */\n-\t\t  code = TREE_CODE (def_rhs1);\n-\t\t  rhs1 = def_rhs1;\n-\t\t  rhs2 = NULL_TREE;\n-\t\t  gimple_assign_set_rhs_with_ops (gsi, code, rhs1, NULL_TREE);\n-\t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t\t  gimple_set_modified (stmt, true);\n-\t\t}\n-\t      else if (CONSTANT_CLASS_P (rhs2)\n-\t\t       && CONSTANT_CLASS_P (def_rhs1))\n-\t\t{\n-\t\t  /* (CST +- A) +- CST -> CST +- A.  */\n-\t\t  tree cst = fold_binary (code, TREE_TYPE (rhs1),\n-\t\t\t\t\t  def_rhs1, rhs2);\n-\t\t  if (cst && !TREE_OVERFLOW (cst))\n-\t\t    {\n-\t\t      code = def_code;\n-\t\t      gimple_assign_set_rhs_code (stmt, code);\n-\t\t      rhs1 = cst;\n-\t\t      gimple_assign_set_rhs1 (stmt, rhs1);\n-\t\t      rhs2 = def_rhs2;\n-\t\t      gimple_assign_set_rhs2 (stmt, rhs2);\n-\t\t      gimple_set_modified (stmt, true);\n-\t\t    }\n-\t\t}\n-\t      else if (CONSTANT_CLASS_P (rhs2)\n-\t\t       && CONSTANT_CLASS_P (def_rhs2))\n-\t\t{\n-\t\t  /* (A +- CST) +- CST -> A +- CST.  */\n-\t\t  enum tree_code mix = (code == def_code)\n-\t\t\t\t       ? PLUS_EXPR : MINUS_EXPR;\n-\t\t  tree cst = fold_binary (mix, TREE_TYPE (rhs1),\n-\t\t\t\t\t  def_rhs2, rhs2);\n-\t\t  if (cst && !TREE_OVERFLOW (cst))\n-\t\t    {\n-\t\t      code = def_code;\n-\t\t      gimple_assign_set_rhs_code (stmt, code);\n-\t\t      rhs1 = def_rhs1;\n-\t\t      gimple_assign_set_rhs1 (stmt, rhs1);\n-\t\t      rhs2 = cst;\n-\t\t      gimple_assign_set_rhs2 (stmt, rhs2);\n-\t\t      gimple_set_modified (stmt, true);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else if (def_code == BIT_NOT_EXPR && code == PLUS_EXPR)\n-\t    {\n-\t      tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n-\t      if (operand_equal_p (def_rhs1, rhs2, 0))\n-\t\t{\n-\t\t  /* ~A + A -> -1.  */\n-\t\t  rhs1 = build_all_ones_cst (TREE_TYPE (rhs2));\n-\t\t  rhs2 = NULL_TREE;\n-\t\t  code = TREE_CODE (rhs1);\n-\t\t  gimple_assign_set_rhs_with_ops (gsi, code, rhs1, NULL_TREE);\n-\t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t\t  gimple_set_modified (stmt, true);\n-\t\t}\n-\t      else if ((TREE_CODE (TREE_TYPE (rhs2)) != COMPLEX_TYPE\n-\t\t\t&& integer_onep (rhs2))\n-\t\t       || (TREE_CODE (rhs2) == COMPLEX_CST\n-\t\t\t   && integer_onep (TREE_REALPART (rhs2))\n-\t\t\t   && integer_onep (TREE_IMAGPART (rhs2))))\n-\t\t{\n-\t\t  /* ~A + 1 -> -A.  */\n-\t\t  code = NEGATE_EXPR;\n-\t\t  rhs1 = def_rhs1;\n-\t\t  rhs2 = NULL_TREE;\n-\t\t  gimple_assign_set_rhs_with_ops (gsi, code, rhs1, NULL_TREE);\n-\t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t\t  gimple_set_modified (stmt, true);\n-\t\t}\n-\t    }\n-\t  else if (code == MINUS_EXPR\n-\t\t   && CONVERT_EXPR_CODE_P (def_code)\n-\t\t   && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME\n-\t\t   && TREE_CODE (rhs2) == SSA_NAME)\n-\t    {\n-\t      /* (T)(P + A) - (T)P -> (T)A.  */\n-\t      gimple def_stmt2 = SSA_NAME_DEF_STMT (rhs2);\n-\t      if (is_gimple_assign (def_stmt2)\n-\t\t  && can_propagate_from (def_stmt2)\n-\t\t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt2))\n-\t\t  && TREE_CODE (gimple_assign_rhs1 (def_stmt2)) == SSA_NAME)\n-\t\t{\n-\t\t  /* Now we have (T)X - (T)P.  */\n-\t\t  tree p = gimple_assign_rhs1 (def_stmt2);\n-\t\t  def_stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (def_stmt));\n-\t\t  if (is_gimple_assign (def_stmt2)\n-\t\t      && can_propagate_from (def_stmt2)\n-\t\t      && (gimple_assign_rhs_code (def_stmt2) == POINTER_PLUS_EXPR\n-\t\t\t  || gimple_assign_rhs_code (def_stmt2) == PLUS_EXPR)\n-\t\t      && gimple_assign_rhs1 (def_stmt2) == p)\n-\t\t    {\n-\t\t      /* And finally (T)(P + A) - (T)P.  */\n-\t\t      tree a = gimple_assign_rhs2 (def_stmt2);\n-\t\t      if (TYPE_PRECISION (TREE_TYPE (rhs1))\n-\t\t\t  <= TYPE_PRECISION (TREE_TYPE (a))\n-\t\t\t  /* For integer types, if A has a smaller type\n-\t\t\t     than T the result depends on the possible\n-\t\t\t     overflow in P + A.\n-\t\t\t     E.g. T=size_t, A=(unsigned)429497295, P>0.\n-\t\t\t     However, if an overflow in P + A would cause\n-\t\t\t     undefined behavior, we can assume that there\n-\t\t\t     is no overflow.  */\n-\t\t\t  || (INTEGRAL_TYPE_P (TREE_TYPE (p))\n-\t\t\t      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (p)))\n-\t\t\t  /* For pointer types, if the conversion of A to the\n-\t\t\t     final type requires a sign- or zero-extension,\n-\t\t\t     then we have to punt - it is not defined which\n-\t\t\t     one is correct.  */\n-\t\t\t  || (POINTER_TYPE_P (TREE_TYPE (p))\n-\t\t\t      && TREE_CODE (a) == INTEGER_CST\n-\t\t\t      && tree_int_cst_sign_bit (a) == 0))\n-\t\t\t{\n-\t\t\t  if (issue_strict_overflow_warning\n-\t\t\t      (WARN_STRICT_OVERFLOW_MISC)\n-\t\t\t      && TYPE_PRECISION (TREE_TYPE (rhs1))\n-\t\t\t\t > TYPE_PRECISION (TREE_TYPE (a))\n-\t\t\t      && INTEGRAL_TYPE_P (TREE_TYPE (p)))\n-\t\t\t    warning_at (gimple_location (stmt),\n-\t\t\t\t\tOPT_Wstrict_overflow,\n-\t\t\t\t\t\"assuming signed overflow does not \"\n-\t\t\t\t\t\"occur when assuming that \"\n-\t\t\t\t\t\"(T)(P + A) - (T)P is always (T)A\");\n-\t\t\t  if (useless_type_conversion_p (TREE_TYPE (rhs1),\n-\t\t\t\t\t\t\t TREE_TYPE (a)))\n-\t\t\t    code = TREE_CODE (a);\n-\t\t\t  else\n-\t\t\t    code = NOP_EXPR;\n-\t\t\t  rhs1 = a;\n-\t\t\t  rhs2 = NULL_TREE;\n-\t\t\t  gimple_assign_set_rhs_with_ops (gsi, code, rhs1,\n-\t\t\t\t\t\t\t  rhs2);\n-\t\t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t\t\t  gimple_set_modified (stmt, true);\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (rhs2 && TREE_CODE (rhs2) == SSA_NAME)\n-    {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (rhs2);\n-      if (is_gimple_assign (def_stmt) && can_propagate_from (def_stmt))\n-\t{\n-\t  enum tree_code def_code = gimple_assign_rhs_code (def_stmt);\n-\t  if (def_code == PLUS_EXPR\n-\t      || def_code == MINUS_EXPR)\n-\t    {\n-\t      tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n-\t      tree def_rhs2 = gimple_assign_rhs2 (def_stmt);\n-\t      if (operand_equal_p (def_rhs1, rhs1, 0)\n-\t\t  && code == MINUS_EXPR)\n-\t\t{\n-\t\t  /* A - (A +- B) -> -+ B.  */\n-\t\t  code = ((def_code == PLUS_EXPR)\n-\t\t\t  ? NEGATE_EXPR : TREE_CODE (def_rhs2));\n-\t\t  rhs1 = def_rhs2;\n-\t\t  rhs2 = NULL_TREE;\n-\t\t  gimple_assign_set_rhs_with_ops (gsi, code, rhs1, NULL_TREE);\n-\t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t\t  gimple_set_modified (stmt, true);\n-\t\t}\n-\t      else if (operand_equal_p (def_rhs2, rhs1, 0)\n-\t\t       && code != def_code)\n-\t\t{\n-\t\t  /* A +- (B +- A) -> +- B.  */\n-\t\t  code = ((code == PLUS_EXPR)\n-\t\t\t  ? TREE_CODE (def_rhs1) : NEGATE_EXPR);\n-\t\t  rhs1 = def_rhs1;\n-\t\t  rhs2 = NULL_TREE;\n-\t\t  gimple_assign_set_rhs_with_ops (gsi, code, rhs1, NULL_TREE);\n-\t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t\t  gimple_set_modified (stmt, true);\n-\t\t}\n-\t      else if (CONSTANT_CLASS_P (rhs1)\n-\t\t       && CONSTANT_CLASS_P (def_rhs1))\n-\t\t{\n-\t\t  /* CST +- (CST +- A) -> CST +- A.  */\n-\t\t  tree cst = fold_binary (code, TREE_TYPE (rhs2),\n-\t\t\t\t\t  rhs1, def_rhs1);\n-\t\t  if (cst && !TREE_OVERFLOW (cst))\n-\t\t    {\n-\t\t      code = (code == def_code ? PLUS_EXPR : MINUS_EXPR);\n-\t\t      gimple_assign_set_rhs_code (stmt, code);\n-\t\t      rhs1 = cst;\n-\t\t      gimple_assign_set_rhs1 (stmt, rhs1);\n-\t\t      rhs2 = def_rhs2;\n-\t\t      gimple_assign_set_rhs2 (stmt, rhs2);\n-\t\t      gimple_set_modified (stmt, true);\n-\t\t    }\n-\t\t}\n-\t      else if (CONSTANT_CLASS_P (rhs1)\n-\t\t       && CONSTANT_CLASS_P (def_rhs2))\n-\t\t{\n-\t\t  /* CST +- (A +- CST) -> CST +- A.  */\n-\t\t  tree cst = fold_binary (def_code == code\n-\t\t\t\t\t  ? PLUS_EXPR : MINUS_EXPR,\n-\t\t\t\t\t  TREE_TYPE (rhs2),\n-\t\t\t\t\t  rhs1, def_rhs2);\n-\t\t  if (cst && !TREE_OVERFLOW (cst))\n-\t\t    {\n-\t\t      rhs1 = cst;\n-\t\t      gimple_assign_set_rhs1 (stmt, rhs1);\n-\t\t      rhs2 = def_rhs1;\n-\t\t      gimple_assign_set_rhs2 (stmt, rhs2);\n-\t\t      gimple_set_modified (stmt, true);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else if (def_code == BIT_NOT_EXPR)\n-\t    {\n-\t      tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n-\t      if (code == PLUS_EXPR\n-\t\t  && operand_equal_p (def_rhs1, rhs1, 0))\n-\t\t{\n-\t\t  /* A + ~A -> -1.  */\n-\t\t  rhs1 = build_all_ones_cst (TREE_TYPE (rhs1));\n-\t\t  rhs2 = NULL_TREE;\n-\t\t  code = TREE_CODE (rhs1);\n-\t\t  gimple_assign_set_rhs_with_ops (gsi, code, rhs1, NULL_TREE);\n-\t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t\t  gimple_set_modified (stmt, true);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-out:\n-  if (gimple_modified_p (stmt))\n-    {\n-      fold_stmt_inplace (gsi);\n-      update_stmt (stmt);\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n /* Combine an element access with a shuffle.  Returns true if there were\n    any changes made, else it returns false.  */\n  \n@@ -2805,14 +2452,6 @@ pass_forwprop::execute (function *fun)\n \t\t\t  || code == BIT_XOR_EXPR)\n \t\t\t && simplify_rotate (&gsi))\n \t\t  changed = true;\n-\t\telse if (code == PLUS_EXPR\n-\t\t\t || code == MINUS_EXPR)\n-\t\t  {\n-\t\t    changed = associate_plusminus (&gsi);\n-\t\t    if (changed\n-\t\t\t&& maybe_clean_or_replace_eh_stmt (stmt, stmt))\n-\t\t      bitmap_set_bit (to_purge, bb->index);\n-\t\t  }\n \t\telse if (code == VEC_PERM_EXPR)\n \t\t  {\n \t\t    int did_something = simplify_permutation (&gsi);"}, {"sha": "221f0dd3d57831739088b86c3ee2723c711713ce", "filename": "gcc/tree.c", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=cc7b5acf3761c358bf9705f58b4fcf9625c49b0e", "patch": "@@ -11659,6 +11659,27 @@ block_ultimate_origin (const_tree block)\n     }\n }\n \n+/* Return true iff conversion from INNER_TYPE to OUTER_TYPE generates\n+   no instruction.  */\n+\n+bool\n+tree_nop_conversion_p (const_tree outer_type, const_tree inner_type)\n+{\n+  /* Use precision rather then machine mode when we can, which gives\n+     the correct answer even for submode (bit-field) types.  */\n+  if ((INTEGRAL_TYPE_P (outer_type)\n+       || POINTER_TYPE_P (outer_type)\n+       || TREE_CODE (outer_type) == OFFSET_TYPE)\n+      && (INTEGRAL_TYPE_P (inner_type)\n+\t  || POINTER_TYPE_P (inner_type)\n+\t  || TREE_CODE (inner_type) == OFFSET_TYPE))\n+    return TYPE_PRECISION (outer_type) == TYPE_PRECISION (inner_type);\n+\n+  /* Otherwise fall back on comparing machine modes (e.g. for\n+     aggregate types, floats).  */\n+  return TYPE_MODE (outer_type) == TYPE_MODE (inner_type);\n+}\n+\n /* Return true iff conversion in EXP generates no instruction.  Mark\n    it inline so that we fully inline into the stripping functions even\n    though we have two uses of this function.  */\n@@ -11680,19 +11701,7 @@ tree_nop_conversion (const_tree exp)\n   if (!inner_type)\n     return false;\n \n-  /* Use precision rather then machine mode when we can, which gives\n-     the correct answer even for submode (bit-field) types.  */\n-  if ((INTEGRAL_TYPE_P (outer_type)\n-       || POINTER_TYPE_P (outer_type)\n-       || TREE_CODE (outer_type) == OFFSET_TYPE)\n-      && (INTEGRAL_TYPE_P (inner_type)\n-\t  || POINTER_TYPE_P (inner_type)\n-\t  || TREE_CODE (inner_type) == OFFSET_TYPE))\n-    return TYPE_PRECISION (outer_type) == TYPE_PRECISION (inner_type);\n-\n-  /* Otherwise fall back on comparing machine modes (e.g. for\n-     aggregate types, floats).  */\n-  return TYPE_MODE (outer_type) == TYPE_MODE (inner_type);\n+  return tree_nop_conversion_p (outer_type, inner_type);\n }\n \n /* Return true iff conversion in EXP generates no instruction.  Don't"}, {"sha": "0577d51d1ca0433e5f1804968c48a0719b8b7083", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7b5acf3761c358bf9705f58b4fcf9625c49b0e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=cc7b5acf3761c358bf9705f58b4fcf9625c49b0e", "patch": "@@ -4226,6 +4226,7 @@ extern bool is_typedef_decl (tree x);\n extern bool typedef_variant_p (tree);\n extern bool auto_var_in_fn_p (const_tree, const_tree);\n extern tree build_low_bits_mask (tree, unsigned);\n+extern bool tree_nop_conversion_p (const_tree, const_tree);\n extern tree tree_strip_nop_conversions (tree);\n extern tree tree_strip_sign_nop_conversions (tree);\n extern const_tree strip_invariant_refs (const_tree);"}]}