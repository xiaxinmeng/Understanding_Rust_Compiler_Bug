{"sha": "c5aa1d125c72e027f99fce58cc5701ab3f269d9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhYTFkMTI1YzcyZTAyN2Y5OWZjZTU4Y2M1NzAxYWIzZjI2OWQ5ZA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-11-03T21:39:48Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-11-03T21:39:48Z"}, "message": "s390-protos.h (s390_split_access_reg): Add prototype.\n\n\t* config/s390/s390-protos.h (s390_split_access_reg): Add prototype.\n\t* config/s390/s390.c (s390_split_access_reg): New function.\n\t(regclass_map): Add access registers.\n\t(get_thread_pointer): Use access register instead of UNSPEC_TP.\n\t* config/s390/s390.h (FIRST_PSEUDO_REGISTER): Set to 38.\n\t(ACCESS_REGNO_P, ACCESS_REG_P): New macros.\n\t(TP_REGNUM): New define.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS, CALL_REALLY_USED_REGISTERS,\n\tREG_ALLOC_ORDER): Add access registers.\n\t(HARD_REGNO_NREGS, HARD_REGNO_MODE_OK, CLASS_MAX_NREGS,\n\tCANNOT_CHANGE_MODE_CLASS): Support access registers.\n\t(enum reg_class): Add ACCESS_REGS.\n\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Likewise.\n\t(REG_CLASS_FROM_LETTER): Add 't' constraint.\n\t(REGISTER_NAMES): Add access registers.\n\t* config/s390/s390.md (UNSPEC_TP): Remove.\n\t(\"*movdi_64\"): Add access register alternatives.  Provide splitters\n\tto split DImode access register <-> GPR moves into SImode moves.\n\t(\"*movsi_zarch\", \"*movsi_esa\"): Add access register alternatives.\n\t(\"movstrictsi\"): Likewise.\n\t(\"get_tp_64\", \"get_tp_31\"): Reimplement using access registers.\n\t(\"set_tp_64\", \"set_tp_31\"): Likewise.\n\t(\"*set_tp\"): New insn.\n\nFrom-SVN: r90036", "tree": {"sha": "4b3981220f83df1f967208ac51682a2b2feba471", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b3981220f83df1f967208ac51682a2b2feba471"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5aa1d125c72e027f99fce58cc5701ab3f269d9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5aa1d125c72e027f99fce58cc5701ab3f269d9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5aa1d125c72e027f99fce58cc5701ab3f269d9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/comments", "author": null, "committer": null, "parents": [{"sha": "57f60923b282714a7a0cdc5965991b20fe07e5eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57f60923b282714a7a0cdc5965991b20fe07e5eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57f60923b282714a7a0cdc5965991b20fe07e5eb"}], "stats": {"total": 252, "additions": 176, "deletions": 76}, "files": [{"sha": "425cf0d543ac070e531671bd1754ac030a6ea2cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5aa1d125c72e027f99fce58cc5701ab3f269d9d", "patch": "@@ -1,3 +1,29 @@\n+2004-11-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_split_access_reg): Add prototype.\n+\t* config/s390/s390.c (s390_split_access_reg): New function.\n+\t(regclass_map): Add access registers.\n+\t(get_thread_pointer): Use access register instead of UNSPEC_TP.\n+\t* config/s390/s390.h (FIRST_PSEUDO_REGISTER): Set to 38.\n+\t(ACCESS_REGNO_P, ACCESS_REG_P): New macros.\n+\t(TP_REGNUM): New define.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS, CALL_REALLY_USED_REGISTERS,\n+\tREG_ALLOC_ORDER): Add access registers.\n+\t(HARD_REGNO_NREGS, HARD_REGNO_MODE_OK, CLASS_MAX_NREGS,\n+\tCANNOT_CHANGE_MODE_CLASS): Support access registers.\n+\t(enum reg_class): Add ACCESS_REGS.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Likewise.\n+\t(REG_CLASS_FROM_LETTER): Add 't' constraint.\n+\t(REGISTER_NAMES): Add access registers.\n+\t* config/s390/s390.md (UNSPEC_TP): Remove.\n+\t(\"*movdi_64\"): Add access register alternatives.  Provide splitters\n+\tto split DImode access register <-> GPR moves into SImode moves.\n+\t(\"*movsi_zarch\", \"*movsi_esa\"): Add access register alternatives.\n+\t(\"movstrictsi\"): Likewise.\n+\t(\"get_tp_64\", \"get_tp_31\"): Reimplement using access registers.\n+\t(\"set_tp_64\", \"set_tp_31\"): Likewise.\n+\t(\"*set_tp\"): New insn.\n+\n 2004-11-03  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-phinodes.c (resize_phi_node): Copy only a portion of"}, {"sha": "3b21d03fcb3aeba8a767fce045397637c93bdc65", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=c5aa1d125c72e027f99fce58cc5701ab3f269d9d", "patch": "@@ -90,6 +90,7 @@ extern void s390_expand_logical_operator (enum rtx_code,\n extern bool s390_logical_operator_ok_p (rtx *);\n extern void s390_narrow_logical_operator (enum rtx_code, rtx *, rtx *);\n extern bool s390_pool_operand (rtx);\n+extern void s390_split_access_reg (rtx, rtx *, rtx *);\n \n extern bool s390_output_addr_const_extra (FILE*, rtx);\n extern void print_operand_address (FILE *, rtx);"}, {"sha": "8ba78a218f13fb8572cc1c572c48c584d2a24f46", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=c5aa1d125c72e027f99fce58cc5701ab3f269d9d", "patch": "@@ -1355,7 +1355,8 @@ const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n-  ADDR_REGS,    CC_REGS,   ADDR_REGS, ADDR_REGS\n+  ADDR_REGS,    CC_REGS,   ADDR_REGS, ADDR_REGS,\n+  ACCESS_REGS,\tACCESS_REGS\n };\n \n /* Return attribute type of insn.  */\n@@ -2019,6 +2020,22 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return 1;\n }\n \n+/* Split DImode access register reference REG (on 64-bit) into its constituent\n+   low and high parts, and store them into LO and HI.  Note that gen_lowpart/\n+   gen_highpart cannot be used as they assume all registers are word-sized,\n+   while our access registers have only half that size.  */\n+\n+void\n+s390_split_access_reg (rtx reg, rtx *lo, rtx *hi)\n+{\n+  gcc_assert (TARGET_64BIT);\n+  gcc_assert (ACCESS_REG_P (reg));\n+  gcc_assert (GET_MODE (reg) == DImode);\n+  gcc_assert (!(REGNO (reg) & 1));\n+\n+  *lo = gen_rtx_REG (SImode, REGNO (reg) + 1);\n+  *hi = gen_rtx_REG (SImode, REGNO (reg));\n+}\n \n /* Return true if OP contains a symbol reference */\n \n@@ -3033,10 +3050,9 @@ legitimize_pic_address (rtx orig, rtx reg)\n static rtx\n get_thread_pointer (void)\n {\n-  rtx tp;\n+  rtx tp = gen_reg_rtx (Pmode);\n \n-  tp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx), UNSPEC_TP);\n-  tp = force_reg (Pmode, tp);\n+  emit_move_insn (tp, gen_rtx_REG (Pmode, TP_REGNUM));\n   mark_reg_pointer (tp, BITS_PER_WORD);\n \n   return tp;"}, {"sha": "0116a6623409cf0783fd9598a3a356df9660a327", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=c5aa1d125c72e027f99fce58cc5701ab3f269d9d", "patch": "@@ -307,31 +307,38 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n    GPR 14: Return address register\n    GPR 15: Stack pointer\n \n-   Registers 32-34 are 'fake' hard registers that do not\n+   Registers 32-35 are 'fake' hard registers that do not\n    correspond to actual hardware:\n    Reg 32: Argument pointer\n    Reg 33: Condition code\n-   Reg 34: Frame pointer  */\n+   Reg 34: Frame pointer  \n+   Reg 35: Return address pointer\n \n-#define FIRST_PSEUDO_REGISTER 36\n+   Registers 36 and 37 are mapped to access registers \n+   0 and 1, used to implement thread-local storage.  */\n+\n+#define FIRST_PSEUDO_REGISTER 38\n \n /* Standard register usage.  */\n #define GENERAL_REGNO_P(N)\t((int)(N) >= 0 && (N) < 16)\n #define ADDR_REGNO_P(N)\t\t((N) >= 1 && (N) < 16)\n #define FP_REGNO_P(N)\t\t((N) >= 16 && (N) < (TARGET_IEEE_FLOAT? 32 : 20))\n #define CC_REGNO_P(N)\t\t((N) == 33)\n #define FRAME_REGNO_P(N)\t((N) == 32 || (N) == 34 || (N) == 35)\n+#define ACCESS_REGNO_P(N)\t((N) == 36 || (N) == 37)\n \n #define GENERAL_REG_P(X)\t(REG_P (X) && GENERAL_REGNO_P (REGNO (X)))\n #define ADDR_REG_P(X)\t\t(REG_P (X) && ADDR_REGNO_P (REGNO (X)))\n #define FP_REG_P(X)\t\t(REG_P (X) && FP_REGNO_P (REGNO (X)))\n #define CC_REG_P(X)\t\t(REG_P (X) && CC_REGNO_P (REGNO (X)))\n #define FRAME_REG_P(X)\t\t(REG_P (X) && FRAME_REGNO_P (REGNO (X)))\n+#define ACCESS_REG_P(X)\t\t(REG_P (X) && ACCESS_REGNO_P (REGNO (X)))\n \n #define SIBCALL_REGNUM 1\n #define BASE_REGNUM 13\n #define RETURN_REGNUM 14\n #define CC_REGNUM 33\n+#define TP_REGNUM 36\n \n /* Set up fixed registers and calling convention:\n \n@@ -342,6 +349,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n    GPR 14 is always fixed on S/390 machines (as return address).\n    GPR 15 is always fixed (as stack pointer).\n    The 'fake' hard registers are call-clobbered and fixed.\n+   The access registers are call-saved and fixed.\n \n    On 31-bit, FPRs 18-19 are call-clobbered;\n    on 64-bit, FPRs 24-31 are call-clobbered.\n@@ -356,7 +364,8 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n   0, 0, 0, 0, \t\t\t\t\t\\\n   0, 0, 0, 0, \t\t\t\t\t\\\n   0, 0, 0, 0, \t\t\t\t\t\\\n-  1, 1, 1, 1 }\n+  1, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1 }\n \n #define CALL_USED_REGISTERS\t\t\t\\\n { 1, 1, 1, 1, \t\t\t\t\t\\\n@@ -367,7 +376,8 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1, 1, 1 }\n+  1, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1 }\n \n #define CALL_REALLY_USED_REGISTERS\t\t\\\n { 1, 1, 1, 1, \t\t\t\t\t\\\n@@ -378,7 +388,8 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1, 1, 1 }\n+  1, 1, 1, 1,\t\t\t\t\t\\\n+  0, 0 }\n \n #define CONDITIONAL_REGISTER_USAGE s390_conditional_register_usage ()\n \n@@ -387,7 +398,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n {  1, 2, 3, 4, 5, 0, 13, 12, 11, 10, 9, 8, 7, 6, 14,            \\\n    16, 17, 18, 19, 20, 21, 22, 23,                              \\\n    24, 25, 26, 27, 28, 29, 30, 31,                              \\\n-   15, 32, 33, 34, 35 }\n+   15, 32, 33, 34, 35, 36, 37 }\n \n \n /* Fitting values into registers.  */\n@@ -411,6 +422,8 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n     (GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT ? 2 : 1) :      \\\n    GENERAL_REGNO_P(REGNO)?                                      \\\n     ((GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD) : \\\n+   ACCESS_REGNO_P(REGNO)?\t\t\t\t\t\\\n+    ((GET_MODE_SIZE(MODE)+32-1) / 32) : \t\t\t\\\n    1)\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)                             \\\n@@ -424,6 +437,9 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n      GET_MODE_CLASS (MODE) == MODE_CC :                             \\\n    FRAME_REGNO_P(REGNO)?                                            \\\n      (enum machine_mode) (MODE) == Pmode :                          \\\n+   ACCESS_REGNO_P(REGNO)?\t\t\t\t\t    \\\n+     (((MODE) == SImode || ((enum machine_mode) (MODE) == Pmode))   \\\n+      && (HARD_REGNO_NREGS(REGNO, MODE) == 1 || !((REGNO) & 1))) :  \\\n    0)\n \n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n@@ -435,48 +451,54 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n #define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\\n      ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n       (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT ? 2 : 1) :  \t\t\\\n+      (CLASS) == ACCESS_REGS ?\t\t\t\t\t\t\\\n+      (GET_MODE_SIZE (MODE) + 32 - 1) / 32 :\t\t\t\t\\\n       (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* If a 4-byte value is loaded into a FPR, it is placed into the\n    *upper* half of the register, not the lower.  Therefore, we\n-   cannot use SUBREGs to switch between modes in FP registers.  */\n+   cannot use SUBREGs to switch between modes in FP registers.\n+   Likewise for access registers, since they have only half the\n+   word size on 64-bit.  */\n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\\n   (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\t\\\n-   ? reg_classes_intersect_p (FP_REGS, CLASS) : 0)\n+   ? reg_classes_intersect_p (FP_REGS, CLASS)\t\t\t\\\n+     || reg_classes_intersect_p (ACCESS_REGS, CLASS) : 0)\n \n /* Register classes.  */\n \n /* We use the following register classes:\n    GENERAL_REGS     All general purpose registers\n-   CC_REGS          Contains only the condition code register\n    ADDR_REGS        All general purpose registers except %r0\n                     (These registers can be used in address generation)\n-   ADDR_CC_REGS     Union of ADDR_REGS and CC_REGS\n-   GENERAL_CC_REGS  Union of GENERAL_REGS and CC_REGS\n    FP_REGS          All floating point registers\n+   CC_REGS          The condition code register\n+   ACCESS_REGS      The access registers\n \n    GENERAL_FP_REGS  Union of GENERAL_REGS and FP_REGS\n    ADDR_FP_REGS     Union of ADDR_REGS and FP_REGS\n+   GENERAL_CC_REGS  Union of GENERAL_REGS and CC_REGS\n+   ADDR_CC_REGS     Union of ADDR_REGS and CC_REGS\n \n    NO_REGS          No registers\n    ALL_REGS         All registers\n \n    Note that the 'fake' frame pointer and argument pointer registers\n-   are included amongst the address registers here.  The condition\n-   code register is only included in ALL_REGS.  */\n+   are included amongst the address registers here.  */\n \n enum reg_class\n {\n-  NO_REGS, CC_REGS, ADDR_REGS, GENERAL_REGS, \n+  NO_REGS, CC_REGS, ADDR_REGS, GENERAL_REGS, ACCESS_REGS,\n   ADDR_CC_REGS, GENERAL_CC_REGS, \n   FP_REGS, ADDR_FP_REGS, GENERAL_FP_REGS,\n   ALL_REGS, LIM_REG_CLASSES\n };\n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n-#define REG_CLASS_NAMES                                                        \\\n-{ \"NO_REGS\", \"CC_REGS\", \"ADDR_REGS\", \"GENERAL_REGS\", \"ADDR_CC_REGS\",           \\\n-  \"GENERAL_CC_REGS\", \"FP_REGS\", \"ADDR_FP_REGS\", \"GENERAL_FP_REGS\", \"ALL_REGS\" }\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n+{ \"NO_REGS\", \"CC_REGS\", \"ADDR_REGS\", \"GENERAL_REGS\", \"ACCESS_REGS\",\t\\\n+  \"ADDR_CC_REGS\", \"GENERAL_CC_REGS\",\t\t\t\t\t\\\n+  \"FP_REGS\", \"ADDR_FP_REGS\", \"GENERAL_FP_REGS\", \"ALL_REGS\" }\n \n /* Class -> register mapping.  */\n #define REG_CLASS_CONTENTS \\\n@@ -485,12 +507,13 @@ enum reg_class\n   { 0x00000000, 0x00000002 },\t/* CC_REGS */\t\t\\\n   { 0x0000fffe, 0x0000000d },\t/* ADDR_REGS */\t\t\\\n   { 0x0000ffff, 0x0000000d },\t/* GENERAL_REGS */\t\\\n+  { 0x00000000, 0x00000030 },\t/* ACCESS_REGS */\t\\\n   { 0x0000fffe, 0x0000000f },\t/* ADDR_CC_REGS */\t\\\n   { 0x0000ffff, 0x0000000f },\t/* GENERAL_CC_REGS */\t\\\n   { 0xffff0000, 0x00000000 },\t/* FP_REGS */\t\t\\\n   { 0xfffffffe, 0x0000000d },\t/* ADDR_FP_REGS */\t\\\n   { 0xffffffff, 0x0000000d },\t/* GENERAL_FP_REGS */\t\\\n-  { 0xffffffff, 0x0000000f },\t/* ALL_REGS */\t\t\\\n+  { 0xffffffff, 0x0000003f },\t/* ALL_REGS */\t\t\\\n }\n \n /* Register -> class mapping.  */\n@@ -543,7 +566,8 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n   ((C) == 'a' ? ADDR_REGS :                                             \\\n    (C) == 'd' ? GENERAL_REGS :                                          \\\n    (C) == 'f' ? FP_REGS :                                               \\\n-   (C) == 'c' ? CC_REGS : NO_REGS)\n+   (C) == 'c' ? CC_REGS : \t\t\t\t\t\t\\\n+   (C) == 't' ? ACCESS_REGS : NO_REGS)\n \n #define CONST_OK_FOR_CONSTRAINT_P(VALUE, C, STR)                          \\\n   s390_const_ok_for_constraint_p ((VALUE), (C), (STR))\n@@ -976,7 +1000,7 @@ extern int flag_pic;\n   \"%r8\",  \"%r9\",  \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\",\t\\\n   \"%f0\",  \"%f2\",  \"%f4\",  \"%f6\",  \"%f1\",  \"%f3\",  \"%f5\",  \"%f7\",\t\\\n   \"%f8\",  \"%f10\", \"%f12\", \"%f14\", \"%f9\",  \"%f11\", \"%f13\", \"%f15\",\t\\\n-  \"%ap\",  \"%cc\",  \"%fp\",  \"%rp\"\t\t\t\t\t\t\\\n+  \"%ap\",  \"%cc\",  \"%fp\",  \"%rp\",  \"%a0\",  \"%a1\"\t\t\t\t\\\n }\n \n /* Emit a dtp-relative reference to a TLS variable.  */"}, {"sha": "fbce222db265121c909f1190e7a425ca94649a9b", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 84, "deletions": 51, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5aa1d125c72e027f99fce58cc5701ab3f269d9d/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=c5aa1d125c72e027f99fce58cc5701ab3f269d9d", "patch": "@@ -112,7 +112,6 @@\n    (UNSPEC_INDNTPOFF            505)\n \n    ; TLS support\n-   (UNSPEC_TP\t\t\t510)\n    (UNSPEC_TLSLDM_NTPOFF\t511)\n    (UNSPEC_TLS_LOAD\t\t512)\n \n@@ -887,9 +886,9 @@\n \n (define_insn \"*movdi_64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-                            \"=d,d,d,d,d,d,d,d,m,!*f,!*f,!*f,!R,!T,?Q\")\n+                            \"=d,d,d,d,d,d,d,d,m,!*f,!*f,!*f,!R,!T,d,t,Q,t,?Q\")\n         (match_operand:DI 1 \"general_operand\"\n-                            \"K,N0HD0,N1HD0,N2HD0,N3HD0,L,d,m,d,*f,R,T,*f,*f,?Q\"))]\n+                            \"K,N0HD0,N1HD0,N2HD0,N3HD0,L,d,m,d,*f,R,T,*f,*f,t,d,t,Q,?Q\"))]\n   \"TARGET_64BIT\"\n   \"@\n    lghi\\t%0,%h1\n@@ -906,10 +905,47 @@\n    ldy\\t%0,%1\n    std\\t%1,%0\n    stdy\\t%1,%0\n+   #\n+   #\n+   stam\\t%1,%N1,%S0\n+   lam\\t%0,%N0,%S1\n    #\"\n-  [(set_attr \"op_type\" \"RI,RI,RI,RI,RI,RXY,RRE,RXY,RXY,RR,RX,RXY,RX,RXY,SS\")\n+  [(set_attr \"op_type\" \"RI,RI,RI,RI,RI,RXY,RRE,RXY,RXY,RR,RX,RXY,RX,RXY,NN,NN,RS,RS,SS\")\n    (set_attr \"type\" \"*,*,*,*,*,la,lr,load,store,floadd,floadd,floadd,\n-                     fstored,fstored,cs\")])\n+                     fstored,fstored,*,*,*,*,cs\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (match_operand:DI 1 \"register_operand\" \"\"))]\n+  \"TARGET_64BIT && ACCESS_REG_P (operands[1])\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 0) (ashift:DI (match_dup 0) (const_int 32)))\n+   (set (strict_low_part (match_dup 2)) (match_dup 4))]\n+  \"operands[2] = gen_lowpart (SImode, operands[0]);\n+   s390_split_access_reg (operands[1], &operands[4], &operands[3]);\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (match_operand:DI 1 \"register_operand\" \"\"))]\n+  \"TARGET_64BIT && ACCESS_REG_P (operands[0])\n+   && dead_or_set_p (insn, operands[1])\"\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 1) (lshiftrt:DI (match_dup 1) (const_int 32)))\n+   (set (match_dup 4) (match_dup 2))]\n+  \"operands[2] = gen_lowpart (SImode, operands[1]);\n+   s390_split_access_reg (operands[0], &operands[3], &operands[4]);\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (match_operand:DI 1 \"register_operand\" \"\"))]\n+  \"TARGET_64BIT && ACCESS_REG_P (operands[0])\n+   && !dead_or_set_p (insn, operands[1])\"\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 1) (rotate:DI (match_dup 1) (const_int 32)))\n+   (set (match_dup 4) (match_dup 2))\n+   (set (match_dup 1) (rotate:DI (match_dup 1) (const_int 32)))]\n+  \"operands[2] = gen_lowpart (SImode, operands[1]);\n+   s390_split_access_reg (operands[0], &operands[3], &operands[4]);\")\n \n (define_insn \"*movdi_31\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,Q,d,o,!*f,!*f,!*f,!R,!T,Q\")\n@@ -1063,9 +1099,9 @@\n \n (define_insn \"*movsi_zarch\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-                            \"=d,d,d,d,d,d,d,R,T,!*f,!*f,!*f,!R,!T,?Q\")\n+                            \"=d,d,d,d,d,d,d,R,T,!*f,!*f,!*f,!R,!T,d,t,Q,t,?Q\")\n         (match_operand:SI 1 \"general_operand\"\n-                            \"K,N0HS0,N1HS0,L,d,R,T,d,d,*f,R,T,*f,*f,?Q\"))]\n+                            \"K,N0HS0,N1HS0,L,d,R,T,d,d,*f,R,T,*f,*f,t,d,t,Q,?Q\"))]\n   \"TARGET_ZARCH\"\n   \"@\n    lhi\\t%0,%h1\n@@ -1082,13 +1118,17 @@\n    ley\\t%0,%1\n    ste\\t%1,%0\n    stey\\t%1,%0\n+   ear\\t%0,%1\n+   sar\\t%0,%1\n+   stam\\t%1,%1,%S0\n+   lam\\t%0,%0,%S1\n    #\"\n-  [(set_attr \"op_type\" \"RI,RI,RI,RXY,RR,RX,RXY,RX,RXY,RR,RX,RXY,RX,RXY,SS\")\n-   (set_attr \"type\" \"*,*,*,la,lr,load,load,store,store,floads,floads,floads,fstores,fstores,cs\")])\n+  [(set_attr \"op_type\" \"RI,RI,RI,RXY,RR,RX,RXY,RX,RXY,RR,RX,RXY,RX,RXY,RRE,RRE,RS,RS,SS\")\n+   (set_attr \"type\" \"*,*,*,la,lr,load,load,store,store,floads,floads,floads,fstores,fstores,*,*,*,*,cs\")])\n \n (define_insn \"*movsi_esa\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,R,!*f,!*f,!R,?Q\")\n-        (match_operand:SI 1 \"general_operand\" \"K,d,R,d,*f,R,*f,?Q\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,R,!*f,!*f,!R,d,t,Q,t,?Q\")\n+        (match_operand:SI 1 \"general_operand\" \"K,d,R,d,*f,R,*f,t,d,t,Q,?Q\"))]\n   \"!TARGET_ZARCH\"\n   \"@\n    lhi\\t%0,%h1\n@@ -1098,9 +1138,13 @@\n    ler\\t%0,%1\n    le\\t%0,%1\n    ste\\t%1,%0\n+   ear\\t%0,%1\n+   sar\\t%0,%1\n+   stam\\t%1,%1,%S0\n+   lam\\t%0,%0,%S1\n    #\"\n-  [(set_attr \"op_type\" \"RI,RR,RX,RX,RR,RX,RX,SS\")\n-   (set_attr \"type\" \"*,lr,load,store,floads,floads,fstores,cs\")])\n+  [(set_attr \"op_type\" \"RI,RR,RX,RX,RR,RX,RX,RRE,RRE,RS,RS,SS\")\n+   (set_attr \"type\" \"*,lr,load,store,floads,floads,fstores,*,*,*,*,cs\")])\n \n (define_peephole2\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -1321,15 +1365,16 @@\n ;\n \n (define_insn \"movstrictsi\"\n-  [(set (strict_low_part (match_operand:SI 0 \"register_operand\" \"+d,d,d\"))\n-                         (match_operand:SI 1 \"general_operand\" \"d,R,T\"))]\n+  [(set (strict_low_part (match_operand:SI 0 \"register_operand\" \"+d,d,d,d\"))\n+                         (match_operand:SI 1 \"general_operand\" \"d,R,T,t\"))]\n   \"TARGET_64BIT\"\n   \"@\n    lr\\t%0,%1\n    l\\t%0,%1\n-   ly\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RR,RX,RXY\")\n-   (set_attr \"type\" \"lr,load,load\")])\n+   ly\\t%0,%1\n+   ear\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RR,RX,RXY,RRE\")\n+   (set_attr \"type\" \"lr,load,load,*\")])\n \n ;\n ; movdf instruction pattern(s).\n@@ -7438,46 +7483,34 @@\n ;;- Thread-local storage support.\n ;;\n \n-(define_insn \"get_tp_64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=??d,Q\")\n-        (unspec:DI [(const_int 0)] UNSPEC_TP))]\n+(define_expand \"get_tp_64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\") (reg:DI 36))]\n   \"TARGET_64BIT\"\n-  \"@\n-   ear\\t%0,%%a0\\;sllg\\t%0,%0,32\\;ear\\t%0,%%a1\n-   stam\\t%%a0,%%a1,%S0\"\n-  [(set_attr \"op_type\" \"NN,RS\")\n-   (set_attr \"atype\"   \"reg,*\")\n-   (set_attr \"type\"    \"o3,*\")\n-   (set_attr \"length\"  \"14,*\")])\n+  \"\")\n \n-(define_insn \"get_tp_31\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,Q\")\n-        (unspec:SI [(const_int 0)] UNSPEC_TP))]\n+(define_expand \"get_tp_31\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\") (reg:SI 36))]\n   \"!TARGET_64BIT\"\n-  \"@\n-   ear\\t%0,%%a0\n-   stam\\t%%a0,%%a0,%S0\"\n-  [(set_attr \"op_type\" \"RRE,RS\")])\n+  \"\")\n \n-(define_insn \"set_tp_64\"\n-  [(unspec_volatile [(match_operand:DI 0 \"general_operand\" \"??d,Q\")] UNSPECV_SET_TP)\n-   (clobber (match_scratch:SI 1 \"=d,X\"))]\n+(define_expand \"set_tp_64\"\n+  [(set (reg:DI 36) (match_operand:DI 0 \"nonimmediate_operand\" \"\"))\n+   (unspec_volatile [(reg:DI 36)] UNSPECV_SET_TP)]\n   \"TARGET_64BIT\"\n-  \"@\n-   sar\\t%%a1,%0\\;srlg\\t%1,%0,32\\;sar\\t%%a0,%1\n-   lam\\t%%a0,%%a1,%S0\"\n-  [(set_attr \"op_type\" \"NN,RS\")\n-   (set_attr \"atype\"   \"reg,*\")\n-   (set_attr \"type\"    \"o3,*\")\n-   (set_attr \"length\"  \"14,*\")])\n+  \"\")\n \n-(define_insn \"set_tp_31\"\n-  [(unspec_volatile [(match_operand:SI 0 \"general_operand\" \"d,Q\")] UNSPECV_SET_TP)]\n+(define_expand \"set_tp_31\"\n+  [(set (reg:SI 36) (match_operand:SI 0 \"nonimmediate_operand\" \"\"))\n+   (unspec_volatile [(reg:SI 36)] UNSPECV_SET_TP)]\n   \"!TARGET_64BIT\"\n-  \"@\n-   sar\\t%%a0,%0\n-   lam\\t%%a0,%%a0,%S0\"\n-  [(set_attr \"op_type\" \"RRE,RS\")])\n+  \"\")\n+\n+(define_insn \"*set_tp\"\n+  [(unspec_volatile [(reg 36)] UNSPECV_SET_TP)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\" \"none\")\n+   (set_attr \"length\" \"0\")])\n \n (define_insn \"*tls_load_64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")"}]}