{"sha": "e4c62b265dfd167efcecbbbc539cbdad28bbd80f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRjNjJiMjY1ZGZkMTY3ZWZjZWNiYmJjNTM5Y2JkYWQyOGJiZDgwZg==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-05-21T20:41:06Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-05-21T20:41:06Z"}, "message": "stl_vector.h: Reformat to follow C++STYLE.\n\n2002-05-21  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* include/bits/stl_vector.h:  Reformat to follow C++STYLE.\n\tDoxygenate all public members.  Reorder to follow 14882.\n\t(vector::push_back(void)):  Remove previously-deprecated fn.\n\t(vector::insert(iterator), vector::_M_insert_aux(iterator)):\n\tDeprecate for removal in 3.3.\n\nFrom-SVN: r53696", "tree": {"sha": "19c224c3761590acba10648245f0d32d4ddbe306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19c224c3761590acba10648245f0d32d4ddbe306"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4c62b265dfd167efcecbbbc539cbdad28bbd80f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c62b265dfd167efcecbbbc539cbdad28bbd80f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4c62b265dfd167efcecbbbc539cbdad28bbd80f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c62b265dfd167efcecbbbc539cbdad28bbd80f/comments", "author": null, "committer": null, "parents": [{"sha": "f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6366fc7ad6938f236cb176977aa57dcd97a8e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6366fc7ad6938f236cb176977aa57dcd97a8e6f"}], "stats": {"total": 865, "additions": 528, "deletions": 337}, "files": [{"sha": "c4a4fe1b28aac856f6943747ce9ba6458b9b0867", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c62b265dfd167efcecbbbc539cbdad28bbd80f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c62b265dfd167efcecbbbc539cbdad28bbd80f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e4c62b265dfd167efcecbbbc539cbdad28bbd80f", "patch": "@@ -1,3 +1,11 @@\n+2002-05-21  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* include/bits/stl_vector.h:  Reformat to follow C++STYLE.\n+\tDoxygenate all public members.  Reorder to follow 14882.\n+\t(vector::push_back(void)):  Remove previously-deprecated fn.\n+\t(vector::insert(iterator), vector::_M_insert_aux(iterator)):\n+\tDeprecate for removal in 3.3.\n+\n 2002-05-20  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* docs/html/faq/index.html (5.4):  Recommend against -I options for"}, {"sha": "7a23b49fdbffe2304e94965211a76cb8c2dc8ded", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 520, "deletions": 337, "changes": 857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c62b265dfd167efcecbbbc539cbdad28bbd80f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c62b265dfd167efcecbbbc539cbdad28bbd80f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=e4c62b265dfd167efcecbbbc539cbdad28bbd80f", "patch": "@@ -65,22 +65,27 @@\n #include <bits/functexcept.h>\n #include <bits/concept_check.h>\n \n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n namespace std\n {\n \n-// The vector base class serves two purposes.  First, its constructor\n-// and destructor allocate (but don't initialize) storage.  This makes\n-// exception safety easier.  Second, the base class encapsulates all of\n-// the differences between SGI-style allocators and standard-conforming\n-// allocators.\n-\n-// Base class for ordinary allocators.\n+/// @if maint Primary default version.  @endif\n+/**\n+ *  @if maint\n+ *  See bits/stl_deque.h's _Deque_alloc_base for an explanation.\n+ *  @endif\n+*/\n template <class _Tp, class _Allocator, bool _IsStatic>\n-class _Vector_alloc_base {\n+class _Vector_alloc_base\n+{\n public:\n   typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n           allocator_type;\n-  allocator_type get_allocator() const { return _M_data_allocator; }\n+\n+  allocator_type\n+  get_allocator() const { return _M_data_allocator; }\n \n   _Vector_alloc_base(const allocator_type& __a)\n     : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n@@ -92,20 +97,24 @@ class _Vector_alloc_base {\n   _Tp* _M_finish;\n   _Tp* _M_end_of_storage;\n \n-  _Tp* _M_allocate(size_t __n)\n-    { return _M_data_allocator.allocate(__n); }\n-  void _M_deallocate(_Tp* __p, size_t __n)\n+  _Tp*\n+  _M_allocate(size_t __n) { return _M_data_allocator.allocate(__n); }\n+\n+  void\n+  _M_deallocate(_Tp* __p, size_t __n)\n     { if (__p) _M_data_allocator.deallocate(__p, __n); }\n };\n \n-// Specialization for allocators that have the property that we don't\n-// actually have to store an allocator object.\n+/// @if maint Specialization for instanceless allocators.  @endif\n template <class _Tp, class _Allocator>\n-class _Vector_alloc_base<_Tp, _Allocator, true> {\n+class _Vector_alloc_base<_Tp, _Allocator, true>\n+{\n public:\n   typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n           allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n+\n+  allocator_type\n+  get_allocator() const { return allocator_type(); }\n \n   _Vector_alloc_base(const allocator_type&)\n     : _M_start(0), _M_finish(0), _M_end_of_storage(0)\n@@ -117,12 +126,20 @@ class _Vector_alloc_base<_Tp, _Allocator, true> {\n   _Tp* _M_end_of_storage;\n \n   typedef typename _Alloc_traits<_Tp, _Allocator>::_Alloc_type _Alloc_type;\n-  _Tp* _M_allocate(size_t __n)\n-    { return _Alloc_type::allocate(__n); }\n-  void _M_deallocate(_Tp* __p, size_t __n)\n-    { _Alloc_type::deallocate(__p, __n);}\n+\n+  _Tp*\n+  _M_allocate(size_t __n) { return _Alloc_type::allocate(__n); }\n+\n+  void\n+  _M_deallocate(_Tp* __p, size_t __n) { _Alloc_type::deallocate(__p, __n);}\n };\n \n+\n+/**\n+ *  @if maint\n+ *  See bits/stl_deque.h's _Deque_base for an explanation.\n+ *  @endif\n+*/\n template <class _Tp, class _Alloc>\n struct _Vector_base\n   : public _Vector_alloc_base<_Tp, _Alloc,\n@@ -133,8 +150,11 @@ struct _Vector_base\n           _Base;\n   typedef typename _Base::allocator_type allocator_type;\n \n-  _Vector_base(const allocator_type& __a) : _Base(__a) {}\n-  _Vector_base(size_t __n, const allocator_type& __a) : _Base(__a) {\n+  _Vector_base(const allocator_type& __a)\n+    : _Base(__a) {}\n+  _Vector_base(size_t __n, const allocator_type& __a)\n+    : _Base(__a)\n+  {\n     _M_start = _M_allocate(__n);\n     _M_finish = _M_start;\n     _M_end_of_storage = _M_start + __n;\n@@ -157,39 +177,43 @@ struct _Vector_base\n  *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n  *  %exception of @c push_front and @c pop_front.\n  *\n- *  In some terminology a vector can be described as a dynamic C-style array,\n+ *  In some terminology a %vector can be described as a dynamic C-style array,\n  *  it offers fast and efficient access to individual elements in any order\n  *  and saves the user from worrying about memory and size allocation.\n- *  Subscripting ( [] ) access is also provided as with C-style arrays.\n+ *  Subscripting ( @c [] ) access is also provided as with C-style arrays.\n */\n template <class _Tp, class _Alloc = allocator<_Tp> >\n class vector : protected _Vector_base<_Tp, _Alloc>\n {\n   // concept requirements\n   __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n \n-private:\n-  typedef _Vector_base<_Tp, _Alloc> _Base;\n-  typedef vector<_Tp, _Alloc> vector_type;\n+  typedef _Vector_base<_Tp, _Alloc>                     _Base;\n+  typedef vector<_Tp, _Alloc>                           vector_type;\n+\n public:\n   typedef _Tp \t\t\t\t\t\tvalue_type;\n   typedef value_type* \t\t\t\t\tpointer;\n   typedef const value_type* \t\t\t\tconst_pointer;\n   typedef __gnu_cxx::__normal_iterator<pointer, vector_type> \titerator;\n   typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>\n                                                         const_iterator;\n+  typedef reverse_iterator<const_iterator>              const_reverse_iterator;\n+  typedef reverse_iterator<iterator>                    reverse_iterator;\n   typedef value_type& \t\t\t\t\treference;\n   typedef const value_type& \t\t\t\tconst_reference;\n   typedef size_t \t\t\t\t\tsize_type;\n   typedef ptrdiff_t \t\t\t\t\tdifference_type;\n-\n-  typedef typename _Base::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return _Base::get_allocator(); }\n-\n-  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-  typedef reverse_iterator<iterator> reverse_iterator;\n+  typedef typename _Base::allocator_type                allocator_type;\n \n protected:\n+  /** @if maint\n+   *  These two functions and three data members are all from the top-most\n+   *  base class, which varies depending on the type of %allocator.  They\n+   *  should be pretty self-explanatory, as %vector uses a simple contiguous \n+   *  allocation scheme.\n+   *  @endif\n+  */\n   using _Base::_M_allocate;\n   using _Base::_M_deallocate;\n   using _Base::_M_start;\n@@ -198,199 +222,318 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n \n protected:\n   void _M_insert_aux(iterator __position, const _Tp& __x);\n+#ifdef _GLIBCPP_DEPRECATED\n   void _M_insert_aux(iterator __position);\n+#endif\n \n public:\n+  // [23.2.4.1] construct/copy/destroy\n+  // (assign() and get_allocator() are also listed in this section)\n   /**\n-   *  Returns a read/write iterator that points to the first element in the\n-   *  vector.  Iteration is done in ordinary element order.\n+   *  @brief  Default constructor creates no elements.\n   */\n-  iterator begin() { return iterator (_M_start); }\n+  explicit\n+  vector(const allocator_type& __a = allocator_type())\n+    : _Base(__a) {}\n \n   /**\n-   *  Returns a read-only (constant) iterator that points to the first element\n-   *  in the vector.  Iteration is done in ordinary element order.\n+   *  @brief  Create a %vector with copies of an exemplar element.\n+   *  @param  n  The number of elements to initially create.\n+   *  @param  value  An element to copy.\n+   * \n+   *  This constructor fills the %vector with @a n copies of @a value.\n   */\n-  const_iterator begin() const\n-    { return const_iterator (_M_start); }\n+  vector(size_type __n, const _Tp& __value,\n+         const allocator_type& __a = allocator_type())\n+    : _Base(__n, __a)\n+    { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }\n \n   /**\n-   *  Returns a read/write iterator that points one past the last element in\n-   *  the vector.  Iteration is done in ordinary element order.\n+   *  @brief  Create a %vector with default elements.\n+   *  @param  n  The number of elements to initially create.\n+   * \n+   *  This constructor fills the %vector with @a n copies of a\n+   *  default-constructed element.\n   */\n-  iterator end() { return iterator (_M_finish); }\n+  explicit\n+  vector(size_type __n)\n+    : _Base(__n, allocator_type())\n+    { _M_finish = uninitialized_fill_n(_M_start, __n, _Tp()); }\n \n   /**\n-   *  Returns a read-only (constant) iterator that points one past the last\n-   *  element in the vector.  Iteration is done in ordinary element order.\n+   *  @brief  %Vector copy constructor.\n+   *  @param  x  A %vector of identical element and allocator types.\n+   * \n+   *  The newly-created %vector uses a copy of the allocation object used\n+   *  by @a x.  All the elements of @a x are copied, but any extra memory in\n+   *  @a x (for fast expansion) will not be copied.\n   */\n-  const_iterator end() const { return const_iterator (_M_finish); }\n+  vector(const vector<_Tp, _Alloc>& __x)\n+    : _Base(__x.size(), __x.get_allocator())\n+    { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n \n   /**\n-   *  Returns a read/write reverse iterator that points to the last element in\n-   *  the vector.  Iteration is done in reverse element order.\n+   *  @brief  Builds a %vector from a range.\n+   *  @param  first  An input iterator.\n+   *  @param  last  An input iterator.\n+   * \n+   *  Creats a %vector consisting of copies of the elements from [first,last).\n+   *\n+   *  If the iterators are forward, bidirectional, or random-access, then\n+   *  this will call the elements' copy constructor N times (where N is\n+   *  distance(first,last)) and do no memory reallocation.  But if only\n+   *  input iterators are used, then this will do at most 2N calls to the\n+   *  copy constructor, and logN memory reallocations.\n   */\n-  reverse_iterator rbegin()\n-    { return reverse_iterator(end()); }\n+  template <class _InputIterator>\n+    vector(_InputIterator __first, _InputIterator __last,\n+           const allocator_type& __a = allocator_type())\n+\t: _Base(__a)\n+    {\n+      // Check whether it's an integral type.  If so, it's not an iterator.\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_initialize_aux(__first, __last, _Integral());\n+    }\n+\n+protected:\n+  template<class _Integer>\n+    void\n+    _M_initialize_aux(_Integer __n, _Integer __value, __true_type)\n+    {\n+      _M_start = _M_allocate(__n);\n+      _M_end_of_storage = _M_start + __n;\n+      _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n+    }\n+\n+  template<class _InputIterator>\n+    void\n+    _M_initialize_aux(_InputIterator __first,_InputIterator __last,__false_type)\n+    {\n+      typedef typename iterator_traits<_InputIterator>::iterator_category\n+                       _IterCategory;\n+      _M_range_initialize(__first, __last, _IterCategory());\n+    }\n \n+public:\n   /**\n-   *  Returns a read-only (constant) reverse iterator that points to the last\n-   *  element in the vector.  Iteration is done in reverse element order.\n+   *  Creats a %vector consisting of copies of the elements from [first,last).\n+   *\n+   *  The dtor only erases the elements, and that if the elements\n+   *  themselves are pointers, the pointed-to memory is not touched in any\n+   *  way.  Managing the pointer is the user's responsibilty.\n   */\n-  const_reverse_iterator rbegin() const\n-    { return const_reverse_iterator(end()); }\n+  ~vector() { _Destroy(_M_start, _M_finish); }\n \n   /**\n-   *  Returns a read/write reverse iterator that points to one before the\n-   *  first element in the vector.  Iteration is done in reverse element\n-   *  order.\n+   *  @brief  %Vector assignment operator.\n+   *  @param  x  A %vector of identical element and allocator types.\n+   * \n+   *  All the elements of @a x are copied, but any extra memory in @a x (for\n+   *  fast expansion) will not be copied.  Unlike the copy constructor, the\n+   *  allocator object is not copied.\n   */\n-  reverse_iterator rend()\n-    { return reverse_iterator(begin()); }\n+  vector<_Tp, _Alloc>&\n+  operator=(const vector<_Tp, _Alloc>& __x);\n \n   /**\n-   *  Returns a read-only (constant) reverse iterator that points to one\n-   *  before the first element in the vector.  Iteration is done in reverse\n-   *  element order.\n+   *  @brief  Assigns a given value to a %vector.\n+   *  @param  n  Number of elements to be assigned.\n+   *  @param  val  Value to be assigned.\n+   *\n+   *  This function fills a %vector with @a n copies of the given value.\n+   *  Note that the assignment completely changes the %vector and that the\n+   *  resulting %vector's size is the same as the number of elements assigned.\n+   *  Old data may be lost.\n   */\n-  const_reverse_iterator rend() const\n-    { return const_reverse_iterator(begin()); }\n-\n-  /**  Returns the number of elements in the vector.  */\n-  size_type size() const\n-    { return size_type(end() - begin()); }\n+  void\n+  assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }\n \n-  /**  Returns the size of the largest possible vector.  */\n-  size_type max_size() const\n-    { return size_type(-1) / sizeof(_Tp); }\n+protected:\n+  void\n+  _M_fill_assign(size_type __n, const _Tp& __val);\n \n+public:\n   /**\n-   *  Returns the amount of memory that has been alocated for the current\n-   *  elements (?).\n+   *  @brief  Assigns a range to a %vector.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *\n+   *  This function fills a %vector with copies of the elements in the\n+   *  range [first,last).\n+   *\n+   *  Note that the assignment completely changes the %vector and that the\n+   *  resulting %vector's size is the same as the number of elements assigned.\n+   *  Old data may be lost.\n   */\n-  size_type capacity() const\n-    { return size_type(const_iterator(_M_end_of_storage) - begin()); }\n+  template<class _InputIterator>\n+    void\n+    assign(_InputIterator __first, _InputIterator __last)\n+    {\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_assign_dispatch(__first, __last, _Integral());\n+    }\n \n+protected:\n+  template<class _Integer>\n+    void\n+     _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+     { _M_fill_assign((size_type) __n, (_Tp) __val); }\n+\n+  template<class _InputIter>\n+    void\n+    _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIter>::iterator_category\n+                       _IterCategory;\n+      _M_assign_aux(__first, __last, _IterCategory());\n+    }\n+\n+  template <class _InputIterator>\n+    void \n+    _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+\t\t  input_iterator_tag);\n+\n+  template <class _ForwardIterator>\n+    void \n+    _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t  forward_iterator_tag);\n+\n+public:\n+  /// Get a copy of the memory allocation object.\n+  allocator_type\n+  get_allocator() const { return _Base::get_allocator(); }\n+\n+  // iterators\n   /**\n-   *  Returns true if the vector is empty.  (Thus begin() would equal end().)\n+   *  Returns a read/write iterator that points to the first element in the\n+   *  %vector.  Iteration is done in ordinary element order.\n   */\n-  bool empty() const\n-    { return begin() == end(); }\n+  iterator\n+  begin() { return iterator (_M_start); }\n \n   /**\n-   *  @brief  Subscript access to the data contained in the vector.\n-   *  @param  n  The element for which data should be accessed.\n-   *  @return  Read/write reference to data.\n-   *\n-   *  This operator allows for easy, array-style, data access.\n-   *  Note that data access with this operator is unchecked and out_of_range\n-   *  lookups are not defined. (For checked lookups see at().)\n+   *  Returns a read-only (constant) iterator that points to the first element\n+   *  in the %vector.  Iteration is done in ordinary element order.\n   */\n-  reference operator[](size_type __n) { return *(begin() + __n); }\n+  const_iterator\n+  begin() const { return const_iterator (_M_start); }\n \n   /**\n-   *  @brief  Subscript access to the data contained in the vector.\n-   *  @param  n  The element for which data should be accessed.\n-   *  @return  Read-only (constant) reference to data.\n-   *\n-   *  This operator allows for easy, array-style, data access.\n-   *  Note that data access with this operator is unchecked and out_of_range\n-   *  lookups are not defined. (For checked lookups see at().)\n+   *  Returns a read/write iterator that points one past the last element in\n+   *  the %vector.  Iteration is done in ordinary element order.\n   */\n-  const_reference operator[](size_type __n) const { return *(begin() + __n); }\n-\n-  void _M_range_check(size_type __n) const {\n-    if (__n >= this->size())\n-      __throw_out_of_range(\"vector\");\n-  }\n+  iterator\n+  end() { return iterator (_M_finish); }\n \n   /**\n-   *  @brief  Provides access to the data contained in the vector.\n-   *  @param  n  The element for which data should be accessed.\n-   *  @return  Read/write reference to data.\n-   *\n-   *  This function provides for safer data access.  The parameter is first\n-   *  checked that it is in the range of the vector.  The function throws\n-   *  out_of_range if the check fails.\n+   *  Returns a read-only (constant) iterator that points one past the last\n+   *  element in the %vector.  Iteration is done in ordinary element order.\n   */\n-  reference at(size_type __n)\n-    { _M_range_check(__n); return (*this)[__n]; }\n+  const_iterator\n+  end() const { return const_iterator (_M_finish); }\n \n   /**\n-   *  @brief  Provides access to the data contained in the vector.\n-   *  @param  n  The element for which data should be accessed.\n-   *  @return  Read-only (constant) reference to data.\n-   *\n-   *  This function provides for safer data access.  The parameter is first\n-   *  checked that it is in the range of the vector.  The function throws\n-   *  out_of_range if the check fails.\n+   *  Returns a read/write reverse iterator that points to the last element in\n+   *  the %vector.  Iteration is done in reverse element order.\n   */\n-  const_reference at(size_type __n) const\n-    { _M_range_check(__n); return (*this)[__n]; }\n-\n+  reverse_iterator\n+  rbegin() { return reverse_iterator(end()); }\n \n-  explicit vector(const allocator_type& __a = allocator_type())\n-    : _Base(__a) {}\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to the last\n+   *  element in the %vector.  Iteration is done in reverse element order.\n+  */\n+  const_reverse_iterator\n+  rbegin() const { return const_reverse_iterator(end()); }\n \n-  vector(size_type __n, const _Tp& __value,\n-         const allocator_type& __a = allocator_type())\n-    : _Base(__n, __a)\n-    { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }\n+  /**\n+   *  Returns a read/write reverse iterator that points to one before the\n+   *  first element in the %vector.  Iteration is done in reverse element\n+   *  order.\n+  */\n+  reverse_iterator\n+  rend() { return reverse_iterator(begin()); }\n \n-  explicit vector(size_type __n)\n-    : _Base(__n, allocator_type())\n-    { _M_finish = uninitialized_fill_n(_M_start, __n, _Tp()); }\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to one\n+   *  before the first element in the %vector.  Iteration is done in reverse\n+   *  element order.\n+  */\n+  const_reverse_iterator\n+  rend() const { return const_reverse_iterator(begin()); }\n \n-  vector(const vector<_Tp, _Alloc>& __x)\n-    : _Base(__x.size(), __x.get_allocator())\n-    { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n+  // [23.2.4.2] capacity\n+  /**  Returns the number of elements in the %vector.  */\n+  size_type\n+  size() const { return size_type(end() - begin()); }\n \n-  // Check whether it's an integral type.  If so, it's not an iterator.\n-  template <class _InputIterator>\n-    vector(_InputIterator __first, _InputIterator __last,\n-           const allocator_type& __a = allocator_type())\n-\t: _Base(__a)\n-\t{\n-      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_initialize_aux(__first, __last, _Integral());\n-    }\n+  /**  Returns the size() of the largest possible %vector.  */\n+  size_type\n+  max_size() const { return size_type(-1) / sizeof(_Tp); }\n \n-  template <class _Integer>\n-    void _M_initialize_aux(_Integer __n, _Integer __value, __true_type)\n-\t{\n-      _M_start = _M_allocate(__n);\n-      _M_end_of_storage = _M_start + __n;\n-      _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n-    }\n+  /**\n+   *  @brief  Resizes the %vector to the specified number of elements.\n+   *  @param  new_size  Number of elements the %vector should contain.\n+   *  @param  x  Data with which new elements should be populated.\n+   *\n+   *  This function will %resize the %vector to the specified number of\n+   *  elements.  If the number is smaller than the %vector's current size the\n+   *  %vector is truncated, otherwise the %vector is extended and new elements\n+   *  are populated with given data.\n+  */\n+  void\n+  resize(size_type __new_size, const _Tp& __x)\n+  {\n+    if (__new_size < size())\n+      erase(begin() + __new_size, end());\n+    else\n+      insert(end(), __new_size - size(), __x);\n+  }\n \n-  template<class _InputIterator>\n-    void\n-\t_M_initialize_aux(_InputIterator __first, _InputIterator __last, __false_type)\n-\t{\n-\t  typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategory;\n-\t  _M_range_initialize(__first, __last, _IterCategory());\n-\t}\n+  /**\n+   *  @brief  Resizes the %vector to the specified number of elements.\n+   *  @param  new_size  Number of elements the %vector should contain.\n+   *\n+   *  This function will resize the %vector to the specified number of\n+   *  elements.  If the number is smaller than the %vector's current size the\n+   *  %vector is truncated, otherwise the %vector is extended and new elements\n+   *  are default-constructed.\n+  */\n+  void\n+  resize(size_type __new_size) { resize(__new_size, _Tp()); }\n \n-  ~vector()\n-  { _Destroy(_M_start, _M_finish); }\n+  /**\n+   *  Returns the total number of elements that the %vector can hold before\n+   *  needing to allocate more memory.\n+  */\n+  size_type\n+  capacity() const\n+    { return size_type(const_iterator(_M_end_of_storage) - begin()); }\n \n-  vector<_Tp, _Alloc>& operator=(const vector<_Tp, _Alloc>& __x);\n+  /**\n+   *  Returns true if the %vector is empty.  (Thus begin() would equal end().)\n+  */\n+  bool\n+  empty() const { return begin() == end(); }\n \n   /**\n    *  @brief  Attempt to preallocate enough memory for specified number of\n    *          elements.\n-   *  @param  n  Number of elements required\n+   *  @param  n  Number of elements required.\n+   *  @throw  std::length_error  If @a n exceeds @c max_size().\n    *\n-   *  This function attempts to reserve enough memory for the vector to hold\n+   *  This function attempts to reserve enough memory for the %vector to hold\n    *  the specified number of elements.  If the number requested is more than\n-   *  max_size() length_error is thrown.\n+   *  max_size(), length_error is thrown.\n    *\n    *  The advantage of this function is that if optimal code is a necessity\n-   *  and the user can determine the number of elements that will be required\n-   *  the user can reserve the memory and thus prevent a possible\n-   *  reallocation of memory and copy of vector data.\n+   *  and the user can determine the number of elements that will be required,\n+   *  the user can reserve the memory in %advance, and thus prevent a possible\n+   *  reallocation of memory and copying of %vector data.\n   */\n-  void reserve(size_type __n) {\n+  void\n+  reserve(size_type __n)   // FIXME should be out of class\n+  {\n     if (capacity() < __n) {\n       const size_type __old_size = size();\n       pointer __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);\n@@ -402,88 +545,104 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n     }\n   }\n \n-  // assign(), a generalized assignment member function.  Two\n-  // versions: one that takes a count, and one that takes a range.\n-  // The range version is a member template, so we dispatch on whether\n-  // or not the type is an integer.\n-\n+  // element access\n   /**\n-   *  @brief  Assigns a given value or range to a vector.\n-   *  @param  n  Number of elements to be assigned.\n-   *  @param  val  Value to be assigned.\n+   *  @brief  Subscript access to the data contained in the %vector.\n+   *  @param  n  The index of the element for which data should be accessed.\n+   *  @return  Read/write reference to data.\n    *\n-   *  This function can be used to assign a range to a vector or fill it\n-   *  with a specified number of copies of the given value.\n-   *  Note that the assignment completely changes the vector and that the\n-   *  resulting vector's size is the same as the number of elements assigned.\n-   *  Old data may be lost.\n+   *  This operator allows for easy, array-style, data access.\n+   *  Note that data access with this operator is unchecked and out_of_range\n+   *  lookups are not defined. (For checked lookups see at().)\n   */\n-  void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }\n-  void _M_fill_assign(size_type __n, const _Tp& __val);\n+  reference\n+  operator[](size_type __n) { return *(begin() + __n); }\n \n-  template<class _InputIterator>\n-    void\n-    assign(_InputIterator __first, _InputIterator __last)\n-    {\n-      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_assign_dispatch(__first, __last, _Integral());\n-    }\n-\n-  template<class _Integer>\n-    void\n-     _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-     { _M_fill_assign((size_type) __n, (_Tp) __val); }\n+  /**\n+   *  @brief  Subscript access to the data contained in the %vector.\n+   *  @param  n  The index of the element for which data should be accessed.\n+   *  @return  Read-only (constant) reference to data.\n+   *\n+   *  This operator allows for easy, array-style, data access.\n+   *  Note that data access with this operator is unchecked and out_of_range\n+   *  lookups are not defined. (For checked lookups see at().)\n+  */\n+  const_reference\n+  operator[](size_type __n) const { return *(begin() + __n); }\n \n-  template<class _InputIter>\n-    void\n-    _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n-    {\n-      typedef typename iterator_traits<_InputIter>::iterator_category _IterCategory;\n-      _M_assign_aux(__first, __last, _IterCategory());\n-    }\n+protected:\n+  /// @if maint Safety check used only from at().  @endif\n+  void\n+  _M_range_check(size_type __n) const\n+  {\n+    if (__n >= this->size())\n+      __throw_out_of_range(\"vector [] access out of range\");\n+  }\n \n-  template <class _InputIterator>\n-    void \n-    _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-\t\t  input_iterator_tag);\n+public:\n+  /**\n+   *  @brief  Provides access to the data contained in the %vector.\n+   *  @param  n  The index of the element for which data should be accessed.\n+   *  @return  Read/write reference to data.\n+   *  @throw  std::out_of_range  If @a n is an invalid index.\n+   *\n+   *  This function provides for safer data access.  The parameter is first\n+   *  checked that it is in the range of the vector.  The function throws\n+   *  out_of_range if the check fails.\n+  */\n+  reference\n+  at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }\n \n-  template <class _ForwardIterator>\n-    void \n-    _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-\t\t  forward_iterator_tag);\n+  /**\n+   *  @brief  Provides access to the data contained in the %vector.\n+   *  @param  n  The index of the element for which data should be accessed.\n+   *  @return  Read-only (constant) reference to data.\n+   *  @throw  std::out_of_range  If @a n is an invalid index.\n+   *\n+   *  This function provides for safer data access.  The parameter is first\n+   *  checked that it is in the range of the vector.  The function throws\n+   *  out_of_range if the check fails.\n+  */\n+  const_reference\n+  at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }\n \n   /**\n    *  Returns a read/write reference to the data at the first element of the\n-   *  vector.\n+   *  %vector.\n   */\n-  reference front() { return *begin(); }\n+  reference\n+  front() { return *begin(); }\n \n   /**\n    *  Returns a read-only (constant) reference to the data at the first\n-   *  element of the vector.\n+   *  element of the %vector.\n   */\n-  const_reference front() const { return *begin(); }\n+  const_reference\n+  front() const { return *begin(); }\n \n   /**\n    *  Returns a read/write reference to the data at the last element of the\n-   *  vector.\n+   *  %vector.\n   */\n-  reference back() { return *(end() - 1); }\n+  reference\n+  back() { return *(end() - 1); }\n \n   /**\n-   *  Returns a read-only (constant) reference to the data at the first\n-   *  element of the vector.\n+   *  Returns a read-only (constant) reference to the data at the last\n+   *  element of the %vector.\n   */\n-  const_reference back() const { return *(end() - 1); }\n+  const_reference\n+  back() const { return *(end() - 1); }\n \n+  // [23.2.4.3] modifiers\n   /**\n-   *  @brief  Add data to the end of the vector.\n+   *  @brief  Add data to the end of the %vector.\n    *  @param  x  Data to be added.\n    *\n    *  This is a typical stack operation.  The function creates an element at\n-   *  the end of the vector and assigns the given data to it.\n-   *  Due to the nature of a vector this operation can be done in constant\n-   *  time if the vector has preallocated space available.\n+   *  the end of the %vector and assigns the given data to it.\n+   *  Due to the nature of a %vector this operation can be done in constant\n+   *  time if the %vector has preallocated space available.\n   */\n   void\n   push_back(const _Tp& __x)\n@@ -496,43 +655,30 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n       _M_insert_aux(end(), __x);\n   }\n \n-#ifdef _GLIBCPP_DEPRECATED\n   /**\n-   *  Add an element to the end of the vector.  The element is\n-   *  default-constructed.\n+   *  @brief  Removes last element.\n    *\n-   *  @note You must define _GLIBCPP_DEPRECATED to make this visible; see\n-   *        c++config.h.\n+   *  This is a typical stack operation. It shrinks the %vector by one.\n+   *\n+   *  Note that no data is returned, and if the last element's data is\n+   *  needed, it should be retrieved before pop_back() is called.\n   */\n   void\n-  push_back()\n-  {\n-    if (_M_finish != _M_end_of_storage) {\n-      _Construct(_M_finish);\n-      ++_M_finish;\n-    }\n-    else\n-      _M_insert_aux(end());\n-  }\n-#endif\n-\n-  void\n-  swap(vector<_Tp, _Alloc>& __x)\n+  pop_back()\n   {\n-    std::swap(_M_start, __x._M_start);\n-    std::swap(_M_finish, __x._M_finish);\n-    std::swap(_M_end_of_storage, __x._M_end_of_storage);\n+    --_M_finish;\n+    _Destroy(_M_finish);\n   }\n \n   /**\n-   *  @brief  Inserts given value into vector at specified element.\n-   *  @param  position  An iterator that points to the element where data\n-   *                    should be inserted.\n+   *  @brief  Inserts given value into %vector before specified iterator.\n+   *  @param  position  An iterator into the %vector.\n    *  @param  x  Data to be inserted.\n    *  @return  An iterator that points to the inserted data.\n    *\n-   *  This function will insert the given value into the specified location.\n-   *  Note that this kind of operation could be expensive for a vector and if\n+   *  This function will insert a copy of the given value before the specified\n+   *  location.\n+   *  Note that this kind of operation could be expensive for a %vector and if\n    *  it is frequently used the user should consider using std::list.\n   */\n   iterator\n@@ -548,16 +694,21 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n     return begin() + __n;\n   }\n \n+#ifdef _GLIBCPP_DEPRECATED\n   /**\n-   *  @brief  Inserts an empty element into the vector.\n-   *  @param  position  An iterator that points to the element where empty\n-   *                    element should be inserted.\n-   *  @param  x  Data to be inserted.\n+   *  @brief  Inserts an element into the %vector.\n+   *  @param  position  An iterator into the %vector.\n    *  @return  An iterator that points to the inserted element.\n    *\n-   *  This function will insert an empty element into the specified location.\n+   *  This function will insert a default-constructed element before the\n+   *  specified location.  You should consider using insert(position,Tp())\n+   *  instead.\n    *  Note that this kind of operation could be expensive for a vector and if\n    *  it is frequently used the user should consider using std::list.\n+   *\n+   *  @note This was deprecated in 3.2 and will be removed in 3.3.  You must\n+   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+   *        c++config.h.\n   */\n   iterator\n   insert(iterator __position)\n@@ -571,78 +722,88 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n       _M_insert_aux(iterator(__position));\n     return begin() + __n;\n   }\n-\n-  // Check whether it's an integral type.  If so, it's not an iterator.\n-  template<class _InputIterator>\n-    void\n-\tinsert(iterator __pos, _InputIterator __first, _InputIterator __last)\n-\t{\n-      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_insert_dispatch(__pos, __first, __last, _Integral());\n-    }\n-\n-  template <class _Integer>\n-    void\n-\t_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, __true_type)\n-    { _M_fill_insert(__pos, static_cast<size_type>(__n), static_cast<_Tp>(__val)); }\n-\n-  template<class _InputIterator>\n-    void\n-\t_M_insert_dispatch(iterator __pos,\n-                       _InputIterator __first, _InputIterator __last,\n-                       __false_type)\n-\t{\n-\t  typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategory;\n-      _M_range_insert(__pos, __first, __last, _IterCategory());\n-    }\n+#endif\n \n   /**\n-   *  @brief  Inserts a number of copies of given data into the vector.\n-   *  @param  position  An iterator that points to the element where data\n-   *                    should be inserted.\n-   *  @param  n  Amount of elements to be inserted.\n+   *  @brief  Inserts a number of copies of given data into the %vector.\n+   *  @param  position  An iterator into the %vector.\n+   *  @param  n  Number of elements to be inserted.\n    *  @param  x  Data to be inserted.\n    *\n    *  This function will insert a specified number of copies of the given data\n-   *  into the specified location.\n+   *  before the location specified by @a position.\n    *\n-   *  Note that this kind of operation could be expensive for a vector and if\n+   *  Note that this kind of operation could be expensive for a %vector and if\n    *  it is frequently used the user should consider using std::list.\n   */\n-  void insert (iterator __pos, size_type __n, const _Tp& __x)\n+  void\n+  insert (iterator __pos, size_type __n, const _Tp& __x)\n     { _M_fill_insert(__pos, __n, __x); }\n \n-  void _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);\n+protected:\n+  void\n+  _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);\n \n+public:\n   /**\n-   *  @brief  Removes last element from vector.\n+   *  @brief  Inserts a range into the %vector.\n+   *  @param  pos  An iterator into the %vector.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n    *\n-   *  This is a typical stack operation. It allows us to shrink the vector by\n-   *  one.\n+   *  This function will insert copies of the data in the range [first,last)\n+   *  into the %vector before the location specified by @a pos.\n    *\n-   *  Note that no data is returned and if last element's data is needed it\n-   *  should be retrieved before pop_back() is called.\n+   *  Note that this kind of operation could be expensive for a %vector and if\n+   *  it is frequently used the user should consider using std::list.\n   */\n-  void pop_back() {\n-    --_M_finish;\n-    _Destroy(_M_finish);\n-  }\n+  template<class _InputIterator>\n+    void\n+    insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n+      {\n+        // Check whether it's an integral type.  If so, it's not an iterator.\n+        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+        _M_insert_dispatch(__pos, __first, __last, _Integral());\n+      }\n \n+protected:\n+  template<class _Integer>\n+    void\n+    _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n+                       __true_type)\n+    {\n+      _M_fill_insert(__pos, static_cast<size_type>(__n),\n+                            static_cast<_Tp>(__val));\n+    }\n+\n+  template<class _InputIterator>\n+    void\n+    _M_insert_dispatch(iterator __pos, _InputIterator __first,\n+                       _InputIterator __last, __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIterator>::iterator_category\n+                       _IterCategory;\n+      _M_range_insert(__pos, __first, __last, _IterCategory());\n+    }\n+\n+public:\n   /**\n-   *  @brief  Remove element at given position\n+   *  @brief  Remove element at given position.\n    *  @param  position  Iterator pointing to element to be erased.\n-   *  @return  Doc Me! (Iterator pointing to new element at old location?)\n+   *  @return  An iterator pointing to the next element (or end()).\n    *\n    *  This function will erase the element at the given position and thus\n-   *  shorten the vector by one.\n+   *  shorten the %vector by one.\n    *\n    *  Note This operation could be expensive and if it is frequently used the\n    *  user should consider using std::list.  The user is also cautioned that\n    *  this function only erases the element, and that if the element is itself\n    *  a pointer, the pointed-to memory is not touched in any way.  Managing\n    *  the pointer is the user's responsibilty.\n   */\n-  iterator erase(iterator __position) {\n+  iterator\n+  erase(iterator __position)\n+  {\n     if (__position + 1 != end())\n       copy(__position + 1, end(), __position);\n     --_M_finish;\n@@ -651,74 +812,68 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   }\n \n   /**\n-   *  @brief  Remove a range of elements from a vector.\n+   *  @brief  Remove a range of elements.\n    *  @param  first  Iterator pointing to the first element to be erased.\n-   *  @param  last  Iterator pointing to the last element to be erased.\n-   *  @return  Doc Me! (Iterator pointing to new element at old location?)\n+   *  @param  last  Iterator pointing to one past the last element to be erased.\n+   *  @return  An iterator pointing to the element pointed to by @a last\n+   *           prior to erasing (or end()).\n    *\n-   *  This function will erase the elements in the given range and shorten the\n-   *  vector accordingly.\n+   *  This function will erase the elements in the range [first,last) and\n+   *  shorten the %vector accordingly.\n    *\n    *  Note This operation could be expensive and if it is frequently used the\n    *  user should consider using std::list.  The user is also cautioned that\n    *  this function only erases the elements, and that if the elements\n    *  themselves are pointers, the pointed-to memory is not touched in any\n    *  way.  Managing the pointer is the user's responsibilty.\n   */\n-  iterator erase(iterator __first, iterator __last) {\n+  iterator\n+  erase(iterator __first, iterator __last)\n+  {\n     iterator __i(copy(__last, end(), __first));\n     _Destroy(__i, end());\n     _M_finish = _M_finish - (__last - __first);\n     return __first;\n   }\n \n   /**\n-   *  @brief  Resizes the vector to the specified number of elements.\n-   *  @param  new_size  Number of elements the vector should contain.\n-   *  @param  x  Data with which new elements should be populated.\n+   *  @brief  Swaps data with another %vector.\n+   *  @param  x  A %vector of the same element and allocator types.\n    *\n-   *  This function will resize the vector to the specified number of\n-   *  elements.  If the number is smaller than the vector's current size the\n-   *  vector is truncated, otherwise the vector is extended and new elements\n-   *  are populated with given data.\n+   *  This exchanges the elements between two vectors in constant time.\n+   *  (Three pointers, so it should be quite fast.)\n+   *  Note that the global std::swap() function is specialized such that\n+   *  std::swap(v1,v2) will feed to this function.\n   */\n-  void resize(size_type __new_size, const _Tp& __x) {\n-    if (__new_size < size())\n-      erase(begin() + __new_size, end());\n-    else\n-      insert(end(), __new_size - size(), __x);\n+  void\n+  swap(vector<_Tp, _Alloc>& __x)\n+  {\n+    std::swap(_M_start, __x._M_start);\n+    std::swap(_M_finish, __x._M_finish);\n+    std::swap(_M_end_of_storage, __x._M_end_of_storage);\n   }\n \n   /**\n-   *  @brief  Resizes the vector to the specified number of elements.\n-   *  @param  new_size  Number of elements the vector should contain.\n-   *\n-   *  This function will resize the vector to the specified number of\n-   *  elements.  If the number is smaller than the vector's current size the\n-   *  vector is truncated, otherwise the vector is extended and new elements\n-   *  are left uninitialized.\n-  */\n-  void resize(size_type __new_size) { resize(__new_size, _Tp()); }\n-\n-  /**\n-   *  Erases all elements in vector.  Note that this function only erases the\n+   *  Erases all the elements.  Note that this function only erases the\n    *  elements, and that if the elements themselves are pointers, the\n    *  pointed-to memory is not touched in any way.  Managing the pointer is\n    *  the user's responsibilty.\n   */\n-  void clear() { erase(begin(), end()); }\n+  void\n+  clear() { erase(begin(), end()); }\n \n protected:\n-\n   template <class _ForwardIterator>\n-  pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first,\n-                                               _ForwardIterator __last)\n+  pointer\n+    _M_allocate_and_copy(size_type __n, _ForwardIterator __first,\n+                         _ForwardIterator __last)\n   {\n     pointer __result = _M_allocate(__n);\n-    try {\n-      uninitialized_copy(__first, __last, __result);\n-      return __result;\n-    }\n+    try\n+      {\n+        uninitialized_copy(__first, __last, __result);\n+        return __result;\n+      }\n     catch(...)\n       {\n \t_M_deallocate(__result, __n);\n@@ -727,8 +882,9 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   }\n \n   template <class _InputIterator>\n-  void _M_range_initialize(_InputIterator __first,\n-                           _InputIterator __last, input_iterator_tag)\n+  void\n+    _M_range_initialize(_InputIterator __first,\n+                        _InputIterator __last, input_iterator_tag)\n   {\n     for ( ; __first != __last; ++__first)\n       push_back(*__first);\n@@ -756,6 +912,17 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n                        forward_iterator_tag);\n };\n \n+\n+/**\n+ *  @brief  Vector equality comparison.\n+ *  @param  x  A %vector.\n+ *  @param  y  A %vector of the same type as @a x.\n+ *  @return  True iff the size and elements of the vectors are equal.\n+ *\n+ *  This is an equivalence relation.  It is linear in the size of the\n+ *  vectors.  Vectors are considered equivalent if their sizes are equal,\n+ *  and if corresponding elements compare equal.\n+*/\n template <class _Tp, class _Alloc>\n inline bool\n operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n@@ -764,6 +931,17 @@ operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n          equal(__x.begin(), __x.end(), __y.begin());\n }\n \n+/**\n+ *  @brief  Vector ordering relation.\n+ *  @param  x  A %vector.\n+ *  @param  y  A %vector of the same type as @a x.\n+ *  @return  True iff @a x is lexographically less than @a y.\n+ *\n+ *  This is a total ordering relation.  It is linear in the size of the\n+ *  vectors.  The elements must be comparable with @c <.\n+ *\n+ *  See std::lexographical_compare() for how the determination is made.\n+*/\n template <class _Tp, class _Alloc>\n inline bool\n operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n@@ -772,36 +950,42 @@ operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n                                  __y.begin(), __y.end());\n }\n \n+/// See std::vector::swap().\n template <class _Tp, class _Alloc>\n inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)\n {\n   __x.swap(__y);\n }\n \n+/// Based on operator==\n template <class _Tp, class _Alloc>\n inline bool\n operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n   return !(__x == __y);\n }\n \n+/// Based on operator<\n template <class _Tp, class _Alloc>\n inline bool\n operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n   return __y < __x;\n }\n \n+/// Based on operator<\n template <class _Tp, class _Alloc>\n inline bool\n operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n   return !(__y < __x);\n }\n \n+/// Based on operator<\n template <class _Tp, class _Alloc>\n inline bool\n operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n   return !(__x < __y);\n }\n \n+// XXX begin tcc me\n template <class _Tp, class _Alloc>\n vector<_Tp,_Alloc>&\n vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)\n@@ -919,6 +1103,7 @@ vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)\n   }\n }\n \n+#ifdef _GLIBCPP_DEPRECATED\n template <class _Tp, class _Alloc>\n void\n vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)\n@@ -956,6 +1141,7 @@ vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)\n     _M_end_of_storage = __new_start + __len;\n   }\n }\n+#endif\n \n template <class _Tp, class _Alloc>\n void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,\n@@ -1078,6 +1264,3 @@ vector<_Tp, _Alloc>::_M_range_insert(iterator __position,\n \n #endif /* __GLIBCPP_INTERNAL_VECTOR_H */\n \n-// Local Variables:\n-// mode:C++\n-// End:"}]}