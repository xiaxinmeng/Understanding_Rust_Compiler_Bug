{"sha": "9840d30abff62d41bda189f256b1ed3e41e6edc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg0MGQzMGFiZmY2MmQ0MWJkYTE4OWYyNTZiMWVkM2U0MWU2ZWRjMQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-09-03T15:37:28Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-09-03T15:37:28Z"}, "message": "linux.h (TARGET_SUPPORTS_SYNC_CALLS): Define to 1.\n\ngcc/\n\t* config/bfin/linux.h (TARGET_SUPPORTS_SYNC_CALLS): Define to 1.\n\t* config/bfin/uclinux.h (TARGET_SUPPORTS_SYNC_CALLS): Define to 1.\n\t* config/bfin/bfin.h (TARGET_SUPPORTS_SYNC_CALLS): Provide default of\n\t0.\n\t* config/bfin/sync.md: New file.\n\t* config/bfin/bfin.md: Include it.\n\t(UNSPEC_ATOMIC): New.\n\t(UNSPEC_ONES): Provide a unique number.\n\n\tFrom Jie Zhang <jie.zhang@analog.com>:\n\t* config/bfin/bfin.c (ret_regs): New.\n\t(must_save_fp_p): Don't return true because of frame_pointer_needed.\n\t(must_save_rets_p): New.\n\t(n_regs_saved_by_prologue): Use must_save_rets_p instead of\n\tcurrent_function_is_leaf.\n\t(do_link): Likewise.\n\t(do_unlink): Likewise.\n\t(expand_interrupt_handler_prologue): Use ret_regs array.\n\t(expand_interrupt_handler_epilogue): Use ret_regs array and\n\tpass return register to gen_return_internal.\n\t(bfin_expand_epilogue): Pass return register to\n\tgen_return_internal.\n\t(bfin_expand_call): Explicitly clobber RETS.\n\t* config/bfin/bfin.h (FUNCTION_RETURN_REGISTERS): Define.\n\t* config/bfin/bfin.md (call_symbol_fdpic, call_value_symbol_fdpic,\n\tcall_insn_fdpic, call_value_insn_fdpic, call_symbol,\n\tcall_value_symbol, call_insn, call_value_insn): Explicitly clobber\n\tRETS.\n\t(return_internal): Take a reg rtx rather than the register number.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_sync_int_long):\n\tSupported on Blackfin Linux targets.\n\nFrom-SVN: r151381", "tree": {"sha": "2a3d9e1c43f8bd260ab33779e73b86699cbfd3cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a3d9e1c43f8bd260ab33779e73b86699cbfd3cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9840d30abff62d41bda189f256b1ed3e41e6edc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9840d30abff62d41bda189f256b1ed3e41e6edc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9840d30abff62d41bda189f256b1ed3e41e6edc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9840d30abff62d41bda189f256b1ed3e41e6edc1/comments", "author": null, "committer": null, "parents": [{"sha": "be2c0fc9418411a898756e517fb6cfbffb3002eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be2c0fc9418411a898756e517fb6cfbffb3002eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be2c0fc9418411a898756e517fb6cfbffb3002eb"}], "stats": {"total": 312, "additions": 279, "deletions": 33}, "files": [{"sha": "ca35f9c3cf97b5a8236ef018dd294d902b845733", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9840d30abff62d41bda189f256b1ed3e41e6edc1", "patch": "@@ -1,3 +1,35 @@\n+2009-09-03  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/linux.h (TARGET_SUPPORTS_SYNC_CALLS): Define to 1.\n+\t* config/bfin/uclinux.h (TARGET_SUPPORTS_SYNC_CALLS): Define to 1.\n+\t* config/bfin/bfin.h (TARGET_SUPPORTS_SYNC_CALLS): Provide default of\n+\t0.\n+\t* config/bfin/sync.md: New file.\n+\t* config/bfin/bfin.md: Include it.\n+\t(UNSPEC_ATOMIC): New.\n+\t(UNSPEC_ONES): Provide a unique number.\n+\n+\tFrom Jie Zhang <jie.zhang@analog.com>:\n+\t* config/bfin/bfin.c (ret_regs): New.\n+\t(must_save_fp_p): Don't return true because of frame_pointer_needed.\n+\t(must_save_rets_p): New.\n+\t(n_regs_saved_by_prologue): Use must_save_rets_p instead of\n+\tcurrent_function_is_leaf.\n+\t(do_link): Likewise.\n+\t(do_unlink): Likewise.\n+\t(expand_interrupt_handler_prologue): Use ret_regs array.\n+\t(expand_interrupt_handler_epilogue): Use ret_regs array and\n+\tpass return register to gen_return_internal.\n+\t(bfin_expand_epilogue): Pass return register to\n+\tgen_return_internal.\n+\t(bfin_expand_call): Explicitly clobber RETS.\n+\t* config/bfin/bfin.h (FUNCTION_RETURN_REGISTERS): Define.\n+\t* config/bfin/bfin.md (call_symbol_fdpic, call_value_symbol_fdpic,\n+\tcall_insn_fdpic, call_value_insn_fdpic, call_symbol,\n+\tcall_value_symbol, call_insn, call_value_insn): Explicitly clobber\n+\tRETS.\n+\t(return_internal): Take a reg rtx rather than the register number.\n+\n 2009-09-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* tree-parloops.c (parallelize_loops): Cast to HOST_WIDE_INT"}, {"sha": "ebcd825043e7aae74dd6ee966beb69e37408d6ba", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=9840d30abff62d41bda189f256b1ed3e41e6edc1", "patch": "@@ -63,6 +63,7 @@ struct GTY(()) machine_function\n   /* Set if we are notified by the doloop pass that a hardware loop\n      was created.  */\n   int has_hardware_loops;\n+\n   /* Set if we create a memcpy pattern that uses loop registers.  */\n   int has_loopreg_clobber;\n };\n@@ -81,6 +82,7 @@ const char *dregs_pair_names[] =  DREGS_PAIR_NAMES;\n const char *byte_reg_names[]   =  BYTE_REGISTER_NAMES;\n \n static int arg_regs[] = FUNCTION_ARG_REGISTERS;\n+static int ret_regs[] = FUNCTION_RETURN_REGISTERS;\n \n /* Nonzero if -mshared-library-id was given.  */\n static int bfin_lib_id_given;\n@@ -532,7 +534,14 @@ n_pregs_to_save (bool is_inthandler, bool consecutive)\n static bool\n must_save_fp_p (void)\n {\n-  return frame_pointer_needed || df_regs_ever_live_p (REG_FP);\n+  return df_regs_ever_live_p (REG_FP);\n+}\n+\n+/* Determine if we are going to save the RETS register.  */\n+static bool\n+must_save_rets_p (void)\n+{\n+  return df_regs_ever_live_p (REG_RETS);\n }\n \n static bool\n@@ -844,13 +853,12 @@ n_regs_saved_by_prologue (void)\n   int i;\n \n   if (all || stack_frame_needed_p ())\n-    /* We use a LINK instruction in this case.  */\n     n += 2;\n   else\n     {\n       if (must_save_fp_p ())\n \tn++;\n-      if (! current_function_is_leaf)\n+      if (must_save_rets_p ())\n \tn++;\n     }\n \n@@ -1092,12 +1100,13 @@ do_link (rtx spreg, HOST_WIDE_INT frame_size, bool all)\n {\n   frame_size += arg_area_size ();\n \n-  if (all || stack_frame_needed_p ()\n-      || (must_save_fp_p () && ! current_function_is_leaf))\n+  if (all\n+      || stack_frame_needed_p ()\n+      || (must_save_rets_p () && must_save_fp_p ()))\n     emit_link_insn (spreg, frame_size);\n   else\n     {\n-      if (! current_function_is_leaf)\n+      if (must_save_rets_p ())\n \t{\n \t  rtx pat = gen_movsi (gen_rtx_MEM (Pmode,\n \t\t\t\t\t    gen_rtx_PRE_DEC (Pmode, spreg)),\n@@ -1127,20 +1136,20 @@ do_unlink (rtx spreg, HOST_WIDE_INT frame_size, bool all, int epilogue_p)\n {\n   frame_size += arg_area_size ();\n \n-  if (all || stack_frame_needed_p ())\n+  if (stack_frame_needed_p ())\n     emit_insn (gen_unlink ());\n   else \n     {\n       rtx postinc = gen_rtx_MEM (Pmode, gen_rtx_POST_INC (Pmode, spreg));\n \n       add_to_reg (spreg, frame_size, 0, epilogue_p);\n-      if (must_save_fp_p ())\n+      if (all || must_save_fp_p ())\n \t{\n \t  rtx fpreg = gen_rtx_REG (Pmode, REG_FP);\n \t  emit_move_insn (fpreg, postinc);\n \t  emit_use (fpreg);\n \t}\n-      if (! current_function_is_leaf)\n+      if (all || must_save_rets_p ())\n \t{\n \t  emit_move_insn (bfin_rets_rtx, postinc);\n \t  emit_use (bfin_rets_rtx);\n@@ -1194,9 +1203,7 @@ expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind, bool all)\n   \n   if (lookup_attribute (\"nesting\", attrs))\n     {\n-      rtx srcreg = gen_rtx_REG (Pmode, (fkind == EXCPT_HANDLER ? REG_RETX\n-\t\t\t\t\t: fkind == NMI_HANDLER ? REG_RETN\n-\t\t\t\t\t: REG_RETI));\n+      rtx srcreg = gen_rtx_REG (Pmode, ret_regs[fkind]);\n       insn = emit_move_insn (predec, srcreg);\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n@@ -1238,9 +1245,7 @@ expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind, bool all)\n \n   if (lookup_attribute (\"nesting\", attrs))\n     {\n-      rtx srcreg = gen_rtx_REG (Pmode, (fkind == EXCPT_HANDLER ? REG_RETX\n-\t\t\t\t\t: fkind == NMI_HANDLER ? REG_RETN\n-\t\t\t\t\t: REG_RETI));\n+      rtx srcreg = gen_rtx_REG (Pmode, ret_regs[fkind]);\n       emit_move_insn (srcreg, postinc);\n     }\n \n@@ -1256,7 +1261,7 @@ expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind, bool all)\n   if (fkind == EXCPT_HANDLER)\n     emit_insn (gen_addsi3 (spreg, spreg, GEN_INT (12)));\n \n-  emit_jump_insn (gen_return_internal (GEN_INT (fkind)));\n+  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, ret_regs[fkind])));\n }\n \n /* Used while emitting the prologue to generate code to load the correct value\n@@ -1392,7 +1397,7 @@ bfin_expand_epilogue (int need_return, int eh_return, bool sibcall_p)\n   if (eh_return)\n     emit_insn (gen_addsi3 (spreg, spreg, gen_rtx_REG (Pmode, REG_P2)));\n \n-  emit_jump_insn (gen_return_internal (GEN_INT (SUBROUTINE)));\n+  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, REG_RETS)));\n }\n \f\n /* Return nonzero if register OLD_REG can be renamed to register NEW_REG.  */\n@@ -2193,9 +2198,10 @@ bfin_expand_call (rtx retval, rtx fnaddr, rtx callarg1, rtx cookie, int sibcall)\n {\n   rtx use = NULL, call;\n   rtx callee = XEXP (fnaddr, 0);\n-  int nelts = 2 + !!sibcall;\n+  int nelts = 3;\n   rtx pat;\n   rtx picreg = get_hard_reg_initial_val (SImode, FDPIC_REGNO);\n+  rtx retsreg = gen_rtx_REG (Pmode, REG_RETS);\n   int n;\n \n   /* In an untyped call, we can get NULL for operand 2.  */\n@@ -2272,6 +2278,8 @@ bfin_expand_call (rtx retval, rtx fnaddr, rtx callarg1, rtx cookie, int sibcall)\n   XVECEXP (pat, 0, n++) = gen_rtx_USE (VOIDmode, cookie);\n   if (sibcall)\n     XVECEXP (pat, 0, n++) = gen_rtx_RETURN (VOIDmode);\n+  else\n+    XVECEXP (pat, 0, n++) = gen_rtx_CLOBBER (VOIDmode, retsreg);\n   call = emit_call_insn (pat);\n   if (use)\n     CALL_INSN_FUNCTION_USAGE (call) = use;"}, {"sha": "53a7957405a1a424dac3cd8f809b72bc6c3cd282", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=9840d30abff62d41bda189f256b1ed3e41e6edc1", "patch": "@@ -794,6 +794,7 @@ enum reg_class\n typedef enum {\n   SUBROUTINE, INTERRUPT_HANDLER, EXCPT_HANDLER, NMI_HANDLER\n } e_funkind;\n+#define FUNCTION_RETURN_REGISTERS { REG_RETS, REG_RETI, REG_RETX, REG_RETN }\n \n #define FUNCTION_ARG_REGISTERS { REG_R0, REG_R1, REG_R2, -1 }\n \n@@ -1258,4 +1259,8 @@ extern int splitting_for_sched, splitting_loops;\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) ((CHAR) == '!')\n \n+#ifndef TARGET_SUPPORTS_SYNC_CALLS\n+#define TARGET_SUPPORTS_SYNC_CALLS 0\n+#endif\n+\n #endif /*  _BFIN_CONFIG */"}, {"sha": "01e40125cf6b2611c8d1058017d937cb86046d73", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=9840d30abff62d41bda189f256b1ed3e41e6edc1", "patch": "@@ -138,7 +138,8 @@\n    ;; Distinguish a 32-bit version of an insn from a 16-bit version.\n    (UNSPEC_32BIT 11)\n    (UNSPEC_NOP 12)\n-   (UNSPEC_ONES 12)])\n+   (UNSPEC_ONES 13)\n+   (UNSPEC_ATOMIC 14)])\n \n (define_constants\n   [(UNSPEC_VOLATILE_CSYNC 1)\n@@ -2005,7 +2006,8 @@\n   [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\" \"Q\"))\n \t (match_operand 1 \"general_operand\" \"g\"))\n    (use (match_operand:SI 2 \"register_operand\" \"Z\"))\n-   (use (match_operand 3 \"\" \"\"))]\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI REG_RETS))]\n   \"! SIBLING_CALL_P (insn)\n    && GET_CODE (operands[0]) == SYMBOL_REF\n    && !bfin_longcall_p (operands[0], INTVAL (operands[3]))\"\n@@ -2031,7 +2033,8 @@\n         (call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"Q\"))\n \t      (match_operand 2 \"general_operand\" \"g\")))\n    (use (match_operand:SI 3 \"register_operand\" \"Z\"))\n-   (use (match_operand 4 \"\" \"\"))]\n+   (use (match_operand 4 \"\" \"\"))\n+   (clobber (reg:SI REG_RETS))]\n   \"! SIBLING_CALL_P (insn)\n    && GET_CODE (operands[1]) == SYMBOL_REF\n    && !bfin_longcall_p (operands[1], INTVAL (operands[4]))\"\n@@ -2057,7 +2060,8 @@\n   [(call (mem:SI (match_operand:SI 0 \"register_no_elim_operand\" \"Y\"))\n \t (match_operand 1 \"general_operand\" \"g\"))\n    (use (match_operand:SI 2 \"register_operand\" \"Z\"))\n-   (use (match_operand 3 \"\" \"\"))]\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI REG_RETS))]\n   \"! SIBLING_CALL_P (insn)\"\n   \"call (%0);\"\n   [(set_attr \"type\" \"call\")\n@@ -2079,7 +2083,8 @@\n         (call (mem:SI (match_operand:SI 1 \"register_no_elim_operand\" \"Y\"))\n \t      (match_operand 2 \"general_operand\" \"g\")))\n    (use (match_operand:SI 3 \"register_operand\" \"Z\"))\n-   (use (match_operand 4 \"\" \"\"))]\n+   (use (match_operand 4 \"\" \"\"))\n+   (clobber (reg:SI REG_RETS))]\n   \"! SIBLING_CALL_P (insn)\"\n   \"call (%1);\"\n   [(set_attr \"type\" \"call\")\n@@ -2100,7 +2105,8 @@\n (define_insn \"*call_symbol\"\n   [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\" \"Q\"))\n \t (match_operand 1 \"general_operand\" \"g\"))\n-   (use (match_operand 2 \"\" \"\"))]\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (reg:SI REG_RETS))]\n   \"! SIBLING_CALL_P (insn)\n    && (!TARGET_ID_SHARED_LIBRARY || TARGET_LEAF_ID_SHARED_LIBRARY)\n    && GET_CODE (operands[0]) == SYMBOL_REF\n@@ -2126,7 +2132,8 @@\n   [(set (match_operand 0 \"register_operand\" \"=d\")\n         (call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"Q\"))\n \t      (match_operand 2 \"general_operand\" \"g\")))\n-   (use (match_operand 3 \"\" \"\"))]\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI REG_RETS))]\n   \"! SIBLING_CALL_P (insn)\n    && (!TARGET_ID_SHARED_LIBRARY || TARGET_LEAF_ID_SHARED_LIBRARY)\n    && GET_CODE (operands[1]) == SYMBOL_REF\n@@ -2152,7 +2159,8 @@\n (define_insn \"*call_insn\"\n   [(call (mem:SI (match_operand:SI 0 \"register_no_elim_operand\" \"a\"))\n \t (match_operand 1 \"general_operand\" \"g\"))\n-   (use (match_operand 2 \"\" \"\"))]\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (reg:SI REG_RETS))]\n   \"! SIBLING_CALL_P (insn)\"\n   \"call (%0);\"\n   [(set_attr \"type\" \"call\")\n@@ -2172,7 +2180,8 @@\n   [(set (match_operand 0 \"register_operand\" \"=d\")\n         (call (mem:SI (match_operand:SI 1 \"register_no_elim_operand\" \"a\"))\n \t      (match_operand 2 \"general_operand\" \"g\")))\n-   (use (match_operand 3 \"\" \"\"))]\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI REG_RETS))]\n   \"! SIBLING_CALL_P (insn)\"\n   \"call (%1);\"\n   [(set_attr \"type\" \"call\")\n@@ -2641,18 +2650,18 @@\n \n (define_insn \"return_internal\"\n   [(return)\n-   (unspec [(match_operand 0 \"immediate_operand\" \"i\")] UNSPEC_RETURN)]\n+   (use (match_operand 0 \"register_operand\" \"\"))]\n   \"reload_completed\"\n {\n-  switch (INTVAL (operands[0]))\n+  switch (REGNO (operands[0]))\n     {\n-    case EXCPT_HANDLER:\n+    case REG_RETX:\n       return \"rtx;\";\n-    case NMI_HANDLER:\n+    case REG_RETN:\n       return \"rtn;\";\n-    case INTERRUPT_HANDLER:\n+    case REG_RETI:\n       return \"rti;\";\n-    case SUBROUTINE:\n+    case REG_RETS:\n       return \"rts;\";\n     }\n   gcc_unreachable ();\n@@ -4106,3 +4115,5 @@\n   \"DISALGNEXCPT || %0 = [%1];\"\n   [(set_attr \"type\" \"mcld\")\n    (set_attr \"length\" \"8\")])\n+\n+(include \"sync.md\")"}, {"sha": "5c716cd67f77fa148923cf3a2d3d5dd9b0ec7d89", "filename": "gcc/config/bfin/linux.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Flinux.h?ref=9840d30abff62d41bda189f256b1ed3e41e6edc1", "patch": "@@ -49,3 +49,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    %{static}} -init __init -fini __fini\"\n \n #define MD_UNWIND_SUPPORT \"config/bfin/linux-unwind.h\"\n+\n+#undef TARGET_SUPPORTS_SYNC_CALLS\n+#define TARGET_SUPPORTS_SYNC_CALLS 1"}, {"sha": "7025af4979d77e3375fe38209762206c767ecac2", "filename": "gcc/config/bfin/sync.md", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fsync.md?ref=9840d30abff62d41bda189f256b1ed3e41e6edc1", "patch": "@@ -0,0 +1,178 @@\n+;; GCC machine description for Blackfin synchronization instructions.\n+;; Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+;; Contributed by Analog Devices.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_code_iterator FETCHOP [plus minus ior and xor])\n+(define_code_attr fetchop_name\n+  [(plus \"add\") (minus \"sub\") (ior \"ior\") (and \"and\") (xor \"xor\")])\n+(define_code_attr fetchop_addr\n+  [(plus \"1072\") (minus \"1088\") (ior \"1104\") (and \"1120\") (xor \"1136\")])\n+\n+(define_insn \"sync_<fetchop_name>si_internal\"\n+  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"qA\"))\n+\t(unspec:SI\n+\t  [(FETCHOP:SI (mem:SI (match_dup 0))\n+\t     (match_operand:SI 1 \"register_operand\" \"q0\"))\n+\t   (match_operand:SI 2 \"register_no_elim_operand\" \"a\")]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:SI 3 \"=q0\"))\n+   (clobber (match_scratch:SI 4 \"=q1\"))\n+   (clobber (reg:SI REG_RETS))]\n+  \"TARGET_SUPPORTS_SYNC_CALLS\"\n+  \"call (%2);\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"sync_<fetchop_name>si\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"memory_operand\" \"+m\")\n+\t  (unspec:SI\n+\t   [(FETCHOP:SI (match_dup 0)\n+\t\t\t(match_operand:SI 1 \"register_operand\" \"q0\"))\n+\t    (match_dup 2)]\n+\t   UNSPEC_ATOMIC))\n+     (clobber (match_scratch:SI 3 \"\"))\n+     (clobber (match_scratch:SI 4 \"\"))\n+     (clobber (reg:SI REG_RETS))])]\n+  \"TARGET_SUPPORTS_SYNC_CALLS\"\n+{\n+  if (!REG_P (XEXP (operands[0], 0)))\n+    {\n+      operands[0] = shallow_copy_rtx (operands[0]);\n+      XEXP (operands[0], 0) = force_reg (Pmode, XEXP (operands[0], 0));\n+    }\n+  operands[2] = force_reg (Pmode, GEN_INT (<fetchop_addr>));\n+})\n+\n+(define_insn \"sync_old_<fetchop_name>si_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=q1\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"qA\")))\n+   (set (mem:SI (match_dup 1))\n+\t(unspec:SI\n+\t  [(FETCHOP:SI (mem:SI (match_dup 1))\n+\t     (match_operand:SI 2 \"register_operand\" \"q0\"))\n+\t   (match_operand:SI 3 \"register_no_elim_operand\" \"a\")]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:SI 4 \"=q0\"))\n+   (clobber (reg:SI REG_RETS))]\n+  \"TARGET_SUPPORTS_SYNC_CALLS\"\n+  \"call (%3);\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"sync_old_<fetchop_name>si\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t  (match_operand:SI 1 \"memory_operand\" \"\"))\n+     (set (match_dup 1)\n+\t  (unspec:SI\n+\t   [(FETCHOP:SI (match_dup 1)\n+\t\t\t(match_operand:SI 2 \"register_operand\" \"\"))\n+\t    (match_dup 3)]\n+\t   UNSPEC_ATOMIC))\n+     (clobber (match_scratch:SI 4 \"\"))\n+     (clobber (reg:SI REG_RETS))])]\n+  \"TARGET_SUPPORTS_SYNC_CALLS\"\n+{\n+  if (!REG_P (XEXP (operands[1], 0)))\n+    {\n+      operands[1] = shallow_copy_rtx (operands[1]);\n+      XEXP (operands[1], 0) = force_reg (Pmode, XEXP (operands[1], 0));\n+    }\n+  operands[3] = force_reg (Pmode, GEN_INT (<fetchop_addr>));\n+})\n+\n+(define_insn \"sync_new_<fetchop_name>si_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=q0\")\n+\t(unspec:SI\n+\t  [(FETCHOP:SI\n+\t    (mem:SI (match_operand:SI 1 \"register_operand\" \"qA\"))\n+\t    (match_operand:SI 2 \"register_operand\" \"q0\"))\n+\t   (match_operand:SI 3 \"register_no_elim_operand\" \"a\")]\n+\t  UNSPEC_ATOMIC))\n+   (set (mem:SI (match_dup 1))\n+\t(unspec:SI\n+\t  [(FETCHOP:SI (mem:SI (match_dup 1)) (match_dup 2))\n+\t   (match_dup 3)]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:SI 4 \"=q1\"))\n+   (clobber (reg:SI REG_RETS))]\n+  \"TARGET_SUPPORTS_SYNC_CALLS\"\n+  \"call (%3);\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"sync_new_<fetchop_name>si\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t  (unspec:SI\n+\t   [(FETCHOP:SI (match_operand:SI 1 \"memory_operand\" \"\")\n+\t\t\t(match_operand:SI 2 \"register_operand\" \"\"))\n+\t    (match_dup 3)]\n+\t   UNSPEC_ATOMIC))\n+     (set (match_dup 1)\n+\t  (unspec:SI\n+\t   [(FETCHOP:SI (match_dup 1) (match_dup 2))\n+\t    (match_dup 3)]\n+\t   UNSPEC_ATOMIC))\n+     (clobber (match_scratch:SI 4 \"\"))\n+     (clobber (reg:SI REG_RETS))])]\n+  \"TARGET_SUPPORTS_SYNC_CALLS\"\n+{\n+  if (!REG_P (XEXP (operands[1], 0)))\n+    {\n+      operands[1] = shallow_copy_rtx (operands[1]);\n+      XEXP (operands[1], 0) = force_reg (Pmode, XEXP (operands[1], 0));\n+    }\n+  operands[3] = force_reg (Pmode, GEN_INT (<fetchop_addr>));\n+})\n+\n+(define_insn \"sync_compare_and_swapsi_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=q0\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"qA\")))\n+   (set (mem:SI (match_dup 1))\n+\t(unspec:SI\n+\t  [(mem:SI (match_dup 1))\n+\t   (match_operand:SI 2 \"register_operand\" \"q1\")\n+\t   (match_operand:SI 3 \"register_operand\" \"q2\")\n+\t   (match_operand:SI 4 \"register_no_elim_operand\" \"a\")]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (reg:SI REG_RETS))]\n+  \"TARGET_SUPPORTS_SYNC_CALLS\"\n+  \"call (%4);\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"sync_compare_and_swapsi\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t  (match_operand:SI 1 \"memory_operand\" \"\"))\n+     (set (match_dup 1)\n+\t  (unspec:SI\n+\t   [(match_dup 1)\n+\t    (match_operand:SI 2 \"register_operand\" \"\")\n+\t    (match_operand:SI 3 \"register_operand\" \"\")\n+\t    (match_dup 4)]\n+\t   UNSPEC_ATOMIC))\n+     (clobber (reg:SI REG_RETS))])]\n+  \"TARGET_SUPPORTS_SYNC_CALLS\"\n+{\n+  if (!REG_P (XEXP (operands[1], 0)))\n+    {\n+      operands[1] = shallow_copy_rtx (operands[1]);\n+      XEXP (operands[1], 0) = force_reg (Pmode, XEXP (operands[1], 0));\n+    }\n+  operands[4] = force_reg (Pmode, GEN_INT (0x420));\n+})"}, {"sha": "6001b23645b786e954ca24347162cfa39115ae2f", "filename": "gcc/config/bfin/uclinux.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Fuclinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Fconfig%2Fbfin%2Fuclinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fuclinux.h?ref=9840d30abff62d41bda189f256b1ed3e41e6edc1", "patch": "@@ -36,3 +36,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n  --wrap=mmap --wrap=munmap --wrap=alloca\\\n  %{fmudflapth: --wrap=pthread_create\\\n }} %{fmudflap|fmudflapth: --wrap=main}\"\n+\n+#undef TARGET_SUPPORTS_SYNC_CALLS\n+#define TARGET_SUPPORTS_SYNC_CALLS 1"}, {"sha": "1317b16d5e77e0be48f487b629ec632a696f7f9e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9840d30abff62d41bda189f256b1ed3e41e6edc1", "patch": "@@ -1,3 +1,8 @@\n+2009-09-03  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_sync_int_long):\n+\tSupported on Blackfin Linux targets.\n+\n 2009-09-02  David Daney  <ddaney@caviumnetworks.com>\n \n \t* gcc.c-torture/compile/builtin_unreachable-1.c: New testcase."}, {"sha": "918993830e8c5e924fa1f4a3bf13beb8168cfe86", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9840d30abff62d41bda189f256b1ed3e41e6edc1/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=9840d30abff62d41bda189f256b1ed3e41e6edc1", "patch": "@@ -2670,6 +2670,7 @@ proc check_effective_target_sync_int_long { } {\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*]\n \t     || [istarget alpha*-*-*] \n+\t     || [istarget bfin*-*linux*]\n \t     || [istarget s390*-*-*] \n \t     || [istarget powerpc*-*-*]\n \t     || [istarget sparc64-*-*]"}]}