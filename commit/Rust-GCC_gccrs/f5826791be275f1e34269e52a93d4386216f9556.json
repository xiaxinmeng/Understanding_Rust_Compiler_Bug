{"sha": "f5826791be275f1e34269e52a93d4386216f9556", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU4MjY3OTFiZTI3NWYxZTM0MjY5ZTUyYTkzZDQzODYyMTZmOTU1Ng==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-01-03T00:07:13Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-01-03T00:07:13Z"}, "message": "ScrollPane.java: Wrote.\n\n\t* java/awt/ScrollPane.java: Wrote.\n\t* java/awt/peer/ScrollPanePeer.java (setBlockIncrement): New\n\tmethod.\n\n\t* java/awt/Panel.java (Panel()): Fixed.\n\n\t* java/awt/Component.java (isShowing): Return false if no peer\n\texists, and true if component is visible and no parent exists.\n\t(getLocationOnScreen): Wrote.\n\t(getPreferredSize): Removed FIXME comment.\n\t(getMinimumSize): Likewise.\n\t(getAlignmentX, getAlignmentY): Wrote.\n\t(list): Wrote.\n\t(requestFocus): Wrote.\n\t(transferFocus): Wrote.\n\t(findNextFocusComponent): New method.\n\t(hasFocus()): Wrote.\n\t(checkImage): Wrote.\n\t(enableEvents): Call setEventMask on the peer.\n\n\t* java/awt/Container.java (list): Use super.list() to print self.\n\t(findNextFocusComponent): New method.\n\t(setLayout): Call invalidate.\n\t(findComponentAt): Wrote.\n\nFrom-SVN: r38639", "tree": {"sha": "c665509a1b1611aeb1f349ca2a85c0c68223e494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c665509a1b1611aeb1f349ca2a85c0c68223e494"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5826791be275f1e34269e52a93d4386216f9556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5826791be275f1e34269e52a93d4386216f9556", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5826791be275f1e34269e52a93d4386216f9556", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5826791be275f1e34269e52a93d4386216f9556/comments", "author": null, "committer": null, "parents": [{"sha": "4f78b9a896ea942d9241538d15532b8f1587f420", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f78b9a896ea942d9241538d15532b8f1587f420", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f78b9a896ea942d9241538d15532b8f1587f420"}], "stats": {"total": 645, "additions": 547, "deletions": 98}, "files": [{"sha": "e3247e38ed19b6bfa66bb704d0307b7ead44ebb9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5826791be275f1e34269e52a93d4386216f9556/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5826791be275f1e34269e52a93d4386216f9556/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f5826791be275f1e34269e52a93d4386216f9556", "patch": "@@ -1,3 +1,30 @@\n+2001-01-02  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/awt/ScrollPane.java: Wrote.\n+\t* java/awt/peer/ScrollPanePeer.java (setBlockIncrement): New\n+\tmethod.\n+\n+\t* java/awt/Panel.java (Panel()): Fixed.\n+\n+\t* java/awt/Component.java (isShowing): Return false if no peer\n+\texists, and true if component is visible and no parent exists.\n+\t(getLocationOnScreen): Wrote.\n+\t(getPreferredSize): Removed FIXME comment.\n+\t(getMinimumSize): Likewise.\n+\t(getAlignmentX, getAlignmentY): Wrote.\n+\t(list): Wrote.\n+\t(requestFocus): Wrote.\n+\t(transferFocus): Wrote.\n+\t(findNextFocusComponent): New method.\n+\t(hasFocus()): Wrote.\n+\t(checkImage): Wrote.\n+\t(enableEvents): Call setEventMask on the peer.\n+\n+\t* java/awt/Container.java (list): Use super.list() to print self.\n+\t(findNextFocusComponent): New method.\n+\t(setLayout): Call invalidate.\n+\t(findComponentAt): Wrote.\n+\n 2000-12-30  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* Makefile.am (libgcj_la_LIBADD): Add $(THREADLIBS). This ensures that"}, {"sha": "6bca20d4c32c3825f6f91abff4c4da4742b9b189", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 100, "deletions": 77, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=f5826791be275f1e34269e52a93d4386216f9556", "patch": "@@ -205,13 +205,10 @@ public boolean isVisible()\n   \n   public boolean isShowing()\n   {\n-    if (! visible)\n+    if (! visible || peer == null)\n       return false;\n \n-    if (parent != null)\n-      return (parent.isShowing());\n-\n-    return false;\n+    return parent == null ? true : parent.isShowing ();\n   }\n   \n   public boolean isEnabled()\n@@ -377,8 +374,11 @@ public Point getLocation()\n \n   public Point getLocationOnScreen()\n   {\n-    // FIXME\n-    return null;\n+    if (! isShowing ())\n+      throw new IllegalComponentStateException (\"component not showing\");\n+\n+    // We know peer != null here.\n+    return peer.getLocationOnScreen ();\n   }\n \n   /** @deprecated Use getLocation() instead. */\n@@ -560,7 +560,6 @@ public boolean isLightweight()\n   \n   public Dimension getPreferredSize()\n   {\n-    // FIXME?\n     if (peer == null)\n       return new Dimension(width, height);\n     else\n@@ -575,7 +574,6 @@ public Dimension preferredSize()\n   \n   public Dimension getMinimumSize()\n   {\n-    // FIXME?\n     if (peer == null)\n       return new Dimension(width, height);\n     else\n@@ -587,24 +585,22 @@ public Dimension minimumSize()\n   {\n     return getMinimumSize();\n   }\n-  \n+\n   public Dimension getMaximumSize()\n   {\n     return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);\n   }\n-  \n+\n   public float getAlignmentX()\n   {\n-    // FIXME\n-    return 0;\n+    return CENTER_ALIGNMENT;\n   }\n-  \n+\n   public float getAlignmentY()\n   {\n-    // FIXME\n-    return 0;\n+    return CENTER_ALIGNMENT;\n   }\n-  \n+\n   public void doLayout()\n   {\n     // nothing to do unless we're a container\n@@ -626,9 +622,9 @@ public void invalidate()\n     valid = false;\n \n     if ((parent != null) && parent.valid)\n-\tparent.invalidate ();\n+      parent.invalidate ();\n   }\n-  \n+\n   public Graphics getGraphics()\n   {\n     if (peer != null)\n@@ -713,40 +709,41 @@ public void repaint(long tm, int x, int y, int width, int height)\n     if (peer != null)\n       peer.repaint(tm, x, y, width, height);\n   }\n-  \n+\n   public void print(Graphics g)\n   {\n     paint(g);\n   }\n-  \n+\n   public void printAll(Graphics g)\n   {\n     paintAll(g);\n   }\n-  \n-  public boolean imageUpdate(Image img, int infoflags, int x, int y, int w, int h)\n+\n+  public boolean imageUpdate (Image img, int infoflags, int x, int y,\n+\t\t\t      int w, int h)\n   {\n     // FIXME\n     return false;\n   }\n-  \n+\n   public Image createImage(ImageProducer producer)\n   {\n     // FIXME\n     return null;\n   }\n-  \n+\n   public Image createImage(int width, int height)\n   {\n     return getGraphicsConfiguration().createCompatibleImage(width, height);\n   }\n-  \n+\n   public boolean prepareImage(Image image, ImageObserver observer)\n   {\n     // FIXME\n     return false;\n   }\n-  \n+\n   public boolean prepareImage(Image image, int width, int height, ImageObserver observer)\n   {\n     // FIXME\n@@ -758,53 +755,54 @@ public int checkImage(Image image, ImageObserver observer)\n     // FIXME\n     return 0;\n   }\n-  \n-  public int checkImage(Image image, int width, int height, ImageObserver observer)\n+\n+  public int checkImage (Image image, int width, int height, ImageObserver observer)\n   {\n-    // FIXME\n-    return 0; \n+    if (peer != null)\n+      return peer.checkImage (image, width, height, observer);\n+    return getToolkit ().checkImage (image, width, height, observer);\n   }\n-  \n-  public boolean contains(int x, int y)\n+\n+  public boolean contains (int x, int y)\n   {\n     return (x >= 0) && (y >= 0) && (x < width) && (y < height);\n   }\n-  \n+\n   /** @deprecated */\n   public boolean inside(int x, int y)\n   {\n     return contains(x,y);\n   }\n-  \n+\n   public boolean contains(Point p)\n   {\n     return contains(p.x, p.y);\n   }\n-  \n+\n   public Component getComponentAt(int x, int y)\n   {\n     if (contains(x,y))\n       return this;\n     return null;\n   }\n-  \n+\n   /** @deprecated */\n   public Component locate(int x, int y)\n   {\n     return getComponentAt(x, y);\n   }\n-  \n+\n   public Component getComponentAt(Point p)\n   {\n     return getComponentAt(p.x, p.y);\n   }\n-    \n+\n   /** @deprecated */\n   public void deliverEvent(Event e)\n   {\n     \n   }\n-  \n+\n   /** Forward AWT events to processEvent() if:\n     *     - Events have been enabled for this type of event via enableEvents(),\n     *   OR:\n@@ -826,7 +824,7 @@ public final void dispatchEvent(AWTEvent e)\n     if (peer != null)\n       peer.handleEvent(e);\n   }\n-  \n+\n   void dispatchEventImpl(AWTEvent e)\n   {\n     // Make use of event id's in order to avoid multiple instanceof tests.\n@@ -1019,7 +1017,7 @@ static EventListener[] getListenersImpl(Class listenerType, EventListener el)\n     v.copyInto(el_a);\n     return el_a;\n   }\n-  \n+\n   static void getListenerList(EventListener el, Vector v)\n   {\n     if (el instanceof AWTEventMulticaster)\n@@ -1040,7 +1038,7 @@ static void getListenerList(EventListener el, Vector v)\n   // /** @since 1.2 */\n   //\n   // public InputContext getInputContext()\n-  \n+\n   protected final void enableEvents(long eventsToEnable)\n   {\n     eventMask |= eventsToEnable;\n@@ -1054,14 +1052,16 @@ protected final void enableEvents(long eventsToEnable)\n \n     if (isLightweight() && (parent != null))\n       parent.enableEvents(eventsToEnable);\n+    else if (peer != null)\n+      peer.setEventMask (eventMask);\n   }\n-  \n+\n   protected final void disableEvents(long eventsToDisable)\n   {\n     eventMask &= ~eventsToDisable;\n     // forward new event mask to peer?\n   }\n-  \n+\n   /** coalesceEvents is called by the EventQueue if two events with the same \n     * event id are queued. Returns a new combined event, or null if no \n     * combining is done. \n@@ -1437,45 +1437,61 @@ public boolean lostFocus(Event evt, Object what)\n \n   public boolean isFocusTraversable()\n   {\n-    // FIXME\n-    return false;\n+    return enabled && visible && (peer == null || peer.isFocusTraversable ());\n   }\n-  \n+\n   public void requestFocus()\n   {\n-    // FIXME\n+    // If there's no peer then this component can't get the focus.  We\n+    // treat it as a silent rejection of the request.\n+    if (peer != null)\n+      peer.requestFocus ();\n   }\n-  \n+\n+  // This method is used to implement transferFocus().\n+  // CHILD is the child making the request.\n+  // This is overridden by Container; when called for an ordinary\n+  // component there is no child and so we always return null.\n+  Component findNextFocusComponent (Component child)\n+  {\n+    return null;\n+  }\n+\n   public void transferFocus()\n   {\n-    // FIXME\n+    Component next;\n+    if (parent == null)\n+      next = findNextFocusComponent (null);\n+    else\n+      next = parent.findNextFocusComponent (this);\n+    if (next != null && next != this)\n+      next.requestFocus ();\n   }\n-  \n+\n   /** @deprecated */\n   public void nextFocus()\n   {\n     transferFocus();\n   }\n-  \n+\n   /** @since 1.2 */\n   public boolean hasFocus()\n   {\n-    // FIXME\n-    return false;\n+    return hasFocus;\n   }\n-  \n+\n   public synchronized void add(PopupMenu popup)\n   {\n     if (popups == null)\n       popups = new Vector();\n     popups.addElement(popup);    \n   }\n-  \n+\n   public synchronized void remove(MenuComponent popup)\n   {\n     popups.removeElement(popup);\n   }\n-  \n+\n   protected String paramString()\n   {\n     StringBuffer param = new StringBuffer();\n@@ -1506,69 +1522,76 @@ protected String paramString()\n     \n     return param.toString();\n   }\n-  \n+\n   public String toString()\n   {\n     return this.getClass().getName() + \"[\" + paramString() + \"]\";\n   }\n-  \n-  public void list()\n+\n+  public void list ()\n   {\n-    list(System.out);\n+    list (System.out, 0);\n   }\n-  \n-  public void list(PrintStream out)\n+\n+  public void list (PrintStream out)\n   {\n-    list(out, 0);\n+    list (out, 0);\n   }\n-  \n-  public void list(PrintStream out, int indent)\n+\n+  public void list (PrintStream out, int indent)\n   {\n+    for (int i = 0; i < indent; ++i)\n+      out.print (' ');\n+    out.println (toString ());\n   }\n-  \n-  public void list(PrintWriter out)\n+\n+  public void list (PrintWriter out)\n   {\n+    list (out, 0);\n   }\n-  \n-  public void list(PrintWriter out, int indent)\n+\n+  public void list (PrintWriter out, int indent)\n   {\n+    for (int i = 0; i < indent; ++i)\n+      out.print (' ');\n+    out.println (toString ());\n   }\n-  \n+\n   public void addPropertyChangeListener(PropertyChangeListener listener)\n   {\n     if (changeSupport == null)\n       changeSupport = new PropertyChangeSupport(this);\n     changeSupport.addPropertyChangeListener(listener);\n   }\n-  \n+\n   public void removePropertyChangeListener(PropertyChangeListener listener)\n   {\n     if (changeSupport != null)\n       changeSupport.removePropertyChangeListener(listener);         \n   }\n-  \n+\n   public void addPropertyChangeListener(String propertyName,\n                                 \tPropertyChangeListener listener)\n   {\n     if (changeSupport == null)\n       changeSupport = new PropertyChangeSupport(this);\n     changeSupport.addPropertyChangeListener(propertyName, listener);  \n   }\n-  \n+\n   public void removePropertyChangeListener(String propertyName,\n                                            PropertyChangeListener listener)\n   {\n     if (changeSupport != null)\n       changeSupport.removePropertyChangeListener(propertyName, listener);\n   }\n-  \n+\n   protected void firePropertyChange(String propertyName, Object oldValue, \n                                     Object newValue)\n   {\n     if (changeSupport != null)\n       changeSupport.firePropertyChange(propertyName, oldValue, newValue);    \n   }\n-  \n+\n   public void setComponentOrientation(ComponentOrientation o)\n   {\n     orientation = o;"}, {"sha": "595c6bfcf82b3e2ba1609b73198628905a389513", "filename": "libjava/java/awt/Container.java", "status": "modified", "additions": 82, "deletions": 15, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainer.java?ref=f5826791be275f1e34269e52a93d4386216f9556", "patch": "@@ -119,15 +119,15 @@ protected void addImpl (Component comp, Object constraints, int index)\n     if (peer != null)\n       {\n \tcomp.addNotify ();\n-    \n+\n \tif (comp.isLightweight())\n \t  enableEvents(comp.eventMask);\n       }\n \n     invalidate ();\n \n     if (component == null)\n-\tcomponent = new Component[4]; // FIXME, better initial size?\n+      component = new Component[4]; // FIXME, better initial size?\n \n     // This isn't the most efficient implementation.  We could do less\n     // copying when growing the array.  It probably doesn't matter.\n@@ -209,13 +209,13 @@ public LayoutManager getLayout()\n   {\n     return layoutMgr;\n   }\n-  \n+\n   public void setLayout(LayoutManager mgr)\n   {\n     layoutMgr = mgr;\n-    // FIXME\n+    invalidate ();\n   }\n-  \n+\n   public void doLayout()\n   {\n     if (layoutMgr != null)\n@@ -496,7 +496,7 @@ public Component getComponentAt (int x, int y)\n \t// Ignore invisible children...\n \tif (!component[i].isVisible())\n \t  continue;\n-\t\n+\n \tint x2 = x - component[i].x;\n \tint y2 = y - component[i].y;\n \tif (component[i].contains (x2, y2))\n@@ -516,10 +516,33 @@ public Component getComponentAt(Point p)\n     return getComponentAt(p.x, p.y);\n   }\n \n-  public Component findComponentAt(int x, int y)\n+  public Component findComponentAt (int x, int y)\n   {\n-    // FIXME\n-    return null;\n+    if (! contains (x, y))\n+      return null;\n+\n+    for (int i = 0; i < ncomponents; ++i)\n+      {\n+\t// Ignore invisible children...\n+\tif (!component[i].isVisible())\n+\t  continue;\n+\n+\tint x2 = x - component[i].x;\n+\tint y2 = y - component[i].y;\n+\t// We don't do the contains() check right away because\n+\t// findComponentAt would redundantly do it first thing.\n+\tif (component[i] instanceof Container)\n+\t  {\n+\t    Container k = (Container) component[i];\n+\t    Component r = k.findComponentAt (x2, y2);\n+\t    if (r != null)\n+\t      return r;\n+\t  }\n+\telse if (component[i].contains (x2, y2))\n+\t  return component[i];\n+      }\n+\n+    return this;\n   }\n \n   public Component findComponentAt(Point p)\n@@ -572,18 +595,14 @@ protected String paramString()\n   \n   public void list (PrintStream out, int indent)\n   {\n-    for (int i = 0; i < indent; ++i)\n-      out.print (' ');\n-    out.println (toString ());\n+    super.list (out, indent);\n     for (int i = 0; i < ncomponents; ++i)\n       component[i].list (out, indent + 2);\n   }\n \n   public void list(PrintWriter out, int indent)\n   {\n-    for (int i = 0; i < indent; ++i)\n-      out.print (' ');\n-    out.println (toString ());\n+    super.list (out, indent);\n     for (int i = 0; i < ncomponents; ++i)\n       component[i].list (out, indent + 2);\n   }\n@@ -622,4 +641,52 @@ static class GfxPrintAllVisitor extends GfxVisitor\n     public static final GfxVisitor INSTANCE = new GfxPrintAllVisitor();\n   }\n \n+  // This is used to implement Component.transferFocus.\n+  Component findNextFocusComponent (Component child)\n+  {\n+    int start, end;\n+    if (child != null)\n+      {\n+\tfor (start = 0; start < ncomponents; ++start)\n+\t  {\n+\t    if (component[start] == child)\n+\t      break;\n+\t  }\n+\tend = start;\n+\t// This special case lets us be sure to terminate.\n+\tif (end == 0)\n+\t  end = ncomponents;\n+\t++start;\n+      }\n+    else\n+      {\n+\tstart = 0;\n+\tend = ncomponents;\n+      }\n+\n+    for (int j = start; j != end; ++j)\n+      {\n+\tif (j >= ncomponents)\n+\t  {\n+\t    // The JCL says that we should wrap here.  However, that\n+\t    // seems wrong.  To me it seems that focus order should be\n+\t    // global within in given window.  So instead if we reach\n+\t    // the end we try to look in our parent, if we have one.\n+\t    if (parent != null)\n+\t      return parent.findNextFocusComponent (this);\n+\t    j -= ncomponents;\n+\t  }\n+\tif (component[j] instanceof Container)\n+\t  {\n+\t    Component c = component[j];\n+\t    c = c.findNextFocusComponent (null);\n+\t    if (c != null)\n+\t      return c;\n+\t  }\n+\telse if (component[j].isFocusTraversable ())\n+\t  return component[j];\n+      }\n+\n+    return null;\n+  }\n }"}, {"sha": "672caf95296ec0bf8b0c02f41934727c6c2e6dd1", "filename": "libjava/java/awt/Panel.java", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2FPanel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2FPanel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FPanel.java?ref=f5826791be275f1e34269e52a93d4386216f9556", "patch": "@@ -10,16 +10,13 @@\n \n import java.awt.peer.ComponentPeer;\n \n-/* An incomplete placeholder. */\n+/* This class is complete to 1.2.  */\n \n public class Panel extends Container\n {\n   public Panel()\n   { \n-    this(\n-\t // should be: new FlowLayout()\n-\t null // FIXME\n-\t );\n+    this (new FlowLayout ());\n   }\n \n   public Panel(LayoutManager layout)"}, {"sha": "69edf81101658eec064374b09c628df690731e6d", "filename": "libjava/java/awt/ScrollPane.java", "status": "modified", "additions": 333, "deletions": 1, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2FScrollPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2FScrollPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FScrollPane.java?ref=f5826791be275f1e34269e52a93d4386216f9556", "patch": "@@ -8,8 +8,340 @@\n \n package java.awt;\n \n-/* A very incomplete placeholder. */\n+import java.awt.event.AdjustmentListener;\n+import java.awt.peer.ScrollPanePeer;\n \n+/** A ScrollPane is a component that has vertical and horizontal\n+ * scrollbars as well as a single child which is scrolled by them.\n+ * @author Tom Tromey <tromey@redhat.com>\n+ * @date December 31, 2000\n+ * Status: Unfinished.  The Adjustables are probably wrong (there\n+ * isn't a mechanism for scrollbar events to affect them), and also\n+ * doLayout() is not finished.\n+ */\n public class ScrollPane extends Container\n {\n+  /** This indicates that scrollbars should only be displayed when\n+   * needed.  */\n+  public static final int SCROLLBARS_AS_NEEDED = 0;\n+  /** This indicates that scrollbars should always be displayed.  */\n+  public static final int SCROLLBARS_ALWAYS = 1;\n+  /** This indicates that scrollbars should never be displayed.  */\n+  public static final int SCROLLBARS_NEVER = 2;\n+\n+  /** Create a new ScrollPane object using the indicated scrollbar\n+   * display policy.  If the policy is not specified it defaults to\n+   * SCROLLBARS_AS_NEEDED.  The default size of this component is\n+   * 100x100.\n+   * @param policy The scrollbar display policy\n+   */\n+  public ScrollPane ()\n+  {\n+    this (SCROLLBARS_AS_NEEDED);\n+  }\n+\n+  public ScrollPane (int policy)\n+  {\n+    if (policy != SCROLLBARS_AS_NEEDED\n+\t&& policy != SCROLLBARS_ALWAYS\n+\t&& policy != SCROLLBARS_NEVER)\n+      throw new IllegalArgumentException (\"invalid value for policy\");\n+\n+    this.policy = policy;\n+    setSize (100, 100);\n+  }\n+\n+  /** Add a component to this ScrollPane.\n+   * @param comp The component to add\n+   * @param constraints Constraints.  This is ignored.\n+   * @param pos Position.  This must be <= 0, but is otherwise ignored.\n+   */\n+  protected final void addImpl (Component comp, Object constraints,\n+\t\t\t\tint pos)\n+  {\n+    if (pos > 0)\n+      throw new IllegalArgumentException (\"pos must be <= 0\");\n+\n+    if (ncomponents > 0)\n+      remove (component[0]);\n+\n+    if (comp.isLightweight ())\n+      {\n+\tPanel p = new Panel ();\n+\tp.add (comp);\n+\tcomp = p;\n+      }\n+\n+    super.addImpl (comp, constraints, pos);\n+  }\n+\n+  /** This creates the component's peer.  */\n+  public void addNotify ()\n+  {\n+    if (peer == null)\n+      peer = getToolkit ().createScrollPane (this);\n+    super.addNotify ();\n+  }\n+\n+  /** Lays out the components in this container.  */\n+  public void doLayout ()\n+  {\n+    ScrollPanePeer spp = (ScrollPanePeer) peer;\n+    Dimension c = component[0].getPreferredSize ();\n+    component[0].setSize (c.width, c.height);\n+    spp.childResized (c.width, c.height);\n+    // FIXME\n+  }\n+\n+  /** Returns an Adjustable representing the horizontal scrollbar.\n+   * The methods setMaximum, setMinimum, and setVisibleAmount should\n+   * not be called on this Adjustable.  They will throw AWTError if\n+   * called.\n+   */\n+  public Adjustable getHAdjustable ()\n+  {\n+    return hscroll;\n+  }\n+\n+  /** Returns the height of the horizontal scrollbar.  */\n+  public int getHScrollbarHeight ()\n+  {\n+    if (peer == null)\n+      return 0;\n+    ScrollPanePeer spp = (ScrollPanePeer) peer;\n+    return spp.getHScrollbarHeight ();\n+  }\n+\n+  /** Returns the scrollbar display policy.  */\n+  public int getScrollbarDisplayPolicy ()\n+  {\n+    return policy;\n+  }\n+\n+  /** Returns the viewport's scroll position.  */\n+  public Point getScrollPosition ()\n+  {\n+    // FIXME\n+    return null;\n+  }\n+\n+  /** Returns an Adjustable representing the vertical scrollbar.\n+   * The methods setMaximum, setMinimum, and setVisibleAmount should\n+   * not be called on this Adjustable.  They will throw AWTError if\n+   * called.\n+   */\n+  public Adjustable getVAdjustable ()\n+  {\n+    return vscroll;\n+  }\n+\n+  /** Returns the size of the viewport.  */\n+  public Dimension getViewportSize ()\n+  {\n+    Insets ins = getInsets ();\n+    int myw = width - ins.left - ins.right;\n+    int myh = height - ins.top - ins.bottom;\n+\n+    Dimension cs;\n+    if (ncomponents > 0)\n+      cs = component[0].getPreferredSize ();\n+    else\n+      cs = new Dimension (myw, myh);\n+\n+    if (policy == SCROLLBARS_ALWAYS\n+\t|| (policy == SCROLLBARS_AS_NEEDED && myw < cs.width))\n+      myw -= getVScrollbarWidth ();\n+\n+    if (policy == SCROLLBARS_ALWAYS\n+\t|| (policy == SCROLLBARS_AS_NEEDED && myh < cs.height))\n+      myh -= getHScrollbarHeight ();\n+\n+    // A little optimization -- reuse the Dimension.\n+    cs.setSize (myw, myh);\n+    return cs;\n+  }\n+\n+  /** Returns the width of the vertical scrollbar.  */\n+  public int getVScrollbarWidth ()\n+  {\n+    if (peer == null)\n+      return 0;\n+    ScrollPanePeer spp = (ScrollPanePeer) peer;\n+    return spp.getVScrollbarWidth ();\n+  }\n+\n+  /** Generates a String representation of this ScrollPane's state.  */\n+  public String paramString ()\n+  {\n+    return (\"[\" + getClass ().getName ()\n+\t    + \": \" + ((ncomponents > 0) ? component[0].paramString () : \"\")\n+\t    + \"]\");\n+  }\n+\n+  /** Set the layout manager for this component.  ScrollPane has its\n+   * own layout manager and overrides this method so that the layout\n+   * manager cannot be changed.\n+   * @param m The new layout manager (ignored)\n+   */\n+  public final void setLayout (LayoutManager m)\n+  {\n+    // Nothing.\n+  }\n+\n+  /** Sets the scroll position for this ScrollPane.  If the point if\n+   * out of range it is silently moved within range.\n+   * @param x The x coordinate\n+   * @param y The y coordinate\n+   */\n+  public void setScrollPosition (int x, int y)\n+  {\n+    // According to the JCL we throw a NullPointerException if there\n+    // is no child.\n+    if (ncomponents == 0)\n+      throw new NullPointerException (\"no child in ScrollPane\");\n+\n+    Dimension child_d = component[0].getPreferredSize ();\n+    Dimension our_d = getViewportSize ();\n+\n+    int xmax = Math.max (0, child_d.width - our_d.width);\n+    int ymax = Math.max (0, child_d.height - our_d.height);\n+\n+    if (x < 0)\n+      x = 0;\n+    else if (x > xmax)\n+      x = xmax;\n+    if (y < 0)\n+      y = 0;\n+    else if (y > ymax)\n+      y = ymax;\n+\n+    ScrollPanePeer spp = (ScrollPanePeer) peer;\n+    spp.setScrollPosition (x, y);\n+  }\n+\n+  /** Sets the scroll position for this ScrollPane.  If the point if\n+   * out of range it is silently moved within range.\n+   * @param p The new point\n+   */\n+  public void setScrollPosition (Point p)\n+  {\n+    setScrollPosition (p.x, p.y);\n+  }\n+\n+  class ScrollPaneAdjustable implements Adjustable\n+  {\n+    AdjustmentListener listeners;\n+    int orient;\n+    int unit;\n+    int block;\n+    int value;\n+\n+    public ScrollPaneAdjustable (int orient)\n+    {\n+      this.orient = orient;\n+    }\n+\n+    public void addAdjustmentListener (AdjustmentListener l)\n+    {\n+      listeners = AWTEventMulticaster.add (listeners, l);\n+    }\n+\n+    public int getBlockIncrement ()\n+    {\n+      return block;\n+    }\n+\n+    public int getMaximum ()\n+    {\n+      Dimension child_d = component[0].getPreferredSize ();\n+      Dimension our_d = getViewportSize ();\n+\n+      int xmax = Math.max (0, child_d.width - our_d.width);\n+      int ymax = Math.max (0, child_d.height - our_d.height);\n+\n+      return (orient == Adjustable.HORIZONTAL) ? xmax : ymax;\n+    }\n+\n+    public int getMinimum ()\n+    {\n+      return 0;\n+    }\n+\n+    public int getOrientation ()\n+    {\n+      return orient;\n+    }\n+\n+    public int getUnitIncrement ()\n+    {\n+      return unit;\n+    }\n+\n+    public int getValue ()\n+    {\n+      return value;\n+    }\n+\n+    public int getVisibleAmount ()\n+    {\n+      Dimension d = getViewportSize ();\n+      return (orient == Adjustable.HORIZONTAL) ? d.width : d.height;\n+    }\n+\n+    public void removeAdjustmentListener (AdjustmentListener l)\n+    {\n+      listeners = AWTEventMulticaster.remove (listeners, l);\n+    }\n+\n+    public void setBlockIncrement (int b)\n+    {\n+      block = b;\n+      if (peer != null)\n+\t{\n+\t  ScrollPanePeer spp = (ScrollPanePeer) peer;\n+\t  spp.setBlockIncrement (this, b);\n+\t}\n+    }\n+\n+    public void setMaximum (int max)\n+    {\n+      throw new AWTError (\"can't use setMaximum on this Adjustable\");\n+    }\n+\n+    public void setMinimum (int min)\n+    {\n+      throw new AWTError (\"can't use setMinimum on this Adjustable\");\n+    }\n+\n+    public void setUnitIncrement (int u)\n+    {\n+      unit = u;\n+      if (peer != null)\n+\t{\n+\t  ScrollPanePeer spp = (ScrollPanePeer) peer;\n+\t  spp.setUnitIncrement (this, u);\n+\t}\n+    }\n+\n+    public void setValue (int v)\n+    {\n+      value = v;\n+      if (peer != null)\n+\t{\n+\t  ScrollPanePeer spp = (ScrollPanePeer) peer;\n+\t  spp.setValue (this, v);\n+\t}\n+    }\n+\n+    public void setVisibleAmount (int v)\n+    {\n+      throw new AWTError (\"can't use setVisibleAmount on this Adjustable\");\n+    }\n+  }\n+\n+  ScrollPaneAdjustable hscroll\n+    = new ScrollPaneAdjustable (Adjustable.HORIZONTAL);\n+  ScrollPaneAdjustable vscroll\n+    = new ScrollPaneAdjustable (Adjustable.VERTICAL);\n+  int policy;\n }"}, {"sha": "6a587a23e1f0e58f684a5443c36ca4dbc0e996d1", "filename": "libjava/java/awt/peer/ComponentPeer.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2Fpeer%2FComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2Fpeer%2FComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fpeer%2FComponentPeer.java?ref=f5826791be275f1e34269e52a93d4386216f9556", "patch": "@@ -30,6 +30,8 @@\n   Dimension getMinimumSize();\n   Dimension getPreferredSize();\n   Toolkit getToolkit();\n+  // The JCL says that handleEvent returns boolean.  However, we've\n+  // experimentally determined that it in fact actually returns void.\n   void handleEvent(AWTEvent e);\n   boolean isFocusTraversable();\n   void paint(Graphics graphics);"}, {"sha": "0fcf44da1654826af3227151c5131d5fd136e5fb", "filename": "libjava/java/awt/peer/ScrollPanePeer.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2Fpeer%2FScrollPanePeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5826791be275f1e34269e52a93d4386216f9556/libjava%2Fjava%2Fawt%2Fpeer%2FScrollPanePeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fpeer%2FScrollPanePeer.java?ref=f5826791be275f1e34269e52a93d4386216f9556", "patch": "@@ -17,5 +17,6 @@ public interface ScrollPanePeer extends ContainerPeer\n   int getVScrollbarWidth();\n   void setScrollPosition(int x, int y);\n   void setUnitIncrement(Adjustable adj, int increment);\n+  void setBlockIncrement(Adjustable adj, int increment);\n   void setValue(Adjustable adj, int value);\n }"}]}