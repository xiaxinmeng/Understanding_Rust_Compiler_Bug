{"sha": "83f3bd62c9329ec4e3439ff4b0a3175863ba12df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNmM2JkNjJjOTMyOWVjNGUzNDM5ZmY0YjBhMzE3NTg2M2JhMTJkZg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-11-10T04:58:16Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-11-10T04:58:16Z"}, "message": "re PR fortran/46331 (Compilation time long with simple function in array constructor)\n\n2010-11-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\t    Mikael Morin   <mikael@gcc.gnu.org>\n\n\tPR fortran/46331\n\t* intrinsic.c: Correctly set the pure attributes for intrinsic\n\tfunctions.\n\t* expr.c (check_specification_function): Remove this function and move\n\tits code into gfc_is_constant_expr. (gfc_is_constant_expr): Change the\n\torder of checks by checking for non-constant arguments first.  Then,\n\tcheck for initialization functions, followed by intrinsics.\n\nCo-Authored-By: Mikael Morin <mikael@gcc.gnu.org>\n\nFrom-SVN: r166520", "tree": {"sha": "458b3e129494260814423b1b3a4a1eea07056ac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/458b3e129494260814423b1b3a4a1eea07056ac5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83f3bd62c9329ec4e3439ff4b0a3175863ba12df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f3bd62c9329ec4e3439ff4b0a3175863ba12df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83f3bd62c9329ec4e3439ff4b0a3175863ba12df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f3bd62c9329ec4e3439ff4b0a3175863ba12df/comments", "author": null, "committer": null, "parents": [{"sha": "e65f1db78c2bba088536e57bae37e18deb3ccfad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e65f1db78c2bba088536e57bae37e18deb3ccfad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e65f1db78c2bba088536e57bae37e18deb3ccfad"}], "stats": {"total": 88, "additions": 40, "deletions": 48}, "files": [{"sha": "e2af57fdb277bc1ff17fa022f91ddeae3b81f260", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f3bd62c9329ec4e3439ff4b0a3175863ba12df/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f3bd62c9329ec4e3439ff4b0a3175863ba12df/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=83f3bd62c9329ec4e3439ff4b0a3175863ba12df", "patch": "@@ -1,3 +1,14 @@\n+2010-11-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\t    Mikael Morin   <mikael@gcc.gnu.org>\n+\n+\tPR fortran/46331\n+\t* intrinsic.c: Correctly set the pure attributes for intrinsic\n+\tfunctions.\n+\t* expr.c (check_specification_function): Remove this function and move\n+\tits code into gfc_is_constant_expr. (gfc_is_constant_expr): Change the\n+\torder of checks by checking for non-constant arguments first.  Then,\n+\tcheck for initialization functions, followed by intrinsics.\n+\n 2010-11-09  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/46313"}, {"sha": "a22e6602a9a65eeeb8a4e4bd9f846123c2f7e356", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f3bd62c9329ec4e3439ff4b0a3175863ba12df/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f3bd62c9329ec4e3439ff4b0a3175863ba12df/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=83f3bd62c9329ec4e3439ff4b0a3175863ba12df", "patch": "@@ -868,31 +868,6 @@ gfc_type_convert_binary (gfc_expr *e, int wconversion)\n }\n \n \n-static match\n-check_specification_function (gfc_expr *e)\n-{\n-  gfc_symbol *sym;\n-\n-  if (!e->symtree)\n-    return MATCH_NO;\n-\n-  sym = e->symtree->n.sym;\n-\n-  /* F95, 7.1.6.2; F2003, 7.1.7  */\n-  if (sym\n-      && sym->attr.function\n-      && sym->attr.pure\n-      && !sym->attr.intrinsic\n-      && !sym->attr.recursive\n-      && sym->attr.proc != PROC_INTERNAL\n-      && sym->attr.proc != PROC_ST_FUNCTION\n-      && sym->attr.proc != PROC_UNKNOWN\n-      && sym->formal == NULL)\n-    return MATCH_YES;\n-\n-  return MATCH_NO;\n-}\n-\n /* Function to determine if an expression is constant or not.  This\n    function expects that the expression has already been simplified.  */\n \n@@ -901,6 +876,7 @@ gfc_is_constant_expr (gfc_expr *e)\n {\n   gfc_constructor *c;\n   gfc_actual_arglist *arg;\n+  gfc_symbol *sym;\n \n   if (e == NULL)\n     return 1;\n@@ -918,21 +894,40 @@ gfc_is_constant_expr (gfc_expr *e)\n     case EXPR_FUNCTION:\n     case EXPR_PPC:\n     case EXPR_COMPCALL:\n-      /* Specification functions are constant.  */\n-      if (check_specification_function (e) == MATCH_YES)\n-\treturn 1;\n-\n       /* Call to intrinsic with at least one argument.  */\n       if (e->value.function.isym && e->value.function.actual)\n \t{\n \t  for (arg = e->value.function.actual; arg; arg = arg->next)\n \t    if (!gfc_is_constant_expr (arg->expr))\n \t      return 0;\n-\n-\t  return 1;\n \t}\n-      else\n-\treturn 0;\n+\n+      /* Make sure we have a symbol.  */\n+      gcc_assert (e->symtree);\n+\n+      sym = e->symtree->n.sym;\n+    \n+      /* Specification functions are constant.  */\n+      /* F95, 7.1.6.2; F2003, 7.1.7  */\n+      if (sym\n+\t  && sym->attr.function\n+\t  && sym->attr.pure\n+\t  && !sym->attr.intrinsic\n+\t  && !sym->attr.recursive\n+\t  && sym->attr.proc != PROC_INTERNAL\n+\t  && sym->attr.proc != PROC_ST_FUNCTION\n+\t  && sym->attr.proc != PROC_UNKNOWN\n+\t  && sym->formal == NULL)\n+\treturn 1;\n+\n+      if (e->value.function.isym\n+\t  && (e->value.function.isym->elemental\n+\t      || e->value.function.isym->pure\n+\t      || e->value.function.isym->inquiry\n+\t      || e->value.function.isym->transformational))\n+\treturn 1;\n+\n+      return 0;\n \n     case EXPR_CONSTANT:\n     case EXPR_NULL:"}, {"sha": "f7f0e0506ae50980f48b06b44a07530169bb1c0b", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f3bd62c9329ec4e3439ff4b0a3175863ba12df/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f3bd62c9329ec4e3439ff4b0a3175863ba12df/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=83f3bd62c9329ec4e3439ff4b0a3175863ba12df", "patch": "@@ -274,10 +274,7 @@ add_sym (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type\n       strcat (buf, name);\n       next_sym->lib_name = gfc_get_string (buf);\n \n-      /* There are no IMPURE ELEMENTAL intrinsics, thus the ELEMENTAL class\n-\t also implies PURE.  Additionally, there's the PURE class itself.  */\n-      next_sym->pure = (cl == CLASS_ELEMENTAL || cl == CLASS_PURE);\n-\n+      next_sym->pure = (cl != CLASS_IMPURE);\n       next_sym->elemental = (cl == CLASS_ELEMENTAL);\n       next_sym->inquiry = (cl == CLASS_INQUIRY);\n       next_sym->transformational = (cl == CLASS_TRANSFORMATIONAL);\n@@ -3370,8 +3367,6 @@ add_char_conversions (void)\n void\n gfc_intrinsic_init_1 (void)\n {\n-  int i;\n-\n   nargs = nfunc = nsub = nconv = 0;\n \n   /* Create a namespace to hold the resolved intrinsic symbols.  */\n@@ -3404,15 +3399,6 @@ gfc_intrinsic_init_1 (void)\n \n   /* Character conversion intrinsics need to be treated separately.  */\n   add_char_conversions ();\n-\n-  /* Set the pure flag.  All intrinsic functions are pure, and\n-     intrinsic subroutines are pure if they are elemental.  */\n-\n-  for (i = 0; i < nfunc; i++)\n-    functions[i].pure = 1;\n-\n-  for (i = 0; i < nsub; i++)\n-    subroutines[i].pure = subroutines[i].elemental;\n }\n \n "}]}