{"sha": "473fe49b1e051c57b64fdaf1ed2601bc2165d703", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDczZmU0OWIxZTA1MWM1N2I2NGZkYWYxZWQyNjAxYmMyMTY1ZDcwMw==", "commit": {"author": {"name": "Ken Raeburn", "email": "raeburn@cygnus.com", "date": "1998-04-07T13:24:41Z"}, "committer": {"name": "Ken Raeburn", "email": "raeburn@gcc.gnu.org", "date": "1998-04-07T13:24:41Z"}, "message": "Sync up MEMORY_MOVE_COST changes with FSF.\n\nFrom-SVN: r19032", "tree": {"sha": "bf79d75abdc3cd25b8178e72cb02346c7d041e99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf79d75abdc3cd25b8178e72cb02346c7d041e99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/473fe49b1e051c57b64fdaf1ed2601bc2165d703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473fe49b1e051c57b64fdaf1ed2601bc2165d703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473fe49b1e051c57b64fdaf1ed2601bc2165d703", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473fe49b1e051c57b64fdaf1ed2601bc2165d703/comments", "author": null, "committer": null, "parents": [{"sha": "d6a007a2abf05e516b634574ea2c00a5e44f22d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6a007a2abf05e516b634574ea2c00a5e44f22d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6a007a2abf05e516b634574ea2c00a5e44f22d2"}], "stats": {"total": 115, "additions": 68, "deletions": 47}, "files": [{"sha": "9d70161c3a6bd20bbc5878ebbafc3191e0f70abe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473fe49b1e051c57b64fdaf1ed2601bc2165d703/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473fe49b1e051c57b64fdaf1ed2601bc2165d703/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=473fe49b1e051c57b64fdaf1ed2601bc2165d703", "patch": "@@ -940,25 +940,6 @@ Mon Mar 16 15:50:20 EST 1998 Andrew MacLeod <amacleod@cygnus.com>\n \t* config/sparc/sparc.md: Add calls to 'in_same_eh_region' in 4 \n \tpeepholes involving calls and unconditional branches. \n \n-Mon Mar 16 12:12:36 1998  Ken Raeburn  <raeburn@cygnus.com>\n-\n-\t* reload.h (MEMORY_MOVE_COST): Define here if not already defined;\n-\tif HAVE_SECONDARY_RELOADS, factor in copying cost.\n-\t(memory_move_secondary_cost): Declare.\n-\t* regclass.c (MEMORY_MOVE_COST): Don't define default here.\n-\t(memory_move_secondary_cost) [HAVE_SECONDARY_RELOADS]: New\n-\tfunction.\n-\t(regclass, record_reg_classes, copy_cost, record_address_regs):\n-\tPass register class and direction of move to MEMORY_MOVE_COST.\n-\t* reload1.c (MEMORY_MOVE_COST): Don't define default here.\n-\t(emit_reload_insns, reload_cse_simplify_set): Pass register class\n-\tand direction of move to MEMORY_MOVE_COST.\n-\t* 1750a.c, a29k.h, alpha.h, arc.h, arm.h, dsp16xx.h, i386.h,\n-\tm32r.h, m88k.h, rs6000.h (MEMORY_MOVE_COST): Add extra ignored\n-\targuments to definition, even in comments.\n-\t* mips.h (MEMORY_MOVE_COST): Add extra arguments; add\n-\tmemory_move_secondary_cost result to cpu-specific cost.\n-\n Mon Mar 16 11:16:50 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* README.gnat: New file.\n@@ -1652,11 +1633,6 @@ Fri Feb 27 11:02:47 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.\n \t* config/m68k/m68k.md (movsf+1): Optimize moving a CONST_DOUBLE\n \tzero.\n \n-1998-02-26  Ken Raeburn  <raeburn@cygnus.com>\n-\n-\t* regclass.c (init_reg_sets): Move init of move cost tables...\n-\t(init_reg_sets_1): ...to here.\n-\n Thu Feb 26 00:13:21 1998  Ian Lance Taylor  <ian@cygnus.com>\n \n \t* choose-temp.c: Fix handling of sys/file.h to work in libiberty."}, {"sha": "a87955ef19a61dd9a0b9a35f88ca3cbb9d3af612", "filename": "gcc/ChangeLog.12", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473fe49b1e051c57b64fdaf1ed2601bc2165d703/gcc%2FChangeLog.12", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473fe49b1e051c57b64fdaf1ed2601bc2165d703/gcc%2FChangeLog.12", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.12?ref=473fe49b1e051c57b64fdaf1ed2601bc2165d703", "patch": "@@ -1,3 +1,22 @@\n+Thu Apr  2 06:19:25 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* reload.h (MEMORY_MOVE_COST): Define here if not already defined.\n+\t(memory_move_secondary_cost): Declare.\n+\t* regclass.c (MEMORY_MOVE_COST): Don't define default here.\n+\t(memory_move_secondary_cost) [HAVE_SECONDARY_RELOADS]: New function.\n+\t(regclass, record_reg_classes, copy_cost, record_address_regs):\n+\tPass register class and direction of move to MEMORY_MOVE_COST.\n+\t(top_of_stack) [HAVE_SECONDARY_RELOADS]: New static array.\n+\t(init_regs) [HAVE_SECONDARY_RELOADS]: Initialize it.\n+\t* reload1.c (MEMORY_MOVE_COST): Don't define default here.\n+\t(emit_reload_insns, reload_cse_simplify_set): Pass register class\n+\tand direction of move to MEMORY_MOVE_COST.\n+\t* 1750a.h (MEMORY_MOVE_COST): Add extra ignored arguments.\n+\t* a29k.h, alpha.h, arc.h, arm.h, dsp16xx.h, i386.h, m32r.h: Likewise.\n+\t* m88k.h, rs6000.h: Likewise.\n+\t* mips.h (MEMORY_MOVE_COST): Likewise.\n+\tAdd memory_move_secondary_cost result to cpu-specific cost.\n+\n Mon Mar 30 13:56:30 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* mips/ultrix.h (SUBTARGET_CPP_SPEC): Define."}, {"sha": "e4dff7921c8215861e59c8cc1ef01750e1730968", "filename": "gcc/regclass.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473fe49b1e051c57b64fdaf1ed2601bc2165d703/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473fe49b1e051c57b64fdaf1ed2601bc2165d703/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=473fe49b1e051c57b64fdaf1ed2601bc2165d703", "patch": "@@ -183,6 +183,14 @@ static char *in_inc_dec;\n \n #endif /* FORBIDDEN_INC_DEC_CLASSES */\n \n+#ifdef HAVE_SECONDARY_RELOADS\n+\n+/* Sample MEM values for use by memory_move_secondary_cost.  */\n+\n+static rtx top_of_stack[MAX_MACHINE_MODE];\n+\n+#endif /* HAVE_SECONDARY_RELOADS */\n+\n /* Function called only once to initialize the above data on reg usage.\n    Once this is done, various switches may override.  */\n \n@@ -422,11 +430,23 @@ init_regs ()\n   init_reg_sets_1 ();\n \n   init_reg_modes ();\n+\n+#ifdef HAVE_SECONDARY_RELOADS\n+  {\n+    /* Make some fake stack-frame MEM references for use in\n+       memory_move_secondary_cost.  */\n+    int i;\n+    for (i = 0; i < MAX_MACHINE_MODE; i++)\n+      top_of_stack[i] = gen_rtx (MEM, i, stack_pointer_rtx);\n+  }\n+#endif\n }\n \n #ifdef HAVE_SECONDARY_RELOADS\n+\n /* Compute extra cost of moving registers to/from memory due to reloads.\n    Only needed if secondary reloads are required for memory moves.  */\n+\n int\n memory_move_secondary_cost (mode, class, in)\n      enum machine_mode mode;\n@@ -435,23 +455,26 @@ memory_move_secondary_cost (mode, class, in)\n {\n   enum reg_class altclass;\n   int partial_cost = 0;\n-  rtx mem;\n-\n   /* We need a memory reference to feed to SECONDARY... macros.  */\n-  mem = gen_rtx (MEM, mode, stack_pointer_rtx);\n+  rtx mem = top_of_stack[(int) mode];\n \n   if (in)\n+    {\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n-    altclass = SECONDARY_INPUT_RELOAD_CLASS (class, mode, mem);\n+      altclass = SECONDARY_INPUT_RELOAD_CLASS (class, mode, mem);\n #else\n-    altclass = NO_REGS;\n+      altclass = NO_REGS;\n #endif\n+    }\n   else\n+    {\n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-    altclass = SECONDARY_OUTPUT_RELOAD_CLASS (class, mode, mem);\n+      altclass = SECONDARY_OUTPUT_RELOAD_CLASS (class, mode, mem);\n #else\n-    altclass = NO_REGS;\n+      altclass = NO_REGS;\n #endif\n+    }\n+\n   if (altclass == NO_REGS)\n     return 0;\n "}, {"sha": "9b447126f81d58db929b7da3109b4a32feb2e40b", "filename": "gcc/tm.texi", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473fe49b1e051c57b64fdaf1ed2601bc2165d703/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473fe49b1e051c57b64fdaf1ed2601bc2165d703/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=473fe49b1e051c57b64fdaf1ed2601bc2165d703", "patch": "@@ -4574,22 +4574,25 @@ if the @samp{mov@var{m}} pattern's constraints do not allow such copying.\n @item MEMORY_MOVE_COST (@var{mode}, @var{class}, @var{in})\n A C expression for the cost of moving data of mode @var{mode} between a\n register of class @var{class} and memory; @var{in} is zero if the value\n-is to be written to memory, non-zero if it is to be read in.  If this\n-macro is not defined, the default cost is assumed to be 4, plus any costs\n-that would be incurred copying via a secondary reload register, if\n-needed.  This cost is relative to those in @code{REGISTER_MOVE_COST}.\n-\n-If moving between registers and memory is more expensive than between\n-two registers, you should define this macro to express the relative cost.\n-\n-If a secondary reload register would be required for @var{class}, but the\n-reload mechanism is more complex than copying via an intermediate, this\n-macro should be defined to reflect the actual cost of the move.\n-\n-The function @code{memory_move_secondary_cost}, which is defined if\n-secondary reloads are needed, will compute the costs due to copying; you\n-can use this function if you need to take other factors into account as\n-well, or if the default base value of 4 is not correct for your machine.\n+is to be written to memory, non-zero if it is to be read in.  This cost\n+is relative to those in @code{REGISTER_MOVE_COST}.  If moving between\n+registers and memory is more expensive than between two registers, you\n+should define this macro to express the relative cost.\n+\n+If you do not define this macro, GNU CC uses a default cost of 4 plus\n+the cost of copying copying via a secondary reload register, if one is\n+needed.  If your machine requires a secondary reload register to copy\n+between memory and a register of @var{class} but the reload mechanism is\n+more complex than copying via an intermediate, define this macro to\n+reflect the actual cost of the move.\n+\n+GNU CC defines the function @code{memory_move_secondary_cost} if\n+secondary reloads are needed.  It computes the costs due to copying via\n+a secondary register.  If your machine copies from memory using a\n+secondary register in the conventional way but the default base value of\n+4 is not correct for your machine, define this macro to add some other\n+value to the result of that function.  The arguments to that function\n+are the same as to this macro.\n \n @findex BRANCH_COST\n @item BRANCH_COST"}]}