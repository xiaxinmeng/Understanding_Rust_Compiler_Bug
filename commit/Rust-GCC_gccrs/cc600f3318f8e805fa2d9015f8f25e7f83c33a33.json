{"sha": "cc600f3318f8e805fa2d9015f8f25e7f83c33a33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M2MDBmMzMxOGY4ZTgwNWZhMmQ5MDE1ZjhmMjVlN2Y4M2MzM2EzMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-06-04T00:34:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-06-04T00:34:57Z"}, "message": "method.c (make_thunk): Use overload machinery to make name.\n\n\t* method.c (make_thunk): Use overload machinery to make name.\n\t* search.c (covariant_return_p): New fn.\n\t(get_matching_virtual): Use it.\n\t* init.c (build_new_1): Fix check for void.\n\nFrom-SVN: r20215", "tree": {"sha": "648ed2cc158463ce2d26af0b903bdc3b87f2baf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/648ed2cc158463ce2d26af0b903bdc3b87f2baf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc600f3318f8e805fa2d9015f8f25e7f83c33a33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc600f3318f8e805fa2d9015f8f25e7f83c33a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc600f3318f8e805fa2d9015f8f25e7f83c33a33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc600f3318f8e805fa2d9015f8f25e7f83c33a33/comments", "author": null, "committer": null, "parents": [{"sha": "ff439b5feee1968f82bd45ae2da87afee820ddf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff439b5feee1968f82bd45ae2da87afee820ddf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff439b5feee1968f82bd45ae2da87afee820ddf8"}], "stats": {"total": 120, "additions": 83, "deletions": 37}, "files": [{"sha": "6f115d65c1029962aa18b416a95235ebfe5cdd5f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc600f3318f8e805fa2d9015f8f25e7f83c33a33/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc600f3318f8e805fa2d9015f8f25e7f83c33a33/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cc600f3318f8e805fa2d9015f8f25e7f83c33a33", "patch": "@@ -1,3 +1,11 @@\n+1998-06-03  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (make_thunk): Use overload machinery to make name.\n+\t* search.c (covariant_return_p): New fn.\n+\t(get_matching_virtual): Use it.\n+\n+\t* init.c (build_new_1): Fix check for void.\n+\n 1998-06-01  Per Bothner  <bothner@cygnus.com>\n \n \t* cp-tree.h (TYPE_FOR_JAVA):  New macro."}, {"sha": "4eca6b630576e4d3dc1567929d57d8a1fd87d023", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc600f3318f8e805fa2d9015f8f25e7f83c33a33/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc600f3318f8e805fa2d9015f8f25e7f83c33a33/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cc600f3318f8e805fa2d9015f8f25e7f83c33a33", "patch": "@@ -2261,7 +2261,7 @@ build_new_1 (exp)\n   else\n     size = size_in_bytes (type);\n \n-  if (true_type == void_type_node)\n+  if (TREE_CODE (true_type) == VOID_TYPE)\n     {\n       error (\"invalid type `void' for new\");\n       return error_mark_node;"}, {"sha": "cc01371a5c67d4f1ef965dd6ced5ea420b2915b9", "filename": "gcc/cp/method.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc600f3318f8e805fa2d9015f8f25e7f83c33a33/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc600f3318f8e805fa2d9015f8f25e7f83c33a33/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=cc600f3318f8e805fa2d9015f8f25e7f83c33a33", "patch": "@@ -1917,23 +1917,30 @@ make_thunk (function, delta)\n      tree function;\n      int delta;\n {\n-  char *buffer;\n   tree thunk_id;\n   tree thunk;\n-  char *func_name;\n   tree func_decl;\n+\n   if (TREE_CODE (function) != ADDR_EXPR)\n     abort ();\n   func_decl = TREE_OPERAND (function, 0);\n   if (TREE_CODE (func_decl) != FUNCTION_DECL)\n     abort ();\n-  func_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (func_decl));\n-  buffer = (char *)alloca (strlen (func_name) + 32);\n-  if (delta<=0)\n-    sprintf (buffer, \"__thunk_%d_%s\", -delta, func_name);\n+\n+  OB_INIT ();\n+  OB_PUTS (\"__thunk_\");\n+  if (delta > 0)\n+    {\n+      OB_PUTC ('n');\n+      icat (delta);\n+    }\n   else\n-    sprintf (buffer, \"__thunk_n%d_%s\", delta, func_name);\n-  thunk_id = get_identifier (buffer);\n+    icat (-delta);\n+  OB_PUTC ('_');\n+  OB_PUTID (DECL_ASSEMBLER_NAME (func_decl));\n+  OB_FINISH ();\n+  thunk_id = get_identifier (obstack_base (&scratch_obstack));\n+\n   thunk = IDENTIFIER_GLOBAL_VALUE (thunk_id);\n   if (thunk && TREE_CODE (thunk) != THUNK_DECL)\n     {"}, {"sha": "d2ad247d38ae9452065f32350e9cec17a525b969", "filename": "gcc/cp/search.c", "status": "modified", "additions": 59, "deletions": 28, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc600f3318f8e805fa2d9015f8f25e7f83c33a33/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc600f3318f8e805fa2d9015f8f25e7f83c33a33/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=cc600f3318f8e805fa2d9015f8f25e7f83c33a33", "patch": "@@ -2133,6 +2133,57 @@ tree_has_any_destructor_p (binfo, i)\n   return TYPE_NEEDS_DESTRUCTOR (type);\n }\n \n+/* Returns > 0 if a function with type DRETTYPE overriding a function\n+   with type BRETTYPE is covariant, as defined in [class.virtual].\n+\n+   Returns 1 if trivial covariance, 2 if non-trivial (requiring runtime\n+   adjustment), or -1 if pedantically invalid covariance.  */\n+\n+int\n+covariant_return_p (brettype, drettype)\n+     tree brettype, drettype;\n+{\n+  tree binfo;\n+\n+  if (TREE_CODE (brettype) == FUNCTION_DECL\n+      || TREE_CODE (brettype) == THUNK_DECL)\n+    {\n+      brettype = TREE_TYPE (TREE_TYPE (brettype));\n+      drettype = TREE_TYPE (TREE_TYPE (drettype));\n+    }\n+  else if (TREE_CODE (brettype) == METHOD_TYPE)\n+    {\n+      brettype = TREE_TYPE (brettype);\n+      drettype = TREE_TYPE (drettype);\n+    }\n+\n+  if (comptypes (brettype, drettype, 1))\n+    return 0;\n+\n+  if (! (TREE_CODE (brettype) == TREE_CODE (drettype)\n+\t && (TREE_CODE (brettype) == POINTER_TYPE\n+\t     || TREE_CODE (brettype) == REFERENCE_TYPE)\n+\t && TYPE_READONLY (brettype) == TYPE_READONLY (drettype)\n+\t && TYPE_VOLATILE (brettype) == TYPE_VOLATILE (drettype)))\n+    return 0;\n+\n+  if (! can_convert (brettype, drettype))\n+    return 0;\n+\n+  brettype = TREE_TYPE (brettype);\n+  drettype = TREE_TYPE (drettype);\n+\n+  /* If not pedantic, allow any standard pointer conversion.  */\n+  if (! IS_AGGR_TYPE (drettype) || ! IS_AGGR_TYPE (brettype))\n+    return -1;\n+\n+  binfo = get_binfo (brettype, drettype, 0);\n+\n+  if (! BINFO_OFFSET_ZEROP (binfo) || TREE_VIA_VIRTUAL (binfo))\n+    return 2;\n+  return 1;\n+}\n+\n /* Given a class type TYPE, and a function decl FNDECL, look for a\n    virtual function in TYPE's hierarchy which FNDECL could match as a\n    virtual function.  It doesn't matter which one we find.\n@@ -2146,6 +2197,7 @@ get_matching_virtual (binfo, fndecl, dtorp)\n      int dtorp;\n {\n   tree tmp = NULL_TREE;\n+  int i;\n \n   /* Breadth first search routines start searching basetypes\n      of TYPE, so we must perform first ply of search here.  */\n@@ -2209,36 +2261,15 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t\t  tree brettype = TREE_TYPE (TREE_TYPE (tmp));\n \t\t  if (comptypes (brettype, drettype, 1))\n \t\t    /* OK */;\n-\t\t  else if\n-\t\t    (TREE_CODE (brettype) == TREE_CODE (drettype)\n-\t\t     && (TREE_CODE (brettype) == POINTER_TYPE\n-\t\t\t || TREE_CODE (brettype) == REFERENCE_TYPE)\n-\t\t     && comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (brettype)),\n-\t\t\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (drettype)),\n-\t\t\t\t   0))\n-\t\t      /* covariant return type */\n+\t\t  else if ((i = covariant_return_p (brettype, drettype)))\n \t\t    {\n-\t\t      tree b = TREE_TYPE (brettype), d = TREE_TYPE (drettype);\n-\t\t      if (TYPE_MAIN_VARIANT (b) != TYPE_MAIN_VARIANT (d))\n-\t\t\t{\n-\t\t\t  tree binfo = get_binfo (b, d, 1);\n-\t\t\t  if (binfo != error_mark_node\n-\t\t\t      && (! BINFO_OFFSET_ZEROP (binfo)\n-\t\t\t\t  || TREE_VIA_VIRTUAL (binfo)))\n-\t\t\t    sorry (\"adjusting pointers for covariant returns\");\n-\t\t\t}\n-\t\t      if (TYPE_READONLY (d) > TYPE_READONLY (b))\n-\t\t\t{\n-\t\t\t  cp_error_at (\"return type of `%#D' adds const\", fndecl);\n-\t\t\t  cp_error_at (\"  overriding definition as `%#D'\",\n-\t\t\t\t       tmp);\n-\t\t\t}\n-\t\t      else if (TYPE_VOLATILE (d) > TYPE_VOLATILE (b))\n+\t\t      if (i == 2)\n+\t\t\tsorry (\"adjusting pointers for covariant returns\");\n+\n+\t\t      if (pedantic && i == -1)\n \t\t\t{\n-\t\t\t  cp_error_at (\"return type of `%#D' adds volatile\",\n-\t\t\t\t    fndecl);\n-\t\t\t  cp_error_at (\"  overriding definition as `%#D'\",\n-\t\t\t\t       tmp);\n+\t\t\t  cp_pedwarn_at (\"invalid covariant return type for `%#D' (must be pointer or reference to class)\", fndecl);\n+\t\t\t  cp_pedwarn_at (\"  overriding `%#D'\", tmp);\n \t\t\t}\n \t\t    }\n \t\t  else if (IS_AGGR_TYPE_2 (brettype, drettype)"}]}