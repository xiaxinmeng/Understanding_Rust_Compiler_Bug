{"sha": "02a65aef508b862388be1589f104993e285f23ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJhNjVhZWY1MDhiODYyMzg4YmUxNTg5ZjEwNDk5M2UyODVmMjNhZQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@redhat.com", "date": "2001-01-21T09:19:15Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2001-01-21T09:19:15Z"}, "message": "expmed.c (synth_mult, [...]): Guard uses of shift_cost, shiftadd_cost and shiftsub_cost with bound checks.\n\n\t* expmed.c (synth_mult, expand_mult_highpart, expand_divmod): Guard\n\tuses of shift_cost, shiftadd_cost and shiftsub_cost with bound checks.\n\nFrom-SVN: r39165", "tree": {"sha": "87a386646ba60da8a7b6f7ba11441cfe3390b8f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87a386646ba60da8a7b6f7ba11441cfe3390b8f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02a65aef508b862388be1589f104993e285f23ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02a65aef508b862388be1589f104993e285f23ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02a65aef508b862388be1589f104993e285f23ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02a65aef508b862388be1589f104993e285f23ae/comments", "author": null, "committer": null, "parents": [{"sha": "625b1acd1030aa14687acd77616c38ef96d5414d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/625b1acd1030aa14687acd77616c38ef96d5414d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/625b1acd1030aa14687acd77616c38ef96d5414d"}], "stats": {"total": 96, "additions": 64, "deletions": 32}, "files": [{"sha": "9eac0b5f3a54845b5aca9b2ea4d21ac7ead41e75", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a65aef508b862388be1589f104993e285f23ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a65aef508b862388be1589f104993e285f23ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02a65aef508b862388be1589f104993e285f23ae", "patch": "@@ -1,3 +1,8 @@\n+Sun Jan 21 02:38:56 2001  J\"orn Rennecke <amylaar@redhat.com>\n+\n+\t* expmed.c (synth_mult, expand_mult_highpart, expand_divmod): Guard\n+\tuses of shift_cost, shiftadd_cost and shiftsub_cost with bound checks.\n+\n Sun Jan 21 09:44:17 2001  Denis Chertykov  <denisc@overta.ru>\n \n \t* config/avr/avr.c (ret_cond_branch): New argument (reverse) added."}, {"sha": "5a2e7f0131e9195bda56bf2137c3cccdebcc4156", "filename": "gcc/expmed.c", "status": "modified", "additions": 59, "deletions": 32, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a65aef508b862388be1589f104993e285f23ae/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a65aef508b862388be1589f104993e285f23ae/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=02a65aef508b862388be1589f104993e285f23ae", "patch": "@@ -2137,18 +2137,21 @@ synth_mult (alg_out, t, cost_limit)\n   if ((t & 1) == 0)\n     {\n       m = floor_log2 (t & -t);\t/* m = number of low zero bits */\n-      q = t >> m;\n-      cost = shift_cost[m];\n-      synth_mult (alg_in, q, cost_limit - cost);\n-\n-      cost += alg_in->cost;\n-      if (cost < cost_limit)\n+      if (m < BITS_PER_WORD)\n \t{\n-\t  struct algorithm *x;\n-\t  x = alg_in, alg_in = best_alg, best_alg = x;\n-\t  best_alg->log[best_alg->ops] = m;\n-\t  best_alg->op[best_alg->ops] = alg_shift;\n-\t  cost_limit = cost;\n+\t  q = t >> m;\n+\t  cost = shift_cost[m];\n+\t  synth_mult (alg_in, q, cost_limit - cost);\n+\n+\t  cost += alg_in->cost;\n+\t  if (cost < cost_limit)\n+\t    {\n+\t      struct algorithm *x;\n+\t      x = alg_in, alg_in = best_alg, best_alg = x;\n+\t      best_alg->log[best_alg->ops] = m;\n+\t      best_alg->op[best_alg->ops] = alg_shift;\n+\t      cost_limit = cost;\n+\t    }\n \t}\n     }\n \n@@ -2219,7 +2222,7 @@ synth_mult (alg_out, t, cost_limit)\n       unsigned HOST_WIDE_INT d;\n \n       d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;\n-      if (t % d == 0 && t > d)\n+      if (t % d == 0 && t > d && m < BITS_PER_WORD)\n \t{\n \t  cost = MIN (shiftadd_cost[m], add_cost + shift_cost[m]);\n \t  synth_mult (alg_in, t / d, cost_limit - cost);\n@@ -2238,7 +2241,7 @@ synth_mult (alg_out, t, cost_limit)\n \t}\n \n       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n-      if (t % d == 0 && t > d)\n+      if (t % d == 0 && t > d && m < BITS_PER_WORD)\n \t{\n \t  cost = MIN (shiftsub_cost[m], add_cost + shift_cost[m]);\n \t  synth_mult (alg_in, t / d, cost_limit - cost);\n@@ -2263,7 +2266,7 @@ synth_mult (alg_out, t, cost_limit)\n       q = t - 1;\n       q = q & -q;\n       m = exact_log2 (q);\n-      if (m >= 0)\n+      if (m >= 0 && m < BITS_PER_WORD)\n \t{\n \t  cost = shiftadd_cost[m];\n \t  synth_mult (alg_in, (t - 1) >> m, cost_limit - cost);\n@@ -2282,7 +2285,7 @@ synth_mult (alg_out, t, cost_limit)\n       q = t + 1;\n       q = q & -q;\n       m = exact_log2 (q);\n-      if (m >= 0)\n+      if (m >= 0 && m < BITS_PER_WORD)\n \t{\n \t  cost = shiftsub_cost[m];\n \t  synth_mult (alg_in, (t + 1) >> m, cost_limit - cost);\n@@ -2815,7 +2818,9 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n \n   /* Secondly, same as above, but use sign flavor opposite of unsignedp.\n      Need to adjust the result after the multiplication.  */\n-  if (mul_highpart_cost[(int) mode] + 2 * shift_cost[size-1] + 4 * add_cost < max_cost)\n+  if (size - 1 < BITS_PER_WORD\n+      && (mul_highpart_cost[(int) mode] + 2 * shift_cost[size-1] + 4 * add_cost\n+\t  < max_cost))\n     {\n       mul_highpart_optab = unsignedp ? smul_highpart_optab : umul_highpart_optab;\n       target = expand_binop (mode, mul_highpart_optab,\n@@ -2838,6 +2843,7 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n   /* Try widening the mode and perform a non-widening multiplication.  */\n   moptab = smul_optab;\n   if (smul_optab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n+      && size - 1 < BITS_PER_WORD\n       && mul_cost[(int) wider_mode] + shift_cost[size-1] < max_cost)\n     {\n       op1 = wide_op1;\n@@ -2847,6 +2853,7 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n   /* Try widening multiplication of opposite signedness, and adjust.  */\n   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n   if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n+      && size - 1 < BITS_PER_WORD\n       && (mul_widen_cost[(int) wider_mode]\n \t  + 2 * shift_cost[size-1] + 4 * add_cost < max_cost))\n     {\n@@ -3183,6 +3190,9 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t  {\n \t\t\t    rtx t1, t2, t3, t4;\n \n+\t\t\t    if (post_shift - 1 >= BITS_PER_WORD)\n+\t\t\t      goto fail1;\n+\n \t\t\t    extra_cost = (shift_cost[post_shift - 1]\n \t\t\t\t\t  + shift_cost[1] + 2 * add_cost);\n \t\t\t    t1 = expand_mult_highpart (compute_mode, op0, ml,\n@@ -3207,6 +3217,10 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t  {\n \t\t\t    rtx t1, t2;\n \n+\t\t\t    if (pre_shift >= BITS_PER_WORD\n+\t\t\t\t|| post_shift >= BITS_PER_WORD)\n+\t\t\t      goto fail1;\n+\n \t\t\t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t\t\t       build_int_2 (pre_shift, 0),\n \t\t\t\t\t       NULL_RTX, 1);\n@@ -3327,6 +3341,10 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t      {\n \t\t\trtx t1, t2, t3;\n \n+\t\t\tif (post_shift >= BITS_PER_WORD\n+\t\t\t    || size - 1 >= BITS_PER_WORD)\n+\t\t\t  goto fail1;\n+\n \t\t\textra_cost = (shift_cost[post_shift]\n \t\t\t\t      + shift_cost[size - 1] + add_cost);\n \t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n@@ -3353,6 +3371,10 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t      {\n \t\t\trtx t1, t2, t3, t4;\n \n+\t\t\tif (post_shift >= BITS_PER_WORD\n+\t\t\t    || size - 1 >= BITS_PER_WORD)\n+\t\t\t  goto fail1;\n+\n \t\t\tml |= (~(unsigned HOST_WIDE_INT) 0) << (size - 1);\n \t\t\textra_cost = (shift_cost[post_shift]\n \t\t\t\t      + shift_cost[size - 1] + 2 * add_cost);\n@@ -3436,23 +3458,28 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t    if (mh)\n \t\t      abort ();\n \n-\t\t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t       build_int_2 (size - 1, 0), NULL_RTX, 0);\n-\t\t    t2 = expand_binop (compute_mode, xor_optab, op0, t1,\n-\t\t\t\t       NULL_RTX, 0, OPTAB_WIDEN);\n-\t\t    extra_cost = (shift_cost[post_shift]\n-\t\t\t\t  + shift_cost[size - 1] + 2 * add_cost);\n-\t\t    t3 = expand_mult_highpart (compute_mode, t2, ml,\n-\t\t\t\t\t       NULL_RTX, 1,\n-\t\t\t\t\t       max_cost - extra_cost);\n-\t\t    if (t3 != 0)\n+\t\t    if (post_shift < BITS_PER_WORD\n+\t\t\t&& size - 1 < BITS_PER_WORD)\n \t\t      {\n-\t\t\tt4 = expand_shift (RSHIFT_EXPR, compute_mode, t3,\n-\t\t\t\t\t   build_int_2 (post_shift, 0),\n-\t\t\t\t\t   NULL_RTX, 1);\n-\t\t\tquotient = expand_binop (compute_mode, xor_optab,\n-\t\t\t\t\t\t t4, t1, tquotient, 0,\n-\t\t\t\t\t\t OPTAB_WIDEN);\n+\t\t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t\t\t   build_int_2 (size - 1, 0),\n+\t\t\t\t\t   NULL_RTX, 0);\n+\t\t\tt2 = expand_binop (compute_mode, xor_optab, op0, t1,\n+\t\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n+\t\t\textra_cost = (shift_cost[post_shift]\n+\t\t\t\t      + shift_cost[size - 1] + 2 * add_cost);\n+\t\t\tt3 = expand_mult_highpart (compute_mode, t2, ml,\n+\t\t\t\t\t\t   NULL_RTX, 1,\n+\t\t\t\t\t\t   max_cost - extra_cost);\n+\t\t\tif (t3 != 0)\n+\t\t\t  {\n+\t\t\t    t4 = expand_shift (RSHIFT_EXPR, compute_mode, t3,\n+\t\t\t\t\t       build_int_2 (post_shift, 0),\n+\t\t\t\t\t       NULL_RTX, 1);\n+\t\t\t    quotient = expand_binop (compute_mode, xor_optab,\n+\t\t\t\t\t\t     t4, t1, tquotient, 0,\n+\t\t\t\t\t\t     OPTAB_WIDEN);\n+\t\t\t  }\n \t\t      }\n \t\t  }\n \t      }"}]}