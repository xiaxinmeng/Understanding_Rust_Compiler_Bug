{"sha": "37a08a298f85099eda5290d250c95eaf707e6c6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdhMDhhMjk4Zjg1MDk5ZWRhNTI5MGQyNTBjOTVlYWY3MDdlNmM2Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-12-05T22:37:41Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-12-05T22:37:41Z"}, "message": "attribs.c (handle_no_check_memory_usage_atribute): Deleted.\n\n\t* attribs.c (handle_no_check_memory_usage_atribute): Deleted.\n\t(c_com): Delete its reference.\n\t* builtins.c: Delete memory checking code.\n\t* calls.c, expr.c, function.c, stmt.c: Likewise.\n\t* builtins.c (expand_builtin_arg_info): Remove reference to\n\tEXPAND_MEMORY_USE_* modifiers.\n\t* explow.c (expr_size): Likewise.\n\t* expr.c (expand_expr, expand_increment): Likewise.\n\t* expr.h (ARGS_SIZE_RTX): Likewise.\n\t* function.c (assign_parms, expand_pending_sizeso): Likewise.\n\t* c-decl.c (duplicate_decls): Don't handle DECL_NO_CHECK_MEMORY_USAGE.\n\t* expr.c (in_check_memory_usage): Delete.\n\t(get_push_address, get_memory_usage_from_modifier): Delete.\n\t(expand_assigment): Use EXPAND_WRITE on destination.\n\t(expand_expr): Delete ro_modifier.\n\t* expr.h (expand_modifier): Delete EXPAND_MEMORY_* entries and\n\tadd EXPAND_WRITE.\n\t(memory_use_mode): Delete.\n\t* flags.h (flag_check_memory_usage): Deleted.\n\t(flag_prefix_function_name): Likewise.\n\t* function.c (expand_function_start): Don't set\n\tcurrent_function_check_memory_usage.\n\t* function.h (check_memory_usage): Delete.\n\t* libfuncs.h, optabs.c: Delete chkr_* stuff.\n\t* stmt.c (expand_asm_opernd): Change EXPAND_MEMORY_USE_WO to\n\tEXPAND_WRITE.\n\t* toplev.c (flag_check_memory_usage): Deleted.\n\t(flag_prefix_function_name): Likewise.\n\t(f_options, process_options): Delete references to above.\n\t* tree.h (DECL_NO_CHECK_MEMORY_USAGE): Deleted.\n\t* varasm.c (CHKR_PREFIX): Deleted.\n\t(make_decl_rtl): Remove flag_prefix_function_name handling.\n\t(assemble_name): Likewise.\n\t* doc/extend.texi: Remove no_check_memory_usage attribute.\n\t* doc/invoke.texi: Remove -fcheck-memory-usage\n\tand -fprefix-function-name.\n\t* cp/decl.c (duplicate_decls): Don't copy DECL_NO_CHECK_MEMORY_USAGE.\n\nFrom-SVN: r47697", "tree": {"sha": "16fd35f587497e051ac05a7ae930fd07de7f29ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16fd35f587497e051ac05a7ae930fd07de7f29ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37a08a298f85099eda5290d250c95eaf707e6c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a08a298f85099eda5290d250c95eaf707e6c6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37a08a298f85099eda5290d250c95eaf707e6c6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a08a298f85099eda5290d250c95eaf707e6c6f/comments", "author": null, "committer": null, "parents": [{"sha": "0228de0c4f91cb2cc0381f2f2c403caab6e7d82e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0228de0c4f91cb2cc0381f2f2c403caab6e7d82e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0228de0c4f91cb2cc0381f2f2c403caab6e7d82e"}], "stats": {"total": 858, "additions": 124, "deletions": 734}, "files": [{"sha": "b7c7f3c6e9f24a5c44f6aa84074d648aa596490e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -1,3 +1,42 @@\n+Wed Dec  5 16:03:04 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* attribs.c (handle_no_check_memory_usage_atribute): Deleted.\n+\t(c_com): Delete its reference.\n+\t* builtins.c: Delete memory checking code.\n+\t* calls.c, expr.c, function.c, stmt.c: Likewise.\n+\t* builtins.c (expand_builtin_arg_info): Remove reference to\n+\tEXPAND_MEMORY_USE_* modifiers.\n+\t* explow.c (expr_size): Likewise.\n+\t* expr.c (expand_expr, expand_increment): Likewise.\n+\t* expr.h (ARGS_SIZE_RTX): Likewise.\n+\t* function.c (assign_parms, expand_pending_sizeso): Likewise.\n+\t* c-decl.c (duplicate_decls): Don't handle DECL_NO_CHECK_MEMORY_USAGE.\n+\t* expr.c (in_check_memory_usage): Delete.\n+\t(get_push_address, get_memory_usage_from_modifier): Delete.\n+\t(expand_assigment): Use EXPAND_WRITE on destination.\n+\t(expand_expr): Delete ro_modifier.\n+\t* expr.h (expand_modifier): Delete EXPAND_MEMORY_* entries and\n+\tadd EXPAND_WRITE.\n+\t(memory_use_mode): Delete.\n+\t* flags.h (flag_check_memory_usage): Deleted.\n+\t(flag_prefix_function_name): Likewise.\n+\t* function.c (expand_function_start): Don't set\n+\tcurrent_function_check_memory_usage.\n+\t* function.h (check_memory_usage): Delete.\n+\t* libfuncs.h, optabs.c: Delete chkr_* stuff.\n+\t* stmt.c (expand_asm_opernd): Change EXPAND_MEMORY_USE_WO to\n+\tEXPAND_WRITE.\n+\t* toplev.c (flag_check_memory_usage): Deleted.\n+\t(flag_prefix_function_name): Likewise.\n+\t(f_options, process_options): Delete references to above.\n+\t* tree.h (DECL_NO_CHECK_MEMORY_USAGE): Deleted.\n+\t* varasm.c (CHKR_PREFIX): Deleted.\n+\t(make_decl_rtl): Remove flag_prefix_function_name handling.\n+\t(assemble_name): Likewise.\n+\t* doc/extend.texi: Remove no_check_memory_usage attribute.\n+\t* doc/invoke.texi: Remove -fcheck-memory-usage\n+\tand -fprefix-function-name.\n+\n 2001-12-05  Andreas Schwab  <schwab@suse.de>\n \n \t* Makefile.in (STMP_FIXPROTO, STMP_FIXINC): Use substituted values"}, {"sha": "9322c421106fe04ccf8839a1cc3e0056787b9eae", "filename": "gcc/attribs.c", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -76,8 +76,6 @@ static tree handle_alias_attribute\tPARAMS ((tree *, tree, tree, int,\n static tree handle_no_instrument_function_attribute PARAMS ((tree *, tree,\n \t\t\t\t\t\t\t     tree, int,\n \t\t\t\t\t\t\t     bool *));\n-static tree handle_no_check_memory_usage_attribute PARAMS ((tree *, tree, tree,\n-\t\t\t\t\t\t\t    int, bool *));\n static tree handle_malloc_attribute\tPARAMS ((tree *, tree, tree, int,\n \t\t\t\t\t\t bool *));\n static tree handle_no_limit_stack_attribute PARAMS ((tree *, tree, tree, int,\n@@ -131,8 +129,6 @@ static const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_alias_attribute },\n   { \"no_instrument_function\", 0, 0, true,  false, false,\n \t\t\t      handle_no_instrument_function_attribute },\n-  { \"no_check_memory_usage\",  0, 0, true,  false, false,\n-\t\t\t      handle_no_check_memory_usage_attribute },\n   { \"malloc\",                 0, 0, true,  false, false,\n \t\t\t      handle_malloc_attribute },\n   { \"no_stack_limit\",         0, 0, true,  false, false,\n@@ -1044,39 +1040,6 @@ handle_no_instrument_function_attribute (node, name, args, flags, no_add_attrs)\n   return NULL_TREE;\n }\n \n-/* Handle a \"no_check_memory_usage\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_no_check_memory_usage_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    {\n-      error_with_decl (decl,\n-\t\t       \"`%s' attribute applies only to functions\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else if (DECL_INITIAL (decl))\n-    {\n-      error_with_decl (decl,\n-\t\t       \"can't set `%s' attribute after definition\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else\n-    DECL_NO_CHECK_MEMORY_USAGE (decl) = 1;\n-\n-  return NULL_TREE;\n-}\n-\n /* Handle a \"malloc\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "68df170b600679904d69b7b281a4068e1574d2f2", "filename": "gcc/builtins.c", "status": "modified", "additions": 9, "deletions": 68, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -1617,13 +1617,6 @@ expand_builtin_strlen (exp, target)\n \t source operand later.  */\n       before_strlen = get_last_insn();\n \n-      /* Check the string is readable and has an end.  */\n-      if (current_function_check_memory_usage)\n-\temit_library_call (chkr_check_str_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t   VOIDmode, 2, src_reg, Pmode,\n-\t\t\t   GEN_INT (MEMORY_USE_RO),\n-\t\t\t   TYPE_MODE (integer_type_node));\n-\n       char_rtx = const0_rtx;\n       char_mode = insn_data[(int) icode].operand[2].mode;\n       if (! (*insn_data[(int) icode].operand[2].predicate) (char_rtx,\n@@ -1672,8 +1665,7 @@ expand_builtin_strstr (arglist, target, mode)\n      rtx target;\n      enum machine_mode mode;\n {\n-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE)\n-      || current_function_check_memory_usage)\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n   else\n     {\n@@ -1729,8 +1721,7 @@ expand_builtin_strchr (arglist, target, mode)\n      rtx target;\n      enum machine_mode mode;\n {\n-  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE)\n-      || current_function_check_memory_usage)\n+  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n   else\n     {\n@@ -1776,8 +1767,7 @@ expand_builtin_strrchr (arglist, target, mode)\n      rtx target;\n      enum machine_mode mode;\n {\n-  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE)\n-      || current_function_check_memory_usage)\n+  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n   else\n     {\n@@ -1831,8 +1821,7 @@ expand_builtin_strpbrk (arglist, target, mode)\n      rtx target;\n      enum machine_mode mode;\n {\n-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE)\n-      || current_function_check_memory_usage)\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n   else\n     {\n@@ -1939,7 +1928,6 @@ expand_builtin_memcpy (arglist)\n \t by pieces, we can avoid loading the string from memory\n \t and only stored the computed constants.  */\n       if (src_str\n-\t  && !current_function_check_memory_usage\n \t  && GET_CODE (len_rtx) == CONST_INT\n \t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n \t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n@@ -1954,13 +1942,6 @@ expand_builtin_memcpy (arglist)\n       src_mem = get_memory_rtx (src);\n       set_mem_align (src_mem, src_align);\n \n-      /* Just copy the rights of SRC to the rights of DEST.  */\n-      if (current_function_check_memory_usage)\n-\temit_library_call (chkr_copy_bitmap_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t   VOIDmode, 3, XEXP (dest_mem, 0), Pmode,\n-\t\t\t   XEXP (src_mem, 0), Pmode,\n-\t\t\t   len_rtx, TYPE_MODE (sizetype));\n-\n       /* Copy word part most expediently.  */\n       dest_addr = emit_block_move (dest_mem, src_mem, len_rtx);\n \n@@ -2143,10 +2124,9 @@ expand_builtin_memset (exp)\n \t{\n \t  if (!host_integerp (len, 1))\n \t    return 0;\n-\t  if (current_function_check_memory_usage\n-\t      || !can_store_by_pieces (tree_low_cst (len, 1),\n-\t\t\t\t       builtin_memset_read_str,\n-\t\t\t\t       (PTR) &c, dest_align))\n+\t  if (!can_store_by_pieces (tree_low_cst (len, 1),\n+\t\t\t\t    builtin_memset_read_str, (PTR) &c,\n+\t\t\t\t    dest_align))\n \t    return 0;\n \n \t  dest_mem = get_memory_rtx (dest);\n@@ -2160,16 +2140,6 @@ expand_builtin_memset (exp)\n \n       dest_mem = get_memory_rtx (dest);\n       set_mem_align (dest_mem, dest_align);\n-\t   \n-      /* Just check DST is writable and mark it as readable.  */\n-      if (current_function_check_memory_usage)\n-\temit_library_call (chkr_check_addr_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t   VOIDmode, 3, XEXP (dest_mem, 0), Pmode,\n-\t\t\t   len_rtx, TYPE_MODE (sizetype),\n-\t\t\t   GEN_INT (MEMORY_USE_WO),\n-\t\t\t   TYPE_MODE (integer_type_node));\n-\n-\n       dest_addr = clear_storage (dest_mem, len_rtx);\n \n       if (dest_addr == 0)\n@@ -2225,10 +2195,6 @@ expand_builtin_memcmp (exp, arglist, target)\n      tree arglist;\n      rtx target;\n {\n-  /* If we need to check memory accesses, call the library function.  */\n-  if (current_function_check_memory_usage)\n-    return 0;\n-\n   if (!validate_arglist (arglist,\n \t\t      POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n@@ -2309,10 +2275,6 @@ expand_builtin_strcmp (exp, target, mode)\n   tree arg1, arg2;\n   const char *p1, *p2;\n \n-  /* If we need to check memory accesses, call the library function.  */\n-  if (current_function_check_memory_usage)\n-    return 0;\n-\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n \n@@ -2414,10 +2376,6 @@ expand_builtin_strncmp (exp, target, mode)\n   tree arg1, arg2, arg3;\n   const char *p1, *p2;\n \n-  /* If we need to check memory accesses, call the library function.  */\n-  if (current_function_check_memory_usage)\n-    return 0;\n-\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n@@ -2518,10 +2476,6 @@ expand_builtin_strcat (arglist, target, mode)\n      rtx target;\n      enum machine_mode mode;\n {\n-  /* If we need to check memory accesses, call the library function.  */\n-  if (current_function_check_memory_usage)\n-    return 0;\n-\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n   else\n@@ -2548,10 +2502,6 @@ expand_builtin_strncat (arglist, target, mode)\n      rtx target;\n      enum machine_mode mode;\n {\n-  /* If we need to check memory accesses, call the library function.  */\n-  if (current_function_check_memory_usage)\n-    return 0;\n-\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n@@ -2605,10 +2555,6 @@ expand_builtin_strspn (arglist, target, mode)\n      rtx target;\n      enum machine_mode mode;\n {\n-  /* If we need to check memory accesses, call the library function.  */\n-  if (current_function_check_memory_usage)\n-    return 0;\n-\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n   else\n@@ -2646,10 +2592,6 @@ expand_builtin_strcspn (arglist, target, mode)\n      rtx target;\n      enum machine_mode mode;\n {\n-  /* If we need to check memory accesses, call the library function.  */\n-  if (current_function_check_memory_usage)\n-    return 0;\n-\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n   else\n@@ -2791,7 +2733,7 @@ expand_builtin_args_info (exp)\n   TREE_STATIC (result) = 1;\n   result = build1 (INDIRECT_REF, build_pointer_type (type), result);\n   TREE_CONSTANT (result) = 1;\n-  return expand_expr (result, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_BAD);\n+  return expand_expr (result, NULL_RTX, VOIDmode, 0);\n #endif\n }\n \n@@ -3280,8 +3222,7 @@ expand_builtin_fputs (arglist, ignore)\n     return 0;\n \n   /* Verify the arguments in the original call.  */\n-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE)\n-      || current_function_check_memory_usage)\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n \n   /* Get the length of the string passed to fputs.  If the length"}, {"sha": "5471f6b268e5b44628a1ece3bdcc2b33c5f0c673", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -1906,13 +1906,9 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t{\n \t  DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n \t  DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n-\n+\t  DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);\n \t  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n \t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n-\t  DECL_NO_CHECK_MEMORY_USAGE (newdecl)\n-\t    |= DECL_NO_CHECK_MEMORY_USAGE (olddecl);\n-\t  DECL_NO_LIMIT_STACK (newdecl)\n-\t    |= DECL_NO_LIMIT_STACK (olddecl);\n \t}\n     }\n   /* If cannot merge, then use the new type and qualifiers,"}, {"sha": "2ab670bb32bb8ebd03161d6e0f2475b94a36a94f", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -1675,17 +1675,6 @@ rtx_for_function_call (fndecl, exp)\n       funaddr = funexp\n \t= expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n       pop_temp_slots ();\t/* FUNEXP can't be BLKmode.  */\n-\n-      /* Check the function is executable.  */\n-      if (current_function_check_memory_usage)\n-\t{\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\t  if (GET_MODE (funexp) != ptr_mode)\n-\t    funaddr = convert_memory_address (ptr_mode, funexp);\n-#endif\n-\t  emit_library_call (chkr_check_exec_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t     VOIDmode, 1, funaddr, ptr_mode);\n-\t}\n       emit_queue ();\n     }\n   return funexp;\n@@ -2162,13 +2151,6 @@ expand_call (exp, target, ignore)\n   /* The alignment of the stack, in bytes.  */\n   HOST_WIDE_INT preferred_unit_stack_boundary;\n \n-  /* The value of the function call can be put in a hard register.  But\n-     if -fcheck-memory-usage, code which invokes functions (and thus\n-     damages some hard registers) can be inserted before using the value.\n-     So, target is always a pseudo-register in that case.  */\n-  if (current_function_check_memory_usage)\n-    target = 0;\n-\n   /* See if this is \"nothrow\" function call.  */\n   if (TREE_NOTHROW (exp))\n     flags |= ECF_NOTHROW;\n@@ -3014,16 +2996,6 @@ expand_call (exp, target, ignore)\n \t\t\t\t     force_operand (structure_value_addr,\n \t\t\t\t\t\t    NULL_RTX)));\n \n-\t  /* Mark the memory for the aggregate as write-only.  */\n-\t  if (current_function_check_memory_usage)\n-\t    emit_library_call (chkr_set_right_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t       VOIDmode, 3,\n-\t\t\t       structure_value_addr, ptr_mode,\n-\t\t\t       GEN_INT (struct_value_size),\n-\t\t\t       TYPE_MODE (sizetype),\n-\t\t\t       GEN_INT (MEMORY_USE_WO),\n-\t\t\t       TYPE_MODE (integer_type_node));\n-\n \t  if (GET_CODE (struct_value_rtx) == REG)\n \t    use_reg (&call_fusage, struct_value_rtx);\n \t}\n@@ -4422,18 +4394,8 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n     do_pending_stack_adjust ();\n \n   if (arg->value == arg->stack)\n-    {\n-      /* If the value is already in the stack slot, we are done.  */\n-      if (current_function_check_memory_usage && GET_CODE (arg->stack) == MEM)\n-\t{\n-\t  emit_library_call (chkr_set_right_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t     VOIDmode, 3, XEXP (arg->stack, 0), Pmode,\n-\t\t\t     ARGS_SIZE_RTX (arg->size),\n-\t\t\t     TYPE_MODE (sizetype),\n-\t\t\t     GEN_INT (MEMORY_USE_RW),\n-\t\t\t     TYPE_MODE (integer_type_node));\n-\t}\n-    }\n+    /* If the value is already in the stack slot, we are done.  */\n+    ;\n   else if (arg->mode != BLKmode)\n     {\n       int size;"}, {"sha": "b01f868c7a89e261196bf48fe40832243b7eb66d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -1,3 +1,7 @@\n+Wed Dec  5 17:00:49 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c (duplicate_decls): Don't copy DECL_NO_CHECK_MEMORY_USAGE.\n+\n 2001-12-04  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* pt.c (end_template_parm_list): Clear TREE_CHAIN of each parm."}, {"sha": "3916610a310d832bddde63e570b779ba705ec247", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -3586,8 +3586,6 @@ duplicate_decls (newdecl, olddecl)\n \t{\n \t  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n \t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n-\t  DECL_NO_CHECK_MEMORY_USAGE (newdecl)\n-\t    |= DECL_NO_CHECK_MEMORY_USAGE (olddecl);\n \t  DECL_NO_LIMIT_STACK (newdecl)\n \t    |= DECL_NO_LIMIT_STACK (olddecl);\n \t}"}, {"sha": "61757f0d4d99f5a821daed8b3064ea60434f0353", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -1917,11 +1917,11 @@ attributes are currently defined for functions on all targets:\n @code{noreturn}, @code{noinline}, @code{pure}, @code{const},\n @code{format}, @code{format_arg}, @code{no_instrument_function},\n @code{section}, @code{constructor}, @code{destructor}, @code{used},\n-@code{unused}, @code{weak}, @code{malloc}, @code{alias} and\n-@code{no_check_memory_usage}.  Several other attributes are defined for\n-functions on particular target systems.  Other attributes, including\n-@code{section} are supported for variables declarations (@pxref{Variable\n-Attributes}) and for types (@pxref{Type Attributes}).\n+@code{unused}, @code{weak}, @code{malloc}, and @code{alias}.  Several\n+other attributes are defined for functions on particular target systems.\n+Other attributes, including @code{section} are supported for variables\n+declarations (@pxref{Variable Attributes}) and for types (@pxref{Type\n+Attributes}).\n \n You may also specify attributes with @samp{__} preceding and following\n each keyword.  This allows you to use them in header files without\n@@ -2212,23 +2212,6 @@ mangled name for the target must be used.\n \n Not all target machines support this attribute.\n \n-@item no_check_memory_usage\n-@cindex @code{no_check_memory_usage} function attribute\n-@opindex fcheck-memory-usage\n-The @code{no_check_memory_usage} attribute causes GCC to omit checks\n-of memory references when it generates code for that function.  Normally\n-if you specify @option{-fcheck-memory-usage} (see @pxref{Code Gen\n-Options}), GCC generates calls to support routines before most memory\n-accesses to permit support code to record usage and detect uses of\n-uninitialized or unallocated storage.  Since GCC cannot handle\n-@code{asm} statements properly they are not allowed in such functions.\n-If you declare a function with this attribute, GCC will not generate\n-memory checking code for that function, permitting the use of @code{asm}\n-statements without having to compile that function with different\n-options.  This also allows you to write support routines of your own if\n-you wish, without getting infinite recursion if they get compiled with\n-@option{-fcheck-memory-usage}.\n-\n @item regparm (@var{number})\n @cindex functions that are passed arguments in registers on the 386\n On the Intel 386, the @code{regparm} attribute causes the compiler to"}, {"sha": "a6b02a4e1698f00ff8edf03d379b4c5d17e12372", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -617,7 +617,6 @@ in the following sections.\n -ffixed-@var{reg} -fexceptions @gol\n -fnon-call-exceptions  -funwind-tables -fasynchronous-unwind-tables @gol\n -finhibit-size-directive  -finstrument-functions @gol\n--fcheck-memory-usage  -fprefix-function-name @gol\n -fno-common  -fno-ident  -fno-gnu-linker @gol\n -fpcc-struct-return  -fpic  -fPIC @gol\n -freg-struct-return  -fshared-data  -fshort-enums @gol\n@@ -9988,75 +9987,6 @@ Pack all structure members together without holes.  Usually you would\n not want to use this option, since it makes the code suboptimal, and\n the offsets of structure members won't agree with system libraries.\n \n-@item -fcheck-memory-usage\n-@opindex fcheck-memory-usage\n-Generate extra code to check each memory access.  GCC will generate\n-code that is suitable for a detector of bad memory accesses such as\n-@file{Checker}.\n-\n-Normally, you should compile all, or none, of your code with this option.\n-\n-If you do mix code compiled with and without this option,\n-you must ensure that all code that has side effects\n-and that is called by code compiled with this option\n-is, itself, compiled with this option.\n-If you do not, you might get erroneous messages from the detector.\n-\n-If you use functions from a library that have side-effects (such as\n-@code{read}), you might not be able to recompile the library and\n-specify this option.  In that case, you can enable the\n-@option{-fprefix-function-name} option, which requests GCC to encapsulate\n-your code and make other functions look as if they were compiled with\n-@option{-fcheck-memory-usage}.  This is done by calling ``stubs'',\n-which are provided by the detector.  If you cannot find or build\n-stubs for every function you call, you might have to specify\n-@option{-fcheck-memory-usage} without @option{-fprefix-function-name}.\n-\n-If you specify this option, you can not use the @code{asm} or\n-@code{__asm__} keywords in functions with memory checking enabled.  GCC\n-cannot understand what the @code{asm} statement may do, and therefore\n-cannot generate the appropriate code, so it will reject it.  However, if\n-you specify the function attribute @code{no_check_memory_usage}\n-(@pxref{Function Attributes}), GCC will disable memory checking within a\n-function; you may use @code{asm} statements inside such functions.  You\n-may have an inline expansion of a non-checked function within a checked\n-function; in that case GCC will not generate checks for the inlined\n-function's memory accesses.\n-\n-If you move your @code{asm} statements to non-checked inline functions\n-and they do access memory, you can add calls to the support code in your\n-inline function, to indicate any reads, writes, or copies being done.\n-These calls would be similar to those done in the stubs described above.\n-\n-@item -fprefix-function-name\n-@opindex fprefix-function-name\n-Request GCC to add a prefix to the symbols generated for function names.\n-GCC adds a prefix to the names of functions defined as well as\n-functions called.  Code compiled with this option and code compiled\n-without the option can't be linked together, unless stubs are used.\n-\n-If you compile the following code with @option{-fprefix-function-name}\n-@example\n-extern void bar (int);\n-void\n-foo (int a)\n-@{\n-  return bar (a + 5);\n-@}\n-@end example\n-\n-@noindent\n-GCC will compile the code as if it was written:\n-@example\n-extern void prefix_bar (int);\n-void\n-prefix_foo (int a)\n-@{\n-  return prefix_bar (a + 5);\n-@}\n-@end example\n-This option is designed to be used with @option{-fcheck-memory-usage}.\n-\n @item -finstrument-functions\n @opindex finstrument-functions\n Generate instrumentation calls for entry and exit to functions.  Just"}, {"sha": "bd6a12bca408bfd69cae3e28e761088560da8bb6", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -297,8 +297,8 @@ expr_size (exp)\n       && contains_placeholder_p (size))\n     size = build (WITH_RECORD_EXPR, sizetype, size, exp);\n \n-  return expand_expr (size, NULL_RTX, TYPE_MODE (sizetype),\n-  \t\t      EXPAND_MEMORY_USE_BAD);\n+  return expand_expr (size, NULL_RTX, TYPE_MODE (sizetype), 0);\n+\n }\n \f\n /* Return a copy of X in which all memory references"}, {"sha": "f2143d74ee34a079b5a3263a38ecb730af1b5f30", "filename": "gcc/expr.c", "status": "modified", "additions": 51, "deletions": 336, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -81,11 +81,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    the same indirect address eventually.  */\n int cse_not_expected;\n \n-/* Don't check memory usage, since code is being emitted to check a memory\n-   usage.  Used when current_function_check_memory_usage is true, to avoid\n-   infinite recursion.  */\n-static int in_check_memory_usage;\n-\n /* Chain of pending expressions for PLACEHOLDER_EXPR to replace.  */\n static tree placeholder_list = 0;\n \n@@ -124,8 +119,6 @@ struct store_by_pieces\n \n extern struct obstack permanent_obstack;\n \n-static rtx get_push_address\tPARAMS ((int));\n-\n static rtx enqueue_insn\t\tPARAMS ((rtx, rtx));\n static unsigned HOST_WIDE_INT move_by_pieces_ninsns\n \t\t\t\tPARAMS ((unsigned HOST_WIDE_INT,\n@@ -152,8 +145,6 @@ static rtx store_field\t\tPARAMS ((rtx, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, enum machine_mode,\n \t\t\t\t\t tree, enum machine_mode, int, tree,\n \t\t\t\t\t int));\n-static enum memory_use_mode\n-  get_memory_usage_from_modifier PARAMS ((enum expand_modifier));\n static rtx var_rtx\t\tPARAMS ((tree));\n static HOST_WIDE_INT highest_pow2_factor PARAMS ((tree));\n static rtx expand_increment\tPARAMS ((tree, int, int));\n@@ -3124,26 +3115,6 @@ push_block (size, extra, below)\n   return memory_address (GET_CLASS_NARROWEST_MODE (MODE_INT), temp);\n }\n \n-\n-/* Return an rtx for the address of the beginning of an as-if-it-was-pushed\n-   block of SIZE bytes.  */\n-\n-static rtx\n-get_push_address (size)\n-     int size;\n-{\n-  rtx temp;\n-\n-  if (STACK_PUSH_CODE == POST_DEC)\n-    temp = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (size));\n-  else if (STACK_PUSH_CODE == POST_INC)\n-    temp = gen_rtx_MINUS (Pmode, stack_pointer_rtx, GEN_INT (size));\n-  else\n-    temp = stack_pointer_rtx;\n-\n-  return copy_to_reg (temp);\n-}\n-\n #ifdef PUSH_ROUNDING\n \n /* Emit single push insn.  */\n@@ -3325,28 +3296,6 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t    anti_adjust_stack (GEN_INT (extra));\n \n \t  move_by_pieces (NULL, xinner, INTVAL (size) - used, align);\n-\n-\t  if (current_function_check_memory_usage && ! in_check_memory_usage)\n-\t    {\n-\t      rtx temp;\n-\n-\t      in_check_memory_usage = 1;\n-\t      temp = get_push_address (INTVAL (size) - used);\n-\t      if (GET_CODE (x) == MEM && type && AGGREGATE_TYPE_P (type))\n-\t\temit_library_call (chkr_copy_bitmap_libfunc,\n-\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3, temp,\n-\t\t\t\t   Pmode, XEXP (xinner, 0), Pmode,\n-\t\t\t\t   GEN_INT (INTVAL (size) - used),\n-\t\t\t\t   TYPE_MODE (sizetype));\n-\t      else\n-\t\temit_library_call (chkr_set_right_libfunc,\n-\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3, temp,\n-\t\t\t\t   Pmode, GEN_INT (INTVAL (size) - used),\n-\t\t\t\t   TYPE_MODE (sizetype),\n-\t\t\t\t   GEN_INT (MEMORY_USE_RW),\n-\t\t\t\t   TYPE_MODE (integer_type_node));\n-\t      in_check_memory_usage = 0;\n-\t    }\n \t}\n       else\n #endif /* PUSH_ROUNDING  */\n@@ -3385,26 +3334,6 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t\t\t\t\t\t\targs_addr,\n \t\t\t\t\t\t\t\targs_so_far),\n \t\t\t\t\t\t  skip));\n-\t  if (current_function_check_memory_usage && ! in_check_memory_usage)\n-\t    {\n-\t      in_check_memory_usage = 1;\n-\t      target = copy_to_reg (temp);\n-\t      if (GET_CODE (x) == MEM && type && AGGREGATE_TYPE_P (type))\n-\t\temit_library_call (chkr_copy_bitmap_libfunc,\n-\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n-\t\t\t\t   target, Pmode,\n-\t\t\t\t   XEXP (xinner, 0), Pmode,\n-\t\t\t\t   size, TYPE_MODE (sizetype));\n-\t      else\n-\t        emit_library_call (chkr_set_right_libfunc,\n-\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n-\t\t\t\t   target, Pmode,\n-\t\t\t \t   size, TYPE_MODE (sizetype),\n-\t\t\t\t   GEN_INT (MEMORY_USE_RW),\n-\t\t\t\t   TYPE_MODE (integer_type_node));\n-\t      in_check_memory_usage = 0;\n-\t    }\n-\n \t  target = gen_rtx_MEM (BLKmode, temp);\n \n \t  if (type != 0)\n@@ -3605,27 +3534,6 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t  emit_move_insn (dest, x);\n \t}\n \n-      if (current_function_check_memory_usage && ! in_check_memory_usage)\n-\t{\n-\t  in_check_memory_usage = 1;\n-\t  if (target == 0)\n-\t    target = get_push_address (GET_MODE_SIZE (mode));\n-\n-\t  if (GET_CODE (x) == MEM && type && AGGREGATE_TYPE_P (type))\n-\t    emit_library_call (chkr_copy_bitmap_libfunc,\n-\t\t\t       LCT_CONST_MAKE_BLOCK, VOIDmode, 3, target,\n-\t\t\t       Pmode, XEXP (x, 0), Pmode,\n-\t\t\t       GEN_INT (GET_MODE_SIZE (mode)),\n-\t\t\t       TYPE_MODE (sizetype));\n-\t  else\n-\t    emit_library_call (chkr_set_right_libfunc,\n-\t\t\t       LCT_CONST_MAKE_BLOCK, VOIDmode, 3, target,\n-\t\t\t       Pmode, GEN_INT (GET_MODE_SIZE (mode)),\n-\t\t\t       TYPE_MODE (sizetype),\n-\t\t\t       GEN_INT (MEMORY_USE_RW),\n-\t\t\t       TYPE_MODE (integer_type_node));\n-\t  in_check_memory_usage = 0;\n-\t}\n     }\n \n  ret:\n@@ -3724,8 +3632,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n       if (mode1 == VOIDmode && want_value)\n \ttem = stabilize_reference (tem);\n \n-      orig_to_rtx = to_rtx\n-\t= expand_expr (tem, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_DONT);\n+      orig_to_rtx = to_rtx = expand_expr (tem, NULL_RTX, VOIDmode,\n+\t\t\t\t\t  EXPAND_WRITE);\n       if (offset != 0)\n \t{\n \t  rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n@@ -3812,36 +3720,6 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t  MEM_KEEP_ALIAS_SET_P (to_rtx) = 1;\n \t}\n \n-      /* Check the access.  */\n-      if (current_function_check_memory_usage && GET_CODE (to_rtx) == MEM)\n-\t{\n-\t  rtx to_addr;\n-\t  int size;\n-\t  int best_mode_size;\n-\t  enum machine_mode best_mode;\n-\n-\t  best_mode = get_best_mode (bitsize, bitpos,\n-\t  \t\t\t     TYPE_ALIGN (TREE_TYPE (tem)),\n-\t  \t\t\t     mode1, volatilep);\n-\t  if (best_mode == VOIDmode)\n-\t    best_mode = QImode;\n-\n-\t  best_mode_size = GET_MODE_BITSIZE (best_mode);\n-\t  to_addr = plus_constant (XEXP (to_rtx, 0), bitpos / BITS_PER_UNIT);\n-\t  size = CEIL ((bitpos % best_mode_size) + bitsize, best_mode_size);\n-\t  size *= GET_MODE_SIZE (best_mode);\n-\n-\t  /* Check the access right of the pointer.  */\n-\t  in_check_memory_usage = 1;\n-\t  if (size)\n-\t    emit_library_call (chkr_check_addr_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t       VOIDmode, 3, to_addr, Pmode,\n-\t\t\t       GEN_INT (size), TYPE_MODE (sizetype),\n-\t\t\t       GEN_INT (MEMORY_USE_WO),\n-\t\t\t       TYPE_MODE (integer_type_node));\n-\t  in_check_memory_usage = 0;\n-\t}\n-\n       result = store_field (to_rtx, bitsize, bitpos, mode1, from,\n \t\t\t    (want_value\n \t\t\t     /* Spurious cast for HPUX compiler.  */\n@@ -3883,7 +3761,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       push_temp_slots ();\n       value = expand_expr (from, NULL_RTX, VOIDmode, 0);\n       if (to_rtx == 0)\n-\tto_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_WO);\n+\tto_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n       /* Handle calls that return values in multiple non-contiguous locations.\n \t The Irix 6 ABI has examples of this.  */\n@@ -3910,7 +3788,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n      Don't re-expand if it was expanded already (in COMPONENT_REF case).  */\n \n   if (to_rtx == 0)\n-    to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_WO);\n+    to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n   /* Don't move directly into a return register.  */\n   if (TREE_CODE (to) == RESULT_DECL\n@@ -3943,17 +3821,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \n       push_temp_slots ();\n       size = expr_size (from);\n-      from_rtx = expand_expr (from, NULL_RTX, VOIDmode,\n-\t\t\t      EXPAND_MEMORY_USE_DONT);\n-\n-      /* Copy the rights of the bitmap.  */\n-      if (current_function_check_memory_usage)\n-\temit_library_call (chkr_copy_bitmap_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t   VOIDmode, 3, XEXP (to_rtx, 0), Pmode,\n-\t\t\t   XEXP (from_rtx, 0), Pmode,\n-\t\t\t   convert_to_mode (TYPE_MODE (sizetype),\n-\t\t\t\t\t    size, TREE_UNSIGNED (sizetype)),\n-\t\t\t   TYPE_MODE (sizetype));\n+      from_rtx = expand_expr (from, NULL_RTX, VOIDmode, 0);\n \n #ifdef TARGET_MEM_FUNCTIONS\n       emit_library_call (memmove_libfunc, LCT_NORMAL,\n@@ -4195,28 +4063,9 @@ store_expr (exp, target, want_value)\n     temp = convert_modes (GET_MODE (target), TYPE_MODE (TREE_TYPE (exp)),\n \t\t\t  temp, TREE_UNSIGNED (TREE_TYPE (exp)));\n \n-  if (current_function_check_memory_usage\n-      && GET_CODE (target) == MEM\n-      && AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n-    {\n-      in_check_memory_usage = 1;\n-      if (GET_CODE (temp) == MEM)\n-\temit_library_call (chkr_copy_bitmap_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t   VOIDmode, 3, XEXP (target, 0), Pmode,\n-\t\t\t   XEXP (temp, 0), Pmode,\n-\t\t\t   expr_size (exp), TYPE_MODE (sizetype));\n-      else\n-\temit_library_call (chkr_check_addr_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t   VOIDmode, 3, XEXP (target, 0), Pmode,\n-\t\t\t   expr_size (exp), TYPE_MODE (sizetype),\n-\t\t\t   GEN_INT (MEMORY_USE_WO),\n-\t\t\t   TYPE_MODE (integer_type_node));\n-      in_check_memory_usage = 0;\n-    }\n-\n   /* If value was not generated in the target, store it there.\n-     Convert the value to TARGET's type first if nec.  */\n-  /* If TEMP and TARGET compare equal according to rtx_equal_p, but\n+     Convert the value to TARGET's type first if necessary.\n+     If TEMP and TARGET compare equal according to rtx_equal_p, but\n      one or both of them are volatile memory refs, we have to distinguish\n      two cases:\n      - expand_expr has used TARGET.  In this case, we must not generate\n@@ -4305,19 +4154,7 @@ store_expr (exp, target, want_value)\n \t\t}\n \n \t      if (size != const0_rtx)\n-\t\t{\n-\t\t  /* Be sure we can write on ADDR.  */\n-\t\t  in_check_memory_usage = 1;\n-\t\t  if (current_function_check_memory_usage)\n-\t\t    emit_library_call (chkr_check_addr_libfunc,\n-\t\t\t\t       LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n-\t\t\t\t       XEXP (target, 0), Pmode,\n-\t\t\t\t       size, TYPE_MODE (sizetype),\n- \t\t\t\t       GEN_INT (MEMORY_USE_WO),\n-\t\t\t\t       TYPE_MODE (integer_type_node));\n-\t\t  in_check_memory_usage = 0;\n-\t\t  clear_storage (target, size);\n-\t\t}\n+\t\tclear_storage (target, size);\n \n \t      if (label)\n \t\temit_label (label);\n@@ -5508,37 +5345,6 @@ handled_component_p (t)\n       return 0;\n     }\n }\n-\n-/* Subroutine of expand_exp: compute memory_usage from modifier.  */\n-\n-static enum memory_use_mode\n-get_memory_usage_from_modifier (modifier)\n-     enum expand_modifier modifier;\n-{\n-  switch (modifier)\n-    {\n-    case EXPAND_NORMAL:\n-    case EXPAND_SUM:\n-      return MEMORY_USE_RO;\n-      break;\n-    case EXPAND_MEMORY_USE_WO:\n-      return MEMORY_USE_WO;\n-      break;\n-    case EXPAND_MEMORY_USE_RW:\n-      return MEMORY_USE_RW;\n-      break;\n-    case EXPAND_MEMORY_USE_DONT:\n-      /* EXPAND_CONST_ADDRESS and EXPAND_INITIALIZER are converted into\n-\t MEMORY_USE_DONT, because they are modifiers to a call of\n-\t expand_expr in the ADDR_EXPR case of expand_expr.  */\n-    case EXPAND_CONST_ADDRESS:\n-    case EXPAND_INITIALIZER:\n-      return MEMORY_USE_DONT;\n-    case EXPAND_MEMORY_USE_BAD:\n-    default:\n-      abort ();\n-    }\n-}\n \f\n /* Given an rtx VALUE that may contain additions and multiplications, return\n    an equivalent value that just refers to a register, memory, or constant.\n@@ -6133,8 +5939,6 @@ expand_expr (exp, target, tmode, modifier)\n   rtx subtarget, original_target;\n   int ignore;\n   tree context;\n-  /* Used by check-memory-usage to make modifier read only.  */\n-  enum expand_modifier ro_modifier;\n \n   /* Handle ERROR_MARK before anybody tries to access its type.  */\n   if (TREE_CODE (exp) == ERROR_MARK || TREE_CODE (type) == ERROR_MARK)\n@@ -6155,13 +5959,6 @@ expand_expr (exp, target, tmode, modifier)\n \t\t || code == COND_EXPR || code == VIEW_CONVERT_EXPR)\n \t\t&& TREE_CODE (type) == VOID_TYPE));\n \n-  /* Make a read-only version of the modifier.  */\n-  if (modifier == EXPAND_NORMAL || modifier == EXPAND_SUM\n-      || modifier == EXPAND_CONST_ADDRESS || modifier == EXPAND_INITIALIZER)\n-    ro_modifier = modifier;\n-  else\n-    ro_modifier = EXPAND_NORMAL;\n-\n   /* If we are going to ignore this result, we need only do something\n      if there is a side-effect somewhere in the expression.  If there\n      is, short-circuit the most common cases here.  Note that we must\n@@ -6180,42 +5977,38 @@ expand_expr (exp, target, tmode, modifier)\n \t  && mode != VOIDmode && mode != BLKmode\n \t  && modifier != EXPAND_CONST_ADDRESS)\n \t{\n-\t  temp = expand_expr (exp, NULL_RTX, VOIDmode, ro_modifier);\n+\t  temp = expand_expr (exp, NULL_RTX, VOIDmode, modifier);\n \t  if (GET_CODE (temp) == MEM)\n \t    temp = copy_to_reg (temp);\n \t  return const0_rtx;\n \t}\n \n       if (TREE_CODE_CLASS (code) == '1' || code == COMPONENT_REF\n \t  || code == INDIRECT_REF || code == BUFFER_REF)\n-\treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n-\t\t\t    VOIDmode, ro_modifier);\n+\treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n+\t\t\t    modifier);\n+\n       else if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<'\n \t       || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n \t{\n-\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n-\t\t       ro_modifier);\n-\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode,\n-\t\t       ro_modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, modifier);\n \t  return const0_rtx;\n \t}\n       else if ((code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n \t       && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n \t/* If the second operand has no side effects, just evaluate\n \t   the first.  */\n-\treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n-\t\t\t    VOIDmode, ro_modifier);\n+\treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n+\t\t\t    modifier);\n       else if (code == BIT_FIELD_REF)\n \t{\n-\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n-\t\t       ro_modifier);\n-\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode,\n-\t\t       ro_modifier);\n-\t  expand_expr (TREE_OPERAND (exp, 2), const0_rtx, VOIDmode,\n-\t\t       ro_modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 2), const0_rtx, VOIDmode, modifier);\n \t  return const0_rtx;\n \t}\n-      ;\n+\n       target = 0;\n     }\n \n@@ -6331,35 +6124,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      set_mem_attributes (value, exp, 1);\n \t      SET_DECL_RTL (exp, value);\n \t    }\n-\t}\n-\n-      /* Although static-storage variables start off initialized, according to\n-\t ANSI C, a memcpy could overwrite them with uninitialized values.  So\n-\t we check them too.  This also lets us check for read-only variables\n-\t accessed via a non-const declaration, in case it won't be detected\n-\t any other way (e.g., in an embedded system or OS kernel without\n-\t memory protection).\n-\n-\t Aggregates are not checked here; they're handled elsewhere.  */\n-      if (cfun && current_function_check_memory_usage\n-\t  && code == VAR_DECL\n-\t  && GET_CODE (DECL_RTL (exp)) == MEM\n-\t  && ! AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n-\t{\n-\t  enum memory_use_mode memory_usage;\n-\t  memory_usage = get_memory_usage_from_modifier (modifier);\n-\n-\t  in_check_memory_usage = 1;\n-\t  if (memory_usage != MEMORY_USE_DONT)\n-\t    emit_library_call (chkr_check_addr_libfunc,\n-\t\t\t       LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n-\t\t\t       XEXP (DECL_RTL (exp), 0), Pmode,\n-\t\t\t       GEN_INT (int_size_in_bytes (type)),\n-\t\t\t       TYPE_MODE (sizetype),\n-\t\t\t       GEN_INT (memory_usage),\n-\t\t\t       TYPE_MODE (integer_type_node));\n-\t  in_check_memory_usage = 0;\n-\t}\n+\t  }\n \n       /* ... fall through ...  */\n \n@@ -6473,8 +6238,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t TREE_INT_CST_HIGH (exp), mode);\n \n     case CONST_DECL:\n-      return expand_expr (DECL_INITIAL (exp), target, VOIDmode,\n-\t\t\t  EXPAND_MEMORY_USE_BAD);\n+      return expand_expr (DECL_INITIAL (exp), target, VOIDmode, 0);\n \n     case REAL_CST:\n       /* If optimized, generate immediate CONST_DOUBLE\n@@ -6587,8 +6351,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    }\n \n \t  if (temp == const0_rtx)\n-\t    expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n-\t\t\t EXPAND_MEMORY_USE_BAD);\n+\t    expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n \t  else\n \t    store_expr (TREE_OPERAND (exp, 0), temp, 0);\n \n@@ -6630,7 +6393,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  abort ();\n \n \tplaceholder_list = TREE_CHAIN (placeholder_expr);\n-\ttemp = expand_expr (exp, original_target, tmode, ro_modifier);\n+\ttemp = expand_expr (exp, original_target, tmode, modifier);\n \tplaceholder_list = old_list;\n \treturn temp;\n       }\n@@ -6643,8 +6406,8 @@ expand_expr (exp, target, tmode, modifier)\n \t and pop the list.  */\n       placeholder_list = tree_cons (TREE_OPERAND (exp, 1), NULL_TREE,\n \t\t\t\t    placeholder_list);\n-      target = expand_expr (TREE_OPERAND (exp, 0), original_target,\n-\t\t\t    tmode, ro_modifier);\n+      target = expand_expr (TREE_OPERAND (exp, 0), original_target, tmode,\n+\t\t\t    modifier);\n       placeholder_list = TREE_CHAIN (placeholder_list);\n       return target;\n \n@@ -6709,7 +6472,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    vars = TREE_CHAIN (vars);\n \t  }\n \n-\ttemp = expand_expr (TREE_OPERAND (exp, 1), target, tmode, ro_modifier);\n+\ttemp = expand_expr (TREE_OPERAND (exp, 1), target, tmode, modifier);\n \n \texpand_end_bindings (TREE_OPERAND (exp, 0), 0, 0);\n \n@@ -6734,9 +6497,10 @@ expand_expr (exp, target, tmode, modifier)\n       if (ignore)\n \t{\n \t  tree elt;\n+\n \t  for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n-\t    expand_expr (TREE_VALUE (elt), const0_rtx, VOIDmode,\n-\t    \t\t EXPAND_MEMORY_USE_BAD);\n+\t    expand_expr (TREE_VALUE (elt), const0_rtx, VOIDmode, 0);\n+\n \t  return const0_rtx;\n \t}\n \n@@ -6798,39 +6562,19 @@ expand_expr (exp, target, tmode, modifier)\n \t    && compare_tree_int (index, TREE_STRING_LENGTH (string)) < 0\n  \t    && GET_MODE_CLASS (mode) == MODE_INT\n  \t    && GET_MODE_SIZE (mode) == 1\n-\t    && modifier != EXPAND_MEMORY_USE_WO)\n+\t    && modifier != EXPAND_WRITE)\n  \t  return\n \t    GEN_INT (TREE_STRING_POINTER (string)[TREE_INT_CST_LOW (index)]);\n \n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address (mode, op0);\n-\n-\tif (cfun && current_function_check_memory_usage\n-\t    && ! AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n-\t  {\n-\t    enum memory_use_mode memory_usage;\n-\t    memory_usage = get_memory_usage_from_modifier (modifier);\n-\n-            if (memory_usage != MEMORY_USE_DONT)\n-\t      {\n-\t\tin_check_memory_usage = 1;\n-\t\temit_library_call (chkr_check_addr_libfunc,\n-\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3, op0,\n-\t\t\t\t   Pmode, GEN_INT (int_size_in_bytes (type)),\n-\t\t\t\t   TYPE_MODE (sizetype),\n-\t\t\t\t   GEN_INT (memory_usage),\n-\t\t\t\t   TYPE_MODE (integer_type_node));\n-\t\tin_check_memory_usage = 0;\n-\t      }\n-\t  }\n-\n \ttemp = gen_rtx_MEM (mode, op0);\n \tset_mem_attributes (temp, exp, 0);\n \n \t/* If we are writing to this object and its type is a record with\n \t   readonly fields, we must mark it as readonly so it will\n \t   conflict with readonly references to those fields.  */\n-\tif (modifier == EXPAND_MEMORY_USE_WO && readonly_fields_p (type))\n+\tif (modifier == EXPAND_WRITE && readonly_fields_p (type))\n \t  RTX_UNCHANGING_P (temp) = 1;\n \n \treturn temp;\n@@ -6892,8 +6636,8 @@ expand_expr (exp, target, tmode, modifier)\n \t      ;\n \n \t    if (elem)\n-\t      return expand_expr (fold (TREE_VALUE (elem)), target,\n-\t\t\t\t  tmode, ro_modifier);\n+\t      return expand_expr (fold (TREE_VALUE (elem)), target, tmode,\n+\t\t\t\t  modifier);\n \t  }\n \n \telse if (optimize >= 1\n@@ -6919,7 +6663,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t\t    if (elem && !TREE_SIDE_EFFECTS (TREE_VALUE (elem)))\n \t\t      return expand_expr (fold (TREE_VALUE (elem)), target,\n-\t\t\t\t\t  tmode, ro_modifier);\n+\t\t\t\t\t  tmode, modifier);\n \t\t  }\n \t\telse if (TREE_CODE (init) == STRING_CST\n \t\t\t && 0 > compare_tree_int (index,\n@@ -7117,34 +6861,6 @@ expand_expr (exp, target, tmode, modifier)\n \t    MEM_VOLATILE_P (op0) = 1;\n \t  }\n \n-\t/* Check the access.  */\n-\tif (cfun != 0 && current_function_check_memory_usage\n-\t    && GET_CODE (op0) == MEM)\n-\t  {\n-\t    enum memory_use_mode memory_usage;\n-\t    memory_usage = get_memory_usage_from_modifier (modifier);\n-\n-\t    if (memory_usage != MEMORY_USE_DONT)\n-\t      {\n-\t\trtx to;\n-\t\tint size;\n-\n-\t\tto = plus_constant (XEXP (op0, 0), (bitpos / BITS_PER_UNIT));\n-\t\tsize = (bitpos % BITS_PER_UNIT) + bitsize + BITS_PER_UNIT - 1;\n-\n-        \t/* Check the access right of the pointer.  */\n-\t\tin_check_memory_usage = 1;\n-\t\tif (size > BITS_PER_UNIT)\n-\t\t  emit_library_call (chkr_check_addr_libfunc,\n-\t\t\t\t     LCT_CONST_MAKE_BLOCK, VOIDmode, 3, to,\n-\t\t\t\t     Pmode, GEN_INT (size / BITS_PER_UNIT),\n-\t\t\t\t     TYPE_MODE (sizetype),\n-\t\t\t\t     GEN_INT (memory_usage),\n-\t\t\t\t     TYPE_MODE (integer_type_node));\n-\t\tin_check_memory_usage = 0;\n-\t      }\n-\t  }\n-\n \t/* In cases where an aligned union has an unaligned object\n \t   as a field, we might be extracting a BLKmode value from\n \t   an integer-mode (e.g., SImode) object.  Handle this case\n@@ -7416,7 +7132,7 @@ expand_expr (exp, target, tmode, modifier)\n       if (WITH_CLEANUP_EXPR_RTL (exp) == 0)\n \t{\n \t  WITH_CLEANUP_EXPR_RTL (exp)\n-\t    = expand_expr (TREE_OPERAND (exp, 0), target, tmode, ro_modifier);\n+\t    = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n \t  expand_decl_cleanup (NULL_TREE, TREE_OPERAND (exp, 1));\n \n \t  /* That's it for this cleanup.  */\n@@ -7432,7 +7148,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \ttarget_temp_slot_level = temp_slot_level;\n \n-\top0 = expand_expr (TREE_OPERAND (exp, 0), target, tmode, ro_modifier);\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n \t/* If we're going to use this value, load it up now.  */\n \tif (! ignore)\n \t  op0 = force_not_mem (op0);\n@@ -7507,7 +7223,7 @@ expand_expr (exp, target, tmode, modifier)\n       if (mode == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n \t{\n \t  op0 = expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode,\n-\t\t\t     ro_modifier);\n+\t\t\t     modifier);\n \n \t  /* If the signedness of the conversion differs and OP0 is\n \t     a promoted SUBREG, clear that indication since we now\n@@ -7542,7 +7258,7 @@ expand_expr (exp, target, tmode, modifier)\n       return target;\n \n     case VIEW_CONVERT_EXPR:\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, ro_modifier);\n+      op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, modifier);\n \n       /* If the input and output modes are both the same, we are done.\n \t Otherwise, if neither mode is BLKmode and both are within a word, we\n@@ -7722,8 +7438,8 @@ expand_expr (exp, target, tmode, modifier)\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n \n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, ro_modifier);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, ro_modifier);\n+      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, modifier);\n+      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, modifier);\n \n     both_summands:\n       /* Make sure any term that's a sum with a constant comes last.  */\n@@ -7782,10 +7498,10 @@ expand_expr (exp, target, tmode, modifier)\n \t  && really_constant_p (TREE_OPERAND (exp, 0))\n \t  && really_constant_p (TREE_OPERAND (exp, 1)))\n \t{\n-\t  rtx op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX,\n-\t\t\t\t VOIDmode, ro_modifier);\n-\t  rtx op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX,\n-\t\t\t\t VOIDmode, ro_modifier);\n+\t  rtx op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode,\n+\t\t\t\t modifier);\n+\t  rtx op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode,\n+\t\t\t\t modifier);\n \n \t  /* If the last operand is a CONST_INT, use plus_constant of\n \t     the negated constant.  Else make the MINUS.  */\n@@ -8267,11 +7983,11 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (ignore)\n \t      {\n \t\texpand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n-\t\t\t     ro_modifier);\n+\t\t\t     modifier);\n \t\treturn const0_rtx;\n \t      }\n \n-\t    op0 = expand_expr (TREE_OPERAND (exp, 0), target, mode, ro_modifier);\n+\t    op0 = expand_expr (TREE_OPERAND (exp, 0), target, mode, modifier);\n \t    if (GET_MODE (op0) == mode)\n \t      return op0;\n \n@@ -9076,7 +8792,7 @@ expand_increment (exp, post, ignore)\n      and insns were generated in computing it.  */\n \n   temp = get_last_insn ();\n-  op0 = expand_expr (incremented, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_RW);\n+  op0 = expand_expr (incremented, NULL_RTX, VOIDmode, 0);\n \n   /* If OP0 is a SUBREG made for a promoted variable, we cannot increment\n      in place but instead must do sign- or zero-extension during assignment,\n@@ -9107,8 +8823,7 @@ expand_increment (exp, post, ignore)\n \n   op0_is_copy = ((GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n \t\t && temp != get_last_insn ());\n-  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode,\n-\t\t     EXPAND_MEMORY_USE_BAD);\n+  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n \n   /* Decide whether incrementing or decrementing.  */\n   if (TREE_CODE (exp) == POSTDECREMENT_EXPR\n@@ -9229,9 +8944,9 @@ expand_increment (exp, post, ignore)\n     temp = copy_rtx (value = op0);\n \n   /* Increment however we can.  */\n-  op1 = expand_binop (mode, this_optab, value, op1,\n-\t\t      current_function_check_memory_usage ? NULL_RTX : op0,\n+  op1 = expand_binop (mode, this_optab, value, op1, op0,\n \t\t      TREE_UNSIGNED (TREE_TYPE (exp)), OPTAB_LIB_WIDEN);\n+\n   /* Make sure the value is stored into OP0.  */\n   if (op1 != op0)\n     emit_move_insn (op0, op1);"}, {"sha": "192733b9a5c1c88a71de0c3a379c3f393f0f8624", "filename": "gcc/expr.h", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -48,26 +48,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    EXPAND_INITIALIZER is similar but also record any labels on forced_labels.\n    EXPAND_CONST_ADDRESS means it is ok to return a MEM whose address\n     is a constant that is not a legitimate address.\n-   EXPAND_MEMORY_USE_* are explained below.  */\n-enum expand_modifier {EXPAND_NORMAL, EXPAND_SUM,\n-\t\t      EXPAND_CONST_ADDRESS, EXPAND_INITIALIZER,\n-\t\t      EXPAND_MEMORY_USE_WO, EXPAND_MEMORY_USE_RW,\n-\t\t      EXPAND_MEMORY_USE_BAD, EXPAND_MEMORY_USE_DONT};\n-\n-/* Argument for chkr_* functions.\n-   MEMORY_USE_RO: the pointer reads memory.\n-   MEMORY_USE_WO: the pointer writes to memory.\n-   MEMORY_USE_RW: the pointer modifies memory (ie it reads and writes). An\n-                  example is (*ptr)++\n-   MEMORY_USE_BAD: use this if you don't know the behavior of the pointer, or\n-                   if you know there are no pointers.  Using an INDIRECT_REF\n-                   with MEMORY_USE_BAD will abort.\n-   MEMORY_USE_TW: just test for writing, without update.  Special.\n-   MEMORY_USE_DONT: the memory is neither read nor written.  This is used by\n-   \t\t   '->' and '.'.  */\n-enum memory_use_mode {MEMORY_USE_BAD = 0, MEMORY_USE_RO = 1,\n-\t\t      MEMORY_USE_WO = 2, MEMORY_USE_RW = 3,\n-\t\t      MEMORY_USE_TW = 6, MEMORY_USE_DONT = 99};\n+   EXPAND_WRITE means we are only going to write to the resulting rtx.  */\n+enum expand_modifier {EXPAND_NORMAL, EXPAND_SUM, EXPAND_CONST_ADDRESS,\n+\t\t\tEXPAND_INITIALIZER, EXPAND_WRITE};\n \n /* Prevent the compiler from deferring stack pops.  See\n    inhibit_defer_pop for more information.  */\n@@ -119,8 +102,7 @@ struct args_size\n /* Convert the implicit sum in a `struct args_size' into an rtx.  */\n #define ARGS_SIZE_RTX(SIZE)\t\t\t\t\t\\\n ((SIZE).var == 0 ? GEN_INT ((SIZE).constant)\t\t\t\\\n- : expand_expr (ARGS_SIZE_TREE (SIZE), NULL_RTX, VOIDmode,\t\\\n-\t\tEXPAND_MEMORY_USE_BAD))\n+ : expand_expr (ARGS_SIZE_TREE (SIZE), NULL_RTX, VOIDmode, 0))\n \n /* Supply a default definition for FUNCTION_ARG_PADDING:\n    usually pad upward, but pad short args downward on"}, {"sha": "af1d8603c5061895a2a877fcddadc88d78dc7b01", "filename": "gcc/flags.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -569,19 +569,10 @@ extern int flag_renumber_insns;\n \n extern int frame_pointer_needed;\n \n-/* Nonzero if GCC must add code to check memory access (used by Checker).  */\n-\n-extern int flag_check_memory_usage;\n-\n /* Nonzero if the generated code should trap on signed overflow\n    for PLUS / SUB / MULT.  */\n extern int flag_trapv;\n \n-/* Nonzero if GCC must prefix function names (used with\n-   flag_check_memory_usage).  */\n-\n-extern int flag_prefix_function_name;\n-\n /* Value of the -G xx switch, and whether it was passed or not.  */\n extern int g_switch_value;\n extern int g_switch_set;"}, {"sha": "82a71d3e327d723d5d3ae0665e214767a6218fdb", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -1432,14 +1432,6 @@ put_var_into_stack (decl)\n     }\n   else\n     return;\n-\n-  if (current_function_check_memory_usage)\n-    emit_library_call (chkr_set_right_libfunc, LCT_CONST_MAKE_BLOCK, VOIDmode,\n-\t\t       3, XEXP (reg, 0), Pmode,\n-\t\t       GEN_INT (GET_MODE_SIZE (GET_MODE (reg))),\n-\t\t       TYPE_MODE (sizetype),\n-\t\t       GEN_INT (MEMORY_USE_RW),\n-\t\t       TYPE_MODE (integer_type_node));\n }\n \n /* Subroutine of put_var_into_stack.  This puts a single pseudo reg REG\n@@ -4824,14 +4816,6 @@ assign_parms (fndecl)\n \n \t      store_expr (parm, copy, 0);\n \t      emit_move_insn (parmreg, XEXP (copy, 0));\n-\t      if (current_function_check_memory_usage)\n-\t\temit_library_call (chkr_set_right_libfunc,\n-\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n-\t\t\t\t   XEXP (copy, 0), Pmode,\n-\t\t\t\t   GEN_INT (int_size_in_bytes (type)),\n-\t\t\t\t   TYPE_MODE (sizetype),\n-\t\t\t\t   GEN_INT (MEMORY_USE_RW),\n-\t\t\t\t   TYPE_MODE (integer_type_node));\n \t      conversion_insns = get_insns ();\n \t      did_conversion = 1;\n \t      end_sequence ();\n@@ -5000,20 +4984,7 @@ assign_parms (fndecl)\n \t\temit_move_insn (validize_mem (stack_parm),\n \t\t\t\tvalidize_mem (entry_parm));\n \t    }\n-\t  if (current_function_check_memory_usage)\n-\t    {\n-\t      push_to_sequence (conversion_insns);\n-\t      emit_library_call (chkr_set_right_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t\t\t VOIDmode, 3, XEXP (stack_parm, 0), Pmode,\n-\t\t\t\t GEN_INT (GET_MODE_SIZE (GET_MODE\n-\t\t\t\t\t\t\t (entry_parm))),\n-\t\t\t\t TYPE_MODE (sizetype),\n-\t\t\t\t GEN_INT (MEMORY_USE_RW),\n-\t\t\t\t TYPE_MODE (integer_type_node));\n \n-\t      conversion_insns = get_insns ();\n-\t      end_sequence ();\n-\t    }\n \t  SET_DECL_RTL (parm, stack_parm);\n \t}\n \n@@ -5074,7 +5045,7 @@ assign_parms (fndecl)\n     = (stack_args_size.var == 0 ? GEN_INT (-stack_args_size.constant)\n        : expand_expr (size_diffop (stack_args_size.var,\n \t\t\t\t   size_int (-stack_args_size.constant)),\n-\t\t      NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_BAD));\n+\t\t      NULL_RTX, VOIDmode, 0);\n #else\n   current_function_arg_offset_rtx = ARGS_SIZE_RTX (stack_args_size);\n #endif\n@@ -6352,8 +6323,7 @@ expand_pending_sizes (pending_sizes)\n   /* Evaluate now the sizes of any types declared among the arguments.  */\n   for (tem = pending_sizes; tem; tem = TREE_CHAIN (tem))\n     {\n-      expand_expr (TREE_VALUE (tem), const0_rtx, VOIDmode,\n-\t\t   EXPAND_MEMORY_USE_BAD);\n+      expand_expr (TREE_VALUE (tem), const0_rtx, VOIDmode, 0);\n       /* Flush the queue in case this parameter declaration has\n \t side-effects.  */\n       emit_queue ();\n@@ -6378,11 +6348,6 @@ expand_function_start (subr, parms_have_cleanups)\n      valid operands of arithmetic insns.  */\n   init_recog_no_volatile ();\n \n-  /* Set this before generating any memory accesses.  */\n-  current_function_check_memory_usage\n-    = (flag_check_memory_usage\n-       && ! DECL_NO_CHECK_MEMORY_USAGE (current_function_decl));\n-\n   current_function_instrument_entry_exit\n     = (flag_instrument_function_entry_exit\n        && ! DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (subr));"}, {"sha": "111949ddb4c79f549065147f3fdc585f3c6f51d4", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -434,9 +434,6 @@ struct function\n      generated.  */\n   unsigned int instrument_entry_exit : 1;\n \n-  /* Nonzero if memory access checking be enabled in the current function.  */\n-  unsigned int check_memory_usage : 1;\n-\n   /* Nonzero if stack limit checking should be enabled in the current\n      function.  */\n   unsigned int limit_stack : 1;\n@@ -507,7 +504,6 @@ extern int virtuals_instantiated;\n #define current_function_internal_arg_pointer (cfun->internal_arg_pointer)\n #define current_function_return_rtx (cfun->return_rtx)\n #define current_function_instrument_entry_exit (cfun->instrument_entry_exit)\n-#define current_function_check_memory_usage (cfun->check_memory_usage)\n #define current_function_limit_stack (cfun->limit_stack)\n #define current_function_uses_pic_offset_table (cfun->uses_pic_offset_table)\n #define current_function_uses_const_pool (cfun->uses_const_pool)"}, {"sha": "59e594e801e2529be4d4218e6cbb3432d1e76372", "filename": "gcc/libfuncs.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Flibfuncs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Flibfuncs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibfuncs.h?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -139,12 +139,6 @@ enum libfunc_index\n   LTI_fixunstfdi,\n   LTI_fixunstfti,\n \n-  LTI_chkr_check_addr,\n-  LTI_chkr_set_right,\n-  LTI_chkr_copy_bitmap,\n-  LTI_chkr_check_exec,\n-  LTI_chkr_check_str,\n-\n   LTI_profile_function_entry,\n   LTI_profile_function_exit,\n \n@@ -272,12 +266,6 @@ extern rtx libfunc_table[LTI_MAX];\n #define fixunstfdi_libfunc\t(libfunc_table[LTI_fixunstfdi])\n #define fixunstfti_libfunc\t(libfunc_table[LTI_fixunstfti])\n \n-#define chkr_check_addr_libfunc\t(libfunc_table[LTI_chkr_check_addr])\n-#define chkr_set_right_libfunc\t(libfunc_table[LTI_chkr_set_right])\n-#define chkr_copy_bitmap_libfunc\t(libfunc_table[LTI_chkr_copy_bitmap])\n-#define chkr_check_exec_libfunc\t(libfunc_table[LTI_chkr_check_exec])\n-#define chkr_check_str_libfunc\t(libfunc_table[LTI_chkr_check_str])\n-\n #define profile_function_entry_libfunc\t(libfunc_table[LTI_profile_function_entry])\n #define profile_function_exit_libfunc\t(libfunc_table[LTI_profile_function_exit])\n "}, {"sha": "8d51a2c04bbc0b03f45034fb43445790ef93f6b1", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -712,11 +712,6 @@ expand_computed_goto (exp)\n #endif\n \n   emit_queue ();\n-  /* Be sure the function is executable.  */\n-  if (current_function_check_memory_usage)\n-    emit_library_call (chkr_check_exec_libfunc, LCT_CONST_MAKE_BLOCK,\n-\t\t       VOIDmode, 1, x, ptr_mode);\n-\n   do_pending_stack_adjust ();\n   emit_indirect_jump (x);\n \n@@ -1290,12 +1285,6 @@ void\n expand_asm (body)\n      tree body;\n {\n-  if (current_function_check_memory_usage)\n-    {\n-      error (\"`asm' cannot be used in function where memory usage is checked\");\n-      return;\n-    }\n-\n   if (TREE_CODE (body) == ADDR_EXPR)\n     body = TREE_OPERAND (body, 0);\n \n@@ -1503,12 +1492,6 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   if (noutputs == 0)\n     vol = 1;\n \n-  if (current_function_check_memory_usage)\n-    {\n-      error (\"`asm' cannot be used in function where memory usage is checked\");\n-      return;\n-    }\n-\n   if (! check_operand_nalternatives (outputs, inputs))\n     return;\n \n@@ -1591,7 +1574,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n \t  output_rtx[i]\n \t    = expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode,\n-\t\t\t   EXPAND_MEMORY_USE_WO);\n+\t\t\t   EXPAND_WRITE);\n \n \t  if (! allows_reg && GET_CODE (output_rtx[i]) != MEM)\n \t    error (\"output number %d not directly addressable\", i);\n@@ -3987,9 +3970,7 @@ expand_decl (decl)\n \t   && !(flag_float_store\n \t\t&& TREE_CODE (type) == REAL_TYPE)\n \t   && ! TREE_THIS_VOLATILE (decl)\n-\t   && (DECL_REGISTER (decl) || optimize)\n-\t   /* if -fcheck-memory-usage, check all variables.  */\n-\t   && ! current_function_check_memory_usage)\n+\t   && (DECL_REGISTER (decl) || optimize))\n     {\n       /* Automatic variable that can go in a register.  */\n       int unsignedp = TREE_UNSIGNED (type);"}, {"sha": "5680275d00b215779edcbe7c78078c091dfda86c", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -828,16 +828,6 @@ int flag_stack_check;\n    the support provided depends on the backend.  */\n rtx stack_limit_rtx;\n \n-/* -fcheck-memory-usage causes extra code to be generated in order to check\n-   memory accesses.  This is used by a detector of bad memory accesses such\n-   as Checker.  */\n-int flag_check_memory_usage = 0;\n-\n-/* -fprefix-function-name causes function name to be prefixed.  This\n-   can be used with -fcheck-memory-usage to isolate code compiled with\n-   -fcheck-memory-usage.  */\n-int flag_prefix_function_name = 0;\n-\n /* 0 if pointer arguments may alias each other.  True in C.\n    1 if pointer arguments may not alias each other but may alias\n    global variables.\n@@ -1137,10 +1127,6 @@ lang_independent_options f_options[] =\n    N_(\"Attempt to merge identical constants accross compilation units\") },\n   {\"merge-all-constants\", &flag_merge_constants, 2,\n    N_(\"Attempt to merge identical constants and constant variables\") },\n-  {\"check-memory-usage\", &flag_check_memory_usage, 1,\n-   N_(\"Generate code to check every memory access\") },\n-  {\"prefix-function-name\", &flag_prefix_function_name, 1,\n-   N_(\"Add a prefix to all function names\") },\n   {\"dump-unnumbered\", &flag_dump_unnumbered, 1,\n    N_(\"Suppress output of instruction numbers and line number notes in debugging dumps\") },\n   {\"instrument-functions\", &flag_instrument_function_entry_exit, 1,\n@@ -4815,10 +4801,6 @@ parse_options_and_default_flags (argc, argv)\n static void\n process_options ()\n {\n-  /* Checker uses the frame pointer.  */\n-  if (flag_check_memory_usage)\n-    flag_omit_frame_pointer = 0;\n-\n   if (optimize == 0)\n     {\n       /* Inlining does not work if not optimizing,"}, {"sha": "ce2bcb9b7a784a5297def440fc5e5f9ea2f817fc", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -1676,11 +1676,6 @@ struct tree_type\n #define DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->decl.no_instrument_function_entry_exit)\n \n-/* Used in FUNCTION_DECLs to indicate that check-memory-usage should be\n-   disabled in this function.  */\n-#define DECL_NO_CHECK_MEMORY_USAGE(NODE) \\\n-  (FUNCTION_DECL_CHECK (NODE)->decl.no_check_memory_usage)\n-\n /* Used in FUNCTION_DECLs to indicate that limit-stack-* should be\n    disabled in this function.  */\n #define DECL_NO_LIMIT_STACK(NODE) \\\n@@ -1756,18 +1751,17 @@ struct tree_decl\n \n   unsigned non_addr_const_p : 1;\n   unsigned no_instrument_function_entry_exit : 1;\n-  unsigned no_check_memory_usage : 1;\n   unsigned comdat_flag : 1;\n   unsigned malloc_flag : 1;\n   unsigned no_limit_stack : 1;\n   ENUM_BITFIELD(built_in_class) built_in_class : 2;\n-\n   unsigned pure_flag : 1;\n+\n   unsigned pointer_depth : 2;\n   unsigned non_addressable : 1;\n   unsigned user_align : 1;\n   unsigned uninlinable : 1;\n-  /* Two unused bits.  */\n+  /* Three unused bits.  */\n \n   unsigned lang_flag_0 : 1;\n   unsigned lang_flag_1 : 1;"}, {"sha": "572641c5cfe40112acb514746b5b6bff3dacf16e", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a08a298f85099eda5290d250c95eaf707e6c6f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=37a08a298f85099eda5290d250c95eaf707e6c6f", "patch": "@@ -61,10 +61,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define ASM_STABS_OP \"\\t.stabs\\t\"\n #endif\n \n-/* Define the prefix to use when check_memory_usage_flag is enable.  */\n-#define CHKR_PREFIX \"_CHKR_\"\n-#define CHKR_PREFIX_SIZE (sizeof (CHKR_PREFIX) - 1)\n-\n /* The (assembler) name of the first globally-visible object output.  */\n const char *first_global_object_name;\n const char *weak_global_object_name;\n@@ -957,25 +953,12 @@ make_decl_rtl (decl, asmspec)\n       && name == IDENTIFIER_POINTER (DECL_NAME (decl)))\n     {\n       char *label;\n+\n       ASM_FORMAT_PRIVATE_NAME (label, name, var_labelno);\n       var_labelno++;\n       new_name = label;\n     }\n \n-  /* When -fprefix-function-name is used, the functions\n-     names are prefixed.  Only nested function names are not\n-     prefixed.  */\n-  else if (flag_prefix_function_name && TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      size_t name_len = IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (decl));\n-      char *pname;\n-\n-      pname = alloca (name_len + CHKR_PREFIX_SIZE + 1);\n-      memcpy (pname, CHKR_PREFIX, CHKR_PREFIX_SIZE);\n-      memcpy (pname + CHKR_PREFIX_SIZE, name, name_len + 1);\n-      new_name = pname;\n-    }\n-\n   if (name != new_name)\n     {\n       SET_DECL_ASSEMBLER_NAME (decl, get_identifier (new_name));\n@@ -1837,9 +1820,6 @@ assemble_name (file, name)\n   tree id;\n \n   STRIP_NAME_ENCODING (real_name, name);\n-  if (flag_prefix_function_name\n-      && ! memcmp (real_name, CHKR_PREFIX, CHKR_PREFIX_SIZE))\n-    real_name = real_name + CHKR_PREFIX_SIZE;\n \n   id = maybe_get_identifier (real_name);\n   if (id)"}]}