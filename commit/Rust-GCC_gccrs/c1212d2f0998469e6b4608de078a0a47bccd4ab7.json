{"sha": "c1212d2f0998469e6b4608de078a0a47bccd4ab7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEyMTJkMmYwOTk4NDY5ZTZiNDYwOGRlMDc4YTBhNDdiY2NkNGFiNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-02-06T23:46:18Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-02-06T23:46:18Z"}, "message": "cpplib.c (my_strerror, [...]): Move to cpperror.c.\n\n\t* cpplib.c (my_strerror, cpp_error, cpp_error_with_line,\n\tcpp_error_from_errno, cpp_warning, cpp_warning_with_line,\n\tcpp_pedwarn, cpp_pedwarn_with_line,\n\tcpp_pedwarn_with_file_and_line): Move to cpperror.c.\n\t(cpp_print_file_and_line, v_cpp_error, v_cpp_warning,\n\tv_cpp_error_with_line, v_cpp_warning_with_line,\n\tcpp_message_from_errno, cpp_perror_with_name): Delete.\n\n\t* cpperror.c (cpp_print_containing_files): Take starting\n\tbuffer as argument.\n\t(cpp_file_line_for_message): Rename to cpp_print_file_and_line.\n\t(v_cpp_message): Now called directly by all entry points.\n\tRemove -1 case.\n\t(cpp_pfatal_with_name, cpp_message): Delete.\n\t(cpp_notice_from_errno, cpp_ice): New functions.\n\t(cpp_notice): Is now for reporting error conditions, just\n\twithout an associated file.\n\t(cpp_error, cpp_error_with_line): Don't do anything if\n\topts->inhibit_errors is on.\n\t(cpp_pedwarn_with_file_and_line): Take column argument also.\n\n\t* cpplib.h: Update prototypes of exported functions.\n\t(struct cpp_options): Add inhibit_errors.\n\n\t* cppalloc.c, cppfiles.c: Use fprintf not cpp_notice for\n\tnon-error messages.  Include intl.h.\n\n\t* cppinit.c, cppmain.c: Likewise.  Also, use\n\tcpp_notice_from_errno instead of cpp_perror_with_name or\n\tcpp_pfatal_with_name, and cpp_notice instead of cpp_message.\n\n\t* cppexp.c, cpphash.c, cppinit.c, cpplib.c: Use cpp_ice to\n\treport internal errors.\n\n\t* cpplib.c (do_define): Switch bcopy to memcpy.\n\tGive cpp_pedwarn_with_file_and_line a dummy column argument.\n\nFrom-SVN: r31829", "tree": {"sha": "894892747a145534ab3a2d2ae699861344cb8913", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/894892747a145534ab3a2d2ae699861344cb8913"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1212d2f0998469e6b4608de078a0a47bccd4ab7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1212d2f0998469e6b4608de078a0a47bccd4ab7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1212d2f0998469e6b4608de078a0a47bccd4ab7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1212d2f0998469e6b4608de078a0a47bccd4ab7/comments", "author": null, "committer": null, "parents": [{"sha": "25e309705ac7405b86e15bc4db7e58b7febdfdc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e309705ac7405b86e15bc4db7e58b7febdfdc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e309705ac7405b86e15bc4db7e58b7febdfdc2"}], "stats": {"total": 963, "additions": 468, "deletions": 495}, "files": [{"sha": "6977d80f7772ad2a142cfce8f5e6197096d44582", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1212d2f0998469e6b4608de078a0a47bccd4ab7", "patch": "@@ -1,5 +1,42 @@\n 2000-02-06  Zack Weinberg  <zack@wolery.cumb.org>\n \n+\t* cpplib.c (my_strerror, cpp_error, cpp_error_with_line,\n+\tcpp_error_from_errno, cpp_warning, cpp_warning_with_line,\n+\tcpp_pedwarn, cpp_pedwarn_with_line,\n+\tcpp_pedwarn_with_file_and_line): Move to cpperror.c.\n+\t(cpp_print_file_and_line, v_cpp_error, v_cpp_warning,\n+\tv_cpp_error_with_line, v_cpp_warning_with_line,\n+\tcpp_message_from_errno, cpp_perror_with_name): Delete.\n+\n+\t* cpperror.c (cpp_print_containing_files): Take starting\n+\tbuffer as argument.\n+\t(cpp_file_line_for_message): Rename to cpp_print_file_and_line.\n+\t(v_cpp_message): Now called directly by all entry points.\n+\tRemove -1 case.\n+\t(cpp_pfatal_with_name, cpp_message): Delete.\n+\t(cpp_notice_from_errno, cpp_ice): New functions.\n+\t(cpp_notice): Is now for reporting error conditions, just\n+\twithout an associated file.\n+\t(cpp_error, cpp_error_with_line): Don't do anything if\n+\topts->inhibit_errors is on.\n+\t(cpp_pedwarn_with_file_and_line): Take column argument also.\n+\n+\t* cpplib.h: Update prototypes of exported functions.\n+\t(struct cpp_options): Add inhibit_errors.\n+\n+\t* cppalloc.c, cppfiles.c: Use fprintf not cpp_notice for\n+\tnon-error messages.  Include intl.h.\n+\n+\t* cppinit.c, cppmain.c: Likewise.  Also, use\n+\tcpp_notice_from_errno instead of cpp_perror_with_name or\n+\tcpp_pfatal_with_name, and cpp_notice instead of cpp_message.\n+\n+\t* cppexp.c, cpphash.c, cppinit.c, cpplib.c: Use cpp_ice to\n+\treport internal errors.\n+\n+\t* cpplib.c (do_define): Switch bcopy to memcpy.\n+\tGive cpp_pedwarn_with_file_and_line a dummy column argument.\n+\n \t* cpplib.c (copy_rest_of_line): Revert previous change: don't\n \tbail out early if we hit a line comment.\n "}, {"sha": "57d43eb2798d9331b6f9a9b7e0a9866fa88a3af4", "filename": "gcc/cppalloc.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcppalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcppalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppalloc.c?ref=c1212d2f0998469e6b4608de078a0a47bccd4ab7", "patch": "@@ -26,13 +26,14 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n+#include \"intl.h\"\n \n static void memory_full PARAMS ((void)) ATTRIBUTE_NORETURN;\n \n static void\n memory_full ()\n {\n-  cpp_notice (\"%s: Memory exhausted.\\n\", progname);\n+  fprintf (stderr, _(\"%s: virtual memory exhausted\\n\"), progname);\n   exit (FATAL_EXIT_CODE);\n }\n "}, {"sha": "228eb6e01efb20440ed99bc995a99543e04cbbd3", "filename": "gcc/cpperror.c", "status": "modified", "additions": 336, "deletions": 67, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=c1212d2f0998469e6b4608de078a0a47bccd4ab7", "patch": "@@ -28,81 +28,142 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"intl.h\"\n \n+static const char *my_strerror\t\tPARAMS ((int));\n+static void cpp_print_containing_files\tPARAMS ((cpp_reader *, cpp_buffer *));\n+static void cpp_print_file_and_line\tPARAMS ((const char *, long, long));\n+static void v_cpp_message\t\tPARAMS ((cpp_reader *, int,\n+\t\t\t\t\t\t const char *, long, long,\n+\t\t\t\t\t\t const char *, va_list));\n+\n+/* my_strerror - return the descriptive text associated with an\n+   `errno' code.\n+   XXX - link with libiberty so we can use its strerror().  */\n+\n+static const char *\n+my_strerror (errnum)\n+     int errnum;\n+{\n+  const char *result;\n+\n+#ifndef VMS\n+#ifndef HAVE_STRERROR\n+  result = (char *) ((errnum < sys_nerr) ? sys_errlist[errnum] : 0);\n+#else\n+  result = strerror (errnum);\n+#endif\n+#else\t/* VMS */\n+  /* VAXCRTL's strerror() takes an optional second argument, which only\n+     matters when the first argument is EVMSERR.  However, it's simplest\n+     just to pass it unconditionally.  `vaxc$errno' is declared in\n+     <errno.h>, and maintained by the library in parallel with `errno'.\n+     We assume that caller's `errnum' either matches the last setting of\n+     `errno' by the library or else does not have the value `EVMSERR'.  */\n+\n+  result = strerror (errnum, vaxc$errno);\n+#endif\n+\n+  if (!result)\n+    result = \"errno = ?\";\n+\n+  return result;\n+}\n+\n /* Print the file names and line numbers of the #include\n    commands which led to the current file.  */\n \n-void\n-cpp_print_containing_files (pfile)\n+static void\n+cpp_print_containing_files (pfile, ip)\n      cpp_reader *pfile;\n+     cpp_buffer *ip;\n {\n-  cpp_buffer *ip;\n   int first = 1;\n \n   /* If stack of files hasn't changed since we last printed\n      this info, don't repeat it.  */\n   if (pfile->input_stack_listing_current)\n     return;\n \n-  ip = cpp_file_buffer (pfile);\n+  /* Find the other, outer source files.  */\n+  for (ip = CPP_PREV_BUFFER (ip);\n+       ip != CPP_NULL_BUFFER (pfile);\n+       ip = CPP_PREV_BUFFER (ip))\n+    if (ip->fname != NULL)\n+      {\n+\tlong line;\n+\tcpp_buf_line_and_col (ip, &line, NULL);\n+\tif (first)\n+\t  {\n+\t    first = 0;\n+\t    fprintf (stderr,  _(\"In file included from %s:%ld\"),\n+\t\t     ip->nominal_fname, line);\n+\t  }\n+\telse\n+\t  /* Translators note: this message is used in conjunction\n+\t     with \"In file included from %s:%ld\" and some other\n+\t     tricks.  We want something like this:\n \n-  /* Give up if we don't find a source file.  */\n-  if (ip == NULL)\n-    return;\n+\t     In file included from sys/select.h:123,\n+\t                      from sys/types.h:234,\n+\t\t\t      from userfile.c:31:\n+\t     bits/select.h:45: <error message here>\n \n-  /* Find the other, outer source files.  */\n-  while ((ip = CPP_PREV_BUFFER (ip)), ip != CPP_NULL_BUFFER (pfile))\n-    {\n-      long line, col;\n-      cpp_buf_line_and_col (ip, &line, &col);\n-      if (ip->fname != NULL)\n-\t{\n-\t  if (first)\n-\t    {\n-\t      first = 0;\n-\t      cpp_message (pfile, -1, \"In file included from %s:%ld\",\n-\t\t\t   ip->nominal_fname, line);\n-\t    }\n-\t  else\n-\t    cpp_message (pfile, -1, \",\\n                 from %s:%ld\",\n-\t\t\t ip->nominal_fname, line);\n-\t}\n-    }\n-  if (! first)\n+\t     The trailing comma is at the beginning of this message,\n+\t     and the trailing colon is not translated.  */\n+\t  fprintf (stderr, _(\",\\n                 from %s:%ld\"),\n+\t\t   ip->nominal_fname, line);\n+      }\n+  if (first == 0)\n     fputs (\":\\n\", stderr);\n \n   /* Record we have printed the status as of this time.  */\n   pfile->input_stack_listing_current = 1;\n }\n \n-void\n-cpp_file_line_for_message (pfile, filename, line, column)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+static void\n+cpp_print_file_and_line (filename, line, column)\n      const char *filename;\n-     int line, column;\n+     long line, column;\n {\n   if (filename == 0 || *filename == '\\0')\n     filename = \"<stdin>\";\n-  if (line == 0)\n+  if (line <= 0)\n     fputs (_(\"<command line>: \"), stderr);\n   else if (column > 0)\n-    fprintf (stderr, \"%s:%d:%d: \", filename, line, column);\n+    fprintf (stderr, \"%s:%ld:%ld: \", filename, line, column);\n   else\n-    fprintf (stderr, \"%s:%d: \", filename, line);\n+    fprintf (stderr, \"%s:%ld: \", filename, line);\n }\n \n-/* IS_ERROR is 2 for \"fatal\" error, 1 for error, 0 for warning, -1 for notice */\n+/* IS_ERROR is 3 for ICE, 2 for merely \"fatal\" error,\n+   1 for error, 0 for warning.  */\n \n-void\n-v_cpp_message (pfile, is_error, msgid, ap)\n-  cpp_reader * pfile;\n-  int is_error;\n-  const char *msgid;\n-  va_list ap;\n+static void\n+v_cpp_message (pfile, is_error, file, line, col, msg, ap)\n+     cpp_reader *pfile;\n+     int is_error;\n+     const char *file;\n+     long line;\n+     long col;\n+     const char *msg;\n+     va_list ap;\n {\n+  cpp_buffer *ip = cpp_file_buffer (pfile);\n+\n+  if (ip)\n+    {\n+      if (file == NULL)\n+\tfile = ip->nominal_fname;\n+      if (line == -1)\n+\tcpp_buf_line_and_col (ip, &line, &col);\n+\n+      cpp_print_containing_files (pfile, ip);\n+      cpp_print_file_and_line (file, line, col);\n+    }\n+  else\n+    fprintf (stderr, \"%s: \", progname);\n+\n   switch (is_error)\n     {\n-    case -1:\n-      break;\n     case 0:\n       fprintf (stderr, _(\"warning: \"));\n       break;\n@@ -113,22 +174,28 @@ v_cpp_message (pfile, is_error, msgid, ap)\n     case 2:\n       pfile->errors = CPP_FATAL_LIMIT;\n       break;\n+    case 3:\n+      fprintf (stderr, _(\"internal error: \"));\n+      pfile->errors = CPP_FATAL_LIMIT;\n+      break;\n     default:\n-      cpp_fatal (pfile, \"internal error: bad is_error(%d) in v_cpp_message\", is_error);\n+      cpp_ice (pfile, \"bad is_error(%d) in v_cpp_message\", is_error);\n     }\n \n-  vfprintf (stderr, _(msgid), ap);\n-\n-  if (0 <= is_error)\n-    fprintf (stderr, \"\\n\");\n+  vfprintf (stderr, _(msg), ap);\n+  putc ('\\n', stderr);\n }\n \n+/* Exported interface.  */\n+\n+/* For reporting internal errors.  Prints \"internal error: \" for you,\n+   otherwise identical to cpp_fatal.  */\n+\n void\n-cpp_message VPARAMS ((cpp_reader *pfile, int is_error, const char *msgid, ...))\n-{\n+cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n+{  \n #ifndef ANSI_PROTOTYPES\n   cpp_reader *pfile;\n-  int is_error;\n   const char *msgid;\n #endif\n   va_list ap;\n@@ -137,11 +204,10 @@ cpp_message VPARAMS ((cpp_reader *pfile, int is_error, const char *msgid, ...))\n   \n #ifndef ANSI_PROTOTYPES\n   pfile = va_arg (ap, cpp_reader *);\n-  is_error = va_arg (ap, int);\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  v_cpp_message(pfile, is_error, msgid, ap);\n+  v_cpp_message (pfile, 3, NULL, -1, -1, msgid, ap);\n   va_end(ap);\n }\n \n@@ -167,42 +233,245 @@ cpp_fatal VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  fprintf (stderr, \"%s: \", progname);\n-  v_cpp_message (pfile, 2, msgid, ap);\n+  v_cpp_message (pfile, 2, NULL, -1, -1, msgid, ap);\n+  va_end(ap);\n+}\n+\n+void\n+cpp_error VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START(ap, msgid);\n+  \n+#ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  if (CPP_OPTIONS (pfile)->inhibit_errors)\n+    return;\n+\n+  v_cpp_message (pfile, 1, NULL, -1, -1, msgid, ap);\n+  va_end(ap);\n+}\n+\n+void\n+cpp_error_with_line VPARAMS ((cpp_reader *pfile, int line, int column,\n+\t\t\t     const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  int line;\n+  int column;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  \n+  VA_START (ap, msgid);\n+  \n+#ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  line = va_arg (ap, int);\n+  column = va_arg (ap, int);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  if (CPP_OPTIONS (pfile)->inhibit_errors)\n+    return;\n+\n+  v_cpp_message (pfile, 1, NULL, line, column, msgid, ap);\n   va_end(ap);\n }\n-\f\n+\n+/* Error including a message from `errno'.  */\n void\n-cpp_pfatal_with_name (pfile, name)\n+cpp_error_from_errno (pfile, name)\n      cpp_reader *pfile;\n      const char *name;\n {\n-  cpp_perror_with_name (pfile, name);\n-#ifdef VMS\n-  exit (vaxc$errno);\n-#else\n-  exit (FATAL_EXIT_CODE);\n+  cpp_error (pfile, \"%s: %s\", name, my_strerror (errno));\n+}\n+\n+void\n+cpp_warning VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  \n+  VA_START (ap, msgid);\n+  \n+#ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  msgid = va_arg (ap, const char *);\n #endif\n+\n+  if (CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+\n+  v_cpp_message (pfile, 0, NULL, -1, -1, msgid, ap);\n+  va_end(ap);\n }\n \n-/* Print an error message.  */\n+void\n+cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n+\t\t\t       const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  int line;\n+  int column;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  \n+  VA_START (ap, msgid);\n+  \n+#ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  line = va_arg (ap, int);\n+  column = va_arg (ap, int);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  if (CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+\n+  v_cpp_message (pfile, 0, NULL, line, column, msgid, ap);\n+  va_end(ap);\n+}\n \n void\n-cpp_notice VPARAMS ((const char *msgid, ...))\n-{  \n+cpp_pedwarn VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  \n+  VA_START (ap, msgid);\n+  \n+#ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  if (CPP_OPTIONS (pfile)->pedantic_errors\n+      ? CPP_OPTIONS (pfile)->inhibit_errors\n+      : CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+\n+  v_cpp_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors,\n+\t\t NULL, -1, -1, msgid, ap);\n+  va_end(ap);\n+}\n+\n+void\n+cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n+\t\t\t       const char *msgid, ...))\n+{\n #ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  int line;\n+  int column;\n   const char *msgid;\n #endif\n   va_list ap;\n   \n   VA_START (ap, msgid);\n   \n #ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  line = va_arg (ap, int);\n+  column = va_arg (ap, int);\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  fprintf (stderr, \"%s: \", progname);\n-  v_cpp_message ((cpp_reader *) 0, -1, msgid, ap);\n+  if (CPP_OPTIONS (pfile)->pedantic_errors\n+      ? CPP_OPTIONS (pfile)->inhibit_errors\n+      : CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+\n+  v_cpp_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors,\n+\t\t NULL, line, column, msgid, ap);\n   va_end(ap);\n }\n-\f\n+\n+/* Report a warning (or an error if pedantic_errors)\n+   giving specified file name and line number, not current.  */\n+\n+void\n+cpp_pedwarn_with_file_and_line VPARAMS ((cpp_reader *pfile,\n+\t\t\t\t\t const char *file, int line, int col,\n+\t\t\t\t\t const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  const char *file;\n+  int line;\n+  int col;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  \n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  file = va_arg (ap, const char *);\n+  line = va_arg (ap, int);\n+  col = va_arg (ap, int);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  if (CPP_OPTIONS (pfile)->pedantic_errors\n+      ? CPP_OPTIONS (pfile)->inhibit_errors\n+      : CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+\n+  v_cpp_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors,\n+\t\t file, line, col, msgid, ap);\n+  va_end(ap);\n+}\n+\n+/* Print an error message not associated with a file.  */\n+void\n+cpp_notice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  \n+  VA_START (ap, msgid);\n+  \n+#ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  if (pfile->errors < CPP_FATAL_LIMIT)\n+    pfile->errors++;\n+\n+  vfprintf (stderr, _(msgid), ap);\n+  putc('\\n', stderr);\n+\n+  va_end(ap);\n+}\n+\n+void\n+cpp_notice_from_errno (pfile, name)\n+     cpp_reader *pfile;\n+     const char *name;\n+{\n+  cpp_notice (pfile, \"%s: %s\", name, my_strerror (errno));\n+}"}, {"sha": "3a6ea14d2008f87dd362ad261c5adccfb1ea07a3", "filename": "gcc/cppexp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=c1212d2f0998469e6b4608de078a0a47bccd4ab7", "patch": "@@ -733,7 +733,7 @@ cpp_parse_expr (pfile)\n       switch (op.op)\n \t{\n \tcase NAME:\n-\t  cpp_fatal (pfile, \"internal error: cpp_lex returns a NAME\");\n+\t  cpp_ice (pfile, \"cpp_lex returns a NAME\");\n \t  goto syntax_error;\n \tcase INT:  case CHAR:\n \t  top->value = op.value;\n@@ -1020,7 +1020,7 @@ cpp_parse_expr (pfile)\n       if (op.op == 0)\n \t{\n \t  if (top != stack)\n-\t    cpp_error (pfile, \"internal error in #if expression\");\n+\t    cpp_ice (pfile, \"unbalanced stack in #if expression\");\n \t  if (stack != init_stack)\n \t    free (stack);\n \t  return top->value;"}, {"sha": "c5e1b18e2242d53989c55161e149616c50275b18", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=c1212d2f0998469e6b4608de078a0a47bccd4ab7", "patch": "@@ -26,6 +26,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n+#include \"intl.h\"\n \n /* The entry points to this file are: find_include_file, finclude,\n    include_hash, append_include_chain, deps_output, and file_cleanup.\n@@ -126,7 +127,8 @@ merge_include_chains (opts)\n \t    && cur->dev == other->dev)\n           {\n \t    if (opts->verbose)\n-\t      cpp_notice (\"ignoring duplicate directory `%s'\\n\", cur->name);\n+\t      fprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t\t       cur->name);\n \n \t    prev->next = cur->next;\n \t    free (cur->name);\n@@ -145,7 +147,8 @@ merge_include_chains (opts)\n \t    && cur->dev == other->dev)\n           {\n \t    if (opts->verbose)\n-\t      cpp_notice (\"ignoring duplicate directory `%s'\\n\", cur->name);\n+\t      fprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t\t       cur->name);\n \n \t    prev->next = cur->next;\n \t    free (cur->name);\n@@ -163,8 +166,8 @@ merge_include_chains (opts)\n \t  if (quote == qtail)\n \t    {\n \t      if (opts->verbose)\n-\t\tcpp_notice (\"ignoring duplicate directory `%s'\\n\",\n-\t\t\t    quote->name);\n+\t\tfprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t\t\t quote->name);\n \n \t      free (quote->name);\n \t      free (quote);\n@@ -177,8 +180,8 @@ merge_include_chains (opts)\n \t\t  cur = cur->next;\n \t      cur->next = brack;\n \t      if (opts->verbose)\n-\t\tcpp_notice (\"ignoring duplicate directory `%s'\\n\",\n-\t\t\t    qtail->name);\n+\t\tfprintf (stderr, _(\"ignoring duplicate directory `%s'\\n\"),\n+\t\t\t qtail->name);\n \n \t      free (qtail->name);\n \t      free (qtail);"}, {"sha": "9da1daa40ff983a5d31efaf141f86559b0b64357", "filename": "gcc/cpphash.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=c1212d2f0998469e6b4608de078a0a47bccd4ab7", "patch": "@@ -295,7 +295,7 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n \n   if (limit < buf)\n     {\n-      cpp_fatal (pfile, \"internal error: limit < buf in collect_expansion\");\n+      cpp_ice (pfile, \"limit < buf in collect_expansion\");\n       limit = buf; /* treat it like a null defn */\n     }\n \n@@ -974,7 +974,7 @@ special_symbol (hp, pfile)\n       break;\n \n     default:\n-      cpp_fatal (pfile, \"cpplib internal error: invalid special hash type\");\n+      cpp_ice (pfile, \"invalid special hash type\");\n       return;\n     }\n }\n@@ -1351,7 +1351,7 @@ macroexpand (pfile, hp)\n \n \t  if (totlen > xbuf_len)\n \t    {\n-\t      cpp_fatal (pfile, \"internal_error: buffer overrun in macroexpand\");\n+\t      cpp_ice (pfile, \"buffer overrun in macroexpand\");\n \t      return;\n \t    }\n \t}"}, {"sha": "6bc567c937b9b02e430beb376e33a6919faae8bd", "filename": "gcc/cppinit.c", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=c1212d2f0998469e6b4608de078a0a47bccd4ab7", "patch": "@@ -343,15 +343,15 @@ append_include_chain (pfile, pend, dir, path)\n     {\n       /* Dirs that don't exist are silently ignored. */\n       if (errno != ENOENT)\n-\tcpp_perror_with_name (pfile, dir);\n+\tcpp_notice_from_errno (pfile, dir);\n       else if (CPP_OPTIONS (pfile)->verbose)\n-\tcpp_notice (\"ignoring nonexistent directory `%s'\\n\", dir);\n+\tfprintf (stderr, _(\"ignoring nonexistent directory `%s'\\n\"), dir);\n       return;\n     }\n \n   if (!S_ISDIR (st.st_mode))\n     {\n-      cpp_message (pfile, 1, \"%s: %s: Not a directory\", progname, dir);\n+      cpp_notice (pfile, \"%s: Not a directory\", dir);\n       return;\n     }\n \n@@ -855,14 +855,14 @@ cpp_start_read (pfile, fname)\n   if (opts->verbose)\n     {\n       struct file_name_list *p;\n-      cpp_message (pfile, -1, \"#include \\\"...\\\" search starts here:\\n\");\n+      fprintf (stderr, _(\"#include \\\"...\\\" search starts here:\\n\"));\n       for (p = opts->quote_include; p; p = p->next)\n \t{\n \t  if (p == opts->bracket_include)\n-\t    cpp_message (pfile, -1, \"#include <...> search starts here:\\n\");\n+\t    fprintf (stderr, _(\"#include <...> search starts here:\\n\"));\n \t  fprintf (stderr, \" %s\\n\", p->name);\n \t}\n-      cpp_message (pfile, -1, \"End of search list.\\n\");\n+      fprintf (stderr, _(\"End of search list.\\n\"));\n     }\n \n   /* Don't bother trying to do macro expansion if we've already done\n@@ -880,7 +880,10 @@ cpp_start_read (pfile, fname)\n       f = 0;\n     }\n   else if ((f = open (fname, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666)) < 0)\n-    cpp_pfatal_with_name (pfile, fname);\n+    {\n+      cpp_notice_from_errno (pfile, fname);\n+      return 0;\n+    }\n \n   initialize_dependency_output (pfile);\n \n@@ -918,7 +921,7 @@ cpp_start_read (pfile, fname)\n       int fd = open (p->arg, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666);\n       if (fd < 0)\n \t{\n-\t  cpp_perror_with_name (pfile, p->arg);\n+\t  cpp_notice_from_errno (pfile, p->arg);\n \t  return 0;\n \t}\n       if (!cpp_push_buffer (pfile, NULL, 0))\n@@ -957,7 +960,7 @@ cpp_start_read (pfile, fname)\n       int fd = open (p->arg, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666);\n       if (fd < 0)\n \t{\n-\t  cpp_perror_with_name (pfile, p->arg);\n+\t  cpp_notice_from_errno (pfile, p->arg);\n \t  return 0;\n \t}\n       if (!cpp_push_buffer (pfile, NULL, 0))\n@@ -1004,14 +1007,13 @@ cpp_finish (pfile)\n   struct cpp_options *opts = CPP_OPTIONS (pfile);\n \n   if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != CPP_NULL_BUFFER (pfile))\n-    cpp_fatal (pfile,\n-\t       \"cpplib internal error: buffers still stacked in cpp_finish\");\n+    cpp_ice (pfile, \"buffers still stacked in cpp_finish\");\n   cpp_pop_buffer (pfile);\n-  \n+\n   if (opts->print_deps)\n     {\n       /* Stream on which to print the dependency information.  */\n-      FILE *deps_stream;\n+      FILE *deps_stream = 0;\n \n       /* Don't actually write the deps file if compilation has failed.  */\n       if (pfile->errors == 0)\n@@ -1020,13 +1022,17 @@ cpp_finish (pfile)\n \t  if (opts->deps_file == 0)\n \t    deps_stream = stdout;\n \t  else if ((deps_stream = fopen (opts->deps_file, deps_mode)) == 0)\n-\t    cpp_pfatal_with_name (pfile, opts->deps_file);\n-\t  fputs (pfile->deps_buffer, deps_stream);\n-\t  putc ('\\n', deps_stream);\n-\t  if (opts->deps_file)\n+\t    cpp_notice_from_errno (pfile, opts->deps_file);\n+\n+\t  if (deps_stream)\n \t    {\n-\t      if (ferror (deps_stream) || fclose (deps_stream) != 0)\n-\t\tcpp_fatal (pfile, \"I/O error on output\");\n+\t      fputs (pfile->deps_buffer, deps_stream);\n+\t      putc ('\\n', deps_stream);\n+\t      if (opts->deps_file)\n+\t\t{\n+\t\t  if (ferror (deps_stream) || fclose (deps_stream) != 0)\n+\t\t    cpp_fatal (pfile, \"I/O error on output\");\n+\t\t}\n \t    }\n \t}\n     }\n@@ -1487,12 +1493,12 @@ cpp_handle_option (pfile, argc, argv)\n \tif (!strcmp (argv[i], \"--help\"))\n \t  print_help ();\n \telse if (!strcmp (argv[i], \"--version\"))\n-\t  cpp_notice (\"GNU CPP version %s (cpplib)\\n\", version_string);\n+\t  fprintf (stderr, _(\"GNU CPP version %s (cpplib)\\n\"), version_string);\n \texit (0);  /* XXX */\n \tbreak;\n \t\n       case 'v':\n-\tcpp_notice (\"GNU CPP version %s (cpplib)\", version_string);\n+\tfprintf (stderr, _(\"GNU CPP version %s (cpplib)\\n\"), version_string);\n #ifdef TARGET_VERSION\n \tTARGET_VERSION;\n #endif\n@@ -1673,7 +1679,7 @@ cpp_handle_options (pfile, argc, argv)\n static void\n print_help ()\n {\n-  cpp_notice (\"Usage: %s [switches] input output\\n\", progname);\n+  fprintf (stderr, _(\"Usage: %s [switches] input output\\n\"), progname);\n   fputs (_(\"\\\n Switches:\\n\\\n   -include <file>           Include the contents of <file> before other files\\n\\"}, {"sha": "f031c958a228158485eaadcf0067b949191c9d97", "filename": "gcc/cpplib.c", "status": "modified", "additions": 18, "deletions": 367, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=c1212d2f0998469e6b4608de078a0a47bccd4ab7", "patch": "@@ -74,7 +74,6 @@ static int do_warning PARAMS ((cpp_reader *, const struct directive *));\n \n /* Forward declarations.  */\n \n-static const char *my_strerror\t\tPARAMS ((int));\n static void validate_else\t\tPARAMS ((cpp_reader *, const char *));\n static HOST_WIDEST_INT eval_if_expression PARAMS ((cpp_reader *));\n static void conditional_skip\t\tPARAMS ((cpp_reader *, int,\n@@ -96,15 +95,6 @@ static void pass_thru_directive\t\tPARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t\t const struct directive *));\n static enum cpp_token get_directive_token PARAMS ((cpp_reader *));\n static int read_line_number\t\tPARAMS ((cpp_reader *, int *));\n-static void cpp_print_file_and_line\tPARAMS ((cpp_reader *));\n-static void v_cpp_error\t\t\tPARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\t\t va_list));\n-static void v_cpp_warning\t\tPARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\t\t va_list));\n-static void v_cpp_error_with_line\tPARAMS ((cpp_reader *, int, int,\n-\t\t\t\t\t\t const char *, va_list));\n-static void v_cpp_warning_with_line\tPARAMS ((cpp_reader *, int, int,\n-\t\t\t\t\t\t const char *, va_list));\n static U_CHAR *detect_if_not_defined\tPARAMS ((cpp_reader *));\n static int consider_directive_while_skipping PARAMS ((cpp_reader *,\n \t\t\t\t\t\t      IF_STACK_FRAME *));\n@@ -551,8 +541,8 @@ handle_directive (pfile)\n   if (ident_length == 0)\n     {\n       /* A line of just `#' becomes blank.  A line with something\n-         other than an identifier after the # is reparsed as a non-\n-         directive line.  */\n+\t other than an identifier after the # is reparsed as a non-\n+\t directive line.  */\n       CPP_SET_WRITTEN (pfile, old_written);\n       return (PEEKC() == '\\n');\n     }\n@@ -661,7 +651,7 @@ do_define (pfile, keyword)\n   buf = pfile->token_buffer + here;\n   end = CPP_PWRITTEN (pfile);\n   macro = (U_CHAR *) alloca (end - buf + 1);\n-  bcopy (buf, macro, end - buf + 1);\n+  memcpy (macro, buf, end - buf + 1);\n   end = macro + (end - buf);\n \n   CPP_SET_WRITTEN (pfile, here);\n@@ -697,7 +687,7 @@ do_define (pfile, keyword)\n \t    cpp_pedwarn (pfile, \"`%.*s' redefined\", mdef.symlen, mdef.symnam);\n \t  if (hp->type == T_MACRO && CPP_OPTIONS (pfile)->done_initializing)\n \t    cpp_pedwarn_with_file_and_line (pfile, hp->value.defn->file,\n-\t\t\t\t\t    hp->value.defn->line,\n+\t\t\t\t\t    hp->value.defn->line, -1,\n \t\t\t\"this is the location of the previous definition\");\n \t}\n       if (hp->type != T_POISON)\n@@ -838,7 +828,7 @@ cpp_expand_to_buffer (pfile, buf, length)\n \n   if (length < 0)\n     {\n-      cpp_fatal (pfile, \"internal error: length < 0 in cpp_expand_to_buffer\");\n+      cpp_ice (pfile, \"length < 0 in cpp_expand_to_buffer\");\n       return;\n     }\n \n@@ -1000,7 +990,7 @@ get_directive_token (pfile)\n       /* token cannot be vspace, it would have been caught above.  */\n       if (token == CPP_VSPACE)\n \t{\n-\t  cpp_fatal (pfile, \"VSPACE in get_directive_token\");\n+\t  cpp_ice (pfile, \"VSPACE in get_directive_token\");\n \t  return token;\n \t}\n \n@@ -1010,12 +1000,12 @@ get_directive_token (pfile)\n \n       if (! CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n \t{\n-\t  cpp_fatal (pfile, \"POP of file buffer in get_directive_token\");\n+\t  cpp_ice (pfile, \"POP of file buffer in get_directive_token\");\n \t  return token;\n \t}\n \n-      /* We must pop the buffer by hand, else cpp_get_token might hand\n-\t us whitespace or newline on the next invocation.  */\n+      /* We must pop the buffer by hand, or else cpp_get_token might\n+\t hand us white space or newline on the next invocation.  */\n       cpp_pop_buffer (pfile);\n     }\n }\n@@ -1145,7 +1135,7 @@ do_include (pfile, keyword)\n \n   if (fp == CPP_NULL_BUFFER (pfile))\n     {\n-      cpp_fatal (pfile, \"cpp internal error: fp == NULL_BUFFER in do_include\");\n+      cpp_ice (pfile, \"fp == NULL_BUFFER in do_include\");\n       return 0;\n     }\n   \n@@ -2253,7 +2243,7 @@ if_directive_name (pfile, ifs)\n     case T_ELIF:    return \"#elif\";\n     case T_ELSE:    return \"#else\";\n     default:\n-      cpp_fatal (pfile, \"impossible if_stack->type value %d\", ifs->type);\n+      cpp_ice (pfile, \"impossible if_stack->type value %d\", ifs->type);\n       return \"unknown\";\n     }\n }\n@@ -2448,9 +2438,7 @@ cpp_get_token (pfile)\n \t\t\t     here.  Just delete 'em. */\n \t\t\t  int d = GETC();\n \t\t\t  if (d != '-' && d != ' ')\n-\t\t\t    cpp_fatal (pfile,\n-\t\t\t\t  \"internal error: unrecognized escape \\\\r%c\",\n-\t\t\t\t       d);\n+\t\t\t    cpp_ice (pfile, \"unrecognized escape \\\\r%c\", d);\n \t\t\t  CPP_ADJUST_WRITTEN (pfile, -1);\n \t\t\t}\t\t\t  \n \t\t    }\n@@ -2707,8 +2695,7 @@ cpp_get_token (pfile)\n \t\t}\n \t      else\n \t\t{\n-\t\t  cpp_fatal (pfile,\n-\t\t\t     \"internal error: unrecognized escape \\\\r%c\", c);\n+\t\t  cpp_ice (pfile, \"unrecognized escape \\\\r%c\", c);\n \t\t  goto get_next;\n \t\t}\n \t    }\n@@ -2868,8 +2855,7 @@ parse_string (pfile, c)\n \t  CPP_ADJUST_WRITTEN (pfile, -1);\n \t  if (CPP_BUFFER (pfile)->has_escapes)\n \t    {\n-\t      cpp_fatal (pfile,\n-\t\t\t \"internal error: \\\\r escape inside string constant\");\n+\t      cpp_ice (pfile, \"\\\\r escape inside string constant\");\n \t      FORWARD(1);\n \t    }\n \t  else\n@@ -3015,8 +3001,7 @@ do_assert (pfile, keyword)\n   else if (base->type != T_ASSERT)\n   {\n     /* Token clash - but with what?! */\n-    cpp_fatal (pfile,\n-\t       \"cpp internal error: base->type != T_ASSERT in do_assert\");\n+    cpp_ice (pfile, \"base->type != T_ASSERT in do_assert\");\n     goto error;\n   }\n \n@@ -3145,8 +3130,7 @@ parse_set_mark (pfile)\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n   if (ip->mark != -1)\n-      cpp_fatal (pfile,\n-\t\t \"cpp internal error: ip->mark != -1 in parse_set_mark\");\n+      cpp_ice (pfile, \"ip->mark != -1 in parse_set_mark\");\n \n   ip->mark = ip->cur - ip->buf;\n }\n@@ -3159,8 +3143,7 @@ parse_clear_mark (pfile)\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n   if (ip->mark == -1)\n-      cpp_fatal (pfile,\n-\t\t \"cpp internal error: ip->mark == -1 in parse_clear_mark\");\n+      cpp_ice (pfile, \"ip->mark == -1 in parse_clear_mark\");\n \n   ip->mark = -1;\n }\n@@ -3174,340 +3157,8 @@ parse_goto_mark (pfile)\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n   if (ip->mark == -1)\n-      cpp_fatal (pfile,\n-\t\t \"cpp internal error: ip->mark == -1 in parse_goto_mark\");\n+      cpp_ice (pfile, \"ip->mark == -1 in parse_goto_mark\");\n \n   ip->cur = ip->buf + ip->mark;\n   ip->mark = -1;\n }\n-\n-static void\n-cpp_print_file_and_line (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *ip = cpp_file_buffer (pfile);\n-\n-  if (ip != NULL)\n-    {\n-      long line, col;\n-      cpp_buf_line_and_col (ip, &line, &col);\n-      cpp_file_line_for_message (pfile, ip->nominal_fname,\n-\t\t\t\t line, pfile->show_column ? col : -1);\n-    }\n-}\n-\n-static void\n-v_cpp_error (pfile, msgid, ap)\n-  cpp_reader *pfile;\n-  const char *msgid;\n-  va_list ap;\n-{\n-  cpp_print_containing_files (pfile);\n-  cpp_print_file_and_line (pfile);\n-  v_cpp_message (pfile, 1, msgid, ap);\n-}\n-\n-void\n-cpp_error VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START(ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_cpp_error (pfile, msgid, ap);\n-  va_end(ap);\n-}\n-\n-/* Print error message but don't count it.  */\n-\n-static void\n-v_cpp_warning (pfile, msgid, ap)\n-  cpp_reader *pfile;\n-  const char *msgid;\n-  va_list ap;\n-{\n-  if (CPP_OPTIONS (pfile)->inhibit_warnings)\n-    return;\n-\n-  if (CPP_OPTIONS (pfile)->warnings_are_errors)\n-    pfile->errors++;\n-\n-  cpp_print_containing_files (pfile);\n-  cpp_print_file_and_line (pfile);\n-  v_cpp_message (pfile, 0, msgid, ap);\n-}\n-\n-void\n-cpp_warning VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_cpp_warning (pfile, msgid, ap);\n-  va_end(ap);\n-}\n-\n-/* Print an error message and maybe count it.  */\n-\n-void\n-cpp_pedwarn VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  if (CPP_OPTIONS (pfile)->pedantic_errors)\n-    v_cpp_error (pfile, msgid, ap);\n-  else\n-    v_cpp_warning (pfile, msgid, ap);\n-  va_end(ap);\n-}\n-\n-static void\n-v_cpp_error_with_line (pfile, line, column, msgid, ap)\n-  cpp_reader * pfile;\n-  int line;\n-  int column;\n-  const char * msgid;\n-  va_list ap;\n-{\n-  cpp_buffer *ip = cpp_file_buffer (pfile);\n-\n-  cpp_print_containing_files (pfile);\n-\n-  if (ip != NULL)\n-    cpp_file_line_for_message (pfile, ip->nominal_fname, line, column);\n-\n-  v_cpp_message (pfile, 1, msgid, ap);\n-}\n-\n-void\n-cpp_error_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n-\t\t\t     const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  int line;\n-  int column;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  line = va_arg (ap, int);\n-  column = va_arg (ap, int);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_cpp_error_with_line(pfile, line, column, msgid, ap);\n-  va_end(ap);\n-}\n-\n-static void\n-v_cpp_warning_with_line (pfile, line, column, msgid, ap)\n-  cpp_reader * pfile;\n-  int line;\n-  int column;\n-  const char *msgid;\n-  va_list ap;\n-{\n-  cpp_buffer *ip;\n-\n-  if (CPP_OPTIONS (pfile)->inhibit_warnings)\n-    return;\n-\n-  if (CPP_OPTIONS (pfile)->warnings_are_errors)\n-    pfile->errors++;\n-\n-  cpp_print_containing_files (pfile);\n-\n-  ip = cpp_file_buffer (pfile);\n-\n-  if (ip != NULL)\n-    cpp_file_line_for_message (pfile, ip->nominal_fname, line, column);\n-\n-  v_cpp_message (pfile, 0, msgid, ap);\n-}  \n-\n-void\n-cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n-\t\t\t       const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  int line;\n-  int column;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  line = va_arg (ap, int);\n-  column = va_arg (ap, int);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  v_cpp_warning_with_line (pfile, line, column, msgid, ap);\n-  va_end(ap);\n-}\n-\n-void\n-cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n-\t\t\t       const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  int line;\n-  int column;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  line = va_arg (ap, int);\n-  column = va_arg (ap, int);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  if (CPP_OPTIONS (pfile)->pedantic_errors)\n-    v_cpp_error_with_line (pfile, column, line, msgid, ap);\n-  else\n-    v_cpp_warning_with_line (pfile, line, column, msgid, ap);\n-  va_end(ap);\n-}\n-\n-/* Report a warning (or an error if pedantic_errors)\n-   giving specified file name and line number, not current.  */\n-\n-void\n-cpp_pedwarn_with_file_and_line VPARAMS ((cpp_reader *pfile, const char *file,\n-\t\t\t\t\tint line, const char *msgid, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  const char *file;\n-  int line;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-\n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  file = va_arg (ap, const char *);\n-  line = va_arg (ap, int);\n-  msgid = va_arg (ap, const char *);\n-#endif\n-\n-  if (!CPP_OPTIONS (pfile)->pedantic_errors\n-      && CPP_OPTIONS (pfile)->inhibit_warnings)\n-    return;\n-  cpp_file_line_for_message (pfile, file, line, -1);\n-  v_cpp_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors, msgid, ap);\n-  va_end(ap);\n-}\n-\n-/* my_strerror - return the descriptive text associated with an\n-   `errno' code.  */\n-\n-static const char *\n-my_strerror (errnum)\n-     int errnum;\n-{\n-  const char *result;\n-\n-#ifndef VMS\n-#ifndef HAVE_STRERROR\n-  result = (char *) ((errnum < sys_nerr) ? sys_errlist[errnum] : 0);\n-#else\n-  result = strerror (errnum);\n-#endif\n-#else\t/* VMS */\n-  /* VAXCRTL's strerror() takes an optional second argument, which only\n-     matters when the first argument is EVMSERR.  However, it's simplest\n-     just to pass it unconditionally.  `vaxc$errno' is declared in\n-     <errno.h>, and maintained by the library in parallel with `errno'.\n-     We assume that caller's `errnum' either matches the last setting of\n-     `errno' by the library or else does not have the value `EVMSERR'.  */\n-\n-  result = strerror (errnum, vaxc$errno);\n-#endif\n-\n-  if (!result)\n-    result = \"errno = ?\";\n-\n-  return result;\n-}\n-\n-/* Error including a message from `errno'.  */\n-\n-void\n-cpp_error_from_errno (pfile, name)\n-     cpp_reader *pfile;\n-     const char *name;\n-{\n-  cpp_message_from_errno (pfile, 1, name);\n-}\n-\n-void\n-cpp_message_from_errno (pfile, is_error, name)\n-     cpp_reader *pfile;\n-     int is_error;\n-     const char *name;\n-{\n-  int e = errno;\n-  cpp_buffer *ip = cpp_file_buffer (pfile);\n-\n-  cpp_print_containing_files (pfile);\n-\n-  if (ip != NULL)\n-    cpp_file_line_for_message (pfile, ip->nominal_fname, ip->lineno, -1);\n-\n-  cpp_message (pfile, is_error, \"%s: %s\", name, my_strerror (e));\n-}\n-\n-void\n-cpp_perror_with_name (pfile, name)\n-     cpp_reader *pfile;\n-     const char *name;\n-{\n-  cpp_message (pfile, 1, \"%s: %s: %s\", progname, name, my_strerror (errno));\n-}"}, {"sha": "fc85a02b3bcee97bbae729feb275f6f478cdafae", "filename": "gcc/cpplib.h", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=c1212d2f0998469e6b4608de078a0a47bccd4ab7", "patch": "@@ -386,10 +386,15 @@ struct cpp_options {\n \n   char pedantic_errors;\n \n-  /* Nonzero means don't print warning messages.  -w.  */\n+  /* Nonzero means don't print warning messages.  */\n \n   char inhibit_warnings;\n \n+  /* Nonzero means don't print error messages.  Has no option to select it,\n+     but can be set by a user of cpplib (e.g. fix-header).  */\n+\n+  char inhibit_errors;\n+\n   /* Nonzero means warn if slash-star appears in a comment.  */\n \n   char warn_comments;\n@@ -710,24 +715,34 @@ extern void cpp_assert PARAMS ((cpp_reader *, unsigned char *));\n extern void cpp_undef  PARAMS ((cpp_reader *, unsigned char *));\n extern void cpp_unassert PARAMS ((cpp_reader *, unsigned char *));\n \n-extern void cpp_error PARAMS ((cpp_reader *, const char *, ...))\n+/* N.B. The error-message-printer prototypes have not been nicely\n+   formatted because exgettext needs to see 'msgid' on the same line\n+   as the name of the function in order to work properly.  Only the\n+   string argument gets a name in an effort to keep the lines from\n+   getting ridiculously oversized.  */\n+\n+extern void cpp_ice PARAMS ((cpp_reader *, const char *msgid, ...))\n   ATTRIBUTE_PRINTF_2;\n-extern void cpp_warning PARAMS ((cpp_reader *, const char *, ...))\n+extern void cpp_fatal PARAMS ((cpp_reader *, const char *msgid, ...))\n   ATTRIBUTE_PRINTF_2;\n-extern void cpp_pedwarn PARAMS ((cpp_reader *, const char *, ...))\n+extern void cpp_error PARAMS ((cpp_reader *, const char *msgid, ...))\n   ATTRIBUTE_PRINTF_2;\n-extern void cpp_error_with_line PARAMS ((cpp_reader *, int, int, const char *, ...))\n-  ATTRIBUTE_PRINTF_4;\n-extern void cpp_warning_with_line PARAMS ((cpp_reader *, int, int, const char *, ...))\n+extern void cpp_warning PARAMS ((cpp_reader *, const char *msgid, ...))\n+  ATTRIBUTE_PRINTF_2;\n+extern void cpp_pedwarn PARAMS ((cpp_reader *, const char *msgid, ...))\n+  ATTRIBUTE_PRINTF_2;\n+extern void cpp_notice PARAMS ((cpp_reader *, const char *msgid, ...))\n+  ATTRIBUTE_PRINTF_2;\n+extern void cpp_error_with_line PARAMS ((cpp_reader *, int, int, const char *msgid, ...))\n   ATTRIBUTE_PRINTF_4;\n-extern void cpp_pedwarn_with_line PARAMS ((cpp_reader *, int, int, const char *, ...))\n+extern void cpp_warning_with_line PARAMS ((cpp_reader *, int, int, const char *msgid, ...))\n   ATTRIBUTE_PRINTF_4;\n-extern void cpp_pedwarn_with_file_and_line PARAMS ((cpp_reader *, const char *, int, const char *, ...))\n+extern void cpp_pedwarn_with_line PARAMS ((cpp_reader *, int, int, const char *msgid, ...))\n   ATTRIBUTE_PRINTF_4;\n-extern void cpp_message_from_errno PARAMS ((cpp_reader *, int, const char *));\n+extern void cpp_pedwarn_with_file_and_line PARAMS ((cpp_reader *, const char *, int, int, const char *msgid, ...))\n+  ATTRIBUTE_PRINTF_5;\n extern void cpp_error_from_errno PARAMS ((cpp_reader *, const char *));\n-extern void cpp_perror_with_name PARAMS ((cpp_reader *, const char *));\n-extern void v_cpp_message PARAMS ((cpp_reader *, int, const char *, va_list));\n+extern void cpp_notice_from_errno PARAMS ((cpp_reader *, const char *));\n \n extern void cpp_grow_buffer PARAMS ((cpp_reader *, long));\n extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n@@ -755,18 +770,6 @@ enum file_change_code {same_file, enter_file, leave_file};\n extern void output_line_command\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t enum file_change_code));\n \n-/* From cpperror.c */\n-extern void cpp_fatal PARAMS ((cpp_reader *, const char *, ...))\n-  ATTRIBUTE_PRINTF_2;\n-extern void cpp_message PARAMS ((cpp_reader *, int, const char *, ...))\n-  ATTRIBUTE_PRINTF_3;\n-extern void cpp_pfatal_with_name PARAMS ((cpp_reader *, const char *))\n-  ATTRIBUTE_NORETURN;\n-extern void cpp_file_line_for_message PARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\t      int, int));\n-extern void cpp_print_containing_files PARAMS ((cpp_reader *));\n-extern void cpp_notice PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1;\n-\n /* In cppfiles.c */\n extern void simplify_pathname\t\tPARAMS ((char *));\n extern void merge_include_chains\tPARAMS ((struct cpp_options *));"}, {"sha": "ef68bc288fac93f826e90f5a6970c99c11628c53", "filename": "gcc/cppmain.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1212d2f0998469e6b4608de078a0a47bccd4ab7/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=c1212d2f0998469e6b4608de078a0a47bccd4ab7", "patch": "@@ -73,7 +73,10 @@ main (argc, argv)\n   if (!opts->out_fname || !strcmp (opts->out_fname, \"\"))\n     opts->out_fname = \"stdout\";\n   else if (! freopen (opts->out_fname, \"w\", stdout))\n-    cpp_pfatal_with_name (&parse_in, opts->out_fname);\n+    {\n+      cpp_notice_from_errno (&parse_in, opts->out_fname);\n+      return (FATAL_EXIT_CODE);\n+    }\n \n   if (! opts->no_output)\n     {\n@@ -87,7 +90,7 @@ main (argc, argv)\n \t      rem = fwrite (parse_in.token_buffer, 1, count, stdout);\n \t      if (rem < count)\n \t\t/* Write error. */\n-\t\tcpp_pfatal_with_name (&parse_in, opts->out_fname);\n+\t\tcpp_notice_from_errno (&parse_in, opts->out_fname);\n \n \t      CPP_SET_WRITTEN (&parse_in, 0);\n \t    }\n@@ -108,7 +111,7 @@ main (argc, argv)\n   cpp_finish (&parse_in);\n   if (fwrite (parse_in.token_buffer, 1, CPP_WRITTEN (&parse_in), stdout)\n       < CPP_WRITTEN (&parse_in))\n-    cpp_pfatal_with_name (&parse_in, opts->out_fname);\n+    cpp_notice_from_errno (&parse_in, opts->out_fname);\n \n   cpp_cleanup (&parse_in);\n "}]}