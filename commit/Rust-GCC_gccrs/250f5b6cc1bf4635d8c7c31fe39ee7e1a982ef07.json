{"sha": "250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUwZjViNmNjMWJmNDYzNWQ4YzdjMzFmZTM5ZWU3ZTFhOTgyZWYwNw==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2017-03-28T23:05:21Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2017-03-28T23:05:21Z"}, "message": "Implement LWG 2900, The copy and move constructors of optional are not constexpr.\n\nImplement LWG 2900, The copy and move constructors\nof optional are not constexpr.\n* include/std/optional (_Optional_payload): New.\n(_Optional_base): Remove the bool parameter.\n(_Optional_base<_Tp, false>): Remove.\n(_Optional_base()): Adjust.\n(_Optional_base(nullopt_t)): Likewise.\n(_Optional_base(in_place_t, _Args&&...)): Likewise.\n(_Optional_base(in_place_t, initializer_list<_Up>, _Args&&...)):\nLikewise.\n(_Optional_base(const _Optional_base&)): Likewise.\n(_Optional_base(_Optional_base&&)): Likewise.\n(operator=(const _Optional_base&)): Likewise.\n(operator=(_Optional_base&&)): Likewise.\n(~_Optional_base()): Remove.\n(_M_is_engaged()): Adjust.\n(_M_get()): Likewise.\n(_M_construct(_Args&&...)): Likewise.\n(_M_destruct()): Likewise.\n(_M_reset()): Likewise.\n(_Optional_base::_Empty_byte): Remove.\n(_Optional_base::_M_empty): Remove.\n(_Optional_base::_M_payload): Adjust.\n* testsuite/20_util/optional/cons/value_neg.cc: Adjust.\n* testsuite/20_util/optional/constexpr/cons/value.cc: Add tests.\n\nFrom-SVN: r246556", "tree": {"sha": "073219861618d399794f44ab4ecea6a000ec33b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/073219861618d399794f44ab4ecea6a000ec33b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19846619223e78409e3788b5b627bfe26684604f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19846619223e78409e3788b5b627bfe26684604f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19846619223e78409e3788b5b627bfe26684604f"}], "stats": {"total": 416, "additions": 256, "deletions": 160}, "files": [{"sha": "a4cb6b7d6cf42bfc892947dabb623536b2cbd3aa", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07", "patch": "@@ -1,3 +1,31 @@\n+2017-03-29  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement LWG 2900, The copy and move constructors\n+\tof optional are not constexpr.\n+\t* include/std/optional (_Optional_payload): New.\n+\t(_Optional_base): Remove the bool parameter.\n+\t(_Optional_base<_Tp, false>): Remove.\n+\t(_Optional_base()): Adjust.\n+\t(_Optional_base(nullopt_t)): Likewise.\n+\t(_Optional_base(in_place_t, _Args&&...)): Likewise.\n+\t(_Optional_base(in_place_t, initializer_list<_Up>, _Args&&...)):\n+\tLikewise.\n+\t(_Optional_base(const _Optional_base&)): Likewise.\n+\t(_Optional_base(_Optional_base&&)): Likewise.\n+\t(operator=(const _Optional_base&)): Likewise.\n+\t(operator=(_Optional_base&&)): Likewise.\n+\t(~_Optional_base()): Remove.\n+\t(_M_is_engaged()): Adjust.\n+\t(_M_get()): Likewise.\n+\t(_M_construct(_Args&&...)): Likewise.\n+\t(_M_destruct()): Likewise.\n+\t(_M_reset()): Likewise.\n+\t(_Optional_base::_Empty_byte): Remove.\n+\t(_Optional_base::_M_empty): Remove.\n+\t(_Optional_base::_M_payload): Adjust.\n+\t* testsuite/20_util/optional/cons/value_neg.cc: Adjust.\n+\t* testsuite/20_util/optional/constexpr/cons/value.cc: Add tests.\n+\n 2017-03-28  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/80137"}, {"sha": "17241204abb3b3f07ed8c3e0088816a962a87775", "filename": "libstdc++-v3/include/std/optional", "status": "modified", "additions": 208, "deletions": 157, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional?ref=250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07", "patch": "@@ -95,178 +95,231 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   __throw_bad_optional_access()\n   { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }\n \n-  /**\n-    * @brief Class template that holds the necessary state for @ref optional\n-    * and that has the responsibility for construction and the special members.\n-    *\n-    * Such a separate base class template is necessary in order to\n-    * conditionally enable the special members (e.g. copy/move constructors).\n-    * Note that this means that @ref _Optional_base implements the\n-    * functionality for copy and move assignment, but not for converting\n-    * assignment.\n-    *\n-    * @see optional, _Enable_special_members\n-    */\n-  template<typename _Tp, bool _ShouldProvideDestructor =\n-\t   !is_trivially_destructible<_Tp>::value>\n-    class _Optional_base\n-    {\n-    private:\n-      // Remove const to avoid prohibition of reusing object storage for\n-      // const-qualified types in [3.8/9]. This is strictly internal\n-      // and even optional itself is oblivious to it.\n-      using _Stored_type = remove_const_t<_Tp>;\n \n-    public:\n+  // Payload for constexpr optionals.\n+  template <typename _Tp,\n+\t    bool /*_TrivialCopyMove*/ =\n+\t      is_trivially_copy_constructible<_Tp>::value\n+\t      && is_trivially_move_constructible<_Tp>::value,\n+\t    bool /*_ShouldProvideDestructor*/ =\n+\t      is_trivially_destructible<_Tp>::value>\n+    struct _Optional_payload\n+    {\n+      constexpr _Optional_payload()\n+\t: _M_empty() {}\n \n-      // Constructors for disengaged optionals.\n-      constexpr _Optional_base() noexcept\n-      : _M_empty{} { }\n+      template<typename... _Args>\n+      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n+\t: _M_payload(std::forward<_Args>(__args)...),\n+\t  _M_engaged(true)\n+      {}\n \n-      constexpr _Optional_base(nullopt_t) noexcept\n-      : _Optional_base{} { }\n+      template<typename _Up, typename... _Args>\n+      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t\t  _Args&&... __args)\n+\t: _M_payload(__il, std::forward<_Args>(__args)...),\n+\t  _M_engaged(true) {}\n+\n+      template <class _Up> struct __ctor_tag {};\n+\n+      constexpr _Optional_payload(__ctor_tag<bool>,\n+\t\t\t\t  const _Tp& __other)\n+\t: _M_payload(__other),\n+\t  _M_engaged(true)\n+      {}\n+\n+      constexpr _Optional_payload(__ctor_tag<void>)\n+\t: _M_empty()\n+      {}\n+\n+      constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n+\t: _M_payload(std::move(__other)),\n+\t  _M_engaged(true)\n+      {}\n+\n+      constexpr _Optional_payload(bool __engaged,\n+\t\t\t\t  const _Optional_payload& __other)\n+\t: _Optional_payload(__engaged ?\n+\t\t\t    _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t      __other._M_payload) :\n+\t\t\t    _Optional_payload(__ctor_tag<void>{}))\n+      {}\n+\n+      constexpr _Optional_payload(bool __engaged,\n+\t\t\t\t  _Optional_payload&& __other)\n+\t: _Optional_payload(__engaged\n+\t\t\t    ? _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t\tstd::move(__other._M_payload))\n+\t\t\t    : _Optional_payload(__ctor_tag<void>{}))\n+      {}\n \n-      // Constructors for engaged optionals.\n-      template<typename... _Args,\n-\t       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>\n-        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)\n-        : _M_payload(std::forward<_Args>(__args)...), _M_engaged(true) { }\n+      using _Stored_type = remove_const_t<_Tp>;\n+      struct _Empty_byte { };\n+      union {\n+          _Empty_byte _M_empty;\n+          _Stored_type _M_payload;\n+      };\n+      bool _M_engaged = false;\n+    };\n \n-      template<typename _Up, typename... _Args,\n-               enable_if_t<is_constructible_v<_Tp,\n-\t\t\t\t\t      initializer_list<_Up>&,\n-\t\t\t\t\t      _Args&&...>, bool> = false>\n-        constexpr explicit _Optional_base(in_place_t,\n-                                          initializer_list<_Up> __il,\n-                                          _Args&&... __args)\n-        : _M_payload(__il, std::forward<_Args>(__args)...),\n-          _M_engaged(true) { }\n+  // Payload for non-constexpr optionals with non-trivial destructor.\n+  template <typename _Tp>\n+    struct _Optional_payload<_Tp, false, false>\n+    {\n+      constexpr _Optional_payload()\n+\t: _M_empty() {}\n \n-      // Copy and move constructors.\n-      _Optional_base(const _Optional_base& __other)\n-      {\n-        if (__other._M_engaged)\n-          this->_M_construct(__other._M_get());\n-      }\n+      template <typename... _Args>\n+      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n+\t: _M_payload(std::forward<_Args>(__args)...),\n+\t  _M_engaged(true) {}\n \n-      _Optional_base(_Optional_base&& __other)\n-      noexcept(is_nothrow_move_constructible<_Tp>())\n+      template<typename _Up, typename... _Args>\n+      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t\t  _Args&&... __args)\n+\t: _M_payload(__il, std::forward<_Args>(__args)...),\n+\t  _M_engaged(true) {}\n+      constexpr\n+      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n+\t: _Optional_payload(__other)\n+      {}\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n+\t: _Optional_payload(std::move(__other))\n+      {}\n+\n+      constexpr _Optional_payload(const _Optional_payload& __other)\n       {\n-        if (__other._M_engaged)\n-          this->_M_construct(std::move(__other._M_get()));\n+\tif (__other._M_engaged)\n+\t  this->_M_construct(__other._M_payload);\n       }\n \n-      // Assignment operators.\n-      _Optional_base&\n-      operator=(const _Optional_base& __other)\n+      constexpr _Optional_payload(_Optional_payload&& __other)\n       {\n-        if (this->_M_engaged && __other._M_engaged)\n-          this->_M_get() = __other._M_get();\n-        else\n-\t  {\n-\t    if (__other._M_engaged)\n-\t      this->_M_construct(__other._M_get());\n-\t    else\n-\t      this->_M_reset();\n-\t  }\n-\n-        return *this;\n+\tif (__other._M_engaged)\n+\t  this->_M_construct(std::move(__other._M_payload));\n       }\n \n-      _Optional_base&\n-      operator=(_Optional_base&& __other)\n-      noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n-\t\t      is_nothrow_move_assignable<_Tp>>())\n-      {\n-\tif (this->_M_engaged && __other._M_engaged)\n-\t  this->_M_get() = std::move(__other._M_get());\n-\telse\n-\t  {\n-\t    if (__other._M_engaged)\n-\t      this->_M_construct(std::move(__other._M_get()));\n-\t    else\n-\t      this->_M_reset();\n-\t  }\n-\treturn *this;\n-      }\n+      using _Stored_type = remove_const_t<_Tp>;\n+      struct _Empty_byte { };\n+      union {\n+          _Empty_byte _M_empty;\n+          _Stored_type _M_payload;\n+      };\n+      bool _M_engaged = false;\n \n-      // Destructor.\n-      ~_Optional_base()\n+      ~_Optional_payload()\n       {\n-        if (this->_M_engaged)\n-          this->_M_payload.~_Stored_type();\n+        if (_M_engaged)\n+          _M_payload.~_Stored_type();\n       }\n \n-      // The following functionality is also needed by optional, hence the\n-      // protected accessibility.\n-    protected:\n-      constexpr bool _M_is_engaged() const noexcept\n-      { return this->_M_engaged; }\n-\n-      // The _M_get operations have _M_engaged as a precondition.\n-      constexpr _Tp&\n-      _M_get() noexcept\n-      { return _M_payload; }\n-\n-      constexpr const _Tp&\n-      _M_get() const noexcept\n-      { return _M_payload; }\n-\n-      // The _M_construct operation has !_M_engaged as a precondition\n-      // while _M_destruct has _M_engaged as a precondition.\n       template<typename... _Args>\n         void\n         _M_construct(_Args&&... __args)\n         noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n         {\n-          ::new (std::__addressof(this->_M_payload))\n+          ::new ((void *) std::__addressof(this->_M_payload))\n             _Stored_type(std::forward<_Args>(__args)...);\n           this->_M_engaged = true;\n         }\n+    };\n \n-      void\n-      _M_destruct()\n+  // Payload for non-constexpr optionals with trivial destructor.\n+  template <typename _Tp>\n+    struct _Optional_payload<_Tp, false, true>\n+    {\n+      constexpr _Optional_payload()\n+\t: _M_empty() {}\n+\n+      template <typename... _Args>\n+      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n+\t: _M_payload(std::forward<_Args>(__args)...),\n+\t  _M_engaged(true) {}\n+\n+      template<typename _Up, typename... _Args>\n+      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t\t  _Args&&... __args)\n+\t: _M_payload(__il, std::forward<_Args>(__args)...),\n+\t  _M_engaged(true) {}\n+      constexpr\n+      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n+\t: _Optional_payload(__other)\n+      {}\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n+\t: _Optional_payload(std::move(__other))\n+      {}\n+\n+      constexpr _Optional_payload(const _Optional_payload& __other)\n       {\n-        this->_M_engaged = false;\n-        this->_M_payload.~_Stored_type();\n+\tif (__other._M_engaged)\n+\t  this->_M_construct(__other._M_payload);\n       }\n \n-      // _M_reset is a 'safe' operation with no precondition.\n-      void\n-      _M_reset()\n+      constexpr _Optional_payload(_Optional_payload&& __other)\n       {\n-        if (this->_M_engaged)\n-          this->_M_destruct();\n+\tif (__other._M_engaged)\n+\t  this->_M_construct(std::move(__other._M_payload));\n       }\n \n-    private:\n+      using _Stored_type = remove_const_t<_Tp>;\n       struct _Empty_byte { };\n       union {\n           _Empty_byte _M_empty;\n           _Stored_type _M_payload;\n       };\n       bool _M_engaged = false;\n+\n+      template<typename... _Args>\n+        void\n+        _M_construct(_Args&&... __args)\n+        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        {\n+          ::new ((void *) std::__addressof(this->_M_payload))\n+            _Stored_type(std::forward<_Args>(__args)...);\n+          this->_M_engaged = true;\n+        }\n     };\n \n-  /// Partial specialization that is exactly identical to the primary template\n-  /// save for not providing a destructor, to fulfill triviality requirements.\n+  /**\n+    * @brief Class template that holds the necessary state for @ref optional\n+    * and that has the responsibility for construction and the special members.\n+    *\n+    * Such a separate base class template is necessary in order to\n+    * conditionally enable the special members (e.g. copy/move constructors).\n+    * Note that this means that @ref _Optional_base implements the\n+    * functionality for copy and move assignment, but not for converting\n+    * assignment.\n+    *\n+    * @see optional, _Enable_special_members\n+    */\n   template<typename _Tp>\n-    class _Optional_base<_Tp, false>\n+    class _Optional_base\n     {\n     private:\n+      // Remove const to avoid prohibition of reusing object storage for\n+      // const-qualified types in [3.8/9]. This is strictly internal\n+      // and even optional itself is oblivious to it.\n       using _Stored_type = remove_const_t<_Tp>;\n \n     public:\n+\n+      // Constructors for disengaged optionals.\n       constexpr _Optional_base() noexcept\n-      : _M_empty{} { }\n+      { }\n \n       constexpr _Optional_base(nullopt_t) noexcept\n-      : _Optional_base{} { }\n+      { }\n \n+      // Constructors for engaged optionals.\n       template<typename... _Args,\n \t       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>\n         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)\n-        : _M_payload(std::forward<_Args>(__args)...), _M_engaged(true) { }\n+        : _M_payload(in_place,\n+\t\t     std::forward<_Args>(__args)...) { }\n \n       template<typename _Up, typename... _Args,\n                enable_if_t<is_constructible_v<_Tp,\n@@ -275,101 +328,99 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         constexpr explicit _Optional_base(in_place_t,\n                                           initializer_list<_Up> __il,\n                                           _Args&&... __args)\n-        : _M_payload(__il, std::forward<_Args>(__args)...),\n-          _M_engaged(true) { }\n+        : _M_payload(in_place,\n+\t\t     __il, std::forward<_Args>(__args)...)\n+        { }\n \n-      _Optional_base(const _Optional_base& __other)\n-      {\n-        if (__other._M_engaged)\n-          this->_M_construct(__other._M_get());\n-      }\n+      // Copy and move constructors.\n+      constexpr _Optional_base(const _Optional_base& __other)\n+\t: _M_payload(__other._M_payload._M_engaged,\n+\t\t     __other._M_payload)\n+      { }\n \n-      _Optional_base(_Optional_base&& __other)\n+      constexpr _Optional_base(_Optional_base&& __other)\n       noexcept(is_nothrow_move_constructible<_Tp>())\n-      {\n-        if (__other._M_engaged)\n-          this->_M_construct(std::move(__other._M_get()));\n-      }\n+\t: _M_payload(__other._M_payload._M_engaged,\n+\t\t     std::move(__other._M_payload))\n+      { }\n \n+      // Assignment operators.\n       _Optional_base&\n       operator=(const _Optional_base& __other)\n       {\n-\tif (this->_M_engaged && __other._M_engaged)\n-\t  this->_M_get() = __other._M_get();\n-\telse\n+        if (this->_M_payload._M_engaged && __other._M_payload._M_engaged)\n+          this->_M_get() = __other._M_get();\n+        else\n \t  {\n-\t    if (__other._M_engaged)\n+\t    if (__other._M_payload._M_engaged)\n \t      this->_M_construct(__other._M_get());\n \t    else\n \t      this->_M_reset();\n \t  }\n-\treturn *this;\n+\n+        return *this;\n       }\n \n       _Optional_base&\n       operator=(_Optional_base&& __other)\n       noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n \t\t      is_nothrow_move_assignable<_Tp>>())\n       {\n-\tif (this->_M_engaged && __other._M_engaged)\n+\tif (this->_M_payload._M_engaged && __other._M_payload._M_engaged)\n \t  this->_M_get() = std::move(__other._M_get());\n \telse\n \t  {\n-\t    if (__other._M_engaged)\n+\t    if (__other._M_payload._M_engaged)\n \t      this->_M_construct(std::move(__other._M_get()));\n \t    else\n \t      this->_M_reset();\n \t  }\n \treturn *this;\n       }\n-\n-      // Sole difference\n-      // ~_Optional_base() noexcept = default;\n-\n+      // The following functionality is also needed by optional, hence the\n+      // protected accessibility.\n     protected:\n       constexpr bool _M_is_engaged() const noexcept\n-      { return this->_M_engaged; }\n+      { return this->_M_payload._M_engaged; }\n \n+      // The _M_get operations have _M_engaged as a precondition.\n       constexpr _Tp&\n       _M_get() noexcept\n-      { return _M_payload; }\n+      { return this->_M_payload._M_payload; }\n \n       constexpr const _Tp&\n       _M_get() const noexcept\n-      { return _M_payload; }\n+      { return this->_M_payload._M_payload; }\n \n+      // The _M_construct operation has !_M_engaged as a precondition\n+      // while _M_destruct has _M_engaged as a precondition.\n       template<typename... _Args>\n         void\n         _M_construct(_Args&&... __args)\n         noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n         {\n-          ::new (std::__addressof(this->_M_payload))\n+          ::new (std::__addressof(this->_M_payload._M_payload))\n             _Stored_type(std::forward<_Args>(__args)...);\n-          this->_M_engaged = true;\n+          this->_M_payload._M_engaged = true;\n         }\n \n       void\n       _M_destruct()\n       {\n-        this->_M_engaged = false;\n-        this->_M_payload.~_Stored_type();\n+        this->_M_payload._M_engaged = false;\n+        this->_M_payload._M_payload.~_Stored_type();\n       }\n \n+      // _M_reset is a 'safe' operation with no precondition.\n       void\n       _M_reset()\n       {\n-        if (this->_M_engaged)\n+        if (this->_M_payload._M_engaged)\n           this->_M_destruct();\n       }\n \n     private:\n-      struct _Empty_byte { };\n-      union\n-      {\n-\t_Empty_byte _M_empty;\n-\t_Stored_type _M_payload;\n-      };\n-      bool _M_engaged = false;\n+      _Optional_payload<_Tp> _M_payload;\n     };\n \n   template<typename _Tp>"}, {"sha": "87907f96d137e87b666274f9d6c1a25f2bf018ca", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/value_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc?ref=250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07", "patch": "@@ -37,8 +37,8 @@ int main()\n     std::optional<std::unique_ptr<int>> oup2 = new int;  // { dg-error \"conversion\" }\n     struct U { explicit U(std::in_place_t); };\n     std::optional<U> ou(std::in_place); // { dg-error \"no matching\" }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 437 }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 447 }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 504 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 488 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 498 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 555 }\n   }\n }"}, {"sha": "3b183f8ee2619385cce41333db1e85d83136af32", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/cons/value.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fcons%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fcons%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fcons%2Fvalue.cc?ref=250f5b6cc1bf4635d8c7c31fe39ee7e1a982ef07", "patch": "@@ -66,4 +66,21 @@ int main()\n     static_assert( o, \"\" );\n     static_assert( *o == 0x1234ABCD, \"\" );\n   }\n+  {\n+    constexpr std::optional<long> o = 42;\n+    constexpr std::optional<long> o2{o};\n+    constexpr std::optional<long> o3(o);\n+    constexpr std::optional<long> o4 = o;\n+    constexpr std::optional<long> o5;\n+    constexpr std::optional<long> o6{o5};\n+    constexpr std::optional<long> o7(o5);\n+    constexpr std::optional<long> o8 = o5;\n+    constexpr std::optional<long> o9{std::move(o)};\n+    constexpr std::optional<long> o10(std::move(o));\n+    constexpr std::optional<long> o11 = std::move(o);\n+    constexpr std::optional<long> o12;\n+    constexpr std::optional<long> o13{std::move(o5)};\n+    constexpr std::optional<long> o14(std::move(o5));\n+    constexpr std::optional<long> o15 = std::move(o5);\n+  }\n }"}]}