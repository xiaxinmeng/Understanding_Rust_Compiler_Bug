{"sha": "7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY5MWQwZDNjOWQ2MGViNzMyZTcxYmU0YzdhMTAwZWYyYmIyZWY4Mg==", "commit": {"author": {"name": "Keith Seitz", "email": "keiths@redhat.com", "date": "2006-06-21T20:56:37Z"}, "committer": {"name": "Keith Seitz", "email": "kseitz@gcc.gnu.org", "date": "2006-06-21T20:56:37Z"}, "message": "pthread_stop_world.c (GC_suspend_handler): Redirect to suspension routine if signal is received and thread is flagged...\n\n        * pthread_stop_world.c (GC_suspend_handler): Redirect to suspension\n        routine if signal is received and thread is flagged SUSPENDED.\n        (suspend_self): New function.\n        (GC_suspend_thread): New function.\n        (GC_resume_thread): New function.\n        * include/gc.h (GC_suspend_thread): Declare.\n        (GC_resumet_thread): Declare.\n        * include/private/pthread_support.h (SUSPENDED): New GC_thread\n        flag.\n\nFrom-SVN: r114869", "tree": {"sha": "55fd808e47f53739af4e710b68299196cc64643e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55fd808e47f53739af4e710b68299196cc64643e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82/comments", "author": {"login": "shtiek", "id": 107581324, "node_id": "U_kgDOBmmPjA", "avatar_url": "https://avatars.githubusercontent.com/u/107581324?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shtiek", "html_url": "https://github.com/shtiek", "followers_url": "https://api.github.com/users/shtiek/followers", "following_url": "https://api.github.com/users/shtiek/following{/other_user}", "gists_url": "https://api.github.com/users/shtiek/gists{/gist_id}", "starred_url": "https://api.github.com/users/shtiek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shtiek/subscriptions", "organizations_url": "https://api.github.com/users/shtiek/orgs", "repos_url": "https://api.github.com/users/shtiek/repos", "events_url": "https://api.github.com/users/shtiek/events{/privacy}", "received_events_url": "https://api.github.com/users/shtiek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c3238e32eb1c51e9cb8d75f5b3266bf3c831112f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3238e32eb1c51e9cb8d75f5b3266bf3c831112f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3238e32eb1c51e9cb8d75f5b3266bf3c831112f"}], "stats": {"total": 88, "additions": 82, "deletions": 6}, "files": [{"sha": "6e2b3a86112d22c37df97c4a6c70c0d1593184fc", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82", "patch": "@@ -1,3 +1,15 @@\n+2006-06-21  Keith Seitz  <keiths@redhat.com>\n+\n+\t* pthread_stop_world.c (GC_suspend_handler): Redirect to suspension\n+\troutine if signal is received and thread is flagged SUSPENDED.\n+\t(suspend_self): New function.\n+\t(GC_suspend_thread): New function.\n+\t(GC_resume_thread): New function.\n+\t* include/gc.h (GC_suspend_thread): Declare.\n+\t(GC_resumet_thread): Declare.\n+\t* include/private/pthread_support.h (SUSPENDED): New GC_thread\n+\tflag.\n+\n 2006-06-20  Ranjit Mathew  <rmathew@gcc.gnu.org>\n \t\n \tBackport Windows 9x/ME VirtualQuery() fix from GC 6.7."}, {"sha": "e6ab2c608c4a52634597d6ec6c63e6d752bdb934", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82", "patch": "@@ -1040,4 +1040,14 @@ GC_API void GC_register_has_static_roots_callback\n     }  /* end of extern \"C\" */\n #endif\n \n+/* External thread suspension support. These functions do not implement\n+ * suspension counts or any other higher-level abstraction. Threads which\n+ * have been suspended numerous times will resume with the very first call\n+ * to GC_resume_thread.\n+ */\n+#if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\\n+  && !defined(GC_WIN32_THREADS) && !defined(GC_DARWIN_THREADS)\n+GC_API void GC_suspend_thread GC_PROTO((pthread_t));\n+GC_API void GC_resume_thread GC_PROTO((pthread_t));\n+#endif\n #endif /* _GC_H */"}, {"sha": "2186c079039f5ef27e270742946c24e1c1454cea", "filename": "boehm-gc/include/private/pthread_support.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fpthread_support.h?ref=7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82", "patch": "@@ -33,6 +33,7 @@ typedef struct GC_Thread_Rep {\n #\tdefine FINISHED 1   \t/* Thread has exited.\t*/\n #\tdefine DETACHED 2\t/* Thread is intended to be detached.\t*/\n #\tdefine MAIN_THREAD 4\t/* True for the original thread only.\t*/\n+#       define SUSPENDED 8      /* True if thread was suspended externally */\n     short thread_blocked;\t/* Protected by GC lock.\t\t*/\n     \t\t\t\t/* Treated as a boolean value.  If set,\t*/\n     \t\t\t\t/* thread will acquire GC lock before\t*/"}, {"sha": "de647769c7c24079457f9f1f890d73df5be6b8e8", "filename": "boehm-gc/pthread_stop_world.c", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82/boehm-gc%2Fpthread_stop_world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82/boehm-gc%2Fpthread_stop_world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_stop_world.c?ref=7691d0d3c9d60eb732e71be4c7a100ef2bb2ef82", "patch": "@@ -13,6 +13,8 @@\n   /* Doesn't exist on HP/UX 11.11. */\n #endif\n \n+void suspend_self();\n+\n #if DEBUG_THREADS\n \n #ifndef NSIG\n@@ -127,19 +129,29 @@ extern void GC_with_callee_saves_pushed();\n \n void GC_suspend_handler(int sig)\n {\n-  int old_errno = errno;\n-  GC_with_callee_saves_pushed(GC_suspend_handler_inner, (ptr_t)(word)sig);\n-  errno = old_errno;\n+  GC_thread me = GC_lookup_thread (pthread_self());\n+  if (me -> flags & SUSPENDED)\n+    suspend_self();\n+  else {\n+    int old_errno = errno;\n+    GC_with_callee_saves_pushed(GC_suspend_handler_inner, (ptr_t)(word)sig);\n+    errno = old_errno;\n+  }\n }\n \n #else\n /* We believe that in all other cases the full context is already\t*/\n /* in the signal handler frame.\t\t\t\t\t\t*/\n void GC_suspend_handler(int sig)\n {\n-  int old_errno = errno;\n-  GC_suspend_handler_inner((ptr_t)(word)sig);\n-  errno = old_errno;\n+  GC_thread me = GC_lookup_thread(pthread_self());\n+  if (me -> flags & SUSPENDED)\n+    suspend_self();\n+  else {\n+    int old_errno = errno;\n+    GC_suspend_handler_inner((ptr_t)(word)sig);\n+    errno = old_errno;\n+  }\n }\n #endif\n \n@@ -430,6 +442,47 @@ void GC_stop_world()\n     GC_stopping_thread = 0;  /* debugging only */\n }\n \n+void suspend_self() {\n+  GC_thread me = GC_lookup_thread(pthread_self());\n+  if (me == NULL)\n+    ABORT(\"attempting to suspend unknown thread\");\n+\n+  me -> flags |= SUSPENDED;\n+  GC_start_blocking();\n+  while (me -> flags & SUSPENDED)\n+    GC_brief_async_signal_safe_sleep();\n+  GC_end_blocking();\n+}\n+\n+void GC_suspend_thread(pthread_t thread) {\n+  if (thread == pthread_self())\n+    suspend_self();\n+  else {\n+    int result;\n+    GC_thread t = GC_lookup_thread(thread);\n+    if (t == NULL)\n+      ABORT(\"attempting to suspend unknown thread\");\n+\n+    t -> flags |= SUSPENDED;\n+    result = pthread_kill (t -> id, SIG_SUSPEND);\n+    switch (result) {\n+    case ESRCH:\n+    case 0:\n+      break;\n+    default:\n+      ABORT(\"pthread_kill failed\");\n+    }\n+  }\n+}\n+\n+void GC_resume_thread(pthread_t thread) {\n+  GC_thread t = GC_lookup_thread(thread);\n+  if (t == NULL)\n+    ABORT(\"attempting to resume unknown thread\");\n+\n+  t -> flags &= ~SUSPENDED;\n+}\n+\n /* Caller holds allocation lock, and has held it continuously since\t*/\n /* the world stopped.\t\t\t\t\t\t\t*/\n void GC_start_world()"}]}