{"sha": "d38d4e5d1800457ad097cb5e6dc35387998e6efa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM4ZDRlNWQxODAwNDU3YWQwOTdjYjVlNmRjMzUzODc5OThlNmVmYQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-12-23T07:24:57Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-12-23T07:24:57Z"}, "message": "new_allocator.h (new_allocator): Proper allocator class.\n\n\n2003-12-23  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/ext/new_allocator.h (new_allocator): Proper allocator class.\n\t(__new_alloc): Delete.\n\t* include/ext/malloc_allocator.h (malloc_allocator): Same.\n\t(__malloc_alloc): Delete.\n \t* include/ext/mt_allocator.h: Same, but weakly.\n \t* include/ext/debug_allocator.h: Convert to the new style.\n\t* include/ext/pool_allocator.h: Use global new and delete directly.\n\t* include/backward/alloc.h: Don't inject malloc_allocator, or\n\tdebug_allocator.\n\t* testsuite/ext/allocators.cc: Minimal fixups for usage of new\n\tclasses.  Comment out tests with __pool_alloc for now.\n\t* testsuite/performance/allocator.cc: Same.\n\nFrom-SVN: r74965", "tree": {"sha": "de3ca351c848fcc5c05f6ece2f1559423a3a5fc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de3ca351c848fcc5c05f6ece2f1559423a3a5fc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d38d4e5d1800457ad097cb5e6dc35387998e6efa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38d4e5d1800457ad097cb5e6dc35387998e6efa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d38d4e5d1800457ad097cb5e6dc35387998e6efa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38d4e5d1800457ad097cb5e6dc35387998e6efa/comments", "author": null, "committer": null, "parents": [{"sha": "cbf6e52aa53df8528eb21cff83631a0523cae79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbf6e52aa53df8528eb21cff83631a0523cae79c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbf6e52aa53df8528eb21cff83631a0523cae79c"}], "stats": {"total": 702, "additions": 332, "deletions": 370}, "files": [{"sha": "9c8048dec24f5fd13bc049207be96a642da11343", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d38d4e5d1800457ad097cb5e6dc35387998e6efa", "patch": "@@ -1,3 +1,18 @@\n+2003-12-23  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/ext/new_allocator.h (new_allocator): Proper allocator class.\n+\t(__new_alloc): Delete.\n+\t* include/ext/malloc_allocator.h (malloc_allocator): Same.\n+\t(__malloc_alloc): Delete.\n+ \t* include/ext/mt_allocator.h: Same, but weakly.\n+ \t* include/ext/debug_allocator.h: Convert to the new style.\n+\t* include/ext/pool_allocator.h: Use global new and delete directly.\n+\t* include/backward/alloc.h: Don't inject malloc_allocator, or\n+\tdebug_allocator.\t\n+\t* testsuite/ext/allocators.cc: Minimal fixups for usage of new\n+\tclasses.  Comment out tests with __pool_alloc for now.\n+\t* testsuite/performance/allocator.cc: Same.\n+\n 2003-12-22  Matt Austern  <austern@apple.com>\n \n \t* include/bits/stl_bvector.h (_Bvector_alloc_base): Eliminate."}, {"sha": "ad9e4e5bb3c7beaf9f4ef09bd2d45cafe761754a", "filename": "libstdc++-v3/include/backward/alloc.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h?ref=d38d4e5d1800457ad097cb5e6dc35387998e6efa", "patch": "@@ -46,11 +46,7 @@\n #include \"backward_warning.h\"\n #include <bits/c++config.h>\n #include <bits/allocator.h>\n-#include <ext/debug_allocator.h>\n-#include <ext/malloc_allocator.h>\n \n-using __gnu_cxx::__malloc_alloc;\n-using __gnu_cxx::__debug_alloc;\n using __gnu_cxx::__pool_alloc;\n using std::__alloc;\n using std::__simple_alloc;"}, {"sha": "e744ab61fae34eba8a4f5015fd41dd3bb63d3c9f", "filename": "libstdc++-v3/include/ext/debug_allocator.h", "status": "modified", "additions": 30, "deletions": 64, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdebug_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdebug_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdebug_allocator.h?ref=d38d4e5d1800457ad097cb5e6dc35387998e6efa", "patch": "@@ -48,92 +48,58 @@\n #ifndef _DEBUG_ALLOCATOR_H\n #define _DEBUG_ALLOCATOR_H 1\n \n-#include <bits/allocator_traits.h>\n+#include <memory>\n \n namespace __gnu_cxx\n {\n   /**\n-   *  @if maint\n-   *  An adaptor for an underlying allocator (_Alloc) to check the size\n-   *  arguments for debugging.\n+   *  @brief  A meta-allocator with debugging bits, as per [20.4].\n    *\n-   *  \"There is some evidence that this can confuse Purify.\" - SGI comment\n+   *  This is precisely the allocator defined in the C++ Standard. \n+   *    - all allocation calls operator new\n+   *    - all deallocation calls operator delete\n    *\n-   *  This adaptor is \"SGI\" style.  The _Alloc parameter must also be \"SGI\".\n-   *  @endif\n    *  (See @link Allocators allocators info @endlink for more.)\n    */\n   template<typename _Alloc>\n-    class __debug_alloc\n+    class debug_allocator\n     {\n+    public:\n+      typedef typename _Alloc::size_type       \tsize_type;\n+      typedef typename _Alloc::difference_type\tdifference_type;\n+      typedef typename _Alloc::pointer       \tpointer;\n+      typedef typename _Alloc::const_pointer    const_pointer;\n+      typedef typename _Alloc::reference       \treference;\n+      typedef typename _Alloc::const_reference  const_reference;\n+      typedef typename _Alloc::value_type       value_type;\n+\n     private:\n       // Size of space used to store size.  Note that this must be\n       // large enough to preserve alignment.\n-      enum {_S_extra = 8};\n+      const size_t \t\t_M_extra;\n+      \n+      _Alloc\t\t\t_M_allocator;\n \n     public:\n-      static void*\n-      allocate(size_t __n)\n+      debug_allocator() : _M_extra(8) { }\n+\n+      pointer\n+      allocate(size_type __n, std::allocator<void>::const_pointer = 0)\n       {\n-        char* __result = (char*)_Alloc::allocate(__n + (int) _S_extra);\n-        *(size_t*)__result = __n;\n-        return __result + (int) _S_extra;\n+        pointer __result = _M_allocator.allocate(__n + _M_extra);\n+        *__result = __n;\n+        return __result + _M_extra;\n       }\n \n-      static void\n-      deallocate(void* __p, size_t __n)\n+      void\n+      deallocate(pointer __p, size_type __n)\n       {\n-        char* __real_p = (char*)__p - (int) _S_extra;\n-        if (*(size_t*)__real_p != __n)\n+        pointer __real_p = __p - _M_extra;\n+        if (*__real_p != __n)\n           abort();\n-        _Alloc::deallocate(__real_p, __n + (int) _S_extra);\n+        _M_allocator.deallocate(__real_p, __n + _M_extra);\n       }\n     };\n-\n-  //@{\n-  /** Comparison operators for all of the predifined SGI-style allocators.\n-   *  This ensures that __allocator<malloc_alloc> (for example) will work\n-   *  correctly.  As required, all allocators compare equal.\n-   */\n-  template<typename _Alloc>\n-    inline bool\n-    operator==(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)\n-    { return true; }\n-\n-  template<typename _Alloc>\n-    inline bool\n-    operator!=(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)\n-    { return false; }\n-  //@}\n } // namespace __gnu_cxx\n \n-namespace std\n-{\n-  //@{\n-  /// Versions for the predefined \"SGI\" style allocators.\n-  template<typename _Tp, typename _Alloc>\n-    struct _Alloc_traits<_Tp, __gnu_cxx::__debug_alloc<_Alloc> >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __gnu_cxx::__debug_alloc<_Alloc>\t\tbase_alloc_type;\n-      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n-      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n-    };\n-  //@}\n-\n-  //@{\n-  /// Versions for the __allocator adaptor used with the predefined\n-  /// \"SGI\" style allocators.\n-  template<typename _Tp, typename _Tp1, typename _Alloc>\n-    struct _Alloc_traits<_Tp, __allocator<_Tp1,\n-\t\t\t\t\t  __gnu_cxx::__debug_alloc<_Alloc> > >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __gnu_cxx::__debug_alloc<_Alloc>\t\tbase_alloc_type;\n-      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n-      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n-    };\n-  //@}\n-} // namespace std\n-\n #endif"}, {"sha": "5545a58f8c93b605529d84ad6cf27a59e4bc1e3f", "filename": "libstdc++-v3/include/ext/malloc_allocator.h", "status": "modified", "additions": 59, "deletions": 118, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h?ref=d38d4e5d1800457ad097cb5e6dc35387998e6efa", "patch": "@@ -1,4 +1,4 @@\n-// Allocators -*- C++ -*-\n+// Allocator that wraps \"C\" malloc -*- C++ -*-\n \n // Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n@@ -27,137 +27,78 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-/*\n- * Copyright (c) 1996-1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-/** @file ext/debug_allocator.h\n- *  This file is a GNU extension to the Standard C++ Library.\n- *  You should only include this header if you are using GCC 3 or later.\n- */\n-\n #ifndef _MALLOC_ALLOCATOR_H\n #define _MALLOC_ALLOCATOR_H 1\n \n-#include <bits/allocator_traits.h>\n+#include <new>\n+#include <memory>\n \n namespace __gnu_cxx\n {\n   /**\n-   *  @if maint\n-   *  A malloc-based allocator.  Typically slower than the\n-   *  __pool_alloc (below).  Typically thread-safe and more\n-   *  storage efficient.  The template argument is unused and is only present\n-   *  to permit multiple instantiations (but see __pool_alloc\n-   *  for caveats).  \"SGI\" style, plus __set_malloc_handler for OOM conditions.\n-   *  @endif\n+   *  @brief  An allocator that uses malloc\n+   *\n+   *  This is precisely the allocator defined in the C++ Standard. \n+   *    - all allocation calls malloc\n+   *    - all deallocation calls free\n+   *\n    *  (See @link Allocators allocators info @endlink for more.)\n    */\n-  template<int __inst>\n-    class __malloc_alloc\n+  template<typename _Tp>\n+    class malloc_allocator\n     {\n-    private:\n-      static void* _S_oom_malloc(size_t);\n-      static void (* __malloc_alloc_oom_handler)();\n-\n     public:\n-      static void*\n-      allocate(size_t __n)\n-      {\n-        void* __result = malloc(__n);\n-        if (__builtin_expect(__result == 0, 0))\n-\t  __result = _S_oom_malloc(__n);\n-        return __result;\n-      }\n-\n-      static void\n-      deallocate(void* __p, size_t /* __n */)\n-      { free(__p); }\n-\n-      static void (* __set_malloc_handler(void (*__f)()))()\n-      {\n-        void (* __old)() = __malloc_alloc_oom_handler;\n-        __malloc_alloc_oom_handler = __f;\n-        return __old;\n-      }\n-    };\n+      typedef size_t     size_type;\n+      typedef ptrdiff_t  difference_type;\n+      typedef _Tp*       pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp&       reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp        value_type;\n \n-  // malloc_alloc out-of-memory handling\n-  template<int __inst>\n-    void (* __malloc_alloc<__inst>::__malloc_alloc_oom_handler)() = 0;\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef malloc_allocator<_Tp1> other; };\n \n-  template<int __inst>\n-    void*\n-    __malloc_alloc<__inst>::\n-    _S_oom_malloc(size_t __n)\n-    {\n-      void (* __my_malloc_handler)();\n-      void* __result;\n-\n-      for (;;)\n-        {\n-          __my_malloc_handler = __malloc_alloc_oom_handler;\n-          if (__builtin_expect(__my_malloc_handler == 0, 0))\n-            __throw_bad_alloc();\n-          (*__my_malloc_handler)();\n-          __result = malloc(__n);\n-          if (__result)\n-            return __result;\n-        }\n-    }\n-  //@{\n-  /** Comparison operators for all of the predifined SGI-style allocators.\n-   *  This ensures that __allocator<malloc_alloc> (for example) will work\n-   *  correctly.  As required, all allocators compare equal.\n-   */\n-  template<int inst>\n-    inline bool\n-    operator==(const __malloc_alloc<inst>&, const __malloc_alloc<inst>&)\n-    { return true; }\n-\n-  template<int __inst>\n-    inline bool\n-    operator!=(const __malloc_alloc<__inst>&, const __malloc_alloc<__inst>&)\n-    { return false; }\n-  //@}\n-} // namespace __gnu_cxx\n+      malloc_allocator() throw() { }\n \n-namespace std\n-{\n-  //@{\n-  /// Versions for the predefined \"SGI\" style allocators.\n-  template<typename _Tp, int __inst>\n-    struct _Alloc_traits<_Tp, __gnu_cxx::__malloc_alloc<__inst> >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __gnu_cxx:: __malloc_alloc<__inst>\tbase_alloc_type;\n-      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n-      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n-    };\n-  //@}\n-\n-  //@{\n-  /// Versions for the __allocator adaptor used with the predefined\n-  /// \"SGI\" style allocators.\n-  template<typename _Tp, typename _Tp1, int __inst>\n-    struct _Alloc_traits<_Tp, __allocator<_Tp1,\n-\t\t\t\t\t  __gnu_cxx::__malloc_alloc<__inst> > >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __gnu_cxx:: __malloc_alloc<__inst>\tbase_alloc_type;\n-      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n-      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n+      malloc_allocator(const malloc_allocator&) throw() { }\n+\n+      template<typename _Tp1>\n+        malloc_allocator(const malloc_allocator<_Tp1>&) throw() { }\n+\n+      ~malloc_allocator() throw() { }\n+\n+      pointer\n+      address(reference __x) const { return &__x; }\n+\n+      const_pointer\n+      address(const_reference __x) const { return &__x; }\n+\n+      // NB: __n is permitted to be 0.  The C++ standard says nothing\n+      // about what the return value is when __n == 0.\n+      pointer\n+      allocate(size_type __n, std::allocator<void>::const_pointer __h = 0)\n+      { return static_cast<_Tp*>(malloc(__n * sizeof(_Tp))); }\n+\n+      // __p is not permitted to be a null pointer.\n+      void\n+      deallocate(pointer __p, size_type __n)\n+      { free(static_cast<void*>(__p)); }\n+\n+      size_type\n+      max_size() const throw() \n+      { return size_t(-1) / sizeof(_Tp); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 402. wrong new expression in [some_] allocator::construct\n+      void \n+      construct(pointer __p, const _Tp& __val) \n+      { *__p = __val; }\n+\n+      void \n+      destroy(pointer __p) { __p->~_Tp(); }\n     };\n-  //@}\n-} // namespace std\n+} // namespace __gnu_cxx\n \n #endif"}, {"sha": "ec77192db26127a094bb5b856dea545c343d8130", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 128, "deletions": 134, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=d38d4e5d1800457ad097cb5e6dc35387998e6efa", "patch": "@@ -35,32 +35,83 @@\n #ifndef _MT_ALLOCATOR_H\n #define _MT_ALLOCATOR_H 1\n \n+#include <new>\n+#include <memory>\n #include <cstdlib>\n #include <bits/functexcept.h>\n #include <bits/gthr.h>\n #include <bits/atomicity.h>\n-#include <bits/allocator_traits.h>\n \n namespace __gnu_cxx\n {\n-\n-/**\n- *  This is a fixed size (power of 2) allocator which - when compiled\n- *  with thread support - will maintain one freelist per size per thread\n- *  plus a \"global\" one. Steps are taken to limit the per thread freelist\n- *  sizes (by returning excess back to \"global\").\n- *\n- *  Usage examples:\n- *  @code\n- *    vector<int, __gnu_cxx::__mt_alloc<0> > v1;\n- *\n- *    typedef std::__allocator<char, __gnu_cxx::__mt_alloc<0> > string_alloc;\n- *    std::basic_string<char, std::char_traits<char>, string_alloc> s1;\n- *  @endcode\n- */\n-  template<int __inst>\n+  /**\n+   *  This is a fixed size (power of 2) allocator which - when\n+   *  compiled with thread support - will maintain one freelist per\n+   *  size per thread plus a \"global\" one. Steps are taken to limit\n+   *  the per thread freelist sizes (by returning excess back to\n+   *  \"global\").\n+   *\n+   *  Usage examples:\n+   *  @code\n+   *    vector<int, __gnu_cxx::__mt_alloc<int> > v1;\n+   *\n+   *    typedef __gnu_cxx::__mt_alloc<char> > string_allocator;\n+   *    std::basic_string<char, std::char_traits<char>, string_allocator> s1;\n+   *  @endcode\n+   */\n+  template<typename _Tp>\n     class __mt_alloc\n     {\n+    public:\n+      typedef size_t     size_type;\n+      typedef ptrdiff_t  difference_type;\n+      typedef _Tp*       pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp&       reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp        value_type;\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef __mt_alloc<_Tp1> other; };\n+\n+      __mt_alloc() throw() \n+      {\n+\t// XXX\n+      }\n+\n+      __mt_alloc(const __mt_alloc&) throw()\n+      {\n+\t// XXX\n+      }\n+\n+      template<typename _Tp1>\n+        __mt_alloc(const __mt_alloc<_Tp1>&) throw()\n+        {\n+\t  // XXX\n+\t}\n+\n+      ~__mt_alloc() throw() { }\n+\n+      pointer\n+      address(reference __x) const { return &__x; }\n+\n+      const_pointer\n+      address(const_reference __x) const { return &__x; }\n+\n+      size_type\n+      max_size() const throw() \n+      { return size_t(-1) / sizeof(_Tp); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 402. wrong new expression in [some_] allocator::construct\n+      void \n+      construct(pointer __p, const _Tp& __val) \n+      { ::new(__p) _Tp(__val); }\n+\n+      void \n+      destroy(pointer __p) { __p->~_Tp(); }\n+\n     private:\n       /*\n        * We need to create the initial lists and set up some variables\n@@ -174,23 +225,21 @@ namespace __gnu_cxx\n       static bin_record* _S_bin;\n \n     public:\n-      static void*\n-      allocate(size_t __n)\n+      pointer\n+      allocate(size_t __n, std::allocator<void>::const_pointer __h = 0)\n       {\n-\n         /*\n          * Requests larger than _S_max_bytes are handled by\n-         * malloc/free directly\n+         * new/delete directly\n          */\n         if (__n > _S_max_bytes)\n           {\n-            void* __ret = malloc(__n);\n+            void* __ret = malloc(__n * sizeof(_Tp));\n             if (!__ret)\n               __throw_bad_alloc();\n-\n-            return __ret;\n+            return static_cast<_Tp*>(__ret);\n           }\n-\n+\t\n         /*\n          * Although the test in __gthread_once() would suffice, we\n          * wrap test of the once condition in our own unlocked\n@@ -306,8 +355,8 @@ namespace __gnu_cxx\n                   __throw_bad_alloc();\n \n                 size_t bin_t = 1 << bin;\n-                size_t block_count =\n-                  _S_chunk_size / (bin_t + sizeof(block_record));\n+                size_t block_count = \n+\t\t  _S_chunk_size / (bin_t + sizeof(block_record));\n \n                 _S_bin[bin].free[0] = block_count;\n \n@@ -349,11 +398,11 @@ namespace __gnu_cxx\n             _S_bin[bin].used[thread_id]++;\n           }\n \n-        return (void*)((char*)block + sizeof(block_record));\n+        return static_cast<_Tp*>(static_cast<void*>((char*)block + sizeof(block_record)));\n       }\n \n-      static void\n-      deallocate(void* __p, size_t __n)\n+      void\n+      deallocate(pointer __p, size_type __n)\n       {\n         /*\n          * Requests larger than _S_max_bytes are handled by\n@@ -363,7 +412,7 @@ namespace __gnu_cxx\n           {\n             free(__p);\n             return;\n-          }\n+           }\n \n         /*\n          * Round up to power of 2 and figure out which bin to use\n@@ -482,9 +531,9 @@ namespace __gnu_cxx\n       }\n     };\n \n-  template<int __inst>\n+  template<typename _Tp>\n     void\n-    __mt_alloc<__inst>::\n+    __mt_alloc<_Tp>::\n     _S_init()\n     {\n       /*\n@@ -530,7 +579,7 @@ namespace __gnu_cxx\n #ifdef __GTHREADS\n       if (__gthread_active_p())\n         {\n-          _S_thread_freelist_first =\n+\t  _S_thread_freelist_first =\n             (thread_record*)malloc(sizeof(thread_record) * _S_max_threads);\n \n           if (!_S_thread_freelist_first)\n@@ -543,8 +592,8 @@ namespace __gnu_cxx\n           size_t i;\n           for (i = 1; i < _S_max_threads; i++)\n             {\n-              _S_thread_freelist_first[i - 1].next =\n-                &_S_thread_freelist_first[i];\n+              _S_thread_freelist_first[i - 1].next = \n+\t\t&_S_thread_freelist_first[i];\n \n               _S_thread_freelist_first[i - 1].id = i;\n             }\n@@ -578,42 +627,34 @@ namespace __gnu_cxx\n       if (!_S_bin)\n         __throw_bad_alloc();\n \n-      for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n+       for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n         {\n-          _S_bin[bin].first = (block_record**)\n-            malloc(sizeof(block_record*) * (_S_max_threads + 1));\n+\t  std::size_t __n = _S_max_threads + 1;\n+\n+          _S_bin[bin].first = (block_record**) \n+\t    malloc(sizeof(block_record*) * __n);\n \n           if (!_S_bin[bin].first)\n             __throw_bad_alloc();\n \n-          _S_bin[bin].last = (block_record**)\n-            malloc(sizeof(block_record*) * (_S_max_threads + 1));\n+          _S_bin[bin].last = (block_record**) \n+\t    malloc(sizeof(block_record*) * __n);\n \n           if (!_S_bin[bin].last)\n             __throw_bad_alloc();\n \n-          _S_bin[bin].free = (size_t*)\n-            malloc(sizeof(size_t) * (_S_max_threads + 1));\n+          _S_bin[bin].free = (size_t*) malloc(sizeof(size_t) * __n);\n \n           if (!_S_bin[bin].free)\n             __throw_bad_alloc();\n \n-          _S_bin[bin].used = (size_t*)\n-            malloc(sizeof(size_t) * (_S_max_threads + 1));\n+          _S_bin[bin].used = (size_t*) malloc(sizeof(size_t) * __n);\n \n           if (!_S_bin[bin].used)\n             __throw_bad_alloc();\n \n-          /*\n-           * Ugly workaround of what at the time of writing seems to be\n-           * a parser problem - see PR c++/9779 for more info.\n-           */\n #ifdef __GTHREADS\n-          size_t s = sizeof(__gthread_mutex_t);\n-          _S_bin[bin].mutex = (__gthread_mutex_t*)malloc(s);\n-\n-          if (!_S_bin[bin].mutex)\n-            __throw_bad_alloc();\n+          _S_bin[bin].mutex =(__gthread_mutex_t*)  malloc(sizeof(__gthread_mutex_t));\n \n #ifdef __GTHREAD_MUTEX_INIT\n \t  {\n@@ -635,23 +676,17 @@ namespace __gnu_cxx\n             }\n         }\n \n-        _S_initialized = true;\n+      _S_initialized = true;\n     }\n \n #ifdef __GTHREADS\n-  template<int __inst>\n+  template<typename _Tp>\n     void\n-    __mt_alloc<__inst>::\n+    __mt_alloc<_Tp>::\n     _S_thread_key_destr(void* freelist_pos)\n     {\n       /*\n-       * This is due to the ugly workaround mentioned in _S_init()\n-       */\n-      if (freelist_pos == NULL)\n-        return;\n-\n-      /*\n-       * If the thread - when it dies - still have records on its\n+       * If the thread - when it dies - still has records on its\n        * freelist we return them to the global pool here.\n        */\n       for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n@@ -662,7 +697,6 @@ namespace __gnu_cxx\n           if (block != NULL)\n             {\n               __gthread_mutex_lock(_S_bin[bin].mutex);\n-\n               while (block != NULL)\n                 {\n                   if (_S_bin[bin].first[0] == NULL)\n@@ -671,14 +705,11 @@ namespace __gnu_cxx\n                     _S_bin[bin].last[0]->next = block;\n \n                   _S_bin[bin].last[0] = block;\n-\n                   block = block->next;\n-\n                   _S_bin[bin].free[0]++;\n                 }\n \n               _S_bin[bin].last[0]->next = NULL;\n-\n               __gthread_mutex_unlock(_S_bin[bin].mutex);\n             }\n         }\n@@ -687,18 +718,15 @@ namespace __gnu_cxx\n        * Return this thread id record to thread_freelist\n        */\n       __gthread_mutex_lock(&_S_thread_freelist_mutex);\n-\n       _S_thread_freelist_last->next = (thread_record*)freelist_pos;\n       _S_thread_freelist_last = (thread_record*)freelist_pos;\n       _S_thread_freelist_last->next = NULL;\n-\n       __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n-\n     }\n \n-  template<int __inst>\n+  template<typename _Tp>\n     size_t\n-    __mt_alloc<__inst>::\n+    __mt_alloc<_Tp>::\n     _S_get_thread_id()\n     {\n       /*\n@@ -714,16 +742,14 @@ namespace __gnu_cxx\n           if ((freelist_pos =\n               (thread_record*)__gthread_getspecific(_S_thread_key)) == NULL)\n             {\n-              __gthread_mutex_lock(&_S_thread_freelist_mutex);\n-\n               /*\n                * Since _S_max_threads must be larger than the\n                * theoretical max number of threads of the OS the list\n                * can never be empty.\n                */\n+              __gthread_mutex_lock(&_S_thread_freelist_mutex);\n               freelist_pos = _S_thread_freelist_first;\n               _S_thread_freelist_first = _S_thread_freelist_first->next;\n-\n               __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n \n               __gthread_setspecific(_S_thread_key, (void*)freelist_pos);\n@@ -754,23 +780,23 @@ namespace __gnu_cxx\n       return 0;\n     }\n \n-  template<int __inst> __gthread_once_t\n-  __mt_alloc<__inst>::_S_once_mt = __GTHREAD_ONCE_INIT;\n+  template<typename _Tp> __gthread_once_t\n+  __mt_alloc<_Tp>::_S_once_mt = __GTHREAD_ONCE_INIT;\n #endif\n \n-  template<int __inst> bool\n-  __mt_alloc<__inst>::_S_initialized = false;\n+  template<typename _Tp> bool\n+  __mt_alloc<_Tp>::_S_initialized = false;\n \n-  template<int __inst> typename __mt_alloc<__inst>::binmap_type*\n-  __mt_alloc<__inst>::_S_binmap = NULL;\n+  template<typename _Tp> typename __mt_alloc<_Tp>::binmap_type*\n+  __mt_alloc<_Tp>::_S_binmap = NULL;\n \n   /*\n    * Allocation requests (after round-up to power of 2) below this\n    * value will be handled by the allocator. A raw malloc/free() call\n    * will be used for requests larger than this value.\n    */\n-  template<int __inst> size_t\n-  __mt_alloc<__inst>::_S_max_bytes = 128;\n+  template<typename _Tp> size_t\n+  __mt_alloc<_Tp>::_S_max_bytes = 128;\n \n   /*\n    * In order to avoid fragmenting and minimize the number of malloc()\n@@ -779,21 +805,21 @@ namespace __gnu_cxx\n    * choosen the value below. See\n    * http://gcc.gnu.org/ml/libstdc++/2001-07/msg00077.html\n    */\n-  template<int __inst> size_t\n-  __mt_alloc<__inst>::_S_chunk_size = 4096 - 4 * sizeof(void*);\n+  template<typename _Tp> size_t\n+  __mt_alloc<_Tp>::_S_chunk_size = 4096 - 4 * sizeof(void*);\n \n   /*\n    * The maximum number of supported threads. Our Linux 2.4.18 reports\n    * 4070 in /proc/sys/kernel/threads-max\n    */\n-  template<int __inst> size_t\n-  __mt_alloc<__inst>::_S_max_threads = 4096;\n+  template<typename _Tp> size_t\n+  __mt_alloc<_Tp>::_S_max_threads = 4096;\n \n   /*\n    * Actual value calculated in _S_init()\n    */\n-  template<int __inst> size_t\n-  __mt_alloc<__inst>::_S_no_of_bins = 1;\n+  template<typename _Tp> size_t\n+  __mt_alloc<_Tp>::_S_no_of_bins = 1;\n \n   /*\n    * Each time a deallocation occurs in a threaded application we make\n@@ -802,63 +828,31 @@ namespace __gnu_cxx\n    * more than _S_freelist_headroom % of the freelist, we move these\n    * records back to the global pool.\n    */\n-  template<int __inst> size_t\n-  __mt_alloc<__inst>::_S_freelist_headroom = 10;\n+  template<typename _Tp> size_t\n+  __mt_alloc<_Tp>::_S_freelist_headroom = 10;\n \n   /*\n    * Actual initialization in _S_init()\n    */\n #ifdef __GTHREADS\n-  template<int __inst> typename __mt_alloc<__inst>::thread_record*\n-  __mt_alloc<__inst>::_S_thread_freelist_first = NULL;\n+  template<typename _Tp> typename __mt_alloc<_Tp>::thread_record*\n+  __mt_alloc<_Tp>::_S_thread_freelist_first = NULL;\n \n-  template<int __inst> typename __mt_alloc<__inst>::thread_record*\n-  __mt_alloc<__inst>::_S_thread_freelist_last = NULL;\n+  template<typename _Tp> typename __mt_alloc<_Tp>::thread_record*\n+  __mt_alloc<_Tp>::_S_thread_freelist_last = NULL;\n \n-  template<int __inst> __gthread_mutex_t\n-  __mt_alloc<__inst>::_S_thread_freelist_mutex = __GTHREAD_MUTEX_INIT;\n+  template<typename _Tp> __gthread_mutex_t\n+  __mt_alloc<_Tp>::_S_thread_freelist_mutex = __GTHREAD_MUTEX_INIT;\n \n   /*\n    * Actual initialization in _S_init()\n    */\n-  template<int __inst> __gthread_key_t\n-  __mt_alloc<__inst>::_S_thread_key;\n+  template<typename _Tp> __gthread_key_t\n+  __mt_alloc<_Tp>::_S_thread_key;\n #endif\n \n-  template<int __inst> typename __mt_alloc<__inst>::bin_record*\n-  __mt_alloc<__inst>::_S_bin = NULL;\n-\n-  template<int __inst>\n-    inline bool\n-    operator==(const __mt_alloc<__inst>&, const __mt_alloc<__inst>&)\n-    { return true; }\n-\n-  template<int __inst>\n-    inline bool\n-    operator!=(const __mt_alloc<__inst>&, const __mt_alloc<__inst>&)\n-    { return false; }\n+  template<typename _Tp> typename __mt_alloc<_Tp>::bin_record*\n+  __mt_alloc<_Tp>::_S_bin = NULL;\n } // namespace __gnu_cxx\n \n-namespace std\n-{\n-  template<typename _Tp, int __inst>\n-    struct _Alloc_traits<_Tp, __gnu_cxx::__mt_alloc<__inst> >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __gnu_cxx:: __mt_alloc<__inst>\t\tbase_alloc_type;\n-      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n-      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n-    };\n-\n-  template<typename _Tp, typename _Tp1, int __inst>\n-    struct _Alloc_traits<_Tp,\n-                         __allocator<_Tp1, __gnu_cxx::__mt_alloc<__inst> > >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __gnu_cxx:: __mt_alloc<__inst>\t\tbase_alloc_type;\n-      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n-      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n-    };\n-} // namespace std\n-\n #endif"}, {"sha": "6c8ca6349edde498e4178f296b711a207d12ca13", "filename": "libstdc++-v3/include/ext/new_allocator.h", "status": "modified", "additions": 62, "deletions": 17, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h?ref=d38d4e5d1800457ad097cb5e6dc35387998e6efa", "patch": "@@ -1,4 +1,4 @@\n-// Allocators -*- C++ -*-\n+// Allocator that wraps operator new -*- C++ -*-\n \n // Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n@@ -35,24 +35,69 @@\n namespace __gnu_cxx\n {\n   /**\n-   *  @if maint\n-   *  A new-based allocator, as required by the standard.  Allocation and\n-   *  deallocation forward to global new and delete.  \"SGI\" style, minus\n-   *  reallocate().\n-   *  @endif\n+   *  @brief  An allocator that uses global new, as per [20.4].\n+   *\n+   *  This is precisely the allocator defined in the C++ Standard. \n+   *    - all allocation calls operator new\n+   *    - all deallocation calls operator delete\n+   *\n    *  (See @link Allocators allocators info @endlink for more.)\n    */\n-  class __new_alloc\n-  {\n-  public:\n-    static void*\n-    allocate(size_t __n)\n-    { return ::operator new(__n); }\n-\n-    static void\n-    deallocate(void* __p, size_t)\n-    { ::operator delete(__p); }\n-  };\n+  template<typename _Tp>\n+    class new_allocator\n+    {\n+    public:\n+      typedef size_t     size_type;\n+      typedef ptrdiff_t  difference_type;\n+      typedef _Tp*       pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp&       reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp        value_type;\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef new_allocator<_Tp1> other; };\n+\n+      new_allocator() throw() { }\n+\n+      new_allocator(const new_allocator&) throw() { }\n+\n+      template<typename _Tp1>\n+        new_allocator(const new_allocator<_Tp1>&) throw() { }\n+\n+      ~new_allocator() throw() { }\n+\n+      pointer\n+      address(reference __x) const { return &__x; }\n+\n+      const_pointer\n+      address(const_reference __x) const { return &__x; }\n+\n+      // NB: __n is permitted to be 0.  The C++ standard says nothing\n+      // about what the return value is when __n == 0.\n+      pointer\n+      allocate(size_type __n, allocator<void>::const_pointer __h = 0)\n+      { return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp))); }\n+\n+      // __p is not permitted to be a null pointer.\n+      void\n+      deallocate(pointer __p, size_type __n)\n+      { ::operator delete(__p); }\n+\n+      size_type\n+      max_size() const throw() \n+      { return size_t(-1) / sizeof(_Tp); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 402. wrong new expression in [some_] allocator::construct\n+      void \n+      construct(pointer __p, const _Tp& __val) \n+      { ::new(__p) _Tp(__val); }\n+\n+      void \n+      destroy(pointer __p) { __p->~_Tp(); }\n+    };\n } // namespace __gnu_cxx\n \n #endif"}, {"sha": "cb2df02997e3f862d43c5fdbf0768f291c662304", "filename": "libstdc++-v3/include/ext/pool_allocator.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h?ref=d38d4e5d1800457ad097cb5e6dc35387998e6efa", "patch": "@@ -44,15 +44,14 @@\n  *  This file is a GNU extension to the Standard C++ Library.\n  *  You should only include this header if you are using GCC 3 or later.\n  */\n-\n #ifndef _POOL_ALLOCATOR_H\n #define _POOL_ALLOCATOR_H 1\n \n+#include <new>\n #include <bits/functexcept.h>\n #include <bits/stl_threads.h>\n #include <bits/atomicity.h>\n #include <bits/allocator_traits.h>\n-#include <ext/new_allocator.h>\n \n namespace __gnu_cxx\n {\n@@ -65,9 +64,9 @@ namespace __gnu_cxx\n    *  when in default high-speed pool mode).\n    *\n    *  Important implementation properties:\n-   *  0. If globally mandated, then allocate objects from __new_alloc\n+   *  0. If globally mandated, then allocate objects from new\n    *  1. If the clients request an object of size > _S_max_bytes, the resulting\n-   *     object will be obtained directly from __new_alloc\n+   *     object will be obtained directly from new\n    *  2. In all other cases, we allocate an object of size exactly\n    *     _S_round_up(requested_size).  Thus the client has enough size\n    *     information that we can return the object to the proper free list\n@@ -201,7 +200,7 @@ namespace __gnu_cxx\n               ((_Obj*)(void*)_S_start_free)->_M_free_list_link = *__free_list;\n               *__free_list = (_Obj*)(void*)_S_start_free;\n             }\n-          _S_start_free = (char*) __new_alloc::allocate(__bytes_to_get);\n+          _S_start_free = new char[__bytes_to_get];\n           if (_S_start_free == 0)\n             {\n               size_t __i;\n@@ -226,7 +225,7 @@ namespace __gnu_cxx\n                     }\n                 }\n               _S_end_free = 0;        // In case of exception.\n-              _S_start_free = (char*)__new_alloc::allocate(__bytes_to_get);\n+              _S_start_free = new char[__bytes_to_get];\n               // This should either throw an exception or remedy the situation.\n               // Thus we assume it succeeded.\n             }\n@@ -291,7 +290,7 @@ namespace __gnu_cxx\n \t}\n \n       if ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n-\t__ret = __new_alloc::allocate(__n);\n+\t__ret = new char[__n];\n       else\n \t{\n \t  _Obj* volatile* __free_list = _S_free_list + _S_freelist_index(__n);\n@@ -318,7 +317,7 @@ namespace __gnu_cxx\n     __pool_alloc<__threads, __inst>::deallocate(void* __p, size_t __n)\n     {\n       if ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n-\t__new_alloc::deallocate(__p, __n);\n+\tdelete [] __p;\n       else\n \t{\n \t  _Obj* volatile* __free_list = _S_free_list + _S_freelist_index(__n);"}, {"sha": "7e4e9f98aa4cdfab7cb3691d5dab82a136f7837e", "filename": "libstdc++-v3/testsuite/ext/allocators.cc", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc?ref=d38d4e5d1800457ad097cb5e6dc35387998e6efa", "patch": "@@ -22,25 +22,23 @@\n \n #include <cstdlib>\n #include <memory>\n-#include <ext/pool_allocator.h>\n+//#include <ext/pool_allocator.h>\n #include <ext/debug_allocator.h>\n #include <ext/malloc_allocator.h>\n #include <testsuite_hooks.h>\n \n-using __gnu_cxx::__malloc_alloc;\n-using __gnu_cxx::__debug_alloc;\n-using __gnu_cxx::__pool_alloc;\n+using __gnu_cxx::malloc_allocator;\n+using __gnu_cxx::debug_allocator;\n \n-template class __malloc_alloc<3>;\n-template class __debug_alloc<__malloc_alloc<3> >;\n-template class __pool_alloc<true, 3>;\n-template class __pool_alloc<false, 3>;\n \n-struct big\n-{\n-  long f[15];\n-};\n+template class malloc_allocator<int>;\n+template class debug_allocator<malloc_allocator<int> >;\n \n+#if 0\n+using __gnu_cxx::__pool_alloc;\n+template class __pool_alloc<true, 3>;\n+template class __pool_alloc<false, 3>;\n+#endif\n \n bool         new_called;\n bool         delete_called;\n@@ -69,31 +67,39 @@ void check_allocator()\n   delete_called = false;\n   requested = 0;\n \n-  std::__allocator<big, Alloc>   a;\n-  big *p = a.allocate(10);\n+  Alloc  a;\n+  typename Alloc::pointer p = a.allocate(10);\n   if (uses_global_new_and_delete)  \n     VERIFY( requested >= (10 * 15 * sizeof(long)) );\n \n-  // Touch the far end of supposedly-allocated memory to check that we got\n-  // all of it.  Why \"3\"?  Because it's my favorite integer between e and pi.\n-  p[9].f[14] = 3;\n   VERIFY( new_called == uses_global_new_and_delete );\n-  a.deallocate(p,10);\n+  a.deallocate(p, 10);\n   VERIFY( delete_called == uses_global_new_and_delete );\n }\n \n // These just help tracking down error messages.\n-void test01() { check_allocator<__malloc_alloc<3>, false>(); }\n-void test02() { check_allocator<__debug_alloc<__malloc_alloc<3> >, false>(); }\n-void test03() { check_allocator<__pool_alloc<true, 3>, true>(); }\n-void test04() { check_allocator<__pool_alloc<false, 3>, true>(); }\n+void test01() \n+{ check_allocator<malloc_allocator<int>, false>(); }\n+\n+void test02() \n+{ check_allocator<debug_allocator<malloc_allocator<int> >, false>(); }\n+\n+#if 0\n+void test03() \n+{ check_allocator<__pool_alloc<true, 3>, true>(); }\n+\n+void test04() \n+{ check_allocator<__pool_alloc<false, 3>, true>(); }\n+#endif\n \n int main()\n {\n   test01();\n   test02();\n+#if 0\n   test03();\n   test04();\n+#endif\n   return 0;\n }\n "}, {"sha": "e4a5ad47766399fa127d87ab1fff38495251577d", "filename": "libstdc++-v3/testsuite/performance/allocator.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38d4e5d1800457ad097cb5e6dc35387998e6efa/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fallocator.cc?ref=d38d4e5d1800457ad097cb5e6dc35387998e6efa", "patch": "@@ -61,7 +61,7 @@\n #include <testsuite_performance.h>\n \n using namespace std;\n-using __gnu_cxx::__malloc_alloc;\n+using __gnu_cxx::malloc_allocator;\n using __gnu_cxx::__mt_alloc;\n \n /*\n@@ -155,7 +155,7 @@ test_ints_malloc_alloc(int iterations)\n   tstart();\n   for(int i = 0; i < iterations; i++)\n   {\n-    vector<int, __malloc_alloc<0> > v1;\n+    vector<int, malloc_allocator<int> > v1;\n \n     for(int j = 0; j < insert_values; j++)\n     {\n@@ -173,7 +173,7 @@ test_ints_mt_alloc(int iterations)\n   tstart();\n   for(int i = 0; i < iterations; i++)\n   {\n-    vector<int, __mt_alloc<0> > v1;\n+    vector<int, __mt_alloc<int> > v1;\n \n     for(int j = 0; j < insert_values; j++)\n     {"}]}