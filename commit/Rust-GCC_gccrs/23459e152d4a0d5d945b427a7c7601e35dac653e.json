{"sha": "23459e152d4a0d5d945b427a7c7601e35dac653e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM0NTllMTUyZDRhMGQ1ZDk0NWI0MjdhN2M3NjAxZTM1ZGFjNjUzZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-20T01:47:50Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-20T01:47:50Z"}, "message": "* protoize.c: Fix formatting.\n\nFrom-SVN: r53644", "tree": {"sha": "fb371c51d6aad2804e172e18df064cab39c0ca3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb371c51d6aad2804e172e18df064cab39c0ca3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23459e152d4a0d5d945b427a7c7601e35dac653e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23459e152d4a0d5d945b427a7c7601e35dac653e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23459e152d4a0d5d945b427a7c7601e35dac653e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23459e152d4a0d5d945b427a7c7601e35dac653e/comments", "author": null, "committer": null, "parents": [{"sha": "174cc7d12781fcced14be9b0af9ab7e1b9120206", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174cc7d12781fcced14be9b0af9ab7e1b9120206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174cc7d12781fcced14be9b0af9ab7e1b9120206"}], "stats": {"total": 1536, "additions": 770, "deletions": 766}, "files": [{"sha": "1ec26fe03ce734301863d7e62137d84c5c37a02e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23459e152d4a0d5d945b427a7c7601e35dac653e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23459e152d4a0d5d945b427a7c7601e35dac653e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23459e152d4a0d5d945b427a7c7601e35dac653e", "patch": "@@ -1,3 +1,7 @@\n+2002-05-19  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* protoize.c: Fix formatting.\n+\n 2002-05-19  Richard Henderson  <rth@redhat.com>\n \n \t* gensupport.c (init_include_reader): Merge into ..."}, {"sha": "98179bc6cf3d125dd672e224abd492db46524ec1", "filename": "gcc/protoize.c", "status": "modified", "additions": 766, "deletions": 766, "changes": 1532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23459e152d4a0d5d945b427a7c7601e35dac653e/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23459e152d4a0d5d945b427a7c7601e35dac653e/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=23459e152d4a0d5d945b427a7c7601e35dac653e", "patch": "@@ -577,8 +577,8 @@ substr (s1, s2)\n       int c;\n \n       for (p1 = s1, p2 = s2; (c = *p2); p1++, p2++)\n-        if (*p1 != c)\n-          goto outer;\n+\tif (*p1 != c)\n+\t  goto outer;\n       return s1;\n outer:\n       ;\n@@ -730,8 +730,8 @@ file_could_be_converted (const char *path)\n     {\n       char *slash;\n \n-      slash = strrchr (dir_last_slash ? dir_last_slash : dir_name, \n-                       DIR_SEPARATOR_2);\n+      slash = strrchr (dir_last_slash ? dir_last_slash : dir_name,\n+\t\t       DIR_SEPARATOR_2);\n       if (slash)\n \tdir_last_slash = slash;\n     }\n@@ -774,8 +774,8 @@ file_normally_convertible (const char *path)\n     {\n       char *slash;\n \n-      slash = strrchr (dir_last_slash ? dir_last_slash : dir_name, \n-                       DIR_SEPARATOR_2);\n+      slash = strrchr (dir_last_slash ? dir_last_slash : dir_name,\n+\t\t       DIR_SEPARATOR_2);\n       if (slash)\n \tdir_last_slash = slash;\n     }\n@@ -789,23 +789,23 @@ file_normally_convertible (const char *path)\n   if (access (path, R_OK))\n     {\n       if (!quiet_flag)\n-        notice (\"%s: warning: no read access for file `%s'\\n\",\n+\tnotice (\"%s: warning: no read access for file `%s'\\n\",\n \t\tpname, shortpath (NULL, path));\n       return 0;\n     }\n \n   if (access (path, W_OK))\n     {\n       if (!quiet_flag)\n-        notice (\"%s: warning: no write access for file `%s'\\n\",\n+\tnotice (\"%s: warning: no write access for file `%s'\\n\",\n \t\tpname, shortpath (NULL, path));\n       return 0;\n     }\n \n   if (access (dir_name, W_OK))\n     {\n       if (!quiet_flag)\n-        notice (\"%s: warning: no write access for dir containing `%s'\\n\",\n+\tnotice (\"%s: warning: no write access for dir containing `%s'\\n\",\n \t\tpname, shortpath (NULL, path));\n       return 0;\n     }\n@@ -870,8 +870,8 @@ needs_to_be_converted (file_p)\n \n #endif /* defined (UNPROTOIZE) */\n       )\n-          /* ... then the containing file needs converting.  */\n-          return -1;\n+\t  /* ... then the containing file needs converting.  */\n+\t  return -1;\n   return 0;\n }\n \n@@ -955,11 +955,11 @@ visit_each_hash_node (hash_tab_p, func)\n   for (primary = hash_tab_p; primary < &hash_tab_p[HASH_TABLE_SIZE]; primary++)\n     if (primary->symbol)\n       {\n-        hash_table_entry *second;\n+\thash_table_entry *second;\n \n-        (*func)(primary);\n-        for (second = primary->hash_next; second; second = second->hash_next)\n-          (*func) (second);\n+\t(*func)(primary);\n+\tfor (second = primary->hash_next; second; second = second->hash_next)\n+\t  (*func) (second);\n       }\n }\n \n@@ -1006,7 +1006,7 @@ lookup (hash_tab_p, search_symbol)\n     {\n       p = p->hash_next;\n       if (!strcmp (p->symbol, search_symbol))\n-        return p;\n+\treturn p;\n     }\n   p->hash_next = (hash_table_entry *) xmalloc (sizeof (hash_table_entry));\n   p = p->hash_next;\n@@ -1031,8 +1031,8 @@ free_def_dec (p)\n \n     for (curr = p->f_list_chain; curr; curr = next)\n       {\n-        next = curr->chain_next;\n-        free ((NONCONST PTR) curr);\n+\tnext = curr->chain_next;\n+\tfree ((NONCONST PTR) curr);\n       }\n   }\n #endif /* !defined (UNPROTOIZE) */\n@@ -1069,14 +1069,14 @@ unexpand_if_needed (aux_info_line)\n   for (s = aux_info_line; *s != '\\n'; )\n     {\n       for (unexp_p = unexpansions; unexp_p->expanded; unexp_p++)\n-        {\n-          const char *in_p = unexp_p->expanded;\n-          size_t len = strlen (in_p);\n+\t{\n+\t  const char *in_p = unexp_p->expanded;\n+\t  size_t len = strlen (in_p);\n \n-          if (*s == *in_p && !strncmp (s, in_p, len) && !is_id_char (s[len]))\n-            {\n+\t  if (*s == *in_p && !strncmp (s, in_p, len) && !is_id_char (s[len]))\n+\t    {\n \t      int size = strlen (unexp_p->contracted);\n-              got_unexpanded = 1;\n+\t      got_unexpanded = 1;\n \t      if (copy_p + size - line_buf >= line_buf_size)\n \t\t{\n \t\t  int offset = copy_p - line_buf;\n@@ -1085,16 +1085,16 @@ unexpand_if_needed (aux_info_line)\n \t\t  line_buf = (char *) xrealloc (line_buf, line_buf_size);\n \t\t  copy_p = line_buf + offset;\n \t\t}\n-              strcpy (copy_p, unexp_p->contracted);\n-              copy_p += size;\n+\t      strcpy (copy_p, unexp_p->contracted);\n+\t      copy_p += size;\n \n-              /* Assume that there will not be another replacement required\n-                 within the text just replaced.  */\n+\t      /* Assume that there will not be another replacement required\n+\t         within the text just replaced.  */\n \n-              s += len;\n-              goto continue_outer;\n-            }\n-        }\n+\t      s += len;\n+\t      goto continue_outer;\n+\t    }\n+\t}\n       if (copy_p - line_buf == line_buf_size)\n \t{\n \t  int offset = copy_p - line_buf;\n@@ -1126,10 +1126,10 @@ is_abspath (path)\n {\n   return (IS_DIR_SEPARATOR (path[0])\n #ifdef HAVE_DOS_BASED_FILE_SYSTEM\n-          /* Check for disk name on MS-DOS-based systems.  */\n-          || (path[0] && path[1] == ':' && IS_DIR_SEPARATOR (path[2]))\n+\t  /* Check for disk name on MS-DOS-based systems.  */\n+\t  || (path[0] && path[1] == ':' && IS_DIR_SEPARATOR (path[2]))\n #endif\n-          );\n+\t  );\n }\n \f\n /* Return the absolutized filename for the given relative\n@@ -1162,16 +1162,16 @@ abspath (cwd, rel_filename)\n \n     if (! is_abspath (rel_filename))\n       {\n-        src_p = cwd2;\n-        while ((*endp++ = *src_p++))\n-          continue;\n-        *(endp-1) = DIR_SEPARATOR;     \t\t/* overwrite null */\n+\tsrc_p = cwd2;\n+\twhile ((*endp++ = *src_p++))\n+\t  continue;\n+\t*(endp-1) = DIR_SEPARATOR;     \t\t/* overwrite null */\n       }\n #ifdef HAVE_DOS_BASED_FILE_SYSTEM\n     else if (IS_DIR_SEPARATOR (rel_filename[0]))\n       {\n-\t/* A path starting with a directory separator is considered absolute \n-\t   for dos based filesystems, but it's really not -- it's just the \n+\t/* A path starting with a directory separator is considered absolute\n+\t   for dos based filesystems, but it's really not -- it's just the\n \t   convention used throughout GCC and it works. However, in this\n \t   case, we still need to prepend the drive spec from cwd_buffer.  */\n \t*endp++ = cwd2[0];\n@@ -1195,42 +1195,42 @@ abspath (cwd, rel_filename)\n   for (;;)\n     {\n       if (!inp[0])\n-        break;\n+\tbreak;\n       else if (IS_DIR_SEPARATOR (inp[0]) && IS_DIR_SEPARATOR (outp[-1]))\n-        {\n-          inp++;\n-          continue;\n-        }\n+\t{\n+\t  inp++;\n+\t  continue;\n+\t}\n       else if (inp[0] == '.' && IS_DIR_SEPARATOR (outp[-1]))\n-        {\n-          if (!inp[1])\n-                  break;\n-          else if (IS_DIR_SEPARATOR (inp[1]))\n-            {\n-                    inp += 2;\n-                    continue;\n-            }\n-          else if ((inp[1] == '.') && (inp[2] == 0 \n+\t{\n+\t  if (!inp[1])\n+\t    break;\n+\t  else if (IS_DIR_SEPARATOR (inp[1]))\n+\t    {\n+\t      inp += 2;\n+\t      continue;\n+\t    }\n+\t  else if ((inp[1] == '.') && (inp[2] == 0\n \t                               || IS_DIR_SEPARATOR (inp[2])))\n-            {\n-                    inp += (IS_DIR_SEPARATOR (inp[2])) ? 3 : 2;\n-                    outp -= 2;\n-                    while (outp >= abs_buffer && ! IS_DIR_SEPARATOR (*outp))\n-              \toutp--;\n-                    if (outp < abs_buffer)\n-\t\t      {\n-\t\t\t/* Catch cases like /.. where we try to backup to a\n-\t\t\t   point above the absolute root of the logical file\n-\t\t\t   system.  */\n-\n-\t\t\tnotice (\"%s: invalid file name: %s\\n\",\n-\t\t\t\tpname, rel_filename);\n-\t\t\texit (FATAL_EXIT_CODE);\n-\t\t      }\n-                    *++outp = '\\0';\n-                    continue;\n-\t\t  }\n-        }\n+\t    {\n+\t      inp += (IS_DIR_SEPARATOR (inp[2])) ? 3 : 2;\n+\t      outp -= 2;\n+\t      while (outp >= abs_buffer && ! IS_DIR_SEPARATOR (*outp))\n+\t      \toutp--;\n+\t      if (outp < abs_buffer)\n+\t\t{\n+\t\t  /* Catch cases like /.. where we try to backup to a\n+\t\t     point above the absolute root of the logical file\n+\t\t     system.  */\n+\n+\t\t  notice (\"%s: invalid file name: %s\\n\",\n+\t\t\t  pname, rel_filename);\n+\t\t  exit (FATAL_EXIT_CODE);\n+\t\t}\n+\t      *++outp = '\\0';\n+\t      continue;\n+\t    }\n+\t}\n       *outp++ = *inp++;\n     }\n \n@@ -1285,29 +1285,29 @@ shortpath (cwd, filename)\n     {\n       /* whole pwd matched */\n       if (!*path_p)        \t/* input *is* the current path! */\n-        return \".\";\n+\treturn \".\";\n       else\n-        return ++path_p;\n+\treturn ++path_p;\n     }\n   else\n     {\n       if (*path_p)\n-        {\n-          --cwd_p;\n-          --path_p;\n-          while (! IS_DIR_SEPARATOR (*cwd_p))     /* backup to last slash */\n-            {\n-              --cwd_p;\n-              --path_p;\n-            }\n-          cwd_p++;\n-          path_p++;\n-          unmatched_slash_count++;\n-        }\n+\t{\n+\t  --cwd_p;\n+\t  --path_p;\n+\t  while (! IS_DIR_SEPARATOR (*cwd_p))     /* backup to last slash */\n+\t    {\n+\t      --cwd_p;\n+\t      --path_p;\n+\t    }\n+\t  cwd_p++;\n+\t  path_p++;\n+\t  unmatched_slash_count++;\n+\t}\n \n       /* Find out how many directory levels in cwd were *not* matched.  */\n       while (*cwd_p++)\n-        if (IS_DIR_SEPARATOR (*(cwd_p-1)))\n+\tif (IS_DIR_SEPARATOR (*(cwd_p-1)))\n \t  unmatched_slash_count++;\n \n       /* Now we know how long the \"short name\" will be.\n@@ -1317,15 +1317,15 @@ shortpath (cwd, filename)\n \n       /* For each of them, put a `../' at the beginning of the short name.  */\n       while (unmatched_slash_count--)\n-        {\n+\t{\n \t  /* Give up if the result gets to be longer\n \t     than the absolute path name.  */\n \t  if (rel_buffer + filename_len <= rel_buf_p + 3)\n \t    return filename;\n-          *rel_buf_p++ = '.';\n-          *rel_buf_p++ = '.';\n-          *rel_buf_p++ = DIR_SEPARATOR;\n-        }\n+\t  *rel_buf_p++ = '.';\n+\t  *rel_buf_p++ = '.';\n+\t  *rel_buf_p++ = DIR_SEPARATOR;\n+\t}\n \n       /* Then tack on the unmatched part of the desired file's name.  */\n       do\n@@ -1337,7 +1337,7 @@ shortpath (cwd, filename)\n \n       --rel_buf_p;\n       if (IS_DIR_SEPARATOR (*(rel_buf_p-1)))\n-        *--rel_buf_p = '\\0';\n+\t*--rel_buf_p = '\\0';\n       return rel_buffer;\n     }\n }\n@@ -1366,21 +1366,21 @@ find_file (filename, do_not_stat)\n       file_info *file_p = (file_info *) xmalloc (sizeof (file_info));\n \n       /* If we cannot get status on any given source file, give a warning\n-         and then just set its time of last modification to infinity.  */\n+\t and then just set its time of last modification to infinity.  */\n \n       if (do_not_stat)\n-        stat_buf.st_mtime = (time_t) 0;\n+\tstat_buf.st_mtime = (time_t) 0;\n       else\n-        {\n-          if (stat (filename, &stat_buf) == -1)\n-            {\n+\t{\n+\t  if (stat (filename, &stat_buf) == -1)\n+\t    {\n \t      int errno_val = errno;\n-              notice (\"%s: %s: can't get status: %s\\n\",\n+\t      notice (\"%s: %s: can't get status: %s\\n\",\n \t\t      pname, shortpath (NULL, filename),\n \t\t      xstrerror (errno_val));\n-              stat_buf.st_mtime = (time_t) -1;\n-            }\n-        }\n+\t      stat_buf.st_mtime = (time_t) -1;\n+\t    }\n+\t}\n \n       hash_entry_p->fip = file_p;\n       file_p->hash_entry = hash_entry_p;\n@@ -1426,14 +1426,14 @@ find_corresponding_lparen (p)\n   for (paren_depth = 1, q = p-1; paren_depth; q--)\n     {\n       switch (*q)\n-        {\n-          case ')':\n-            paren_depth++;\n-            break;\n-          case '(':\n-            paren_depth--;\n-            break;\n-        }\n+\t{\n+\tcase ')':\n+\t  paren_depth++;\n+\t  break;\n+\tcase '(':\n+\t  paren_depth--;\n+\t  break;\n+\t}\n     }\n   return ++q;\n }\n@@ -1461,9 +1461,9 @@ referenced_file_is_newer (l, aux_info_mtime)\n \n     while (*p != ':'\n #ifdef HAVE_DOS_BASED_FILE_SYSTEM\n-           || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n+\t   || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n #endif\n-           )\n+\t   )\n       p++;\n     filename = (char *) alloca ((size_t) (p - filename_start) + 1);\n     strncpy (filename, filename_start, (size_t) (p - filename_start));\n@@ -1523,9 +1523,9 @@ save_def_or_dec (l, is_syscalls)\n \n     while (*p != ':'\n #ifdef HAVE_DOS_BASED_FILE_SYSTEM\n-           || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n+\t   || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n #endif\n-           )\n+\t   )\n       p++;\n     filename = (char *) alloca ((size_t) (p - filename_start) + 1);\n     strncpy (filename, filename_start, (size_t) (p - filename_start));\n@@ -1535,7 +1535,7 @@ save_def_or_dec (l, is_syscalls)\n        which contained this particular def or dec item.  Note that this call\n        may cause a new file_info record to be created if this is the first time\n        that we have ever known about this particular file.\n-  \n+\n        Note that we started out by forcing all of the base source file names\n        (i.e. the names of the aux_info files with the .X stripped off) into the\n        filenames hash table, and we simultaneously setup file_info records for\n@@ -1544,7 +1544,7 @@ save_def_or_dec (l, is_syscalls)\n        act as file_info records for the \"original\" (i.e. un-included) files\n        which were submitted to gcc for compilation (when the -aux-info\n        option was used).  */\n-  \n+\n     def_dec_p->file = find_file (abspath (invocation_filename, filename), is_syscalls);\n   }\n \n@@ -1554,9 +1554,9 @@ save_def_or_dec (l, is_syscalls)\n \n     while (*p != ':'\n #ifdef HAVE_DOS_BASED_FILE_SYSTEM\n-           || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n+\t   || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n #endif\n-           )\n+\t   )\n       p++;\n     strncpy (line_number, line_number_start, (size_t) (p - line_number_start));\n     line_number[p-line_number_start] = '\\0';\n@@ -1657,32 +1657,32 @@ save_def_or_dec (l, is_syscalls)\n       const char *left_paren_p = find_corresponding_lparen (p);\n #ifndef UNPROTOIZE\n       {\n-        f_list_chain_item *cip\n+\tf_list_chain_item *cip\n \t  = (f_list_chain_item *) xmalloc (sizeof (f_list_chain_item));\n \n-        cip->formals_list\n+\tcip->formals_list\n \t  = dupnstr (left_paren_p + 1, (size_t) (p - (left_paren_p+1)));\n-      \n-        /* Add the new chain item at the head of the current list.  */\n \n-        cip->chain_next = def_dec_p->f_list_chain;\n-        def_dec_p->f_list_chain = cip;\n+\t/* Add the new chain item at the head of the current list.  */\n+\n+\tcip->chain_next = def_dec_p->f_list_chain;\n+\tdef_dec_p->f_list_chain = cip;\n       }\n #endif /* !defined (UNPROTOIZE) */\n       def_dec_p->f_list_count++;\n \n       p = left_paren_p - 2;\n \n       /* p must now point either to another right paren, or to the last\n-         character of the name of the function that was declared/defined.\n-         If p points to another right paren, then this indicates that we\n-         are dealing with multiple formals lists.  In that case, there\n-         really should be another right paren preceding this right paren.  */\n+\t character of the name of the function that was declared/defined.\n+\t If p points to another right paren, then this indicates that we\n+\t are dealing with multiple formals lists.  In that case, there\n+\t really should be another right paren preceding this right paren.  */\n \n       if (*p != ')')\n-        break;\n+\tbreak;\n       else\n-        check_aux_info (*--p == ')');\n+\tcheck_aux_info (*--p == ')');\n     }\n \n \n@@ -1728,19 +1728,19 @@ save_def_or_dec (l, is_syscalls)\n \n     for (other = def_dec_p->hash_entry->ddip; other; other = other->next_for_func)\n       {\n-        if (def_dec_p->line == other->line && def_dec_p->file == other->file)\n-          {\n-            if (strcmp (def_dec_p->ansi_decl, other->ansi_decl))\n-              {\n-                notice (\"%s:%d: declaration of function `%s' takes different forms\\n\",\n+\tif (def_dec_p->line == other->line && def_dec_p->file == other->file)\n+\t  {\n+\t    if (strcmp (def_dec_p->ansi_decl, other->ansi_decl))\n+\t      {\n+\t        notice (\"%s:%d: declaration of function `%s' takes different forms\\n\",\n \t\t\tdef_dec_p->file->hash_entry->symbol,\n \t\t\tdef_dec_p->line,\n \t\t\tdef_dec_p->hash_entry->symbol);\n-                exit (FATAL_EXIT_CODE);\n-              }\n-            free_def_dec (def_dec_p);\n-            return;\n-          }\n+\t        exit (FATAL_EXIT_CODE);\n+\t      }\n+\t    free_def_dec (def_dec_p);\n+\t    return;\n+\t  }\n       }\n   }\n \n@@ -1772,58 +1772,58 @@ save_def_or_dec (l, is_syscalls)\n       check_aux_info (*++p == '(');\n \n       {\n-        const char *kr_names_start = ++p;   /* Point just inside '('.  */\n+\tconst char *kr_names_start = ++p;   /* Point just inside '('.  */\n \n-        while (*p++ != ')')\n-          continue;\n-        p--;\t\t/* point to closing right paren */\n+\twhile (*p++ != ')')\n+\t  continue;\n+\tp--;\t\t/* point to closing right paren */\n \n-        /* Make a copy of the K&R parameter names list.  */\n+\t/* Make a copy of the K&R parameter names list.  */\n \n-        def_dec_p->formal_names\n+\tdef_dec_p->formal_names\n \t  = dupnstr (kr_names_start, (size_t) (p - kr_names_start));\n       }\n \n       check_aux_info (*++p == ' ');\n       p++;\n \n       /* p now points to the first character of the K&R style declarations\n-         list (if there is one) or to the star-slash combination that ends\n-         the comment in which such lists get embedded.  */\n+\t list (if there is one) or to the star-slash combination that ends\n+\t the comment in which such lists get embedded.  */\n \n       /* Make a copy of the K&R formal decls list and set the def_dec record\n-         to point to it.  */\n+\t to point to it.  */\n \n       if (*p == '*')\t\t/* Are there no K&R declarations? */\n-        {\n-          check_aux_info (*++p == '/');\n-          def_dec_p->formal_decls = \"\";\n-        }\n+\t{\n+\t  check_aux_info (*++p == '/');\n+\t  def_dec_p->formal_decls = \"\";\n+\t}\n       else\n-        {\n-          const char *kr_decls_start = p;\n+\t{\n+\t  const char *kr_decls_start = p;\n \n-          while (p[0] != '*' || p[1] != '/')\n-            p++;\n-          p--;\n+\t  while (p[0] != '*' || p[1] != '/')\n+\t    p++;\n+\t  p--;\n \n-          check_aux_info (*p == ' ');\n+\t  check_aux_info (*p == ' ');\n \n-          def_dec_p->formal_decls\n+\t  def_dec_p->formal_decls\n \t    = dupnstr (kr_decls_start, (size_t) (p - kr_decls_start));\n-        }\n+\t}\n \n       /* Handle a special case.  If we have a function definition marked as\n-         being in \"old\" style, and if its formal names list is empty, then\n-         it may actually have the string \"void\" in its real formals list\n-         in the original source code.  Just to make sure, we will get setup\n-         to convert such things anyway.\n+\t being in \"old\" style, and if its formal names list is empty, then\n+\t it may actually have the string \"void\" in its real formals list\n+\t in the original source code.  Just to make sure, we will get setup\n+\t to convert such things anyway.\n \n-         This kludge only needs to be here because of an insurmountable\n-         problem with generating .X files.  */\n+\t This kludge only needs to be here because of an insurmountable\n+\t problem with generating .X files.  */\n \n       if (!def_dec_p->prototyped && !*def_dec_p->formal_names)\n-        def_dec_p->prototyped = 1;\n+\tdef_dec_p->prototyped = 1;\n     }\n \n   /* Since we are unprotoizing, if this item is already in old (K&R) style,\n@@ -1861,25 +1861,25 @@ save_def_or_dec (l, is_syscalls)\n       const def_dec_info *next = curr->next_in_file;\n \n       while (next && (line < curr->line))\n-        {\n-          prev = curr;\n-          curr = next;\n-          next = next->next_in_file;\n-        }\n+\t{\n+\t  prev = curr;\n+\t  curr = next;\n+\t  next = next->next_in_file;\n+\t}\n       if (line >= curr->line)\n-        {\n-          def_dec_p->next_in_file = curr;\n-          if (prev)\n-            ((NONCONST def_dec_info *) prev)->next_in_file = def_dec_p;\n-          else\n-            def_dec_p->file->defs_decs = def_dec_p;\n-        }\n+\t{\n+\t  def_dec_p->next_in_file = curr;\n+\t  if (prev)\n+\t    ((NONCONST def_dec_info *) prev)->next_in_file = def_dec_p;\n+\t  else\n+\t    def_dec_p->file->defs_decs = def_dec_p;\n+\t}\n       else\t/* assert (next == NULL); */\n-        {\n-          ((NONCONST def_dec_info *) curr)->next_in_file = def_dec_p;\n-          /* assert (next == NULL); */\n-          def_dec_p->next_in_file = next;\n-        }\n+\t{\n+\t  ((NONCONST def_dec_info *) curr)->next_in_file = def_dec_p;\n+\t  /* assert (next == NULL); */\n+\t  def_dec_p->next_in_file = next;\n+\t}\n     }\n }\n \f\n@@ -1906,38 +1906,38 @@ munge_compile_params (params_list)\n   for (;;)\n     {\n       while (ISSPACE ((const unsigned char)*params_list))\n-        params_list++;\n+\tparams_list++;\n       if (!*params_list)\n-        break;\n+\tbreak;\n       param = params_list;\n       while (*params_list && !ISSPACE ((const unsigned char)*params_list))\n-        params_list++;\n+\tparams_list++;\n       if (param[0] != '-')\n-        temp_params[param_count++]\n+\ttemp_params[param_count++]\n \t  = dupnstr (param, (size_t) (params_list - param));\n       else\n-        {\n-          switch (param[1])\n-            {\n-              case 'g':\n-              case 'O':\n-              case 'S':\n-              case 'c':\n-                break;\t\t/* Don't copy these.  */\n-              case 'o':\n-                while (ISSPACE ((const unsigned char)*params_list))\n-                  params_list++;\n-                while (*params_list\n-\t\t       && !ISSPACE ((const unsigned char)*params_list))\n-                  params_list++;\n-                break;\n-              default:\n-                temp_params[param_count++]\n-\t\t  = dupnstr (param, (size_t) (params_list - param));\n-            }\n-        }\n+\t{\n+\t  switch (param[1])\n+\t    {\n+\t    case 'g':\n+\t    case 'O':\n+\t    case 'S':\n+\t    case 'c':\n+\t      break;\t\t/* Don't copy these.  */\n+\t    case 'o':\n+\t      while (ISSPACE ((const unsigned char)*params_list))\n+\t\tparams_list++;\n+\t      while (*params_list\n+\t\t     && !ISSPACE ((const unsigned char)*params_list))\n+\t\tparams_list++;\n+\t      break;\n+\t    default:\n+\t      temp_params[param_count++]\n+\t\t= dupnstr (param, (size_t) (params_list - param));\n+\t    }\n+\t}\n       if (!*params_list)\n-        break;\n+\tbreak;\n     }\n   temp_params[param_count++] = \"-aux-info\";\n \n@@ -1947,7 +1947,7 @@ munge_compile_params (params_list)\n \n   temp_params[param_count++] = \"-S\";\n   temp_params[param_count++] = \"-o\";\n-  \n+\n   if ((stat (HOST_BIT_BUCKET, &st) == 0)\n       && (!S_ISDIR (st.st_mode))\n       && (access (HOST_BIT_BUCKET, W_OK) == 0))\n@@ -1988,7 +1988,7 @@ gen_aux_info_file (base_filename)\n   /* Add .X to source file name to get aux-info file name.  */\n   compile_params[aux_info_file_name_index] =\n     concat (compile_params[input_file_name_index], aux_info_suffix, NULL);\n-  \n+\n   if (!quiet_flag)\n     notice (\"%s: compiling `%s'\\n\",\n \t    pname, compile_params[input_file_name_index]);\n@@ -2128,27 +2128,27 @@ start_over: ;\n     struct stat stat_buf;\n \n     /* Get some status information about this aux_info file.  */\n-  \n+\n     if (stat (aux_info_filename, &stat_buf) == -1)\n       {\n \tint errno_val = errno;\n-        notice (\"%s: can't get status of aux info file `%s': %s\\n\",\n+\tnotice (\"%s: can't get status of aux info file `%s': %s\\n\",\n \t\tpname, shortpath (NULL, aux_info_filename),\n \t\txstrerror (errno_val));\n-        errors++;\n-        return;\n+\terrors++;\n+\treturn;\n       }\n-  \n+\n     /* Check on whether or not this aux_info file is zero length.  If it is,\n        then just ignore it and return.  */\n-  \n+\n     if ((aux_info_size = stat_buf.st_size) == 0)\n       return;\n-  \n+\n     /* Get the date/time of last modification for this aux_info file and\n        remember it.  We will have to check that any source files that it\n        contains information about are at least this old or older.  */\n-  \n+\n     aux_info_mtime = stat_buf.st_mtime;\n \n     if (!is_syscalls)\n@@ -2179,7 +2179,7 @@ start_over: ;\n     int fd_flags;\n \n     /* Open the aux_info file.  */\n-  \n+\n     fd_flags = O_RDONLY;\n #ifdef O_BINARY\n     /* Use binary mode to avoid having to deal with different EOL characters.  */\n@@ -2188,43 +2188,43 @@ start_over: ;\n     if ((aux_info_file = open (aux_info_filename, fd_flags, 0444 )) == -1)\n       {\n \tint errno_val = errno;\n-        notice (\"%s: can't open aux info file `%s' for reading: %s\\n\",\n+\tnotice (\"%s: can't open aux info file `%s' for reading: %s\\n\",\n \t\tpname, shortpath (NULL, aux_info_filename),\n \t\txstrerror (errno_val));\n-        return;\n+\treturn;\n       }\n-  \n+\n     /* Allocate space to hold the aux_info file in memory.  */\n-  \n+\n     aux_info_base = xmalloc (aux_info_size + 1);\n     aux_info_limit = aux_info_base + aux_info_size;\n     *aux_info_limit = '\\0';\n-  \n+\n     /* Read the aux_info file into memory.  */\n-  \n+\n     if (safe_read (aux_info_file, aux_info_base, aux_info_size) !=\n \t(int) aux_info_size)\n       {\n \tint errno_val = errno;\n-        notice (\"%s: error reading aux info file `%s': %s\\n\",\n+\tnotice (\"%s: error reading aux info file `%s': %s\\n\",\n \t\tpname, shortpath (NULL, aux_info_filename),\n \t\txstrerror (errno_val));\n-        free (aux_info_base);\n-        close (aux_info_file);\n-        return;\n+\tfree (aux_info_base);\n+\tclose (aux_info_file);\n+\treturn;\n       }\n-  \n+\n     /* Close the aux info file.  */\n-  \n+\n     if (close (aux_info_file))\n       {\n \tint errno_val = errno;\n-        notice (\"%s: error closing aux info file `%s': %s\\n\",\n+\tnotice (\"%s: error closing aux info file `%s': %s\\n\",\n \t\tpname, shortpath (NULL, aux_info_filename),\n \t\txstrerror (errno_val));\n-        free (aux_info_base);\n-        close (aux_info_file);\n-        return;\n+\tfree (aux_info_base);\n+\tclose (aux_info_file);\n+\treturn;\n       }\n   }\n \n@@ -2252,9 +2252,9 @@ start_over: ;\n \n     while (*p != ':'\n #ifdef HAVE_DOS_BASED_FILE_SYSTEM\n-           || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n+\t   || (*p == ':' && *p && *(p+1) && IS_DIR_SEPARATOR (*(p+1)))\n #endif\n-           )\n+\t   )\n       p++;\n     p++;\n     while (*p == ' ')\n@@ -2280,8 +2280,8 @@ start_over: ;\n \t{\n \t  char *slash;\n \n-\t  slash = strrchr (dir_end ? dir_end : aux_info_relocated_name, \n-\t                   DIR_SEPARATOR_2);\n+\t  slash = strrchr (dir_end ? dir_end : aux_info_relocated_name,\n+\t\t\t   DIR_SEPARATOR_2);\n \t  if (slash)\n \t    dir_end = slash;\n \t}\n@@ -2306,58 +2306,58 @@ start_over: ;\n \n     if (!is_syscalls)\n       {\n-        current_aux_info_lineno = 2;\n-    \n-        for (aux_info_p = aux_info_second_line; *aux_info_p; )\n-          {\n-            if (referenced_file_is_newer (aux_info_p, aux_info_mtime))\n-              {\n-                free (aux_info_base);\n+\tcurrent_aux_info_lineno = 2;\n+\n+\tfor (aux_info_p = aux_info_second_line; *aux_info_p; )\n+\t  {\n+\t    if (referenced_file_is_newer (aux_info_p, aux_info_mtime))\n+\t      {\n+\t\tfree (aux_info_base);\n \t\tfree (aux_info_relocated_name);\n-                if (keep_it && unlink (aux_info_filename) == -1)\n-                  {\n+\t\tif (keep_it && unlink (aux_info_filename) == -1)\n+\t\t  {\n \t\t    int errno_val = errno;\n-                    notice (\"%s: can't delete file `%s': %s\\n\",\n+\t            notice (\"%s: can't delete file `%s': %s\\n\",\n \t\t\t    pname, shortpath (NULL, aux_info_filename),\n \t\t\t    xstrerror (errno_val));\n-                    return;\n-                  }\n+\t            return;\n+\t          }\n \t\tmust_create = 1;\n-                goto start_over;\n-              }\n-    \n-            /* Skip over the rest of this line to start of next line.  */\n-    \n-            while (*aux_info_p != '\\n')\n-              aux_info_p++;\n-            aux_info_p++;\n-            current_aux_info_lineno++;\n-          }\n+\t        goto start_over;\n+\t      }\n+\n+\t    /* Skip over the rest of this line to start of next line.  */\n+\n+\t    while (*aux_info_p != '\\n')\n+\t      aux_info_p++;\n+\t    aux_info_p++;\n+\t    current_aux_info_lineno++;\n+\t  }\n       }\n \n     /* Now do the real pass on the aux_info lines.  Save their information in\n        the in-core data base.  */\n-  \n+\n     current_aux_info_lineno = 2;\n-  \n+\n     for (aux_info_p = aux_info_second_line; *aux_info_p;)\n       {\n-        char *unexpanded_line = unexpand_if_needed (aux_info_p);\n-  \n-        if (unexpanded_line)\n-          {\n-            save_def_or_dec (unexpanded_line, is_syscalls);\n-            free (unexpanded_line);\n-          }\n-        else\n-          save_def_or_dec (aux_info_p, is_syscalls);\n-  \n-        /* Skip over the rest of this line and get to start of next line.  */\n-  \n-        while (*aux_info_p != '\\n')\n-          aux_info_p++;\n-        aux_info_p++;\n-        current_aux_info_lineno++;\n+\tchar *unexpanded_line = unexpand_if_needed (aux_info_p);\n+\n+\tif (unexpanded_line)\n+\t  {\n+\t    save_def_or_dec (unexpanded_line, is_syscalls);\n+\t    free (unexpanded_line);\n+\t  }\n+\telse\n+\t  save_def_or_dec (aux_info_p, is_syscalls);\n+\n+\t/* Skip over the rest of this line and get to start of next line.  */\n+\n+\twhile (*aux_info_p != '\\n')\n+\t  aux_info_p++;\n+\taux_info_p++;\n+\tcurrent_aux_info_lineno++;\n       }\n   }\n \n@@ -2377,8 +2377,8 @@ rename_c_file (hp)\n {\n   const char *filename = hp->symbol;\n   int last_char_index = strlen (filename) - 1;\n-  char *const new_filename = (char *) alloca (strlen (filename) \n-                                              + strlen (cplus_suffix) + 1);\n+  char *const new_filename = (char *) alloca (strlen (filename)\n+\t                                      + strlen (cplus_suffix) + 1);\n \n   /* Note that we don't care here if the given file was converted or not.  It\n      is possible that the given file was *not* converted, simply because there\n@@ -2496,51 +2496,51 @@ find_extern_def (head, user)\n   for (dd_p = head; dd_p; dd_p = dd_p->next_for_func)\n     if (dd_p->is_func_def && !dd_p->is_static)\n       {\n-        if (!extern_def_p)\t/* Previous definition? */\n-          extern_def_p = dd_p;\t/* Remember the first definition found.  */\n-        else\n-          {\n-            /* Ignore definition just found if it came from SYSCALLS.c.X.  */\n-\n-            if (is_syscalls_file (dd_p->file))\n-              continue;\n-\n-            /* Quietly replace the definition previously found with the one\n-               just found if the previous one was from SYSCALLS.c.X.  */\n-\n-            if (is_syscalls_file (extern_def_p->file))\n-              {\n-                extern_def_p = dd_p;\n-                continue;\n-              }\n-\n-            /* If we get here, then there is a conflict between two function\n-               declarations for the same function, both of which came from the\n-               user's own code.  */\n-\n-            if (!conflict_noted)\t/* first time we noticed? */\n-              {\n-                conflict_noted = 1;\n-                notice (\"%s: conflicting extern definitions of '%s'\\n\",\n+\tif (!extern_def_p)\t/* Previous definition? */\n+\t  extern_def_p = dd_p;\t/* Remember the first definition found.  */\n+\telse\n+\t  {\n+\t    /* Ignore definition just found if it came from SYSCALLS.c.X.  */\n+\n+\t    if (is_syscalls_file (dd_p->file))\n+\t      continue;\n+\n+\t    /* Quietly replace the definition previously found with the one\n+\t       just found if the previous one was from SYSCALLS.c.X.  */\n+\n+\t    if (is_syscalls_file (extern_def_p->file))\n+\t      {\n+\t        extern_def_p = dd_p;\n+\t        continue;\n+\t      }\n+\n+\t    /* If we get here, then there is a conflict between two function\n+\t       declarations for the same function, both of which came from the\n+\t       user's own code.  */\n+\n+\t    if (!conflict_noted)\t/* first time we noticed? */\n+\t      {\n+\t\tconflict_noted = 1;\n+\t\tnotice (\"%s: conflicting extern definitions of '%s'\\n\",\n \t\t\tpname, head->hash_entry->symbol);\n-                if (!quiet_flag)\n-                  {\n-                    notice (\"%s: declarations of '%s' will not be converted\\n\",\n+\t\tif (!quiet_flag)\n+\t\t  {\n+\t\t    notice (\"%s: declarations of '%s' will not be converted\\n\",\n \t\t\t    pname, head->hash_entry->symbol);\n-                    notice (\"%s: conflict list for '%s' follows:\\n\",\n+\t\t    notice (\"%s: conflict list for '%s' follows:\\n\",\n \t\t\t    pname, head->hash_entry->symbol);\n-                    fprintf (stderr, \"%s:     %s(%d): %s\\n\",\n+\t\t    fprintf (stderr, \"%s:     %s(%d): %s\\n\",\n \t\t\t     pname,\n \t\t\t     shortpath (NULL, extern_def_p->file->hash_entry->symbol),\n \t\t\t     extern_def_p->line, extern_def_p->ansi_decl);\n-                  }\n-              }\n-            if (!quiet_flag)\n-              fprintf (stderr, \"%s:     %s(%d): %s\\n\",\n+\t\t  }\n+\t      }\n+\t    if (!quiet_flag)\n+\t      fprintf (stderr, \"%s:     %s(%d): %s\\n\",\n \t\t       pname,\n \t\t       shortpath (NULL, dd_p->file->hash_entry->symbol),\n \t\t       dd_p->line, dd_p->ansi_decl);\n-          }\n+\t  }\n       }\n \n   /* We want to err on the side of caution, so if we found multiple conflicting\n@@ -2553,64 +2553,64 @@ find_extern_def (head, user)\n   if (!extern_def_p)\n     {\n       /* We have no definitions for this function so do the next best thing.\n-         Search for an extern declaration already in prototype form.  */\n+\t Search for an extern declaration already in prototype form.  */\n \n       for (dd_p = head; dd_p; dd_p = dd_p->next_for_func)\n-        if (!dd_p->is_func_def && !dd_p->is_static && dd_p->prototyped)\n-          {\n-            extern_def_p = dd_p;\t/* save a pointer to the definition */\n-            if (!quiet_flag)\n-              notice (\"%s: warning: using formals list from %s(%d) for function `%s'\\n\",\n+\tif (!dd_p->is_func_def && !dd_p->is_static && dd_p->prototyped)\n+\t  {\n+\t    extern_def_p = dd_p;\t/* save a pointer to the definition */\n+\t    if (!quiet_flag)\n+\t      notice (\"%s: warning: using formals list from %s(%d) for function `%s'\\n\",\n \t\t      pname,\n \t\t      shortpath (NULL, dd_p->file->hash_entry->symbol),\n \t\t      dd_p->line, dd_p->hash_entry->symbol);\n-            break;\n-          }\n+\t    break;\n+\t  }\n \n       /* Gripe about unprototyped function declarations that we found no\n-         corresponding definition (or other source of prototype information)\n-         for.\n+\t corresponding definition (or other source of prototype information)\n+\t for.\n \n-         Gripe even if the unprototyped declaration we are worried about\n-         exists in a file in one of the \"system\" include directories.  We\n-         can gripe about these because we should have at least found a\n-         corresponding (pseudo) definition in the SYSCALLS.c.X file.  If we\n+\t Gripe even if the unprototyped declaration we are worried about\n+\t exists in a file in one of the \"system\" include directories.  We\n+\t can gripe about these because we should have at least found a\n+\t corresponding (pseudo) definition in the SYSCALLS.c.X file.  If we\n \t didn't, then that means that the SYSCALLS.c.X file is missing some\n-         needed prototypes for this particular system.  That is worth telling\n-         the user about!  */\n+\t needed prototypes for this particular system.  That is worth telling\n+\t the user about!  */\n \n       if (!extern_def_p)\n-        {\n-          const char *file = user->file->hash_entry->symbol;\n+\t{\n+\t  const char *file = user->file->hash_entry->symbol;\n \n-          if (!quiet_flag)\n-            if (in_system_include_dir (file))\n-              {\n+\t  if (!quiet_flag)\n+\t    if (in_system_include_dir (file))\n+\t      {\n \t\t/* Why copy this string into `needed' at all?\n \t\t   Why not just use user->ansi_decl without copying?  */\n \t\tchar *needed = (char *) alloca (strlen (user->ansi_decl) + 1);\n-                char *p;\n+\t        char *p;\n \n-                strcpy (needed, user->ansi_decl);\n-                p = (NONCONST char *) substr (needed, user->hash_entry->symbol)\n-                    + strlen (user->hash_entry->symbol) + 2;\n+\t        strcpy (needed, user->ansi_decl);\n+\t        p = (NONCONST char *) substr (needed, user->hash_entry->symbol)\n+\t            + strlen (user->hash_entry->symbol) + 2;\n \t\t/* Avoid having ??? in the string.  */\n \t\t*p++ = '?';\n \t\t*p++ = '?';\n \t\t*p++ = '?';\n-                strcpy (p, \");\");\n+\t        strcpy (p, \");\");\n \n-                notice (\"%s: %d: `%s' used but missing from SYSCALLS\\n\",\n+\t        notice (\"%s: %d: `%s' used but missing from SYSCALLS\\n\",\n \t\t\tshortpath (NULL, file), user->line,\n \t\t\tneeded+7);\t/* Don't print \"extern \" */\n-              }\n+\t      }\n #if 0\n-            else\n-              notice (\"%s: %d: warning: no extern definition for `%s'\\n\",\n+\t    else\n+\t      notice (\"%s: %d: warning: no extern definition for `%s'\\n\",\n \t\t      shortpath (NULL, file), user->line,\n \t\t      user->hash_entry->symbol);\n #endif\n-        }\n+\t}\n     }\n   return extern_def_p;\n }\n@@ -2631,13 +2631,13 @@ find_static_definition (user)\n   for (dd_p = head; dd_p; dd_p = dd_p->next_for_func)\n     if (dd_p->is_func_def && dd_p->is_static && (dd_p->file == user->file))\n       {\n-        static_def_p = dd_p;\t/* save a pointer to the definition */\n-        num_static_defs++;\n+\tstatic_def_p = dd_p;\t/* save a pointer to the definition */\n+\tnum_static_defs++;\n       }\n   if (num_static_defs == 0)\n     {\n       if (!quiet_flag)\n-        notice (\"%s: warning: no static definition for `%s' in file `%s'\\n\",\n+\tnotice (\"%s: warning: no static definition for `%s' in file `%s'\\n\",\n \t\tpname, head->hash_entry->symbol,\n \t\tshortpath (NULL, user->file->hash_entry->symbol));\n     }\n@@ -2717,12 +2717,12 @@ connect_defs_and_decs (hp)\n   for (dd_p = hp->ddip; dd_p; dd_p = dd_p->next_for_func)\n     if (!dd_p->is_func_def && !dd_p->is_static && !dd_p->definition)\n       {\n-        if (first_extern_reference)\n-          {\n-            extern_def_p = find_extern_def (hp->ddip, dd_p);\n-            first_extern_reference = 0;\n-          }\n-        ((NONCONST def_dec_info *) dd_p)->definition = extern_def_p;\n+\tif (first_extern_reference)\n+\t  {\n+\t    extern_def_p = find_extern_def (hp->ddip, dd_p);\n+\t    first_extern_reference = 0;\n+\t  }\n+\t((NONCONST def_dec_info *) dd_p)->definition = extern_def_p;\n       }\n \n   /* Traverse the list of definitions and declarations for this particular\n@@ -2748,37 +2748,37 @@ connect_defs_and_decs (hp)\n   for (dd_p = hp->ddip; dd_p; dd_p = dd_p->next_for_func)\n     if (!dd_p->is_func_def && dd_p->is_static && !dd_p->definition)\n       {\n-        const def_dec_info *dd_p2;\n-        const def_dec_info *static_def;\n-\n-        /* We have now found a single static declaration for which we need to\n-           find a matching definition.  We want to minimize the work (and the\n-           number of warnings), so we will find an appropriate (matching)\n-           static definition for this declaration, and then distribute it\n-           (as the definition for) any and all other static declarations\n-           for this function name which occur within the same file, and which\n-           do not already have definitions.\n-\n-           Note that a trick is used here to prevent subsequent attempts to\n-           call find_static_definition for a given function-name & file\n-           if the first such call returns NULL.  Essentially, we convert\n-           these NULL return values to -1, and put the -1 into the definition\n-           field for each other static declaration from the same file which\n-           does not already have an associated definition.\n-           This makes these other static declarations look like they are\n-           actually defined already when the outer loop here revisits them\n-           later on.  Thus, the outer loop will skip over them.  Later, we\n-           turn the -1's back to NULL's.  */\n-\n-      ((NONCONST def_dec_info *) dd_p)->definition =\n-        (static_def = find_static_definition (dd_p))\n-          ? static_def\n-          : (const def_dec_info *) -1;\n-\n-      for (dd_p2 = dd_p->next_for_func; dd_p2; dd_p2 = dd_p2->next_for_func)\n-        if (!dd_p2->is_func_def && dd_p2->is_static\n-         && !dd_p2->definition && (dd_p2->file == dd_p->file))\n-          ((NONCONST def_dec_info *) dd_p2)->definition = dd_p->definition;\n+\tconst def_dec_info *dd_p2;\n+\tconst def_dec_info *static_def;\n+\n+\t/* We have now found a single static declaration for which we need to\n+\t   find a matching definition.  We want to minimize the work (and the\n+\t   number of warnings), so we will find an appropriate (matching)\n+\t   static definition for this declaration, and then distribute it\n+\t   (as the definition for) any and all other static declarations\n+\t   for this function name which occur within the same file, and which\n+\t   do not already have definitions.\n+\n+\t   Note that a trick is used here to prevent subsequent attempts to\n+\t   call find_static_definition for a given function-name & file\n+\t   if the first such call returns NULL.  Essentially, we convert\n+\t   these NULL return values to -1, and put the -1 into the definition\n+\t   field for each other static declaration from the same file which\n+\t   does not already have an associated definition.\n+\t   This makes these other static declarations look like they are\n+\t   actually defined already when the outer loop here revisits them\n+\t   later on.  Thus, the outer loop will skip over them.  Later, we\n+\t   turn the -1's back to NULL's.  */\n+\n+\t((NONCONST def_dec_info *) dd_p)->definition =\n+\t  (static_def = find_static_definition (dd_p))\n+\t  ? static_def\n+\t  : (const def_dec_info *) -1;\n+\n+\tfor (dd_p2 = dd_p->next_for_func; dd_p2; dd_p2 = dd_p2->next_for_func)\n+\t  if (!dd_p2->is_func_def && dd_p2->is_static\n+\t      && !dd_p2->definition && (dd_p2->file == dd_p->file))\n+\t    ((NONCONST def_dec_info *) dd_p2)->definition = dd_p->definition;\n       }\n \n   /* Convert any dummy (-1) definitions we created in the step above back to\n@@ -2816,10 +2816,10 @@ declare_source_confusing (clean_p)\n   if (!quiet_flag)\n     {\n       if (clean_p == 0)\n-        notice (\"%s: %d: warning: source too confusing\\n\",\n+\tnotice (\"%s: %d: warning: source too confusing\\n\",\n \t\tshortpath (NULL, convert_filename), last_known_line_number);\n       else\n-        notice (\"%s: %d: warning: source too confusing\\n\",\n+\tnotice (\"%s: %d: warning: source too confusing\\n\",\n \t\tshortpath (NULL, convert_filename),\n \t\tidentify_lineno (clean_p));\n     }\n@@ -2864,7 +2864,7 @@ seek_to_line (n)\n   while (n > last_known_line_number)\n     {\n       while (*last_known_line_start != '\\n')\n-        check_source (++last_known_line_start < clean_text_limit, 0);\n+\tcheck_source (++last_known_line_start < clean_text_limit, 0);\n       last_known_line_start++;\n       last_known_line_number++;\n     }\n@@ -2979,12 +2979,12 @@ other_variable_style_function (ansi_header)\n       const char *candidate;\n \n       if ((candidate = substr (p, varargs_style_indicator)) == 0)\n-        return 0;\n+\treturn 0;\n       else\n-        if (!is_id_char (candidate[-1]) && !is_id_char (candidate[len]))\n-          return 1;\n-        else\n-          p = candidate + 1;\n+\tif (!is_id_char (candidate[-1]) && !is_id_char (candidate[len]))\n+\t  return 1;\n+\telse\n+\t  p = candidate + 1;\n     }\n   return 0;\n #endif /* !defined (UNPROTOIZE) */\n@@ -3025,7 +3025,7 @@ edit_fn_declaration (def_dec_p, clean_text_p)\n   if (other_variable_style_function (definition->ansi_decl))\n     {\n       if (!quiet_flag)\n-        notice (\"%s: %d: warning: varargs function declaration not converted\\n\",\n+\tnotice (\"%s: %d: warning: varargs function declaration not converted\\n\",\n \t\tshortpath (NULL, def_dec_p->file->hash_entry->symbol),\n \t\tdef_dec_p->line);\n       return;\n@@ -3065,47 +3065,47 @@ edit_fn_declaration (def_dec_p, clean_text_p)\n   do\n     {\n       for (;;)\n-        {\n-          /* Scan leftwards until we find some character which can be\n-             part of an identifier.  */\n+\t{\n+\t  /* Scan leftwards until we find some character which can be\n+\t     part of an identifier.  */\n+\n+\t  while (!is_id_char (*clean_text_p))\n+\t    check_source (--clean_text_p > clean_read_ptr, 0);\n \n-          while (!is_id_char (*clean_text_p))\n-            check_source (--clean_text_p > clean_read_ptr, 0);\n+\t  /* Scan backwards until we find a char that cannot be part of an\n+\t     identifier.  */\n \n-          /* Scan backwards until we find a char that cannot be part of an\n-             identifier.  */\n+\t  while (is_id_char (*clean_text_p))\n+\t    check_source (--clean_text_p > clean_read_ptr, 0);\n \n-          while (is_id_char (*clean_text_p))\n-            check_source (--clean_text_p > clean_read_ptr, 0);\n+\t  /* Having found an \"id break\", see if the following id is the one\n+\t     that we are looking for.  If so, then exit from this loop.  */\n \n-          /* Having found an \"id break\", see if the following id is the one\n-             that we are looking for.  If so, then exit from this loop.  */\n+\t  if (!strncmp (clean_text_p+1, function_to_edit, func_name_len))\n+\t    {\n+\t      char ch = *(clean_text_p + 1 + func_name_len);\n \n-          if (!strncmp (clean_text_p+1, function_to_edit, func_name_len))\n-            {\n-              char ch = *(clean_text_p + 1 + func_name_len);\n+\t      /* Must also check to see that the name in the source text\n+\t         ends where it should (in order to prevent bogus matches\n+\t         on similar but longer identifiers.  */\n \n-              /* Must also check to see that the name in the source text\n-                 ends where it should (in order to prevent bogus matches\n-                 on similar but longer identifiers.  */\n+\t      if (! is_id_char (ch))\n+\t        break;\t\t\t/* exit from loop */\n+\t    }\n+\t}\n \n-              if (! is_id_char (ch))\n-                break;\t\t\t/* exit from loop */\n-            }\n-        }\n-    \n       /* We have now found the first perfect match for the function name in\n-         our backward search.  This may or may not be the actual function\n-         name at the start of the actual function declaration (i.e. we could\n-         have easily been mislead).  We will try to avoid getting fooled too\n-         often by looking forward for the open paren which should follow the\n-         identifier we just found.  We ignore whitespace while hunting.  If\n-         the next non-whitespace byte we see is *not* an open left paren,\n-         then we must assume that we have been fooled and we start over\n-         again accordingly.  Note that there is no guarantee, that even if\n-         we do see the open paren, that we are in the right place.\n-         Programmers do the strangest things sometimes!  */\n-    \n+\t our backward search.  This may or may not be the actual function\n+\t name at the start of the actual function declaration (i.e. we could\n+\t have easily been mislead).  We will try to avoid getting fooled too\n+\t often by looking forward for the open paren which should follow the\n+\t identifier we just found.  We ignore whitespace while hunting.  If\n+\t the next non-whitespace byte we see is *not* an open left paren,\n+\t then we must assume that we have been fooled and we start over\n+\t again accordingly.  Note that there is no guarantee, that even if\n+\t we do see the open paren, that we are in the right place.\n+\t Programmers do the strangest things sometimes!  */\n+\n       end_of_fn_name = clean_text_p + strlen (def_dec_p->hash_entry->symbol);\n       start_formals = forward_to_next_token_char (end_of_fn_name);\n     }\n@@ -3126,76 +3126,76 @@ edit_fn_declaration (def_dec_p, clean_text_p)\n   for (;;)\n     {\n       {\n-        int depth;\n-\n-        end_formals = start_formals + 1;\n-        depth = 1;\n-        for (; depth; check_source (++end_formals < clean_text_limit, 0))\n-          {\n-            switch (*end_formals)\n-              {\n-                case '(':\n-                  depth++;\n-                  break;\n-                case ')':\n-                  depth--;\n-                  break;\n-              }\n-          }\n-        end_formals--;\n+\tint depth;\n+\n+\tend_formals = start_formals + 1;\n+\tdepth = 1;\n+\tfor (; depth; check_source (++end_formals < clean_text_limit, 0))\n+\t  {\n+\t    switch (*end_formals)\n+\t      {\n+\t      case '(':\n+\t\tdepth++;\n+\t\tbreak;\n+\t      case ')':\n+\t\tdepth--;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tend_formals--;\n       }\n \n       /* end_formals now points to the closing right paren of the formals\n-         list whose left paren is pointed to by start_formals.  */\n-    \n+\t list whose left paren is pointed to by start_formals.  */\n+\n       /* Now, if we are protoizing, we insert the new ANSI-style formals list\n-         attached to the associated definition of this function.  If however\n-         we are unprotoizing, then we simply delete any formals list which\n-         may be present.  */\n-    \n+\t attached to the associated definition of this function.  If however\n+\t we are unprotoizing, then we simply delete any formals list which\n+\t may be present.  */\n+\n       output_up_to (start_formals);\n #ifndef UNPROTOIZE\n       if (this_f_list_chain_item)\n-        {\n-          output_string (this_f_list_chain_item->formals_list);\n-          this_f_list_chain_item = this_f_list_chain_item->chain_next;\n-        }\n+\t{\n+\t  output_string (this_f_list_chain_item->formals_list);\n+\t  this_f_list_chain_item = this_f_list_chain_item->chain_next;\n+\t}\n       else\n-        {\n-          if (!quiet_flag)\n-            notice (\"%s: warning: too many parameter lists in declaration of `%s'\\n\",\n+\t{\n+\t  if (!quiet_flag)\n+\t    notice (\"%s: warning: too many parameter lists in declaration of `%s'\\n\",\n \t\t    pname, def_dec_p->hash_entry->symbol);\n-          check_source (0, end_formals);  /* leave the declaration intact */\n-        }\n+\t  check_source (0, end_formals);  /* leave the declaration intact */\n+\t}\n #endif /* !defined (UNPROTOIZE) */\n       clean_read_ptr = end_formals - 1;\n \n       /* Now see if it looks like there may be another formals list associated\n-         with the function declaration that we are converting (following the\n-         formals list that we just converted.  */\n+\t with the function declaration that we are converting (following the\n+\t formals list that we just converted.  */\n \n       {\n-        const char *another_r_paren = forward_to_next_token_char (end_formals);\n+\tconst char *another_r_paren = forward_to_next_token_char (end_formals);\n \n-        if ((*another_r_paren != ')')\n-            || (*(start_formals = forward_to_next_token_char (another_r_paren)) != '('))\n-          {\n+\tif ((*another_r_paren != ')')\n+\t    || (*(start_formals = forward_to_next_token_char (another_r_paren)) != '('))\n+\t  {\n #ifndef UNPROTOIZE\n-            if (this_f_list_chain_item)\n-              {\n-                if (!quiet_flag)\n-                  notice (\"\\n%s: warning: too few parameter lists in declaration of `%s'\\n\",\n+\t    if (this_f_list_chain_item)\n+\t      {\n+\t\tif (!quiet_flag)\n+\t\t  notice (\"\\n%s: warning: too few parameter lists in declaration of `%s'\\n\",\n \t\t\t  pname, def_dec_p->hash_entry->symbol);\n-                check_source (0, start_formals); /* leave the decl intact */\n-              }\n+\t\tcheck_source (0, start_formals); /* leave the decl intact */\n+\t      }\n #endif /* !defined (UNPROTOIZE) */\n-            break;\n-  \n-          }\n+\t    break;\n+\n+\t  }\n       }\n \n       /* There does appear to be yet another formals list, so loop around\n-         again, and convert it also.  */\n+\t again, and convert it also.  */\n     }\n }\n \n@@ -3224,14 +3224,14 @@ edit_formals_lists (end_formals, f_list_count, def_dec_p)\n   for (; depth; check_source (--start_formals > clean_read_ptr, 0))\n     {\n       switch (*start_formals)\n-        {\n-          case '(':\n-            depth--;\n-            break;\n-          case ')':\n-            depth++;\n-            break;\n-        }\n+\t{\n+\tcase '(':\n+\t  depth--;\n+\t  break;\n+\tcase ')':\n+\t  depth++;\n+\t  break;\n+\t}\n     }\n   start_formals++;\n \n@@ -3248,12 +3248,12 @@ edit_formals_lists (end_formals, f_list_count, def_dec_p)\n       next_end = start_formals - 1;\n       check_source (next_end > clean_read_ptr, 0);\n       while (ISSPACE ((const unsigned char)*next_end))\n-        check_source (--next_end > clean_read_ptr, 0);\n+\tcheck_source (--next_end > clean_read_ptr, 0);\n       check_source (*next_end == ')', next_end);\n       check_source (--next_end > clean_read_ptr, 0);\n       check_source (*next_end == ')', next_end);\n       if (edit_formals_lists (next_end, f_list_count, def_dec_p))\n-        return 1;\n+\treturn 1;\n     }\n \n   /* Check that the function name in the header we are working on is the same\n@@ -3269,26 +3269,26 @@ edit_formals_lists (end_formals, f_list_count, def_dec_p)\n \n       for (func_name_limit = start_formals-1;\n \t   ISSPACE ((const unsigned char)*func_name_limit); )\n-        check_source (--func_name_limit > clean_read_ptr, 0);\n+\tcheck_source (--func_name_limit > clean_read_ptr, 0);\n \n       for (func_name_start = func_name_limit++;\n-           is_id_char (*func_name_start);\n-           func_name_start--)\n-        check_source (func_name_start > clean_read_ptr, 0);\n+\t   is_id_char (*func_name_start);\n+\t   func_name_start--)\n+\tcheck_source (func_name_start > clean_read_ptr, 0);\n       func_name_start++;\n       func_name_len = func_name_limit - func_name_start;\n       if (func_name_len == 0)\n-        check_source (0, func_name_start);\n+\tcheck_source (0, func_name_start);\n       if (func_name_len != strlen (expected)\n \t  || strncmp (func_name_start, expected, func_name_len))\n-        {\n-          notice (\"%s: %d: warning: found `%s' but expected `%s'\\n\",\n+\t{\n+\t  notice (\"%s: %d: warning: found `%s' but expected `%s'\\n\",\n \t\t  shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n \t\t  identify_lineno (func_name_start),\n \t\t  dupnstr (func_name_start, func_name_len),\n \t\t  expected);\n-          return 1;\n-        }\n+\t  return 1;\n+\t}\n     }\n \n   output_up_to (start_formals);\n@@ -3393,32 +3393,32 @@ find_rightmost_formals_list (clean_text_p)\n       /* Look leftward and try to find a right-paren.  */\n \n       while (*end_formals != ')')\n-        {\n-          if (ISSPACE ((const unsigned char)*end_formals))\n-            while (ISSPACE ((const unsigned char)*end_formals))\n-              check_source (--end_formals > clean_read_ptr, 0);\n-          else\n-            check_source (--end_formals > clean_read_ptr, 0);\n-        }\n+\t{\n+\t  if (ISSPACE ((const unsigned char)*end_formals))\n+\t    while (ISSPACE ((const unsigned char)*end_formals))\n+\t      check_source (--end_formals > clean_read_ptr, 0);\n+\t  else\n+\t    check_source (--end_formals > clean_read_ptr, 0);\n+\t}\n \n       ch = *(l_brace_p = forward_to_next_token_char (end_formals));\n \n       /* Since it is possible that we found a right paren before the starting\n-         '{' of the body which IS NOT the one at the end of the real K&R\n-         formals list (say for instance, we found one embedded inside one of\n-         the old K&R formal parameter declarations) we have to check to be\n-         sure that this is in fact the right paren that we were looking for.\n+\t '{' of the body which IS NOT the one at the end of the real K&R\n+\t formals list (say for instance, we found one embedded inside one of\n+\t the old K&R formal parameter declarations) we have to check to be\n+\t sure that this is in fact the right paren that we were looking for.\n \n-         The one we were looking for *must* be followed by either a '{' or\n-         by an alphabetic character, while others *cannot* validly be followed\n-         by such characters.  */\n+\t The one we were looking for *must* be followed by either a '{' or\n+\t by an alphabetic character, while others *cannot* validly be followed\n+\t by such characters.  */\n \n       if ((ch == '{') || ISALPHA ((unsigned char) ch))\n-        break;\n+\tbreak;\n \n       /* At this point, we have found a right paren, but we know that it is\n-         not the one we were looking for, so backup one character and keep\n-         looking.  */\n+\t not the one we were looking for, so backup one character and keep\n+\t looking.  */\n \n       check_source (--end_formals > clean_read_ptr, 0);\n     }\n@@ -3487,9 +3487,9 @@ add_local_decl (def_dec_p, clean_text_p)\n   if (*start_of_block != '{')\n     {\n       if (!quiet_flag)\n-        notice (\"\\n%s: %d: warning: can't add declaration of `%s' into macro call\\n\",\n-          def_dec_p->file->hash_entry->symbol, def_dec_p->line, \n-          def_dec_p->hash_entry->symbol);\n+\tnotice (\"\\n%s: %d: warning: can't add declaration of `%s' into macro call\\n\",\n+\t  def_dec_p->file->hash_entry->symbol, def_dec_p->line,\n+\t  def_dec_p->hash_entry->symbol);\n       return;\n     }\n \n@@ -3516,18 +3516,18 @@ add_local_decl (def_dec_p, clean_text_p)\n        we just found.  */\n \n     output_up_to (ep);\n-  \n+\n     /* Now we go ahead and insert the new declaration at this point.\n \n        If the definition of the given function is in the same file that we\n        are currently editing, and if its full ANSI declaration normally\n        would start with the keyword `extern', suppress the `extern'.  */\n-  \n+\n     {\n       const char *decl = def_dec_p->definition->ansi_decl;\n-  \n+\n       if ((*decl == 'e') && (def_dec_p->file == def_dec_p->definition->file))\n-        decl += 7;\n+\tdecl += 7;\n       output_string (decl);\n     }\n \n@@ -3575,10 +3575,10 @@ add_global_decls (file_p, clean_text_p)\n   for (;; --scan_p)\n     {\n       if (scan_p < clean_text_base)\n-        break;\n+\tbreak;\n       check_source (scan_p > clean_read_ptr, 0);\n       if (*scan_p == ';')\n-        break;\n+\tbreak;\n     }\n \n   /* scan_p now points either to a semicolon, or to just before the start\n@@ -3602,24 +3602,24 @@ add_global_decls (file_p, clean_text_p)\n \n   {\n     int some_decls_added = 0;\n-  \n+\n     for (dd_p = file_p->defs_decs; dd_p; dd_p = dd_p->next_in_file)\n       if (dd_p->is_implicit && dd_p->definition && !dd_p->definition->written)\n-        {\n-          const char *decl = dd_p->definition->ansi_decl;\n-  \n-          /* If the function for which we are inserting a declaration is\n-             actually defined later in the same file, then suppress the\n-             leading `extern' keyword (if there is one).  */\n-  \n-          if (*decl == 'e' && (dd_p->file == dd_p->definition->file))\n-            decl += 7;\n-  \n-          output_string (\"\\n\");\n-          output_string (decl);\n-          some_decls_added = 1;\n-          ((NONCONST def_dec_info *) dd_p->definition)->written = 1;\n-        }\n+\t{\n+\t  const char *decl = dd_p->definition->ansi_decl;\n+\n+\t  /* If the function for which we are inserting a declaration is\n+\t     actually defined later in the same file, then suppress the\n+\t     leading `extern' keyword (if there is one).  */\n+\n+\t  if (*decl == 'e' && (dd_p->file == dd_p->definition->file))\n+\t    decl += 7;\n+\n+\t  output_string (\"\\n\");\n+\t  output_string (decl);\n+\t  some_decls_added = 1;\n+\t  ((NONCONST def_dec_info *) dd_p->definition)->written = 1;\n+\t}\n     if (some_decls_added)\n       output_string (\"\\n\\n\");\n   }\n@@ -3667,13 +3667,13 @@ edit_fn_definition (def_dec_p, clean_text_p)\n      function with a variable number of arguments, and if the way it does\n      that is different from that way we would like it (i.e. varargs vs.\n      stdarg) then issue a warning and leave the header unconverted.  */\n-     \n+\n   if (other_variable_style_function (def_dec_p->ansi_decl))\n     {\n       if (!quiet_flag)\n-        notice (\"%s: %d: warning: definition of %s not converted\\n\",\n+\tnotice (\"%s: %d: warning: definition of %s not converted\\n\",\n \t\tshortpath (NULL, def_dec_p->file->hash_entry->symbol),\n-\t\tidentify_lineno (end_formals), \n+\t\tidentify_lineno (end_formals),\n \t\tother_var_style);\n       output_up_to (end_formals);\n       return;\n@@ -3706,24 +3706,24 @@ edit_fn_definition (def_dec_p, clean_text_p)\n     limit_p = decl_p + strlen (decl_p);\n     for (;decl_p < limit_p; decl_p = semicolon_p + 2)\n       {\n-        for (semicolon_p = decl_p; *semicolon_p != ';'; semicolon_p++)\n-          continue;\n-        output_string (\"\\n\");\n-        output_string (indent_string);\n-        output_bytes (decl_p, (size_t) ((semicolon_p + 1) - decl_p));\n+\tfor (semicolon_p = decl_p; *semicolon_p != ';'; semicolon_p++)\n+\t  continue;\n+\toutput_string (\"\\n\");\n+\toutput_string (indent_string);\n+\toutput_bytes (decl_p, (size_t) ((semicolon_p + 1) - decl_p));\n       }\n \n     /* If there are no newlines between the end of the formals list and the\n        start of the body, we should insert one now.  */\n \n     for (scan_p = end_formals+1; *scan_p != '{'; )\n       {\n-        if (*scan_p == '\\n')\n-          {\n-            had_newlines = 1;\n-            break;\n-          }\n-        check_source (++scan_p < clean_text_limit, 0);\n+\tif (*scan_p == '\\n')\n+\t  {\n+\t    had_newlines = 1;\n+\t    break;\n+\t  }\n+\tcheck_source (++scan_p < clean_text_limit, 0);\n       }\n     if (!had_newlines)\n       output_string (\"\\n\");\n@@ -3754,24 +3754,24 @@ edit_fn_definition (def_dec_p, clean_text_p)\n     scan_orig = end_formals_orig + 1;\n     for (; scan < start_body; scan++, scan_orig++)\n       {\n-        if (*scan == *scan_orig)\n-          {\n-            have_newlines |= (*scan_orig == '\\n');\n-            /* Leave identical whitespace alone.  */\n-            if (!ISSPACE ((const unsigned char)*scan_orig))\n-              *((NONCONST char *) scan_orig) = ' '; /* identical - so whiteout */\n-          }\n-        else\n-          have_flotsam = 1;\n+\tif (*scan == *scan_orig)\n+\t  {\n+\t    have_newlines |= (*scan_orig == '\\n');\n+\t    /* Leave identical whitespace alone.  */\n+\t    if (!ISSPACE ((const unsigned char)*scan_orig))\n+\t      *((NONCONST char *) scan_orig) = ' '; /* identical - so whiteout */\n+\t  }\n+\telse\n+\t  have_flotsam = 1;\n       }\n     if (have_flotsam)\n       output_bytes (end_formals_orig + 1,\n \t\t    (size_t) (start_body_orig - end_formals_orig) - 1);\n     else\n       if (have_newlines)\n-        output_string (\"\\n\");\n+\toutput_string (\"\\n\");\n       else\n-        output_string (\" \");\n+\toutput_string (\" \");\n     clean_read_ptr = start_body - 1;\n   }\n #endif /* !defined (UNPROTOIZE) */\n@@ -3792,94 +3792,94 @@ do_cleaning (new_clean_text_base, new_clean_text_limit)\n   for (scan_p = new_clean_text_base; scan_p < new_clean_text_limit; scan_p++)\n     {\n       switch (*scan_p)\n-        {\n-          case '/':\t\t\t/* Handle comments.  */\n-            if (scan_p[1] != '*')\n-              goto regular;\n-            non_whitespace_since_newline = 1;\n-            scan_p[0] = ' ';\n-            scan_p[1] = ' ';\n-            scan_p += 2;\n-            while (scan_p[1] != '/' || scan_p[0] != '*')\n-              {\n-                if (!ISSPACE ((const unsigned char)*scan_p))\n-                  *scan_p = ' ';\n-                if (++scan_p >= new_clean_text_limit)\n-                  abort ();\n-              }\n-            *scan_p++ = ' ';\n-            *scan_p = ' ';\n-            break;\n-\n-          case '#':\t\t\t/* Handle pp directives.  */\n-            if (non_whitespace_since_newline)\n-              goto regular;\n-            *scan_p = ' ';\n-            while (scan_p[1] != '\\n' || scan_p[0] == '\\\\')\n-              {\n-                if (!ISSPACE ((const unsigned char)*scan_p))\n-                  *scan_p = ' ';\n-                if (++scan_p >= new_clean_text_limit)\n-                  abort ();\n-              }\n-            *scan_p++ = ' ';\n-            break;\n-\n-          case '\\'':\t\t\t/* Handle character literals.  */\n-            non_whitespace_since_newline = 1;\n-            while (scan_p[1] != '\\'' || scan_p[0] == '\\\\')\n-              {\n-                if (scan_p[0] == '\\\\'\n-\t\t    && !ISSPACE ((const unsigned char) scan_p[1]))\n-                  scan_p[1] = ' ';\n-                if (!ISSPACE ((const unsigned char)*scan_p))\n-                  *scan_p = ' ';\n-                if (++scan_p >= new_clean_text_limit)\n-                  abort ();\n-              }\n-            *scan_p++ = ' ';\n-            break;\n-\n-          case '\"':\t\t\t/* Handle string literals.  */\n-            non_whitespace_since_newline = 1;\n-            while (scan_p[1] != '\"' || scan_p[0] == '\\\\')\n-              {\n-                if (scan_p[0] == '\\\\'\n-\t\t    && !ISSPACE ((const unsigned char) scan_p[1]))\n-                  scan_p[1] = ' ';\n-                if (!ISSPACE ((const unsigned char)*scan_p))\n-                  *scan_p = ' ';\n-                if (++scan_p >= new_clean_text_limit)\n-                  abort ();\n-              }\n-\t    if (!ISSPACE ((const unsigned char)*scan_p))\n-\t      *scan_p = ' ';\n-\t    scan_p++;\n-            break;\n-\n-          case '\\\\':\t\t\t/* Handle line continuations.  */\n-            if (scan_p[1] != '\\n')\n-              goto regular;\n-            *scan_p = ' ';\n-            break;\n-\n-          case '\\n':\n-            non_whitespace_since_newline = 0;\t/* Reset.  */\n-            break;\n-\n-          case ' ':\n-          case '\\v':\n-          case '\\t':\n-          case '\\r':\n-          case '\\f':\n-          case '\\b':\n-            break;\t\t/* Whitespace characters.  */\n-\n-          default:\n+\t{\n+\tcase '/':\t\t\t/* Handle comments.  */\n+\t  if (scan_p[1] != '*')\n+\t    goto regular;\n+\t  non_whitespace_since_newline = 1;\n+\t  scan_p[0] = ' ';\n+\t  scan_p[1] = ' ';\n+\t  scan_p += 2;\n+\t  while (scan_p[1] != '/' || scan_p[0] != '*')\n+\t    {\n+\t      if (!ISSPACE ((const unsigned char)*scan_p))\n+\t\t*scan_p = ' ';\n+\t      if (++scan_p >= new_clean_text_limit)\n+\t\tabort ();\n+\t    }\n+\t  *scan_p++ = ' ';\n+\t  *scan_p = ' ';\n+\t  break;\n+\n+\tcase '#':\t\t\t/* Handle pp directives.  */\n+\t  if (non_whitespace_since_newline)\n+\t    goto regular;\n+\t  *scan_p = ' ';\n+\t  while (scan_p[1] != '\\n' || scan_p[0] == '\\\\')\n+\t    {\n+\t      if (!ISSPACE ((const unsigned char)*scan_p))\n+\t\t*scan_p = ' ';\n+\t      if (++scan_p >= new_clean_text_limit)\n+\t\tabort ();\n+\t    }\n+\t  *scan_p++ = ' ';\n+\t  break;\n+\n+\tcase '\\'':\t\t\t/* Handle character literals.  */\n+\t  non_whitespace_since_newline = 1;\n+\t  while (scan_p[1] != '\\'' || scan_p[0] == '\\\\')\n+\t    {\n+\t      if (scan_p[0] == '\\\\'\n+\t\t  && !ISSPACE ((const unsigned char) scan_p[1]))\n+\t\tscan_p[1] = ' ';\n+\t      if (!ISSPACE ((const unsigned char)*scan_p))\n+\t\t*scan_p = ' ';\n+\t      if (++scan_p >= new_clean_text_limit)\n+\t\tabort ();\n+\t    }\n+\t  *scan_p++ = ' ';\n+\t  break;\n+\n+\tcase '\"':\t\t\t/* Handle string literals.  */\n+\t  non_whitespace_since_newline = 1;\n+\t  while (scan_p[1] != '\"' || scan_p[0] == '\\\\')\n+\t    {\n+\t      if (scan_p[0] == '\\\\'\n+\t\t  && !ISSPACE ((const unsigned char) scan_p[1]))\n+\t\tscan_p[1] = ' ';\n+\t      if (!ISSPACE ((const unsigned char)*scan_p))\n+\t\t*scan_p = ' ';\n+\t      if (++scan_p >= new_clean_text_limit)\n+\t\tabort ();\n+\t    }\n+\t  if (!ISSPACE ((const unsigned char)*scan_p))\n+\t    *scan_p = ' ';\n+\t  scan_p++;\n+\t  break;\n+\n+\tcase '\\\\':\t\t\t/* Handle line continuations.  */\n+\t  if (scan_p[1] != '\\n')\n+\t    goto regular;\n+\t  *scan_p = ' ';\n+\t  break;\n+\n+\tcase '\\n':\n+\t  non_whitespace_since_newline = 0;\t/* Reset.  */\n+\t  break;\n+\n+\tcase ' ':\n+\tcase '\\v':\n+\tcase '\\t':\n+\tcase '\\r':\n+\tcase '\\f':\n+\tcase '\\b':\n+\t  break;\t\t/* Whitespace characters.  */\n+\n+\tdefault:\n regular:\n-            non_whitespace_since_newline = 1;\n-            break;\n-        }\n+\t  non_whitespace_since_newline = 1;\n+\t  break;\n+\t}\n     }\n }\n \n@@ -3897,14 +3897,14 @@ careful_find_l_paren (p)\n   for (paren_depth = 1, q = p-1; paren_depth; check_source (--q >= clean_text_base, 0))\n     {\n       switch (*q)\n-        {\n-          case ')':\n-            paren_depth++;\n-            break;\n-          case '(':\n-            paren_depth--;\n-            break;\n-        }\n+\t{\n+\tcase ')':\n+\t  paren_depth++;\n+\t  break;\n+\tcase '(':\n+\t  paren_depth--;\n+\t  break;\n+\t}\n     }\n   return ++q;\n }\n@@ -3939,50 +3939,50 @@ scan_for_missed_items (file_p)\n   for (scan_p = clean_text_base; scan_p < limit; scan_p++)\n     {\n       if (*scan_p == ')')\n-        {\n-          static const char *last_r_paren;\n-          const char *ahead_p;\n+\t{\n+\t  static const char *last_r_paren;\n+\t  const char *ahead_p;\n \n-          last_r_paren = scan_p;\n+\t  last_r_paren = scan_p;\n \n-          for (ahead_p = scan_p + 1; ISSPACE ((const unsigned char)*ahead_p); )\n-            check_source (++ahead_p < limit, limit);\n+\t  for (ahead_p = scan_p + 1; ISSPACE ((const unsigned char)*ahead_p); )\n+\t    check_source (++ahead_p < limit, limit);\n \n-          scan_p = ahead_p - 1;\n+\t  scan_p = ahead_p - 1;\n \n-          if (ISALPHA ((const unsigned char)*ahead_p) || *ahead_p == '{')\n-            {\n-              const char *last_l_paren;\n-              const int lineno = identify_lineno (ahead_p);\n+\t  if (ISALPHA ((const unsigned char)*ahead_p) || *ahead_p == '{')\n+\t    {\n+\t      const char *last_l_paren;\n+\t      const int lineno = identify_lineno (ahead_p);\n \n-              if (setjmp (source_confusion_recovery))\n-                continue;\n+\t      if (setjmp (source_confusion_recovery))\n+\t\tcontinue;\n \n-              /* We know we have a function definition header.  Now skip\n-                 leftwards over all of its associated formals lists.  */\n+\t      /* We know we have a function definition header.  Now skip\n+\t         leftwards over all of its associated formals lists.  */\n \n-              do\n-                {\n-                  last_l_paren = careful_find_l_paren (last_r_paren);\n-                  for (last_r_paren = last_l_paren-1;\n+\t      do\n+\t\t{\n+\t\t  last_l_paren = careful_find_l_paren (last_r_paren);\n+\t\t  for (last_r_paren = last_l_paren-1;\n \t\t       ISSPACE ((const unsigned char)*last_r_paren); )\n-                    check_source (--last_r_paren >= backup_limit, backup_limit);\n-                }\n-              while (*last_r_paren == ')');\n-\n-              if (is_id_char (*last_r_paren))\n-                {\n-                  const char *id_limit = last_r_paren + 1;\n-                  const char *id_start;\n-                  size_t id_length;\n-                  const def_dec_info *dd_p;\n-\n-                  for (id_start = id_limit-1; is_id_char (*id_start); )\n-                    check_source (--id_start >= backup_limit, backup_limit);\n-                  id_start++;\n-                  backup_limit = id_start;\n-                  if ((id_length = (size_t) (id_limit - id_start)) == 0)\n-                    goto not_missed;\n+\t\t    check_source (--last_r_paren >= backup_limit, backup_limit);\n+\t\t}\n+\t      while (*last_r_paren == ')');\n+\n+\t      if (is_id_char (*last_r_paren))\n+\t\t{\n+\t\t  const char *id_limit = last_r_paren + 1;\n+\t\t  const char *id_start;\n+\t\t  size_t id_length;\n+\t\t  const def_dec_info *dd_p;\n+\n+\t\t  for (id_start = id_limit-1; is_id_char (*id_start); )\n+\t\t    check_source (--id_start >= backup_limit, backup_limit);\n+\t\t  id_start++;\n+\t\t  backup_limit = id_start;\n+\t\t  if ((id_length = (size_t) (id_limit - id_start)) == 0)\n+\t\t    goto not_missed;\n \n \t\t  {\n \t\t    char *func_name = (char *) alloca (id_length + 1);\n@@ -4024,9 +4024,9 @@ scan_for_missed_items (file_p)\n \t\t\t    pname);\n \t\t  }\n \t\tnot_missed: ;\n-                }\n-            }\n-        }\n+\t        }\n+\t    }\n+\t}\n     }\n }\n \n@@ -4041,7 +4041,7 @@ scan_for_missed_items (file_p)\n \n    Note that the trick of making a copy of the original sans comments &\n    preprocessing directives make the editing a whole lot easier.  */\n-   \n+\n static void\n edit_file (hp)\n      const hash_table_entry *hp;\n@@ -4072,14 +4072,14 @@ edit_file (hp)\n     {\n       if (!quiet_flag\n #ifdef UNPROTOIZE\n-          /* Don't even mention \"system\" include files unless we are\n-             protoizing.  If we are protoizing, we mention these as a\n-             gentle way of prodding the user to convert his \"system\"\n-             include files to prototype format.  */\n-          && !in_system_include_dir (convert_filename)\n+\t  /* Don't even mention \"system\" include files unless we are\n+\t     protoizing.  If we are protoizing, we mention these as a\n+\t     gentle way of prodding the user to convert his \"system\"\n+\t     include files to prototype format.  */\n+\t  && !in_system_include_dir (convert_filename)\n #endif /* defined (UNPROTOIZE) */\n-          )\n-        notice (\"%s: `%s' not converted\\n\",\n+\t  )\n+\tnotice (\"%s: `%s' not converted\\n\",\n \t\tpname, shortpath (NULL, convert_filename));\n       return;\n     }\n@@ -4142,10 +4142,10 @@ edit_file (hp)\n     if ((input_file = open (convert_filename, fd_flags, 0444)) == -1)\n       {\n \tint errno_val = errno;\n-        notice (\"%s: can't open file `%s' for reading: %s\\n\",\n+\tnotice (\"%s: can't open file `%s' for reading: %s\\n\",\n \t\tpname, shortpath (NULL, convert_filename),\n \t\txstrerror (errno_val));\n-        return;\n+\treturn;\n       }\n \n     /* Read the entire original source text file into the original text buffer\n@@ -4156,11 +4156,11 @@ edit_file (hp)\n \t(int) orig_size)\n       {\n \tint errno_val = errno;\n-        close (input_file);\n-        notice (\"\\n%s: error reading input file `%s': %s\\n\",\n+\tclose (input_file);\n+\tnotice (\"\\n%s: error reading input file `%s': %s\\n\",\n \t\tpname, shortpath (NULL, convert_filename),\n \t\txstrerror (errno_val));\n-        return;\n+\treturn;\n       }\n \n     close (input_file);\n@@ -4185,22 +4185,22 @@ edit_file (hp)\n     char *const clean_filename = (char *) alloca (strlen (convert_filename) + 6 + 1);\n \n     /* Open (and create) the clean file.  */\n-  \n+\n     strcpy (clean_filename, convert_filename);\n     strcat (clean_filename, \".clean\");\n     if ((clean_file = creat (clean_filename, 0666)) == -1)\n       {\n \tint errno_val = errno;\n-        notice (\"%s: can't create/open clean file `%s': %s\\n\",\n+\tnotice (\"%s: can't create/open clean file `%s': %s\\n\",\n \t\tpname, shortpath (NULL, clean_filename),\n \t\txstrerror (errno_val));\n-        return;\n+\treturn;\n       }\n-  \n+\n     /* Write the clean file.  */\n-  \n+\n     safe_write (clean_file, new_clean_text_base, clean_size, clean_filename);\n-  \n+\n     close (clean_file);\n   }\n #endif /* 0 */\n@@ -4226,39 +4226,39 @@ edit_file (hp)\n     def_dec_p = file_p->defs_decs;\n     for (; def_dec_p; def_dec_p = def_dec_p->next_in_file)\n       {\n-        const char *clean_text_p = seek_to_line (def_dec_p->line);\n-  \n-        /* clean_text_p now points to the first character of the line which\n-           contains the `terminator' for the declaration or definition that\n-           we are about to process.  */\n-  \n+\tconst char *clean_text_p = seek_to_line (def_dec_p->line);\n+\n+\t/* clean_text_p now points to the first character of the line which\n+\t   contains the `terminator' for the declaration or definition that\n+\t   we are about to process.  */\n+\n #ifndef UNPROTOIZE\n-  \n-        if (global_flag && def_dec_p->is_func_def && first_definition_in_file)\n-          {\n-            add_global_decls (def_dec_p->file, clean_text_p);\n-            first_definition_in_file = 0;\n-          }\n \n-        /* Don't edit this item if it is already in prototype format or if it\n-           is a function declaration and we have found no corresponding\n-           definition.  */\n+\tif (global_flag && def_dec_p->is_func_def && first_definition_in_file)\n+\t  {\n+\t    add_global_decls (def_dec_p->file, clean_text_p);\n+\t    first_definition_in_file = 0;\n+\t  }\n \n-        if (def_dec_p->prototyped\n-         || (!def_dec_p->is_func_def && !def_dec_p->definition))\n-          continue;\n+\t/* Don't edit this item if it is already in prototype format or if it\n+\t   is a function declaration and we have found no corresponding\n+\t   definition.  */\n+\n+\tif (def_dec_p->prototyped\n+\t    || (!def_dec_p->is_func_def && !def_dec_p->definition))\n+\t  continue;\n \n #endif /* !defined (UNPROTOIZE) */\n \n-        if (def_dec_p->is_func_def)\n-          edit_fn_definition (def_dec_p, clean_text_p);\n-        else\n+\tif (def_dec_p->is_func_def)\n+\t  edit_fn_definition (def_dec_p, clean_text_p);\n+\telse\n #ifndef UNPROTOIZE\n-  \tif (def_dec_p->is_implicit)\n-  \t  add_local_decl (def_dec_p, clean_text_p);\n-  \telse\n+\tif (def_dec_p->is_implicit)\n+\t  add_local_decl (def_dec_p, clean_text_p);\n+\telse\n #endif /* !defined (UNPROTOIZE) */\n-            edit_fn_declaration (def_dec_p, clean_text_p);\n+\t  edit_fn_declaration (def_dec_p, clean_text_p);\n       }\n   }\n \n@@ -4283,11 +4283,11 @@ edit_file (hp)\n     {\n       char *new_filename\n \t= (char *) xmalloc (strlen (convert_filename) + strlen (save_suffix) + 2);\n-  \n+\n       strcpy (new_filename, convert_filename);\n #ifdef __MSDOS__\n       /* MSDOS filenames are restricted to 8.3 format, so we save `foo.c'\n-         as `foo.<save_suffix>'.  */\n+\t as `foo.<save_suffix>'.  */\n       new_filename[(strlen (convert_filename) - 1] = '\\0';\n #endif\n       strcat (new_filename, save_suffix);\n@@ -4302,23 +4302,23 @@ edit_file (hp)\n \t\t    shortpath (NULL, new_filename));\n \t}\n       else if (rename (convert_filename, new_filename) == -1)\n-        {\n+\t{\n \t  int errno_val = errno;\n \t  notice (\"%s: can't link file `%s' to `%s': %s\\n\",\n \t\t  pname,\n \t\t  shortpath (NULL, convert_filename),\n \t\t  shortpath (NULL, new_filename),\n \t\t  xstrerror (errno_val));\n \t  return;\n-        }\n+\t}\n     }\n \n   if (unlink (convert_filename) == -1)\n     {\n       int errno_val = errno;\n       /* The file may have already been renamed.  */\n       if (errno_val != ENOENT)\n-        {\n+\t{\n \t  notice (\"%s: can't delete file `%s': %s\\n\",\n \t\t  pname, shortpath (NULL, convert_filename),\n \t\t  xstrerror (errno_val));\n@@ -4330,28 +4330,28 @@ edit_file (hp)\n     int output_file;\n \n     /* Open (and create) the output file.  */\n-  \n+\n     if ((output_file = creat (convert_filename, 0666)) == -1)\n       {\n \tint errno_val = errno;\n-        notice (\"%s: can't create/open output file `%s': %s\\n\",\n+\tnotice (\"%s: can't create/open output file `%s': %s\\n\",\n \t\tpname, shortpath (NULL, convert_filename),\n \t\txstrerror (errno_val));\n-        return;\n+\treturn;\n       }\n #ifdef O_BINARY\n     /* Use binary mode to avoid changing the existing EOL character.  */\n     setmode (output_file, O_BINARY);\n #endif\n-  \n+\n     /* Write the output file.  */\n-  \n+\n     {\n       unsigned int out_size = (repl_write_ptr + 1) - repl_text_base;\n-  \n+\n       safe_write (output_file, repl_text_base, out_size, convert_filename);\n     }\n-  \n+\n     close (output_file);\n   }\n \n@@ -4409,8 +4409,8 @@ do_processing ()\n   if (nondefault_syscalls_dir)\n     {\n       syscalls_absolute_filename\n-        = (char *) xmalloc (strlen (nondefault_syscalls_dir) + 1\n-                            + sizeof (syscalls_filename));\n+\t= (char *) xmalloc (strlen (nondefault_syscalls_dir) + 1\n+\t                    + sizeof (syscalls_filename));\n       strcpy (syscalls_absolute_filename, nondefault_syscalls_dir);\n     }\n   else\n@@ -4421,10 +4421,10 @@ do_processing ()\n \t  default_syscalls_dir = standard_exec_prefix;\n \t}\n       syscalls_absolute_filename\n-        = (char *) xmalloc (strlen (default_syscalls_dir) + 0\n+\t= (char *) xmalloc (strlen (default_syscalls_dir) + 0\n \t\t\t    + strlen (target_machine) + 1\n \t\t\t    + strlen (target_version) + 1\n-                            + sizeof (syscalls_filename));\n+\t                    + sizeof (syscalls_filename));\n       strcpy (syscalls_absolute_filename, default_syscalls_dir);\n       strcat (syscalls_absolute_filename, target_machine);\n       strcat (syscalls_absolute_filename, \"/\");\n@@ -4439,7 +4439,7 @@ do_processing ()\n       *(syscalls_absolute_filename + syscalls_len) = '\\0';\n     }\n   strcat (syscalls_absolute_filename, syscalls_filename);\n-  \n+\n   /* Call process_aux_info_file in such a way that it does not try to\n      delete the SYSCALLS aux_info file.  */\n \n@@ -4572,7 +4572,7 @@ main (argc, argv)\n \tcase 'x':\n \t  exclude_list = string_list_cons (optarg, exclude_list);\n \t  break;\n-\t    \n+\n \tcase 'v':\n \tcase 'V':\n \t  version_flag = 1;\n@@ -4620,7 +4620,7 @@ main (argc, argv)\n \t  usage ();\n \t}\n     }\n- \n+\n   /* Set up compile_params based on -p and -c options.  */\n   munge_compile_params (params);\n \n@@ -4666,7 +4666,7 @@ main (argc, argv)\n   else\n     {\n       if (version_flag)\n-        fprintf (stderr, \"%s: %s\\n\", pname, version_string);\n+\tfprintf (stderr, \"%s: %s\\n\", pname, version_string);\n       do_processing ();\n     }\n "}]}