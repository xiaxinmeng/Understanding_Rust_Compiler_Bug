{"sha": "92cfe9d50a819f5e6c9dda83905ad56c34ab62f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJjZmU5ZDUwYTgxOWY1ZTZjOWRkYTgzOTA1YWQ1NmMzNGFiNjJmNQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-11-27T00:17:25Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-11-27T00:17:25Z"}, "message": "loop-invariant.c (check_invariant_table_size): Take sizeof of the right type.\n\n\t* loop-invariant.c (check_invariant_table_size): Take sizeof of\n\tthe right type.\n\n\t* reorg.c (resource_conflicts_p): Use hard_reg_set_intersect_p.\n\t(rare_destination): Remove.\n\t(mostly_true_jump): Simplify.  Base result on REG_BR_PROP notes if\n\tavailable, otherwise assume branches are not taken.\n\t(fill_eager_delay_slots): Update mostly_true_jump call.\n\t(relax_delay_slots): Likewise.\n\nFrom-SVN: r193834", "tree": {"sha": "3a1e8272c8e7a655b69995c261aef29d5bfe98db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a1e8272c8e7a655b69995c261aef29d5bfe98db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92cfe9d50a819f5e6c9dda83905ad56c34ab62f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92cfe9d50a819f5e6c9dda83905ad56c34ab62f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92cfe9d50a819f5e6c9dda83905ad56c34ab62f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92cfe9d50a819f5e6c9dda83905ad56c34ab62f5/comments", "author": null, "committer": null, "parents": [{"sha": "5895a897b5b05db6d53b3b5e68fad1d653abf209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5895a897b5b05db6d53b3b5e68fad1d653abf209", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5895a897b5b05db6d53b3b5e68fad1d653abf209"}], "stats": {"total": 128, "additions": 22, "deletions": 106}, "files": [{"sha": "1274fb18a9ea4aa9c2e3174d1868c7058951da76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92cfe9d50a819f5e6c9dda83905ad56c34ab62f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92cfe9d50a819f5e6c9dda83905ad56c34ab62f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92cfe9d50a819f5e6c9dda83905ad56c34ab62f5", "patch": "@@ -1,3 +1,15 @@\n+2012-11-27  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* loop-invariant.c (check_invariant_table_size): Take sizeof of\n+\tthe right type.\n+\n+\t* reorg.c (resource_conflicts_p): Use hard_reg_set_intersect_p.\n+\t(rare_destination): Remove.\n+\t(mostly_true_jump): Simplify.  Base result on REG_BR_PROP notes if\n+\tavailable, otherwise assume branches are not taken.\n+\t(fill_eager_delay_slots): Update mostly_true_jump call.\n+\t(relax_delay_slots): Likewise.\n+\n 2012-11-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* reorg.c (redundant_insn): Do not handle DEBUG_INSNs."}, {"sha": "25d69f18ee834e42e8228d13d724b99d2ad0e017", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92cfe9d50a819f5e6c9dda83905ad56c34ab62f5/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92cfe9d50a819f5e6c9dda83905ad56c34ab62f5/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=92cfe9d50a819f5e6c9dda83905ad56c34ab62f5", "patch": "@@ -186,7 +186,7 @@ check_invariant_table_size (void)\n       unsigned int new_size = DF_DEFS_TABLE_SIZE () + (DF_DEFS_TABLE_SIZE () / 4);\n       invariant_table = XRESIZEVEC (struct invariant *, invariant_table, new_size);\n       memset (&invariant_table[invariant_table_size], 0,\n-\t      (new_size - invariant_table_size) * sizeof (struct rtx_iv *));\n+\t      (new_size - invariant_table_size) * sizeof (struct invariant *));\n       invariant_table_size = new_size;\n     }\n }"}, {"sha": "cce5cf5747264fe6f9644f2c80af34a3bb93ef78", "filename": "gcc/reorg.c", "status": "modified", "additions": 9, "deletions": 105, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92cfe9d50a819f5e6c9dda83905ad56c34ab62f5/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92cfe9d50a819f5e6c9dda83905ad56c34ab62f5/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=92cfe9d50a819f5e6c9dda83905ad56c34ab62f5", "patch": "@@ -187,8 +187,7 @@ static void note_delay_statistics (int, int);\n static rtx optimize_skip (rtx);\n #endif\n static int get_jump_flags (rtx, rtx);\n-static int rare_destination (rtx);\n-static int mostly_true_jump (rtx, rtx);\n+static int mostly_true_jump (rtx);\n static rtx get_branch_condition (rtx, rtx);\n static int condition_dominates_p (rtx, rtx);\n static int redirect_with_delay_slots_safe_p (rtx, rtx, rtx);\n@@ -292,18 +291,7 @@ resource_conflicts_p (struct resources *res1, struct resources *res2)\n       || res1->volatil || res2->volatil)\n     return 1;\n \n-#ifdef HARD_REG_SET\n-  return (res1->regs & res2->regs) != HARD_CONST (0);\n-#else\n-  {\n-    int i;\n-\n-    for (i = 0; i < HARD_REG_SET_LONGS; i++)\n-      if ((res1->regs[i] & res2->regs[i]) != 0)\n-\treturn 1;\n-    return 0;\n-  }\n-#endif\n+  return hard_reg_set_intersect_p (res1->regs, res2->regs);\n }\n \n /* Return TRUE if any resource marked in RES, a `struct resources', is\n@@ -905,72 +893,18 @@ get_jump_flags (rtx insn, rtx label)\n   return flags;\n }\n \n-/* Return 1 if INSN is a destination that will be branched to rarely (the\n-   return point of a function); return 2 if DEST will be branched to very\n-   rarely (a call to a function that doesn't return).  Otherwise,\n-   return 0.  */\n-\n-static int\n-rare_destination (rtx insn)\n-{\n-  int jump_count = 0;\n-  rtx next;\n-\n-  for (; insn && !ANY_RETURN_P (insn); insn = next)\n-    {\n-      if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\tinsn = XVECEXP (PATTERN (insn), 0, 0);\n-\n-      next = NEXT_INSN (insn);\n-\n-      switch (GET_CODE (insn))\n-\t{\n-\tcase CODE_LABEL:\n-\t  return 0;\n-\tcase BARRIER:\n-\t  /* A BARRIER can either be after a JUMP_INSN or a CALL_INSN.  We\n-\t     don't scan past JUMP_INSNs, so any barrier we find here must\n-\t     have been after a CALL_INSN and hence mean the call doesn't\n-\t     return.  */\n-\t  return 2;\n-\tcase JUMP_INSN:\n-\t  if (ANY_RETURN_P (PATTERN (insn)))\n-\t    return 1;\n-\t  else if (simplejump_p (insn)\n-\t\t   && jump_count++ < 10)\n-\t    next = JUMP_LABEL (insn);\n-\t  else\n-\t    return 0;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-\n-  /* If we got here it means we hit the end of the function.  So this\n-     is an unlikely destination.  */\n-\n-  return 1;\n-}\n-\n /* Return truth value of the statement that this branch\n    is mostly taken.  If we think that the branch is extremely likely\n    to be taken, we return 2.  If the branch is slightly more likely to be\n    taken, return 1.  If the branch is slightly less likely to be taken,\n-   return 0 and if the branch is highly unlikely to be taken, return -1.\n-\n-   CONDITION, if nonzero, is the condition that JUMP_INSN is testing.  */\n+   return 0 and if the branch is highly unlikely to be taken, return -1.  */\n \n static int\n-mostly_true_jump (rtx jump_insn, rtx condition)\n+mostly_true_jump (rtx jump_insn)\n {\n-  rtx target_label = JUMP_LABEL (jump_insn);\n-  rtx note;\n-  int rare_dest, rare_fallthrough;\n-\n   /* If branch probabilities are available, then use that number since it\n      always gives a correct answer.  */\n-  note = find_reg_note (jump_insn, REG_BR_PROB, 0);\n+  rtx note = find_reg_note (jump_insn, REG_BR_PROB, 0);\n   if (note)\n     {\n       int prob = INTVAL (XEXP (note, 0));\n@@ -985,37 +919,9 @@ mostly_true_jump (rtx jump_insn, rtx condition)\n \treturn -1;\n     }\n \n-  /* Look at the relative rarities of the fallthrough and destination.  If\n-     they differ, we can predict the branch that way.  */\n-  rare_dest = rare_destination (target_label);\n-  rare_fallthrough = rare_destination (NEXT_INSN (jump_insn));\n-\n-  switch (rare_fallthrough - rare_dest)\n-    {\n-    case -2:\n-      return -1;\n-    case -1:\n-      return 0;\n-    case 0:\n-      break;\n-    case 1:\n-      return 1;\n-    case 2:\n-      return 2;\n-    }\n-\n-  /* If we couldn't figure out what this jump was, assume it won't be\n-     taken.  This should be rare.  */\n-  if (condition == 0)\n+  /* If there is no note, assume branches are not taken.\n+     This should be rare.  */\n     return 0;\n-\n-  /* Predict backward branches usually take, forward branches usually not.  If\n-     we don't know whether this is forward or backward, assume the branch\n-     will be taken, since most are.  */\n-  return (ANY_RETURN_P (target_label) || INSN_UID (jump_insn) > max_uid\n-\t  || INSN_UID (target_label) > max_uid\n-\t  || (uid_to_ruid[INSN_UID (jump_insn)]\n-\t      > uid_to_ruid[INSN_UID (target_label)]));\n }\n \n /* Return the condition under which INSN will branch to TARGET.  If TARGET\n@@ -3007,7 +2913,7 @@ fill_eager_delay_slots (void)\n \t{\n \t  fallthrough_insn = next_active_insn (insn);\n \t  own_fallthrough = own_thread_p (NEXT_INSN (insn), NULL_RTX, 1);\n-\t  prediction = mostly_true_jump (insn, condition);\n+\t  prediction = mostly_true_jump (insn);\n \t}\n \n       /* If this insn is expected to branch, first try to get insns from our\n@@ -3356,9 +3262,7 @@ relax_delay_slots (rtx first)\n \t  && (other = prev_active_insn (insn)) != 0\n \t  && any_condjump_p (other)\n \t  && no_labels_between_p (other, insn)\n-\t  && 0 > mostly_true_jump (other,\n-\t\t\t\t   get_branch_condition (other,\n-\t\t\t\t\t\t\t JUMP_LABEL (other))))\n+\t  && 0 > mostly_true_jump (other))\n \t{\n \t  rtx other_target = JUMP_LABEL (other);\n \t  target_label = JUMP_LABEL (insn);"}]}