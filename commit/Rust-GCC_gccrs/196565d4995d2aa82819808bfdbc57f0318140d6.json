{"sha": "196565d4995d2aa82819808bfdbc57f0318140d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk2NTY1ZDQ5OTVkMmFhODI4MTk4MDhiZmRiYzU3ZjAzMTgxNDBkNg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-04-04T18:23:27Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-04-04T18:23:27Z"}, "message": "cprop.c (oprs_not_set_p): Remove.\n\n\t* cprop.c (oprs_not_set_p): Remove.\n\t(mark_set, mark_clobber): Remove.\n\t(mark_oprs_set): Rewrite using DF_INSN_INFO_DEFS cache.\n\t(reg_not_set_p): New function.\n\t(find_avail_set): Use reg_not_set_p instead of oprs_not_set_p.\n\t(cprop_insn): Likewise.\n\t(cprop_jump): Use FOR_EACH_EDGE.\n\nFrom-SVN: r171944", "tree": {"sha": "e812fb5b695f2c9687bfe3cd1dc728ca6674d825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e812fb5b695f2c9687bfe3cd1dc728ca6674d825"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/196565d4995d2aa82819808bfdbc57f0318140d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/196565d4995d2aa82819808bfdbc57f0318140d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/196565d4995d2aa82819808bfdbc57f0318140d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/196565d4995d2aa82819808bfdbc57f0318140d6/comments", "author": null, "committer": null, "parents": [{"sha": "53e3000cd1513601000059fd6175912d5ee41b04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53e3000cd1513601000059fd6175912d5ee41b04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53e3000cd1513601000059fd6175912d5ee41b04"}], "stats": {"total": 126, "additions": 22, "deletions": 104}, "files": [{"sha": "f43c0d97bb26231966bdc56e107a25781af5f49f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196565d4995d2aa82819808bfdbc57f0318140d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196565d4995d2aa82819808bfdbc57f0318140d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=196565d4995d2aa82819808bfdbc57f0318140d6", "patch": "@@ -1,3 +1,13 @@\n+2011-04-04  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cprop.c (oprs_not_set_p): Remove.\n+\t(mark_set, mark_clobber): Remove.\n+\t(mark_oprs_set): Rewrite using DF_INSN_INFO_DEFS cache.\n+\t(reg_not_set_p): New function.\n+\t(find_avail_set): Use reg_not_set_p instead of oprs_not_set_p.\n+\t(cprop_insn): Likewise.\n+\t(cprop_jump): Use FOR_EACH_EDGE.\n+\n 2011-04-04  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR bootstrap/48403"}, {"sha": "b48f7f8900cfc4c7b9cd80ce713367c4bbe04c84", "filename": "gcc/cprop.c", "status": "modified", "additions": 12, "deletions": 104, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196565d4995d2aa82819808bfdbc57f0318140d6/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196565d4995d2aa82819808bfdbc57f0318140d6/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=196565d4995d2aa82819808bfdbc57f0318140d6", "patch": "@@ -554,118 +554,26 @@ reset_opr_set_tables (void)\n   CLEAR_REG_SET (reg_set_bitmap);\n }\n \n-/* Return nonzero if the operands of X are not set before INSN in\n-   INSN's basic block.  */\n+/* Return nonzero if the register X has not been set yet [since the\n+   start of the basic block containing INSN].  */\n \n static int\n-oprs_not_set_p (const_rtx x, const_rtx insn)\n+reg_not_set_p (const_rtx x, const_rtx insn ATTRIBUTE_UNUSED)\n {\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-\n-  if (x == 0)\n-    return 1;\n-\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case PC:\n-    case CC0:\n-    case CONST:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_FIXED:\n-    case CONST_VECTOR:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-      return 1;\n-\n-    case REG:\n-      return ! REGNO_REG_SET_P (reg_set_bitmap, REGNO (x));\n-\n-    default:\n-      break;\n-    }\n-\n-  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  /* If we are about to do the last recursive call\n-\t     needed at this level, change it into iteration.\n-\t     This function is called enough to be worth it.  */\n-\t  if (i == 0)\n-\t    return oprs_not_set_p (XEXP (x, i), insn);\n-\n-\t  if (! oprs_not_set_p (XEXP (x, i), insn))\n-\t    return 0;\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (! oprs_not_set_p (XVECEXP (x, i, j), insn))\n-\t    return 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Mark things set by a SET.  */\n-\n-static void\n-mark_set (rtx pat, rtx insn ATTRIBUTE_UNUSED)\n-{\n-  rtx dest = SET_DEST (pat);\n-\n-  while (GET_CODE (dest) == SUBREG\n-\t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || GET_CODE (dest) == STRICT_LOW_PART)\n-    dest = XEXP (dest, 0);\n-\n-  if (REG_P (dest))\n-    SET_REGNO_REG_SET (reg_set_bitmap, REGNO (dest));\n-}\n-\n-/* Record things set by a CLOBBER.  */\n-\n-static void\n-mark_clobber (rtx pat, rtx insn ATTRIBUTE_UNUSED)\n-{\n-  rtx clob = XEXP (pat, 0);\n-\n-  while (GET_CODE (clob) == SUBREG || GET_CODE (clob) == STRICT_LOW_PART)\n-    clob = XEXP (clob, 0);\n-\n-  if (REG_P (clob))\n-    SET_REGNO_REG_SET (reg_set_bitmap, REGNO (clob));\n+  return ! REGNO_REG_SET_P (reg_set_bitmap, REGNO (x));\n }\n \n /* Record things set by INSN.\n-   This data is used by oprs_not_set_p.  */\n+   This data is used by reg_not_set_p.  */\n \n static void\n mark_oprs_set (rtx insn)\n {\n-  rtx pat = PATTERN (insn);\n-  int i;\n-\n-  if (GET_CODE (pat) == SET)\n-    mark_set (pat, insn);\n-  else if (GET_CODE (pat) == PARALLEL)\n-    for (i = 0; i < XVECLEN (pat, 0); i++)\n-      {\n-\trtx x = XVECEXP (pat, 0, i);\n-\n-\tif (GET_CODE (x) == SET)\n-\t  mark_set (x, insn);\n-\telse if (GET_CODE (x) == CLOBBER)\n-\t  mark_clobber (x, insn);\n-      }\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+  df_ref *def_rec;\n \n-  else if (GET_CODE (pat) == CLOBBER)\n-    mark_clobber (pat, insn);\n+  for (def_rec = DF_INSN_INFO_DEFS (insn_info); *def_rec; def_rec++)\n+    SET_REGNO_REG_SET (reg_set_bitmap, DF_REF_REGNO (*def_rec));\n }\n \n \f\n@@ -1023,7 +931,7 @@ find_avail_set (int regno, rtx insn)\n          If the source operand changed, we may still use it for the next\n          iteration of this loop, but we may not use it for substitutions.  */\n \n-      if (gcse_constant_p (src) || oprs_not_set_p (src, insn))\n+      if (gcse_constant_p (src) || reg_not_set_p (src, insn))\n \tset1 = set;\n \n       /* If the source of the set is anything except a register, then\n@@ -1144,7 +1052,7 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n       edge e;\n       edge_iterator ei;\n \n-      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); ei_next (&ei))\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->dest != EXIT_BLOCK_PTR\n \t    && BB_HEAD (e->dest) == JUMP_LABEL (jump))\n \t  {\n@@ -1221,7 +1129,7 @@ cprop_insn (rtx insn)\n \n       /* If the register has already been set in this block, there's\n \t nothing we can do.  */\n-      if (! oprs_not_set_p (reg_used->reg_rtx, insn))\n+      if (! reg_not_set_p (reg_used->reg_rtx, insn))\n \tcontinue;\n \n       /* Find an assignment that sets reg_used and is available"}]}