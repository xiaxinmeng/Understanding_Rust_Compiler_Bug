{"sha": "75040a044e3563d6168aea06f076dd1334ef0a7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUwNDBhMDQ0ZTM1NjNkNjE2OGFlYTA2ZjA3NmRkMTMzNGVmMGE3YQ==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-07-10T04:44:05Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-10T04:44:05Z"}, "message": "* fold-const.c: Properly wrap prototypes.\n\nFrom-SVN: r69170", "tree": {"sha": "b38b7214bc710cd03328b8259eca9cb5d0826935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b38b7214bc710cd03328b8259eca9cb5d0826935"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75040a044e3563d6168aea06f076dd1334ef0a7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75040a044e3563d6168aea06f076dd1334ef0a7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75040a044e3563d6168aea06f076dd1334ef0a7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75040a044e3563d6168aea06f076dd1334ef0a7a/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d177606965244f0165a9859919e848d187dcfd38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d177606965244f0165a9859919e848d187dcfd38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d177606965244f0165a9859919e848d187dcfd38"}], "stats": {"total": 73, "additions": 45, "deletions": 28}, "files": [{"sha": "312c138b6709fb9c2c243f71066cd34eafb4a857", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75040a044e3563d6168aea06f076dd1334ef0a7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75040a044e3563d6168aea06f076dd1334ef0a7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75040a044e3563d6168aea06f076dd1334ef0a7a", "patch": "@@ -1,3 +1,7 @@\n+2003-07-10  Andreas Jaeger  <aj@suse.de>\n+\n+\t* fold-const.c: Properly wrap prototypes.\n+\n 2003-07-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \t2003-06-16  Alexandre Oliva  <aoliva@redhat.com>"}, {"sha": "7ef2b22a91db4dcf093998e9e42997c044d2a9fe", "filename": "gcc/fold-const.c", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75040a044e3563d6168aea06f076dd1334ef0a7a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75040a044e3563d6168aea06f076dd1334ef0a7a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=75040a044e3563d6168aea06f076dd1334ef0a7a", "patch": "@@ -159,7 +159,8 @@ encode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n    The integer is stored into *LOW and *HI as two `HOST_WIDE_INT' pieces.  */\n \n static void\n-decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low, HOST_WIDE_INT *hi)\n+decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low,\n+\tHOST_WIDE_INT *hi)\n {\n   *low = words[0] + words[1] * BASE;\n   *hi = words[2] + words[3] * BASE;\n@@ -252,8 +253,9 @@ force_fit_type (tree t, int overflow)\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n-add_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, unsigned HOST_WIDE_INT l2,\n-\t    HOST_WIDE_INT h2, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n+add_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t    unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n+\t    unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n   unsigned HOST_WIDE_INT l;\n   HOST_WIDE_INT h;\n@@ -272,8 +274,8 @@ add_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, unsigned HOST_WIDE_INT\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n-neg_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, unsigned HOST_WIDE_INT *lv,\n-\t    HOST_WIDE_INT *hv)\n+neg_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t    unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n   if (l1 == 0)\n     {\n@@ -296,8 +298,9 @@ neg_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, unsigned HOST_WIDE_INT\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n-mul_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, unsigned HOST_WIDE_INT l2,\n-\t    HOST_WIDE_INT h2, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n+mul_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t    unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n+\t    unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n   HOST_WIDE_INT arg1[4];\n   HOST_WIDE_INT arg2[4];\n@@ -353,9 +356,9 @@ mul_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, unsigned HOST_WIDE_INT\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n-lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count,\n-\t       unsigned int prec, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n-\t       int arith)\n+lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t       HOST_WIDE_INT count, unsigned int prec,\n+\t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, int arith)\n {\n   unsigned HOST_WIDE_INT signmask;\n \n@@ -417,8 +420,9 @@ lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count,\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n-rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count,\n-\t       unsigned int prec, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n+rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t       HOST_WIDE_INT count, unsigned int prec,\n+\t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n \t       int arith)\n {\n   unsigned HOST_WIDE_INT signmask;\n@@ -479,8 +483,9 @@ rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count,\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n-lrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count,\n-\t\tunsigned int prec, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n+lrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t\tHOST_WIDE_INT count, unsigned int prec,\n+\t\tunsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n   unsigned HOST_WIDE_INT s1l, s2l;\n   HOST_WIDE_INT s1h, s2h;\n@@ -500,8 +505,9 @@ lrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n-rrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1, HOST_WIDE_INT count,\n-\t\tunsigned int prec, unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n+rrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t\tHOST_WIDE_INT count, unsigned int prec,\n+\t\tunsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n   unsigned HOST_WIDE_INT s1l, s2l;\n   HOST_WIDE_INT s1h, s2h;\n@@ -530,7 +536,8 @@ div_and_round_double (enum tree_code code, int uns,\n \t\t      unsigned HOST_WIDE_INT lnum_orig, /* num == numerator == dividend */\n \t\t      HOST_WIDE_INT hnum_orig,\n \t\t      unsigned HOST_WIDE_INT lden_orig, /* den == denominator == divisor */\n-\t\t      HOST_WIDE_INT hden_orig, unsigned HOST_WIDE_INT *lquo,\n+\t\t      HOST_WIDE_INT hden_orig,\n+\t\t      unsigned HOST_WIDE_INT *lquo,\n \t\t      HOST_WIDE_INT *hquo, unsigned HOST_WIDE_INT *lrem,\n \t\t      HOST_WIDE_INT *hrem)\n {\n@@ -906,7 +913,8 @@ negate_expr (tree t)\n    same type as IN, but they will have the same signedness and mode.  */\n \n static tree\n-split_tree (tree in, enum tree_code code, tree *conp, tree *litp, tree *minus_litp, int negate_p)\n+split_tree (tree in, enum tree_code code, tree *conp, tree *litp,\n+\t    tree *minus_litp, int negate_p)\n {\n   tree var = 0;\n \n@@ -2416,7 +2424,8 @@ distribute_bit_expr (enum tree_code code, tree type, tree arg0, tree arg1)\n    starting at BITPOS.  The field is unsigned if UNSIGNEDP is nonzero.  */\n \n static tree\n-make_bit_field_ref (tree inner, tree type, int bitsize, int bitpos, int unsignedp)\n+make_bit_field_ref (tree inner, tree type, int bitsize, int bitpos,\n+\t\t    int unsignedp)\n {\n   tree result = build (BIT_FIELD_REF, type, inner,\n \t\t       size_int (bitsize), bitsize_int (bitpos));\n@@ -2447,7 +2456,8 @@ make_bit_field_ref (tree inner, tree type, int bitsize, int bitpos, int unsigned\n    tree.  Otherwise we return zero.  */\n \n static tree\n-optimize_bit_field_compare (enum tree_code code, tree compare_type, tree lhs, tree rhs)\n+optimize_bit_field_compare (enum tree_code code, tree compare_type,\n+\t\t\t    tree lhs, tree rhs)\n {\n   HOST_WIDE_INT lbitpos, lbitsize, rbitpos, rbitsize, nbitpos, nbitsize;\n   tree type = TREE_TYPE (lhs);\n@@ -2621,8 +2631,9 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type, tree lhs, tr\n    do anything with.  */\n \n static tree\n-decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize, HOST_WIDE_INT *pbitpos,\n-\t\t\tenum machine_mode *pmode, int *punsignedp, int *pvolatilep,\n+decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize,\n+\t\t\tHOST_WIDE_INT *pbitpos, enum machine_mode *pmode,\n+\t\t\tint *punsignedp, int *pvolatilep,\n \t\t\ttree *pmask, tree *pand_mask)\n {\n   tree outer_type = 0;\n@@ -2821,8 +2832,8 @@ simple_operand_p (tree exp)\n    type if both are specified.  */\n \n static tree\n-range_binop (enum tree_code code, tree type, tree arg0, int upper0_p, tree arg1,\n-\t     int upper1_p)\n+range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n+\t     tree arg1, int upper1_p)\n {\n   tree tem;\n   int result;\n@@ -3228,8 +3239,8 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n    can, 0 if we can't.  Set the output range into the specified parameters.  */\n \n static int\n-merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0, tree high0,\n-\t      int in1_p, tree low1, tree high1)\n+merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n+\t      tree high0, int in1_p, tree low1, tree high1)\n {\n   int no_overlap;\n   int subset;\n@@ -4397,7 +4408,8 @@ count_cond (tree expr, int lim)\n    original expression.  */\n \n static tree\n-fold_binary_op_with_conditional_arg (enum tree_code code, tree type, tree cond, tree arg, int cond_first_p)\n+fold_binary_op_with_conditional_arg (enum tree_code code, tree type,\n+\t\t\t\t     tree cond, tree arg, int cond_first_p)\n {\n   tree test, true_value, false_value;\n   tree lhs = NULL_TREE;\n@@ -4575,7 +4587,8 @@ fold_real_zero_addition_p (tree type, tree addend, int negate)\n    can be made, and NULL_TREE otherwise.  */\n \n static tree\n-fold_mathfn_compare (enum built_in_function fcode, enum tree_code code, tree type, tree arg0, tree arg1)\n+fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n+\t\t     tree type, tree arg0, tree arg1)\n {\n   REAL_VALUE_TYPE c;\n "}]}