{"sha": "6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYzMjJkMjc3OGE4ZDVkMmMyYzg5ZDcxODlhYTA4ZWJiMjY2ZjVkNQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-08-22T08:19:00Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-08-22T08:19:00Z"}, "message": "codecvt.h: Implement codecvt<wchar_t, char, mbstate_t>.\n\n\n\n2000-08-21  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\t* bits/codecvt.h: Implement codecvt<wchar_t, char, mbstate_t>. Fix\n\tup __enc_traits template so as to be marginally useful.\n\t* src/codecvt.cc: And here.\n\t* bits/char_traits: Tweak.\n\t* bits/locale_facets.h: Tweak.\n\t* bits/locale_facets.tcc: Tweak.\n\t* bits/localefwd.h: Tweak.\n\t* src/locale-inst.cc: Add use_facet/has_facet instantiations here.\n\t* testsuite/22_locale/codecvt_wchar_t_cc.cc: New file.\n\t* testsuite/22_locale/codecvt_char_char.cc: New file.\n\t* testsuite/22_locale/codecvt_unicode_char.cc: New file.\n\nFrom-SVN: r35871", "tree": {"sha": "4b71630d16ddc6bc5e51ba75ea5fce6931706964", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b71630d16ddc6bc5e51ba75ea5fce6931706964"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5/comments", "author": null, "committer": null, "parents": [{"sha": "a5834d1b7912ea9bd5066cd53cf99764b26055c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5834d1b7912ea9bd5066cd53cf99764b26055c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5834d1b7912ea9bd5066cd53cf99764b26055c6"}], "stats": {"total": 386, "additions": 386, "deletions": 0}, "files": [{"sha": "a86e7ff9ef86b5df135c3a50a6c6e1edb8db94eb", "filename": "libstdc++-v3/testsuite/22_locale/codecvt_char_char.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_char_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_char_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_char_char.cc?ref=6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5", "patch": "@@ -0,0 +1,90 @@\n+// 2000-08-17 Benjamin Kosnik <bkoz@cygnus.com>\n+\n+// Copyright (C) 2000 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <debug_assert.h>\n+\n+// Required instantiation, degenerate conversion.\n+// codecvt<char, char, mbstate_t>\n+void test01()\n+{\n+  using namespace std;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef codecvt<char, char, mbstate_t> \tc_codecvt;\n+\n+  bool \t\t\ttest = true;\n+  const char* \t\tc_lit = \"black pearl jasmine tea\";\n+  const char* \t        from_next;\n+  int \t\t\tsize = 25;\n+  char* \t\tc_arr = new char[size];\n+  char*\t\t\tto_next;\n+\n+  locale \t\tloc;\n+  c_codecvt::state_type state;\n+  const c_codecvt* \tcvt = &use_facet<c_codecvt>(loc); \n+\n+  // in\n+  result r1 = cvt->in(state, c_lit, c_lit + size, from_next, \n+\t\t      c_arr, c_arr + size, to_next);\n+  VERIFY( r1 == codecvt_base::noconv );\n+  VERIFY( !strcmp(c_arr, c_lit) ); \n+  VERIFY( from_next == c_lit );\n+  VERIFY( to_next == c_arr );\n+\n+  // out\n+  result r2 = cvt->out(state, c_lit, c_lit + size, from_next, \n+\t\t       c_arr, c_arr + size, to_next);\n+  VERIFY( r2 == codecvt_base::noconv );\n+  VERIFY( !strcmp(c_arr, c_lit) ); \n+  VERIFY( from_next == c_lit );\n+  VERIFY( to_next == c_arr );\n+\n+  // unshift\n+  strcpy(c_arr, c_lit);\n+  result r3 = cvt->unshift(state, c_arr, c_arr + size, to_next);\n+  VERIFY( r3 == codecvt_base::noconv );\n+  VERIFY( !strcmp(c_arr, c_lit) ); \n+  VERIFY( to_next == c_arr );\n+\n+  int i = cvt->encoding();\n+  VERIFY( i == 1 );\n+\n+  VERIFY( cvt->always_noconv() );\n+\n+  int j = cvt->length(state, c_lit, c_lit + size, 5);\n+  VERIFY( j == 5 );\n+\n+  int k = cvt->max_length();\n+  VERIFY( k == 1 );\n+\n+  delete [] c_arr;\n+}\n+\n+int main ()\n+{\n+  test01();\n+\n+  return 0;\n+}\n+\n+\n+"}, {"sha": "55e089e2a36482e5105742438a667661590d29a5", "filename": "libstdc++-v3/testsuite/22_locale/codecvt_unicode_char.cc", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_unicode_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_unicode_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_unicode_char.cc?ref=6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5", "patch": "@@ -0,0 +1,176 @@\n+// 2000-08-22 Benjamin Kosnik <bkoz@cygnus.com>\n+\n+// Copyright (C) 2000 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <debug_assert.h>\n+\n+using namespace std;\n+\n+/*\n+> how do I check that these conversions are correct? \n+Very easy.  Since all the characters are from ASCII you simply\n+zero-extend the values.\n+\n+drepper$ echo 'black pearl jasmine tea' | od -t x1\n+0000000 62 6c 61 63 6b 20 70 65 61 72 6c 20 6a 61 73 6d\n+0000020 69 6e 65 20 74 65 61 0a\n+\n+So the UCS-2 string is\n+\n+0x0062, 0x006c, 0x0061, ...\n+\n+You get the idea.  With iconv() you have to take care of the\n+byte-order, though.  UCS-2 can mean little- or big endian.  Looking at\n+your result\n+\n+> $9 = 25856\n+\n+it shows that the other byte-order is used (25856 == 0x6500).\n+*/\n+\n+#if 0\n+void  \n+create_internal_literal(unsigned short* i_lit)\n+{\n+  i_lit[00] = 25088; //b\n+  i_lit[01] = 27648; //l\n+  i_lit[02] = 24832; //a\n+  i_lit[03] = 25344; //c\n+  i_lit[04] = 27392; //k\n+  i_lit[05] = 8192;\n+  i_lit[06] = 28672; //p\n+  i_lit[07] = 25856; //e\n+  i_lit[08] = 24832; //a\n+  i_lit[09] = 29148; //r\n+  i_lit[10] = 27648; //l\n+  i_lit[11] = 8192;\n+  i_lit[12] = 27136; //j\n+  i_lit[13] = 24832;\n+  i_lit[14] = 29440;\n+  i_lit[15] = 27904;\n+  i_lit[16] = 26880;\n+  i_lit[17] = 28160;\n+  i_lit[18] = 25856; //e\n+  i_lit[19] = 8192;\n+  i_lit[20] = 29696; //t\n+  i_lit[21] = 25856; //e\n+  i_lit[22] = 24832; //a\n+  i_lit[23] = 2560;\n+}\n+#endif\n+\n+void\n+initialize_state(__enc_traits& state)\n+{ state._M_init(); }\n+\n+// Partial specialization using __enc_traits.\n+// codecvt<unicode_t, char, __enc_traits>\n+void test01()\n+{\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef unsigned short\t\t\tunicode_t;\n+  typedef unicode_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef __enc_traits\t\t\t\tenc_type;\n+  typedef codecvt<int_type, ext_type, enc_type>\tunicode_codecvt;\n+  typedef char_traits<int_type>\t\t\tint_traits;\n+  typedef char_traits<ext_type>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit = \"black pearl jasmine tea\";\n+  const ext_type*       efrom_next;\n+  const int_type*       ifrom_next;\n+  int \t\t\tsize = strlen(e_lit);\n+\n+  int_type \t\ti_lit_base[24] = \n+  { 25088, 27648, 24832, 25344, 27392, 8192, 28672, 25856, 24832, 29184, \n+    27648, 8192, 27136, 24832, 29440, 27904, 26880, 28160, 25856, 8192, 29696,\n+    25856, 24832, 2560\n+  };\n+  const int_type* \ti_lit = i_lit_base;\n+\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type*\t\teto_next;\n+  int_type* \t\ti_arr = new int_type[size + 1];\n+  int_type*\t\tito_next;\n+\n+  // construct a locale object with the specialized facet.\n+  locale \t\tloc(locale::classic(), new unicode_codecvt);\n+  // sanity check the constructed locale has the specialized facet.\n+  VERIFY( has_facet<unicode_codecvt>(loc) );\n+  const unicode_codecvt&\tcvt = use_facet<unicode_codecvt>(loc); \n+\n+  // in\n+  unicode_codecvt::state_type state01(\"UNICODE\", \"ISO_8859-1\");\n+  initialize_state(state01);\n+  result r1 = cvt.in(state01, e_lit, e_lit + size, efrom_next, \n+\t\t     i_arr, i_arr + size, ito_next);\n+  VERIFY( r1 == codecvt_base::ok );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n+  VERIFY( efrom_next == e_lit + size );\n+  VERIFY( ito_next == i_arr + size );\n+\n+  // out\n+  unicode_codecvt::state_type state02;\n+  initialize_state(state02);  \n+  result r2 = cvt.out(state02, i_lit, i_lit + size, ifrom_next, \n+\t\t       e_arr, e_arr + size, eto_next);\n+  VERIFY( r2 == codecvt_base::ok );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, size) ); \n+  VERIFY( ifrom_next == i_lit + size );\n+  VERIFY( eto_next == e_arr + size );\n+\n+  // unshift\n+  ext_traits::copy(e_arr, e_lit, size);\n+  unicode_codecvt::state_type state03;\n+  initialize_state(state03);\n+  result r3 = cvt.unshift(state03, e_arr, e_arr + size, eto_next);\n+  VERIFY( r3 == codecvt_base::noconv );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, size) ); \n+  VERIFY( eto_next == e_arr );\n+\n+  int i = cvt.encoding();\n+  VERIFY( i == 0 );\n+\n+  VERIFY( !cvt.always_noconv() );\n+\n+  unicode_codecvt::state_type state04;\n+  initialize_state(state04);\n+  int j = cvt.length(state03, e_lit, e_lit + size, 5);\n+  VERIFY( j == 5 );\n+\n+  int k = cvt.max_length();\n+  VERIFY( k == 1 );\n+\n+  delete [] e_arr;\n+  delete [] i_arr;\n+}\n+\n+int main ()\n+{\n+  test01();\n+\n+  return 0;\n+}\n+\n+\n+"}, {"sha": "7ef07b0443c097df6a44c45d6b39270950f7686f", "filename": "libstdc++-v3/testsuite/22_locale/codecvt_wchar_t_char.cc", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_wchar_t_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_wchar_t_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_wchar_t_char.cc?ref=6f322d2778a8d5d2c2c89d7189aa08ebb266f5d5", "patch": "@@ -0,0 +1,120 @@\n+// 2000-08-18 Benjamin Kosnik <bkoz@cygnus.com>\n+\n+// Copyright (C) 2000 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.1.5 - Template class codecvt [lib.locale.codecvt]\n+\n+#include <locale>\n+#include <debug_assert.h>\n+\n+\n+// Need to explicitly set the state(mbstate_t) to zero.\n+// How to do this is not specified by the ISO C9X standard, so we\n+// might need to add some operators to make the intuiative case\n+// work:\n+//   w_codecvt::state_type state00;\n+//   state00 = 0;  \n+// or, can use this explicit \"C\" initialization:\n+//   w_codecvt::state_type state01 = {0, 0};\n+// .. except Ulrich says: Use memset. Always use memset. Feel the force...\n+void\n+zero_state(mbstate_t& state)\n+{ memset(&state, 0, sizeof(mbstate_t)); }\n+\n+// Required instantiation\n+// codecvt<wchar_t, char, mbstate_t>\n+void test01()\n+{\n+  using namespace std;\n+  typedef codecvt<wchar_t, char, mbstate_t> \tw_codecvt;\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef wchar_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef char_traits<wchar_t>\t\t\tint_traits;\n+  typedef char_traits<char>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit = \"black pearl jasmine tea\";\n+  const ext_type*       efrom_next;\n+  const int_type* \ti_lit = L\"black pearl jasmine tea\";\n+  const int_type*       ifrom_next;\n+  int \t\t\tsize = strlen(e_lit);\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type*\t\teto_next;\n+  int_type* \t\ti_arr = new int_type[size + 1];\n+  int_type*\t\tito_next;\n+\n+  locale \t\tloc;\n+  const w_codecvt* \tcvt = &use_facet<w_codecvt>(loc); \n+\n+  // in\n+  w_codecvt::state_type state01;\n+  zero_state(state01);\n+  result r1 = cvt->in(state01, e_lit, e_lit + size, efrom_next, \n+\t\t      i_arr, i_arr + size, ito_next);\n+  VERIFY( r1 == codecvt_base::ok );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n+  VERIFY( efrom_next == e_lit + size );\n+  VERIFY( ito_next == i_arr + size );\n+\n+  // out\n+  w_codecvt::state_type state02;\n+  zero_state(state02);  \n+  result r2 = cvt->out(state02, i_lit, i_lit + size, ifrom_next, \n+\t\t       e_arr, e_arr + size, eto_next);\n+  VERIFY( r2 == codecvt_base::ok );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, size) ); \n+  VERIFY( ifrom_next == i_lit + size );\n+  VERIFY( eto_next == e_arr + size );\n+\n+  // unshift\n+  strcpy(e_arr, e_lit);\n+  w_codecvt::state_type state03;\n+  zero_state(state03);\n+  result r3 = cvt->unshift(state03, e_arr, e_arr + size, eto_next);\n+  VERIFY( r3 == codecvt_base::noconv );\n+  VERIFY( !strcmp(e_arr, e_lit) ); \n+  VERIFY( eto_next == e_arr );\n+\n+  int i = cvt->encoding();\n+  VERIFY( i == 0 );\n+\n+  VERIFY( !cvt->always_noconv() );\n+\n+  w_codecvt::state_type state04;\n+  zero_state(state04);\n+  int j = cvt->length(state03, e_lit, e_lit + size, 5);\n+  VERIFY( j == 5 );\n+\n+  int k = cvt->max_length();\n+  VERIFY( k == 1 );\n+\n+  delete [] e_arr;\n+  delete [] i_arr;\n+}\n+\n+int main ()\n+{\n+  test01();\n+\n+  return 0;\n+}\n+\n+\n+"}]}