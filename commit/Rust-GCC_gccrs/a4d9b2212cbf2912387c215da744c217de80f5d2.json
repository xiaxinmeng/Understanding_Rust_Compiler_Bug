{"sha": "a4d9b2212cbf2912387c215da744c217de80f5d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRkOWIyMjEyY2JmMjkxMjM4N2MyMTVkYTc0NGMyMTdkZTgwZjVkMg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-12-12T23:12:06Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-12-12T23:12:06Z"}, "message": "error.c (gfc_error): Add variant which takes a va_list.\n\n2014-12-13  Tobias Burnus  <burnus@net-b.de>\n            Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\nfortran/\n        * error.c (gfc_error): Add variant which takes a va_list.\n        (gfc_notify_std): Convert to common diagnostic.\n        * array.c: Use %qs, %<...%> in more gfc_error calls and\n        for gfc_notify_std.\n        * check.c: Ditto.\n        * data.c: Ditto.\n        * decl.c: Ditto.\n        * expr.c: Ditto.\n        * interface.c: Ditto.\n        * intrinsic.c: Ditto.\n        * io.c: Ditto.\n        * match.c: Ditto.\n        * matchexp.c: Ditto.\n        * module.c: Ditto.\n        * openmp.c: Ditto.\n        * parse.c: Ditto.\n        * primary.c: Ditto.\n        * resolve.c: Ditto.\n        * simplify.c: Ditto.\n        * symbol.c: Ditto.\n        * trans-common.c: Ditto.\n        * trans-intrinsic.c: Ditto.\n\ngcc/testsuite/\n        * gfortran.dg/realloc_on_assign_21.f90: Update dg-error.\n        * gfortran.dg/warnings_are_errors_1.f: Ditto.\n        * gfortran.dg/warnings_are_errors_1.f90: Ditto.\n\n\nCo-Authored-By: Manuel L\u00f3pez-Ib\u00e1\u00f1ez <manu@gcc.gnu.org>\n\nFrom-SVN: r218694", "tree": {"sha": "142ed494ce58fe546f97386fe9da7a4610d92270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/142ed494ce58fe546f97386fe9da7a4610d92270"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4d9b2212cbf2912387c215da744c217de80f5d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4d9b2212cbf2912387c215da744c217de80f5d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4d9b2212cbf2912387c215da744c217de80f5d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4d9b2212cbf2912387c215da744c217de80f5d2/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "33948765f16435febf518b9ce4843b4b1e386677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33948765f16435febf518b9ce4843b4b1e386677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33948765f16435febf518b9ce4843b4b1e386677"}], "stats": {"total": 925, "additions": 517, "deletions": 408}, "files": [{"sha": "4d99f1830f8374061eafd6fba7e7015017a0235b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -1,3 +1,29 @@\n+2014-12-13  Tobias Burnus  <burnus@net-b.de>\n+\t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\t* error.c (gfc_error): Add variant which takes a va_list.\n+\t(gfc_notify_std): Convert to common diagnostic.\n+\t* array.c: Use %qs, %<...%> in more gfc_error calls and\n+\tfor gfc_notify_std.\n+\t* check.c: Ditto.\n+\t* data.c: Ditto.\n+\t* decl.c: Ditto.\n+\t* expr.c: Ditto.\n+\t* interface.c: Ditto.\n+\t* intrinsic.c: Ditto.\n+\t* io.c: Ditto.\n+\t* match.c: Ditto.\n+\t* matchexp.c: Ditto.\n+\t* module.c: Ditto.\n+\t* openmp.c: Ditto.\n+\t* parse.c: Ditto.\n+\t* primary.c: Ditto.\n+\t* resolve.c: Ditto.\n+\t* simplify.c: Ditto.\n+\t* symbol.c: Ditto.\n+\t* trans-common.c: Ditto.\n+\t* trans-intrinsic.c: Ditto.\n+\n 2014-12-11  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/42108"}, {"sha": "300bfebf1fa5a486bddfa8191bc0c7e676d36ac8", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -684,7 +684,7 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n \n   if (current_type == AS_EXPLICIT)\n     {\n-      gfc_error (\"Upper bound of last coarray dimension must be '*' at %C\");\n+      gfc_error (\"Upper bound of last coarray dimension must be %<*%> at %C\");\n       goto cleanup;\n     }\n "}, {"sha": "527123df725ae7a8cdb6235b029a5688d0cffaa2", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -384,7 +384,7 @@ less_than_bitsize2 (const char *arg1, gfc_expr *expr1, const char *arg2,\n       i3 = gfc_validate_kind (BT_INTEGER, expr1->ts.kind, false);\n       if (i2 > gfc_integer_kinds[i3].bit_size)\n \t{\n-\t  gfc_error (\"'%s + %s' at %L must be less than or equal \"\n+\t  gfc_error (\"%<%s + %s%> at %L must be less than or equal \"\n \t\t     \"to BIT_SIZE(%qs)\",\n \t\t     arg2, arg3, &expr2->where, arg1);\n \t  return false;\n@@ -581,7 +581,7 @@ dim_corank_check (gfc_expr *dim, gfc_expr *array)\n   if (mpz_cmp_ui (dim->value.integer, 1) < 0\n       || mpz_cmp_ui (dim->value.integer, corank) > 0)\n     {\n-      gfc_error (\"'dim' argument of %qs intrinsic at %L is not a valid \"\n+      gfc_error (\"%<dim%> argument of %qs intrinsic at %L is not a valid \"\n \t\t \"codimension index\", gfc_current_intrinsic, &dim->where);\n \n       return false;\n@@ -631,7 +631,7 @@ dim_rank_check (gfc_expr *dim, gfc_expr *array, int allow_assumed)\n   if (mpz_cmp_ui (dim->value.integer, 1) < 0\n       || mpz_cmp_ui (dim->value.integer, rank) > 0)\n     {\n-      gfc_error (\"'dim' argument of %qs intrinsic at %L is not a valid \"\n+      gfc_error (\"%<dim%> argument of %qs intrinsic at %L is not a valid \"\n \t\t \"dimension index\", gfc_current_intrinsic, &dim->where);\n \n       return false;\n@@ -1378,7 +1378,7 @@ gfc_check_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n       if (x->ts.type == BT_COMPLEX)\n \t{\n \t  gfc_error (\"%qs argument of %qs intrinsic at %L must not be \"\n-\t\t     \"present if 'x' is COMPLEX\",\n+\t\t     \"present if %<x%> is COMPLEX\",\n \t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t     &y->where);\n \t  return false;\n@@ -1428,7 +1428,7 @@ check_co_collective (gfc_expr *a, gfc_expr *image_idx, gfc_expr *stat,\n   /* Fortran 2008, 12.5.2.4, paragraph 18.  */\n   if (gfc_has_vector_subscript (a))\n     {\n-      gfc_error (\"Argument 'A' with INTENT(INOUT) at %L of the intrinsic \"\n+      gfc_error (\"Argument %<A%> with INTENT(INOUT) at %L of the intrinsic \"\n \t\t \"subroutine %s shall not have a vector subscript\",\n \t\t &a->where, gfc_current_intrinsic);\n       return false;\n@@ -1728,7 +1728,7 @@ gfc_check_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n     return false;\n   if (!kind_check (kind, 2, BT_INTEGER))\n     return false;\n-  if (kind && !gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+  if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t       \"with KIND argument at %L\", \n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n@@ -1835,7 +1835,7 @@ gfc_check_dcmplx (gfc_expr *x, gfc_expr *y)\n       if (x->ts.type == BT_COMPLEX)\n \t{\n \t  gfc_error (\"%qs argument of %qs intrinsic at %L must not be \"\n-\t\t     \"present if 'x' is COMPLEX\",\n+\t\t     \"present if %<x%> is COMPLEX\",\n \t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t     &y->where);\n \t  return false;\n@@ -1908,7 +1908,8 @@ gfc_check_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n   if (! identical_dimen_shape (vector_a, 0, vector_b, 0))\n     {\n       gfc_error (\"Different shape for arguments %qs and %qs at %L for \"\n-\t\t \"intrinsic 'dot_product'\", gfc_current_intrinsic_arg[0]->name,\n+\t\t \"intrinsic %<dot_product%>\",\n+\t\t gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic_arg[1]->name, &vector_a->where);\n       return false;\n     }\n@@ -2146,9 +2147,9 @@ gfc_check_fn_rc2008 (gfc_expr *a)\n     return false;\n \n   if (a->ts.type == BT_COMPLEX\n-      && !gfc_notify_std (GFC_STD_F2008, \"COMPLEX argument '%s' \"\n-\t\t\t  \"of '%s' intrinsic at %L\", \n-\t\t\t  gfc_current_intrinsic_arg[0]->name, \n+      && !gfc_notify_std (GFC_STD_F2008, \"COMPLEX argument %qs \"\n+\t\t\t  \"of %qs intrinsic at %L\",\n+\t\t\t  gfc_current_intrinsic_arg[0]->name,\n \t\t\t  gfc_current_intrinsic, &a->where))\n     return false;\n \n@@ -2259,7 +2260,7 @@ gfc_check_ichar_iachar (gfc_expr *c, gfc_expr *kind)\n   if (!kind_check (kind, 1, BT_INTEGER))\n     return false;\n \n-  if (kind && !gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+  if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t       \"with KIND argument at %L\", \n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n@@ -2362,7 +2363,7 @@ gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back,\n \n   if (!kind_check (kind, 3, BT_INTEGER))\n     return false;\n-  if (kind && !gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+  if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t       \"with KIND argument at %L\", \n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n@@ -2556,7 +2557,7 @@ gfc_check_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n \n   if (!kind_check (kind, 2, BT_INTEGER))\n     return false;\n-  if (kind && !gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+  if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t       \"with KIND argument at %L\", \n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n@@ -2601,7 +2602,7 @@ gfc_check_len_lentrim (gfc_expr *s, gfc_expr *kind)\n \n   if (!kind_check (kind, 1, BT_INTEGER))\n     return false;\n-  if (kind && !gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+  if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t       \"with KIND argument at %L\", \n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n@@ -2840,17 +2841,17 @@ check_rest (bt type, int kind, gfc_actual_arglist *arglist)\n \t    }\n \t  else\n \t    {\n-\t      gfc_error (\"'a%d' argument of %qs intrinsic at %L must be \"\n+\t      gfc_error (\"%<a%d%> argument of %qs intrinsic at %L must be \"\n \t\t\t \"%s(%d)\", n, gfc_current_intrinsic, &x->where,\n \t\t\t gfc_basic_typename (type), kind);\n \t      return false;\n \t    }\n \t}\n \n       for (tmp = arglist, m=1; tmp != arg; tmp = tmp->next, m++)\n-\tif (!gfc_check_conformance (tmp->expr, x, \n+\tif (!gfc_check_conformance (tmp->expr, x,\n \t\t\t\t    \"arguments 'a%d' and 'a%d' for \"\n-\t\t\t\t    \"intrinsic '%s'\", m, n, \n+\t\t\t\t    \"intrinsic '%s'\", m, n,\n \t\t\t\t    gfc_current_intrinsic))\n \t    return false;\n     }\n@@ -2871,14 +2872,14 @@ gfc_check_min_max (gfc_actual_arglist *arg)\n \n   if (x->ts.type == BT_CHARACTER)\n     {\n-      if (!gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+      if (!gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t   \"with CHARACTER argument at %L\", \n \t\t\t   gfc_current_intrinsic, &x->where))\n \treturn false;\n     }\n   else if (x->ts.type != BT_INTEGER && x->ts.type != BT_REAL)\n     {\n-      gfc_error (\"'a1' argument of %qs intrinsic at %L must be INTEGER, \"\n+      gfc_error (\"%<a1%> argument of %qs intrinsic at %L must be INTEGER, \"\n \t\t \"REAL or CHARACTER\", gfc_current_intrinsic, &x->where);\n       return false;\n     }\n@@ -3287,7 +3288,7 @@ gfc_check_nearest (gfc_expr *x, gfc_expr *s)\n     {\n       if (mpfr_sgn (s->value.real) == 0)\n \t{\n-\t  gfc_error (\"Argument 'S' of NEAREST at %L shall not be zero\",\n+\t  gfc_error (\"Argument %<S%> of NEAREST at %L shall not be zero\",\n \t\t     &s->where);\n \t  return false;\n \t}\n@@ -3661,7 +3662,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \n   if (!gfc_array_size (shape, &size))\n     {\n-      gfc_error (\"'shape' argument of 'reshape' intrinsic at %L must be an \"\n+      gfc_error (\"%<shape%> argument of %<reshape%> intrinsic at %L must be an \"\n \t\t \"array of constant size\", &shape->where);\n       return false;\n     }\n@@ -3678,7 +3679,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n     }\n   else if (shape_size > GFC_MAX_DIMENSIONS)\n     {\n-      gfc_error (\"'shape' argument of 'reshape' intrinsic at %L has more \"\n+      gfc_error (\"%<shape%> argument of %<reshape%> intrinsic at %L has more \"\n \t\t \"than %d elements\", &shape->where, GFC_MAX_DIMENSIONS);\n       return false;\n     }\n@@ -3764,7 +3765,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t\t{\n \t\t  gfc_error (\"%qs argument of %qs intrinsic at %L has \"\n \t\t\t     \"invalid permutation of dimensions (dimension \"\n-\t\t\t     \"'%d' duplicated)\",\n+\t\t\t     \"%<%d%> duplicated)\",\n \t\t\t     gfc_current_intrinsic_arg[3]->name,\n \t\t\t     gfc_current_intrinsic, &e->where, dim);\n \t\t  return false;\n@@ -3882,7 +3883,7 @@ gfc_check_scan (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n \n   if (!kind_check (kind, 3, BT_INTEGER))\n     return false;\n-  if (kind && !gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+  if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t       \"with KIND argument at %L\", \n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n@@ -3944,7 +3945,7 @@ gfc_check_selected_real_kind (gfc_expr *p, gfc_expr *r, gfc_expr *radix)\n {\n   if (p == NULL && r == NULL\n       && !gfc_notify_std (GFC_STD_F2008, \"SELECTED_REAL_KIND with\"\n-\t\t\t  \" neither 'P' nor 'R' argument at %L\", \n+\t\t\t  \" neither %<P%> nor %<R%> argument at %L\", \n \t\t\t  gfc_current_intrinsic_where))\n     return false;\n \n@@ -3974,7 +3975,7 @@ gfc_check_selected_real_kind (gfc_expr *p, gfc_expr *r, gfc_expr *radix)\n       if (!scalar_check (radix, 1))\n \treturn false;\n \n-      if (!gfc_notify_std (GFC_STD_F2008, \"'%s' intrinsic with \"\n+      if (!gfc_notify_std (GFC_STD_F2008, \"%qs intrinsic with \"\n \t\t\t   \"RADIX argument at %L\", gfc_current_intrinsic, \n \t\t\t   &radix->where))\n \treturn false;\n@@ -4009,14 +4010,14 @@ gfc_check_shape (gfc_expr *source, gfc_expr *kind)\n \n   if (ar->as && ar->as->type == AS_ASSUMED_SIZE && ar->type == AR_FULL)\n     {\n-      gfc_error (\"'source' argument of 'shape' intrinsic at %L must not be \"\n+      gfc_error (\"%<source%> argument of %<shape%> intrinsic at %L must not be \"\n \t\t \"an assumed size array\", &source->where);\n       return false;\n     }\n \n   if (!kind_check (kind, 1, BT_INTEGER))\n     return false;\n-  if (kind && !gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+  if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t       \"with KIND argument at %L\", \n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n@@ -4071,7 +4072,7 @@ gfc_check_size (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n \n   if (!kind_check (kind, 2, BT_INTEGER))\n     return false;\n-  if (kind && !gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+  if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t       \"with KIND argument at %L\", \n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n@@ -5053,8 +5054,8 @@ gfc_check_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n \n   if (mold->ts.type == BT_HOLLERITH)\n     {\n-      gfc_error (\"'MOLD' argument of 'TRANSFER' intrinsic at %L must not be %s\",\n-\t\t &mold->where, gfc_basic_typename (BT_HOLLERITH));\n+      gfc_error (\"%<MOLD%> argument of %<TRANSFER%> intrinsic at %L must not be\"\n+                 \" %s\", &mold->where, gfc_basic_typename (BT_HOLLERITH));\n       return false;\n     }\n \n@@ -5113,7 +5114,7 @@ gfc_check_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n \n   if (!kind_check (kind, 2, BT_INTEGER))\n     return false;\n-  if (kind && !gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+  if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t       \"with KIND argument at %L\", \n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;\n@@ -5242,7 +5243,7 @@ gfc_check_verify (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n \n   if (!kind_check (kind, 3, BT_INTEGER))\n     return false;\n-  if (kind && !gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n+  if (kind && !gfc_notify_std (GFC_STD_F2003, \"%qs intrinsic \"\n \t\t\t       \"with KIND argument at %L\", \n \t\t\t       gfc_current_intrinsic, &kind->where))\n     return false;"}, {"sha": "8e072ee0087b1a893ff554b39103600f3d023e4a", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -324,7 +324,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t\t\t   > LOCATION_LINE (rvalue->where.lb->location))\n \t\t\t  ? con->expr : rvalue;\n \t\t  if (gfc_notify_std (GFC_STD_GNU,\n-\t\t\t\t      \"re-initialization of '%s' at %L\",\n+\t\t\t\t      \"re-initialization of %qs at %L\",\n \t\t\t\t      symbol->name, &exprd->where) == false)\n \t\t    return false;\n \t\t}\n@@ -490,7 +490,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t\t  > LOCATION_LINE (rvalue->where.lb->location))\n \t       ? init : rvalue;\n \t  if (gfc_notify_std (GFC_STD_GNU,\n-\t\t\t      \"re-initialization of '%s' at %L\",\n+\t\t\t      \"re-initialization of %qs at %L\",\n \t\t\t      symbol->name, &expr->where) == false)\n \t    return false;\n \t}"}, {"sha": "1c648735ae6eaa013362d27032d06c58e25fa78d", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -269,7 +269,7 @@ var_element (gfc_data_variable *new_var)\n   if (gfc_current_state () != COMP_BLOCK_DATA\n       && sym->attr.in_common\n       && !gfc_notify_std (GFC_STD_GNU, \"initialization of \"\n-\t\t\t  \"common block variable '%s' in DATA statement at %C\",\n+\t\t\t  \"common block variable %qs in DATA statement at %C\",\n \t\t\t  sym->name))\n     return MATCH_ERROR;\n \n@@ -1059,16 +1059,16 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t     not have the allocatable, pointer, or optional attributes,\n \t     according to J3/04-007, section 5.1.  */\n \t  if (sym->attr.allocatable == 1\n-\t      && !gfc_notify_std (GFC_STD_F2008_TS, \"Variable '%s' at %L with \"\n-\t\t\t\t  \"ALLOCATABLE attribute in procedure '%s' \"\n+\t      && !gfc_notify_std (GFC_STD_F2008_TS, \"Variable %qs at %L with \"\n+\t\t\t\t  \"ALLOCATABLE attribute in procedure %qs \"\n \t\t\t\t  \"with BIND(C)\", sym->name,\n \t\t\t\t  &(sym->declared_at),\n \t\t\t\t  sym->ns->proc_name->name))\n \t    retval = false;\n \n \t  if (sym->attr.pointer == 1\n-\t      && !gfc_notify_std (GFC_STD_F2008_TS, \"Variable '%s' at %L with \"\n-\t\t\t\t  \"POINTER attribute in procedure '%s' \"\n+\t      && !gfc_notify_std (GFC_STD_F2008_TS, \"Variable %qs at %L with \"\n+\t\t\t\t  \"POINTER attribute in procedure %qs \"\n \t\t\t\t  \"with BIND(C)\", sym->name,\n \t\t\t\t  &(sym->declared_at),\n \t\t\t\t  sym->ns->proc_name->name))\n@@ -1092,9 +1092,9 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t      retval = false;\n \t    }\n \t  else if (sym->attr.optional == 1\n-\t\t   && !gfc_notify_std (GFC_STD_F2008_TS, \"Variable '%s' \"\n+\t\t   && !gfc_notify_std (GFC_STD_F2008_TS, \"Variable %qs \"\n \t\t\t\t       \"at %L with OPTIONAL attribute in \"\n-\t\t\t\t       \"procedure '%s' which is BIND(C)\", \n+\t\t\t\t       \"procedure %qs which is BIND(C)\", \n \t\t\t\t       sym->name, &(sym->declared_at), \n \t\t\t\t       sym->ns->proc_name->name))\n \t    retval = false;\n@@ -1103,7 +1103,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t     either assumed size or explicit shape. Deferred shape is already\n \t     covered by the pointer/allocatable attribute.  */\n \t  if (sym->as != NULL && sym->as->type == AS_ASSUMED_SHAPE\n-\t      && !gfc_notify_std (GFC_STD_F2008_TS, \"Assumed-shape array '%s' \"\n+\t      && !gfc_notify_std_1 (GFC_STD_F2008_TS, \"Assumed-shape array '%s' \"\n \t\t\t\t  \"at %L as dummy argument to the BIND(C) \"\n \t\t\t\t  \"procedure '%s' at %L\", sym->name, \n \t\t\t\t  &(sym->declared_at), \n@@ -2031,8 +2031,8 @@ variable_decl (int elem)\n \t{\n \t  if (current_attr.pointer)\n \t    {\n-\t      gfc_error (\"Pointer initialization at %C requires '=>', \"\n-\t\t\t \"not '='\");\n+\t      gfc_error (\"Pointer initialization at %C requires %<=>%>, \"\n+\t\t\t \"not %<=%>\");\n \t      m = MATCH_ERROR;\n \t      goto cleanup;\n \t    }\n@@ -5096,7 +5096,7 @@ match_ppc_decl (void)\n   /* Match the colons (required).  */\n   if (gfc_match (\" ::\") != MATCH_YES)\n     {\n-      gfc_error (\"Expected '::' after binding-attributes at %C\");\n+      gfc_error (\"Expected %<::%> after binding-attributes at %C\");\n       return MATCH_ERROR;\n     }\n \n@@ -6565,7 +6565,7 @@ cray_pointer_decl (void)\n     {\n       if (gfc_match_char ('(') != MATCH_YES)\n \t{\n-\t  gfc_error (\"Expected '(' at %C\");\n+\t  gfc_error (\"Expected %<(%> at %C\");\n \t  return MATCH_ERROR;\n \t}\n \n@@ -6680,7 +6680,7 @@ cray_pointer_decl (void)\n   if (m == MATCH_ERROR /* Failed when trying to find ',' above.  */\n       || gfc_match_eos () != MATCH_YES)\n     {\n-      gfc_error (\"Expected \\\",\\\" or end of statement at %C\");\n+      gfc_error (\"Expected %<,%> or end of statement at %C\");\n       return MATCH_ERROR;\n     }\n   return MATCH_YES;\n@@ -8272,13 +8272,13 @@ match_procedure_in_type (void)\n \treturn m;\n       if (m != MATCH_YES)\n \t{\n-\t  gfc_error (\"Interface-name expected after '(' at %C\");\n+\t  gfc_error (\"Interface-name expected after %<(%> at %C\");\n \t  return MATCH_ERROR;\n \t}\n \n       if (gfc_match (\" )\") != MATCH_YES)\n \t{\n-\t  gfc_error (\"')' expected at %C\");\n+\t  gfc_error (\"%<)%> expected at %C\");\n \t  return MATCH_ERROR;\n \t}\n \n@@ -8314,7 +8314,7 @@ match_procedure_in_type (void)\n   seen_colons = (m == MATCH_YES);\n   if (seen_attrs && !seen_colons)\n     {\n-      gfc_error (\"Expected '::' after binding-attributes at %C\");\n+      gfc_error (\"Expected %<::%> after binding-attributes at %C\");\n       return MATCH_ERROR;\n     }\n \n@@ -8342,13 +8342,13 @@ match_procedure_in_type (void)\n \t{\n \t  if (tb.deferred)\n \t    {\n-\t      gfc_error (\"'=> target' is invalid for DEFERRED binding at %C\");\n+\t      gfc_error (\"%<=> target%> is invalid for DEFERRED binding at %C\");\n \t      return MATCH_ERROR;\n \t    }\n \n \t  if (!seen_colons)\n \t    {\n-\t      gfc_error (\"'::' needed in PROCEDURE binding with explicit target\"\n+\t      gfc_error (\"%<::%> needed in PROCEDURE binding with explicit target\"\n \t\t\t \" at %C\");\n \t      return MATCH_ERROR;\n \t    }\n@@ -8358,7 +8358,7 @@ match_procedure_in_type (void)\n \t    return m;\n \t  if (m == MATCH_NO)\n \t    {\n-\t      gfc_error (\"Expected binding target after '=>' at %C\");\n+\t      gfc_error (\"Expected binding target after %<=>%> at %C\");\n \t      return MATCH_ERROR;\n \t    }\n \t  target = target_buf;\n@@ -8455,7 +8455,7 @@ gfc_match_generic (void)\n   /* Now the colons, those are required.  */\n   if (gfc_match (\" ::\") != MATCH_YES)\n     {\n-      gfc_error (\"Expected '::' at %C\");\n+      gfc_error (\"Expected %<::%> at %C\");\n       goto error;\n     }\n \n@@ -8493,7 +8493,7 @@ gfc_match_generic (void)\n   /* Match the required =>.  */\n   if (gfc_match (\" =>\") != MATCH_YES)\n     {\n-      gfc_error (\"Expected '=>' at %C\");\n+      gfc_error (\"Expected %<=>%> at %C\");\n       goto error;\n     }\n \n@@ -8705,7 +8705,7 @@ gfc_match_final_decl (void)\n \tlast = true;\n       if (!last && gfc_match_char (',') != MATCH_YES)\n \t{\n-\t  gfc_error (\"Expected ',' at %C\");\n+\t  gfc_error (\"Expected %<,%> at %C\");\n \t  return MATCH_ERROR;\n \t}\n "}, {"sha": "f267344f12f5bed026a58e41549b4a562c5480cd", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 84, "deletions": 10, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -68,6 +68,12 @@ gfc_push_suppress_errors (void)\n   ++suppress_errors;\n }\n \n+static void\n+gfc_error (const char *gmsgid, va_list ap)  ATTRIBUTE_GCC_GFC(1,0);\n+\n+static bool\n+gfc_warning (int opt, const char *gmsgid, va_list ap) ATTRIBUTE_GCC_GFC(2,0);\n+\n \n /* Leave one level of error suppressing.  */\n \n@@ -835,9 +841,6 @@ gfc_warning_1 (const char *gmsgid, ...)\n /* This is just a helper function to avoid duplicating the logic of\n    gfc_warning.  */\n \n-static bool\n-gfc_warning (int opt, const char *gmsgid, va_list ap) ATTRIBUTE_GCC_GFC(2,0);\n-\n static bool\n gfc_warning (int opt, const char *gmsgid, va_list ap)\n {\n@@ -935,7 +938,7 @@ gfc_notification_std (int std)\n    an error is generated.  */\n \n bool\n-gfc_notify_std (int std, const char *gmsgid, ...)\n+gfc_notify_std_1 (int std, const char *gmsgid, ...)\n {\n   va_list argp;\n   bool warning;\n@@ -1012,6 +1015,68 @@ gfc_notify_std (int std, const char *gmsgid, ...)\n }\n \n \n+bool\n+gfc_notify_std (int std, const char *gmsgid, ...)\n+{\n+  va_list argp;\n+  bool warning;\n+  const char *msg, *msg2;\n+  char *buffer;\n+\n+  warning = ((gfc_option.warn_std & std) != 0) && !inhibit_warnings;\n+  if ((gfc_option.allow_std & std) != 0 && !warning)\n+    return true;\n+\n+  if (suppress_errors)\n+    return warning ? true : false;\n+\n+  switch (std)\n+  {\n+    case GFC_STD_F2008_TS:\n+      msg = \"TS 29113/TS 18508:\";\n+      break;\n+    case GFC_STD_F2008_OBS:\n+      msg = _(\"Fortran 2008 obsolescent feature:\");\n+      break;\n+    case GFC_STD_F2008:\n+      msg = \"Fortran 2008:\";\n+      break;\n+    case GFC_STD_F2003:\n+      msg = \"Fortran 2003:\";\n+      break;\n+    case GFC_STD_GNU:\n+      msg = _(\"GNU Extension:\");\n+      break;\n+    case GFC_STD_LEGACY:\n+      msg = _(\"Legacy Extension:\");\n+      break;\n+    case GFC_STD_F95_OBS:\n+      msg = _(\"Obsolescent feature:\");\n+      break;\n+    case GFC_STD_F95_DEL:\n+      msg = _(\"Deleted feature:\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n+  }\n+\n+  msg2 = _(gmsgid);\n+  buffer = (char *) alloca (strlen (msg) + strlen (msg2) + 2);\n+  strcpy (buffer, msg);\n+  strcat (buffer, \" \");\n+  strcat (buffer, msg2);\n+\n+  va_start (argp, gmsgid);\n+  if (warning)\n+    gfc_warning (0, buffer, argp);\n+  else\n+    gfc_error (buffer, argp);\n+  va_end (argp);\n+\n+  return (warning && !warnings_are_errors) ? true : false;\n+}\n+\n+\n /* Immediate warning (i.e. do not buffer the warning).  */\n /* Use gfc_warning_now instead, unless two locations are used in the same\n    warning or for scanner.c, if the location is not properly set up.  */\n@@ -1349,11 +1414,11 @@ gfc_error_1 (const char *gmsgid, ...)\n    two locations; when being used in scanner.c, ensure that the location\n    is properly setup. Otherwise, use gfc_error_1.   */\n \n-void\n-gfc_error (const char *gmsgid, ...)\n+static void\n+gfc_error (const char *gmsgid, va_list ap)\n {\n   va_list argp;\n-  va_start (argp, gmsgid);\n+  va_copy (argp, ap);\n \n   if (warnings_not_errors)\n     {\n@@ -1380,8 +1445,8 @@ gfc_error (const char *gmsgid, ...)\n       pp->buffer = pp_error_buffer;\n       global_dc->fatal_errors = false;\n       /* To prevent -fmax-errors= triggering, we decrease it before\n-\t report_diagnostic increases it.  */\n-      --errorcount; \n+     report_diagnostic increases it.  */\n+      --errorcount;\n     }\n \n   diagnostic_set_info (&diagnostic, gmsgid, &argp, UNKNOWN_LOCATION, DK_ERROR);\n@@ -1392,11 +1457,20 @@ gfc_error (const char *gmsgid, ...)\n       pp->buffer = tmp_buffer;\n       global_dc->fatal_errors = fatal_errors;\n     }\n-  \n+\n   va_end (argp);\n }\n \n \n+void\n+gfc_error (const char *gmsgid, ...)\n+{\n+  va_list argp;\n+  va_start (argp, gmsgid);\n+  gfc_error (gmsgid, argp);\n+  va_end (argp);\n+}\n+\n \n /* Immediate error.  */\n /* Use gfc_error_now instead, unless two locations are used in the same"}, {"sha": "5c2a3065eb85fb4ea909798b61a0f6067c0ec3e9", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -145,7 +145,8 @@ gfc_get_constant_expr (bt type, int kind, locus *where)\n   gfc_expr *e;\n \n   if (!where)\n-    gfc_internal_error (\"gfc_get_constant_expr(): locus 'where' cannot be NULL\");\n+    gfc_internal_error (\"gfc_get_constant_expr(): locus %<where%> cannot be \"\n+\t\t\t\"NULL\");\n \n   e = gfc_get_expr ();\n \n@@ -3185,7 +3186,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n   if (rvalue->is_boz && lvalue->ts.type != BT_INTEGER\n       && lvalue->symtree->n.sym->attr.data\n       && !gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L used to \"\n-\t\t\t  \"initialize non-integer variable '%s'\", \n+\t\t\t  \"initialize non-integer variable %qs\", \n \t\t\t  &rvalue->where, lvalue->symtree->n.sym->name))\n     return false;\n   else if (rvalue->is_boz && !lvalue->symtree->n.sym->attr.data\n@@ -3210,15 +3211,15 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n \t  if (rc == ARITH_UNDERFLOW)\n \t    gfc_error (\"Arithmetic underflow of bit-wise transferred BOZ at %L\"\n \t\t       \". This check can be disabled with the option \"\n-\t\t       \"-fno-range-check\", &rvalue->where);\n+\t\t       \"%<-fno-range-check%>\", &rvalue->where);\n \t  else if (rc == ARITH_OVERFLOW)\n \t    gfc_error (\"Arithmetic overflow of bit-wise transferred BOZ at %L\"\n \t\t       \". This check can be disabled with the option \"\n-\t\t       \"-fno-range-check\", &rvalue->where);\n+\t\t       \"%<-fno-range-check%>\", &rvalue->where);\n \t  else if (rc == ARITH_NAN)\n \t    gfc_error (\"Arithmetic NaN of bit-wise transferred BOZ at %L\"\n \t\t       \". This check can be disabled with the option \"\n-\t\t       \"-fno-range-check\", &rvalue->where);\n+\t\t       \"%<-fno-range-check%>\", &rvalue->where);\n \t  return false;\n \t}\n     }\n@@ -3360,7 +3361,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t    }\n \n \t  if (!gfc_notify_std (GFC_STD_F2003, \"Bounds specification \"\n-\t\t\t       \"for '%s' in pointer assignment at %L\", \n+\t\t\t       \"for %qs in pointer assignment at %L\", \n \t\t\t       lvalue->symtree->n.sym->name, &lvalue->where))\n \t    return false;\n \n@@ -3486,7 +3487,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t      return false;\n \t    }\n \t  if (attr.proc == PROC_INTERNAL &&\n-\t      !gfc_notify_std(GFC_STD_F2008, \"Internal procedure '%s' \"\n+\t      !gfc_notify_std(GFC_STD_F2008, \"Internal procedure %qs \"\n \t\t\t      \"is invalid in procedure pointer assignment \"\n \t\t\t      \"at %L\", rvalue->symtree->name, &rvalue->where))\n \t    return false;"}, {"sha": "42ed8eb0fff5210e519534514e06e5fa18f92c21", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -2693,6 +2693,7 @@ bool gfc_error_check (void);\n bool gfc_error_flag_test (void);\n \n notification gfc_notification_std (int);\n+bool gfc_notify_std_1 (int, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n bool gfc_notify_std (int, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n \n /* A general purpose syntax error.  */"}, {"sha": "04bcf12864bb8cfe65bb1a6d941b2514e61f5ca3", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -316,7 +316,7 @@ gfc_match_end_interface (void)\n \t  if (current_interface.op == INTRINSIC_ASSIGN)\n \t    {\n \t      m = MATCH_ERROR;\n-\t      gfc_error (\"Expected 'END INTERFACE ASSIGNMENT (=)' at %C\");\n+\t      gfc_error (\"Expected %<END INTERFACE ASSIGNMENT (=)%> at %C\");\n \t    }\n \t  else\n \t    {\n@@ -346,7 +346,7 @@ gfc_match_end_interface (void)\n \t\tbreak;\n \n \t      m = MATCH_ERROR;\n-\t      gfc_error (\"Expecting 'END INTERFACE OPERATOR (%s)' at %C, \"\n+\t      gfc_error (\"Expecting %<END INTERFACE OPERATOR (%s)%> at %C, \"\n \t\t\t \"but got %s\", s1, s2);\n \t    }\n \n@@ -360,7 +360,7 @@ gfc_match_end_interface (void)\n       if (type != current_interface.type\n \t  || strcmp (current_interface.uop->name, name) != 0)\n \t{\n-\t  gfc_error (\"Expecting 'END INTERFACE OPERATOR (.%s.)' at %C\",\n+\t  gfc_error (\"Expecting %<END INTERFACE OPERATOR (.%s.)%> at %C\",\n \t\t     current_interface.uop->name);\n \t  m = MATCH_ERROR;\n \t}\n@@ -371,7 +371,7 @@ gfc_match_end_interface (void)\n       if (type != current_interface.type\n \t  || strcmp (current_interface.sym->name, name) != 0)\n \t{\n-\t  gfc_error (\"Expecting 'END INTERFACE %s' at %C\",\n+\t  gfc_error (\"Expecting %<END INTERFACE %s%> at %C\",\n \t\t     current_interface.sym->name);\n \t  m = MATCH_ERROR;\n \t}\n@@ -1226,7 +1226,7 @@ check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \n \t      case -2:\n \t\t/* FIXME: Implement a warning for this case.\n-\t\tgfc_warning (\"Possible shape mismatch in argument '%s'\",\n+\t\tgfc_warning (\"Possible shape mismatch in argument %qs\",\n \t\t\t    s1->name);*/\n \t\tbreak;\n \n@@ -1589,7 +1589,7 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n       /* F2003, C1207. F2008, C1207.  */\n       if (p->sym->attr.proc == PROC_INTERNAL\n \t  && !gfc_notify_std (GFC_STD_F2008, \"Internal procedure \"\n-\t\t\t      \"'%s' in %s at %L\", p->sym->name, \n+\t\t\t      \"%qs in %s at %L\", p->sym->name,\n \t\t\t      interface_name, &p->sym->declared_at))\n \treturn 1;\n     }"}, {"sha": "e920a422667c4607b6e9916bcd62b4154bcf7439", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -4387,7 +4387,7 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n   if ((isym->id == GFC_ISYM_REAL || isym->id == GFC_ISYM_DBLE\n        || isym->id == GFC_ISYM_CMPLX)\n       && gfc_init_expr_flag\n-      && !gfc_notify_std (GFC_STD_F2003, \"Function '%s' as initialization \"\n+      && !gfc_notify_std (GFC_STD_F2003, \"Function %qs as initialization \"\n \t\t\t  \"expression at %L\", name, &expr->where))\n     {\n       if (!error_flag)"}, {"sha": "ef0e59aba13f6ba9a07b6b2c69ad6c1970c0aa52", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -550,8 +550,8 @@ check_format (bool is_input)\n {\n   const char *posint_required\t  = _(\"Positive width required\");\n   const char *nonneg_required\t  = _(\"Nonnegative width required\");\n-  const char *unexpected_element  = _(\"Unexpected element '%c' in format string\"\n-\t\t\t\t      \" at %L\");\n+  const char *unexpected_element  = _(\"Unexpected element %<%c%> in format \"\n+\t\t\t\t      \"string at %L\");\n   const char *unexpected_end\t  = _(\"Unexpected end of format string\");\n   const char *zero_width\t  = _(\"Zero width in format descriptor\");\n \n@@ -602,7 +602,7 @@ check_format (bool is_input)\n \t  level++;\n \t  goto format_item;\n \t}\n-      error = _(\"Left parenthesis required after '*'\");\n+      error = _(\"Left parenthesis required after %<*%>\");\n       goto syntax;\n \n     case FMT_POSINT:\n@@ -823,7 +823,7 @@ check_format (bool is_input)\n \t      error = zero_width;\n \t      goto syntax;\n \t    }\n-\t  if (!gfc_notify_std (GFC_STD_F2008, \"'G0' in format at %L\", \n+\t  if (!gfc_notify_std (GFC_STD_F2008, \"%<G0%> in format at %L\", \n \t\t\t       &format_locus))\n \t    return false;\n \t  u = format_lex ();\n@@ -1408,14 +1408,14 @@ resolve_tag_format (const gfc_expr *e)\n \t    return false;\n \t  if (e->symtree->n.sym->attr.assign != 1)\n \t    {\n-\t      gfc_error (\"Variable '%s' at %L has not been assigned a \"\n+\t      gfc_error (\"Variable %qs at %L has not been assigned a \"\n \t\t\t \"format label\", e->symtree->n.sym->name, &e->where);\n \t      return false;\n \t    }\n \t}\n       else if (e->ts.type == BT_INTEGER)\n \t{\n-\t  gfc_error (\"Scalar '%s' in FORMAT tag at %L is not an ASSIGNED \"\n+\t  gfc_error (\"Scalar %qs in FORMAT tag at %L is not an ASSIGNED \"\n \t\t     \"variable\", gfc_basic_typename (e->ts.type), &e->where);\n \t  return false;\n \t}\n@@ -1729,7 +1729,7 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n \t  if (n == ERROR)\n \t    {\n \t      gfc_notify_std (GFC_STD_F2003, \"%s specifier in \"\n-\t\t\t      \"%s statement at %C has value '%s'\", specifier,\n+\t\t\t      \"%s statement at %C has value %qs\", specifier,\n \t\t\t      statement, allowed_f2003[i]);\n \t      return 0;\n \t    }\n@@ -1756,7 +1756,7 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n \t  if (n == ERROR)\n \t    {\n \t      gfc_notify_std (GFC_STD_GNU, \"%s specifier in \"\n-\t\t\t      \"%s statement at %C has value '%s'\", specifier,\n+\t\t\t      \"%s statement at %C has value %qs\", specifier,\n \t\t\t      statement, allowed_gnu[i]);\n \t      return 0;\n \t    }\n@@ -1768,15 +1768,15 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n   if (warn)\n     {\n       char *s = gfc_widechar_to_char (value, -1);\n-      gfc_warning (\"%s specifier in %s statement at %C has invalid value '%s'\",\n+      gfc_warning (\"%s specifier in %s statement at %C has invalid value %qs\",\n \t\t   specifier, statement, s);\n       free (s);\n       return 1;\n     }\n   else\n     {\n       char *s = gfc_widechar_to_char (value, -1);\n-      gfc_error (\"%s specifier in %s statement at %C has invalid value '%s'\",\n+      gfc_error (\"%s specifier in %s statement at %C has invalid value %qs\",\n \t\t specifier, statement, s);\n       free (s);\n       return 0;\n@@ -2085,7 +2085,7 @@ gfc_match_open (void)\n \t  char *s = gfc_widechar_to_char (open->status->value.character.string,\n \t\t\t\t\t  -1);\n \t  warn_or_error (\"The STATUS specified in OPEN statement at %C is \"\n-\t\t\t \"'%s' and no FILE specifier is present\", s);\n+\t\t\t \"%qs and no FILE specifier is present\", s);\n \t  free (s);\n \t}\n \n@@ -2618,7 +2618,7 @@ check_namelist (gfc_symbol *sym)\n   for (p = sym->namelist; p; p = p->next)\n     if (p->sym->attr.intent == INTENT_IN)\n       {\n-\tgfc_error (\"Symbol '%s' in namelist '%s' is INTENT(IN) at %C\",\n+\tgfc_error (\"Symbol %qs in namelist %qs is INTENT(IN) at %C\",\n \t\t   p->sym->name, sym->name);\n \treturn 1;\n       }\n@@ -2663,7 +2663,7 @@ match_dt_element (io_kind k, gfc_dt *dt)\n \n       if (sym == NULL || sym->attr.flavor != FL_NAMELIST)\n \t{\n-\t  gfc_error (\"Symbol '%s' at %C must be a NAMELIST group name\",\n+\t  gfc_error (\"Symbol %qs at %C must be a NAMELIST group name\",\n \t\t     sym != NULL ? sym->name : name);\n \t  return MATCH_ERROR;\n \t}\n@@ -2892,8 +2892,8 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n \n \t  if (!t)\n \t    {\n-\t      gfc_error (\"NAMELIST '%s' in READ statement at %L contains\"\n-\t\t\t \" the symbol '%s' which may not appear in a\"\n+\t      gfc_error (\"NAMELIST %qs in READ statement at %L contains\"\n+\t\t\t \" the symbol %qs which may not appear in a\"\n \t\t\t \" variable definition context\",\n \t\t\t dt->namelist->name, loc, n->sym->name);\n \t      return false;\n@@ -3533,11 +3533,11 @@ if (condition) \\\n \t\t     \"YES or NO.\", &expr->where);\n \n       io_constraint (dt->size && not_no && k == M_READ,\n-\t\t     \"SIZE tag at %L requires an ADVANCE = 'NO'\",\n+\t\t     \"SIZE tag at %L requires an ADVANCE = %<NO%>\",\n \t\t     &dt->size->where);\n \n       io_constraint (dt->eor && not_no && k == M_READ,\n-\t\t     \"EOR tag at %L requires an ADVANCE = 'NO'\",\n+\t\t     \"EOR tag at %L requires an ADVANCE = %<NO%>\",\n \t\t     &dt->eor_where);      \n     }\n "}, {"sha": "9e0851351c238f74f07e4ee20d0ef420a6b07bfd", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -162,12 +162,12 @@ gfc_match_parens (void)\n \n   if (count > 0)\n     {\n-      gfc_error (\"Missing ')' in statement at or before %L\", &where);\n+      gfc_error (\"Missing %<)%> in statement at or before %L\", &where);\n       return MATCH_ERROR;\n     }\n   if (count < 0)\n     {\n-      gfc_error (\"Missing '(' in statement at or before %L\", &where);\n+      gfc_error (\"Missing %<(%> in statement at or before %L\", &where);\n       return MATCH_ERROR;\n     }\n \n@@ -496,13 +496,13 @@ gfc_match_label (void)\n \n   if (gfc_get_symbol (name, NULL, &gfc_new_block))\n     {\n-      gfc_error (\"Label name '%s' at %C is ambiguous\", name);\n+      gfc_error (\"Label name %qs at %C is ambiguous\", name);\n       return MATCH_ERROR;\n     }\n \n   if (gfc_new_block->attr.flavor == FL_LABEL)\n     {\n-      gfc_error (\"Duplicate construct label '%s' at %C\", name);\n+      gfc_error (\"Duplicate construct label %qs at %C\", name);\n       return MATCH_ERROR;\n     }\n \n@@ -1554,7 +1554,7 @@ gfc_match_else (void)\n \n   if (strcmp (name, gfc_current_block ()->name) != 0)\n     {\n-      gfc_error (\"Label '%s' at %C doesn't match IF label '%s'\",\n+      gfc_error (\"Label %qs at %C doesn't match IF label %qs\",\n \t\t name, gfc_current_block ()->name);\n       return MATCH_ERROR;\n     }\n@@ -1589,7 +1589,7 @@ gfc_match_elseif (void)\n \n   if (strcmp (name, gfc_current_block ()->name) != 0)\n     {\n-      gfc_error (\"Label '%s' at %C doesn't match IF label '%s'\",\n+      gfc_error (\"Label %qs at %C doesn't match IF label %qs\",\n \t\t name, gfc_current_block ()->name);\n       goto cleanup;\n     }\n@@ -1746,7 +1746,7 @@ gfc_match_associate (void)\n       for (a = new_st.ext.block.assoc; a; a = a->next)\n \tif (!strcmp (a->name, newAssoc->name))\n \t  {\n-\t    gfc_error (\"Duplicate name '%s' in association at %C\",\n+\t    gfc_error (\"Duplicate name %qs in association at %C\",\n \t\t       newAssoc->name);\n \t    goto assocListError;\n \t  }\n@@ -1772,7 +1772,7 @@ gfc_match_associate (void)\n \tbreak;\n       if (gfc_match_char (',') != MATCH_YES)\n \t{\n-\t  gfc_error (\"Expected ')' or ',' at %C\");\n+\t  gfc_error (\"Expected %<)%> or %<,%> at %C\");\n \t  return MATCH_ERROR;\n \t}\n \n@@ -1859,7 +1859,7 @@ gfc_match_type_spec (gfc_typespec *ts)\n       /* Enforce F03:C401.  */\n       if (ts->u.derived->attr.abstract)\n \t{\n-\t  gfc_error (\"Derived type '%s' at %L may not be ABSTRACT\",\n+\t  gfc_error (\"Derived type %qs at %L may not be ABSTRACT\",\n \t\t     ts->u.derived->name, &old_locus);\n \t  return MATCH_ERROR;\n \t}\n@@ -2406,15 +2406,15 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n       stree = gfc_find_symtree_in_proc (name, gfc_current_ns);\n       if (!stree)\n \t{\n-\t  gfc_error (\"Name '%s' in %s statement at %C is unknown\",\n+\t  gfc_error (\"Name %qs in %s statement at %C is unknown\",\n \t\t     name, gfc_ascii_statement (st));\n \t  return MATCH_ERROR;\n \t}\n \n       sym = stree->n.sym;\n       if (sym->attr.flavor != FL_LABEL)\n \t{\n-\t  gfc_error (\"Name '%s' in %s statement at %C is not a construct name\",\n+\t  gfc_error (\"Name %qs in %s statement at %C is not a construct name\",\n \t\t     name, gfc_ascii_statement (st));\n \t  return MATCH_ERROR;\n \t}\n@@ -2449,7 +2449,7 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n \tgfc_error (\"%s statement at %C is not within a construct\",\n \t\t   gfc_ascii_statement (st));\n       else\n-\tgfc_error (\"%s statement at %C is not within construct '%s'\",\n+\tgfc_error (\"%s statement at %C is not within construct %qs\",\n \t\t   gfc_ascii_statement (st), sym->name);\n \n       return MATCH_ERROR;\n@@ -2475,7 +2475,7 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n       if (op == EXEC_CYCLE)\n \t{\n \t  gfc_error (\"CYCLE statement at %C is not applicable to non-loop\"\n-\t\t     \" construct '%s'\", sym->name);\n+\t\t     \" construct %qs\", sym->name);\n \t  return MATCH_ERROR;\n \t}\n       gcc_assert (op == EXEC_EXIT);\n@@ -2485,7 +2485,7 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n       break;\n \n     default:\n-      gfc_error (\"%s statement at %C is not applicable to construct '%s'\",\n+      gfc_error (\"%s statement at %C is not applicable to construct %qs\",\n \t\t gfc_ascii_statement (st), sym->name);\n       return MATCH_ERROR;\n     }\n@@ -4323,7 +4323,7 @@ gfc_match_common (void)\n \t  if (((sym->value != NULL && sym->value->expr_type != EXPR_NULL)\n \t       || sym->attr.data) && gfc_current_state () != COMP_BLOCK_DATA)\n \t    {\n-\t      if (!gfc_notify_std (GFC_STD_GNU, \"Initialized symbol '%s' at \"\n+\t      if (!gfc_notify_std (GFC_STD_GNU, \"Initialized symbol %qs at \"\n \t\t\t\t   \"%C can only be COMMON in BLOCK DATA\", \n \t\t\t\t   sym->name))\n \t\tgoto cleanup;\n@@ -4349,7 +4349,7 @@ gfc_match_common (void)\n \t    {\n \t      if (as->type != AS_EXPLICIT)\n \t\t{\n-\t\t  gfc_error (\"Array specification for symbol '%s' in COMMON \"\n+\t\t  gfc_error (\"Array specification for symbol %qs in COMMON \"\n \t\t\t     \"at %C must be explicit\", sym->name);\n \t\t  goto cleanup;\n \t\t}\n@@ -4359,7 +4359,7 @@ gfc_match_common (void)\n \n \t      if (sym->attr.pointer)\n \t\t{\n-\t\t  gfc_error (\"Symbol '%s' in COMMON at %C cannot be a \"\n+\t\t  gfc_error (\"Symbol %qs in COMMON at %C cannot be a \"\n \t\t\t     \"POINTER array\", sym->name);\n \t\t  goto cleanup;\n \t\t}\n@@ -4391,9 +4391,9 @@ gfc_match_common (void)\n \t\t      if (other->common_head\n \t\t\t  && other->common_head != sym->common_head)\n \t\t\t{\n-\t\t\t  gfc_error (\"Symbol '%s', in COMMON block '%s' at \"\n+\t\t\t  gfc_error (\"Symbol %qs, in COMMON block %qs at \"\n \t\t\t\t     \"%C is being indirectly equivalenced to \"\n-\t\t\t\t     \"another COMMON block '%s'\",\n+\t\t\t\t     \"another COMMON block %qs\",\n \t\t\t\t     sym->name, sym->common_head->name,\n \t\t\t\t     other->common_head->name);\n \t\t\t    goto cleanup;\n@@ -4519,15 +4519,15 @@ gfc_match_namelist (void)\n     {\n       if (group_name->ts.type != BT_UNKNOWN)\n \t{\n-\t  gfc_error (\"Namelist group name '%s' at %C already has a basic \"\n+\t  gfc_error (\"Namelist group name %qs at %C already has a basic \"\n \t\t     \"type of %s\", group_name->name,\n \t\t     gfc_typename (&group_name->ts));\n \t  return MATCH_ERROR;\n \t}\n \n       if (group_name->attr.flavor == FL_NAMELIST\n \t  && group_name->attr.use_assoc\n-\t  && !gfc_notify_std (GFC_STD_GNU, \"Namelist group name '%s' \"\n+\t  && !gfc_notify_std (GFC_STD_GNU, \"Namelist group name %qs \"\n \t\t\t      \"at %C already is USE associated and can\"\n \t\t\t      \"not be respecified.\", group_name->name))\n \treturn MATCH_ERROR;\n@@ -4553,7 +4553,7 @@ gfc_match_namelist (void)\n \t     these are the only errors for the next two lines.  */\n \t  if (sym->as && sym->as->type == AS_ASSUMED_SIZE)\n \t    {\n-\t      gfc_error (\"Assumed size array '%s' in namelist '%s' at \"\n+\t      gfc_error (\"Assumed size array %qs in namelist %qs at \"\n \t\t\t \"%C is not allowed\", sym->name, group_name->name);\n \t      gfc_error_check ();\n \t    }\n@@ -4991,7 +4991,7 @@ match_case_eos (void)\n \n   if (strcmp (name, gfc_current_block ()->name) != 0)\n     {\n-      gfc_error (\"Expected block name '%s' of SELECT construct at %C\",\n+      gfc_error (\"Expected block name %qs of SELECT construct at %C\",\n \t\t gfc_current_block ()->name);\n       return MATCH_ERROR;\n     }\n@@ -5669,7 +5669,7 @@ gfc_match_elsewhere (void)\n \n       if (strcmp (name, gfc_current_block ()->name) != 0)\n \t{\n-\t  gfc_error (\"Label '%s' at %C doesn't match WHERE label '%s'\",\n+\t  gfc_error (\"Label %qs at %C doesn't match WHERE label %qs\",\n \t\t     name, gfc_current_block ()->name);\n \t  goto cleanup;\n \t}"}, {"sha": "303dee17333391bb29abd6331f13a7c07553e891", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -69,15 +69,15 @@ gfc_match_defined_op_name (char *result, int error_flag)\n   for (i = 0; name[i]; i++)\n     if (!ISALPHA (name[i]))\n       {\n-\tgfc_error (\"Bad character '%c' in OPERATOR name at %C\", name[i]);\n+\tgfc_error (\"Bad character %<%c%> in OPERATOR name at %C\", name[i]);\n \treturn MATCH_ERROR;\n       }\n \n   strcpy (result, name);\n   return MATCH_YES;\n \n error:\n-  gfc_error (\"The name '%s' cannot be used as a defined operator at %C\",\n+  gfc_error (\"The name %qs cannot be used as a defined operator at %C\",\n \t     name);\n \n   gfc_current_locus = old_loc;"}, {"sha": "84c1163486e92df5553ae61509af3de9c3cea1ce", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -670,7 +670,7 @@ gfc_match_use (void)\n \t  if (strcmp (new_use->use_name, use_list->module_name) == 0\n \t      || strcmp (new_use->local_name, use_list->module_name) == 0)\n \t    {\n-\t      gfc_error (\"The name '%s' at %C has already been used as \"\n+\t      gfc_error (\"The name %qs at %C has already been used as \"\n \t\t\t \"an external module name.\", use_list->module_name);\n \t      goto cleanup;\n \t    }\n@@ -4855,7 +4855,7 @@ check_for_ambiguous (gfc_symbol *st_sym, pointer_info *info)\n \n   if (gfc_current_ns->proc_name && st_sym->name == gfc_current_ns->proc_name->name)\n     {\n-      gfc_error (\"'%s' of module '%s', imported at %C, is also the name of the \"\n+      gfc_error (\"%qs of module %qs, imported at %C, is also the name of the \"\n \t\t \"current program unit\", st_sym->name, module_name);\n       return true;\n     }\n@@ -5206,20 +5206,20 @@ read_module (void)\n \n       if (u->op == INTRINSIC_NONE)\n \t{\n-\t  gfc_error (\"Symbol '%s' referenced at %L not found in module '%s'\",\n+\t  gfc_error (\"Symbol %qs referenced at %L not found in module %qs\",\n \t\t     u->use_name, &u->where, module_name);\n \t  continue;\n \t}\n \n       if (u->op == INTRINSIC_USER)\n \t{\n-\t  gfc_error (\"User operator '%s' referenced at %L not found \"\n-\t\t     \"in module '%s'\", u->use_name, &u->where, module_name);\n+\t  gfc_error (\"User operator %qs referenced at %L not found \"\n+\t\t     \"in module %qs\", u->use_name, &u->where, module_name);\n \t  continue;\n \t}\n \n-      gfc_error (\"Intrinsic operator '%s' referenced at %L not found \"\n-\t\t \"in module '%s'\", gfc_op2string (u->op), &u->where,\n+      gfc_error (\"Intrinsic operator %qs referenced at %L not found \"\n+\t\t \"in module %qs\", gfc_op2string (u->op), &u->where,\n \t\t module_name);\n     }\n \n@@ -6050,7 +6050,7 @@ gfc_dump_module (const char *name, int dump_flag)\n   else\n     {\n       if (remove (filename_tmp))\n-\tgfc_fatal_error (\"Can't delete temporary module file '%s': %s\",\n+\tgfc_fatal_error (\"Can't delete temporary module file %qs: %s\",\n \t\t\t filename_tmp, xstrerror (errno));\n     }\n }\n@@ -6070,7 +6070,7 @@ create_intrinsic_function (const char *name, int id,\n     {\n       if (strcmp (modname, tmp_symtree->n.sym->module) == 0)\n         return;\n-      gfc_error (\"Symbol '%s' already declared\", name);\n+      gfc_error (\"Symbol %qs already declared\", name);\n     }\n \n   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n@@ -6248,7 +6248,7 @@ import_iso_c_binding_module (void)\n \n \t    if (not_in_std)\n \t      {\n-\t\tgfc_error (\"The symbol '%s', referenced at %L, is not \"\n+\t\tgfc_error (\"The symbol %qs, referenced at %L, is not \"\n \t\t\t   \"in the selected standard\", name, &u->where);\n \t\tcontinue;\n \t      }\n@@ -6376,7 +6376,7 @@ import_iso_c_binding_module (void)\n       if (u->found)\n \tcontinue;\n \n-      gfc_error (\"Symbol '%s' referenced at %L not found in intrinsic \"\n+      gfc_error (\"Symbol %qs referenced at %L not found in intrinsic \"\n \t\t \"module ISO_C_BINDING\", u->use_name, &u->where);\n      }\n }\n@@ -6397,7 +6397,7 @@ create_int_parameter (const char *name, int value, const char *modname,\n       if (strcmp (modname, tmp_symtree->n.sym->module) == 0)\n \treturn;\n       else\n-\tgfc_error (\"Symbol '%s' already declared\", name);\n+\tgfc_error (\"Symbol %qs already declared\", name);\n     }\n \n   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n@@ -6430,7 +6430,7 @@ create_int_parameter_array (const char *name, int size, gfc_expr *value,\n       if (strcmp (modname, tmp_symtree->n.sym->module) == 0)\n \treturn;\n       else\n-\tgfc_error (\"Symbol '%s' already declared\", name);\n+\tgfc_error (\"Symbol %qs already declared\", name);\n     }\n \n   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n@@ -6472,7 +6472,7 @@ create_derived_type (const char *name, const char *modname,\n       if (strcmp (modname, tmp_symtree->n.sym->module) == 0)\n \treturn;\n       else\n-\tgfc_error (\"Symbol '%s' already declared\", name);\n+\tgfc_error (\"Symbol %qs already declared\", name);\n     }\n \n   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n@@ -6577,7 +6577,7 @@ use_iso_fortran_env_module (void)\n     }\n   else\n     if (!mod_symtree->n.sym->attr.intrinsic)\n-      gfc_error (\"Use of intrinsic module '%s' at %C conflicts with \"\n+      gfc_error (\"Use of intrinsic module %qs at %C conflicts with \"\n \t\t \"non-intrinsic module name used previously\", mod);\n \n   /* Generate the symbols for the module integer named constants.  */\n@@ -6592,7 +6592,7 @@ use_iso_fortran_env_module (void)\n \t      found = true;\n \t      u->found = 1;\n \n-\t      if (!gfc_notify_std (symbol[i].standard, \"The symbol '%s', \"\n+\t      if (!gfc_notify_std (symbol[i].standard, \"The symbol %qs, \"\n \t\t\t\t   \"referenced at %L, is not in the selected \"\n \t\t\t\t   \"standard\", symbol[i].name, &u->where))\n \t        continue;\n@@ -6720,7 +6720,7 @@ use_iso_fortran_env_module (void)\n       if (u->found)\n \tcontinue;\n \n-      gfc_error (\"Symbol '%s' referenced at %L not found in intrinsic \"\n+      gfc_error (\"Symbol %qs referenced at %L not found in intrinsic \"\n \t\t     \"module ISO_FORTRAN_ENV\", u->use_name, &u->where);\n     }\n }\n@@ -6822,7 +6822,7 @@ gfc_use_module (gfc_use_list *module)\n \n   mod_symtree = gfc_find_symtree (gfc_current_ns->sym_root, module_name);\n   if (mod_symtree && mod_symtree->n.sym->attr.intrinsic)\n-    gfc_error (\"Use of non-intrinsic module '%s' at %C conflicts with \"\n+    gfc_error (\"Use of non-intrinsic module %qs at %C conflicts with \"\n \t       \"intrinsic module name used previously\", module_name);\n \n   iomode = IO_INPUT;"}, {"sha": "84b17a7295b3347ecf90a6d2ebf706f9147e1d47", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -2074,7 +2074,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t    || (!code && (!n->sym->attr.dummy || n->sym->ns != ns)))\n \t  {\n \t    if (!code && (!n->sym->attr.dummy || n->sym->ns != ns))\n-\t      gfc_error (\"Variable '%s' is not a dummy argument at %L\",\n+\t      gfc_error (\"Variable %qs is not a dummy argument at %L\",\n \t\t\t n->sym->name, where);\n \t    continue;\n \t  }\n@@ -2106,7 +2106,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t  continue;\n \t      }\n \t  }\n-\tgfc_error (\"Object '%s' is not a variable at %L\", n->sym->name,\n+\tgfc_error (\"Object %qs is not a variable at %L\", n->sym->name,\n \t\t   where);\n       }\n \n@@ -2121,7 +2121,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n       for (n = omp_clauses->lists[list]; n; n = n->next)\n \t{\n \t  if (n->sym->mark)\n-\t    gfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\t    gfc_error (\"Symbol %qs present on multiple clauses at %L\",\n \t\t       n->sym->name, where);\n \t  else\n \t    n->sym->mark = 1;\n@@ -2132,15 +2132,15 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n     for (n = omp_clauses->lists[list]; n; n = n->next)\n       if (n->sym->mark)\n \t{\n-\t  gfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\t  gfc_error (\"Symbol %qs present on multiple clauses at %L\",\n \t\t     n->sym->name, where);\n \t  n->sym->mark = 0;\n \t}\n \n   for (n = omp_clauses->lists[OMP_LIST_FIRSTPRIVATE]; n; n = n->next)\n     {\n       if (n->sym->mark)\n-\tgfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\tgfc_error (\"Symbol %qs present on multiple clauses at %L\",\n \t\t   n->sym->name, where);\n       else\n \tn->sym->mark = 1;\n@@ -2151,7 +2151,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n   for (n = omp_clauses->lists[OMP_LIST_LASTPRIVATE]; n; n = n->next)\n     {\n       if (n->sym->mark)\n-\tgfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\tgfc_error (\"Symbol %qs present on multiple clauses at %L\",\n \t\t   n->sym->name, where);\n       else\n \tn->sym->mark = 1;\n@@ -2163,7 +2163,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n   for (n = omp_clauses->lists[OMP_LIST_ALIGNED]; n; n = n->next)\n     {\n       if (n->sym->mark)\n-\tgfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\tgfc_error (\"Symbol %qs present on multiple clauses at %L\",\n \t\t   n->sym->name, where);\n       else\n \tn->sym->mark = 1;\n@@ -2177,7 +2177,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n   for (n = omp_clauses->lists[OMP_LIST_TO]; n; n = n->next)\n     {\n       if (n->expr == NULL && n->sym->mark)\n-\tgfc_error (\"Symbol '%s' present on both FROM and TO clauses at %L\",\n+\tgfc_error (\"Symbol %qs present on both FROM and TO clauses at %L\",\n \t\t   n->sym->name, where);\n       else\n \tn->sym->mark = 1;\n@@ -2199,32 +2199,32 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t    for (; n != NULL; n = n->next)\n \t      {\n \t\tif (!n->sym->attr.threadprivate)\n-\t\t  gfc_error (\"Non-THREADPRIVATE object '%s' in COPYIN clause\"\n+\t\t  gfc_error (\"Non-THREADPRIVATE object %qs in COPYIN clause\"\n \t\t\t     \" at %L\", n->sym->name, where);\n \t      }\n \t    break;\n \t  case OMP_LIST_COPYPRIVATE:\n \t    for (; n != NULL; n = n->next)\n \t      {\n \t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n-\t\t  gfc_error (\"Assumed size array '%s' in COPYPRIVATE clause \"\n+\t\t  gfc_error (\"Assumed size array %qs in COPYPRIVATE clause \"\n \t\t\t     \"at %L\", n->sym->name, where);\n \t\tif (n->sym->attr.pointer && n->sym->attr.intent == INTENT_IN)\n-\t\t  gfc_error (\"INTENT(IN) POINTER '%s' in COPYPRIVATE clause \"\n+\t\t  gfc_error (\"INTENT(IN) POINTER %qs in COPYPRIVATE clause \"\n \t\t\t     \"at %L\", n->sym->name, where);\n \t      }\n \t    break;\n \t  case OMP_LIST_SHARED:\n \t    for (; n != NULL; n = n->next)\n \t      {\n \t\tif (n->sym->attr.threadprivate)\n-\t\t  gfc_error (\"THREADPRIVATE object '%s' in SHARED clause at \"\n+\t\t  gfc_error (\"THREADPRIVATE object %qs in SHARED clause at \"\n \t\t\t     \"%L\", n->sym->name, where);\n \t\tif (n->sym->attr.cray_pointee)\n-\t\t  gfc_error (\"Cray pointee '%s' in SHARED clause at %L\",\n+\t\t  gfc_error (\"Cray pointee %qs in SHARED clause at %L\",\n \t\t\t    n->sym->name, where);\n \t\tif (n->sym->attr.associate_var)\n-\t\t  gfc_error (\"ASSOCIATE name '%s' in SHARED clause at %L\",\n+\t\t  gfc_error (\"ASSOCIATE name %qs in SHARED clause at %L\",\n \t\t\t     n->sym->name, where);\n \t      }\n \t    break;\n@@ -2239,7 +2239,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\t    != INTMOD_ISO_C_BINDING)\n \t\t\t|| (n->sym->ts.u.derived->intmod_sym_id\n \t\t\t    != ISOCBINDING_PTR)))\n-\t\t  gfc_error (\"'%s' in ALIGNED clause must be POINTER, \"\n+\t\t  gfc_error (\"%qs in ALIGNED clause must be POINTER, \"\n \t\t\t     \"ALLOCATABLE, Cray pointer or C_PTR at %L\",\n \t\t\t     n->sym->name, where);\n \t\telse if (n->expr)\n@@ -2251,7 +2251,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\t|| expr->rank != 0\n \t\t\t|| gfc_extract_int (expr, &alignment)\n \t\t\t|| alignment <= 0)\n-\t\t      gfc_error (\"'%s' in ALIGNED clause at %L requires a scalar \"\n+\t\t      gfc_error (\"%qs in ALIGNED clause at %L requires a scalar \"\n \t\t\t\t \"positive constant integer alignment \"\n \t\t\t\t \"expression\", n->sym->name, where);\n \t\t  }\n@@ -2269,7 +2269,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t      || n->expr->ref == NULL\n \t\t      || n->expr->ref->next\n \t\t      || n->expr->ref->type != REF_ARRAY)\n-\t\t    gfc_error (\"'%s' in %s clause at %L is not a proper \"\n+\t\t    gfc_error (\"%qs in %s clause at %L is not a proper \"\n \t\t\t       \"array section\", n->sym->name, name, where);\n \t\t  else if (n->expr->ref->u.ar.codimen)\n \t\t    gfc_error (\"Coarrays not supported in %s clause at %L\",\n@@ -2289,7 +2289,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\telse if (ar->dimen_type[i] != DIMEN_ELEMENT\n \t\t\t\t && ar->dimen_type[i] != DIMEN_RANGE)\n \t\t\t  {\n-\t\t\t    gfc_error (\"'%s' in %s clause at %L is not a \"\n+\t\t\t    gfc_error (\"%qs in %s clause at %L is not a \"\n \t\t\t\t       \"proper array section\",\n \t\t\t\t       n->sym->name, name, where);\n \t\t\t    break;\n@@ -2302,7 +2302,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\t\t && mpz_cmp (ar->start[i]->value.integer,\n \t\t\t\t\t     ar->end[i]->value.integer) > 0)\n \t\t\t  {\n-\t\t\t    gfc_error (\"'%s' in DEPEND clause at %L is a zero \"\n+\t\t\t    gfc_error (\"%qs in DEPEND clause at %L is a zero \"\n \t\t\t\t       \"size array section\", n->sym->name,\n \t\t\t\t       where);\n \t\t\t    break;\n@@ -2314,10 +2314,10 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t{\n \t\t  n->sym->attr.referenced = 1;\n \t\t  if (n->sym->attr.threadprivate)\n-\t\t    gfc_error (\"THREADPRIVATE object '%s' in %s clause at %L\",\n+\t\t    gfc_error (\"THREADPRIVATE object %qs in %s clause at %L\",\n \t\t\t       n->sym->name, name, where);\n \t\t  if (n->sym->attr.cray_pointee)\n-\t\t    gfc_error (\"Cray pointee '%s' in %s clause at %L\",\n+\t\t    gfc_error (\"Cray pointee %qs in %s clause at %L\",\n \t\t\t       n->sym->name, name, where);\n \t\t}\n \t    break;"}, {"sha": "ad3137bdeba6dc9cf976bc11f8ff7fd7fd8adfa8", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -2220,7 +2220,7 @@ unexpected_eof (void)\n {\n   gfc_state_data *p;\n \n-  gfc_error (\"Unexpected end of file in '%s'\", gfc_source_file);\n+  gfc_error (\"Unexpected end of file in %qs\", gfc_source_file);\n \n   /* Memory cleanup.  Move to \"second to last\".  */\n   for (p = gfc_state_stack; p && p->previous && p->previous->previous;\n@@ -2252,10 +2252,10 @@ parse_derived_contains (void)\n   /* Derived-types with SEQUENCE and/or BIND(C) must not have a CONTAINS\n      section.  */\n   if (gfc_current_block ()->attr.sequence)\n-    gfc_error (\"Derived-type '%s' with SEQUENCE must not have a CONTAINS\"\n+    gfc_error (\"Derived-type %qs with SEQUENCE must not have a CONTAINS\"\n \t       \" section at %C\", gfc_current_block ()->name);\n   if (gfc_current_block ()->attr.is_bind_c)\n-    gfc_error (\"Derived-type '%s' with BIND(C) must not have a CONTAINS\"\n+    gfc_error (\"Derived-type %qs with BIND(C) must not have a CONTAINS\"\n \t       \" section at %C\", gfc_current_block ()->name);\n \n   accept_statement (ST_CONTAINS);\n@@ -2739,7 +2739,7 @@ parse_interface (void)\n     {\n       gfc_add_abstract (&gfc_new_block->attr, &gfc_current_locus);\n       if (gfc_is_intrinsic_typename (gfc_new_block->name))\n-\tgfc_error (\"Name '%s' of ABSTRACT INTERFACE at %C \"\n+\tgfc_error (\"Name %qs of ABSTRACT INTERFACE at %C \"\n \t\t   \"cannot be the same as an intrinsic type\",\n \t\t   gfc_new_block->name);\n     }\n@@ -2790,7 +2790,7 @@ parse_interface (void)\n \t&& current_interface.ns->proc_name\n \t&& strcmp (current_interface.ns->proc_name->name,\n \t\t   prog_unit->name) == 0)\n-    gfc_error (\"INTERFACE procedure '%s' at %L has the same name as the \"\n+    gfc_error (\"INTERFACE procedure %qs at %L has the same name as the \"\n \t       \"enclosing procedure\", prog_unit->name,\n \t       &current_interface.ns->proc_name->declared_at);\n \n@@ -3088,11 +3088,11 @@ parse_spec (gfc_statement st)\n     {\n       ts = &gfc_current_block ()->result->ts;\n       if (ts->type != BT_DERIVED)\n-\tgfc_error (\"Bad kind expression for function '%s' at %L\",\n+\tgfc_error (\"Bad kind expression for function %qs at %L\",\n \t\t   gfc_current_block ()->name,\n \t\t   &gfc_current_block ()->declared_at);\n       else\n-\tgfc_error (\"The type for function '%s' at %L is not accessible\",\n+\tgfc_error (\"The type for function %qs at %L is not accessible\",\n \t\t   gfc_current_block ()->name,\n \t\t   &gfc_current_block ()->declared_at);\n \n@@ -4467,7 +4467,7 @@ parse_contained (int module)\n \t  if (!module)\n \t    {\n \t      if (gfc_get_symbol (gfc_new_block->name, parent_ns, &sym))\n-\t\tgfc_error (\"Contained procedure '%s' at %C is already \"\n+\t\tgfc_error (\"Contained procedure %qs at %C is already \"\n \t\t\t   \"ambiguous\", gfc_new_block->name);\n \t      else\n \t\t{"}, {"sha": "18791ceaf037939c71cf2bd74f6db8c9b1a7732a", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -631,7 +631,7 @@ match_real_constant (gfc_expr **result, int signflag)\n     case 'd':\n       if (kind != -2)\n \t{\n-\t  gfc_error (\"Real number at %C has a 'd' exponent and an explicit \"\n+\t  gfc_error (\"Real number at %C has a %<d%> exponent and an explicit \"\n \t\t     \"kind\");\n \t  goto cleanup;\n \t}\n@@ -661,7 +661,7 @@ match_real_constant (gfc_expr **result, int signflag)\n     case 'q':\n       if (kind != -2)\n \t{\n-\t  gfc_error (\"Real number at %C has a 'q' exponent and an explicit \"\n+\t  gfc_error (\"Real number at %C has a %<q%> exponent and an explicit \"\n \t\t     \"kind\");\n \t  goto cleanup;\n \t}\n@@ -675,7 +675,7 @@ match_real_constant (gfc_expr **result, int signflag)\n \t  kind = 10;\n           if (gfc_validate_kind (BT_REAL, kind, true) < 0)\n \t    {\n-\t      gfc_error (\"Invalid exponent-letter 'q' in \"\n+\t      gfc_error (\"Invalid exponent-letter %<q%> in \"\n \t\t\t \"real-literal-constant at %C\");\n \t      goto cleanup;\n \t    }\n@@ -1083,7 +1083,7 @@ match_string_constant (gfc_expr **result)\n       if (!gfc_check_character_range (c, kind))\n \t{\n \t  gfc_free_expr (e);\n-\t  gfc_error (\"Character '%s' in string at %C is not representable \"\n+\t  gfc_error (\"Character %qs in string at %C is not representable \"\n \t\t     \"in character kind %d\", gfc_print_wide_char (c), kind);\n \t  return MATCH_ERROR;\n \t}\n@@ -1580,7 +1580,7 @@ match_keyword_arg (gfc_actual_arglist *actual, gfc_actual_arglist *base)\n       for (a = base; a; a = a->next)\n \tif (a->name != NULL && strcmp (a->name, name) == 0)\n \t  {\n-\t    gfc_error (\"Keyword '%s' at %C has already appeared in the \"\n+\t    gfc_error (\"Keyword %qs at %C has already appeared in the \"\n \t\t       \"current argument list\", name);\n \t    return MATCH_ERROR;\n \t  }\n@@ -1847,7 +1847,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t  || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n \t      && !CLASS_DATA (sym)->attr.codimension))\n \t{\n-\t  gfc_error (\"Coarray designator at %C but '%s' is not a coarray\",\n+\t  gfc_error (\"Coarray designator at %C but %qs is not a coarray\",\n \t\t     sym->name);\n \t  return MATCH_ERROR;\n \t}\n@@ -1914,13 +1914,13 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \n   if (sym->ts.type == BT_UNKNOWN && gfc_match_char ('%') == MATCH_YES)\n     {\n-      gfc_error (\"Symbol '%s' at %C has no IMPLICIT type\", sym->name);\n+      gfc_error (\"Symbol %qs at %C has no IMPLICIT type\", sym->name);\n       return MATCH_ERROR;\n     }\n   else if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)\n \t   && gfc_match_char ('%') == MATCH_YES)\n     {\n-      gfc_error (\"Unexpected '%%' for nonderived-type variable '%s' at %C\",\n+      gfc_error (\"Unexpected %<%%%> for nonderived-type variable %qs at %C\",\n \t\t sym->name);\n       return MATCH_ERROR;\n     }\n@@ -2020,7 +2020,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t  if (m == MATCH_NO && !gfc_matching_ptr_assignment\n \t      && !gfc_matching_procptr_assignment && !matching_actual_arglist)\n \t    {\n-\t      gfc_error (\"Procedure pointer component '%s' requires an \"\n+\t      gfc_error (\"Procedure pointer component %qs requires an \"\n \t\t\t \"argument list at %C\", component->name);\n \t      return MATCH_ERROR;\n \t    }\n@@ -2369,7 +2369,7 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \t    }\n \t  else if (!comp->attr.deferred_parameter)\n \t    {\n-\t      gfc_error (\"No initializer for component '%s' given in the\"\n+\t      gfc_error (\"No initializer for component %qs given in the\"\n \t\t\t \" structure constructor at %C!\", comp->name);\n \t      return false;\n \t    }\n@@ -2417,7 +2417,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n \n   if (!parent && sym->attr.abstract)\n     {\n-      gfc_error (\"Can't construct ABSTRACT type '%s' at %L\",\n+      gfc_error (\"Can't construct ABSTRACT type %qs at %L\",\n \t\t sym->name, &expr->where);\n       goto cleanup;\n     }\n@@ -2506,7 +2506,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n       if (this_comp->attr.pointer && comp_tail->val\n \t  && gfc_is_coindexed (comp_tail->val))\n      \t{\n-       \t  gfc_error (\"Coindexed expression to pointer component '%s' in \"\n+\t  gfc_error (\"Coindexed expression to pointer component %qs in \"\n \t\t     \"structure constructor at %L!\", comp_tail->name,\n \t\t     &comp_tail->where);\n \t  goto cleanup;\n@@ -2560,7 +2560,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n     {\n       for (comp_iter = comp_head; comp_iter; comp_iter = comp_iter->next)\n \t{\n-\t  gfc_error (\"component '%s' at %L has already been set by a \"\n+\t  gfc_error (\"component %qs at %L has already been set by a \"\n \t\t     \"parent derived type constructor\", comp_iter->name,\n \t\t     &comp_iter->where);\n \t}\n@@ -2743,7 +2743,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  && gfc_current_ns->proc_name == sym\n \t  && !sym->attr.dimension)\n \t{\n-\t  gfc_error (\"'%s' at %C is the name of a recursive function \"\n+\t  gfc_error (\"%qs at %C is the name of a recursive function \"\n \t\t     \"and so refers to the result variable. Use an \"\n \t\t     \"explicit RESULT variable for direct recursion \"\n \t\t     \"(12.5.2.1)\", sym->name);\n@@ -2866,7 +2866,7 @@ gfc_match_rvalue (gfc_expr **result)\n \n       if (sym->attr.subroutine)\n \t{\n-\t  gfc_error (\"Unexpected use of subroutine name '%s' at %C\",\n+\t  gfc_error (\"Unexpected use of subroutine name %qs at %C\",\n \t\t     sym->name);\n \t  m = MATCH_ERROR;\n \t  break;\n@@ -2897,10 +2897,10 @@ gfc_match_rvalue (gfc_expr **result)\n       if (m == MATCH_NO)\n \t{\n \t  if (sym->attr.proc == PROC_ST_FUNCTION)\n-\t    gfc_error (\"Statement function '%s' requires argument list at %C\",\n+\t    gfc_error (\"Statement function %qs requires argument list at %C\",\n \t\t       sym->name);\n \t  else\n-\t    gfc_error (\"Function '%s' requires an argument list at %C\",\n+\t    gfc_error (\"Function %qs requires an argument list at %C\",\n \t\t       sym->name);\n \n \t  m = MATCH_ERROR;\n@@ -2950,7 +2950,7 @@ gfc_match_rvalue (gfc_expr **result)\n           /* make sure we were given a param */\n           if (actual_arglist == NULL)\n             {\n-              gfc_error (\"Missing argument to '%s' at %C\", sym->name);\n+              gfc_error (\"Missing argument to %qs at %C\", sym->name);\n               m = MATCH_ERROR;\n               break;\n             }\n@@ -3106,7 +3106,7 @@ gfc_match_rvalue (gfc_expr **result)\n \n       m = gfc_match_actual_arglist (0, &e->value.function.actual);\n       if (m == MATCH_NO)\n-\tgfc_error (\"Missing argument list in function '%s' at %C\", sym->name);\n+\tgfc_error (\"Missing argument list in function %qs at %C\", sym->name);\n \n       if (m != MATCH_YES)\n \t{\n@@ -3273,7 +3273,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n       /* Fall through to error */\n \n     default:\n-      gfc_error (\"'%s' at %C is not a variable\", sym->name);\n+      gfc_error (\"%qs at %C is not a variable\", sym->name);\n       return MATCH_ERROR;\n     }\n "}, {"sha": "d47bb7be35fad2b72854294ebda90834a0bb61f3", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 186, "deletions": 186, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -122,10 +122,10 @@ resolve_typespec_used (gfc_typespec* ts, locus* where, const char* name)\n       if (where)\n \t{\n \t  if (name)\n-\t    gfc_error (\"'%s' at %L is of the ABSTRACT type '%s'\",\n+\t    gfc_error (\"%qs at %L is of the ABSTRACT type %qs\",\n \t\t       name, where, ts->u.derived->name);\n \t  else\n-\t    gfc_error (\"ABSTRACT type '%s' used at %L\",\n+\t    gfc_error (\"ABSTRACT type %qs used at %L\",\n \t\t       ts->u.derived->name, where);\n \t}\n \n@@ -142,7 +142,7 @@ check_proc_interface (gfc_symbol *ifc, locus *where)\n   /* Several checks for F08:C1216.  */\n   if (ifc->attr.procedure)\n     {\n-      gfc_error (\"Interface '%s' at %L is declared \"\n+      gfc_error (\"Interface %qs at %L is declared \"\n \t\t \"in a later PROCEDURE statement\", ifc->name, where);\n       return false;\n     }\n@@ -155,14 +155,14 @@ check_proc_interface (gfc_symbol *ifc, locus *where)\n \tgen = gen->next;\n       if (!gen)\n \t{\n-\t  gfc_error (\"Interface '%s' at %L may not be generic\",\n+\t  gfc_error (\"Interface %qs at %L may not be generic\",\n \t\t     ifc->name, where);\n \t  return false;\n \t}\n     }\n   if (ifc->attr.proc == PROC_ST_FUNCTION)\n     {\n-      gfc_error (\"Interface '%s' at %L may not be a statement function\",\n+      gfc_error (\"Interface %qs at %L may not be a statement function\",\n \t\t ifc->name, where);\n       return false;\n     }\n@@ -171,13 +171,13 @@ check_proc_interface (gfc_symbol *ifc, locus *where)\n     ifc->attr.intrinsic = 1;\n   if (ifc->attr.intrinsic && !gfc_intrinsic_actual_ok (ifc->name, 0))\n     {\n-      gfc_error (\"Intrinsic procedure '%s' not allowed in \"\n+      gfc_error (\"Intrinsic procedure %qs not allowed in \"\n \t\t \"PROCEDURE statement at %L\", ifc->name, where);\n       return false;\n     }\n   if (!ifc->attr.if_source && !ifc->attr.intrinsic && ifc->name[0] != '\\0')\n     {\n-      gfc_error (\"Interface '%s' at %L must be explicit\", ifc->name, where);\n+      gfc_error (\"Interface %qs at %L must be explicit\", ifc->name, where);\n       return false;\n     }\n   return true;\n@@ -199,7 +199,7 @@ resolve_procedure_interface (gfc_symbol *sym)\n \n   if (ifc == sym)\n     {\n-      gfc_error (\"PROCEDURE '%s' at %L may not be used as its own interface\",\n+      gfc_error (\"PROCEDURE %qs at %L may not be used as its own interface\",\n \t\t sym->name, &sym->declared_at);\n       return false;\n     }\n@@ -294,11 +294,11 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t  /* Alternate return placeholder.  */\n \t  if (gfc_elemental (proc))\n \t    gfc_error (\"Alternate return specifier in elemental subroutine \"\n-\t\t       \"'%s' at %L is not allowed\", proc->name,\n+\t\t       \"%qs at %L is not allowed\", proc->name,\n \t\t       &proc->declared_at);\n \t  if (proc->attr.function)\n \t    gfc_error (\"Alternate return specifier in function \"\n-\t\t       \"'%s' at %L is not allowed\", proc->name,\n+\t\t       \"%qs at %L is not allowed\", proc->name,\n \t\t       &proc->declared_at);\n \t  continue;\n \t}\n@@ -309,7 +309,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n       if (strcmp (proc->name, sym->name) == 0)\n         {\n           gfc_error (\"Self-referential argument \"\n-                     \"'%s' at %L is not allowed\", sym->name,\n+                     \"%qs at %L is not allowed\", sym->name,\n                      &proc->declared_at);\n           return;\n         }\n@@ -380,7 +380,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t      /* F08:C1279.  */\n \t      if (!gfc_pure (sym))\n \t\t{\n-\t\t  gfc_error (\"Dummy procedure '%s' of PURE procedure at %L must \"\n+\t\t  gfc_error (\"Dummy procedure %qs of PURE procedure at %L must \"\n \t\t\t    \"also be PURE\", sym->name, &sym->declared_at);\n \t\t  continue;\n \t\t}\n@@ -390,25 +390,25 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t      if (proc->attr.function && sym->attr.intent != INTENT_IN)\n \t\t{\n \t\t  if (sym->attr.value)\n-\t\t    gfc_notify_std (GFC_STD_F2008, \"Argument '%s'\"\n-\t\t\t\t    \" of pure function '%s' at %L with VALUE \"\n+\t\t    gfc_notify_std (GFC_STD_F2008, \"Argument %qs\"\n+\t\t\t\t    \" of pure function %qs at %L with VALUE \"\n \t\t\t\t    \"attribute but without INTENT(IN)\",\n \t\t\t\t    sym->name, proc->name, &sym->declared_at);\n \t\t  else\n-\t\t    gfc_error (\"Argument '%s' of pure function '%s' at %L must \"\n+\t\t    gfc_error (\"Argument %qs of pure function %qs at %L must \"\n \t\t\t       \"be INTENT(IN) or VALUE\", sym->name, proc->name,\n \t\t\t       &sym->declared_at);\n \t\t}\n \n \t      if (proc->attr.subroutine && sym->attr.intent == INTENT_UNKNOWN)\n \t\t{\n \t\t  if (sym->attr.value)\n-\t\t    gfc_notify_std (GFC_STD_F2008, \"Argument '%s'\"\n-\t\t\t\t    \" of pure subroutine '%s' at %L with VALUE \"\n+\t\t    gfc_notify_std (GFC_STD_F2008, \"Argument %qs\"\n+\t\t\t\t    \" of pure subroutine %qs at %L with VALUE \"\n \t\t\t\t    \"attribute but without INTENT\", sym->name,\n \t\t\t\t    proc->name, &sym->declared_at);\n \t\t  else\n-\t\t    gfc_error (\"Argument '%s' of pure subroutine '%s' at %L \"\n+\t\t    gfc_error (\"Argument %qs of pure subroutine %qs at %L \"\n \t\t\t       \"must have its INTENT specified or have the \"\n \t\t\t       \"VALUE attribute\", sym->name, proc->name,\n \t\t\t       &sym->declared_at);\n@@ -442,15 +442,15 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n \t\t  && CLASS_DATA (sym)->attr.codimension))\n \t    {\n-\t      gfc_error (\"Coarray dummy argument '%s' at %L to elemental \"\n+\t      gfc_error (\"Coarray dummy argument %qs at %L to elemental \"\n \t\t\t \"procedure\", sym->name, &sym->declared_at);\n \t      continue;\n \t    }\n \n \t  if (sym->as || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n \t\t\t  && CLASS_DATA (sym)->as))\n \t    {\n-\t      gfc_error (\"Argument '%s' of elemental procedure at %L must \"\n+\t      gfc_error (\"Argument %qs of elemental procedure at %L must \"\n \t\t\t \"be scalar\", sym->name, &sym->declared_at);\n \t      continue;\n \t    }\n@@ -459,7 +459,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n \t\t  && CLASS_DATA (sym)->attr.allocatable))\n \t    {\n-\t      gfc_error (\"Argument '%s' of elemental procedure at %L cannot \"\n+\t      gfc_error (\"Argument %qs of elemental procedure at %L cannot \"\n \t\t\t \"have the ALLOCATABLE attribute\", sym->name,\n \t\t\t &sym->declared_at);\n \t      continue;\n@@ -913,11 +913,11 @@ resolve_common_vars (gfc_symbol *sym, bool named_common)\n       if (csym->value || csym->attr.data)\n \t{\n \t  if (!csym->ns->is_block_data)\n-\t    gfc_notify_std (GFC_STD_GNU, \"Variable '%s' at %L is in COMMON \"\n+\t    gfc_notify_std (GFC_STD_GNU, \"Variable %qs at %L is in COMMON \"\n \t\t\t    \"but only in BLOCK DATA initialization is \"\n \t\t\t    \"allowed\", csym->name, &csym->declared_at);\n \t  else if (!named_common)\n-\t    gfc_notify_std (GFC_STD_GNU, \"Initialized variable '%s' at %L is \"\n+\t    gfc_notify_std (GFC_STD_GNU, \"Initialized variable %qs at %L is \"\n \t\t\t    \"in a blank COMMON but initialization is only \"\n \t\t\t    \"allowed in named common blocks\", csym->name,\n \t\t\t    &csym->declared_at);\n@@ -1061,12 +1061,12 @@ resolve_common_blocks (gfc_symtree *common_root)\n \t       sym->name, &common_root->n.common->where);\n   else if (sym->attr.result\n \t   || gfc_is_function_return_value (sym, gfc_current_ns))\n-    gfc_notify_std (GFC_STD_F2003, \"COMMON block '%s' at %L \"\n+    gfc_notify_std (GFC_STD_F2003, \"COMMON block %qs at %L \"\n \t\t    \"that is also a function result\", sym->name,\n \t\t    &common_root->n.common->where);\n   else if (sym->attr.flavor == FL_PROCEDURE && sym->attr.proc != PROC_INTERNAL\n \t   && sym->attr.proc != PROC_ST_FUNCTION)\n-    gfc_notify_std (GFC_STD_F2003, \"COMMON block '%s' at %L \"\n+    gfc_notify_std (GFC_STD_F2003, \"COMMON block %qs at %L \"\n \t\t    \"that is also a global procedure\", sym->name,\n \t\t    &common_root->n.common->where);\n }\n@@ -1683,10 +1683,10 @@ gfc_resolve_intrinsic (gfc_symbol *sym, locus *loc)\n   /* Check it is actually available in the standard settings.  */\n   if (!gfc_check_intrinsic_standard (isym, &symstd, false, sym->declared_at))\n     {\n-      gfc_error (\"The intrinsic %qs declared INTRINSIC at %L is not\"\n-\t\t \" available in the current standard settings but %s.  Use\"\n-\t\t \" an appropriate -std=* option or enable -fall-intrinsics\"\n-\t\t \" in order to use it.\",\n+      gfc_error (\"The intrinsic %qs declared INTRINSIC at %L is not \"\n+\t\t \"available in the current standard settings but %s. Use \"\n+\t\t \"an appropriate %<-std=*%> option or enable \"\n+\t\t \"%<-fall-intrinsics%> in order to use it.\",\n \t\t sym->name, &sym->declared_at, symstd);\n       return false;\n     }\n@@ -1815,7 +1815,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t  if (sym->attr.contained && !sym->attr.use_assoc\n \t      && sym->ns->proc_name->attr.flavor != FL_MODULE)\n \t    {\n-\t      if (!gfc_notify_std (GFC_STD_F2008, \"Internal procedure '%s' is\"\n+\t      if (!gfc_notify_std (GFC_STD_F2008, \"Internal procedure %qs is\"\n \t\t\t\t   \" used as actual argument at %L\",\n \t\t\t\t   sym->name, &e->where))\n \t\tgoto cleanup;\n@@ -4966,12 +4966,12 @@ resolve_variable (gfc_expr *e)\n \t  if (!seen)\n \t    {\n \t      if (specification_expr)\n-\t\tgfc_error (\"Variable '%s', used in a specification expression\"\n+\t\tgfc_error (\"Variable %qs, used in a specification expression\"\n \t\t\t   \", is referenced at %L before the ENTRY statement \"\n \t\t\t   \"in which it is a parameter\",\n \t\t\t   sym->name, &cs_base->current->loc);\n \t      else\n-\t\tgfc_error (\"Variable '%s' is used at %L before the ENTRY \"\n+\t\tgfc_error (\"Variable %qs is used at %L before the ENTRY \"\n \t\t\t   \"statement in which it is a parameter\",\n \t\t\t   sym->name, &cs_base->current->loc);\n \t      t = false;\n@@ -5393,7 +5393,7 @@ update_ppc_arglist (gfc_expr* e)\n   if (po->ts.type == BT_DERIVED && po->ts.u.derived->attr.abstract)\n     {\n       gfc_error (\"Base object for procedure-pointer component call at %L is of\"\n-\t\t \" ABSTRACT type '%s'\", &e->where, po->ts.u.derived->name);\n+\t\t \" ABSTRACT type %qs\", &e->where, po->ts.u.derived->name);\n       return false;\n     }\n \n@@ -5428,7 +5428,7 @@ check_typebound_baseobject (gfc_expr* e)\n   if (base->ts.type == BT_DERIVED && base->ts.u.derived->attr.abstract)\n     {\n       gfc_error (\"Base object for type-bound procedure call at %L is of\"\n-\t\t \" ABSTRACT type '%s'\", &e->where, base->ts.u.derived->name);\n+\t\t \" ABSTRACT type %qs\", &e->where, base->ts.u.derived->name);\n       goto cleanup;\n     }\n \n@@ -5625,7 +5625,7 @@ resolve_typebound_generic_call (gfc_expr* e, const char **name)\n \n   /* Nothing matching found!  */\n   gfc_error (\"Found no matching specific binding for the call to the GENERIC\"\n-\t     \" '%s' at %L\", genname, &e->where);\n+\t     \" %qs at %L\", genname, &e->where);\n   return false;\n \n success:\n@@ -5651,7 +5651,7 @@ resolve_typebound_call (gfc_code* c, const char **name)\n   /* Check that's really a SUBROUTINE.  */\n   if (!c->expr1->value.compcall.tbp->subroutine)\n     {\n-      gfc_error (\"'%s' at %L should be a SUBROUTINE\",\n+      gfc_error (\"%qs at %L should be a SUBROUTINE\",\n \t\t c->expr1->value.compcall.name, &c->loc);\n       return false;\n     }\n@@ -5698,7 +5698,7 @@ resolve_compcall (gfc_expr* e, const char **name)\n   /* Check that's really a FUNCTION.  */\n   if (!e->value.compcall.tbp->function)\n     {\n-      gfc_error (\"'%s' at %L should be a FUNCTION\",\n+      gfc_error (\"%qs at %L should be a FUNCTION\",\n \t\t e->value.compcall.name, &e->where);\n       return false;\n     }\n@@ -6433,7 +6433,7 @@ resolve_forall_iterators (gfc_forall_iterator *it)\n \tif (find_forall_index (iter2->start, iter->var->symtree->n.sym, 0)\n \t    || find_forall_index (iter2->end, iter->var->symtree->n.sym, 0)\n \t    || find_forall_index (iter2->stride, iter->var->symtree->n.sym, 0))\n-\t  gfc_error (\"FORALL index '%s' may not appear in triplet \"\n+\t  gfc_error (\"FORALL index %qs may not appear in triplet \"\n \t\t     \"specification at %L\", iter->var->symtree->name,\n \t\t     &iter2->start->where);\n       }\n@@ -7049,7 +7049,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t      || (ar->end[i] != NULL\n \t\t  && gfc_find_sym_in_expr (sym, ar->end[i])))\n \t    {\n-\t      gfc_error (\"'%s' must not appear in the array specification at \"\n+\t      gfc_error (\"%qs must not appear in the array specification at \"\n \t\t\t \"%L in the same ALLOCATE statement where it is \"\n \t\t\t \"itself allocated\", sym->name, &ar->where);\n \t      goto failure;\n@@ -7883,7 +7883,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n   /* Finally resolve if this is an array or not.  */\n   if (sym->attr.dimension && target->rank == 0)\n     {\n-      gfc_error (\"Associate-name '%s' at %L is used as array\",\n+      gfc_error (\"Associate-name %qs at %L is used as array\",\n \t\t sym->name, &sym->declared_at);\n       sym->attr.dimension = 0;\n       return;\n@@ -7992,7 +7992,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t  && !selector_type->attr.unlimited_polymorphic\n \t  && !gfc_type_is_extensible (c->ts.u.derived))\n \t{\n-\t  gfc_error (\"Derived type '%s' at %L must be extensible\",\n+\t  gfc_error (\"Derived type %qs at %L must be extensible\",\n \t\t     c->ts.u.derived->name, &c->where);\n \t  error++;\n \t  continue;\n@@ -8004,10 +8004,10 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t      || !gfc_type_is_extension_of (selector_type, c->ts.u.derived)))\n \t{\n \t  if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n-\t    gfc_error (\"Derived type '%s' at %L must be an extension of '%s'\",\n+\t    gfc_error (\"Derived type %qs at %L must be an extension of %qs\",\n \t\t       c->ts.u.derived->name, &c->where, selector_type->name);\n \t  else\n-\t    gfc_error (\"Unexpected intrinsic type '%s' at %L\",\n+\t    gfc_error (\"Unexpected intrinsic type %qs at %L\",\n \t\t       gfc_basic_typename (c->ts.type), &c->where);\n \t  error++;\n \t  continue;\n@@ -8656,7 +8656,7 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n   /* The label is not in an enclosing block, so illegal.  This was\n      allowed in Fortran 66, so we allow it as extension.  No\n      further checks are necessary in this case.  */\n-  gfc_notify_std (GFC_STD_LEGACY, \"Label at %L is not in the same block \"\n+  gfc_notify_std_1 (GFC_STD_LEGACY, \"Label at %L is not in the same block \"\n \t\t  \"as the GOTO statement at %L\", &label->where,\n \t\t  &code->loc);\n   return;\n@@ -9196,15 +9196,15 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \t  if (rc == ARITH_UNDERFLOW)\n \t    gfc_error (\"Arithmetic underflow of bit-wise transferred BOZ at %L\"\n \t\t       \". This check can be disabled with the option \"\n-\t\t       \"-fno-range-check\", &rhs->where);\n+\t\t       \"%<-fno-range-check%>\", &rhs->where);\n \t  else if (rc == ARITH_OVERFLOW)\n \t    gfc_error (\"Arithmetic overflow of bit-wise transferred BOZ at %L\"\n \t\t       \". This check can be disabled with the option \"\n-\t\t       \"-fno-range-check\", &rhs->where);\n+\t\t       \"%<-fno-range-check%>\", &rhs->where);\n \t  else if (rc == ARITH_NAN)\n \t    gfc_error (\"Arithmetic NaN of bit-wise transferred BOZ at %L\"\n \t\t       \". This check can be disabled with the option \"\n-\t\t       \"-fno-range-check\", &rhs->where);\n+\t\t       \"%<-fno-range-check%>\", &rhs->where);\n \t  return false;\n \t}\n     }\n@@ -9316,7 +9316,7 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n       if (!gfc_option.flag_realloc_lhs)\n \t{\n \t  gfc_error (\"Assignment to an allocatable polymorphic variable at %L \"\n-\t\t     \"requires -frealloc-lhs\", &lhs->where);\n+\t\t     \"requires %<-frealloc-lhs%>\", &lhs->where);\n \t  return false;\n \t}\n       /* See PR 43366.  */\n@@ -10836,19 +10836,19 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n \t{\n \t  if (dimension && as->type != AS_ASSUMED_RANK)\n \t    {\n-\t      gfc_error (\"Allocatable array '%s' at %L must have a deferred \"\n+\t      gfc_error (\"Allocatable array %qs at %L must have a deferred \"\n \t\t\t \"shape or assumed rank\", sym->name, &sym->declared_at);\n \t      return false;\n \t    }\n \t  else if (!gfc_notify_std (GFC_STD_F2003, \"Scalar object \"\n-\t\t\t\t    \"'%s' at %L may not be ALLOCATABLE\",\n+\t\t\t\t    \"%qs at %L may not be ALLOCATABLE\",\n \t\t\t\t    sym->name, &sym->declared_at))\n \t    return false;\n \t}\n \n       if (pointer && dimension && as->type != AS_ASSUMED_RANK)\n \t{\n-\t  gfc_error (\"Array pointer '%s' at %L must have a deferred shape or \"\n+\t  gfc_error (\"Array pointer %qs at %L must have a deferred shape or \"\n \t\t     \"assumed rank\", sym->name, &sym->declared_at);\n \t  return false;\n \t}\n@@ -10858,7 +10858,7 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n       if (!mp_flag && !sym->attr.allocatable && !sym->attr.pointer\n \t  && sym->ts.type != BT_CLASS && !sym->assoc)\n \t{\n-\t  gfc_error (\"Array '%s' at %L cannot have a deferred shape\",\n+\t  gfc_error (\"Array %qs at %L cannot have a deferred shape\",\n \t\t     sym->name, &sym->declared_at);\n \t  return false;\n \t }\n@@ -10873,7 +10873,7 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n \t  && !UNLIMITED_POLY (sym)\n \t  && !gfc_type_is_extensible (CLASS_DATA (sym)->ts.u.derived))\n \t{\n-\t  gfc_error (\"Type '%s' of CLASS variable '%s' at %L is not extensible\",\n+\t  gfc_error (\"Type %qs of CLASS variable %qs at %L is not extensible\",\n \t\t     CLASS_DATA (sym)->ts.u.derived->name, sym->name,\n \t\t     &sym->declared_at);\n \t  return false;\n@@ -10885,7 +10885,7 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n \t and excepted from the test.  */\n       if (!sym->attr.class_ok && !sym->attr.use_assoc && !sym->assoc)\n \t{\n-\t  gfc_error (\"CLASS variable '%s' at %L must be dummy, allocatable \"\n+\t  gfc_error (\"CLASS variable %qs at %L must be dummy, allocatable \"\n \t\t     \"or pointer\", sym->name, &sym->declared_at);\n \t  return false;\n \t}\n@@ -10939,7 +10939,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n       && !sym->attr.pointer && !sym->attr.allocatable\n       && gfc_has_default_initializer (sym->ts.u.derived)\n       && !gfc_notify_std (GFC_STD_F2008, \"Implied SAVE for module variable \"\n-\t\t\t  \"'%s' at %L, needed due to the default \"\n+\t\t\t  \"%qs at %L, needed due to the default \"\n \t\t\t  \"initialization\", sym->name, &sym->declared_at))\n     return false;\n \n@@ -10964,7 +10964,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n   const char *auto_save_msg;\n   bool saved_specification_expr;\n \n-  auto_save_msg = \"Automatic object '%s' at %L cannot have the \"\n+  auto_save_msg = \"Automatic object %qs at %L cannot have the \"\n \t\t  \"SAVE attribute\";\n \n   if (!resolve_fl_var_and_proc (sym, mp_flag))\n@@ -10998,7 +10998,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t   || sym->attr.allocatable\n \t   || sym->attr.omp_udr_artificial_var))\n     {\n-      gfc_error (\"Entity '%s' at %L has a deferred type parameter and \"\n+      gfc_error (\"Entity %qs at %L has a deferred type parameter and \"\n \t\t \"requires either the pointer or allocatable attribute\",\n \t\t     sym->name, &sym->declared_at);\n       specification_expr = saved_specification_expr;\n@@ -11042,7 +11042,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t    }\n \t  if (sym->attr.in_common)\n \t    {\n-\t      gfc_error (\"COMMON variable '%s' at %L must have constant \"\n+\t      gfc_error (\"COMMON variable %qs at %L must have constant \"\n \t\t\t \"character length\", sym->name, &sym->declared_at);\n \t      specification_expr = saved_specification_expr;\n \t      return false;\n@@ -11089,23 +11089,23 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n     {\n       if (sym->attr.allocatable || (sym->ts.type == BT_CLASS\n \t\t\t\t    && CLASS_DATA (sym)->attr.allocatable))\n-\tgfc_error (\"Allocatable '%s' at %L cannot have an initializer\",\n+\tgfc_error (\"Allocatable %qs at %L cannot have an initializer\",\n \t\t   sym->name, &sym->declared_at);\n       else if (sym->attr.external)\n-\tgfc_error (\"External '%s' at %L cannot have an initializer\",\n+\tgfc_error (\"External %qs at %L cannot have an initializer\",\n \t\t   sym->name, &sym->declared_at);\n       else if (sym->attr.dummy\n \t&& !(sym->ts.type == BT_DERIVED && sym->attr.intent == INTENT_OUT))\n-\tgfc_error (\"Dummy '%s' at %L cannot have an initializer\",\n+\tgfc_error (\"Dummy %qs at %L cannot have an initializer\",\n \t\t   sym->name, &sym->declared_at);\n       else if (sym->attr.intrinsic)\n-\tgfc_error (\"Intrinsic '%s' at %L cannot have an initializer\",\n+\tgfc_error (\"Intrinsic %qs at %L cannot have an initializer\",\n \t\t   sym->name, &sym->declared_at);\n       else if (sym->attr.result)\n-\tgfc_error (\"Function result '%s' at %L cannot have an initializer\",\n+\tgfc_error (\"Function result %qs at %L cannot have an initializer\",\n \t\t   sym->name, &sym->declared_at);\n       else if (automatic_flag)\n-\tgfc_error (\"Automatic array '%s' at %L cannot have an initializer\",\n+\tgfc_error (\"Automatic array %qs at %L cannot have an initializer\",\n \t\t   sym->name, &sym->declared_at);\n       else\n \tgoto no_init_error;\n@@ -11148,7 +11148,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n       if ((!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT)\n \t  && sym->attr.proc == PROC_ST_FUNCTION)\n \t{\n-\t  gfc_error (\"Character-valued statement function '%s' at %L must \"\n+\t  gfc_error (\"Character-valued statement function %qs at %L must \"\n \t\t     \"have constant length\", sym->name, &sym->declared_at);\n \t  return false;\n \t}\n@@ -11170,9 +11170,9 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t      && arg->sym->ts.type == BT_DERIVED\n \t      && !arg->sym->ts.u.derived->attr.use_assoc\n \t      && !gfc_check_symbol_access (arg->sym->ts.u.derived)\n-\t      && !gfc_notify_std (GFC_STD_F2003, \"'%s' is of a PRIVATE type \"\n+\t      && !gfc_notify_std (GFC_STD_F2003, \"%qs is of a PRIVATE type \"\n \t\t\t\t  \"and cannot be a dummy argument\"\n-\t\t\t\t  \" of '%s', which is PUBLIC at %L\",\n+\t\t\t\t  \" of %qs, which is PUBLIC at %L\",\n \t\t\t\t  arg->sym->name, sym->name,\n \t\t\t\t  &sym->declared_at))\n \t    {\n@@ -11192,9 +11192,9 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t\t  && arg->sym->ts.type == BT_DERIVED\n \t\t  && !arg->sym->ts.u.derived->attr.use_assoc\n \t\t  && !gfc_check_symbol_access (arg->sym->ts.u.derived)\n-\t\t  && !gfc_notify_std (GFC_STD_F2003, \"Procedure '%s' in \"\n-\t\t\t\t      \"PUBLIC interface '%s' at %L \"\n-\t\t\t\t      \"takes dummy arguments of '%s' which \"\n+\t\t  && !gfc_notify_std (GFC_STD_F2003, \"Procedure %qs in \"\n+\t\t\t\t      \"PUBLIC interface %qs at %L \"\n+\t\t\t\t      \"takes dummy arguments of %qs which \"\n \t\t\t\t      \"is PRIVATE\", iface->sym->name,\n \t\t\t\t      sym->name, &iface->sym->declared_at,\n \t\t\t\t      gfc_typename(&arg->sym->ts)))\n@@ -11210,7 +11210,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n   if (sym->attr.function && sym->value && sym->attr.proc != PROC_ST_FUNCTION\n       && !sym->attr.proc_pointer)\n     {\n-      gfc_error (\"Function '%s' at %L cannot have an initializer\",\n+      gfc_error (\"Function %qs at %L cannot have an initializer\",\n \t\t sym->name, &sym->declared_at);\n       return false;\n     }\n@@ -11219,15 +11219,15 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n      a procedure. Exception: Procedure Pointers.  */\n   if (sym->attr.external && sym->value && !sym->attr.proc_pointer)\n     {\n-      gfc_error (\"External object '%s' at %L may not have an initializer\",\n+      gfc_error (\"External object %qs at %L may not have an initializer\",\n \t\t sym->name, &sym->declared_at);\n       return false;\n     }\n \n   /* An elemental function is required to return a scalar 12.7.1  */\n   if (sym->attr.elemental && sym->attr.function && sym->as)\n     {\n-      gfc_error (\"ELEMENTAL function '%s' at %L must have a scalar \"\n+      gfc_error (\"ELEMENTAL function %qs at %L must have a scalar \"\n \t\t \"result\", sym->name, &sym->declared_at);\n       /* Reset so that the error only occurs once.  */\n       sym->attr.elemental = 0;\n@@ -11237,7 +11237,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n   if (sym->attr.proc == PROC_ST_FUNCTION\n       && (sym->attr.allocatable || sym->attr.pointer))\n     {\n-      gfc_error (\"Statement function '%s' at %L may not have pointer or \"\n+      gfc_error (\"Statement function %qs at %L may not have pointer or \"\n \t\t \"allocatable attribute\", sym->name, &sym->declared_at);\n       return false;\n     }\n@@ -11256,19 +11256,19 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t  || (sym->attr.recursive) || (sym->attr.pure))\n \t{\n \t  if (sym->as && sym->as->rank)\n-\t    gfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t    gfc_error (\"CHARACTER(*) function %qs at %L cannot be \"\n \t\t       \"array-valued\", sym->name, &sym->declared_at);\n \n \t  if (sym->attr.pointer)\n-\t    gfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t    gfc_error (\"CHARACTER(*) function %qs at %L cannot be \"\n \t\t       \"pointer-valued\", sym->name, &sym->declared_at);\n \n \t  if (sym->attr.pure)\n-\t    gfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t    gfc_error (\"CHARACTER(*) function %qs at %L cannot be \"\n \t\t       \"pure\", sym->name, &sym->declared_at);\n \n \t  if (sym->attr.recursive)\n-\t    gfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t    gfc_error (\"CHARACTER(*) function %qs at %L cannot be \"\n \t\t       \"recursive\", sym->name, &sym->declared_at);\n \n \t  return false;\n@@ -11281,7 +11281,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n       if (!sym->attr.contained && !sym->ts.deferred\n \t  && (sym->name[0] != '_' || sym->name[1] != '_'))\n \tgfc_notify_std (GFC_STD_F95_OBS,\n-\t\t\t\"CHARACTER(*) function '%s' at %L\",\n+\t\t\t\"CHARACTER(*) function %qs at %L\",\n \t\t\tsym->name, &sym->declared_at);\n     }\n \n@@ -11290,13 +11290,13 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n     {\n       if (sym->attr.proc_pointer)\n \t{\n-\t  gfc_error (\"Procedure pointer '%s' at %L shall not be elemental\",\n+\t  gfc_error (\"Procedure pointer %qs at %L shall not be elemental\",\n \t\t     sym->name, &sym->declared_at);\n \t  return false;\n \t}\n       if (sym->attr.dummy)\n \t{\n-\t  gfc_error (\"Dummy procedure '%s' at %L shall not be elemental\",\n+\t  gfc_error (\"Dummy procedure %qs at %L shall not be elemental\",\n \t\t     sym->name, &sym->declared_at);\n \t  return false;\n \t}\n@@ -11353,32 +11353,32 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n       if (sym->attr.save == SAVE_EXPLICIT)\n \t{\n \t  gfc_error (\"PROCEDURE attribute conflicts with SAVE attribute \"\n-\t\t     \"in '%s' at %L\", sym->name, &sym->declared_at);\n+\t\t     \"in %qs at %L\", sym->name, &sym->declared_at);\n \t  return false;\n \t}\n       if (sym->attr.intent)\n \t{\n \t  gfc_error (\"PROCEDURE attribute conflicts with INTENT attribute \"\n-\t\t     \"in '%s' at %L\", sym->name, &sym->declared_at);\n+\t\t     \"in %qs at %L\", sym->name, &sym->declared_at);\n \t  return false;\n \t}\n       if (sym->attr.subroutine && sym->attr.result)\n \t{\n \t  gfc_error (\"PROCEDURE attribute conflicts with RESULT attribute \"\n-\t\t     \"in '%s' at %L\", sym->name, &sym->declared_at);\n+\t\t     \"in %qs at %L\", sym->name, &sym->declared_at);\n \t  return false;\n \t}\n       if (sym->attr.external && sym->attr.function\n \t  && ((sym->attr.if_source == IFSRC_DECL && !sym->attr.procedure)\n \t      || sym->attr.contained))\n \t{\n \t  gfc_error (\"EXTERNAL attribute conflicts with FUNCTION attribute \"\n-\t\t     \"in '%s' at %L\", sym->name, &sym->declared_at);\n+\t\t     \"in %qs at %L\", sym->name, &sym->declared_at);\n \t  return false;\n \t}\n       if (strcmp (\"ppr@\", sym->name) == 0)\n \t{\n-\t  gfc_error (\"Procedure pointer result '%s' at %L \"\n+\t  gfc_error (\"Procedure pointer result %qs at %L \"\n \t\t     \"is missing the pointer attribute\",\n \t\t     sym->ns->proc_name->name, &sym->declared_at);\n \t  return false;\n@@ -11450,7 +11450,7 @@ gfc_resolve_finalizers (gfc_symbol* derived, bool *finalizable)\n       /* Check this exists and is a SUBROUTINE.  */\n       if (!list->proc_sym->attr.subroutine)\n \t{\n-\t  gfc_error (\"FINAL procedure '%s' at %L is not a SUBROUTINE\",\n+\t  gfc_error (\"FINAL procedure %qs at %L is not a SUBROUTINE\",\n \t\t     list->proc_sym->name, &list->where);\n \t  goto error;\n \t}\n@@ -11468,7 +11468,7 @@ gfc_resolve_finalizers (gfc_symbol* derived, bool *finalizable)\n       /* This argument must be of our type.  */\n       if (arg->ts.type != BT_DERIVED || arg->ts.u.derived != derived)\n \t{\n-\t  gfc_error (\"Argument of FINAL procedure at %L must be of type '%s'\",\n+\t  gfc_error (\"Argument of FINAL procedure at %L must be of type %qs\",\n \t\t     &arg->declared_at, derived->name);\n \t  goto error;\n \t}\n@@ -11527,8 +11527,8 @@ gfc_resolve_finalizers (gfc_symbol* derived, bool *finalizable)\n \t      const int i_rank = (i_arg->as ? i_arg->as->rank : 0);\n \t      if (i_rank == my_rank)\n \t\t{\n-\t\t  gfc_error (\"FINAL procedure '%s' declared at %L has the same\"\n-\t\t\t     \" rank (%d) as '%s'\",\n+\t\t  gfc_error (\"FINAL procedure %qs declared at %L has the same\"\n+\t\t\t     \" rank (%d) as %qs\",\n \t\t\t     list->proc_sym->name, &list->where, my_rank,\n \t\t\t     i->proc_sym->name);\n \t\t  goto error;\n@@ -11604,8 +11604,8 @@ check_generic_tbp_ambiguity (gfc_tbp_generic* t1, gfc_tbp_generic* t2,\n   if (sym1->attr.subroutine != sym2->attr.subroutine\n       || sym1->attr.function != sym2->attr.function)\n     {\n-      gfc_error (\"'%s' and '%s' can't be mixed FUNCTION/SUBROUTINE for\"\n-\t\t \" GENERIC '%s' at %L\",\n+      gfc_error (\"%qs and %qs can't be mixed FUNCTION/SUBROUTINE for\"\n+\t\t \" GENERIC %qs at %L\",\n \t\t sym1->name, sym2->name, generic_name, &where);\n       return false;\n     }\n@@ -11640,7 +11640,7 @@ check_generic_tbp_ambiguity (gfc_tbp_generic* t1, gfc_tbp_generic* t2,\n   if (gfc_compare_interfaces (sym1, sym2, sym2->name, !t1->is_operator, 0,\n \t\t\t      NULL, 0, pass1, pass2))\n     {\n-      gfc_error (\"'%s' and '%s' for GENERIC '%s' at %L are ambiguous\",\n+      gfc_error (\"%qs and %qs for GENERIC %qs at %L are ambiguous\",\n \t\t sym1->name, sym2->name, generic_name, &where);\n       return false;\n     }\n@@ -11699,7 +11699,7 @@ resolve_tb_generic_targets (gfc_symbol* super_type,\n \t      }\n \t  }\n \n-\tgfc_error (\"Undefined specific binding '%s' as target of GENERIC '%s'\"\n+\tgfc_error (\"Undefined specific binding %qs as target of GENERIC %qs\"\n \t\t   \" at %L\", target_name, name, &p->where);\n \treturn false;\n \n@@ -11711,8 +11711,8 @@ resolve_tb_generic_targets (gfc_symbol* super_type,\n \t/* This must really be a specific binding!  */\n \tif (target->specific->is_generic)\n \t  {\n-\t    gfc_error (\"GENERIC '%s' at %L must target a specific binding,\"\n-\t\t       \" '%s' is GENERIC, too\", name, &p->where, target_name);\n+\t    gfc_error (\"GENERIC %qs at %L must target a specific binding,\"\n+\t\t       \" %qs is GENERIC, too\", name, &p->where, target_name);\n \t    return false;\n \t  }\n \n@@ -11739,7 +11739,7 @@ resolve_tb_generic_targets (gfc_symbol* super_type,\n   /* If we attempt to \"overwrite\" a specific binding, this is an error.  */\n   if (p->overridden && !p->overridden->is_generic)\n     {\n-      gfc_error (\"GENERIC '%s' at %L can't overwrite specific binding with\"\n+      gfc_error (\"GENERIC %qs at %L can't overwrite specific binding with\"\n \t\t \" the same name\", name, &p->where);\n       return false;\n     }\n@@ -11977,7 +11977,7 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t      && proc->attr.if_source != IFSRC_IFBODY)\n \t  || proc->attr.abstract)\n \t{\n-\t  gfc_error (\"'%s' must be a module procedure or an external procedure with\"\n+\t  gfc_error (\"%qs must be a module procedure or an external procedure with\"\n \t\t    \" an explicit interface at %L\", proc->name, &where);\n \t  goto error;\n \t}\n@@ -12019,8 +12019,8 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \n \t  if (!me_arg)\n \t    {\n-\t      gfc_error (\"Procedure '%s' with PASS(%s) at %L has no\"\n-\t\t\t \" argument '%s'\",\n+\t      gfc_error (\"Procedure %qs with PASS(%s) at %L has no\"\n+\t\t\t \" argument %qs\",\n \t\t\t proc->name, stree->n.tb->pass_arg, &where,\n \t\t\t stree->n.tb->pass_arg);\n \t      goto error;\n@@ -12033,7 +12033,7 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t  stree->n.tb->pass_arg_num = 1;\n \t  if (!dummy_args)\n \t    {\n-\t      gfc_error (\"Procedure '%s' with PASS at %L must have at\"\n+\t      gfc_error (\"Procedure %qs with PASS at %L must have at\"\n \t\t\t \" least one argument\", proc->name, &where);\n \t      goto error;\n \t    }\n@@ -12047,36 +12047,36 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \n       if (me_arg->ts.type != BT_CLASS)\n \t{\n-\t  gfc_error (\"Non-polymorphic passed-object dummy argument of '%s'\"\n+\t  gfc_error (\"Non-polymorphic passed-object dummy argument of %qs\"\n \t\t     \" at %L\", proc->name, &where);\n \t  goto error;\n \t}\n \n       if (CLASS_DATA (me_arg)->ts.u.derived\n \t  != resolve_bindings_derived)\n \t{\n-\t  gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L must be of\"\n-\t\t     \" the derived-type '%s'\", me_arg->name, proc->name,\n+\t  gfc_error (\"Argument %qs of %qs with PASS(%s) at %L must be of\"\n+\t\t     \" the derived-type %qs\", me_arg->name, proc->name,\n \t\t     me_arg->name, &where, resolve_bindings_derived->name);\n \t  goto error;\n \t}\n \n       gcc_assert (me_arg->ts.type == BT_CLASS);\n       if (CLASS_DATA (me_arg)->as && CLASS_DATA (me_arg)->as->rank != 0)\n \t{\n-\t  gfc_error (\"Passed-object dummy argument of '%s' at %L must be\"\n+\t  gfc_error (\"Passed-object dummy argument of %qs at %L must be\"\n \t\t     \" scalar\", proc->name, &where);\n \t  goto error;\n \t}\n       if (CLASS_DATA (me_arg)->attr.allocatable)\n \t{\n-\t  gfc_error (\"Passed-object dummy argument of '%s' at %L must not\"\n+\t  gfc_error (\"Passed-object dummy argument of %qs at %L must not\"\n \t\t     \" be ALLOCATABLE\", proc->name, &where);\n \t  goto error;\n \t}\n       if (CLASS_DATA (me_arg)->attr.class_pointer)\n \t{\n-\t  gfc_error (\"Passed-object dummy argument of '%s' at %L must not\"\n+\t  gfc_error (\"Passed-object dummy argument of %qs at %L must not\"\n \t\t     \" be POINTER\", proc->name, &where);\n \t  goto error;\n \t}\n@@ -12105,17 +12105,17 @@ resolve_typebound_procedure (gfc_symtree* stree)\n   for (comp = resolve_bindings_derived->components; comp; comp = comp->next)\n     if (!strcmp (comp->name, stree->name))\n       {\n-\tgfc_error (\"Procedure '%s' at %L has the same name as a component of\"\n-\t\t   \" '%s'\",\n+\tgfc_error (\"Procedure %qs at %L has the same name as a component of\"\n+\t\t   \" %qs\",\n \t\t   stree->name, &where, resolve_bindings_derived->name);\n \tgoto error;\n       }\n \n   /* Try to find a name collision with an inherited component.  */\n   if (super_type && gfc_find_component (super_type, stree->name, true, true))\n     {\n-      gfc_error (\"Procedure '%s' at %L has the same name as an inherited\"\n-\t\t \" component of '%s'\",\n+      gfc_error (\"Procedure %qs at %L has the same name as an inherited\"\n+\t\t \" component of %qs\",\n \t\t stree->name, &where, resolve_bindings_derived->name);\n       goto error;\n     }\n@@ -12206,8 +12206,8 @@ ensure_not_abstract_walker (gfc_symbol* sub, gfc_symtree* st)\n       gcc_assert (overriding->n.tb);\n       if (overriding->n.tb->deferred)\n \t{\n-\t  gfc_error (\"Derived-type '%s' declared at %L must be ABSTRACT because\"\n-\t\t     \" '%s' is DEFERRED and not overridden\",\n+\t  gfc_error (\"Derived-type %qs declared at %L must be ABSTRACT because\"\n+\t\t     \" %qs is DEFERRED and not overridden\",\n \t\t     sub->name, &sub->declared_at, st->name);\n \t  return false;\n \t}\n@@ -12304,8 +12304,8 @@ resolve_fl_derived0 (gfc_symbol *sym)\n   /* F2008, C432.  */\n   if (super_type && sym->attr.coarray_comp && !super_type->attr.coarray_comp)\n     {\n-      gfc_error (\"As extending type '%s' at %L has a coarray component, \"\n-\t\t \"parent type '%s' shall also have one\", sym->name,\n+      gfc_error (\"As extending type %qs at %L has a coarray component, \"\n+\t\t \"parent type %qs shall also have one\", sym->name,\n \t\t &sym->declared_at, super_type->name);\n       return false;\n     }\n@@ -12317,7 +12317,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n   /* An ABSTRACT type must be extensible.  */\n   if (sym->attr.abstract && !gfc_type_is_extensible (sym))\n     {\n-      gfc_error (\"Non-extensible derived-type '%s' at %L must not be ABSTRACT\",\n+      gfc_error (\"Non-extensible derived-type %qs at %L must not be ABSTRACT\",\n \t\t sym->name, &sym->declared_at);\n       return false;\n     }\n@@ -12606,9 +12606,9 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t  && !is_sym_host_assoc (c->ts.u.derived, sym->ns)\n \t  && !c->ts.u.derived->attr.use_assoc\n \t  && !gfc_check_symbol_access (c->ts.u.derived)\n-\t  && !gfc_notify_std (GFC_STD_F2003, \"the component '%s' is a \"\n+\t  && !gfc_notify_std (GFC_STD_F2003, \"the component %qs is a \"\n \t\t\t      \"PRIVATE type and cannot be a component of \"\n-\t\t\t      \"'%s', which is PUBLIC at %L\", c->name,\n+\t\t\t      \"%qs, which is PUBLIC at %L\", c->name,\n \t\t\t      sym->name, &sym->declared_at))\n \treturn false;\n \n@@ -12730,7 +12730,7 @@ resolve_fl_derived (gfc_symbol *sym)\n   if (gen_dt && gen_dt->generic && gen_dt->generic->next\n       && (!gen_dt->generic->sym->attr.use_assoc\n \t  || gen_dt->generic->sym->module != gen_dt->generic->next->sym->module)\n-      && !gfc_notify_std (GFC_STD_F2003, \"Generic name '%s' of function \"\n+      && !gfc_notify_std_1 (GFC_STD_F2003, \"Generic name '%s' of function \"\n \t\t\t  \"'%s' at %L being the same name as derived \"\n \t\t\t  \"type at %L\", sym->name,\n \t\t\t  gen_dt->generic->sym == sym\n@@ -12786,37 +12786,37 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t after the decl.  */\n       if (nl->sym->as && nl->sym->as->type == AS_ASSUMED_SIZE)\n      \t{\n-\t  gfc_error (\"Assumed size array '%s' in namelist '%s' at %L is not \"\n+\t  gfc_error (\"Assumed size array %qs in namelist %qs at %L is not \"\n \t\t     \"allowed\", nl->sym->name, sym->name, &sym->declared_at);\n \t  return false;\n \t}\n \n       if (nl->sym->as && nl->sym->as->type == AS_ASSUMED_SHAPE\n-\t  && !gfc_notify_std (GFC_STD_F2003, \"NAMELIST array object '%s' \"\n-\t\t\t      \"with assumed shape in namelist '%s' at %L\",\n+\t  && !gfc_notify_std (GFC_STD_F2003, \"NAMELIST array object %qs \"\n+\t\t\t      \"with assumed shape in namelist %qs at %L\",\n \t\t\t      nl->sym->name, sym->name, &sym->declared_at))\n \treturn false;\n \n       if (is_non_constant_shape_array (nl->sym)\n-\t  && !gfc_notify_std (GFC_STD_F2003, \"NAMELIST array object '%s' \"\n-\t\t\t      \"with nonconstant shape in namelist '%s' at %L\",\n+\t  && !gfc_notify_std (GFC_STD_F2003, \"NAMELIST array object %qs \"\n+\t\t\t      \"with nonconstant shape in namelist %qs at %L\",\n \t\t\t      nl->sym->name, sym->name, &sym->declared_at))\n \treturn false;\n \n       if (nl->sym->ts.type == BT_CHARACTER\n \t  && (nl->sym->ts.u.cl->length == NULL\n \t      || !gfc_is_constant_expr (nl->sym->ts.u.cl->length))\n-\t  && !gfc_notify_std (GFC_STD_F2003, \"NAMELIST object '%s' with \"\n+\t  && !gfc_notify_std (GFC_STD_F2003, \"NAMELIST object %qs with \"\n \t\t\t      \"nonconstant character length in \"\n-\t\t\t      \"namelist '%s' at %L\", nl->sym->name,\n+\t\t\t      \"namelist %qs at %L\", nl->sym->name,\n \t\t\t      sym->name, &sym->declared_at))\n \treturn false;\n \n       /* FIXME: Once UDDTIO is implemented, the following can be\n \t removed.  */\n       if (nl->sym->ts.type == BT_CLASS)\n \t{\n-\t  gfc_error (\"NAMELIST object '%s' in namelist '%s' at %L is \"\n+\t  gfc_error (\"NAMELIST object %qs in namelist %qs at %L is \"\n \t\t     \"polymorphic and requires a defined input/output \"\n \t\t     \"procedure\", nl->sym->name, sym->name, &sym->declared_at);\n \t  return false;\n@@ -12826,15 +12826,15 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t  && (nl->sym->ts.u.derived->attr.alloc_comp\n \t      || nl->sym->ts.u.derived->attr.pointer_comp))\n \t{\n-\t  if (!gfc_notify_std (GFC_STD_F2003, \"NAMELIST object '%s' in \"\n-\t\t\t       \"namelist '%s' at %L with ALLOCATABLE \"\n+\t  if (!gfc_notify_std (GFC_STD_F2003, \"NAMELIST object %qs in \"\n+\t\t\t       \"namelist %qs at %L with ALLOCATABLE \"\n \t\t\t       \"or POINTER components\", nl->sym->name,\n \t\t\t       sym->name, &sym->declared_at))\n \t    return false;\n \n \t /* FIXME: Once UDDTIO is implemented, the following can be\n \t    removed.  */\n-\t  gfc_error (\"NAMELIST object '%s' in namelist '%s' at %L has \"\n+\t  gfc_error (\"NAMELIST object %qs in namelist %qs at %L has \"\n \t\t     \"ALLOCATABLE or POINTER components and thus requires \"\n \t\t     \"a defined input/output procedure\", nl->sym->name,\n \t\t     sym->name, &sym->declared_at);\n@@ -12851,8 +12851,8 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t      && !is_sym_host_assoc (nl->sym, sym->ns)\n \t      && !gfc_check_symbol_access (nl->sym))\n \t    {\n-\t      gfc_error (\"NAMELIST object '%s' was declared PRIVATE and \"\n-\t\t\t \"cannot be member of PUBLIC namelist '%s' at %L\",\n+\t      gfc_error (\"NAMELIST object %qs was declared PRIVATE and \"\n+\t\t\t \"cannot be member of PUBLIC namelist %qs at %L\",\n \t\t\t nl->sym->name, sym->name, &sym->declared_at);\n \t      return false;\n \t    }\n@@ -12861,8 +12861,8 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t  if (nl->sym->ts.type == BT_DERIVED\n \t      && derived_inaccessible (nl->sym->ts.u.derived))\n \t    {\n-\t      gfc_error (\"NAMELIST object '%s' has use-associated PRIVATE \"\n-\t\t\t \"components and cannot be member of namelist '%s' at %L\",\n+\t      gfc_error (\"NAMELIST object %qs has use-associated PRIVATE \"\n+\t\t\t \"components and cannot be member of namelist %qs at %L\",\n \t\t\t nl->sym->name, sym->name, &sym->declared_at);\n \t      return false;\n \t    }\n@@ -12872,8 +12872,8 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t      && !is_sym_host_assoc (nl->sym->ts.u.derived, sym->ns)\n \t      && nl->sym->ts.u.derived->attr.private_comp)\n \t    {\n-\t      gfc_error (\"NAMELIST object '%s' has PRIVATE components and \"\n-\t\t\t \"cannot be a member of PUBLIC namelist '%s' at %L\",\n+\t      gfc_error (\"NAMELIST object %qs has PRIVATE components and \"\n+\t\t\t \"cannot be a member of PUBLIC namelist %qs at %L\",\n \t\t\t nl->sym->name, sym->name, &sym->declared_at);\n \t      return false;\n \t    }\n@@ -12900,7 +12900,7 @@ resolve_fl_namelist (gfc_symbol *sym)\n       if (nlsym && nlsym->attr.flavor == FL_PROCEDURE)\n \t{\n \t  gfc_error (\"PROCEDURE attribute conflicts with NAMELIST \"\n-\t\t     \"attribute in '%s' at %L\", nlsym->name,\n+\t\t     \"attribute in %qs at %L\", nlsym->name,\n \t\t     &sym->declared_at);\n \t  return false;\n \t}\n@@ -12918,7 +12918,7 @@ resolve_fl_parameter (gfc_symbol *sym)\n       && (sym->as->type == AS_DEFERRED\n           || is_non_constant_shape_array (sym)))\n     {\n-      gfc_error (\"Parameter array '%s' at %L cannot be automatic \"\n+      gfc_error (\"Parameter array %qs at %L cannot be automatic \"\n \t\t \"or of deferred shape\", sym->name, &sym->declared_at);\n       return false;\n     }\n@@ -12930,7 +12930,7 @@ resolve_fl_parameter (gfc_symbol *sym)\n       && !gfc_compare_types (&sym->ts, gfc_get_default_type (sym->name,\n \t\t\t\t\t\t\t     sym->ns)))\n     {\n-      gfc_error (\"Implicitly typed PARAMETER '%s' at %L doesn't match a \"\n+      gfc_error (\"Implicitly typed PARAMETER %qs at %L doesn't match a \"\n \t\t \"later IMPLICIT type\", sym->name, &sym->declared_at);\n       return false;\n     }\n@@ -13117,7 +13117,7 @@ resolve_symbol (gfc_symbol *sym)\n \t  || (as->type != AS_ASSUMED_SHAPE && as->type != AS_ASSUMED_RANK\n \t      && !class_attr.pointer)))\n     {\n-      gfc_error (\"'%s' at %L has the CONTIGUOUS attribute but is not an \"\n+      gfc_error (\"%qs at %L has the CONTIGUOUS attribute but is not an \"\n \t\t \"array pointer or an assumed-shape or assumed-rank array\",\n \t\t sym->name, &sym->declared_at);\n       return;\n@@ -13172,7 +13172,7 @@ resolve_symbol (gfc_symbol *sym)\n \n   if (sym->attr.value && !sym->attr.dummy)\n     {\n-      gfc_error (\"'%s' at %L cannot have the VALUE attribute because \"\n+      gfc_error (\"%qs at %L cannot have the VALUE attribute because \"\n \t\t \"it is not a dummy argument\", sym->name, &sym->declared_at);\n       return;\n     }\n@@ -13182,7 +13182,7 @@ resolve_symbol (gfc_symbol *sym)\n       gfc_charlen *cl = sym->ts.u.cl;\n       if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT)\n \t{\n-\t  gfc_error (\"Character dummy variable '%s' at %L with VALUE \"\n+\t  gfc_error (\"Character dummy variable %qs at %L with VALUE \"\n \t\t     \"attribute must have constant length\",\n \t\t     sym->name, &sym->declared_at);\n \t  return;\n@@ -13191,7 +13191,7 @@ resolve_symbol (gfc_symbol *sym)\n       if (sym->ts.is_c_interop\n \t  && mpz_cmp_si (cl->length->value.integer, 1) != 0)\n \t{\n-\t  gfc_error (\"C interoperable character dummy variable '%s' at %L \"\n+\t  gfc_error (\"C interoperable character dummy variable %qs at %L \"\n \t\t     \"with VALUE attribute must have length one\",\n \t\t     sym->name, &sym->declared_at);\n \t  return;\n@@ -13204,7 +13204,7 @@ resolve_symbol (gfc_symbol *sym)\n       sym->ts.u.derived = gfc_find_dt_in_generic (sym->ts.u.derived);\n       if (!sym->ts.u.derived)\n \t{\n-\t  gfc_error (\"The derived type '%s' at %L is of type '%s', \"\n+\t  gfc_error (\"The derived type %qs at %L is of type %qs, \"\n \t\t     \"which has not been defined\", sym->name,\n \t\t     &sym->declared_at, sym->ts.u.derived->name);\n \t  sym->ts.type = BT_UNKNOWN;\n@@ -13371,7 +13371,7 @@ resolve_symbol (gfc_symbol *sym)\n       && sym->ts.u.derived->components == NULL\n       && !sym->ts.u.derived->attr.zero_comp)\n     {\n-      gfc_error (\"The derived type '%s' at %L is of type '%s', \"\n+      gfc_error (\"The derived type %qs at %L is of type %qs, \"\n \t\t \"which has not been defined\", sym->name,\n \t\t  &sym->declared_at, sym->ts.u.derived->name);\n       sym->ts.type = BT_UNKNOWN;\n@@ -13397,8 +13397,8 @@ resolve_symbol (gfc_symbol *sym)\n       && !sym->ts.u.derived->attr.use_assoc\n       && gfc_check_symbol_access (sym)\n       && !gfc_check_symbol_access (sym->ts.u.derived)\n-      && !gfc_notify_std (GFC_STD_F2003, \"PUBLIC %s '%s' at %L of PRIVATE \"\n-\t\t\t  \"derived type '%s'\",\n+      && !gfc_notify_std (GFC_STD_F2003, \"PUBLIC %s %qs at %L of PRIVATE \"\n+\t\t\t  \"derived type %qs\",\n \t\t\t  (sym->attr.flavor == FL_PARAMETER)\n \t\t\t  ? \"parameter\" : \"variable\",\n \t\t\t  sym->name, &sym->declared_at,\n@@ -13430,7 +13430,7 @@ resolve_symbol (gfc_symbol *sym)\n \t{\n \t  if (c->initializer)\n \t    {\n-\t      gfc_error (\"The INTENT(OUT) dummy argument '%s' at %L is \"\n+\t      gfc_error (\"The INTENT(OUT) dummy argument %qs at %L is \"\n \t\t\t \"ASSUMED SIZE and so cannot have a default initializer\",\n \t\t\t sym->name, &sym->declared_at);\n \t      return;\n@@ -13442,7 +13442,7 @@ resolve_symbol (gfc_symbol *sym)\n   if (sym->ts.type == BT_DERIVED && sym->attr.dummy\n       && sym->attr.intent == INTENT_OUT && sym->attr.lock_comp)\n     {\n-      gfc_error (\"Dummy argument '%s' at %L of LOCK_TYPE shall not be \"\n+      gfc_error (\"Dummy argument %qs at %L of LOCK_TYPE shall not be \"\n \t\t \"INTENT(OUT)\", sym->name, &sym->declared_at);\n       return;\n     }\n@@ -13454,7 +13454,7 @@ resolve_symbol (gfc_symbol *sym)\n        || class_attr.codimension)\n       && (sym->attr.result || sym->result == sym))\n     {\n-      gfc_error (\"Function result '%s' at %L shall not be a coarray or have \"\n+      gfc_error (\"Function result %qs at %L shall not be a coarray or have \"\n \t         \"a coarray component\", sym->name, &sym->declared_at);\n       return;\n     }\n@@ -13463,7 +13463,7 @@ resolve_symbol (gfc_symbol *sym)\n   if (sym->attr.codimension && sym->ts.type == BT_DERIVED\n       && sym->ts.u.derived->ts.is_iso_c)\n     {\n-      gfc_error (\"Variable '%s' at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) \"\n+      gfc_error (\"Variable %qs at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) \"\n \t\t \"shall not be a coarray\", sym->name, &sym->declared_at);\n       return;\n     }\n@@ -13475,7 +13475,7 @@ resolve_symbol (gfc_symbol *sym)\n       && (class_attr.codimension || class_attr.pointer || class_attr.dimension\n \t  || class_attr.allocatable))\n     {\n-      gfc_error (\"Variable '%s' at %L with coarray component shall be a \"\n+      gfc_error (\"Variable %qs at %L with coarray component shall be a \"\n \t\t \"nonpointer, nonallocatable scalar, which is not a coarray\",\n \t\t sym->name, &sym->declared_at);\n       return;\n@@ -13490,22 +13490,22 @@ resolve_symbol (gfc_symbol *sym)\n \t   || sym->ns->proc_name->attr.is_main_program\n \t   || sym->attr.function || sym->attr.result || sym->attr.use_assoc))\n     {\n-      gfc_error (\"Variable '%s' at %L is a coarray and is not ALLOCATABLE, SAVE \"\n+      gfc_error (\"Variable %qs at %L is a coarray and is not ALLOCATABLE, SAVE \"\n \t\t \"nor a dummy argument\", sym->name, &sym->declared_at);\n       return;\n     }\n   /* F2008, C528.  */\n   else if (class_attr.codimension && !sym->attr.select_type_temporary\n \t   && !class_attr.allocatable && as && as->cotype == AS_DEFERRED)\n     {\n-      gfc_error (\"Coarray variable '%s' at %L shall not have codimensions with \"\n+      gfc_error (\"Coarray variable %qs at %L shall not have codimensions with \"\n \t\t \"deferred shape\", sym->name, &sym->declared_at);\n       return;\n     }\n   else if (class_attr.codimension && class_attr.allocatable && as\n \t   && (as->cotype != AS_DEFERRED || as->type != AS_DEFERRED))\n     {\n-      gfc_error (\"Allocatable coarray variable '%s' at %L must have \"\n+      gfc_error (\"Allocatable coarray variable %qs at %L must have \"\n \t\t \"deferred shape\", sym->name, &sym->declared_at);\n       return;\n     }\n@@ -13517,7 +13517,7 @@ resolve_symbol (gfc_symbol *sym)\n        || (class_attr.codimension && class_attr.allocatable))\n       && sym->attr.dummy && sym->attr.intent == INTENT_OUT)\n     {\n-      gfc_error (\"Variable '%s' at %L is INTENT(OUT) and can thus not be an \"\n+      gfc_error (\"Variable %qs at %L is INTENT(OUT) and can thus not be an \"\n \t\t \"allocatable coarray or have coarray components\",\n \t\t sym->name, &sym->declared_at);\n       return;\n@@ -13526,8 +13526,8 @@ resolve_symbol (gfc_symbol *sym)\n   if (class_attr.codimension && sym->attr.dummy\n       && sym->ns->proc_name && sym->ns->proc_name->attr.is_bind_c)\n     {\n-      gfc_error (\"Coarray dummy variable '%s' at %L not allowed in BIND(C) \"\n-\t\t \"procedure '%s'\", sym->name, &sym->declared_at,\n+      gfc_error (\"Coarray dummy variable %qs at %L not allowed in BIND(C) \"\n+\t\t \"procedure %qs\", sym->name, &sym->declared_at,\n \t\t sym->ns->proc_name->name);\n       return;\n     }\n@@ -13542,15 +13542,15 @@ resolve_symbol (gfc_symbol *sym)\n         if (gfc_logical_kinds[i].kind == sym->ts.kind)\n           break;\n       if (!gfc_logical_kinds[i].c_bool && sym->attr.dummy\n-\t  && !gfc_notify_std (GFC_STD_GNU, \"LOGICAL dummy argument '%s' at \"\n+\t  && !gfc_notify_std (GFC_STD_GNU, \"LOGICAL dummy argument %qs at \"\n \t\t\t      \"%L with non-C_Bool kind in BIND(C) procedure \"\n-\t\t\t      \"'%s'\", sym->name, &sym->declared_at,\n+\t\t\t      \"%qs\", sym->name, &sym->declared_at,\n \t\t\t      sym->ns->proc_name->name))\n \treturn;\n       else if (!gfc_logical_kinds[i].c_bool\n \t       && !gfc_notify_std (GFC_STD_GNU, \"LOGICAL result variable \"\n-\t\t\t\t   \"'%s' at %L with non-C_Bool kind in \"\n-\t\t\t\t   \"BIND(C) procedure '%s'\", sym->name,\n+\t\t\t\t   \"%qs at %L with non-C_Bool kind in \"\n+\t\t\t\t   \"BIND(C) procedure %qs\", sym->name,\n \t\t\t\t   &sym->declared_at,\n \t\t\t\t   sym->attr.function ? sym->name\n \t\t\t\t   : sym->ns->proc_name->name))\n@@ -13638,7 +13638,7 @@ resolve_symbol (gfc_symbol *sym)\n \t  && sym->module == NULL\n \t  && (sym->ns->proc_name == NULL\n \t      || sym->ns->proc_name->attr.flavor != FL_MODULE)))\n-    gfc_error (\"!$OMP DECLARE TARGET variable '%s' at %L isn't SAVEd\",\n+    gfc_error (\"!$OMP DECLARE TARGET variable %qs at %L isn't SAVEd\",\n \t       sym->name, &sym->declared_at);\n \n   /* If we have come this far we can apply default-initializers, as\n@@ -13731,13 +13731,13 @@ check_data_variable (gfc_data_variable *var, locus *where)\n \n   if (sym->ns->is_block_data && !sym->attr.in_common)\n     {\n-      gfc_error (\"BLOCK DATA element '%s' at %L must be in COMMON\",\n+      gfc_error (\"BLOCK DATA element %qs at %L must be in COMMON\",\n \t\t sym->name, &sym->declared_at);\n     }\n \n   if (e->ref == NULL && sym->as)\n     {\n-      gfc_error (\"DATA array '%s' at %L must be specified in a previous\"\n+      gfc_error (\"DATA array %qs at %L must be specified in a previous\"\n \t\t \" declaration\", sym->name, where);\n       return false;\n     }\n@@ -13746,7 +13746,7 @@ check_data_variable (gfc_data_variable *var, locus *where)\n \n   if (gfc_is_coindexed (e))\n     {\n-      gfc_error (\"DATA element '%s' at %L cannot have a coindex\", sym->name,\n+      gfc_error (\"DATA element %qs at %L cannot have a coindex\", sym->name,\n \t\t where);\n       return false;\n     }\n@@ -13760,7 +13760,7 @@ check_data_variable (gfc_data_variable *var, locus *where)\n \t    && ref->type == REF_ARRAY\n \t    && ref->u.ar.type != AR_FULL)\n \t  {\n-\t    gfc_error (\"DATA element '%s' at %L is a pointer and so must \"\n+\t    gfc_error (\"DATA element %qs at %L is a pointer and so must \"\n \t\t\t\"be a full array\", sym->name, where);\n \t    return false;\n \t  }\n@@ -14313,7 +14313,7 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n   /* Shall not be an object of nonsequence derived type.  */\n   if (!derived->attr.sequence)\n     {\n-      gfc_error (\"Derived type variable '%s' at %L must have SEQUENCE \"\n+      gfc_error (\"Derived type variable %qs at %L must have SEQUENCE \"\n \t\t \"attribute to be an EQUIVALENCE object\", sym->name,\n \t\t &e->where);\n       return false;\n@@ -14322,15 +14322,15 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n   /* Shall not have allocatable components.  */\n   if (derived->attr.alloc_comp)\n     {\n-      gfc_error (\"Derived type variable '%s' at %L cannot have ALLOCATABLE \"\n+      gfc_error (\"Derived type variable %qs at %L cannot have ALLOCATABLE \"\n \t\t \"components to be an EQUIVALENCE object\",sym->name,\n \t\t &e->where);\n       return false;\n     }\n \n   if (sym->attr.in_common && gfc_has_default_initializer (sym->ts.u.derived))\n     {\n-      gfc_error (\"Derived type variable '%s' at %L with default \"\n+      gfc_error (\"Derived type variable %qs at %L with default \"\n \t\t \"initialization cannot be in EQUIVALENCE with a variable \"\n \t\t \"in COMMON\", sym->name, &e->where);\n       return false;\n@@ -14346,7 +14346,7 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n \t in the structure.  */\n       if (c->attr.pointer)\n \t{\n-\t  gfc_error (\"Derived type variable '%s' at %L with pointer \"\n+\t  gfc_error (\"Derived type variable %qs at %L with pointer \"\n \t\t     \"component(s) cannot be an EQUIVALENCE object\",\n \t\t     sym->name, &e->where);\n \t  return false;\n@@ -14476,16 +14476,16 @@ resolve_equivalence (gfc_equiv *eq)\n \t  && sym->ns->proc_name->attr.pure\n \t  && sym->attr.in_common)\n \t{\n-\t  gfc_error (\"Common block member '%s' at %L cannot be an EQUIVALENCE \"\n-\t\t     \"object in the pure procedure '%s'\",\n+\t  gfc_error (\"Common block member %qs at %L cannot be an EQUIVALENCE \"\n+\t\t     \"object in the pure procedure %qs\",\n \t\t     sym->name, &e->where, sym->ns->proc_name->name);\n \t  break;\n \t}\n \n       /* Shall not be a named constant.  */\n       if (e->expr_type == EXPR_CONSTANT)\n \t{\n-\t  gfc_error (\"Named constant '%s' at %L cannot be an EQUIVALENCE \"\n+\t  gfc_error (\"Named constant %qs at %L cannot be an EQUIVALENCE \"\n \t\t     \"object\", sym->name, &e->where);\n \t  continue;\n \t}\n@@ -14533,14 +14533,14 @@ resolve_equivalence (gfc_equiv *eq)\n \t      && !gfc_notify_std (GFC_STD_GNU, msg, sym->name, &e->where)))\n \tcontinue;\n \n-      msg =\"Non-CHARACTER object '%s' in default CHARACTER \"\n+      msg =\"Non-CHARACTER object %qs in default CHARACTER \"\n \t   \"EQUIVALENCE statement at %L\";\n       if (last_eq_type == SEQ_CHARACTER\n \t  && eq_type != SEQ_CHARACTER\n \t  && !gfc_notify_std (GFC_STD_GNU, msg, sym->name, &e->where))\n \t\tcontinue;\n \n-      msg =\"Non-NUMERIC object '%s' in default NUMERIC \"\n+      msg =\"Non-NUMERIC object %qs in default NUMERIC \"\n \t   \"EQUIVALENCE statement at %L\";\n       if (last_eq_type == SEQ_NUMERIC\n \t  && eq_type != SEQ_NUMERIC\n@@ -14558,7 +14558,7 @@ resolve_equivalence (gfc_equiv *eq)\n       if (e->ref->type == REF_ARRAY\n \t  && !gfc_resolve_array_spec (e->ref->u.ar.as, 1))\n \t{\n-\t  gfc_error (\"Array '%s' at %L with non-constant bounds cannot be \"\n+\t  gfc_error (\"Array %qs at %L with non-constant bounds cannot be \"\n \t\t     \"an EQUIVALENCE object\", sym->name, &e->where);\n \t  continue;\n \t}\n@@ -14569,7 +14569,7 @@ resolve_equivalence (gfc_equiv *eq)\n \t  /* Shall not be a structure component.  */\n \t  if (r->type == REF_COMPONENT)\n \t    {\n-\t      gfc_error (\"Structure component '%s' at %L cannot be an \"\n+\t      gfc_error (\"Structure component %qs at %L cannot be an \"\n \t\t\t \"EQUIVALENCE object\",\n \t\t\t r->u.c.component->name, &e->where);\n \t      break;\n@@ -14613,7 +14613,7 @@ resolve_fntype (gfc_namespace *ns)\n       && !gfc_set_default_type (sym, 0, NULL)\n       && !sym->attr.untyped)\n     {\n-      gfc_error (\"Function '%s' at %L has no IMPLICIT type\",\n+      gfc_error (\"Function %qs at %L has no IMPLICIT type\",\n \t\t sym->name, &sym->declared_at);\n       sym->attr.untyped = 1;\n     }\n@@ -14623,8 +14623,8 @@ resolve_fntype (gfc_namespace *ns)\n       && !gfc_check_symbol_access (sym->ts.u.derived)\n       && gfc_check_symbol_access (sym))\n     {\n-      gfc_notify_std (GFC_STD_F2003, \"PUBLIC function '%s' at \"\n-\t\t      \"%L of PRIVATE type '%s'\", sym->name,\n+      gfc_notify_std (GFC_STD_F2003, \"PUBLIC function %qs at \"\n+\t\t      \"%L of PRIVATE type %qs\", sym->name,\n \t\t      &sym->declared_at, sym->ts.u.derived->name);\n     }\n \n@@ -14636,7 +14636,7 @@ resolve_fntype (gfc_namespace *ns)\n \t    && !gfc_set_default_type (el->sym, 0, NULL)\n \t    && !el->sym->attr.untyped)\n \t  {\n-\t    gfc_error (\"ENTRY '%s' at %L has no IMPLICIT type\",\n+\t    gfc_error (\"ENTRY %qs at %L has no IMPLICIT type\",\n \t\t       el->sym->name, &el->sym->declared_at);\n \t    el->sym->attr.untyped = 1;\n \t  }\n@@ -14653,7 +14653,7 @@ check_uop_procedure (gfc_symbol *sym, locus where)\n \n   if (!sym->attr.function)\n     {\n-      gfc_error (\"User operator procedure '%s' at %L must be a FUNCTION\",\n+      gfc_error (\"User operator procedure %qs at %L must be a FUNCTION\",\n \t\t sym->name, &where);\n       return false;\n     }\n@@ -14663,15 +14663,15 @@ check_uop_procedure (gfc_symbol *sym, locus where)\n       && !(sym->result && sym->result->ts.u.cl\n \t   && sym->result->ts.u.cl->length))\n     {\n-      gfc_error (\"User operator procedure '%s' at %L cannot be assumed \"\n+      gfc_error (\"User operator procedure %qs at %L cannot be assumed \"\n \t\t \"character length\", sym->name, &where);\n       return false;\n     }\n \n   formal = gfc_sym_get_dummy_args (sym);\n   if (!formal || !formal->sym)\n     {\n-      gfc_error (\"User operator procedure '%s' at %L must have at least \"\n+      gfc_error (\"User operator procedure %qs at %L must have at least \"\n \t\t \"one argument\", sym->name, &where);\n       return false;\n     }\n@@ -14785,7 +14785,7 @@ resolve_types (gfc_namespace *ns)\n   for (n = ns->contained; n; n = n->sibling)\n     {\n       if (gfc_pure (ns->proc_name) && !gfc_pure (n->proc_name))\n-\tgfc_error (\"Contained procedure '%s' at %L of a PURE procedure must \"\n+\tgfc_error (\"Contained procedure %qs at %L of a PURE procedure must \"\n \t\t   \"also be PURE\", n->proc_name->name,\n \t\t   &n->proc_name->declared_at);\n "}, {"sha": "32d44ca503646b12c3a3dbcfdadbae77f5094bd5", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -6928,7 +6928,7 @@ gfc_convert_char_constant (gfc_expr *e, bt type ATTRIBUTE_UNUSED, int kind)\n \tif (!gfc_check_character_range (result->value.character.string[i],\n \t\t\t\t\tkind))\n \t  {\n-\t    gfc_error (\"Character '%s' in string at %L cannot be converted \"\n+\t    gfc_error (\"Character %qs in string at %L cannot be converted \"\n \t\t       \"into character kind %d\",\n \t\t       gfc_print_wide_char (result->value.character.string[i]),\n \t\t       &e->where, kind);"}, {"sha": "a39d4140b4ab433a8ac0fdd5106502397629074f", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -165,7 +165,7 @@ gfc_add_new_implicit_range (int c1, int c2)\n     {\n       if (new_flag[i])\n \t{\n-\t  gfc_error (\"Letter '%c' already set in IMPLICIT statement at %C\",\n+\t  gfc_error (\"Letter %<%c%> already set in IMPLICIT statement at %C\",\n \t\t     i + 'A');\n \t  return false;\n \t}\n@@ -253,7 +253,7 @@ gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n     {\n       if (error_flag && !sym->attr.untyped)\n \t{\n-\t  gfc_error (\"Symbol '%s' at %L has no IMPLICIT type\",\n+\t  gfc_error (\"Symbol %qs at %L has no IMPLICIT type\",\n \t\t     sym->name, &sym->declared_at);\n \t  sym->attr.untyped = 1; /* Ensure we only give an error once.  */\n \t}\n@@ -330,7 +330,7 @@ gfc_check_function_type (gfc_namespace *ns)\n \t}\n       else if (!proc->result->attr.proc_pointer)\n \t{\n-\t  gfc_error (\"Function result '%s' at %L has no IMPLICIT type\",\n+\t  gfc_error (\"Function result %qs at %L has no IMPLICIT type\",\n \t\t     proc->result->name, &proc->result->declared_at);\n \t  proc->result->attr.untyped = 1;\n \t}\n@@ -772,7 +772,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     gfc_error (\"%s attribute conflicts with %s attribute at %L\",\n \t       a1, a2, where);\n   else\n-    gfc_error (\"%s attribute conflicts with %s attribute in '%s' at %L\",\n+    gfc_error (\"%s attribute conflicts with %s attribute in %qs at %L\",\n \t       a1, a2, name, where);\n \n   return false;\n@@ -787,7 +787,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   else\n     {\n       return gfc_notify_std (standard, \"%s attribute \"\n-\t\t\t     \"with %s attribute in '%s' at %L\",\n+\t\t\t     \"with %s attribute in %qs at %L\",\n                              a1, a2, name, where);\n     }\n }\n@@ -917,7 +917,7 @@ gfc_add_codimension (symbol_attribute *attr, const char *name, locus *where)\n   if (attr->flavor == FL_PROCEDURE && attr->if_source == IFSRC_IFBODY\n       && !gfc_find_state (COMP_INTERFACE))\n     {\n-      gfc_error (\"CODIMENSION specified for '%s' outside its INTERFACE body \"\n+      gfc_error (\"CODIMENSION specified for %qs outside its INTERFACE body \"\n \t\t \"at %L\", name, where);\n       return false;\n     }\n@@ -943,7 +943,7 @@ gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)\n   if (attr->flavor == FL_PROCEDURE && attr->if_source == IFSRC_IFBODY\n       && !gfc_find_state (COMP_INTERFACE))\n     {\n-      gfc_error (\"DIMENSION specified for '%s' outside its INTERFACE body \"\n+      gfc_error (\"DIMENSION specified for %qs outside its INTERFACE body \"\n \t\t \"at %L\", name, where);\n       return false;\n     }\n@@ -1502,7 +1502,7 @@ gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,\n \twhere = &gfc_current_locus;\n \n       if (name)\n-        gfc_error (\"%s attribute of '%s' conflicts with %s attribute at %L\",\n+        gfc_error (\"%s attribute of %qs conflicts with %s attribute at %L\",\n \t\t   gfc_code2string (flavors, attr->flavor), name,\n \t\t   gfc_code2string (flavors, f), where);\n       else\n@@ -1660,14 +1660,14 @@ gfc_add_explicit_interface (gfc_symbol *sym, ifsrc source,\n   if (sym->attr.if_source != IFSRC_UNKNOWN\n       && sym->attr.if_source != IFSRC_DECL)\n     {\n-      gfc_error (\"Symbol '%s' at %L already has an explicit interface\",\n+      gfc_error (\"Symbol %qs at %L already has an explicit interface\",\n \t\t sym->name, where);\n       return false;\n     }\n \n   if (source == IFSRC_IFBODY && (sym->attr.dimension || sym->attr.allocatable))\n     {\n-      gfc_error (\"'%s' at %L has attributes specified outside its INTERFACE \"\n+      gfc_error (\"%qs at %L has attributes specified outside its INTERFACE \"\n \t\t \"body\", sym->name, where);\n       return false;\n     }\n@@ -1724,7 +1724,7 @@ gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)\n       || (flavor == FL_PROCEDURE && sym->attr.subroutine)\n       || flavor == FL_DERIVED || flavor == FL_NAMELIST)\n     {\n-      gfc_error (\"Symbol '%s' at %L cannot have a type\", sym->name, where);\n+      gfc_error (\"Symbol %qs at %L cannot have a type\", sym->name, where);\n       return false;\n     }\n \n@@ -1991,7 +1991,7 @@ gfc_use_derived (gfc_symbol *sym)\n \n   if (gfc_find_symbol (sym->name, sym->ns->parent, 1, &s))\n     {\n-      gfc_error (\"Symbol '%s' at %C is ambiguous\", sym->name);\n+      gfc_error (\"Symbol %qs at %C is ambiguous\", sym->name);\n       return NULL;\n     }\n \n@@ -2023,7 +2023,7 @@ gfc_use_derived (gfc_symbol *sym)\n   return s;\n \n bad:\n-  gfc_error (\"Derived type '%s' at %C is being used before it is defined\",\n+  gfc_error (\"Derived type %qs at %C is being used before it is defined\",\n \t     sym->name);\n   return NULL;\n }\n@@ -3979,15 +3979,15 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n   /* Make sure we don't have conflicts with the attributes.  */\n   if (derived_sym->attr.access == ACCESS_PRIVATE)\n     {\n-      gfc_error (\"Derived type '%s' at %L cannot be declared with both \"\n+      gfc_error (\"Derived type %qs at %L cannot be declared with both \"\n                  \"PRIVATE and BIND(C) attributes\", derived_sym->name,\n                  &(derived_sym->declared_at));\n       retval = false;\n     }\n \n   if (derived_sym->attr.sequence != 0)\n     {\n-      gfc_error (\"Derived type '%s' at %L cannot have the SEQUENCE \"\n+      gfc_error (\"Derived type %qs at %L cannot have the SEQUENCE \"\n                  \"attribute because it is BIND(C)\", derived_sym->name,\n                  &(derived_sym->declared_at));\n       retval = false;\n@@ -4467,12 +4467,12 @@ gfc_check_symbol_typed (gfc_symbol* sym, gfc_namespace* ns,\n     {\n       if (strict)\n \t{\n-\t  gfc_error (\"Symbol '%s' is used before it is typed at %L\",\n+\t  gfc_error (\"Symbol %qs is used before it is typed at %L\",\n \t\t     sym->name, &where);\n \t  return false;\n \t}\n \n-      if (!gfc_notify_std (GFC_STD_GNU, \"Symbol '%s' is used before\"\n+      if (!gfc_notify_std (GFC_STD_GNU, \"Symbol %qs is used before\"\n \t\t\t   \" it is typed at %L\", sym->name, &where))\n \treturn false;\n     }"}, {"sha": "1c54ef47c6be85bad67a43c9e21d552ec76ea4c4", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -1041,7 +1041,7 @@ align_segment (unsigned HOST_WIDE_INT *palign)\n \t  if (this_offset & (max_align - 1))\n \t    {\n \t      /* Aligning this field would misalign a previous field.  */\n-\t      gfc_error (\"The equivalence set for variable '%s' \"\n+\t      gfc_error (\"The equivalence set for variable %qs \"\n \t\t\t \"declared at %L violates alignment requirements\",\n \t\t\t s->sym->name, &s->sym->declared_at);\n \t    }\n@@ -1106,8 +1106,8 @@ translate_common (gfc_common_head *common, gfc_symbol *var_list)\n \t  /* Verify that it ended up where we expect it.  */\n \t  if (s->offset != current_offset)\n \t    {\n-\t      gfc_error (\"Equivalence for '%s' does not match ordering of \"\n-\t\t\t \"COMMON '%s' at %L\", sym->name,\n+\t      gfc_error (\"Equivalence for %qs does not match ordering of \"\n+\t\t\t \"COMMON %qs at %L\", sym->name,\n \t\t\t common->name, &common->where);\n \t    }\n \t}\n@@ -1121,8 +1121,8 @@ translate_common (gfc_common_head *common, gfc_symbol *var_list)\n \t  add_equivalences (&saw_equiv);\n \n \t  if (current_segment->offset < 0)\n-\t    gfc_error (\"The equivalence set for '%s' cause an invalid \"\n-\t\t       \"extension to COMMON '%s' at %L\", sym->name,\n+\t    gfc_error (\"The equivalence set for %qs cause an invalid \"\n+\t\t       \"extension to COMMON %qs at %L\", sym->name,\n \t\t       common->name, &common->where);\n \n \t  if (gfc_option.flag_align_commons)"}, {"sha": "bd3962ecf71497d154e40b0ec78257373b5bfc0f", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -1468,7 +1468,7 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n \t{\n \t  if (wi::ltu_p (dim_arg, 1)\n \t      || wi::gtu_p (dim_arg, GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))))\n-\t    gfc_error (\"'dim' argument of %s intrinsic at %L is not a valid \"\n+\t    gfc_error (\"%<dim%> argument of %s intrinsic at %L is not a valid \"\n \t\t       \"dimension index\", expr->value.function.isym->name,\n \t\t       &expr->where);\n \t}\n@@ -1854,7 +1854,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       if (((!as || as->type != AS_ASSUMED_RANK)\n \t   && wi::geu_p (bound, GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))))\n \t  || wi::gtu_p (bound, GFC_MAX_DIMENSIONS))\n-\tgfc_error (\"'dim' argument of %s intrinsic at %L is not a valid \"\n+\tgfc_error (\"%<dim%> argument of %s intrinsic at %L is not a valid \"\n \t\t   \"dimension index\", upper ? \"UBOUND\" : \"LBOUND\",\n \t\t   &expr->where);\n     }\n@@ -2050,7 +2050,7 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n \t{\n \t  if (wi::ltu_p (bound, 1)\n \t      || wi::gtu_p (bound, GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))))\n-\t    gfc_error (\"'dim' argument of %s intrinsic at %L is not a valid \"\n+\t    gfc_error (\"%<dim%> argument of %s intrinsic at %L is not a valid \"\n \t\t       \"dimension index\", expr->value.function.isym->name,\n \t\t       &expr->where);\n \t}"}, {"sha": "81e2ad05c9266147443d00749d1dce4fe1635f49", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -1,3 +1,9 @@\n+2014-12-13  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/realloc_on_assign_21.f90: Update dg-error.\n+\t* gfortran.dg/warnings_are_errors_1.f: Ditto.\n+\t* gfortran.dg/warnings_are_errors_1.f90: Ditto.\n+\n 2014-12-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/59240"}, {"sha": "5853b78d41c242ed92c27f71aaecb234b759efa0", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_21.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_21.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_21.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_21.f90?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -9,5 +9,5 @@\n end type t\n class(t), allocatable :: var\n \n-var = t() ! { dg-error \"Assignment to an allocatable polymorphic variable at .1. requires -frealloc-lhs\" }\n+var = t() ! { dg-error \"Assignment to an allocatable polymorphic variable at .1. requires '-frealloc-lhs'\" }\n end"}, {"sha": "9c3d8ae01b775b86ea63e285c7a82d8891e2fa2a", "filename": "gcc/testsuite/gfortran.dg/warnings_are_errors_1.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarnings_are_errors_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarnings_are_errors_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarnings_are_errors_1.f?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -13,7 +13,7 @@ program warnings_are_errors_1\n !\n 34 5   i=0 \n ! gfc_notify_std(GFC_STD_F95_DEL):\n-       do r1 = 1, 2 ! { dg-warning \"Deleted feature: Loop variable\" }\n+       do r1 = 1, 2 ! { dg-error \"Deleted feature: Loop variable\" }\n          i = i+1\n        end do\n        call foo j bar"}, {"sha": "6fcd29adebd84818b43596e3ab515e3369d70f8c", "filename": "gcc/testsuite/gfortran.dg/warnings_are_errors_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarnings_are_errors_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d9b2212cbf2912387c215da744c217de80f5d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarnings_are_errors_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwarnings_are_errors_1.f90?ref=a4d9b2212cbf2912387c215da744c217de80f5d2", "patch": "@@ -5,7 +5,7 @@\n ! free-form tests\n \n ! gfc_notify_std:\n-       function char_ (ch) ! { dg-warning \"Obsolescent feature\" }\n+       function char_ (ch) ! { dg-error \"Obsolescent feature\" }\n        character(*) :: char_, ch\n         char_ = ch\n        end function char_"}]}