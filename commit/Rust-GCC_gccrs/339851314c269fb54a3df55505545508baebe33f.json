{"sha": "339851314c269fb54a3df55505545508baebe33f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM5ODUxMzE0YzI2OWZiNTRhM2RmNTU1MDU1NDU1MDhiYWViZTMzZg==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2018-12-03T15:49:56Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-12-03T15:49:56Z"}, "message": "[Ada] Fixes for various wrong and missing error messages on ACATS B85100[567]\n\nGNAT was missing errors as well as issuing messages on legal lines in\nnew ACATS tests for illegal renamings of discriminant-dependent\ncomponents. Cases that are fixed include object names involving\nqualified expressions, dereference cases, and generic formal access and\nformal derived types. Better implements the \"known to be constrained\"\nrules in the Ada RM.\n\nTested by new ACATS tests B85100[567] that are soon to be released.\n\n2018-12-03  Gary Dismukes  <dismukes@adacore.com>\n\ngcc/ada/\n\n\t* sem_aux.adb (Object_Type_Has_Constrained_Partial_View): Return\n\tTrue for an untagged discriminated formal derived type when\n\treferenced within a generic body (augments existing test for\n\tformal private types).\n\t* sem_util.adb (Is_Dependent_Component_Of_Mutable_Type): If the\n\tprefix of the name is a qualified expression, retrieve the\n\toperand of that. Add a test of whether the (possible)\n\tdereference prefix is a variable, and also test whether that\n\tprefix might just be of an access type (occurs in some implicit\n\tdereference cases) rather than being an explicit dereference.\n\tRetrieve the Original_Node of the object name's main prefix and\n\thandle the possibility of that being a qualified expression.\n\tRemove special-case code for explicit dereferences that don't\n\tcome from source. Add test for the renaming not being within a\n\tgeneric body for proper determination of whether a formal access\n\ttype is known to be constrained (it is within a generic spec,\n\tbut not in the body).  Fix an existing incorrect test for\n\trenaming of a discriminant-dependent component of a untagged\n\tgeneric formal type being within a generic body, adding test of\n\ttaggedness and calling In_Generic_Body (now properly checks for\n\tcases where the renaming is in a nongeneric body nested within a\n\tgeneric).  Return False in cases where the selector is not a\n\tcomponent (or discriminant), which can occur for\n\tprefixed-notation calls.\n\nFrom-SVN: r266759", "tree": {"sha": "f6ecaa22001984207cf63376bd87a518c9ff4f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6ecaa22001984207cf63376bd87a518c9ff4f68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/339851314c269fb54a3df55505545508baebe33f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/339851314c269fb54a3df55505545508baebe33f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/339851314c269fb54a3df55505545508baebe33f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/339851314c269fb54a3df55505545508baebe33f/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cddd902d35bfef2bf6cea89b63d6dea23e0babed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cddd902d35bfef2bf6cea89b63d6dea23e0babed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cddd902d35bfef2bf6cea89b63d6dea23e0babed"}], "stats": {"total": 107, "additions": 92, "deletions": 15}, "files": [{"sha": "b48c757b816ed057f3be79b79ed9a4bc9f8dcd2e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339851314c269fb54a3df55505545508baebe33f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339851314c269fb54a3df55505545508baebe33f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=339851314c269fb54a3df55505545508baebe33f", "patch": "@@ -1,3 +1,30 @@\n+2018-12-03  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_aux.adb (Object_Type_Has_Constrained_Partial_View): Return\n+\tTrue for an untagged discriminated formal derived type when\n+\treferenced within a generic body (augments existing test for\n+\tformal private types).\n+\t* sem_util.adb (Is_Dependent_Component_Of_Mutable_Type): If the\n+\tprefix of the name is a qualified expression, retrieve the\n+\toperand of that. Add a test of whether the (possible)\n+\tdereference prefix is a variable, and also test whether that\n+\tprefix might just be of an access type (occurs in some implicit\n+\tdereference cases) rather than being an explicit dereference.\n+\tRetrieve the Original_Node of the object name's main prefix and\n+\thandle the possibility of that being a qualified expression.\n+\tRemove special-case code for explicit dereferences that don't\n+\tcome from source. Add test for the renaming not being within a\n+\tgeneric body for proper determination of whether a formal access\n+\ttype is known to be constrained (it is within a generic spec,\n+\tbut not in the body).  Fix an existing incorrect test for\n+\trenaming of a discriminant-dependent component of a untagged\n+\tgeneric formal type being within a generic body, adding test of\n+\ttaggedness and calling In_Generic_Body (now properly checks for\n+\tcases where the renaming is in a nongeneric body nested within a\n+\tgeneric).  Return False in cases where the selector is not a\n+\tcomponent (or discriminant), which can occur for\n+\tprefixed-notation calls.\n+\n 2018-12-03  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_res.adb (Apply_Check): For array types, apply a length"}, {"sha": "80e82d2033c3c767884fcf0cd92db66bcef4bccc", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339851314c269fb54a3df55505545508baebe33f/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339851314c269fb54a3df55505545508baebe33f/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=339851314c269fb54a3df55505545508baebe33f", "patch": "@@ -1472,7 +1472,8 @@ package body Sem_Aux is\n       return Has_Constrained_Partial_View (Typ)\n         or else (In_Generic_Body (Scop)\n                   and then Is_Generic_Type (Base_Type (Typ))\n-                  and then Is_Private_Type (Base_Type (Typ))\n+                  and then (Is_Private_Type (Base_Type (Typ))\n+                             or else Is_Derived_Type (Base_Type (Typ)))\n                   and then not Is_Tagged_Type (Typ)\n                   and then not (Is_Array_Type (Typ)\n                                  and then not Is_Constrained (Typ))"}, {"sha": "cf13c246d4b8e6cf753147de3306a0c85980a433", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339851314c269fb54a3df55505545508baebe33f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339851314c269fb54a3df55505545508baebe33f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=339851314c269fb54a3df55505545508baebe33f", "patch": "@@ -14123,20 +14123,58 @@ package body Sem_Util is\n          Deref := Prefix (Deref);\n       end loop;\n \n+      --  If the prefix is a qualified expression of a variable, then function\n+      --  Is_Variable will return False for that because a qualified expression\n+      --  denotes a constant view, so we need to get the name being qualified\n+      --  so we can test below whether that's a variable (or a dereference).\n+\n+      if Nkind (Deref) = N_Qualified_Expression then\n+         Deref := Expression (Deref);\n+      end if;\n+\n       --  Ada 2005: If we have a component or slice of a dereference,\n       --  something like X.all.Y (2), and the type of X is access-to-constant,\n       --  Is_Variable will return False, because it is indeed a constant\n       --  view. But it might be a view of a variable object, so we want the\n       --  following condition to be True in that case.\n \n       if Is_Variable (Object)\n+        or else Is_Variable (Deref)\n         or else (Ada_Version >= Ada_2005\n-                  and then Nkind (Deref) = N_Explicit_Dereference)\n+                  and then (Nkind (Deref) = N_Explicit_Dereference\n+                             or else Is_Access_Type (Etype (Deref))))\n       then\n          if Nkind (Object) = N_Selected_Component then\n-            P := Prefix (Object);\n+\n+            --  If the selector is not a component, then we definitely return\n+            --  False (it could be a function selector in a prefix form call\n+            --  occurring in an iterator specification).\n+\n+            if not\n+              Ekind_In\n+                (Entity (Selector_Name (Object)), E_Component, E_Discriminant)\n+            then\n+               return False;\n+            end if;\n+\n+            --  Get the original node of the prefix in case it has been\n+            --  rewritten, which can occur, for example, in qualified\n+            --  expression cases. Also, a discriminant check on a selected\n+            --  component may be expanded into a dereference when removing\n+            --  side effects, and the subtype of the original node may be\n+            --  unconstrained.\n+\n+            P := Original_Node (Prefix (Object));\n             Prefix_Type := Etype (P);\n \n+            --  If the prefix is a qualified expression, we want to look at\n+            --  its operand.\n+\n+            if Nkind (P) = N_Qualified_Expression then\n+               P := Expression (P);\n+               Prefix_Type := Etype (P);\n+            end if;\n+\n             if Is_Entity_Name (P) then\n                if Ekind (Entity (P)) = E_Generic_In_Out_Parameter then\n                   Prefix_Type := Base_Type (Prefix_Type);\n@@ -14146,14 +14184,13 @@ package body Sem_Util is\n                   P_Aliased := True;\n                end if;\n \n-            --  A discriminant check on a selected component may be expanded\n-            --  into a dereference when removing side effects. Recover the\n-            --  original node and its type, which may be unconstrained.\n+            --  For explicit dereferences we get the access prefix so we can\n+            --  treat this similarly to implicit dereferences and examine the\n+            --  kind of the access type and its designated subtype further\n+            --  below.\n \n-            elsif Nkind (P) = N_Explicit_Dereference\n-              and then not (Comes_From_Source (P))\n-            then\n-               P := Original_Node (P);\n+            elsif Nkind (P) = N_Explicit_Dereference then\n+               P := Prefix (P);\n                Prefix_Type := Etype (P);\n \n             else\n@@ -14186,12 +14223,23 @@ package body Sem_Util is\n \n             else pragma Assert (Ada_Version >= Ada_2005);\n                if Is_Access_Type (Prefix_Type) then\n+                  --  We need to make sure we have the base subtype, in case\n+                  --  this is actually an access subtype (whose Ekind will be\n+                  --  E_Access_Subtype).\n+\n+                  Prefix_Type := Etype (Prefix_Type);\n \n                   --  If the access type is pool-specific, and there is no\n                   --  constrained partial view of the designated type, then the\n-                  --  designated object is known to be constrained.\n+                  --  designated object is known to be constrained. If it's a\n+                  --  formal access type and the renaming is in the generic\n+                  --  spec, we also treat it as pool-specific (known to be\n+                  --  constrained), but assume the worst if in the generic body\n+                  --  (see RM 3.3(23.3/3)).\n \n                   if Ekind (Prefix_Type) = E_Access_Type\n+                    and then (not Is_Generic_Type (Prefix_Type)\n+                               or else not In_Generic_Body (Current_Scope))\n                     and then not Object_Type_Has_Constrained_Partial_View\n                                    (Typ  => Designated_Type (Prefix_Type),\n                                     Scop => Current_Scope)\n@@ -14212,16 +14260,17 @@ package body Sem_Util is\n               Original_Record_Component (Entity (Selector_Name (Object)));\n \n             --  As per AI-0017, the renaming is illegal in a generic body, even\n-            --  if the subtype is indefinite.\n+            --  if the subtype is indefinite (only applies to prefixes of an\n+            --  untagged formal type, see RM 3.3 (23.11/3)).\n \n             --  Ada 2005 (AI-363): In Ada 2005 an aliased object can be mutable\n \n             if not Is_Constrained (Prefix_Type)\n               and then (Is_Definite_Subtype (Prefix_Type)\n                          or else\n-                           (Is_Generic_Type (Prefix_Type)\n-                             and then Ekind (Current_Scope) = E_Generic_Package\n-                             and then In_Package_Body (Current_Scope)))\n+                           (not Is_Tagged_Type (Prefix_Type)\n+                             and then Is_Generic_Type (Prefix_Type)\n+                             and then In_Generic_Body (Current_Scope)))\n \n               and then (Is_Declared_Within_Variant (Comp)\n                          or else Has_Discriminant_Dependent_Constraint (Comp))"}]}