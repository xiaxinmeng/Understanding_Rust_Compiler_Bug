{"sha": "82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJiODVhODVjODJjZWZkMDU5NGM4YmVjMDJhYjE3YTJhZDZlOTI4NA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-08-24T20:48:23Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-08-24T20:48:23Z"}, "message": "tree-ssa-loop-ivcanon.c: New file.\n\n\t* tree-ssa-loop-ivcanon.c: New file.\n\t* tree-ssa-loop-manip.c (create_iv): New function.\n\t* Makefile.in (tree-ssa-loop-ivcanon.o): Add.\n\t(tree-ssa-loop.o, tree-ssa-loop-manip.o): Add SCEV_H dependency.\n\t* cfgloop.c (mark_single_exit_loops): New function.\n\t(verify_loop_structure): Verify single-exit loops.\n\t* cfgloop.h (struct loop): Add single_exit field.\n\t(LOOPS_HAVE_MARKED_SINGLE_EXITS): New constant.\n\t(mark_single_exit_loops): Declare.\n\t(tree_num_loop_insns): Declare.\n\t* cfgloopmanip.c (update_single_exits_after_duplication): New function.\n\t(duplicate_loop_to_header_edge): Use it.\n\t* common.opt (fivcanon): New flag.\n\t* timevar.def (TV_TREE_LOOP_IVCANON, TV_COMPLETE_UNROLL): New timevars.\n\t* tree-cfg.c (tree_find_edge_insert_loc): Return newly created block.\n\t(bsi_commit_edge_inserts_1): Pass null to tree_find_edge_insert_loc.\n\t(bsi_insert_on_edge_immediate): New function.\n\t* tree-flow.h (bsi_insert_on_edge_immediate,\n\tcanonicalize_induction_variables, tree_unroll_loops_completely,\n\tcreate_iv): Declare.\n\t* tree-optimize.c (init_tree_optimization_passes): Add\n\tpass_iv_canon and pass_complete_unroll.\n\t* tree-pass.h (pass_iv_canon, pass_complete_unroll): Declare.\n\t* tree-scalar-evolution.c (get_loop_exit_condition,\n\tget_exit_conditions_rec, number_of_iterations_in_loop,\n\tscev_initialize): Use single_exit information.\n\t* tree-ssa-loop-niter.c (number_of_iterations_cond): Record\n\tmissing assumptions.\n\t(loop_niter_by_eval):  Return number of iterations as unsigned\n\tint.\n\t* tree-ssa-loop.c (tree_ssa_loop_init): Mark single exit loops.\n\t(tree_ssa_loop_ivcanon, gate_tree_ssa_loop_ivcanon, pass_iv_canon,\n\ttree_complete_unroll, gate_tree_complete_unroll, pass_complete_unroll):\n\tNew passes.\n\t(tree_ssa_loop_done): Call free_numbers_of_iterations_estimates.\n\t* tree-ssanames.c (make_ssa_name): Allow creating ssa name before\n\tthe defining statement is ready.\n\t* tree-vectorizer.c (vect_create_iv_simple): Removed.\n\t(vect_create_index_for_array_ref, vect_transform_loop_bound):\n\tUse create_iv.\n\t(vect_transform_loop_bound): Use single_exit information.\n\t(vect_analyze_loop_form): Cleanup bogus tests.\n\t(vectorize_loops): Do not call flow_loop_scan.\n\t* tree.h (may_negate_without_overflow_p): Declare.\n\t* fold-const.c (may_negate_without_overflow_p): Split out from ...\n\t(negate_expr_p): ... this function.\n\t(tree_expr_nonzero_p): Handle overflowed constants correctly.\n\t* doc/invoke.texi (-fivcanon): Document.\n\t* doc/passes.texi: Document canonical induction variable creation.\n\n\t* gcc.dg/tree-ssa/loop-1.c: New test.\n\nFrom-SVN: r86516", "tree": {"sha": "437eb45f8de15cfc88b0b52b021ad483bab2b80e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/437eb45f8de15cfc88b0b52b021ad483bab2b80e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/comments", "author": null, "committer": null, "parents": [{"sha": "b3c90666df0131202f02ad1e4b1101c3b9287029", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c90666df0131202f02ad1e4b1101c3b9287029", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3c90666df0131202f02ad1e4b1101c3b9287029"}], "stats": {"total": 924, "additions": 802, "deletions": 122}, "files": [{"sha": "01406c6c9402c62e66be625edc21b73c1eda712b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -1,3 +1,55 @@\n+2004-08-24  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* tree-ssa-loop-ivcanon.c: New file.\n+\t* tree-ssa-loop-manip.c (create_iv): New function.\n+\t* Makefile.in (tree-ssa-loop-ivcanon.o): Add.\n+\t(tree-ssa-loop.o, tree-ssa-loop-manip.o): Add SCEV_H dependency.\n+\t* cfgloop.c (mark_single_exit_loops): New function.\n+\t(verify_loop_structure): Verify single-exit loops.\n+\t* cfgloop.h (struct loop): Add single_exit field.\n+\t(LOOPS_HAVE_MARKED_SINGLE_EXITS): New constant.\n+\t(mark_single_exit_loops): Declare.\n+\t(tree_num_loop_insns): Declare.\n+\t* cfgloopmanip.c (update_single_exits_after_duplication): New function.\n+\t(duplicate_loop_to_header_edge): Use it.\n+\t* common.opt (fivcanon): New flag.\n+\t* timevar.def (TV_TREE_LOOP_IVCANON, TV_COMPLETE_UNROLL): New timevars.\n+\t* tree-cfg.c (tree_find_edge_insert_loc): Return newly created block.\n+\t(bsi_commit_edge_inserts_1): Pass null to tree_find_edge_insert_loc.\n+\t(bsi_insert_on_edge_immediate): New function.\n+\t* tree-flow.h (bsi_insert_on_edge_immediate,\n+\tcanonicalize_induction_variables, tree_unroll_loops_completely,\n+\tcreate_iv): Declare.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add\n+\tpass_iv_canon and pass_complete_unroll.\n+\t* tree-pass.h (pass_iv_canon, pass_complete_unroll): Declare.\n+\t* tree-scalar-evolution.c (get_loop_exit_condition,\n+\tget_exit_conditions_rec, number_of_iterations_in_loop,\n+\tscev_initialize): Use single_exit information.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_cond): Record\n+\tmissing assumptions.\n+\t(loop_niter_by_eval):  Return number of iterations as unsigned\n+\tint.\n+\t* tree-ssa-loop.c (tree_ssa_loop_init): Mark single exit loops.\n+\t(tree_ssa_loop_ivcanon, gate_tree_ssa_loop_ivcanon, pass_iv_canon,\n+\ttree_complete_unroll, gate_tree_complete_unroll, pass_complete_unroll):\n+\tNew passes.\n+\t(tree_ssa_loop_done): Call free_numbers_of_iterations_estimates.\n+\t* tree-ssanames.c (make_ssa_name): Allow creating ssa name before\n+\tthe defining statement is ready.\n+\t* tree-vectorizer.c (vect_create_iv_simple): Removed.\n+\t(vect_create_index_for_array_ref, vect_transform_loop_bound):\n+\tUse create_iv.\n+\t(vect_transform_loop_bound): Use single_exit information.\n+\t(vect_analyze_loop_form): Cleanup bogus tests.\n+\t(vectorize_loops): Do not call flow_loop_scan.\n+\t* tree.h (may_negate_without_overflow_p): Declare.\n+\t* fold-const.c (may_negate_without_overflow_p): Split out from ...\n+\t(negate_expr_p): ... this function.\n+\t(tree_expr_nonzero_p): Handle overflowed constants correctly.\n+\t* doc/invoke.texi (-fivcanon): Document.\n+\t* doc/passes.texi: Document canonical induction variable creation.\n+\n 2004-08-24  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.h (ISA_HAS_INT_CONDMOVE): Delete."}, {"sha": "4bc56d75cc7da615e65282a3f8019d2e04d7d5c5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -888,7 +888,7 @@ OBJS-common = \\\n  tree-ssa-dom.o domwalk.o tree-tailcall.o gimple-low.o tree-iterator.o\t   \\\n  tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o tree-ssa-loop.o \\\n  tree-ssa-loop-niter.o tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t   \\\n- tree-vectorizer.o\t\t\t\t\t\t \t   \\\n+ tree-vectorizer.o tree-ssa-loop-ivcanon.o\t\t\t \t   \\\n  alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t  \t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n@@ -1681,19 +1681,23 @@ tree-eh.o : tree-eh.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n tree-ssa-loop.o : tree-ssa-loop.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   tree-pass.h $(FLAGS_H) tree-inline.h\n+   tree-pass.h $(FLAGS_H) tree-inline.h $(SCEV_H)\n tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) cfgloop.h $(PARAMS_H) tree-inline.h \\\n    output.h diagnostic.h $(TM_H) coretypes.h $(TREE_DUMP_H) flags.h \\\n    tree-pass.h $(SCEV_H)\t\t \n+tree-ssa-loop-ivcanon.o : tree-ssa-loop-ivcanon.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) tree-inline.h \\\n+   output.h diagnostic.h $(TM_H) coretypes.h $(TREE_DUMP_H) flags.h \\\n+   tree-pass.h $(SCEV_H)\n tree-ssa-loop-ch.o : tree-ssa-loop-ch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) tree-inline.h \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h flags.h\n tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   tree-pass.h cfglayout.h\n+   tree-pass.h cfglayout.h $(SCEV_H)\n tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h $(PARAMS_H)\\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\"}, {"sha": "b5553d2f05ef5bb05594777fbecee219a4e25df3", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 120, "deletions": 2, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -370,6 +370,63 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n   return num_nodes;\n }\n \n+/* For each loop in the lOOPS tree that has just a single exit\n+   record the exit edge.  */\n+\n+void\n+mark_single_exit_loops (struct loops *loops)\n+{\n+  basic_block bb;\n+  edge e;\n+  struct loop *loop;\n+  unsigned i;\n+\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      loop = loops->parray[i];\n+      if (loop)\n+\tloop->single_exit = NULL;\n+    }\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      if (bb->loop_father == loops->tree_root)\n+\tcontinue;\n+      for (e = bb->succ; e; e = e->succ_next)\n+\t{\n+\t  if (e->dest == EXIT_BLOCK_PTR)\n+\t    continue;\n+\n+\t  if (flow_bb_inside_loop_p (bb->loop_father, e->dest))\n+\t    continue;\n+\n+\t  for (loop = bb->loop_father;\n+\t       loop != e->dest->loop_father;\n+\t       loop = loop->outer)\n+\t    {\n+\t      /* If we have already seen an exit, mark this by the edge that\n+\t\t surely does not occur as any exit.  */\n+\t      if (loop->single_exit)\n+\t\tloop->single_exit = ENTRY_BLOCK_PTR->succ;\n+\t      else\n+\t\tloop->single_exit = e;\n+\t    }\n+\t}\n+    }\n+\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      loop = loops->parray[i];\n+      if (!loop)\n+\tcontinue;\n+\n+      if (loop->single_exit == ENTRY_BLOCK_PTR->succ)\n+\tloop->single_exit = NULL;\n+    }\n+\n+  loops->state |= LOOPS_HAVE_MARKED_SINGLE_EXITS;\n+}\n+\n /* Find the root node of the loop pre-header extended basic block and\n    the edges along the trace from the root node to the loop header.  */\n \n@@ -1197,8 +1254,6 @@ verify_loop_structure (struct loops *loops)\n \t}\n     }\n \n-  free (sizes);\n-\n   /* Check get_loop_body.  */\n   for (i = 1; i < loops->num; i++)\n     {\n@@ -1319,8 +1374,71 @@ verify_loop_structure (struct loops *loops)\n       free (irreds);\n     }\n \n+  /* Check the single_exit.  */\n+  if (loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n+    {\n+      memset (sizes, 0, sizeof (unsigned) * loops->num);\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  if (bb->loop_father == loops->tree_root)\n+\t    continue;\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    {\n+\t      if (e->dest == EXIT_BLOCK_PTR)\n+\t\tcontinue;\n+\n+\t      if (flow_bb_inside_loop_p (bb->loop_father, e->dest))\n+\t\tcontinue;\n+\n+\t      for (loop = bb->loop_father;\n+\t\t   loop != e->dest->loop_father;\n+\t\t   loop = loop->outer)\n+\t\t{\n+\t\t  sizes[loop->num]++;\n+\t\t  if (loop->single_exit\n+\t\t      && loop->single_exit != e)\n+\t\t    {\n+\t\t      error (\"Wrong single exit %d->%d recorded for loop %d.\",\n+\t\t\t     loop->single_exit->src->index,\n+\t\t\t     loop->single_exit->dest->index,\n+\t\t\t     loop->num);\n+\t\t      error (\"Right exit is %d->%d.\",\n+\t\t\t     e->src->index, e->dest->index);\n+\t\t      err = 1;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      for (i = 1; i < loops->num; i++)\n+\t{\n+\t  loop = loops->parray[i];\n+\t  if (!loop)\n+\t    continue;\n+\n+\t  if (sizes[i] == 1\n+\t      && !loop->single_exit)\n+\t    {\n+\t      error (\"Single exit not recorded for loop %d.\", loop->num);\n+\t      err = 1;\n+\t    }\n+\n+\t  if (sizes[i] != 1\n+\t      && loop->single_exit)\n+\t    {\n+\t      error (\"Loop %d should not have single exit (%d -> %d).\",\n+\t\t     loop->num,\n+\t\t     loop->single_exit->src->index,\n+\t\t     loop->single_exit->dest->index);\n+\t      err = 1;\n+\t    }\n+\t}\n+    }\n+\n   if (err)\n     abort ();\n+\n+  free (sizes);\n }\n \n /* Returns latch edge of LOOP.  */"}, {"sha": "367851ebd361180b4da0aa4fb6e9a67649b7622a", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -185,14 +185,19 @@ struct loop\n \n   /* Upper bound on number of iterations of a loop.  */\n   struct nb_iter_bound *bounds;\n+\n+  /* If not NULL, loop has just single exit edge stored here (edges to the\n+     EXIT_BLOCK_PTR do not count.  */\n+  edge single_exit;\n };\n \n /* Flags for state of loop structure.  */\n enum\n {\n   LOOPS_HAVE_PREHEADERS = 1,\n   LOOPS_HAVE_SIMPLE_LATCHES = 2,\n-  LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS = 4\n+  LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS = 4,\n+  LOOPS_HAVE_MARKED_SINGLE_EXITS = 8\n };\n \n /* Structure to hold CFG information about natural loops within a function.  */\n@@ -258,6 +263,7 @@ extern void flow_loop_dump (const struct loop *, FILE *,\n extern int flow_loop_scan (struct loop *, int);\n extern void flow_loop_free (struct loop *);\n void mark_irreducible_loops (struct loops *);\n+void mark_single_exit_loops (struct loops *);\n extern void create_loop_notes (void);\n \n /* Loop data structure manipulation/querying.  */\n@@ -268,6 +274,7 @@ extern bool flow_loop_nested_p\t(const struct loop *, const struct loop *);\n extern bool flow_bb_inside_loop_p (const struct loop *, const basic_block);\n extern struct loop * find_common_loop (struct loop *, struct loop *);\n struct loop *superloop_at_depth (struct loop *, unsigned);\n+extern unsigned tree_num_loop_insns (struct loop *);\n extern int num_loop_insns (struct loop *);\n extern int average_num_loop_insns (struct loop *);\n extern unsigned get_loop_level (const struct loop *);"}, {"sha": "4d4005da1a94b9c409ca6a57a68bc5ce163c2ae5", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -821,6 +821,31 @@ can_duplicate_loop_p (struct loop *loop)\n   return ret;\n }\n \n+/* The NBBS blocks in BBS will get duplicated and the copies will be placed\n+   to LOOP.  Update the single_exit information in superloops of LOOP.  */\n+\n+static void\n+update_single_exits_after_duplication (basic_block *bbs, unsigned nbbs,\n+\t\t\t\t       struct loop *loop)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < nbbs; i++)\n+    bbs[i]->rbi->duplicated = 1;\n+\n+  for (; loop->outer; loop = loop->outer)\n+    {\n+      if (!loop->single_exit)\n+\tcontinue;\n+\n+      if (loop->single_exit->src->rbi->duplicated)\n+\tloop->single_exit = NULL;\n+    }\n+\n+  for (i = 0; i < nbbs; i++)\n+    bbs[i]->rbi->duplicated = 0;\n+}\n+\n \n /* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating\n    LOOPS structure and dominators.  E's destination must be LOOP header for\n@@ -964,6 +989,10 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       first_active_latch = latch;\n     }\n \n+  /* Update the information about single exits.  */\n+  if (loops->state & LOOPS_HAVE_MARKED_SINGLE_EXITS)\n+    update_single_exits_after_duplication (bbs, n, target);\n+\n   /* Record exit edge in original loop body.  */\n   if (orig && TEST_BIT (wont_exit, 0))\n     to_remove[(*n_to_remove)++] = orig;"}, {"sha": "2f615f7be538754fa7228ed15674699a549cbe96", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -472,6 +472,10 @@ finstrument-functions\n Common Report Var(flag_instrument_function_entry_exit)\n Instrument function entry and exit with profiling calls\n \n+fivcanon\n+Common Report Var(flag_ivcanon)\n+Create canonical induction variables in loops\n+\n fkeep-inline-functions\n Common Report Var(flag_keep_inline_functions)\n Generate code for functions even if they are fully inlined"}, {"sha": "0da40754606f5e7209e1aaecb2bc07182da01e99", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -316,7 +316,7 @@ Objective-C and Objective-C++ Dialects}.\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -funswitch-loops  -fold-unroll-loops  -fold-unroll-all-loops @gol\n -ftree-pre  -ftree-ccp  -ftree-dce -ftree-loop-optimize @gol\n--ftree-lim @gol\n+-ftree-lim -fivcanon @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-lrs -ftree-fre -ftree-vectorize @gol\n --param @var{name}=@var{value}\n@@ -4483,6 +4483,12 @@ operands of conditions that are invariant out of the loop, so that we can use\n just trivial invariantness analysis in loop unswitching.  The pass also includes\n store motion.\n \n+@item -fivcanon\n+Create a canonical counter for number of iterations in the loop for that\n+determining number of iterations requires complicated analysis.  Later\n+optimizations then may determine the number easily.  Useful especially\n+in connection with unrolling.\n+\n @item -ftree-sra\n Perform scalar replacement of aggregates.  This pass replaces structure\n references with scalars to prevent committing structures to memory too"}, {"sha": "9af3659c98652fd4d7dc936605fbeb466054975e", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -375,8 +375,15 @@ operands of conditions that are invariant out of the loop, so that we can use\n just trivial invariantness analysis in loop unswitching.  The pass also includes\n store motion.  The pass is implemented in @file{tree-ssa-loop-im.c}.\n \n+Canonical induction variable creation.  This pass creates a simple counter\n+for number of iterations of the loop and replaces the exit condition of the\n+loop using it, in case when a complicated analysis is necessary to determine\n+the number of iterations.  Later optimizations then may determine the number\n+easily.  The pass is implemented in @file{tree-ssa-loop-ivcanon.c}.\n+\n The optimizations also use various utility functions contained in\n-@file{cfgloop.c}, @file{cfgloopanal.c} and @file{cfgloopmanip.c}.\n+@file{tree-ssa-loop-manip.c}, @file{cfgloop.c}, @file{cfgloopanal.c} and\n+@file{cfgloopmanip.c}.\n \n @item Conditional constant propagation\n "}, {"sha": "ed6ae0f95c98e653be825a5296343258f478a2fe", "filename": "gcc/fold-const.c", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -865,14 +865,44 @@ negate_mathfn_p (enum built_in_function code)\n   return false;\n }\n \n+/* Check whether we may negate an integer constant T without causing\n+   overflow.  */\n+\n+bool\n+may_negate_without_overflow_p (tree t)\n+{\n+  unsigned HOST_WIDE_INT val;\n+  unsigned int prec;\n+  tree type;\n+\n+  if (TREE_CODE (t) != INTEGER_CST)\n+    abort ();\n+\n+  type = TREE_TYPE (t);\n+  if (TYPE_UNSIGNED (type))\n+    return false;\n+\n+  prec = TYPE_PRECISION (type);\n+  if (prec > HOST_BITS_PER_WIDE_INT)\n+    {\n+      if (TREE_INT_CST_LOW (t) != 0)\n+\treturn true;\n+      prec -= HOST_BITS_PER_WIDE_INT;\n+      val = TREE_INT_CST_HIGH (t);\n+    }\n+  else\n+    val = TREE_INT_CST_LOW (t);\n+  if (prec < HOST_BITS_PER_WIDE_INT)\n+    val &= ((unsigned HOST_WIDE_INT) 1 << prec) - 1;\n+  return val != ((unsigned HOST_WIDE_INT) 1 << (prec - 1));\n+}\n+\n /* Determine whether an expression T can be cheaply negated using\n    the function negate_expr.  */\n \n static bool\n negate_expr_p (tree t)\n {\n-  unsigned HOST_WIDE_INT val;\n-  unsigned int prec;\n   tree type;\n \n   if (t == 0)\n@@ -888,19 +918,7 @@ negate_expr_p (tree t)\n \treturn true;\n \n       /* Check that -CST will not overflow type.  */\n-      prec = TYPE_PRECISION (type);\n-      if (prec > HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  if (TREE_INT_CST_LOW (t) != 0)\n-\t    return true;\n-\t  prec -= HOST_BITS_PER_WIDE_INT;\n-\t  val = TREE_INT_CST_HIGH (t);\n-\t}\n-      else\n-\tval = TREE_INT_CST_LOW (t);\n-      if (prec < HOST_BITS_PER_WIDE_INT)\n-\tval &= ((unsigned HOST_WIDE_INT) 1 << prec) - 1;\n-      return val != ((unsigned HOST_WIDE_INT) 1 << (prec - 1));\n+      return may_negate_without_overflow_p (t);\n \n     case REAL_CST:\n     case NEGATE_EXPR:\n@@ -9615,7 +9633,10 @@ tree_expr_nonzero_p (tree t)\n \treturn tree_expr_nonzero_p (TREE_OPERAND (t, 0));\n \n     case INTEGER_CST:\n-      return !integer_zerop (t);\n+      /* We used to test for !integer_zerop here.  This does not work correctly\n+\t if TREE_CONSTANT_OVERFLOW (t).  */\n+      return (TREE_INT_CST_LOW (t) != 0\n+\t      || TREE_INT_CST_HIGH (t) != 0);\n \n     case PLUS_EXPR:\n       if (!TYPE_UNSIGNED (type) && !flag_wrapv)"}, {"sha": "23fff497d58d84e09077bae65855bab0b57b9fee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -1,3 +1,7 @@\n+2004-08-24  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-1.c: New test.\n+\n 2004-08-24  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* gcc.c-torture/compile/20040824-1.c: New test."}, {"sha": "767e935e7917cc32772502a3ee50f2c68c2e6f33", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fivcanon -funroll-loops -fdump-tree-ivcanon-details\" } */\n+\n+void xxx(void)\n+{\n+  int x = 45;\n+\n+  while (x >>= 1)\n+    foo ();\n+}\n+\n+/* We should be able to find out that the loop iterates four times and unroll it completely.  */\n+\n+/* { dg-final { scan-tree-dump-times \"Added canonical iv to loop 1, 4 iterations\" 1 \"ivcanon\"} } */\n+/* { dg-final { scan-assembler-times \"foo\" 5} } */\n+\n+"}, {"sha": "f75ebdcdbf1ed1893c9504a5fb35c89862a10208", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -83,6 +83,8 @@ DEFTIMEVAR (TV_TREE_CD_DCE\t     , \"tree aggressive DCE\")\n DEFTIMEVAR (TV_TREE_DSE\t\t     , \"tree DSE\")\n DEFTIMEVAR (TV_TREE_LOOP\t     , \"tree loop optimization\")\n DEFTIMEVAR (TV_LIM                   , \"loop invariant motion\")\n+DEFTIMEVAR (TV_TREE_LOOP_IVCANON     , \"tree canonical iv creation\")\n+DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree loop vectorization\")\n DEFTIMEVAR (TV_TREE_CH\t\t     , \"tree copy headers\")\n DEFTIMEVAR (TV_TREE_SSA_TO_NORMAL    , \"tree SSA to normal\")"}, {"sha": "dce8e4152d100bcac89b4f0be7ac723ea672a4bc", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -2837,10 +2837,12 @@ bsi_replace (const block_stmt_iterator *bsi, tree stmt, bool preserve_eh_info)\n \n    In all cases, the returned *BSI points to the correct location.  The\n    return value is true if insertion should be done after the location,\n-   or false if it should be done before the location.  */\n+   or false if it should be done before the location.  If new basic block\n+   has to be created, it is stored in *NEW_BB.  */\n \n static bool\n-tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi)\n+tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi,\n+\t\t\t   basic_block *new_bb)\n {\n   basic_block dest, src;\n   tree tmp;\n@@ -2917,6 +2919,8 @@ tree_find_edge_insert_loc (edge e, block_stmt_iterator *bsi)\n \n   /* Otherwise, create a new basic block, and split this edge.  */\n   dest = split_edge (e);\n+  if (new_bb)\n+    *new_bb = dest;\n   e = dest->pred;\n   goto restart;\n }\n@@ -2960,7 +2964,7 @@ bsi_commit_edge_inserts_1 (edge e)\n \n       PENDING_STMT (e) = NULL_TREE;\n \n-      if (tree_find_edge_insert_loc (e, &bsi))\n+      if (tree_find_edge_insert_loc (e, &bsi, NULL))\n \tbsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n       else\n \tbsi_insert_before (&bsi, stmt, BSI_NEW_STMT);\n@@ -2977,6 +2981,25 @@ bsi_insert_on_edge (edge e, tree stmt)\n   append_to_statement_list (stmt, &PENDING_STMT (e));\n }\n \n+/* Similar to bsi_insert_on_edge+bsi_commit_edge_inserts.  If new block has to\n+   be created, it is returned.  */\n+\n+basic_block\n+bsi_insert_on_edge_immediate (edge e, tree stmt)\n+{\n+  block_stmt_iterator bsi;\n+  basic_block new_bb = NULL;\n+\n+  if (PENDING_STMT (e))\n+    abort ();\n+\n+  if (tree_find_edge_insert_loc (e, &bsi, &new_bb))\n+    bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n+  else\n+    bsi_insert_before (&bsi, stmt, BSI_NEW_STMT);\n+\n+  return new_bb;\n+}\n \n /*---------------------------------------------------------------------------\n \t     Tree specific functions for CFG manipulation"}, {"sha": "909cd8a06055b8cbf83996cb3dfa0c93942e7027", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -486,6 +486,7 @@ extern basic_block label_to_block (tree);\n extern void tree_optimize_tail_calls (bool, enum tree_dump_index);\n extern edge tree_block_forwards_to (basic_block bb);\n extern void bsi_insert_on_edge (edge, tree);\n+extern basic_block bsi_insert_on_edge_immediate (edge, tree);\n extern void bsi_commit_edge_inserts (int *);\n extern void notice_special_calls (tree);\n extern void clear_special_calls (void);\n@@ -639,6 +640,8 @@ bool empty_block_p (basic_block);\n /* In tree-ssa-loop*.c  */\n \n void tree_ssa_lim (struct loops *);\n+void canonicalize_induction_variables (struct loops *);\n+void tree_unroll_loops_completely (struct loops *);\n \n void number_of_iterations_cond (tree, tree, tree, enum tree_code, tree, tree,\n \t\t\t\tstruct tree_niter_desc *);\n@@ -653,6 +656,8 @@ void rewrite_into_loop_closed_ssa (void);\n void verify_loop_closed_ssa (void);\n void loop_commit_inserts (void);\n bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n+void create_iv (tree, tree, tree, struct loop *, block_stmt_iterator *, bool,\n+\t\ttree *, tree *);\n \n /* In tree-flow-inline.h  */\n static inline int phi_arg_from_edge (tree, edge);"}, {"sha": "f14f1b07f16e34d05c3ba8250956473c80e9e7d3", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -367,7 +367,9 @@ init_tree_optimization_passes (void)\n   p = &pass_loop.sub;\n   NEXT_PASS (pass_loop_init);\n   NEXT_PASS (pass_lim);\n+  NEXT_PASS (pass_iv_canon);\n   NEXT_PASS (pass_vectorize);\n+  NEXT_PASS (pass_complete_unroll);\n   NEXT_PASS (pass_loop_done);\n   *p = NULL;\n "}, {"sha": "0609adc3a961e2dc868f0d65ebf0dc380ad35fb2", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -109,7 +109,9 @@ extern struct tree_opt_pass pass_tail_calls;\n extern struct tree_opt_pass pass_loop;\n extern struct tree_opt_pass pass_loop_init;\n extern struct tree_opt_pass pass_lim;\n+extern struct tree_opt_pass pass_iv_canon;\n extern struct tree_opt_pass pass_vectorize;\n+extern struct tree_opt_pass pass_complete_unroll;\n extern struct tree_opt_pass pass_loop_done;\n extern struct tree_opt_pass pass_ch;\n extern struct tree_opt_pass pass_ccp;"}, {"sha": "79eb3a6db2171f469c35c755dfca837d5057d1bb", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -1001,18 +1001,17 @@ tree\n get_loop_exit_condition (struct loop *loop)\n {\n   tree res = NULL_TREE;\n+  edge exit_edge = loop->single_exit;\n+\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(get_loop_exit_condition \\n  \");\n   \n-  if (loop->exit_edges)\n+  if (exit_edge)\n     {\n-      edge exit_edge;\n       tree expr;\n       \n-      exit_edge = loop->exit_edges[0];\n       expr = last_stmt (exit_edge->src);\n-      \n       if (analyzable_condition (expr))\n \tres = expr;\n     }\n@@ -1039,8 +1038,7 @@ get_exit_conditions_rec (struct loop *loop,\n   get_exit_conditions_rec (loop->inner, exit_conditions);\n   get_exit_conditions_rec (loop->next, exit_conditions);\n   \n-  flow_loop_scan (loop, LOOP_EXIT_EDGES);\n-  if (loop->num_exits == 1)\n+  if (loop->single_exit)\n     {\n       tree loop_condition = get_loop_exit_condition (loop);\n       \n@@ -2185,9 +2183,9 @@ number_of_iterations_in_loop (struct loop *loop)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(number_of_iterations_in_loop\\n\");\n   \n-  if (!loop->exit_edges)\n+  exit = loop->single_exit;\n+  if (!exit)\n     goto end;\n-  exit = loop->exit_edges[0];\n \n   if (!number_of_iterations_exit (loop, exit, &niter_desc))\n     goto end;\n@@ -2458,10 +2456,7 @@ scev_initialize (struct loops *loops)\n \n   for (i = 1; i < loops->num; i++)\n     if (loops->parray[i])\n-      {\n-\tflow_loop_scan (loops->parray[i], LOOP_EXIT_EDGES);\n-\tloops->parray[i]->nb_iterations = NULL_TREE;\n-      }\n+      loops->parray[i]->nb_iterations = NULL_TREE;\n }\n \n /* Cleans up the information cached by the scalar evolutions analysis.  */"}, {"sha": "67c599856c6a1b2d4767076e99d649dfb8843373", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -0,0 +1,299 @@\n+/* Induction variable canonicalization.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* This pass detects the loops that iterate a constant number of times,\n+   adds a canonical induction variable (step -1, tested against 0) \n+   and replaces the exit test.  This enables the less powerful rtl\n+   level analysis to use this information.\n+\n+   This might spoil the code in some cases (by increasing register pressure).\n+   Note that in the case the new variable is not needed, ivopts will get rid\n+   of it, so it might only be a problem when there are no other linear induction\n+   variables.  In that case the created optimization possibilities are likely\n+   to pay up.\n+\n+   Additionally in case we detect that it is beneficial to unroll the\n+   loop completely, we do it right here to expose the optimization\n+   possibilities to the following passes.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-pass.h\"\n+#include \"ggc.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"params.h\"\n+#include \"flags.h\"\n+#include \"tree-inline.h\"\n+\n+/* Adds a canonical induction variable to LOOP iterating NITER times.  EXIT\n+   is the exit edge whose condition is replaced.  */\n+\n+static void\n+create_canonical_iv (struct loop *loop, edge exit, tree niter)\n+{\n+  edge in;\n+  tree cond, type, var;\n+  block_stmt_iterator incr_at;\n+  enum tree_code cmp;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Added canonical iv to loop %d, \", loop->num);\n+      print_generic_expr (dump_file, niter, TDF_SLIM);\n+      fprintf (dump_file, \" iterations.\\n\");\n+    }\n+\n+  cond = last_stmt (exit->src);\n+  in = exit->src->succ;\n+  if (in == exit)\n+    in = in->succ_next;\n+\n+  /* Note that we do not need to worry about overflows, since\n+     type of niter is always unsigned and all comparisons are\n+     just for equality/nonequality -- i.e. everything works\n+     with a modulo arithmetics.  */\n+\n+  type = TREE_TYPE (niter);\n+  niter = fold (build2 (PLUS_EXPR, type,\n+\t\t\tniter,\n+\t\t\tbuild_int_cst (type, 1, 0)));\n+  incr_at = bsi_last (in->src);\n+  create_iv (niter,\n+\t     fold_convert (type, integer_minus_one_node),\n+\t     NULL_TREE, loop,\n+\t     &incr_at, false, NULL, &var);\n+\n+  cmp = (exit->flags & EDGE_TRUE_VALUE) ? EQ_EXPR : NE_EXPR;\n+  COND_EXPR_COND (cond) = build2 (cmp, boolean_type_node,\n+\t\t\t\t  var,\n+\t\t\t\t  build_int_cst (type, 0, 0));\n+  modify_stmt (cond);\n+}\n+\n+/* Computes an estimated number of insns in LOOP.  */\n+\n+unsigned\n+tree_num_loop_insns (struct loop *loop)\n+{\n+  basic_block *body = get_loop_body (loop);\n+  block_stmt_iterator bsi;\n+  unsigned size = 1, i;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    for (bsi = bsi_start (body[i]); !bsi_end_p (bsi); bsi_next (&bsi))\n+      size += estimate_num_insns (bsi_stmt (bsi));\n+  free (body);\n+\n+  return size;\n+}\n+\n+/* Tries to unroll LOOP completely, i.e. NITER times.  LOOPS is the\n+   loop tree.  COMPLETELY_UNROLL is true if we should unroll the loop\n+   even if it may cause code growth.  EXIT is the exit of the loop\n+   that should be eliminated.  */\n+\n+static bool\n+try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n+\t\t\t    struct loop *loop,\n+\t\t\t    edge exit, tree niter,\n+\t\t\t    bool completely_unroll)\n+{\n+  unsigned HOST_WIDE_INT n_unroll, ninsns, max_unroll;\n+  tree old_cond, cond, dont_exit, do_exit;\n+\n+  if (loop->inner)\n+    return false;\n+\n+  if (!host_integerp (niter, 1))\n+    return false;\n+  n_unroll = tree_low_cst (niter, 1);\n+\n+  max_unroll = PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES);\n+  if (n_unroll > max_unroll)\n+    return false;\n+\n+  if (n_unroll)\n+    {\n+      if (!completely_unroll)\n+\treturn false;\n+\n+      ninsns = tree_num_loop_insns (loop);\n+\n+      if (n_unroll * ninsns\n+\t  > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS))\n+\treturn false;\n+    }\n+\n+  if (exit->flags & EDGE_TRUE_VALUE)\n+    {\n+      dont_exit = boolean_false_node;\n+      do_exit = boolean_true_node;\n+    }\n+  else\n+    {\n+      dont_exit = boolean_true_node;\n+      do_exit = boolean_false_node;\n+    }\n+  cond = last_stmt (exit->src);\n+    \n+  if (n_unroll)\n+    {\n+      if (!flag_unroll_loops)\n+\treturn false;\n+\n+      old_cond = COND_EXPR_COND (cond);\n+      COND_EXPR_COND (cond) = dont_exit;\n+      modify_stmt (cond);\n+\n+#if 0\n+      /* The necessary infrastructure is not in yet.  */\n+      if (!tree_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t\t       loops, n_unroll, NULL,\n+\t\t\t\t\t       NULL, NULL, NULL, 0))\n+#endif\n+\t{\n+\t  COND_EXPR_COND (cond) = old_cond;\n+\t  return false;\n+\t}\n+    }\n+  \n+  COND_EXPR_COND (cond) = do_exit;\n+  modify_stmt (cond);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Unrolled loop %d completely.\\n\", loop->num);\n+\n+  return true;\n+}\n+\n+/* Adds a canonical induction variable to LOOP if suitable.  LOOPS is the loops\n+   tree.  CREATE_IV is true if we may create a new iv.  COMPLETELY_UNROLL is\n+   true if we should do complete unrolling even if it may cause the code\n+   growth.  If TRY_EVAL is true, we try to determine the number of iterations\n+   of a loop by direct evaluation.  Returns true if cfg is changed.  */\n+\n+static bool\n+canonicalize_loop_induction_variables (struct loops *loops, struct loop *loop,\n+\t\t\t\t       bool create_iv, bool completely_unroll,\n+\t\t\t\t       bool try_eval)\n+{\n+  edge exit = NULL;\n+  tree niter;\n+\n+  niter = number_of_iterations_in_loop (loop);\n+  if (TREE_CODE (niter) == INTEGER_CST)\n+    {\n+      exit = loop->single_exit;\n+      if (!just_once_each_iteration_p (loop, exit->src))\n+\treturn false;\n+\n+      /* The result of number_of_iterations_in_loop is by one higher than\n+\t we expect (i.e. it returns number of executions of the exit\n+\t condition, not of the loop latch edge).  */\n+      niter = fold (build2 (MINUS_EXPR, TREE_TYPE (niter), niter,\n+\t\t\t    build_int_cst (TREE_TYPE (niter), 1, 0)));\n+    }\n+  else if (try_eval)\n+    niter = find_loop_niter_by_eval (loop, &exit);\n+\n+  if (chrec_contains_undetermined (niter)\n+      || TREE_CODE (niter) != INTEGER_CST)\n+    return false;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Loop %d iterates \", loop->num);\n+      print_generic_expr (dump_file, niter, TDF_SLIM);\n+      fprintf (dump_file, \" times.\\n\");\n+    }\n+\n+  if (try_unroll_loop_completely (loops, loop, exit, niter, completely_unroll))\n+    return true;\n+\n+  if (create_iv)\n+    create_canonical_iv (loop, exit, niter);\n+\n+  return false;\n+}\n+\n+/* The main entry point of the pass.  Adds canonical induction variables\n+   to the suitable LOOPS.  */\n+\n+void\n+canonicalize_induction_variables (struct loops *loops)\n+{\n+  unsigned i;\n+  struct loop *loop;\n+  \n+  for (i = 1; i < loops->num; i++)\n+    {\n+      loop = loops->parray[i];\n+\n+      if (loop)\n+\tcanonicalize_loop_induction_variables (loops, loop, true, false, true);\n+    }\n+\n+#if 0\n+  /* The necessary infrastructure is not in yet.  */\n+  if (changed)\n+    cleanup_tree_cfg_loop ();\n+#endif\n+}\n+\n+/* Unroll LOOPS completely if they iterate just few times.  */\n+\n+void\n+tree_unroll_loops_completely (struct loops *loops)\n+{\n+  unsigned i;\n+  struct loop *loop;\n+  bool changed = false;\n+\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      loop = loops->parray[i];\n+\n+      if (!loop)\n+\tcontinue;\n+\n+      changed |= canonicalize_loop_induction_variables (loops, loop,\n+\t\t\t\t\t\t\tfalse, true,\n+\t\t\t\t\t\t\t!flag_ivcanon);\n+    }\n+\n+#if 0\n+  /* The necessary infrastructure is not in yet.  */\n+  if (changed)\n+    cleanup_tree_cfg_loop ();\n+#endif\n+}"}, {"sha": "e096d265f21f5adba5f9ee3eddd347e777bf1843", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -37,6 +37,77 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cfglayout.h\"\n #include \"tree-scalar-evolution.h\"\n \n+/* Creates an induction variable with value BASE + STEP * iteration in LOOP.\n+   It is expected that neither BASE nor STEP are shared with other expressions\n+   (unless the sharing rules allow this).  Use VAR as a base var_decl for it\n+   (if NULL, a new temporary will be created).  The increment will occur at\n+   INCR_POS (after it if AFTER is true, before it otherwise).  The ssa versions\n+   of the variable before and after increment will be stored in VAR_BEFORE and\n+   VAR_AFTER (unless they are NULL).  */\n+\n+void\n+create_iv (tree base, tree step, tree var, struct loop *loop,\n+\t   block_stmt_iterator *incr_pos, bool after,\n+\t   tree *var_before, tree *var_after)\n+{\n+  tree stmt, initial, step1;\n+  tree vb, va;\n+  enum tree_code incr_op = PLUS_EXPR;\n+\n+  if (!var)\n+    {\n+      var = create_tmp_var (TREE_TYPE (base), \"ivtmp\");\n+      add_referenced_tmp_var (var);\n+    }\n+\n+  vb = make_ssa_name (var, NULL_TREE);\n+  if (var_before)\n+    *var_before = vb;\n+  va = make_ssa_name (var, NULL_TREE);\n+  if (var_after)\n+    *var_after = va;\n+\n+  /* For easier readability of the created code, produce MINUS_EXPRs\n+     when suitable.  */\n+  if (TREE_CODE (step) == INTEGER_CST)\n+    {\n+      if (TYPE_UNSIGNED (TREE_TYPE (step)))\n+\t{\n+\t  step1 = fold (build1 (NEGATE_EXPR, TREE_TYPE (step), step));\n+\t  if (tree_int_cst_lt (step1, step))\n+\t    {\n+\t      incr_op = MINUS_EXPR;\n+\t      step = step1;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (!tree_expr_nonnegative_p (step)\n+\t      && may_negate_without_overflow_p (step))\n+\t    {\n+\t      incr_op = MINUS_EXPR;\n+\t      step = fold (build1 (NEGATE_EXPR, TREE_TYPE (step), step));\n+\t    }\n+\t}\n+    }\n+\n+  stmt = build2 (MODIFY_EXPR, void_type_node, va,\n+\t\t build2 (incr_op, TREE_TYPE (base),\n+\t\t\t vb, step));\n+  SSA_NAME_DEF_STMT (va) = stmt;\n+  if (after)\n+    bsi_insert_after (incr_pos, stmt, BSI_NEW_STMT);\n+  else\n+    bsi_insert_before (incr_pos, stmt, BSI_NEW_STMT);\n+\n+  initial = base;\n+\n+  stmt = create_phi_node (vb, loop->header);\n+  SSA_NAME_DEF_STMT (vb) = stmt;\n+  add_phi_arg (&stmt, initial, loop_preheader_edge (loop));\n+  add_phi_arg (&stmt, va, loop_latch_edge (loop));\n+}\n+\n /* Add exit phis for the USE on EXIT.  */\n \n static void"}, {"sha": "af1fbad1090ecd19f3ed0f89ee78641e0977109b", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -367,6 +367,13 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t\t       convert (niter_type, integer_one_node));\n \t}\n \n+      assumption = fold (build2 (FLOOR_MOD_EXPR, niter_type, base1, d));\n+      assumption = fold (build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t assumption,\n+\t\t\t\t build_int_cst (niter_type, 0, 0)));\n+      assumptions = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t  assumptions, assumption));\n+\n       tmp = fold (build (EXACT_DIV_EXPR, niter_type, base1, d));\n       tmp = fold (build (MULT_EXPR, niter_type, tmp, inverse (s, bound)));\n       niter->niter = fold (build (BIT_AND_EXPR, niter_type, tmp, bound));\n@@ -877,7 +884,7 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n \t    fprintf (dump_file,\n \t\t     \"Proved that loop %d iterates %d times using brute force.\\n\",\n \t\t     loop->num, i);\n-\t  return build_int_cst (NULL_TREE, i, 0);\n+\t  return build_int_cst (unsigned_type_node, i, 0);\n \t}\n \n       for (j = 0; j < 2; j++)"}, {"sha": "5b5ec05f2b43cb180653bafe198dc01b0ebe7d32", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -101,6 +101,10 @@ tree_ssa_loop_init (void)\n   current_loops = tree_loop_optimizer_init (dump_file);\n   if (!current_loops)\n     return;\n+\n+  /* Find the loops that are exited just through a single edge.  */\n+  mark_single_exit_loops (current_loops);\n+\n   scev_initialize (current_loops);\n }\n   \n@@ -187,6 +191,72 @@ struct tree_opt_pass pass_vectorize =\n   TODO_dump_func\t\t\t/* todo_flags_finish */\n };\n \n+/* Canonical induction variable creation pass.  */\n+\n+static void\n+tree_ssa_loop_ivcanon (void)\n+{\n+  if (!current_loops)\n+    return;\n+\n+  canonicalize_induction_variables (current_loops);\n+}\n+\n+static bool\n+gate_tree_ssa_loop_ivcanon (void)\n+{\n+  return flag_ivcanon != 0;\n+}\n+\n+struct tree_opt_pass pass_iv_canon =\n+{\n+  \"ivcanon\",\t\t\t\t/* name */\n+  gate_tree_ssa_loop_ivcanon,\t\t/* gate */\n+  tree_ssa_loop_ivcanon,\t       \t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_LOOP_IVCANON,\t  \t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func                \t/* todo_flags_finish */\n+};\n+\n+/* Complete unrolling of loops.  */\n+\n+static void\n+tree_complete_unroll (void)\n+{\n+  if (!current_loops)\n+    return;\n+\n+  tree_unroll_loops_completely (current_loops);\n+}\n+\n+static bool\n+gate_tree_complete_unroll (void)\n+{\n+  return flag_unroll_loops != 0;\n+}\n+\n+struct tree_opt_pass pass_complete_unroll =\n+{\n+  \"cunroll\",\t\t\t\t/* name */\n+  gate_tree_complete_unroll,\t\t/* gate */\n+  tree_complete_unroll,\t\t       \t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_COMPLETE_UNROLL,\t  \t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func                \t/* todo_flags_finish */\n+};\n+\n /* Loop optimizer finalization.  */\n \n static void\n@@ -195,12 +265,12 @@ tree_ssa_loop_done (void)\n   if (!current_loops)\n     return;\n \n-  scev_finalize ();\n-\n #ifdef ENABLE_CHECKING\n   verify_loop_closed_ssa ();\n #endif\n \n+  free_numbers_of_iterations_estimates (current_loops);\n+  scev_finalize ();\n   loop_optimizer_finalize (current_loops,\n \t\t\t   (dump_flags & TDF_DETAILS ? dump_file : NULL));\n   current_loops = NULL;"}, {"sha": "f48c4a0de7ae149b1af6f9e2bfdce7d670e93ce6", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -182,7 +182,8 @@ make_ssa_name (tree var, tree stmt)\n #if defined ENABLE_CHECKING\n   if ((!DECL_P (var)\n        && TREE_CODE (var) != INDIRECT_REF)\n-      || (!IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (stmt)))\n+      || (stmt\n+\t  && !IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (stmt)))\n \t  && TREE_CODE (stmt) != PHI_NODE))\n     abort ();\n #endif"}, {"sha": "0e6e7cabe01df4b3eefccdaa07136a0f096b47cb", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 12, "deletions": 79, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -402,65 +402,6 @@ vect_debug_details (struct loop *loop)\n   return false;\n }\n \n-\n-/*  THIS IS A COPY OF THE FUNCTION IN TREE-SSA-IVOPTS.C, MODIFIED\n-    TO NOT USE FORCE_GIMPLE_OPERAND.  When that function is accepted\n-    into he mainline, This function can go away and be replaced by it.\n-    Creates an induction variable with value BASE + STEP * iteration in\n-    LOOP.  It is expected that neither BASE nor STEP are shared with\n-    other expressions (unless the sharing rules allow this).  Use VAR\n-    as a base var_decl for it (if NULL, a new temporary will be\n-    created).  The increment will occur at INCR_POS (after it if AFTER\n-    is true, before it otherwise).  The ssa versions of the variable\n-    before and after increment will be stored in VAR_BEFORE and\n-    VAR_AFTER (unless they are NULL).  */\n-\n-static void\n-vect_create_iv_simple (tree base, tree step, tree var, struct loop *loop,\n-\t \t\t   block_stmt_iterator *incr_pos, bool after,\n-\t \t\t   tree *var_before, tree *var_after)\n-{\n-   tree stmt, stmts, initial;\n-   tree vb, va;\n-   stmts = NULL;\n-\n-   if (!var)\n-     {\n-       var = create_tmp_var (TREE_TYPE (base), \"ivtmp\");\n-       add_referenced_tmp_var (var);\n-     }\n-\n-   vb = make_ssa_name (var, build_empty_stmt ());\n-   if (var_before)\n-     *var_before = vb;\n-   va = make_ssa_name (var, build_empty_stmt ());\n-   if (var_after)\n-     *var_after = va;\n-\n-   stmt = build (MODIFY_EXPR, void_type_node, va,\n- \t\t build (PLUS_EXPR, TREE_TYPE (base), vb, step));\n-   SSA_NAME_DEF_STMT (va) = stmt;\n-   if (after)\n-     bsi_insert_after (incr_pos, stmt, BSI_NEW_STMT);\n-   else\n-     bsi_insert_before (incr_pos, stmt, BSI_NEW_STMT);\n-\n-   /* Our base is always a GIMPLE variable, thus, we don't need to\n-      force_gimple_operand it.  */\n-   initial = base;\n-   if (stmts)\n-     {\n-       edge pe = loop_preheader_edge (loop);\n-       bsi_insert_on_edge (pe, stmts);\n-     }\n-\n-   stmt = create_phi_node (vb, loop->header);\n-   SSA_NAME_DEF_STMT (vb) = stmt;\n-   add_phi_arg (&stmt, initial, loop_preheader_edge (loop));\n-   add_phi_arg (&stmt, va, loop_latch_edge (loop));\n-}\n-\n-\n /* Function vect_get_base_decl_and_bit_offset\n    \n    Get the decl from which the data reference REF is based, \n@@ -650,10 +591,8 @@ vect_create_index_for_array_ref (tree stmt, block_stmt_iterator *bsi)\n       fprintf (dump_file, \")\");\n     }\n \n-  /* both init and step are guaranted to be gimple expressions,\n-     so we can use vect_create_iv_simple.  */\n-  vect_create_iv_simple (init, step, NULL, loop, bsi, false, \n-\t&indx_before_incr, &indx_after_incr); \n+  create_iv (init, step, NULL_TREE, loop, bsi, false, \n+\t     &indx_before_incr, &indx_after_incr); \n \n   return indx_before_incr;\n }\n@@ -1474,7 +1413,7 @@ static void\n vect_transform_loop_bound (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  edge exit_edge = loop->exit_edges[0];\n+  edge exit_edge = loop->single_exit;\n   block_stmt_iterator loop_exit_bsi = bsi_last (exit_edge->src);\n   tree indx_before_incr, indx_after_incr;\n   tree orig_cond_expr;\n@@ -1507,10 +1446,8 @@ vect_transform_loop_bound (loop_vec_info loop_vinfo)\n   if (orig_cond_expr != bsi_stmt (loop_exit_bsi))\n     abort ();\n \n-  /* both init and step are guaranted to be gimple expressions,\n-     so we can use vect_create_iv_simple.  */\n-  vect_create_iv_simple (integer_zero_node, integer_one_node, NULL_TREE, loop, \n-\t&loop_exit_bsi, false, &indx_before_incr, &indx_after_incr);\n+  create_iv (integer_zero_node, integer_one_node, NULL_TREE, loop, \n+\t     &loop_exit_bsi, false, &indx_before_incr, &indx_after_incr);\n \n   /* bsi_insert is using BSI_NEW_STMT. We need to bump it back \n      to point to the exit condition. */\n@@ -3266,21 +3203,19 @@ vect_analyze_loop_form (struct loop *loop)\n   if (vect_debug_details (loop))\n     fprintf (dump_file, \"\\n<<vect_analyze_loop_form>>\\n\");\n \n-  if (loop->level > 1\t\t/* FORNOW: inner-most loop  */\n-      || loop->num_exits > 1 || loop->num_entries > 1 || loop->num_nodes != 2\n-      || !loop->pre_header || !loop->header || !loop->latch)\n+  if (loop->inner\n+      || !loop->single_exit\n+      || loop->num_nodes != 2)\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n \t{\n \t  fprintf (dump_file, \"not vectorized: bad loop form. \");\n-\t  if (loop->level > 1)\n+\t  if (loop->inner)\n \t    fprintf (dump_file, \"nested loop.\");\n-\t  else if (loop->num_exits > 1 || loop->num_entries > 1)\n-\t    fprintf (dump_file, \"multiple entries or exits.\");\n-\t  else if (loop->num_nodes != 2 || !loop->header || !loop->latch)\n+\t  else if (!loop->single_exit)\n+\t    fprintf (dump_file, \"multiple exits.\");\n+\t  else if (loop->num_nodes != 2)\n \t    fprintf (dump_file, \"too many BBs in loop.\");\n-\t  else if (!loop->pre_header)\n-\t    fprintf (dump_file, \"no pre-header BB for loop.\");\n \t}\n \n       return NULL;\n@@ -3507,8 +3442,6 @@ vectorize_loops (struct loops *loops)\n       if (!loop)\n         continue;\n \n-      flow_loop_scan (loop, LOOP_ALL);\n-\n       loop_vinfo = vect_analyze_loop (loop);\n       loop->aux = loop_vinfo;\n "}, {"sha": "a91cd4f21fe15acffb7224f90a8cdb78d7b86e07", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b85a85c82cefd0594c8bec02ab17a2ad6e9284/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=82b85a85c82cefd0594c8bec02ab17a2ad6e9284", "patch": "@@ -2805,6 +2805,7 @@ extern HOST_WIDE_INT tree_low_cst (tree, int);\n extern int tree_int_cst_msb (tree);\n extern int tree_int_cst_sgn (tree);\n extern int tree_expr_nonnegative_p (tree);\n+extern bool may_negate_without_overflow_p (tree);\n extern tree get_inner_array_type (tree);\n \n /* From expmed.c.  Since rtl.h is included after tree.h, we can't"}]}