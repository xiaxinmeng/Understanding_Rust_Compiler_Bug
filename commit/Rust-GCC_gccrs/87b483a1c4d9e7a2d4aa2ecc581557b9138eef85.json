{"sha": "87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdiNDgzYTFjNGQ5ZTdhMmQ0YWEyZWNjNTgxNTU3YjkxMzhlZWY4NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-01-16T18:04:22Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-01-16T18:04:22Z"}, "message": "frv-protos.h: Fix comment formatting.\n\n\t* config/frv/frv-protos.h: Fix comment formatting.\n\t* config/frv/frv.c: Likewise.\n\t* config/frv/frv.h: Likewise.\n\t* config/frv/frv.md: Likewise.\n\t* config/frv/frvbegin.c: Likewise.\n\t* config/frv/frvend.c: Likewise.\n\nFrom-SVN: r75984", "tree": {"sha": "8f7eb59bdfee35b247159a0887329903f09b032f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f7eb59bdfee35b247159a0887329903f09b032f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/comments", "author": null, "committer": null, "parents": [{"sha": "1b6bfcd2ce1e9114684fdf78677edd2aa8615383", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b6bfcd2ce1e9114684fdf78677edd2aa8615383", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b6bfcd2ce1e9114684fdf78677edd2aa8615383"}], "stats": {"total": 307, "additions": 159, "deletions": 148}, "files": [{"sha": "39eaeba7dc670c8acd07a817a1795e63aef108e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "patch": "@@ -1,3 +1,12 @@\n+2004-01-16  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/frv/frv-protos.h: Fix comment formatting.\n+\t* config/frv/frv.c: Likewise.\n+\t* config/frv/frv.h: Likewise.\n+\t* config/frv/frv.md: Likewise.\n+\t* config/frv/frvbegin.c: Likewise.\n+\t* config/frv/frvend.c: Likewise.\n+\n 2004-01-16  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* system.h (LINKER_DOES_NOT_WORK_WITH_DWARF2): Poison."}, {"sha": "d664bb070f651f47c25c70a2818683ba96fa0a0b", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "patch": "@@ -23,7 +23,7 @@ Boston, MA 02111-1307, USA.  */\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n \n-/* Define global data defined in frv.c */\n+/* Define global data defined in frv.c.  */\n extern const char *frv_branch_cost_string;\t/* -mbranch-cost option */\n extern int frv_branch_cost_int;\t\t\t/* value of -mbranch_cost */\n "}, {"sha": "ae0c6bd80c69e3243ce5b335bbd6d15096802cf9", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 138, "deletions": 136, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "patch": "@@ -74,7 +74,7 @@ frv_tmp_reg_t;\n \t\t\t\t\t/* conditional expression used */\n #define REGSTATE_IF_EITHER\t(REGSTATE_IF_TRUE | REGSTATE_IF_FALSE)\n \n-/* the following is not sure in the reg_state bytes, so can have a larger value\n+/* The following is not sure in the reg_state bytes, so can have a larger value\n    than 0xff.  */\n #define REGSTATE_CONDJUMP\t0x100\t/* conditional jump done in VLIW insn */\n \n@@ -110,7 +110,7 @@ typedef struct\n rtx frv_compare_op0;\n rtx frv_compare_op1;\n \n-/* Conditional execution support gathered together in one structure */\n+/* Conditional execution support gathered together in one structure.  */\n typedef struct\n   {\n     /* Linked list of insns to add if the conditional execution conversion was\n@@ -138,13 +138,13 @@ typedef struct\n     /* Current number of temp registers available.  */\n     int cur_scratch_regs;\n \n-    /* Number of nested conditional execution blocks */\n+    /* Number of nested conditional execution blocks.  */\n     int num_nested_cond_exec;\n \n     /* Map of insns that set up constants in scratch registers.  */\n     bitmap scratch_insns_bitmap;\n \n-    /* Conditional execution test register (CC0..CC7) */\n+    /* Conditional execution test register (CC0..CC7).  */\n     rtx cr_reg;\n \n     /* Conditional execution compare register that is paired with cr_reg, so that\n@@ -159,7 +159,7 @@ typedef struct\n     rtx extra_fp_cr;\n \n     /* Previous CR used in nested if, to make sure we are dealing with the same\n-       nested if as the previous statement. */\n+       nested if as the previous statement.  */\n     rtx last_nested_if_cr;\n   }\n frv_ifcvt_t;\n@@ -169,10 +169,10 @@ static /* GTY(()) */ frv_ifcvt_t frv_ifcvt;\n /* Map register number to smallest register class.  */\n enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n-/* Map class letter into register class */\n+/* Map class letter into register class.  */\n enum reg_class reg_class_from_letter[256];\n \n-/* Cached value of frv_stack_info */\n+/* Cached value of frv_stack_info.  */\n static frv_stack_t *frv_stack_cache = (frv_stack_t *)0;\n \n /* -mbranch-cost= support */\n@@ -378,7 +378,7 @@ frv_override_options (void)\n {\n   int regno, i;\n \n-  /* Set the cpu type */\n+  /* Set the cpu type.  */\n   if (frv_cpu_string)\n     {\n       if (strcmp (frv_cpu_string, \"simple\") == 0)\n@@ -431,26 +431,26 @@ frv_override_options (void)\n   if (write_symbols == DWARF_DEBUG && flag_pic)\n     error (\"-fpic and -gdwarf are incompatible (-fpic and -g/-gdwarf-2 are fine)\");\n \n-  /* Change the branch cost value */\n+  /* Change the branch cost value.  */\n   if (frv_branch_cost_string)\n     frv_branch_cost_int = atoi (frv_branch_cost_string);\n \n-  /* Change the # of insns to be converted to conditional execution */\n+  /* Change the # of insns to be converted to conditional execution.  */\n   if (frv_condexec_insns_str)\n     frv_condexec_insns = atoi (frv_condexec_insns_str);\n \n-  /* Change # of temporary registers used to hold integer constants */\n+  /* Change # of temporary registers used to hold integer constants.  */\n   if (frv_condexec_temps_str)\n     frv_condexec_temps = atoi (frv_condexec_temps_str);\n \n-  /* Change scheduling look ahead. */\n+  /* Change scheduling look ahead.  */\n   if (frv_sched_lookahead_str)\n     frv_sched_lookahead = atoi (frv_sched_lookahead_str);\n \n   /* A C expression whose value is a register class containing hard\n      register REGNO.  In general there is more than one such class;\n      choose a class which is \"minimal\", meaning that no smaller class\n-     also contains the register. */\n+     also contains the register.  */\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     {\n@@ -862,14 +862,15 @@ frv_stack_info (void)\n   int alignment;\n   int offset;\n \n-  /* If we've already calculated the values and reload is complete, just return now */\n+  /* If we've already calculated the values and reload is complete,\n+     just return now.  */\n   if (frv_stack_cache)\n     return frv_stack_cache;\n \n-  /* Zero all fields */\n+  /* Zero all fields.  */\n   info = zero_info;\n \n-  /* Set up the register range information */\n+  /* Set up the register range information.  */\n   info_ptr->regs[STACK_REGS_GPR].name         = \"gpr\";\n   info_ptr->regs[STACK_REGS_GPR].first        = LAST_ARG_REGNUM + 1;\n   info_ptr->regs[STACK_REGS_GPR].last         = GPR_LAST;\n@@ -932,7 +933,7 @@ frv_stack_info (void)\n \t}\n     }\n \n-  /* Iterate over all of the register ranges */\n+  /* Iterate over all of the register ranges.  */\n   for (range = 0; range < STACK_REGS_MAX; range++)\n     {\n       frv_stack_regs_t *reg_ptr = &(info_ptr->regs[range]);\n@@ -942,7 +943,7 @@ frv_stack_info (void)\n       int size_2words = 0;\n       int regno;\n \n-      /* Calculate which registers need to be saved & save area size */\n+      /* Calculate which registers need to be saved & save area size.  */\n       switch (range)\n \t{\n \tdefault:\n@@ -978,9 +979,9 @@ frv_stack_info (void)\n \tcase STACK_REGS_STDARG:\n \t  if (varargs_p)\n \t    {\n-\t      /* If this is a stdarg function with a non varardic argument split\n-\t\t between registers and the stack, adjust the saved registers\n-\t\t downward */\n+\t      /* If this is a stdarg function with a non varardic\n+\t\t argument split between registers and the stack,\n+\t\t adjust the saved registers downward.  */\n \t      last -= (ADDR_ALIGN (cfun->pretend_args_size, UNITS_PER_WORD)\n \t\t       / UNITS_PER_WORD);\n \n@@ -1006,11 +1007,11 @@ frv_stack_info (void)\n \n       if (size_1word)\n \t{\n-\t  /* If this is a field, it only takes one word */\n+\t  /* If this is a field, it only takes one word.  */\n \t  if (reg_ptr->field_p)\n \t    size_1word = UNITS_PER_WORD;\n \n-\t  /* Determine which register pairs can be saved together */\n+\t  /* Determine which register pairs can be saved together.  */\n \t  else if (reg_ptr->dword_p && TARGET_DWORD)\n \t    {\n \t      for (regno = first; regno < last; regno += 2)\n@@ -1069,7 +1070,7 @@ frv_stack_info (void)\n       info_ptr->header_size = 4 * UNITS_PER_WORD;\n       info_ptr->total_size += 4 * UNITS_PER_WORD;\n \n-      /* Calculate the offsets to save normal register pairs */\n+      /* Calculate the offsets to save normal register pairs.  */\n       for (range = 0; range < STACK_REGS_MAX; range++)\n \t{\n \t  frv_stack_regs_t *reg_ptr = &(info_ptr->regs[range]);\n@@ -1091,7 +1092,7 @@ frv_stack_info (void)\n \t    }\n \t}\n \n-      /* Calculate the offsets to save normal single registers */\n+      /* Calculate the offsets to save normal single registers.  */\n       for (range = 0; range < STACK_REGS_MAX; range++)\n \t{\n \t  frv_stack_regs_t *reg_ptr = &(info_ptr->regs[range]);\n@@ -1175,7 +1176,7 @@ frv_stack_info (void)\n }\n \n \f\n-/* Print the information about the frv stack offsets, etc. when debugging. */\n+/* Print the information about the frv stack offsets, etc. when debugging.  */\n \n void\n frv_debug_stack (frv_stack_t *info)\n@@ -1237,7 +1238,7 @@ frv_debug_stack (frv_stack_t *info)\n \n /* The following variable value is TRUE if the next output insn should\n    finish cpu cycle.  In order words the insn will have packing bit\n-   (which means absence of asm code suffix `.p' on assembler. */\n+   (which means absence of asm code suffix `.p' on assembler.  */\n \n static int frv_insn_packing_flag;\n \n@@ -1635,7 +1636,7 @@ frv_expand_prologue (void)\n   if (info->stdarg_size > 0)\n     emit_insn (gen_blockage ());\n \n-  /* Set up pic register/small data register for this function. */\n+  /* Set up pic register/small data register for this function.  */\n   if (flag_pic && cfun->uses_pic_offset_table)\n     emit_insn (gen_pic_prologue (gen_rtx_REG (Pmode, PIC_REGNO),\n \t\t\t\t gen_rtx_REG (Pmode, LR_REGNO),\n@@ -1652,10 +1653,10 @@ frv_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n {\n   frv_stack_cache = (frv_stack_t *)0;\n \n-  /* zap last used registers for conditional execution.  */\n+  /* Zap last used registers for conditional execution.  */\n   memset (&frv_ifcvt.tmp_reg, 0, sizeof (frv_ifcvt.tmp_reg));\n \n-  /* release the bitmap of created insns.  */\n+  /* Release the bitmap of created insns.  */\n   BITMAP_XFREE (frv_ifcvt.scratch_insns_bitmap);\n }\n \n@@ -1785,7 +1786,7 @@ frv_asm_output_mi_thunk (FILE *file,\n   const char *name_jmp = reg_names[JUMP_REGNO];\n   const char *parallel = ((PACKING_FLAG_USED_P ()) ? \".p\" : \"\");\n \n-  /* Do the add using an addi if possible */\n+  /* Do the add using an addi if possible.  */\n   if (IN_RANGE_P (delta, -2048, 2047))\n     fprintf (file, \"\\taddi %s,#%d,%s\\n\", name_arg0, (int) delta, name_arg0);\n   else\n@@ -1834,7 +1835,7 @@ frv_asm_output_mi_thunk (FILE *file,\n       fprintf (file, \"\\tadd %s,%s,%s\\n\", name_gppic, name_tmp, name_jmp);\n     }\n \n-  /* Jump to the function address */\n+  /* Jump to the function address.  */\n   fprintf (file, \"\\tjmpl @(%s,%s)\\n\", name_jmp, reg_names[GPR_FIRST+0]);\n }\n \n@@ -1858,7 +1859,7 @@ frv_asm_output_mi_thunk (FILE *file,\n    register can be allocated for ordinary usage, unless you mark it as a fixed\n    register.  See `FIXED_REGISTERS' for more information.  */\n \n-/* On frv, create a frame whenever we need to create stack */\n+/* On frv, create a frame whenever we need to create stack.  */\n \n int\n frv_frame_pointer_required (void)\n@@ -2085,11 +2086,11 @@ frv_expand_block_move (rtx operands[])\n   int move_bytes;\n   enum machine_mode mode;\n \n-  /* If this is not a fixed size move, just call memcpy */\n+  /* If this is not a fixed size move, just call memcpy.  */\n   if (! constp)\n     return FALSE;\n \n-  /* If this is not a fixed size alignment, abort */\n+  /* If this is not a fixed size alignment, abort.  */\n   if (GET_CODE (align_rtx) != CONST_INT)\n     abort ();\n \n@@ -2111,7 +2112,7 @@ frv_expand_block_move (rtx operands[])\n   num_reg = offset = 0;\n   for ( ; bytes > 0; (bytes -= move_bytes), (offset += move_bytes))\n     {\n-      /* Calculate the correct offset for src/dest */\n+      /* Calculate the correct offset for src/dest.  */\n       if (offset == 0)\n \t{\n \t  src_addr  = src_reg;\n@@ -2178,11 +2179,11 @@ frv_expand_block_clear (rtx operands[])\n   int clear_bytes;\n   enum machine_mode mode;\n \n-  /* If this is not a fixed size move, just call memcpy */\n+  /* If this is not a fixed size move, just call memcpy.  */\n   if (! constp)\n     return FALSE;\n \n-  /* If this is not a fixed size alignment, abort */\n+  /* If this is not a fixed size alignment, abort.  */\n   if (GET_CODE (align_rtx) != CONST_INT)\n     abort ();\n \n@@ -2203,12 +2204,12 @@ frv_expand_block_clear (rtx operands[])\n   num_reg = offset = 0;\n   for ( ; bytes > 0; (bytes -= clear_bytes), (offset += clear_bytes))\n     {\n-      /* Calculate the correct offset for src/dest */\n+      /* Calculate the correct offset for src/dest.  */\n       dest_addr = ((offset == 0)\n \t\t   ? dest_reg\n \t\t   : plus_constant (dest_reg, offset));\n \n-      /* Generate the appropriate store of gr0 */\n+      /* Generate the appropriate store of gr0.  */\n       if (bytes >= 4 && align >= 4)\n \tmode = SImode;\n       else if (bytes >= 2 && align >= 2)\n@@ -2226,12 +2227,12 @@ frv_expand_block_clear (rtx operands[])\n \n \f\n /* The following variable is used to output modifiers of assembler\n-   code of the current output insn.. */\n+   code of the current output insn.  */\n \n static rtx *frv_insn_operands;\n \n /* The following function is used to add assembler insn code suffix .p\n-   if it is necessary. */\n+   if it is necessary.  */\n \n const char *\n frv_asm_output_opcode (FILE *f, const char *ptr)\n@@ -2266,7 +2267,7 @@ frv_asm_output_opcode (FILE *f, const char *ptr)\n \n /* The following function sets up the packing bit for the current\n    output insn.  Remember that the function is not called for asm\n-   insns. */\n+   insns.  */\n \n void\n frv_final_prescan_insn (rtx insn, rtx *opvec, int noperands ATTRIBUTE_UNUSED)\n@@ -2653,7 +2654,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n     {\n \n     case '.':\n-      /* Output r0 */\n+      /* Output r0.  */\n       fputs (reg_names[GPR_R0], file);\n       break;\n \n@@ -2662,29 +2663,29 @@ frv_print_operand (FILE * file, rtx x, int code)\n       break;\n \n     case '@':\n-      /* Output small data area base register (gr16). */\n+      /* Output small data area base register (gr16).  */\n       fputs (reg_names[SDA_BASE_REG], file);\n       break;\n \n     case '~':\n-      /* Output pic register (gr17). */\n+      /* Output pic register (gr17).  */\n       fputs (reg_names[PIC_REGNO], file);\n       break;\n \n     case '*':\n-      /* Output the temporary integer CCR register */\n+      /* Output the temporary integer CCR register.  */\n       fputs (reg_names[ICR_TEMP], file);\n       break;\n \n     case '&':\n-      /* Output the temporary integer CC register */\n+      /* Output the temporary integer CC register.  */\n       fputs (reg_names[ICC_TEMP], file);\n       break;\n \n-    /* case 'a': print an address */\n+    /* case 'a': print an address.  */\n \n     case 'C':\n-      /* Print appropriate test for integer branch false operation */\n+      /* Print appropriate test for integer branch false operation.  */\n       switch (GET_CODE (x))\n \t{\n \tdefault:\n@@ -2707,7 +2708,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n        CONSTANT_ADDRESS_P(x) is not true, PRINT_OPERAND is called.  */\n \n     case 'c':\n-      /* Print appropriate test for integer branch true operation */\n+      /* Print appropriate test for integer branch true operation.  */\n       switch (GET_CODE (x))\n \t{\n \tdefault:\n@@ -2740,7 +2741,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n       break;\n \n     case 'F':\n-      /* Print appropriate test for floating point branch false operation */\n+      /* Print appropriate test for floating point branch false operation.  */\n       switch (GET_CODE (x))\n \t{\n \tdefault:\n@@ -2756,7 +2757,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n       break;\n \n     case 'f':\n-      /* Print appropriate test for floating point branch true operation */\n+      /* Print appropriate test for floating point branch true operation.  */\n       switch (GET_CODE (x))\n \t{\n \tdefault:\n@@ -2773,7 +2774,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n \n     case 'I':\n       /* Print 'i' if the operand is a constant, or is a memory reference that\n-         adds a constant */\n+         adds a constant.  */\n       if (GET_CODE (x) == MEM)\n \tx = ((GET_CODE (XEXP (x, 0)) == PLUS)\n \t     ? XEXP (XEXP (x, 0), 1)\n@@ -2794,7 +2795,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n \n     case 'i':\n       /* For jump instructions, print 'i' if the operand is a constant or\n-         is an expression that adds a constant */\n+         is an expression that adds a constant.  */\n       if (GET_CODE (x) == CONST_INT)\n         fputs (\"i\", file);\n \n@@ -2816,7 +2817,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n \tfatal_insn (\"Bad insn to frv_print_operand, 'L' modifier:\", x);\n       break;\n \n-    /* case 'l': print a LABEL_REF */\n+    /* case 'l': print a LABEL_REF.  */\n \n     case 'M':\n     case 'N':\n@@ -2860,7 +2861,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n \t}\n       break;\n \n-    /* case 'n': negate and print a constant int */\n+    /* case 'n': negate and print a constant int.  */\n \n     case 'P':\n       /* Print PIC label using operand as the number.  */\n@@ -2871,13 +2872,13 @@ frv_print_operand (FILE * file, rtx x, int code)\n       break;\n \n     case 'U':\n-      /* Print 'u' if the operand is a update load/store */\n+      /* Print 'u' if the operand is a update load/store.  */\n       if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == PRE_MODIFY)\n \tfputs (\"u\", file);\n       break;\n \n     case 'z':\n-      /* If value is 0, print gr0, otherwise it must be a register  */\n+      /* If value is 0, print gr0, otherwise it must be a register.  */\n       if (GET_CODE (x) == CONST_INT && INTVAL (x) == 0)\n \tfputs (reg_names[GPR_R0], file);\n \n@@ -2889,14 +2890,14 @@ frv_print_operand (FILE * file, rtx x, int code)\n       break;\n \n     case 'x':\n-      /* Print constant in hex */\n+      /* Print constant in hex.  */\n       if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n         {\n \t  fprintf (file, \"%s0x%.4lx\", IMMEDIATE_PREFIX, (long) value);\n \t  break;\n \t}\n \n-      /* fall through */\n+      /* Fall through.  */\n \n     case '\\0':\n       if (GET_CODE (x) == REG)\n@@ -3277,7 +3278,7 @@ frv_legitimate_address_p (enum machine_mode mode,\n       if (GET_CODE (x) != REG)\n         break;\n \n-      /* fall through */\n+      /* Fall through.  */\n \n     case REG:\n       ret = frv_regno_ok_for_base_p (REGNO (x), strict_p);\n@@ -3337,11 +3338,11 @@ frv_legitimate_address_p (enum machine_mode mode,\n \t  if (GET_CODE (x1) != REG)\n \t    break;\n \n-\t  /* fall through */\n+\t  /* Fall through.  */\n \n \tcase REG:\n-\t  /* Do not allow reg+reg addressing for modes > 1 word if we can't depend\n-\t     on having move double instructions */\n+\t  /* Do not allow reg+reg addressing for modes > 1 word if we\n+\t     can't depend on having move double instructions.  */\n \t  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n \t    ret = FALSE;\n \t  else\n@@ -3819,7 +3820,7 @@ small_data_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return FALSE;\n }\n \n-/* Return 1 if operand is a 16 bit unsigned immediate */\n+/* Return 1 if operand is a 16 bit unsigned immediate.  */\n \n int\n uint16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n@@ -3830,7 +3831,8 @@ uint16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return IN_RANGE_P (INTVAL (op), 0, 0xffff);\n }\n \n-/* Return 1 if operand is an integer constant with the bottom 16 bits clear */\n+/* Return 1 if operand is an integer constant with the bottom 16 bits\n+   clear.  */\n \n int\n upper_int16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n@@ -3841,7 +3843,7 @@ upper_int16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return ((INTVAL (op) & 0xffff) == 0);\n }\n \n-/* Return true if operand is a GPR register. */\n+/* Return true if operand is a GPR register.  */\n \n int\n integer_register_operand (rtx op, enum machine_mode mode)\n@@ -3878,7 +3880,7 @@ gpr_no_subreg_operand (rtx op, enum machine_mode mode)\n   return GPR_OR_PSEUDO_P (REGNO (op));\n }\n \n-/* Return true if operand is a FPR register. */\n+/* Return true if operand is a FPR register.  */\n \n int\n fpr_operand (rtx op, enum machine_mode mode)\n@@ -3900,7 +3902,7 @@ fpr_operand (rtx op, enum machine_mode mode)\n   return FPR_OR_PSEUDO_P (REGNO (op));\n }\n \n-/* Return true if operand is an even GPR or FPR register. */\n+/* Return true if operand is an even GPR or FPR register.  */\n \n int\n even_reg_operand (rtx op, enum machine_mode mode)\n@@ -3934,7 +3936,7 @@ even_reg_operand (rtx op, enum machine_mode mode)\n   return FALSE;\n }\n \n-/* Return true if operand is an odd GPR register. */\n+/* Return true if operand is an odd GPR register.  */\n \n int\n odd_reg_operand (rtx op, enum machine_mode mode)\n@@ -3956,7 +3958,7 @@ odd_reg_operand (rtx op, enum machine_mode mode)\n     return FALSE;\n \n   regno = REGNO (op);\n-  /* assume that reload will give us an even register */\n+  /* Assume that reload will give us an even register.  */\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     return FALSE;\n \n@@ -3969,7 +3971,7 @@ odd_reg_operand (rtx op, enum machine_mode mode)\n   return FALSE;\n }\n \n-/* Return true if operand is an even GPR register. */\n+/* Return true if operand is an even GPR register.  */\n \n int\n even_gpr_operand (rtx op, enum machine_mode mode)\n@@ -4000,7 +4002,7 @@ even_gpr_operand (rtx op, enum machine_mode mode)\n   return (((regno - GPR_FIRST) & 1) == 0);\n }\n \n-/* Return true if operand is an odd GPR register. */\n+/* Return true if operand is an odd GPR register.  */\n \n int\n odd_gpr_operand (rtx op, enum machine_mode mode)\n@@ -4022,7 +4024,7 @@ odd_gpr_operand (rtx op, enum machine_mode mode)\n     return FALSE;\n \n   regno = REGNO (op);\n-  /* assume that reload will give us an even register */\n+  /* Assume that reload will give us an even register.  */\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     return FALSE;\n \n@@ -4032,7 +4034,7 @@ odd_gpr_operand (rtx op, enum machine_mode mode)\n   return (((regno - GPR_FIRST) & 1) != 0);\n }\n \n-/* Return true if operand is a quad aligned FPR register. */\n+/* Return true if operand is a quad aligned FPR register.  */\n \n int\n quad_fpr_operand (rtx op, enum machine_mode mode)\n@@ -4063,7 +4065,7 @@ quad_fpr_operand (rtx op, enum machine_mode mode)\n   return (((regno - FPR_FIRST) & 3) == 0);\n }\n \n-/* Return true if operand is an even FPR register. */\n+/* Return true if operand is an even FPR register.  */\n \n int\n even_fpr_operand (rtx op, enum machine_mode mode)\n@@ -4094,7 +4096,7 @@ even_fpr_operand (rtx op, enum machine_mode mode)\n   return (((regno - FPR_FIRST) & 1) == 0);\n }\n \n-/* Return true if operand is an odd FPR register. */\n+/* Return true if operand is an odd FPR register.  */\n \n int\n odd_fpr_operand (rtx op, enum machine_mode mode)\n@@ -4116,7 +4118,7 @@ odd_fpr_operand (rtx op, enum machine_mode mode)\n     return FALSE;\n \n   regno = REGNO (op);\n-  /* assume that reload will give us an even register */\n+  /* Assume that reload will give us an even register.  */\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     return FALSE;\n \n@@ -4404,7 +4406,7 @@ reg_or_0_operand (rtx op, enum machine_mode mode)\n   return FALSE;\n }\n \n-/* Return true if operand is the link register */\n+/* Return true if operand is the link register.  */\n \n int\n lr_operand (rtx op, enum machine_mode mode)\n@@ -4439,7 +4441,7 @@ fpr_or_memory_operand (rtx op, enum machine_mode mode)\n \t  || frv_legitimate_memory_operand (op, mode, FALSE));\n }\n \n-/* Return true if operand is an icc register */\n+/* Return true if operand is an icc register.  */\n \n int\n icc_operand (rtx op, enum machine_mode mode)\n@@ -4456,7 +4458,7 @@ icc_operand (rtx op, enum machine_mode mode)\n   return ICC_OR_PSEUDO_P (regno);\n }\n \n-/* Return true if operand is an fcc register */\n+/* Return true if operand is an fcc register.  */\n \n int\n fcc_operand (rtx op, enum machine_mode mode)\n@@ -4473,7 +4475,7 @@ fcc_operand (rtx op, enum machine_mode mode)\n   return FCC_OR_PSEUDO_P (regno);\n }\n \n-/* Return true if operand is either an fcc or icc register */\n+/* Return true if operand is either an fcc or icc register.  */\n \n int\n cc_operand (rtx op, enum machine_mode mode)\n@@ -4493,7 +4495,7 @@ cc_operand (rtx op, enum machine_mode mode)\n   return FALSE;\n }\n \n-/* Return true if operand is an integer CCR register */\n+/* Return true if operand is an integer CCR register.  */\n \n int\n icr_operand (rtx op, enum machine_mode mode)\n@@ -4510,7 +4512,7 @@ icr_operand (rtx op, enum machine_mode mode)\n   return ICR_OR_PSEUDO_P (regno);\n }\n \n-/* Return true if operand is an fcc register */\n+/* Return true if operand is an fcc register.  */\n \n int\n fcr_operand (rtx op, enum machine_mode mode)\n@@ -4527,7 +4529,7 @@ fcr_operand (rtx op, enum machine_mode mode)\n   return FCR_OR_PSEUDO_P (regno);\n }\n \n-/* Return true if operand is either an fcc or icc register */\n+/* Return true if operand is either an fcc or icc register.  */\n \n int\n cr_operand (rtx op, enum machine_mode mode)\n@@ -4623,7 +4625,7 @@ relational_operator (rtx op, enum machine_mode mode)\n   return FALSE;\n }\n \n-/* Return true if operator is a signed integer relational operator */\n+/* Return true if operator is a signed integer relational operator.  */\n \n int\n signed_relational_operator (rtx op, enum machine_mode mode)\n@@ -4667,7 +4669,7 @@ signed_relational_operator (rtx op, enum machine_mode mode)\n   return FALSE;\n }\n \n-/* Return true if operator is a signed integer relational operator */\n+/* Return true if operator is a signed integer relational operator.  */\n \n int\n unsigned_relational_operator (rtx op, enum machine_mode mode)\n@@ -4709,7 +4711,7 @@ unsigned_relational_operator (rtx op, enum machine_mode mode)\n   return FALSE;\n }\n \n-/* Return true if operator is a floating point relational operator */\n+/* Return true if operator is a floating point relational operator.  */\n \n int\n float_relational_operator (rtx op, enum machine_mode mode)\n@@ -5068,7 +5070,7 @@ condexec_intop_cmp_operator (rtx op, enum machine_mode mode)\n   return TRUE;\n }\n \n-/* Return 1 if operand is a valid ACC register number */\n+/* Return 1 if operand is a valid ACC register number.  */\n \n int\n acc_operand (rtx op, enum machine_mode mode)\n@@ -5093,7 +5095,7 @@ acc_operand (rtx op, enum machine_mode mode)\n   return ACC_OR_PSEUDO_P (regno);\n }\n \n-/* Return 1 if operand is a valid even ACC register number */\n+/* Return 1 if operand is a valid even ACC register number.  */\n \n int\n even_acc_operand (rtx op, enum machine_mode mode)\n@@ -5118,7 +5120,7 @@ even_acc_operand (rtx op, enum machine_mode mode)\n   return (ACC_OR_PSEUDO_P (regno) && ((regno - ACC_FIRST) & 1) == 0);\n }\n \n-/* Return 1 if operand is zero or four */\n+/* Return 1 if operand is zero or four.  */\n \n int\n quad_acc_operand (rtx op, enum machine_mode mode)\n@@ -5143,7 +5145,7 @@ quad_acc_operand (rtx op, enum machine_mode mode)\n   return (ACC_OR_PSEUDO_P (regno) && ((regno - ACC_FIRST) & 3) == 0);\n }\n \n-/* Return 1 if operand is a valid ACCG register number */\n+/* Return 1 if operand is a valid ACCG register number.  */\n \n int\n accg_operand (rtx op, enum machine_mode mode)\n@@ -5197,7 +5199,7 @@ frv_emit_movsi (rtx dest, rtx src)\n       && (!reg_or_0_operand (src, SImode)\n \t     /* Virtual registers will almost always be replaced by an\n \t\tadd instruction, so expose this to CSE by copying to\n-\t\tan intermediate register */\n+\t\tan intermediate register.  */\n \t  || (GET_CODE (src) == REG\n \t      && IN_RANGE_P (REGNO (src),\n \t\t\t     FIRST_VIRTUAL_REGISTER,\n@@ -5751,7 +5753,7 @@ frv_emit_comparison (enum rtx_code test, rtx op0, rtx op1)\n   enum machine_mode cc_mode;\n   rtx cc_reg;\n \n-  /* Floating point doesn't have comparison against a constant */\n+  /* Floating point doesn't have comparison against a constant.  */\n   if (GET_MODE (op0) == CC_FPmode && GET_CODE (op1) != REG)\n     op1 = force_reg (GET_MODE (op0), op1);\n \n@@ -5892,7 +5894,7 @@ frv_emit_cond_move (rtx dest, rtx test_rtx, rtx src1, rtx src2)\n       HOST_WIDE_INT value1 = INTVAL (src1);\n       HOST_WIDE_INT value2 = INTVAL (src2);\n \n-      /* having 0 as one of the constants can be done by loading the other\n+      /* Having 0 as one of the constants can be done by loading the other\n          constant, and optionally moving in gr0.  */\n       if (value1 == 0 || value2 == 0)\n \t;\n@@ -5972,7 +5974,7 @@ frv_split_cond_move (rtx operands[])\n       HOST_WIDE_INT value1 = INTVAL (src1);\n       HOST_WIDE_INT value2 = INTVAL (src2);\n \n-      /* having 0 as one of the constants can be done by loading the other\n+      /* Having 0 as one of the constants can be done by loading the other\n          constant, and optionally moving in gr0.  */\n       if (value1 == 0)\n \t{\n@@ -6111,7 +6113,7 @@ frv_split_minmax (rtx operands[])\n \n   start_sequence ();\n \n-  /* Figure out which test to use */\n+  /* Figure out which test to use.  */\n   switch (GET_CODE (minmax))\n     {\n     default:\n@@ -6197,7 +6199,7 @@ frv_split_abs (rtx operands[])\n \t\t\t  cr_reg,\n \t\t\t  gen_rtx_fmt_ee (LT, CC_CCRmode, cc_reg, const0_rtx)));\n \n-  /* Emit the conditional negate if the value is negative */\n+  /* Emit the conditional negate if the value is negative.  */\n   emit_insn (gen_rtx_COND_EXEC (VOIDmode,\n \t\t\t\tgen_rtx_NE (CC_CCRmode, cr_reg, const0_rtx),\n \t\t\t\tgen_negsi2 (dest, src)));\n@@ -6268,7 +6270,7 @@ frv_ifcvt_add_insn (rtx pattern, rtx insn, int before_p)\n {\n   rtx link = alloc_EXPR_LIST (VOIDmode, pattern, insn);\n \n-  link->jump = before_p;\t/* mark to add this before or after insn */\n+  link->jump = before_p;\t/* Mark to add this before or after insn.  */\n   frv_ifcvt.added_insns_list = alloc_EXPR_LIST (VOIDmode, link,\n \t\t\t\t\t\tfrv_ifcvt.added_insns_list);\n \n@@ -6326,7 +6328,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n   /* Figure out which registers we can allocate for our own purposes.  Only\n      consider registers that are not preserved across function calls and are\n      not fixed.  However, allow the ICC/ICR temporary registers to be allocated\n-     if we did not need to use them in reloading other registers. */\n+     if we did not need to use them in reloading other registers.  */\n   memset (&tmp_reg->regs, 0, sizeof (tmp_reg->regs));\n   COPY_HARD_REG_SET (tmp_reg->regs, call_used_reg_set);\n   AND_COMPL_HARD_REG_SET (tmp_reg->regs, fixed_reg_set);\n@@ -6421,7 +6423,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \t\t\t\t     CLEAR_HARD_REG_BIT (tmp_reg->regs, regno);\n \t\t\t\t });\n \n-      /* loop through the insns in the block.  */\n+      /* Loop through the insns in the block.  */\n       for (;;)\n \t{\n \t  /* Mark any new registers that are created as being unavailable for\n@@ -6738,7 +6740,7 @@ frv_ifcvt_modify_multiple_tests (ce_if_block_t *ce_info,\n \n   check_insn = gen_rtx_SET (VOIDmode, new_cr, if_else);\n \n-  /* add the new check insn to the list of check insns that need to be\n+  /* Add the new check insn to the list of check insns that need to be\n      inserted.  */\n   frv_ifcvt_add_insn (check_insn, BB_END (bb), TRUE);\n \n@@ -6758,7 +6760,7 @@ frv_ifcvt_modify_multiple_tests (ce_if_block_t *ce_info,\n  fail:\n   *p_true = *p_false = NULL_RTX;\n \n-  /* If we allocated a CR register, release it. */\n+  /* If we allocated a CR register, release it.  */\n   if (new_cr)\n     {\n       CLEAR_HARD_REG_BIT (frv_ifcvt.tmp_reg.regs, REGNO (new_cr));\n@@ -6799,7 +6801,7 @@ frv_ifcvt_load_value (rtx value, rtx insn ATTRIBUTE_UNUSED)\n \t}\n     }\n \n-  /* Have we exhausted the number of registers available? */\n+  /* Have we exhausted the number of registers available?  */\n   if (num_alloc >= GPR_TEMP_NUM)\n     {\n       if (rtl_dump_file)\n@@ -7006,7 +7008,7 @@ frv_ifcvt_modify_insn (ce_if_block_t *ce_info,\n       rtx src = SET_SRC (set);\n       enum machine_mode mode = GET_MODE (dest);\n \n-      /* Check for normal binary operators */\n+      /* Check for normal binary operators.  */\n       if (mode == SImode\n \t  && (GET_RTX_CLASS (GET_CODE (src)) == '2'\n \t      || GET_RTX_CLASS (GET_CODE (src)) == 'c'))\n@@ -7559,7 +7561,7 @@ frv_adjust_field_align (tree field, int computed)\n \n       /* If this isn't a :0 field and if the previous element is a bitfield\n \t also, see if the type is different, if so, we will need to align the\n-\t bit-field to the next boundary */\n+\t bit-field to the next boundary.  */\n       if (prev\n \t  && ! DECL_PACKED (field)\n \t  && ! integer_zerop (DECL_SIZE (field))\n@@ -7679,7 +7681,7 @@ frv_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \t  else if (SPR_P (regno))\n \t    return mode == SImode;\n \n-\t  /* Fill in the table. */\n+\t  /* Fill in the table.  */\n \t  else\n \t    return 0;\n \n@@ -7754,20 +7756,20 @@ frv_legitimate_constant_p (rtx x)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n-  /* All of the integer constants are ok */\n+  /* All of the integer constants are ok.  */\n   if (GET_CODE (x) != CONST_DOUBLE)\n     return TRUE;\n \n-  /* double integer constants are ok */\n+  /* double integer constants are ok.  */\n   if (mode == VOIDmode || mode == DImode)\n     return TRUE;\n \n-  /* 0 is always ok */\n+  /* 0 is always ok.  */\n   if (x == CONST0_RTX (mode))\n     return TRUE;\n \n   /* If floating point is just emulated, allow any constant, since it will be\n-     constructed in the GPRs */\n+     constructed in the GPRs.  */\n   if (!TARGET_HAS_FPRS)\n     return TRUE;\n \n@@ -8046,7 +8048,7 @@ frv_registers_update (rtx x,\n     case REG:\n       regno = REGNO (x);\n       reg_max = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n-      /* fall through */\n+      /* Fall through.  */\n \n     reg_common:\n       if (flag & REGSTATE_MODIFIED)\n@@ -8133,7 +8135,7 @@ frv_registers_used_p (rtx x, unsigned char reg_state[], int flag)\n     default:\n       break;\n \n-      /* Skip clobber, that doesn't use the previous value */\n+      /* Skip clobber, that doesn't use the previous value.  */\n     case CLOBBER:\n       return FALSE;\n \n@@ -8198,7 +8200,7 @@ frv_registers_used_p (rtx x, unsigned char reg_state[], int flag)\n     case REG:\n       regno = REGNO (x);\n       reg_max = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n-      /* fall through */\n+      /* Fall through.  */\n \n     reg_common:\n       while (regno < reg_max)\n@@ -8219,7 +8221,7 @@ frv_registers_used_p (rtx x, unsigned char reg_state[], int flag)\n \t\t expression that governs this expression (ie, true vs. false\n \t\t for the same CC register).  If this isn't two halves of the\n \t\t same conditional expression, consider the register\n-\t\t modified. */\n+\t\t modified.  */\n \t      if (((rs_if == REGSTATE_IF_TRUE && flag_if == REGSTATE_IF_FALSE)\n \t\t   || (rs_if == REGSTATE_IF_FALSE && flag_if == REGSTATE_IF_TRUE))\n \t\t  && ((rs & REGSTATE_CC_MASK) == (flag & REGSTATE_CC_MASK)))\n@@ -8298,7 +8300,7 @@ frv_registers_set_p (rtx x, unsigned char reg_state[], int modify_p)\n \n     case COND_EXEC:\n       cond = XEXP (x, 0);\n-      /* just to be sure, make sure it is the type of cond_exec we\n+      /* Just to be sure, make sure it is the type of cond_exec we\n          expect.  */\n       if ((GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n \t  && GET_CODE (XEXP (cond, 0)) == REG\n@@ -8329,7 +8331,7 @@ frv_registers_set_p (rtx x, unsigned char reg_state[], int modify_p)\n     case REG:\n       regno = REGNO (x);\n       reg_max = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n-      /* fall through */\n+      /* Fall through.  */\n \n     reg_common:\n       if (modify_p)\n@@ -8445,7 +8447,7 @@ frv_pack_insns (void)\n \t  continue;\n \t}\n \n-      /* things like labels reset everything.  */\n+      /* Things like labels reset everything.  */\n       if (GET_RTX_CLASS (code) != 'i')\n \t{\n \t  next_start_vliw_p = TRUE;\n@@ -8499,7 +8501,7 @@ frv_pack_insns (void)\n \t     partnering sethi instruction, with which it can be packed.\n \n \t     Although output dependencies are rare they are still\n-\t     possible.  So check output dependencies in VLIW insn. */\n+\t     possible.  So check output dependencies in VLIW insn.  */\n \t  || (get_attr_type (insn) != TYPE_SETLO\n \t      && (frv_registers_used_p (PATTERN (insn),\n \t\t\t\t\treg_state,\n@@ -8526,7 +8528,7 @@ frv_pack_insns (void)\n       /* Record which registers are modified.  */\n       frv_registers_update (PATTERN (insn), reg_state, modified, &num_mod, 0);\n \n-      /* Process the death notices */\n+      /* Process the death notices.  */\n       for (link = REG_NOTES (insn);\n \t   link != NULL_RTX;\n \t   link = XEXP (link, 1))\n@@ -8568,7 +8570,7 @@ static struct builtin_description bdesc_set[] =\n   { CODE_FOR_mhdsets, \"__MHDSETS\", FRV_BUILTIN_MHDSETS, 0, 0 }\n };\n \n-/* Media intrinsics that take just one argument. */\n+/* Media intrinsics that take just one argument.  */\n \n static struct builtin_description bdesc_1arg[] =\n {\n@@ -8579,7 +8581,7 @@ static struct builtin_description bdesc_1arg[] =\n   { CODE_FOR_mabshs, \"__MABSHS\", FRV_BUILTIN_MABSHS, 0, 0 }\n };\n \n-/* Media intrinsics that take two arguments. */\n+/* Media intrinsics that take two arguments.  */\n \n static struct builtin_description bdesc_2arg[] =\n {\n@@ -8614,7 +8616,7 @@ static struct builtin_description bdesc_cut[] =\n   { CODE_FOR_mdcutssi, \"__MDCUTSSI\", FRV_BUILTIN_MDCUTSSI, 0, 0 }\n };\n \n-/* Two-argument media intrinsics with an immediate second argument. */\n+/* Two-argument media intrinsics with an immediate second argument.  */\n \n static struct builtin_description bdesc_2argimm[] =\n {\n@@ -8636,7 +8638,7 @@ static struct builtin_description bdesc_2argimm[] =\n };\n \n /* Media intrinsics that take two arguments and return void, the first argument\n-   being a pointer to 4 words in memory. */\n+   being a pointer to 4 words in memory.  */\n \n static struct builtin_description bdesc_void2arg[] =\n {\n@@ -8645,7 +8647,7 @@ static struct builtin_description bdesc_void2arg[] =\n };\n \n /* Media intrinsics that take three arguments, the first being a const_int that\n-   denotes an accumulator, and that return void. */\n+   denotes an accumulator, and that return void.  */\n \n static struct builtin_description bdesc_void3arg[] =\n {\n@@ -8689,7 +8691,7 @@ static struct builtin_description bdesc_voidacc[] =\n   { CODE_FOR_mdasaccs, \"__MDASACCS\", FRV_BUILTIN_MDASACCS, 0, 0 }\n };\n \n-/* Initialize media builtins. */\n+/* Initialize media builtins.  */\n \n static void\n frv_init_builtins (void)\n@@ -9045,7 +9047,7 @@ frv_expand_set_builtin (enum insn_code icode, tree arglist, rtx target)\n   return target;\n }\n \n-/* Expand builtins that take one operand. */\n+/* Expand builtins that take one operand.  */\n \n static rtx\n frv_expand_unop_builtin (enum insn_code icode, tree arglist, rtx target)\n@@ -9063,7 +9065,7 @@ frv_expand_unop_builtin (enum insn_code icode, tree arglist, rtx target)\n   return target;\n }\n \n-/* Expand builtins that take two operands. */\n+/* Expand builtins that take two operands.  */\n \n static rtx\n frv_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n@@ -9084,7 +9086,7 @@ frv_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n }\n \n /* Expand cut-style builtins, which take two operands and an implicit ACCG\n-   one. */\n+   one.  */\n \n static rtx\n frv_expand_cut_builtin (enum insn_code icode, tree arglist, rtx target)\n@@ -9116,7 +9118,7 @@ frv_expand_cut_builtin (enum insn_code icode, tree arglist, rtx target)\n   return target;\n }\n \n-/* Expand builtins that take two operands and the second is immediate. */\n+/* Expand builtins that take two operands and the second is immediate.  */\n \n static rtx\n frv_expand_binopimm_builtin (enum insn_code icode, tree arglist, rtx target)\n@@ -9139,7 +9141,7 @@ frv_expand_binopimm_builtin (enum insn_code icode, tree arglist, rtx target)\n }\n \n /* Expand builtins that take two operands, the first operand being a pointer to\n-   ints and return void. */\n+   ints and return void.  */\n \n static rtx\n frv_expand_voidbinop_builtin (enum insn_code icode, tree arglist)\n@@ -9315,7 +9317,7 @@ frv_expand_mwtacc_builtin (enum insn_code icode, tree arglist)\n   return NULL_RTX;\n }\n \n-/* Expand builtins. */\n+/* Expand builtins.  */\n \n static rtx\n frv_expand_builtin (tree exp,\n@@ -9381,7 +9383,7 @@ frv_expand_builtin (tree exp,\n       break;\n     }\n \n-  /* Expand unique builtins. */\n+  /* Expand unique builtins.  */\n \n   switch (fcode)\n     {\n@@ -9413,7 +9415,7 @@ frv_expand_builtin (tree exp,\n       break;\n     }\n \n-  /* Expand groups of builtins. */\n+  /* Expand groups of builtins.  */\n \n   for (i = 0, d = bdesc_set; i < ARRAY_SIZE (bdesc_set); i++, d++)\n     if (d->code == fcode)\n@@ -9499,7 +9501,7 @@ frv_rtx_costs (rtx x,\n \t  *total = 0;\n \t  return true;\n \t}\n-      /* FALLTHRU */\n+      /* Fall through.  */\n \n     case CONST:\n     case LABEL_REF:"}, {"sha": "9f85d57637d82330440719d9481276a0209e05e1", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "patch": "@@ -538,7 +538,7 @@ extern int target_flags;\n /* Define this macro if debugging can be performed even without a frame\n    pointer.  If this macro is defined, GCC will turn on the\n    `-fomit-frame-pointer' option whenever `-O' is specified.  */\n-/* Frv needs a specific frame layout that includes the frame pointer */\n+/* Frv needs a specific frame layout that includes the frame pointer.  */\n \n #define CAN_DEBUG_WITHOUT_FP\n \n@@ -2423,7 +2423,7 @@ __asm__(\"\\n\"\t\t\t\t\t\t\t\t\\\n         #define REVERSIBLE_CC_MODE(MODE)  ((MODE) != CCFPEmode)  */\n \n /* On frv, don't consider floating point comparisons to be reversible.  In\n-   theory, fp equality comparisons can be reversible */\n+   theory, fp equality comparisons can be reversible.  */\n #define REVERSIBLE_CC_MODE(MODE) ((MODE) == CCmode || (MODE) == CC_UNSmode)\n \n /* Frv CCR_MODE's are not reversible.  */"}, {"sha": "95a7590a32cf231eb47cac834fed1ce9626ef15c", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "patch": "@@ -5470,7 +5470,7 @@\n   if (GET_CODE (operands[2]) != CONST_INT)\n     abort ();\n \n-  /* If we can't generate an immediate instruction, promote to register */\n+  /* If we can't generate an immediate instruction, promote to register.  */\n   if (! IN_RANGE_P (INTVAL (range), -2048, 2047))\n     range = force_reg (SImode, range);\n \n@@ -5496,11 +5496,11 @@\n \n   emit_cmp_and_jump_insns (indx, range, GTU, NULL_RTX, SImode, 1, fail);\n \n-  /* Move the table address to a register */\n+  /* Move the table address to a register.  */\n   treg = gen_reg_rtx (Pmode);\n   emit_insn (gen_movsi (treg, gen_rtx_LABEL_REF (VOIDmode, table)));\n \n-  /* scale index-low by wordsize */\n+  /* Scale index-low by wordsize.  */\n   scale = gen_reg_rtx (SImode);\n   emit_insn (gen_ashlsi3 (scale, indx, GEN_INT (2)));\n "}, {"sha": "0e241047eaf07654ea770dc947d13d465370e835", "filename": "gcc/config/frv/frvbegin.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrvbegin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrvbegin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrvbegin.c?ref=87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "patch": "@@ -20,7 +20,7 @@\n    Boston, MA 02111-1307, USA.\n \n    This file was originally taken from the file crtstuff.c in the\n-   main compiler directory, and simplified. */\n+   main compiler directory, and simplified.  */\n \n /* As a special exception, if you link this library with other files,\n    some of which are compiled with GCC, to produce an executable,\n@@ -81,7 +81,7 @@ extern void __frv_deregister_eh(void) __attribute__((__destructor__));\n \n extern func_ptr __EH_FRAME_BEGIN__[];\n \n-/* Register the exception handling table as the first constructor */\n+/* Register the exception handling table as the first constructor.  */\n void\n __frv_register_eh (void)\n {\n@@ -93,7 +93,7 @@ __frv_register_eh (void)\n /* Note, do not declare __{,de}register_frame_info weak as it seems\n    to interfere with the pic support.  */\n \n-/* Unregister the exception handling table as a deconstructor */\n+/* Unregister the exception handling table as a deconstructor.  */\n void\n __frv_deregister_eh (void)\n {\n@@ -108,7 +108,7 @@ __frv_deregister_eh (void)\n   completed = 1;\n }\n \n-/* Run the global destructors */\n+/* Run the global destructors.  */\n void\n __do_global_dtors (void)\n {\n@@ -120,7 +120,7 @@ __do_global_dtors (void)\n     }\n }\n \n-/* Run the global constructors */\n+/* Run the global constructors.  */\n void\n __do_global_ctors (void)\n {"}, {"sha": "c12c151433b8036c3cb0b6ebef83b4576e1880dd", "filename": "gcc/config/frv/frvend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrvend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87b483a1c4d9e7a2d4aa2ecc581557b9138eef85/gcc%2Fconfig%2Ffrv%2Ffrvend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrvend.c?ref=87b483a1c4d9e7a2d4aa2ecc581557b9138eef85", "patch": "@@ -17,7 +17,7 @@\n    You should have received a copy of the GNU General Public License\n    along with GCC; see the file COPYING.  If not, write to\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA. */\n+   Boston, MA 02111-1307, USA.  */\n \n /* As a special exception, if you link this library with other files,\n    some of which are compiled with GCC, to produce an executable,"}]}