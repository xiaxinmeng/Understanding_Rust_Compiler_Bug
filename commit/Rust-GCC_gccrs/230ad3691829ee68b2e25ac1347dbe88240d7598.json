{"sha": "230ad3691829ee68b2e25ac1347dbe88240d7598", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMwYWQzNjkxODI5ZWU2OGIyZTI1YWMxMzQ3ZGJlODgyNDBkNzU5OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T09:22:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T09:22:50Z"}, "message": "[multiple changes]\n\n2016-04-18  Arnaud Charlet  <charlet@adacore.com>\n\n\t* a-sytaco.adb (Suspension_Object): Aspect Default_Initial_Condition\n\tadded.\n\n2016-04-18  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* affinity.c: Use the proper type for task id.\n\t* init.c (__gnat_inum_to_ivec): ivec is a pointer.\n\nFrom-SVN: r235101", "tree": {"sha": "a9ad53875c39dae79df606e1cc2645af0e8ff3d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9ad53875c39dae79df606e1cc2645af0e8ff3d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/230ad3691829ee68b2e25ac1347dbe88240d7598", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/230ad3691829ee68b2e25ac1347dbe88240d7598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/230ad3691829ee68b2e25ac1347dbe88240d7598", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/230ad3691829ee68b2e25ac1347dbe88240d7598/comments", "author": null, "committer": null, "parents": [{"sha": "d9d25d048f004727e491c4887a4b1460afff1c24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9d25d048f004727e491c4887a4b1460afff1c24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9d25d048f004727e491c4887a4b1460afff1c24"}], "stats": {"total": 160, "additions": 106, "deletions": 54}, "files": [{"sha": "8ebc59102553ac09a82eab27de5a010bff9c1ff5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230ad3691829ee68b2e25ac1347dbe88240d7598/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230ad3691829ee68b2e25ac1347dbe88240d7598/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=230ad3691829ee68b2e25ac1347dbe88240d7598", "patch": "@@ -1,3 +1,13 @@\n+2016-04-18  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* a-sytaco.adb (Suspension_Object): Aspect Default_Initial_Condition\n+\tadded.\n+\n+2016-04-18  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* affinity.c: Use the proper type for task id.\n+\t* init.c (__gnat_inum_to_ivec): ivec is a pointer.\n+\n 2016-04-18  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_prag.adb (Process_Convention): Relax rule on exporting"}, {"sha": "733fc764e2339f1853db6041cf3bc302f11eefe3", "filename": "gcc/ada/a-sytaco.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230ad3691829ee68b2e25ac1347dbe88240d7598/gcc%2Fada%2Fa-sytaco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230ad3691829ee68b2e25ac1347dbe88240d7598/gcc%2Fada%2Fa-sytaco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sytaco.ads?ref=230ad3691829ee68b2e25ac1347dbe88240d7598", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -44,7 +44,8 @@ is\n    pragma Preelaborate;\n    --  In accordance with Ada 2005 AI-362\n \n-   type Suspension_Object is limited private;\n+   type Suspension_Object is limited private with\n+     Default_Initial_Condition;\n \n    procedure Set_True (S : in out Suspension_Object) with\n      Global  => null,"}, {"sha": "bac8b5aec25feb0e6e1aa13c0f8359054c269de7", "filename": "gcc/ada/affinity.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230ad3691829ee68b2e25ac1347dbe88240d7598/gcc%2Fada%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230ad3691829ee68b2e25ac1347dbe88240d7598/gcc%2Fada%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faffinity.c?ref=230ad3691829ee68b2e25ac1347dbe88240d7598", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *            Copyright (C) 2005-2011, Free Software Foundation, Inc.       *\n+ *            Copyright (C) 2005-2015, Free Software Foundation, Inc.       *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -34,11 +34,11 @@\n #include \"taskLib.h\"\n #include \"cpuset.h\"\n \n-extern int __gnat_set_affinity (int tid, unsigned cpu);\n-extern int __gnat_set_affinity_mask (int tid, unsigned mask);\n+extern int __gnat_set_affinity (TASK_ID tid, unsigned cpu);\n+extern int __gnat_set_affinity_mask (TASK_ID tid, unsigned mask);\n \n int\n- __gnat_set_affinity (int tid, unsigned cpu)\n+ __gnat_set_affinity (TASK_ID tid, unsigned cpu)\n {\n   cpuset_t cpuset;\n \n@@ -48,9 +48,9 @@ int\n }\n \n int\n-__gnat_set_affinity_mask (int tid, unsigned mask)\n+__gnat_set_affinity_mask (TASK_ID tid, unsigned mask)\n {\n-  int index;\n+  unsigned index;\n   cpuset_t cpuset;\n \n   CPUSET_ZERO(cpuset);"}, {"sha": "38907a11af9af556a188daecc255d8b797a5e02a", "filename": "gcc/ada/init.c", "status": "modified", "additions": 87, "deletions": 46, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230ad3691829ee68b2e25ac1347dbe88240d7598/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230ad3691829ee68b2e25ac1347dbe88240d7598/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=230ad3691829ee68b2e25ac1347dbe88240d7598", "patch": "@@ -1714,8 +1714,11 @@ __gnat_install_handler (void)\n #include <iv.h>\n #endif\n \n-#if defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6) && !defined(__RTP__)\n+#if ((defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6)) || defined (__x86_64__)) && !defined(__RTP__)\n+#define VXWORKS_FORCE_GUARD_PAGE 1\n #include <vmLib.h>\n+extern size_t vxIntStackOverflowSize;\n+#define INT_OVERFLOW_SIZE vxIntStackOverflowSize\n #endif\n \n #ifdef VTHREADS\n@@ -1726,13 +1729,13 @@ __gnat_install_handler (void)\n \n /* Directly vectored Interrupt routines are not supported when using RTPs.  */\n \n-extern int __gnat_inum_to_ivec (int);\n+extern void * __gnat_inum_to_ivec (int);\n \n /* This is needed by the GNAT run time to handle Vxworks interrupts.  */\n-int\n+void *\n __gnat_inum_to_ivec (int num)\n {\n-  return (int) ((long) INUM_TO_IVEC ((long) num));\n+  return (void *) INUM_TO_IVEC (num);\n }\n #endif\n \n@@ -1750,6 +1753,69 @@ getpid (void)\n }\n #endif\n \n+/* When stack checking is performed by probing a guard page on the stack,\n+   sometimes this guard page is not properly reset on VxWorks. We need to\n+   manually reset it in this case.\n+   This function returns TRUE in case the guard page was hit by the\n+   signal. */\n+static int\n+__gnat_reset_guard_page (int sig, void *sc)\n+{\n+  /* On ARM VxWorks 6.x and x86_64 VxWorks 7, the guard page is left un-armed\n+     by the kernel after being violated, so subsequent violations aren't\n+     detected.\n+     So we retrieve the address of the guard page from the TCB and compare it\n+     with the page that is violated and re-arm that page if there's a match. */\n+#if defined (VXWORKS_FORCE_GUARD_PAGE)\n+\n+  /* Ignore signals that are not stack overflow signals */\n+  if (sig != SIGSEGV && sig != SIGBUS && sig != SIGILL) return FALSE;\n+\n+  /* If the target does not support guard pages, INT_OVERFLOW_SIZE will be 0 */\n+  if (INT_OVERFLOW_SIZE == 0) return FALSE;\n+\n+  TASK_ID tid           = taskIdSelf ();\n+  WIND_TCB *pTcb        = taskTcb (tid);\n+  REG_SET *pregs        = ((struct sigcontext *) sc)->sc_pregs;\n+  VIRT_ADDR guardPage   = (VIRT_ADDR) pTcb->pStackEnd - INT_OVERFLOW_SIZE;\n+  UINT stateMask        = VM_STATE_MASK_VALID;\n+  UINT state            = VM_STATE_VALID_NOT;\n+  size_t probe_distance = 0;\n+  VIRT_ADDR sigPage;\n+\n+#if defined (ARMEL)\n+  /* violating address in rip: r12 */\n+  sigPage    = pregs->r[12] & ~(INT_OVERFLOW_SIZE - 1);\n+#elif defined (__x86_64__)\n+  /* violating address in rsp. */\n+  probe_distance = 16 * 1024; /* in gcc/config/i386/vxworks7.h */\n+  sigPage    = pregs->rsp & ~(INT_OVERFLOW_SIZE - 1);\n+  stateMask |= MMU_ATTR_SPL_MSK;\n+  state     |= MMU_ATTR_NO_BLOCK;\n+#else\n+#error \"Not Implemented for this CPU\"\n+#endif\n+\n+  if (guardPage == (sigPage - probe_distance))\n+    {\n+      UINT nState;\n+      vmStateGet (NULL, guardPage, &nState);\n+      if ((nState & VM_STATE_MASK_VALID) != VM_STATE_VALID_NOT) {\n+        /* If the guard page has a valid state, we need to reset to\n+           invalid state here */\n+        vmStateSet (NULL, guardPage, INT_OVERFLOW_SIZE, stateMask, state);\n+      }\n+\n+      return TRUE;\n+    }\n+  else\n+    {\n+      return FALSE;\n+    }\n+#endif /* VXWORKS_FORCE_GUARD_PAGE */\n+  return FALSE;\n+}\n+\n /* VxWorks 653 vThreads expects the field excCnt to be zeroed when a signal is.\n    handled. The VxWorks version of longjmp does this; GCC's builtin_longjmp\n    doesn't.  */\n@@ -1766,8 +1832,7 @@ __gnat_clear_exception_count (void)\n /* Handle different SIGnal to exception mappings in different VxWorks\n    versions.  */\n void\n-__gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED,\n-\t\t   void *sc ATTRIBUTE_UNUSED)\n+__gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED, void *sc)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n@@ -1854,49 +1919,25 @@ __gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED,\n       msg = \"unhandled signal\";\n     }\n \n-  /* On ARM VxWorks 6.x, the guard page is left un-armed by the kernel\n-     after being violated, so subsequent violations aren't detected.\n-     so we retrieve the address of the guard page from the TCB and compare it\n-     with the page that is violated (pREG 12 in the context) and re-arm that\n-     page if there's a match.  Additionally we're are assured this is a\n-     genuine stack overflow condition and and set the message and exception\n-     to that effect.  */\n-#if defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6) && !defined(__RTP__)\n-\n-  /* We re-arm the guard page by marking it invalid */\n-\n-#define PAGE_SIZE 4096\n-#define REG_IP 12\n-\n-  if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL)\n+  if (__gnat_reset_guard_page (sig, sc))\n     {\n-      TASK_ID tid = taskIdSelf ();\n-      WIND_TCB *pTcb = taskTcb (tid);\n-      unsigned long violated_page\n-          = ((struct sigcontext *) sc)->sc_pregs->r[REG_IP] & ~(PAGE_SIZE - 1);\n+      /* Set the exception message: we know for sure that we have a\n+         stack overflow here */\n+      exception = &storage_error;\n \n-      if ((unsigned long) (pTcb->pStackEnd - PAGE_SIZE) == violated_page)\n+      switch (sig)\n         {\n-\t  vmStateSet (NULL, violated_page,\n-\t\t      PAGE_SIZE, VM_STATE_MASK_VALID, VM_STATE_VALID_NOT);\n-\t  exception = &storage_error;\n-\n-\t  switch (sig)\n-\t  {\n-            case SIGSEGV:\n-\t      msg = \"SIGSEGV: stack overflow\";\n-\t      break;\n-            case SIGBUS:\n-\t      msg = \"SIGBUS: stack overflow\";\n-\t      break;\n-            case SIGILL:\n-\t      msg = \"SIGILL: stack overflow\";\n-\t      break;\n-\t  }\n-       }\n+        case SIGSEGV:\n+          msg = \"SIGSEGV: stack overflow\";\n+          break;\n+        case SIGBUS:\n+          msg = \"SIGBUS: stack overflow\";\n+          break;\n+        case SIGILL:\n+          msg = \"SIGILL: stack overflow\";\n+          break;\n+        }\n     }\n-#endif /* defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6) && !defined(__RTP__) */\n-\n   __gnat_clear_exception_count ();\n   Raise_From_Signal_Handler (exception, msg);\n }\n@@ -2115,7 +2156,7 @@ __gnat_init_float (void)\n #endif\n #endif\n \n-#if (defined (__i386__) && !defined (VTHREADS))\n+#if defined (__i386__) && !defined (VTHREADS)\n   /* This is used to properly initialize the FPU on an x86 for each\n      process thread. Is this needed for x86_64 ???  */\n   asm (\"finit\");"}]}