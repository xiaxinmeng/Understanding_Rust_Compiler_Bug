{"sha": "b6f670ff706e35dc51a62db4206cb241dcac4963", "node_id": "C_kwDOANBUbNoAKGI2ZjY3MGZmNzA2ZTM1ZGM1MWE2MmRiNDIwNmNiMjQxZGNhYzQ5NjM", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-20T22:48:05Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-22T18:48:29Z"}, "message": "Convert CFN_BUILT_IN_UBSAN_CHECK_* to range-ops.\n\n\t* gimple-range-fold.cc (range_of_builtin_ubsan_call): Delete.\n\t(range_of_builtin_int_call): Remove cases for\n\tCFN_BUILT_IN_UBSAN_CHECK.\n\t* gimple-range-op.cc (class cfn_ubsan): New.\n\t(gimple_range_op_handler::maybe_builtin_call): Set arguments.", "tree": {"sha": "e75faf9b622687f0b916cf05cd949874f7489cbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e75faf9b622687f0b916cf05cd949874f7489cbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6f670ff706e35dc51a62db4206cb241dcac4963", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f670ff706e35dc51a62db4206cb241dcac4963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6f670ff706e35dc51a62db4206cb241dcac4963", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f670ff706e35dc51a62db4206cb241dcac4963/comments", "author": null, "committer": null, "parents": [{"sha": "f7e62b09300b6935bceaffb4c42f6edab80f52dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e62b09300b6935bceaffb4c42f6edab80f52dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7e62b09300b6935bceaffb4c42f6edab80f52dc"}], "stats": {"total": 103, "additions": 57, "deletions": 46}, "files": [{"sha": "d445270417a64496fa67e51dd2c3c8aa611379ac", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6f670ff706e35dc51a62db4206cb241dcac4963/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6f670ff706e35dc51a62db4206cb241dcac4963/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=b6f670ff706e35dc51a62db4206cb241dcac4963", "patch": "@@ -852,41 +852,6 @@ fold_using_range::range_of_call (vrange &r, gcall *call, fur_source &src)\n   return true;\n }\n \n-// Return the range of a __builtin_ubsan* in CALL and set it in R.\n-// CODE is the type of ubsan call (PLUS_EXPR, MINUS_EXPR or\n-// MULT_EXPR).\n-\n-void\n-fold_using_range::range_of_builtin_ubsan_call (irange &r, gcall *call,\n-\t\t\t\t\t       tree_code code, fur_source &src)\n-{\n-  gcc_checking_assert (code == PLUS_EXPR || code == MINUS_EXPR\n-\t\t       || code == MULT_EXPR);\n-  tree type = gimple_range_type (call);\n-  range_op_handler op (code, type);\n-  gcc_checking_assert (op);\n-  int_range_max ir0, ir1;\n-  tree arg0 = gimple_call_arg (call, 0);\n-  tree arg1 = gimple_call_arg (call, 1);\n-  src.get_operand (ir0, arg0);\n-  src.get_operand (ir1, arg1);\n-  // Check for any relation between arg0 and arg1.\n-  relation_kind relation = src.query_relation (arg0, arg1);\n-\n-  bool saved_flag_wrapv = flag_wrapv;\n-  // Pretend the arithmetic is wrapping.  If there is any overflow,\n-  // we'll complain, but will actually do wrapping operation.\n-  flag_wrapv = 1;\n-  op.fold_range (r, type, ir0, ir1, relation);\n-  flag_wrapv = saved_flag_wrapv;\n-\n-  // If for both arguments vrp_valueize returned non-NULL, this should\n-  // have been already folded and if not, it wasn't folded because of\n-  // overflow.  Avoid removing the UBSAN_CHECK_* calls in that case.\n-  if (r.singleton_p ())\n-    r.set_varying (type);\n-}\n-\n // For a builtin in CALL, return a range in R if known and return\n // TRUE.  Otherwise return FALSE.\n \n@@ -909,7 +874,7 @@ fold_using_range::range_of_builtin_call (vrange &r, gcall *call,\n \n bool\n fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n-\t\t\t\t\t     fur_source &src)\n+\t\t\t\t\t     fur_source &)\n {\n   combined_fn func = gimple_call_combined_fn (call);\n   if (func == CFN_LAST)\n@@ -924,16 +889,6 @@ fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n       r.set (build_zero_cst (type), build_one_cst (type));\n       return true;\n \n-    case CFN_UBSAN_CHECK_ADD:\n-      range_of_builtin_ubsan_call (r, call, PLUS_EXPR, src);\n-      return true;\n-    case CFN_UBSAN_CHECK_SUB:\n-      range_of_builtin_ubsan_call (r, call, MINUS_EXPR, src);\n-      return true;\n-    case CFN_UBSAN_CHECK_MUL:\n-      range_of_builtin_ubsan_call (r, call, MULT_EXPR, src);\n-      return true;\n-\n     case CFN_GOACC_DIM_SIZE:\n     case CFN_GOACC_DIM_POS:\n       // Optimizing these two internal functions helps the loop"}, {"sha": "09b7dd2add3cc37eca1272acdacbd94eb4147703", "filename": "gcc/gimple-range-op.cc", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6f670ff706e35dc51a62db4206cb241dcac4963/gcc%2Fgimple-range-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6f670ff706e35dc51a62db4206cb241dcac4963/gcc%2Fgimple-range-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.cc?ref=b6f670ff706e35dc51a62db4206cb241dcac4963", "patch": "@@ -576,6 +576,41 @@ class cfn_clrsb : public range_operator\n   }\n } op_cfn_clrsb;\n \n+\n+// Implement range operator for CFN_BUILT_IN_\n+class cfn_ubsan : public range_operator\n+{\n+public:\n+  cfn_ubsan (enum tree_code code) { m_code = code; }\n+  using range_operator::fold_range;\n+  virtual bool fold_range (irange &r, tree type, const irange &lh,\n+\t\t\t   const irange &rh, relation_kind rel) const\n+  {\n+    range_op_handler handler (m_code, type);\n+    gcc_checking_assert (handler);\n+\n+    bool saved_flag_wrapv = flag_wrapv;\n+    // Pretend the arithmetic is wrapping.  If there is any overflow,\n+    // we'll complain, but will actually do wrapping operation.\n+    flag_wrapv = 1;\n+    bool result = handler.fold_range (r, type, lh, rh, rel);\n+    flag_wrapv = saved_flag_wrapv;\n+\n+    // If for both arguments vrp_valueize returned non-NULL, this should\n+    // have been already folded and if not, it wasn't folded because of\n+    // overflow.  Avoid removing the UBSAN_CHECK_* calls in that case.\n+    if (result && r.singleton_p ())\n+      r.set_varying (type);\n+    return result;\n+  }\n+private:\n+  enum tree_code m_code;\n+};\n+\n+cfn_ubsan op_cfn_ubsan_add (PLUS_EXPR);\n+cfn_ubsan op_cfn_ubsan_sub (MINUS_EXPR);\n+cfn_ubsan op_cfn_ubsan_mul (MULT_EXPR);\n+\n // Set up a gimple_range_op_handler for any built in function which can be\n // supported via range-ops.\n \n@@ -655,6 +690,27 @@ gimple_range_op_handler::maybe_builtin_call ()\n       m_int = &op_cfn_clrsb;\n       break;\n \n+    case CFN_UBSAN_CHECK_ADD:\n+      m_op1 = gimple_call_arg (call, 0);\n+      m_op2 = gimple_call_arg (call, 1);\n+      m_valid = true;\n+      m_int = &op_cfn_ubsan_add;\n+      break;\n+\n+    case CFN_UBSAN_CHECK_SUB:\n+      m_op1 = gimple_call_arg (call, 0);\n+      m_op2 = gimple_call_arg (call, 1);\n+      m_valid = true;\n+      m_int = &op_cfn_ubsan_sub;\n+      break;\n+\n+    case CFN_UBSAN_CHECK_MUL:\n+      m_op1 = gimple_call_arg (call, 0);\n+      m_op2 = gimple_call_arg (call, 1);\n+      m_valid = true;\n+      m_int = &op_cfn_ubsan_mul;\n+      break;\n+\n     default:\n       break;\n     }"}]}