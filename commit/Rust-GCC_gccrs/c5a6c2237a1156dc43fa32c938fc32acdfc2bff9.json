{"sha": "c5a6c2237a1156dc43fa32c938fc32acdfc2bff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhNmMyMjM3YTExNTZkYzQzZmEzMmM5MzhmYzMyYWNkZmMyYmZmOQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-09-04T07:05:04Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-09-04T10:26:14Z"}, "message": "rename widest_irange to int_range_max.\n\ngcc/ChangeLog:\n\n\t* range-op.cc (range_operator::fold_range): Rename widest_irange\n\tto int_range_max.\n\t(operator_div::wi_fold): Same.\n\t(operator_lshift::op1_range): Same.\n\t(operator_rshift::op1_range): Same.\n\t(operator_cast::fold_range): Same.\n\t(operator_cast::op1_range): Same.\n\t(operator_bitwise_and::remove_impossible_ranges): Same.\n\t(operator_bitwise_and::op1_range): Same.\n\t(operator_abs::op1_range): Same.\n\t(range_cast): Same.\n\t(widest_irange_tests): Same.\n\t(range3_tests): Rename irange3 to int_range3.\n\t(int_range_max_tests): Rename from widest_irange_tests.\n\tRename widest_irange to int_range_max.\n\t(operator_tests): Rename widest_irange to int_range_max.\n\t(range_tests): Same.\n\t* tree-vrp.c (find_case_label_range): Same.\n\t* value-range.cc (irange::irange_intersect): Same.\n\t(irange::invert): Same.\n\t* value-range.h: Same.", "tree": {"sha": "54e8842e9cfe88b1113bb78e7f3bdcb372b5d1b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54e8842e9cfe88b1113bb78e7f3bdcb372b5d1b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fab77644842869adc8871e133e4c3f4c35b2b245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fab77644842869adc8871e133e4c3f4c35b2b245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fab77644842869adc8871e133e4c3f4c35b2b245"}], "stats": {"total": 142, "additions": 71, "deletions": 71}, "files": [{"sha": "fbf78be0a3c3e064338fab1772c1c85f561c6fad", "filename": "gcc/range-op.cc", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=c5a6c2237a1156dc43fa32c938fc32acdfc2bff9", "patch": "@@ -160,7 +160,7 @@ range_operator::fold_range (irange &r, tree type,\n       return true;\n     }\n \n-  widest_irange tmp;\n+  int_range_max tmp;\n   r.set_undefined ();\n   for (unsigned x = 0; x < num_lh; ++x)\n     for (unsigned y = 0; y < num_rh; ++y)\n@@ -1367,7 +1367,7 @@ operator_div::wi_fold (irange &r, tree type,\n   // Then divide by the non-zero positive numbers, if any.\n   if (wi::gt_p (divisor_max, wi::zero (prec), sign))\n     {\n-      widest_irange tmp;\n+      int_range_max tmp;\n       wi_cross_product (tmp, type, dividend_min, dividend_max,\n \t\t\twi::one (prec), divisor_max);\n       r.union_ (tmp);\n@@ -1567,7 +1567,7 @@ operator_lshift::op1_range (irange &r,\n       //\n       // Perform a logical rshift by doing the rshift as unsigned.\n       tree unsigned_type = unsigned_type_for (type);\n-      widest_irange unsigned_lhs = lhs;\n+      int_range_max unsigned_lhs = lhs;\n       range_cast (unsigned_lhs, unsigned_type);\n       rshift_op = range_op_handler (RSHIFT_EXPR, unsigned_type);\n       rshift_op->fold_range (lb, unsigned_type, unsigned_lhs, shifted);\n@@ -1611,16 +1611,16 @@ operator_rshift::op1_range (irange &r,\n     {\n       // Folding the original operation may discard some impossible\n       // ranges from the LHS.\n-      widest_irange lhs_refined;\n+      int_range_max lhs_refined;\n       op_rshift.fold_range (lhs_refined, type, int_range<1> (type), op2);\n       lhs_refined.intersect (lhs);\n       if (lhs_refined.undefined_p ())\n \t{\n \t  r.set_undefined ();\n \t  return true;\n \t}\n-      widest_irange shift_range (shift, shift);\n-      widest_irange lb, ub;\n+      int_range_max shift_range (shift, shift);\n+      int_range_max lb, ub;\n       op_lshift.fold_range (lb, type, lhs_refined, shift_range);\n       //    LHS\n       // 0000 0111 = OP1 >> 3\n@@ -1632,7 +1632,7 @@ operator_rshift::op1_range (irange &r,\n \t\t\t       fold_build2 (LSHIFT_EXPR, type,\n \t\t\t\t\t    build_minus_one_cst (type),\n \t\t\t\t\t    shift));\n-      widest_irange mask_range (build_zero_cst (type), mask);\n+      int_range_max mask_range (build_zero_cst (type), mask);\n       op_plus.fold_range (ub, type, lb, mask_range);\n       r = lb;\n       r.union_ (ub);\n@@ -1786,7 +1786,7 @@ operator_cast::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n   // Then process any additonal pairs by unioning with their results.\n   for (unsigned x = 1; x < inner.num_pairs (); ++x)\n     {\n-      widest_irange tmp;\n+      int_range_max tmp;\n       fold_pair (tmp, x, inner, outer);\n       r.union_ (tmp);\n       if (r.varying_p ())\n@@ -1811,7 +1811,7 @@ operator_cast::op1_range (irange &r, tree type,\n         {\n \t  // We want to insert the LHS as an unsigned value since it\n \t  // would not trigger the signed bit of the larger type.\n-\t  widest_irange converted_lhs = lhs;\n+\t  int_range_max converted_lhs = lhs;\n \t  range_cast (converted_lhs, unsigned_type_for (lhs_type));\n \t  range_cast (converted_lhs, type);\n \t  // Start by building the positive signed outer range for the type.\n@@ -1826,14 +1826,14 @@ operator_cast::op1_range (irange &r, tree type,\n \t  lim = wi::mask (TYPE_PRECISION (lhs_type), true,\n \t\t\t  TYPE_PRECISION (type));\n \t  // Add this to the unsigned LHS range(s).\n-\t  widest_irange lim_range (type, lim, lim);\n-\t  widest_irange lhs_neg;\n+\t  int_range_max lim_range (type, lim, lim);\n+\t  int_range_max lhs_neg;\n \t  range_op_handler (PLUS_EXPR, type)->fold_range (lhs_neg,\n \t\t\t\t\t\t\t  type,\n \t\t\t\t\t\t\t  converted_lhs,\n \t\t\t\t\t\t\t  lim_range);\n \t  // And union this with the entire outer types negative range.\n-\t  widest_irange neg (type,\n+\t  int_range_max neg (type,\n \t\t\t     wi::min_value (TYPE_PRECISION (type),\n \t\t\t\t\t    SIGNED),\n \t\t\t     lim - 1);\n@@ -1846,7 +1846,7 @@ operator_cast::op1_range (irange &r, tree type,\n       return true;\n     }\n \n-  widest_irange tmp;\n+  int_range_max tmp;\n   if (TYPE_PRECISION (lhs_type) == TYPE_PRECISION (type))\n     tmp = lhs;\n   else\n@@ -1984,7 +1984,7 @@ operator_bitwise_and::remove_impossible_ranges (irange &r,\n   tree type = r.type ();\n   int prec = TYPE_PRECISION (type);\n   int leading_zeros = wi::clz (mask);\n-  widest_irange impossible_ranges;\n+  int_range_max impossible_ranges;\n \n   /* We know that starting at the most significant bit, any 0 in the\n      mask means the resulting range cannot contain a 1 in that same\n@@ -2315,10 +2315,10 @@ operator_bitwise_and::op1_range (irange &r, tree type,\n   r.set_undefined ();\n   for (unsigned i = 0; i < lhs.num_pairs (); ++i)\n     {\n-      widest_irange chunk (lhs.type (),\n+      int_range_max chunk (lhs.type (),\n \t\t\t   lhs.lower_bound (i),\n \t\t\t   lhs.upper_bound (i));\n-      widest_irange res;\n+      int_range_max res;\n       simple_op1_range_solver (res, type, chunk, op2);\n       r.union_ (res);\n     }\n@@ -2872,7 +2872,7 @@ operator_abs::op1_range (irange &r, tree type,\n       return true;\n     }\n   // Start with the positives because negatives are an impossible result.\n-  widest_irange positives = range_positives (type);\n+  int_range_max positives = range_positives (type);\n   positives.intersect (lhs);\n   r = positives;\n   // Then add the negative of each pair:\n@@ -3284,7 +3284,7 @@ range_op_handler (enum tree_code code, tree type)\n void\n range_cast (irange &r, tree type)\n {\n-  widest_irange tmp = r;\n+  int_range_max tmp = r;\n   range_operator *op = range_op_handler (CONVERT_EXPR, type);\n   // Call op_convert, if it fails, the result is varying.\n   if (!op->fold_range (r, type, tmp, int_range<1> (type)))\n@@ -3321,84 +3321,84 @@ build_range3 (int a, int b, int c, int d, int e, int f)\n static void\n range3_tests ()\n {\n-  typedef int_range<3> irange3;\n-  irange3 r0, r1, r2;\n-  irange3 i1, i2, i3;\n+  typedef int_range<3> int_range3;\n+  int_range3 r0, r1, r2;\n+  int_range3 i1, i2, i3;\n \n   // ([10,20] U [5,8]) U [1,3] ==> [1,3][5,8][10,20].\n-  r0 = irange3 (INT (10), INT (20));\n-  r1 = irange3 (INT (5), INT (8));\n+  r0 = int_range3 (INT (10), INT (20));\n+  r1 = int_range3 (INT (5), INT (8));\n   r0.union_ (r1);\n-  r1 = irange3 (INT (1), INT (3));\n+  r1 = int_range3 (INT (1), INT (3));\n   r0.union_ (r1);\n   ASSERT_TRUE (r0 == build_range3 (1, 3, 5, 8, 10, 20));\n \n   // [1,3][5,8][10,20] U [-5,0] => [-5,3][5,8][10,20].\n-  r1 = irange3 (INT (-5), INT (0));\n+  r1 = int_range3 (INT (-5), INT (0));\n   r0.union_ (r1);\n   ASSERT_TRUE (r0 == build_range3 (-5, 3, 5, 8, 10, 20));\n \n   // [10,20][30,40] U [50,60] ==> [10,20][30,40][50,60].\n-  r1 = irange3 (INT (50), INT (60));\n-  r0 = irange3 (INT (10), INT (20));\n-  r0.union_ (irange3 (INT (30), INT (40)));\n+  r1 = int_range3 (INT (50), INT (60));\n+  r0 = int_range3 (INT (10), INT (20));\n+  r0.union_ (int_range3 (INT (30), INT (40)));\n   r0.union_ (r1);\n   ASSERT_TRUE (r0 == build_range3 (10, 20, 30, 40, 50, 60));\n   // [10,20][30,40][50,60] U [70, 80] ==> [10,20][30,40][50,60][70,80].\n-  r1 = irange3 (INT (70), INT (80));\n+  r1 = int_range3 (INT (70), INT (80));\n   r0.union_ (r1);\n \n   r2 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r2.union_ (irange3 (INT (70), INT (80)));\n+  r2.union_ (int_range3 (INT (70), INT (80)));\n   ASSERT_TRUE (r0 == r2);\n \n   // [10,20][30,40][50,60] U [6,35] => [6,40][50,60].\n   r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = irange3 (INT (6), INT (35));\n+  r1 = int_range3 (INT (6), INT (35));\n   r0.union_ (r1);\n-  r1 = irange3 (INT (6), INT (40));\n-  r1.union_ (irange3 (INT (50), INT (60)));\n+  r1 = int_range3 (INT (6), INT (40));\n+  r1.union_ (int_range3 (INT (50), INT (60)));\n   ASSERT_TRUE (r0 == r1);\n \n   // [10,20][30,40][50,60] U [6,60] => [6,60].\n   r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = irange3 (INT (6), INT (60));\n+  r1 = int_range3 (INT (6), INT (60));\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0 == irange3 (INT (6), INT (60)));\n+  ASSERT_TRUE (r0 == int_range3 (INT (6), INT (60)));\n \n   // [10,20][30,40][50,60] U [6,70] => [6,70].\n   r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = irange3 (INT (6), INT (70));\n+  r1 = int_range3 (INT (6), INT (70));\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0 == irange3 (INT (6), INT (70)));\n+  ASSERT_TRUE (r0 == int_range3 (INT (6), INT (70)));\n \n   // [10,20][30,40][50,60] U [35,70] => [10,20][30,70].\n   r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = irange3 (INT (35), INT (70));\n+  r1 = int_range3 (INT (35), INT (70));\n   r0.union_ (r1);\n-  r1 = irange3 (INT (10), INT (20));\n-  r1.union_ (irange3 (INT (30), INT (70)));\n+  r1 = int_range3 (INT (10), INT (20));\n+  r1.union_ (int_range3 (INT (30), INT (70)));\n   ASSERT_TRUE (r0 == r1);\n \n   // [10,20][30,40][50,60] U [15,35] => [10,40][50,60].\n   r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = irange3 (INT (15), INT (35));\n+  r1 = int_range3 (INT (15), INT (35));\n   r0.union_ (r1);\n-  r1 = irange3 (INT (10), INT (40));\n-  r1.union_ (irange3 (INT (50), INT (60)));\n+  r1 = int_range3 (INT (10), INT (40));\n+  r1.union_ (int_range3 (INT (50), INT (60)));\n   ASSERT_TRUE (r0 == r1);\n \n   // [10,20][30,40][50,60] U [35,35] => [10,20][30,40][50,60].\n   r0 = build_range3 (10, 20, 30, 40, 50, 60);\n-  r1 = irange3 (INT (35), INT (35));\n+  r1 = int_range3 (INT (35), INT (35));\n   r0.union_ (r1);\n   ASSERT_TRUE (r0 == build_range3 (10, 20, 30, 40, 50, 60));\n }\n \n static void\n-widest_irange_tests ()\n+int_range_max_tests ()\n {\n-  widest_irange big;\n+  int_range_max big;\n   unsigned int nrange;\n \n   // Build a huge multi-range range.\n@@ -3410,7 +3410,7 @@ widest_irange_tests ()\n   ASSERT_TRUE (big.num_pairs () == nrange);\n \n   // Verify that we can copy it without loosing precision.\n-  widest_irange copy (big);\n+  int_range_max copy (big);\n   ASSERT_TRUE (copy.num_pairs () == nrange);\n \n   // Inverting it should produce one more sub-range.\n@@ -3423,9 +3423,9 @@ widest_irange_tests ()\n \n   // Test that [10,10][20,20] does NOT contain 15.\n   {\n-    widest_irange i1 (build_int_cst (integer_type_node, 10),\n+    int_range_max i1 (build_int_cst (integer_type_node, 10),\n \t\t      build_int_cst (integer_type_node, 10));\n-    widest_irange i2 (build_int_cst (integer_type_node, 20),\n+    int_range_max i2 (build_int_cst (integer_type_node, 20),\n \t\t      build_int_cst (integer_type_node, 20));\n     i1.union_ (i2);\n     ASSERT_FALSE (i1.contains_p (build_int_cst (integer_type_node, 15)));\n@@ -3463,9 +3463,9 @@ operator_tests ()\n   tree max = vrp_val_max (integer_type_node);\n   tree tiny = fold_build2 (PLUS_EXPR, integer_type_node, min,\n \t\t\t   build_one_cst (integer_type_node));\n-  widest_irange res;\n-  widest_irange i1 (tiny, max);\n-  widest_irange i2 (build_int_cst (integer_type_node, 255),\n+  int_range_max res;\n+  int_range_max i1 (tiny, max);\n+  int_range_max i2 (build_int_cst (integer_type_node, 255),\n \t\t    build_int_cst (integer_type_node, 255));\n \n   // [MIN+1, MAX] = OP1 & 255: OP1 is VARYING\n@@ -3497,43 +3497,43 @@ operator_tests ()\n \n   // unsigned: [3, MAX] = OP1 >> 1\n   {\n-    widest_irange lhs (build_int_cst (unsigned_type_node, 3),\n+    int_range_max lhs (build_int_cst (unsigned_type_node, 3),\n \t\t       TYPE_MAX_VALUE (unsigned_type_node));\n-    widest_irange one (build_one_cst (unsigned_type_node),\n+    int_range_max one (build_one_cst (unsigned_type_node),\n \t\t       build_one_cst (unsigned_type_node));\n-    widest_irange op1;\n+    int_range_max op1;\n     op_rshift.op1_range (op1, unsigned_type_node, lhs, one);\n     ASSERT_FALSE (op1.contains_p (UINT (3)));\n   }\n \n   // signed: [3, MAX] = OP1 >> 1\n   {\n-    widest_irange lhs (INT (3), TYPE_MAX_VALUE (integer_type_node));\n-    widest_irange one (INT (1), INT (1));\n-    widest_irange op1;\n+    int_range_max lhs (INT (3), TYPE_MAX_VALUE (integer_type_node));\n+    int_range_max one (INT (1), INT (1));\n+    int_range_max op1;\n     op_rshift.op1_range (op1, integer_type_node, lhs, one);\n     ASSERT_FALSE (op1.contains_p (INT (-2)));\n   }\n \n   // This is impossible, so OP1 should be [].\n   // signed: [MIN, MIN] = OP1 >> 1\n   {\n-    widest_irange lhs (TYPE_MIN_VALUE (integer_type_node),\n+    int_range_max lhs (TYPE_MIN_VALUE (integer_type_node),\n \t\t       TYPE_MIN_VALUE (integer_type_node));\n-    widest_irange one (INT (1), INT (1));\n-    widest_irange op1;\n+    int_range_max one (INT (1), INT (1));\n+    int_range_max op1;\n     op_rshift.op1_range (op1, integer_type_node, lhs, one);\n     ASSERT_TRUE (op1.undefined_p ());\n   }\n \n   // signed: ~[-1] = OP1 >> 31\n   if (TYPE_PRECISION (integer_type_node) > 31)\n     {\n-      widest_irange lhs (INT (-1), INT (-1), VR_ANTI_RANGE);\n-      widest_irange shift (INT (31), INT (31));\n-      widest_irange op1;\n+      int_range_max lhs (INT (-1), INT (-1), VR_ANTI_RANGE);\n+      int_range_max shift (INT (31), INT (31));\n+      int_range_max op1;\n       op_rshift.op1_range (op1, integer_type_node, lhs, shift);\n-      widest_irange negatives = range_negatives (integer_type_node);\n+      int_range_max negatives = range_negatives (integer_type_node);\n       negatives.intersect (op1);\n       ASSERT_TRUE (negatives.undefined_p ());\n     }\n@@ -3823,7 +3823,7 @@ range_tests ()\n   ASSERT_TRUE (r0.nonzero_p ());\n \n   multi_precision_range_tests ();\n-  widest_irange_tests ();\n+  int_range_max_tests ();\n   operator_tests ();\n }\n "}, {"sha": "f7b0692a407674a46a8c4844c57bda86c287dde2", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=c5a6c2237a1156dc43fa32c938fc32acdfc2bff9", "patch": "@@ -3827,7 +3827,7 @@ find_case_label_range (gswitch *switch_stmt, const irange *range_of_op)\n       tree label = gimple_switch_label (switch_stmt, i);\n       tree case_high\n \t= CASE_HIGH (label) ? CASE_HIGH (label) : CASE_LOW (label);\n-      widest_irange label_range (CASE_LOW (label), case_high);\n+      int_range_max label_range (CASE_LOW (label), case_high);\n       label_range.intersect (range_of_op);\n       if (label_range == *range_of_op)\n \treturn label;\n@@ -3849,7 +3849,7 @@ find_case_label_range (gswitch *switch_stmt, const irange *range_of_op)\n       tree case_high = CASE_HIGH (max_label);\n       if (!case_high)\n \tcase_high = CASE_LOW (max_label);\n-      widest_irange label_range (CASE_LOW (min_label), case_high);\n+      int_range_max label_range (CASE_LOW (min_label), case_high);\n       if (!types_compatible_p (label_range.type (), range_of_op->type ()))\n \trange_cast (label_range, range_of_op->type ());\n       label_range.intersect (range_of_op);"}, {"sha": "20aa4f114c9fe43c09cfbcae1e5710413243b891", "filename": "gcc/value-range.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=c5a6c2237a1156dc43fa32c938fc32acdfc2bff9", "patch": "@@ -1690,7 +1690,7 @@ irange::irange_intersect (const irange &r)\n   signop sign = TYPE_SIGN (TREE_TYPE(m_base[0]));\n   unsigned bld_pair = 0;\n   unsigned bld_lim = m_max_ranges;\n-  widest_irange r2 (*this);\n+  int_range_max r2 (*this);\n   unsigned r2_lim = r2.num_pairs ();\n   unsigned i2 = 0;\n   for (unsigned i = 0; i < r.num_pairs (); )\n@@ -1827,7 +1827,7 @@ irange::invert ()\n   unsigned i = 0;\n   wi::overflow_type ovf;\n   // Construct leftmost range.\n-  widest_irange orig_range (*this);\n+  int_range_max orig_range (*this);\n   unsigned nitems = 0;\n   wide_int tmp;\n   // If this is going to underflow on the MINUS 1, don't even bother"}, {"sha": "8497791c7b3a0e7a2b4c4e12d186fe71fc078856", "filename": "gcc/value-range.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a6c2237a1156dc43fa32c938fc32acdfc2bff9/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=c5a6c2237a1156dc43fa32c938fc32acdfc2bff9", "patch": "@@ -174,7 +174,7 @@ typedef int_range<1> value_range;\n \n // This is an \"infinite\" precision irange for use in temporary\n // calculations.\n-typedef int_range<255> widest_irange;\n+typedef int_range<255> int_range_max;\n \n // Returns true for an old-school value_range as described above.\n inline bool"}]}