{"sha": "e7754973ed3f91db45ae9257197966e1030e1e85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc3NTQ5NzNlZDNmOTFkYjQ1YWU5MjU3MTk3OTY2ZTEwMzBlMWU4NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-06-02T10:25:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-06-02T10:25:22Z"}, "message": "tree-vect-loop.c (get_initial_def_for_induction): Inline into ...\n\n2017-06-02  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (get_initial_def_for_induction): Inline into ...\n\t(vectorizable_induction): ... this.  Remove dead code.\n\nFrom-SVN: r248819", "tree": {"sha": "8d67b362fc27745431192d9aae03020b1ad207be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d67b362fc27745431192d9aae03020b1ad207be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7754973ed3f91db45ae9257197966e1030e1e85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7754973ed3f91db45ae9257197966e1030e1e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7754973ed3f91db45ae9257197966e1030e1e85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7754973ed3f91db45ae9257197966e1030e1e85/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7e52782f605f9dd73526cf6fcf305207612313d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e52782f605f9dd73526cf6fcf305207612313d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7e52782f605f9dd73526cf6fcf305207612313d"}], "stats": {"total": 673, "additions": 307, "deletions": 366}, "files": [{"sha": "db9e2430d05ded887134912e0fb453adb4af136b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7754973ed3f91db45ae9257197966e1030e1e85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7754973ed3f91db45ae9257197966e1030e1e85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7754973ed3f91db45ae9257197966e1030e1e85", "patch": "@@ -1,3 +1,8 @@\n+2017-06-02  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (get_initial_def_for_induction): Inline into ...\n+\t(vectorizable_induction): ... this.  Remove dead code.\n+\n 2017-06-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* builtins. (expand_builtin_alloca): Remove second parameter and"}, {"sha": "27fe80852e29b28b27f75aaa4159cf694b975334", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 302, "deletions": 366, "changes": 668, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7754973ed3f91db45ae9257197966e1030e1e85/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7754973ed3f91db45ae9257197966e1030e1e85/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e7754973ed3f91db45ae9257197966e1030e1e85", "patch": "@@ -3813,347 +3813,6 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n }\n \n \n-/* Function get_initial_def_for_induction\n-\n-   Input:\n-   STMT - a stmt that performs an induction operation in the loop.\n-   IV_PHI - the initial value of the induction variable\n-\n-   Output:\n-   Return a vector variable, initialized with the first VF values of\n-   the induction variable.  E.g., for an iv with IV_PHI='X' and\n-   evolution S, for a vector of 4 units, we want to return:\n-   [X, X + S, X + 2*S, X + 3*S].  */\n-\n-static tree\n-get_initial_def_for_induction (gimple *iv_phi)\n-{\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (iv_phi);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree vectype;\n-  int nunits;\n-  edge pe = loop_preheader_edge (loop);\n-  struct loop *iv_loop;\n-  basic_block new_bb;\n-  tree new_vec, vec_init, vec_step, t;\n-  tree new_name;\n-  gimple *new_stmt;\n-  gphi *induction_phi;\n-  tree induc_def, vec_def, vec_dest;\n-  tree init_expr, step_expr;\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  int i;\n-  int ncopies;\n-  tree expr;\n-  stmt_vec_info phi_info = vinfo_for_stmt (iv_phi);\n-  bool nested_in_vect_loop = false;\n-  gimple_seq stmts;\n-  imm_use_iterator imm_iter;\n-  use_operand_p use_p;\n-  gimple *exit_phi;\n-  edge latch_e;\n-  tree loop_arg;\n-  gimple_stmt_iterator si;\n-  basic_block bb = gimple_bb (iv_phi);\n-  tree stepvectype;\n-  tree resvectype;\n-\n-  /* Is phi in an inner-loop, while vectorizing an enclosing outer-loop?  */\n-  if (nested_in_vect_loop_p (loop, iv_phi))\n-    {\n-      nested_in_vect_loop = true;\n-      iv_loop = loop->inner;\n-    }\n-  else\n-    iv_loop = loop;\n-  gcc_assert (iv_loop == (gimple_bb (iv_phi))->loop_father);\n-\n-  latch_e = loop_latch_edge (iv_loop);\n-  loop_arg = PHI_ARG_DEF_FROM_EDGE (iv_phi, latch_e);\n-\n-  step_expr = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (phi_info);\n-  gcc_assert (step_expr != NULL_TREE);\n-\n-  pe = loop_preheader_edge (iv_loop);\n-  init_expr = PHI_ARG_DEF_FROM_EDGE (iv_phi,\n-\t\t\t\t     loop_preheader_edge (iv_loop));\n-\n-  vectype = get_vectype_for_scalar_type (TREE_TYPE (init_expr));\n-  resvectype = get_vectype_for_scalar_type (TREE_TYPE (PHI_RESULT (iv_phi)));\n-  gcc_assert (vectype);\n-  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  ncopies = vf / nunits;\n-\n-  gcc_assert (phi_info);\n-  gcc_assert (ncopies >= 1);\n-\n-  /* Convert the step to the desired type.  */\n-  stmts = NULL;\n-  step_expr = gimple_convert (&stmts, TREE_TYPE (vectype), step_expr);\n-  if (stmts)\n-    {\n-      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-      gcc_assert (!new_bb);\n-    }\n-\n-  /* Find the first insertion point in the BB.  */\n-  si = gsi_after_labels (bb);\n-\n-  /* Create the vector that holds the initial_value of the induction.  */\n-  if (nested_in_vect_loop)\n-    {\n-      /* iv_loop is nested in the loop to be vectorized.  init_expr had already\n-\t been created during vectorization of previous stmts.  We obtain it\n-\t from the STMT_VINFO_VEC_STMT of the defining stmt.  */\n-      vec_init = vect_get_vec_def_for_operand (init_expr, iv_phi);\n-      /* If the initial value is not of proper type, convert it.  */\n-      if (!useless_type_conversion_p (vectype, TREE_TYPE (vec_init)))\n-\t{\n-\t  new_stmt\n-\t    = gimple_build_assign (vect_get_new_ssa_name (vectype,\n-\t\t\t\t\t\t\t  vect_simple_var,\n-\t\t\t\t\t\t\t  \"vec_iv_\"),\n-\t\t\t\t   VIEW_CONVERT_EXPR,\n-\t\t\t\t   build1 (VIEW_CONVERT_EXPR, vectype,\n-\t\t\t\t\t   vec_init));\n-\t  vec_init = gimple_assign_lhs (new_stmt);\n-\t  new_bb = gsi_insert_on_edge_immediate (loop_preheader_edge (iv_loop),\n-\t\t\t\t\t\t new_stmt);\n-\t  gcc_assert (!new_bb);\n-\t  set_vinfo_for_stmt (new_stmt,\n-\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo));\n-\t}\n-    }\n-  else\n-    {\n-      vec<constructor_elt, va_gc> *v;\n-\n-      /* iv_loop is the loop to be vectorized. Create:\n-\t vec_init = [X, X+S, X+2*S, X+3*S] (S = step_expr, X = init_expr)  */\n-      stmts = NULL;\n-      new_name = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n-\n-      vec_alloc (v, nunits);\n-      bool constant_p = is_gimple_min_invariant (new_name);\n-      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, new_name);\n-      for (i = 1; i < nunits; i++)\n-\t{\n-\t  /* Create: new_name_i = new_name + step_expr  */\n-\t  new_name = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (new_name),\n-\t\t\t\t   new_name, step_expr);\n-\t  if (!is_gimple_min_invariant (new_name))\n-\t    constant_p = false;\n-\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, new_name);\n-\t}\n-      if (stmts)\n-\t{\n-\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t  gcc_assert (!new_bb);\n-\t}\n-\n-      /* Create a vector from [new_name_0, new_name_1, ..., new_name_nunits-1]  */\n-      if (constant_p)\n-\tnew_vec = build_vector_from_ctor (vectype, v);\n-      else\n-\tnew_vec = build_constructor (vectype, v);\n-      vec_init = vect_init_vector (iv_phi, new_vec, vectype, NULL);\n-    }\n-\n-\n-  /* Create the vector that holds the step of the induction.  */\n-  if (nested_in_vect_loop)\n-    /* iv_loop is nested in the loop to be vectorized. Generate:\n-       vec_step = [S, S, S, S]  */\n-    new_name = step_expr;\n-  else\n-    {\n-      /* iv_loop is the loop to be vectorized. Generate:\n-\t  vec_step = [VF*S, VF*S, VF*S, VF*S]  */\n-      if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)))\n-\t{\n-\t  expr = build_int_cst (integer_type_node, vf);\n-\t  expr = fold_convert (TREE_TYPE (step_expr), expr);\n-\t}\n-      else\n-\texpr = build_int_cst (TREE_TYPE (step_expr), vf);\n-      new_name = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n-\t\t\t      expr, step_expr);\n-      if (TREE_CODE (step_expr) == SSA_NAME)\n-\tnew_name = vect_init_vector (iv_phi, new_name,\n-\t\t\t\t     TREE_TYPE (step_expr), NULL);\n-    }\n-\n-  t = unshare_expr (new_name);\n-  gcc_assert (CONSTANT_CLASS_P (new_name)\n-\t      || TREE_CODE (new_name) == SSA_NAME);\n-  stepvectype = get_vectype_for_scalar_type (TREE_TYPE (new_name));\n-  gcc_assert (stepvectype);\n-  new_vec = build_vector_from_val (stepvectype, t);\n-  vec_step = vect_init_vector (iv_phi, new_vec, stepvectype, NULL);\n-\n-\n-  /* Create the following def-use cycle:\n-     loop prolog:\n-         vec_init = ...\n-\t vec_step = ...\n-     loop:\n-         vec_iv = PHI <vec_init, vec_loop>\n-         ...\n-         STMT\n-         ...\n-         vec_loop = vec_iv + vec_step;  */\n-\n-  /* Create the induction-phi that defines the induction-operand.  */\n-  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n-  induction_phi = create_phi_node (vec_dest, iv_loop->header);\n-  set_vinfo_for_stmt (induction_phi,\n-\t\t      new_stmt_vec_info (induction_phi, loop_vinfo));\n-  induc_def = PHI_RESULT (induction_phi);\n-\n-  /* Create the iv update inside the loop  */\n-  new_stmt = gimple_build_assign (vec_dest, PLUS_EXPR, induc_def, vec_step);\n-  vec_def = make_ssa_name (vec_dest, new_stmt);\n-  gimple_assign_set_lhs (new_stmt, vec_def);\n-  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n-  set_vinfo_for_stmt (new_stmt, new_stmt_vec_info (new_stmt, loop_vinfo));\n-\n-  /* Set the arguments of the phi node:  */\n-  add_phi_arg (induction_phi, vec_init, pe, UNKNOWN_LOCATION);\n-  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n-\t       UNKNOWN_LOCATION);\n-\n-\n-  /* In case that vectorization factor (VF) is bigger than the number\n-     of elements that we can fit in a vectype (nunits), we have to generate\n-     more than one vector stmt - i.e - we need to \"unroll\" the\n-     vector stmt by a factor VF/nunits.  For more details see documentation\n-     in vectorizable_operation.  */\n-\n-  if (ncopies > 1)\n-    {\n-      stmt_vec_info prev_stmt_vinfo;\n-      /* FORNOW. This restriction should be relaxed.  */\n-      gcc_assert (!nested_in_vect_loop);\n-\n-      /* Create the vector that holds the step of the induction.  */\n-      if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)))\n-\t{\n-\t  expr = build_int_cst (integer_type_node, nunits);\n-\t  expr = fold_convert (TREE_TYPE (step_expr), expr);\n-\t}\n-      else\n-\texpr = build_int_cst (TREE_TYPE (step_expr), nunits);\n-      new_name = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n-\t\t\t      expr, step_expr);\n-      if (TREE_CODE (step_expr) == SSA_NAME)\n-\tnew_name = vect_init_vector (iv_phi, new_name,\n-\t\t\t\t     TREE_TYPE (step_expr), NULL);\n-      t = unshare_expr (new_name);\n-      gcc_assert (CONSTANT_CLASS_P (new_name)\n-\t\t  || TREE_CODE (new_name) == SSA_NAME);\n-      new_vec = build_vector_from_val (stepvectype, t);\n-      vec_step = vect_init_vector (iv_phi, new_vec, stepvectype, NULL);\n-\n-      vec_def = induc_def;\n-      prev_stmt_vinfo = vinfo_for_stmt (induction_phi);\n-      for (i = 1; i < ncopies; i++)\n-\t{\n-\t  /* vec_i = vec_prev + vec_step  */\n-\t  new_stmt = gimple_build_assign (vec_dest, PLUS_EXPR,\n-\t\t\t\t\t  vec_def, vec_step);\n-\t  vec_def = make_ssa_name (vec_dest, new_stmt);\n-\t  gimple_assign_set_lhs (new_stmt, vec_def);\n- \n-\t  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n-\t  if (!useless_type_conversion_p (resvectype, vectype))\n-\t    {\n-\t      new_stmt\n-\t\t= gimple_build_assign\n-\t\t\t(vect_get_new_vect_var (resvectype, vect_simple_var,\n-\t\t\t\t\t\t\"vec_iv_\"),\n-\t\t\t VIEW_CONVERT_EXPR,\n-\t\t\t build1 (VIEW_CONVERT_EXPR, resvectype,\n-\t\t\t\t gimple_assign_lhs (new_stmt)));\n-\t      gimple_assign_set_lhs (new_stmt,\n-\t\t\t\t     make_ssa_name\n-\t\t\t\t       (gimple_assign_lhs (new_stmt), new_stmt));\n-\t      gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n-\t    }\n-\t  set_vinfo_for_stmt (new_stmt,\n-\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo));\n-\t  STMT_VINFO_RELATED_STMT (prev_stmt_vinfo) = new_stmt;\n-\t  prev_stmt_vinfo = vinfo_for_stmt (new_stmt);\n-\t}\n-    }\n-\n-  if (nested_in_vect_loop)\n-    {\n-      /* Find the loop-closed exit-phi of the induction, and record\n-         the final vector of induction results:  */\n-      exit_phi = NULL;\n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, loop_arg)\n-        {\n-\t  gimple *use_stmt = USE_STMT (use_p);\n-\t  if (is_gimple_debug (use_stmt))\n-\t    continue;\n-\n-\t  if (!flow_bb_inside_loop_p (iv_loop, gimple_bb (use_stmt)))\n-\t    {\n-\t      exit_phi = use_stmt;\n-\t      break;\n-\t    }\n-        }\n-      if (exit_phi)\n-\t{\n-\t  stmt_vec_info stmt_vinfo = vinfo_for_stmt (exit_phi);\n-\t  /* FORNOW. Currently not supporting the case that an inner-loop induction\n-\t     is not used in the outer-loop (i.e. only outside the outer-loop).  */\n-\t  gcc_assert (STMT_VINFO_RELEVANT_P (stmt_vinfo)\n-\t\t      && !STMT_VINFO_LIVE_P (stmt_vinfo));\n-\n-\t  STMT_VINFO_VEC_STMT (stmt_vinfo) = new_stmt;\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"vector of inductions after inner-loop:\");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, new_stmt, 0);\n-\t    }\n-\t}\n-    }\n-\n-\n-  if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"transform induction: created def-use cycle: \");\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, induction_phi, 0);\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n-\t\t\tSSA_NAME_DEF_STMT (vec_def), 0);\n-    }\n-\n-  STMT_VINFO_VEC_STMT (phi_info) = induction_phi;\n-  if (!useless_type_conversion_p (resvectype, vectype))\n-    {\n-      new_stmt = gimple_build_assign (vect_get_new_vect_var (resvectype,\n-\t\t\t\t\t\t\t     vect_simple_var,\n-\t\t\t\t\t\t\t     \"vec_iv_\"),\n-\t\t\t\t      VIEW_CONVERT_EXPR,\n-\t\t\t\t      build1 (VIEW_CONVERT_EXPR, resvectype,\n-\t\t\t\t\t      induc_def));\n-      induc_def = make_ssa_name (gimple_assign_lhs (new_stmt), new_stmt);\n-      gimple_assign_set_lhs (new_stmt, induc_def);\n-      si = gsi_after_labels (bb);\n-      gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n-      set_vinfo_for_stmt (new_stmt,\n-\t\t\t  new_stmt_vec_info (new_stmt, loop_vinfo));\n-      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (new_stmt))\n-\t= STMT_VINFO_RELATED_STMT (vinfo_for_stmt (induction_phi));\n-    }\n-\n-  return induc_def;\n-}\n-\n \n /* Function get_initial_def_for_reduction\n \n@@ -6425,20 +6084,58 @@ vect_min_worthwhile_factor (enum tree_code code)\n    phi to replace it, put it in VEC_STMT, and add it to the same basic block.\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n-bool\n-vectorizable_induction (gimple *phi,\n-\t\t\tgimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n-\t\t\tgimple **vec_stmt)\n-{\n-  stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n+bool\n+vectorizable_induction (gimple *phi,\n+\t\t\tgimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n+\t\t\tgimple **vec_stmt)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  unsigned ncopies;\n+  bool nested_in_vect_loop = false;\n+  struct loop *iv_loop;\n+  tree vec_def;\n+  edge pe = loop_preheader_edge (loop);\n+  basic_block new_bb;\n+  tree new_vec, vec_init, vec_step, t;\n+  tree new_name;\n+  gimple *new_stmt;\n+  gphi *induction_phi;\n+  tree induc_def, vec_dest;\n+  tree init_expr, step_expr;\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  unsigned i;\n+  tree expr;\n+  gimple_seq stmts;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  gimple *exit_phi;\n+  edge latch_e;\n+  tree loop_arg;\n+  gimple_stmt_iterator si;\n+  basic_block bb = gimple_bb (phi);\n+\n+  if (gimple_code (phi) != GIMPLE_PHI)\n+    return false;\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  /* Make sure it was recognized as induction computation.  */\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n+    return false;\n+\n+  /* FORNOW: SLP not supported.  */\n+  if (STMT_SLP_TYPE (stmt_info))\n+    return false;\n+\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n-  tree vec_def;\n+  unsigned nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n+  ncopies = vf / nunits;\n   gcc_assert (ncopies >= 1);\n+\n   /* FORNOW. These restrictions should be relaxed.  */\n   if (nested_in_vect_loop_p (loop, phi))\n     {\n@@ -6456,6 +6153,10 @@ vectorizable_induction (gimple *phi,\n \t  return false;\n \t}\n \n+      /* FORNOW: outer loop induction with SLP not supported.  */\n+      if (STMT_SLP_TYPE (stmt_info))\n+\treturn false;\n+\n       exit_phi = NULL;\n       latch_e = loop_latch_edge (loop->inner);\n       loop_arg = PHI_ARG_DEF_FROM_EDGE (phi, latch_e);\n@@ -6484,19 +6185,13 @@ vectorizable_induction (gimple *phi,\n \t      return false;\n \t    }\n \t}\n-    }\n \n-  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n-    return false;\n-\n-  /* FORNOW: SLP not supported.  */\n-  if (STMT_SLP_TYPE (stmt_info))\n-    return false;\n-\n-  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def);\n-\n-  if (gimple_code (phi) != GIMPLE_PHI)\n-    return false;\n+      nested_in_vect_loop = true;\n+      iv_loop = loop->inner;\n+    }\n+  else\n+    iv_loop = loop;\n+  gcc_assert (iv_loop == (gimple_bb (phi))->loop_father);\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n@@ -6510,11 +6205,252 @@ vectorizable_induction (gimple *phi,\n \n   /* Transform.  */\n \n+  /* Compute a vector variable, initialized with the first VF values of\n+     the induction variable.  E.g., for an iv with IV_PHI='X' and\n+     evolution S, for a vector of 4 units, we want to compute:\n+     [X, X + S, X + 2*S, X + 3*S].  */\n+\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"transform induction phi.\\n\");\n \n-  vec_def = get_initial_def_for_induction (phi);\n-  *vec_stmt = SSA_NAME_DEF_STMT (vec_def);\n+  latch_e = loop_latch_edge (iv_loop);\n+  loop_arg = PHI_ARG_DEF_FROM_EDGE (phi, latch_e);\n+\n+  step_expr = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_info);\n+  gcc_assert (step_expr != NULL_TREE);\n+\n+  pe = loop_preheader_edge (iv_loop);\n+  init_expr = PHI_ARG_DEF_FROM_EDGE (phi,\n+\t\t\t\t     loop_preheader_edge (iv_loop));\n+\n+  /* Convert the step to the desired type.  */\n+  stmts = NULL;\n+  step_expr = gimple_convert (&stmts, TREE_TYPE (vectype), step_expr);\n+  if (stmts)\n+    {\n+      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+      gcc_assert (!new_bb);\n+    }\n+\n+  /* Find the first insertion point in the BB.  */\n+  si = gsi_after_labels (bb);\n+\n+  /* Create the vector that holds the initial_value of the induction.  */\n+  if (nested_in_vect_loop)\n+    {\n+      /* iv_loop is nested in the loop to be vectorized.  init_expr had already\n+\t been created during vectorization of previous stmts.  We obtain it\n+\t from the STMT_VINFO_VEC_STMT of the defining stmt.  */\n+      vec_init = vect_get_vec_def_for_operand (init_expr, phi);\n+      /* If the initial value is not of proper type, convert it.  */\n+      if (!useless_type_conversion_p (vectype, TREE_TYPE (vec_init)))\n+\t{\n+\t  new_stmt\n+\t    = gimple_build_assign (vect_get_new_ssa_name (vectype,\n+\t\t\t\t\t\t\t  vect_simple_var,\n+\t\t\t\t\t\t\t  \"vec_iv_\"),\n+\t\t\t\t   VIEW_CONVERT_EXPR,\n+\t\t\t\t   build1 (VIEW_CONVERT_EXPR, vectype,\n+\t\t\t\t\t   vec_init));\n+\t  vec_init = gimple_assign_lhs (new_stmt);\n+\t  new_bb = gsi_insert_on_edge_immediate (loop_preheader_edge (iv_loop),\n+\t\t\t\t\t\t new_stmt);\n+\t  gcc_assert (!new_bb);\n+\t  set_vinfo_for_stmt (new_stmt,\n+\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo));\n+\t}\n+    }\n+  else\n+    {\n+      vec<constructor_elt, va_gc> *v;\n+\n+      /* iv_loop is the loop to be vectorized. Create:\n+\t vec_init = [X, X+S, X+2*S, X+3*S] (S = step_expr, X = init_expr)  */\n+      stmts = NULL;\n+      new_name = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n+\n+      vec_alloc (v, nunits);\n+      bool constant_p = is_gimple_min_invariant (new_name);\n+      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, new_name);\n+      for (i = 1; i < nunits; i++)\n+\t{\n+\t  /* Create: new_name_i = new_name + step_expr  */\n+\t  new_name = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (new_name),\n+\t\t\t\t   new_name, step_expr);\n+\t  if (!is_gimple_min_invariant (new_name))\n+\t    constant_p = false;\n+\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, new_name);\n+\t}\n+      if (stmts)\n+\t{\n+\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t  gcc_assert (!new_bb);\n+\t}\n+\n+      /* Create a vector from [new_name_0, new_name_1, ..., new_name_nunits-1]  */\n+      if (constant_p)\n+\tnew_vec = build_vector_from_ctor (vectype, v);\n+      else\n+\tnew_vec = build_constructor (vectype, v);\n+      vec_init = vect_init_vector (phi, new_vec, vectype, NULL);\n+    }\n+\n+\n+  /* Create the vector that holds the step of the induction.  */\n+  if (nested_in_vect_loop)\n+    /* iv_loop is nested in the loop to be vectorized. Generate:\n+       vec_step = [S, S, S, S]  */\n+    new_name = step_expr;\n+  else\n+    {\n+      /* iv_loop is the loop to be vectorized. Generate:\n+\t  vec_step = [VF*S, VF*S, VF*S, VF*S]  */\n+      if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)))\n+\t{\n+\t  expr = build_int_cst (integer_type_node, vf);\n+\t  expr = fold_convert (TREE_TYPE (step_expr), expr);\n+\t}\n+      else\n+\texpr = build_int_cst (TREE_TYPE (step_expr), vf);\n+      new_name = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n+\t\t\t      expr, step_expr);\n+      if (TREE_CODE (step_expr) == SSA_NAME)\n+\tnew_name = vect_init_vector (phi, new_name,\n+\t\t\t\t     TREE_TYPE (step_expr), NULL);\n+    }\n+\n+  t = unshare_expr (new_name);\n+  gcc_assert (CONSTANT_CLASS_P (new_name)\n+\t      || TREE_CODE (new_name) == SSA_NAME);\n+  new_vec = build_vector_from_val (vectype, t);\n+  vec_step = vect_init_vector (phi, new_vec, vectype, NULL);\n+\n+\n+  /* Create the following def-use cycle:\n+     loop prolog:\n+         vec_init = ...\n+\t vec_step = ...\n+     loop:\n+         vec_iv = PHI <vec_init, vec_loop>\n+         ...\n+         STMT\n+         ...\n+         vec_loop = vec_iv + vec_step;  */\n+\n+  /* Create the induction-phi that defines the induction-operand.  */\n+  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n+  induction_phi = create_phi_node (vec_dest, iv_loop->header);\n+  set_vinfo_for_stmt (induction_phi,\n+\t\t      new_stmt_vec_info (induction_phi, loop_vinfo));\n+  induc_def = PHI_RESULT (induction_phi);\n+\n+  /* Create the iv update inside the loop  */\n+  vec_def = make_ssa_name (vec_dest);\n+  new_stmt = gimple_build_assign (vec_def, PLUS_EXPR, induc_def, vec_step);\n+  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n+  set_vinfo_for_stmt (new_stmt, new_stmt_vec_info (new_stmt, loop_vinfo));\n+\n+  /* Set the arguments of the phi node:  */\n+  add_phi_arg (induction_phi, vec_init, pe, UNKNOWN_LOCATION);\n+  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n+\t       UNKNOWN_LOCATION);\n+\n+  STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = induction_phi;\n+\n+  /* In case that vectorization factor (VF) is bigger than the number\n+     of elements that we can fit in a vectype (nunits), we have to generate\n+     more than one vector stmt - i.e - we need to \"unroll\" the\n+     vector stmt by a factor VF/nunits.  For more details see documentation\n+     in vectorizable_operation.  */\n+\n+  if (ncopies > 1)\n+    {\n+      stmt_vec_info prev_stmt_vinfo;\n+      /* FORNOW. This restriction should be relaxed.  */\n+      gcc_assert (!nested_in_vect_loop);\n+\n+      /* Create the vector that holds the step of the induction.  */\n+      if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)))\n+\t{\n+\t  expr = build_int_cst (integer_type_node, nunits);\n+\t  expr = fold_convert (TREE_TYPE (step_expr), expr);\n+\t}\n+      else\n+\texpr = build_int_cst (TREE_TYPE (step_expr), nunits);\n+      new_name = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n+\t\t\t      expr, step_expr);\n+      if (TREE_CODE (step_expr) == SSA_NAME)\n+\tnew_name = vect_init_vector (phi, new_name,\n+\t\t\t\t     TREE_TYPE (step_expr), NULL);\n+      t = unshare_expr (new_name);\n+      gcc_assert (CONSTANT_CLASS_P (new_name)\n+\t\t  || TREE_CODE (new_name) == SSA_NAME);\n+      new_vec = build_vector_from_val (vectype, t);\n+      vec_step = vect_init_vector (phi, new_vec, vectype, NULL);\n+\n+      vec_def = induc_def;\n+      prev_stmt_vinfo = vinfo_for_stmt (induction_phi);\n+      for (i = 1; i < ncopies; i++)\n+\t{\n+\t  /* vec_i = vec_prev + vec_step  */\n+\t  new_stmt = gimple_build_assign (vec_dest, PLUS_EXPR,\n+\t\t\t\t\t  vec_def, vec_step);\n+\t  vec_def = make_ssa_name (vec_dest, new_stmt);\n+\t  gimple_assign_set_lhs (new_stmt, vec_def);\n+ \n+\t  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n+\t  set_vinfo_for_stmt (new_stmt,\n+\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo));\n+\t  STMT_VINFO_RELATED_STMT (prev_stmt_vinfo) = new_stmt;\n+\t  prev_stmt_vinfo = vinfo_for_stmt (new_stmt);\n+\t}\n+    }\n+\n+  if (nested_in_vect_loop)\n+    {\n+      /* Find the loop-closed exit-phi of the induction, and record\n+         the final vector of induction results:  */\n+      exit_phi = NULL;\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, loop_arg)\n+        {\n+\t  gimple *use_stmt = USE_STMT (use_p);\n+\t  if (is_gimple_debug (use_stmt))\n+\t    continue;\n+\n+\t  if (!flow_bb_inside_loop_p (iv_loop, gimple_bb (use_stmt)))\n+\t    {\n+\t      exit_phi = use_stmt;\n+\t      break;\n+\t    }\n+        }\n+      if (exit_phi)\n+\t{\n+\t  stmt_vec_info stmt_vinfo = vinfo_for_stmt (exit_phi);\n+\t  /* FORNOW. Currently not supporting the case that an inner-loop induction\n+\t     is not used in the outer-loop (i.e. only outside the outer-loop).  */\n+\t  gcc_assert (STMT_VINFO_RELEVANT_P (stmt_vinfo)\n+\t\t      && !STMT_VINFO_LIVE_P (stmt_vinfo));\n+\n+\t  STMT_VINFO_VEC_STMT (stmt_vinfo) = new_stmt;\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"vector of inductions after inner-loop:\");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, new_stmt, 0);\n+\t    }\n+\t}\n+    }\n+\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"transform induction: created def-use cycle: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, induction_phi, 0);\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n+\t\t\tSSA_NAME_DEF_STMT (vec_def), 0);\n+    }\n+\n   return true;\n }\n "}]}