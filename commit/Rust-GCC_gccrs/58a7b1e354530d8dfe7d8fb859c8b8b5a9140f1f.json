{"sha": "58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f", "node_id": "C_kwDOANBUbNoAKDU4YTdiMWUzNTQ1MzBkOGRmZTdkOGZiODU5YzhiOGI1YTkxNDBmMWY", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2022-11-30T17:05:56Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2022-12-04T10:39:36Z"}, "message": "coroutines: Do not promote temporaries that will be elided.\n\nWe usually need to 'promote' (i.e. save to the coroutine frame) any temporary\nvariable that is in a target expression that must persist across an await\nexpression.  However, if the TE is just used as a direct initializer for\nanother object it will be elided - and we should not promote it since that\nwould lead to a DTOR call for something that is never constructed.\n\nSince we now have a mechanism to tell if TEs will be elided, use that.\n\nAlthough the PRs referenced initially appear to be different issues, they all\nstem from this.\n\nCo-Authored-By: Adrian Perl <adrian.perl@web.de>\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\n\tPR c++/100611\n\tPR c++/101367\n\tPR c++/101976\n\tPR c++/99576\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (find_interesting_subtree): Do not promote temporaries\n\tthat are only used as direct initializers for some other object.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/coroutines/pr100611.C: New test.\n\t* g++.dg/coroutines/pr101367.C: New test.\n\t* g++.dg/coroutines/pr101976.C: New test.\n\t* g++.dg/coroutines/pr99576_1.C: New test.\n\t* g++.dg/coroutines/pr99576_2.C: New test.", "tree": {"sha": "1d5aa2a02785dc85b25480d17af01e2af6a0055b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d5aa2a02785dc85b25480d17af01e2af6a0055b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c45e67ac673bbddaaf9770a1a6944b382174938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c45e67ac673bbddaaf9770a1a6944b382174938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c45e67ac673bbddaaf9770a1a6944b382174938"}], "stats": {"total": 441, "additions": 441, "deletions": 0}, "files": [{"sha": "3f23317a315157864801abd12efbc98034c10adf", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f", "patch": "@@ -2685,6 +2685,7 @@ find_interesting_subtree (tree *expr_p, int *dosub, void *d)\n \t}\n     }\n   else if (tmp_target_expr_p (expr)\n+\t   && !TARGET_EXPR_ELIDING_P (expr)\n \t   && !p->temps_used->contains (expr))\n     {\n       p->entry = expr_p;"}, {"sha": "14edf4870a14560e58f6d5023d4f0767a3c4b7b4", "filename": "gcc/testsuite/g++.dg/coroutines/pr100611.C", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr100611.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr100611.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr100611.C?ref=58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f", "patch": "@@ -0,0 +1,94 @@\n+// { dg-do run }\n+/*\n+  Test that instances created in capture clauses within co_await statements do not\n+  get 'promoted'. This would lead to the members destructor getting called more\n+  than once.\n+\n+  Correct output should look like:\n+  Foo(23) 0xf042d8\n+  Foo(const& 23) 0xf042ec\n+  ~Foo(23) 0xf042ec\n+  After co_await\n+  ~Foo(23) 0xf042d8\n+*/\n+#include <coroutine>\n+#include <iostream>\n+\n+static unsigned int struct_Foo_destructor_counter = 0;\n+static bool lambda_was_executed = false;\n+\n+class Task {\n+public:\n+  struct promise_type {\n+    Task get_return_object() {\n+      return {std::coroutine_handle<promise_type>::from_promise(*this)};\n+    }\n+\n+    std::suspend_never initial_suspend() { return {}; }\n+    std::suspend_always final_suspend() noexcept { return {}; }\n+    void unhandled_exception() {}\n+    void return_void() {}\n+  };\n+\n+  ~Task() {\n+    if (handle_) {\n+      handle_.destroy();\n+    }\n+  }\n+\n+  bool await_ready() { return false; }\n+  bool await_suspend(std::coroutine_handle<>) { return false; }\n+  bool await_resume() { return false; }\n+\n+private:\n+  Task(std::coroutine_handle<promise_type> handle) : handle_(handle) {}\n+\n+  std::coroutine_handle<promise_type> handle_;\n+};\n+\n+class Foo {\n+public:\n+  Foo(int id) : id_(id) {\n+    std::cout << \"Foo(\" << id_ << \") \" << (void*)this << std::endl;\n+  }\n+\n+  Foo(Foo const& other) : id_(other.id_) {\n+    std::cout << \"Foo(const& \" << id_ << \") \" << (void*)this << std::endl;\n+  }\n+\n+  Foo(Foo&& other) : id_(other.id_) {\n+    std::cout << \"Foo(&& \" << id_ << \") \" << (void*)this << std::endl;\n+  }\n+\n+  ~Foo() {\n+    std::cout << \"~Foo(\" << id_ << \") \" << (void*)this << std::endl;\n+    struct_Foo_destructor_counter++;\n+\n+    if (struct_Foo_destructor_counter > 2){\n+      std::cout << \"Foo was destroyed more than two times!\\n\";\n+      __builtin_abort();\n+    }\n+    }\n+\n+private:\n+  int id_;\n+};\n+\n+Task test() {\n+  Foo foo(23);\n+\n+  co_await [foo]() -> Task { // A copy of foo is captured. This copy must not get 'promoted'.\n+    co_return;\n+  }();\n+\n+  std::cout << \"After co_await\\n\";\n+  if (struct_Foo_destructor_counter == 0){\n+    std::cout << \"The captured copy of foo was not destroyed after the co_await statement!\\n\";\n+    __builtin_abort();\n+  }\n+}\n+\n+int main() {\n+  test();\n+  return 0;\n+}"}, {"sha": "0a9e5bee7d170e1591302cbc4a716243c59cac90", "filename": "gcc/testsuite/g++.dg/coroutines/pr101367.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr101367.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr101367.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr101367.C?ref=58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f", "patch": "@@ -0,0 +1,72 @@\n+// { dg-do run }\n+\n+#include <coroutine>\n+using namespace std;\n+#include <cstdio>\n+#include <utility>\n+#include <string>\n+\n+struct resource {\n+    template<typename Func>\n+    resource(Func fn) { fn(); /*std::printf(\"resource()\\n\"); */}\n+    ~resource() { /*std::printf(\"~resource()\\n\"); */}\n+    resource(resource&&) = delete;\n+};\n+\n+template<typename T>\n+struct generator {\n+    struct promise_type {\n+        generator get_return_object() {\n+            return generator{coroutine_handle<promise_type>::from_promise(*this)};\n+        }\n+\n+        void return_void() {}\n+        void unhandled_exception() {}\n+        suspend_always initial_suspend() { return {}; }\n+        suspend_always final_suspend() noexcept { return {}; }\n+\n+        struct awaitable {\n+            resource& r;\n+\n+            awaitable(resource&& r) : r(r) {}\n+\n+            bool await_ready() noexcept { return false; }\n+\n+            void await_suspend(coroutine_handle<> h) noexcept {\n+                //std::printf(\"awaitable::await_suspend()\\n\");\n+            }\n+\n+            void await_resume() noexcept {\n+                //std::printf(\"awaitable::await_resume()\\n\");\n+            }\n+        };\n+\n+        awaitable yield_value(resource&& r) {\n+            return awaitable{std::move(r)};\n+        }\n+    };\n+\n+    generator(coroutine_handle<promise_type> coro) : coro(coro)\n+    {}\n+\n+    generator(generator&& g) noexcept : coro(std::exchange(g.coro, {}))\n+    {}\n+\n+    ~generator() {\n+        if (coro) { coro.destroy(); }\n+    }\n+\n+    coroutine_handle<promise_type> coro;\n+};\n+\n+generator<int> f() {\n+    std::string s;\n+    // if `s` isn't captured things work ok\n+    co_yield resource{[s]{}};\n+}\n+\n+int main() {\n+    generator x = f();\n+    x.coro.resume();\n+    x.coro.resume();\n+}"}, {"sha": "1854ba001bb378664e9e67aed6840b0ed0e5a65f", "filename": "gcc/testsuite/g++.dg/coroutines/pr101976.C", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr101976.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr101976.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr101976.C?ref=58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f", "patch": "@@ -0,0 +1,78 @@\n+// { dg-do run }\n+\n+/*\n+  Test that members of temporary instances in co_await statements do not get\n+  'promoted'. This would lead to the members destructor getting called more\n+  than once.\n+\n+  Correct output should look like:\n+  Before co_await\n+  nontrivial_move() 0x6ec2e1\n+  nontrivial_move(nontrivial_move&&) 0x6ed320\n+  In subtask\n+  ~nontrivial_move() 0x6ed320\n+  ~nontrivial_move() 0x6ec2e1\n+  After co_await\n+*/\n+#include <coroutine>\n+#include <iostream>\n+\n+static unsigned int struct_nontrivial_move_destructor_counter = 0;\n+\n+struct task {\n+  struct promise_type {\n+    task get_return_object() {\n+      return {std::coroutine_handle<promise_type>::from_promise(*this)};\n+    }\n+    std::suspend_never initial_suspend() { return {}; }\n+    std::suspend_never final_suspend() noexcept { return {}; }\n+    void unhandled_exception() {}\n+    void return_void() {}\n+  };\n+\n+  bool await_ready() { return true; }\n+  void await_suspend(std::coroutine_handle<>) {}\n+  void await_resume() {}\n+\n+  std::coroutine_handle<promise_type> m_handle;\n+};\n+\n+struct nontrivial_move {\n+  nontrivial_move() {\n+    std::cout << \"nontrivial_move() \" << (void *)this << std::endl;\n+  }\n+  nontrivial_move(nontrivial_move&&) {\n+    std::cout << \"nontrivial_move(nontrivial_move&&) \" << (void *)this\n+              << std::endl;\n+  }\n+  ~nontrivial_move() {\n+    std::cout << \"~nontrivial_move() \" << (void *)this << std::endl;\n+    struct_nontrivial_move_destructor_counter++;\n+    if (struct_nontrivial_move_destructor_counter > 2){\n+      std::cerr << \"The destructor of nontrivial_move was called more than two times!\\n\";\n+      __builtin_abort();\n+    }\n+  }\n+\n+  char buf[128]{}; // Example why the move could be non trivial\n+};\n+\n+struct wrapper {\n+  nontrivial_move member;\n+};\n+\n+task subtask(wrapper /* unused */) {\n+  std::cout << \"In subtask\\n\";\n+  co_return;\n+}\n+\n+task main_task() {\n+  std::cout << \"Before co_await\\n\";\n+  co_await subtask({}); // wrapper must get 'promoted', but not its member\n+  std::cout << \"After co_await\\n\";\n+}\n+\n+int main() {\n+  main_task();\n+  return 0;\n+}"}, {"sha": "612f0cda2b18410559264cf8d67acbadf7213138", "filename": "gcc/testsuite/g++.dg/coroutines/pr99576_1.C", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr99576_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr99576_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr99576_1.C?ref=58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f", "patch": "@@ -0,0 +1,124 @@\n+// { dg-do run }\n+/*\n+  Test that instances created in capture clauses within co_await statements do not get\n+  'promoted'. This would lead to their members destructors getting called more\n+  than once.\n+\n+  Correct output should look like:\n+  START TASK\n+  Foo() 0x4f9320\n+  IN LAMBDA\n+  ~Foo() 0x4f9320\n+  TASK RETURN\n+*/\n+#include <coroutine>\n+#include <exception>\n+#include <iostream>\n+#include <utility>\n+\n+static unsigned int struct_Foo_destructor_counter = 0;\n+static bool lambda_was_executed = false;\n+\n+class Task {\n+public:\n+  struct promise_type {\n+    struct final_awaitable {\n+      bool await_ready() noexcept { return false; }\n+      auto await_suspend(std::coroutine_handle<promise_type> coro) noexcept {\n+        return coro.promise().continuation;\n+      }\n+      void await_resume() noexcept {}\n+    };\n+    Task get_return_object() {\n+      return Task(std::coroutine_handle<promise_type>::from_promise(*this));\n+    }\n+    std::suspend_always initial_suspend() { return {}; }\n+    final_awaitable final_suspend() noexcept { return {}; }\n+    void unhandled_exception() { std::terminate(); }\n+    void return_void() {}\n+\n+    std::coroutine_handle<void> continuation = std::noop_coroutine();\n+  };\n+\n+  Task(Task const&) = delete;\n+  Task(Task&& other) noexcept\n+      : handle_(std::exchange(other.handle_, nullptr)) {}\n+  Task& operator=(Task const&) = delete;\n+  Task& operator=(Task&& other) noexcept {\n+    handle_ = std::exchange(other.handle_, nullptr);\n+    return *this;\n+  }\n+  ~Task() {\n+    if (handle_) {\n+      handle_.destroy();\n+    }\n+  }\n+\n+  bool await_ready() const { return false; }\n+  auto await_suspend(std::coroutine_handle<void> continuation) {\n+    handle_.promise().continuation = continuation;\n+    return handle_;\n+  }\n+  void await_resume() {}\n+\n+private:\n+  explicit Task(std::coroutine_handle<promise_type> handle) : handle_(handle) {}\n+\n+  std::coroutine_handle<promise_type> handle_;\n+};\n+\n+struct RunTask {\n+  struct promise_type {\n+    RunTask get_return_object() { return {}; }\n+    std::suspend_never initial_suspend() { return {}; }\n+    std::suspend_never final_suspend() noexcept { return {}; }\n+    void return_void() {}\n+    void unhandled_exception() { std::terminate(); }\n+  };\n+};\n+\n+struct Foo {\n+  Foo() {\n+    std::cout << \"Foo() \" << (void *)this << std::endl;\n+  }\n+\n+  ~Foo() {\n+    std::cout << \"~Foo() \" << (void *)this << std::endl;\n+    struct_Foo_destructor_counter++;\n+\n+    if (struct_Foo_destructor_counter > 1 || !lambda_was_executed) {\n+      std::cout << \"The destructor of Foo was called more than once or too early!\\n\";\n+      __builtin_abort();\n+    }\n+  }\n+\n+  Foo(Foo&&) = delete;\n+  Foo(Foo const&) = delete;\n+  Foo& operator=(Foo&&) = delete;\n+  Foo& operator=(Foo const&) = delete;\n+};\n+\n+Task DoAsync() {\n+  std::cout << \"START TASK\\n\";\n+  co_await [foo = Foo{}]() -> Task { // foo is constructed inplace, no copy/move is performed.\n+                                     // foo itself must not get 'promoted'.\n+    std::cout << \"IN LAMBDA\\n\";\n+    lambda_was_executed = true;\n+    co_return;\n+  }();\n+  // After the co_await statement the temporary lambda and foo\n+  // must now have been destroyed\n+  if (struct_Foo_destructor_counter == 0){\n+    std::cout << \"foo was not destroyed after the co_await statement!\\n\";\n+    __builtin_abort();\n+  }\n+  std::cout << \"TASK RETURN\\n\";\n+  co_return;\n+}\n+\n+RunTask Main() { co_await DoAsync(); }\n+\n+int main() {\n+  Main();\n+  return 0;\n+}"}, {"sha": "b7371d64480e9e320e4965217bf6b0078f55a092", "filename": "gcc/testsuite/g++.dg/coroutines/pr99576_2.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr99576_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr99576_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr99576_2.C?ref=58a7b1e354530d8dfe7d8fb859c8b8b5a9140f1f", "patch": "@@ -0,0 +1,72 @@\n+// { dg-do run }\n+/*\n+  Test that members of temporary awaitables in co_await statements do not get\n+  'promoted'. This would lead to the members destructor getting called more\n+  than once.\n+\n+  Correct output should look like:\n+  A 0x4f82d6\n+  ~A 0x4f82d6\n+*/\n+#include <coroutine>\n+#include <iostream>\n+\n+\n+static unsigned int struct_A_destructor_counter = 0;\n+\n+struct task : std::coroutine_handle<> {\n+  struct promise_type;\n+};\n+\n+struct task::promise_type {\n+  task get_return_object() {\n+    return {std::coroutine_handle<promise_type>::from_promise(*this)};\n+  }\n+  std::suspend_always initial_suspend() { return {}; }\n+  std::suspend_always final_suspend() noexcept { return {}; }\n+  void unhandled_exception() { std::terminate(); }\n+  void return_void() {}\n+};\n+\n+struct A {\n+  void log(const char *str) { std::cout << str << \" \" << (void *)this << std::endl; }\n+\n+  A() { log(__func__); }\n+\n+  ~A() {\n+    log(__func__);\n+    struct_A_destructor_counter++;\n+\n+    if (struct_A_destructor_counter > 1) {\n+      std::cout << \"The destructor of A was called more than once!\\n\";\n+      __builtin_abort();\n+    }\n+  }\n+\n+  A(A&&) = delete;\n+  A(A const&) = delete;\n+  A& operator=(A&&) = delete;\n+  A& operator=(A const&) = delete;\n+};\n+\n+struct Awaitable {\n+  A a{}; // <- This member must NOT get 'promoted'\n+  bool await_ready() { return false; }\n+  void await_suspend(std::coroutine_handle<> handle) {}\n+  void await_resume() {}\n+};\n+\n+task coroutine() {\n+  co_await Awaitable{}; // <- This temporary must get 'promoted'\n+}\n+\n+int main() {\n+\n+  auto task = coroutine();\n+  while (!task.done()) {\n+    task();\n+  }\n+  task.destroy();\n+\n+  return 0;\n+}"}]}