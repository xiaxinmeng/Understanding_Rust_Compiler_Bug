{"sha": "f49b295a191729400b3cbb9bf9e8d1dffedde666", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ5YjI5NWExOTE3Mjk0MDBiM2NiYjliZjllOGQxZGZmZWRkZTY2Ng==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2009-10-17T06:28:43Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2009-10-17T06:28:43Z"}, "message": "re PR debug/41535 (Broken var location info after scheduling)\n\nPR debug/41535\n* sched-deps.c (depl_on_debug_p): New.\n(attach_dep_link): Reject debug deps before nondebug deps.\n(add_to_deps_list): Insert debug deps after nondebug deps.\n(sd_lists_empty_p): Stop at first nonempty list.  Disregard debug\ndeps.\n(sd_add_dep): Do not reject debug deps.\n(add_insn_mem_dependence): Don't count debug deps.\n(remove_from_deps): Likewise.\n(sched_analyze_2): Set up mem deps on debug insns.\n(sched_analyze_insn): Record reg uses for deps on debug insns.\n* haifa-sched.c (schedule_insn): Reset deferred debug insn.  Don't\ntry_ready nondebug insn after debug insn.\n* ddg.c (create_ddg_dep_from_intra_loop_link,\ncreate_ddg_dep_no_link): Don't reject debug deps.\n\nFrom-SVN: r152927", "tree": {"sha": "aba3b71df6de715f9777fb83f5018b7b4c61856c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aba3b71df6de715f9777fb83f5018b7b4c61856c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f49b295a191729400b3cbb9bf9e8d1dffedde666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f49b295a191729400b3cbb9bf9e8d1dffedde666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f49b295a191729400b3cbb9bf9e8d1dffedde666", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f49b295a191729400b3cbb9bf9e8d1dffedde666/comments", "author": null, "committer": null, "parents": [{"sha": "af16209f32e1920919942ae2989fa1b857dfe73c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af16209f32e1920919942ae2989fa1b857dfe73c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af16209f32e1920919942ae2989fa1b857dfe73c"}], "stats": {"total": 195, "additions": 140, "deletions": 55}, "files": [{"sha": "212a9e2fd13cb188f2b6287015408aa2642ea001", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49b295a191729400b3cbb9bf9e8d1dffedde666/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49b295a191729400b3cbb9bf9e8d1dffedde666/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f49b295a191729400b3cbb9bf9e8d1dffedde666", "patch": "@@ -1,3 +1,21 @@\n+2009-10-17  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41535\n+\t* sched-deps.c (depl_on_debug_p): New.\n+\t(attach_dep_link): Reject debug deps before nondebug deps.\n+\t(add_to_deps_list): Insert debug deps after nondebug deps.\n+\t(sd_lists_empty_p): Stop at first nonempty list.  Disregard debug\n+\tdeps.\n+\t(sd_add_dep): Do not reject debug deps.\n+\t(add_insn_mem_dependence): Don't count debug deps.\n+\t(remove_from_deps): Likewise.\n+\t(sched_analyze_2): Set up mem deps on debug insns.\n+\t(sched_analyze_insn): Record reg uses for deps on debug insns.\n+\t* haifa-sched.c (schedule_insn): Reset deferred debug insn.  Don't\n+\ttry_ready nondebug insn after debug insn.\n+\t* ddg.c (create_ddg_dep_from_intra_loop_link,\n+\tcreate_ddg_dep_no_link): Don't reject debug deps.\n+\n 2009-10-16  Richard Guenther  <rguenther@suse.de>\n \n \t* lto-symtab.c (merge_incomplete_and_complete_type): Remove."}, {"sha": "c06ea75ea2d1e8d3db84488ec0607ad7a284688a", "filename": "gcc/ddg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49b295a191729400b3cbb9bf9e8d1dffedde666/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49b295a191729400b3cbb9bf9e8d1dffedde666/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=f49b295a191729400b3cbb9bf9e8d1dffedde666", "patch": "@@ -167,7 +167,7 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n     t = OUTPUT_DEP;\n \n   gcc_assert (!DEBUG_INSN_P (dest_node->insn) || t == ANTI_DEP);\n-  gcc_assert (!DEBUG_INSN_P (src_node->insn) || DEBUG_INSN_P (dest_node->insn));\n+  gcc_assert (!DEBUG_INSN_P (src_node->insn) || t == ANTI_DEP);\n \n   /* We currently choose not to create certain anti-deps edges and\n      compensate for that by generating reg-moves based on the life-range\n@@ -213,7 +213,7 @@ create_ddg_dep_no_link (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to,\n   struct _dep _dep, *dep = &_dep;\n \n   gcc_assert (!DEBUG_INSN_P (to->insn) || d_t == ANTI_DEP);\n-  gcc_assert (!DEBUG_INSN_P (from->insn) || DEBUG_INSN_P (to->insn));\n+  gcc_assert (!DEBUG_INSN_P (from->insn) || d_t == ANTI_DEP);\n \n   if (d_t == ANTI_DEP)\n     dep_kind = REG_DEP_ANTI;"}, {"sha": "bc947fad6f667c8c2cae61f00010d9c5272639b7", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49b295a191729400b3cbb9bf9e8d1dffedde666/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49b295a191729400b3cbb9bf9e8d1dffedde666/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f49b295a191729400b3cbb9bf9e8d1dffedde666", "patch": "@@ -989,7 +989,7 @@ dep_list_size (rtx insn)\n     {\n       if (DEBUG_INSN_P (DEP_CON (dep)))\n \tdbgcount++;\n-      else\n+      else if (!DEBUG_INSN_P (DEP_PRO (dep)))\n \tnodbgcount++;\n     }\n \n@@ -1688,6 +1688,39 @@ schedule_insn (rtx insn)\n      should have been removed from the ready list.  */\n   gcc_assert (sd_lists_empty_p (insn, SD_LIST_BACK));\n \n+  /* Reset debug insns invalidated by moving this insn.  */\n+  if (MAY_HAVE_DEBUG_INSNS && !DEBUG_INSN_P (insn))\n+    for (sd_it = sd_iterator_start (insn, SD_LIST_BACK);\n+\t sd_iterator_cond (&sd_it, &dep);)\n+      {\n+\trtx dbg = DEP_PRO (dep);\n+\n+\tgcc_assert (DEBUG_INSN_P (dbg));\n+\n+\tif (sched_verbose >= 6)\n+\t  fprintf (sched_dump, \";;\\t\\tresetting: debug insn %d\\n\",\n+\t\t   INSN_UID (dbg));\n+\n+\t/* ??? Rather than resetting the debug insn, we might be able\n+\t   to emit a debug temp before the just-scheduled insn, but\n+\t   this would involve checking that the expression at the\n+\t   point of the debug insn is equivalent to the expression\n+\t   before the just-scheduled insn.  They might not be: the\n+\t   expression in the debug insn may depend on other insns not\n+\t   yet scheduled that set MEMs, REGs or even other debug\n+\t   insns.  It's not clear that attempting to preserve debug\n+\t   information in these cases is worth the effort, given how\n+\t   uncommon these resets are and the likelihood that the debug\n+\t   temps introduced won't survive the schedule change.  */\n+\tINSN_VAR_LOCATION_LOC (dbg) = gen_rtx_UNKNOWN_VAR_LOC ();\n+\tdf_insn_rescan (dbg);\n+\n+\t/* We delete rather than resolve these deps, otherwise we\n+\t   crash in sched_free_deps(), because forward deps are\n+\t   expected to be released before backward deps.  */\n+\tsd_delete_dep (sd_it);\n+      }\n+\n   gcc_assert (QUEUE_INDEX (insn) == QUEUE_NOWHERE);\n   QUEUE_INDEX (insn) = QUEUE_SCHEDULED;\n \n@@ -1712,6 +1745,12 @@ schedule_insn (rtx insn)\n \t advancing the iterator.  */\n       sd_resolve_dep (sd_it);\n \n+      /* Don't bother trying to mark next as ready if insn is a debug\n+\t insn.  If insn is the last hard dependency, it will have\n+\t already been discounted.  */\n+      if (DEBUG_INSN_P (insn) && !DEBUG_INSN_P (next))\n+\tcontinue;\n+\n       if (!IS_SPECULATION_BRANCHY_CHECK_P (insn))\n \t{\n \t  int effective_cost;      "}, {"sha": "1fd484d97aab4ae86f94e4f7b121d1b5778683d8", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 80, "deletions": 52, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f49b295a191729400b3cbb9bf9e8d1dffedde666/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f49b295a191729400b3cbb9bf9e8d1dffedde666/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=f49b295a191729400b3cbb9bf9e8d1dffedde666", "patch": "@@ -211,6 +211,16 @@ sd_debug_dep (dep_t dep)\n   fprintf (stderr, \"\\n\");\n }\n \n+/* Determine whether DEP is a dependency link of a non-debug insn on a\n+   debug insn.  */\n+\n+static inline bool\n+depl_on_debug_p (dep_link_t dep)\n+{\n+  return (DEBUG_INSN_P (DEP_LINK_PRO (dep))\n+\t  && !DEBUG_INSN_P (DEP_LINK_CON (dep)));\n+}\n+\n /* Functions to operate with a single link from the dependencies lists -\n    dep_link_t.  */\n \n@@ -246,7 +256,9 @@ add_to_deps_list (dep_link_t link, deps_list_t l)\n {\n   attach_dep_link (link, &DEPS_LIST_FIRST (l));\n \n-  ++DEPS_LIST_N_LINKS (l);\n+  /* Don't count debug deps.  */\n+  if (!depl_on_debug_p (link))\n+    ++DEPS_LIST_N_LINKS (l);\n }\n \n /* Detach dep_link L from the list.  */\n@@ -271,7 +283,9 @@ remove_from_deps_list (dep_link_t link, deps_list_t list)\n {\n   detach_dep_link (link);\n \n-  --DEPS_LIST_N_LINKS (list);\n+  /* Don't count debug deps.  */\n+  if (!depl_on_debug_p (link))\n+    --DEPS_LIST_N_LINKS (list);\n }\n \n /* Move link LINK from list FROM to list TO.  */\n@@ -668,10 +682,21 @@ sd_lists_size (const_rtx insn, sd_list_types_def list_types)\n }\n \n /* Return true if INSN's lists defined by LIST_TYPES are all empty.  */\n+\n bool\n sd_lists_empty_p (const_rtx insn, sd_list_types_def list_types)\n {\n-  return sd_lists_size (insn, list_types) == 0;\n+  while (list_types != SD_LIST_NONE)\n+    {\n+      deps_list_t list;\n+      bool resolved_p;\n+\n+      sd_next_list (insn, &list_types, &list, &resolved_p);\n+      if (!deps_list_empty_p (list))\n+\treturn false;\n+    }\n+\n+  return true;\n }\n \n /* Initialize data for INSN.  */\n@@ -1201,7 +1226,6 @@ sd_add_dep (dep_t dep, bool resolved_p)\n   rtx insn = DEP_CON (dep);\n \n   gcc_assert (INSN_P (insn) && INSN_P (elem) && insn != elem);\n-  gcc_assert (!DEBUG_INSN_P (elem) || DEBUG_INSN_P (insn));\n \n   if ((current_sched_info->flags & DO_SPECULATION)\n       && !sched_insn_is_legitimate_for_speculation_p (insn, DEP_STATUS (dep)))\n@@ -1528,7 +1552,8 @@ add_insn_mem_dependence (struct deps *deps, bool read_p,\n     {\n       insn_list = &deps->pending_read_insns;\n       mem_list = &deps->pending_read_mems;\n-      deps->pending_read_list_length++;\n+      if (!DEBUG_INSN_P (insn))\n+\tdeps->pending_read_list_length++;\n     }\n   else\n     {\n@@ -2408,63 +2433,63 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \trtx pending, pending_mem;\n \trtx t = x;\n \n-\tif (DEBUG_INSN_P (insn))\n-\t  {\n-\t    sched_analyze_2 (deps, XEXP (x, 0), insn);\n-\t    return;\n-\t  }\n-\n \tif (sched_deps_info->use_cselib)\n \t  {\n \t    t = shallow_copy_rtx (t);\n \t    cselib_lookup (XEXP (t, 0), Pmode, 1);\n \t    XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n \t  }\n-\tt = canon_rtx (t);\n-\tpending = deps->pending_read_insns;\n-\tpending_mem = deps->pending_read_mems;\n-\twhile (pending)\n-\t  {\n-\t    if (read_dependence (XEXP (pending_mem, 0), t)\n-\t\t&& ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t      note_mem_dep (t, XEXP (pending_mem, 0), XEXP (pending, 0),\n-\t\t\t    DEP_ANTI);\n-\n-\t    pending = XEXP (pending, 1);\n-\t    pending_mem = XEXP (pending_mem, 1);\n-\t  }\n \n-\tpending = deps->pending_write_insns;\n-\tpending_mem = deps->pending_write_mems;\n-\twhile (pending)\n+\tif (!DEBUG_INSN_P (insn))\n \t  {\n-\t    if (true_dependence (XEXP (pending_mem, 0), VOIDmode,\n-\t\t\t\t t, rtx_varies_p)\n-\t\t&& ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t      note_mem_dep (t, XEXP (pending_mem, 0), XEXP (pending, 0),\n-\t\t\t    sched_deps_info->generate_spec_deps\n-\t\t\t    ? BEGIN_DATA | DEP_TRUE : DEP_TRUE);\n-\n-\t    pending = XEXP (pending, 1);\n-\t    pending_mem = XEXP (pending_mem, 1);\n-\t  }\n+\t    t = canon_rtx (t);\n+\t    pending = deps->pending_read_insns;\n+\t    pending_mem = deps->pending_read_mems;\n+\t    while (pending)\n+\t      {\n+\t\tif (read_dependence (XEXP (pending_mem, 0), t)\n+\t\t    && ! sched_insns_conditions_mutex_p (insn,\n+\t\t\t\t\t\t\t XEXP (pending, 0)))\n+\t\t  note_mem_dep (t, XEXP (pending_mem, 0), XEXP (pending, 0),\n+\t\t\t\tDEP_ANTI);\n+\n+\t\tpending = XEXP (pending, 1);\n+\t\tpending_mem = XEXP (pending_mem, 1);\n+\t      }\n \n-\tfor (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\t  {\n-\t    if (! JUMP_P (XEXP (u, 0)))\n-\t      add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t    else if (deps_may_trap_p (x))\n+\t    pending = deps->pending_write_insns;\n+\t    pending_mem = deps->pending_write_mems;\n+\t    while (pending)\n \t      {\n-\t\tif ((sched_deps_info->generate_spec_deps)\n-\t\t    && sel_sched_p () && (spec_info->mask & BEGIN_CONTROL))\n-\t\t  {\n-\t\t    ds_t ds = set_dep_weak (DEP_ANTI, BEGIN_CONTROL,\n-\t\t\t\t\t    MAX_DEP_WEAK);\n+\t\tif (true_dependence (XEXP (pending_mem, 0), VOIDmode,\n+\t\t\t\t     t, rtx_varies_p)\n+\t\t    && ! sched_insns_conditions_mutex_p (insn,\n+\t\t\t\t\t\t\t XEXP (pending, 0)))\n+\t\t  note_mem_dep (t, XEXP (pending_mem, 0), XEXP (pending, 0),\n+\t\t\t\tsched_deps_info->generate_spec_deps\n+\t\t\t\t? BEGIN_DATA | DEP_TRUE : DEP_TRUE);\n+\n+\t\tpending = XEXP (pending, 1);\n+\t\tpending_mem = XEXP (pending_mem, 1);\n+\t      }\n \n-\t\t    note_dep (XEXP (u, 0), ds);\n-\t\t  }\n-\t\telse\n+\t    for (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n+\t      {\n+\t\tif (! JUMP_P (XEXP (u, 0)))\n \t\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t\telse if (deps_may_trap_p (x))\n+\t\t  {\n+\t\t    if ((sched_deps_info->generate_spec_deps)\n+\t\t\t&& sel_sched_p () && (spec_info->mask & BEGIN_CONTROL))\n+\t\t      {\n+\t\t\tds_t ds = set_dep_weak (DEP_ANTI, BEGIN_CONTROL,\n+\t\t\t\t\t\tMAX_DEP_WEAK);\n+\n+\t\t\tnote_dep (XEXP (u, 0), ds);\n+\t\t      }\n+\t\t    else\n+\t\t      add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t\t  }\n \t      }\n \t  }\n \n@@ -2473,7 +2498,6 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n         if (!deps->readonly)\n           add_insn_mem_dependence (deps, true, insn, x);\n \n-\t/* Take advantage of tail recursion here.  */\n \tsched_analyze_2 (deps, XEXP (x, 0), insn);\n \n \tif (cslr_p && sched_deps_info->finish_rhs)\n@@ -2773,6 +2797,9 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n \t  struct deps_reg *reg_last = &deps->reg_last[i];\n \t  add_dependence_list (insn, reg_last->sets, 1, REG_DEP_ANTI);\n \t  add_dependence_list (insn, reg_last->clobbers, 1, REG_DEP_ANTI);\n+\n+\t  if (!deps->readonly)\n+\t    reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n \t}\n       CLEAR_REG_SET (reg_pending_uses);\n \n@@ -3505,7 +3532,8 @@ remove_from_deps (struct deps *deps, rtx insn)\n   \n   removed = remove_from_both_dependence_lists (insn, &deps->pending_read_insns,\n                                                &deps->pending_read_mems);\n-  deps->pending_read_list_length -= removed;\n+  if (!DEBUG_INSN_P (insn))\n+    deps->pending_read_list_length -= removed;\n   removed = remove_from_both_dependence_lists (insn, &deps->pending_write_insns,\n                                                &deps->pending_write_mems);\n   deps->pending_write_list_length -= removed;"}]}