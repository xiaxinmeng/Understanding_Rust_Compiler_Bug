{"sha": "bee1d478578db03924bf2505092db9ee967190da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVlMWQ0Nzg1NzhkYjAzOTI0YmYyNTA1MDkyZGI5ZWU5NjcxOTBkYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-18T13:03:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-18T13:03:46Z"}, "message": "re PR tree-optimization/63914 (ICE in set_lattice_value, at tree-ssa-ccp.c:517)\n\n2014-11-18  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/63914\n\t* tree-ssa-ccp.c (canonicalize_value): Remove float value\n\tcanonicalization.\n\t(valid_lattice_transition): Allow (partial) transition\n\tfrom NaN to non-NaN if !HONOR_NANS.\n\t(set_lattice_value): Check for valid lattice transitions\n\tonly when checking is enabled.\n\n\t* gcc.dg/pr63914.c: New testcase.\n\nFrom-SVN: r217712", "tree": {"sha": "41bc9661bf4c4b0f4a1663b999f73d3a69378d74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41bc9661bf4c4b0f4a1663b999f73d3a69378d74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bee1d478578db03924bf2505092db9ee967190da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bee1d478578db03924bf2505092db9ee967190da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bee1d478578db03924bf2505092db9ee967190da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bee1d478578db03924bf2505092db9ee967190da/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "60dcf0e05338baa02e0857cfca2742072994817a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60dcf0e05338baa02e0857cfca2742072994817a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60dcf0e05338baa02e0857cfca2742072994817a"}], "stats": {"total": 150, "additions": 105, "deletions": 45}, "files": [{"sha": "0bce05ab31711c519ba9b08ffbed294c1f945fec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee1d478578db03924bf2505092db9ee967190da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee1d478578db03924bf2505092db9ee967190da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bee1d478578db03924bf2505092db9ee967190da", "patch": "@@ -1,3 +1,13 @@\n+2014-11-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63914\n+\t* tree-ssa-ccp.c (canonicalize_value): Remove float value\n+\tcanonicalization.\n+\t(valid_lattice_transition): Allow (partial) transition\n+\tfrom NaN to non-NaN if !HONOR_NANS.\n+\t(set_lattice_value): Check for valid lattice transitions\n+\tonly when checking is enabled.\n+\n 2014-11-18  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* config/nvptx/nvptx.c: Include <sstream> directly after \"config.h\"."}, {"sha": "679db5b350e346e4362b7fc039ff729b4c3021ca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee1d478578db03924bf2505092db9ee967190da/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee1d478578db03924bf2505092db9ee967190da/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bee1d478578db03924bf2505092db9ee967190da", "patch": "@@ -1,3 +1,8 @@\n+2014-11-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63914\n+\t* gcc.dg/pr63914.c: New testcase.\n+\n 2014-11-18  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/55443"}, {"sha": "fe57288b74db87b130df2ca1d6921cf200c6aac5", "filename": "gcc/testsuite/gcc.dg/pr63914.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee1d478578db03924bf2505092db9ee967190da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr63914.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee1d478578db03924bf2505092db9ee967190da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr63914.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr63914.c?ref=bee1d478578db03924bf2505092db9ee967190da", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+typedef float __m128 __attribute__ ((__vector_size__ (16)));\n+__m128 a, d, e;\n+int b;\n+struct dt_interpolation c;\n+__m128\n+fn1 (float p1)\n+{\n+  return (__attribute__ ((__vector_size__ (4 * sizeof 0))) float){ p1 };\n+}\n+__m128\n+fn2 (float p1)\n+{\n+  return fn1 (p1);\n+}\n+struct dt_interpolation\n+{\n+  int width;\n+};\n+void\n+fn3 (struct dt_interpolation *p1, int *p2)\n+{\n+  int i = 0, n = 0;\n+  while (i < 2 * p1->width)\n+    n = i++;\n+  *p2 = n;\n+}\n+void\n+fn4 ()\n+{\n+  __m128 f;\n+  fn3 (&c, &b);\n+  __m128 g = fn2 (1.f / b);\n+  e = (__m128){};\n+  __m128 h = e;\n+  for (int i = 0; i < 2 * c.width; i++)\n+    {\n+      for (; c.width;)\n+\tf = a;\n+      h = f;\n+    }\n+  d = h * g;\n+}"}, {"sha": "2c8f6b9effd779f288a951ad291c499d35e8bfb0", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee1d478578db03924bf2505092db9ee967190da/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee1d478578db03924bf2505092db9ee967190da/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=bee1d478578db03924bf2505092db9ee967190da", "patch": "@@ -402,58 +402,16 @@ set_value_varying (tree var)\n   val->mask = -1;\n }\n \n-/* For float types, modify the value of VAL to make ccp work correctly\n-   for non-standard values (-0, NaN):\n-\n-   If HONOR_SIGNED_ZEROS is false, and VAL = -0, we canonicalize it to 0.\n-   If HONOR_NANS is false, and VAL is NaN, we canonicalize it to UNDEFINED.\n-     This is to fix the following problem (see PR 29921): Suppose we have\n-\n-     x = 0.0 * y\n-\n-     and we set value of y to NaN.  This causes value of x to be set to NaN.\n-     When we later determine that y is in fact VARYING, fold uses the fact\n-     that HONOR_NANS is false, and we try to change the value of x to 0,\n-     causing an ICE.  With HONOR_NANS being false, the real appearance of\n-     NaN would cause undefined behavior, though, so claiming that y (and x)\n-     are UNDEFINED initially is correct.\n-\n-  For other constants, make sure to drop TREE_OVERFLOW.  */\n+/* For integer constants, make sure to drop TREE_OVERFLOW.  */\n \n static void\n canonicalize_value (ccp_prop_value_t *val)\n {\n-  machine_mode mode;\n-  tree type;\n-  REAL_VALUE_TYPE d;\n-\n   if (val->lattice_val != CONSTANT)\n     return;\n \n   if (TREE_OVERFLOW_P (val->value))\n     val->value = drop_tree_overflow (val->value);\n-\n-  if (TREE_CODE (val->value) != REAL_CST)\n-    return;\n-\n-  d = TREE_REAL_CST (val->value);\n-  type = TREE_TYPE (val->value);\n-  mode = TYPE_MODE (type);\n-\n-  if (!HONOR_SIGNED_ZEROS (mode)\n-      && REAL_VALUE_MINUS_ZERO (d))\n-    {\n-      val->value = build_real (type, dconst0);\n-      return;\n-    }\n-\n-  if (!HONOR_NANS (mode)\n-      && REAL_VALUE_ISNAN (d))\n-    {\n-      val->lattice_val = UNDEFINED;\n-      val->value = NULL;\n-      return;\n-    }\n }\n \n /* Return whether the lattice transition is valid.  */\n@@ -487,7 +445,49 @@ valid_lattice_transition (ccp_prop_value_t old_val, ccp_prop_value_t new_val)\n \t    == wi::bit_and_not (wi::to_widest (new_val.value), new_val.mask));\n \n   /* Otherwise constant values have to agree.  */\n-  return operand_equal_p (old_val.value, new_val.value, 0);\n+  if (operand_equal_p (old_val.value, new_val.value, 0))\n+    return true;\n+\n+  /* At least the kinds and types should agree now.  */\n+  if (TREE_CODE (old_val.value) != TREE_CODE (new_val.value)\n+      || !types_compatible_p (TREE_TYPE (old_val.value),\n+\t\t\t      TREE_TYPE (new_val.value)))\n+    return false;\n+\n+  /* For floats and !HONOR_NANS allow transitions from (partial) NaN\n+     to non-NaN.  */\n+  tree type = TREE_TYPE (new_val.value);\n+  if (SCALAR_FLOAT_TYPE_P (type)\n+      && !HONOR_NANS (TYPE_MODE (type)))\n+    {\n+      if (REAL_VALUE_ISNAN (TREE_REAL_CST (old_val.value)))\n+\treturn true;\n+    }\n+  else if (VECTOR_FLOAT_TYPE_P (type)\n+\t   && !HONOR_NANS (TYPE_MODE (TREE_TYPE (type))))\n+    {\n+      for (unsigned i = 0; i < VECTOR_CST_NELTS (old_val.value); ++i)\n+\tif (!REAL_VALUE_ISNAN\n+\t       (TREE_REAL_CST (VECTOR_CST_ELT (old_val.value, i)))\n+\t    && !operand_equal_p (VECTOR_CST_ELT (old_val.value, i),\n+\t\t\t\t VECTOR_CST_ELT (new_val.value, i), 0))\n+\t  return false;\n+      return true;\n+    }\n+  else if (COMPLEX_FLOAT_TYPE_P (type)\n+\t   && !HONOR_NANS (TYPE_MODE (TREE_TYPE (type))))\n+    {\n+      if (!REAL_VALUE_ISNAN (TREE_REAL_CST (TREE_REALPART (old_val.value)))\n+\t  && !operand_equal_p (TREE_REALPART (old_val.value),\n+\t\t\t       TREE_REALPART (new_val.value), 0))\n+\treturn false;\n+      if (!REAL_VALUE_ISNAN (TREE_REAL_CST (TREE_IMAGPART (old_val.value)))\n+\t  && !operand_equal_p (TREE_IMAGPART (old_val.value),\n+\t\t\t       TREE_IMAGPART (new_val.value), 0))\n+\treturn false;\n+      return true;\n+    }\n+  return false;\n }\n \n /* Set the value for variable VAR to NEW_VAL.  Return true if the new\n@@ -514,7 +514,7 @@ set_lattice_value (tree var, ccp_prop_value_t new_val)\n       new_val.mask = new_val.mask | old_val->mask | diff;\n     }\n \n-  gcc_assert (valid_lattice_transition (*old_val, new_val));\n+  gcc_checking_assert (valid_lattice_transition (*old_val, new_val));\n \n   /* If *OLD_VAL and NEW_VAL are the same, return false to inform the\n      caller that this was a non-transition.  */"}]}