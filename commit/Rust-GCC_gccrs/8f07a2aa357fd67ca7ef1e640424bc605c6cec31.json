{"sha": "8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYwN2EyYWEzNTdmZDY3Y2E3ZWYxZTY0MDQyNGJjNjA1YzZjZWMzMQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-01T20:06:36Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-01T20:06:36Z"}, "message": "In gcc/objc/: 2010-11-01 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-01  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Implemented Objective-C 2.0 property accessors. \n        * objc-act.h (enum objc_tree_index): Added OCTI_GET_PROPERTY_DECL,\n        OCTI_SET_PROPERTY_DECL, OCTI_COPY_STRUCT_DECL,\n        OCTI_GET_PROPERTY_STRUCT_DECL and OCTI_SET_PROPERTY_STRUCT_DECL.\n        (objc_getProperty_decl): New.\n        (objc_setProperty_decl): New.\n        (objc_copyStruct_decl): New.\n        (objc_getPropertyStruct_decl): New.\n        (objc_setPropertyStruct_decl): New.\n        * objc-act.c (build_objc_property_accessor_helpers): New.\n        (synth_module_prologue): Call\n        build_objc_property_accessor_helpers.\n        (lookup_ivar): New.\n        (objc_synthesize_getter): Implemented synthesizing getters that\n        work with properties that are not nonatomic, assign properties.\n        (objc_synthesize_setter): Implemented synthesizing setters that\n        work with properties that are not nonatomic, assign properties.\n\nIn gcc/testsuite/:      \n2010-11-01  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Implemented Objective-C 2.0 property accessors.\n        * objc.dg/property/at-property-6.m: Use nonatomic properties to\n        avoid testing more complex accessors in this testcase which is not\n        about them.\n        * objc.dg/property/at-property-7.m: Same change.\n        * objc.dg/property/at-property-8.m: Same change.\n        * objc.dg/property/at-property-9.m: Same change.\n        * objc.dg/property/at-property-10.m: Same change.\n        * objc.dg/property/at-property-11.m: Same change.\n        * obj-c++.dg/property/at-property-6.mm: Same change.\n        * obj-c++.dg/property/at-property-7.mm: Same change.\n        * obj-c++.dg/property/at-property-8.mm: Same change.\n        * obj-c++.dg/property/at-property-9.mm: Same change.\n        * obj-c++.dg/property/at-property-10.mm: Same change.\n        * obj-c++.dg/property/at-property-11.mm: Same change.\n        * objc.dg/property/at-property-12.m: New.\n        * objc.dg/property/at-property-13.m: New.\n        * obj-c++.dg/property/at-property-12.mm: New.\n        * obj-c++.dg/property/at-property-13.mm: New.\n\nFrom-SVN: r166143", "tree": {"sha": "53252370c4f738209d137b61fe83ed7b6b403a21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53252370c4f738209d137b61fe83ed7b6b403a21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fccc6c3464c8862297bdf74d7bf22ac245e4639", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fccc6c3464c8862297bdf74d7bf22ac245e4639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fccc6c3464c8862297bdf74d7bf22ac245e4639"}], "stats": {"total": 759, "additions": 705, "deletions": 54}, "files": [{"sha": "5a7c85f5fc2a3be43a6d7aa5063263625384b426", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -1,3 +1,23 @@\n+2010-11-01  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented Objective-C 2.0 property accessors.\t\n+\t* objc-act.h (enum objc_tree_index): Added OCTI_GET_PROPERTY_DECL,\n+\tOCTI_SET_PROPERTY_DECL, OCTI_COPY_STRUCT_DECL,\n+\tOCTI_GET_PROPERTY_STRUCT_DECL and OCTI_SET_PROPERTY_STRUCT_DECL.\n+\t(objc_getProperty_decl): New.\n+\t(objc_setProperty_decl): New.\n+\t(objc_copyStruct_decl): New.\n+\t(objc_getPropertyStruct_decl): New.\n+\t(objc_setPropertyStruct_decl): New.\n+\t* objc-act.c (build_objc_property_accessor_helpers): New.\n+\t(synth_module_prologue): Call\n+\tbuild_objc_property_accessor_helpers.\n+\t(lookup_ivar): New.\n+\t(objc_synthesize_getter): Implemented synthesizing getters that\n+\twork with properties that are not nonatomic, assign properties.\n+\t(objc_synthesize_setter): Implemented synthesizing setters that\n+\twork with properties that are not nonatomic, assign properties.\n+\t\n 2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented Objective-C 2.0 @property, @synthesize and @dynamic."}, {"sha": "00e2a4330a3feba58d6698c0415aa119ed00db1f", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 393, "deletions": 42, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -178,6 +178,7 @@ static int match_proto_with_proto (tree, tree, int);\n static tree lookup_property (tree, tree);\n static tree lookup_property_in_list (tree, tree);\n static tree lookup_property_in_protocol_list (tree, tree);\n+static void build_objc_property_accessor_helpers (void);\n \n static void objc_xref_basetypes (tree, tree);\n \n@@ -2348,6 +2349,10 @@ synth_module_prologue (void)\n   build_category_template ();\n   build_objc_exception_stuff ();\n \n+  /* Declare objc_getProperty, object_setProperty and other property\n+     accessor helpers.  */\n+  build_objc_property_accessor_helpers ();\n+\n   if (flag_next_runtime)\n     build_next_objc_exception_stuff ();\n \n@@ -7938,6 +7943,7 @@ add_instance_variable (tree klass, objc_ivar_visibility_kind visibility,\n   return klass;\n }\n \f\n+\n static tree\n is_ivar (tree decl_chain, tree ident)\n {\n@@ -8516,11 +8522,120 @@ objc_build_property_setter_name (tree ident)\n   return string;\n }\n \n+/* This routine prepares the declarations of the property accessor\n+   helper functions (objc_getProperty(), etc) that are used when\n+   @synthesize is used.  */\n+static void \n+build_objc_property_accessor_helpers (void)\n+{\n+  tree type;\n+\n+  /* Declare the following function:\n+     id\n+     objc_getProperty (id self, SEL _cmd, \n+                       ptrdiff_t offset, BOOL is_atomic);  */\n+  type = build_function_type_list (objc_object_type,\n+\t\t\t\t   objc_object_type,\n+\t\t\t\t   objc_selector_type,\n+\t\t\t\t   ptrdiff_type_node,\n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   NULL_TREE);\n+  objc_getProperty_decl = add_builtin_function (\"objc_getProperty\",\n+\t\t\t\t\t\ttype, 0, NOT_BUILT_IN,\n+\t\t\t\t\t\tNULL, NULL_TREE);\n+  TREE_NOTHROW (objc_getProperty_decl) = 0;\n+  \n+  /* Declare the following function:\n+     void\n+     objc_setProperty (id self, SEL _cmd, \n+                       ptrdiff_t offset, id new_value, \n+                       BOOL is_atomic, BOOL should_copy);  */\n+  type = build_function_type_list (void_type_node,\n+\t\t\t\t   objc_object_type,\n+\t\t\t\t   objc_selector_type,\n+\t\t\t\t   ptrdiff_type_node,\n+\t\t\t\t   objc_object_type,\n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   NULL_TREE);\n+  objc_setProperty_decl = add_builtin_function (\"objc_setProperty\",\n+\t\t\t\t\t\ttype, 0, NOT_BUILT_IN,\n+\t\t\t\t\t\tNULL, NULL_TREE);\n+  TREE_NOTHROW (objc_setProperty_decl) = 0;\n+\n+  /* This is the type of all of the following functions\n+     (objc_copyStruct(), objc_getPropertyStruct() and\n+     objc_setPropertyStruct()).  */\n+  type = build_function_type_list (void_type_node,\n+\t\t\t\t   ptr_type_node,\n+\t\t\t\t   const_ptr_type_node,\n+\t\t\t\t   ptrdiff_type_node,       \n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   NULL_TREE);\n+\n+  if (flag_next_runtime)\n+    {\n+      /* Declare the following function:\n+\t void\n+         objc_copyStruct (void *destination, const void *source, \n+\t                  ptrdiff_t size, BOOL is_atomic, BOOL has_strong);  */\n+      objc_copyStruct_decl = add_builtin_function (\"objc_copyStruct\",\n+\t\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t\t   NULL, NULL_TREE);\n+      TREE_NOTHROW (objc_copyStruct_decl) = 0;\n+      objc_getPropertyStruct_decl = NULL_TREE;\n+      objc_setPropertyStruct_decl = NULL_TREE;\n+    }\n+  else\n+    {\n+      objc_copyStruct_decl = NULL_TREE;\n+\n+      /* Declare the following function:\n+\t void\n+\t objc_getPropertyStruct (void *destination, const void *source, \n+                                 ptrdiff_t size, BOOL is_atomic, BOOL has_strong);  */\n+      objc_getPropertyStruct_decl = add_builtin_function (\"objc_getPropertyStruct\",\n+\t\t\t\t\t\t\t  type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t\t\t  NULL, NULL_TREE);\n+      TREE_NOTHROW (objc_getPropertyStruct_decl) = 0;\n+      /* Declare the following function:\n+\t void\n+\t objc_setPropertyStruct (void *destination, const void *source, \n+\t                         ptrdiff_t size, BOOL is_atomic, BOOL has_strong);  */\n+      objc_setPropertyStruct_decl = add_builtin_function (\"objc_setPropertyStruct\",\n+\t\t\t\t\t\t\t  type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t\t\t  NULL, NULL_TREE);\n+      TREE_NOTHROW (objc_setPropertyStruct_decl) = 0;\n+    }\n+}\n+\n+/* This looks up an ivar in a class (including superclasses).  */\n+static tree\n+lookup_ivar (tree interface, tree instance_variable_name)\n+{\n+  while (interface)\n+    {\n+      tree decl_chain;\n+      \n+      for (decl_chain = CLASS_IVARS (interface); decl_chain; decl_chain = DECL_CHAIN (decl_chain))\n+\tif (DECL_NAME (decl_chain) == instance_variable_name)\n+\t  return decl_chain;\n+      \n+      /* Not found.  Search superclass if any.  */\n+      if (CLASS_SUPER_NAME (interface))\n+\tinterface = lookup_interface (CLASS_SUPER_NAME (interface));\n+    }\n+  \n+  return NULL_TREE;\n+}\n+\n /* This routine synthesizes a 'getter' method.  This is only called\n    for @synthesize properties.  */\n static void\n-objc_synthesize_getter (tree klass ATTRIBUTE_UNUSED, tree class_method, tree property)\n+objc_synthesize_getter (tree klass, tree class_method, tree property)\n {\n+  location_t location = DECL_SOURCE_LOCATION (property);\n   tree fn, decl;\n   tree body;\n   tree ret_val;\n@@ -8543,29 +8658,150 @@ objc_synthesize_getter (tree klass ATTRIBUTE_UNUSED, tree class_method, tree pro\n   /* Adapt the 'decl'.  Use the source location of the @synthesize\n      statement for error messages.  */\n   decl = copy_node (decl);\n-  DECL_SOURCE_LOCATION (decl) = DECL_SOURCE_LOCATION (property);\n+  DECL_SOURCE_LOCATION (decl) = location;\n \n   objc_start_method_definition (false /* is_class_method */, decl, NULL_TREE);\n   body = c_begin_compound_stmt (true);\n \n-  /* TODO: Implement PROPERTY_NONATOMIC, use objc_getProperty etc as\n-     appropriate.  The following code just always does direct ivar\n-     access.  */\n+  /* Now we need to decide how we build the getter.  There are three\n+     cases:\n+\n+     for 'copy' or 'retain' properties we need to use the\n+     objc_getProperty() accessor helper which knows about retain and\n+     copy.  It supports both 'nonatomic' and 'atomic' access.\n \n-  /* return self->_property_name; */\n+     for 'nonatomic, assign' properties we can access the instance\n+     variable directly.  'nonatomic' means we don't have to use locks,\n+     and 'assign' means we don't have to worry about retain or copy.\n+     If you combine the two, it means we can just access the instance\n+     variable directly.\n+\n+     for 'atomic, assign' properties we use objc_copyStruct() (for the\n+     next runtime) or objc_getPropertyStruct() (for the GNU runtime).  */\n+  switch (PROPERTY_ASSIGN_SEMANTICS (property))\n+    {\n+    case OBJC_PROPERTY_RETAIN:\n+    case OBJC_PROPERTY_COPY:\n+      {\n+\t/* We build \"return objc_getProperty (self, _cmd, offset, is_atomic);\"  */\n+\ttree cmd, ivar, offset, is_atomic;\n+\tcmd = TREE_CHAIN (DECL_ARGUMENTS (current_function_decl));\n+\n+\t/* Find the ivar to compute the offset.  */\n+\tivar = lookup_ivar (klass, PROPERTY_IVAR_NAME (property));\n+\tif (!ivar || is_private (ivar))\n+\t  {\n+\t    /* This should never happen.  */\n+\t    error_at (location,\n+\t\t      \"can not find instance variable associated with property\");\n+\t    ret_val = error_mark_node;\n+\t    break;\n+\t  }\n+\toffset = byte_position (ivar);\n+\n+\tif (PROPERTY_NONATOMIC (property))\n+\t  is_atomic = boolean_false_node;\n+\telse\n+\t  is_atomic = boolean_true_node;\n+\n+\tret_val = build_function_call\n+\t  (location,\n+\t   /* Function prototype.  */\n+\t   objc_getProperty_decl,\n+\t   /* Parameters.  */\n+\t   tree_cons    /* self */\n+\t   (NULL_TREE, self_decl,\n+\t    tree_cons   /* _cmd */\n+\t    (NULL_TREE, cmd,\n+\t     tree_cons  /* offset */\n+\t     (NULL_TREE, offset,\n+\t      tree_cons /* is_atomic */\n+\t      (NULL_TREE, is_atomic, NULL_TREE)))));\n+      }\n+      break;\n+    case OBJC_PROPERTY_ASSIGN:    \n+      if (PROPERTY_NONATOMIC (property))\n+\t{\n+\t  /* We build \"return self->PROPERTY_IVAR_NAME;\"  */\n+\t  ret_val = objc_lookup_ivar (NULL_TREE, PROPERTY_IVAR_NAME (property));\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  /* We build\n+\t       <property type> __objc_property_temp;\n+\t       objc_getPropertyStruct (&__objc_property_temp,\n+\t                               &(self->PROPERTY_IVAR_NAME),\n+\t                               sizeof (type of self->PROPERTY_IVAR_NAME),\n+\t\t\t\t       is_atomic,\n+\t\t\t\t       false)\n+\t       return __objc_property_temp;\n+\n+\t     For the NeXT runtime, we need to use objc_copyStruct\n+\t     instead of objc_getPropertyStruct.  */\n+\t  tree objc_property_temp_decl, function_decl, function_call;\n+\t  tree size_of, is_atomic;\n+\n+\t  objc_property_temp_decl = objc_create_temporary_var (TREE_TYPE (property), \"__objc_property_temp\");\n+\t  DECL_SOURCE_LOCATION (objc_property_temp_decl) = location;\n+\t  objc_property_temp_decl = lang_hooks.decls.pushdecl (objc_property_temp_decl);\n+\n+\t  /* sizeof (ivar type).  Since the ivar and the property have\n+\t     the same type, there is no need to lookup the ivar.  */\n+\t  size_of = c_sizeof_or_alignof_type (location, TREE_TYPE (property),\n+\t\t\t\t\t      true /* is_sizeof */,\n+\t\t\t\t\t      false /* complain */);\n+\t  \n+\t  if (PROPERTY_NONATOMIC (property))\n+\t    is_atomic = boolean_false_node;\n+\t  else\n+\t    is_atomic = boolean_true_node;\n+\t  \n+\t  if (flag_next_runtime)\n+\t    function_decl = objc_copyStruct_decl;\n+\t  else\n+\t    function_decl = objc_getPropertyStruct_decl;\n+\n+\t  function_call = build_function_call\n+\t    (location,\n+\t     /* Function prototype.  */\n+\t     function_decl,\n+\t     /* Parameters.  */\n+\t     tree_cons /* &__objc_property_temp_decl */\n+\t     /* Warning: note that using build_fold_addr_expr_loc()\n+\t\there causes invalid code to be generated.  */\n+\t     (NULL_TREE, build_unary_op (location, ADDR_EXPR, objc_property_temp_decl, 0),\n+\t      tree_cons /* &(self->PROPERTY_IVAR_NAME); */\n+\t      (NULL_TREE, build_fold_addr_expr_loc (location, \n+\t\t\t\t\t\t    objc_lookup_ivar \n+\t\t\t\t\t\t    (NULL_TREE, PROPERTY_IVAR_NAME (property))),\n+\t       tree_cons /* sizeof (PROPERTY_IVAR) */\n+\t       (NULL_TREE, size_of,\n+\t\ttree_cons /* is_atomic */\n+\t\t(NULL_TREE, is_atomic,\n+\t\t /* TODO: This is currently ignored by the GNU\n+\t\t    runtime, but what about the next one ? */\n+\t\t tree_cons /* has_strong */\n+\t\t (NULL_TREE, boolean_true_node, NULL_TREE))))));\n+\n+\t  add_stmt (function_call);\n+\n+\t  ret_val = objc_property_temp_decl;\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-  /* PROPERTY_IVAR_NAME is always defined if we got here, and should\n-     be a valid instance variable.  */\n-  ret_val = objc_lookup_ivar (NULL_TREE, PROPERTY_IVAR_NAME (property));\n   gcc_assert (ret_val);\n \n #ifdef OBJCPLUS\n   finish_return_stmt (ret_val);\n #else\n-  (void)c_finish_return (DECL_SOURCE_LOCATION (property), ret_val, NULL);\n+  c_finish_return (location, ret_val, NULL_TREE);\n #endif\n \n-  add_stmt (c_end_compound_stmt (DECL_SOURCE_LOCATION (property), body, true));\n+  add_stmt (c_end_compound_stmt (location, body, true));\n   fn = current_function_decl;\n #ifdef OBJCPLUS\n   finish_function ();\n@@ -8578,8 +8814,10 @@ objc_synthesize_getter (tree klass ATTRIBUTE_UNUSED, tree class_method, tree pro\n static void\n objc_synthesize_setter (tree klass ATTRIBUTE_UNUSED, tree class_method, tree property)\n {\n-  tree fn, decl, lhs, rhs;\n+  location_t location = DECL_SOURCE_LOCATION (property);\n+  tree fn, decl;\n   tree body;\n+  tree new_value, statement;\n \n   /* If user has implemented a setter with same name then do nothing.  */\n   if (lookup_method (CLASS_NST_METHODS (objc_implementation_context),\n@@ -8605,40 +8843,153 @@ objc_synthesize_setter (tree klass ATTRIBUTE_UNUSED, tree class_method, tree pro\n \n   body = c_begin_compound_stmt (true);\n \n-  /* TODO: Implement PROPERTY_NONATOMIC, use objc_getProperty etc as\n-     appropriate.  The following code just always does direct ivar\n-     access.  */\n-\n-  /* _property_name = _value; */\n-\n-  /* PROPERTY_IVAR_NAME is always defined if we got here, and should\n-     be a valid instance variable.  */\n-  lhs = objc_lookup_ivar (NULL_TREE, PROPERTY_IVAR_NAME (property));\n-  gcc_assert (lhs);\n-  \n-  /* TODO: Lookup the argument in a more robust way so that it works\n-     even if the method prototype does not call it '_value'.  */\n-  rhs = lookup_name (get_identifier (\"_value\"));\n+  /* The 'new_value' is the only argument to the method, which is the\n+     3rd argument of the function, after self and _cmd.  We use twice\n+     TREE_CHAIN to move forward two arguments.  */\n+  new_value = TREE_CHAIN (TREE_CHAIN (DECL_ARGUMENTS (current_function_decl)));\n \n   /* This would presumably happen if the user has specified a\n-     prototype for the setter that is not the correct one.  */\n-  if (rhs == NULL_TREE)\n+     prototype for the setter that does not have an argument!  */\n+  if (new_value == NULL_TREE)\n     {\n       /* TODO: This should be caught much earlier than this.  */\n-      /* We couldn't find the '_value' identifier in the current\n-\t context; presumably the user didn't have a '_value'\n-\t argument.  */\n-      error_at (DECL_SOURCE_LOCATION (decl), \"invalid setter, missing _value argument\");\n-      /* Just recover somehow.  */\n-      rhs = lhs;\n-    }\n-\n-  /* FIXME: NULL types to get compile.  */\n-  add_stmt (build_modify_expr (DECL_SOURCE_LOCATION (decl), \n-\t\t\t       lhs, NULL_TREE, NOP_EXPR, \n-\t\t\t       DECL_SOURCE_LOCATION (decl), rhs, NULL_TREE));\n-  \n-  add_stmt (c_end_compound_stmt (DECL_SOURCE_LOCATION (decl), body, true));\n+      error_at (DECL_SOURCE_LOCATION (decl), \"invalid setter, it must have one argument\");\n+      /* Try to recover somehow.  */\n+      new_value = error_mark_node;\n+    }\n+\n+  /* Now we need to decide how we build the setter.  There are three\n+     cases:\n+\n+     for 'copy' or 'retain' properties we need to use the\n+     objc_setProperty() accessor helper which knows about retain and\n+     copy.  It supports both 'nonatomic' and 'atomic' access.\n+\n+     for 'nonatomic, assign' properties we can access the instance\n+     variable directly.  'nonatomic' means we don't have to use locks,\n+     and 'assign' means we don't have to worry about retain or copy.\n+     If you combine the two, it means we can just access the instance\n+     variable directly.\n+\n+     for 'atomic, assign' properties we use objc_copyStruct() (for the\n+     next runtime) or objc_setPropertyStruct() (for the GNU runtime).  */\n+  switch (PROPERTY_ASSIGN_SEMANTICS (property))\n+    {\n+    case OBJC_PROPERTY_RETAIN:\n+    case OBJC_PROPERTY_COPY:\n+      {\n+\t/* We build \"objc_setProperty (self, _cmd, new_value, offset, is_atomic, should_copy);\"  */\n+\ttree cmd, ivar, offset, is_atomic, should_copy;\n+\tcmd = TREE_CHAIN (DECL_ARGUMENTS (current_function_decl));\n+\n+\t/* Find the ivar to compute the offset.  */\n+\tivar = lookup_ivar (klass, PROPERTY_IVAR_NAME (property));\n+\tif (!ivar || is_private (ivar))\n+\t  {\n+\t    error_at (location,\n+\t\t      \"can not find instance variable associated with property\");\n+\t    statement = error_mark_node;\n+\t    break;\n+\t  }\n+\toffset = byte_position (ivar);\n+\n+\tif (PROPERTY_NONATOMIC (property))\n+\t  is_atomic = boolean_false_node;\n+\telse\n+\t  is_atomic = boolean_true_node;\n+\t\n+\tif (PROPERTY_ASSIGN_SEMANTICS (property) == OBJC_PROPERTY_COPY)\n+\t  should_copy = boolean_true_node;\n+\telse\n+\t  should_copy = boolean_false_node;\n+\n+\tstatement = build_function_call\n+\t  (location,\n+\t   /* Function prototype.  */\n+\t   objc_setProperty_decl,\n+\t   /* Parameters.  */\n+\t   tree_cons    /* self */\n+\t   (NULL_TREE, self_decl,\n+\t    tree_cons   /* _cmd */\n+\t    (NULL_TREE, cmd,\n+\t     tree_cons  /* offset */\n+\t     (NULL_TREE, offset,\n+\t      tree_cons /* new_value */\n+\t      (NULL_TREE, new_value,\n+\t       tree_cons /* is_atomic */\n+\t       (NULL_TREE, is_atomic, \n+\t\ttree_cons /* should_copy */\n+\t\t(NULL_TREE, should_copy, NULL_TREE)))))));\n+      }\n+      break;\n+    case OBJC_PROPERTY_ASSIGN:    \n+      if (PROPERTY_NONATOMIC (property))\n+\t{\n+\t  /* We build \"self->PROPERTY_IVAR_NAME = new_value;\"  */\n+\t  statement = build_modify_expr\n+\t    (location,\n+\t     objc_lookup_ivar (NULL_TREE, PROPERTY_IVAR_NAME (property)),\n+\t     NULL_TREE, NOP_EXPR, \n+\t     location, new_value, NULL_TREE);\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  /* We build\n+\t       objc_setPropertyStruct (&(self->PROPERTY_IVAR_NAME),\n+\t                               &new_value,\n+\t                               sizeof (type of self->PROPERTY_IVAR_NAME),\n+\t\t\t\t       is_atomic,\n+\t\t\t\t       false)\n+\n+\t     For the NeXT runtime, we need to use objc_copyStruct\n+\t     instead of objc_getPropertyStruct.  */\n+\t  tree function_decl, size_of, is_atomic;\n+\n+\t  /* sizeof (ivar type).  Since the ivar and the property have\n+\t     the same type, there is no need to lookup the ivar.  */\n+\t  size_of = c_sizeof_or_alignof_type (location, TREE_TYPE (property),\n+\t\t\t\t\t      true /* is_sizeof */,\n+\t\t\t\t\t      false /* complain */);\n+\t  \n+\t  if (PROPERTY_NONATOMIC (property))\n+\t    is_atomic = boolean_false_node;\n+\t  else\n+\t    is_atomic = boolean_true_node;\n+\t  \n+\t  if (flag_next_runtime)\n+\t    function_decl = objc_copyStruct_decl;\n+\t  else\n+\t    function_decl = objc_setPropertyStruct_decl;\n+\n+\t  statement = build_function_call \n+\t    (location,\n+\t     /* Function prototype.  */\n+\t     function_decl,\n+\t     /* Parameters.  */\n+\t     tree_cons /* &(self->PROPERTY_IVAR_NAME); */\n+\t     (NULL_TREE, build_fold_addr_expr_loc (location, \n+\t\t\t\t\t\t   objc_lookup_ivar \n+\t\t\t\t\t\t   (NULL_TREE, PROPERTY_IVAR_NAME (property))),\n+\t      tree_cons /* &new_value */\n+\t      (NULL_TREE, build_fold_addr_expr_loc (location, new_value),\n+\t       tree_cons /* sizeof (PROPERTY_IVAR) */\n+\t       (NULL_TREE, size_of,\n+\t\ttree_cons /* is_atomic */\n+\t\t(NULL_TREE, is_atomic,\n+\t\t /* TODO: This is currently ignored by the GNU\n+\t\t    runtime, but what about the next one ? */\n+\t\t tree_cons /* has_strong */\n+\t\t (NULL_TREE, boolean_true_node, NULL_TREE))))));\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  gcc_assert (statement);\n+\n+  add_stmt (statement);  \n+  add_stmt (c_end_compound_stmt (location, body, true));\n   fn = current_function_decl;\n #ifdef OBJCPLUS\n   finish_function ();"}, {"sha": "4c10c01378e2c8e997bc3b1edaa403d7904b2acd", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -339,6 +339,12 @@ enum objc_tree_index\n     OCTI_FAST_ENUM_STATE_TEMP,\n     OCTI_ENUM_MUTATION_DECL,\n \n+    OCTI_GET_PROPERTY_DECL,\n+    OCTI_SET_PROPERTY_DECL,\n+    OCTI_COPY_STRUCT_DECL,\n+    OCTI_GET_PROPERTY_STRUCT_DECL,\n+    OCTI_SET_PROPERTY_STRUCT_DECL,\n+\n     OCTI_MAX\n };\n \n@@ -506,4 +512,13 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n #define objc_enumeration_mutation_decl\t\t\\\n                                 objc_global_trees[OCTI_ENUM_MUTATION_DECL]\n \n+/* Declarations of functions used when synthesizing property\n+   accessors.  */\n+#define objc_getProperty_decl       objc_global_trees[OCTI_GET_PROPERTY_DECL]\n+#define objc_setProperty_decl       objc_global_trees[OCTI_SET_PROPERTY_DECL]\n+#define objc_copyStruct_decl        objc_global_trees[OCTI_COPY_STRUCT_DECL]\n+#define objc_getPropertyStruct_decl objc_global_trees[OCTI_GET_PROPERTY_STRUCT_DECL]\n+#define objc_setPropertyStruct_decl objc_global_trees[OCTI_SET_PROPERTY_STRUCT_DECL]\n+\n+\n #endif /* GCC_OBJC_ACT_H */"}, {"sha": "ae4de13e2f57bec0b91b1a9db0332286dc9c57db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -1,3 +1,25 @@\n+2010-11-01  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tImplemented Objective-C 2.0 property accessors.\n+\t* objc.dg/property/at-property-6.m: Use nonatomic properties to\n+\tavoid testing more complex accessors in this testcase which is not\n+\tabout them.\n+\t* objc.dg/property/at-property-7.m: Same change.\n+\t* objc.dg/property/at-property-8.m: Same change.\n+\t* objc.dg/property/at-property-9.m: Same change.\n+\t* objc.dg/property/at-property-10.m: Same change.\n+\t* objc.dg/property/at-property-11.m: Same change.\n+\t* obj-c++.dg/property/at-property-6.mm: Same change.\n+\t* obj-c++.dg/property/at-property-7.mm: Same change.\n+\t* obj-c++.dg/property/at-property-8.mm: Same change.\n+\t* obj-c++.dg/property/at-property-9.mm: Same change.\n+\t* obj-c++.dg/property/at-property-10.mm: Same change.\n+\t* obj-c++.dg/property/at-property-11.mm: Same change.\n+\t* objc.dg/property/at-property-12.m: New.\n+\t* objc.dg/property/at-property-13.m: New.\n+\t* obj-c++.dg/property/at-property-12.mm: New.\n+\t* obj-c++.dg/property/at-property-13.mm: New.\t\n+\t\n 2010-11-01  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/46152"}, {"sha": "83494ec3bccd1a6d291a43e91d7ab6a1889d0543", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-10.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-10.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-10.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-10.mm?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -12,7 +12,7 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property int a;\n+@property (nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "82880521680d0c3cca6c622767f9f24e24f8f8ca", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-11.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-11.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-11.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-11.mm?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -12,7 +12,7 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property int a;\n+@property (nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "8d28bde966847ce8826ebd1bab09b6dbd2c4ea3d", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-12.mm", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-12.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-12.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-12.mm?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -0,0 +1,46 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test atomic, assign synthesized methods.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+  id b;\n+}\n+@property int a;\n+@property (assign) id b;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize a;\n+@synthesize b;\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  object.a = 40;\n+  if (object.a != 40)\n+    abort ();\n+\n+  object.b = object;\n+  if (object.b != object)\n+    abort ();\n+\n+  return (0);\n+}\n+\n+"}, {"sha": "5a5dcbbf63ce937b6d2ea84eaa63d73586640084", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-13.mm", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-13.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-13.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-13.mm?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -0,0 +1,71 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test retain and copy synthesized methods.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int copy_count;\n+  id a;\n+  id b;\n+}\n+@property (copy) id a;\n+@property (retain) id b;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (id) copyWithZone: (void *)zone;\n+- (int) copyCount;\n+- (id) autorelease;\n+- (oneway void) release;\n+- (id) retain;\n+@end\n+\n+/* This class implements copyWithZone, which doesn't do anything other\n+   than increasing a counter of how many copies were made.  */\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (id) copyWithZone: (void *)zone { copy_count++; return self; }\n+- (int) copyCount { return copy_count; }\n+- (id) autorelease { return self; }\n+- (oneway void) release { return; }\n+- (id) retain { return self; }\n+@synthesize a;\n+@synthesize b;\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+  MyRootClass *argument = [[MyRootClass alloc] init];\n+\n+  /* This should copy argument.  */\n+  object.a = argument;\n+  if (object.a != argument)\n+    abort ();\n+\n+  /* Test that it was copied.  */\n+  if ([object.a copyCount] != 1)\n+    abort ();\n+\n+  /* We just test that the retain accessors seem to work and that they\n+     don't copy.  We don't test that retain was actually called,\n+     because if garbage collection is enabled, it may never be\n+     called!  */\n+  object.b = argument;\n+  if (object.b != argument)\n+    abort ();\n+\n+  /* Test that it was not copied.  */\n+  if ([object.b copyCount] != 1)\n+    abort ();\n+\n+  return (0);\n+}"}, {"sha": "8b7346b95af70a3739823c184341ce2f651af372", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-6.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-6.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-6.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-6.mm?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -13,7 +13,7 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property int a;\n+@property (nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "bace2420e57e7ca0dfcc6d84c31bccacddc311e7", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-7.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-7.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-7.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-7.mm?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -13,7 +13,7 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property (getter = getA) int a;\n+@property (getter = getA, nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "a290dd3df35c14c3120d291379c9da212955eac3", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-8.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-8.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-8.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-8.mm?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -13,7 +13,7 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property (setter = writeA:) int a;\n+@property (setter = writeA:, nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "be52e37f5d068fc9aeecb208a1c8ccaedc04be57", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-9.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-9.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-9.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-9.mm?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -13,7 +13,7 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property (getter = giveMeA, setter = writeA:) int a;\n+@property (getter = giveMeA, setter = writeA:, nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "1a7a0430899215b0ab5768b72428c0c0c46faa1f", "filename": "gcc/testsuite/objc.dg/property/at-property-10.m", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-10.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-10.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-10.m?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -12,7 +12,10 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property int a;\n+/* Use the simplest synthesized accessor (assign, nonatomic) as we are\n+   not testing the synthesized accessors in this test, just the\n+   property syntax.  */\n+@property (nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "2526a9cc1dedf041fee2332b09a43fe828a2cf19", "filename": "gcc/testsuite/objc.dg/property/at-property-11.m", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-11.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-11.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-11.m?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -12,7 +12,10 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property int a;\n+/* Use the simplest synthesized accessor (assign, nonatomic) as we are\n+   not testing the synthesized accessors in this test, just the\n+   property syntax.  */\n+@property (nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "e96b198282ca363fac5b69bae464a0e5151778c1", "filename": "gcc/testsuite/objc.dg/property/at-property-12.m", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-12.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-12.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-12.m?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -0,0 +1,46 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test atomic, assign synthesized methods.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+  id b;\n+}\n+@property int a;\n+@property (assign) id b;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@synthesize a;\n+@synthesize b;\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  object.a = 40;\n+  if (object.a != 40)\n+    abort ();\n+\n+  object.b = object;\n+  if (object.b != object)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "dfdb02f71277bfc29686962f82e33ab0ad3e3504", "filename": "gcc/testsuite/objc.dg/property/at-property-13.m", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-13.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-13.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-13.m?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -0,0 +1,71 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+\n+/* Test retain and copy synthesized methods.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int copy_count;\n+  id a;\n+  id b;\n+}\n+@property (copy) id a;\n+@property (retain) id b;\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+- (id) copyWithZone: (void *)zone;\n+- (int) copyCount;\n+- (id) autorelease;\n+- (oneway void) release;\n+- (id) retain;\n+@end\n+\n+/* This class implements copyWithZone, which doesn't do anything other\n+   than increasing a counter of how many copies were made.  */\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+- (id) copyWithZone: (void *)zone { copy_count++; return self; }\n+- (int) copyCount { return copy_count; }\n+- (id) autorelease { return self; }\n+- (oneway void) release { return; }\n+- (id) retain { return self; }\n+@synthesize a;\n+@synthesize b;\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+  MyRootClass *argument = [[MyRootClass alloc] init];\n+\n+  /* This should copy argument.  */\n+  object.a = argument;\n+  if (object.a != argument)\n+    abort ();\n+\n+  /* Test that it was copied.  */\n+  if ([object.a copyCount] != 1)\n+    abort ();\n+\n+  /* We just test that the retain accessors seem to work and that they\n+     don't copy.  We don't test that retain was actually called,\n+     because if garbage collection is enabled, it may never be\n+     called!  */\n+  object.b = argument;\n+  if (object.b != argument)\n+    abort ();\n+\n+  /* Test that it was not copied.  */\n+  if ([object.b copyCount] != 1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "079995c526a9bb9978051d7b1214d96a4e1717df", "filename": "gcc/testsuite/objc.dg/property/at-property-6.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-6.m?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -13,7 +13,7 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property int a;\n+@property (nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "6f182d0730e1ceda637a7fcb881e6bf85dd2d933", "filename": "gcc/testsuite/objc.dg/property/at-property-7.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-7.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-7.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-7.m?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -13,7 +13,7 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property (getter = getA) int a;\n+@property (getter = getA, nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "94ed86e7f8b7b7c90de17efb1ee96316190b3f9c", "filename": "gcc/testsuite/objc.dg/property/at-property-8.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-8.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-8.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-8.m?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -13,7 +13,7 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property (setter = writeA:) int a;\n+@property (setter = writeA:, nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}, {"sha": "6e2d118882f86495c368e4c94801556e1ef25e72", "filename": "gcc/testsuite/objc.dg/property/at-property-9.m", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-9.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f07a2aa357fd67ca7ef1e640424bc605c6cec31/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-9.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-9.m?ref=8f07a2aa357fd67ca7ef1e640424bc605c6cec31", "patch": "@@ -13,7 +13,10 @@ @interface MyRootClass\n   Class isa;\n   int a;\n }\n-@property (getter = giveMeA, setter = writeA:) int a;\n+/* Use the simplest synthesized accessor (assign, nonatomic) as we are\n+   not testing the synthesized accessors in this test, just the\n+   property syntax.  */\n+@property (getter = giveMeA, setter = writeA:, nonatomic) int a;\n + (id) initialize;\n + (id) alloc;\n - (id) init;"}]}