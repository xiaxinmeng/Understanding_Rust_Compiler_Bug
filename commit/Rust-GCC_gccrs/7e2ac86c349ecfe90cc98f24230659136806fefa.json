{"sha": "7e2ac86c349ecfe90cc98f24230659136806fefa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UyYWM4NmMzNDllY2ZlOTBjYzk4ZjI0MjMwNjU5MTM2ODA2ZmVmYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-01-10T00:44:26Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-01-10T00:44:26Z"}, "message": "re PR middle-end/30322 (((-i-1) + i) +1) is turned into ~i + (i+1) and never into 0 on the tree level)\n\n\tPR tree-optimization/30322\n\t* tree-ssa-loop-ivopts.c (fold_affine_expr, iv_value): Removed.\n\t(cand_value_at): Return the value as aff_tree.\n\t(may_eliminate_iv): Convert the bound from aff_tree to tree.\n\t* tree-affine.c (aff_combination_add_cst, aff_combination_add_product,\n\taff_combination_mult): New functions.\n\t(aff_combination_add): Use aff_combination_add_cst.\n\t(aff_combination_convert): Allow conversions to a wider type.\n\t(tree_to_aff_combination): Handle BIT_NOT_EXPR.\n\t* tree-affine.h (aff_combination_mult): Declare.\n\n\t* gcc.dg/tree-ssa/loop-21.c: New test.\n\nFrom-SVN: r120630", "tree": {"sha": "f1798b70409e7522ae71bb941b4d1af411b2db36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1798b70409e7522ae71bb941b4d1af411b2db36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e2ac86c349ecfe90cc98f24230659136806fefa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2ac86c349ecfe90cc98f24230659136806fefa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e2ac86c349ecfe90cc98f24230659136806fefa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2ac86c349ecfe90cc98f24230659136806fefa/comments", "author": null, "committer": null, "parents": [{"sha": "92c25b55d49ef9ba4c273ec543ad23b684389123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c25b55d49ef9ba4c273ec543ad23b684389123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92c25b55d49ef9ba4c273ec543ad23b684389123"}], "stats": {"total": 178, "additions": 138, "deletions": 40}, "files": [{"sha": "b85f8bbbe86fdc0335ba75d6d3393beefa648f8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e2ac86c349ecfe90cc98f24230659136806fefa", "patch": "@@ -1,3 +1,16 @@\n+2007-01-09  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/30322\n+\t* tree-ssa-loop-ivopts.c (fold_affine_expr, iv_value): Removed.\n+\t(cand_value_at): Return the value as aff_tree.\n+\t(may_eliminate_iv): Convert the bound from aff_tree to tree.\n+\t* tree-affine.c (aff_combination_add_cst, aff_combination_add_product,\n+\taff_combination_mult): New functions.\n+\t(aff_combination_add): Use aff_combination_add_cst.\n+\t(aff_combination_convert): Allow conversions to a wider type.\n+\t(tree_to_aff_combination): Handle BIT_NOT_EXPR.\n+\t* tree-affine.h (aff_combination_mult): Declare.\n+\n 2007-01-09  Carlos O'Donell  <carlos@codesourcery.com>\n \n \t* doc/tm.texi: Update documentation to reflect reality of exec"}, {"sha": "2e2ebd5c975962a5e68fd3631fe660fe9fc4f671", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e2ac86c349ecfe90cc98f24230659136806fefa", "patch": "@@ -1,3 +1,8 @@\n+2007-01-09  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/30322\n+\t* gcc.dg/tree-ssa/loop-21.c: New test.\n+\n 2007-01-08  Geoffrey Keating  <geoffk@apple.com>\n \n \t* g++.dg/rtti/darwin-builtin-linkage.C: New."}, {"sha": "59a17cb5e7f63ca5de843e0e42c2a74a31a0e812", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-21.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-21.c?ref=7e2ac86c349ecfe90cc98f24230659136806fefa", "patch": "@@ -0,0 +1,17 @@\n+/* PR tree-optimization/30322 */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-final_cleanup\" } */\n+\n+extern void op( int, int);\n+void foo(int f0, int f1, int e0, int e1)\n+{\n+  int i0, i1;\n+\n+  for (i1 = f1; i1 <= e1; ++i1)\n+    for (i0 = f0; i0 <= e0; ++i0)\n+      op(i0, i1);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"~\" 0 \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "43b251ddd90d7ed49ea233c6927e216f2a7c4dbb", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=7e2ac86c349ecfe90cc98f24230659136806fefa", "patch": "@@ -180,16 +180,22 @@ aff_combination_add_elt (aff_tree *comb, tree elt, double_int scale)\n     comb->rest = elt;\n }\n \n+/* Adds CST to C.  */\n+\n+static void\n+aff_combination_add_cst (aff_tree *c, double_int cst)\n+{\n+  c->offset = double_int_ext_for_comb (double_int_add (c->offset, cst), c);\n+}\n+\n /* Adds COMB2 to COMB1.  */\n \n void\n aff_combination_add (aff_tree *comb1, aff_tree *comb2)\n {\n   unsigned i;\n \n-  comb1->offset\n-    = double_int_ext_for_comb (double_int_add (comb1->offset, comb2->offset),\n-\t\t\t       comb1);\n+  aff_combination_add_cst (comb1, comb2->offset);\n   for (i = 0; i < comb2->n; i++)\n     aff_combination_add_elt (comb1, comb2->elts[i].val, comb2->elts[i].coef);\n   if (comb2->rest)\n@@ -204,7 +210,13 @@ aff_combination_convert (aff_tree *comb, tree type)\n   unsigned i, j;\n   tree comb_type = comb->type;\n \n-  gcc_assert (TYPE_PRECISION (type) <= TYPE_PRECISION (comb_type));\n+  if  (TYPE_PRECISION (type) > TYPE_PRECISION (comb_type))\n+    {\n+      tree val = fold_convert (type, aff_combination_to_tree (comb));\n+      tree_to_aff_combination (val, type, comb);\n+      return;\n+    }\n+\n   comb->type = type;\n   if (comb->rest)\n     comb->rest = fold_convert (type, comb->rest);\n@@ -276,6 +288,13 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n       aff_combination_scale (comb, double_int_minus_one);\n       return;\n \n+    case BIT_NOT_EXPR:\n+      /* ~x = -x - 1 */\n+      tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n+      aff_combination_scale (comb, double_int_minus_one);\n+      aff_combination_add_cst (comb, double_int_minus_one);\n+      return;\n+\n     case ADDR_EXPR:\n       core = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize, &bitpos,\n \t\t\t\t  &toffset, &mode, &unsignedp, &volatilep,\n@@ -412,3 +431,65 @@ aff_combination_remove_elt (aff_tree *comb, unsigned m)\n       comb->n++;\n     }\n }\n+\n+/* Adds C * COEF * VAL to R.  VAL may be NULL, in that case only\n+   C * COEF is added to R.  */\n+   \n+\n+static void\n+aff_combination_add_product (aff_tree *c, double_int coef, tree val,\n+\t\t\t     aff_tree *r)\n+{\n+  unsigned i;\n+  tree aval, type;\n+\n+  for (i = 0; i < c->n; i++)\n+    {\n+      aval = c->elts[i].val;\n+      if (val)\n+\t{\n+\t  type = TREE_TYPE (aval);\n+\t  aval = fold_build2 (MULT_EXPR, type, aval,\n+\t\t\t      fold_convert (type, val));\n+\t}\n+\n+      aff_combination_add_elt (r, aval,\n+\t\t\t       double_int_mul (coef, c->elts[i].coef));\n+    }\n+\n+  if (c->rest)\n+    {\n+      aval = c->rest;\n+      if (val)\n+\t{\n+\t  type = TREE_TYPE (aval);\n+\t  aval = fold_build2 (MULT_EXPR, type, aval,\n+\t\t\t      fold_convert (type, val));\n+\t}\n+\n+      aff_combination_add_elt (r, aval, coef);\n+    }\n+\n+  if (val)\n+    aff_combination_add_elt (r, val,\n+\t\t\t     double_int_mul (coef, c->offset));\n+  else\n+    aff_combination_add_cst (r, double_int_mul (coef, c->offset));\n+}\n+\n+/* Multiplies C1 by C2, storing the result to R  */\n+\n+void\n+aff_combination_mult (aff_tree *c1, aff_tree *c2, aff_tree *r)\n+{\n+  unsigned i;\n+  gcc_assert (TYPE_PRECISION (c1->type) == TYPE_PRECISION (c2->type));\n+\n+  aff_combination_zero (r, c1->type);\n+\n+  for (i = 0; i < c2->n; i++)\n+    aff_combination_add_product (c1, c2->elts[i].coef, c2->elts[i].val, r);\n+  if (c2->rest)\n+    aff_combination_add_product (c1, double_int_one, c2->rest, r);\n+  aff_combination_add_product (c1, c2->offset, NULL, r);\n+}"}, {"sha": "51af99acec2617b2f1be3f3a496d57c47532bc2b", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=7e2ac86c349ecfe90cc98f24230659136806fefa", "patch": "@@ -62,6 +62,7 @@ double_int double_int_ext_for_comb (double_int, aff_tree *);\n void aff_combination_const (aff_tree *, tree, double_int);\n void aff_combination_elt (aff_tree *, tree, tree);\n void aff_combination_scale (aff_tree *, double_int);\n+void aff_combination_mult (aff_tree *, aff_tree *, aff_tree *);\n void aff_combination_add (aff_tree *, aff_tree *);\n void aff_combination_add_elt (aff_tree *, tree, double_int);\n void aff_combination_remove_elt (aff_tree *, unsigned);"}, {"sha": "a11165d7b851c7e2dfa5bd2349429686bf19e1bf", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2ac86c349ecfe90cc98f24230659136806fefa/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=7e2ac86c349ecfe90cc98f24230659136806fefa", "patch": "@@ -2565,21 +2565,6 @@ constant_multiple_of (tree top, tree bot, double_int *mul)\n     }\n }\n \n-/* Folds EXPR using the affine expressions framework.  */\n-\n-static tree\n-fold_affine_expr (tree expr)\n-{\n-  tree type = TREE_TYPE (expr);\n-  struct affine_tree_combination comb;\n-\n-  if (TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT)\n-    return expr;\n-\n-  tree_to_aff_combination (expr, type, &comb);\n-  return aff_combination_to_tree (&comb);\n-}\n-\n /* If A is (TYPE) BA and B is (TYPE) BB, and the types of BA and BB have the\n    same precision that is at least as wide as the precision of TYPE, stores\n    BA to A and BB to B, and returns the type of BA.  Otherwise, returns the\n@@ -3557,32 +3542,26 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n   return cost != INFTY;\n }\n \n-/* Computes value of induction variable IV in iteration NITER.  */\n+/* Computes value of candidate CAND at position AT in iteration NITER, and\n+   stores it to VAL.  */\n \n-static tree\n-iv_value (struct iv *iv, tree niter)\n+static void\n+cand_value_at (struct loop *loop, struct iv_cand *cand, tree at, tree niter,\n+\t       aff_tree *val)\n {\n-  tree val;\n+  aff_tree step, delta, nit;\n+  struct iv *iv = cand->iv;\n   tree type = TREE_TYPE (iv->base);\n \n-  niter = fold_convert (type, niter);\n-  val = fold_build2 (MULT_EXPR, type, iv->step, niter);\n-\n-  return fold_build2 (PLUS_EXPR, type, iv->base, val);\n-}\n-\n-/* Computes value of candidate CAND at position AT in iteration NITER.  */\n-\n-static tree\n-cand_value_at (struct loop *loop, struct iv_cand *cand, tree at, tree niter)\n-{\n-  tree val = iv_value (cand->iv, niter);\n-  tree type = TREE_TYPE (cand->iv->base);\n-\n+  tree_to_aff_combination (iv->step, type, &step);\n+  tree_to_aff_combination (niter, TREE_TYPE (niter), &nit);\n+  aff_combination_convert (&nit, type);\n+  aff_combination_mult (&nit, &step, &delta);\n   if (stmt_after_increment (loop, cand, at))\n-    val = fold_build2 (PLUS_EXPR, type, val, cand->iv->step);\n+    aff_combination_add (&delta, &step);\n \n-  return val;\n+  tree_to_aff_combination (iv->base, type, val);\n+  aff_combination_add (val, &delta);\n }\n \n /* Returns period of induction variable iv.  */\n@@ -3637,6 +3616,7 @@ may_eliminate_iv (struct ivopts_data *data,\n   tree nit, nit_type;\n   tree wider_type, period, per_type;\n   struct loop *loop = data->current_loop;\n+  aff_tree bnd;\n   \n   if (TREE_CODE (cand->iv->step) != INTEGER_CST)\n     return false;\n@@ -3681,7 +3661,8 @@ may_eliminate_iv (struct ivopts_data *data,\n \t\t\t\t      fold_convert (wider_type, nit))))\n     return false;\n \n-  *bound = fold_affine_expr (cand_value_at (loop, cand, use->stmt, nit));\n+  cand_value_at (loop, cand, use->stmt, nit, &bnd);\n+  *bound = aff_combination_to_tree (&bnd);\n   return true;\n }\n "}]}