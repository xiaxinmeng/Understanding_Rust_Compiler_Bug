{"sha": "0d92b55538087dd0c4acfed6bbed89053e5521d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ5MmI1NTUzODA4N2RkMGM0YWNmZWQ2YmJlZDg5MDUzZTU1MjFkMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-01-14T03:47:17Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-01-14T03:47:17Z"}, "message": "re PR ipa/64481 (r219076 breaks bootstrap (x86_64-unknown-linux-gnu))\n\n\n\tPR ipa/64481\n\t* ipa-inline-analysis.c (node_growth_cache): Remove.\n\t(initialize_growth_caches): Do not initialize it.\n\t(free_growth_caches): Do not free it.\n\t(do_estimate_growth): Rename to ...\n\t(estimate_growth): ... this one; drop growth cache code.\n\t(growth_likely_positive): Always go the heuristics way.\n\t* ipa-inline.c (can_inline_edge_p): Walk through aliases.\n\t(reset_edge_caches): Do not reset node growth.\n\t(heap_edge_removal_hook): Do not maintain cache.\n\t(inline_small_functions): Likewise; strenghten sanity check.\n\t(ipa_inline): Do not maintain caches.\n\t* ipa-inline.h (node_growth_cache): Remove.\n\t(do_estimate_growth): Remove to ...\n\t(estimate_growth): this one; remove inline version.\n\t(reset_node_growth_cache): Remove.\n\nFrom-SVN: r219572", "tree": {"sha": "d263aa4b3c8e49114fabaca0cafcda95de3c39a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d263aa4b3c8e49114fabaca0cafcda95de3c39a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d92b55538087dd0c4acfed6bbed89053e5521d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d92b55538087dd0c4acfed6bbed89053e5521d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d92b55538087dd0c4acfed6bbed89053e5521d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d92b55538087dd0c4acfed6bbed89053e5521d3/comments", "author": null, "committer": null, "parents": [{"sha": "dc396715ae5034be1a14181d777ad7d110267624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc396715ae5034be1a14181d777ad7d110267624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc396715ae5034be1a14181d777ad7d110267624"}], "stats": {"total": 89, "additions": 33, "deletions": 56}, "files": [{"sha": "99d384eac91d66eb5300d1ab79f1e7c978296597", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d92b55538087dd0c4acfed6bbed89053e5521d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d92b55538087dd0c4acfed6bbed89053e5521d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d92b55538087dd0c4acfed6bbed89053e5521d3", "patch": "@@ -1,3 +1,22 @@\n+2015-01-13  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/64481\n+\t* ipa-inline-analysis.c (node_growth_cache): Remove.\n+\t(initialize_growth_caches): Do not initialize it.\n+\t(free_growth_caches): Do not free it.\n+\t(do_estimate_growth): Rename to ...\n+\t(estimate_growth): ... this one; drop growth cache code.\n+\t(growth_likely_positive): Always go the heuristics way.\n+\t* ipa-inline.c (can_inline_edge_p): Walk through aliases.\n+\t(reset_edge_caches): Do not reset node growth.\n+\t(heap_edge_removal_hook): Do not maintain cache.\n+\t(inline_small_functions): Likewise; strenghten sanity check.\n+\t(ipa_inline): Do not maintain caches.\n+\t* ipa-inline.h (node_growth_cache): Remove.\n+\t(do_estimate_growth): Remove to ...\n+\t(estimate_growth): this one; remove inline version.\n+\t(reset_node_growth_cache): Remove.\n+\n 2015-01-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/64565"}, {"sha": "02b756e8566556a9d0f87913a11a582149d54f35", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d92b55538087dd0c4acfed6bbed89053e5521d3/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d92b55538087dd0c4acfed6bbed89053e5521d3/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=0d92b55538087dd0c4acfed6bbed89053e5521d3", "patch": "@@ -167,7 +167,6 @@ function_summary <inline_summary *> *inline_summaries;\n vec<inline_edge_summary_t> inline_edge_summary_vec;\n \n /* Cached node/edge growths.  */\n-vec<int> node_growth_cache;\n vec<edge_growth_cache_entry> edge_growth_cache;\n \n /* Edge predicates goes here.  */\n@@ -1341,8 +1340,6 @@ initialize_growth_caches (void)\n {\n   if (symtab->edges_max_uid)\n     edge_growth_cache.safe_grow_cleared (symtab->edges_max_uid);\n-  if (symtab->cgraph_max_uid)\n-    node_growth_cache.safe_grow_cleared (symtab->cgraph_max_uid);\n }\n \n \n@@ -1352,7 +1349,6 @@ void\n free_growth_caches (void)\n {\n   edge_growth_cache.release ();\n-  node_growth_cache.release ();\n }\n \n \n@@ -3931,7 +3927,7 @@ do_estimate_growth_1 (struct cgraph_node *node, void *data)\n /* Estimate the growth caused by inlining NODE into all callees.  */\n \n int\n-do_estimate_growth (struct cgraph_node *node)\n+estimate_growth (struct cgraph_node *node)\n {\n   struct growth_data d = { node, 0, false };\n   struct inline_summary *info = inline_summaries->get (node);\n@@ -3960,12 +3956,6 @@ do_estimate_growth (struct cgraph_node *node)\n \t\t     + 50) / 100;\n     }\n \n-  if (node_growth_cache.exists ())\n-    {\n-      if ((int) node_growth_cache.length () <= node->uid)\n-\tnode_growth_cache.safe_grow_cleared (symtab->cgraph_max_uid);\n-      node_growth_cache[node->uid] = d.growth + (d.growth >= 0);\n-    }\n   return d.growth;\n }\n \n@@ -3979,7 +3969,6 @@ bool\n growth_likely_positive (struct cgraph_node *node, int edge_growth ATTRIBUTE_UNUSED)\n {\n   int max_callers;\n-  int ret;\n   struct cgraph_edge *e;\n   gcc_checking_assert (edge_growth > 0);\n \n@@ -3999,10 +3988,6 @@ growth_likely_positive (struct cgraph_node *node, int edge_growth ATTRIBUTE_UNUS\n       || !node->can_remove_if_no_direct_calls_p ())\n     return true;\n \n-  /* If there is cached value, just go ahead.  */\n-  if ((int)node_growth_cache.length () > node->uid\n-      && (ret = node_growth_cache[node->uid]))\n-    return ret > 0;\n   if (!node->will_be_removed_from_program_if_no_direct_calls_p ()\n       && (!DECL_COMDAT (node->decl)\n \t  || !node->can_remove_if_no_direct_calls_p ()))"}, {"sha": "96d618e0024226b0ad7b395435247f2add03d5df", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d92b55538087dd0c4acfed6bbed89053e5521d3/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d92b55538087dd0c4acfed6bbed89053e5521d3/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=0d92b55538087dd0c4acfed6bbed89053e5521d3", "patch": "@@ -388,11 +388,11 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n   else if (caller_tree != callee_tree)\n     {\n       if (((opt_for_fn (e->caller->decl, optimize)\n-\t    > opt_for_fn (e->callee->decl, optimize))\n+\t    > opt_for_fn (callee->decl, optimize))\n \t    || (opt_for_fn (e->caller->decl, optimize_size)\n-\t\t!= opt_for_fn (e->callee->decl, optimize_size)))\n+\t\t!= opt_for_fn (callee->decl, optimize_size)))\n \t  /* gcc.dg/pr43564.c.  Look at forced inline even in -O0.  */\n-\t  && !DECL_DISREGARD_INLINE_LIMITS (e->callee->decl))\n+\t  && !DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n \t{\n \t  e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t  inlinable = false;\n@@ -1095,9 +1095,6 @@ reset_edge_caches (struct cgraph_node *node)\n   if (where->global.inlined_to)\n     where = where->global.inlined_to;\n \n-  /* WHERE body size has changed, the cached growth is invalid.  */\n-  reset_node_growth_cache (where);\n-\n   for (edge = where->callers; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       reset_edge_growth_cache (edge);\n@@ -1428,8 +1425,6 @@ add_new_edges_to_heap (edge_heap_t *heap, vec<cgraph_edge *> new_edges)\n static void\n heap_edge_removal_hook (struct cgraph_edge *e, void *data)\n {\n-  if (e->callee)\n-    reset_node_growth_cache (e->callee);\n   if (e->aux)\n     {\n       ((edge_heap_t *)data)->delete_node ((edge_heap_node_t *)e->aux);\n@@ -1622,7 +1617,6 @@ inline_small_functions (void)\n \t  struct cgraph_node *where = node->global.inlined_to\n \t\t\t\t      ? node->global.inlined_to : node;\n \t  inline_update_overall_summary (where);\n-          reset_node_growth_cache (where);\n \t  reset_edge_caches (where);\n           update_caller_keys (&edge_heap, where,\n \t\t\t      updated_nodes, NULL);\n@@ -1653,8 +1647,15 @@ inline_small_functions (void)\n #ifdef ENABLE_CHECKING\n       /* Be sure that caches are maintained consistent.  */\n       sreal cached_badness = edge_badness (edge, false);\n+ \n+      int old_size_est = estimate_edge_size (edge);\n+      int old_time_est = estimate_edge_time (edge);\n+      int old_hints_est = estimate_edge_hints (edge);\n+\n       reset_edge_growth_cache (edge);\n-      reset_node_growth_cache (edge->callee);\n+      gcc_assert (old_size_est == estimate_edge_size (edge));\n+      gcc_assert (old_time_est == estimate_edge_time (edge));\n+      gcc_assert (old_hints_est == estimate_edge_hints (edge));\n \n       /* When updating the edge costs, we only decrease badness in the keys.\n \t Increases of badness are handled lazilly; when we see key with out\n@@ -1785,8 +1786,7 @@ inline_small_functions (void)\n \t  inline_call (edge, true, &new_indirect_edges, &overall_size, true);\n \t  add_new_edges_to_heap (&edge_heap, new_indirect_edges);\n \n-\t  reset_edge_caches (edge->callee);\n-          reset_node_growth_cache (callee);\n+\t  reset_edge_caches (edge->callee->function_symbol ());\n \n \t  update_callee_keys (&edge_heap, where, updated_nodes);\n \t}\n@@ -2218,7 +2218,6 @@ ipa_inline (void)\n \t    {\n \t      struct cgraph_node *where = node->global.inlined_to\n \t\t\t\t\t  ? node->global.inlined_to : node;\n-              reset_node_growth_cache (where);\n \t      reset_edge_caches (where);\n \t      inline_update_overall_summary (where);\n \t    }"}, {"sha": "ea7cb09270985b3479327e8d28ab386d07987107", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d92b55538087dd0c4acfed6bbed89053e5521d3/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d92b55538087dd0c4acfed6bbed89053e5521d3/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=0d92b55538087dd0c4acfed6bbed89053e5521d3", "patch": "@@ -224,7 +224,6 @@ struct edge_growth_cache_entry\n   inline_hints hints;\n };\n \n-extern vec<int> node_growth_cache;\n extern vec<edge_growth_cache_entry> edge_growth_cache;\n \n /* In ipa-inline-analysis.c  */\n@@ -245,7 +244,7 @@ void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n \t\t\t\t\tvec<ipa_polymorphic_call_context>,\n \t\t\t\t\tvec<ipa_agg_jump_function_p>,\n \t\t\t\t\tint *, int *, inline_hints *);\n-int do_estimate_growth (struct cgraph_node *);\n+int estimate_growth (struct cgraph_node *);\n bool growth_likely_positive (struct cgraph_node *, int);\n void inline_merge_summary (struct cgraph_edge *edge);\n void inline_update_overall_summary (struct cgraph_node *node);\n@@ -274,21 +273,6 @@ inline_edge_summary (struct cgraph_edge *edge)\n   return &inline_edge_summary_vec[edge->uid];\n }\n \n-/* Return estimated unit growth after inlning all calls to NODE.\n-   Quick accesors to the inline growth caches.  \n-   For convenience we keep zero 0 as unknown.  Because growth\n-   can be both positive and negative, we simply increase positive\n-   growths by 1. */\n-static inline int\n-estimate_growth (struct cgraph_node *node)\n-{\n-  int ret;\n-  if ((int)node_growth_cache.length () <= node->uid\n-      || !(ret = node_growth_cache[node->uid]))\n-    return do_estimate_growth (node);\n-  return ret - (ret > 0);\n-}\n-\n \n /* Return estimated size of the inline sequence of EDGE.  */\n \n@@ -342,16 +326,6 @@ estimate_edge_hints (struct cgraph_edge *edge)\n   return ret - 1;\n }\n \n-\n-/* Reset cached value for NODE.  */\n-\n-static inline void\n-reset_node_growth_cache (struct cgraph_node *node)\n-{\n-  if ((int)node_growth_cache.length () > node->uid)\n-    node_growth_cache[node->uid] = 0;\n-}\n-\n /* Reset cached value for EDGE.  */\n \n static inline void"}]}