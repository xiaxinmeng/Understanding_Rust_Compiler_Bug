{"sha": "6496a589dfe14041da10691b70be2e1825829c2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ5NmE1ODlkZmUxNDA0MWRhMTA2OTFiNzBiZTJlMTgyNTgyOWMyYg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2001-05-01T12:11:35Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2001-05-01T12:11:35Z"}, "message": "bitmap.c: Change NULL_PTR to NULL or \"(rtx*)0\".\n\n\t* bitmap.c: Change NULL_PTR to NULL or \"(rtx*)0\".\n\t* c-common.c: Likewise.\n\t* c-decl.c: Likewise.\n\t* combine.c: Likewise.\n\t* rs6000.c: Likewise.\n\t* except.c: Likewise.\n\t* explow.c: Likewise.\n\t* expr.c: Likewise.\n\t* fold-const.c: Likewise.\n\t* function.c: Likewise.\n\t* gcc.c: Likewise.\n\t* gcse.c: Likewise.\n\t* integrate.c: Likewise.\n\t* loop.c: Likewise.\n\t* objc/objc-act.c: Likewise.\n\t* recog.c: Likewise.\n\t* reg-stack.c: Likewise.\n\t* reload.c: Likewise.\n\t* reload1.c: Likewise.\n\t* simplify-rtx.c: Likewise.\n\t* stmt.c: Likewise.\n\t* varasm.c: Likewise.\n\nFrom-SVN: r41722", "tree": {"sha": "8291109d2b67c4e545af01d31c07d304a1aa6fc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8291109d2b67c4e545af01d31c07d304a1aa6fc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6496a589dfe14041da10691b70be2e1825829c2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6496a589dfe14041da10691b70be2e1825829c2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6496a589dfe14041da10691b70be2e1825829c2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6496a589dfe14041da10691b70be2e1825829c2b/comments", "author": null, "committer": null, "parents": [{"sha": "4b48a93e898353dc4bbe1bec80ec56736fc16beb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b48a93e898353dc4bbe1bec80ec56736fc16beb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b48a93e898353dc4bbe1bec80ec56736fc16beb"}], "stats": {"total": 446, "additions": 235, "deletions": 211}, "files": [{"sha": "ae82798df81ea90e9caae216beb7fa9c58f5025d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -1,3 +1,28 @@\n+2001-05-01  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* bitmap.c: Change NULL_PTR to NULL or \"(rtx*)0\".\n+\t* c-common.c: Likewise.\n+\t* c-decl.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* rs6000.c: Likewise.\n+\t* except.c: Likewise.\n+\t* explow.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* function.c: Likewise.\n+\t* gcc.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* integrate.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* objc/objc-act.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* reload.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* simplify-rtx.c: Likewise.\n+\t* stmt.c: Likewise.\n+\t* varasm.c: Likewise.\n+\n 2001-05-01  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* diagnostic.def: New file."}, {"sha": "56a5fd7b3b9ad5a6ca731141a01a9e2224437629", "filename": "gcc/bitmap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -673,6 +673,6 @@ bitmap_release_memory ()\n   if (bitmap_obstack_init)\n     {\n       bitmap_obstack_init = FALSE;\n-      obstack_free (&bitmap_obstack, NULL_PTR);\n+      obstack_free (&bitmap_obstack, NULL);\n     }\n }"}, {"sha": "751d67d2e0d0995cea2c2bc869574479e0ac93df", "filename": "gcc/c-common.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -2893,14 +2893,14 @@ c_common_nodes_and_builtins ()\n   tree va_list_arg_type_node;\n \n   /* Define `int' and `char' first so that dbx will output them first.  */\n-  record_builtin_type (RID_INT, NULL_PTR, integer_type_node);\n+  record_builtin_type (RID_INT, NULL, integer_type_node);\n   record_builtin_type (RID_CHAR, \"char\", char_type_node);\n \n   /* `signed' is the same as `int'.  FIXME: the declarations of \"signed\",\n      \"unsigned long\", \"long long unsigned\" and \"unsigned short\" were in C++\n      but not C.  Are the conditionals here needed?  */\n   if (c_language == clk_cplusplus)\n-    record_builtin_type (RID_SIGNED, NULL_PTR, integer_type_node);\n+    record_builtin_type (RID_SIGNED, NULL, integer_type_node);\n   record_builtin_type (RID_LONG, \"long int\", long_integer_type_node);\n   record_builtin_type (RID_UNSIGNED, \"unsigned int\", unsigned_type_node);\n   record_builtin_type (RID_MAX, \"long unsigned int\",\n@@ -2964,8 +2964,8 @@ c_common_nodes_and_builtins ()\n \n   build_common_tree_nodes_2 (flag_short_double);\n \n-  record_builtin_type (RID_FLOAT, NULL_PTR, float_type_node);\n-  record_builtin_type (RID_DOUBLE, NULL_PTR, double_type_node);\n+  record_builtin_type (RID_FLOAT, NULL, float_type_node);\n+  record_builtin_type (RID_DOUBLE, NULL, double_type_node);\n   record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n \n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex int\"),\n@@ -2977,7 +2977,7 @@ c_common_nodes_and_builtins ()\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n \t\t\tcomplex_long_double_type_node));\n \n-  record_builtin_type (RID_VOID, NULL_PTR, void_type_node);\n+  record_builtin_type (RID_VOID, NULL, void_type_node);\n \n   void_list_node = build_void_list_node ();\n \n@@ -3288,17 +3288,17 @@ c_common_nodes_and_builtins ()\n \t\t\t\t\t\t NULL_TREE)));\n \n   builtin_function (\"__builtin_constant_p\", default_function_type,\n-\t\t    BUILT_IN_CONSTANT_P, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_CONSTANT_P, BUILT_IN_NORMAL, NULL);\n \n   builtin_function (\"__builtin_return_address\", ptr_ftype_unsigned,\n-\t\t    BUILT_IN_RETURN_ADDRESS, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_RETURN_ADDRESS, BUILT_IN_NORMAL, NULL);\n \n   builtin_function (\"__builtin_frame_address\", ptr_ftype_unsigned,\n-\t\t    BUILT_IN_FRAME_ADDRESS, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_FRAME_ADDRESS, BUILT_IN_NORMAL, NULL);\n \n #ifdef EH_RETURN_DATA_REGNO\n   builtin_function (\"__builtin_eh_return_data_regno\", int_ftype_int,\n-\t\t    BUILT_IN_EH_RETURN_DATA_REGNO, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_EH_RETURN_DATA_REGNO, BUILT_IN_NORMAL, NULL);\n #endif\n \n   builtin_function (\"__builtin_alloca\", ptr_ftype_sizetype,\n@@ -3308,13 +3308,13 @@ c_common_nodes_and_builtins ()\n \t\t      BUILT_IN_FFS, BUILT_IN_NORMAL, 0, 1, 0);\n   /* Define alloca as builtin, unless SMALL_STACK.  */\n #ifndef SMALL_STACK\n-  builtin_function_2 (NULL_PTR, \"alloca\", NULL_TREE, ptr_ftype_sizetype,\n+  builtin_function_2 (NULL, \"alloca\", NULL_TREE, ptr_ftype_sizetype,\n \t\t      BUILT_IN_ALLOCA, BUILT_IN_NORMAL, 0, 1, 0);\n #endif\n   /* Declare _exit and _Exit just to mark them as non-returning.  */\n-  builtin_function_2 (NULL_PTR, \"_exit\", NULL_TREE, void_ftype_int,\n+  builtin_function_2 (NULL, \"_exit\", NULL_TREE, void_ftype_int,\n \t\t      0, NOT_BUILT_IN, 0, 1, 1);\n-  builtin_function_2 (NULL_PTR, \"_Exit\", NULL_TREE, void_ftype_int,\n+  builtin_function_2 (NULL, \"_Exit\", NULL_TREE, void_ftype_int,\n \t\t      0, NOT_BUILT_IN, 0, !flag_isoc99, 1);\n \n   builtin_function_2 (\"__builtin_index\", \"index\",\n@@ -3357,75 +3357,75 @@ c_common_nodes_and_builtins ()\n \t\t      BUILT_IN_ABS, BUILT_IN_NORMAL, 0, !flag_isoc99, 0);\n \n   builtin_function (\"__builtin_saveregs\", ptr_ftype, BUILT_IN_SAVEREGS,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_classify_type\", default_function_type,\n-\t\t    BUILT_IN_CLASSIFY_TYPE, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_CLASSIFY_TYPE, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_next_arg\", ptr_ftype, BUILT_IN_NEXT_ARG,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_args_info\", int_ftype_int, BUILT_IN_ARGS_INFO,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_setjmp\",\n \t\t    build_function_type (integer_type_node,\n \t\t\t\t\t tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t\t\t    endlink)),\n-\t\t    BUILT_IN_SETJMP, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_SETJMP, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_longjmp\",\n \t\t    build_function_type (void_type_node,\n \t\t\t\t\t tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t\t\t    int_endlink)),\n-\t\t    BUILT_IN_LONGJMP, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_LONGJMP, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_trap\", void_ftype, BUILT_IN_TRAP,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n \n   /* ISO C99 IEEE Unordered compares.  */\n   builtin_function (\"__builtin_isgreater\", default_function_type,\n-\t\t    BUILT_IN_ISGREATER, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_ISGREATER, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_isgreaterequal\", default_function_type,\n-\t\t    BUILT_IN_ISGREATEREQUAL, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_ISGREATEREQUAL, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_isless\", default_function_type,\n-\t\t    BUILT_IN_ISLESS, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_ISLESS, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_islessequal\", default_function_type,\n-\t\t    BUILT_IN_ISLESSEQUAL, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_ISLESSEQUAL, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_islessgreater\", default_function_type,\n-\t\t    BUILT_IN_ISLESSGREATER, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_ISLESSGREATER, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_isunordered\", default_function_type,\n-\t\t    BUILT_IN_ISUNORDERED, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_ISUNORDERED, BUILT_IN_NORMAL, NULL);\n \n   /* Untyped call and return.  */\n   builtin_function (\"__builtin_apply_args\", ptr_ftype,\n-\t\t    BUILT_IN_APPLY_ARGS, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_APPLY_ARGS, BUILT_IN_NORMAL, NULL);\n \n   temp = tree_cons (NULL_TREE,\n \t\t    build_pointer_type (build_function_type (void_type_node,\n \t\t\t\t\t\t\t     NULL_TREE)),\n \t\t    tree_cons (NULL_TREE, ptr_type_node, sizetype_endlink));\n   builtin_function (\"__builtin_apply\",\n \t\t    build_function_type (ptr_type_node, temp),\n-\t\t    BUILT_IN_APPLY, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_APPLY, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_return\", void_ftype_ptr,\n-\t\t    BUILT_IN_RETURN, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_RETURN, BUILT_IN_NORMAL, NULL);\n \n   /* Support for varargs.h and stdarg.h.  */\n   builtin_function (\"__builtin_varargs_start\",\n \t\t    build_function_type (void_type_node,\n \t\t\t\t\t tree_cons (NULL_TREE,\n \t\t\t\t\t\t    va_list_ref_type_node,\n \t\t\t\t\t\t    endlink)),\n-\t\t    BUILT_IN_VARARGS_START, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_VARARGS_START, BUILT_IN_NORMAL, NULL);\n \n   builtin_function (\"__builtin_stdarg_start\",\n \t\t    build_function_type (void_type_node,\n \t\t\t\t\t tree_cons (NULL_TREE,\n \t\t\t\t\t\t    va_list_ref_type_node,\n \t\t\t\t\t\t    NULL_TREE)),\n-\t\t    BUILT_IN_STDARG_START, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_STDARG_START, BUILT_IN_NORMAL, NULL);\n \n   builtin_function (\"__builtin_va_end\",\n \t\t    build_function_type (void_type_node,\n \t\t\t\t\t tree_cons (NULL_TREE,\n \t\t\t\t\t\t    va_list_ref_type_node,\n \t\t\t\t\t\t    endlink)),\n-\t\t    BUILT_IN_VA_END, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_VA_END, BUILT_IN_NORMAL, NULL);\n \n   builtin_function (\"__builtin_va_copy\",\n \t\t    build_function_type (void_type_node,\n@@ -3434,7 +3434,7 @@ c_common_nodes_and_builtins ()\n \t\t\t\t\t\t    tree_cons (NULL_TREE,\n \t\t\t\t\t\t      va_list_arg_type_node,\n \t\t\t\t\t\t      endlink))),\n-\t\t    BUILT_IN_VA_COPY, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_VA_COPY, BUILT_IN_NORMAL, NULL);\n \n   /* ??? Ought to be `T __builtin_expect(T, T)' for any type T.  */\n   builtin_function (\"__builtin_expect\",\n@@ -3444,7 +3444,7 @@ c_common_nodes_and_builtins ()\n \t\t\t\t\t\t    tree_cons (NULL_TREE,\n \t\t\t\t\t\t\tlong_integer_type_node,\n \t\t\t\t\t\t\tendlink))),\n-\t\t    BUILT_IN_EXPECT, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_EXPECT, BUILT_IN_NORMAL, NULL);\n \n   /* Currently under experimentation.  */\n   builtin_function_2 (\"__builtin_memcpy\", \"memcpy\",\n@@ -3590,12 +3590,12 @@ c_common_nodes_and_builtins ()\n \n   /* Declare these functions non-returning\n      to avoid spurious \"control drops through\" warnings.  */\n-  builtin_function_2 (NULL_PTR, \"abort\",\n+  builtin_function_2 (NULL, \"abort\",\n \t\t      NULL_TREE, ((c_language == clk_cplusplus)\n \t\t\t\t  ? void_ftype : void_ftype_any),\n \t\t      0, NOT_BUILT_IN, 0, 0, 1);\n \n-  builtin_function_2 (NULL_PTR, \"exit\",\n+  builtin_function_2 (NULL, \"exit\",\n \t\t      NULL_TREE, ((c_language == clk_cplusplus)\n \t\t\t\t  ? void_ftype_int : void_ftype_any),\n \t\t      0, NOT_BUILT_IN, 0, 0, 1);\n@@ -3604,21 +3604,21 @@ c_common_nodes_and_builtins ()\n   /* Support for these has not been written in either expand_builtin\n      or build_function_call.  */\n   builtin_function (\"__builtin_div\", default_ftype, BUILT_IN_DIV,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_ldiv\", default_ftype, BUILT_IN_LDIV,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_ffloor\", double_ftype_double, BUILT_IN_FFLOOR,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_fceil\", double_ftype_double, BUILT_IN_FCEIL,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_fmod\", double_ftype_double_double,\n-\t\t    BUILT_IN_FMOD, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_FMOD, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_frem\", double_ftype_double_double,\n-\t\t    BUILT_IN_FREM, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_FREM, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_getexp\", double_ftype_double, BUILT_IN_GETEXP,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_getman\", double_ftype_double, BUILT_IN_GETMAN,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n #endif\n \n   main_identifier_node = get_identifier (\"main\");\n@@ -3669,7 +3669,7 @@ builtin_function_2 (builtin_name, name, builtin_type, type, function_code,\n   if (builtin_name != 0)\n     {\n       bdecl = builtin_function (builtin_name, builtin_type, function_code,\n-\t\t\t\tclass, library_name_p ? name : NULL_PTR);\n+\t\t\t\tclass, library_name_p ? name : NULL);\n       if (noreturn_p)\n \t{\n \t  TREE_THIS_VOLATILE (bdecl) = 1;\n@@ -3678,7 +3678,7 @@ builtin_function_2 (builtin_name, name, builtin_type, type, function_code,\n     }\n   if (name != 0 && !flag_no_builtin && !(nonansi_p && flag_no_nonansi_builtin))\n     {\n-      decl = builtin_function (name, type, function_code, class, NULL_PTR);\n+      decl = builtin_function (name, type, function_code, class, NULL);\n       if (nonansi_p)\n \tDECL_BUILT_IN_NONANSI (decl) = 1;\n       if (noreturn_p)"}, {"sha": "3de45922245493f03b0618c7c0013f368dd6a5ca", "filename": "gcc/c-decl.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -2547,7 +2547,7 @@ implicitly_declare (functionid)\n   /* This is a no-op in c-lang.c or something real in objc-actions.c.  */\n   maybe_objc_check_decl (decl);\n \n-  rest_of_decl_compilation (decl, NULL_PTR, 0, 0);\n+  rest_of_decl_compilation (decl, NULL, 0, 0);\n \n   if (implicit_warning)\n     implicit_decl_warning (functionid);\n@@ -3059,23 +3059,23 @@ init_decl_processing ()\n   builtin_function (\"__builtin_aggregate_incoming_address\",\n \t\t    build_function_type (ptr_type_node, NULL_TREE),\n \t\t    BUILT_IN_AGGREGATE_INCOMING_ADDRESS,\n-\t\t    BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_NORMAL, NULL);\n \n   /* Hooks for the DWARF 2 __throw routine.  */\n   builtin_function (\"__builtin_unwind_init\",\n \t\t    build_function_type (void_type_node, endlink),\n-\t\t    BUILT_IN_UNWIND_INIT, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_UNWIND_INIT, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_dwarf_cfa\", ptr_ftype_void,\n-\t\t    BUILT_IN_DWARF_CFA, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_DWARF_CFA, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_dwarf_fp_regnum\",\n \t\t    build_function_type (unsigned_type_node, endlink),\n-\t\t    BUILT_IN_DWARF_FP_REGNUM, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_DWARF_FP_REGNUM, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_init_dwarf_reg_size_table\", void_ftype_ptr,\n-\t\t    BUILT_IN_INIT_DWARF_REG_SIZES, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_INIT_DWARF_REG_SIZES, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_frob_return_addr\", ptr_ftype_ptr,\n-\t\t    BUILT_IN_FROB_RETURN_ADDR, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_FROB_RETURN_ADDR, BUILT_IN_NORMAL, NULL);\n   builtin_function (\"__builtin_extract_return_addr\", ptr_ftype_ptr,\n-\t\t    BUILT_IN_EXTRACT_RETURN_ADDR, BUILT_IN_NORMAL, NULL_PTR);\n+\t\t    BUILT_IN_EXTRACT_RETURN_ADDR, BUILT_IN_NORMAL, NULL);\n   builtin_function\n     (\"__builtin_eh_return\",\n      build_function_type (void_type_node,\n@@ -3084,7 +3084,7 @@ init_decl_processing ()\n \t\t\t\t     tree_cons (NULL_TREE,\n \t\t\t\t\t\tptr_type_node,\n \t\t\t\t\t\tendlink))),\n-     BUILT_IN_EH_RETURN, BUILT_IN_NORMAL, NULL_PTR);\n+     BUILT_IN_EH_RETURN, BUILT_IN_NORMAL, NULL);\n \n   pedantic_lvalues = pedantic;\n \n@@ -3179,7 +3179,7 @@ builtin_function (name, type, function_code, class, library_name)\n     DECL_BUILT_IN_NONANSI (decl) = 1;\n   if (library_name)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n-  make_decl_rtl (decl, NULL_PTR);\n+  make_decl_rtl (decl, NULL);\n   pushdecl (decl);\n   DECL_BUILT_IN_CLASS (decl) = class;\n   DECL_FUNCTION_CODE (decl) = function_code;\n@@ -3644,7 +3644,7 @@ finish_decl (decl, init, asmspec_tree)\n     {\n       /* This is a no-op in c-lang.c or something real in objc-actions.c.  */\n       maybe_objc_check_decl (decl);\n-      rest_of_decl_compilation (decl, NULL_PTR, DECL_CONTEXT (decl) == 0, 0);\n+      rest_of_decl_compilation (decl, NULL, DECL_CONTEXT (decl) == 0, 0);\n     }\n \n   /* At the end of a declaration, throw away any variable type sizes\n@@ -5503,7 +5503,7 @@ finish_struct (t, fieldlist, attributes)\n \t      layout_decl (decl, 0);\n \t      /* This is a no-op in c-lang.c or something real in objc-actions.c.  */\n \t      maybe_objc_check_decl (decl);\n-\t      rest_of_decl_compilation (decl, NULL_PTR, toplevel, 0);\n+\t      rest_of_decl_compilation (decl, NULL, toplevel, 0);\n \t      if (! toplevel)\n \t\texpand_decl (decl);\n \t      --current_binding_level->n_incomplete;"}, {"sha": "4693855e4d999392c01da4ebb5d571c4285936fc", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -1952,7 +1952,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t isn't mentioned in any SETs in NEWPAT that are field assignments.  */\n \n       if (! combinable_i3pat (NULL_RTX, &newpat, i1dest, NULL_RTX,\n-\t\t\t      0, NULL_PTR))\n+\t\t\t      0, (rtx*)0))\n \t{\n \t  undo_all ();\n \t  return 0;\n@@ -3029,7 +3029,7 @@ find_split_point (loc, insn)\n \t      && GET_CODE (XEXP (SET_SRC (x), 0)) == REG\n \t      && (pos = exact_log2 (INTVAL (XEXP (SET_SRC (x), 1)))) >= 7\n \t      && GET_CODE (SET_DEST (x)) == REG\n-\t      && (split = find_single_use (SET_DEST (x), insn, NULL_PTR)) != 0\n+\t      && (split = find_single_use (SET_DEST (x), insn, (rtx*)0)) != 0\n \t      && (GET_CODE (*split) == EQ || GET_CODE (*split) == NE)\n \t      && XEXP (*split, 0) == SET_DEST (x)\n \t      && XEXP (*split, 1) == const0_rtx)"}, {"sha": "4fa63a177d56232000a0e70291b6d04e62673522", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -5445,7 +5445,7 @@ rs6000_emit_eh_toc_restore (stacksize)\n     abort();\n   emit_move_insn (opcode, insn_after_throw);\n   \n-  emit_note (NULL_PTR, NOTE_INSN_LOOP_BEG);\n+  emit_note (NULL, NOTE_INSN_LOOP_BEG);\n   emit_label (loop_start);\n   \n   do_compare_rtx_and_jump (opcode, tocompare, NE, 1,\n@@ -5472,9 +5472,9 @@ rs6000_emit_eh_toc_restore (stacksize)\n   emit_move_insn (opcode_addr, mem);\n   emit_move_insn (opcode, gen_rtx_MEM (SImode, opcode_addr));\n \n-  emit_note (NULL_PTR, NOTE_INSN_LOOP_CONT);\n+  emit_note (NULL, NOTE_INSN_LOOP_CONT);\n   emit_jump (loop_start);\n-  emit_note (NULL_PTR, NOTE_INSN_LOOP_END);\n+  emit_note (NULL, NOTE_INSN_LOOP_END);\n   emit_label (loop_exit);\n }\n #endif /* TARGET_AIX */"}, {"sha": "a0158126b2b5f001e528df25f3535d10fda5ab93", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -661,7 +661,7 @@ expand_eh_region_start ()\n \n   /* Create a note marking the start of this region.  */\n   new_region->region_number = ++cfun->eh->last_region_number;\n-  note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_BEG);\n+  note = emit_note (NULL, NOTE_INSN_EH_REGION_BEG);\n   NOTE_EH_HANDLER (note) = new_region->region_number;\n }\n \n@@ -674,7 +674,7 @@ expand_eh_region_end ()\n   rtx note;\n \n   /* Create a nute marking the end of this region.  */\n-  note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_END);\n+  note = emit_note (NULL, NOTE_INSN_EH_REGION_END);\n   NOTE_EH_HANDLER (note) = cur_region->region_number;\n \n   /* Pop.  */"}, {"sha": "171670b3374535acfeb88d9d5b3d15bf9037d83a", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -1625,13 +1625,13 @@ probe_stack_range (first, size)\n \t  || REGNO (test_addr) < FIRST_PSEUDO_REGISTER)\n \ttest_addr = force_reg (Pmode, test_addr);\n \n-      emit_note (NULL_PTR, NOTE_INSN_LOOP_BEG);\n+      emit_note (NULL, NOTE_INSN_LOOP_BEG);\n       emit_jump (test_lab);\n \n       emit_label (loop_lab);\n       emit_stack_probe (test_addr);\n \n-      emit_note (NULL_PTR, NOTE_INSN_LOOP_CONT);\n+      emit_note (NULL, NOTE_INSN_LOOP_CONT);\n \n #ifdef STACK_GROWS_DOWNWARD\n #define CMP_OPCODE GTU\n@@ -1650,7 +1650,7 @@ probe_stack_range (first, size)\n       emit_cmp_and_jump_insns (test_addr, last_addr, CMP_OPCODE,\n \t\t\t       NULL_RTX, Pmode, 1, 0, loop_lab);\n       emit_jump (end_lab);\n-      emit_note (NULL_PTR, NOTE_INSN_LOOP_END);\n+      emit_note (NULL, NOTE_INSN_LOOP_END);\n       emit_label (end_lab);\n \n       emit_stack_probe (last_addr);"}, {"sha": "2ad473c3abd5cd6f34a51ca521692032a38c5fa4", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -1768,7 +1768,7 @@ emit_block_move (x, y, size, align)\n \t  DECL_EXTERNAL (fn) = 1;\n \t  TREE_PUBLIC (fn) = 1;\n \t  DECL_ARTIFICIAL (fn) = 1;\n-\t  make_decl_rtl (fn, NULL_PTR);\n+\t  make_decl_rtl (fn, NULL);\n \t  assemble_external (fn);\n \t}\n \n@@ -2668,7 +2668,7 @@ clear_storage (object, size, align)\n \t      DECL_EXTERNAL (fn) = 1;\n \t      TREE_PUBLIC (fn) = 1;\n \t      DECL_ARTIFICIAL (fn) = 1;\n-\t      make_decl_rtl (fn, NULL_PTR);\n+\t      make_decl_rtl (fn, NULL);\n \t      assemble_external (fn);\n \t    }\n "}, {"sha": "3bedea13a78895533e0c1756178cdbc47224e462", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -997,7 +997,7 @@ exact_real_inverse (mode, r)\n     {\n       /* Don't do the optimization if there was an arithmetic error.  */\n fail:\n-      set_float_handler (NULL_PTR);\n+      set_float_handler (NULL);\n       return 0;\n     }\n   set_float_handler (float_error);\n@@ -1040,7 +1040,7 @@ exact_real_inverse (mode, r)\n #endif\n \n   /* Output the reciprocal and return success flag.  */\n-  set_float_handler (NULL_PTR);\n+  set_float_handler (NULL);\n   *r = y.d;\n   return 1;\n }"}, {"sha": "7673aab0d8138d90ce70dccb3edf5aeab595ea9b", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -2178,7 +2178,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \toptimize_bit_field (x, insn, 0);\n       if (GET_CODE (SET_SRC (x)) == SIGN_EXTRACT\n \t  || GET_CODE (SET_SRC (x)) == ZERO_EXTRACT)\n-\toptimize_bit_field (x, insn, NULL_PTR);\n+\toptimize_bit_field (x, insn, 0);\n \n       /* For a paradoxical SUBREG inside a ZERO_EXTRACT, load the object\n \t into a register and then store it back out.  */\n@@ -6209,7 +6209,7 @@ init_function_start (subr, filename, line)\n   /* Make sure first insn is a note even if we don't want linenums.\n      This makes sure the first insn will never be deleted.\n      Also, final expects a note to appear there.  */\n-  emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+  emit_note (NULL, NOTE_INSN_DELETED);\n \n   /* Set flags used by final.c.  */\n   if (aggregate_value_p (DECL_RESULT (subr)))\n@@ -6422,10 +6422,10 @@ expand_function_start (subr, parms_have_cleanups)\n      The move is supposed to make sdb output more accurate.  */\n   /* Indicate the beginning of the function body,\n      as opposed to parm setup.  */\n-  emit_note (NULL_PTR, NOTE_INSN_FUNCTION_BEG);\n+  emit_note (NULL, NOTE_INSN_FUNCTION_BEG);\n \n   if (GET_CODE (get_last_insn ()) != NOTE)\n-    emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+    emit_note (NULL, NOTE_INSN_DELETED);\n   parm_birth_insn = get_last_insn ();\n \n   context_display = 0;\n@@ -6497,7 +6497,7 @@ expand_function_start (subr, parms_have_cleanups)\n   /* After the display initializations is where the tail-recursion label\n      should go, if we end up needing one.   Ensure we have a NOTE here\n      since some things (like trampolines) get placed before this.  */\n-  tail_recursion_reentry = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+  tail_recursion_reentry = emit_note (NULL, NOTE_INSN_DELETED);\n \n   /* Evaluate now the sizes of any types declared among the arguments.  */\n   for (tem = nreverse (get_pending_sizes ()); tem; tem = TREE_CHAIN (tem))\n@@ -6755,15 +6755,15 @@ expand_function_end (filename, line, end_bindings)\n   /* Mark the end of the function body.\n      If control reaches this insn, the function can drop through\n      without returning a value.  */\n-  emit_note (NULL_PTR, NOTE_INSN_FUNCTION_END);\n+  emit_note (NULL, NOTE_INSN_FUNCTION_END);\n \n   /* Must mark the last line number note in the function, so that the test\n      coverage code can avoid counting the last line twice.  This just tells\n      the code to ignore the immediately following line note, since there\n      already exists a copy of this note somewhere above.  This line number\n      note is still needed for debugging though, so we can't delete it.  */\n   if (flag_test_coverage)\n-    emit_note (NULL_PTR, NOTE_INSN_REPEATED_LINE_NUMBER);\n+    emit_note (NULL, NOTE_INSN_REPEATED_LINE_NUMBER);\n \n   /* Output a linenumber for the end of the function.\n      SDB depends on this.  */"}, {"sha": "84ab2bf0e7747b9a596dbe53d9812be749ffd58b", "filename": "gcc/gcc.c", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -1257,7 +1257,7 @@ struct spec_list\n };\n \n #define INIT_STATIC_SPEC(NAME,PTR) \\\n-{ NAME, NULL_PTR, PTR, (struct spec_list *) 0, sizeof (NAME) - 1, 0 }\n+{ NAME, NULL, PTR, (struct spec_list *) 0, sizeof (NAME) - 1, 0 }\n \n /* List of statically defined specs.  */\n static struct spec_list static_specs[] =\n@@ -2160,7 +2160,7 @@ split_directories (name, ptr_num_dirs)\n   if (p - 1 - q > 0)\n     dirs[num_dirs++] = save_string (q, p - 1 - q);\n \n-  dirs[num_dirs] = NULL_PTR;\n+  dirs[num_dirs] = NULL;\n   if (ptr_num_dirs)\n     *ptr_num_dirs = num_dirs;\n \n@@ -2175,7 +2175,7 @@ free_split_directories (dirs)\n {\n   int i = 0;\n \n-  while (dirs[i] != NULL_PTR)\n+  while (dirs[i] != NULL)\n     free (dirs[i++]);\n \n   free ((char *) dirs);\n@@ -2282,7 +2282,7 @@ make_relative_prefix (progname, bin_prefix, prefix)\n \t  free_split_directories (prog_dirs);\n \t  free_split_directories (bin_dirs);\n \t  prog_dirs = bin_dirs = (char **) 0;\n-\t  return NULL_PTR;\n+\t  return NULL;\n \t}\n     }\n \n@@ -2302,7 +2302,7 @@ make_relative_prefix (progname, bin_prefix, prefix)\n       free_split_directories (prog_dirs);\n       free_split_directories (bin_dirs);\n       free_split_directories (prefix_dirs);\n-      return NULL_PTR;\n+      return NULL;\n     }\n \n   /* Build up the pathnames in argv[0].  */\n@@ -3115,7 +3115,7 @@ process_command (argc, argv)\n \t\t}\n \t      else\n \t\tnstore[endp - startp] = 0;\n-\t      add_prefix (&startfile_prefixes, nstore, NULL_PTR,\n+\t      add_prefix (&startfile_prefixes, nstore, NULL,\n \t\t\t  PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t      if (*endp == 0)\n \t\tbreak;\n@@ -3148,7 +3148,7 @@ process_command (argc, argv)\n \t\t}\n \t      else\n \t\tnstore[endp - startp] = 0;\n-\t      add_prefix (&startfile_prefixes, nstore, NULL_PTR,\n+\t      add_prefix (&startfile_prefixes, nstore, NULL,\n \t\t\t  PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t      if (*endp == 0)\n \t\tbreak;\n@@ -3374,25 +3374,24 @@ process_command (argc, argv)\n \t\t      && (IS_DIR_SEPARATOR (value[len - 1])))\n \t\t    {\n \t\t      if (len == 7)\n-\t\t\tadd_prefix (&include_prefixes, \"include\", NULL_PTR,\n+\t\t\tadd_prefix (&include_prefixes, \"include\", NULL,\n \t\t\t\t    PREFIX_PRIORITY_B_OPT, 0, NULL_PTR);\n \t\t      else\n \t\t\t{\n \t\t\t  char *string = xmalloc (len + 1);\n \t\t\t  strncpy (string, value, len-7);\n \t\t\t  strcpy (string+len-7, \"include\");\n-\t\t\t  add_prefix (&include_prefixes, string, NULL_PTR,\n+\t\t\t  add_prefix (&include_prefixes, string, NULL,\n \t\t\t\t      PREFIX_PRIORITY_B_OPT, 0, NULL_PTR);\n \t\t\t}\n \t\t    }\n \t\t}\n-\t\tadd_prefix (&exec_prefixes, value, NULL_PTR,\n+\t\tadd_prefix (&exec_prefixes, value, NULL,\n \t\t\t    PREFIX_PRIORITY_B_OPT, 0, &warn_B);\n-\t\tadd_prefix (&startfile_prefixes, value, NULL_PTR,\n+\t\tadd_prefix (&startfile_prefixes, value, NULL,\n \t\t\t    PREFIX_PRIORITY_B_OPT, 0, &warn_B);\n \t\tadd_prefix (&include_prefixes, concat (value, \"include\", NULL),\n-\t\t\t    NULL_PTR,\n-\t\t\t    PREFIX_PRIORITY_B_OPT, 0, NULL_PTR);\n+\t\t\t    NULL, PREFIX_PRIORITY_B_OPT, 0, NULL_PTR);\n \t\tn_switches++;\n \t      }\n \t      break;\n@@ -3598,11 +3597,11 @@ process_command (argc, argv)\n \t  add_prefix (&exec_prefixes,\n \t\t      concat (gcc_exec_tooldir_prefix, \"bin\",\n \t\t\t      dir_separator_str, NULL),\n-\t\t      NULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n+\t\t      NULL, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t  add_prefix (&startfile_prefixes,\n \t\t      concat (gcc_exec_tooldir_prefix, \"lib\",\n \t\t\t      dir_separator_str, NULL),\n-\t\t      NULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n+\t\t      NULL, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t}\n \n       tooldir_prefix = concat (standard_exec_prefix, spec_machine,\n@@ -3931,7 +3930,7 @@ do_spec (spec)\n   input_from_pipe = 0;\n   suffix_subst = NULL;\n \n-  value = do_spec_1 (spec, 0, NULL_PTR);\n+  value = do_spec_1 (spec, 0, NULL);\n \n   /* Force out any unfinished command.\n      If -pipe, this forces out the last command if it ended in `|'.  */\n@@ -4118,40 +4117,40 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\t  strcat (buffer, machine_suffix);\n \t\t\t  if (is_directory (buffer, multilib_dir, 1))\n \t\t\t    {\n-\t\t\t      do_spec_1 (\"-L\", 0, NULL_PTR);\n+\t\t\t      do_spec_1 (\"-L\", 0, NULL);\n #ifdef SPACE_AFTER_L_OPTION\n-\t\t\t      do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t\t      do_spec_1 (\" \", 0, NULL);\n #endif\n-\t\t\t      do_spec_1 (buffer, 1, NULL_PTR);\n-\t\t\t      do_spec_1 (multilib_dir, 1, NULL_PTR);\n+\t\t\t      do_spec_1 (buffer, 1, NULL);\n+\t\t\t      do_spec_1 (multilib_dir, 1, NULL);\n \t\t\t      /* Make this a separate argument.  */\n-\t\t\t      do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t\t      do_spec_1 (\" \", 0, NULL);\n \t\t\t    }\n \t\t\t}\n \t\t      if (!pl->require_machine_suffix)\n \t\t\t{\n \t\t\t  if (is_directory (pl->prefix, multilib_dir, 1))\n \t\t\t    {\n-\t\t\t      do_spec_1 (\"-L\", 0, NULL_PTR);\n+\t\t\t      do_spec_1 (\"-L\", 0, NULL);\n #ifdef SPACE_AFTER_L_OPTION\n-\t\t\t      do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t\t      do_spec_1 (\" \", 0, NULL);\n #endif\n-\t\t\t      do_spec_1 (pl->prefix, 1, NULL_PTR);\n-\t\t\t      do_spec_1 (multilib_dir, 1, NULL_PTR);\n+\t\t\t      do_spec_1 (pl->prefix, 1, NULL);\n+\t\t\t      do_spec_1 (multilib_dir, 1, NULL);\n \t\t\t      /* Make this a separate argument.  */\n-\t\t\t      do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t\t      do_spec_1 (\" \", 0, NULL);\n \t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t  if (machine_suffix)\n \t\t    {\n \t\t      if (is_directory (pl->prefix, machine_suffix, 1))\n \t\t\t{\n-\t\t\t  do_spec_1 (\"-L\", 0, NULL_PTR);\n+\t\t\t  do_spec_1 (\"-L\", 0, NULL);\n #ifdef SPACE_AFTER_L_OPTION\n-\t\t\t  do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t\t  do_spec_1 (\" \", 0, NULL);\n #endif\n-\t\t\t  do_spec_1 (pl->prefix, 1, NULL_PTR);\n+\t\t\t  do_spec_1 (pl->prefix, 1, NULL);\n \t\t\t  /* Remove slash from machine_suffix.  */\n \t\t\t  if (strlen (machine_suffix) >= bufsize)\n \t\t\t    bufsize = strlen (machine_suffix) * 2 + 1;\n@@ -4160,18 +4159,18 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\t  idx = strlen (buffer);\n \t\t\t  if (IS_DIR_SEPARATOR (buffer[idx - 1]))\n \t\t\t    buffer[idx - 1] = 0;\n-\t\t\t  do_spec_1 (buffer, 1, NULL_PTR);\n+\t\t\t  do_spec_1 (buffer, 1, NULL);\n \t\t\t  /* Make this a separate argument.  */\n-\t\t\t  do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t\t  do_spec_1 (\" \", 0, NULL);\n \t\t\t}\n \t\t    }\n \t\t  if (!pl->require_machine_suffix)\n \t\t    {\n \t\t      if (is_directory (pl->prefix, \"\", 1))\n \t\t\t{\n-\t\t\t  do_spec_1 (\"-L\", 0, NULL_PTR);\n+\t\t\t  do_spec_1 (\"-L\", 0, NULL);\n #ifdef SPACE_AFTER_L_OPTION\n-\t\t\t  do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t\t  do_spec_1 (\" \", 0, NULL);\n #endif\n \t\t\t  /* Remove slash from pl->prefix.  */\n \t\t\t  if (strlen (pl->prefix) >= bufsize)\n@@ -4181,9 +4180,9 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\t  idx = strlen (buffer);\n \t\t\t  if (IS_DIR_SEPARATOR (buffer[idx - 1]))\n \t\t\t    buffer[idx - 1] = 0;\n-\t\t\t  do_spec_1 (buffer, 1, NULL_PTR);\n+\t\t\t  do_spec_1 (buffer, 1, NULL);\n \t\t\t  /* Make this a separate argument.  */\n-\t\t\t  do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t\t  do_spec_1 (\" \", 0, NULL);\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -4326,20 +4325,20 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n \t      if (gcc_exec_prefix)\n \t\t{\n-\t\t  do_spec_1 (\"-iprefix\", 1, NULL_PTR);\n+\t\t  do_spec_1 (\"-iprefix\", 1, NULL);\n \t\t  /* Make this a separate argument.  */\n-\t\t  do_spec_1 (\" \", 0, NULL_PTR);\n-\t\t  do_spec_1 (gcc_exec_prefix, 1, NULL_PTR);\n-\t\t  do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t  do_spec_1 (\" \", 0, NULL);\n+\t\t  do_spec_1 (gcc_exec_prefix, 1, NULL);\n+\t\t  do_spec_1 (\" \", 0, NULL);\n \t\t}\n \n \t      for (; pl; pl = pl->next)\n \t\t{\n-\t\t  do_spec_1 (\"-isystem\", 1, NULL_PTR);\n+\t\t  do_spec_1 (\"-isystem\", 1, NULL);\n \t\t  /* Make this a separate argument.  */\n-\t\t  do_spec_1 (\" \", 0, NULL_PTR);\n-\t\t  do_spec_1 (pl->prefix, 1, NULL_PTR);\n-\t\t  do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t  do_spec_1 (\" \", 0, NULL);\n+\t\t  do_spec_1 (pl->prefix, 1, NULL);\n+\t\t  do_spec_1 (\" \", 0, NULL);\n \t\t}\n \t    }\n \t    break;\n@@ -4414,61 +4413,61 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t  case 'X':\n \t    for (i = 0; i < n_linker_options; i++)\n \t      {\n-\t\tdo_spec_1 (linker_options[i], 1, NULL_PTR);\n+\t\tdo_spec_1 (linker_options[i], 1, NULL);\n \t\t/* Make each accumulated option a separate argument.  */\n-\t\tdo_spec_1 (\" \", 0, NULL_PTR);\n+\t\tdo_spec_1 (\" \", 0, NULL);\n \t      }\n \t    break;\n \n \t  /* Dump out the options accumulated previously using -Wa,.  */\n \t  case 'Y':\n \t    for (i = 0; i < n_assembler_options; i++)\n \t      {\n-\t\tdo_spec_1 (assembler_options[i], 1, NULL_PTR);\n+\t\tdo_spec_1 (assembler_options[i], 1, NULL);\n \t\t/* Make each accumulated option a separate argument.  */\n-\t\tdo_spec_1 (\" \", 0, NULL_PTR);\n+\t\tdo_spec_1 (\" \", 0, NULL);\n \t      }\n \t    break;\n \n \t  /* Dump out the options accumulated previously using -Wp,.  */\n \t  case 'Z':\n \t    for (i = 0; i < n_preprocessor_options; i++)\n \t      {\n-\t\tdo_spec_1 (preprocessor_options[i], 1, NULL_PTR);\n+\t\tdo_spec_1 (preprocessor_options[i], 1, NULL);\n \t\t/* Make each accumulated option a separate argument.  */\n-\t\tdo_spec_1 (\" \", 0, NULL_PTR);\n+\t\tdo_spec_1 (\" \", 0, NULL);\n \t      }\n \t    break;\n \n \t    /* Here are digits and numbers that just process\n \t       a certain constant string as a spec.  */\n \n \t  case '1':\n-\t    value = do_spec_1 (cc1_spec, 0, NULL_PTR);\n+\t    value = do_spec_1 (cc1_spec, 0, NULL);\n \t    if (value != 0)\n \t      return value;\n \t    break;\n \n \t  case '2':\n-\t    value = do_spec_1 (cc1plus_spec, 0, NULL_PTR);\n+\t    value = do_spec_1 (cc1plus_spec, 0, NULL);\n \t    if (value != 0)\n \t      return value;\n \t    break;\n \n \t  case 'a':\n-\t    value = do_spec_1 (asm_spec, 0, NULL_PTR);\n+\t    value = do_spec_1 (asm_spec, 0, NULL);\n \t    if (value != 0)\n \t      return value;\n \t    break;\n \n \t  case 'A':\n-\t    value = do_spec_1 (asm_final_spec, 0, NULL_PTR);\n+\t    value = do_spec_1 (asm_final_spec, 0, NULL);\n \t    if (value != 0)\n \t      return value;\n \t    break;\n \n \t  case 'c':\n-\t    value = do_spec_1 (signed_char_spec, 0, NULL_PTR);\n+\t    value = do_spec_1 (signed_char_spec, 0, NULL);\n \t    if (value != 0)\n \t      return value;\n \t    break;\n@@ -4479,32 +4478,32 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t= (input_file_compiler->cpp_spec \n \t\t   ? input_file_compiler->cpp_spec \n \t\t   : cpp_spec);\n-\t      value = do_spec_1 (spec, 0, NULL_PTR);\n+\t      value = do_spec_1 (spec, 0, NULL);\n \t      if (value != 0)\n \t\treturn value;\n \t    }\n \t    break;\n \n \t  case 'E':\n-\t    value = do_spec_1 (endfile_spec, 0, NULL_PTR);\n+\t    value = do_spec_1 (endfile_spec, 0, NULL);\n \t    if (value != 0)\n \t      return value;\n \t    break;\n \n \t  case 'l':\n-\t    value = do_spec_1 (link_spec, 0, NULL_PTR);\n+\t    value = do_spec_1 (link_spec, 0, NULL);\n \t    if (value != 0)\n \t      return value;\n \t    break;\n \n \t  case 'L':\n-\t    value = do_spec_1 (lib_spec, 0, NULL_PTR);\n+\t    value = do_spec_1 (lib_spec, 0, NULL);\n \t    if (value != 0)\n \t      return value;\n \t    break;\n \n \t  case 'G':\n-\t    value = do_spec_1 (libgcc_spec, 0, NULL_PTR);\n+\t    value = do_spec_1 (libgcc_spec, 0, NULL);\n \t    if (value != 0)\n \t      return value;\n \t    break;\n@@ -4550,7 +4549,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n \t      *x = 0;\n \n-\t      value = do_spec_1 (buf, 0, NULL_PTR);\n+\t      value = do_spec_1 (buf, 0, NULL);\n \t      if (value != 0)\n \t\treturn value;\n \t    }\n@@ -4681,14 +4680,14 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n \t      *x = 0;\n \n-\t      value = do_spec_1 (buf, 0, NULL_PTR);\n+\t      value = do_spec_1 (buf, 0, NULL);\n \t      if (value != 0)\n \t\treturn value;\n \t    }\n \t    break;\n \n \t  case 'S':\n-\t    value = do_spec_1 (startfile_spec, 0, NULL_PTR);\n+\t    value = do_spec_1 (startfile_spec, 0, NULL);\n \t    if (value != 0)\n \t      return value;\n \t    break;\n@@ -4719,8 +4718,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t  case '*':\n \t    if (soft_matched_part)\n \t      {\n-\t\tdo_spec_1 (soft_matched_part, 1, NULL_PTR);\n-\t\tdo_spec_1 (\" \", 0, NULL_PTR);\n+\t\tdo_spec_1 (soft_matched_part, 1, NULL);\n+\t\tdo_spec_1 (\" \", 0, NULL);\n \t      }\n \t    else\n \t      /* Catch the case where a spec string contains something like\n@@ -4763,7 +4762,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t{\n \t\t  if (c == '(')\n \t\t    {\n-\t\t      value = do_spec_1 (name, 0, NULL_PTR);\n+\t\t      value = do_spec_1 (name, 0, NULL);\n \t\t      if (value != 0)\n \t\t\treturn value;\n \t\t    }\n@@ -4803,7 +4802,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\t}\n \t\t      *x = 0;\n \n-\t\t      value = do_spec_1 (buf, 0, NULL_PTR);\n+\t\t      value = do_spec_1 (buf, 0, NULL);\n \t\t      if (value != 0)\n \t\t\treturn value;\n \t\t    }\n@@ -4874,7 +4873,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n \t  case '|':\n \t    if (input_from_pipe)\n-\t      do_spec_1 (\"-\", 0, NULL_PTR);\n+\t      do_spec_1 (\"-\", 0, NULL);\n \t    break;\n \n \t  default:\n@@ -5007,7 +5006,7 @@ handle_braces (p)\n \tabort ();\n \n       if (negate != found\n-\t  && do_spec_1 (save_string (body, endbody-body-1), 0, NULL_PTR) < 0)\n+\t  && do_spec_1 (save_string (body, endbody-body-1), 0, NULL) < 0)\n \treturn 0;\n     }\n   else if (p[-1] == '*' && (p[0] == '}' || p[0] == '&'))\n@@ -5129,7 +5128,7 @@ handle_braces (p)\n \t{\n \t  /* Here if a %{|...} conditional fails: output a minus sign,\n \t     which means \"standard output\" or \"standard input\".  */\n-\t  do_spec_1 (\"-\", 0, NULL_PTR);\n+\t  do_spec_1 (\"-\", 0, NULL);\n \t  return endbody;\n \t}\n     }\n@@ -5160,7 +5159,7 @@ handle_braces (p)\n   else if (true_once)\n     {\n       if (do_spec_1 (save_string (body, endbody - body - 1),\n-\t\t     0, NULL_PTR) < 0)\n+\t\t     0, NULL) < 0)\n \treturn 0;\n     }\n \n@@ -5265,8 +5264,8 @@ give_switch (switchnum, omit_first_word, include_blanks)\n \n   if (!omit_first_word)\n     {\n-      do_spec_1 (\"-\", 0, NULL_PTR);\n-      do_spec_1 (switches[switchnum].part1, 1, NULL_PTR);\n+      do_spec_1 (\"-\", 0, NULL);\n+      do_spec_1 (switches[switchnum].part1, 1, NULL);\n     }\n \n   if (switches[switchnum].args != 0)\n@@ -5277,7 +5276,7 @@ give_switch (switchnum, omit_first_word, include_blanks)\n \t  const char *arg = *p;\n \n \t  if (include_blanks)\n-\t    do_spec_1 (\" \", 0, NULL_PTR);\n+\t    do_spec_1 (\" \", 0, NULL);\n \t  if (suffix_subst)\n \t    {\n \t      unsigned length = strlen (arg);\n@@ -5288,19 +5287,19 @@ give_switch (switchnum, omit_first_word, include_blanks)\n \t\t    ((char *)arg)[length] = 0;\n \t\t    break;\n \t\t  }\n-\t      do_spec_1 (arg, 1, NULL_PTR);\n+\t      do_spec_1 (arg, 1, NULL);\n \t      if (!arg[length])\n \t\t{\n \t\t  ((char *)arg)[length] = '.';\n-\t\t  do_spec_1 (suffix_subst, 1, NULL_PTR);\n+\t\t  do_spec_1 (suffix_subst, 1, NULL);\n \t\t}\n \t    }\n \t  else\n-\t    do_spec_1 (arg, 1, NULL_PTR);\n+\t    do_spec_1 (arg, 1, NULL);\n \t}\n     }\n \n-  do_spec_1 (\" \", 0, NULL_PTR);\n+  do_spec_1 (\" \", 0, NULL);\n   switches[switchnum].validated = 1;\n }\n \f\n@@ -5670,20 +5669,20 @@ main (argc, argv)\n \t    add_prefix (&startfile_prefixes,\n \t\t\tconcat (gcc_exec_prefix, machine_suffix,\n \t\t\t\tstandard_startfile_prefix, NULL),\n-\t\t\tNULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n+\t\t\tNULL, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t  add_prefix (&startfile_prefixes,\n \t\t      concat (standard_exec_prefix,\n \t\t\t      machine_suffix,\n \t\t\t      standard_startfile_prefix, NULL),\n-\t\t      NULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n+\t\t      NULL, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t}\n \n       add_prefix (&startfile_prefixes, standard_startfile_prefix_1,\n \t\t  \"BINUTILS\", PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n       add_prefix (&startfile_prefixes, standard_startfile_prefix_2,\n \t\t  \"BINUTILS\", PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n #if 0 /* Can cause surprises, and one can use -B./ instead.  */\n-      add_prefix (&startfile_prefixes, \"./\", NULL_PTR,\n+      add_prefix (&startfile_prefixes, \"./\", NULL,\n \t\t  PREFIX_PRIORITY_LAST, 1, NULL_PTR);\n #endif\n     }\n@@ -6021,7 +6020,7 @@ lookup_compiler (name, length, language)\n       /* An alias entry maps a suffix to a language.\n \t Search for the language; pass 0 for NAME and LENGTH\n \t to avoid infinite recursion if language not found.  */\n-      return lookup_compiler (NULL_PTR, 0, cp->spec + 1);\n+      return lookup_compiler (NULL, 0, cp->spec + 1);\n     }\n   return 0;\n }"}, {"sha": "a17f30ef3cb2921fd1fe8510b2d5169ddcaab8e8", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -914,7 +914,7 @@ gcse_main (f, file)\n \t       pass, pass > 1 ? \"es\" : \"\", max_pass_bytes);\n     }\n \n-  obstack_free (&gcse_obstack, NULL_PTR);\n+  obstack_free (&gcse_obstack, NULL);\n   free_reg_set_mem ();\n   /* We are finished with alias.  */\n   end_alias_analysis ();\n@@ -1247,7 +1247,7 @@ static void\n free_reg_set_mem ()\n {\n   free (reg_set_table);\n-  obstack_free (&reg_set_obstack, NULL_PTR);\n+  obstack_free (&reg_set_obstack, NULL);\n }\n \n /* Record REGNO in the reg_set table.  */"}, {"sha": "ba198b4c404c6ae3fa10bbb943720098addf1537", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -807,7 +807,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n      insn that can be used as an insertion point.  */\n   map->insns_at_start = get_last_insn ();\n   if (map->insns_at_start == 0)\n-    map->insns_at_start = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+    map->insns_at_start = emit_note (NULL, NOTE_INSN_DELETED);\n \n   map->regno_pointer_align = inl_f->emit->regno_pointer_align;\n   map->x_regno_reg_rtx = inl_f->emit->x_regno_reg_rtx;"}, {"sha": "fb045123356cc808add1246c3dc77cdadffbc320", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -4602,7 +4602,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \n \t  record_giv (loop, v, p, src_reg, dest_reg, mult_val, add_val,\n \t\t      ext_val, benefit, DEST_REG, not_every_iteration,\n-\t\t      maybe_multiple, NULL_PTR);\n+\t\t      maybe_multiple, (rtx*)0);\n \n \t}\n     }\n@@ -8582,7 +8582,7 @@ get_condition_for_loop (loop, x)\n      const struct loop *loop;\n      rtx x;\n {\n-  rtx comparison = get_condition (x, NULL_PTR);\n+  rtx comparison = get_condition (x, (rtx*)0);\n \n   if (comparison == 0\n       || ! loop_invariant_p (loop, XEXP (comparison, 0))"}, {"sha": "a074a54a09ae81e2e643b3c1b19b38ae23d3b6c7", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -1308,7 +1308,7 @@ synth_module_prologue ()\n       if (flag_traditional && TAG_MSGSEND[0] != '_')\n \tDECL_BUILT_IN_NONANSI (umsg_decl) = 1;\n \n-      make_decl_rtl (umsg_decl, NULL_PTR);\n+      make_decl_rtl (umsg_decl, NULL);\n       pushdecl (umsg_decl);\n     }\n   else"}, {"sha": "3fcd85c18c762cbaeeabaaf37d9c90e1af68b1e0", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -115,7 +115,7 @@ recog_memoized_1 (insn)\n      rtx insn;\n {\n   if (INSN_CODE (insn) < 0)\n-    INSN_CODE (insn) = recog (PATTERN (insn), insn, NULL_PTR);\n+    INSN_CODE (insn) = recog (PATTERN (insn), insn, 0);\n   return INSN_CODE (insn);\n }\n \f\n@@ -268,7 +268,7 @@ insn_invalid_p (insn)\n   int icode = recog (pat, insn,\n \t\t     (GET_CODE (pat) == SET\n \t\t      && ! reload_completed && ! reload_in_progress)\n-\t\t     ? &num_clobbers : NULL_PTR);\n+\t\t     ? &num_clobbers : 0);\n   int is_asm = icode < 0 && asm_noperands (PATTERN (insn)) >= 0;\n \n   "}, {"sha": "2bf0fe7e3e32d2a9ba169092e9a0449638f7099a", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -1498,7 +1498,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \n     case SET:\n       {\n-\trtx *src1 = (rtx *) NULL_PTR, *src2;\n+\trtx *src1 = (rtx *) 0, *src2;\n \trtx src1_note, src2_note;\n \trtx pat_src;\n "}, {"sha": "96c073dcd2f5943e8f1d29a4019070306a823ebf", "filename": "gcc/reload.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -634,7 +634,7 @@ get_secondary_mem (x, mode, opnum, type)\n \t       : type == RELOAD_FOR_OUTPUT ? RELOAD_FOR_OUTPUT_ADDRESS\n \t       : RELOAD_OTHER);\n \n-      find_reloads_address (mode, NULL_PTR, XEXP (loc, 0), &XEXP (loc, 0),\n+      find_reloads_address (mode, (rtx*)0, XEXP (loc, 0), &XEXP (loc, 0),\n \t\t\t    opnum, type, 0, 0);\n     }\n \n@@ -1035,7 +1035,7 @@ push_reload (in, out, inloc, outloc, class,\n \t order as the reloads.  Thus if the outer reload is also of type\n \t RELOAD_OTHER, we are guaranteed that this inner reload will be\n \t output before the outer reload.  */\n-      push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), NULL_PTR,\n+      push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), (rtx*)0,\n \t\t   find_valid_class (inmode,\n \t\t\t\t     subreg_regno_offset (REGNO (SUBREG_REG (in)),\n \t\t\t\t\t\t\t  GET_MODE (SUBREG_REG (in)),\n@@ -1908,7 +1908,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n       unsigned int regno = REGNO (in) + in_offset;\n       unsigned int nwords = HARD_REGNO_NREGS (regno, inmode);\n \n-      if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, NULL_PTR)\n+      if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, (rtx*)0)\n \t  && ! hard_reg_set_here_p (regno, regno + nwords,\n \t\t\t\t    PATTERN (this_insn))\n \t  && (! earlyclobber\n@@ -2327,7 +2327,7 @@ immune_p (x, y, ydata)\n   struct decomposition xdata;\n \n   if (ydata.reg_flag)\n-    return !refers_to_regno_for_reload_p (ydata.start, ydata.end, x, NULL_PTR);\n+    return !refers_to_regno_for_reload_p (ydata.start, ydata.end, x, (rtx*)0);\n   if (ydata.safe)\n     return 1;\n \n@@ -2605,7 +2605,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t;\n       else if (constraints[i][0] == 'p')\n \t{\n-\t  find_reloads_address (VOIDmode, NULL_PTR,\n+\t  find_reloads_address (VOIDmode, (rtx*)0,\n \t\t\t\trecog_data.operand[i],\n \t\t\t\trecog_data.operand_loc[i],\n \t\t\t\ti, operand_type[i], ind_levels, insn);\n@@ -3655,7 +3655,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  {\n \t    operand_reloadnum[i]\n \t      = push_reload (XEXP (recog_data.operand[i], 0), NULL_RTX,\n-\t\t\t     &XEXP (recog_data.operand[i], 0), NULL_PTR,\n+\t\t\t     &XEXP (recog_data.operand[i], 0), (rtx*)0,\n \t\t\t     BASE_REG_CLASS,\n \t\t\t     GET_MODE (XEXP (recog_data.operand[i], 0)),\n \t\t\t     VOIDmode, 0, 0, i, RELOAD_FOR_INPUT);\n@@ -4426,12 +4426,12 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n          calculate the register number as : \n \t SUBREG_BYTE (x) / GET_MODE_SIZE (subreg_mode) */\n       if (is_set_dest)\n-\tpush_reload (NULL_RTX, SUBREG_REG (x), NULL_PTR, &SUBREG_REG (x),\n+\tpush_reload (NULL_RTX, SUBREG_REG (x), (rtx*)0, &SUBREG_REG (x),\n \t\t     find_valid_class (subreg_mode, \n \t\t     \t\tSUBREG_BYTE (x) / GET_MODE_SIZE (subreg_mode)),\n \t\t     VOIDmode, subreg_mode, 0, 0, opnum, type);\n       else\n-\tpush_reload (SUBREG_REG (x), NULL_RTX, &SUBREG_REG (x), NULL_PTR,\n+\tpush_reload (SUBREG_REG (x), NULL_RTX, &SUBREG_REG (x), (rtx*)0,\n \t\t     find_valid_class (subreg_mode,\n \t\t     \t\tSUBREG_BYTE (x) / GET_MODE_SIZE (subreg_mode)),\n \t\t     subreg_mode, VOIDmode, 0, 0, opnum, type);\n@@ -4549,7 +4549,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t      tem = make_memloc (ad, regno);\n \t      if (! strict_memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\n \t\t{\n-\t\t  find_reloads_address (GET_MODE (tem), NULL_PTR, XEXP (tem, 0),\n+\t\t  find_reloads_address (GET_MODE (tem), (rtx*)0, XEXP (tem, 0),\n \t\t\t\t\t&XEXP (tem, 0), opnum, ADDR_TYPE (type),\n \t\t\t\t\tind_levels, insn);\n \t\t}\n@@ -4593,7 +4593,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \treturn 0;\n \n       /* If we do not have one of the cases above, we must do the reload.  */\n-      push_reload (ad, NULL_RTX, loc, NULL_PTR, BASE_REG_CLASS,\n+      push_reload (ad, NULL_RTX, loc, (rtx*)0, BASE_REG_CLASS,\n \t\t   GET_MODE (ad), VOIDmode, 0, 0, opnum, type);\n       return 1;\n     }\n@@ -4693,7 +4693,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t{\n \t  /* Must use TEM here, not AD, since it is the one that will\n \t     have any subexpressions reloaded, if needed.  */\n-\t  push_reload (tem, NULL_RTX, loc, NULL_PTR,\n+\t  push_reload (tem, NULL_RTX, loc, (rtx*)0,\n \t\t       BASE_REG_CLASS, GET_MODE (tem),\n \t\t       VOIDmode, 0,\n \t\t       0, opnum, type);\n@@ -5400,7 +5400,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t      else\n \t\t{\n \t\t  reloadnum\n-\t\t    = push_reload (x, NULL_RTX, loc, NULL_PTR,\n+\t\t    = push_reload (x, NULL_RTX, loc, (rtx*)0,\n \t\t\t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n \t\t\t\t   GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t\t   opnum, type);\n@@ -5440,7 +5440,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\tXEXP (XEXP (x, 0), 0), &XEXP (XEXP (x, 0), 0),\n \t\t\t\topnum, type, ind_levels, insn);\n \n-\t  reloadnum = push_reload (x, NULL_RTX, loc, NULL_PTR,\n+\t  reloadnum = push_reload (x, NULL_RTX, loc, (rtx*)0,\n \t\t\t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n \t\t\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t  rld[reloadnum].inc\n@@ -5469,7 +5469,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \n       find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n \t\t\t    opnum, ADDR_TYPE (type), ind_levels, insn);\n-      push_reload (*loc, NULL_RTX, loc, NULL_PTR,\n+      push_reload (*loc, NULL_RTX, loc, (rtx*)0,\n \t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n \t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n       return 1;\n@@ -5490,7 +5490,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t that feeds this insn.  */\n \tif (reg_equiv_mem[regno] != 0)\n \t  {\n-\t    push_reload (reg_equiv_mem[regno], NULL_RTX, loc, NULL_PTR,\n+\t    push_reload (reg_equiv_mem[regno], NULL_RTX, loc, (rtx*)0,\n \t\t\t (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n@@ -5518,7 +5518,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t     || !(context ? REGNO_OK_FOR_INDEX_P (regno)\n \t\t  : REGNO_MODE_OK_FOR_BASE_P (regno, mode))))\n \t  {\n-\t    push_reload (x, NULL_RTX, loc, NULL_PTR,\n+\t    push_reload (x, NULL_RTX, loc, (rtx*)0,\n \t\t\t (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n@@ -5530,7 +5530,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t   from before this insn to after it.  */\n \tif (regno_clobbered_p (regno, this_insn, GET_MODE (x), 0))\n \t  {\n-\t    push_reload (x, NULL_RTX, loc, NULL_PTR,\n+\t    push_reload (x, NULL_RTX, loc, (rtx*)0,\n \t\t\t (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n \t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t    return 1;\n@@ -5551,7 +5551,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t      if (! (context ? REGNO_OK_FOR_INDEX_P (regno)\n \t\t     : REGNO_MODE_OK_FOR_BASE_P (regno, mode)))\n \t\t{\n-\t\t  push_reload (x, NULL_RTX, loc, NULL_PTR,\n+\t\t  push_reload (x, NULL_RTX, loc, (rtx*)0,\n \t\t\t       (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n \t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t\t  return 1;\n@@ -5568,7 +5568,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t{\n \t\t  x = find_reloads_subreg_address (x, 0, opnum, type,\n \t\t\t\t\t\t   ind_levels, insn);\n-\t\t  push_reload (x, NULL_RTX, loc, NULL_PTR, class,\n+\t\t  push_reload (x, NULL_RTX, loc, (rtx*)0, class,\n \t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t\t  return 1;\n \t\t}\n@@ -5644,7 +5644,7 @@ find_reloads_address_part (x, loc, class, mode, opnum, type, ind_levels)\n \t\t\t    opnum, type, ind_levels, 0);\n     }\n \n-  push_reload (x, NULL_RTX, loc, NULL_PTR, class,\n+  push_reload (x, NULL_RTX, loc, (rtx*)0, class,\n \t       mode, VOIDmode, 0, 0, opnum, type);\n }\n \f\n@@ -5977,7 +5977,7 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n \t  if (reg_equiv_memory_loc[r])\n \t    return refers_to_regno_for_reload_p (regno, endregno,\n \t\t\t\t\t\t reg_equiv_memory_loc[r],\n-\t\t\t\t\t\t NULL_PTR);\n+\t\t\t\t\t\t (rtx*)0);\n \n \t  if (reg_equiv_constant[r])\n \t    return 0;\n@@ -6123,7 +6123,7 @@ reg_overlap_mentioned_for_reload_p (x, in)\n   endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n \t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n \n-  return refers_to_regno_for_reload_p (regno, endregno, in, NULL_PTR);\n+  return refers_to_regno_for_reload_p (regno, endregno, in, (rtx*)0);\n }\n \n /* Return nonzero if anything in X contains a MEM.  Look also for pseudo\n@@ -6378,7 +6378,7 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n       && refers_to_regno_for_reload_p (valueno,\n \t\t\t\t       (valueno\n \t\t\t\t\t+ HARD_REGNO_NREGS (valueno, mode)),\n-\t\t\t\t       goal, NULL_PTR))\n+\t\t\t\t       goal, (rtx*)0))\n     return 0;\n \n   /* Reject registers that overlap GOAL.  */"}, {"sha": "e3bd7bb1be84ce16097b7b1c1556897693778643", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -690,7 +690,7 @@ reload (first, global)\n \n   /* Make sure that the last insn in the chain\n      is not something that needs reloading.  */\n-  emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+  emit_note (NULL, NOTE_INSN_DELETED);\n \n   /* Enable find_equiv_reg to distinguish insns made by reload.  */\n   reload_first_uid = get_max_uid ();"}, {"sha": "07fb24ba9f0e87c1df31ef49e8b0915c0be4329e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -600,7 +600,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t}\n \n       x = CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n-      set_float_handler (NULL_PTR);\n+      set_float_handler (NULL);\n       return x;\n     }\n \n@@ -634,7 +634,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t  abort ();\n \t}\n \n-      set_float_handler (NULL_PTR);\n+      set_float_handler (NULL);\n \n       val = trunc_int_for_mode (val, mode);\n \n@@ -794,7 +794,7 @@ simplify_binary_operation (code, mode, op0, op1)\n #endif\n \n       value = real_value_truncate (mode, value);\n-      set_float_handler (NULL_PTR);\n+      set_float_handler (NULL);\n       return CONST_DOUBLE_FROM_REAL_VALUE (value, mode);\n     }\n #endif  /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n@@ -1220,7 +1220,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      REAL_VALUE_FROM_CONST_DOUBLE (d, op1);\n \t      op1is2 = REAL_VALUES_EQUAL (d, dconst2);\n \t      op1ism1 = REAL_VALUES_EQUAL (d, dconstm1);\n-\t      set_float_handler (NULL_PTR);\n+\t      set_float_handler (NULL);\n \n \t      /* x*2 is x+x and x*(-1) is -x */\n \t      if (op1is2 && GET_MODE (op0) == mode)"}, {"sha": "b529853e01a2077d53b0a0de70606cde840a7598", "filename": "gcc/stmt.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -1054,11 +1054,11 @@ expand_fixup (tree_label, rtl_label, last_insn)\n \t  }\n \n         start_sequence ();\n-        start = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n+        start = emit_note (NULL, NOTE_INSN_BLOCK_BEG);\n \tif (cfun->x_whole_function_mode_p)\n \t  NOTE_BLOCK (start) = block;\n-\tfixup->before_jump = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n-\tend = emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n+\tfixup->before_jump = emit_note (NULL, NOTE_INSN_DELETED);\n+\tend = emit_note (NULL, NOTE_INSN_BLOCK_END);\n \tif (cfun->x_whole_function_mode_p)\n \t  NOTE_BLOCK (end) = block;\n         fixup->context = block;\n@@ -2286,7 +2286,7 @@ expand_start_loop (exit_flag)\n \n   do_pending_stack_adjust ();\n   emit_queue ();\n-  emit_note (NULL_PTR, NOTE_INSN_LOOP_BEG);\n+  emit_note (NULL, NOTE_INSN_LOOP_BEG);\n   emit_label (thisloop->data.loop.start_label);\n \n   return thisloop;\n@@ -2337,7 +2337,7 @@ void\n expand_loop_continue_here ()\n {\n   do_pending_stack_adjust ();\n-  emit_note (NULL_PTR, NOTE_INSN_LOOP_CONT);\n+  emit_note (NULL, NOTE_INSN_LOOP_CONT);\n   emit_label (loop_stack->data.loop.continue_label);\n }\n \n@@ -2645,7 +2645,7 @@ expand_end_loop ()\n   if (needs_end_jump)\n     {\n       emit_jump (start_label);\n-      emit_note (NULL_PTR, NOTE_INSN_LOOP_END);\n+      emit_note (NULL, NOTE_INSN_LOOP_END);\n     }\n   emit_label (loop_stack->data.loop.end_label);\n \n@@ -3272,11 +3272,11 @@ expand_start_bindings_and_block (flags, block)\n   /* Create a note to mark the beginning of the block.  */\n   if (block_flag)\n     {\n-      note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n+      note = emit_note (NULL, NOTE_INSN_BLOCK_BEG);\n       NOTE_BLOCK (note) = block;\n     }\n   else\n-    note = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+    note = emit_note (NULL, NOTE_INSN_DELETED);\n \n   /* Make an entry on block_stack for the block we are entering.  */\n \n@@ -3297,7 +3297,7 @@ expand_start_bindings_and_block (flags, block)\n      fix this is to just insert another instruction here, so that the\n      instructions inserted after the last unconditional cleanup are\n      never the last instruction.  */\n-  emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+  emit_note (NULL, NOTE_INSN_DELETED);\n   thisblock->data.block.cleanup_ptr = &thisblock->data.block.cleanups;\n \n   if (block_stack\n@@ -3696,7 +3696,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \n   if (mark_ends)\n     {\n-      rtx note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n+      rtx note = emit_note (NULL, NOTE_INSN_BLOCK_END);\n       NOTE_BLOCK (note) = NOTE_BLOCK (thisblock->data.block.first_insn);\n     }\n   else\n@@ -4032,7 +4032,7 @@ expand_decl_cleanup (decl, cleanup)\n \t     fix this is to just insert another instruction here, so that the\n \t     instructions inserted after the last unconditional cleanup are\n \t     never the last instruction.  */\n-\t  emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+\t  emit_note (NULL, NOTE_INSN_DELETED);\n \t  thisblock->data.block.cleanup_ptr = &thisblock->data.block.cleanups;\n \t}\n     }\n@@ -4297,7 +4297,7 @@ expand_start_case (exit_flag, expr, type, printname)\n   /* Make sure case_stmt.start points to something that won't\n      need any transformation before expand_end_case.  */\n   if (GET_CODE (get_last_insn ()) != NOTE)\n-    emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+    emit_note (NULL, NOTE_INSN_DELETED);\n \n   thiscase->data.case_stmt.start = get_last_insn ();\n "}, {"sha": "690098792ca2403901004943e7faee77edc0c757", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6496a589dfe14041da10691b70be2e1825829c2b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=6496a589dfe14041da10691b70be2e1825829c2b", "patch": "@@ -1939,7 +1939,7 @@ assemble_real (d, mode)\n       abort ();\n     }\n \n-  set_float_handler (NULL_PTR);\n+  set_float_handler (NULL);\n }\n \f\n /* Here we combine duplicate floating constants to make\n@@ -4804,7 +4804,7 @@ assemble_alias (decl, target)\n \n   /* We must force creation of DECL_RTL for debug info generation, even though\n      we don't use it here.  */\n-  make_decl_rtl (decl, NULL_PTR);\n+  make_decl_rtl (decl, NULL);\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n "}]}