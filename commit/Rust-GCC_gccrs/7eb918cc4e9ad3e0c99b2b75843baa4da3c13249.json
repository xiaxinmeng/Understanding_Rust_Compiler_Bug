{"sha": "7eb918cc4e9ad3e0c99b2b75843baa4da3c13249", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ViOTE4Y2M0ZTlhZDNlMGM5OWIyYjc1ODQzYmFhNGRhM2MxMzI0OQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-04-30T11:42:00Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-04-30T11:42:00Z"}, "message": "Make expand_location resolve to locus in main source file\n\nApparently, quite some places in the compiler (like the C/C++\npreprocessor, the debug info machinery) expect expand_location to\nresolve to locations that are in the main source file, even if the\ntoken at stake comes from a macro that was defined in a header\nsomewhere.  Turning on -ftrack-macro-expansion by default was\ntriggering a lot of failures (not necessarily related to diagnostics)\nbecause expand_location resolves to spelling locations instead.\n\nSo I have changed expand_location to honour the initial expectation.\n\nIn addition, I came up with the new expand_location_to_spelling_point\nused in diagnostic_build_prefix because the diagnostic system, on the\nother hand, wants to point to the location of the token where it was\nspelled, and then display the error context involving all the macro\nwhose expansion led to that spelling point - if we are in the context\nof a macro expansion there.\n\nThis seems to me like a reasonable balance.\n\nTested and bootstrapped on x86_64-unknown-linux-gnu against trunk and\nwhitnessed that a lot more tests were PASSing.\n\nNote that the bootstrap with -ftrack-macro-expansion exhibits other\nseparate issues that are addressed in subsequent patches.  This patch\njust fixes one class of problems.\n\nThe patch does pass bootstrap with -ftrack-macro-expansion turned off,\nthough.\n\ngcc/\n\n\t* input.c (expand_location_1): New.  Takes a parameter to choose\n\twhether to resolve the location to spelling or expansion point.\n\tWas factorized from ...\n\t(expand_location): ... here.\n\t(expand_location_to_spelling_point): New.  Implemented in terms of\n\texpand_location_1.\n\t* diagnostic.c (diagnostic_build_prefix): Use the new\n\texpand_location_to_spelling_point instead of expand_location.\n\nFrom-SVN: r186969", "tree": {"sha": "738efb08fe80b3ccdec781fe89133fc0088d90e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/738efb08fe80b3ccdec781fe89133fc0088d90e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249/comments", "author": null, "committer": null, "parents": [{"sha": "3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3600218c8ba558bf5ac3a5f7697dbc8f512099e7"}], "stats": {"total": 55, "additions": 48, "deletions": 7}, "files": [{"sha": "a6e8cbb77783f0337ae37b836074a8aee093eee6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7eb918cc4e9ad3e0c99b2b75843baa4da3c13249", "patch": "@@ -1,5 +1,15 @@\n 2012-04-30  Dodji Seketeli  <dodji@redhat.com>\n \n+\tMake expand_location resolve to locus in main source file\n+\t* input.c (expand_location_1): New.  Takes a parameter to choose\n+\twhether to resolve the location to spelling or expansion point.\n+\tWas factorized from ...\n+\t(expand_location): ... here.\n+\t(expand_location_to_spelling_point): New.  Implemented in terms of\n+\texpand_location_1.\n+\t* diagnostic.c (diagnostic_build_prefix): Use the new\n+\texpand_location_to_spelling_point instead of expand_location.\n+\n \tFix PCH crash on GTYed pointer-to-scalar field of a struct\n \t* gengtype.c (write_types_process_field): Force second argument of\n \tthe call to the PCH object hierarchy walker to be 'x'."}, {"sha": "729e8654298e2f1833925f70e3663190ebbef5d4", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=7eb918cc4e9ad3e0c99b2b75843baa4da3c13249", "patch": "@@ -214,7 +214,7 @@ diagnostic_build_prefix (diagnostic_context *context,\n     \"must-not-happen\"\n   };\n   const char *text = _(diagnostic_kind_text[diagnostic->kind]);\n-  expanded_location s = expand_location (diagnostic->location);\n+  expanded_location s = expand_location_to_spelling_point (diagnostic->location);\n   if (diagnostic->override_column)\n     s.column = diagnostic->override_column;\n   gcc_assert (diagnostic->kind < DK_LAST_DIAGNOSTIC_KIND);\n@@ -266,7 +266,7 @@ diagnostic_show_locus (diagnostic_context * context,\n       || diagnostic->location <= BUILTINS_LOCATION)\n     return;\n \n-  s = expand_location(diagnostic->location);\n+  s = expand_location_to_spelling_point (diagnostic->location);\n   line = location_get_source_line (s);\n   if (line == NULL)\n     return;"}, {"sha": "e9ba301c22944d4d35d5187ffaedcfb6e3ee3864", "filename": "gcc/input.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=7eb918cc4e9ad3e0c99b2b75843baa4da3c13249", "patch": "@@ -32,16 +32,22 @@ struct line_maps *line_table;\n \n /* Expand the source location LOC into a human readable location.  If\n    LOC resolves to a builtin location, the file name of the readable\n-   location is set to the string \"<built-in>\".  */\n-\n-expanded_location\n-expand_location (source_location loc)\n+   location is set to the string \"<built-in>\". If EXPANSION_POINT_P is\n+   TRUE and LOC is virtual, then it is resolved to the expansion\n+   point of the involved macro.  Otherwise, it is resolved to the\n+   spelling location of the token.  */\n+\n+static expanded_location\n+expand_location_1 (source_location loc,\n+\t\t   bool expansion_point_p)\n {\n   expanded_location xloc;\n   const struct line_map *map;\n \n   loc = linemap_resolve_location (line_table, loc,\n-\t\t\t\t  LRK_SPELLING_LOCATION, &map);\n+\t\t\t\t  expansion_point_p\n+\t\t\t\t  ? LRK_MACRO_EXPANSION_POINT\n+\t\t\t\t  : LRK_SPELLING_LOCATION, &map);\n   xloc = linemap_expand_location (line_table, map, loc);\n \n   if (loc <= BUILTINS_LOCATION)\n@@ -109,6 +115,30 @@ location_get_source_line(expanded_location xloc)\n   return buffer;\n }\n \n+/* Expand the source location LOC into a human readable location.  If\n+   LOC is virtual, it resolves to the expansion point of the involved\n+   macro.  If LOC resolves to a builtin location, the file name of the\n+   readable location is set to the string \"<built-in>\".  */\n+\n+expanded_location\n+expand_location (source_location loc)\n+{\n+  return expand_location_1 (loc, /*expansion_point_p=*/true);\n+}\n+\n+/* Expand the source location LOC into a human readable location.  If\n+   LOC is virtual, it resolves to the expansion location of the\n+   relevant macro.  If LOC resolves to a builtin location, the file\n+   name of the readable location is set to the string\n+   \"<built-in>\".  */\n+\n+expanded_location\n+expand_location_to_spelling_point (source_location loc)\n+{\n+  return expand_location_1 (loc, /*expansion_piont_p=*/false);\n+}\n+\n+\n #define ONE_K 1024\n #define ONE_M (ONE_K * ONE_K)\n "}, {"sha": "ea19e0777979c23a305d16257607f466a6e1668a", "filename": "gcc/input.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=7eb918cc4e9ad3e0c99b2b75843baa4da3c13249", "patch": "@@ -39,6 +39,7 @@ extern char builtins_location_check[(BUILTINS_LOCATION\n \n extern expanded_location expand_location (source_location);\n extern const char * location_get_source_line(expanded_location xloc);\n+extern expanded_location expand_location_to_spelling_point (source_location);\n \n /* Historically GCC used location_t, while cpp used source_location.\n    This could be removed but it hardly seems worth the effort.  */"}]}