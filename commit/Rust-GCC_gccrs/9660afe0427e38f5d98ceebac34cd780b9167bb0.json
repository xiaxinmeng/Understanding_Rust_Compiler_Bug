{"sha": "9660afe0427e38f5d98ceebac34cd780b9167bb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY2MGFmZTA0MjdlMzhmNWQ5OGNlZWJhYzM0Y2Q3ODBiOTE2N2JiMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-10-23T18:08:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-10-23T18:08:18Z"}, "message": "semantics.c (outer_lambda_capture_p): New fn.\n\n\t* semantics.c (outer_lambda_capture_p): New fn.\n\t(thisify_lambda_field): Factor out...\n\t(add_default_capture): ...from here.\n\t(finish_id_expression): Use them.\n\nFrom-SVN: r153510", "tree": {"sha": "051c608ab728620701b9c69fbbb4409d799cf03c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/051c608ab728620701b9c69fbbb4409d799cf03c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9660afe0427e38f5d98ceebac34cd780b9167bb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9660afe0427e38f5d98ceebac34cd780b9167bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9660afe0427e38f5d98ceebac34cd780b9167bb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9660afe0427e38f5d98ceebac34cd780b9167bb0/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "78dd7466f8143975212a874e72a0ffc843c09a94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78dd7466f8143975212a874e72a0ffc843c09a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78dd7466f8143975212a874e72a0ffc843c09a94"}], "stats": {"total": 97, "additions": 81, "deletions": 16}, "files": [{"sha": "e0bf4f2e6dee47c2b6def4148ecfab2c0c75820a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9660afe0427e38f5d98ceebac34cd780b9167bb0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9660afe0427e38f5d98ceebac34cd780b9167bb0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9660afe0427e38f5d98ceebac34cd780b9167bb0", "patch": "@@ -1,5 +1,10 @@\n 2009-10-23  Jason Merrill  <jason@redhat.com>\n \n+\t* semantics.c (outer_lambda_capture_p): New fn.\n+\t(thisify_lambda_field): Factor out...\n+\t(add_default_capture): ...from here.\n+\t(finish_id_expression): Use them.\n+\n \tCore issue 899\n \t* call.c (add_function_candidate): Only permit explicit conversion\n \tops if copy ctor was called with a single argument."}, {"sha": "3e39f3765e1e861118fe0ebe12be51c22bf83bff", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9660afe0427e38f5d98ceebac34cd780b9167bb0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9660afe0427e38f5d98ceebac34cd780b9167bb0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9660afe0427e38f5d98ceebac34cd780b9167bb0", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n static tree maybe_convert_cond (tree);\n static tree finalize_nrv_r (tree *, int *, void *);\n static tree capture_decltype (tree);\n+static tree thisify_lambda_field (tree);\n \n \n /* Deferred Access Checking Overview\n@@ -1447,14 +1448,13 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n       return error_mark_node;\n     }\n \n-  /* If decl is a field, object has a lambda type, and decl is not a member\n-     of that type, then we have a reference to a member of 'this' from a\n+  /* If decl is a non-capture field and object has a lambda type,\n+     then we have a reference to a member of 'this' from a\n      lambda inside a non-static member function, and we must get to decl\n      through the 'this' capture.  If decl is not a member of that object,\n      either, then its access will still fail later.  */\n   if (LAMBDA_TYPE_P (TREE_TYPE (object))\n-      && !same_type_ignoring_top_level_qualifiers_p (DECL_CONTEXT (decl),\n-                                                     TREE_TYPE (object)))\n+      && !LAMBDA_TYPE_P (DECL_CONTEXT (decl)))\n     object = cp_build_indirect_ref (lambda_expr_this_capture\n \t\t\t\t    (CLASSTYPE_LAMBDA_EXPR\n \t\t\t\t     (TREE_TYPE (object))),\n@@ -2648,6 +2648,18 @@ outer_automatic_var_p (tree decl)\n \t  && DECL_CONTEXT (decl) != current_function_decl);\n }\n \n+/* Returns true iff DECL is a capture field from a lambda that is not our\n+   immediate context.  */\n+\n+static bool\n+outer_lambda_capture_p (tree decl)\n+{\n+  return (TREE_CODE (decl) == FIELD_DECL\n+\t  && LAMBDA_TYPE_P (DECL_CONTEXT (decl))\n+\t  && (!current_class_type\n+\t      || !DERIVED_FROM_P (DECL_CONTEXT (decl), current_class_type)));\n+}\n+\n /* ID_EXPRESSION is a representation of parsed, but unprocessed,\n    id-expression.  (See cp_parser_id_expression for details.)  SCOPE,\n    if non-NULL, is the type or namespace used to explicitly qualify\n@@ -2751,14 +2763,16 @@ finish_id_expression (tree id_expression,\n \n       /* Disallow uses of local variables from containing functions, except\n \t within lambda-expressions.  */\n-      if (outer_automatic_var_p (decl)\n+      if ((outer_automatic_var_p (decl)\n+\t   || outer_lambda_capture_p (decl))\n \t  /* It's not a use (3.2) if we're in an unevaluated context.  */\n \t  && !cp_unevaluated_operand)\n \t{\n \t  tree context = DECL_CONTEXT (decl);\n \t  tree containing_function = current_function_decl;\n \t  tree lambda_stack = NULL_TREE;\n \t  tree lambda_expr = NULL_TREE;\n+\t  tree initializer = decl;\n \n \t  /* Core issue 696: \"[At the July 2009 meeting] the CWG expressed\n \t     support for an approach in which a reference to a local\n@@ -2770,6 +2784,13 @@ finish_id_expression (tree id_expression,\n \t  if (DECL_INTEGRAL_CONSTANT_VAR_P (decl))\n \t    return integral_constant_value (decl);\n \n+\t  if (TYPE_P (context))\n+\t    {\n+\t      /* Implicit capture of an explicit capture.  */\n+\t      context = lambda_function (context);\n+\t      initializer = thisify_lambda_field (decl);\n+\t    }\n+\n \t  /* If we are in a lambda function, we can move out until we hit\n \t     1. the context,\n \t     2. a non-lambda function, or\n@@ -2796,7 +2817,7 @@ finish_id_expression (tree id_expression,\n \t    {\n \t      decl = add_default_capture (lambda_stack,\n \t\t\t\t\t  /*id=*/DECL_NAME (decl),\n-\t\t\t\t\t  /*initializer=*/decl);\n+\t\t\t\t\t  initializer);\n \t    }\n \t  else if (lambda_expr)\n \t    {\n@@ -5604,6 +5625,21 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n   return member;\n }\n \n+/* Given a FIELD_DECL decl belonging to a closure type, return a\n+   COMPONENT_REF of it relative to the 'this' parameter of the op() for\n+   that type.  */\n+\n+static tree\n+thisify_lambda_field (tree decl)\n+{\n+  tree context = lambda_function (DECL_CONTEXT (decl));\n+  tree object = cp_build_indirect_ref (DECL_ARGUMENTS (context),\n+\t\t\t\t       /*errorstring*/\"\",\n+\t\t\t\t       tf_warning_or_error);\n+  return finish_non_static_data_member (decl, object,\n+\t\t\t\t\t/*qualifying_scope*/NULL_TREE);\n+}\n+\n /* Similar to add_capture, except this works on a stack of nested lambdas.\n    BY_REFERENCE_P in this case is derived from the default capture mode.\n    Returns the capture for the lambda at the bottom of the stack.  */\n@@ -5634,16 +5670,7 @@ add_default_capture (tree lambda_stack, tree id, tree initializer)\n \t\t\t     && (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda)\n \t\t\t\t == CPLD_REFERENCE)),\n \t\t\t    /*explicit_init_p=*/false);\n-\n-      {\n-        /* Have to get the old value of current_class_ref.  */\n-        tree object = cp_build_indirect_ref (DECL_ARGUMENTS\n-                                               (lambda_function (lambda)),\n-                                             /*errorstring=*/\"\",\n-                                             /*complain=*/tf_warning_or_error);\n-        initializer = finish_non_static_data_member\n-                        (member, object, /*qualifying_scope=*/NULL_TREE);\n-      }\n+      initializer = thisify_lambda_field (member);\n     }\n \n   current_class_type = saved_class_type;"}, {"sha": "4d6eb811876f0cef692bf33841323d2b03cb46de", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9660afe0427e38f5d98ceebac34cd780b9167bb0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9660afe0427e38f5d98ceebac34cd780b9167bb0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9660afe0427e38f5d98ceebac34cd780b9167bb0", "patch": "@@ -1,5 +1,7 @@\n 2009-10-23  Jason Merrill  <jason@redhat.com>\n \n+\t* g++.dg/cpp0x/lambda/lambda-nested2.C: New.\n+\n \tCore issue 899\n \t* g++.dg/cpp0x/explicit4.C: New.\n "}, {"sha": "b7887485595ad7f152a27f1676c183916dce73da", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nested2.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9660afe0427e38f5d98ceebac34cd780b9167bb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9660afe0427e38f5d98ceebac34cd780b9167bb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested2.C?ref=9660afe0427e38f5d98ceebac34cd780b9167bb0", "patch": "@@ -0,0 +1,31 @@\n+// Testcase from N2998\n+// { dg-options -std=c++0x }\n+\n+void f1(int i) {\n+  int const N = 20;\n+  auto m1 = [=]{\n+     int const M = 30;\n+     auto m2 = [i]{\n+        int x[N][M]; // OK: N and M are not \"used\"\n+        x[0][0] = i; // OK: i is explicitly captured by m2\n+                     // and implicitly captured by m1\n+     };\n+  };\n+  struct s1 {\n+    int f;\n+    int work(int n) {\n+      int m = n*n;\n+      int j = 40;\n+      auto m3 = [this,m]{\n+        /*auto m4=*/[&,j]{      // { dg-error \"j. is not captured\" }\n+          int x = n;\t        // { dg-error \"n. is not captured\" }\n+          x += m;\t        // OK: m implicitly captured by m4\n+\t\t\t\t// and explicitly captured by m3\n+          x += i;\t\t// { dg-error \"i. is not captured\" }\n+          x += f;\t\t// OK: this captured implicitly by m4\n+\t\t\t\t// and explicitly by m3\n+        };\n+      };\n+    }\n+  };\n+}"}]}