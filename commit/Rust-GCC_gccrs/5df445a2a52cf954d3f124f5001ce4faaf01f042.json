{"sha": "5df445a2a52cf954d3f124f5001ce4faaf01f042", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRmNDQ1YTJhNTJjZjk1NGQzZjEyNGY1MDAxY2U0ZmFhZjAxZjA0Mg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2015-12-02T21:59:05Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2015-12-02T21:59:05Z"}, "message": "check.c (gfc_check_event_query): New function.\n\n2015-12-02  Tobias Burnus  <burnus@net-b.de>\n\t    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n\n\t* check.c (gfc_check_event_query): New function.\n\t* dump-parse-tree.c (show_code_node): Handle EXEC_EVENT_POST,\n\tEXEC_EVENT_WAIT.\n\t* expr.c (gfc_check_vardef_context): New check for event variables\n\tdefinition.\n\t* gfortran.h (gfc_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.\n\t(gfc_isym_id): GFC_ISYM_EVENT_QUERY.\n\t(struct symbol_attribute): New field.\n\t(gfc_exec_op): Add EXEC_EVENT_POST and EXEC_EVENT_WAIT.\n\t* gfortran.texi: Document about new events functions and minor\n\tchanges.\n\t* interface.c (compare_parameter): New check.\n\t(gfc_procedure_use): New check for explicit procedure interface.\n\t(add_subroutines): Add event_query.\n\t* intrinsic.h (gfc_check_event_query,gfc_resolve_event_query):\n\tNew prototypes.\n\t* iresolve.c (gfc_resolve_event_query): New function.\n\t* iso-fortran-env.def (event_type): New type.\n\t* match.c (event_statement,gfc_match_event_post,gfc_match_event_wait):\n\tNew functions.\n\t(gfc_match_name): New event post and event wait.\n\t* match.h (gfc_match_event_post,gfc_match_event_wait):\n\tNew prototypes.\n\t* module.c (ab_attribute): Add AB_EVENT_COMP.\n\t(attr_bits): Likewise.\n\t(mio_symbol_attribute): Handle event_comp attribute.\n\t* parse.c (decode_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.\n\t(next_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.\n\t(gfc_ascii_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.\n\t(parse_derived): Check for event_type components.\n\t* resolve.c (resolve_allocate_expr): Check for event variable def.\n\t(resolve_lock_unlock): Renamed to resolve_lock_unlock_event. It\n\tincludes logic for locks and events.\n\t(gfc_resolve_code): Call it.\n\t(gfc_resolve_symbol): New check for event variable to be a corray.\n\t* st.c (gfc_free_statement): Handle new EXEC_EVENT_POST and\n\tEXEC_EVENT_WAIT.\n\t* trans-decl.c (gfor_fndecl_caf_event_post,gfor_fndecl_caf_event_wait,\n\tgfor_fndecl_caf_event_query): New global variables.\n\t(generate_coarray_sym_init): Checking for event_type.\n\t(gfc_conv_procedure_call): Check for C bind attribute.\n\t* trans-intrinsic.c (conv_intrinsic_event_query): New function.\n\t(conv_intrinsic_move_alloc): Call it.\n\t* trans-stmt.c (gfc_trans_lock_unlock): Passing address\n\tof actual argument.\n\t(gfc_trans_sync): Likewise.\n\t(gfc_trans_event_post_wait): New function.\n\t* trans-stmt.h (gfc_trans_event_post_wait): New prototype.\n\t* trans-types.c (gfc_get_derived_type): Integer_kind as event_type.\n\t* trans.c (gfc_allocate_using_lib): New argument and logic for events.\n\t(gfc_allocate_allocatable): Passing new argument.\n\t(trans_code): Handle EXEC_EVENT_POST, EXEC_EVENT_WAIT.\n\t* trans.h (gfc_coarray_type): New elements.\n\t(gfor_fndecl_caf_event_post,gfor_fndecl_caf_event_wait,\n\tgfor_fndecl_caf_event_query): Declare them.\n\n2015-12-02  Tobias Burnus  <burnus@net-b.de>\n\t    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n\n\t* gfortran.dg/coarray/event_1.f90: New.\n\t* gfortran.dg/coarray/event_2.f90: New.\n\nCo-Authored-By: Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n\nFrom-SVN: r231208", "tree": {"sha": "8b8c4c4de354d0e49cd44c9ed198749aa58db30e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b8c4c4de354d0e49cd44c9ed198749aa58db30e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5df445a2a52cf954d3f124f5001ce4faaf01f042", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5df445a2a52cf954d3f124f5001ce4faaf01f042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5df445a2a52cf954d3f124f5001ce4faaf01f042", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5df445a2a52cf954d3f124f5001ce4faaf01f042/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca377fc3710c76c35cec79ee96af999e060564b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca377fc3710c76c35cec79ee96af999e060564b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca377fc3710c76c35cec79ee96af999e060564b9"}], "stats": {"total": 1305, "additions": 1264, "deletions": 41}, "files": [{"sha": "7617a1adf7cb471de0fcff0b82324c2bcbcada49", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -1,3 +1,62 @@\n+2015-12-02  Tobias Burnus  <burnus@net-b.de>\n+\t    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n+\n+\t* check.c (gfc_check_event_query): New function.\n+\t* dump-parse-tree.c (show_code_node): Handle EXEC_EVENT_POST,\n+\tEXEC_EVENT_WAIT.\n+\t* expr.c (gfc_check_vardef_context): New check for event variables\n+\tdefinition.\n+\t* gfortran.h (gfc_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.\n+\t(gfc_isym_id): GFC_ISYM_EVENT_QUERY.\n+\t(struct symbol_attribute): New field.\n+\t(gfc_exec_op): Add EXEC_EVENT_POST and EXEC_EVENT_WAIT.\n+\t* gfortran.texi: Document about new events functions and minor\n+\tchanges.\n+\t* interface.c (compare_parameter): New check.\n+\t(gfc_procedure_use): New check for explicit procedure interface.\n+\t(add_subroutines): Add event_query.\n+\t* intrinsic.h (gfc_check_event_query,gfc_resolve_event_query):\n+\tNew prototypes.\n+\t* iresolve.c (gfc_resolve_event_query): New function.\n+\t* iso-fortran-env.def (event_type): New type.\n+\t* match.c (event_statement,gfc_match_event_post,gfc_match_event_wait):\n+\tNew functions.\n+\t(gfc_match_name): New event post and event wait.\n+\t* match.h (gfc_match_event_post,gfc_match_event_wait):\n+\tNew prototypes.\n+\t* module.c (ab_attribute): Add AB_EVENT_COMP.\n+\t(attr_bits): Likewise.\n+\t(mio_symbol_attribute): Handle event_comp attribute.\n+\t* parse.c (decode_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.\n+\t(next_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.\n+\t(gfc_ascii_statement): Add ST_EVENT_POST, ST_EVENT_WAIT.\n+\t(parse_derived): Check for event_type components.\n+\t* resolve.c (resolve_allocate_expr): Check for event variable def.\n+\t(resolve_lock_unlock): Renamed to resolve_lock_unlock_event. It\n+\tincludes logic for locks and events.\n+\t(gfc_resolve_code): Call it.\n+\t(gfc_resolve_symbol): New check for event variable to be a corray.\n+\t* st.c (gfc_free_statement): Handle new EXEC_EVENT_POST and\n+\tEXEC_EVENT_WAIT.\n+\t* trans-decl.c (gfor_fndecl_caf_event_post,gfor_fndecl_caf_event_wait,\n+\tgfor_fndecl_caf_event_query): New global variables.\n+\t(generate_coarray_sym_init): Checking for event_type.\n+\t(gfc_conv_procedure_call): Check for C bind attribute.\n+\t* trans-intrinsic.c (conv_intrinsic_event_query): New function.\n+\t(conv_intrinsic_move_alloc): Call it.\n+\t* trans-stmt.c (gfc_trans_lock_unlock): Passing address\n+\tof actual argument.\n+\t(gfc_trans_sync): Likewise.\n+\t(gfc_trans_event_post_wait): New function.\n+\t* trans-stmt.h (gfc_trans_event_post_wait): New prototype.\n+\t* trans-types.c (gfc_get_derived_type): Integer_kind as event_type.\n+\t* trans.c (gfc_allocate_using_lib): New argument and logic for events.\n+\t(gfc_allocate_allocatable): Passing new argument.\n+\t(trans_code): Handle EXEC_EVENT_POST, EXEC_EVENT_WAIT.\n+\t* trans.h (gfc_coarray_type): New elements.\n+\t(gfor_fndecl_caf_event_post,gfor_fndecl_caf_event_wait,\n+\tgfor_fndecl_caf_event_query): Declare them.\n+\n 2015-12-02  Cesar Philippidis  <cesar@codesourcery.com>\n \n \tPR fortran/63861"}, {"sha": "6dc7f3e264b86bb1eeebea25332e6b38b5916c42", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -1157,6 +1157,59 @@ gfc_check_atomic_cas (gfc_expr *atom, gfc_expr *old, gfc_expr *compare,\n   return true;\n }\n \n+bool\n+gfc_check_event_query (gfc_expr *event, gfc_expr *count, gfc_expr *stat)\n+{\n+  if (event->ts.type != BT_DERIVED\n+      || event->ts.u.derived->from_intmod != INTMOD_ISO_FORTRAN_ENV\n+      || event->ts.u.derived->intmod_sym_id != ISOFORTRAN_EVENT_TYPE)\n+    {\n+      gfc_error (\"EVENT argument at %L to the intrinsic EVENT_QUERY \"\n+\t\t \"shall be of type EVENT_TYPE\", &event->where);\n+      return false;\n+    }\n+\n+  if (!scalar_check (event, 0))\n+    return false;\n+\n+  if (!gfc_check_vardef_context (count, false, false, false, NULL))\n+    {\n+      gfc_error (\"COUNT argument of the EVENT_QUERY intrinsic function at %L \"\n+\t\t \"shall be definable\", &count->where);\n+      return false;\n+    }\n+\n+  if (!type_check (count, 1, BT_INTEGER))\n+    return false;\n+\n+  int i = gfc_validate_kind (BT_INTEGER, count->ts.kind, false);\n+  int j = gfc_validate_kind (BT_INTEGER, gfc_default_integer_kind, false);\n+\n+  if (gfc_integer_kinds[i].range < gfc_integer_kinds[j].range)\n+    {\n+      gfc_error (\"COUNT argument of the EVENT_QUERY intrinsic function at %L \"\n+\t\t \"shall have at least the range of the default integer\",\n+\t\t &count->where);\n+      return false;\n+    }\n+\n+  if (stat != NULL)\n+    {\n+      if (!type_check (stat, 2, BT_INTEGER))\n+\treturn false;\n+      if (!scalar_check (stat, 2))\n+\treturn false;\n+      if (!variable_check (stat, 2, false))\n+\treturn false;\n+\n+      if (!gfc_notify_std (GFC_STD_F2008_TS, \"STAT= argument to %s at %L\",\n+\t\t\t   gfc_current_intrinsic, &stat->where))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n \n bool\n gfc_check_atomic_fetch_op (gfc_expr *atom, gfc_expr *value, gfc_expr *old,"}, {"sha": "dad5c18439af79807d7e8e42b2aa8cd6deee8a12", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -1673,6 +1673,33 @@ show_code_node (int level, gfc_code *c)\n \t}\n       break;\n \n+    case EXEC_EVENT_POST:\n+    case EXEC_EVENT_WAIT:\n+      if (c->op == EXEC_EVENT_POST)\n+\tfputs (\"EVENT POST \", dumpfile);\n+      else\n+\tfputs (\"EVENT WAIT \", dumpfile);\n+\n+      fputs (\"event-variable=\", dumpfile);\n+      if (c->expr1 != NULL)\n+\tshow_expr (c->expr1);\n+      if (c->expr4 != NULL)\n+\t{\n+\t  fputs (\" until_count=\", dumpfile);\n+\t  show_expr (c->expr4);\n+\t}\n+      if (c->expr2 != NULL)\n+\t{\n+\t  fputs (\" stat=\", dumpfile);\n+\t  show_expr (c->expr2);\n+\t}\n+      if (c->expr3 != NULL)\n+\t{\n+\t  fputs (\" errmsg=\", dumpfile);\n+\t  show_expr (c->expr3);\n+\t}\n+      break;\n+\n     case EXEC_LOCK:\n     case EXEC_UNLOCK:\n       if (c->op == EXEC_LOCK)"}, {"sha": "2aeb0b5f94604111817e9016b42d0d6b071c2696", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -4860,6 +4860,19 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       return false;\n     }\n \n+  /* TS18508, C702/C203.  */\n+  if (!alloc_obj\n+      && (attr.lock_comp\n+\t  || (e->ts.type == BT_DERIVED\n+\t      && e->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t      && e->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)))\n+    {\n+      if (context)\n+\tgfc_error (\"LOCK_EVENT in variable definition context (%s) at %L\",\n+\t\t   context, &e->where);\n+      return false;\n+    }\n+\n   /* INTENT(IN) dummy argument.  Check this, unless the object itself is the\n      component of sub-component of a pointer; we need to distinguish\n      assignment to a pointer component from pointer-assignment to a pointer"}, {"sha": "9f61e4522c4d3c53187595ffa24f548ed060f109", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -241,7 +241,8 @@ enum gfc_statement\n   ST_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n   ST_OMP_END_TARGET_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD,\n   ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,\n-  ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_NONE\n+  ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_EVENT_POST,\n+  ST_EVENT_WAIT,ST_NONE\n };\n \n /* Types of interfaces that we can have.  Assignment interfaces are\n@@ -393,6 +394,7 @@ enum gfc_isym_id\n   GFC_ISYM_ERFC,\n   GFC_ISYM_ERFC_SCALED,\n   GFC_ISYM_ETIME,\n+  GFC_ISYM_EVENT_QUERY,\n   GFC_ISYM_EXECUTE_COMMAND_LINE,\n   GFC_ISYM_EXIT,\n   GFC_ISYM_EXP,\n@@ -828,7 +830,7 @@ typedef struct\n      entities.  */\n   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,\n \t   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1,\n-\t   defined_assign_comp:1, unlimited_polymorphic:1;\n+\t   event_comp:1, defined_assign_comp:1, unlimited_polymorphic:1;\n \n   /* This is a temporary selector for SELECT TYPE or an associate\n      variable for SELECT_TYPE or ASSOCIATE.  */\n@@ -2366,7 +2368,7 @@ enum gfc_exec_op\n   EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n   EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,\n-  EXEC_LOCK, EXEC_UNLOCK,\n+  EXEC_LOCK, EXEC_UNLOCK, EXEC_EVENT_POST, EXEC_EVENT_WAIT,\n   EXEC_OACC_KERNELS_LOOP, EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_ROUTINE,\n   EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS, EXEC_OACC_DATA, EXEC_OACC_HOST_DATA,\n   EXEC_OACC_LOOP, EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,"}, {"sha": "d82ded61dcf5bbfad42f3ee5bc614f7e529af97d", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 126, "deletions": 12, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -3342,7 +3342,9 @@ typedef enum caf_register_t {\n   CAF_REGTYPE_COARRAY_ALLOC,\n   CAF_REGTYPE_LOCK_STATIC,\n   CAF_REGTYPE_LOCK_ALLOC,\n-  CAF_REGTYPE_CRITICAL\n+  CAF_REGTYPE_CRITICAL,\n+  CAF_REGTYPE_EVENT_STATIC,\n+  CAF_REGTYPE_EVENT_ALLOC\n }\n caf_register_t;\n @end verbatim\n@@ -3363,6 +3365,9 @@ caf_register_t;\n * _gfortran_caf_sendget:: Sending data between remote images\n * _gfortran_caf_lock:: Locking a lock variable\n * _gfortran_caf_unlock:: Unlocking a lock variable\n+* _gfortran_caf_event_post:: Post an event\n+* _gfortran_caf_event_wait:: Wait that an event occurred\n+* _gfortran_caf_event_query:: Query event count\n * _gfortran_caf_sync_all:: All-image barrier\n * _gfortran_caf_sync_images:: Barrier for selected images\n * _gfortran_caf_sync_memory:: Wait for completion of segment-memory operations\n@@ -3516,7 +3521,7 @@ int *stat, char *errmsg, int errmsg_len)}\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{size} @tab For normal coarrays, the byte size of the coarray to be\n-allocated; for lock types, the number of elements.\n+allocated; for lock types and event types, the number of elements.\n @item @var{type} @tab one of the caf_register_t types.\n @item @var{token} @tab intent(out) An opaque pointer identifying the coarray.\n @item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;\n@@ -3541,7 +3546,10 @@ image. For lock types, the value shall only used for checking the allocation\n status. Note that for critical blocks, the locking is only required on one\n image; in the locking statement, the processor shall always pass always an\n image index of one for critical-block lock variables\n-(@code{CAF_REGTYPE_CRITICAL}).\n+(@code{CAF_REGTYPE_CRITICAL}). For lock types and critical-block variables,\n+the initial value shall be unlocked (or, respecitively, not in critical\n+section) such as the value false; for event types, the initial state should\n+be no event, e.g. zero.\n @end table\n \n \n@@ -3561,8 +3569,7 @@ int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;\n-may be NULL\n+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set\n to an error message; may be NULL\n @item @var{errmsg_len} @tab the buffer size of errmsg.\n@@ -3769,8 +3776,7 @@ always 0.\n number.\n @item @var{aquired_lock} @tab intent(out) If not NULL, it returns whether lock\n could be obtained\n-@item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;\n-may be NULL\n+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n an error message; may be NULL\n @item @var{errmsg_len} @tab the buffer size of errmsg.\n@@ -3782,7 +3788,6 @@ is always zero and the image index is one.  Libraries are permitted to use other\n images for critical-block locking variables.\n @end table\n \n-\n @node _gfortran_caf_unlock\n @subsection @code{_gfortran_caf_lock} --- Unlocking a lock variable\n @cindex Coarray, _gfortran_caf_unlock\n@@ -3817,6 +3822,115 @@ is always zero and the image index is one.  Libraries are permitted to use other\n images for critical-block locking variables.\n @end table\n \n+@node _gfortran_caf_event_post\n+@subsection @code{_gfortran_caf_event_post} --- Post an event\n+@cindex Coarray, _gfortran_caf_event_post\n+\n+@table @asis\n+@item @emph{Description}:\n+Increment the event count of the specified event variable.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_event_post (caf_token_t token, size_t index,\n+int image_index, int *stat, char *errmsg, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n+@item @var{index} @tab Array index; first array index is 0. For scalars, it is\n+always 0.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number; zero indicates the current image when accessed noncoindexed.\n+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTES}\n+This acts like an atomic add of one to the remote image's event variable.\n+The statement is an image-control statement but does not imply sync memory.\n+Still, all preceeding push communications of this image to the specified\n+remote image has to be completed before @code{event_wait} on the remote\n+image returns.\n+@end table\n+\n+\n+\n+@node _gfortran_caf_event_wait\n+@subsection @code{_gfortran_caf_event_wait} --- Wait that an event occurred\n+@cindex Coarray, _gfortran_caf_event_wait\n+\n+@table @asis\n+@item @emph{Description}:\n+Wait until the event count has reached at least the specified\n+@var{until_count}; if so, atomically decrement the event variable by this\n+amount and return.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_event_wait (caf_token_t token, size_t index,\n+int until_count, int *stat, char *errmsg, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n+@item @var{index} @tab Array index; first array index is 0. For scalars, it is\n+always 0.\n+@item @var{until_count} @tab The number of events which have to be available\n+before the function returns.\n+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTES}\n+This function only operates on a local coarray. It acts like a loop checking\n+atomically the value of the event variable, breaking if the value is greater\n+or equal the requested number of counts. Before the function returns, the\n+event variable has to be decremented by the requested @var{until_count} value.\n+A possible implementation would be a busy loop for a certain number of spins\n+(possibly depending on the number of threads relative to the number of available\n+cores) followed by other waiting strategy such as a sleeping wait (possibly with\n+an increasing number of sleep time) or, if possible, a futex wait.\n+\n+The statement is an image-control statement but does not imply sync memory.\n+Still, all preceeding push communications to this image of images having\n+issued a @code{event_push} have to be completed before this function returns.\n+@end table\n+\n+\n+\n+@node _gfortran_caf_event_query\n+@subsection @code{_gfortran_caf_event_query} --- Query event count\n+@cindex Coarray, _gfortran_caf_event_query\n+\n+@table @asis\n+@item @emph{Description}:\n+Return the event count of the specified event count.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_event_query (caf_token_t token, size_t index,\n+int image_index, int *count, int *stat)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n+@item @var{index} @tab Array index; first array index is 0. For scalars, it is\n+always 0.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number; zero indicates the current image when accessed noncoindexed.\n+@item @var{count} @tab intent(out) The number of events currently posted to\n+the event variable\n+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n+@end multitable\n+\n+@item @emph{NOTES}\n+The typical use is to check the local even variable to only call\n+@code{event_wait} when the data is available. However, a coindexed variable\n+is permitted; there is no ordering or synchronization implied.  It acts like\n+an atomic fetch of the value of the event variable.\n+@end table\n \n @node _gfortran_caf_sync_all\n @subsection @code{_gfortran_caf_sync_all} --- All-image barrier\n@@ -3962,7 +4076,7 @@ int image_index, void *value, int *stat, int type, int kind)}\n @item @var{offset} @tab By which amount of bytes the actual data is shifted\n compared to the base address of the coarray.\n @item @var{image_index} @tab The ID of the remote image; must be a positive\n-number.\n+number; zero indicates the current image when used noncoindexed.\n @item @var{value} @tab intent(in) the value to be assigned, passed by reference.\n @item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n @item @var{type} @tab the data type, i.e. @code{BT_INTEGER} (1) or\n@@ -3992,7 +4106,7 @@ int image_index, void *value, int *stat, int type, int kind)}\n @item @var{offset} @tab By which amount of bytes the actual data is shifted\n compared to the base address of the coarray.\n @item @var{image_index} @tab The ID of the remote image; must be a positive\n-number.\n+number; zero indicates the current image when used noncoindexed.\n @item @var{value} @tab intent(out) The variable assigned the atomically\n referenced variable.\n @item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n@@ -4025,7 +4139,7 @@ int type, int kind)}\n @item @var{offset} @tab By which amount of bytes the actual data is shifted\n compared to the base address of the coarray.\n @item @var{image_index} @tab The ID of the remote image; must be a positive\n-number.\n+number; zero indicates the current image when used noncoindexed.\n @item @var{old} @tab intent(out) the value which the atomic variable had\n just before the cas operation.\n @item @var{compare} @tab intent(in) The value used for comparision.\n@@ -4067,7 +4181,7 @@ int image_index, void *value, void *old, int *stat, int type, int kind)}\n @item @var{offset} @tab By which amount of bytes the actual data is shifted\n compared to the base address of the coarray.\n @item @var{image_index} @tab The ID of the remote image; must be a positive\n-number.\n+number; zero indicates the current image when used noncoindexed.\n @item @var{old} @tab intent(out) the value which the atomic variable had\n just before the atomic operation.\n @item @var{val} @tab intent(in) The new value for the atomic variable,"}, {"sha": "f74239d48449c71fed5264e6489ebb56832331cd", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -2157,6 +2157,21 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t       formal->name, &actual->where);\n \t  return 0;\n \t}\n+\n+      /* TS18508, C702/C703.  */\n+      if (formal->attr.intent != INTENT_INOUT\n+\t  && (((formal->ts.type == BT_DERIVED || formal->ts.type == BT_CLASS)\n+\t       && formal->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t       && formal->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n+\t      || formal->attr.event_comp))\n+\n+    \t{\n+\t  if (where)\n+\t    gfc_error (\"Actual argument to non-INTENT(INOUT) dummy %qs at %L, \"\n+\t\t       \"which is EVENT_TYPE or has a EVENT_TYPE component\",\n+\t\t       formal->name, &actual->where);\n+\t  return 0;\n+\t}\n     }\n \n   /* F2008, C1239/C1240.  */\n@@ -3385,6 +3400,19 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \t      break;\n \t    }\n \n+\t  if (a->expr\n+\t      && (a->expr->ts.type == BT_DERIVED || a->expr->ts.type == BT_CLASS)\n+\t      && ((a->expr->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t\t   && a->expr->ts.u.derived->intmod_sym_id\n+\t\t      == ISOFORTRAN_EVENT_TYPE)\n+\t\t  || gfc_expr_attr (a->expr).event_comp))\n+\t    {\n+\t      gfc_error (\"Actual argument of EVENT_TYPE or with EVENT_TYPE \"\n+\t\t\t \"component at %L requires an explicit interface for \"\n+\t\t\t \"procedure %qs\", &a->expr->where, sym->name);\n+\t      break;\n+\t    }\n+\n \t  if (a->expr && a->expr->expr_type == EXPR_NULL\n \t      && a->expr->ts.type == BT_UNKNOWN)\n \t    {"}, {"sha": "170006adc3322d8f9daa5534ba187a34c25b2a22", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -3164,6 +3164,13 @@ add_subroutines (void)\n \t      GFC_STD_F95, gfc_check_cpu_time, NULL, gfc_resolve_cpu_time,\n \t      tm, BT_REAL, dr, REQUIRED, INTENT_OUT);\n \n+  add_sym_3s (\"event_query\", GFC_ISYM_EVENT_QUERY, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n+\t      gfc_check_event_query, NULL, gfc_resolve_event_query,\n+\t      \"event\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      c, BT_INTEGER, di, OPTIONAL, INTENT_IN,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n+\n   /* More G77 compatibility garbage.  */\n   add_sym_2s (\"ctime\", GFC_ISYM_CTIME, CLASS_IMPURE, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      gfc_check_ctime_sub, NULL, gfc_resolve_ctime_sub,"}, {"sha": "9b76542c526399114661e70b17bf5131ebc1bf8c", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -70,6 +70,7 @@ bool gfc_check_dprod (gfc_expr *, gfc_expr *);\n bool gfc_check_dshift (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_dtime_etime (gfc_expr *);\n+bool gfc_check_event_query (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_fgetputc (gfc_expr *, gfc_expr *);\n bool gfc_check_fgetput (gfc_expr *);\n bool gfc_check_float (gfc_expr *);\n@@ -462,6 +463,7 @@ void gfc_resolve_dtime_sub (gfc_code *);\n void gfc_resolve_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t  gfc_expr *);\n void gfc_resolve_etime_sub (gfc_code *);\n+void gfc_resolve_event_query (gfc_code *);\n void gfc_resolve_exp (gfc_expr *, gfc_expr *);\n void gfc_resolve_exponent (gfc_expr *, gfc_expr *);\n void gfc_resolve_extends_type_of (gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "8aa3a16af2ee4d068309d7d4e6233313b0c934b2", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -2945,6 +2945,12 @@ gfc_resolve_atomic_ref (gfc_code *c)\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n+void\n+gfc_resolve_event_query (gfc_code *c)\n+{\n+  const char *name = \"event_query\";\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n+}\n \n void\n gfc_resolve_mvbits (gfc_code *c)"}, {"sha": "c5fb3ff21f081f4594388b0197b36c1ac8b7dac3", "filename": "gcc/fortran/iso-fortran-env.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fiso-fortran-env.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fiso-fortran-env.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-fortran-env.def?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -123,6 +123,11 @@ NAMED_FUNCTION (ISOFORTRAN_COMPILER_VERSION, \"compiler_version\", \\\n NAMED_DERIVED_TYPE (ISOFORTRAN_LOCK_TYPE, \"lock_type\", \\\n               get_int_kind_from_node (ptr_type_node), GFC_STD_F2008)\n \n+NAMED_DERIVED_TYPE (ISOFORTRAN_EVENT_TYPE, \"event_type\", \\\n+\t\t    flag_coarray == GFC_FCOARRAY_LIB\n+\t\t    ?  get_int_kind_from_node (ptr_type_node)\n+\t\t    : gfc_default_integer_kind, GFC_STD_F2008_TS)\n+\n #undef NAMED_INTCST\n #undef NAMED_KINDARRAY\n #undef NAMED_FUNCTION"}, {"sha": "b55346497e9d881780cc17dbbd34ae428f940814", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -1463,6 +1463,8 @@ gfc_match_if (gfc_statement *if_type)\n   match (\"deallocate\", gfc_match_deallocate, ST_DEALLOCATE)\n   match (\"end file\", gfc_match_endfile, ST_END_FILE)\n   match (\"error stop\", gfc_match_error_stop, ST_ERROR_STOP)\n+  match (\"event post\", gfc_match_event_post, ST_EVENT_POST)\n+  match (\"event wait\", gfc_match_event_wait, ST_EVENT_WAIT)\n   match (\"exit\", gfc_match_exit, ST_EXIT)\n   match (\"flush\", gfc_match_flush, ST_FLUSH)\n   match (\"forall\", match_simple_forall, ST_FORALL)\n@@ -2747,6 +2749,202 @@ gfc_match_error_stop (void)\n   return gfc_match_stopcode (ST_ERROR_STOP);\n }\n \n+/* Match EVENT POST/WAIT statement. Syntax:\n+     EVENT POST ( event-variable [, sync-stat-list] )\n+     EVENT WAIT ( event-variable [, wait-spec-list] )\n+   with\n+      wait-spec-list  is  sync-stat-list  or until-spec\n+      until-spec  is  UNTIL_COUNT = scalar-int-expr\n+      sync-stat  is  STAT= or ERRMSG=.  */\n+\n+static match\n+event_statement (gfc_statement st)\n+{\n+  match m;\n+  gfc_expr *tmp, *eventvar, *until_count, *stat, *errmsg;\n+  bool saw_until_count, saw_stat, saw_errmsg;\n+\n+  tmp = eventvar = until_count = stat = errmsg = NULL;\n+  saw_until_count = saw_stat = saw_errmsg = false;\n+\n+  if (gfc_pure (NULL))\n+    {\n+      gfc_error (\"Image control statement EVENT %s at %C in PURE procedure\",\n+\t\t st == ST_EVENT_POST ? \"POST\" : \"WAIT\");\n+      return MATCH_ERROR;\n+    }\n+\n+  gfc_unset_implicit_pure (NULL);\n+\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n+    {\n+       gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n+       return MATCH_ERROR;\n+    }\n+\n+  if (gfc_find_state (COMP_CRITICAL))\n+    {\n+      gfc_error (\"Image control statement EVENT %s at %C in CRITICAL block\",\n+\t\t st == ST_EVENT_POST ? \"POST\" : \"WAIT\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_find_state (COMP_DO_CONCURRENT))\n+    {\n+      gfc_error (\"Image control statement EVENT %s at %C in DO CONCURRENT \"\n+\t\t \"block\", st == ST_EVENT_POST ? \"POST\" : \"WAIT\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    goto syntax;\n+\n+  if (gfc_match (\"%e\", &eventvar) != MATCH_YES)\n+    goto syntax;\n+  m = gfc_match_char (',');\n+  if (m == MATCH_ERROR)\n+    goto syntax;\n+  if (m == MATCH_NO)\n+    {\n+      m = gfc_match_char (')');\n+      if (m == MATCH_YES)\n+\tgoto done;\n+      goto syntax;\n+    }\n+\n+  for (;;)\n+    {\n+      m = gfc_match (\" stat = %v\", &tmp);\n+      if (m == MATCH_ERROR)\n+\tgoto syntax;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (saw_stat)\n+\t    {\n+\t      gfc_error (\"Redundant STAT tag found at %L \", &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\t  stat = tmp;\n+\t  saw_stat = true;\n+\n+\t  m = gfc_match_char (',');\n+\t  if (m == MATCH_YES)\n+\t    continue;\n+\n+\t  tmp = NULL;\n+\t  break;\n+\t}\n+\n+      m = gfc_match (\" errmsg = %v\", &tmp);\n+      if (m == MATCH_ERROR)\n+\tgoto syntax;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (saw_errmsg)\n+\t    {\n+\t      gfc_error (\"Redundant ERRMSG tag found at %L \", &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\t  errmsg = tmp;\n+\t  saw_errmsg = true;\n+\n+\t  m = gfc_match_char (',');\n+\t  if (m == MATCH_YES)\n+\t    continue;\n+\n+\t  tmp = NULL;\n+\t  break;\n+\t}\n+\n+      m = gfc_match (\" until_count = %e\", &tmp);\n+      if (m == MATCH_ERROR || st == ST_EVENT_POST)\n+\tgoto syntax;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (saw_until_count)\n+\t    {\n+\t      gfc_error (\"Redundant UNTIL_COUNT tag found at %L \",\n+\t\t\t &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\t  until_count = tmp;\n+\t  saw_until_count = true;\n+\n+\t  m = gfc_match_char (',');\n+\t  if (m == MATCH_YES)\n+\t    continue;\n+\n+\t  tmp = NULL;\n+\t  break;\n+\t}\n+\n+      break;\n+    }\n+\n+  if (m == MATCH_ERROR)\n+    goto syntax;\n+\n+  if (gfc_match (\" )%t\") != MATCH_YES)\n+    goto syntax;\n+\n+done:\n+  switch (st)\n+    {\n+    case ST_EVENT_POST:\n+      new_st.op = EXEC_EVENT_POST;\n+      break;\n+    case ST_EVENT_WAIT:\n+      new_st.op = EXEC_EVENT_WAIT;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  new_st.expr1 = eventvar;\n+  new_st.expr2 = stat;\n+  new_st.expr3 = errmsg;\n+  new_st.expr4 = until_count;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (st);\n+\n+cleanup:\n+  if (until_count != tmp)\n+    gfc_free_expr (until_count);\n+  if (errmsg != tmp)\n+    gfc_free_expr (errmsg);\n+  if (stat != tmp)\n+    gfc_free_expr (stat);\n+\n+  gfc_free_expr (tmp);\n+  gfc_free_expr (eventvar);\n+\n+  return MATCH_ERROR;\n+\n+}\n+\n+\n+match\n+gfc_match_event_post (void)\n+{\n+  if (!gfc_notify_std (GFC_STD_F2008_TS, \"EVENT POST statement at %C\"))\n+    return MATCH_ERROR;\n+\n+  return event_statement (ST_EVENT_POST);\n+}\n+\n+\n+match\n+gfc_match_event_wait (void)\n+{\n+  if (!gfc_notify_std (GFC_STD_F2008_TS, \"EVENT WAIT statement at %C\"))\n+    return MATCH_ERROR;\n+\n+  return event_statement (ST_EVENT_WAIT);\n+}\n+\n \n /* Match LOCK/UNLOCK statement. Syntax:\n      LOCK ( lock-variable [ , lock-stat-list ] )"}, {"sha": "7d383ed7357b9b8c0700a534d1eb65cdc33c282e", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -69,6 +69,8 @@ match gfc_match_assignment (void);\n match gfc_match_if (gfc_statement *);\n match gfc_match_else (void);\n match gfc_match_elseif (void);\n+match gfc_match_event_post (void);\n+match gfc_match_event_wait (void);\n match gfc_match_critical (void);\n match gfc_match_block (void);\n match gfc_match_associate (void);"}, {"sha": "704ff1523ef5ba0dc5191e3d68b87ae8aa29c9d4", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -1981,7 +1981,7 @@ enum ab_attribute\n   AB_ELEMENTAL, AB_PURE, AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT,\n   AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE,\n   AB_ALLOC_COMP, AB_POINTER_COMP, AB_PROC_POINTER_COMP, AB_PRIVATE_COMP,\n-  AB_VALUE, AB_VOLATILE, AB_PROTECTED, AB_LOCK_COMP,\n+  AB_VALUE, AB_VOLATILE, AB_PROTECTED, AB_LOCK_COMP, AB_EVENT_COMP,\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n   AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS, AB_CLASS_POINTER,\n@@ -2028,6 +2028,7 @@ static const mstring attr_bits[] =\n     minit (\"ALLOC_COMP\", AB_ALLOC_COMP),\n     minit (\"COARRAY_COMP\", AB_COARRAY_COMP),\n     minit (\"LOCK_COMP\", AB_LOCK_COMP),\n+    minit (\"EVENT_COMP\", AB_EVENT_COMP),\n     minit (\"POINTER_COMP\", AB_POINTER_COMP),\n     minit (\"PROC_POINTER_COMP\", AB_PROC_POINTER_COMP),\n     minit (\"PRIVATE_COMP\", AB_PRIVATE_COMP),\n@@ -2216,6 +2217,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_COARRAY_COMP, attr_bits);\n       if (attr->lock_comp)\n \tMIO_NAME (ab_attribute) (AB_LOCK_COMP, attr_bits);\n+      if (attr->event_comp)\n+\tMIO_NAME (ab_attribute) (AB_EVENT_COMP, attr_bits);\n       if (attr->zero_comp)\n \tMIO_NAME (ab_attribute) (AB_ZERO_COMP, attr_bits);\n       if (attr->is_class)\n@@ -2383,6 +2386,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_LOCK_COMP:\n \t      attr->lock_comp = 1;\n \t      break;\n+\t    case AB_EVENT_COMP:\n+\t      attr->event_comp = 1;\n+\t      break;\n \t    case AB_POINTER_COMP:\n \t      attr->pointer_comp = 1;\n \t      break;"}, {"sha": "157dea874ad2fefbf85f6d476a705c29037cf63c", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 66, "deletions": 3, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -477,6 +477,8 @@ decode_statement (void)\n       match (\"entry% \", gfc_match_entry, ST_ENTRY);\n       match (\"equivalence\", gfc_match_equivalence, ST_EQUIVALENCE);\n       match (\"external\", gfc_match_external, ST_ATTR_DECL);\n+      match (\"event post\", gfc_match_event_post, ST_EVENT_POST);\n+      match (\"event wait\", gfc_match_event_wait, ST_EVENT_WAIT);\n       break;\n \n     case 'f':\n@@ -1348,6 +1350,7 @@ next_statement (void)\n   case ST_OMP_CANCEL: case ST_OMP_CANCELLATION_POINT: \\\n   case ST_OMP_TARGET_UPDATE: case ST_ERROR_STOP: case ST_SYNC_ALL: \\\n   case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK: \\\n+  case ST_EVENT_POST: case ST_EVENT_WAIT: \\\n   case ST_OACC_UPDATE: case ST_OACC_WAIT: case ST_OACC_CACHE: \\\n   case ST_OACC_ENTER_DATA: case ST_OACC_EXIT_DATA\n \n@@ -1654,6 +1657,12 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_ELSEWHERE:\n       p = \"ELSEWHERE\";\n       break;\n+    case ST_EVENT_POST:\n+      p = \"EVENT POST\";\n+      break;\n+    case ST_EVENT_WAIT:\n+      p = \"EVENT WAIT\";\n+      break;\n     case ST_END_ASSOCIATE:\n       p = \"END ASSOCIATE\";\n       break;\n@@ -2646,7 +2655,7 @@ parse_derived (void)\n   gfc_statement st;\n   gfc_state_data s;\n   gfc_symbol *sym;\n-  gfc_component *c, *lock_comp = NULL;\n+  gfc_component *c, *lock_comp = NULL, *event_comp = NULL;\n \n   accept_statement (ST_DERIVED_DECL);\n   push_state (&s, COMP_DERIVED, gfc_new_block);\n@@ -2754,8 +2763,8 @@ parse_derived (void)\n   sym = gfc_current_block ();\n   for (c = sym->components; c; c = c->next)\n     {\n-      bool coarray, lock_type, allocatable, pointer;\n-      coarray = lock_type = allocatable = pointer = false;\n+      bool coarray, lock_type, event_type, allocatable, pointer;\n+      coarray = lock_type = event_type = allocatable = pointer = false;\n \n       /* Look for allocatable components.  */\n       if (c->attr.allocatable\n@@ -2817,6 +2826,23 @@ parse_derived (void)\n \t  sym->attr.lock_comp = 1;\n \t}\n \n+      /* Looking for event_type components.  */\n+      if ((c->ts.type == BT_DERIVED\n+\t      && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n+\t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n+\t      && CLASS_DATA (c)->ts.u.derived->from_intmod\n+\t\t == INTMOD_ISO_FORTRAN_ENV\n+\t      && CLASS_DATA (c)->ts.u.derived->intmod_sym_id\n+\t\t == ISOFORTRAN_EVENT_TYPE)\n+\t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.event_comp\n+\t      && !allocatable && !pointer))\n+\t{\n+\t  event_type = 1;\n+\t  event_comp = c;\n+\t  sym->attr.event_comp = 1;\n+\t}\n+\n       /* Check for F2008, C1302 - and recall that pointers may not be coarrays\n \t (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),\n \t unless there are nondirect [allocatable or pointer] components\n@@ -2857,6 +2883,43 @@ parse_derived (void)\n \t\t   \"coarray subcomponent)\", lock_comp->name, &lock_comp->loc,\n \t\t   sym->name, c->name, &c->loc);\n \n+      /* Similarly for EVENT TYPE.  */\n+\n+      if (pointer && !coarray && event_type)\n+\tgfc_error (\"Component %s at %L of type EVENT_TYPE must have a \"\n+\t\t   \"codimension or be a subcomponent of a coarray, \"\n+\t\t   \"which is not possible as the component has the \"\n+\t\t   \"pointer attribute\", c->name, &c->loc);\n+      else if (pointer && !coarray && c->ts.type == BT_DERIVED\n+\t       && c->ts.u.derived->attr.event_comp)\n+\tgfc_error (\"Pointer component %s at %L has a noncoarray subcomponent \"\n+\t\t   \"of type EVENT_TYPE, which must have a codimension or be a \"\n+\t\t   \"subcomponent of a coarray\", c->name, &c->loc);\n+\n+      if (event_type && allocatable && !coarray)\n+\tgfc_error (\"Allocatable component %s at %L of type EVENT_TYPE must have \"\n+\t\t   \"a codimension\", c->name, &c->loc);\n+      else if (event_type && allocatable && c->ts.type == BT_DERIVED\n+\t       && c->ts.u.derived->attr.event_comp)\n+\tgfc_error (\"Allocatable component %s at %L must have a codimension as \"\n+\t\t   \"it has a noncoarray subcomponent of type EVENT_TYPE\",\n+\t\t   c->name, &c->loc);\n+\n+      if (sym->attr.coarray_comp && !coarray && event_type)\n+\tgfc_error (\"Noncoarray component %s at %L of type EVENT_TYPE or with \"\n+\t\t   \"subcomponent of type EVENT_TYPE must have a codimension or \"\n+\t\t   \"be a subcomponent of a coarray. (Variables of type %s may \"\n+\t\t   \"not have a codimension as already a coarray \"\n+\t\t   \"subcomponent exists)\", c->name, &c->loc, sym->name);\n+\n+      if (sym->attr.event_comp && coarray && !event_type)\n+\tgfc_error (\"Noncoarray component %s at %L of type EVENT_TYPE or with \"\n+\t\t   \"subcomponent of type EVENT_TYPE must have a codimension or \"\n+\t\t   \"be a subcomponent of a coarray. (Variables of type %s may \"\n+\t\t   \"not have a codimension as %s at %L has a codimension or a \"\n+\t\t   \"coarray subcomponent)\", event_comp->name, &event_comp->loc,\n+\t\t   sym->name, c->name, &c->loc);\n+\n       /* Look for private components.  */\n       if (sym->component_access == ACCESS_PRIVATE\n \t  || c->attr.access == ACCESS_PRIVATE"}, {"sha": "6598855f81a503af11f119e26e71ea75101fd538", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 82, "deletions": 11, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -7055,6 +7055,21 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n \t\t      &code->expr3->where, &e->where);\n \t  goto failure;\n \t}\n+\n+      /* Check TS18508, C702/C703.  */\n+      if (code->expr3->ts.type == BT_DERIVED\n+\t  && ((codimension && gfc_expr_attr (code->expr3).event_comp)\n+\t      || (code->expr3->ts.u.derived->from_intmod\n+\t\t     == INTMOD_ISO_FORTRAN_ENV\n+\t\t  && code->expr3->ts.u.derived->intmod_sym_id\n+\t\t     == ISOFORTRAN_EVENT_TYPE)))\n+\t{\n+\t  gfc_error (\"The source-expr at %L shall neither be of type \"\n+\t\t     \"EVENT_TYPE nor have a EVENT_TYPE component if \"\n+\t\t      \"allocate-object at %L is a coarray\",\n+\t\t      &code->expr3->where, &e->where);\n+\t  goto failure;\n+\t}\n     }\n \n   /* Check F08:C629.  */\n@@ -7106,6 +7121,13 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n \t no SOURCE exists by setting expr3.  */\n       code->expr3 = gfc_default_initializer (&code->ext.alloc.ts);\n     }\n+  else if (flag_coarray != GFC_FCOARRAY_LIB && e->ts.type == BT_DERIVED\n+\t   && e->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t   && e->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n+    {\n+      /* We have to zero initialize the integer variable.  */\n+      code->expr3 = gfc_get_int_expr (gfc_default_integer_kind, &e->where, 0);\n+    }\n   else if (!code->expr3)\n     {\n       /* Set up default initializer if needed.  */\n@@ -8706,21 +8728,40 @@ find_reachable_labels (gfc_code *block)\n \n \n static void\n-resolve_lock_unlock (gfc_code *code)\n+resolve_lock_unlock_event (gfc_code *code)\n {\n   if (code->expr1->expr_type == EXPR_FUNCTION\n       && code->expr1->value.function.isym\n       && code->expr1->value.function.isym->id == GFC_ISYM_CAF_GET)\n     remove_caf_get_intrinsic (code->expr1);\n \n-  if (code->expr1->ts.type != BT_DERIVED\n-      || code->expr1->expr_type != EXPR_VARIABLE\n-      || code->expr1->ts.u.derived->from_intmod != INTMOD_ISO_FORTRAN_ENV\n-      || code->expr1->ts.u.derived->intmod_sym_id != ISOFORTRAN_LOCK_TYPE\n-      || code->expr1->rank != 0\n-      || (!gfc_is_coarray (code->expr1) && !gfc_is_coindexed (code->expr1)))\n+  if ((code->op == EXEC_LOCK || code->op == EXEC_UNLOCK)\n+      && (code->expr1->ts.type != BT_DERIVED\n+\t  || code->expr1->expr_type != EXPR_VARIABLE\n+\t  || code->expr1->ts.u.derived->from_intmod != INTMOD_ISO_FORTRAN_ENV\n+\t  || code->expr1->ts.u.derived->intmod_sym_id != ISOFORTRAN_LOCK_TYPE\n+\t  || code->expr1->rank != 0\n+\t  || (!gfc_is_coarray (code->expr1) &&\n+\t      !gfc_is_coindexed (code->expr1))))\n     gfc_error (\"Lock variable at %L must be a scalar of type LOCK_TYPE\",\n \t       &code->expr1->where);\n+  else if ((code->op == EXEC_EVENT_POST && code->op == EXEC_EVENT_WAIT)\n+\t   && (code->expr1->ts.type != BT_DERIVED\n+\t       || code->expr1->expr_type != EXPR_VARIABLE\n+\t       || code->expr1->ts.u.derived->from_intmod\n+\t\t  != INTMOD_ISO_FORTRAN_ENV\n+\t       || code->expr1->ts.u.derived->intmod_sym_id\n+\t\t  != ISOFORTRAN_EVENT_TYPE\n+\t       || code->expr1->rank != 0))\n+    gfc_error (\"Event variable at %L must be a scalar of type EVENT_TYPE\",\n+\t       &code->expr1->where);\n+  else if (code->op == EXEC_EVENT_POST && !gfc_is_coarray (code->expr1)\n+\t   && !gfc_is_coindexed (code->expr1))\n+    gfc_error (\"Event variable argument at %L must be a coarray or coindexed\",\n+\t       &code->expr1->where);\n+  else if (code->op == EXEC_EVENT_WAIT && !gfc_is_coarray (code->expr1))\n+    gfc_error (\"Event variable argument at %L must be a coarray but not \"\n+\t       \"coindexed\", &code->expr1->where);\n \n   /* Check STAT.  */\n   if (code->expr2\n@@ -8746,17 +8787,23 @@ resolve_lock_unlock (gfc_code *code)\n \t\t\t\t    _(\"ERRMSG variable\")))\n     return;\n \n-  /* Check ACQUIRED_LOCK.  */\n-  if (code->expr4\n+  /* Check for LOCK the ACQUIRED_LOCK.  */\n+  if (code->op != EXEC_EVENT_WAIT && code->expr4\n       && (code->expr4->ts.type != BT_LOGICAL || code->expr4->rank != 0\n \t  || code->expr4->expr_type != EXPR_VARIABLE))\n     gfc_error (\"ACQUIRED_LOCK= argument at %L must be a scalar LOGICAL \"\n \t       \"variable\", &code->expr4->where);\n \n-  if (code->expr4\n+  if (code->op != EXEC_EVENT_WAIT && code->expr4\n       && !gfc_check_vardef_context (code->expr4, false, false, false,\n \t\t\t\t    _(\"ACQUIRED_LOCK variable\")))\n     return;\n+\n+  /* Check for EVENT WAIT the UNTIL_COUNT.  */\n+  if (code->op == EXEC_EVENT_WAIT && code->expr4\n+      && (code->expr4->ts.type != BT_INTEGER || code->expr4->rank != 0))\n+    gfc_error (\"UNTIL_COUNT= argument at %L must be a scalar INTEGER \"\n+\t       \"expression\", &code->expr4->where);\n }\n \n \n@@ -10403,7 +10450,9 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \n \tcase EXEC_LOCK:\n \tcase EXEC_UNLOCK:\n-\t  resolve_lock_unlock (code);\n+\tcase EXEC_EVENT_POST:\n+\tcase EXEC_EVENT_WAIT:\n+\t  resolve_lock_unlock_event (code);\n \t  break;\n \n \tcase EXEC_ENTRY:\n@@ -14001,6 +14050,19 @@ resolve_symbol (gfc_symbol *sym)\n       return;\n     }\n \n+  /* TS18508, C702/C703.  */\n+  if (sym->ts.type == BT_DERIVED\n+      && ((sym->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t   && sym->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n+\t  || sym->ts.u.derived->attr.event_comp)\n+      && !sym->attr.codimension && !sym->ts.u.derived->attr.coarray_comp)\n+    {\n+      gfc_error (\"Variable %s at %L of type EVENT_TYPE or with subcomponent of \"\n+\t\t \"type LOCK_TYPE must be a coarray\", sym->name,\n+\t\t &sym->declared_at);\n+      return;\n+    }\n+\n   /* An assumed-size array with INTENT(OUT) shall not be of a type for which\n      default initialization is defined (5.1.2.4.4).  */\n   if (sym->ts.type == BT_DERIVED\n@@ -14030,6 +14092,15 @@ resolve_symbol (gfc_symbol *sym)\n       return;\n     }\n \n+  /* TS18508.  */\n+  if (sym->ts.type == BT_DERIVED && sym->attr.dummy\n+      && sym->attr.intent == INTENT_OUT && sym->attr.event_comp)\n+    {\n+      gfc_error (\"Dummy argument %qs at %L of EVENT_TYPE shall not be \"\n+\t\t \"INTENT(OUT)\", sym->name, &sym->declared_at);\n+      return;\n+    }\n+\n   /* F2008, C525.  */\n   if ((((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)\n \t || (sym->ts.type == BT_CLASS && sym->attr.class_ok"}, {"sha": "573385f52388e7d539e58fb616230652ad21fd45", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -118,6 +118,8 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_SYNC_MEMORY:\n     case EXEC_LOCK:\n     case EXEC_UNLOCK:\n+    case EXEC_EVENT_POST:\n+    case EXEC_EVENT_WAIT:\n       break;\n \n     case EXEC_BLOCK:"}, {"sha": "8c4fa03629b4a4d55d174e042e067d0545eb16b0", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -145,6 +145,9 @@ tree gfor_fndecl_caf_atomic_cas;\n tree gfor_fndecl_caf_atomic_op;\n tree gfor_fndecl_caf_lock;\n tree gfor_fndecl_caf_unlock;\n+tree gfor_fndecl_caf_event_post;\n+tree gfor_fndecl_caf_event_wait;\n+tree gfor_fndecl_caf_event_query;\n tree gfor_fndecl_co_broadcast;\n tree gfor_fndecl_co_max;\n tree gfor_fndecl_co_min;\n@@ -3559,6 +3562,21 @@ gfc_build_builtin_function_decls (void)\n \tvoid_type_node, 6, pvoid_type_node, size_type_node, integer_type_node,\n \tpint_type, pchar_type_node, integer_type_node);\n \n+      gfor_fndecl_caf_event_post = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_event_post\")), \"R..WW\",\n+\tvoid_type_node, 6, pvoid_type_node, size_type_node, integer_type_node,\n+\tpint_type, pchar_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_event_wait = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_event_wait\")), \"R..WW\",\n+\tvoid_type_node, 6, pvoid_type_node, size_type_node, integer_type_node,\n+\tpint_type, pchar_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_event_query = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_event_query\")), \"R..WW\",\n+\tvoid_type_node, 5, pvoid_type_node, size_type_node, integer_type_node,\n+\tpint_type, pint_type);\n+\n       gfor_fndecl_co_broadcast = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_co_broadcast\")), \"W.WW\",\n \tvoid_type_node, 5, pvoid_type_node, integer_type_node,\n@@ -4854,7 +4872,7 @@ static void\n generate_coarray_sym_init (gfc_symbol *sym)\n {\n   tree tmp, size, decl, token;\n-  bool is_lock_type;\n+  bool is_lock_type, is_event_type;\n   int reg_type;\n \n   if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension\n@@ -4870,13 +4888,17 @@ generate_coarray_sym_init (gfc_symbol *sym)\n \t\t && sym->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n \t\t && sym->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE;\n \n+  is_event_type = sym->ts.type == BT_DERIVED\n+\t\t  && sym->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t\t  && sym->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE;\n+\n   /* FIXME: Workaround for PR middle-end/49106, cf. also PR middle-end/49108\n      to make sure the variable is not optimized away.  */\n   DECL_PRESERVE_P (DECL_CONTEXT (decl)) = 1;\n \n   /* For lock types, we pass the array size as only the library knows the\n      size of the variable.  */\n-  if (is_lock_type)\n+  if (is_lock_type || is_event_type)\n     size = gfc_index_one_node;\n   else\n     size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (decl)));\n@@ -4898,6 +4920,8 @@ generate_coarray_sym_init (gfc_symbol *sym)\n \t\t\t       GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE(decl)));\n   if (is_lock_type)\n     reg_type = sym->attr.artificial ? GFC_CAF_CRITICAL : GFC_CAF_LOCK_STATIC;\n+  else if (is_event_type)\n+    reg_type = GFC_CAF_EVENT_STATIC;\n   else\n     reg_type = GFC_CAF_COARRAY_STATIC;\n   tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_register, 6, size,"}, {"sha": "22195e09887172117fabf5b2ead7a437ae2fb19b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -5784,8 +5784,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       len = cl.backend_decl;\n     }\n \n-  byref = (comp && (comp->attr.dimension || comp->ts.type == BT_CHARACTER))\n-\t  || (!comp && gfc_return_by_reference (sym));\n+  byref = (comp && (comp->attr.dimension\n+\t   || (comp->ts.type == BT_CHARACTER && !sym->attr.is_bind_c)))\n+\t   || (!comp && gfc_return_by_reference (sym));\n   if (byref)\n     {\n       if (se->direct_byref)\n@@ -6611,6 +6612,11 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n {\n   gfc_se se;\n \n+  if (flag_coarray != GFC_FCOARRAY_LIB && ts->type == BT_DERIVED\n+      && ts->u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+      && ts->u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n+    return build_constructor (type, NULL);\n+\n   if (!(expr || pointer || procptr))\n     return NULL_TREE;\n "}, {"sha": "21efe4412bdcb02535c0cb7398507b40787e7cf1", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -9291,6 +9291,154 @@ conv_intrinsic_atomic_cas (gfc_code *code)\n   return gfc_finish_block (&block);\n }\n \n+static tree\n+conv_intrinsic_event_query (gfc_code *code)\n+{\n+  gfc_se se, argse;\n+  tree stat = NULL_TREE, stat2 = NULL_TREE;\n+  tree count = NULL_TREE, count2 = NULL_TREE;\n+\n+  gfc_expr *event_expr = code->ext.actual->expr;\n+\n+  if (code->ext.actual->next->next->expr)\n+    {\n+      gcc_assert (code->ext.actual->next->next->expr->expr_type\n+\t\t  == EXPR_VARIABLE);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->ext.actual->next->next->expr);\n+      stat = argse.expr;\n+    }\n+  else if (flag_coarray == GFC_FCOARRAY_LIB)\n+    stat = null_pointer_node;\n+\n+  if (code->ext.actual->next->expr)\n+    {\n+      gcc_assert (code->ext.actual->next->expr->expr_type == EXPR_VARIABLE);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->ext.actual->next->expr);\n+      count = argse.expr;\n+    }\n+\n+  gfc_start_block (&se.pre);\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n+    {\n+      tree tmp, token, image_index;\n+      tree index = size_zero_node;\n+\n+      if (event_expr->expr_type == EXPR_FUNCTION\n+\t  && event_expr->value.function.isym\n+\t  && event_expr->value.function.isym->id == GFC_ISYM_CAF_GET)\n+\tevent_expr = event_expr->value.function.actual->expr;\n+\n+      tree caf_decl = gfc_get_tree_for_caf_expr (event_expr);\n+\n+      if (event_expr->symtree->n.sym->ts.type != BT_DERIVED\n+\t  || event_expr->symtree->n.sym->ts.u.derived->from_intmod\n+\t     != INTMOD_ISO_FORTRAN_ENV\n+\t  || event_expr->symtree->n.sym->ts.u.derived->intmod_sym_id\n+\t     != ISOFORTRAN_EVENT_TYPE)\n+\t{\n+\t  gfc_error (\"Sorry, the event component of derived type at %L is not \"\n+\t\t     \"yet supported\", &event_expr->where);\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (gfc_is_coindexed (event_expr))\n+\t{\n+\t  gfc_error (\"The event variable at %L shall not be coindexed \",\n+\t\t     &event_expr->where);\n+          return NULL_TREE;\n+\t}\n+\n+      image_index = integer_zero_node;\n+\n+      gfc_get_caf_token_offset (&token, NULL, caf_decl, NULL_TREE, event_expr);\n+\n+      /* For arrays, obtain the array index.  */\n+      if (gfc_expr_attr (event_expr).dimension)\n+\t{\n+\t  tree desc, tmp, extent, lbound, ubound;\n+          gfc_array_ref *ar, ar2;\n+          int i;\n+\n+\t  /* TODO: Extend this, once DT components are supported.  */\n+\t  ar = &event_expr->ref->u.ar;\n+\t  ar2 = *ar;\n+\t  memset (ar, '\\0', sizeof (*ar));\n+\t  ar->as = ar2.as;\n+\t  ar->type = AR_FULL;\n+\n+\t  gfc_init_se (&argse, NULL);\n+\t  argse.descriptor_only = 1;\n+\t  gfc_conv_expr_descriptor (&argse, event_expr);\n+\t  gfc_add_block_to_block (&se.pre, &argse.pre);\n+\t  desc = argse.expr;\n+\t  *ar = ar2;\n+\n+\t  extent = integer_one_node;\n+\t  for (i = 0; i < ar->dimen; i++)\n+\t    {\n+\t      gfc_init_se (&argse, NULL);\n+\t      gfc_conv_expr_type (&argse, ar->start[i], integer_type_node);\n+\t      gfc_add_block_to_block (&argse.pre, &argse.pre);\n+\t      lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[i]);\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     integer_type_node, argse.expr,\n+\t\t\t\t     fold_convert(integer_type_node, lbound));\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     integer_type_node, extent, tmp);\n+\t      index = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t       integer_type_node, index, tmp);\n+\t      if (i < ar->dimen - 1)\n+\t\t{\n+\t\t  ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[i]);\n+\t\t  tmp = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n+\t\t  tmp = fold_convert (integer_type_node, tmp);\n+\t\t  extent = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t    integer_type_node, extent, tmp);\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (count != null_pointer_node && TREE_TYPE (count) != integer_type_node)\n+\t{\n+\t  count2 = count;\n+\t  count = gfc_create_var (integer_type_node, \"count\");\n+\t}\n+\n+      if (stat != null_pointer_node && TREE_TYPE (stat) != integer_type_node)\n+\t{\n+\t  stat2 = stat;\n+\t  stat = gfc_create_var (integer_type_node, \"stat\");\n+\t}\n+\n+      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_event_query, 5,\n+                                   token, index, image_index, count\n+\t\t\t\t   ? gfc_build_addr_expr (NULL, count) : count,\n+\t\t\t\t   stat != null_pointer_node\n+\t\t\t\t   ? gfc_build_addr_expr (NULL, stat) : stat);\n+      gfc_add_expr_to_block (&se.pre, tmp);\n+\n+      if (count2 != NULL_TREE)\n+\tgfc_add_modify (&se.pre, count2,\n+\t\t\tfold_convert (TREE_TYPE (count2), count));\n+\n+      if (stat2 != NULL_TREE)\n+\tgfc_add_modify (&se.pre, stat2,\n+\t\t\tfold_convert (TREE_TYPE (stat2), stat));\n+\n+      return gfc_finish_block (&se.pre);\n+    }\n+\n+  gfc_init_se (&argse, NULL);\n+  gfc_conv_expr_val (&argse, code->ext.actual->expr);\n+  gfc_add_modify (&se.pre, count, fold_convert (TREE_TYPE (count), argse.expr));\n+\n+  if (stat != NULL_TREE)\n+    gfc_add_modify (&se.pre, stat, build_int_cst (TREE_TYPE (stat), 0));\n+\n+  return gfc_finish_block (&se.pre);\n+}\n \n static tree\n conv_intrinsic_move_alloc (gfc_code *code)\n@@ -9587,6 +9735,10 @@ gfc_conv_intrinsic_subroutine (gfc_code *code)\n       res = conv_intrinsic_atomic_ref (code);\n       break;\n \n+    case GFC_ISYM_EVENT_QUERY:\n+      res = conv_intrinsic_event_query (code);\n+      break;\n+\n     case GFC_ISYM_C_F_POINTER:\n     case GFC_ISYM_C_F_PROCPOINTER:\n       res = conv_isocbinding_subroutine (code);"}, {"sha": "3df483a29180ae350819dfdf23079c5c717992ab", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -776,6 +776,7 @@ gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op op)\n       if (code->expr3)\n \t{\n \t  gfc_init_se (&argse, NULL);\n+\t  argse.want_pointer = 1;\n \t  gfc_conv_expr (&argse, code->expr3);\n \t  gfc_add_block_to_block (&se.pre, &argse.pre);\n \t  errmsg = argse.expr;\n@@ -840,6 +841,165 @@ gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op op)\n   return gfc_finish_block (&se.pre);\n }\n \n+tree\n+gfc_trans_event_post_wait (gfc_code *code, gfc_exec_op op)\n+{\n+  gfc_se se, argse;\n+  tree stat = NULL_TREE, stat2 = NULL_TREE;\n+  tree until_count = NULL_TREE;\n+\n+  if (code->expr2)\n+    {\n+      gcc_assert (code->expr2->expr_type == EXPR_VARIABLE);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->expr2);\n+      stat = argse.expr;\n+    }\n+  else if (flag_coarray == GFC_FCOARRAY_LIB)\n+    stat = null_pointer_node;\n+\n+  if (code->expr4)\n+    {\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->expr4);\n+      until_count = fold_convert (integer_type_node, argse.expr);\n+    }\n+  else\n+    until_count = integer_one_node;\n+\n+  if (flag_coarray != GFC_FCOARRAY_LIB)\n+    {\n+      gfc_start_block (&se.pre);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->expr1);\n+\n+      if (op == EXEC_EVENT_POST)\n+\tgfc_add_modify (&se.pre, argse.expr,\n+\t\t\tfold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\tTREE_TYPE (argse.expr), argse.expr,\n+\t\t\t\tbuild_int_cst (TREE_TYPE (argse.expr), 1)));\n+      else\n+\tgfc_add_modify (&se.pre, argse.expr,\n+\t\t\tfold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\tTREE_TYPE (argse.expr), argse.expr,\n+\t\t\t\tfold_convert (TREE_TYPE (argse.expr),\n+\t\t\t\t\t      until_count)));\n+      if (stat != NULL_TREE)\n+\tgfc_add_modify (&se.pre, stat, build_int_cst (TREE_TYPE (stat), 0));\n+\n+      return gfc_finish_block (&se.pre);\n+    }\n+\n+  gfc_start_block (&se.pre);\n+  tree tmp, token, image_index, errmsg, errmsg_len;\n+  tree index = size_zero_node;\n+  tree caf_decl = gfc_get_tree_for_caf_expr (code->expr1);\n+\n+  if (code->expr1->symtree->n.sym->ts.type != BT_DERIVED\n+      || code->expr1->symtree->n.sym->ts.u.derived->from_intmod\n+\t != INTMOD_ISO_FORTRAN_ENV\n+      || code->expr1->symtree->n.sym->ts.u.derived->intmod_sym_id\n+\t != ISOFORTRAN_EVENT_TYPE)\n+    {\n+      gfc_error (\"Sorry, the event component of derived type at %L is not \"\n+\t\t \"yet supported\", &code->expr1->where);\n+      return NULL_TREE;\n+    }\n+\n+  gfc_get_caf_token_offset (&token, NULL, caf_decl, NULL_TREE, code->expr1);\n+\n+  if (gfc_is_coindexed (code->expr1))\n+    image_index = gfc_caf_get_image_index (&se.pre, code->expr1, caf_decl);\n+  else\n+    image_index = integer_zero_node;\n+\n+  /* For arrays, obtain the array index.  */\n+  if (gfc_expr_attr (code->expr1).dimension)\n+    {\n+      tree desc, tmp, extent, lbound, ubound;\n+      gfc_array_ref *ar, ar2;\n+      int i;\n+\n+      /* TODO: Extend this, once DT components are supported.  */\n+      ar = &code->expr1->ref->u.ar;\n+      ar2 = *ar;\n+      memset (ar, '\\0', sizeof (*ar));\n+      ar->as = ar2.as;\n+      ar->type = AR_FULL;\n+\n+      gfc_init_se (&argse, NULL);\n+      argse.descriptor_only = 1;\n+      gfc_conv_expr_descriptor (&argse, code->expr1);\n+      gfc_add_block_to_block (&se.pre, &argse.pre);\n+      desc = argse.expr;\n+      *ar = ar2;\n+\n+      extent = integer_one_node;\n+      for (i = 0; i < ar->dimen; i++)\n+\t{\n+\t  gfc_init_se (&argse, NULL);\n+\t  gfc_conv_expr_type (&argse, ar->start[i], integer_type_node);\n+\t  gfc_add_block_to_block (&argse.pre, &argse.pre);\n+\t  lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[i]);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t integer_type_node, argse.expr,\n+\t\t\t\t fold_convert(integer_type_node, lbound));\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t integer_type_node, extent, tmp);\n+\t  index = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t   integer_type_node, index, tmp);\n+\t  if (i < ar->dimen - 1)\n+\t    {\n+\t      ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[i]);\n+\t      tmp = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n+\t      tmp = fold_convert (integer_type_node, tmp);\n+\t      extent = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\tinteger_type_node, extent, tmp);\n+\t    }\n+\t}\n+    }\n+\n+  /* errmsg.  */\n+  if (code->expr3)\n+    {\n+      gfc_init_se (&argse, NULL);\n+      argse.want_pointer = 1;\n+      gfc_conv_expr (&argse, code->expr3);\n+      gfc_add_block_to_block (&se.pre, &argse.pre);\n+      errmsg = argse.expr;\n+      errmsg_len = fold_convert (integer_type_node, argse.string_length);\n+    }\n+  else\n+    {\n+      errmsg = null_pointer_node;\n+      errmsg_len = integer_zero_node;\n+    }\n+\n+  if (stat != null_pointer_node && TREE_TYPE (stat) != integer_type_node)\n+    {\n+      stat2 = stat;\n+      stat = gfc_create_var (integer_type_node, \"stat\");\n+    }\n+\n+  if (op == EXEC_EVENT_POST)\n+    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_event_post, 6,\n+\t\t\t       token, index, image_index,\n+\t\t\t       stat != null_pointer_node\n+\t\t\t       ? gfc_build_addr_expr (NULL, stat) : stat,\n+\t\t\t       errmsg, errmsg_len);\n+  else\n+    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_event_wait, 6,\n+\t\t\t       token, index, until_count,\n+\t\t\t       stat != null_pointer_node\n+\t\t\t       ? gfc_build_addr_expr (NULL, stat) : stat,\n+\t\t\t       errmsg, errmsg_len);\n+  gfc_add_expr_to_block (&se.pre, tmp);\n+\n+  if (stat2 != NULL_TREE)\n+    gfc_add_modify (&se.pre, stat2, fold_convert (TREE_TYPE (stat2), stat));\n+\n+  return gfc_finish_block (&se.pre);\n+}\n \n tree\n gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n@@ -879,6 +1039,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n     {\n       gcc_assert (code->expr3->expr_type == EXPR_VARIABLE);\n       gfc_init_se (&argse, NULL);\n+      argse.want_pointer = 1;\n       gfc_conv_expr (&argse, code->expr3);\n       gfc_conv_string_parameter (&argse);\n       errmsg = gfc_build_addr_expr (NULL, argse.expr);"}, {"sha": "76f1f28f27cc45e28906fd6c1d26970028ae2512", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -55,6 +55,7 @@ tree gfc_trans_do_while (gfc_code *);\n tree gfc_trans_select (gfc_code *);\n tree gfc_trans_sync (gfc_code *, gfc_exec_op);\n tree gfc_trans_lock_unlock (gfc_code *, gfc_exec_op);\n+tree gfc_trans_event_post_wait (gfc_code *, gfc_exec_op);\n tree gfc_trans_forall (gfc_code *);\n tree gfc_trans_where (gfc_code *);\n tree gfc_trans_allocate (gfc_code *);"}, {"sha": "60bd8e1b9820743ea89dcbbc82fdea5a869bb964", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -2371,6 +2371,11 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t  && derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE))\n     return ptr_type_node;\n \n+  if (flag_coarray != GFC_FCOARRAY_LIB\n+      && derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+      && derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n+    return gfc_get_int_type (gfc_default_integer_kind);\n+\n   if (derived && derived->attr.flavor == FL_PROCEDURE\n       && derived->attr.generic)\n     derived = gfc_find_dt_in_generic (derived);"}, {"sha": "001db41ca8344cd6c6e26e53feeb7d73714e38b8", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -711,7 +711,7 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n static void\n gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n \t\t\ttree token, tree status, tree errmsg, tree errlen,\n-\t\t\tbool lock_var)\n+\t\t\tbool lock_var, bool event_var)\n {\n   tree tmp, pstat;\n \n@@ -738,7 +738,8 @@ gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n \t\t\t      build_int_cst (size_type_node, 1)),\n \t     build_int_cst (integer_type_node,\n \t\t\t    lock_var ? GFC_CAF_LOCK_ALLOC\n-\t\t\t\t     : GFC_CAF_COARRAY_ALLOC),\n+                            : event_var ? GFC_CAF_EVENT_ALLOC\n+\t\t\t\t\t: GFC_CAF_COARRAY_ALLOC),\n \t     token, pstat, errmsg, errlen);\n \n   tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n@@ -798,6 +799,11 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n \t\t\t == INTMOD_ISO_FORTRAN_ENV\n \t\t      && expr->ts.u.derived->intmod_sym_id\n \t\t         == ISOFORTRAN_LOCK_TYPE;\n+      bool event_var = expr->ts.type == BT_DERIVED\n+\t\t       && expr->ts.u.derived->from_intmod\n+\t\t\t == INTMOD_ISO_FORTRAN_ENV\n+\t\t       && expr->ts.u.derived->intmod_sym_id\n+\t\t         == ISOFORTRAN_EVENT_TYPE;\n       /* In the front end, we represent the lock variable as pointer. However,\n \t the FE only passes the pointer around and leaves the actual\n \t representation to the library. Hence, we have to convert back to the\n@@ -807,7 +813,7 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n \t\t\t\tsize, TYPE_SIZE_UNIT (ptr_type_node));\n \n       gfc_allocate_using_lib (&alloc_block, mem, size, token, status,\n-\t\t\t      errmsg, errlen, lock_var);\n+\t\t\t      errmsg, errlen, lock_var, event_var);\n \n       if (status != NULL_TREE)\n \t{\n@@ -1797,6 +1803,11 @@ trans_code (gfc_code * code, tree cond)\n \t  res = gfc_trans_lock_unlock (code, code->op);\n \t  break;\n \n+\tcase EXEC_EVENT_POST:\n+\tcase EXEC_EVENT_WAIT:\n+\t  res = gfc_trans_event_post_wait (code, code->op);\n+\t  break;\n+\n \tcase EXEC_FORALL:\n \t  res = gfc_trans_forall (code);\n \t  break;"}, {"sha": "088eca376b5e445c1f790c6969393c12b3f6a151", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -113,7 +113,9 @@ enum gfc_coarray_type\n   GFC_CAF_COARRAY_ALLOC,\n   GFC_CAF_LOCK_STATIC,\n   GFC_CAF_LOCK_ALLOC,\n-  GFC_CAF_CRITICAL\n+  GFC_CAF_CRITICAL,\n+  GFC_CAF_EVENT_STATIC,\n+  GFC_CAF_EVENT_ALLOC\n };\n \n \n@@ -763,6 +765,9 @@ extern GTY(()) tree gfor_fndecl_caf_atomic_cas;\n extern GTY(()) tree gfor_fndecl_caf_atomic_op;\n extern GTY(()) tree gfor_fndecl_caf_lock;\n extern GTY(()) tree gfor_fndecl_caf_unlock;\n+extern GTY(()) tree gfor_fndecl_caf_event_post;\n+extern GTY(()) tree gfor_fndecl_caf_event_wait;\n+extern GTY(()) tree gfor_fndecl_caf_event_query;\n extern GTY(()) tree gfor_fndecl_co_broadcast;\n extern GTY(()) tree gfor_fndecl_co_max;\n extern GTY(()) tree gfor_fndecl_co_min;"}, {"sha": "517b23e832fc61d4b4f5d177d22ed117bdbf4ab5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -1,3 +1,9 @@\n+2015-12-02  Tobias Burnus  <burnus@net-b.de>\n+\t    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n+\n+\t* gfortran.dg/coarray/event_1.f90: New.\n+\t* gfortran.dg/coarray/event_2.f90: New.\n+\n 2015-12-02  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "b4385f340ed08620ce182ea1fe714a1d75281fb5", "filename": "gcc/testsuite/gfortran.dg/coarray/event_1.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fevent_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fevent_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fevent_1.f90?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+!\n+! Run-time test for EVENT_TYPE\n+!\n+use iso_fortran_env, only: event_type\n+implicit none\n+\n+type(event_type), save :: var[*]\n+integer :: count, stat\n+\n+count = -42\n+call event_query (var, count)\n+if (count /= 0) call abort()\n+\n+stat = 99\n+event post (var, stat=stat)\n+if (stat /= 0) call abort()\n+call event_query(var, count, stat=stat)\n+if (count /= 1 .or. stat /= 0) call abort()\n+\n+stat = 99\n+event post (var[this_image()])\n+call event_query(var, count)\n+if (count /= 2) call abort()\n+\n+stat = 99\n+event wait (var)\n+call event_query(var, count)\n+if (count /= 1) call abort()\n+\n+stat = 99\n+event post (var)\n+call event_query(var, count)\n+if (count /= 2) call abort()\n+\n+stat = 99\n+event post (var)\n+call event_query(var, count)\n+if (count /= 3) call abort()\n+\n+stat = 99\n+event wait (var, until_count=2)\n+call event_query(var, count)\n+if (count /= 1) call abort()\n+\n+stat = 99\n+event wait (var, stat=stat, until_count=1)\n+if (stat /= 0) call abort()\n+call event_query(event=var, stat=stat, count=count)\n+if (count /= 0 .or. stat /= 0) call abort()\n+end"}, {"sha": "2d451a557a91bafbcda7c6fd691eec69f9c22857", "filename": "gcc/testsuite/gfortran.dg/coarray/event_2.f90", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fevent_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fevent_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fevent_2.f90?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -0,0 +1,89 @@\n+! { dg-do run }\n+!\n+! Run-time test for EVENT_TYPE\n+!\n+use iso_fortran_env, only: event_type\n+implicit none\n+\n+type(event_type), save, allocatable :: var(:)[:]\n+integer :: count, stat\n+\n+allocate(var(3)[*])\n+\n+count = -42\n+call event_query (var(1), count)\n+if (count /= 0) call abort()\n+call event_query (var(1), count)\n+if (count /= 0) call abort()\n+call event_query (var(2), count)\n+if (count /= 0) call abort()\n+call event_query (var(3), count)\n+if (count /= 0) call abort()\n+\n+stat = 99\n+event post (var(2), stat=stat)\n+if (stat /= 0) call abort()\n+call event_query (var(1), count)\n+if (count /= 0) call abort()\n+call event_query(var(2), count, stat=stat)\n+if (count /= 1 .or. stat /= 0) call abort()\n+call event_query (var(3), count)\n+if (count /= 0) call abort()\n+\n+stat = 99\n+event post (var(2)[this_image()])\n+call event_query(var(1), count)\n+if (count /= 0) call abort()\n+call event_query(var(2), count)\n+if (count /= 2) call abort()\n+call event_query(var(2), count)\n+if (count /= 2) call abort()\n+call event_query(var(3), count)\n+if (count /= 0) call abort()\n+\n+stat = 99\n+event wait (var(2))\n+call event_query(var(1), count)\n+if (count /= 0) call abort()\n+call event_query(var(2), count)\n+if (count /= 1) call abort()\n+call event_query(var(3), count)\n+if (count /= 0) call abort()\n+\n+stat = 99\n+event post (var(2))\n+call event_query(var(1), count)\n+if (count /= 0) call abort()\n+call event_query(var(2), count)\n+if (count /= 2) call abort()\n+call event_query(var(3), count)\n+if (count /= 0) call abort()\n+\n+stat = 99\n+event post (var(2))\n+call event_query(var(1), count)\n+if (count /= 0) call abort()\n+call event_query(var(2), count)\n+if (count /= 3) call abort()\n+call event_query(var(3), count)\n+if (count /= 0) call abort()\n+\n+stat = 99\n+event wait (var(2), until_count=2)\n+call event_query(var(1), count)\n+if (count /= 0) call abort()\n+call event_query(var(2), count)\n+if (count /= 1) call abort()\n+call event_query(var(3), count)\n+if (count /= 0) call abort()\n+\n+stat = 99\n+event wait (var(2), stat=stat, until_count=1)\n+if (stat /= 0) call abort()\n+call event_query(event=var(1), stat=stat, count=count)\n+if (count /= 0 .or. stat /= 0) call abort()\n+call event_query(event=var(2), stat=stat, count=count)\n+if (count /= 0 .or. stat /= 0) call abort()\n+call event_query(event=var(3), stat=stat, count=count)\n+if (count /= 0 .or. stat /= 0) call abort()\n+end"}, {"sha": "4843fd5046422a189b21af71e2bbed8964ce44b8", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -1,3 +1,11 @@\n+2015-11-26  Tobias Burnus  <burnus@net-b.de>\n+\t    Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n+\n+        * caf/libcaf.h (_gfortran_caf_event_post,\n+\t_gfortran_caf_event_wait,_gfortran_caf_event_query): New prototypes.\n+        * caf/single.c (_gfortran_caf_event_post,\n+\t_gfortran_caf_event_wait,_gfortran_caf_event_query): Implement.\n+\n 2015-11-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/52251"}, {"sha": "ebda579d06cb51a00842b8435f92524ce3a7553b", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -57,7 +57,9 @@ typedef enum caf_register_t {\n   CAF_REGTYPE_COARRAY_ALLOC,\n   CAF_REGTYPE_LOCK_STATIC,\n   CAF_REGTYPE_LOCK_ALLOC,\n-  CAF_REGTYPE_CRITICAL\n+  CAF_REGTYPE_CRITICAL,\n+  CAF_REGTYPE_EVENT_STATIC,\n+  CAF_REGTYPE_EVENT_ALLOC\n }\n caf_register_t;\n \n@@ -133,5 +135,8 @@ void _gfortran_caf_atomic_op (int, caf_token_t, size_t, int, void *, void *,\n \n void _gfortran_caf_lock (caf_token_t, size_t, int, int *, int *, char *, int);\n void _gfortran_caf_unlock (caf_token_t, size_t, int, int *, char *, int);\n+void _gfortran_caf_event_post (caf_token_t, size_t, int, int *, char *, int);\n+void _gfortran_caf_event_wait (caf_token_t, size_t, int, int *, char *, int);\n+void _gfortran_caf_event_query (caf_token_t, size_t, int, int *, int *);\n \n #endif  /* LIBCAF_H  */"}, {"sha": "9c4b3434f5c242b747d3fc997c63d9fc57ffecb3", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5df445a2a52cf954d3f124f5001ce4faaf01f042/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5df445a2a52cf954d3f124f5001ce4faaf01f042/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=5df445a2a52cf954d3f124f5001ce4faaf01f042", "patch": "@@ -101,7 +101,8 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n   void *local;\n \n   if (type == CAF_REGTYPE_LOCK_STATIC || type == CAF_REGTYPE_LOCK_ALLOC\n-      || type == CAF_REGTYPE_CRITICAL)\n+      || type == CAF_REGTYPE_CRITICAL || type == CAF_REGTYPE_EVENT_STATIC\n+      || type == CAF_REGTYPE_EVENT_ALLOC)\n     local = calloc (size, sizeof (bool));\n   else\n     local = malloc (size);\n@@ -133,7 +134,8 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n     *stat = 0;\n \n   if (type == CAF_REGTYPE_COARRAY_STATIC || type == CAF_REGTYPE_LOCK_STATIC\n-      || type == CAF_REGTYPE_CRITICAL)\n+      || type == CAF_REGTYPE_CRITICAL || type == CAF_REGTYPE_EVENT_STATIC\n+      || type == CAF_REGTYPE_EVENT_ALLOC)\n     {\n       caf_static_t *tmp = malloc (sizeof (caf_static_t));\n       tmp->prev  = caf_static_list;\n@@ -1071,6 +1073,45 @@ _gfortran_caf_atomic_op (int op, caf_token_t token, size_t offset,\n     *stat = 0;\n }\n \n+void\n+_gfortran_caf_event_post (caf_token_t token, size_t index, \n+\t\t\t  int image_index __attribute__ ((unused)), \n+\t\t\t  int *stat, char *errmsg __attribute__ ((unused)), \n+\t\t\t  int errmsg_len __attribute__ ((unused)))\n+{\n+  uint32_t value = 1;\n+  uint32_t *event = (uint32_t *) ((char *) TOKEN (token) + index*sizeof(uint32_t));\n+  __atomic_fetch_add (event, (uint32_t) value, __ATOMIC_RELAXED);\n+  \n+  if(stat)\n+    *stat = 0;\n+}\n+\n+void\n+_gfortran_caf_event_wait (caf_token_t token, size_t index, \n+\t\t\t  int until_count, int *stat,\n+\t\t\t  char *errmsg __attribute__ ((unused)), \n+\t\t\t  int errmsg_len __attribute__ ((unused)))\n+{\n+  uint32_t *event = (uint32_t *) ((char *) TOKEN (token) + index*sizeof(uint32_t));\n+  uint32_t value = (uint32_t)-until_count;\n+   __atomic_fetch_add (event, (uint32_t) value, __ATOMIC_RELAXED);\n+  \n+   if(stat)\n+    *stat = 0;    \n+}\n+\n+void\n+_gfortran_caf_event_query (caf_token_t token, size_t index, \n+\t\t\t   int image_index __attribute__ ((unused)), \n+\t\t\t   int *count, int *stat)\n+{\n+  uint32_t *event = (uint32_t *) ((char *) TOKEN (token) + index*sizeof(uint32_t));\n+  __atomic_load (event, (uint32_t *) count, __ATOMIC_RELAXED);\n+  \n+  if(stat)\n+    *stat = 0;\n+}\n \n void\n _gfortran_caf_lock (caf_token_t token, size_t index,"}]}