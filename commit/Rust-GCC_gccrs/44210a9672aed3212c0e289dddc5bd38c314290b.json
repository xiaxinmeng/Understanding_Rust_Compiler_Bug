{"sha": "44210a9672aed3212c0e289dddc5bd38c314290b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQyMTBhOTY3MmFlZDMyMTJjMGUyODlkZGRjNWJkMzhjMzE0MjkwYg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2014-11-14T20:03:19Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2014-11-14T20:03:19Z"}, "message": "ipa-prop.h (ipa_get_jf_pass_through_type_preserved): use agg_preserved flag instead.\n\n2014-11-14  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (ipa_get_jf_pass_through_type_preserved): use\n\tagg_preserved flag instead.\n\t(ipa_get_jf_ancestor_type_preserved): Likewise.\n\t(ipa_node_params): Rename known_vals to known_csts, update all users.\n\tNew field known_contexts.\n\t(ipa_get_indirect_edge_target): Update prototype.\n\t(ipcp_poly_ctx_values_pool): Declare.\n\t(ipa_context_from_jfunc): Likewise.\n\t* ipa-inline.h (estimate_ipcp_clone_size_and_time): Updated prototype.\n\t* cgraph.h (ipa_polymorphic_call_context): New method equal_to.  New\n\tparameter newline of method dump.\n\t* ipa-cp.c (ctxlat): New field.\n\t(ipcp_values_pool): Renamed to ipcp_cst_values_pool, updated all users.\n\t(ipcp_poly_ctx_values_pool):New variable.\n\t(ipa_get_poly_ctx_lat): New function.\n\t(print_ipcp_constant_value): New overloaded function for contexts.\n\t(print_all_lattices): Also print contexts.\n\t(ipa_topo_info): New field contexts;\n\t(set_all_contains_variable): Also set the flag in the context lattice.\n\t(initialize_node_lattices): Likewise for flag bottom.\n\t(ipa_get_jf_ancestor_result): Removed BINFO handling.\n\t(ipa_value_from_jfunc): Likewise.\n\t(ipa_context_from_jfunc): New function.\n\t(values_equal_for_ipcp_p): New overloaded function for contexts.\n\t(allocate_and_init_ipcp_value): Construct the value.\n\t(allocate_and_init_ipcp_value): New overloaded function for contexts.\n\t(propagate_scalar_accross_jump_function): Removed handling of\n\tKNOWN_TYPE jump functions.\n\t(propagate_context_accross_jump_function): New function.\n\t(propagate_constants_accross_call): Also propagate contexts.\n\t(ipa_get_indirect_edge_target_1): Work on contexts rather than BINFOs.\n\t(ipa_get_indirect_edge_target): Likewise.\n\t(devirtualization_time_bonus): Likewise.\n\t(gather_context_independent_values): Create and populate known_contexts\n\tvector rather than known_binfos.\n\t(perform_estimation_of_a_value): Work on contexts rather than BINFOs.\n\t(estimate_local_effects): Likewise.\n\t(add_all_node_vals_to_toposort): Also add contexts to teir topological\n\tsort.\n\t(ipcp_propagate_stage): Also propagate effects of contexts.\n\t(ipcp_discover_new_direct_edges): Receive and pass known_contexts to\n\tipa_get_indirect_edge_target_1.\n\t(cgraph_edge_brings_value_p): New overloaded function for contexts.\n\t(create_specialized_node): Work on contexts rather than BINFOs.\n\t(find_more_contexts_for_caller_subset): New function.\n\t(known_contexts_useful_p): New function.\n\t(copy_useful_known_contexts): Likewise.\n\t(modify_known_vectors_with_val): Likewise.\n\t(ipcp_val_in_agg_replacements_p): Renamed to\n\tipcp_val_agg_replacement_ok_p, return true for all offset indicating\n\tnon-aggregate.\n\t(ipcp_val_agg_replacement_ok_p): New overloaded function for contexts.\n\t(decide_about_value): Work on contexts rather than BINFOs.\n\t(decide_whether_version_node): Likewise.\n\t(ipcp_driver): Initialize the new alloc pool.\n\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Prettify\n\tprinting of edge contexts.\n\t(ipa_set_ancestor_jf): Replace assert with conditional setting of\n\ttype_preserved to false.\n\t(update_jump_functions_after_inlining): Use access function instead of\n\treading agg_preserved directly.  Store combined context in the ancestor\n\tcase.\n\t(try_make_edge_direct_virtual_call): Work on contexts rather than\n\tBINFOs.\n\t(update_indirect_edges_after_inlining): Get context from\n\tipa_context_from_jfunc.\n\t(ipa_free_node_params_substructures): Free also known_contexts.\n\t(ipa_free_all_structures_after_ipa_cp): Free the new alloc pool.\n\t(ipa_free_all_structures_after_iinln): Likewise.\n\t* ipa-inline-analysis.c (evaluate_properties_for_edge): Work on\n\tcontexts rather than BINFOs.\n\t(estimate_edge_devirt_benefit): Likewise.\n\t(estimate_edge_size_and_time): Likewise.\n\t(estimate_calls_size_and_time): Likewise.\n\t(estimate_node_size_and_time): Likewise.\n\t(estimate_ipcp_clone_size_and_time): Likewise.\n\t(do_estimate_edge_time): Likewise.\n\t(do_estimate_edge_size): Likewise.\n\t(do_estimate_edge_hints): Likewise.\n\t* ipa-polymorphic-call.c (ipa_polymorphic_call_context::dump): New\n\tparameter newline, ouput newline only when it is set.\n\t(ipa_polymorphic_call_context::equal_to): New method.\n\ntestsuite/\n\t* g++.dg/ipa/devirt-11.C: Dont't run ipa-cp, remove times constraint\n\tfrom the dump scan.\n\t* g++.dg/ipa/devirt-21.C: Xfail.\n\t* g++.dg/ipa/devirt-24.C: Likewise.\n\t* g++.dg/ipa/devirt-10.C: Removed times constraint from the dump scan.\n\t* g++.dg/ipa/devirt-41.C: Updated the dump scan.\n\t* g++.dg/ipa/devirt-44.C: Likewise.\n\t* g++.dg/ipa/devirt-43.C: Xfail.\n\nFrom-SVN: r217587", "tree": {"sha": "abc9c56fc79fdcc18ce1542f7710341d6d75f88d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abc9c56fc79fdcc18ce1542f7710341d6d75f88d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44210a9672aed3212c0e289dddc5bd38c314290b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44210a9672aed3212c0e289dddc5bd38c314290b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44210a9672aed3212c0e289dddc5bd38c314290b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44210a9672aed3212c0e289dddc5bd38c314290b/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0cb50559966b5215b3b2901fed2d672f6594b5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0cb50559966b5215b3b2901fed2d672f6594b5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0cb50559966b5215b3b2901fed2d672f6594b5f"}], "stats": {"total": 1278, "additions": 898, "deletions": 380}, "files": [{"sha": "c42a532a222459b7b8cc4f5d205f6d49c2e3b1c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -1,3 +1,88 @@\n+2014-11-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (ipa_get_jf_pass_through_type_preserved): use\n+\tagg_preserved flag instead.\n+\t(ipa_get_jf_ancestor_type_preserved): Likewise.\n+\t(ipa_node_params): Rename known_vals to known_csts, update all users.\n+\tNew field known_contexts.\n+\t(ipa_get_indirect_edge_target): Update prototype.\n+\t(ipcp_poly_ctx_values_pool): Declare.\n+\t(ipa_context_from_jfunc): Likewise.\n+\t* ipa-inline.h (estimate_ipcp_clone_size_and_time): Updated prototype.\n+\t* cgraph.h (ipa_polymorphic_call_context): New method equal_to.  New\n+\tparameter newline of method dump.\n+\t* ipa-cp.c (ctxlat): New field.\n+\t(ipcp_values_pool): Renamed to ipcp_cst_values_pool, updated all users.\n+\t(ipcp_poly_ctx_values_pool):New variable.\n+\t(ipa_get_poly_ctx_lat): New function.\n+\t(print_ipcp_constant_value): New overloaded function for contexts.\n+\t(print_all_lattices): Also print contexts.\n+\t(ipa_topo_info): New field contexts;\n+\t(set_all_contains_variable): Also set the flag in the context lattice.\n+\t(initialize_node_lattices): Likewise for flag bottom.\n+\t(ipa_get_jf_ancestor_result): Removed BINFO handling.\n+\t(ipa_value_from_jfunc): Likewise.\n+\t(ipa_context_from_jfunc): New function.\n+\t(values_equal_for_ipcp_p): New overloaded function for contexts.\n+\t(allocate_and_init_ipcp_value): Construct the value.\n+\t(allocate_and_init_ipcp_value): New overloaded function for contexts.\n+\t(propagate_scalar_accross_jump_function): Removed handling of\n+\tKNOWN_TYPE jump functions.\n+\t(propagate_context_accross_jump_function): New function.\n+\t(propagate_constants_accross_call): Also propagate contexts.\n+\t(ipa_get_indirect_edge_target_1): Work on contexts rather than BINFOs.\n+\t(ipa_get_indirect_edge_target): Likewise.\n+\t(devirtualization_time_bonus): Likewise.\n+\t(gather_context_independent_values): Create and populate known_contexts\n+\tvector rather than known_binfos.\n+\t(perform_estimation_of_a_value): Work on contexts rather than BINFOs.\n+\t(estimate_local_effects): Likewise.\n+\t(add_all_node_vals_to_toposort): Also add contexts to teir topological\n+\tsort.\n+\t(ipcp_propagate_stage): Also propagate effects of contexts.\n+\t(ipcp_discover_new_direct_edges): Receive and pass known_contexts to\n+\tipa_get_indirect_edge_target_1.\n+\t(cgraph_edge_brings_value_p): New overloaded function for contexts.\n+\t(create_specialized_node): Work on contexts rather than BINFOs.\n+\t(find_more_contexts_for_caller_subset): New function.\n+\t(known_contexts_useful_p): New function.\n+\t(copy_useful_known_contexts): Likewise.\n+\t(modify_known_vectors_with_val): Likewise.\n+\t(ipcp_val_in_agg_replacements_p): Renamed to\n+\tipcp_val_agg_replacement_ok_p, return true for all offset indicating\n+\tnon-aggregate.\n+\t(ipcp_val_agg_replacement_ok_p): New overloaded function for contexts.\n+\t(decide_about_value): Work on contexts rather than BINFOs.\n+\t(decide_whether_version_node): Likewise.\n+\t(ipcp_driver): Initialize the new alloc pool.\n+\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Prettify\n+\tprinting of edge contexts.\n+\t(ipa_set_ancestor_jf): Replace assert with conditional setting of\n+\ttype_preserved to false.\n+\t(update_jump_functions_after_inlining): Use access function instead of\n+\treading agg_preserved directly.  Store combined context in the ancestor\n+\tcase.\n+\t(try_make_edge_direct_virtual_call): Work on contexts rather than\n+\tBINFOs.\n+\t(update_indirect_edges_after_inlining): Get context from\n+\tipa_context_from_jfunc.\n+\t(ipa_free_node_params_substructures): Free also known_contexts.\n+\t(ipa_free_all_structures_after_ipa_cp): Free the new alloc pool.\n+\t(ipa_free_all_structures_after_iinln): Likewise.\n+\t* ipa-inline-analysis.c (evaluate_properties_for_edge): Work on\n+\tcontexts rather than BINFOs.\n+\t(estimate_edge_devirt_benefit): Likewise.\n+\t(estimate_edge_size_and_time): Likewise.\n+\t(estimate_calls_size_and_time): Likewise.\n+\t(estimate_node_size_and_time): Likewise.\n+\t(estimate_ipcp_clone_size_and_time): Likewise.\n+\t(do_estimate_edge_time): Likewise.\n+\t(do_estimate_edge_size): Likewise.\n+\t(do_estimate_edge_hints): Likewise.\n+\t* ipa-polymorphic-call.c (ipa_polymorphic_call_context::dump): New\n+\tparameter newline, ouput newline only when it is set.\n+\t(ipa_polymorphic_call_context::equal_to): New method.\n+\n 2014-11-14  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-cp.c (ipcp_value_source): Converted to a template class.  All"}, {"sha": "5d949abc722b00b2c6956dd74700471a462ed353", "filename": "gcc/cgraph.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -1387,9 +1387,12 @@ class GTY(()) ipa_polymorphic_call_context {\n \n   /* Return TRUE if context is fully useless.  */\n   bool useless_p () const;\n+  /* Return TRUE if this context conveys the same information as X.  */\n+  bool equal_to (const ipa_polymorphic_call_context &x) const;\n \n-  /* Dump human readable context to F.  */\n-  void dump (FILE *f) const;\n+  /* Dump human readable context to F.  If NEWLINE is true, it will be\n+     terminated by a newline.  */\n+  void dump (FILE *f, bool newline = true) const;\n   void DEBUG_FUNCTION debug () const;\n \n   /* LTO streaming.  */"}, {"sha": "4f44c4ce61047a7d4c2e6b50f81366552a038319", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 606, "deletions": 215, "changes": 821, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -258,6 +258,8 @@ class ipcp_param_lattices\n public:\n   /* Lattice describing the value of the parameter itself.  */\n   ipcp_lattice<tree> itself;\n+  /* Lattice describing the the polymorphic contexts of a parameter.  */\n+  ipcp_lattice<ipa_polymorphic_call_context> ctxlat;\n   /* Lattices describing aggregate parts.  */\n   ipcp_agg_lattice *aggs;\n   /* Number of aggregate lattices */\n@@ -278,7 +280,8 @@ class ipcp_param_lattices\n \n /* Allocation pools for values and their sources in ipa-cp.  */\n \n-alloc_pool ipcp_values_pool;\n+alloc_pool ipcp_cst_values_pool;\n+alloc_pool ipcp_poly_ctx_values_pool;\n alloc_pool ipcp_sources_pool;\n alloc_pool ipcp_agg_lattice_pool;\n \n@@ -310,6 +313,15 @@ ipa_get_scalar_lat (struct ipa_node_params *info, int i)\n   return &plats->itself;\n }\n \n+/* Return the lattice corresponding to the scalar value of the Ith formal\n+   parameter of the function described by INFO.  */\n+static inline ipcp_lattice<ipa_polymorphic_call_context> *\n+ipa_get_poly_ctx_lat (struct ipa_node_params *info, int i)\n+{\n+  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+  return &plats->ctxlat;\n+}\n+\n /* Return whether LAT is a lattice with a single constant and without an\n    undefined value.  */\n \n@@ -343,6 +355,14 @@ print_ipcp_constant_value (FILE * f, tree v)\n     print_generic_expr (f, v, 0);\n }\n \n+/* Print V which is extracted from a value in a lattice to F.  */\n+\n+static void\n+print_ipcp_constant_value (FILE * f, ipa_polymorphic_call_context v)\n+{\n+  v.dump(f, false);\n+}\n+\n /* Print a lattice LAT to F.  */\n \n template <typename valtype>\n@@ -427,7 +447,8 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n \t  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n \t  fprintf (f, \"    param [%d]: \", i);\n \t  plats->itself.print (f, dump_sources, dump_benefits);\n-\n+\t  fprintf (f, \"         ctxs: \");\n+\t  plats->ctxlat.print (f, dump_sources, dump_benefits);\n \t  if (plats->virt_call)\n \t    fprintf (f, \"        virt_call flag set\\n\");\n \n@@ -639,6 +660,7 @@ class ipa_topo_info\n   int nnodes, stack_top;\n \n   value_topo_info<tree> constants;\n+  value_topo_info<ipa_polymorphic_call_context> contexts;\n \n   ipa_topo_info () : order(NULL), stack(NULL), nnodes(0), stack_top(0),\n     constants ()\n@@ -750,9 +772,10 @@ set_agg_lats_contain_variable (struct ipcp_param_lattices *plats)\n static inline bool\n set_all_contains_variable (struct ipcp_param_lattices *plats)\n {\n-  bool ret = !plats->itself.contains_variable || !plats->aggs_contain_variable;\n-  plats->itself.contains_variable = true;\n-  plats->aggs_contain_variable = true;\n+  bool ret;\n+  ret = plats->itself.set_contains_variable ();\n+  ret |= plats->ctxlat.set_contains_variable ();\n+  ret |= set_agg_lats_contain_variable (plats);\n   return ret;\n }\n \n@@ -787,6 +810,7 @@ initialize_node_lattices (struct cgraph_node *node)\n \t  if (disable)\n \t    {\n \t      plats->itself.set_to_bottom ();\n+\t      plats->ctxlat.set_to_bottom ();\n \t      set_agg_lats_to_bottom (plats);\n \t    }\n \t  else\n@@ -853,28 +877,8 @@ ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input)\n static tree\n ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n {\n-  if (TREE_CODE (input) == TREE_BINFO)\n-    {\n-      if (!ipa_get_jf_ancestor_type_preserved (jfunc))\n-\treturn NULL;\n-      /* FIXME: At LTO we can't propagate to non-polymorphic type, because\n-\t we have no ODR equivalency on those.  This should be fixed by\n-\t propagating on types rather than binfos that would make type\n-\t matching here unnecesary.  */\n-      if (in_lto_p\n-\t  && (TREE_CODE (ipa_get_jf_ancestor_type (jfunc)) != RECORD_TYPE\n-\t      || !TYPE_BINFO (ipa_get_jf_ancestor_type (jfunc))\n-\t      || !BINFO_VTABLE (TYPE_BINFO (ipa_get_jf_ancestor_type (jfunc)))))\n-\t{\n-\t  if (!ipa_get_jf_ancestor_offset (jfunc))\n-\t    return input;\n-\t  return NULL;\n-\t}\n-      return get_binfo_at_offset (input,\n-\t\t\t\t  ipa_get_jf_ancestor_offset (jfunc),\n-\t\t\t\t  ipa_get_jf_ancestor_type (jfunc));\n-    }\n-  else if (TREE_CODE (input) == ADDR_EXPR)\n+  gcc_checking_assert (TREE_CODE (input) != TREE_BINFO);\n+  if (TREE_CODE (input) == ADDR_EXPR)\n     {\n       tree t = TREE_OPERAND (input, 0);\n       t = build_ref_for_offset (EXPR_LOCATION (t), t,\n@@ -888,18 +892,16 @@ ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n     return NULL_TREE;\n }\n \n-/* Determine whether JFUNC evaluates to a known value (that is either a\n-   constant or a binfo) and if so, return it.  Otherwise return NULL. INFO\n-   describes the caller node so that pass-through jump functions can be\n+/* Determine whether JFUNC evaluates to a single known constant value and if\n+   so, return it.  Otherwise return NULL.  INFO describes the caller node or\n+   the one it is inlined to, so that pass-through jump functions can be\n    evaluated.  */\n \n tree\n ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n {\n   if (jfunc->type == IPA_JF_CONST)\n     return ipa_get_jf_constant (jfunc);\n-  else if (jfunc->type == IPA_JF_KNOWN_TYPE)\n-    return ipa_binfo_from_known_type_jfunc (jfunc);\n   else if (jfunc->type == IPA_JF_PASS_THROUGH\n \t   || jfunc->type == IPA_JF_ANCESTOR)\n     {\n@@ -912,7 +914,7 @@ ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n \tidx = ipa_get_jf_ancestor_formal_id (jfunc);\n \n       if (info->ipcp_orig_node)\n-\tinput = info->known_vals[idx];\n+\tinput = info->known_csts[idx];\n       else\n \t{\n \t  ipcp_lattice<tree> *lat;\n@@ -940,6 +942,68 @@ ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n     return NULL_TREE;\n }\n \n+/* Determie whether JFUNC evaluates to single known polymorphic context, given\n+   that INFO describes the caller node or the one it is inlined to, CS is the\n+   call graph edge corresponding to JFUNC and CSIDX index of the described\n+   parameter.  */\n+\n+ipa_polymorphic_call_context\n+ipa_context_from_jfunc (ipa_node_params *info, cgraph_edge *cs, int csidx,\n+\t\t\tipa_jump_func *jfunc)\n+{\n+  ipa_edge_args *args = IPA_EDGE_REF (cs);\n+  ipa_polymorphic_call_context ctx;\n+  ipa_polymorphic_call_context *edge_ctx\n+    = cs ? ipa_get_ith_polymorhic_call_context (args, csidx) : NULL;\n+\n+  if (edge_ctx && !edge_ctx->useless_p ())\n+    ctx = *edge_ctx;\n+\n+  if (jfunc->type == IPA_JF_PASS_THROUGH\n+      || jfunc->type == IPA_JF_ANCESTOR)\n+    {\n+      ipa_polymorphic_call_context srcctx;\n+      int srcidx;\n+      if (jfunc->type == IPA_JF_PASS_THROUGH)\n+\t{\n+\t  if (ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR\n+\t      || !ipa_get_jf_pass_through_type_preserved (jfunc))\n+\t    return ctx;\n+\t  srcidx = ipa_get_jf_pass_through_formal_id (jfunc);\n+\t}\n+      else\n+\t{\n+\t  if (!ipa_get_jf_ancestor_type_preserved (jfunc))\n+\t    return ctx;\n+\t  srcidx = ipa_get_jf_ancestor_formal_id (jfunc);\n+\t}\n+      if (info->ipcp_orig_node)\n+\t{\n+\t  if (info->known_contexts.exists ())\n+\t    srcctx = info->known_contexts[srcidx];\n+\t}\n+      else\n+\t{\n+\t  if (!info->lattices)\n+\t    {\n+\t      gcc_checking_assert (!flag_ipa_cp);\n+\t      return ctx;\n+\t    }\n+\t  ipcp_lattice<ipa_polymorphic_call_context> *lat;\n+\t  lat = ipa_get_poly_ctx_lat (info, srcidx);\n+\t  if (!lat->is_single_const ())\n+\t    return ctx;\n+\t  srcctx = lat->values->value;\n+\t}\n+      if (srcctx.useless_p ())\n+\treturn ctx;\n+      if (jfunc->type == IPA_JF_ANCESTOR)\n+\tsrcctx.offset_by (ipa_get_jf_ancestor_offset (jfunc));\n+      ctx.combine_with (srcctx);\n+    }\n+\n+  return ctx;\n+}\n \n /* If checking is enabled, verify that no lattice is in the TOP state, i.e. not\n    bottom, not containing a variable component and without any known value at\n@@ -1000,6 +1064,16 @@ values_equal_for_ipcp_p (tree x, tree y)\n     return operand_equal_p (x, y, 0);\n }\n \n+/* Return true iff X and Y should be considered equal contexts by IPA-CP.  */\n+\n+static bool\n+values_equal_for_ipcp_p (ipa_polymorphic_call_context x,\n+\t\t\t ipa_polymorphic_call_context y)\n+{\n+  return x.equal_to (y);\n+}\n+\n+\n /* Add a new value source to the value represented by THIS, marking that a\n    value comes from edge CS and (if the underlying jump function is a\n    pass-through or an ancestor one) from a caller value SRC_VAL of a caller\n@@ -1031,7 +1105,22 @@ allocate_and_init_ipcp_value (tree source)\n {\n   ipcp_value<tree> *val;\n \n-  val = new (pool_alloc (ipcp_values_pool)) ipcp_value<tree>;\n+  val = new (pool_alloc (ipcp_cst_values_pool)) ipcp_value<tree>;\n+  memset (val, 0, sizeof (*val));\n+  val->value = source;\n+  return val;\n+}\n+\n+/* Allocate a new ipcp_value holding a polymorphic context, initialize its\n+   value to SOURCE and clear all other fields.  */\n+\n+static ipcp_value<ipa_polymorphic_call_context> *\n+allocate_and_init_ipcp_value (ipa_polymorphic_call_context source)\n+{\n+  ipcp_value<ipa_polymorphic_call_context> *val;\n+\n+  val = new (pool_alloc (ipcp_poly_ctx_values_pool))\n+    ipcp_value<ipa_polymorphic_call_context>;\n   memset (val, 0, sizeof (*val));\n   val->value = source;\n   return val;\n@@ -1171,19 +1260,9 @@ propagate_scalar_accross_jump_function (struct cgraph_edge *cs,\n   if (dest_lat->bottom)\n     return false;\n \n-  if (jfunc->type == IPA_JF_CONST\n-      || jfunc->type == IPA_JF_KNOWN_TYPE)\n+  if (jfunc->type == IPA_JF_CONST)\n     {\n-      tree val;\n-\n-      if (jfunc->type == IPA_JF_KNOWN_TYPE)\n-\t{\n-\t  val = ipa_binfo_from_known_type_jfunc (jfunc);\n-\t  if (!val)\n-\t    return dest_lat->set_contains_variable ();\n-\t}\n-      else\n-\tval = ipa_get_jf_constant (jfunc);\n+      tree val = ipa_get_jf_constant (jfunc);\n       return dest_lat->add_value (val, cs, NULL, 0);\n     }\n   else if (jfunc->type == IPA_JF_PASS_THROUGH\n@@ -1227,6 +1306,93 @@ propagate_scalar_accross_jump_function (struct cgraph_edge *cs,\n   return dest_lat->set_contains_variable ();\n }\n \n+/* Propagate scalar values across jump function JFUNC that is associated with\n+   edge CS and describes argument IDX and put the values into DEST_LAT.  */\n+\n+static bool\n+propagate_context_accross_jump_function (cgraph_edge *cs,\n+\t\t\t  ipa_jump_func *jfunc, int idx,\n+\t\t\t  ipcp_lattice<ipa_polymorphic_call_context> *dest_lat)\n+{\n+  ipa_edge_args *args = IPA_EDGE_REF (cs);\n+  if (dest_lat->bottom)\n+    return false;\n+  bool ret = false;\n+  bool added_sth = false;\n+\n+  ipa_polymorphic_call_context edge_ctx, *edge_ctx_ptr\n+    = ipa_get_ith_polymorhic_call_context (args, idx);\n+\n+  if (edge_ctx_ptr)\n+    {\n+      edge_ctx = *edge_ctx_ptr;\n+      edge_ctx.clear_speculation ();\n+    }\n+\n+  if (jfunc->type == IPA_JF_PASS_THROUGH\n+      || jfunc->type == IPA_JF_ANCESTOR)\n+    {\n+      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      int src_idx;\n+      ipcp_lattice<ipa_polymorphic_call_context> *src_lat;\n+\n+      /* TODO: Once we figure out how to propagate speculations, it will\n+\t probably be a good idea to switch to speculation if type_preserved is\n+\t not set instead of punting.  */\n+      if (jfunc->type == IPA_JF_PASS_THROUGH)\n+\t{\n+\t  if (ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR\n+\t      || !ipa_get_jf_pass_through_type_preserved (jfunc))\n+\t    goto prop_fail;\n+\t  src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n+\t}\n+      else\n+\t{\n+\t  if (!ipa_get_jf_ancestor_type_preserved (jfunc))\n+\t    goto prop_fail;\n+\t  src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n+\t}\n+\n+      src_lat = ipa_get_poly_ctx_lat (caller_info, src_idx);\n+      /* If we would need to clone the caller and cannot, do not propagate.  */\n+      if (!ipcp_versionable_function_p (cs->caller)\n+\t  && (src_lat->contains_variable\n+\t      || (src_lat->values_count > 1)))\n+\tgoto prop_fail;\n+      if (src_lat->contains_variable)\n+\t  ret |= dest_lat->set_contains_variable ();\n+\n+      ipcp_value<ipa_polymorphic_call_context> *src_val;\n+      for (src_val = src_lat->values; src_val; src_val = src_val->next)\n+\t{\n+\t  ipa_polymorphic_call_context cur = src_val->value;\n+\t  if (jfunc->type == IPA_JF_ANCESTOR)\n+\t    cur.offset_by (ipa_get_jf_ancestor_offset (jfunc));\n+\t  /* TODO: Perhaps attempt to look up some used OTR type? */\n+\t  cur.clear_speculation ();\n+\t  if (!edge_ctx.useless_p ())\n+\t    cur.combine_with (edge_ctx);\n+\t  if (!cur.useless_p ())\n+\t    {\n+\t      ret |= dest_lat->add_value (cur, cs, src_val, src_idx);\n+\t      added_sth = true;\n+\t    }\n+\t}\n+\n+    }\n+\n+ prop_fail:\n+  if (!added_sth)\n+    {\n+      if (!edge_ctx.useless_p ())\n+\tret |= dest_lat->add_value (edge_ctx, cs);\n+      else\n+\tret |= dest_lat->set_contains_variable ();\n+    }\n+\n+  return ret;\n+}\n+\n /* If DEST_PLATS already has aggregate items, check that aggs_by_ref matches\n    NEW_AGGS_BY_REF and if not, mark all aggs as bottoms and return true (in all\n    other cases, return false).  If there are no aggregate items, set\n@@ -1561,6 +1727,8 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n \t{\n \t  ret |= propagate_scalar_accross_jump_function (cs, jump_func,\n \t\t\t\t\t\t\t &dest_plats->itself);\n+\t  ret |= propagate_context_accross_jump_function (cs, jump_func, i,\n+\t\t\t\t\t\t\t  &dest_plats->ctxlat);\n \t  ret |= propagate_aggs_accross_jump_function (cs, jump_func,\n \t\t\t\t\t\t       dest_plats);\n \t}\n@@ -1572,25 +1740,24 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n }\n \n /* If an indirect edge IE can be turned into a direct one based on KNOWN_VALS\n-   (which can contain both constants and binfos), KNOWN_BINFOS, KNOWN_AGGS or\n+   (which can contain both constants and binfos), KNOWN_CONTEXTS, KNOWN_AGGS or\n    AGG_REPS return the destination.  The latter three can be NULL.  If AGG_REPS\n    is not NULL, KNOWN_AGGS is ignored.  */\n \n static tree\n ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n-\t\t\t\tvec<tree> known_vals,\n-\t\t\t\tvec<tree> known_binfos,\n+\t\t\t\tvec<tree> known_csts,\n+\t\t\t\tvec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t\tvec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t\tstruct ipa_agg_replacement_value *agg_reps)\n {\n   int param_index = ie->indirect_info->param_index;\n-  HOST_WIDE_INT token, anc_offset;\n-  tree otr_type;\n+  HOST_WIDE_INT anc_offset;\n   tree t;\n   tree target = NULL;\n \n   if (param_index == -1\n-      || known_vals.length () <= (unsigned int) param_index)\n+      || known_csts.length () <= (unsigned int) param_index)\n     return NULL_TREE;\n \n   if (!ie->indirect_info->polymorphic)\n@@ -1625,7 +1792,7 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t    t = NULL;\n \t}\n       else\n-\tt = known_vals[param_index];\n+\tt = known_csts[param_index];\n \n       if (t &&\n \t  TREE_CODE (t) == ADDR_EXPR\n@@ -1639,9 +1806,7 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n     return NULL_TREE;\n \n   gcc_assert (!ie->indirect_info->agg_contents);\n-  token = ie->indirect_info->otr_token;\n   anc_offset = ie->indirect_info->offset;\n-  otr_type = ie->indirect_info->otr_type;\n \n   t = NULL;\n \n@@ -1695,42 +1860,43 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t}\n     }\n \n-  /* Did we work out BINFO via type propagation?  */\n-  if (!t && known_binfos.length () > (unsigned int) param_index)\n-    t = known_binfos[param_index];\n-  /* Or do we know the constant value of pointer?  */\n+  /* Do we know the constant value of pointer?  */\n   if (!t)\n-    t = known_vals[param_index];\n-  if (!t)\n-    return NULL_TREE;\n+    t = known_csts[param_index];\n \n-  if (TREE_CODE (t) != TREE_BINFO)\n+  gcc_checking_assert (!t || TREE_CODE (t) != TREE_BINFO);\n+\n+  ipa_polymorphic_call_context context;\n+  if (known_contexts.length () > (unsigned int) param_index)\n     {\n-      ipa_polymorphic_call_context context (t, ie->indirect_info->otr_type,\n-\t\t\t\t\t    anc_offset);\n-      vec <cgraph_node *>targets;\n-      bool final;\n-\n-      targets = possible_polymorphic_call_targets\n-\t\t (ie->indirect_info->otr_type,\n-\t\t  ie->indirect_info->otr_token,\n-\t\t  context, &final);\n-      if (!final || targets.length () > 1)\n-\treturn NULL_TREE;\n-      if (targets.length () == 1)\n-\ttarget = targets[0]->decl;\n-      else\n-\ttarget = ipa_impossible_devirt_target (ie, NULL_TREE);\n+      context = known_contexts[param_index];\n+      if (t)\n+\t{\n+\t  ipa_polymorphic_call_context ctx2 = ipa_polymorphic_call_context\n+\t    (t, ie->indirect_info->otr_type, anc_offset);\n+\t  if (!ctx2.useless_p ())\n+\t    context.combine_with (ctx2, ie->indirect_info->otr_type);\n+\t}\n     }\n+  else if (t)\n+    context = ipa_polymorphic_call_context (t, ie->indirect_info->otr_type,\n+\t\t\t\t\t    anc_offset);\n   else\n-    {\n-      tree binfo;\n+    return NULL_TREE;\n \n-      binfo = get_binfo_at_offset (t, anc_offset, otr_type);\n-      if (!binfo)\n-\treturn NULL_TREE;\n-      target = gimple_get_virt_method_for_binfo (token, binfo);\n-    }\n+  vec <cgraph_node *>targets;\n+  bool final;\n+\n+  targets = possible_polymorphic_call_targets\n+    (ie->indirect_info->otr_type,\n+     ie->indirect_info->otr_token,\n+     context, &final);\n+  if (!final || targets.length () > 1)\n+    return NULL_TREE;\n+  if (targets.length () == 1)\n+    target = targets[0]->decl;\n+  else\n+    target = ipa_impossible_devirt_target (ie, NULL_TREE);\n \n   if (target && !possible_polymorphic_call_target_p (ie,\n \t\t\t\t\t\t     cgraph_node::get (target)))\n@@ -1740,27 +1906,27 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n }\n \n \n-/* If an indirect edge IE can be turned into a direct one based on KNOWN_VALS\n-   (which can contain both constants and binfos), KNOWN_BINFOS (which can be\n-   NULL) or KNOWN_AGGS (which also can be NULL) return the destination.  */\n+/* If an indirect edge IE can be turned into a direct one based on KNOWN_CSTS,\n+   KNOWN_CONTEXTS (which can be vNULL) or KNOWN_AGGS (which also can be vNULL)\n+   return the destination.  */\n \n tree\n ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n-\t\t\t      vec<tree> known_vals,\n-\t\t\t      vec<tree> known_binfos,\n+\t\t\t      vec<tree> known_csts,\n+\t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t      vec<ipa_agg_jump_function_p> known_aggs)\n {\n-  return ipa_get_indirect_edge_target_1 (ie, known_vals, known_binfos,\n+  return ipa_get_indirect_edge_target_1 (ie, known_csts, known_contexts,\n \t\t\t\t\t known_aggs, NULL);\n }\n \n /* Calculate devirtualization time bonus for NODE, assuming we know KNOWN_CSTS\n-   and KNOWN_BINFOS.  */\n+   and KNOWN_CONTEXTS.  */\n \n static int\n devirtualization_time_bonus (struct cgraph_node *node,\n \t\t\t     vec<tree> known_csts,\n-\t\t\t     vec<tree> known_binfos,\n+\t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs)\n {\n   struct cgraph_edge *ie;\n@@ -1773,7 +1939,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       enum availability avail;\n       tree target;\n \n-      target = ipa_get_indirect_edge_target (ie, known_csts, known_binfos,\n+      target = ipa_get_indirect_edge_target (ie, known_csts, known_contexts,\n \t\t\t\t\t     known_aggs);\n       if (!target)\n \tcontinue;\n@@ -1890,25 +2056,27 @@ context_independent_aggregate_values (struct ipcp_param_lattices *plats)\n   return res;\n }\n \n-/* Allocate KNOWN_CSTS, KNOWN_BINFOS and, if non-NULL, KNOWN_AGGS and populate\n-   them with values of parameters that are known independent of the context.\n-   INFO describes the function.  If REMOVABLE_PARAMS_COST is non-NULL, the\n-   movement cost of all removable parameters will be stored in it.  */\n+/* Allocate KNOWN_CSTS, KNOWN_CONTEXTS and, if non-NULL, KNOWN_AGGS and\n+   populate them with values of parameters that are known independent of the\n+   context.  INFO describes the function.  If REMOVABLE_PARAMS_COST is\n+   non-NULL, the movement cost of all removable parameters will be stored in\n+   it.  */\n \n static bool\n gather_context_independent_values (struct ipa_node_params *info,\n-\t\t\t       vec<tree> *known_csts,\n-\t\t\t       vec<tree> *known_binfos,\n-\t\t\t       vec<ipa_agg_jump_function> *known_aggs,\n-\t\t\t       int *removable_params_cost)\n+\t\t\t\t   vec<tree> *known_csts,\n+\t\t\t\t   vec<ipa_polymorphic_call_context>\n+\t\t\t\t   *known_contexts,\n+\t\t\t\t   vec<ipa_agg_jump_function> *known_aggs,\n+\t\t\t\t   int *removable_params_cost)\n {\n   int i, count = ipa_get_param_count (info);\n   bool ret = false;\n \n   known_csts->create (0);\n-  known_binfos->create (0);\n+  known_contexts->create (0);\n   known_csts->safe_grow_cleared (count);\n-  known_binfos->safe_grow_cleared (count);\n+  known_contexts->safe_grow_cleared (count);\n   if (known_aggs)\n     {\n       known_aggs->create (0);\n@@ -1926,28 +2094,25 @@ gather_context_independent_values (struct ipa_node_params *info,\n       if (lat->is_single_const ())\n \t{\n \t  ipcp_value<tree> *val = lat->values;\n-\t  if (TREE_CODE (val->value) != TREE_BINFO)\n-\t    {\n-\t      (*known_csts)[i] = val->value;\n-\t      if (removable_params_cost)\n-\t\t*removable_params_cost\n-\t\t  += estimate_move_cost (TREE_TYPE (val->value), false);\n-\t      ret = true;\n-\t    }\n-\t  else if (plats->virt_call)\n-\t    {\n-\t      (*known_binfos)[i] = val->value;\n-\t      ret = true;\n-\t    }\n-\t  else if (removable_params_cost\n-\t\t   && !ipa_is_param_used (info, i))\n-\t    *removable_params_cost += ipa_get_param_move_cost (info, i);\n+\t  gcc_checking_assert (TREE_CODE (val->value) != TREE_BINFO);\n+\t  (*known_csts)[i] = val->value;\n+\t  if (removable_params_cost)\n+\t    *removable_params_cost\n+\t      += estimate_move_cost (TREE_TYPE (val->value), false);\n+\t  ret = true;\n \t}\n       else if (removable_params_cost\n \t       && !ipa_is_param_used (info, i))\n \t*removable_params_cost\n \t  += ipa_get_param_move_cost (info, i);\n \n+      ipcp_lattice<ipa_polymorphic_call_context> *ctxlat = &plats->ctxlat;\n+      if (ctxlat->is_single_const ())\n+\t{\n+\t  (*known_contexts)[i] = ctxlat->values->value;\n+\t  ret = true;\n+\t}\n+\n       if (known_aggs)\n \t{\n \t  vec<ipa_agg_jf_item, va_gc> *agg_items;\n@@ -1985,26 +2150,26 @@ agg_jmp_p_vec_for_t_vec (vec<ipa_agg_jump_function> known_aggs)\n }\n \n /* Perform time and size measurement of NODE with the context given in\n-   KNOWN_CSTS, KNOWN_BINFOS and KNOWN_AGGS, calculate the benefit and cost\n+   KNOWN_CSTS, KNOWN_CONTEXTS and KNOWN_AGGS, calculate the benefit and cost\n    given BASE_TIME of the node without specialization, REMOVABLE_PARAMS_COST of\n    all context-independent removable parameters and EST_MOVE_COST of estimated\n    movement of the considered parameter and store it into VAL.  */\n \n static void\n perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n-\t\t\t       vec<tree> known_binfos,\n+\t\t\t       vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t       vec<ipa_agg_jump_function_p> known_aggs_ptrs,\n \t\t\t       int base_time, int removable_params_cost,\n \t\t\t       int est_move_cost, ipcp_value_base *val)\n {\n   int time, size, time_benefit;\n   inline_hints hints;\n \n-  estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n+  estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,\n \t\t\t\t     known_aggs_ptrs, &size, &time,\n \t\t\t\t     &hints);\n   time_benefit = base_time - time\n-    + devirtualization_time_bonus (node, known_csts, known_binfos,\n+    + devirtualization_time_bonus (node, known_csts, known_contexts,\n \t\t\t\t   known_aggs_ptrs)\n     + hint_time_bonus (hints)\n     + removable_params_cost + est_move_cost;\n@@ -2029,7 +2194,8 @@ estimate_local_effects (struct cgraph_node *node)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n-  vec<tree> known_csts, known_binfos;\n+  vec<tree> known_csts;\n+  vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function> known_aggs;\n   vec<ipa_agg_jump_function_p> known_aggs_ptrs;\n   bool always_const;\n@@ -2044,7 +2210,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t     node->name (), node->order, base_time);\n \n   always_const = gather_context_independent_values (info, &known_csts,\n-\t\t\t\t\t\t    &known_binfos, &known_aggs,\n+\t\t\t\t\t\t    &known_contexts, &known_aggs,\n \t\t\t\t\t\t    &removable_params_cost);\n   known_aggs_ptrs = agg_jmp_p_vec_for_t_vec (known_aggs);\n   if (always_const)\n@@ -2056,9 +2222,9 @@ estimate_local_effects (struct cgraph_node *node)\n       init_caller_stats (&stats);\n       node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats,\n \t\t\t\t\t      false);\n-      estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n+      estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,\n \t\t\t\t\t known_aggs_ptrs, &size, &time, &hints);\n-      time -= devirtualization_time_bonus (node, known_csts, known_binfos,\n+      time -= devirtualization_time_bonus (node, known_csts, known_contexts,\n \t\t\t\t\t   known_aggs_ptrs);\n       time -= hint_time_bonus (hints);\n       time -= removable_params_cost;\n@@ -2104,32 +2270,19 @@ estimate_local_effects (struct cgraph_node *node)\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n       ipcp_value<tree> *val;\n-      int emc;\n \n       if (lat->bottom\n \t  || !lat->values\n-\t  || known_csts[i]\n-\t  || known_binfos[i])\n+\t  || known_csts[i])\n \tcontinue;\n \n       for (val = lat->values; val; val = val->next)\n \t{\n-\t  if (TREE_CODE (val->value) != TREE_BINFO)\n-\t    {\n-\t      known_csts[i] = val->value;\n-\t      known_binfos[i] = NULL_TREE;\n-\t      emc = estimate_move_cost (TREE_TYPE (val->value), true);\n-\t    }\n-\t  else if (plats->virt_call)\n-\t    {\n-\t      known_csts[i] = NULL_TREE;\n-\t      known_binfos[i] = val->value;\n-\t      emc = 0;\n-\t    }\n-\t  else\n-\t    continue;\n+\t  gcc_checking_assert (TREE_CODE (val->value) != TREE_BINFO);\n+\t  known_csts[i] = val->value;\n \n-\t  perform_estimation_of_a_value (node, known_csts, known_binfos,\n+\t  int emc = estimate_move_cost (TREE_TYPE (val->value), true);\n+\t  perform_estimation_of_a_value (node, known_csts, known_contexts,\n \t\t\t\t\t known_aggs_ptrs, base_time,\n \t\t\t\t\t removable_params_cost, emc, val);\n \n@@ -2143,10 +2296,44 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t       val->local_time_benefit, val->local_size_cost);\n \t    }\n \t}\n-      known_binfos[i] = NULL_TREE;\n       known_csts[i] = NULL_TREE;\n     }\n \n+  for (i = 0; i < count; i++)\n+    {\n+      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+\n+      if (!plats->virt_call)\n+\tcontinue;\n+\n+      ipcp_lattice<ipa_polymorphic_call_context> *ctxlat = &plats->ctxlat;\n+      ipcp_value<ipa_polymorphic_call_context> *val;\n+\n+      if (ctxlat->bottom\n+\t  || !ctxlat->values\n+\t  || !known_contexts[i].useless_p ())\n+\tcontinue;\n+\n+      for (val = ctxlat->values; val; val = val->next)\n+\t{\n+\t  known_contexts[i] = val->value;\n+\t  perform_estimation_of_a_value (node, known_csts, known_contexts,\n+\t\t\t\t\t known_aggs_ptrs, base_time,\n+\t\t\t\t\t removable_params_cost, 0, val);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \" - estimates for polymorphic context \");\n+\t      print_ipcp_constant_value (dump_file, val->value);\n+\t      fprintf (dump_file, \" for \");\n+\t      ipa_dump_param (dump_file, info, i);\n+\t      fprintf (dump_file, \": time_benefit: %i, size: %i\\n\",\n+\t\t       val->local_time_benefit, val->local_size_cost);\n+\t    }\n+\t}\n+      known_contexts[i] = ipa_polymorphic_call_context ();\n+    }\n+\n   for (i = 0; i < count ; i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n@@ -2174,7 +2361,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t      item.value = val->value;\n \t      vec_safe_push (ajf->items, item);\n \n-\t      perform_estimation_of_a_value (node, known_csts, known_binfos,\n+\t      perform_estimation_of_a_value (node, known_csts, known_contexts,\n \t\t\t\t\t     known_aggs_ptrs, base_time,\n \t\t\t\t\t     removable_params_cost, 0, val);\n \n@@ -2200,7 +2387,7 @@ estimate_local_effects (struct cgraph_node *node)\n     vec_free (known_aggs[i].items);\n \n   known_csts.release ();\n-  known_binfos.release ();\n+  known_contexts.release ();\n   known_aggs.release ();\n   known_aggs_ptrs.release ();\n }\n@@ -2274,17 +2461,30 @@ add_all_node_vals_to_toposort (cgraph_node *node, ipa_topo_info *topo)\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n       struct ipcp_agg_lattice *aglat;\n-      ipcp_value<tree> *val;\n \n       if (!lat->bottom)\n-\tfor (val = lat->values; val; val = val->next)\n-\t  topo->constants.add_val (val);\n+\t{\n+\t  ipcp_value<tree> *val;\n+\t  for (val = lat->values; val; val = val->next)\n+\t    topo->constants.add_val (val);\n+\t}\n \n       if (!plats->aggs_bottom)\n \tfor (aglat = plats->aggs; aglat; aglat = aglat->next)\n \t  if (!aglat->bottom)\n-\t    for (val = aglat->values; val; val = val->next)\n-\t      topo->constants.add_val (val);\n+\t    {\n+\t      ipcp_value<tree> *val;\n+\t      for (val = aglat->values; val; val = val->next)\n+\t\ttopo->constants.add_val (val);\n+\t    }\n+\n+      ipcp_lattice<ipa_polymorphic_call_context> *ctxlat = &plats->ctxlat;\n+      if (!ctxlat->bottom)\n+\t{\n+\t  ipcp_value<ipa_polymorphic_call_context> *ctxval;\n+\t  for (ctxval = ctxlat->values; ctxval; ctxval = ctxval->next)\n+\t    topo->contexts.add_val (ctxval);\n+\t}\n     }\n }\n \n@@ -2389,8 +2589,8 @@ value_topo_info<valtype>::propagate_effects ()\n }\n \n \n-/* Propagate constants, binfos and their effects from the summaries\n-   interprocedurally.  */\n+/* Propagate constants, polymorphic contexts and their effects from the\n+   summaries interprocedurally.  */\n \n static void\n ipcp_propagate_stage (struct ipa_topo_info *topo)\n@@ -2435,6 +2635,7 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n   ipcp_verify_propagated_values ();\n #endif\n   topo->constants.propagate_effects ();\n+  topo->contexts.propagate_effects ();\n \n   if (dump_file)\n     {\n@@ -2444,11 +2645,13 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n }\n \n /* Discover newly direct outgoing edges from NODE which is a new clone with\n-   known KNOWN_VALS and make them direct.  */\n+   known KNOWN_CSTS and make them direct.  */\n \n static void\n ipcp_discover_new_direct_edges (struct cgraph_node *node,\n-\t\t\t\tvec<tree> known_vals,\n+\t\t\t\tvec<tree> known_csts,\n+\t\t\t\tvec<ipa_polymorphic_call_context>\n+\t\t\t\tknown_contexts,\n \t\t\t\tstruct ipa_agg_replacement_value *aggvals)\n {\n   struct cgraph_edge *ie, *next_ie;\n@@ -2459,8 +2662,8 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n       tree target;\n \n       next_ie = ie->next_callee;\n-      target = ipa_get_indirect_edge_target_1 (ie, known_vals, vNULL, vNULL,\n-\t\t\t\t\t       aggvals);\n+      target = ipa_get_indirect_edge_target_1 (ie, known_csts, known_contexts,\n+\t\t\t\t\t       vNULL, aggvals);\n       if (target)\n \t{\n \t  bool agg_contents = ie->indirect_info->agg_contents;\n@@ -2589,7 +2792,7 @@ cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n     {\n       tree t;\n       if (src->offset == -1)\n-\tt = caller_info->known_vals[src->index];\n+\tt = caller_info->known_csts[src->index];\n       else\n \tt = get_clone_agg_value (cs->caller, src->offset, src->index);\n       return (t != NULL_TREE\n@@ -2618,6 +2821,35 @@ cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n     }\n }\n \n+/* Return true if edge CS does bring about the value described by SRC.  */\n+\n+static bool\n+cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n+\t\t\t    ipcp_value_source<ipa_polymorphic_call_context>\n+\t\t\t    *src)\n+{\n+  struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+  cgraph_node *real_dest = cs->callee->function_symbol ();\n+  struct ipa_node_params *dst_info = IPA_NODE_REF (real_dest);\n+\n+  if ((dst_info->ipcp_orig_node && !dst_info->is_all_contexts_clone)\n+      || caller_info->node_dead)\n+    return false;\n+  if (!src->val)\n+    return true;\n+\n+  if (caller_info->ipcp_orig_node)\n+    return (caller_info->known_contexts.length () > (unsigned) src->index)\n+      && values_equal_for_ipcp_p (src->val->value,\n+\t\t\t\t  caller_info->known_contexts[src->index]);\n+\n+  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (caller_info,\n+\t\t\t\t\t\t\t     src->index);\n+  return plats->ctxlat.is_single_const ()\n+    && values_equal_for_ipcp_p (src->val->value,\n+\t\t\t\tplats->ctxlat.values->value);\n+}\n+\n /* Get the next clone in the linked list of clones of an edge.  */\n \n static inline struct cgraph_edge *\n@@ -2847,12 +3079,14 @@ update_specialized_profile (struct cgraph_node *new_node,\n     dump_profile_updates (orig_node, new_node);\n }\n \n-/* Create a specialized version of NODE with known constants and types of\n-   parameters in KNOWN_VALS and redirect all edges in CALLERS to it.  */\n+/* Create a specialized version of NODE with known constants in KNOWN_CSTS,\n+   known contexts in KNOWN_CONTEXTS and known aggregate values in AGGVALS and\n+   redirect all edges in CALLERS to it.  */\n \n static struct cgraph_node *\n create_specialized_node (struct cgraph_node *node,\n-\t\t\t vec<tree> known_vals,\n+\t\t\t vec<tree> known_csts,\n+\t\t\t vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t struct ipa_agg_replacement_value *aggvals,\n \t\t\t vec<cgraph_edge *> callers)\n {\n@@ -2870,10 +3104,9 @@ create_specialized_node (struct cgraph_node *node,\n       args_to_skip = BITMAP_GGC_ALLOC ();\n       for (i = 0; i < count; i++)\n \t{\n-\t  tree t = known_vals[i];\n+\t  tree t = known_csts[i];\n \n-\t  if ((t && TREE_CODE (t) != TREE_BINFO)\n-\t      || !ipa_is_param_used (info, i))\n+\t  if (t || !ipa_is_param_used (info, i))\n \t    bitmap_set_bit (args_to_skip, i);\n \t}\n     }\n@@ -2886,11 +3119,12 @@ create_specialized_node (struct cgraph_node *node,\n \n   for (i = 0; i < count ; i++)\n     {\n-      tree t = known_vals[i];\n-      if (t && TREE_CODE (t) != TREE_BINFO)\n+      tree t = known_csts[i];\n+      if (t)\n \t{\n \t  struct ipa_replace_map *replace_map;\n \n+\t  gcc_checking_assert (TREE_CODE (t) != TREE_BINFO);\n \t  replace_map = get_replacement_map (info, t, i);\n \t  if (replace_map)\n \t    vec_safe_push (replace_trees, replace_map);\n@@ -2907,28 +3141,37 @@ create_specialized_node (struct cgraph_node *node,\n     {\n       fprintf (dump_file, \"     the new node is %s/%i.\\n\",\n \t       new_node->name (), new_node->order);\n+      if (known_contexts.exists ())\n+\t{\n+\t  for (i = 0; i < count ; i++)\n+\t    if (!known_contexts[i].useless_p ())\n+\t      {\n+\t\tfprintf (dump_file, \"     known ctx %i is \", i);\n+\t\tknown_contexts[i].dump (dump_file);\n+\t      }\n+\t}\n       if (aggvals)\n \tipa_dump_agg_replacement_values (dump_file, aggvals);\n     }\n   ipa_check_create_node_params ();\n   update_profiling_info (node, new_node);\n   new_info = IPA_NODE_REF (new_node);\n   new_info->ipcp_orig_node = node;\n-  new_info->known_vals = known_vals;\n+  new_info->known_csts = known_csts;\n+  new_info->known_contexts = known_contexts;\n \n-  ipcp_discover_new_direct_edges (new_node, known_vals, aggvals);\n+  ipcp_discover_new_direct_edges (new_node, known_csts, known_contexts, aggvals);\n \n   callers.release ();\n   return new_node;\n }\n \n /* Given a NODE, and a subset of its CALLERS, try to populate blanks slots in\n-   KNOWN_VALS with constants and types that are also known for all of the\n-   CALLERS.  */\n+   KNOWN_CSTS with constants that are also known for all of the CALLERS.  */\n \n static void\n find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n-\t\t\t\t\t    vec<tree> known_vals,\n+\t\t\t\t\t    vec<tree> known_csts,\n \t\t\t\t\t    vec<cgraph_edge *> callers)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n@@ -2940,7 +3183,7 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n       tree newval = NULL_TREE;\n       int j;\n \n-      if (ipa_get_scalar_lat (info, i)->bottom || known_vals[i])\n+      if (ipa_get_scalar_lat (info, i)->bottom || known_csts[i])\n \tcontinue;\n \n       FOR_EACH_VEC_ELT (callers, j, cs)\n@@ -2977,11 +3220,80 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  known_vals[i] = newval;\n+\t  known_csts[i] = newval;\n \t}\n     }\n }\n \n+/* Given a NODE and a subset of its CALLERS, try to populate plank slots in\n+   KNOWN_CONTEXTS with polymorphic contexts that are also known for all of the\n+   CALLERS.  */\n+\n+static void\n+find_more_contexts_for_caller_subset (cgraph_node *node,\n+\t\t\t\t      vec<ipa_polymorphic_call_context>\n+\t\t\t\t      *known_contexts,\n+\t\t\t\t      vec<cgraph_edge *> callers)\n+{\n+  ipa_node_params *info = IPA_NODE_REF (node);\n+  int i, count = ipa_get_param_count (info);\n+\n+  for (i = 0; i < count ; i++)\n+    {\n+      cgraph_edge *cs;\n+\n+      if (ipa_get_poly_ctx_lat (info, i)->bottom\n+\t  || (known_contexts->exists ()\n+\t      && !(*known_contexts)[i].useless_p ()))\n+\tcontinue;\n+\n+      ipa_polymorphic_call_context newval;\n+      bool found = false;\n+      int j;\n+\n+      FOR_EACH_VEC_ELT (callers, j, cs)\n+\t{\n+\t  if (i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs)))\n+\t    return;\n+\t  ipa_jump_func *jfunc = ipa_get_ith_jump_func (IPA_EDGE_REF (cs),\n+\t\t\t\t\t\t\t    i);\n+\t  ipa_polymorphic_call_context ctx;\n+\t  ctx = ipa_context_from_jfunc (IPA_NODE_REF (cs->caller), cs, i,\n+\t\t\t\t\tjfunc);\n+\t  ctx.clear_speculation ();\n+\t  if (ctx.useless_p ()\n+\t      || (found && !values_equal_for_ipcp_p (newval, ctx)))\n+\t    {\n+\t      found = false;\n+\t      break;\n+\t    }\n+\t  else if (!found)\n+\t    {\n+\t      found = true;\n+\t      newval = ctx;\n+\t    }\n+\t}\n+\n+      if (found)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"    adding an extra known polymorphic \"\n+\t\t       \"context \");\n+\t      print_ipcp_constant_value (dump_file, newval);\n+\t      fprintf (dump_file, \" for \");\n+\t      ipa_dump_param (dump_file, info, i);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  if (!known_contexts->exists ())\n+\t    known_contexts->safe_grow_cleared (ipa_get_param_count (info));\n+\t  (*known_contexts)[i] = newval;\n+\t}\n+\n+    }\n+}\n+\n /* Go through PLATS and create a vector of values consisting of values and\n    offsets (minus OFFSET) of lattices that contain only a single value.  */\n \n@@ -3355,7 +3667,7 @@ cgraph_edge_brings_all_scalars_for_node (struct cgraph_edge *cs,\n       struct ipa_jump_func *jump_func;\n       tree val, t;\n \n-      val = dest_info->known_vals[i];\n+      val = dest_info->known_csts[i];\n       if (!val)\n \tcontinue;\n \n@@ -3489,28 +3801,70 @@ perhaps_add_new_callers (cgraph_node *node, ipcp_value<valtype> *val)\n     update_specialized_profile (val->spec_node, node, redirected_sum);\n }\n \n+/* Return true if KNOWN_CONTEXTS contain at least one useful context.  */\n \n-/* Copy KNOWN_BINFOS to KNOWN_VALS.  */\n+static bool\n+known_contexts_useful_p (vec<ipa_polymorphic_call_context> known_contexts)\n+{\n+  ipa_polymorphic_call_context *ctx;\n+  int i;\n+\n+  FOR_EACH_VEC_ELT (known_contexts, i, ctx)\n+    if (!ctx->useless_p ())\n+      return true;\n+  return false;\n+}\n+\n+/* Return a copy of KNOWN_CSTS if it is not empty, otherwise return vNULL.  */\n+\n+static vec<ipa_polymorphic_call_context>\n+copy_useful_known_contexts (vec<ipa_polymorphic_call_context> known_contexts)\n+{\n+  if (known_contexts_useful_p (known_contexts))\n+    return known_contexts.copy ();\n+  else\n+    return vNULL;\n+}\n+\n+/* Copy KNOWN_CSTS and modify the copy according to VAL and INDEX.  If\n+   non-empty, replace KNOWN_CONTEXTS with its copy too.  */\n \n static void\n-move_binfos_to_values (vec<tree> known_vals,\n-\t\t       vec<tree> known_binfos)\n+modify_known_vectors_with_val (vec<tree> *known_csts,\n+\t\t\t       vec<ipa_polymorphic_call_context> *known_contexts,\n+\t\t\t       ipcp_value<tree> *val,\n+\t\t\t       int index)\n {\n-  tree t;\n-  int i;\n+  *known_csts = known_csts->copy ();\n+  *known_contexts = copy_useful_known_contexts (*known_contexts);\n+  (*known_csts)[index] = val->value;\n+}\n \n-  for (i = 0; known_binfos.iterate (i, &t); i++)\n-    if (t)\n-      known_vals[i] = t;\n+/* Replace KNOWN_CSTS with its copy.  Also copy KNOWN_CONTEXTS and modify the\n+   copy according to VAL and INDEX.  */\n+\n+static void\n+modify_known_vectors_with_val (vec<tree> *known_csts,\n+\t\t\t       vec<ipa_polymorphic_call_context> *known_contexts,\n+\t\t\t       ipcp_value<ipa_polymorphic_call_context> *val,\n+\t\t\t       int index)\n+{\n+  *known_csts = known_csts->copy ();\n+  *known_contexts = known_contexts->copy ();\n+  (*known_contexts)[index] = val->value;\n }\n \n-/* Return true if there is a replacement equivalent to VALUE, INDEX and OFFSET\n-   among those in the AGGVALS list.  */\n+/* Return true if OFFSET indicates this was not an aggregate value or there is\n+   a replacement equivalent to VALUE, INDEX and OFFSET among those in the\n+   AGGVALS list.  */\n \n DEBUG_FUNCTION bool\n-ipcp_val_in_agg_replacements_p (struct ipa_agg_replacement_value *aggvals,\n-\t\t\t\tint index, HOST_WIDE_INT offset, tree value)\n+ipcp_val_agg_replacement_ok_p (ipa_agg_replacement_value *aggvals,\n+\t\t\t       int index, HOST_WIDE_INT offset, tree value)\n {\n+  if (offset == -1)\n+    return true;\n+\n   while (aggvals)\n     {\n       if (aggvals->index == index\n@@ -3522,22 +3876,32 @@ ipcp_val_in_agg_replacements_p (struct ipa_agg_replacement_value *aggvals,\n   return false;\n }\n \n+/* Return true if offset is minus one because source of a polymorphic contect\n+   cannot be an aggregate value.  */\n+\n+DEBUG_FUNCTION bool\n+ipcp_val_agg_replacement_ok_p (ipa_agg_replacement_value *,\n+\t\t\t       int , HOST_WIDE_INT offset,\n+\t\t\t       ipa_polymorphic_call_context)\n+{\n+  return offset == -1;\n+}\n+\n /* Decide wheter to create a special version of NODE for value VAL of parameter\n    at the given INDEX.  If OFFSET is -1, the value is for the parameter itself,\n    otherwise it is stored at the given OFFSET of the parameter.  KNOWN_CSTS,\n-   KNOWN_BINFOS and KNOWN_AGGS describe the other already known values.  */\n+   KNOWN_CONTEXTS and KNOWN_AGGS describe the other already known values.  */\n \n template <typename valtype>\n static bool\n decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n \t\t    ipcp_value<valtype> *val, vec<tree> known_csts,\n-\t\t    vec<tree> known_binfos)\n+\t\t    vec<ipa_polymorphic_call_context> known_contexts)\n {\n   struct ipa_agg_replacement_value *aggvals;\n   int freq_sum, caller_count;\n   gcov_type count_sum;\n   vec<cgraph_edge *> callers;\n-  vec<tree> kv;\n \n   if (val->spec_node)\n     {\n@@ -3583,16 +3947,20 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n \t     node->name (), node->order);\n \n   callers = gather_edges_for_value (val, caller_count);\n-  kv = known_csts.copy ();\n-  move_binfos_to_values (kv, known_binfos);\n   if (offset == -1)\n-    kv[index] = val->value;\n-  find_more_scalar_values_for_callers_subset (node, kv, callers);\n+    modify_known_vectors_with_val (&known_csts, &known_contexts, val, index);\n+  else\n+    {\n+      known_csts = known_csts.copy ();\n+      known_contexts = copy_useful_known_contexts (known_contexts);\n+    }\n+  find_more_scalar_values_for_callers_subset (node, known_csts, callers);\n+  find_more_contexts_for_caller_subset (node, &known_contexts, callers);\n   aggvals = find_aggregate_values_for_callers_subset (node, callers);\n-  gcc_checking_assert (offset == -1\n-\t\t       || ipcp_val_in_agg_replacements_p (aggvals, index,\n-\t\t\t\t\t\t\t  offset, val->value));\n-  val->spec_node = create_specialized_node (node, kv, aggvals, callers);\n+  gcc_checking_assert (ipcp_val_agg_replacement_ok_p (aggvals, index,\n+\t\t\t\t\t\t      offset, val->value));\n+  val->spec_node = create_specialized_node (node, known_csts, known_contexts,\n+\t\t\t\t\t    aggvals, callers);\n   overall_size += val->local_size_cost;\n \n   /* TODO: If for some lattice there is only one other known value\n@@ -3608,7 +3976,8 @@ decide_whether_version_node (struct cgraph_node *node)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n-  vec<tree> known_csts, known_binfos;\n+  vec<tree> known_csts;\n+  vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function> known_aggs = vNULL;\n   bool ret = false;\n \n@@ -3619,22 +3988,24 @@ decide_whether_version_node (struct cgraph_node *node)\n     fprintf (dump_file, \"\\nEvaluating opportunities for %s/%i.\\n\",\n \t     node->name (), node->order);\n \n-  gather_context_independent_values (info, &known_csts, &known_binfos,\n+  gather_context_independent_values (info, &known_csts, &known_contexts,\n \t\t\t\t  info->do_clone_for_all_contexts ? &known_aggs\n \t\t\t\t  : NULL, NULL);\n \n   for (i = 0; i < count ;i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n-      ipcp_value<tree> *val;\n+      ipcp_lattice<ipa_polymorphic_call_context> *ctxlat = &plats->ctxlat;\n \n       if (!lat->bottom\n-\t  && !known_csts[i]\n-\t  && !known_binfos[i])\n-\tfor (val = lat->values; val; val = val->next)\n-\t  ret |= decide_about_value (node, i, -1, val, known_csts,\n-\t\t\t\t     known_binfos);\n+\t  && !known_csts[i])\n+\t{\n+\t  ipcp_value<tree> *val;\n+\t  for (val = lat->values; val; val = val->next)\n+\t    ret |= decide_about_value (node, i, -1, val, known_csts,\n+\t\t\t\t       known_contexts);\n+\t}\n \n       if (!plats->aggs_bottom)\n \t{\n@@ -3648,8 +4019,18 @@ decide_whether_version_node (struct cgraph_node *node)\n \t\t    || !aglat->is_single_const ()))\n \t      for (val = aglat->values; val; val = val->next)\n \t\tret |= decide_about_value (node, i, aglat->offset, val,\n-\t\t\t\t\t   known_csts, known_binfos);\n+\t\t\t\t\t   known_csts, known_contexts);\n \t}\n+\n+      if (!ctxlat->bottom\n+\t  && known_contexts[i].useless_p ())\n+\t{\n+\t  ipcp_value<ipa_polymorphic_call_context> *val;\n+\t  for (val = ctxlat->values; val; val = val->next)\n+\t    ret |= decide_about_value (node, i, -1, val, known_csts,\n+\t\t\t\t       known_contexts);\n+\t}\n+\n         info = IPA_NODE_REF (node);\n     }\n \n@@ -3664,8 +4045,13 @@ decide_whether_version_node (struct cgraph_node *node)\n \t\t node->order);\n \n       callers = node->collect_callers ();\n-      move_binfos_to_values (known_csts, known_binfos);\n-      clone = create_specialized_node (node, known_csts,\n+\n+      if (!known_contexts_useful_p (known_contexts))\n+\t{\n+\t  known_contexts.release ();\n+\t  known_contexts = vNULL;\n+\t}\n+      clone = create_specialized_node (node, known_csts, known_contexts,\n \t\t\t       known_aggs_to_agg_replacement_list (known_aggs),\n \t\t\t       callers);\n       info = IPA_NODE_REF (node);\n@@ -3677,9 +4063,11 @@ decide_whether_version_node (struct cgraph_node *node)\n       ret = true;\n     }\n   else\n-    known_csts.release ();\n+    {\n+      known_csts.release ();\n+      known_contexts.release ();\n+    }\n \n-  known_binfos.release ();\n   return ret;\n }\n \n@@ -3803,8 +4191,11 @@ ipcp_driver (void)\n   edge_removal_hook_holder =\n     symtab->add_edge_removal_hook (&ipcp_edge_removal_hook, NULL);\n \n-  ipcp_values_pool = create_alloc_pool (\"IPA-CP values\",\n-\t\t\t\t\tsizeof (ipcp_value<tree>), 32);\n+  ipcp_cst_values_pool = create_alloc_pool (\"IPA-CP constant values\",\n+\t\t\t\t\t    sizeof (ipcp_value<tree>), 32);\n+  ipcp_poly_ctx_values_pool = create_alloc_pool\n+    (\"IPA-CP polymorphic contexts\",\n+     sizeof (ipcp_value<ipa_polymorphic_call_context>), 32);\n   ipcp_sources_pool = create_alloc_pool (\"IPA-CP value sources\",\n \t\t\t\t\t sizeof (ipcp_value_source<tree>), 64);\n   ipcp_agg_lattice_pool = create_alloc_pool (\"IPA_CP aggregate lattices\","}, {"sha": "69e06123fee0575921a22edcc4c0af2f3414f273", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -895,7 +895,8 @@ static void\n evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t      clause_t *clause_ptr,\n \t\t\t      vec<tree> *known_vals_ptr,\n-\t\t\t      vec<tree> *known_binfos_ptr,\n+\t\t\t      vec<ipa_polymorphic_call_context>\n+\t\t\t      *known_contexts_ptr,\n \t\t\t      vec<ipa_agg_jump_function_p> *known_aggs_ptr)\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n@@ -907,12 +908,12 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n     *clause_ptr = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n   if (known_vals_ptr)\n     known_vals_ptr->create (0);\n-  if (known_binfos_ptr)\n-    known_binfos_ptr->create (0);\n+  if (known_contexts_ptr)\n+    known_contexts_ptr->create (0);\n \n   if (ipa_node_params_vector.exists ()\n       && !e->call_stmt_cannot_inline_p\n-      && ((clause_ptr && info->conds) || known_vals_ptr || known_binfos_ptr))\n+      && ((clause_ptr && info->conds) || known_vals_ptr || known_contexts_ptr))\n     {\n       struct ipa_node_params *parms_info;\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n@@ -928,23 +929,25 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \tknown_vals.safe_grow_cleared (count);\n       if (count && (info->conds || known_aggs_ptr))\n \tknown_aggs.safe_grow_cleared (count);\n-      if (count && known_binfos_ptr)\n-\tknown_binfos_ptr->safe_grow_cleared (count);\n+      if (count && known_contexts_ptr)\n+\tknown_contexts_ptr->safe_grow_cleared (count);\n \n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n \t  tree cst = ipa_value_from_jfunc (parms_info, jf);\n \t  if (cst)\n \t    {\n-\t      if (known_vals.exists () && TREE_CODE (cst) != TREE_BINFO)\n+\t      gcc_checking_assert (TREE_CODE (cst) != TREE_BINFO);\n+\t      if (known_vals.exists ())\n \t\tknown_vals[i] = cst;\n-\t      else if (known_binfos_ptr != NULL\n-\t\t       && TREE_CODE (cst) == TREE_BINFO)\n-\t\t(*known_binfos_ptr)[i] = cst;\n \t    }\n \t  else if (inline_p && !es->param[i].change_prob)\n \t    known_vals[i] = error_mark_node;\n+\n+\t  if (known_contexts_ptr)\n+\t    (*known_contexts_ptr)[i] = ipa_context_from_jfunc (parms_info, e,\n+\t\t\t\t\t\t\t       i, jf);\n \t  /* TODO: When IPA-CP starts propagating and merging aggregate jump\n \t     functions, use its knowledge of the caller too, just like the\n \t     scalar case above.  */\n@@ -2969,27 +2972,27 @@ make_pass_inline_parameters (gcc::context *ctxt)\n }\n \n \n-/* Estimate benefit devirtualizing indirect edge IE, provided KNOWN_VALS and\n-   KNOWN_BINFOS.  */\n+/* Estimate benefit devirtualizing indirect edge IE, provided KNOWN_VALS,\n+   KNOWN_CONTEXTS and KNOWN_AGGS.  */\n \n static bool\n estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n \t\t\t      int *size, int *time,\n \t\t\t      vec<tree> known_vals,\n-\t\t\t      vec<tree> known_binfos,\n+\t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t      vec<ipa_agg_jump_function_p> known_aggs)\n {\n   tree target;\n   struct cgraph_node *callee;\n   struct inline_summary *isummary;\n   enum availability avail;\n \n-  if (!known_vals.exists () && !known_binfos.exists ())\n+  if (!known_vals.exists () && !known_contexts.exists ())\n     return false;\n   if (!flag_indirect_inlining)\n     return false;\n \n-  target = ipa_get_indirect_edge_target (ie, known_vals, known_binfos,\n+  target = ipa_get_indirect_edge_target (ie, known_vals, known_contexts,\n \t\t\t\t\t known_aggs);\n   if (!target)\n     return false;\n@@ -3013,15 +3016,15 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n /* Increase SIZE, MIN_SIZE (if non-NULL) and TIME for size and time needed to\n    handle edge E with probability PROB.\n    Set HINTS if edge may be devirtualized.\n-   KNOWN_VALS, KNOWN_AGGS and KNOWN_BINFOS describe context of the call\n+   KNOWN_VALS, KNOWN_AGGS and KNOWN_CONTEXTS describe context of the call\n    site.  */\n \n static inline void\n estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \t\t\t     int *time,\n \t\t\t     int prob,\n \t\t\t     vec<tree> known_vals,\n-\t\t\t     vec<tree> known_binfos,\n+\t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t     inline_hints *hints)\n {\n@@ -3031,7 +3034,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n   int cur_size;\n   if (!e->callee\n       && estimate_edge_devirt_benefit (e, &call_size, &call_time,\n-\t\t\t\t       known_vals, known_binfos, known_aggs)\n+\t\t\t\t       known_vals, known_contexts, known_aggs)\n       && hints && e->maybe_hot_p ())\n     *hints |= INLINE_HINT_indirect_call;\n   cur_size = call_size * INLINE_SIZE_SCALE;\n@@ -3047,17 +3050,16 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \n \n /* Increase SIZE, MIN_SIZE and TIME for size and time needed to handle all\n-   calls in NODE.\n-   POSSIBLE_TRUTHS, KNOWN_VALS, KNOWN_AGGS and KNOWN_BINFOS describe context of\n-   the call site.  */\n+   calls in NODE.  POSSIBLE_TRUTHS, KNOWN_VALS, KNOWN_AGGS and KNOWN_CONTEXTS\n+   describe context of the call site.  */\n \n static void\n estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \t\t\t      int *min_size, int *time,\n \t\t\t      inline_hints *hints,\n \t\t\t      clause_t possible_truths,\n \t\t\t      vec<tree> known_vals,\n-\t\t\t      vec<tree> known_binfos,\n+\t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t      vec<ipa_agg_jump_function_p> known_aggs)\n {\n   struct cgraph_edge *e;\n@@ -3074,14 +3076,14 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \t      estimate_edge_size_and_time (e, size,\n \t\t\t\t\t   es->predicate ? NULL : min_size,\n \t\t\t\t\t   time, REG_BR_PROB_BASE,\n-\t\t\t\t\t   known_vals, known_binfos,\n+\t\t\t\t\t   known_vals, known_contexts,\n \t\t\t\t\t   known_aggs, hints);\n \t    }\n \t  else\n \t    estimate_calls_size_and_time (e->callee, size, min_size, time,\n \t\t\t\t\t  hints,\n \t\t\t\t\t  possible_truths,\n-\t\t\t\t\t  known_vals, known_binfos,\n+\t\t\t\t\t  known_vals, known_contexts,\n \t\t\t\t\t  known_aggs);\n \t}\n     }\n@@ -3093,14 +3095,14 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \testimate_edge_size_and_time (e, size,\n \t\t\t\t     es->predicate ? NULL : min_size,\n \t\t\t\t     time, REG_BR_PROB_BASE,\n-\t\t\t\t     known_vals, known_binfos, known_aggs,\n+\t\t\t\t     known_vals, known_contexts, known_aggs,\n \t\t\t\t     hints);\n     }\n }\n \n \n /* Estimate size and time needed to execute NODE assuming\n-   POSSIBLE_TRUTHS clause, and KNOWN_VALS, KNOWN_AGGS and KNOWN_BINFOS\n+   POSSIBLE_TRUTHS clause, and KNOWN_VALS, KNOWN_AGGS and KNOWN_CONTEXTS\n    information about NODE's arguments.  If non-NULL use also probability\n    information present in INLINE_PARAM_SUMMARY vector.\n    Additionally detemine hints determined by the context.  Finally compute\n@@ -3112,7 +3114,7 @@ static void\n estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     clause_t possible_truths,\n \t\t\t     vec<tree> known_vals,\n-\t\t\t     vec<tree> known_binfos,\n+\t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t     int *ret_size, int *ret_min_size, int *ret_time,\n \t\t\t     inline_hints *ret_hints,\n@@ -3189,7 +3191,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n     hints |= INLINE_HINT_declared_inline;\n \n   estimate_calls_size_and_time (node, &size, &min_size, &time, &hints, possible_truths,\n-\t\t\t\tknown_vals, known_binfos, known_aggs);\n+\t\t\t\tknown_vals, known_contexts, known_aggs);\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n   time = RDIV (time, INLINE_TIME_SCALE);\n@@ -3212,13 +3214,14 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \n /* Estimate size and time needed to execute callee of EDGE assuming that\n    parameters known to be constant at caller of EDGE are propagated.\n-   KNOWN_VALS and KNOWN_BINFOS are vectors of assumed known constant values\n+   KNOWN_VALS and KNOWN_CONTEXTS are vectors of assumed known constant values\n    and types for parameters.  */\n \n void\n estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \t\t\t\t   vec<tree> known_vals,\n-\t\t\t\t   vec<tree> known_binfos,\n+\t\t\t\t   vec<ipa_polymorphic_call_context>\n+\t\t\t\t   known_contexts,\n \t\t\t\t   vec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t\t   int *ret_size, int *ret_time,\n \t\t\t\t   inline_hints *hints)\n@@ -3227,7 +3230,7 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \n   clause = evaluate_conditions_for_known_args (node, false, known_vals,\n \t\t\t\t\t       known_aggs);\n-  estimate_node_size_and_time (node, clause, known_vals, known_binfos,\n+  estimate_node_size_and_time (node, clause, known_vals, known_contexts,\n \t\t\t       known_aggs, ret_size, NULL, ret_time, hints, vNULL);\n }\n \n@@ -3672,7 +3675,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   struct cgraph_node *callee;\n   clause_t clause;\n   vec<tree> known_vals;\n-  vec<tree> known_binfos;\n+  vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n   int min_size;\n@@ -3681,9 +3684,9 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n \n   gcc_checking_assert (edge->inline_failed);\n   evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &known_vals, &known_binfos,\n+\t\t\t\t&clause, &known_vals, &known_contexts,\n \t\t\t\t&known_aggs);\n-  estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n+  estimate_node_size_and_time (callee, clause, known_vals, known_contexts,\n \t\t\t       known_aggs, &size, &min_size, &time, &hints, es->param);\n \n   /* When we have profile feedback, we can quite safely identify hot\n@@ -3697,7 +3700,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n     hints |= INLINE_HINT_known_hot;\n \n   known_vals.release ();\n-  known_binfos.release ();\n+  known_contexts.release ();\n   known_aggs.release ();\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n@@ -3728,7 +3731,7 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n   struct cgraph_node *callee;\n   clause_t clause;\n   vec<tree> known_vals;\n-  vec<tree> known_binfos;\n+  vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n@@ -3746,12 +3749,12 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n   evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &known_vals, &known_binfos,\n+\t\t\t\t&clause, &known_vals, &known_contexts,\n \t\t\t\t&known_aggs);\n-  estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n+  estimate_node_size_and_time (callee, clause, known_vals, known_contexts,\n \t\t\t       known_aggs, &size, NULL, NULL, NULL, vNULL);\n   known_vals.release ();\n-  known_binfos.release ();\n+  known_contexts.release ();\n   known_aggs.release ();\n   return size;\n }\n@@ -3767,7 +3770,7 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   struct cgraph_node *callee;\n   clause_t clause;\n   vec<tree> known_vals;\n-  vec<tree> known_binfos;\n+  vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n@@ -3785,12 +3788,12 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n   evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &known_vals, &known_binfos,\n+\t\t\t\t&clause, &known_vals, &known_contexts,\n \t\t\t\t&known_aggs);\n-  estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n+  estimate_node_size_and_time (callee, clause, known_vals, known_contexts,\n \t\t\t       known_aggs, NULL, NULL, NULL, &hints, vNULL);\n   known_vals.release ();\n-  known_binfos.release ();\n+  known_contexts.release ();\n   known_aggs.release ();\n   hints |= simple_edge_hints (edge);\n   return hints;"}, {"sha": "4ba626441a2f2a540ccd2d8e6fa05d7a8809561e", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -223,7 +223,8 @@ void initialize_inline_failed (struct cgraph_edge *);\n int estimate_time_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n-\t\t\t\t\tvec<tree>,  vec<tree>,\n+\t\t\t\t\tvec<tree>,\n+\t\t\t\t\tvec<ipa_polymorphic_call_context>,\n \t\t\t\t\tvec<ipa_agg_jump_function_p>,\n \t\t\t\t\tint *, int *, inline_hints *);\n int do_estimate_growth (struct cgraph_node *);"}, {"sha": "f1905f1609aec2cf6ad99e8deed15536b38ce43c", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -599,10 +599,11 @@ decl_maybe_in_construction_p (tree base, tree outer_type,\n   return false;\n }\n \n-/* Dump human readable context to F.  */\n+/* Dump human readable context to F.  If NEWLINE is true, it will be terminated\n+   by a newline.  */\n \n void\n-ipa_polymorphic_call_context::dump (FILE *f) const\n+ipa_polymorphic_call_context::dump (FILE *f, bool newline) const\n {\n   fprintf (f, \"    \");\n   if (invalid)\n@@ -634,7 +635,8 @@ ipa_polymorphic_call_context::dump (FILE *f) const\n \t\t   speculative_offset);\n \t}\n     }\n-  fprintf(f, \"\\n\");\n+  if (newline)\n+    fprintf(f, \"\\n\");\n }\n \n /* Print context to stderr.  */\n@@ -2130,3 +2132,47 @@ ipa_polymorphic_call_context::possible_dynamic_type_change (bool in_poly_cdtor,\n   else if (in_poly_cdtor)\n     maybe_in_construction = true;\n }\n+\n+/* Return TRUE if this context conveys the same information as OTHER.  */\n+\n+bool\n+ipa_polymorphic_call_context::equal_to\n+    (const ipa_polymorphic_call_context &x) const\n+{\n+  if (useless_p ())\n+    return x.useless_p ();\n+  if (invalid)\n+    return x.invalid;\n+  if (x.useless_p () || x.invalid)\n+    return false;\n+\n+  if (outer_type)\n+    {\n+      if (!x.outer_type\n+\t  || !types_odr_comparable (outer_type, x.outer_type)\n+\t  || !types_same_for_odr (outer_type, x.outer_type)\n+\t  || offset != x.offset\n+\t  || maybe_in_construction != x.maybe_in_construction\n+\t  || maybe_derived_type != x.maybe_derived_type\n+\t  || dynamic != x.dynamic)\n+\treturn false;\n+    }\n+  else if (x.outer_type)\n+    return false;\n+\n+  if (speculative_outer_type)\n+    {\n+      if (!x.speculative_outer_type\n+\t  || !types_odr_comparable (speculative_outer_type,\n+\t\t\t\t    x.speculative_outer_type)\n+\t  || !types_same_for_odr  (speculative_outer_type,\n+\t\t\t\t    x.speculative_outer_type)\n+\t  || speculative_offset != x.speculative_offset\n+\t  || speculative_maybe_derived_type != x.speculative_maybe_derived_type)\n+\treturn false;\n+    }\n+  else if (x.speculative_outer_type)\n+    return false;\n+\n+  return true;\n+}"}, {"sha": "d9331f362199a492a9651b13205fa455f535d31f", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 68, "deletions": 95, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -380,8 +380,14 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t      fprintf (f, \"\\n\");\n \t    }\n \t}\n-      if (IPA_EDGE_REF (cs)->polymorphic_call_contexts)\n-\tipa_get_ith_polymorhic_call_context (IPA_EDGE_REF (cs), i)->dump (f);\n+\n+      struct ipa_polymorphic_call_context *ctx\n+\t= ipa_get_ith_polymorhic_call_context (IPA_EDGE_REF (cs), i);\n+      if (ctx && !ctx->useless_p ())\n+\t{\n+\t  fprintf (f, \"         Context: \");\n+\t  ctx->dump (dump_file);\n+\t}\n     }\n }\n \n@@ -559,7 +565,8 @@ ipa_set_ancestor_jf (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n     type = NULL_TREE;\n   if (type)\n     type = TYPE_MAIN_VARIANT (type);\n-  gcc_assert (!type_preserved || contains_polymorphic_type_p (type));\n+  if (!type || !contains_polymorphic_type_p (type))\n+    type_preserved = false;\n   jfunc->type = IPA_JF_ANCESTOR;\n   jfunc->value.ancestor.formal_id = formal_id;\n   jfunc->value.ancestor.offset = offset;\n@@ -2622,9 +2629,12 @@ combine_known_type_and_ancestor_jfs (struct ipa_jump_func *src,\n     + ipa_get_jf_ancestor_offset (dst);\n   combined_type = ipa_get_jf_ancestor_type (dst);\n \n-  ipa_set_jf_known_type (dst, combined_offset,\n-\t\t\t ipa_get_jf_known_type_base_type (src),\n-\t\t\t combined_type);\n+  if (combined_type)\n+    ipa_set_jf_known_type (dst, combined_offset,\n+\t\t\t   ipa_get_jf_known_type_base_type (src),\n+\t\t\t   combined_type);\n+  else\n+    dst->type = IPA_JF_UNKNOWN;\n }\n \n /* Update the jump functions associated with call graph edge E when the call\n@@ -2669,7 +2679,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t      struct ipa_polymorphic_call_context ctx = *src_ctx;\n \n \t      /* TODO: Make type preserved safe WRT contexts.  */\n-\t      if (!dst->value.ancestor.agg_preserved)\n+\t      if (!ipa_get_jf_ancestor_type_preserved (dst))\n \t\tctx.possible_dynamic_type_change (e->in_polymorphic_cdtor);\n \t      ctx.offset_by (dst->value.ancestor.offset);\n \t      if (!ctx.useless_p ())\n@@ -2678,6 +2688,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t\t\t\t count);\n \t\t  dst_ctx = ipa_get_ith_polymorhic_call_context (args, i);\n \t\t}\n+\t      dst_ctx->combine_with (ctx);\n \t    }\n \n \t  if (src->agg.items\n@@ -2739,7 +2750,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t  struct ipa_polymorphic_call_context ctx = *src_ctx;\n \n \t\t  /* TODO: Make type preserved safe WRT contexts.  */\n-\t\t  if (!dst->value.ancestor.agg_preserved)\n+\t\t  if (!ipa_get_jf_pass_through_type_preserved (dst))\n \t\t    ctx.possible_dynamic_type_change (e->in_polymorphic_cdtor);\n \t\t  if (!ctx.useless_p ())\n \t\t    {\n@@ -3152,41 +3163,24 @@ ipa_impossible_devirt_target (struct cgraph_edge *ie, tree target)\n /* Try to find a destination for indirect edge IE that corresponds to a virtual\n    call based on a formal parameter which is described by jump function JFUNC\n    and if it can be determined, make it direct and return the direct edge.\n-   Otherwise, return NULL.  NEW_ROOT_INFO is the node info that JFUNC lattices\n-   are relative to.  */\n+   Otherwise, return NULL.  CTX describes the polymorphic context that the\n+   parameter the call is based on brings along with it.  */\n \n static struct cgraph_edge *\n try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t\t\t\t   struct ipa_jump_func *jfunc,\n-\t\t\t\t   struct ipa_node_params *new_root_info,\n-\t\t\t\t   struct ipa_polymorphic_call_context *ctx_ptr)\n+\t\t\t\t   struct ipa_polymorphic_call_context ctx)\n {\n-  tree binfo, target = NULL;\n+  tree target = NULL;\n   bool speculative = false;\n-  bool updated = false;\n \n   if (!flag_devirtualize)\n     return NULL;\n \n-  /* If this is call of a function parameter, restrict its type\n-     based on knowlede of the context.  */\n-  if (ctx_ptr && !ie->indirect_info->by_ref)\n-    {\n-      struct ipa_polymorphic_call_context ctx = *ctx_ptr;\n-\n-      ctx.offset_by (ie->indirect_info->offset);\n-\n-      if (ie->indirect_info->vptr_changed)\n-\tctx.possible_dynamic_type_change (ie->in_polymorphic_cdtor,\n-\t\t\t\t\t  ie->indirect_info->otr_type);\n-\n-      updated = ie->indirect_info->context.combine_with\n-\t\t  (ctx, ie->indirect_info->otr_type);\n-    }\n+  gcc_assert (!ie->indirect_info->by_ref);\n \n   /* Try to do lookup via known virtual table pointer value.  */\n-  if (!ie->indirect_info->by_ref\n-      && (!ie->indirect_info->vptr_changed || flag_devirtualize_speculatively))\n+  if (!ie->indirect_info->vptr_changed || flag_devirtualize_speculatively)\n     {\n       tree vtable;\n       unsigned HOST_WIDE_INT offset;\n@@ -3217,67 +3211,44 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t}\n     }\n \n-  binfo = ipa_value_from_jfunc (new_root_info, jfunc);\n-\n-  if (binfo && TREE_CODE (binfo) != TREE_BINFO)\n-    {\n-      struct ipa_polymorphic_call_context ctx (binfo,\n-\t\t\t\t\t       ie->indirect_info->otr_type,\n-\t\t\t\t\t       ie->indirect_info->offset);\n-      updated |= ie->indirect_info->context.combine_with\n-\t\t  (ctx, ie->indirect_info->otr_type);\n+  ipa_polymorphic_call_context ie_context (ie);\n+  vec <cgraph_node *>targets;\n+  bool final;\n+\n+  ctx.offset_by (ie->indirect_info->offset);\n+  if (ie->indirect_info->vptr_changed)\n+    ctx.possible_dynamic_type_change (ie->in_polymorphic_cdtor,\n+\t\t\t\t      ie->indirect_info->otr_type);\n+  ctx.combine_with (ie_context, ie->indirect_info->otr_type);\n+  targets = possible_polymorphic_call_targets\n+    (ie->indirect_info->otr_type,\n+     ie->indirect_info->otr_token,\n+     ctx, &final);\n+  if (final && targets.length () <= 1)\n+    {\n+      if (targets.length () == 1)\n+\ttarget = targets[0]->decl;\n+      else\n+\ttarget = ipa_impossible_devirt_target (ie, NULL_TREE);\n     }\n-\n-  if (updated)\n-    {\n-      ipa_polymorphic_call_context context (ie);\n-      vec <cgraph_node *>targets;\n-      bool final;\n-\n-      targets = possible_polymorphic_call_targets\n-\t\t (ie->indirect_info->otr_type,\n-\t\t  ie->indirect_info->otr_token,\n-\t\t  context, &final);\n-      if (final && targets.length () <= 1)\n-\t{\n-\t  if (targets.length () == 1)\n-\t    target = targets[0]->decl;\n-\t  else\n-\t    target = ipa_impossible_devirt_target (ie, NULL_TREE);\n-\t}\n-      else if (!target && flag_devirtualize_speculatively\n-\t       && !ie->speculative && ie->maybe_hot_p ())\n-\t{\n-\t  cgraph_node *n = try_speculative_devirtualization (ie->indirect_info->otr_type,\n-\t\t\t\t\t\t\t     ie->indirect_info->otr_token,\n-\t\t\t\t\t\t\t     ie->indirect_info->context);\n-\t  if (n)\n-\t    {\n-\t      target = n->decl;\n-\t      speculative = true;\n-\t    }\n-\t}\n-     }\n-\n-  if (binfo && TREE_CODE (binfo) == TREE_BINFO)\n-    {\n-      binfo = get_binfo_at_offset (binfo, ie->indirect_info->offset,\n-\t\t\t\t   ie->indirect_info->otr_type);\n-      if (binfo)\n+  else if (!target && flag_devirtualize_speculatively\n+\t   && !ie->speculative && ie->maybe_hot_p ())\n+    {\n+      cgraph_node *n;\n+      n = try_speculative_devirtualization (ie->indirect_info->otr_type,\n+\t\t\t\t\t    ie->indirect_info->otr_token,\n+\t\t\t\t\t    ie->indirect_info->context);\n+      if (n)\n \t{\n-\t  tree t = gimple_get_virt_method_for_binfo (ie->indirect_info->otr_token,\n-\t\t\t\t\t\t     binfo);\n-\t  if (t)\n-\t    {\n-\t      target = t;\n-\t      speculative = false;\n-\t    }\n+\t  target = n->decl;\n+\t  speculative = true;\n \t}\n     }\n \n   if (target)\n     {\n-      if (!possible_polymorphic_call_target_p (ie, cgraph_node::get_create (target)))\n+      if (!possible_polymorphic_call_target_p\n+\t  (ie, cgraph_node::get_create (target)))\n \t{\n \t  if (speculative)\n \t    return NULL;\n@@ -3336,11 +3307,9 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \tnew_direct_edge = NULL;\n       else if (ici->polymorphic)\n \t{\n-          ipa_polymorphic_call_context *ctx;\n-          ctx = ipa_get_ith_polymorhic_call_context (top, param_index);\n-\t  new_direct_edge = try_make_edge_direct_virtual_call (ie, jfunc,\n-\t\t\t\t\t\t\t       new_root_info,\n-\t\t\t\t\t\t\t       ctx);\n+          ipa_polymorphic_call_context ctx;\n+\t  ctx = ipa_context_from_jfunc (new_root_info, cs, param_index, jfunc);\n+\t  new_direct_edge = try_make_edge_direct_virtual_call (ie, jfunc, ctx);\n \t}\n       else\n \tnew_direct_edge = try_make_edge_direct_simple_call (ie, jfunc,\n@@ -3474,7 +3443,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t    {\n \t      struct cgraph_node *n;\n \t      struct ipa_ref *ref;\n-\t      tree t = new_root_info->known_vals[src_idx];\n+\t      tree t = new_root_info->known_csts[src_idx];\n \n \t      if (t && TREE_CODE (t) == ADDR_EXPR\n \t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL\n@@ -3617,7 +3586,8 @@ ipa_free_node_params_substructures (struct ipa_node_params *info)\n   free (info->lattices);\n   /* Lattice values and their sources are deallocated with their alocation\n      pool.  */\n-  info->known_vals.release ();\n+  info->known_csts.release ();\n+  info->known_contexts.release ();\n   memset (info, 0, sizeof (*info));\n }\n \n@@ -3892,7 +3862,8 @@ ipa_free_all_structures_after_ipa_cp (void)\n       ipa_free_all_edge_args ();\n       ipa_free_all_node_params ();\n       free_alloc_pool (ipcp_sources_pool);\n-      free_alloc_pool (ipcp_values_pool);\n+      free_alloc_pool (ipcp_cst_values_pool);\n+      free_alloc_pool (ipcp_poly_ctx_values_pool);\n       free_alloc_pool (ipcp_agg_lattice_pool);\n       ipa_unregister_cgraph_hooks ();\n       if (ipa_refdesc_pool)\n@@ -3911,8 +3882,10 @@ ipa_free_all_structures_after_iinln (void)\n   ipa_unregister_cgraph_hooks ();\n   if (ipcp_sources_pool)\n     free_alloc_pool (ipcp_sources_pool);\n-  if (ipcp_values_pool)\n-    free_alloc_pool (ipcp_values_pool);\n+  if (ipcp_cst_values_pool)\n+    free_alloc_pool (ipcp_cst_values_pool);\n+  if (ipcp_poly_ctx_values_pool)\n+    free_alloc_pool (ipcp_poly_ctx_values_pool);\n   if (ipcp_agg_lattice_pool)\n     free_alloc_pool (ipcp_agg_lattice_pool);\n   if (ipa_refdesc_pool)"}, {"sha": "2227c0d41149be190fe2d753532b006c6a3e78a7", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -278,13 +278,14 @@ ipa_get_jf_pass_through_agg_preserved (struct ipa_jump_func *jfunc)\n   return jfunc->value.pass_through.agg_preserved;\n }\n \n-/* Return the type_preserved flag of a pass through jump function JFUNC.  */\n+/* Return true if pass through jump function JFUNC preserves type\n+   information.  */\n \n static inline bool\n ipa_get_jf_pass_through_type_preserved (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n-  return jfunc->value.pass_through.type_preserved;\n+  return jfunc->value.pass_through.agg_preserved;\n }\n \n /* Return the offset of an ancestor jump function JFUNC.  */\n@@ -324,13 +325,13 @@ ipa_get_jf_ancestor_agg_preserved (struct ipa_jump_func *jfunc)\n   return jfunc->value.ancestor.agg_preserved;\n }\n \n-/* Return the type_preserved flag of an ancestor jump function JFUNC.  */\n+/* Return true if ancestor jump function JFUNC presrves type information.  */\n \n static inline bool\n ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n-  return jfunc->value.ancestor.type_preserved;\n+  return jfunc->value.ancestor.agg_preserved;\n }\n \n /* Summary describing a single formal parameter.  */\n@@ -363,9 +364,12 @@ struct ipa_node_params\n   /* Only for versioned nodes this field would not be NULL,\n      it points to the node that IPA cp cloned from.  */\n   struct cgraph_node *ipcp_orig_node;\n-  /* If this node is an ipa-cp clone, these are the known values that describe\n-     what it has been specialized for.  */\n-  vec<tree> known_vals;\n+  /* If this node is an ipa-cp clone, these are the known constants that\n+     describe what it has been specialized for.  */\n+  vec<tree> known_csts;\n+  /* If this node is an ipa-cp clone, these are the known polymorphic contexts\n+     that describe what it has been specialized for.  */\n+  vec<ipa_polymorphic_call_context> known_contexts;\n   /* Whether the param uses analysis and jump function computation has already\n      been performed.  */\n   unsigned analysis_done : 1;\n@@ -592,7 +596,7 @@ bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n /* Indirect edge and binfo processing.  */\n tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n \t\t\t\t   vec<tree> ,\n-\t\t\t\t   vec<tree> ,\n+\t\t\t\t   vec<ipa_polymorphic_call_context>,\n \t\t\t\t   vec<ipa_agg_jump_function_p> );\n struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree,\n \t\t\t\t\t\t    bool speculative = false);\n@@ -615,7 +619,8 @@ void ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node);\n void ipa_print_all_jump_functions (FILE * f);\n void ipcp_verify_propagated_values (void);\n \n-extern alloc_pool ipcp_values_pool;\n+extern alloc_pool ipcp_cst_values_pool;\n+extern alloc_pool ipcp_poly_ctx_values_pool;\n extern alloc_pool ipcp_sources_pool;\n extern alloc_pool ipcp_agg_lattice_pool;\n \n@@ -716,6 +721,10 @@ int ipa_get_param_decl_index (struct ipa_node_params *, tree);\n tree ipa_value_from_jfunc (struct ipa_node_params *info,\n \t\t\t   struct ipa_jump_func *jfunc);\n unsigned int ipcp_transform_function (struct cgraph_node *node);\n+ipa_polymorphic_call_context ipa_context_from_jfunc (ipa_node_params *,\n+\t\t\t\t\t\t     cgraph_edge *,\n+\t\t\t\t\t\t     int,\n+\t\t\t\t\t\t     ipa_jump_func *);\n void ipa_dump_param (FILE *, struct ipa_node_params *info, int i);\n bool ipa_modify_expr (tree *, bool, ipa_parm_adjustment_vec);\n ipa_parm_adjustment *ipa_get_adjustment_candidate (tree **, bool *,"}, {"sha": "46493f225e3c791267913a54797805c294557dbc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -1,3 +1,14 @@\n+2014-11-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/ipa/devirt-11.C: Dont't run ipa-cp, remove times constraint\n+\tfrom the dump scan.\n+\t* g++.dg/ipa/devirt-21.C: Xfail.\n+\t* g++.dg/ipa/devirt-24.C: Likewise.\n+\t* g++.dg/ipa/devirt-10.C: Removed times constraint from the dump scan.\n+\t* g++.dg/ipa/devirt-41.C: Updated the dump scan.\n+\t* g++.dg/ipa/devirt-44.C: Likewise.\n+\t* g++.dg/ipa/devirt-43.C: Xfail.\n+\n 2014-11-14  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* g++.dg/abi/abi-tag11.C: New."}, {"sha": "e29d33fa9558406c0207947e36ce3bed869d08b2", "filename": "gcc/testsuite/g++.dg/ipa/devirt-10.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-10.C?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -27,8 +27,6 @@ struct wxBufferedPaintDC  : public wxBufferedDC {\n void  OnPaint(wxPaintEvent & event) {\n   wxBufferedPaintDC dc;\n }\n-/* IPA-CP should really discover both cases, but for time being the second is handled by inliner.  */\n-/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"inline\"  } } */\n-/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 2 \"cp\"  } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "7a698f16967e701f4dfd0ce8eb8cad6bd8598b11", "filename": "gcc/testsuite/g++.dg/ipa/devirt-11.C", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-ipa-inline -fno-devirtualize-speculatively\" } */\n+/* { dg-options \"-O2 -fno-ipa-cp -fdump-ipa-inline -fno-devirtualize-speculatively\" } */\n int baz ();\n struct A\n {\n@@ -42,7 +42,5 @@ bar ()\n   baz ();\n   c + d;\n }\n-/* While inlining function called once we should devirtualize a new call to fn3.\n-   Because fn2 is already removed, we should not devirtualize.  */\n-/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target\" \"inline\"  } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "99f60afe33c561d3e9850175900273974a87dd49", "filename": "gcc/testsuite/g++.dg/ipa/devirt-21.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-21.C?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -37,5 +37,5 @@ main()\n {\n   class C c;\n }\n-/* { dg-final { scan-ipa-dump \"Discovered a virtual call to\" \"cp\" { xfail *-*-* } } } */\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to\" \"cp\" } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "6ac4b606d88cb4b24ee0f14c10a9671775f44be3", "filename": "gcc/testsuite/g++.dg/ipa/devirt-24.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-24.C?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -36,7 +36,7 @@ C *b = new (C);\n     sort(f, *b);\n   }\n }\n-/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"inline\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */\n /* { dg-final { scan-ipa-dump-times \"Aggregate passed by reference\" 1 \"cp\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "926c3c49813b477d13473039f8cbac568fd3c217", "filename": "gcc/testsuite/g++.dg/ipa/devirt-41.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-41.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-41.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-41.C?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -26,6 +26,6 @@ main()\n \n    Because the type is in static storage, we know it won't change type in dostuff\n    and from callstack we can tell that is is not in construction/destruction.  */\n-/* { dg-final { scan-ipa-dump-times \"First type is base of second\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"Second type is base of first\" \"inline\"  } } */\n /* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"inline\"  } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "be1aaa86754a0bde9ea9778b0a2c3a0ba83b937a", "filename": "gcc/testsuite/g++.dg/ipa/devirt-43.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-43.C?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -23,5 +23,5 @@ t(struct B *b)\n    of type B.  This makes A fully specified and we know C::foo is unlikely.\n    FIXME: We could most probably can devirtualize unconditonally because dereference of b in\n    &b->a makes the type known.  GIMPLE does not represent this.  */\n-/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a speculative target\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a speculative target\" 1 \"inline\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "214cf95d6e9611d1431870dcfbef028d00132a08", "filename": "gcc/testsuite/g++.dg/ipa/devirt-44.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-44.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44210a9672aed3212c0e289dddc5bd38c314290b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-44.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-44.C?ref=44210a9672aed3212c0e289dddc5bd38c314290b", "patch": "@@ -26,7 +26,7 @@ main()\n /* Here one invocation of foo is while type is in construction, while other is not.\n    Check that we handle that.  */\n \n-/* { dg-final { scan-ipa-dump-times \"First type is base of second\" 1 \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"Second type is base of first\" \"inline\"  } } */\n /* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\\[^\\\\n\\]*A::foo\" 1 \"inline\"  } } */\n /* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\\[^\\\\n\\]*B::foo\" 1 \"inline\"  } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}