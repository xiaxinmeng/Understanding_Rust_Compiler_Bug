{"sha": "bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNlMDhkNTAwM2UwY2IxZjYzY2JlOTI4OTViZThjYmNjNWM0ODU0Nw==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2009-02-18T02:16:03Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2009-02-18T02:16:03Z"}, "message": "re PR target/39082 (union with long double doesn't follow x86-64 psABI)\n\ngcc/\n\n2009-02-17  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/39082\n\t* c.opt (Wabi): Support C and ObjC.\n\t(Wpsabi): New.\n\n\t* c-opts.c (c_common_handle_option): Handle OPT_Wabi.\n\n\t* config/i386/i386.c (classify_argument): Warn once about the ABI\n\tchange when passing union with long double.\n\n\t* doc/invoke.texi: Update -Wabi for warning psABI changes.\n\ngcc/testsuite/\n\n2009-02-17  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/39082\n\t* g++.dg/compat/struct-layout-1_generate.c (dg_options): Add\n\t-Wno-abi for x86.\n\t* gcc.dg/compat/struct-layout-1_generate.c (dg_options): Likewise.\n\n\t* gcc.target/i386/pr39082-1.c: New.\n\n\t* gcc.target/x86_64/abi/abi-x86_64.exp (additional_flags): Add\n\t-Wno-abi.\n\n\t* gcc.target/x86_64/abi/args.h (XMM_T): Add _m64 and _m128 if\n\tCHECK_M64_M128 is defined.\n\t(check_f_arguments): Add \"do\".\n\t(check_vector_arguments): New.\n\t(check_m64_arguments): Likewise.\n\t(check_m128_arguments): Likewise.\n\n\t* gcc.target/x86_64/abi/defines.h: Include <xmmintrin.h>.\n\t(CHECK_M64_M128): Define.\n\n\t* gcc.target/x86_64/abi/test_m64m128_returning.c: New.  Based\n\ton abitest.\n\t* gcc.target/x86_64/abi/test_passing_m64m128.c: Likewise.\n\n\t* gcc.target/x86_64/abi/test_passing_structs.c: Define __m128\n\ttests only if CHECK_M64_M128 is defined.\n\n\t* gcc.target/x86_64/abi/test_passing_structs.c (m128_struct): New.\n\t(m128_2_struct): Likewise.\n\t(check_struct_passing5): Likewise.\n\t(check_struct_passing6): Likewise.\n\t(main): Test struct with __m128 if CHECK_M64_M128 is defined.\n\n\t* gcc.target/x86_64/abi/test_passing_unions.c (un4): New.\n\t(un5): Likewise.\n\t(check_union_passing4): Likewise.\n\t(main): Test union with __m128 if CHECK_M64_M128 is defined.\n\nFrom-SVN: r144257", "tree": {"sha": "69c176a033d12f090d8e12d52fe61b4ace95034f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69c176a033d12f090d8e12d52fe61b4ace95034f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5600f233ef5f740908f0480b76936e503b1d4cda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5600f233ef5f740908f0480b76936e503b1d4cda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5600f233ef5f740908f0480b76936e503b1d4cda"}], "stats": {"total": 649, "additions": 634, "deletions": 15}, "files": [{"sha": "780468f393c976fb5d4a5fa94e1445e739ed2dc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -1,3 +1,16 @@\n+2009-02-17  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/39082\n+\t* c.opt (Wabi): Support C and ObjC.\n+\t(Wpsabi): New.\n+\n+\t* c-opts.c (c_common_handle_option): Handle OPT_Wabi.\n+\n+\t* config/i386/i386.c (classify_argument): Warn once about the ABI\n+\tchange when passing union with long double.\n+\n+\t* doc/invoke.texi: Update -Wabi for warning psABI changes.\n+\n 2009-02-18  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/35447"}, {"sha": "28bdc31d5a42a95cb7cf2dd899b66d6855ef09d6", "filename": "gcc/c-opts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -978,6 +978,10 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n     case OPT_v:\n       verbose = true;\n       break;\n+\n+    case OPT_Wabi:\n+      warn_psabi = value;\n+      break;\n     }\n \n   return result;"}, {"sha": "36691c43ae5f4e3127b301522965fdda42e9a966", "filename": "gcc/c.opt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -112,9 +112,12 @@ C ObjC C++ ObjC++ Joined Separate\n -U<macro>\tUndefine <macro>\n \n Wabi\n-C++ ObjC++ Var(warn_abi) Warning\n+C ObjC C++ ObjC++ Var(warn_abi) Warning\n Warn about things that will change when compiling with an ABI-compliant compiler\n \n+Wpsabi\n+C ObjC C++ ObjC++ Var(warn_psabi) Init(1) Undocumented\n+\n Waddress\n C ObjC C++ ObjC++ Var(warn_address) Warning\n Warn about suspicious uses of memory addresses"}, {"sha": "da36f17671a7fd5c8f97c38e3b316b01507ecde2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -5022,10 +5022,24 @@ classify_argument (enum machine_mode mode, const_tree type,\n \t      classes[i] = X86_64_SSE_CLASS;\n \t    }\n \n-\t  /*  X86_64_X87UP_CLASS should be preceded by X86_64_X87_CLASS.  */\n+\t  /*  If X86_64_X87UP_CLASS isn't preceded by X86_64_X87_CLASS,\n+\t       everything should be passed in memory.  */\n \t  if (classes[i] == X86_64_X87UP_CLASS\n-\t      && (i == 0 || classes[i - 1] != X86_64_X87_CLASS))\n-\t    classes[i] = X86_64_SSE_CLASS;\n+\t      && (classes[i - 1] != X86_64_X87_CLASS))\n+\t    {\n+\t      static bool warned;\n+\n+\t      /* The first one should never be X86_64_X87UP_CLASS.  */\n+\t      gcc_assert (i != 0);\n+\t      if (!warned && warn_psabi)\n+\t\t{\n+\t\t  warned = true;\n+\t\t  inform (input_location,\n+\t\t\t  \"The ABI of passing union with long double\"\n+\t\t\t  \" has changed in GCC 4.4\");\n+\t\t}\n+\t      return 0;\n+\t    }\n \t}\n       return words;\n     }"}, {"sha": "f52b6433160c8b6b8e954ee80b34e55d8600c4ee", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -1966,7 +1966,7 @@ Do not assume @samp{inline} for functions defined inside a class scope.\n functions will have linkage like inline functions; they just won't be\n inlined by default.\n \n-@item -Wabi @r{(C++ and Objective-C++ only)}\n+@item -Wabi @r{(C, Objective-C, C++ and Objective-C++ only)}\n @opindex Wabi\n @opindex Wno-abi\n Warn when G++ generates code that is probably not compatible with the\n@@ -2066,6 +2066,27 @@ Instantiations of these templates may be mangled incorrectly.\n \n @end itemize\n \n+It also warns psABI related changes.  The known psABI changes at this\n+point include:\n+\n+@itemize @bullet\n+\n+@item\n+For SYSV/x86-64, when passing union with long double, it is changed to\n+pass in memory as specified in psABI.  For example:\n+\n+@smallexample\n+union U @{\n+  long double ld;\n+  int i;\n+@};\n+@end smallexample\n+\n+@noindent\n+@code{union U} will always be passed in memory.\n+\n+@end itemize\n+\n @item -Wctor-dtor-privacy @r{(C++ and Objective-C++ only)}\n @opindex Wctor-dtor-privacy\n @opindex Wno-ctor-dtor-privacy"}, {"sha": "ca72b0223a43d094b1d59e8a0a18c246c76f27d3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -1,3 +1,43 @@\n+2009-02-17  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/39082\n+\t* g++.dg/compat/struct-layout-1_generate.c (dg_options): Add\n+\t-Wno-abi for x86.\n+\t* gcc.dg/compat/struct-layout-1_generate.c (dg_options): Likewise.\n+\n+\t* gcc.target/i386/pr39082-1.c: New.\n+\n+\t* gcc.target/x86_64/abi/abi-x86_64.exp (additional_flags): Add\n+\t-Wno-abi.\n+\n+\t* gcc.target/x86_64/abi/args.h (XMM_T): Add _m64 and _m128 if\n+\tCHECK_M64_M128 is defined.\n+\t(check_f_arguments): Add \"do\".\n+\t(check_vector_arguments): New.\n+\t(check_m64_arguments): Likewise.\n+\t(check_m128_arguments): Likewise.\n+\n+\t* gcc.target/x86_64/abi/defines.h: Include <xmmintrin.h>.\n+\t(CHECK_M64_M128): Define.\n+\n+\t* gcc.target/x86_64/abi/test_m64m128_returning.c: New.  Based\n+\ton abitest.\n+\t* gcc.target/x86_64/abi/test_passing_m64m128.c: Likewise.\n+\n+\t* gcc.target/x86_64/abi/test_passing_structs.c: Define __m128\n+\ttests only if CHECK_M64_M128 is defined.\n+\n+\t* gcc.target/x86_64/abi/test_passing_structs.c (m128_struct): New.\n+\t(m128_2_struct): Likewise.\n+\t(check_struct_passing5): Likewise.\n+\t(check_struct_passing6): Likewise.\n+\t(main): Test struct with __m128 if CHECK_M64_M128 is defined.\n+\n+\t* gcc.target/x86_64/abi/test_passing_unions.c (un4): New.\n+\t(un5): Likewise.\n+\t(check_union_passing4): Likewise.\n+\t(main): Test union with __m128 if CHECK_M64_M128 is defined.\n+\n 2009-02-18  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/35447"}, {"sha": "93700d20feb4d662ef16c2fdb63cde6e0072d4f8", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -44,9 +44,9 @@ along with GCC; see the file COPYING3.  If not see\n \n const char *dg_options[] = {\n \"/* { dg-options \\\"%s-I%s\\\" } */\\n\",\n-\"/* { dg-options \\\"%s-I%s -mno-mmx\\\" { target i?86-*-* x86_64-*-* } } */\\n\",\n+\"/* { dg-options \\\"%s-I%s -mno-mmx -Wno-abi\\\" { target i?86-*-* x86_64-*-* } } */\\n\",\n \"/* { dg-options \\\"%s-I%s -fno-common\\\" { target hppa*-*-hpux* powerpc*-*-darwin* *-*-mingw32* *-*-cygwin* } } */\\n\",\n-\"/* { dg-options \\\"%s-I%s -mno-mmx -fno-common\\\" { target i?86-*-darwin* x86_64-*-darwin* } } */\\n\",\n+\"/* { dg-options \\\"%s-I%s -mno-mmx -fno-common -Wno-abi\\\" { target i?86-*-darwin* x86_64-*-darwin* } } */\\n\",\n \"/* { dg-options \\\"%s-I%s -mno-base-addresses\\\" { target mmix-*-* } } */\\n\",\n \"/* { dg-options \\\"%s-I%s -mlongcalls -mtext-section-literals\\\" { target xtensa*-*-* } } */\\n\"\n #define NDG_OPTIONS (sizeof (dg_options) / sizeof (dg_options[0]))"}, {"sha": "c08014768bc755eef8b2d44d52e0e5555a467c2e", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -44,9 +44,9 @@ along with GCC; see the file COPYING3.  If not see\n \n const char *dg_options[] = {\n \"/* { dg-options \\\"%s-I%s\\\" } */\\n\",\n-\"/* { dg-options \\\"%s-I%s -mno-mmx\\\" { target i?86-*-* x86_64-*-* } } */\\n\",\n+\"/* { dg-options \\\"%s-I%s -mno-mmx -Wno-abi\\\" { target i?86-*-* x86_64-*-* } } */\\n\",\n \"/* { dg-options \\\"%s-I%s -fno-common\\\" { target hppa*-*-hpux* powerpc*-*-darwin* *-*-mingw32* *-*-cygwin* } } */\\n\",\n-\"/* { dg-options \\\"%s-I%s -mno-mmx -fno-common\\\" { target i?86-*-darwin* x86_64-*-darwin* } } */\\n\",\n+\"/* { dg-options \\\"%s-I%s -mno-mmx -fno-common -Wno-abi\\\" { target i?86-*-darwin* x86_64-*-darwin* } } */\\n\",\n \"/* { dg-options \\\"%s-I%s -mno-base-addresses\\\" { target mmix-*-* } } */\\n\",\n \"/* { dg-options \\\"%s-I%s -mlongcalls -mtext-section-literals\\\" { target xtensa*-*-* } } */\\n\"\n #define NDG_OPTIONS (sizeof (dg_options) / sizeof (dg_options[0]))"}, {"sha": "4c4e2547a88486b926ae0fb36b594fc2e60b564b", "filename": "gcc/testsuite/gcc.target/i386/pr39082-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr39082-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr39082-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr39082-1.c?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -0,0 +1,35 @@\n+/* PR target/39082 */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2\" } */\n+\n+union un\n+{\n+  long double x;\n+  int i;\n+};\n+\n+extern int bar1 (union un);\n+extern union un bar2 (int);\n+\n+int\n+foo1 (union un u) /* { dg-message \"note: The ABI of passing union with long double has changed in GCC 4.4\" } */\n+{\n+  bar1 (u);\n+  return u.i;\n+}\n+\n+int\n+foo2 (void)\n+{\n+  union un u;\n+  u.i = 1;\n+  return foo1 (u) + bar1 (u);\n+}\n+\n+int\n+foo3 (int x)\n+{\n+  union un u = bar2 (x);\n+  return u.i;\n+}"}, {"sha": "57ffc5258790571ff972e3099aa9f201d07af085", "filename": "gcc/testsuite/gcc.target/x86_64/abi/abi-x86_64.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fabi-x86_64.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fabi-x86_64.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fabi-x86_64.exp?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -29,7 +29,7 @@ if { (![istarget x86_64-*-*] && ![istarget i?86-*-*])\n \n torture-init\n set-torture-options $C_TORTURE_OPTIONS\n-set additional_flags \"-W -Wall\"\n+set additional_flags \"-W -Wall -Wno-abi\"\n \n foreach src [lsort [glob -nocomplain $srcdir/$subdir/test_*.c]] {\n     if {[runtest_file_p $runtests $src]} {"}, {"sha": "99d7b76f84d64851bdeb58cb3e9d7a8047cbb1aa", "filename": "gcc/testsuite/gcc.target/x86_64/abi/args.h", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fargs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fargs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fargs.h?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -25,6 +25,10 @@ typedef union {\n   long _long[2];\n   int _int[4];\n   unsigned long _ulong[2];\n+#ifdef CHECK_M64_M128\n+  __m64 _m64[2];\n+  __m128 _m128[1];\n+#endif\n } XMM_T;\n \n typedef union {\n@@ -111,7 +115,7 @@ extern unsigned int num_iregs, num_fregs;\n   clear_int_hardware_registers\n \n /* TODO: Do the checking.  */\n-#define check_f_arguments(T) { \\\n+#define check_f_arguments(T) do { \\\n   assert (num_fregs <= 0 || fregs.xmm0._ ## T [0] == xmm_regs[0]._ ## T [0]); \\\n   assert (num_fregs <= 1 || fregs.xmm1._ ## T [0] == xmm_regs[1]._ ## T [0]); \\\n   assert (num_fregs <= 2 || fregs.xmm2._ ## T [0] == xmm_regs[2]._ ## T [0]); \\\n@@ -125,6 +129,44 @@ extern unsigned int num_iregs, num_fregs;\n #define check_float_arguments check_f_arguments(float)\n #define check_double_arguments check_f_arguments(double)\n \n+#define check_vector_arguments(T,O) do { \\\n+  assert (num_fregs <= 0 \\\n+\t  || memcmp (((char *) &fregs.xmm0) + (O), \\\n+\t\t     &xmm_regs[0], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 1 \\\n+\t  || memcmp (((char *) &fregs.xmm1) + (O), \\\n+\t\t     &xmm_regs[1], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 2 \\\n+\t  || memcmp (((char *) &fregs.xmm2) + (O), \\\n+\t\t     &xmm_regs[2], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 3 \\\n+\t  || memcmp (((char *) &fregs.xmm3) + (O), \\\n+\t\t     &xmm_regs[3], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 4 \\\n+\t  || memcmp (((char *) &fregs.xmm4) + (O), \\\n+\t\t     &xmm_regs[4], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 5 \\\n+\t  || memcmp (((char *) &fregs.xmm5) + (O), \\\n+\t\t     &xmm_regs[5], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 6 \\\n+\t  || memcmp (((char *) &fregs.xmm6) + (O), \\\n+\t\t     &xmm_regs[6], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 7 \\\n+\t  || memcmp (((char *) &fregs.xmm7) + (O), \\\n+\t\t     &xmm_regs[7], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  } while (0)\n+\n+#define check_m64_arguments check_vector_arguments(m64, 0)\n+#define check_m128_arguments check_vector_arguments(m128, 0)\n+\n /* ldoubles are not passed in registers */\n #define check_ldouble_arguments\n "}, {"sha": "a32daf694682545b3580f9af64669cf9e5ec10a4", "filename": "gcc/testsuite/gcc.target/x86_64/abi/defines.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fdefines.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fdefines.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fdefines.h?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -1,6 +1,9 @@\n #ifndef DEFINED_DEFINES_H\n #define DEFINED_DEFINES_H\n \n+/* Get __m64 and __m128. */\n+#include <xmmintrin.h>\n+\n typedef unsigned long ulong;\n typedef long double ldouble;\n \n@@ -18,7 +21,7 @@ typedef long double ldouble;\n /* #define CHECK_FLOAT128 */\n \n /* Scalar types __m64 and __m128.  */\n-/* #define CHECK_M64_M128 */\n+#define CHECK_M64_M128\n \n /* Returning of complex type.  */\n #define CHECK_COMPLEX"}, {"sha": "cde0346935c9e7049aca90a7efa7c7ec46ba3f91", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_m64m128_returning.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_m64m128_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_m64m128_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_m64m128_returning.c?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -0,0 +1,54 @@\n+#include <stdio.h>\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+__m64\n+fun_test_returning___m64 (void)\n+{\n+  volatile_var++;\n+  return (__m64){72,0};\n+}\n+\n+__m128\n+fun_test_returning___m128 (void)\n+{\n+  volatile_var++;\n+  return (__m128){73,0,0,0};\n+}\n+\n+__m64 test_64;\n+__m128 test_128;\n+\n+int\n+main (void)\n+{\n+  unsigned failed = 0;\n+  XMM_T xmmt1, xmmt2;\n+\n+  /* We jump through hoops to compare the results as gcc 3.3 does throw\n+     an ICE when trying to generate a compare for a == b, when a and b\n+     are of __m64 or __m128 type :-(  */\n+  clear_struct_registers;\n+  test_64 = (__m64){72,0};\n+  xmmt1._m64[0] = test_64;\n+  xmmt2._m64[0] = WRAP_RET (fun_test_returning___m64)();\n+  if (xmmt1._long[0] != xmmt2._long[0]\n+      || xmmt1._long[0] != xmm_regs[0]._long[0])\n+    printf (\"fail m64\\n\"), failed++;\n+\n+  clear_struct_registers;\n+  test_128 = (__m128){73,0};\n+  xmmt1._m128[0] = test_128;\n+  xmmt2._m128[0] = WRAP_RET (fun_test_returning___m128)();\n+  if (xmmt1._long[0] != xmmt2._long[0]\n+      || xmmt1._long[0] != xmm_regs[0]._long[0])\n+    printf (\"fail m128\\n\"), failed++;\n+  if (failed)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "237435c4e4efe20259ad23a4bf1c00529782855a", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_passing_m64m128.c", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_m64m128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_m64m128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_m64m128.c?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -0,0 +1,249 @@\n+#include <stdio.h>\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  XMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+void\n+fun_check_passing_m64_8_values (__m64 i0 ATTRIBUTE_UNUSED, __m64 i1 ATTRIBUTE_UNUSED, __m64 i2 ATTRIBUTE_UNUSED, __m64 i3 ATTRIBUTE_UNUSED, __m64 i4 ATTRIBUTE_UNUSED, __m64 i5 ATTRIBUTE_UNUSED, __m64 i6 ATTRIBUTE_UNUSED, __m64 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m64);\n+  compare (values.i1, i1, __m64);\n+  compare (values.i2, i2, __m64);\n+  compare (values.i3, i3, __m64);\n+  compare (values.i4, i4, __m64);\n+  compare (values.i5, i5, __m64);\n+  compare (values.i6, i6, __m64);\n+  compare (values.i7, i7, __m64);\n+}\n+\n+void\n+fun_check_passing_m64_8_regs (__m64 i0 ATTRIBUTE_UNUSED, __m64 i1 ATTRIBUTE_UNUSED, __m64 i2 ATTRIBUTE_UNUSED, __m64 i3 ATTRIBUTE_UNUSED, __m64 i4 ATTRIBUTE_UNUSED, __m64 i5 ATTRIBUTE_UNUSED, __m64 i6 ATTRIBUTE_UNUSED, __m64 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m64_arguments;\n+}\n+\n+void\n+fun_check_passing_m64_20_values (__m64 i0 ATTRIBUTE_UNUSED, __m64 i1 ATTRIBUTE_UNUSED, __m64 i2 ATTRIBUTE_UNUSED, __m64 i3 ATTRIBUTE_UNUSED, __m64 i4 ATTRIBUTE_UNUSED, __m64 i5 ATTRIBUTE_UNUSED, __m64 i6 ATTRIBUTE_UNUSED, __m64 i7 ATTRIBUTE_UNUSED, __m64 i8 ATTRIBUTE_UNUSED, __m64 i9 ATTRIBUTE_UNUSED, __m64 i10 ATTRIBUTE_UNUSED, __m64 i11 ATTRIBUTE_UNUSED, __m64 i12 ATTRIBUTE_UNUSED, __m64 i13 ATTRIBUTE_UNUSED, __m64 i14 ATTRIBUTE_UNUSED, __m64 i15 ATTRIBUTE_UNUSED, __m64 i16 ATTRIBUTE_UNUSED, __m64 i17 ATTRIBUTE_UNUSED, __m64 i18 ATTRIBUTE_UNUSED, __m64 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0 , i0, __m64);\n+  compare (values.i1 , i1, __m64);\n+  compare (values.i2 , i2, __m64);\n+  compare (values.i3 , i3, __m64);\n+  compare (values.i4 , i4, __m64);\n+  compare (values.i5 , i5, __m64);\n+  compare (values.i6 , i6, __m64);\n+  compare (values.i7 , i7, __m64);\n+  compare (values.i8 , i8, __m64);\n+  compare (values.i9 , i9, __m64);\n+  compare (values.i10 , i10, __m64);\n+  compare (values.i11 , i11, __m64);\n+  compare (values.i12 , i12, __m64);\n+  compare (values.i13 , i13, __m64);\n+  compare (values.i14 , i14, __m64);\n+  compare (values.i15 , i15, __m64);\n+  compare (values.i16 , i16, __m64);\n+  compare (values.i17 , i17, __m64);\n+  compare (values.i18 , i18, __m64);\n+  compare (values.i19 , i19, __m64);\n+}\n+\n+void\n+fun_check_passing_m64_20_regs (__m64 i0 ATTRIBUTE_UNUSED, __m64 i1 ATTRIBUTE_UNUSED, __m64 i2 ATTRIBUTE_UNUSED, __m64 i3 ATTRIBUTE_UNUSED, __m64 i4 ATTRIBUTE_UNUSED, __m64 i5 ATTRIBUTE_UNUSED, __m64 i6 ATTRIBUTE_UNUSED, __m64 i7 ATTRIBUTE_UNUSED, __m64 i8 ATTRIBUTE_UNUSED, __m64 i9 ATTRIBUTE_UNUSED, __m64 i10 ATTRIBUTE_UNUSED, __m64 i11 ATTRIBUTE_UNUSED, __m64 i12 ATTRIBUTE_UNUSED, __m64 i13 ATTRIBUTE_UNUSED, __m64 i14 ATTRIBUTE_UNUSED, __m64 i15 ATTRIBUTE_UNUSED, __m64 i16 ATTRIBUTE_UNUSED, __m64 i17 ATTRIBUTE_UNUSED, __m64 i18 ATTRIBUTE_UNUSED, __m64 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m64_arguments;\n+}\n+\n+void\n+fun_check_passing_m128_8_values (__m128 i0 ATTRIBUTE_UNUSED, __m128 i1 ATTRIBUTE_UNUSED, __m128 i2 ATTRIBUTE_UNUSED, __m128 i3 ATTRIBUTE_UNUSED, __m128 i4 ATTRIBUTE_UNUSED, __m128 i5 ATTRIBUTE_UNUSED, __m128 i6 ATTRIBUTE_UNUSED, __m128 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m128);\n+  compare (values.i1, i1, __m128);\n+  compare (values.i2, i2, __m128);\n+  compare (values.i3, i3, __m128);\n+  compare (values.i4, i4, __m128);\n+  compare (values.i5, i5, __m128);\n+  compare (values.i6, i6, __m128);\n+  compare (values.i7, i7, __m128);\n+}\n+\n+void\n+fun_check_passing_m128_8_regs (__m128 i0 ATTRIBUTE_UNUSED, __m128 i1 ATTRIBUTE_UNUSED, __m128 i2 ATTRIBUTE_UNUSED, __m128 i3 ATTRIBUTE_UNUSED, __m128 i4 ATTRIBUTE_UNUSED, __m128 i5 ATTRIBUTE_UNUSED, __m128 i6 ATTRIBUTE_UNUSED, __m128 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m128_arguments;\n+}\n+\n+void\n+fun_check_passing_m128_20_values (__m128 i0 ATTRIBUTE_UNUSED, __m128 i1 ATTRIBUTE_UNUSED, __m128 i2 ATTRIBUTE_UNUSED, __m128 i3 ATTRIBUTE_UNUSED, __m128 i4 ATTRIBUTE_UNUSED, __m128 i5 ATTRIBUTE_UNUSED, __m128 i6 ATTRIBUTE_UNUSED, __m128 i7 ATTRIBUTE_UNUSED, __m128 i8 ATTRIBUTE_UNUSED, __m128 i9 ATTRIBUTE_UNUSED, __m128 i10 ATTRIBUTE_UNUSED, __m128 i11 ATTRIBUTE_UNUSED, __m128 i12 ATTRIBUTE_UNUSED, __m128 i13 ATTRIBUTE_UNUSED, __m128 i14 ATTRIBUTE_UNUSED, __m128 i15 ATTRIBUTE_UNUSED, __m128 i16 ATTRIBUTE_UNUSED, __m128 i17 ATTRIBUTE_UNUSED, __m128 i18 ATTRIBUTE_UNUSED, __m128 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0 , i0, __m128);\n+  compare (values.i1 , i1, __m128);\n+  compare (values.i2 , i2, __m128);\n+  compare (values.i3 , i3, __m128);\n+  compare (values.i4 , i4, __m128);\n+  compare (values.i5 , i5, __m128);\n+  compare (values.i6 , i6, __m128);\n+  compare (values.i7 , i7, __m128);\n+  compare (values.i8 , i8, __m128);\n+  compare (values.i9 , i9, __m128);\n+  compare (values.i10 , i10, __m128);\n+  compare (values.i11 , i11, __m128);\n+  compare (values.i12 , i12, __m128);\n+  compare (values.i13 , i13, __m128);\n+  compare (values.i14 , i14, __m128);\n+  compare (values.i15 , i15, __m128);\n+  compare (values.i16 , i16, __m128);\n+  compare (values.i17 , i17, __m128);\n+  compare (values.i18 , i18, __m128);\n+  compare (values.i19 , i19, __m128);\n+}\n+\n+void\n+fun_check_passing_m128_20_regs (__m128 i0 ATTRIBUTE_UNUSED, __m128 i1 ATTRIBUTE_UNUSED, __m128 i2 ATTRIBUTE_UNUSED, __m128 i3 ATTRIBUTE_UNUSED, __m128 i4 ATTRIBUTE_UNUSED, __m128 i5 ATTRIBUTE_UNUSED, __m128 i6 ATTRIBUTE_UNUSED, __m128 i7 ATTRIBUTE_UNUSED, __m128 i8 ATTRIBUTE_UNUSED, __m128 i9 ATTRIBUTE_UNUSED, __m128 i10 ATTRIBUTE_UNUSED, __m128 i11 ATTRIBUTE_UNUSED, __m128 i12 ATTRIBUTE_UNUSED, __m128 i13 ATTRIBUTE_UNUSED, __m128 i14 ATTRIBUTE_UNUSED, __m128 i15 ATTRIBUTE_UNUSED, __m128 i16 ATTRIBUTE_UNUSED, __m128 i17 ATTRIBUTE_UNUSED, __m128 i18 ATTRIBUTE_UNUSED, __m128 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m128_arguments;\n+}\n+\n+\n+#define def_check_int_passing8(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _func1, _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7); \\\n+  \\\n+  clear_float_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7);\n+\n+#define def_check_int_passing20(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11, _i12, _i13, _i14, _i15, _i16, _i17, _i18, _i19, _func1, _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  values.i10.TYPE[0] = _i10; \\\n+  values.i11.TYPE[0] = _i11; \\\n+  values.i12.TYPE[0] = _i12; \\\n+  values.i13.TYPE[0] = _i13; \\\n+  values.i14.TYPE[0] = _i14; \\\n+  values.i15.TYPE[0] = _i15; \\\n+  values.i16.TYPE[0] = _i16; \\\n+  values.i17.TYPE[0] = _i17; \\\n+  values.i18.TYPE[0] = _i18; \\\n+  values.i19.TYPE[0] = _i19; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11, _i12, _i13, _i14, _i15, _i16, _i17, _i18, _i19); \\\n+  \\\n+  clear_float_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11, _i12, _i13, _i14, _i15, _i16, _i17, _i18, _i19);\n+\n+void\n+test_m64_on_stack ()\n+{\n+  __m64 x[8];\n+  int i;\n+  for (i = 0; i < 8; i++)\n+    x[i] = (__m64){32+i, 0};\n+  pass = \"m64-8\";\n+  def_check_int_passing8(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], fun_check_passing_m64_8_values, fun_check_passing_m64_8_regs, _m64);\n+}\n+\n+void\n+test_too_many_m64 ()\n+{\n+  __m64 x[20];\n+  int i;\n+  for (i = 0; i < 20; i++)\n+    x[i] = (__m64){32+i, 0};\n+  pass = \"m64-20\";\n+  def_check_int_passing20(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16], x[17], x[18], x[19], fun_check_passing_m64_20_values, fun_check_passing_m64_20_regs, _m64);\n+}\n+\n+void\n+test_m128_on_stack ()\n+{\n+  __m128 x[8];\n+  int i;\n+  for (i = 0; i < 8; i++)\n+    x[i] = (__m128){32+i, 0, 0, 0};\n+  pass = \"m128-8\";\n+  def_check_int_passing8(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], fun_check_passing_m128_8_values, fun_check_passing_m128_8_regs, _m128);\n+}\n+\n+void\n+test_too_many_m128 ()\n+{\n+  __m128 x[20];\n+  int i;\n+  for (i = 0; i < 20; i++)\n+    x[i] = (__m128){32+i, 0, 0, 0};\n+  pass = \"m128-20\";\n+  def_check_int_passing20(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16], x[17], x[18], x[19], fun_check_passing_m128_20_values, fun_check_passing_m128_20_regs, _m128);\n+}\n+\n+int\n+main (void)\n+{\n+  test_m64_on_stack ();\n+  test_too_many_m64 ();\n+  test_m128_on_stack ();\n+  test_too_many_m128 ();\n+  if (failed)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "3ce0db14652e4ed6f579a3b9ed3fdf3830d2a55f", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_passing_structs.c", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_structs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_structs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_structs.c?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -1,4 +1,4 @@\n-/* This tests passing of structs. Only integers are tested.  */\n+/* This tests passing of structs. */\n \n #include \"defines.h\"\n #include \"args.h\"\n@@ -57,6 +57,40 @@ check_struct_passing4 (struct long3_struct ls ATTRIBUTE_UNUSED)\n   assert ((unsigned long)&ls.l3 == rsp+24);\n }\n \n+#ifdef CHECK_M64_M128\n+struct m128_struct\n+{\n+  __m128 x;\n+};\n+\n+struct m128_2_struct\n+{\n+  __m128 x1, x2;\n+};\n+\n+/* Check that the struct is passed as the individual members in fregs.  */\n+void\n+check_struct_passing5 (struct m128_struct ms1 ATTRIBUTE_UNUSED,\n+\t\t       struct m128_struct ms2 ATTRIBUTE_UNUSED,\n+\t\t       struct m128_struct ms3 ATTRIBUTE_UNUSED,\n+\t\t       struct m128_struct ms4 ATTRIBUTE_UNUSED,\n+\t\t       struct m128_struct ms5 ATTRIBUTE_UNUSED,\n+\t\t       struct m128_struct ms6 ATTRIBUTE_UNUSED,\n+\t\t       struct m128_struct ms7 ATTRIBUTE_UNUSED,\n+\t\t       struct m128_struct ms8 ATTRIBUTE_UNUSED)\n+{\n+  check_m128_arguments;\n+}\n+\n+void\n+check_struct_passing6 (struct m128_2_struct ms ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ms.x1 == rsp+8);\n+  assert ((unsigned long)&ms.x2 == rsp+24);\n+}\n+#endif\n \n int\n main (void)\n@@ -67,6 +101,14 @@ main (void)\n   struct long2_struct l2s = { 50, 51 };\n   struct long3_struct l3s = { 52, 53, 54 };\n #endif\n+#ifdef CHECK_M64_M128\n+  struct m128_struct m128s[8];\n+  struct m128_2_struct m128_2s = { \n+      { 48.394, 39.3, -397.9, 3484.9 },\n+      { -8.394, -93.3, 7.9, 84.94 }\n+  };\n+  int i;\n+#endif\n \n   clear_struct_registers;\n   iregs.I0 = is.i;\n@@ -90,5 +132,19 @@ main (void)\n   WRAP_CALL (check_struct_passing4)(l3s);\n #endif\n \n+#ifdef CHECK_M64_M128\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      m128s[i].x = (__m128){32+i, 0, i, 0};\n+      fregs.xmm0._m128[i] = m128s[i].x;\n+    }\n+  num_fregs = 8;\n+  clear_float_hardware_registers;\n+  WRAP_CALL (check_struct_passing5)(m128s[0], m128s[1], m128s[2], m128s[3],\n+\t\t\t\t    m128s[4], m128s[5], m128s[6], m128s[7]);\n+  WRAP_CALL (check_struct_passing6)(m128_2s);\n+#endif\n+\n   return 0;\n }"}, {"sha": "1e3e85fdb5025586d9199573116c5ed145b2d22f", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_passing_unions.c", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce08d5003e0cb1f63cbe92895be8cbcc5c48547/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_unions.c?ref=bce08d5003e0cb1f63cbe92895be8cbcc5c48547", "patch": "@@ -1,4 +1,4 @@\n-/* This tests passing of structs. Only integers are tested.  */\n+/* This tests passing of structs.  */\n \n #include \"defines.h\"\n #include \"args.h\"\n@@ -45,7 +45,7 @@ check_union_passing1(union un1 u ATTRIBUTE_UNUSED)\n }\n \n void\n-check_union_passing2(union un2 u ATTRIBUTE_UNUSED)\n+check_union_passing2(union un2 u1 ATTRIBUTE_UNUSED)\n {\n   check_int_arguments;\n }\n@@ -60,6 +60,61 @@ check_union_passing3(union un3 u ATTRIBUTE_UNUSED)\n #define check_union_passing2 WRAP_CALL(check_union_passing2)\n #define check_union_passing3 WRAP_CALL(check_union_passing3)\n \n+#ifdef CHECK_M64_M128\n+union un4\n+{\n+  __m128 x;\n+  float f;\n+};\n+\n+union un5\n+{\n+  __m128 x;\n+  long i;\n+};\n+\n+void\n+check_union_passing4(union un4 u1 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u2 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u3 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u4 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u5 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u6 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u7 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m128_arguments;\n+}\n+\n+void\n+check_union_passing5(union un5 u ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+  check_vector_arguments(m128, 8);\n+}\n+\n+#define check_union_passing4 WRAP_CALL(check_union_passing4)\n+#define check_union_passing5 WRAP_CALL(check_union_passing5)\n+#endif\n+\n+union un6\n+{\n+  long double ld;\n+  int i;\n+};\n+\n+\n+void\n+check_union_passing6(union un6 u ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.ld == rsp+8);\n+  assert ((unsigned long)&u.i == rsp+8);\n+}\n+\n+#define check_union_passing6 WRAP_CALL(check_union_passing6)\n+\n int\n main (void)\n {\n@@ -70,6 +125,12 @@ main (void)\n   struct int_struct is;\n   struct long_struct ls;\n #endif /* CHECK_LARGER_UNION_PASSING */\n+#ifdef CHECK_M64_M128\n+  union un4 u4[8];\n+  union un5 u5 = { { 48.394, 39.3, -397.9, 3484.9 } };\n+  int i;\n+#endif\n+  union un6 u6;\n \n   /* Check a union with char, int.  */\n   clear_struct_registers;\n@@ -140,5 +201,29 @@ main (void)\n   check_union_passing3(u3);\n #endif /* CHECK_LARGER_UNION_PASSING */\n \n+#ifdef CHECK_M64_M128\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u4[i].x = (__m128){32+i, 0, i, 0};\n+      fregs.xmm0._m128[i] = u4[i].x;\n+    }\n+  num_fregs = 8;\n+  clear_float_hardware_registers;\n+  check_union_passing4(u4[0], u4[1], u4[2], u4[3],\n+\t\t       u4[4], u4[5], u4[6], u4[7]);\n+\n+  clear_struct_registers;\n+  fregs.xmm0._m128[0] = u5.x;\n+  num_fregs = 1;\n+  num_iregs = 1;\n+  iregs.I0 = u5.i;\n+  clear_float_hardware_registers;\n+  check_union_passing5(u5);\n+#endif\n+\n+  u6.i = 2;\n+  check_union_passing6(u6);\n+\n   return 0;\n }"}]}