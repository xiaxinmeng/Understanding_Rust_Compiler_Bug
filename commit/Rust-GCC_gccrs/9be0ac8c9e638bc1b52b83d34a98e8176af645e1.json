{"sha": "9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJlMGFjOGM5ZTYzOGJjMWI1MmI4M2QzNGE5OGU4MTc2YWY2NDVlMQ==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2012-09-24T18:22:31Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2012-09-24T18:22:31Z"}, "message": "Finish conversion of uses of double_int to the new API.\n\nSome old functionality required new interfaces, and these have been added to\ndouble-int.[hc]:\n\n  double_int::from_pair - static constructor function\n  wide_mul_with_sign - double-wide multiply instruction\n  sub_with_overflow - subtraction with overlow testing\n  neg_with_overflow - negation with overlow testing\n  divmod_with_overflow - div and mod with overlow testing\n\nThis patch corrects the bootstrap problem on HPPA, via the addition of\nsub_with_overflow.  (The overflow properties of negation and addition are\ndifferent from subtraction.)\n\nThe prior two generations of the interface have been removed.\n\nSome of these old interfaces are still used as static implementation in\ndouble-int.c.\n\nThe changed compiler appears 0.321% faster with 80% confidence of being faster.\n\nTested on x86_64, HPPA, and SPARC.  However, there are changes to the avr\nconfig files, and I have not tested those.\n\n\nIndex: gcc/java/ChangeLog\n\n2012-09-24  Lawrence Crowl  <crowl@google.com>\n\n\t* decl.c (java_init_decl_processing): Change to new double_int API.\n\t* jcf-parse.c (get_constant): Likewise.\n\t* boehm.c (mark_reference_fields): Likewise.\n\t(get_boehm_type_descriptor): Likewise.\n\nIndex: gcc/ChangeLog\n\n2012-09-24  Lawrence Crowl  <crowl@google.com>\n\n\t* double-int.h (double_int::from_pair): New.\n\t(double_int::wide_mul_with_sign): New.\n\t(double_int::sub_with_overflow): New.\n\t(double_int::neg_with_overflow): New.\n\t(double_int::divmod_with_overflow): New.\n\t(shwi_to_double_int): Remove.\n\t(uhwi_to_double_int): Remove.\n\t(double_int_to_shwi): Remove.\n\t(double_int_to_uhwi): Remove.\n\t(double_int_fits_in_uhwi_p): Remove.\n\t(double_int_fits_in_shwi_p): Remove.\n\t(double_int_fits_in_hwi_p): Remove.\n\t(double_int_mul): Remove.\n\t(double_int_mul_with_sign): Remove.\n\t(double_int_add): Remove.\n\t(double_int_sub): Remove.\n\t(double_int_neg): Remove.\n\t(double_int_div): Remove.\n\t(double_int_sdiv): Remove.\n\t(double_int_udiv): Remove.\n\t(double_int_mod): Remove.\n\t(double_int_smod): Remove.\n\t(double_int_umod): Remove.\n\t(double_int_divmod): Remove.\n\t(double_int_sdivmod): Remove.\n\t(double_int_udivmod): Remove.\n\t(double_int_multiple_of): Remove.\n\t(double_int_setbit): Remove.\n\t(double_int_ctz): Remove.\n\t(double_int_not): Remove.\n\t(double_int_ior): Remove.\n\t(double_int_and): Remove.\n\t(double_int_and_not): Remove.\n\t(double_int_xor): Remove.\n\t(double_int_lshift): Remove.\n\t(double_int_rshift): Remove.\n\t(double_int_lrotate): Remove.\n\t(double_int_rrotate): Remove.\n\t(double_int_negative_p): Remove.\n\t(double_int_cmp): Remove.\n\t(double_int_scmp): Remove.\n\t(double_int_ucmp): Remove.\n\t(double_int_max): Remove.\n\t(double_int_smax): Remove.\n\t(double_int_umax): Remove.\n\t(double_int_min): Remove.\n\t(double_int_smin): Remove.\n\t(double_int_umin): Remove.\n\t(double_int_ext): Remove.\n\t(double_int_sext): Remove.\n\t(double_int_zext): Remove.\n\t(double_int_mask): Remove.\n\t(double_int_max_value): Remove.\n\t(double_int_min_value): Remove.\n\t(double_int_zero_p): Remove.\n\t(double_int_one_p): Remove.\n\t(double_int_minus_one_p): Remove.\n\t(double_int_equal_p): Remove.\n\t(double_int_popcount): Remove.\n\t(extern add_double_with_sign): Remove.\n\t(#define add_double): Remove.\n\t(extern neg_double): Remove.\n\t(extern mul_double_with_sign): Remove.\n\t(extern mul_double_wide_with_sign): Remove.\n\t(#define mul_double): Remove.\n\t(extern lshift_double): Remove.\n\t(extern div_and_round_double): Remove.\n\t* double-int.c (add_double_with_sign): Make static.\n\t(#defined add_double): Localized from header.\n\t(neg_double): Make static.\n\t(mul_double_with_sign): Make static.\n\t(mul_double_wide_with_sign): Make static.\n\t(#defined mul_double): Localized from header.\n\t(lshift_double): Make static.\n\t(div_and_round_double): Make static.\n\t(double_int::wide_mul_with_sign): New.\n\t(double_int::sub_with_overflow): New.\n\t(double_int::neg_with_overflow): New.\n\t(double_int::divmod_with_overflow): New.\n\t* emit-rtl.c (init_emit_once): Change to new double_int API.\n\t* explow.c (plus_constant): Likewise.\n\t* expmed.c (choose_multiplier): Likewise.\n\t* fold-const.c (#define OVERFLOW_SUM_SIGN): Remove.\n\t(int_const_binop_1): Change to new double_int API.\n\t(fold_div_compare): Likewise.\n\t(maybe_canonicalize_comparison): Likewise.\n\t(pointer_may_wrap_p): Likewise.\n\t(fold_negate_const): Likewise.\n\t(fold_abs_const): Likewise.\n\t* simplify-rtx.c (simplify_const_unary_operation): Likewise.\n\t(simplify_const_binary_operation): Likewise.\n\t* tree-chrec.c (tree_fold_binomial): Likewise.\n\t* tree-vrp.c (extract_range_from_binary_expr_1): Likewise.\n\t* config/sparc/sparc.c (sparc_fold_builtin): Likewise.\n\t* config/avr/avr.c (avr_double_int_push_digit): Likewise.\n\t(avr_map): Likewise.\n\t(avr_map_decompose): Likewise.\n\t(avr_out_insert_bits): Likewise.\n\nIndex: gcc/cp/ChangeLog\n\n2012-09-24  Lawrence Crowl  <crowl@google.com>\n\n\t* init.c (build_new_1): Change to new double_int API.\n\t* decl.c (build_enumerator): Likewise.\n\t* typeck2.c (process_init_constructor_array): Likewise.\n\t* mangle.c (write_array_type): Likewise.\n\nIndex: gcc/fortran/ChangeLog\n\n2012-09-24  Lawrence Crowl  <crowl@google.com>\n\n\t* trans-expr.c (gfc_conv_cst_int_power): Change to new double_int API.\n\t* target-memory.c (gfc_interpret_logical): Likewise.\n\nFrom-SVN: r191675", "tree": {"sha": "023b0bf502c0f425e346dd501e463d522b3de28e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/023b0bf502c0f425e346dd501e463d522b3de28e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/comments", "author": null, "committer": null, "parents": [{"sha": "ee38ecd4066dc3af0b893f2f4cda42d7938fa951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee38ecd4066dc3af0b893f2f4cda42d7938fa951", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee38ecd4066dc3af0b893f2f4cda42d7938fa951"}], "stats": {"total": 1224, "additions": 450, "deletions": 774}, "files": [{"sha": "276feadea13aa92f427cca53d098320512a69a55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -1,3 +1,104 @@\n+2012-09-24  Lawrence Crowl  <crowl@google.com>\n+\n+\t* double-int.h (double_int::from_pair): New.\n+\t(double_int::wide_mul_with_sign): New.\n+\t(double_int::sub_with_overflow): New.\n+\t(double_int::neg_with_overflow): New.\n+\t(double_int::divmod_with_overflow): New.\n+\t(shwi_to_double_int): Remove.\n+\t(uhwi_to_double_int): Remove.\n+\t(double_int_to_shwi): Remove.\n+\t(double_int_to_uhwi): Remove.\n+\t(double_int_fits_in_uhwi_p): Remove.\n+\t(double_int_fits_in_shwi_p): Remove.\n+\t(double_int_fits_in_hwi_p): Remove.\n+\t(double_int_mul): Remove.\n+\t(double_int_mul_with_sign): Remove.\n+\t(double_int_add): Remove.\n+\t(double_int_sub): Remove.\n+\t(double_int_neg): Remove.\n+\t(double_int_div): Remove.\n+\t(double_int_sdiv): Remove.\n+\t(double_int_udiv): Remove.\n+\t(double_int_mod): Remove.\n+\t(double_int_smod): Remove.\n+\t(double_int_umod): Remove.\n+\t(double_int_divmod): Remove.\n+\t(double_int_sdivmod): Remove.\n+\t(double_int_udivmod): Remove.\n+\t(double_int_multiple_of): Remove.\n+\t(double_int_setbit): Remove.\n+\t(double_int_ctz): Remove.\n+\t(double_int_not): Remove.\n+\t(double_int_ior): Remove.\n+\t(double_int_and): Remove.\n+\t(double_int_and_not): Remove.\n+\t(double_int_xor): Remove.\n+\t(double_int_lshift): Remove.\n+\t(double_int_rshift): Remove.\n+\t(double_int_lrotate): Remove.\n+\t(double_int_rrotate): Remove.\n+\t(double_int_negative_p): Remove.\n+\t(double_int_cmp): Remove.\n+\t(double_int_scmp): Remove.\n+\t(double_int_ucmp): Remove.\n+\t(double_int_max): Remove.\n+\t(double_int_smax): Remove.\n+\t(double_int_umax): Remove.\n+\t(double_int_min): Remove.\n+\t(double_int_smin): Remove.\n+\t(double_int_umin): Remove.\n+\t(double_int_ext): Remove.\n+\t(double_int_sext): Remove.\n+\t(double_int_zext): Remove.\n+\t(double_int_mask): Remove.\n+\t(double_int_max_value): Remove.\n+\t(double_int_min_value): Remove.\n+\t(double_int_zero_p): Remove.\n+\t(double_int_one_p): Remove.\n+\t(double_int_minus_one_p): Remove.\n+\t(double_int_equal_p): Remove.\n+\t(double_int_popcount): Remove.\n+\t(extern add_double_with_sign): Remove.\n+\t(#define add_double): Remove.\n+\t(extern neg_double): Remove.\n+\t(extern mul_double_with_sign): Remove.\n+\t(extern mul_double_wide_with_sign): Remove.\n+\t(#define mul_double): Remove.\n+\t(extern lshift_double): Remove.\n+\t(extern div_and_round_double): Remove.\n+\t* double-int.c (add_double_with_sign): Make static.\n+\t(#defined add_double): Localized from header.\n+\t(neg_double): Make static.\n+\t(mul_double_with_sign): Make static.\n+\t(mul_double_wide_with_sign): Make static.\n+\t(#defined mul_double): Localized from header.\n+\t(lshift_double): Make static.\n+\t(div_and_round_double): Make static.\n+\t(double_int::wide_mul_with_sign): New.\n+\t(double_int::sub_with_overflow): New.\n+\t(double_int::neg_with_overflow): New.\n+\t(double_int::divmod_with_overflow): New.\n+\t* emit-rtl.c (init_emit_once): Change to new double_int API.\n+\t* explow.c (plus_constant): Likewise.\n+\t* expmed.c (choose_multiplier): Likewise.\n+\t* fold-const.c (#define OVERFLOW_SUM_SIGN): Remove.\n+\t(int_const_binop_1): Change to new double_int API.\n+\t(fold_div_compare): Likewise.\n+\t(maybe_canonicalize_comparison): Likewise.\n+\t(pointer_may_wrap_p): Likewise.\n+\t(fold_negate_const): Likewise.\n+\t(fold_abs_const): Likewise.\n+\t* simplify-rtx.c (simplify_const_unary_operation): Likewise.\n+\t(simplify_const_binary_operation): Likewise.\n+\t* tree-chrec.c (tree_fold_binomial): Likewise.\n+\t* tree-vrp.c (extract_range_from_binary_expr_1): Likewise.\n+\t* config/sparc/sparc.c (sparc_fold_builtin): Likewise.\n+\t* config/avr/avr.c (avr_double_int_push_digit): Likewise.\n+\t(avr_map): Likewise.\n+\t(avr_map_decompose): Likewise.\n+\t(avr_out_insert_bits): Likewise.\n+\n 2012-09-24  Janis Johnson  <janisjo@codesourcery.com>\n \n \tdoc/sourcebuild.texi (Selectors): Document the use of target"}, {"sha": "ea36a54fcff32d75a0a0bf3c9745610a738c6f3a", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -10812,10 +10812,10 @@ avr_double_int_push_digit (double_int val, int base,\n                            unsigned HOST_WIDE_INT digit)\n {\n   val = 0 == base\n-    ? double_int_lshift (val, 32, 64, false)\n-    : double_int_mul (val, uhwi_to_double_int (base));\n+    ? val.llshift (32, 64)\n+    : val * double_int::from_uhwi (base);\n   \n-  return double_int_add (val, uhwi_to_double_int (digit));\n+  return val + double_int::from_uhwi (digit);\n }\n \n \n@@ -10824,7 +10824,7 @@ avr_double_int_push_digit (double_int val, int base,\n static int\n avr_map (double_int f, int x)\n {\n-  return 0xf & double_int_to_uhwi (double_int_rshift (f, 4*x, 64, false));\n+  return 0xf & f.lrshift (4*x, 64).to_uhwi ();\n }\n \n \n@@ -10997,7 +10997,7 @@ avr_map_decompose (double_int f, const avr_map_op_t *g, bool val_const_p)\n          are mapped to 0 and used operands are reloaded to xop[0].  */\n \n       xop[0] = all_regs_rtx[24];\n-      xop[1] = gen_int_mode (double_int_to_uhwi (f_ginv.map), SImode);\n+      xop[1] = gen_int_mode (f_ginv.map.to_uhwi (), SImode);\n       xop[2] = all_regs_rtx[25];\n       xop[3] = val_used_p ? xop[0] : const0_rtx;\n   \n@@ -11093,7 +11093,7 @@ avr_out_insert_bits (rtx *op, int *plen)\n   else if (flag_print_asm_name)\n     fprintf (asm_out_file,\n              ASM_COMMENT_START \"map = 0x%08\" HOST_LONG_FORMAT \"x\\n\",\n-             double_int_to_uhwi (map) & GET_MODE_MASK (SImode));\n+             map.to_uhwi () & GET_MODE_MASK (SImode));\n \n   /* If MAP has fixed points it might be better to initialize the result\n      with the bits to be inserted instead of moving all bits by hand.  */"}, {"sha": "fa36901f9e04f9b222b19afc80f5479c564f71e7", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -10129,35 +10129,30 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \t  && TREE_CODE (arg1) == VECTOR_CST\n \t  && TREE_CODE (arg2) == INTEGER_CST)\n \t{\n-\t  int overflow = 0;\n-\t  unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (arg2);\n-\t  HOST_WIDE_INT high = TREE_INT_CST_HIGH (arg2);\n+\t  bool overflow = false;\n+\t  double_int di_arg2 = TREE_INT_CST (arg2);\n+\t  double_int tmp;\n \t  unsigned i;\n \n \t  for (i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n \t    {\n-\t      unsigned HOST_WIDE_INT\n-\t\tlow0 = TREE_INT_CST_LOW (VECTOR_CST_ELT (arg0, i)),\n-\t\tlow1 = TREE_INT_CST_LOW (VECTOR_CST_ELT (arg1, i));\n-\t      HOST_WIDE_INT\n-\t\thigh0 = TREE_INT_CST_HIGH (VECTOR_CST_ELT (arg0, i));\n-\t      HOST_WIDE_INT\n-\t\thigh1 = TREE_INT_CST_HIGH (VECTOR_CST_ELT (arg1, i));\n-\n-\t      unsigned HOST_WIDE_INT l;\n-\t      HOST_WIDE_INT h;\n-\n-\t      overflow |= neg_double (low1, high1, &l, &h);\n-\t      overflow |= add_double (low0, high0, l, h, &l, &h);\n-\t      if (h < 0)\n-\t\toverflow |= neg_double (l, h, &l, &h);\n-\n-\t      overflow |= add_double (low, high, l, h, &low, &high);\n+\t      double_int e0 = TREE_INT_CST (VECTOR_CST_ELT (arg0, i));\n+\t      double_int e1 = TREE_INT_CST (VECTOR_CST_ELT (arg1, i));\n+\n+\t      bool neg1_ovf, neg2_ovf, add1_ovf, add2_ovf;\n+\n+\t      tmp = e1.neg_with_overflow (&neg1_ovf);\n+\t      tmp = e0.add_with_sign (tmp, false, &add1_ovf);\n+\t      if (tmp.is_negative ())\n+\t\ttmp = tmp.neg_with_overflow (&neg2_ovf);\n+\n+\t      tmp = di_arg2.add_with_sign (tmp, false, &add2_ovf);\n+\t      overflow |= neg1_ovf | neg2_ovf | add1_ovf | add2_ovf;\n \t    }\n \n-\t  gcc_assert (overflow == 0);\n+\t  gcc_assert (!overflow);\n \n-\t  return build_int_cst_wide (rtype, low, high);\n+\t  return build_int_cst_wide (rtype, tmp.low, tmp.high);\n \t}\n \n     default:"}, {"sha": "c03f66a7ad6b7e4c2050e239f94af4c9cd27f973", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -1,3 +1,10 @@\n+2012-09-24  Lawrence Crowl  <crowl@google.com>\n+\n+\t* init.c (build_new_1): Change to new double_int API.\n+\t* decl.c (build_enumerator): Likewise.\n+\t* typeck2.c (process_init_constructor_array): Likewise.\n+\t* mangle.c (write_array_type): Likewise.\n+\n 2012-09-24  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/50828"}, {"sha": "6f2c023aa5fc05f1a39c47e8da348496efc0739d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -12462,8 +12462,6 @@ build_enumerator (tree name, tree value, tree enumtype, location_t loc)\n \t{\n \t  if (TYPE_VALUES (enumtype))\n \t    {\n-\t      HOST_WIDE_INT hi;\n-\t      unsigned HOST_WIDE_INT lo;\n \t      tree prev_value;\n \t      bool overflowed;\n \n@@ -12479,15 +12477,13 @@ build_enumerator (tree name, tree value, tree enumtype, location_t loc)\n \t\tvalue = error_mark_node;\n \t      else\n \t\t{\n-\t\t  overflowed = add_double (TREE_INT_CST_LOW (prev_value),\n-\t\t\t\t\t   TREE_INT_CST_HIGH (prev_value),\n-\t\t\t\t\t   1, 0, &lo, &hi);\n+\t\t  double_int di = TREE_INT_CST (prev_value)\n+\t\t\t\t  .add_with_sign (double_int_one,\n+\t\t\t\t\t\t  false, &overflowed);\n \t\t  if (!overflowed)\n \t\t    {\n-\t\t      double_int di;\n \t\t      tree type = TREE_TYPE (prev_value);\n-\t\t      bool pos = (TYPE_UNSIGNED (type) || hi >= 0);\n-\t\t      di.low = lo; di.high = hi;\n+\t\t      bool pos = TYPE_UNSIGNED (type) || !di.is_negative ();\n \t\t      if (!double_int_fits_to_tree_p (type, di))\n \t\t\t{\n \t\t\t  unsigned int itk;"}, {"sha": "b18f600e1b0de4eb99c65d02842e2c54306b3072", "filename": "gcc/cp/init.c", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -2238,11 +2238,11 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n       if (TREE_CONSTANT (inner_nelts_cst)\n \t  && TREE_CODE (inner_nelts_cst) == INTEGER_CST)\n \t{\n-\t  double_int result;\n-\t  if (mul_double (TREE_INT_CST_LOW (inner_nelts_cst),\n-\t\t\t  TREE_INT_CST_HIGH (inner_nelts_cst),\n-\t\t\t  inner_nelts_count.low, inner_nelts_count.high,\n-\t\t\t  &result.low, &result.high))\n+\t  bool overflow;\n+\t  double_int result = TREE_INT_CST (inner_nelts_cst)\n+\t\t\t      .mul_with_sign (inner_nelts_count,\n+\t\t\t\t\t      false, &overflow);\n+\t  if (overflow)\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"integer overflow in array size\");\n@@ -2344,8 +2344,8 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n       /* Maximum available size in bytes.  Half of the address space\n \t minus the cookie size.  */\n       double_int max_size\n-\t= double_int_lshift (double_int_one, TYPE_PRECISION (sizetype) - 1,\n-\t\t\t     HOST_BITS_PER_DOUBLE_INT, false);\n+\t= double_int_one.llshift (TYPE_PRECISION (sizetype) - 1,\n+\t\t\t\t  HOST_BITS_PER_DOUBLE_INT);\n       /* Size of the inner array elements. */\n       double_int inner_size;\n       /* Maximum number of outer elements which can be allocated. */\n@@ -2355,33 +2355,30 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n       gcc_assert (TREE_CODE (size) == INTEGER_CST);\n       cookie_size = targetm.cxx.get_cookie_size (elt_type);\n       gcc_assert (TREE_CODE (cookie_size) == INTEGER_CST);\n-      gcc_checking_assert (double_int_ucmp\n-\t\t\t   (TREE_INT_CST (cookie_size), max_size) < 0);\n+      gcc_checking_assert (TREE_INT_CST (cookie_size).ult (max_size));\n       /* Unconditionally substract the cookie size.  This decreases the\n \t maximum object size and is safe even if we choose not to use\n \t a cookie after all.  */\n-      max_size = double_int_sub (max_size, TREE_INT_CST (cookie_size));\n-      if (mul_double (TREE_INT_CST_LOW (size), TREE_INT_CST_HIGH (size),\n-\t\t      inner_nelts_count.low, inner_nelts_count.high,\n-\t\t      &inner_size.low, &inner_size.high)\n-\t  || double_int_ucmp (inner_size, max_size) > 0)\n+      max_size -= TREE_INT_CST (cookie_size);\n+      bool overflow;\n+      inner_size = TREE_INT_CST (size)\n+\t\t   .mul_with_sign (inner_nelts_count, false, &overflow);\n+      if (overflow || inner_size.ugt (max_size))\n \t{\n \t  if (complain & tf_error)\n \t    error (\"size of array is too large\");\n \t  return error_mark_node;\n \t}\n-      max_outer_nelts = double_int_udiv (max_size, inner_size, TRUNC_DIV_EXPR);\n+      max_outer_nelts = max_size.udiv (inner_size, TRUNC_DIV_EXPR);\n       /* Only keep the top-most seven bits, to simplify encoding the\n \t constant in the instruction stream.  */\n       {\n \tunsigned shift = HOST_BITS_PER_DOUBLE_INT - 7\n \t  - (max_outer_nelts.high ? clz_hwi (max_outer_nelts.high)\n \t     : (HOST_BITS_PER_WIDE_INT + clz_hwi (max_outer_nelts.low)));\n \tmax_outer_nelts\n-\t  = double_int_lshift (double_int_rshift\n-\t\t\t       (max_outer_nelts, shift,\n-\t\t\t\tHOST_BITS_PER_DOUBLE_INT, false),\n-\t\t\t       shift, HOST_BITS_PER_DOUBLE_INT, false);\n+\t  = max_outer_nelts.lrshift (shift, HOST_BITS_PER_DOUBLE_INT)\n+\t    .llshift (shift, HOST_BITS_PER_DOUBLE_INT);\n       }\n       max_outer_nelts_tree = double_int_to_tree (sizetype, max_outer_nelts);\n "}, {"sha": "13c658b29e2e33d7ea342bf5b2aef189b03ff9af", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -3119,12 +3119,11 @@ write_array_type (const tree type)\n \t{\n \t  /* The ABI specifies that we should mangle the number of\n \t     elements in the array, not the largest allowed index.  */\n-\t  double_int dmax\n-\t    = double_int_add (tree_to_double_int (max), double_int_one);\n+\t  double_int dmax = tree_to_double_int (max) + double_int_one;\n \t  /* Truncate the result - this will mangle [0, SIZE_INT_MAX]\n \t     number of elements as zero.  */\n-\t  dmax = double_int_zext (dmax, TYPE_PRECISION (TREE_TYPE (max)));\n-\t  gcc_assert (double_int_fits_in_uhwi_p (dmax));\n+\t  dmax = dmax.zext (TYPE_PRECISION (TREE_TYPE (max)));\n+\t  gcc_assert (dmax.fits_uhwi ());\n \t  write_unsigned_number (dmax.low);\n \t}\n       else"}, {"sha": "3dbfcb6663a09b9ff65acae8f81201a438edc465", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -1058,14 +1058,12 @@ process_init_constructor_array (tree type, tree init,\n     {\n       tree domain = TYPE_DOMAIN (type);\n       if (domain)\n-\tlen = double_int_ext\n-\t        (double_int_add\n-\t\t  (double_int_sub\n-\t\t    (tree_to_double_int (TYPE_MAX_VALUE (domain)),\n-\t\t     tree_to_double_int (TYPE_MIN_VALUE (domain))),\n-\t\t    double_int_one),\n-\t\t  TYPE_PRECISION (TREE_TYPE (domain)),\n-\t\t  TYPE_UNSIGNED (TREE_TYPE (domain))).low;\n+\tlen = (tree_to_double_int (TYPE_MAX_VALUE (domain))\n+\t       - tree_to_double_int (TYPE_MIN_VALUE (domain))\n+\t       + double_int_one)\n+\t      .ext (TYPE_PRECISION (TREE_TYPE (domain)),\n+\t\t    TYPE_UNSIGNED (TREE_TYPE (domain)))\n+\t      .low;\n       else\n \tunbounded = true;  /* Take as many as there are.  */\n     }"}, {"sha": "41a41487c72ef0eaf6f3d7065721a05b11ea4d06", "filename": "gcc/double-int.c", "status": "modified", "additions": 88, "deletions": 6, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -23,6 +23,41 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\t\t\t/* For SHIFT_COUNT_TRUNCATED.  */\n #include \"tree.h\"\n \n+static int add_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t bool);\n+\n+#define add_double(l1,h1,l2,h2,lv,hv) \\\n+  add_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n+\n+static int neg_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+\n+static int mul_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t bool);\n+\n+static int mul_double_wide_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t      unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t      unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t      unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t      bool);\n+\n+#define mul_double(l1,h1,l2,h2,lv,hv) \\\n+  mul_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n+\n+static void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t   HOST_WIDE_INT, unsigned int,\n+\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n+\n+static int div_and_round_double (unsigned, int, unsigned HOST_WIDE_INT,\n+\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT *,\n+\t\t\t\t HOST_WIDE_INT *, unsigned HOST_WIDE_INT *,\n+\t\t\t\t HOST_WIDE_INT *);\n+\n /* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n    and SUM1.  Then this yields nonzero if overflow occurred during the\n@@ -75,7 +110,7 @@ decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low,\n    One argument is L1 and H1; the other, L2 and H2.\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n-int\n+static int\n add_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \t\t      unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n \t\t      unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n@@ -105,7 +140,7 @@ add_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n    The argument is given as two `HOST_WIDE_INT' pieces in L1 and H1.\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n-int\n+static int\n neg_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \t    unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n {\n@@ -129,7 +164,7 @@ neg_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n    One argument is L1 and H1; the other, L2 and H2.\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n-int\n+static int\n mul_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \t\t      unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n \t\t      unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n@@ -143,7 +178,7 @@ mul_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \t\t\t\t    unsigned_p);\n }\n \n-int\n+static int\n mul_double_wide_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \t\t\t   unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n \t\t\t   unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n@@ -269,7 +304,7 @@ rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n-void\n+static void\n lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \t       HOST_WIDE_INT count, unsigned int prec,\n \t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, bool arith)\n@@ -335,7 +370,7 @@ lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n    Return nonzero if the operation overflows.\n    UNS nonzero says do unsigned division.  */\n \n-int\n+static int\n div_and_round_double (unsigned code, int uns,\n \t\t      /* num == numerator == dividend */\n \t\t      unsigned HOST_WIDE_INT lnum_orig,\n@@ -762,6 +797,19 @@ double_int::mul_with_sign (double_int b, bool unsigned_p, bool *overflow) const\n   return ret;\n }\n \n+double_int\n+double_int::wide_mul_with_sign (double_int b, bool unsigned_p,\n+\t\t\t\tdouble_int *higher, bool *overflow) const\n+\n+{\n+  double_int lower;\n+  *overflow = mul_double_wide_with_sign (low, high, b.low, b.high,\n+\t\t\t\t\t &lower.low, &lower.high,\n+\t\t\t\t\t &higher->low, &higher->high,\n+\t\t\t\t\t unsigned_p);\n+  return lower;\n+}\n+\n /* Returns A + B.  */\n \n double_int\n@@ -798,6 +846,19 @@ double_int::operator - (double_int b) const\n   return ret;\n }\n \n+/* Returns A - B. If the operation overflows via inconsistent sign bits,\n+   *OVERFLOW is set to nonzero.  */\n+\n+double_int\n+double_int::sub_with_overflow (double_int b, bool *overflow) const\n+{\n+  double_int ret;\n+  neg_double (b.low, b.high, &ret.low, &ret.high);\n+  add_double (low, high, ret.low, ret.high, &ret.low, &ret.high);\n+  *overflow = OVERFLOW_SUM_SIGN (ret.high, b.high, high);\n+  return ret;\n+}\n+\n /* Returns -A.  */\n \n double_int\n@@ -809,11 +870,32 @@ double_int::operator - () const\n   return ret;\n }\n \n+double_int\n+double_int::neg_with_overflow (bool *overflow) const\n+{\n+  double_int ret;\n+  *overflow = neg_double (low, high, &ret.low, &ret.high);\n+  return ret;\n+}\n+\n /* Returns A / B (computed as unsigned depending on UNS, and rounded as\n    specified by CODE).  CODE is enum tree_code in fact, but double_int.h\n    must be included before tree.h.  The remainder after the division is\n    stored to MOD.  */\n \n+double_int\n+double_int::divmod_with_overflow (double_int b, bool uns, unsigned code,\n+\t\t\t\t  double_int *mod, bool *overflow) const\n+{\n+  const double_int &a = *this;\n+  double_int ret;\n+\n+  *overflow = div_and_round_double (code, uns, a.low, a.high,\n+\t\t\t\t    b.low, b.high, &ret.low, &ret.high,\n+\t\t\t\t    &mod->low, &mod->high);\n+  return ret;\n+}\n+\n double_int\n double_int::divmod (double_int b, bool uns, unsigned code,\n \t\t    double_int *mod) const"}, {"sha": "f4eb6ab0a77d059f5befff8b407641a0b56c1748", "filename": "gcc/double-int.h", "status": "modified", "additions": 18, "deletions": 442, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -61,6 +61,7 @@ struct double_int\n \n   static double_int from_uhwi (unsigned HOST_WIDE_INT cst);\n   static double_int from_shwi (HOST_WIDE_INT cst);\n+  static double_int from_pair (HOST_WIDE_INT high, unsigned HOST_WIDE_INT low);\n \n   /* No copy assignment operator or destructor to keep the type a POD.  */\n \n@@ -105,9 +106,17 @@ struct double_int\n \n   /* Arithmetic operation functions.  */\n \n+  /* The following operations perform arithmetics modulo 2^precision, so you\n+     do not need to call .ext between them, even if you are representing\n+     numbers with precision less than HOST_BITS_PER_DOUBLE_INT bits.  */\n+\n   double_int set_bit (unsigned) const;\n   double_int mul_with_sign (double_int, bool unsigned_p, bool *overflow) const;\n+  double_int wide_mul_with_sign (double_int, bool unsigned_p,\n+\t\t\t\t double_int *higher, bool *overflow) const;\n   double_int add_with_sign (double_int, bool unsigned_p, bool *overflow) const;\n+  double_int sub_with_overflow (double_int, bool *overflow) const;\n+  double_int neg_with_overflow (bool *overflow) const;\n \n   double_int operator * (double_int) const;\n   double_int operator + (double_int) const;\n@@ -131,12 +140,15 @@ struct double_int\n   /* You must ensure that double_int::ext is called on the operands\n      of the following operations, if the precision of the numbers\n      is less than HOST_BITS_PER_DOUBLE_INT bits.  */\n+\n   double_int div (double_int, bool, unsigned) const;\n   double_int sdiv (double_int, unsigned) const;\n   double_int udiv (double_int, unsigned) const;\n   double_int mod (double_int, bool, unsigned) const;\n   double_int smod (double_int, unsigned) const;\n   double_int umod (double_int, unsigned) const;\n+  double_int divmod_with_overflow (double_int, bool, unsigned,\n+\t\t\t\t   double_int *, bool *) const;\n   double_int divmod (double_int, bool, unsigned, double_int *) const;\n   double_int sdivmod (double_int, unsigned, double_int *) const;\n   double_int udivmod (double_int, unsigned, double_int *) const;\n@@ -199,13 +211,6 @@ double_int::from_shwi (HOST_WIDE_INT cst)\n   return r;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline double_int\n-shwi_to_double_int (HOST_WIDE_INT cst)\n-{\n-  return double_int::from_shwi (cst);\n-}\n-\n /* Some useful constants.  */\n /* FIXME(crowl): Maybe remove after converting callers?\n    The problem is that a named constant would not be as optimizable,\n@@ -229,11 +234,13 @@ double_int::from_uhwi (unsigned HOST_WIDE_INT cst)\n   return r;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline double_int\n-uhwi_to_double_int (unsigned HOST_WIDE_INT cst)\n+inline double_int\n+double_int::from_pair (HOST_WIDE_INT high, unsigned HOST_WIDE_INT low)\n {\n-  return double_int::from_uhwi (cst);\n+  double_int r;\n+  r.low = low;\n+  r.high = high;\n+  return r;\n }\n \n inline double_int &\n@@ -301,13 +308,6 @@ double_int::to_shwi () const\n   return (HOST_WIDE_INT) low;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline HOST_WIDE_INT\n-double_int_to_shwi (double_int cst)\n-{\n-  return cst.to_shwi ();\n-}\n-\n /* Returns value of CST as an unsigned number.  CST must satisfy\n    double_int::fits_unsigned.  */\n \n@@ -317,13 +317,6 @@ double_int::to_uhwi () const\n   return low;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline unsigned HOST_WIDE_INT\n-double_int_to_uhwi (double_int cst)\n-{\n-  return cst.to_uhwi ();\n-}\n-\n /* Returns true if CST fits in unsigned HOST_WIDE_INT.  */\n \n inline bool\n@@ -332,164 +325,6 @@ double_int::fits_uhwi () const\n   return high == 0;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline bool\n-double_int_fits_in_uhwi_p (double_int cst)\n-{\n-  return cst.fits_uhwi ();\n-}\n-\n-/* Returns true if CST fits in signed HOST_WIDE_INT.  */\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline bool\n-double_int_fits_in_shwi_p (double_int cst)\n-{\n-  return cst.fits_shwi ();\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline bool\n-double_int_fits_in_hwi_p (double_int cst, bool uns)\n-{\n-  return cst.fits_hwi (uns);\n-}\n-\n-/* The following operations perform arithmetics modulo 2^precision,\n-   so you do not need to call double_int_ext between them, even if\n-   you are representing numbers with precision less than\n-   HOST_BITS_PER_DOUBLE_INT bits.  */\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_mul (double_int a, double_int b)\n-{\n-  return a * b;\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_mul_with_sign (double_int a, double_int b,\n-\t\t\t  bool unsigned_p, int *overflow)\n-{\n-  bool ovf;\n-  return a.mul_with_sign (b, unsigned_p, &ovf);\n-  *overflow = ovf;\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_add (double_int a, double_int b)\n-{\n-  return a + b;\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_sub (double_int a, double_int b)\n-{\n-  return a - b;\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_neg (double_int a)\n-{\n-  return -a;\n-}\n-\n-/* You must ensure that double_int_ext is called on the operands\n-   of the following operations, if the precision of the numbers\n-   is less than HOST_BITS_PER_DOUBLE_INT bits.  */\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_div (double_int a, double_int b, bool uns, unsigned code)\n-{\n-  return a.div (b, uns, code);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_sdiv (double_int a, double_int b, unsigned code)\n-{\n-  return a.sdiv (b, code);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_udiv (double_int a, double_int b, unsigned code)\n-{\n-  return a.udiv (b, code);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_mod (double_int a, double_int b, bool uns, unsigned code)\n-{\n-  return a.mod (b, uns, code);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_smod (double_int a, double_int b, unsigned code)\n-{\n-  return a.smod (b, code);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_umod (double_int a, double_int b, unsigned code)\n-{\n-  return a.umod (b, code);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_divmod (double_int a, double_int b, bool uns,\n-\t\t   unsigned code, double_int *mod)\n-{\n-  return a.divmod (b, uns, code, mod);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_sdivmod (double_int a, double_int b, unsigned code, double_int *mod)\n-{\n-  return a.sdivmod (b, code, mod);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_udivmod (double_int a, double_int b, unsigned code, double_int *mod)\n-{\n-  return a.udivmod (b, code, mod);\n-}\n-\n-/***/\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline bool\n-double_int_multiple_of (double_int product, double_int factor,\n-                        bool unsigned_p, double_int *multiple)\n-{\n-  return product.multiple_of (factor, unsigned_p, multiple);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_setbit (double_int a, unsigned bitpos)\n-{\n-  return a.set_bit (bitpos);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline int\n-double_int_ctz (double_int a)\n-{\n-  return a.trailing_zeros ();\n-}\n-\n /* Logical operations.  */\n \n /* Returns ~A.  */\n@@ -503,13 +338,6 @@ double_int::operator ~ () const\n   return result;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline double_int\n-double_int_not (double_int a)\n-{\n-  return ~a;\n-}\n-\n /* Returns A | B.  */\n \n inline double_int\n@@ -521,13 +349,6 @@ double_int::operator | (double_int b) const\n   return result;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline double_int\n-double_int_ior (double_int a, double_int b)\n-{\n-  return a | b;\n-}\n-\n /* Returns A & B.  */\n \n inline double_int\n@@ -539,13 +360,6 @@ double_int::operator & (double_int b) const\n   return result;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline double_int\n-double_int_and (double_int a, double_int b)\n-{\n-  return a & b;\n-}\n-\n /* Returns A & ~B.  */\n \n inline double_int\n@@ -557,13 +371,6 @@ double_int::and_not (double_int b) const\n   return result;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline double_int\n-double_int_and_not (double_int a, double_int b)\n-{\n-  return a.and_not (b);\n-}\n-\n /* Returns A ^ B.  */\n \n inline double_int\n@@ -575,165 +382,8 @@ double_int::operator ^ (double_int b) const\n   return result;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline double_int\n-double_int_xor (double_int a, double_int b)\n-{\n-  return a ^ b;\n-}\n-\n-\n-/* Shift operations.  */\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_lshift (double_int a, HOST_WIDE_INT count, unsigned int prec,\n-\t\t   bool arith)\n-{\n-  return a.lshift (count, prec, arith);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_rshift (double_int a, HOST_WIDE_INT count, unsigned int prec,\n-\t\t   bool arith)\n-{\n-  return a.rshift (count, prec, arith);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_lrotate (double_int a, HOST_WIDE_INT count, unsigned int prec)\n-{\n-  return a.lrotate (count, prec);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_rrotate (double_int a, HOST_WIDE_INT count, unsigned int prec)\n-{\n-  return a.rrotate (count, prec);\n-}\n-\n-/* Returns true if CST is negative.  Of course, CST is considered to\n-   be signed.  */\n-\n-static inline bool\n-double_int_negative_p (double_int cst)\n-{\n-  return cst.high < 0;\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline int\n-double_int_cmp (double_int a, double_int b, bool uns)\n-{\n-  return a.cmp (b, uns);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline int\n-double_int_scmp (double_int a, double_int b)\n-{\n-  return a.scmp (b);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline int\n-double_int_ucmp (double_int a, double_int b)\n-{\n-  return a.ucmp (b);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_max (double_int a, double_int b, bool uns)\n-{\n-  return a.max (b, uns);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_smax (double_int a, double_int b)\n-{\n-  return a.smax (b);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_umax (double_int a, double_int b)\n-{\n-  return a.umax (b);\n-}\n-\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_min (double_int a, double_int b, bool uns)\n-{\n-  return a.min (b, uns);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_smin (double_int a, double_int b)\n-{\n-  return a.smin (b);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_umin (double_int a, double_int b)\n-{\n-  return a.umin (b);\n-}\n-\n void dump_double_int (FILE *, double_int, bool);\n \n-/* Zero and sign extension of numbers in smaller precisions.  */\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_ext (double_int a, unsigned prec, bool uns)\n-{ \n-  return a.ext (prec, uns);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_sext (double_int a, unsigned prec)\n-{\n-  return a.sext (prec);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_zext (double_int a, unsigned prec)\n-{\n-  return a.zext (prec);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_mask (unsigned prec)\n-{\n-  return double_int::mask (prec);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_max_value (unsigned int prec, bool uns)\n-{\n-  return double_int::max_value (prec, uns);\n-}\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-inline double_int\n-double_int_min_value (unsigned int prec, bool uns)\n-{\n-  return double_int::min_value (prec, uns);\n-}\n-\n #define ALL_ONES (~((unsigned HOST_WIDE_INT) 0))\n \n /* The operands of the following comparison functions must be processed\n@@ -748,13 +398,6 @@ double_int::is_zero () const\n   return low == 0 && high == 0;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline bool\n-double_int_zero_p (double_int cst)\n-{\n-  return cst.is_zero ();\n-}\n-\n /* Returns true if CST is one.  */\n \n inline bool\n@@ -763,13 +406,6 @@ double_int::is_one () const\n   return low == 1 && high == 0;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline bool\n-double_int_one_p (double_int cst)\n-{\n-  return cst.is_one ();\n-}\n-\n /* Returns true if CST is minus one.  */\n \n inline bool\n@@ -778,13 +414,6 @@ double_int::is_minus_one () const\n   return low == ALL_ONES && high == -1;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline bool\n-double_int_minus_one_p (double_int cst)\n-{\n-  return cst.is_minus_one ();\n-}\n-\n /* Returns true if CST is negative.  */\n \n inline bool\n@@ -801,13 +430,6 @@ double_int::operator == (double_int cst2) const\n   return low == cst2.low && high == cst2.high;\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline bool\n-double_int_equal_p (double_int cst1, double_int cst2)\n-{\n-  return cst1 == cst2;\n-}\n-\n /* Returns true if CST1 != CST2.  */\n \n inline bool\n@@ -824,52 +446,6 @@ double_int::popcount () const\n   return popcount_hwi (high) + popcount_hwi (low);\n }\n \n-/* FIXME(crowl): Remove after converting callers.  */\n-static inline int\n-double_int_popcount (double_int cst)\n-{\n-  return cst.popcount ();\n-}\n-\n-\n-/* Legacy interface with decomposed high/low parts.  */\n-\n-/* FIXME(crowl): Remove after converting callers.  */\n-extern int add_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t bool);\n-/* FIXME(crowl): Remove after converting callers.  */\n-#define add_double(l1,h1,l2,h2,lv,hv) \\\n-  add_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n-/* FIXME(crowl): Remove after converting callers.  */\n-extern int neg_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n-/* FIXME(crowl): Remove after converting callers.  */\n-extern int mul_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t bool);\n-/* FIXME(crowl): Remove after converting callers.  */\n-extern int mul_double_wide_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t      unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t      unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t      unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t      bool);\n-/* FIXME(crowl): Remove after converting callers.  */\n-#define mul_double(l1,h1,l2,h2,lv,hv) \\\n-  mul_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n-/* FIXME(crowl): Remove after converting callers.  */\n-extern void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t   HOST_WIDE_INT, unsigned int,\n-\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n-/* FIXME(crowl): Remove after converting callers.  */\n-extern int div_and_round_double (unsigned, int, unsigned HOST_WIDE_INT,\n-\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT *,\n-\t\t\t\t HOST_WIDE_INT *, unsigned HOST_WIDE_INT *,\n-\t\t\t\t HOST_WIDE_INT *);\n-\n \n #ifndef GENERATOR_FILE\n /* Conversion to and from GMP integer representations.  */"}, {"sha": "ee6ae226e23f77ba5ce53c8bf8bfc9740f04d45e", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -5764,11 +5764,10 @@ init_emit_once (void)\n       FCONST1(mode).data.high = 0;\n       FCONST1(mode).data.low = 0;\n       FCONST1(mode).mode = mode;\n-      lshift_double (1, 0, GET_MODE_FBIT (mode),\n-                     HOST_BITS_PER_DOUBLE_INT,\n-                     &FCONST1(mode).data.low,\n-\t\t     &FCONST1(mode).data.high,\n-                     SIGNED_FIXED_POINT_MODE_P (mode));\n+      FCONST1(mode).data\n+\t= double_int_one.lshift (GET_MODE_FBIT (mode),\n+\t\t\t\t HOST_BITS_PER_DOUBLE_INT,\n+\t\t\t\t SIGNED_FIXED_POINT_MODE_P (mode));\n       const_tiny_rtx[1][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n \t\t\t\t      FCONST1 (mode), mode);\n     }\n@@ -5787,11 +5786,10 @@ init_emit_once (void)\n       FCONST1(mode).data.high = 0;\n       FCONST1(mode).data.low = 0;\n       FCONST1(mode).mode = mode;\n-      lshift_double (1, 0, GET_MODE_FBIT (mode),\n-                     HOST_BITS_PER_DOUBLE_INT,\n-                     &FCONST1(mode).data.low,\n-\t\t     &FCONST1(mode).data.high,\n-                     SIGNED_FIXED_POINT_MODE_P (mode));\n+      FCONST1(mode).data\n+\t= double_int_one.lshift (GET_MODE_FBIT (mode),\n+\t\t\t\t HOST_BITS_PER_DOUBLE_INT,\n+\t\t\t\t SIGNED_FIXED_POINT_MODE_P (mode));\n       const_tiny_rtx[1][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n \t\t\t\t      FCONST1 (mode), mode);\n     }"}, {"sha": "61098324aaeb95fef4152c95d4b8f17d0b6e4600", "filename": "gcc/explow.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -100,36 +100,33 @@ plus_constant (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n     case CONST_INT:\n       if (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT)\n \t{\n-\t  unsigned HOST_WIDE_INT l1 = INTVAL (x);\n-\t  HOST_WIDE_INT h1 = (l1 >> (HOST_BITS_PER_WIDE_INT - 1)) ? -1 : 0;\n-\t  unsigned HOST_WIDE_INT l2 = c;\n-\t  HOST_WIDE_INT h2 = c < 0 ? -1 : 0;\n-\t  unsigned HOST_WIDE_INT lv;\n-\t  HOST_WIDE_INT hv;\n-\n-\t  if (add_double_with_sign (l1, h1, l2, h2, &lv, &hv, false))\n+\t  double_int di_x = double_int::from_shwi (INTVAL (x));\n+\t  double_int di_c = double_int::from_shwi (c);\n+\n+\t  bool overflow;\n+\t  double_int v = di_x.add_with_sign (di_c, false, &overflow);\n+\t  if (overflow)\n \t    gcc_unreachable ();\n \n-\t  return immed_double_const (lv, hv, VOIDmode);\n+\t  return immed_double_int_const (v, VOIDmode);\n \t}\n \n       return GEN_INT (INTVAL (x) + c);\n \n     case CONST_DOUBLE:\n       {\n-\tunsigned HOST_WIDE_INT l1 = CONST_DOUBLE_LOW (x);\n-\tHOST_WIDE_INT h1 = CONST_DOUBLE_HIGH (x);\n-\tunsigned HOST_WIDE_INT l2 = c;\n-\tHOST_WIDE_INT h2 = c < 0 ? -1 : 0;\n-\tunsigned HOST_WIDE_INT lv;\n-\tHOST_WIDE_INT hv;\n-\n-\tif (add_double_with_sign (l1, h1, l2, h2, &lv, &hv, false))\n+\tdouble_int di_x = double_int::from_pair (CONST_DOUBLE_HIGH (x),\n+\t\t\t\t\t\t CONST_DOUBLE_LOW (x));\n+\tdouble_int di_c = double_int::from_shwi (c);\n+\n+\tbool overflow;\n+\tdouble_int v = di_x.add_with_sign (di_c, false, &overflow);\n+\tif (overflow)\n \t  /* Sorry, we have no way to represent overflows this wide.\n \t     To fix, add constant support wider than CONST_DOUBLE.  */\n \t  gcc_assert (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_DOUBLE_INT);\n \n-\treturn immed_double_const (lv, hv, VOIDmode);\n+\treturn immed_double_int_const (v, VOIDmode);\n       }\n \n     case MEM:"}, {"sha": "767834eefb58ae41c7ad067138dde338491f3ab3", "filename": "gcc/expmed.c", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -3392,12 +3392,9 @@ choose_multiplier (unsigned HOST_WIDE_INT d, int n, int precision,\n \t\t   unsigned HOST_WIDE_INT *multiplier_ptr,\n \t\t   int *post_shift_ptr, int *lgup_ptr)\n {\n-  HOST_WIDE_INT mhigh_hi, mlow_hi;\n-  unsigned HOST_WIDE_INT mhigh_lo, mlow_lo;\n+  double_int mhigh, mlow;\n   int lgup, post_shift;\n   int pow, pow2;\n-  unsigned HOST_WIDE_INT nl, dummy1;\n-  HOST_WIDE_INT nh, dummy2;\n \n   /* lgup = ceil(log2(divisor)); */\n   lgup = ceil_log2 (d);\n@@ -3413,62 +3410,46 @@ choose_multiplier (unsigned HOST_WIDE_INT d, int n, int precision,\n   gcc_assert (pow != HOST_BITS_PER_DOUBLE_INT);\n \n   /* mlow = 2^(N + lgup)/d */\n- if (pow >= HOST_BITS_PER_WIDE_INT)\n-    {\n-      nh = (HOST_WIDE_INT) 1 << (pow - HOST_BITS_PER_WIDE_INT);\n-      nl = 0;\n-    }\n-  else\n-    {\n-      nh = 0;\n-      nl = (unsigned HOST_WIDE_INT) 1 << pow;\n-    }\n-  div_and_round_double (TRUNC_DIV_EXPR, 1, nl, nh, d, (HOST_WIDE_INT) 0,\n-\t\t\t&mlow_lo, &mlow_hi, &dummy1, &dummy2);\n+  double_int val = double_int_zero.set_bit (pow);\n+  mlow = val.div (double_int::from_uhwi (d), true, TRUNC_DIV_EXPR); \n \n-  /* mhigh = (2^(N + lgup) + 2^N + lgup - precision)/d */\n-  if (pow2 >= HOST_BITS_PER_WIDE_INT)\n-    nh |= (HOST_WIDE_INT) 1 << (pow2 - HOST_BITS_PER_WIDE_INT);\n-  else\n-    nl |= (unsigned HOST_WIDE_INT) 1 << pow2;\n-  div_and_round_double (TRUNC_DIV_EXPR, 1, nl, nh, d, (HOST_WIDE_INT) 0,\n-\t\t\t&mhigh_lo, &mhigh_hi, &dummy1, &dummy2);\n+  /* mhigh = (2^(N + lgup) + 2^(N + lgup - precision))/d */\n+  val |= double_int_zero.set_bit (pow2);\n+  mhigh = val.div (double_int::from_uhwi (d), true, TRUNC_DIV_EXPR);\n \n-  gcc_assert (!mhigh_hi || nh - d < d);\n-  gcc_assert (mhigh_hi <= 1 && mlow_hi <= 1);\n+  gcc_assert (!mhigh.high || val.high - d < d);\n+  gcc_assert (mhigh.high <= 1 && mlow.high <= 1);\n   /* Assert that mlow < mhigh.  */\n-  gcc_assert (mlow_hi < mhigh_hi\n-\t      || (mlow_hi == mhigh_hi && mlow_lo < mhigh_lo));\n+  gcc_assert (mlow.ult (mhigh));\n \n   /* If precision == N, then mlow, mhigh exceed 2^N\n      (but they do not exceed 2^(N+1)).  */\n \n   /* Reduce to lowest terms.  */\n   for (post_shift = lgup; post_shift > 0; post_shift--)\n     {\n-      unsigned HOST_WIDE_INT ml_lo = (mlow_hi << (HOST_BITS_PER_WIDE_INT - 1)) | (mlow_lo >> 1);\n-      unsigned HOST_WIDE_INT mh_lo = (mhigh_hi << (HOST_BITS_PER_WIDE_INT - 1)) | (mhigh_lo >> 1);\n+      int shft = HOST_BITS_PER_WIDE_INT - 1;\n+      unsigned HOST_WIDE_INT ml_lo = (mlow.high << shft) | (mlow.low >> 1);\n+      unsigned HOST_WIDE_INT mh_lo = (mhigh.high << shft) | (mhigh.low >> 1);\n       if (ml_lo >= mh_lo)\n \tbreak;\n \n-      mlow_hi = 0;\n-      mlow_lo = ml_lo;\n-      mhigh_hi = 0;\n-      mhigh_lo = mh_lo;\n+      mlow = double_int::from_uhwi (ml_lo);\n+      mhigh = double_int::from_uhwi (mh_lo);\n     }\n \n   *post_shift_ptr = post_shift;\n   *lgup_ptr = lgup;\n   if (n < HOST_BITS_PER_WIDE_INT)\n     {\n       unsigned HOST_WIDE_INT mask = ((unsigned HOST_WIDE_INT) 1 << n) - 1;\n-      *multiplier_ptr = mhigh_lo & mask;\n-      return mhigh_lo >= mask;\n+      *multiplier_ptr = mhigh.low & mask;\n+      return mhigh.low >= mask;\n     }\n   else\n     {\n-      *multiplier_ptr = mhigh_lo;\n-      return mhigh_hi;\n+      *multiplier_ptr = mhigh.low;\n+      return mhigh.high;\n     }\n }\n "}, {"sha": "3197cef7703a5678c8c9f264e7c5893ea3ba6a09", "filename": "gcc/fold-const.c", "status": "modified", "additions": 22, "deletions": 59, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -165,17 +165,6 @@ protected_set_expr_location_unshare (tree x, location_t loc)\n     }\n   return x;\n }\n-\n-\n-/* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n-   overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n-   and SUM1.  Then this yields nonzero if overflow occurred during the\n-   addition.\n-\n-   Overflow occurs if A and B have the same sign, but A and SUM differ in\n-   sign.  Use `^' to test whether signs differ, and `< 0' to isolate the\n-   sign.  */\n-#define OVERFLOW_SUM_SIGN(a, b, sum) ((~((a) ^ (b)) & ((a) ^ (sum))) < 0)\n \f\n /* If ARG2 divides ARG1 with zero remainder, carries out the division\n    of type CODE and returns the quotient.\n@@ -982,13 +971,7 @@ int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree arg2,\n       break;\n \n     case MINUS_EXPR:\n-/* FIXME(crowl) Remove this code if the replacment works.\n-      neg_double (op2.low, op2.high, &res.low, &res.high);\n-      add_double (op1.low, op1.high, res.low, res.high,\n-\t\t  &res.low, &res.high);\n-      overflow = OVERFLOW_SUM_SIGN (res.high, op2.high, op1.high);\n-*/\n-      res = op1.add_with_sign (-op2, false, &overflow);\n+      res = op1.sub_with_overflow (op2, &overflow);\n       break;\n \n     case MULT_EXPR:\n@@ -1035,10 +1018,7 @@ int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree arg2,\n \t  res = double_int_one;\n \t  break;\n \t}\n-      overflow = div_and_round_double (code, uns,\n-\t\t\t\t       op1.low, op1.high, op2.low, op2.high,\n-\t\t\t\t       &res.low, &res.high,\n-\t\t\t\t       &tmp.low, &tmp.high);\n+      res = op1.divmod_with_overflow (op2, uns, code, &tmp, &overflow);\n       break;\n \n     case TRUNC_MOD_EXPR:\n@@ -1060,10 +1040,7 @@ int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree arg2,\n     case ROUND_MOD_EXPR:\n       if (op2.is_zero ())\n \treturn NULL_TREE;\n-      overflow = div_and_round_double (code, uns,\n-\t\t\t\t       op1.low, op1.high, op2.low, op2.high,\n-\t\t\t\t       &tmp.low, &tmp.high,\n-\t\t\t\t       &res.low, &res.high);\n+      tmp = op1.divmod_with_overflow (op2, uns, code, &res, &overflow);\n       break;\n \n     case MIN_EXPR:\n@@ -6290,15 +6267,12 @@ fold_div_compare (location_t loc,\n   double_int val;\n   bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (arg0));\n   bool neg_overflow;\n-  int overflow;\n+  bool overflow;\n \n   /* We have to do this the hard way to detect unsigned overflow.\n      prod = int_const_binop (MULT_EXPR, arg01, arg1);  */\n-  overflow = mul_double_with_sign (TREE_INT_CST_LOW (arg01),\n-\t\t\t\t   TREE_INT_CST_HIGH (arg01),\n-\t\t\t\t   TREE_INT_CST_LOW (arg1),\n-\t\t\t\t   TREE_INT_CST_HIGH (arg1),\n-\t\t\t\t   &val.low, &val.high, unsigned_p);\n+  val = TREE_INT_CST (arg01)\n+\t.mul_with_sign (TREE_INT_CST (arg1), unsigned_p, &overflow);\n   prod = force_fit_type_double (TREE_TYPE (arg00), val, -1, overflow);\n   neg_overflow = false;\n \n@@ -6309,11 +6283,8 @@ fold_div_compare (location_t loc,\n       lo = prod;\n \n       /* Likewise hi = int_const_binop (PLUS_EXPR, prod, tmp).  */\n-      overflow = add_double_with_sign (TREE_INT_CST_LOW (prod),\n-\t\t\t\t       TREE_INT_CST_HIGH (prod),\n-\t\t\t\t       TREE_INT_CST_LOW (tmp),\n-\t\t\t\t       TREE_INT_CST_HIGH (tmp),\n-\t\t\t\t       &val.low, &val.high, unsigned_p);\n+      val = TREE_INT_CST (prod)\n+\t    .add_with_sign (TREE_INT_CST (tmp), unsigned_p, &overflow);\n       hi = force_fit_type_double (TREE_TYPE (arg00), val,\n \t\t\t\t  -1, overflow | TREE_OVERFLOW (prod));\n     }\n@@ -8691,8 +8662,7 @@ maybe_canonicalize_comparison (location_t loc, enum tree_code code, tree type,\n static bool\n pointer_may_wrap_p (tree base, tree offset, HOST_WIDE_INT bitpos)\n {\n-  unsigned HOST_WIDE_INT offset_low, total_low;\n-  HOST_WIDE_INT size, offset_high, total_high;\n+  double_int di_offset, total;\n \n   if (!POINTER_TYPE_P (TREE_TYPE (base)))\n     return true;\n@@ -8701,28 +8671,22 @@ pointer_may_wrap_p (tree base, tree offset, HOST_WIDE_INT bitpos)\n     return true;\n \n   if (offset == NULL_TREE)\n-    {\n-      offset_low = 0;\n-      offset_high = 0;\n-    }\n+    di_offset = double_int_zero;\n   else if (TREE_CODE (offset) != INTEGER_CST || TREE_OVERFLOW (offset))\n     return true;\n   else\n-    {\n-      offset_low = TREE_INT_CST_LOW (offset);\n-      offset_high = TREE_INT_CST_HIGH (offset);\n-    }\n+    di_offset = TREE_INT_CST (offset);\n \n-  if (add_double_with_sign (offset_low, offset_high,\n-\t\t\t    bitpos / BITS_PER_UNIT, 0,\n-\t\t\t    &total_low, &total_high,\n-\t\t\t    true))\n+  bool overflow;\n+  double_int units = double_int::from_uhwi (bitpos / BITS_PER_UNIT);\n+  total = di_offset.add_with_sign (units, true, &overflow);\n+  if (overflow)\n     return true;\n \n-  if (total_high != 0)\n+  if (total.high != 0)\n     return true;\n \n-  size = int_size_in_bytes (TREE_TYPE (TREE_TYPE (base)));\n+  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (TREE_TYPE (base)));\n   if (size <= 0)\n     return true;\n \n@@ -8737,7 +8701,7 @@ pointer_may_wrap_p (tree base, tree offset, HOST_WIDE_INT bitpos)\n \tsize = base_size;\n     }\n \n-  return total_low > (unsigned HOST_WIDE_INT) size;\n+  return total.low > (unsigned HOST_WIDE_INT) size;\n }\n \n /* Subroutine of fold_binary.  This routine performs all of the\n@@ -15938,8 +15902,8 @@ fold_negate_const (tree arg0, tree type)\n     case INTEGER_CST:\n       {\n \tdouble_int val = tree_to_double_int (arg0);\n-\tint overflow = neg_double (val.low, val.high, &val.low, &val.high);\n-\n+\tbool overflow;\n+\tval = val.neg_with_overflow (&overflow);\n \tt = force_fit_type_double (type, val, 1,\n \t\t\t\t   (overflow | TREE_OVERFLOW (arg0))\n \t\t\t\t   && !TYPE_UNSIGNED (type));\n@@ -15996,9 +15960,8 @@ fold_abs_const (tree arg0, tree type)\n \t   its negation.  */\n \telse\n \t  {\n-\t    int overflow;\n-\n-\t    overflow = neg_double (val.low, val.high, &val.low, &val.high);\n+\t    bool overflow;\n+\t    val = val.neg_with_overflow (&overflow);\n \t    t = force_fit_type_double (type, val, -1,\n \t\t\t\t       overflow | TREE_OVERFLOW (arg0));\n \t  }"}, {"sha": "d6bfcf9e8d35def8b5c485fb9b4497d4be22915e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -1,3 +1,8 @@\n+2012-09-24  Lawrence Crowl  <crowl@google.com>\n+\n+\t* trans-expr.c (gfc_conv_cst_int_power): Change to new double_int API.\n+\t* target-memory.c (gfc_interpret_logical): Likewise.\n+\n 2012-09-23  Tobias Burnus  <burnus@net-b.de>\n \n \t* parse.c (parse_derived): Don't set attr.alloc_comp"}, {"sha": "aec7fa207bdc4e5a889d4f9399b540e7709ce6c4", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -404,8 +404,7 @@ gfc_interpret_logical (int kind, unsigned char *buffer, size_t buffer_size,\n {\n   tree t = native_interpret_expr (gfc_get_logical_type (kind), buffer,\n \t\t\t\t  buffer_size);\n-  *logical = double_int_zero_p (tree_to_double_int (t))\n-\t     ? 0 : 1;\n+  *logical = tree_to_double_int (t).is_zero () ? 0 : 1;\n   return size_logical (kind);\n }\n "}, {"sha": "319c36175aa8d9fabdde46d85f20bc86bff75b3b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -1667,10 +1667,10 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n \n   /* If exponent is too large, we won't expand it anyway, so don't bother\n      with large integer values.  */\n-  if (!double_int_fits_in_shwi_p (TREE_INT_CST (rhs)))\n+  if (!TREE_INT_CST (rhs).fits_shwi ())\n     return 0;\n \n-  m = double_int_to_shwi (TREE_INT_CST (rhs));\n+  m = TREE_INT_CST (rhs).to_shwi ();\n   /* There's no ABS for HOST_WIDE_INT, so here we go. It also takes care\n      of the asymmetric range of the integer type.  */\n   n = (unsigned HOST_WIDE_INT) (m < 0 ? -m : m);"}, {"sha": "96c9df9c27dc846e71bfef38704d6d8c492b6320", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -1,3 +1,10 @@\n+2012-09-24  Lawrence Crowl  <crowl@google.com>\n+\n+\t* decl.c (java_init_decl_processing): Change to new double_int API.\n+\t* jcf-parse.c (get_constant): Likewise.\n+\t* boehm.c (mark_reference_fields): Likewise.\n+\t(get_boehm_type_descriptor): Likewise.\n+\n 2012-07-30  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n \n \t* jcf.h (CPool): Use the \"atomic\" GTY option for the tags field."}, {"sha": "0fa8964df453f918b316c463c5157bc97bb7b110", "filename": "gcc/java/boehm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -108,7 +108,7 @@ mark_reference_fields (tree field,\n \t     bits for all words in the record. This is conservative, but the \n \t     size_words != 1 case is impossible in regular java code. */\n \t  for (i = 0; i < size_words; ++i)\n-\t    *mask = double_int_setbit (*mask, ubit - count - i - 1);\n+\t    *mask = (*mask).set_bit (ubit - count - i - 1);\n \n \t  if (count >= ubit - 2)\n \t    *pointer_after_end = 1;\n@@ -200,7 +200,7 @@ get_boehm_type_descriptor (tree type)\n       while (last_set_index)\n \t{\n \t  if ((last_set_index & 1))\n-\t    mask = double_int_setbit (mask, log2_size + count);\n+\t    mask = mask.set_bit (log2_size + count);\n \t  last_set_index >>= 1;\n \t  ++count;\n \t}\n@@ -209,7 +209,7 @@ get_boehm_type_descriptor (tree type)\n   else if (! pointer_after_end)\n     {\n       /* Bottom two bits for bitmap mark type are 01.  */\n-      mask = double_int_setbit (mask, 0);\n+      mask = mask.set_bit (0);\n       value = double_int_to_tree (value_type, mask);\n     }\n   else"}, {"sha": "30048fd021c6e372c3cf88b2c8545fb7d6e3e7cd", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -617,7 +617,7 @@ java_init_decl_processing (void)\n   decimal_int_max = build_int_cstu (unsigned_int_type_node, 0x80000000);\n   decimal_long_max\n     = double_int_to_tree (unsigned_long_type_node,\n-\t\t\t  double_int_setbit (double_int_zero, 64));\n+\t\t\t  double_int_zero.set_bit (64));\n \n   long_zero_node = build_int_cst (long_type_node, 0);\n "}, {"sha": "92f032cb9d0b2855ee9e68ae90305ae4e7ed867c", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -1043,9 +1043,9 @@ get_constant (JCF *jcf, int index)\n \tdouble_int val;\n \n \tnum = JPOOL_UINT (jcf, index);\n-\tval = double_int_lshift (uhwi_to_double_int (num), 32, 64, false);\n+\tval = double_int::from_uhwi (num).llshift (32, 64);\n \tnum = JPOOL_UINT (jcf, index + 1);\n-\tval = double_int_ior (val, uhwi_to_double_int (num));\n+\tval |= double_int::from_uhwi (num);\n \n \tvalue = double_int_to_tree (long_type_node, val);\n \tbreak;"}, {"sha": "97a9330d156ac2b0e38be1dcbd6b7ab855fb494b", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 78, "deletions": 74, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -1525,109 +1525,117 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n   else if (width <= HOST_BITS_PER_DOUBLE_INT\n \t   && (CONST_DOUBLE_AS_INT_P (op) || CONST_INT_P (op)))\n     {\n-      unsigned HOST_WIDE_INT l1, lv;\n-      HOST_WIDE_INT h1, hv;\n+      double_int first, value;\n \n       if (CONST_DOUBLE_AS_INT_P (op))\n-\tl1 = CONST_DOUBLE_LOW (op), h1 = CONST_DOUBLE_HIGH (op);\n+\tfirst = double_int::from_pair (CONST_DOUBLE_HIGH (op),\n+\t\t\t\t       CONST_DOUBLE_LOW (op));\n       else\n-\tl1 = INTVAL (op), h1 = HWI_SIGN_EXTEND (l1);\n+\tfirst = double_int::from_shwi (INTVAL (op));\n \n       switch (code)\n \t{\n \tcase NOT:\n-\t  lv = ~ l1;\n-\t  hv = ~ h1;\n+\t  value = ~first;\n \t  break;\n \n \tcase NEG:\n-\t  neg_double (l1, h1, &lv, &hv);\n+\t  value = -first;\n \t  break;\n \n \tcase ABS:\n-\t  if (h1 < 0)\n-\t    neg_double (l1, h1, &lv, &hv);\n+\t  if (first.is_negative ())\n+\t    value = -first;\n \t  else\n-\t    lv = l1, hv = h1;\n+\t    value = first;\n \t  break;\n \n \tcase FFS:\n-\t  hv = 0;\n-\t  if (l1 != 0)\n-\t    lv = ffs_hwi (l1);\n-\t  else if (h1 != 0)\n-\t    lv = HOST_BITS_PER_WIDE_INT + ffs_hwi (h1);\n+\t  value.high = 0;\n+\t  if (first.low != 0)\n+\t    value.low = ffs_hwi (first.low);\n+\t  else if (first.high != 0)\n+\t    value.low = HOST_BITS_PER_WIDE_INT + ffs_hwi (first.high);\n \t  else\n-\t    lv = 0;\n+\t    value.low = 0;\n \t  break;\n \n \tcase CLZ:\n-\t  hv = 0;\n-\t  if (h1 != 0)\n-\t    lv = GET_MODE_PRECISION (mode) - floor_log2 (h1) - 1\n-\t      - HOST_BITS_PER_WIDE_INT;\n-\t  else if (l1 != 0)\n-\t    lv = GET_MODE_PRECISION (mode) - floor_log2 (l1) - 1;\n-\t  else if (! CLZ_DEFINED_VALUE_AT_ZERO (mode, lv))\n-\t    lv = GET_MODE_PRECISION (mode);\n+\t  value.high = 0;\n+\t  if (first.high != 0)\n+\t    value.low = GET_MODE_PRECISION (mode) - floor_log2 (first.high) - 1\n+\t              - HOST_BITS_PER_WIDE_INT;\n+\t  else if (first.low != 0)\n+\t    value.low = GET_MODE_PRECISION (mode) - floor_log2 (first.low) - 1;\n+\t  else if (! CLZ_DEFINED_VALUE_AT_ZERO (mode, value.low))\n+\t    value.low = GET_MODE_PRECISION (mode);\n \t  break;\n \n \tcase CTZ:\n-\t  hv = 0;\n-\t  if (l1 != 0)\n-\t    lv = ctz_hwi (l1);\n-\t  else if (h1 != 0)\n-\t    lv = HOST_BITS_PER_WIDE_INT + ctz_hwi (h1);\n-\t  else if (! CTZ_DEFINED_VALUE_AT_ZERO (mode, lv))\n-\t    lv = GET_MODE_PRECISION (mode);\n+\t  value.high = 0;\n+\t  if (first.low != 0)\n+\t    value.low = ctz_hwi (first.low);\n+\t  else if (first.high != 0)\n+\t    value.low = HOST_BITS_PER_WIDE_INT + ctz_hwi (first.high);\n+\t  else if (! CTZ_DEFINED_VALUE_AT_ZERO (mode, value.low))\n+\t    value.low = GET_MODE_PRECISION (mode);\n \t  break;\n \n \tcase POPCOUNT:\n-\t  hv = 0;\n-\t  lv = 0;\n-\t  while (l1)\n-\t    lv++, l1 &= l1 - 1;\n-\t  while (h1)\n-\t    lv++, h1 &= h1 - 1;\n+\t  value = double_int_zero;\n+\t  while (first.low)\n+\t    {\n+\t      value.low++;\n+\t      first.low &= first.low - 1;\n+\t    }\n+\t  while (first.high)\n+\t    {\n+\t      value.low++;\n+\t      first.high &= first.high - 1;\n+\t    }\n \t  break;\n \n \tcase PARITY:\n-\t  hv = 0;\n-\t  lv = 0;\n-\t  while (l1)\n-\t    lv++, l1 &= l1 - 1;\n-\t  while (h1)\n-\t    lv++, h1 &= h1 - 1;\n-\t  lv &= 1;\n+\t  value = double_int_zero;\n+\t  while (first.low)\n+\t    {\n+\t      value.low++;\n+\t      first.low &= first.low - 1;\n+\t    }\n+\t  while (first.high)\n+\t    {\n+\t      value.low++;\n+\t      first.high &= first.high - 1;\n+\t    }\n+\t  value.low &= 1;\n \t  break;\n \n \tcase BSWAP:\n \t  {\n \t    unsigned int s;\n \n-\t    hv = 0;\n-\t    lv = 0;\n+\t    value = double_int_zero;\n \t    for (s = 0; s < width; s += 8)\n \t      {\n \t\tunsigned int d = width - s - 8;\n \t\tunsigned HOST_WIDE_INT byte;\n \n \t\tif (s < HOST_BITS_PER_WIDE_INT)\n-\t\t  byte = (l1 >> s) & 0xff;\n+\t\t  byte = (first.low >> s) & 0xff;\n \t\telse\n-\t\t  byte = (h1 >> (s - HOST_BITS_PER_WIDE_INT)) & 0xff;\n+\t\t  byte = (first.high >> (s - HOST_BITS_PER_WIDE_INT)) & 0xff;\n \n \t\tif (d < HOST_BITS_PER_WIDE_INT)\n-\t\t  lv |= byte << d;\n+\t\t  value.low |= byte << d;\n \t\telse\n-\t\t  hv |= byte << (d - HOST_BITS_PER_WIDE_INT);\n+\t\t  value.high |= byte << (d - HOST_BITS_PER_WIDE_INT);\n \t      }\n \t  }\n \t  break;\n \n \tcase TRUNCATE:\n \t  /* This is just a change-of-mode, so do nothing.  */\n-\t  lv = l1, hv = h1;\n+\t  value = first;\n \t  break;\n \n \tcase ZERO_EXTEND:\n@@ -1636,8 +1644,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  if (op_width > HOST_BITS_PER_WIDE_INT)\n \t    return 0;\n \n-\t  hv = 0;\n-\t  lv = l1 & GET_MODE_MASK (op_mode);\n+\t  value = double_int::from_uhwi (first.low & GET_MODE_MASK (op_mode));\n \t  break;\n \n \tcase SIGN_EXTEND:\n@@ -1646,11 +1653,11 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t    return 0;\n \t  else\n \t    {\n-\t      lv = l1 & GET_MODE_MASK (op_mode);\n-\t      if (val_signbit_known_set_p (op_mode, lv))\n-\t\tlv |= ~GET_MODE_MASK (op_mode);\n+\t      value.low = first.low & GET_MODE_MASK (op_mode);\n+\t      if (val_signbit_known_set_p (op_mode, value.low))\n+\t\tvalue.low |= ~GET_MODE_MASK (op_mode);\n \n-\t      hv = HWI_SIGN_EXTEND (lv);\n+\t      value.high = HWI_SIGN_EXTEND (value.low);\n \t    }\n \t  break;\n \n@@ -1661,7 +1668,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  return 0;\n \t}\n \n-      return immed_double_const (lv, hv, mode);\n+      return immed_double_int_const (value, mode);\n     }\n \n   else if (CONST_DOUBLE_AS_FLOAT_P (op) \n@@ -3578,6 +3585,7 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n       && (CONST_DOUBLE_AS_INT_P (op1) || CONST_INT_P (op1)))\n     {\n       double_int o0, o1, res, tmp;\n+      bool overflow;\n \n       o0 = rtx_to_double_int (op0);\n       o1 = rtx_to_double_int (op1);\n@@ -3599,34 +3607,30 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t  break;\n \n \tcase DIV:\n-\t  if (div_and_round_double (TRUNC_DIV_EXPR, 0,\n-\t\t\t\t    o0.low, o0.high, o1.low, o1.high,\n-\t\t\t\t    &res.low, &res.high,\n-\t\t\t\t    &tmp.low, &tmp.high))\n+          res = o0.divmod_with_overflow (o1, false, TRUNC_DIV_EXPR,\n+\t\t\t\t\t &tmp, &overflow);\n+\t  if (overflow)\n \t    return 0;\n \t  break;\n \n \tcase MOD:\n-\t  if (div_and_round_double (TRUNC_DIV_EXPR, 0,\n-\t\t\t\t    o0.low, o0.high, o1.low, o1.high,\n-\t\t\t\t    &tmp.low, &tmp.high,\n-\t\t\t\t    &res.low, &res.high))\n+          tmp = o0.divmod_with_overflow (o1, false, TRUNC_DIV_EXPR,\n+\t\t\t\t\t &res, &overflow);\n+\t  if (overflow)\n \t    return 0;\n \t  break;\n \n \tcase UDIV:\n-\t  if (div_and_round_double (TRUNC_DIV_EXPR, 1,\n-\t\t\t\t    o0.low, o0.high, o1.low, o1.high,\n-\t\t\t\t    &res.low, &res.high,\n-\t\t\t\t    &tmp.low, &tmp.high))\n+          res = o0.divmod_with_overflow (o1, true, TRUNC_DIV_EXPR,\n+\t\t\t\t\t &tmp, &overflow);\n+\t  if (overflow)\n \t    return 0;\n \t  break;\n \n \tcase UMOD:\n-\t  if (div_and_round_double (TRUNC_DIV_EXPR, 1,\n-\t\t\t\t    o0.low, o0.high, o1.low, o1.high,\n-\t\t\t\t    &tmp.low, &tmp.high,\n-\t\t\t\t    &res.low, &res.high))\n+          tmp = o0.divmod_with_overflow (o1, true, TRUNC_DIV_EXPR,\n+\t\t\t\t\t &res, &overflow);\n+\t  if (overflow)\n \t    return 0;\n \t  break;\n "}, {"sha": "309d4375d51dd29477fe80566b06ddba310712d5", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -461,8 +461,8 @@ chrec_fold_multiply (tree type,\n static tree\n tree_fold_binomial (tree type, tree n, unsigned int k)\n {\n-  unsigned HOST_WIDE_INT lidx, lnum, ldenom, lres, ldum;\n-  HOST_WIDE_INT hidx, hnum, hdenom, hres, hdum;\n+  double_int num, denom, idx, di_res;\n+  bool overflow;\n   unsigned int i;\n   tree res;\n \n@@ -472,59 +472,41 @@ tree_fold_binomial (tree type, tree n, unsigned int k)\n   if (k == 1)\n     return fold_convert (type, n);\n \n+  /* Numerator = n.  */\n+  num = TREE_INT_CST (n);\n+\n   /* Check that k <= n.  */\n-  if (TREE_INT_CST_HIGH (n) == 0\n-      && TREE_INT_CST_LOW (n) < k)\n+  if (num.ult (double_int::from_uhwi (k)))\n     return NULL_TREE;\n \n-  /* Numerator = n.  */\n-  lnum = TREE_INT_CST_LOW (n);\n-  hnum = TREE_INT_CST_HIGH (n);\n-\n   /* Denominator = 2.  */\n-  ldenom = 2;\n-  hdenom = 0;\n+  denom = double_int::from_uhwi (2);\n \n   /* Index = Numerator-1.  */\n-  if (lnum == 0)\n-    {\n-      hidx = hnum - 1;\n-      lidx = ~ (unsigned HOST_WIDE_INT) 0;\n-    }\n-  else\n-    {\n-      hidx = hnum;\n-      lidx = lnum - 1;\n-    }\n+  idx = num - double_int_one;\n \n   /* Numerator = Numerator*Index = n*(n-1).  */\n-  if (mul_double (lnum, hnum, lidx, hidx, &lnum, &hnum))\n+  num = num.mul_with_sign (idx, false, &overflow);\n+  if (overflow)\n     return NULL_TREE;\n \n   for (i = 3; i <= k; i++)\n     {\n       /* Index--.  */\n-      if (lidx == 0)\n-\t{\n-\t  hidx--;\n-\t  lidx = ~ (unsigned HOST_WIDE_INT) 0;\n-\t}\n-      else\n-        lidx--;\n+      --idx;\n \n       /* Numerator *= Index.  */\n-      if (mul_double (lnum, hnum, lidx, hidx, &lnum, &hnum))\n+      num = num.mul_with_sign (idx, false, &overflow);\n+      if (overflow)\n \treturn NULL_TREE;\n \n       /* Denominator *= i.  */\n-      mul_double (ldenom, hdenom, i, 0, &ldenom, &hdenom);\n+      denom *= double_int::from_uhwi (i);\n     }\n \n   /* Result = Numerator / Denominator.  */\n-  div_and_round_double (EXACT_DIV_EXPR, 1, lnum, hnum, ldenom, hdenom,\n-\t\t\t&lres, &hres, &ldum, &hdum);\n-\n-  res = build_int_cst_wide (type, lres, hres);\n+  di_res = num.div (denom, true, EXACT_DIV_EXPR);\n+  res = build_int_cst_wide (type, di_res.low, di_res.high);\n   return int_fits_type_p (res, type) ? res : NULL_TREE;\n }\n "}, {"sha": "a84c4b96feef6b345c534ec62edac3f0cd76b5af", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9be0ac8c9e638bc1b52b83d34a98e8176af645e1/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=9be0ac8c9e638bc1b52b83d34a98e8176af645e1", "patch": "@@ -2478,7 +2478,7 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t\t  if (tmin.cmp (tmax, uns) < 0)\n \t\t    covers = true;\n \t\t  tmax = tem + double_int_minus_one;\n-\t\t  if (double_int_cmp (tmax, tem, uns) > 0)\n+\t\t  if (tmax.cmp (tem, uns) > 0)\n \t\t    covers = true;\n \t\t  /* If the anti-range would cover nothing, drop to varying.\n \t\t     Likewise if the anti-range bounds are outside of the\n@@ -2632,37 +2632,26 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t    }\n \t  uns = uns0 & uns1;\n \n-\t  mul_double_wide_with_sign (min0.low, min0.high,\n-\t\t\t\t     min1.low, min1.high,\n-\t\t\t\t     &prod0l.low, &prod0l.high,\n-\t\t\t\t     &prod0h.low, &prod0h.high, true);\n+\t  bool overflow;\n+\t  prod0l = min0.wide_mul_with_sign (min1, true, &prod0h, &overflow);\n \t  if (!uns0 && min0.is_negative ())\n \t    prod0h -= min1;\n \t  if (!uns1 && min1.is_negative ())\n \t    prod0h -= min0;\n \n-\t  mul_double_wide_with_sign (min0.low, min0.high,\n-\t\t\t\t     max1.low, max1.high,\n-\t\t\t\t     &prod1l.low, &prod1l.high,\n-\t\t\t\t     &prod1h.low, &prod1h.high, true);\n+\t  prod1l = min0.wide_mul_with_sign (max1, true, &prod1h, &overflow);\n \t  if (!uns0 && min0.is_negative ())\n \t    prod1h -= max1;\n \t  if (!uns1 && max1.is_negative ())\n \t    prod1h -= min0;\n \n-\t  mul_double_wide_with_sign (max0.low, max0.high,\n-\t\t\t\t     min1.low, min1.high,\n-\t\t\t\t     &prod2l.low, &prod2l.high,\n-\t\t\t\t     &prod2h.low, &prod2h.high, true);\n+\t  prod2l = max0.wide_mul_with_sign (min1, true, &prod2h, &overflow);\n \t  if (!uns0 && max0.is_negative ())\n \t    prod2h -= min1;\n \t  if (!uns1 && min1.is_negative ())\n \t    prod2h -= max0;\n \n-\t  mul_double_wide_with_sign (max0.low, max0.high,\n-\t\t\t\t     max1.low, max1.high,\n-\t\t\t\t     &prod3l.low, &prod3l.high,\n-\t\t\t\t     &prod3h.low, &prod3h.high, true);\n+\t  prod3l = max0.wide_mul_with_sign (max1, true, &prod3h, &overflow);\n \t  if (!uns0 && max0.is_negative ())\n \t    prod3h -= max1;\n \t  if (!uns1 && max1.is_negative ())"}]}