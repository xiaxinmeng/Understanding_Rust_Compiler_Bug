{"sha": "8b11009bad1b794283984fc806198e3cf29dbed3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIxMTAwOWJhZDFiNzk0MjgzOTg0ZmM4MDYxOThlM2NmMjlkYmVkMw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-05-01T10:17:43Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-05-01T10:17:43Z"}, "message": "tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Use bsi_after_labels.\n\n\t* tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Use\n\tbsi_after_labels.  Always insert statements before bsi.\n\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Ditto.\n\t* predict.c (apply_return_prediction): Check for empty blocks.\n\t* cfgexpand.c (lab_rtx_for_bb): New variable.\n\t(label_rtx_for_bb): Do not create new tree labels.\n\t(expand_gimple_basic_block): Add labels recorded in lab_rtx_for_bb.\n\t(tree_expand_cfg): Initialize lab_rtx_for_bb.\n\t* tree-cfg.c (build_tree_cfg): Call cleanup_dead_labels after\n\tcreating edges.\n\t(label_for_bb): Add field used.\n\t(update_eh_label, main_block_label): Mark the label used.\n\t(cleanup_dead_labels): Remove unused labels.\n\nFrom-SVN: r124322", "tree": {"sha": "af410434537ec713cf3e23d857c1ce808af279bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af410434537ec713cf3e23d857c1ce808af279bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b11009bad1b794283984fc806198e3cf29dbed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b11009bad1b794283984fc806198e3cf29dbed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b11009bad1b794283984fc806198e3cf29dbed3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b11009bad1b794283984fc806198e3cf29dbed3/comments", "author": null, "committer": null, "parents": [{"sha": "f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866"}], "stats": {"total": 152, "additions": 101, "deletions": 51}, "files": [{"sha": "2230102974d838567003aff951dea9372d3e8e96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b11009bad1b794283984fc806198e3cf29dbed3", "patch": "@@ -1,3 +1,19 @@\n+2007-05-01  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Use\n+\tbsi_after_labels.  Always insert statements before bsi.\n+\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Ditto.\n+\t* predict.c (apply_return_prediction): Check for empty blocks.\n+\t* cfgexpand.c (lab_rtx_for_bb): New variable.\n+\t(label_rtx_for_bb): Do not create new tree labels.\n+\t(expand_gimple_basic_block): Add labels recorded in lab_rtx_for_bb.\n+\t(tree_expand_cfg): Initialize lab_rtx_for_bb.\n+\t* tree-cfg.c (build_tree_cfg): Call cleanup_dead_labels after\n+\tcreating edges.\n+\t(label_for_bb): Add field used.\n+\t(update_eh_label, main_block_label): Mark the label used.\n+\t(cleanup_dead_labels): Remove unused labels.\n+\n 2007-05-01  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vrp.c (set_value_range): Do not allocate equiv bitmap"}, {"sha": "da1e8552e24bb1f36b7dc7842133b780021c87a1", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=8b11009bad1b794283984fc806198e3cf29dbed3", "patch": "@@ -1244,19 +1244,28 @@ maybe_dump_rtl_for_tree_stmt (tree stmt, rtx since)\n     }\n }\n \n+/* Maps the blocks that do not contain tree labels to rtx labels.  */\n+\n+static struct pointer_map_t *lab_rtx_for_bb;\n+\n /* Returns the label_rtx expression for a label starting basic block BB.  */\n \n static rtx\n label_rtx_for_bb (basic_block bb)\n {\n   tree_stmt_iterator tsi;\n   tree lab, lab_stmt;\n+  void **elt;\n \n   if (bb->flags & BB_RTL)\n     return block_label (bb);\n \n-  /* We cannot use tree_block_label, as we no longer have stmt annotations.\n-     TODO -- avoid creating the new tree labels.  */\n+  elt = pointer_map_contains (lab_rtx_for_bb, bb);\n+  if (elt)\n+    return *elt;\n+\n+  /* Find the tree label if it is present.  */\n+     \n   for (tsi = tsi_start (bb_stmt_list (bb)); !tsi_end_p (tsi); tsi_next (&tsi))\n     {\n       lab_stmt = tsi_stmt (tsi);\n@@ -1270,10 +1279,9 @@ label_rtx_for_bb (basic_block bb)\n       return label_rtx (lab);\n     }\n \n-  lab = create_artificial_label ();\n-  lab_stmt = build1 (LABEL_EXPR, void_type_node, lab);\n-  tsi_link_before (&tsi, lab_stmt, TSI_NEW_STMT);\n-  return label_rtx (lab);\n+  elt = pointer_map_insert (lab_rtx_for_bb, bb);\n+  *elt = gen_label_rtx ();\n+  return *elt;\n }\n \n /* A subroutine of expand_gimple_basic_block.  Expand one COND_EXPR.\n@@ -1477,6 +1485,7 @@ expand_gimple_basic_block (basic_block bb)\n   rtx note, last;\n   edge e;\n   edge_iterator ei;\n+  void **elt;\n \n   if (dump_file)\n     {\n@@ -1510,20 +1519,32 @@ expand_gimple_basic_block (basic_block bb)\n \n   tsi = tsi_start (stmts);\n   if (!tsi_end_p (tsi))\n-    stmt = tsi_stmt (tsi);\n+    {\n+      stmt = tsi_stmt (tsi);\n+      if (TREE_CODE (stmt) != LABEL_EXPR)\n+\tstmt = NULL_TREE;\n+    }\n \n-  if (stmt && TREE_CODE (stmt) == LABEL_EXPR)\n+  elt = pointer_map_contains (lab_rtx_for_bb, bb);\n+\n+  if (stmt || elt)\n     {\n       last = get_last_insn ();\n \n-      expand_expr_stmt (stmt);\n+      if (stmt)\n+\t{\n+\t  expand_expr_stmt (stmt);\n+\t  tsi_next (&tsi);\n+\t}\n+\n+      if (elt)\n+\temit_label (*elt);\n \n       /* Java emits line number notes in the top of labels.\n \t ??? Make this go away once line number notes are obsoleted.  */\n       BB_HEAD (bb) = NEXT_INSN (last);\n       if (NOTE_P (BB_HEAD (bb)))\n \tBB_HEAD (bb) = NEXT_INSN (BB_HEAD (bb));\n-      tsi_next (&tsi);\n       note = emit_note_after (NOTE_INSN_BASIC_BLOCK, BB_HEAD (bb));\n \n       maybe_dump_rtl_for_tree_stmt (stmt, last);\n@@ -1896,8 +1917,10 @@ tree_expand_cfg (void)\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n     e->flags &= ~EDGE_EXECUTABLE;\n \n+  lab_rtx_for_bb = pointer_map_create ();\n   FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR, next_bb)\n     bb = expand_gimple_basic_block (bb);\n+  pointer_map_destroy (lab_rtx_for_bb);\n \n   construct_exit_block ();\n   set_curr_insn_block (DECL_INITIAL (current_function_decl));"}, {"sha": "f4ecb6fd415af60a4db366c952de552ac381ac48", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=8b11009bad1b794283984fc806198e3cf29dbed3", "patch": "@@ -1240,7 +1240,8 @@ apply_return_prediction (int *heads)\n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     {\n       return_stmt = last_stmt (e->src);\n-      if (TREE_CODE (return_stmt) == RETURN_EXPR)\n+      if (return_stmt\n+\t  && TREE_CODE (return_stmt) == RETURN_EXPR)\n \tbreak;\n     }\n   if (!e)"}, {"sha": "bf15bceeb4c905a35e7fea04078fe9e85ce8ae30", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=8b11009bad1b794283984fc806198e3cf29dbed3", "patch": "@@ -181,6 +181,7 @@ build_tree_cfg (tree *tp)\n \n   /* Create the edges of the flowgraph.  */\n   make_edges ();\n+  cleanup_dead_labels ();\n \n   /* Debugging dumps.  */\n \n@@ -830,11 +831,19 @@ make_goto_expr_edges (basic_block bb)\n    to do early because it allows us to group case labels before creating\n    the edges for the CFG, and it speeds up block statement iterators in\n    all passes later on.\n-   We only run this pass once, running it more than once is probably not\n-   profitable.  */\n+   We rerun this pass after CFG is created, to get rid of the labels that\n+   are no longer referenced.  After then we do not run it any more, since\n+   (almost) no new labels should be created.  */\n \n /* A map from basic block index to the leading label of that block.  */\n-static tree *label_for_bb;\n+static struct label_record\n+{\n+  /* The label.  */\n+  tree label;\n+\n+  /* True if the label is referenced from somewhere.  */\n+  bool used;\n+} *label_for_bb;\n \n /* Callback for for_each_eh_region.  Helper for cleanup_dead_labels.  */\n static void\n@@ -852,7 +861,8 @@ update_eh_label (struct eh_region *region)\n       if (! bb)\n \treturn;\n \n-      new_label = label_for_bb[bb->index];\n+      new_label = label_for_bb[bb->index].label;\n+      label_for_bb[bb->index].used = true;\n       set_eh_region_tree_label (region, new_label);\n     }\n }\n@@ -862,11 +872,17 @@ static tree\n main_block_label (tree label)\n {\n   basic_block bb = label_to_block (label);\n+  tree main_label = label_for_bb[bb->index].label;\n \n   /* label_to_block possibly inserted undefined label into the chain.  */\n-  if (!label_for_bb[bb->index])\n-    label_for_bb[bb->index] = label;\n-  return label_for_bb[bb->index];\n+  if (!main_label)\n+    {\n+      label_for_bb[bb->index].label = label;\n+      main_label = label;\n+    }\n+\n+  label_for_bb[bb->index].used = true;\n+  return main_label;\n }\n \n /* Cleanup redundant labels.  This is a three-step process:\n@@ -878,7 +894,7 @@ void\n cleanup_dead_labels (void)\n {\n   basic_block bb;\n-  label_for_bb = XCNEWVEC (tree, last_basic_block);\n+  label_for_bb = XCNEWVEC (struct label_record, last_basic_block);\n \n   /* Find a suitable label for each block.  We use the first user-defined\n      label if there is one, or otherwise just the first label we see.  */\n@@ -897,19 +913,19 @@ cleanup_dead_labels (void)\n \n \t  /* If we have not yet seen a label for the current block,\n \t     remember this one and see if there are more labels.  */\n-\t  if (! label_for_bb[bb->index])\n+\t  if (!label_for_bb[bb->index].label)\n \t    {\n-\t      label_for_bb[bb->index] = label;\n+\t      label_for_bb[bb->index].label = label;\n \t      continue;\n \t    }\n \n \t  /* If we did see a label for the current block already, but it\n \t     is an artificially created label, replace it if the current\n \t     label is a user defined label.  */\n-\t  if (! DECL_ARTIFICIAL (label)\n-\t      && DECL_ARTIFICIAL (label_for_bb[bb->index]))\n+\t  if (!DECL_ARTIFICIAL (label)\n+\t      && DECL_ARTIFICIAL (label_for_bb[bb->index].label))\n \t    {\n-\t      label_for_bb[bb->index] = label;\n+\t      label_for_bb[bb->index].label = label;\n \t      break;\n \t    }\n \t}\n@@ -981,11 +997,15 @@ cleanup_dead_labels (void)\n   FOR_EACH_BB (bb)\n     {\n       block_stmt_iterator i;\n-      tree label_for_this_bb = label_for_bb[bb->index];\n+      tree label_for_this_bb = label_for_bb[bb->index].label;\n \n-      if (! label_for_this_bb)\n+      if (!label_for_this_bb)\n \tcontinue;\n \n+      /* If the main label of the block is unused, we may still remove it.  */\n+      if (!label_for_bb[bb->index].used)\n+\tlabel_for_this_bb = NULL;\n+\n       for (i = bsi_start (bb); !bsi_end_p (i); )\n \t{\n \t  tree label, stmt = bsi_stmt (i);"}, {"sha": "1e5c5039ac028eb6351ba4f2f205c7a775200d82", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=8b11009bad1b794283984fc806198e3cf29dbed3", "patch": "@@ -4866,7 +4866,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n {\n   tree comp;\n   tree op, stmts, tgt, ass;\n-  block_stmt_iterator bsi, pbsi;\n+  block_stmt_iterator bsi;\n \n   /* An important special case -- if we are asked to express value of\n      the original iv by itself, just exit; there is no need to\n@@ -4937,13 +4937,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n       if (name_info (data, tgt)->preserve_biv)\n \treturn;\n \n-      pbsi = bsi = bsi_start (bb_for_stmt (use->stmt));\n-      while (!bsi_end_p (pbsi)\n-\t     && TREE_CODE (bsi_stmt (pbsi)) == LABEL_EXPR)\n-\t{\n-\t  bsi = pbsi;\n-\t  bsi_next (&pbsi);\n-\t}\n+      bsi = bsi_after_labels (bb_for_stmt (use->stmt));\n       break;\n \n     case GIMPLE_MODIFY_STMT:\n@@ -4956,22 +4950,18 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n     }\n \n   op = force_gimple_operand (comp, &stmts, false, SSA_NAME_VAR (tgt));\n+  if (stmts)\n+    bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n \n   if (TREE_CODE (use->stmt) == PHI_NODE)\n     {\n-      if (stmts)\n-\tbsi_insert_after (&bsi, stmts, BSI_CONTINUE_LINKING);\n       ass = build_gimple_modify_stmt (tgt, op);\n-      bsi_insert_after (&bsi, ass, BSI_NEW_STMT);\n+      bsi_insert_before (&bsi, ass, BSI_SAME_STMT);\n       remove_statement (use->stmt, false);\n       SSA_NAME_DEF_STMT (tgt) = ass;\n     }\n   else\n-    {\n-      if (stmts)\n-\tbsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n-      GIMPLE_STMT_OPERAND (use->stmt, 1) = op;\n-    }\n+    GIMPLE_STMT_OPERAND (use->stmt, 1) = op;\n }\n \n /* Replaces ssa name in index IDX by its basic variable.  Callback for"}, {"sha": "161e82d3314da6ecb9e59bfa9650a735b50074f1", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b11009bad1b794283984fc806198e3cf29dbed3/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=8b11009bad1b794283984fc806198e3cf29dbed3", "patch": "@@ -1174,7 +1174,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   exit_bb = single_exit (loop)->dest;\n   new_phi = create_phi_node (SSA_NAME_VAR (vect_def), exit_bb);\n   SET_PHI_ARG_DEF (new_phi, single_exit (loop)->dest_idx, vect_def);\n-  exit_bsi = bsi_start (exit_bb);\n+  exit_bsi = bsi_after_labels (exit_bb);\n \n   /* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3 \n          (i.e. when reduc_code is not available) and in the final adjustment\n@@ -1223,7 +1223,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n       epilog_stmt = build_gimple_modify_stmt (vec_dest, tmp);\n       new_temp = make_ssa_name (vec_dest, epilog_stmt);\n       GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n-      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+      bsi_insert_before (&exit_bsi, epilog_stmt, BSI_SAME_STMT);\n \n       extract_scalar_result = true;\n     }\n@@ -1280,13 +1280,13 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t      epilog_stmt = build_gimple_modify_stmt (vec_dest, tmp);\n \t      new_name = make_ssa_name (vec_dest, epilog_stmt);\n \t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_name;\n-\t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t      bsi_insert_before (&exit_bsi, epilog_stmt, BSI_SAME_STMT);\n \n \t      tmp = build2 (code, vectype, new_name, new_temp);\n \t      epilog_stmt = build_gimple_modify_stmt (vec_dest, tmp);\n \t      new_temp = make_ssa_name (vec_dest, epilog_stmt);\n \t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n-\t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t      bsi_insert_before (&exit_bsi, epilog_stmt, BSI_SAME_STMT);\n \t    }\n \n \t  extract_scalar_result = true;\n@@ -1316,7 +1316,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t  epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\n \t  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t  GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n-\t  bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t  bsi_insert_before (&exit_bsi, epilog_stmt, BSI_SAME_STMT);\n \t      \n \t  for (bit_offset = element_bitsize;\n \t       bit_offset < vec_size_in_bits;\n@@ -1331,13 +1331,13 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t      epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\n \t      new_name = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_name;\n-\t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t      bsi_insert_before (&exit_bsi, epilog_stmt, BSI_SAME_STMT);\n \n \t      tmp = build2 (code, scalar_type, new_name, new_temp);\n \t      epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, tmp);\n \t      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n-\t      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+\t      bsi_insert_before (&exit_bsi, epilog_stmt, BSI_SAME_STMT);\n \t    }\n \n \t  extract_scalar_result = false;\n@@ -1366,7 +1366,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n       epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp; \n-      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+      bsi_insert_before (&exit_bsi, epilog_stmt, BSI_SAME_STMT);\n     }\n \n   /* 2.4 Adjust the final result by the initial value of the reduction\n@@ -1382,7 +1382,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n       epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, tmp);\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n-      bsi_insert_after (&exit_bsi, epilog_stmt, BSI_NEW_STMT);\n+      bsi_insert_before (&exit_bsi, epilog_stmt, BSI_SAME_STMT);\n     }\n \n   /* 2.6 Replace uses of s_out0 with uses of s_out3  */"}]}