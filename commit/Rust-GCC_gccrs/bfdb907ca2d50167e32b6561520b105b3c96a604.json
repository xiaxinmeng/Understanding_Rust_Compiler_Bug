{"sha": "bfdb907ca2d50167e32b6561520b105b3c96a604", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZkYjkwN2NhMmQ1MDE2N2UzMmI2NTYxNTIwYjEwNWIzYzk2YTYwNA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-04-29T18:16:47Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-04-29T18:16:47Z"}, "message": "locale_facets.tcc (num_get<>::_M_extract_float): Special case main parsing loop for !_M_allocated (i.e., \"C\" locale).\n\n2006-04-29  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float):\n\tSpecial case main parsing loop for !_M_allocated (i.e., \"C\" locale).\n\t(num_get<>::_M_extract_int): Likewise.\n\t* include/bits/locale_facets.h (num_get<>::_M_find): New.\n\nFrom-SVN: r113377", "tree": {"sha": "1703a62d1a43d2f9347b398979fb66f2168f23a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1703a62d1a43d2f9347b398979fb66f2168f23a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfdb907ca2d50167e32b6561520b105b3c96a604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfdb907ca2d50167e32b6561520b105b3c96a604", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfdb907ca2d50167e32b6561520b105b3c96a604", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfdb907ca2d50167e32b6561520b105b3c96a604/comments", "author": null, "committer": null, "parents": [{"sha": "49914d0380452c7dd89fb976d02b0e170694d553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49914d0380452c7dd89fb976d02b0e170694d553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49914d0380452c7dd89fb976d02b0e170694d553"}], "stats": {"total": 385, "additions": 255, "deletions": 130}, "files": [{"sha": "e6d19ef49ff65847ebf1e5c5056e587332fed496", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfdb907ca2d50167e32b6561520b105b3c96a604/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfdb907ca2d50167e32b6561520b105b3c96a604/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bfdb907ca2d50167e32b6561520b105b3c96a604", "patch": "@@ -1,3 +1,10 @@\n+2006-04-29  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float):\n+\tSpecial case main parsing loop for !_M_allocated (i.e., \"C\" locale).\n+\t(num_get<>::_M_extract_int): Likewise.\n+\t* include/bits/locale_facets.h (num_get<>::_M_find): New.\n+\n 2006-04-27  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* docs/html/17_intro/TODO: Update."}, {"sha": "6187fbf8c9cd6fd806fc9ca99a7585ed39e9c5f0", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfdb907ca2d50167e32b6561520b105b3c96a604/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfdb907ca2d50167e32b6561520b105b3c96a604/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=bfdb907ca2d50167e32b6561520b105b3c96a604", "patch": "@@ -47,6 +47,7 @@\n #include <iosfwd>\n #include <bits/ios_base.h>  // For ios_base, ios_base::iostate\n #include <streambuf>\n+#include <bits/cpp_type_traits.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n@@ -2125,6 +2126,43 @@ _GLIBCXX_BEGIN_LDBL_NAMESPACE\n         _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,\n \t\t       _ValueT& __v) const;\n \n+      template<typename _CharT2>\n+        typename __enable_if<int, __is_char<_CharT2>::__value>::__type\n+        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const\n+        {\n+\t  int __ret = -1;\n+\t  if (__len <= 10)\n+\t    {\n+\t      if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))\n+\t\t__ret = __c - _CharT2('0');\n+\t    }\n+\t  else\n+\t    {\n+\t      if (__c >= _CharT2('0') && __c <= _CharT2('9'))\n+\t\t__ret = __c - _CharT2('0');\n+\t      else if (__c >= _CharT2('a') && __c <= _CharT2('f'))\n+\t\t__ret = 10 + (__c - _CharT2('a'));\n+\t      else if (__c >= _CharT2('A') && __c <= _CharT2('F'))\n+\t\t__ret = 10 + (__c - _CharT2('A'));\n+\t    }\n+\t  return __ret;\n+\t}\n+\n+      template<typename _CharT2>\n+        typename __enable_if<int, !__is_char<_CharT2>::__value>::__type\n+        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const\n+        {\n+\t  int __ret = -1;\n+\t  const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);\n+\t  if (__q)\n+\t    {\n+\t      __ret = __q - __zero;\n+\t      if (__ret > 15)\n+\t\t__ret -= 6;\n+\t    }\n+\t  return __ret;\n+\t}\n+\n       //@{\n       /**\n        *  @brief  Numeric parsing."}, {"sha": "bfe6fc7f41952a6c154853e084071737a86da79d", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 210, "deletions": 130, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfdb907ca2d50167e32b6561520b105b3c96a604/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfdb907ca2d50167e32b6561520b105b3c96a604/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=bfdb907ca2d50167e32b6561520b105b3c96a604", "patch": "@@ -340,93 +340,146 @@ _GLIBCXX_BEGIN_LDBL_NAMESPACE\n       string __found_grouping;\n       if (__lc->_M_use_grouping)\n \t__found_grouping.reserve(32);\n-      const char_type* __q;\n       const char_type* __lit_zero = __lit + __num_base::_S_izero;\n-      while (!__testeof)\n-        {\n-\t  // According to 22.2.2.1.2, p8-9, first look for thousands_sep\n-\t  // and decimal_point.\n-          if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n-\t    {\n-\t      if (!__found_dec && !__found_sci)\n-\t\t{\n-\t\t  // NB: Thousands separator at the beginning of a string\n-\t\t  // is a no-no, as is two consecutive thousands separators.\n-\t\t  if (__sep_pos)\n-\t\t    {\n-\t\t      __found_grouping += static_cast<char>(__sep_pos);\n-\t\t      __sep_pos = 0;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      // NB: __convert_to_v will not assign __v and will\n-\t\t      // set the failbit.\n-\t\t      __xtrc.clear();\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tbreak;\n-            }\n-\t  else if (__c == __lc->_M_decimal_point)\n-\t    {\n-\t      if (!__found_dec && !__found_sci)\n-\t\t{\n-\t\t  // If no grouping chars are seen, no grouping check\n-\t\t  // is applied. Therefore __found_grouping is adjusted\n-\t\t  // only if decimal_point comes after some thousands_sep.\n-\t\t  if (__found_grouping.size())\n-\t\t    __found_grouping += static_cast<char>(__sep_pos);\n-\t\t  __xtrc += '.';\n-\t\t  __found_dec = true;\n-\t\t}\n-\t      else\n-\t\tbreak;\n-\t    }\n-          else if ((__q = __traits_type::find(__lit_zero, 10, __c)))\n-\t    {\n-\t      __xtrc += __num_base::_S_atoms_in[__q - __lit];\n-\t      __found_mantissa = true;\n-\t      ++__sep_pos;\n-\t    }\n-\t  else if ((__c == __lit[__num_base::_S_ie] \n-\t\t    || __c == __lit[__num_base::_S_iE])\n-\t\t   && !__found_sci && __found_mantissa)\n-\t    {\n-\t      // Scientific notation.\n-\t      if (__found_grouping.size() && !__found_dec)\n-\t\t__found_grouping += static_cast<char>(__sep_pos);\n-\t      __xtrc += 'e';\n-\t      __found_sci = true;\n \n-\t      // Remove optional plus or minus sign, if they exist.\n-\t      if (++__beg != __end)\n-\t\t{\n-\t\t  __c = *__beg;\n-\t\t  const bool __plus = __c == __lit[__num_base::_S_iplus];\n-\t\t  if ((__plus || __c == __lit[__num_base::_S_iminus])\n-\t\t      && !(__lc->_M_use_grouping\n-\t\t\t   && __c == __lc->_M_thousands_sep)\n-\t\t      && !(__c == __lc->_M_decimal_point))\n-\t\t    __xtrc += __plus ? '+' : '-';\n-\t\t  else\n-\t\t    continue;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  __testeof = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  else\n-\t    // Not a valid input item.\n-\t    break;\n+      if (!__lc->_M_allocated)\n+\t// \"C\" locale\n+\twhile (!__testeof)\n+\t  {\n+\t    const int __digit = _M_find(__lit_zero, 10, __c);\n+\t    if (__digit != -1)\n+\t      {\n+\t\t__xtrc += '0' + __digit;\n+\t\t__found_mantissa = true;\n+\t      }\n+\t    else if (__c == __lc->_M_decimal_point\n+\t\t     && !__found_dec && !__found_sci)\n+\t      {\n+\t\t__xtrc += '.';\n+\t\t__found_dec = true;\n+\t      }\n+\t    else if ((__c == __lit[__num_base::_S_ie] \n+\t\t      || __c == __lit[__num_base::_S_iE])\n+\t\t     && !__found_sci && __found_mantissa)\n+\t      {\n+\t\t// Scientific notation.\n+\t\t__xtrc += 'e';\n+\t\t__found_sci = true;\n+\t\t\n+\t\t// Remove optional plus or minus sign, if they exist.\n+\t\tif (++__beg != __end)\n+\t\t  {\n+\t\t    __c = *__beg;\n+\t\t    const bool __plus = __c == __lit[__num_base::_S_iplus];\n+\t\t    if (__plus || __c == __lit[__num_base::_S_iminus])\n+\t\t      __xtrc += __plus ? '+' : '-';\n+\t\t    else\n+\t\t      continue;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    __testeof = true;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      break;\n \n-\t  if (++__beg != __end)\n-\t    __c = *__beg;\n-\t  else\n-\t    __testeof = true;\n-        }\n+\t    if (++__beg != __end)\n+\t      __c = *__beg;\n+\t    else\n+\t      __testeof = true;\n+\t  }\n+      else\n+\twhile (!__testeof)\n+\t  {\n+\t    // According to 22.2.2.1.2, p8-9, first look for thousands_sep\n+\t    // and decimal_point.\n+\t    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n+\t      {\n+\t\tif (!__found_dec && !__found_sci)\n+\t\t  {\n+\t\t    // NB: Thousands separator at the beginning of a string\n+\t\t    // is a no-no, as is two consecutive thousands separators.\n+\t\t    if (__sep_pos)\n+\t\t      {\n+\t\t\t__found_grouping += static_cast<char>(__sep_pos);\n+\t\t\t__sep_pos = 0;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\t// NB: __convert_to_v will not assign __v and will\n+\t\t\t// set the failbit.\n+\t\t\t__xtrc.clear();\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  break;\n+\t      }\n+\t    else if (__c == __lc->_M_decimal_point)\n+\t      {\n+\t\tif (!__found_dec && !__found_sci)\n+\t\t  {\n+\t\t    // If no grouping chars are seen, no grouping check\n+\t\t    // is applied. Therefore __found_grouping is adjusted\n+\t\t    // only if decimal_point comes after some thousands_sep.\n+\t\t    if (__found_grouping.size())\n+\t\t      __found_grouping += static_cast<char>(__sep_pos);\n+\t\t    __xtrc += '.';\n+\t\t    __found_dec = true;\n+\t\t  }\n+\t\telse\n+\t\t  break;\n+\t      }\n+\t    else\n+\t      {\n+\t\tconst char_type* __q =\n+\t\t  __traits_type::find(__lit_zero, 10, __c);\n+\t\tif (__q)\n+\t\t  {\n+\t\t    __xtrc += '0' + (__q - __lit_zero);\n+\t\t    __found_mantissa = true;\n+\t\t    ++__sep_pos;\n+\t\t  }\n+\t\telse if ((__c == __lit[__num_base::_S_ie] \n+\t\t\t  || __c == __lit[__num_base::_S_iE])\n+\t\t\t && !__found_sci && __found_mantissa)\n+\t\t  {\n+\t\t    // Scientific notation.\n+\t\t    if (__found_grouping.size() && !__found_dec)\n+\t\t      __found_grouping += static_cast<char>(__sep_pos);\n+\t\t    __xtrc += 'e';\n+\t\t    __found_sci = true;\n+\t\t    \n+\t\t    // Remove optional plus or minus sign, if they exist.\n+\t\t    if (++__beg != __end)\n+\t\t      {\n+\t\t\t__c = *__beg;\n+\t\t\tconst bool __plus = __c == __lit[__num_base::_S_iplus];\n+\t\t\tif ((__plus || __c == __lit[__num_base::_S_iminus])\n+\t\t\t    && !(__lc->_M_use_grouping\n+\t\t\t\t && __c == __lc->_M_thousands_sep)\n+\t\t\t    && !(__c == __lc->_M_decimal_point))\n+\t\t      __xtrc += __plus ? '+' : '-';\n+\t\t\telse\n+\t\t\t  continue;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\t__testeof = true;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  break;\n+\t      }\n+\t    \n+\t    if (++__beg != __end)\n+\t      __c = *__beg;\n+\t    else\n+\t      __testeof = true;\n+\t  }\n \n       // Digit grouping is checked. If grouping and found_grouping don't\n       // match, then get very very upset, and set failbit.\n@@ -569,54 +622,81 @@ _GLIBCXX_BEGIN_LDBL_NAMESPACE\n \t  -numeric_limits<_ValueT>::min() : numeric_limits<_ValueT>::max();\n \tconst __unsigned_type __smax = __max / __base;\n \t__unsigned_type __result = 0;\n-\tconst char_type* __q;\n+\tint __digit = 0;\n \tconst char_type* __lit_zero = __lit + __num_base::_S_izero;\n-\twhile (!__testeof)\n-\t  {\n-\t    // According to 22.2.2.1.2, p8-9, first look for thousands_sep\n-\t    // and decimal_point.\n-\t    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n-\t      {\n-\t\t// NB: Thousands separator at the beginning of a string\n-\t\t// is a no-no, as is two consecutive thousands separators.\n-\t\tif (__sep_pos)\n-\t\t  {\n-\t\t    __found_grouping += static_cast<char>(__sep_pos);\n-\t\t    __sep_pos = 0;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    __testfail = true;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    else if (__c == __lc->_M_decimal_point)\n-\t      break;\n-\t    else if ((__q = __traits_type::find(__lit_zero, __len, __c)))\n-\t      {\n-\t\tint __digit = __q - __lit_zero;\n-\t\tif (__digit > 15)\n-\t\t  __digit -= 6;\n-\t\tif (__result > __smax)\n-\t\t  __testfail = true;\n-\t\telse\n-\t\t  {\n-\t\t    __result *= __base;\n-\t\t    __testfail |= __result > __max - __digit;\n-\t\t    __result += __digit;\n-\t\t    ++__sep_pos;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      // Not a valid input item.\t      \n-\t      break;\n-\t    \n-\t    if (++__beg != __end)\n-\t      __c = *__beg;\n-\t    else\n-\t      __testeof = true;\n-\t  }\n \n+\tif (!__lc->_M_allocated)\n+\t  // \"C\" locale\n+\t  while (!__testeof)\n+\t    {\n+\t      __digit = _M_find(__lit_zero, __len, __c);\n+\t      if (__digit == -1)\n+\t\tbreak;\n+\t      \n+\t      if (__result > __smax)\n+\t\t__testfail = true;\n+\t      else\n+\t\t{\n+\t\t  __result *= __base;\n+\t\t  __testfail |= __result > __max - __digit;\n+\t\t  __result += __digit;\n+\t\t  ++__sep_pos;\n+\t\t}\n+\t      \n+\t      if (++__beg != __end)\n+\t\t__c = *__beg;\n+\t      else\n+\t\t__testeof = true;\n+\t    }\n+\telse\n+\t  while (!__testeof)\n+\t    {\n+\t      // According to 22.2.2.1.2, p8-9, first look for thousands_sep\n+\t      // and decimal_point.\n+\t      if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n+\t\t{\n+\t\t  // NB: Thousands separator at the beginning of a string\n+\t\t  // is a no-no, as is two consecutive thousands separators.\n+\t\t  if (__sep_pos)\n+\t\t    {\n+\t\t      __found_grouping += static_cast<char>(__sep_pos);\n+\t\t      __sep_pos = 0;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      __testfail = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      else if (__c == __lc->_M_decimal_point)\n+\t\tbreak;\n+\t      else\n+\t\t{\n+\t\t  const char_type* __q =\n+\t\t    __traits_type::find(__lit_zero, __len, __c);\n+\t\t  if (!__q)\n+\t\t    break;\n+\t\t  \n+\t\t  __digit = __q - __lit_zero;\n+\t\t  if (__digit > 15)\n+\t\t    __digit -= 6;\n+\t\t  if (__result > __smax)\n+\t\t    __testfail = true;\n+\t\t  else\n+\t\t    {\n+\t\t      __result *= __base;\n+\t\t      __testfail |= __result > __max - __digit;\n+\t\t      __result += __digit;\n+\t\t      ++__sep_pos;\n+\t\t    }\n+\t\t}\n+\t      \n+\t      if (++__beg != __end)\n+\t\t__c = *__beg;\n+\t      else\n+\t\t__testeof = true;\n+\t    }\n+\t\n \t// Digit grouping is checked. If grouping and found_grouping don't\n \t// match, then get very very upset, and set failbit.\n \tif (__found_grouping.size())"}]}