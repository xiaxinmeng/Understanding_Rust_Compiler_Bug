{"sha": "2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxZjNhNWUzZTc2YWExMTQ5YjkwNjEzMDRhNGVmMGVhNDA0ODNiMw==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2021-05-03T05:56:38Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-06T14:46:52Z"}, "message": "[Ada] Support for Object.Op subprogram-call notation for untagged types\n\ngcc/ada/\n\n\t* doc/gnat_rm/implementation_defined_pragmas.rst: Add a\n\tdescription of the feature of prefixed-view calls for untagged\n\ttypes to the section on pragma Extensions_Allowed.\n\t* gnat_rm.texi: Regenerate.\n\t* einfo.ads: Update specification for\n\tDirect_Primitive_Operations to reflect its use for untagged\n\ttypes when Extensions_Allowed is True.\n\t* gen_il-gen-gen_entities.adb: Allow Direct_Primitive_Operations\n\tas a field of untagged classes of types by removing the \"Pre\"\n\ttest of \"Is_Tagged_Type (N)\", and making that field generally\n\tavailable for all types and subtypes by defining it for\n\tType_Kind and removing its specification for individual classes\n\tof types.\n\t* sem_ch3.adb (Analyze_Full_Type_Declaration): Initialize the\n\tDirect_Primitive_Operations list when not already set for the\n\tnew (sub)type and its base type (except when Ekind of the type\n\tis E_Void, which can happen due to errors in cases where\n\tDerived_Type_Declaration is called and perhaps in other\n\tsituations).\n\t(Analyze_Subtype_Declaration): Inherit\n\tDirect_Primitive_Operations list from the base type, for record\n\tand private cases.\n\t(Build_Derived_Record_Type): Initialize the\n\tDirect_Primitive_Operations list for derived record and private\n\ttypes.\n\t(Build_Derived_Type): Initialize the Direct_Primitive_Operations\n\tlist for derived types (and also for their associated base types\n\twhen needed).\n\t(Process_Full_View): For full types that are untagged record and\n\tprivate types, copy the primitive operations of the partial view\n\tto the primitives list of the full view.\n\t* sem_ch4.adb (Analyze_Selected_Component): Allow prefixed\n\tnotation for subprogram calls in the case of untagged\n\ttypes (when Extensions_Allowed is True). In the case where\n\tIs_Private_Type (Prefix_Type) is True, call Try_Object_Operation\n\twhen a discriminant selector wasn't found. Also call\n\tTry_Object_Operation in other type kind cases (when\n\tExtensions_Allowed is True).\n\t(Try_Object_Operation.Try_One_Prefixed_Interpretation): Prevent\n\tearly return in the untagged case (when Extensions_Allowed is\n\tTrue). Condition main call to Try_Primitive_Operation on the\n\ttype having primitives, and after that, if Prim_Result is False,\n\ttest for case where the prefix type is a named access type with\n\tprimitive operations and in that case call\n\tTry_Primitive_Operation after temporarily resetting Obj_Type to\n\tdenote the access type (and restore it to the designated type\n\tafter the call)\n\t(Try_Object_Operation.Valid_First_Argument_Of): Do matching type\n\tcomparison by testing Base_Type (Obj_Type) against\n\tBase_Type (Typ), rather than against just Typ, to properly\n\thandle cases where the object prefix has a constrained\n\tsubtype.  (Fixes a bug discovered while working on this\n\tfeature.)\n\t* sem_ch6.adb\n\t(New_Overloaded_Entity.Check_For_Primitive_Subprogram): Add a\n\tprimitive of an untagged type to the type's list of primitive\n\toperations, for both explicit and implicit (derived, so\n\tComes_From_Source is False) subprogram declarations. In the case\n\twhere the new primitive overrides an inherited subprogram,\n\tlocate the primitives Elist that references the overridden\n\tsubprogram, and replace that element of the list with the new\n\tsubprogram (done by calling the new procedure\n\tAdd_Or_Replace_Untagged_Primitive on the result type and each\n\tformal atype).\n\t(Check_For_Primitive_Subprogram.Add_Or_Replace_Untagged_Primitive):\n\tNew nested procedure to either add or replace an untagged\n\tprimitive subprogram in a given type's list of primitive\n\toperations (replacement happens in case where the new subprogram\n\toverrides a primitive of the type).\n\t* sem_ch7.adb (New_Private_Type): When Extensions_Allowed is\n\tTrue, initialize the Direct_Primitive_Operations list of a\n\tprivate type to New_Elmt_List in the case of untagged types.\n\t* sem_ch8.adb (Find_Selected_Component): In the case where the\n\tprefix is an entity name, relax condition that tests\n\tHas_Components so that Analyze_Selected_Component will also be\n\tcalled when Extensions_Allowed is True and the prefix type is\n\tany type.", "tree": {"sha": "9468f7bc379e04fe9e4786474fd77add6f1e8a77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9468f7bc379e04fe9e4786474fd77add6f1e8a77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daf9bc6aeab822da203c01beb47d2c9e11ab3635", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daf9bc6aeab822da203c01beb47d2c9e11ab3635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daf9bc6aeab822da203c01beb47d2c9e11ab3635"}], "stats": {"total": 430, "additions": 346, "deletions": 84}, "files": [{"sha": "c82658d065700738087760be56b7d7823d31f966", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "patch": "@@ -2362,6 +2362,23 @@ of GNAT specific extensions are recognized as follows:\n   knows the lower bound of unconstrained array formals when the formal's\n   subtype has index ranges with static fixed lower bounds.\n \n+* Prefixed-view notation for calls to primitive subprograms of untagged types\n+\n+  Since Ada 2005, calls to primitive subprograms of a tagged type that\n+  have a \"prefixed view\" (see RM 4.1.3(9.2)) have been allowed to be\n+  written using the form of a selected_component, with the first actual\n+  parameter given as the prefix and the name of the subprogram as a\n+  selector. This prefixed-view notation for calls is extended so as to\n+  also allow such syntax for calls to primitive subprograms of untagged\n+  types. The primitives of an untagged type T that have a prefixed view\n+  are those where the first formal parameter of the subprogram either\n+  is of type T or is an anonymous access parameter whose designated type\n+  is T. For a type that has a component that happens to have the same\n+  simple name as one of the type's primitive subprograms, where the\n+  component is visible at the point of a selected_component using that\n+  name, preference is given to the component in a selected_component\n+  (as is currently the case for tagged types with such component names).\n+\n .. _Pragma-Extensions_Visible:\n \n Pragma Extensions_Visible"}, {"sha": "59588bb94d0a729397a5f1d9c5a7024d0e817149", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "patch": "@@ -933,14 +933,15 @@ package Einfo is\n \n --    Direct_Primitive_Operations\n --       Defined in tagged types and subtypes (including synchronized types),\n---       in tagged private types and in tagged incomplete types. Element list\n---       of entities for primitive operations of the tagged type. Not defined\n---       in untagged types. In order to follow the C++ ABI, entities of\n---       primitives that come from source must be stored in this list in the\n---       order of their occurrence in the sources. For incomplete types the\n---       list is always empty.\n---       When expansion is disabled the corresponding record type of a\n---       synchronized type is not constructed. In that case, such types\n+--       in tagged private types, and in tagged incomplete types. However, when\n+--       Extensions_Allowed is True (-gnatX), also defined for untagged types\n+--       (for support of the extension feature of prefixed calls for untagged\n+--       types). This field is an element list of entities for primitive\n+--       operations of the type. For incomplete types the list is always empty.\n+--       In order to follow the C++ ABI, entities of primitives that come from\n+--       source must be stored in this list in the order of their occurrence in\n+--       the sources. When expansion is disabled, the corresponding record type\n+--       of a synchronized type is not constructed. In that case, such types\n --       carry this attribute directly.\n \n --    Directly_Designated_Type"}, {"sha": "9538a74ab1e6e7d28230a99b55d5b103ddf28dd3", "filename": "gcc/ada/gen_il-gen-gen_entities.adb", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_entities.adb?ref=2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "patch": "@@ -461,6 +461,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Contract, Node_Id),\n         Sm (Current_Use_Clause, Node_Id),\n         Sm (Derived_Type_Link, Node_Id),\n+        Sm (Direct_Primitive_Operations, Elist_Id),\n         Sm (Predicates_Ignored, Flag),\n         Sm (Esize, Uint),\n         Sm (Finalize_Storage_Only, Flag, Base_Type_Only),\n@@ -560,11 +561,9 @@ begin -- Gen_IL.Gen.Gen_Entities\n    Ab (Signed_Integer_Kind, Integer_Kind,\n        (Sm (First_Entity, Node_Id)));\n \n-   Cc (E_Signed_Integer_Type, Signed_Integer_Kind,\n+   Cc (E_Signed_Integer_Type, Signed_Integer_Kind);\n        --  Signed integer type, used for the anonymous base type of the\n        --  integer subtype created by an integer type declaration.\n-       (Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\")));\n \n    Cc (E_Signed_Integer_Subtype, Signed_Integer_Kind);\n        --  Signed integer subtype, created by either an integer subtype or\n@@ -648,14 +647,12 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (No_Strict_Aliasing, Flag, Base_Type_Only),\n         Sm (Storage_Size_Variable, Node_Id, Impl_Base_Type_Only)));\n \n-   Cc (E_Access_Type, Access_Kind,\n+   Cc (E_Access_Type, Access_Kind);\n        --  An access type created by an access type declaration with no all\n        --  keyword present. Note that the predefined type Any_Access, which\n        --  has E_Access_Type Ekind, is used to label NULL in the upwards pass\n        --  of type analysis, to be replaced by the true access type in the\n        --  downwards resolution pass.\n-       (Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\")));\n \n    Cc (E_Access_Subtype, Access_Kind);\n        --  An access subtype created by a subtype declaration for any access\n@@ -739,8 +736,6 @@ begin -- Gen_IL.Gen.Gen_Entities\n        --  An array subtype, created by an explicit array subtype declaration,\n        --  or the use of an anonymous array subtype.\n        (Sm (Predicated_Parent, Node_Id),\n-        Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\"),\n         Sm (First_Entity, Node_Id),\n         Sm (Static_Real_Or_String_Predicate, Node_Id)));\n \n@@ -752,8 +747,6 @@ begin -- Gen_IL.Gen.Gen_Entities\n \n    Ab (Class_Wide_Kind, Aggregate_Kind,\n        (Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n-        Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\"),\n         Sm (Equivalent_Type, Node_Id),\n         Sm (First_Entity, Node_Id),\n         Sm (Has_Complex_Representation, Flag, Impl_Base_Type_Only),\n@@ -785,8 +778,6 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n         Sm (Corresponding_Concurrent_Type, Node_Id),\n         Sm (Corresponding_Remote_Type, Node_Id),\n-        Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\"),\n         Sm (Dispatch_Table_Wrappers, Elist_Id, Impl_Base_Type_Only),\n         Sm (First_Entity, Node_Id),\n         Sm (Has_Complex_Representation, Flag, Impl_Base_Type_Only),\n@@ -807,8 +798,6 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Cloned_Subtype, Node_Id),\n         Sm (Corresponding_Remote_Type, Node_Id),\n         Sm (Predicated_Parent, Node_Id),\n-        Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\"),\n         Sm (Dispatch_Table_Wrappers, Elist_Id, Impl_Base_Type_Only),\n         Sm (First_Entity, Node_Id),\n         Sm (Has_Complex_Representation, Flag, Impl_Base_Type_Only),\n@@ -841,8 +830,6 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n         Sm (Component_Alignment, Component_Alignment_Kind, Base_Type_Only),\n         Sm (Corresponding_Remote_Type, Node_Id),\n-        Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\"),\n         Sm (Has_Complex_Representation, Flag, Impl_Base_Type_Only),\n         Sm (Has_Pragma_Pack, Flag, Impl_Base_Type_Only),\n         Sm (Has_Record_Rep_Clause, Flag, Impl_Base_Type_Only),\n@@ -861,8 +848,6 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Component_Alignment, Component_Alignment_Kind, Base_Type_Only),\n         Sm (Corresponding_Remote_Type, Node_Id),\n         Sm (Predicated_Parent, Node_Id),\n-        Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\"),\n         Sm (Has_Complex_Representation, Flag, Impl_Base_Type_Only),\n         Sm (Has_Pragma_Pack, Flag, Impl_Base_Type_Only),\n         Sm (Has_Record_Rep_Clause, Flag, Impl_Base_Type_Only),\n@@ -877,17 +862,13 @@ begin -- Gen_IL.Gen.Gen_Entities\n    Cc (E_Private_Type, Private_Kind,\n        --  A private type, created by a private type declaration that has\n        --  neither the keyword limited nor the keyword tagged.\n-       (Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\"),\n-        Sm (Scalar_Range, Node_Id),\n+       (Sm (Scalar_Range, Node_Id),\n         Sm (Scope_Depth_Value, Uint)));\n \n    Cc (E_Private_Subtype, Private_Kind,\n        --  A subtype of a private type, created by a subtype declaration used\n        --  to declare a subtype of a private type.\n-       (Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\"),\n-        Sm (Scope_Depth_Value, Uint)));\n+       (Sm (Scope_Depth_Value, Uint)));\n \n    Cc (E_Limited_Private_Type, Private_Kind,\n        --  A limited private type, created by a private type declaration that\n@@ -901,9 +882,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n        (Sm (Scope_Depth_Value, Uint)));\n \n    Ab (Incomplete_Kind, Incomplete_Or_Private_Kind,\n-       (Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\"),\n-        Sm (Non_Limited_View, Node_Id)));\n+       (Sm (Non_Limited_View, Node_Id)));\n \n    Cc (E_Incomplete_Type, Incomplete_Kind,\n        --  An incomplete type, created by an incomplete type declaration\n@@ -915,8 +894,6 @@ begin -- Gen_IL.Gen.Gen_Entities\n \n    Ab (Concurrent_Kind, Composite_Kind,\n        (Sm (Corresponding_Record_Type, Node_Id),\n-        Sm (Direct_Primitive_Operations, Elist_Id,\n-            Pre => \"Is_Tagged_Type (N)\"),\n         Sm (First_Entity, Node_Id),\n         Sm (First_Private_Entity, Node_Id),\n         Sm (Last_Entity, Node_Id),"}, {"sha": "19d6f334aac7d9da04f3ef33feef5f1d72b31c1a", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "patch": "@@ -3793,6 +3793,24 @@ Use of this feature increases safety by simplifying code, and can also\n improve the efficiency of indexing operations, since the compiler statically\n knows the lower bound of unconstrained array formals when the formal\u2019s\n subtype has index ranges with static fixed lower bounds.\n+\n+@item \n+Prefixed-view notation for calls to primitive subprograms of untagged types\n+\n+Since Ada 2005, calls to primitive subprograms of a tagged type that\n+have a \u201cprefixed view\u201d (see RM 4.1.3(9.2)) have been allowed to be\n+written using the form of a selected_component, with the first actual\n+parameter given as the prefix and the name of the subprogram as a\n+selector. This prefixed-view notation for calls is extended so as to\n+also allow such syntax for calls to primitive subprograms of untagged\n+types. The primitives of an untagged type T that have a prefixed view\n+are those where the first formal parameter of the subprogram either\n+is of type T or is an anonymous access parameter whose designated type\n+is T. For a type that has a component that happens to have the same\n+simple name as one of the type\u2019s primitive subprograms, where the\n+component is visible at the point of a selected_component using that\n+name, preference is given to the component in a selected_component\n+(as is currently the case for tagged types with such component names).\n @end itemize\n \n @node Pragma Extensions_Visible,Pragma External,Pragma Extensions_Allowed,Implementation Defined Pragmas"}, {"sha": "936852cef18eab1040b24268190f4e3277f40c53", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 124, "deletions": 38, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "patch": "@@ -3261,6 +3261,40 @@ package body Sem_Ch3 is\n          return;\n       end if;\n \n+      --  Set the primitives list of the full type and its base type when\n+      --  needed. T may be E_Void in cases of earlier errors, and in that\n+      --  case we bypass this.\n+\n+      if Ekind (T) /= E_Void\n+        and then not Present (Direct_Primitive_Operations (T))\n+      then\n+         if Etype (T) = T then\n+            Set_Direct_Primitive_Operations (T, New_Elmt_List);\n+\n+         --  If Etype of T is the base type (as opposed to a parent type) and\n+         --  already has an associated list of primitive operations, then set\n+         --  T's primitive list to the base type's list. Otherwise, create a\n+         --  new empty primitives list and share the list between T and its\n+         --  base type. The lists need to be shared in common between the two.\n+\n+         elsif Etype (T) = Base_Type (T) then\n+\n+            if not Present (Direct_Primitive_Operations (Base_Type (T))) then\n+               Set_Direct_Primitive_Operations\n+                 (Base_Type (T), New_Elmt_List);\n+            end if;\n+\n+            Set_Direct_Primitive_Operations\n+              (T, Direct_Primitive_Operations (Base_Type (T)));\n+\n+         --  Case where the Etype is a parent type, so we need a new primitives\n+         --  list for T.\n+\n+         else\n+            Set_Direct_Primitive_Operations (T, New_Elmt_List);\n+         end if;\n+      end if;\n+\n       --  Some common processing for all types\n \n       Set_Depends_On_Private (T, Has_Private_Component (T));\n@@ -5706,6 +5740,14 @@ package body Sem_Ch3 is\n          Inherit_Predicate_Flags (Id, T);\n       end if;\n \n+      --  When prefixed calls are enabled for untagged types, the subtype\n+      --  shares the primitive operations of its base type.\n+\n+      if Extensions_Allowed then\n+         Set_Direct_Primitive_Operations\n+           (Id, Direct_Primitive_Operations (Base_Type (T)));\n+      end if;\n+\n       if Etype (Id) = Any_Type then\n          goto Leave;\n       end if;\n@@ -9507,6 +9549,13 @@ package body Sem_Ch3 is\n          end;\n       end if;\n \n+      --  When prefixed-call syntax is allowed for untagged types, initialize\n+      --  the list of primitive operations to an empty list.\n+\n+      if Extensions_Allowed and then not Is_Tagged then\n+         Set_Direct_Primitive_Operations (Derived_Type, New_Elmt_List);\n+      end if;\n+\n       --  Set fields for tagged types\n \n       if Is_Tagged then\n@@ -9985,6 +10034,28 @@ package body Sem_Ch3 is\n          return;\n       end if;\n \n+      --  If not already set, initialize the derived type's list of primitive\n+      --  operations to an empty element list.\n+\n+      if not Present (Direct_Primitive_Operations (Derived_Type)) then\n+         Set_Direct_Primitive_Operations (Derived_Type, New_Elmt_List);\n+\n+         --  If Etype of the derived type is the base type (as opposed to\n+         --  a parent type) and doesn't have an associated list of primitive\n+         --  operations, then set the base type's primitive list to the\n+         --  derived type's list. The lists need to be shared in common\n+         --  between the two.\n+\n+         if Etype (Derived_Type) = Base_Type (Derived_Type)\n+           and then\n+             not Present (Direct_Primitive_Operations (Etype (Derived_Type)))\n+         then\n+            Set_Direct_Primitive_Operations\n+              (Etype (Derived_Type),\n+               Direct_Primitive_Operations (Derived_Type));\n+         end if;\n+      end if;\n+\n       --  Set delayed freeze and then derive subprograms, we need to do this\n       --  in this order so that derived subprograms inherit the derived freeze\n       --  if necessary.\n@@ -21011,48 +21082,48 @@ package body Sem_Ch3 is\n          end loop;\n       end;\n \n-      --  If the private view was tagged, copy the new primitive operations\n-      --  from the private view to the full view.\n+      declare\n+         Disp_Typ  : Entity_Id;\n+         Full_List : Elist_Id;\n+         Prim      : Entity_Id;\n+         Prim_Elmt : Elmt_Id;\n+         Priv_List : Elist_Id;\n+\n+         function Contains\n+           (E : Entity_Id;\n+            L : Elist_Id) return Boolean;\n+         --  Determine whether list L contains element E\n+\n+         --------------\n+         -- Contains --\n+         --------------\n+\n+         function Contains\n+           (E : Entity_Id;\n+            L : Elist_Id) return Boolean\n+         is\n+            List_Elmt : Elmt_Id;\n \n-      if Is_Tagged_Type (Full_T) then\n-         declare\n-            Disp_Typ  : Entity_Id;\n-            Full_List : Elist_Id;\n-            Prim      : Entity_Id;\n-            Prim_Elmt : Elmt_Id;\n-            Priv_List : Elist_Id;\n-\n-            function Contains\n-              (E : Entity_Id;\n-               L : Elist_Id) return Boolean;\n-            --  Determine whether list L contains element E\n-\n-            --------------\n-            -- Contains --\n-            --------------\n-\n-            function Contains\n-              (E : Entity_Id;\n-               L : Elist_Id) return Boolean\n-            is\n-               List_Elmt : Elmt_Id;\n+         begin\n+            List_Elmt := First_Elmt (L);\n+            while Present (List_Elmt) loop\n+               if Node (List_Elmt) = E then\n+                  return True;\n+               end if;\n \n-            begin\n-               List_Elmt := First_Elmt (L);\n-               while Present (List_Elmt) loop\n-                  if Node (List_Elmt) = E then\n-                     return True;\n-                  end if;\n+               Next_Elmt (List_Elmt);\n+            end loop;\n \n-                  Next_Elmt (List_Elmt);\n-               end loop;\n+            return False;\n+         end Contains;\n \n-               return False;\n-            end Contains;\n+      --  Start of processing\n \n-         --  Start of processing\n+      begin\n+         --  If the private view was tagged, copy the new primitive operations\n+         --  from the private view to the full view.\n \n-         begin\n+         if Is_Tagged_Type (Full_T) then\n             if Is_Tagged_Type (Priv_T) then\n                Priv_List := Primitive_Operations (Priv_T);\n                Prim_Elmt := First_Elmt (Priv_List);\n@@ -21186,8 +21257,23 @@ package body Sem_Ch3 is\n \n                Propagate_Concurrent_Flags (Class_Wide_Type (Priv_T), Full_T);\n             end if;\n-         end;\n-      end if;\n+\n+         --  For untagged types, copy the primitives across from the private\n+         --  view to the full view (when extensions are allowed), for support\n+         --  of prefixed calls (when extensions are enabled).\n+\n+         elsif Extensions_Allowed then\n+            Priv_List := Primitive_Operations (Priv_T);\n+            Prim_Elmt := First_Elmt (Priv_List);\n+\n+            Full_List := Primitive_Operations (Full_T);\n+            while Present (Prim_Elmt) loop\n+               Prim := Node (Prim_Elmt);\n+               Append_Elmt (Prim, Full_List);\n+               Next_Elmt (Prim_Elmt);\n+            end loop;\n+         end if;\n+      end;\n \n       --  Ada 2005 AI 161: Check preelaborable initialization consistency\n "}, {"sha": "eb1a556dd5c7340d0b9039bc4b290c7ddf081be5", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "patch": "@@ -5002,8 +5002,11 @@ package body Sem_Ch4 is\n          --  Ada 2005 (AI05-0030): In the case of dispatching requeue, the\n          --  selected component should resolve to a name.\n \n+         --  Extension feature: Also support calls with prefixed views for\n+         --  untagged record types.\n+\n          if Ada_Version >= Ada_2005\n-           and then Is_Tagged_Type (Prefix_Type)\n+           and then (Is_Tagged_Type (Prefix_Type) or else Extensions_Allowed)\n            and then not Is_Concurrent_Type (Prefix_Type)\n          then\n             if Nkind (Parent (N)) = N_Generic_Association\n@@ -5076,6 +5079,15 @@ package body Sem_Ch4 is\n             Next_Entity (Comp);\n          end loop;\n \n+         --  Extension feature: Also support calls with prefixed views for\n+         --  untagged private types.\n+\n+         if Extensions_Allowed then\n+            if Try_Object_Operation (N) then\n+               return;\n+            end if;\n+         end if;\n+\n       elsif Is_Concurrent_Type (Prefix_Type) then\n \n          --  Find visible operation with given name. For a protected type,\n@@ -5328,6 +5340,14 @@ package body Sem_Ch4 is\n \n          Set_Is_Overloaded (N, Is_Overloaded (Sel));\n \n+      --  Extension feature: Also support calls with prefixed views for\n+      --  untagged types.\n+\n+      elsif Extensions_Allowed\n+        and then Try_Object_Operation (N)\n+      then\n+         return;\n+\n       else\n          --  Invalid prefix\n \n@@ -9536,7 +9556,11 @@ package body Sem_Ch4 is\n          --  type, this is not a prefixed call. Restore the previous type as\n          --  the current one is not a legal candidate.\n \n-         if not Is_Tagged_Type (Obj_Type)\n+         --  Extension feature: Calls with prefixed views are also supported\n+         --  for untagged types, so skip the early return when extensions are\n+         --  enabled.\n+\n+         if (not Is_Tagged_Type (Obj_Type) and then not Extensions_Allowed)\n            or else Is_Incomplete_Type (Obj_Type)\n          then\n             Obj_Type := Prev_Obj_Type;\n@@ -9554,6 +9578,36 @@ package body Sem_Ch4 is\n                   Try_Primitive_Operation\n                    (Call_Node       => New_Call_Node,\n                     Node_To_Replace => Node_To_Replace);\n+\n+               --  Extension feature: In the case where the prefix is of an\n+               --  access type, and a primitive wasn't found for the designated\n+               --  type, then if the access type has primitives we attempt a\n+               --  prefixed call using one of its primitives. (It seems that\n+               --  this isn't quite right to give preference to the designated\n+               --  type in the case where both the access and designated types\n+               --  have homographic prefixed-view operations that could result\n+               --  in an ambiguity, but handling properly may be tricky. ???)\n+\n+               if Extensions_Allowed\n+                 and then not Prim_Result\n+                 and then Is_Named_Access_Type (Prev_Obj_Type)\n+                 and then Present (Direct_Primitive_Operations (Prev_Obj_Type))\n+               then\n+                  --  Temporarily reset Obj_Type to the original access type\n+\n+                  Obj_Type := Prev_Obj_Type;\n+\n+                  Prim_Result :=\n+                     Try_Primitive_Operation\n+                      (Call_Node       => New_Call_Node,\n+                       Node_To_Replace => Node_To_Replace);\n+\n+                  --  Restore Obj_Type to the designated type (is this really\n+                  --  necessary, or should it only be done when Prim_Result is\n+                  --  still False?).\n+\n+                  Obj_Type := Designated_Type (Obj_Type);\n+               end if;\n             end if;\n \n             --  Check if there is a class-wide subprogram covering the\n@@ -9893,7 +9947,7 @@ package body Sem_Ch4 is\n             --  be the corresponding record of a synchronized type.\n \n             return Obj_Type = Typ\n-              or else Base_Type (Obj_Type) = Typ\n+              or else Base_Type (Obj_Type) = Base_Type (Typ)\n               or else Corr_Type = Typ\n \n               --  Object may be of a derived type whose parent has unknown"}, {"sha": "abe8060a7b18ff178f34d8c15d20c1a462f299f6", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 96, "deletions": 2, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "patch": "@@ -11022,6 +11022,12 @@ package body Sem_Ch6 is\n          F_Typ  : Entity_Id;\n          B_Typ  : Entity_Id;\n \n+         procedure Add_Or_Replace_Untagged_Primitive (Typ : Entity_Id);\n+         --  Either add the new subprogram to the list of primitives for\n+         --  untagged type Typ, or if it overrides a primitive of Typ, then\n+         --  replace the overridden primitive in Typ's primitives list with\n+         --  the new subprogram.\n+\n          function Visible_Part_Type (T : Entity_Id) return Boolean;\n          --  Returns true if T is declared in the visible part of the current\n          --  package scope; otherwise returns false. Assumes that T is declared\n@@ -11035,6 +11041,63 @@ package body Sem_Ch6 is\n          --  in a private part, then it must override a function declared in\n          --  the visible part.\n \n+         ---------------------------------------\n+         -- Add_Or_Replace_Untagged_Primitive --\n+         ---------------------------------------\n+\n+         procedure Add_Or_Replace_Untagged_Primitive (Typ : Entity_Id) is\n+            Replaced_Overridden_Subp : Boolean := False;\n+\n+         begin\n+            pragma Assert (not Is_Tagged_Type (Typ));\n+\n+            --  Anonymous access types don't have a primitives list. Normally\n+            --  such types wouldn't make it here, but the case of anonymous\n+            --  access-to-subprogram types can.\n+\n+            if not Is_Anonymous_Access_Type (Typ) then\n+\n+               --  If S overrides a subprogram that's a primitive of\n+               --  the formal's type, then replace the overridden\n+               --  subprogram with the new subprogram in the type's\n+               --  list of primitives.\n+\n+               if Is_Overriding then\n+                  pragma Assert (Present (Overridden_Subp)\n+                    and then Overridden_Subp = E);  -- Added for now\n+\n+                  declare\n+                     Prim_Ops : constant Elist_Id :=\n+                       Primitive_Operations (Typ);\n+                     Elmt     : Elmt_Id;\n+                  begin\n+                     if Present (Prim_Ops) then\n+                        Elmt := First_Elmt (Prim_Ops);\n+\n+                        while Present (Elmt)\n+                          and then Node (Elmt) /= Overridden_Subp\n+                        loop\n+                           Next_Elmt (Elmt);\n+                        end loop;\n+\n+                        if Present (Elmt) then\n+                           Replace_Elmt (Elmt, S);\n+                           Replaced_Overridden_Subp := True;\n+                        end if;\n+                     end if;\n+                  end;\n+               end if;\n+\n+               --  If the new subprogram did not override an operation\n+               --  of the formal's type, then add it to the primitives\n+               --  list of the type.\n+\n+               if not Replaced_Overridden_Subp then\n+                  Append_Unique_Elmt (S, Primitive_Operations (Typ));\n+               end if;\n+            end if;\n+         end Add_Or_Replace_Untagged_Primitive;\n+\n          ------------------------------\n          -- Check_Private_Overriding --\n          ------------------------------\n@@ -11213,7 +11276,17 @@ package body Sem_Ch6 is\n          Is_Primitive := False;\n \n          if not Comes_From_Source (S) then\n-            null;\n+\n+            --  Add an inherited primitive for an untagged derived type to\n+            --  Derived_Type's list of primitives. Tagged primitives are dealt\n+            --  with in Check_Dispatching_Operation.\n+\n+            if Present (Derived_Type)\n+              and then Extensions_Allowed\n+              and then not Is_Tagged_Type (Derived_Type)\n+            then\n+               Append_Unique_Elmt (S, Primitive_Operations (Derived_Type));\n+            end if;\n \n          --  If subprogram is at library level, it is not primitive operation\n \n@@ -11242,8 +11315,18 @@ package body Sem_Ch6 is\n                   Is_Primitive := True;\n                   Set_Has_Primitive_Operations (B_Typ);\n                   Set_Is_Primitive (S);\n-                  Check_Private_Overriding (B_Typ);\n \n+                  --  Add a primitive for an untagged type to B_Typ's list\n+                  --  of primitives. Tagged primitives are dealt with in\n+                  --  Check_Dispatching_Operation.\n+\n+                  if Extensions_Allowed\n+                    and then not Is_Tagged_Type (B_Typ)\n+                  then\n+                     Add_Or_Replace_Untagged_Primitive (B_Typ);\n+                  end if;\n+\n+                  Check_Private_Overriding (B_Typ);\n                   --  The Ghost policy in effect at the point of declaration\n                   --  or a tagged type and a primitive operation must match\n                   --  (SPARK RM 6.9(16)).\n@@ -11275,6 +11358,17 @@ package body Sem_Ch6 is\n                   Is_Primitive := True;\n                   Set_Is_Primitive (S);\n                   Set_Has_Primitive_Operations (B_Typ);\n+\n+                  --  Add a primitive for an untagged type to B_Typ's list\n+                  --  of primitives. Tagged primitives are dealt with in\n+                  --  Check_Dispatching_Operation.\n+\n+                  if Extensions_Allowed\n+                    and then not Is_Tagged_Type (B_Typ)\n+                  then\n+                     Add_Or_Replace_Untagged_Primitive (B_Typ);\n+                  end if;\n+\n                   Check_Private_Overriding (B_Typ);\n \n                   --  The Ghost policy in effect at the point of declaration"}, {"sha": "f30a9aa396c2e92f1a7c7291f15aecae3d60f0af", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "patch": "@@ -2612,6 +2612,15 @@ package body Sem_Ch7 is\n \n       elsif Abstract_Present (Def) then\n          Error_Msg_N (\"only a tagged type can be abstract\", N);\n+\n+      --  When extensions are enabled, we initialize the primitive operations\n+      --  list of an untagged private type to an empty element list. (Note:\n+      --  This could be done for all private types and shared with the tagged\n+      --  case above, but for now we do it separately when the feature of\n+      --  prefixed calls for untagged types is enabled.)\n+\n+      elsif Extensions_Allowed then\n+         Set_Direct_Primitive_Operations (Id, New_Elmt_List);\n       end if;\n    end New_Private_Type;\n "}, {"sha": "d3bbfebd0e7db7ff7d5964201331ae2dade85d3c", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=2e1f3a5e3e76aa1149b9061304a4ef0ea40483b3", "patch": "@@ -7588,10 +7588,16 @@ package body Sem_Ch8 is\n             P_Type := Implicitly_Designated_Type (P_Type);\n          end if;\n \n-         --  First check for components of a record object (not the\n-         --  result of a call, which is handled below).\n-\n-         if Has_Components (P_Type)\n+         --  First check for components of a record object (not the result of\n+         --  a call, which is handled below). This also covers the case where\n+         --  where the extension feature that supports the prefixed form of\n+         --  calls for primitives of untagged types is enabled (excluding\n+         --  concurrent cases, which are handled further below).\n+\n+         if Is_Type (P_Type)\n+           and then (Has_Components (P_Type)\n+                      or else (Extensions_Allowed\n+                                and then not Is_Concurrent_Type (P_Type)))\n            and then not Is_Overloadable (P_Name)\n            and then not Is_Type (P_Name)\n          then"}]}