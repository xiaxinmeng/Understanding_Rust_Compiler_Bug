{"sha": "c47decad97eca23beacfc3a58006b86ef747fe66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ3ZGVjYWQ5N2VjYTIzYmVhY2ZjM2E1ODAwNmI4NmVmNzQ3ZmU2Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-01-07T07:59:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-01-07T07:59:42Z"}, "message": "pa.h (enum processor_type): New enumeration describing the processor to schedule for (700, 7100, 7100LC).\n\n\t* pa.h (enum processor_type): New enumeration describing the\n\tprocessor to schedule for (700, 7100, 7100LC).\n\t(pa_cpu_attr, TARGET_OPTIONS, OVERRIDE_OPTIONS): Define.\n\t(pa_cpu_string, pa_cpu): Provide extern decls.\n\t* pa.c (pa_cpu, pa_cpu_string): Provide definitions.\n\t(override_options): New function.\n\t(pa_adjust_cost): Handle PROCESSOR_7100 and PROCESSOR_7100LC\n\tscheduling.  Handle anti-dependendy cases involving fp division\n\tand sqrt.  Handle output dependencies correctly.  Break TYPE_FPMUL\n\tinto TYPE_FPMULSGL and TYPE_FPMULDBL.\n\t* pa.md (cpu attribute): New attribute.\n\tClean up comments for PROCESSOR_700 scheduling info.  Slightly\n\tsimplify.  Make conditional on PROCESSOR_700.\n\tAdd comments and scheduling information for PROCESSOR_7100 and\n\tPROCESSOR_7100LC.  Set types for instructions which use the shifter\n\tto \"shift\".  Explicitly set lengths and types for all instructions.\n\tBreak type \"fpmul\" into \"fmulsgl\" and \"fpmuldbl\".\n\nFrom-SVN: r8723", "tree": {"sha": "438449607691411bc40eb5b7c75d60a5a2ceab5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/438449607691411bc40eb5b7c75d60a5a2ceab5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c47decad97eca23beacfc3a58006b86ef747fe66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47decad97eca23beacfc3a58006b86ef747fe66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c47decad97eca23beacfc3a58006b86ef747fe66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47decad97eca23beacfc3a58006b86ef747fe66/comments", "author": null, "committer": null, "parents": [{"sha": "c1fe41cbd37fca7d9079cc7fce669c68ac294c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fe41cbd37fca7d9079cc7fce669c68ac294c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1fe41cbd37fca7d9079cc7fce669c68ac294c99"}], "stats": {"total": 680, "additions": 552, "deletions": 128}, "files": [{"sha": "2d2eb12ad1be68ac9b5abb1ba2fa13b2d58c9780", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 161, "deletions": 9, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47decad97eca23beacfc3a58006b86ef747fe66/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47decad97eca23beacfc3a58006b86ef747fe66/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=c47decad97eca23beacfc3a58006b86ef747fe66", "patch": "@@ -41,6 +41,12 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n rtx hppa_compare_op0, hppa_compare_op1;\n enum cmp_type hppa_branch_type;\n \n+/* Which cpu we are scheduling for.  */\n+enum processor_type pa_cpu;\n+\n+/* String to hold which cpu we are scheduling for.  */\n+char *pa_cpu_string;\n+\n rtx hppa_save_pic_table_rtx;\n \n /* Set by the FUNCTION_PROFILER macro. */\n@@ -57,6 +63,34 @@ static rtx find_addr_reg ();\n \n unsigned int total_code_bytes;\n \n+void\n+override_options ()\n+{\n+  /* Default to 700 scheduling which is reasonable for older 800 processors\n+     correct for the 700s, and not too bad for the 7100s and 7100LCs.  */\n+  if (pa_cpu_string == NULL\n+      || ! strcmp (pa_cpu_string, \"700\"))\n+    {\n+      pa_cpu_string = \"700\";\n+      pa_cpu = PROCESSOR_700;\n+    }\n+  else if (! strcmp (pa_cpu_string, \"7100\"))\n+    {\n+      pa_cpu_string = \"7100\";\n+      pa_cpu = PROCESSOR_7100;\n+    }\n+  else if (! strncmp (pa_cpu_string, \"7100LC\"))\n+    {\n+      pa_cpu_string = \"7100LC\";\n+      pa_cpu = PROCESSOR_7100LC;\n+    }\n+  else\n+    {\n+      warning (\"Unknown -mschedule= option (%s).\\nValid options are 700, 7100 and 7100LC\\n\", pa_cpu_string);\n+    }\n+}\n+\n+\n /* Return non-zero only if OP is a register of mode MODE,\n    or CONST0_RTX.  */\n int\n@@ -2498,18 +2532,20 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t      switch (get_attr_type (dep_insn))\n \t\t{\n \t\tcase TYPE_FPLOAD:\n-\t\t  /* This cost 3 cycles, not 2 as the md says.  */\n-\t\t  return cost + 1;\n+\t\t  /* This cost 3 cycles, not 2 as the md says for the\n+\t\t     700 and 7100.  Note scaling of cost for 7100.  */\n+\t\t  return cost + (pa_cpu_attr == PROCESSOR_700) ? 1 : 2;\n \n \t\tcase TYPE_FPALU:\n-\t\tcase TYPE_FPMUL:\n+\t\tcase TYPE_FPMULSGL:\n+\t\tcase TYPE_FPMULDBL:\n \t\tcase TYPE_FPDIVSGL:\n \t\tcase TYPE_FPDIVDBL:\n \t\tcase TYPE_FPSQRTSGL:\n \t\tcase TYPE_FPSQRTDBL:\n \t\t  /* In these important cases, we save one cycle compared to\n \t\t     when flop instruction feed each other.  */\n-\t\t  return cost - 1;\n+\t\t  return cost - (pa_cpu_attr == PROCESSOR_700) ? 1 : 2;\n \n \t\tdefault:\n \t\t  return cost;\n@@ -2547,16 +2583,52 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t      switch (get_attr_type (dep_insn))\n \t\t{\n \t\tcase TYPE_FPALU:\n-\t\tcase TYPE_FPMUL:\n+\t\tcase TYPE_FPMULSGL:\n+\t\tcase TYPE_FPMULDBL:\n \t\tcase TYPE_FPDIVSGL:\n \t\tcase TYPE_FPDIVDBL:\n \t\tcase TYPE_FPSQRTSGL:\n \t\tcase TYPE_FPSQRTDBL:\n \t\t  /* A fpload can't be issued until one cycle before a\n-\t\t     preceeding arithmetic operation has finished, if\n+\t\t     preceeding arithmetic operation has finished if\n \t\t     the target of the fpload is any of the sources\n \t\t     (or destination) of the arithmetic operation.  */\n-\t\t  return cost - 1;\n+\t\t  return cost - (pa_cpu_attr == PROCESSOR_700) ? 1 : 2;\n+\n+\t\tdefault:\n+\t\t  return 0;\n+\t\t}\n+\t    }\n+\t}\n+      else if (get_attr_type (insn) == TYPE_FPALU)\n+\t{\n+\t  rtx pat = PATTERN (insn);\n+\t  rtx dep_pat = PATTERN (dep_insn);\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      /* This happens for the fldXs,mb patterns.  */\n+\t      pat = XVECEXP (pat, 0, 0);\n+\t    }\n+\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n+\t    /* If this happens, we have to extend this to schedule\n+\t       optimally.  Return 0 for now.  */\n+\t  return 0;\n+\n+\t  if (reg_mentioned_p (SET_DEST (pat), SET_SRC (dep_pat)))\n+\t    {\n+\t      if (! recog_memoized (dep_insn))\n+\t\treturn 0;\n+\t      switch (get_attr_type (dep_insn))\n+\t\t{\n+\t\tcase TYPE_FPDIVSGL:\n+\t\tcase TYPE_FPDIVDBL:\n+\t\tcase TYPE_FPSQRTSGL:\n+\t\tcase TYPE_FPSQRTDBL:\n+\t\t  /* An ALU flop can't be issued until two cycles before a\n+\t\t     preceeding divide or sqrt operation has finished if\n+\t\t     the target of the ALU flop is any of the sources\n+\t\t     (or destination) of the divide or sqrt operation.  */\n+\t\t  return cost - (pa_cpu_attr == PROCESSOR_700) ? 2 : 4;\n \n \t\tdefault:\n \t\t  return 0;\n@@ -2567,9 +2639,89 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n       /* For other anti dependencies, the cost is 0.  */\n       return 0;\n     }\n+  else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n+    {\n+      /* Output dependency; DEP_INSN writes a register that INSN writes some\n+\t cycles later.  */\n+      if (get_attr_type (insn) == TYPE_FPLOAD)\n+\t{\n+\t  rtx pat = PATTERN (insn);\n+\t  rtx dep_pat = PATTERN (dep_insn);\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      /* This happens for the fldXs,mb patterns.  */\n+\t      pat = XVECEXP (pat, 0, 0);\n+\t    }\n+\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n+\t    /* If this happens, we have to extend this to schedule\n+\t       optimally.  Return 0 for now.  */\n+\t  return 0;\n+\n+\t  if (reg_mentioned_p (SET_DEST (pat), SET_DEST (dep_pat)))\n+\t    {\n+\t      if (! recog_memoized (dep_insn))\n+\t\treturn 0;\n+\t      switch (get_attr_type (dep_insn))\n+\t\t{\n+\t\tcase TYPE_FPALU:\n+\t\tcase TYPE_FPMULSGL:\n+\t\tcase TYPE_FPMULDBL:\n+\t\tcase TYPE_FPDIVSGL:\n+\t\tcase TYPE_FPDIVDBL:\n+\t\tcase TYPE_FPSQRTSGL:\n+\t\tcase TYPE_FPSQRTDBL:\n+\t\t  /* A fpload can't be issued until one cycle before a\n+\t\t     preceeding arithmetic operation has finished if\n+\t\t     the target of the fpload is the destination of the\n+\t\t     arithmetic operation.  */\n+\t\t  return cost - (pa_cpu_attr == PROCESSOR_700) ? 1 : 2;\n \n-  /* For output dependencies, the cost is often one too high.  */\n-  return cost - 1;\n+\t\tdefault:\n+\t\t  return 0;\n+\t\t}\n+\t    }\n+\t}\n+      else if (get_attr_type (insn) == TYPE_FPALU)\n+\t{\n+\t  rtx pat = PATTERN (insn);\n+\t  rtx dep_pat = PATTERN (dep_insn);\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      /* This happens for the fldXs,mb patterns.  */\n+\t      pat = XVECEXP (pat, 0, 0);\n+\t    }\n+\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n+\t    /* If this happens, we have to extend this to schedule\n+\t       optimally.  Return 0 for now.  */\n+\t  return 0;\n+\n+\t  if (reg_mentioned_p (SET_DEST (pat), SET_DEST (dep_pat)))\n+\t    {\n+\t      if (! recog_memoized (dep_insn))\n+\t\treturn 0;\n+\t      switch (get_attr_type (dep_insn))\n+\t\t{\n+\t\tcase TYPE_FPDIVSGL:\n+\t\tcase TYPE_FPDIVDBL:\n+\t\tcase TYPE_FPSQRTSGL:\n+\t\tcase TYPE_FPSQRTDBL:\n+\t\t  /* An ALU flop can't be issued until two cycles before a\n+\t\t     preceeding divide or sqrt operation has finished if\n+\t\t     the target of the ALU flop is also the target of\n+\t\t     of the divide or sqrt operation.  */\n+\t\t  return cost - (pa_cpu_attr == PROCESSOR_700) ? 2 : 4;\n+\n+\t\tdefault:\n+\t\t  return 0;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* For other output dependencies, the cost is 0.  */\n+      return 0;\n+    }\n+  else\n+    abort ();\n }\n \n /* Return any length adjustment needed by INSN which already has its length"}, {"sha": "9b414c25b4d4969b8b16d5df633d74d24e651e4f", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47decad97eca23beacfc3a58006b86ef747fe66/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47decad97eca23beacfc3a58006b86ef747fe66/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=c47decad97eca23beacfc3a58006b86ef747fe66", "patch": "@@ -31,6 +31,21 @@ enum cmp_type\t\t\t\t/* comparison type */\n /* For long call handling.  */\n extern unsigned int total_code_bytes;\n \n+/* Which processor to schedule for.  */\n+\n+enum processor_type\n+{\n+  PROCESSOR_700,\n+  PROCESSOR_7100,\n+  PROCESSOR_7100LC,\n+};\n+\n+#define pa_cpu_attr ((enum attr_cpu)pa_cpu)\n+\n+/* For -mschedule= option.  */\n+extern char *pa_cpu_string;\n+extern enum processor_type pa_cpu;\n+\n /* Print subsidiary information on the compiler version in use.  */\n \n #define TARGET_VERSION fprintf (stderr, \" (hppa)\");\n@@ -123,6 +138,13 @@ extern int target_flags;\n #define TARGET_DEFAULT 0x88\t\t/* TARGET_GAS + TARGET_JUMP_IN_DELAY */\n #endif\n \n+#define TARGET_OPTIONS\t\t\t\\\n+{\t\t\t\t\t\\\n+  { \"schedule=\",\t&pa_cpu_string }\\\n+}\n+\n+#define OVERRIDE_OPTIONS override_options ()\n+\n #define DBX_DEBUGGING_INFO\n #define DEFAULT_GDB_EXTENSIONS 1\n "}, {"sha": "1af759779a22fc6009849dd8c0bfbf32b9c36a3c", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 369, "deletions": 119, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47decad97eca23beacfc3a58006b86ef747fe66/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47decad97eca23beacfc3a58006b86ef747fe66/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=c47decad97eca23beacfc3a58006b86ef747fe66", "patch": "@@ -30,9 +30,16 @@\n ;; type \"binary\" insns have two input operands (1,2) and one output (0)\n \n (define_attr \"type\"\n-  \"move,unary,binary,compare,load,store,uncond_branch,branch,cbranch,fbranch,call,dyncall,fpload,fpstore,fpalu,fpcc,fpmul,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,misc,milli\"\n+  \"move,unary,binary,shift,nullshift,compare,load,store,uncond_branch,branch,cbranch,fbranch,call,dyncall,fpload,fpstore,fpalu,fpcc,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,milli\"\n   (const_string \"binary\"))\n \n+;; Processor type (for scheduling, not code generation) -- this attribute\n+;; must exactly match the processor_type enumeration in pa.h.\n+;;\n+;; FIXME: Add 800 scheduling for completeness?\n+\n+(define_attr \"cpu\" \"700,7100,7100LC\" (const (symbol_ref \"pa_cpu_attr\")))\n+\n ;; Length (in # of insns).\n (define_attr \"length\" \"\"\n   (cond [(eq_attr \"type\" \"load,fpload\")\n@@ -43,11 +50,11 @@\n \t (if_then_else (match_operand 0 \"symbolic_memory_operand\" \"\")\n \t\t       (const_int 8) (const_int 4))\n \n-\t (eq_attr \"type\" \"binary\")\n+\t (eq_attr \"type\" \"binary,shift,nullshift\")\n \t (if_then_else (match_operand 2 \"arith_operand\" \"\")\n \t\t       (const_int 4) (const_int 12))\n \n-\t (eq_attr \"type\" \"move,unary\")\n+\t (eq_attr \"type\" \"move,unary,shift,nullshift\")\n \t (if_then_else (match_operand 1 \"arith_operand\" \"\")\n \t\t       (const_int 4) (const_int 8))]\n \n@@ -69,7 +76,7 @@\n ;; Disallow instructions which use the FPU since they will tie up the FPU\n ;; even if the instruction is nullified.\n (define_attr \"in_nullified_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,fpcc,fpalu,fpmul,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli,fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl\")\n \t\t     (eq_attr \"length\" \"4\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n@@ -122,8 +129,8 @@\n    (and (eq_attr \"in_nullified_branch_delay\" \"true\")\n \t(attr_flag \"backward\"))])\n \n-;; Function units of the HPPA. The following data is for the \"Snake\"\n-;; (Mustang CPU + Timex FPU) because that's what I have the docs for.\n+;; Function units of the HPPA. The following data is for the 700 CPUs\n+;; (Mustang CPU + Timex FPU aka PA-89) because that's what I have the docs for.\n ;; Scheduling instructions for PA-83 machines according to the Snake\n ;; constraints shouldn't hurt.\n \n@@ -135,19 +142,23 @@\n ;; be specified.)\n \n ;; (define_function_unit \"alu\" 1 0\n-;;  (eq_attr \"type\" \"unary,binary,move,address\") 1 0)\n+;;  (and (eq_attr \"type\" \"unary,shift,nullshift,binary,move,address\")\n+;;\t (eq_attr \"cpu\" \"700\"))\n+;;  1 0)\n \n \n ;; Memory. Disregarding Cache misses, the Mustang memory times are:\n-;; load: 2\n+;; load: 2, fpload: 3\n ;; store, fpstore: 3, no D-cache operations should be scheduled.\n-;; fpload: 3 (really 2 for flops, but I don't think we can specify that).\n \n-(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load\") 2 0)\n-(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"store,fpstore\") 3 3)\n-(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"fpload\") 2 0)\n+(define_function_unit \"pa700memory\" 1 0\n+  (and (eq_attr \"type\" \"load,fpload\")\n+       (eq_attr \"cpu\" \"700\")) 2 0)\n+(define_function_unit \"pa700memory\" 1 0 \n+  (and (eq_attr \"type\" \"store,fpstore\")\n+       (eq_attr \"cpu\" \"700\")) 3 3)\n \n-;; The Timex has two floating-point units: ALU, and MUL/DIV/SQRT unit.\n+;; The Timex (aka 700) has two floating-point units: ALU, and MUL/DIV/SQRT.\n ;; Timings:\n ;; Instruction\tTime\tUnit\tMinimum Distance (unit contention)\n ;; fcpy\t\t3\tALU\t2\n@@ -166,13 +177,160 @@\n ;; fsqrt,sgl\t14\tMPY\t14\n ;; fsqrt,dbl\t18\tMPY\t18\n \n-(define_function_unit \"fp_alu\" 1 0 (eq_attr \"type\" \"fpcc\") 4 2)\n-(define_function_unit \"fp_alu\" 1 0 (eq_attr \"type\" \"fpalu\") 3 2)\n-(define_function_unit \"fp_mpy\" 1 0 (eq_attr \"type\" \"fpmul\") 3 2)\n-(define_function_unit \"fp_mpy\" 1 0 (eq_attr \"type\" \"fpdivsgl\") 10 10)\n-(define_function_unit \"fp_mpy\" 1 0 (eq_attr \"type\" \"fpdivdbl\") 12 12)\n-(define_function_unit \"fp_mpy\" 1 0 (eq_attr \"type\" \"fpsqrtsgl\") 14 14)\n-(define_function_unit \"fp_mpy\" 1 0 (eq_attr \"type\" \"fpsqrtdbl\") 18 18)\n+(define_function_unit \"pa700fp_alu\" 1 0\n+  (and (eq_attr \"type\" \"fpcc\")\n+       (eq_attr \"cpu\" \"700\")) 4 2)\n+(define_function_unit \"pa700fp_alu\" 1 0\n+  (and (eq_attr \"type\" \"fpalu\")\n+       (eq_attr \"cpu\" \"700\")) 3 2)\n+(define_function_unit \"pa700fp_mpy\" 1 0\n+  (and (eq_attr \"type\" \"fpmulsgl,fpmuldbl\")\n+       (eq_attr \"cpu\" \"700\")) 3 2)\n+(define_function_unit \"pa700fp_mpy\" 1 0\n+  (and (eq_attr \"type\" \"fpdivsgl\")\n+       (eq_attr \"cpu\" \"700\")) 10 10)\n+(define_function_unit \"pa700fp_mpy\" 1 0\n+  (and (eq_attr \"type\" \"fpdivdbl\")\n+       (eq_attr \"cpu\" \"700\")) 12 12)\n+(define_function_unit \"pa700fp_mpy\" 1 0\n+  (and (eq_attr \"type\" \"fpsqrtsgl\")\n+       (eq_attr \"cpu\" \"700\")) 14 14)\n+(define_function_unit \"pa700fp_mpy\" 1 0\n+  (and (eq_attr \"type\" \"fpsqrtdbl\")\n+       (eq_attr \"cpu\" \"700\")) 18 18)\n+\n+;; Function units for the 7100 and 7150.  The 7100/7150 can dual-issue\n+;; floating point computations with non-floating point computations (fp loads\n+;; and stores are not fp computations).\n+;;\n+;; As with the alpha we multiply the ready delay by two to encourage\n+;; schedules which will allow the 7100/7150 to dual issue as many instructions\n+;; as possible.\n+\n+;; Memory. Disregarding Cache misses, memory loads take two cycles; stores also\n+;; take two cycles, during which no Dcache operations should be scheduled.\n+;; Any special cases are handled in pa_adjust_cost.  The 7100, 7150 and 7100LC\n+;; all have the same memory characteristics if one disregards cache misses.\n+(define_function_unit \"pa7100memory\" 1 0\n+  (and (eq_attr \"type\" \"load,fpload\")\n+       (eq_attr \"cpu\" \"7100,7100LC\")) 4 0)\n+(define_function_unit \"pa7100memory\" 1 0 \n+  (and (eq_attr \"type\" \"store,fpstore\")\n+       (eq_attr \"cpu\" \"7100,7100LC\")) 4 4)\n+\n+;; The 7100/7150 has three floating-point units: ALU, MUL, and DIV.\n+;; Timings:\n+;; Instruction\tTime\tUnit\tMinimum Distance (unit contention)\n+;; fcpy\t\t2\tALU\t1\n+;; fabs\t\t2\tALU\t1\n+;; fadd\t\t2\tALU\t1\n+;; fsub\t\t2\tALU\t1\n+;; fcmp\t\t2\tALU\t1\n+;; fcnv\t\t2\tALU\t1\n+;; fmpyadd\t2\tALU,MPY\t1\n+;; fmpysub\t2\tALU,MPY 1\n+;; fmpycfxt\t2\tALU,MPY 1\n+;; fmpy\t\t2\tMPY\t1\n+;; fmpyi\t2\tMPY\t1\n+;; fdiv,sgl\t8\tDIV\t8\n+;; fdiv,dbl\t15\tDIV\t15\n+;; fsqrt,sgl\t8\tDIV\t8\n+;; fsqrt,dbl\t15\tDIV\t15\n+\n+(define_function_unit \"pa7100fp_alu\" 1 0\n+  (and (eq_attr \"type\" \"fpcc,fpalu\")\n+       (eq_attr \"cpu\" \"7100\")) 4 2)\n+(define_function_unit \"pa7100fp_mpy\" 1 0\n+  (and (eq_attr \"type\" \"fpmulsgl,fpmuldbl\")\n+       (eq_attr \"cpu\" \"7100\")) 4 2)\n+(define_function_unit \"pa7100fp_div\" 1 0\n+  (and (eq_attr \"type\" \"fpdivsgl,fpsqrtsgl\")\n+       (eq_attr \"cpu\" \"7100\")) 16 16)\n+(define_function_unit \"pa7100fp_div\" 1 0\n+  (and (eq_attr \"type\" \"fpdivdbl,fpsqrtdbl\")\n+       (eq_attr \"cpu\" \"7100\")) 30 30)\n+\n+;; To encourage dual issue we define function units corresponding to\n+;; the instructions which can be dual issued.    This is a rather crude\n+;; approximation, the \"pa7100nonflop\" test in particular could be refined.\n+(define_function_unit \"pa7100flop\" 1 1\n+  (and\n+    (eq_attr \"type\" \"fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl\")\n+    (eq_attr \"cpu\" \"7100,7100LC\")) 2 2)\n+\n+(define_function_unit \"pa7100nonflop\" 1 1\n+  (and\n+    (eq_attr \"type\" \"!fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl\")\n+    (eq_attr \"cpu\" \"7100\")) 2 2)\n+\n+\n+;; Memory subsystem works just like 7100/7150 (except for cache miss times which\n+;; we don't model here).  \n+\n+;; The 7100LC has three floating-point units: ALU, MUL, and DIV.\n+;; Note divides and sqrt flops lock the cpu until the flop is\n+;; finished.  fmpy and xmpyu (fmpyi) lock the cpu for one cycle.\n+;; There's no way to avoid the penalty.\n+;; Timings:\n+;; Instruction\tTime\tUnit\tMinimum Distance (unit contention)\n+;; fcpy\t\t2\tALU\t1\n+;; fabs\t\t2\tALU\t1\n+;; fadd\t\t2\tALU\t1\n+;; fsub\t\t2\tALU\t1\n+;; fcmp\t\t2\tALU\t1\n+;; fcnv\t\t2\tALU\t1\n+;; fmpyadd,sgl\t2\tALU,MPY\t1\n+;; fmpyadd,dbl\t3\tALU,MPY\t2\n+;; fmpysub,sgl\t2\tALU,MPY 1\n+;; fmpysub,dbl\t3\tALU,MPY 2\n+;; fmpycfxt,sgl\t2\tALU,MPY 1\n+;; fmpycfxt,dbl\t3\tALU,MPY 2\n+;; fmpy,sgl\t2\tMPY\t1\n+;; fmpy,dbl\t3\tMPY\t2\n+;; fmpyi\t3\tMPY\t2\n+;; fdiv,sgl\t8\tDIV\t8\n+;; fdiv,dbl\t15\tDIV\t15\n+;; fsqrt,sgl\t8\tDIV\t8\n+;; fsqrt,dbl\t15\tDIV\t15\n+\n+(define_function_unit \"pa7100LCfp_alu\" 1 0\n+  (and (eq_attr \"type\" \"fpcc,fpalu\")\n+       (eq_attr \"cpu\" \"7100LC\")) 4 2)\n+(define_function_unit \"pa7100LCfp_mpy\" 1 0\n+  (and (eq_attr \"type\" \"fpmulsgl\")\n+       (eq_attr \"cpu\" \"7100LC\")) 4 2)\n+(define_function_unit \"pa7100LCfp_mpy\" 1 0\n+  (and (eq_attr \"type\" \"fpmuldbl\")\n+       (eq_attr \"cpu\" \"7100LC\")) 6 4)\n+(define_function_unit \"pa7100LCfp_div\" 1 0\n+  (and (eq_attr \"type\" \"fpdivsgl,fpsqrtsgl\")\n+       (eq_attr \"cpu\" \"7100LC\")) 16 16)\n+(define_function_unit \"pa7100LCfp_div\" 1 0\n+  (and (eq_attr \"type\" \"fpdivdbl,fpsqrtdbl\")\n+       (eq_attr \"cpu\" \"7100LC\")) 30 30)\n+\n+;; Define the various functional units for dual-issue.\n+;; The 7100LC shares the generic \"flop\" unit specification with the 7100/7150.\n+\n+;; The 7100LC has two basic integer which allow dual issue of most integer\n+;; instructions.  This needs further refinement to deal with the nullify,\n+;; carry/borrow possible the ldw/ldw stw/stw special dual issue cases, and\n+;; of course it needs to know about hte 2nd alu.\n+(define_function_unit \"pa7100LCnonflop\" 1 1\n+  (and\n+    (eq_attr \"type\" \"!fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpsqrtsgl,fpdivdbl,fpsqrtdbl,load,fpload,store,fpstore,shift,nullshift\")\n+    (eq_attr \"cpu\" \"7100LC\")) 2 2)\n+\n+(define_function_unit \"pa7100LCshifter\" 1 1\n+  (and\n+    (eq_attr \"type\" \"shift,nullshift\")\n+    (eq_attr \"cpu\" \"7100LC\")) 2 2)\n+\n+(define_function_unit \"pa7100LCmem\" 1 1\n+  (and\n+    (eq_attr \"type\" \"load,fpload,store,fpstore\")\n+    (eq_attr \"cpu\" \"7100LC\")) 2 2)\n+\n \f\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation.\n@@ -228,7 +386,8 @@\n \t\t\t      (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")]))]\n   \"\"\n   \"fcmp,sgl,%Y2 %r0,%r1\"\n-  [(set_attr \"type\" \"fpcc\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"fpcc\")])\n \n (define_insn \"\"\n   [(set (reg:CCFP 0)\n@@ -237,7 +396,8 @@\n \t\t\t      (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")]))]\n   \"\"\n   \"fcmp,dbl,%Y2 %r0,%r1\"\n-  [(set_attr \"type\" \"fpcc\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"fpcc\")])\n \n ;; scc insns.\n \n@@ -403,7 +563,7 @@\n   \"\"\n   \"com%I2clr,%S3 %2,%1,0\\;com%I5clr,%B6 %5,%4,%0\\;ldi 1,%0\"\n   [(set_attr \"type\" \"binary\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"length\" \"12\")])\n \n ;; Combiner patterns for common operations performed with the output\n ;; from an scc insn (negscc and incscc).\n@@ -619,7 +779,7 @@\n    com%I4clr,%B5 %4,%3,%0\\;ldi %1,%0\n    com%I4clr,%B5 %4,%3,%0\\;ldil L'%1,%0\n    com%I4clr,%B5 %4,%3,%0\\;zdepi %Z1,%0\"\n-  [(set_attr \"type\" \"multi,multi,multi,multi,multi\")\n+  [(set_attr \"type\" \"multi,multi,multi,multi,nullshift\")\n    (set_attr \"length\" \"8,8,8,8,8\")])\n \n (define_insn \"\"\n@@ -640,7 +800,7 @@\n    com%I4clr,%B5 %4,%3,0\\;ldi %1,%0\n    com%I4clr,%B5 %4,%3,0\\;ldil L'%1,%0\n    com%I4clr,%B5 %4,%3,0\\;zdepi %Z1,%0\"\n-  [(set_attr \"type\" \"multi,multi,multi,multi,multi,multi,multi,multi\")\n+  [(set_attr \"type\" \"multi,multi,multi,nullshift,multi,multi,multi,nullshift\")\n    (set_attr \"length\" \"8,8,8,8,8,8,8,8\")])\n \n ;; Conditional Branches\n@@ -1014,7 +1174,7 @@\n    fcpy,sgl %r1,%0\n    fldws%F1 %1,%0\n    fstws%F0 %1,%0\"\n-  [(set_attr \"type\" \"move,move,move,move,load,store,move,fpalu,fpload,fpstore\")\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu,fpload,fpstore\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4\")])\n \n ;; Load indexed.  We don't use unscaled modes since they can't be used\n@@ -1039,7 +1199,7 @@\n ;; has constraints allowing a register.  I don't know how this works,\n ;; but it somehow makes sure that out-of-range constants are placed\n ;; in a register which somehow magically is a \"const_int_operand\".\n-;; (this was stolen from alpha.md, I'm not going to try and change it.\n+;; (this was stolen from alpha.md, I'm not going to try and change it.)\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"&=r\")\n \t(mem:SI (plus:SI (plus:SI\n@@ -1190,7 +1350,9 @@\n   if (flag_pic != 2)\n     abort ();\n   return \\\"ldw RT'%G2(%1),%0\\\";\n-}\")\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n \n \n ;; Always use addil rather than ldil;add sequences.  This allows the\n@@ -1263,7 +1425,8 @@\n \t\t   (match_operand:SI 2 \"function_label_operand\" \"\")))]\n   \"!TARGET_PORTABLE_RUNTIME\"\n   \"ldo RP'%G2(%1),%0\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")])\n \n ;; This version is used only for the portable runtime conventions model\n ;; (it does not use/support plabels)\n@@ -1273,7 +1436,8 @@\n \t\t   (match_operand:SI 2 \"function_label_operand\" \"\")))]\n   \"TARGET_PORTABLE_RUNTIME\"\n   \"ldo R'%G2(%1),%0\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1287,7 +1451,8 @@\n   else\n     return \\\"ldo R'%G2(%1),%0\\\";\n }\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")])\n \n ;; Now that a symbolic_address plus a constant is broken up early\n ;; in the compilation phase (for better CSE) we need a special\n@@ -1327,7 +1492,7 @@\n    sth%M0 %r1,%0\n    mtsar %r1\n    fcpy,sgl %r1,%0\"\n-  [(set_attr \"type\" \"move,move,move,move,load,store,move,fpalu\")\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n@@ -1402,7 +1567,8 @@\n \t\t   (match_operand 2 \"const_int_operand\" \"\")))]\n   \"\"\n   \"ldo R'%G2(%1),%0\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")])\n \n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n@@ -1428,7 +1594,7 @@\n    stb%M0 %r1,%0\n    mtsar %r1\n    fcpy,sgl %r1,%0\"\n-  [(set_attr \"type\" \"move,move,move,move,load,store,move,fpalu\")\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n@@ -1755,7 +1921,7 @@\n     return output_fp_move_double (operands);\n   return output_move_double (operands);\n }\"\n-  [(set_attr \"type\" \"move,store,store,load,load,misc,fpalu,fpload,fpstore\")\n+  [(set_attr \"type\" \"move,store,store,load,load,multi,fpalu,fpload,fpstore\")\n    (set_attr \"length\" \"8,8,16,8,16,16,4,4,4\")])\n \n (define_insn \"\"\n@@ -1773,9 +1939,8 @@\n     output_asm_insn (\\\"copy %1,%0\\\", operands);\n   return \\\"ldo R'%G2(%R1),%R0\\\";\n }\"\n-  ;; Need to set length for this arith insn because operand2\n-  ;; is not an \"arith_operand\".\n-  [(set_attr \"length\" \"4,8\")])\n+  [(set_attr \"type\" \"move,move\")\n+   (set_attr \"length\" \"4,8\")])\n \n ;; This pattern forces (set (reg:SF ...) (const_double ...))\n ;; to be reloaded by putting the constant into memory when\n@@ -1944,7 +2109,8 @@\n   \"@\n    extru %1,31,16,%0\n    ldh%M1 %1,%0\"\n-  [(set_attr \"type\" \"unary,load\")])\n+  [(set_attr \"type\" \"shift,load\")\n+   (set_attr \"length\" \"4,4\")])\n \n (define_insn \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n@@ -1954,7 +2120,8 @@\n   \"@\n    extru %1,31,8,%0\n    ldb%M1 %1,%0\"\n-  [(set_attr \"type\" \"unary,load\")])\n+  [(set_attr \"type\" \"shift,load\")\n+   (set_attr \"length\" \"4,4\")])\n \n (define_insn \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -1964,7 +2131,8 @@\n   \"@\n    extru %1,31,8,%0\n    ldb%M1 %1,%0\"\n-  [(set_attr \"type\" \"unary,load\")])\n+  [(set_attr \"type\" \"shift,load\")\n+   (set_attr \"length\" \"4,4\")])\n \n ;;- sign extension instructions\n \n@@ -1973,21 +2141,24 @@\n \t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"extrs %1,31,16,%0\"\n-  [(set_attr \"type\" \"unary\")])\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"extrs %1,31,8,%0\"\n-  [(set_attr \"type\" \"unary\")])\n+  [(set_attr \"type\" \"shift\") \n+  (set_attr \"length\" \"4\")])\n \n (define_insn \"extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"extrs %1,31,8,%0\"\n-  [(set_attr \"type\" \"unary\")])\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \f\n ;; Conversions between float and double.\n \n@@ -1997,15 +2168,17 @@\n \t (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcnvff,sgl,dbl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(float_truncate:SF\n \t (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcnvff,dbl,sgl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n ;; Conversion between fixed point and floating point.\n ;; Note that among the fix-to-float insns\n@@ -2031,7 +2204,8 @@\n \t(float:SF (match_operand:SI 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcnvxf,sgl,sgl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n ;; This pattern forces (set (reg:DF ...) (float:DF (const_int ...)))\n ;; to be reloaded by putting the constant into memory.\n@@ -2049,7 +2223,8 @@\n \t(float:DF (match_operand:SI 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fcnvxf,sgl,dbl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_expand \"floatunssisf2\"\n   [(set (subreg:SI (match_dup 2) 1)\n@@ -2076,14 +2251,16 @@\n \t(float:SF (match_operand:DI 1 \"register_operand\" \"f\")))]\n   \"TARGET_SNAKE\"\n   \"fcnvxf,dbl,sgl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"floatdidf2\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n \t(float:DF (match_operand:DI 1 \"register_operand\" \"f\")))]\n   \"TARGET_SNAKE\"\n   \"fcnvxf,dbl,dbl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n ;; Convert a float to an actual integer.\n ;; Truncation is performed as part of the conversion.\n@@ -2093,28 +2270,32 @@\n \t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n   \"\"\n   \"fcnvfxt,sgl,sgl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"fix_truncdfsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n   \"\"\n   \"fcnvfxt,dbl,sgl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"fix_truncsfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n   \"TARGET_SNAKE\"\n   \"fcnvfxt,sgl,dbl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"fix_truncdfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n   \"TARGET_SNAKE\"\n   \"fcnvfxt,dbl,dbl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \f\n ;;- arithmetic instructions\n \n@@ -2135,14 +2316,17 @@\n   else\n     return \\\"add %R2,%R1,%R0\\;addc %2,%1,%0\\\";\n }\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(plus:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"uaddcm %2,%1,%0\")\n+  \"uaddcm %2,%1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n \n ;; define_splits to optimize cases of adding a constant integer\n ;; to a register when the constant does not fit in 14 bits.  */\n@@ -2207,15 +2391,18 @@\n   \"\"\n   \"@\n    addl %1,%2,%0\n-   ldo %2(%1),%0\")\n+   ldo %2(%1),%0\"\n+  [(set_attr \"type\" \"binary,binary\")\n+   (set_attr \"length\" \"4,4\")])\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t  (match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"sub %R1,%R2,%R0\\;subb %1,%2,%0\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"binary\")\n+  (set_attr \"length\" \"8\")])\n \n (define_insn \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -2224,7 +2411,9 @@\n   \"\"\n   \"@\n    sub %1,%2,%0\n-   subi %1,%2,%0\")\n+   subi %1,%2,%0\"\n+  [(set_attr \"type\" \"binary,binary\")\n+   (set_attr \"length\" \"4,4\")])\n \n ;; Clobbering a \"register_operand\" instead of a match_scratch\n ;; in operand3 of millicode calls avoids spilling %r1 and\n@@ -2263,15 +2452,17 @@\n \t\t (zero_extend:DI (match_operand:SI 2 \"nonimmediate_operand\" \"f\"))))]\n   \"TARGET_SNAKE && ! TARGET_DISABLE_FPREGS\"\n   \"xmpyu %1,%2,%0\"\n-  [(set_attr \"type\" \"fpmul\")])\n+  [(set_attr \"type\" \"fpmuldbl\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=f\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"f\"))\n \t\t (match_operand:DI 2 \"uint32_operand\" \"f\")))]\n   \"TARGET_SNAKE && ! TARGET_DISABLE_FPREGS\"\n   \"xmpyu %1,%R2,%0\"\n-  [(set_attr \"type\" \"fpmul\")])\n+  [(set_attr \"type\" \"fpmuldbl\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n@@ -2514,7 +2705,8 @@\n \t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"and %1,%2,%0\\;and %R1,%R2,%R0\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n \n ; The ? for op1 makes reload prefer zdepi instead of loading a huge\n ; constant with ldil;ldo.\n@@ -2524,23 +2716,26 @@\n \t\t(match_operand:SI 2 \"and_operand\" \"rO,P\")))]\n   \"\"\n   \"* return output_and (operands); \"\n-  [(set_attr \"type\" \"binary\")\n-   (set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"binary,shift\")\n+   (set_attr \"length\" \"4,4\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n \t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"andcm %2,%1,%0\\;andcm %R2,%R1,%R0\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"andcm %2,%1,%0\")\n+  \"andcm %2,%1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+  (set_attr \"length\" \"4\")])\n \n (define_expand \"iordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -2561,7 +2756,8 @@\n \t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"or %1,%2,%0\\;or %R1,%R2,%R0\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n \n ;; Need a define_expand because we've run out of CONST_OK... characters.\n (define_expand \"iorsi3\"\n@@ -2576,20 +2772,22 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t(match_operand:SI 2 \"ior_operand\" \"\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t(match_operand:SI 2 \"ior_operand\" \"M,i\")))]\n   \"\"\n   \"* return output_ior (operands); \"\n-  [(set_attr \"type\" \"binary\")\n-   (set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"binary,shift\")\n+   (set_attr \"length\" \"4,4\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n \t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"or %1,%2,%0\")\n+  \"or %1,%2,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n \n (define_expand \"xordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -2610,14 +2808,17 @@\n \t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"xor %1,%2,%0\\;xor %R1,%R2,%R0\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n \t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"xor %1,%2,%0\")\n+  \"xor %1,%2,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"negdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -2632,7 +2833,8 @@\n \t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"sub 0,%1,%0\"\n-  [(set_attr \"type\" \"unary\")])\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"4\")])\n \n (define_expand \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -2657,7 +2859,8 @@\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"uaddcm 0,%1,%0\"\n-  [(set_attr \"type\" \"unary\")])\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"4\")])\n \f\n ;; Floating point arithmetic instructions.\n \n@@ -2667,105 +2870,119 @@\n \t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"\"\n   \"fadd,dbl %1,%2,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"addsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(plus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"\"\n   \"fadd,sgl %1,%2,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"subdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"\"\n   \"fsub,dbl %1,%2,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"subsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(minus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t  (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"\"\n   \"fsub,sgl %1,%2,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"muldf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"\"\n   \"fmpy,dbl %1,%2,%0\"\n-  [(set_attr \"type\" \"fpmul\")])\n+  [(set_attr \"type\" \"fpmuldbl\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"mulsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"\"\n   \"fmpy,sgl %1,%2,%0\"\n-  [(set_attr \"type\" \"fpmul\")])\n+  [(set_attr \"type\" \"fpmulsgl\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"divdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"\"\n   \"fdiv,dbl %1,%2,%0\"\n-  [(set_attr \"type\" \"fpdivdbl\")])\n+  [(set_attr \"type\" \"fpdivdbl\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"divsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"\"\n   \"fdiv,sgl %1,%2,%0\"\n-  [(set_attr \"type\" \"fpdivsgl\")])\n+  [(set_attr \"type\" \"fpdivsgl\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"negdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(neg:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fsub,dbl 0,%1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"negsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(neg:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fsub,sgl 0,%1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"absdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(abs:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fabs,dbl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"abssf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(abs:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fabs,sgl %1,%0\"\n-  [(set_attr \"type\" \"fpalu\")])\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fsqrt,dbl %1,%0\"\n-  [(set_attr \"type\" \"fpsqrtdbl\")])\n+  [(set_attr \"type\" \"fpsqrtdbl\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"\"\n   \"fsqrt,sgl %1,%0\"\n-  [(set_attr \"type\" \"fpsqrtsgl\")])\n+  [(set_attr \"type\" \"fpsqrtsgl\")\n+   (set_attr \"length\" \"4\")])\n \f\n ;;- Shift instructions\n \n@@ -2795,7 +3012,9 @@\n \t\t\t  (match_operand:SI 3 \"shadd_operand\" \"\"))\n \t\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"sh%O3addl %2,%1,%0\")\n+  \"sh%O3addl %2,%1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n \n ;; This variant of the above insn can occur if the first operand\n ;; is the frame pointer.  This is a kludge, but there doesn't\n@@ -2847,7 +3066,7 @@\n \t\t   (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n   \"\"\n   \"zdep %1,%P2,%L2,%0\"\n-  [(set_attr \"type\" \"binary\")\n+  [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n ; Match cases of op1 a CONST_INT here that zvdep_imm doesn't handle.\n@@ -2864,7 +3083,9 @@\n   \"\"\n   \"@\n    zvdep %1,32,%0\n-   zvdepi %1,32,%0\")\n+   zvdepi %1,32,%0\"\n+  [(set_attr \"type\" \"shift,shift\")\n+   (set_attr \"length\" \"4,4\")])\n \n (define_insn \"zvdep_imm\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -2878,7 +3099,9 @@\n   operands[2] = GEN_INT (4 + exact_log2 ((x >> 4) + 1));\n   operands[1] = GEN_INT ((x & 0xf) - 0x10);\n   return \\\"zvdepi %1,%2,%0\\\";\n-}\")\n+}\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"vdepi_ior\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -2893,7 +3116,9 @@\n   int x = INTVAL (operands[1]);\n   operands[2] = GEN_INT (exact_log2 (x + 1));\n   return \\\"vdepi -1,%2,%0\\\";\n-}\")\n+}\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"vdepi_and\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -2908,7 +3133,9 @@\n   int x = INTVAL (operands[1]);\n   operands[2] = GEN_INT (exact_log2 ((~x) + 1));\n   return \\\"vdepi 0,%2,%0\\\";\n-}\")\n+}\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \n (define_expand \"ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -2932,7 +3159,7 @@\n \t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n   \"\"\n   \"extrs %1,%P2,%L2,%0\"\n-  [(set_attr \"type\" \"binary\")\n+  [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"vextrs32\"\n@@ -2941,7 +3168,9 @@\n \t\t     (minus:SI (const_int 31)\n \t\t\t       (match_operand:SI 2 \"register_operand\" \"q\"))))]\n   \"\"\n-  \"vextrs %1,32,%0\")\n+  \"vextrs %1,32,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -2951,7 +3180,7 @@\n   \"@\n    vshd 0,%1,%0\n    extru %1,%P2,%L2,%0\"\n-  [(set_attr \"type\" \"binary\")\n+  [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"rotrsi3\"\n@@ -2969,7 +3198,7 @@\n   else\n     return \\\"vshd %1,%1,%0\\\";\n }\"\n-  [(set_attr \"type\" \"binary\")\n+  [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"rotlsi3\"\n@@ -2982,7 +3211,7 @@\n   operands[2] = GEN_INT ((32 - INTVAL (operands[2])) & 31);\n   return \\\"shd %1,%1,%2,%0\\\";\n }\"\n-  [(set_attr \"type\" \"binary\")\n+  [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n@@ -2994,7 +3223,7 @@\n \t\t\t(match_operand:SI 4 \"const_int_operand\" \"n\"))]))]\n   \"INTVAL (operands[3]) + INTVAL (operands[4]) == 32\"\n   \"shd %1,%2,%4,%0\"\n-  [(set_attr \"type\" \"binary\")\n+  [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n@@ -3006,7 +3235,7 @@\n \t\t      (match_operand:SI 3 \"const_int_operand\" \"n\"))]))]\n   \"INTVAL (operands[3]) + INTVAL (operands[4]) == 32\"\n   \"shd %1,%2,%4,%0\"\n-  [(set_attr \"type\" \"binary\")\n+  [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n@@ -3022,7 +3251,7 @@\n   operands[2] = GEN_INT (31 - cnt);\n   return \\\"zdep %1,%2,%3,%0\\\";\n }\"\n-  [(set_attr \"type\" \"binary\")\n+  [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \f\n ;; Unconditional and other jump instructions.\n@@ -3031,7 +3260,8 @@\n   [(return)]\n   \"hppa_can_use_return_insn_p ()\"\n   \"bv%* 0(%%r2)\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n \n ;; Use a different pattern for functions which have non-trivial\n ;; epilogues so as not to confuse jump and reorg.\n@@ -3040,7 +3270,8 @@\n    (return)]\n   \"\"\n   \"bv%* 0(%%r2)\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n \n (define_expand \"prologue\"\n   [(const_int 0)]\n@@ -3072,7 +3303,8 @@\n    (use (match_operand:SI 0 \"const_int_operand\" \"\"))]\n   \"\"\n   \"bl _mcount,%%r2\\;ldo %0(%%r2),%%r25\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"blockage\"\n   [(unspec_volatile [(const_int 2)] 0)]\n@@ -3156,7 +3388,8 @@\n       return \\\"sub,>> %0,%1,0\\;blr,n %0,0\\;b,n %l3\\\";\n     }\n }\"\n-  [(set_attr \"length\" \"12\")])\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"12\")])\n \n ;; Need nops for the calls because execution is supposed to continue\n ;; past; we don't want to nullify an instruction that we need.\n@@ -3384,46 +3617,57 @@\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n-  \"nop\")\n+  \"nop\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")])\n \n ;;; Hope this is only within a function...\n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n   \"\"\n   \"bv%* 0(%0)\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"extzv\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n \t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n   \"\"\n-  \"extru %1,%3+%2-1,%2,%0\")\n+  \"extru %1,%3+%2-1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (const_int 1)\n \t\t\t (match_operand:SI 3 \"register_operand\" \"q\")))]\n   \"\"\n-  \"vextru %1,1,%0\")\n+  \"vextru %1,1,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"extv\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n \t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n   \"\"\n-  \"extrs %1,%3+%2-1,%2,%0\")\n+  \"extrs %1,%3+%2-1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (const_int 1)\n \t\t\t (match_operand:SI 3 \"register_operand\" \"q\")))]\n   \"\"\n-  \"vextrs %1,1,%0\")\n+  \"vextrs %1,1,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"insv\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r,r\")\n@@ -3433,7 +3677,9 @@\n   \"\"\n   \"@\n    dep %3,%2+%1-1,%1,%0\n-   depi %3,%2+%1-1,%1,%0\")\n+   depi %3,%2+%1-1,%1,%0\"\n+  [(set_attr \"type\" \"shift,shift\")\n+   (set_attr \"length\" \"4,4\")])\n \n ;; Optimize insertion of const_int values of type 1...1xxxx.\n (define_insn \"\"\n@@ -3447,7 +3693,9 @@\n {\n   operands[3] = GEN_INT ((INTVAL (operands[3]) & 0xf) - 0x10);\n   return \\\"depi %3,%2+%1-1,%1,%0\\\";\n-}\")\n+}\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n \n ;; This insn is used for some loop tests, typically loops reversed when\n ;; strength reduction is used.  It is actually created when the instruction\n@@ -3759,7 +4007,8 @@\n    (use (mem:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"fdc 0(0,%0)\\;fdc 0(0,%1)\\;sync\"\n-  [(set_attr \"length\" \"12\")])\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"12\")])\n \n (define_insn \"icacheflush\"\n   [(unspec_volatile [(const_int 2)] 0)\n@@ -3770,4 +4019,5 @@\n    (clobber (match_operand:SI 4 \"register_operand\" \"=&r\"))]\n   \"\"\n   \"mfsp %%sr0,%4\\;ldsid (0,%2),%3\\;mtsp %3,%%sr0\\;fic 0(%%sr0,%0)\\;fic 0(%%sr0,%1)\\;sync\\;mtsp %4,%%sr0\\;nop\\;nop\\;nop\\;nop\\;nop\\;nop\"\n-  [(set_attr \"length\" \"52\")])\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"52\")])"}]}