{"sha": "8dd5516b4c01d6301161716b8d626b999fa42d56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRkNTUxNmI0YzAxZDYzMDExNjE3MTZiOGQ2MjZiOTk5ZmE0MmQ1Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-12-22T23:41:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-12-22T23:41:17Z"}, "message": "re PR middle-end/31150 (Not promoting an whole array to be static const)\n\n\tPR middle-end/31150\n\t* dse.c (struct store_info): Add const_rhs field.\n\t(clear_rhs_from_active_local_stores): Clear also const_rhs.\n\t(record_store): Try also cselib_expand_value_rtx to get a constant.\n\t(find_shift_sequence, get_stored_val): Use const_rhs instead of\n\trhs if worthwhile.\n\t* cselib.c (cselib_record_sets): If !cselib_record_memory and\n\tthere is just one set from read-only MEM, look at REG_EQUAL or\n\tREG_EQUIV note.\n\n\t* dse.c (struct store_info): Add redundant_reason field.\n\t(record_store): When storing the same constant as has been\n\tstored by an earlier store, set redundant_reason field\n\tto the earlier store's insn_info_t.  Don't delete cannot_delete\n\tinsns.\n\t(find_shift_sequence): Remove read_info argument, add read_mode\n\tand require_cst arguments.  Return early if require_cst and\n\tconstant wouldn't be returned.\n\t(get_stored_val): New function.\n\t(replace_read): Use it.\n\t(scan_insn): Put even cannot_delete insns with exactly 1 store\n\tinto active_local_stores.\n\t(dse_step1): Don't delete cannot_delete insns.  Remove redundant\n\tconstant stores if contains_cselib_groups and earlier store storing\n\tthe same value hasn't been eliminated.\n\t(dse_step6): Renamed to dse_step7.  New function.\n\t(dse_step7): Renamed from dse_step6.\n\t(rest_of_handle_dse): Call dse_step6 and dse_step7 at the end.\n\t* cselib.c (cselib_expand_value_rtx): Don't wrap CONST_INTs\n\tinto CONST unless really necessary.  Handle SUBREG, unary,\n\tternary, bitfield and compares specially, to be able to simplify\n\toperations on constants.\n\t(expand_loc): Try to optimize LO_SUM.\n\n\t* dse.c (get_call_args): New function.\n\t(scan_insn): Don't handle BUILT_IN_BZERO.  For memset, attempt\n\tto get call arguments and if successful and both len and val are\n\tconstants, handle the call as (mem:BLK) (const_int) store.\n\n\t* dse.c (struct store_info): Add is_large bool field, change\n\tpositions_needed into a union of a bitmask and bitmap + count.\n\t(free_store_info): Free bitmap if is_large.\n\t(set_usage_bits): Don't look at stores where\n\toffset + width >= MAX_OFFSET.\n\t(set_position_unneeded, set_all_positions_unneeded,\n\tany_positions_needed_p, all_positions_needed_p): New static inline\n\tfunctions.\n\t(record_store): Handle BLKmode stores of CONST_INT, if\n\tMEM_SIZE is set on the MEM.  Use the new positions_needed\n\taccessor inlines.\n\t(replace_read): Handle reads from BLKmode CONST_INT stores.\n\t(check_mem_read_rtx): Use all_positions_needed_p function.\n\t(dse_step1): Free large positions_needed bitmaps and clear is_large.\n\n\t* dse.c (struct store_info): Change begin and end types to\n\tHOST_WIDE_INT.\n\n\t* dse.c (record_store): Fix check for unused store.\n\n\t* expr.c (block_clear_fn): No longer static.\n\t* expr.h (block_clear_fn): Declare.\n\t* dse.c (scan_insn): Memset and bzero can just read their\n\targuments.\n\n\t* gcc.c-torture/execute/20081218-1.c: New test.\n\nFrom-SVN: r142892", "tree": {"sha": "167c47dc48087fc4f6a776d5c66088ff2c4fca0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/167c47dc48087fc4f6a776d5c66088ff2c4fca0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dd5516b4c01d6301161716b8d626b999fa42d56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dd5516b4c01d6301161716b8d626b999fa42d56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dd5516b4c01d6301161716b8d626b999fa42d56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dd5516b4c01d6301161716b8d626b999fa42d56/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "805903b5251042186344830f35161eaec7fedb69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/805903b5251042186344830f35161eaec7fedb69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/805903b5251042186344830f35161eaec7fedb69"}], "stats": {"total": 905, "additions": 772, "deletions": 133}, "files": [{"sha": "690a1c95aba52168e4d33b8c8fe1703e44dad696", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8dd5516b4c01d6301161716b8d626b999fa42d56", "patch": "@@ -1,5 +1,69 @@\n 2008-12-23  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/31150\n+\t* dse.c (struct store_info): Add const_rhs field.\n+\t(clear_rhs_from_active_local_stores): Clear also const_rhs.\n+\t(record_store): Try also cselib_expand_value_rtx to get a constant.\n+\t(find_shift_sequence, get_stored_val): Use const_rhs instead of\n+\trhs if worthwhile.\n+\t* cselib.c (cselib_record_sets): If !cselib_record_memory and\n+\tthere is just one set from read-only MEM, look at REG_EQUAL or\n+\tREG_EQUIV note.\n+\n+\t* dse.c (struct store_info): Add redundant_reason field.\n+\t(record_store): When storing the same constant as has been\n+\tstored by an earlier store, set redundant_reason field\n+\tto the earlier store's insn_info_t.  Don't delete cannot_delete\n+\tinsns.\n+\t(find_shift_sequence): Remove read_info argument, add read_mode\n+\tand require_cst arguments.  Return early if require_cst and\n+\tconstant wouldn't be returned.\n+\t(get_stored_val): New function.\n+\t(replace_read): Use it.\n+\t(scan_insn): Put even cannot_delete insns with exactly 1 store\n+\tinto active_local_stores.\n+\t(dse_step1): Don't delete cannot_delete insns.  Remove redundant\n+\tconstant stores if contains_cselib_groups and earlier store storing\n+\tthe same value hasn't been eliminated.\n+\t(dse_step6): Renamed to dse_step7.  New function.\n+\t(dse_step7): Renamed from dse_step6.\n+\t(rest_of_handle_dse): Call dse_step6 and dse_step7 at the end.\n+\t* cselib.c (cselib_expand_value_rtx): Don't wrap CONST_INTs\n+\tinto CONST unless really necessary.  Handle SUBREG, unary,\n+\tternary, bitfield and compares specially, to be able to simplify\n+\toperations on constants.\n+\t(expand_loc): Try to optimize LO_SUM.\n+\n+\t* dse.c (get_call_args): New function.\n+\t(scan_insn): Don't handle BUILT_IN_BZERO.  For memset, attempt\n+\tto get call arguments and if successful and both len and val are\n+\tconstants, handle the call as (mem:BLK) (const_int) store.\n+\n+\t* dse.c (struct store_info): Add is_large bool field, change\n+\tpositions_needed into a union of a bitmask and bitmap + count.\n+\t(free_store_info): Free bitmap if is_large.\n+\t(set_usage_bits): Don't look at stores where\n+\toffset + width >= MAX_OFFSET.\n+\t(set_position_unneeded, set_all_positions_unneeded,\n+\tany_positions_needed_p, all_positions_needed_p): New static inline\n+\tfunctions.\n+\t(record_store): Handle BLKmode stores of CONST_INT, if\n+\tMEM_SIZE is set on the MEM.  Use the new positions_needed\n+\taccessor inlines.\n+\t(replace_read): Handle reads from BLKmode CONST_INT stores.\n+\t(check_mem_read_rtx): Use all_positions_needed_p function.\n+\t(dse_step1): Free large positions_needed bitmaps and clear is_large.\n+\n+\t* dse.c (struct store_info): Change begin and end types to\n+\tHOST_WIDE_INT.\n+\n+\t* dse.c (record_store): Fix check for unused store.\n+\n+\t* expr.c (block_clear_fn): No longer static.\n+\t* expr.h (block_clear_fn): Declare.\n+\t* dse.c (scan_insn): Memset and bzero can just read their\n+\targuments.\n+\n \t* config/i386/i386.c (expand_setmem_via_rep_stos): Add ORIG_VALUE\n \targument.  If ORIG_VALUE is const0_rtx and COUNT is constant,\n \tset MEM_SIZE on DESTMEM."}, {"sha": "945a4a118de7830a0914ab32ef51ed898f1674f3", "filename": "gcc/cselib.c", "status": "modified", "additions": 109, "deletions": 21, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=8dd5516b4c01d6301161716b8d626b999fa42d56", "patch": "@@ -1,6 +1,7 @@\n /* Common subexpression elimination library for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -865,12 +866,18 @@ expand_loc (struct elt_loc_list *p, bitmap regs_active, int max_depth)\n \tcontinue;\n       else if (!REG_P (p->loc))\n \t{\n-\t  rtx result;\n+\t  rtx result, note;\n \t  if (dump_file)\n \t    {\n \t      print_inline_rtx (dump_file, p->loc, 0);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n+\t  if (GET_CODE (p->loc) == LO_SUM\n+\t      && GET_CODE (XEXP (p->loc, 1)) == SYMBOL_REF\n+\t      && p->setting_insn\n+\t      && (note = find_reg_note (p->setting_insn, REG_EQUAL, NULL_RTX))\n+\t      && XEXP (note, 0) == XEXP (p->loc, 1))\n+\t    return XEXP (p->loc, 1);\n \t  result = cselib_expand_value_rtx (p->loc, regs_active, max_depth - 1);\n \t  if (result)\n \t    return result;\n@@ -928,6 +935,7 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n   int i, j;\n   RTX_CODE code;\n   const char *format_ptr;\n+  enum machine_mode mode;\n \n   code = GET_CODE (orig);\n \n@@ -1007,25 +1015,30 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n \treturn orig;\n       break;\n \n-\n-    case VALUE:\n+    case SUBREG:\n       {\n-\trtx result;\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"expanding value %s into: \", GET_MODE_NAME (GET_MODE (orig)));\n-\t\n-\tresult = expand_loc (CSELIB_VAL_PTR (orig)->locs, regs_active, max_depth);\n-\tif (result \n-\t    && GET_CODE (result) == CONST_INT\n-\t    && GET_MODE (orig) != VOIDmode)\n-\t  {\n-\t    result = gen_rtx_CONST (GET_MODE (orig), result);\n-\t    if (dump_file)\n-\t      fprintf (dump_file, \"  wrapping const_int result in const to preserve mode %s\\n\", \n-\t\t       GET_MODE_NAME (GET_MODE (orig)));\n-\t  }\n-\treturn result;\n+\trtx subreg = cselib_expand_value_rtx (SUBREG_REG (orig), regs_active,\n+\t\t\t\t\t      max_depth - 1);\n+\tif (!subreg)\n+\t  return NULL;\n+\tscopy = simplify_gen_subreg (GET_MODE (orig), subreg,\n+\t\t\t\t     GET_MODE (SUBREG_REG (orig)),\n+\t\t\t\t     SUBREG_BYTE (orig));\n+\tif (scopy == NULL\n+\t    || (GET_CODE (scopy) == SUBREG\n+\t\t&& !REG_P (SUBREG_REG (scopy))\n+\t\t&& !MEM_P (SUBREG_REG (scopy))))\n+\t  return shallow_copy_rtx (orig);\n+\treturn scopy;\n       }\n+\n+    case VALUE:\n+      if (dump_file)\n+\tfprintf (dump_file, \"expanding value %s into: \",\n+\t\t GET_MODE_NAME (GET_MODE (orig)));\n+\n+      return expand_loc (CSELIB_VAL_PTR (orig)->locs, regs_active, max_depth);\n+\n     default:\n       break;\n     }\n@@ -1036,9 +1049,9 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n      us to explicitly document why we are *not* copying a flag.  */\n   copy = shallow_copy_rtx (orig);\n \n-  format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n+  format_ptr = GET_RTX_FORMAT (code);\n \n-  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n     switch (*format_ptr++)\n       {\n       case 'e':\n@@ -1082,6 +1095,70 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n \tgcc_unreachable ();\n       }\n \n+  mode = GET_MODE (copy);\n+  /* If an operand has been simplified into CONST_INT, which doesn't\n+     have a mode and the mode isn't derivable from whole rtx's mode,\n+     try simplify_*_operation first with mode from original's operand\n+     and as a fallback wrap CONST_INT into gen_rtx_CONST.  */\n+  scopy = copy;\n+  switch (GET_RTX_CLASS (code))\n+    {\n+    case RTX_UNARY:\n+      if (CONST_INT_P (XEXP (copy, 0))\n+\t  && GET_MODE (XEXP (orig, 0)) != VOIDmode)\n+\t{\n+\t  scopy = simplify_unary_operation (code, mode, XEXP (copy, 0),\n+\t\t\t\t\t    GET_MODE (XEXP (orig, 0)));\n+\t  if (scopy)\n+\t    return scopy;\n+\t}\n+      break;\n+    case RTX_COMM_ARITH:\n+    case RTX_BIN_ARITH:\n+      /* These expressions can derive operand modes from the whole rtx's mode.  */\n+      break;\n+    case RTX_TERNARY:\n+    case RTX_BITFIELD_OPS:\n+      if (CONST_INT_P (XEXP (copy, 0))\n+\t  && GET_MODE (XEXP (orig, 0)) != VOIDmode)\n+\t{\n+\t  scopy = simplify_ternary_operation (code, mode,\n+\t\t\t\t\t      GET_MODE (XEXP (orig, 0)),\n+\t\t\t\t\t      XEXP (copy, 0), XEXP (copy, 1),\n+\t\t\t\t\t      XEXP (copy, 2));\n+\t  if (scopy)\n+\t    return scopy;\n+\t}\n+      break;\n+    case RTX_COMPARE:\n+    case RTX_COMM_COMPARE:\n+      if (CONST_INT_P (XEXP (copy, 0))\n+\t  && GET_MODE (XEXP (copy, 1)) == VOIDmode\n+\t  && (GET_MODE (XEXP (orig, 0)) != VOIDmode\n+\t      || GET_MODE (XEXP (orig, 1)) != VOIDmode))\n+\t{\n+\t  scopy = simplify_relational_operation (code, mode,\n+\t\t\t\t\t\t (GET_MODE (XEXP (orig, 0))\n+\t\t\t\t\t\t  != VOIDmode)\n+\t\t\t\t\t\t ? GET_MODE (XEXP (orig, 0))\n+\t\t\t\t\t\t : GET_MODE (XEXP (orig, 1)),\n+\t\t\t\t\t\t XEXP (copy, 0),\n+\t\t\t\t\t\t XEXP (copy, 1));\n+\t  if (scopy)\n+\t    return scopy;\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+  if (scopy == NULL_RTX)\n+    {\n+      XEXP (copy, 0)\n+\t= gen_rtx_CONST (GET_MODE (XEXP (orig, 0)), XEXP (copy, 0));\n+      if (dump_file)\n+\tfprintf (dump_file, \"  wrapping const_int result in const to preserve mode %s\\n\",\n+\t\t GET_MODE_NAME (GET_MODE (XEXP (copy, 0))));\n+    }\n   scopy = simplify_rtx (copy);\n   if (scopy)\n     return scopy;\n@@ -1581,6 +1658,17 @@ cselib_record_sets (rtx insn)\n \t}\n     }\n \n+  if (n_sets == 1\n+      && MEM_P (sets[0].src)\n+      && !cselib_record_memory\n+      && MEM_READONLY_P (sets[0].src))\n+    {\n+      rtx note = find_reg_equal_equiv_note (insn);\n+\n+      if (note && CONSTANT_P (XEXP (note, 0)))\n+\tsets[0].src = XEXP (note, 0);\n+    }\n+\n   /* Look up the values that are read.  Do this before invalidating the\n      locations that are written.  */\n   for (i = 0; i < n_sets; i++)"}, {"sha": "95a351b59a6f573a0816c171cc7cdc9596fc6aa6", "filename": "gcc/dse.c", "status": "modified", "additions": 553, "deletions": 111, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=8dd5516b4c01d6301161716b8d626b999fa42d56", "patch": "@@ -91,7 +91,10 @@ along with GCC; see the file COPYING3.  If not see\n    5) Delete the insns that the global analysis has indicated are\n    unnecessary.\n \n-   6) Cleanup.\n+   6) Delete insns that store the same value as preceeding store\n+   where the earlier store couldn't be eliminated.\n+\n+   7) Cleanup.\n \n    This step uses cselib and canon_rtx to build the largest expression\n    possible for each address.  This pass is a forwards pass through\n@@ -205,6 +208,9 @@ struct store_info\n   /* False means this is a clobber.  */\n   bool is_set;\n \n+  /* False if a single HOST_WIDE_INT bitmap is used for positions_needed.  */\n+  bool is_large;\n+\n   /* The id of the mem group of the base address.  If rtx_varies_p is\n      true, this is -1.  Otherwise, it is the index into the group\n      table.  */\n@@ -224,20 +230,43 @@ struct store_info\n \n   /* The offset of the first and byte before the last byte associated\n      with the operation.  */\n-  int begin, end;\n+  HOST_WIDE_INT begin, end;\n+\n+  union\n+    {\n+      /* A bitmask as wide as the number of bytes in the word that\n+\t contains a 1 if the byte may be needed.  The store is unused if\n+\t all of the bits are 0.  This is used if IS_LARGE is false.  */\n+      unsigned HOST_WIDE_INT small_bitmask;\n+\n+      struct\n+\t{\n+\t  /* A bitmap with one bit per byte.  Cleared bit means the position\n+\t     is needed.  Used if IS_LARGE is false.  */\n+\t  bitmap bitmap;\n \n-  /* An bitmask as wide as the number of bytes in the word that\n-     contains a 1 if the byte may be needed.  The store is unused if\n-     all of the bits are 0.  */\n-  unsigned HOST_WIDE_INT positions_needed;\n+\t  /* Number of set bits (i.e. unneeded bytes) in BITMAP.  If it is\n+\t     equal to END - BEGIN, the whole store is unused.  */\n+\t  int count;\n+\t} large;\n+    } positions_needed;\n \n   /* The next store info for this insn.  */\n   struct store_info *next;\n \n   /* The right hand side of the store.  This is used if there is a\n      subsequent reload of the mems address somewhere later in the\n      basic block.  */\n-  rtx rhs;  \n+  rtx rhs;\n+\n+  /* If rhs is or holds a constant, this contains that constant,\n+     otherwise NULL.  */\n+  rtx const_rhs;\n+\n+  /* Set if this store stores the same constant value as REDUNDANT_REASON\n+     insn stored.  These aren't eliminated early, because doing that\n+     might prevent the earlier larger store to be eliminated.  */\n+  struct insn_info *redundant_reason;\n };\n \n /* Return a bitmask with the first N low bits set.  */\n@@ -760,6 +789,8 @@ free_store_info (insn_info_t insn_info)\n   while (store_info)\n     {\n       store_info_t next = store_info->next;\n+      if (store_info->is_large)\n+\tBITMAP_FREE (store_info->positions_needed.large.bitmap);\n       if (store_info->cse_base)\n \tpool_free (cse_store_info_pool, store_info);\n       else\n@@ -911,7 +942,7 @@ set_usage_bits (group_info_t group, HOST_WIDE_INT offset, HOST_WIDE_INT width)\n {\n   HOST_WIDE_INT i;\n \n-  if ((offset > -MAX_OFFSET) && (offset < MAX_OFFSET))\n+  if (offset > -MAX_OFFSET && offset + width < MAX_OFFSET)\n     for (i=offset; i<offset+width; i++)\n       {\n \tbitmap store1;\n@@ -1167,41 +1198,116 @@ clear_rhs_from_active_local_stores (void)\n \tstore_info = store_info->next;\n \n       store_info->rhs = NULL;\n+      store_info->const_rhs = NULL;\n \n       ptr = ptr->next_local_store;\n     }\n }\n \n \n+/* Mark byte POS bytes from the beginning of store S_INFO as unneeded.  */\n+\n+static inline void\n+set_position_unneeded (store_info_t s_info, int pos)\n+{\n+  if (__builtin_expect (s_info->is_large, false))\n+    {\n+      if (!bitmap_bit_p (s_info->positions_needed.large.bitmap, pos))\n+\t{\n+\t  s_info->positions_needed.large.count++;\n+\t  bitmap_set_bit (s_info->positions_needed.large.bitmap, pos);\n+\t}\n+    }\n+  else\n+    s_info->positions_needed.small_bitmask\n+      &= ~(((unsigned HOST_WIDE_INT) 1) << pos);\n+}\n+\n+/* Mark the whole store S_INFO as unneeded.  */\n+\n+static inline void\n+set_all_positions_unneeded (store_info_t s_info)\n+{\n+  if (__builtin_expect (s_info->is_large, false))\n+    {\n+      int pos, end = s_info->end - s_info->begin;\n+      for (pos = 0; pos < end; pos++)\n+\tbitmap_set_bit (s_info->positions_needed.large.bitmap, pos);\n+      s_info->positions_needed.large.count = end;\n+    }\n+  else\n+    s_info->positions_needed.small_bitmask = (unsigned HOST_WIDE_INT) 0;\n+}\n+\n+/* Return TRUE if any bytes from S_INFO store are needed.  */\n+\n+static inline bool\n+any_positions_needed_p (store_info_t s_info)\n+{\n+  if (__builtin_expect (s_info->is_large, false))\n+    return (s_info->positions_needed.large.count\n+\t    < s_info->end - s_info->begin);\n+  else\n+    return (s_info->positions_needed.small_bitmask\n+\t    != (unsigned HOST_WIDE_INT) 0);\n+}\n+\n+/* Return TRUE if all bytes START through START+WIDTH-1 from S_INFO\n+   store are needed.  */\n+\n+static inline bool\n+all_positions_needed_p (store_info_t s_info, int start, int width)\n+{\n+  if (__builtin_expect (s_info->is_large, false))\n+    {\n+      int end = start + width;\n+      while (start < end)\n+\tif (bitmap_bit_p (s_info->positions_needed.large.bitmap, start++))\n+\t  return false;\n+      return true;\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT mask = lowpart_bitmask (width) << start;\n+      return (s_info->positions_needed.small_bitmask & mask) == mask;\n+    }\n+}\n+\n+\n+static rtx get_stored_val (store_info_t, enum machine_mode, HOST_WIDE_INT,\n+\t\t\t   HOST_WIDE_INT, basic_block, bool);\n+\n+\n /* BODY is an instruction pattern that belongs to INSN.  Return 1 if\n    there is a candidate store, after adding it to the appropriate\n    local store group if so.  */\n \n static int\n record_store (rtx body, bb_info_t bb_info)\n {\n-  rtx mem;\n+  rtx mem, rhs, const_rhs;\n   HOST_WIDE_INT offset = 0;\n   HOST_WIDE_INT width = 0;\n   alias_set_type spill_alias_set;\n   insn_info_t insn_info = bb_info->last_insn;\n   store_info_t store_info = NULL;\n   int group_id;\n   cselib_val *base = NULL;\n-  insn_info_t ptr, last;\n+  insn_info_t ptr, last, redundant_reason;\n   bool store_is_unused;\n \n   if (GET_CODE (body) != SET && GET_CODE (body) != CLOBBER)\n     return 0;\n \n+  mem = SET_DEST (body);\n+\n   /* If this is not used, then this cannot be used to keep the insn\n      from being deleted.  On the other hand, it does provide something\n      that can be used to prove that another store is dead.  */\n   store_is_unused\n-    = (find_reg_note (insn_info->insn, REG_UNUSED, body) != NULL);\n+    = (find_reg_note (insn_info->insn, REG_UNUSED, mem) != NULL);\n \n   /* Check whether that value is a suitable memory location.  */\n-  mem = SET_DEST (body);\n   if (!MEM_P (mem))\n     {\n       /* If the set or clobber is unused, then it does not effect our\n@@ -1220,33 +1326,52 @@ record_store (rtx body, bb_info_t bb_info)\n \t    fprintf (dump_file, \" adding wild read for (clobber (mem:BLK (scratch))\\n\");\n \t  add_wild_read (bb_info);\n \t  insn_info->cannot_delete = true;\n+\t  return 0;\n \t}\n-      else if (!store_is_unused)\n+      /* Handle (set (mem:BLK (addr) [... S36 ...]) (const_int 0))\n+\t as memset (addr, 0, 36);  */\n+      else if (!MEM_SIZE (mem)\n+\t       || !CONST_INT_P (MEM_SIZE (mem))\n+\t       || GET_CODE (body) != SET\n+\t       || INTVAL (MEM_SIZE (mem)) <= 0\n+\t       || INTVAL (MEM_SIZE (mem)) > MAX_OFFSET\n+\t       || !CONST_INT_P (SET_SRC (body)))\n \t{\n-\t  /* If the set or clobber is unused, then it does not effect our\n-\t     ability to get rid of the entire insn.  */\n-\t  insn_info->cannot_delete = true;\n-\t  clear_rhs_from_active_local_stores ();\n+\t  if (!store_is_unused)\n+\t    {\n+\t      /* If the set or clobber is unused, then it does not effect our\n+\t\t ability to get rid of the entire insn.  */\n+\t      insn_info->cannot_delete = true;\n+\t      clear_rhs_from_active_local_stores ();\n+\t    }\n+\t  return 0;\n \t}\n-      return 0;\n     }\n \n   /* We can still process a volatile mem, we just cannot delete it.  */\n   if (MEM_VOLATILE_P (mem))\n-      insn_info->cannot_delete = true;\n+    insn_info->cannot_delete = true;\n \n   if (!canon_address (mem, &spill_alias_set, &group_id, &offset, &base))\n     {\n       clear_rhs_from_active_local_stores ();\n       return 0;\n     }\n \n-  width = GET_MODE_SIZE (GET_MODE (mem));\n+  if (GET_MODE (mem) == BLKmode)\n+    width = INTVAL (MEM_SIZE (mem));\n+  else\n+    {\n+      width = GET_MODE_SIZE (GET_MODE (mem));\n+      gcc_assert ((unsigned) width <= HOST_BITS_PER_WIDE_INT);\n+    }\n \n   if (spill_alias_set)\n     {\n       bitmap store1 = clear_alias_group->store1_p;\n       bitmap store2 = clear_alias_group->store2_p;\n+\n+      gcc_assert (GET_MODE (mem) != BLKmode);\n       \n       if (bitmap_bit_p (store1, spill_alias_set))\n \tbitmap_set_bit (store2, spill_alias_set);\n@@ -1295,10 +1420,41 @@ record_store (rtx body, bb_info_t bb_info)\n \t\t (int)offset, (int)(offset+width));\n     }\n \n+  const_rhs = rhs = NULL_RTX;\n+  if (GET_CODE (body) == SET\n+      /* No place to keep the value after ra.  */\n+      && !reload_completed\n+      && (REG_P (SET_SRC (body))\n+\t  || GET_CODE (SET_SRC (body)) == SUBREG\n+\t  || CONSTANT_P (SET_SRC (body)))\n+      && !MEM_VOLATILE_P (mem)\n+      /* Sometimes the store and reload is used for truncation and\n+\t rounding.  */\n+      && !(FLOAT_MODE_P (GET_MODE (mem)) && (flag_float_store)))\n+    {\n+      rhs = SET_SRC (body);\n+      if (CONSTANT_P (rhs))\n+\tconst_rhs = rhs;\n+      else if (body == PATTERN (insn_info->insn))\n+\t{\n+\t  rtx tem = find_reg_note (insn_info->insn, REG_EQUAL, NULL_RTX);\n+\t  if (tem && CONSTANT_P (XEXP (tem, 0)))\n+\t    const_rhs = XEXP (tem, 0);\n+\t}\n+      if (const_rhs == NULL_RTX && REG_P (rhs))\n+\t{\n+\t  rtx tem = cselib_expand_value_rtx (rhs, scratch, 5);\n+\n+\t  if (tem && CONSTANT_P (tem))\n+\t    const_rhs = tem;\n+\t}\n+    }\n+\n   /* Check to see if this stores causes some other stores to be\n      dead.  */\n   ptr = active_local_stores;\n   last = NULL;\n+  redundant_reason = NULL;\n \n   while (ptr)\n     {\n@@ -1327,7 +1483,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t      && (GET_MODE (mem) == entry->mode))\n \t    {\n \t      del = true;\n-\t      s_info->positions_needed = (unsigned HOST_WIDE_INT) 0;\n+\t      set_all_positions_unneeded (s_info);\n \t    }\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    trying spill store in insn=%d alias_set=%d\\n\",\n@@ -1341,10 +1497,46 @@ record_store (rtx body, bb_info_t bb_info)\n \t    fprintf (dump_file, \"    trying store in insn=%d gid=%d[%d..%d)\\n\",\n \t\t     INSN_UID (ptr->insn), s_info->group_id, \n \t\t     (int)s_info->begin, (int)s_info->end);\n-\t  for (i = offset; i < offset+width; i++)\n-\t    if (i >= s_info->begin && i < s_info->end)\n-\t      s_info->positions_needed\n-\t\t&= ~(((unsigned HOST_WIDE_INT) 1) << (i - s_info->begin));\n+\n+\t  /* Even if PTR won't be eliminated as unneeded, if both\n+\t     PTR and this insn store the same constant value, we might\n+\t     eliminate this insn instead.  */\n+\t  if (s_info->const_rhs\n+\t      && const_rhs\n+\t      && offset >= s_info->begin\n+\t      && offset + width <= s_info->end\n+\t      && all_positions_needed_p (s_info, offset - s_info->begin,\n+\t\t\t\t\t width))\n+\t    {\n+\t      if (GET_MODE (mem) == BLKmode)\n+\t\t{\n+\t\t  if (GET_MODE (s_info->mem) == BLKmode\n+\t\t      && s_info->const_rhs == const_rhs)\n+\t\t    redundant_reason = ptr;\n+\t\t}\n+\t      else if (s_info->const_rhs == const0_rtx\n+\t\t       && const_rhs == const0_rtx)\n+\t\tredundant_reason = ptr;\n+\t      else\n+\t\t{\n+\t\t  rtx val;\n+\t\t  start_sequence ();\n+\t\t  val = get_stored_val (s_info, GET_MODE (mem),\n+\t\t\t\t\toffset, offset + width,\n+\t\t\t\t\tBLOCK_FOR_INSN (insn_info->insn),\n+\t\t\t\t\ttrue);\n+\t\t  if (get_insns () != NULL)\n+\t\t    val = NULL_RTX;\n+\t\t  end_sequence ();\n+\t\t  if (val && rtx_equal_p (val, const_rhs))\n+\t\t    redundant_reason = ptr;\n+\t\t}\n+\t    }\n+\n+\t  for (i = MAX (offset, s_info->begin);\n+\t       i < offset + width && i < s_info->end;\n+\t       i++)\n+\t    set_position_unneeded (s_info, i - s_info->begin);\n \t}\n       else if (s_info->rhs)\n \t/* Need to see if it is possible for this store to overwrite\n@@ -1355,14 +1547,18 @@ record_store (rtx body, bb_info_t bb_info)\n \t\t\t\t     GET_MODE (s_info->mem),\n \t\t\t\t     s_info->mem_addr,\n \t\t\t\t     mem, rtx_varies_p))\n-\t    s_info->rhs = NULL;\n+\t    {\n+\t      s_info->rhs = NULL;\n+\t      s_info->const_rhs = NULL;\n+\t    }\n \t}\n       \n       /* An insn can be deleted if every position of every one of\n \t its s_infos is zero.  */\n-      if (s_info->positions_needed != (unsigned HOST_WIDE_INT) 0)\n+      if (any_positions_needed_p (s_info)\n+\t  || ptr->cannot_delete)\n \tdel = false;\n-      \n+\n       if (del)\n \t{\n \t  insn_info_t insn_to_delete = ptr;\n@@ -1380,34 +1576,32 @@ record_store (rtx body, bb_info_t bb_info)\n       ptr = next;\n     }\n   \n-  gcc_assert ((unsigned) width <= HOST_BITS_PER_WIDE_INT);\n-  \n   /* Finish filling in the store_info.  */\n   store_info->next = insn_info->store_rec;\n   insn_info->store_rec = store_info;\n   store_info->mem = canon_rtx (mem);\n   store_info->alias_set = spill_alias_set;\n   store_info->mem_addr = get_addr (XEXP (mem, 0));\n   store_info->cse_base = base;\n-  store_info->positions_needed = lowpart_bitmask (width);\n+  if (width > HOST_BITS_PER_WIDE_INT)\n+    {\n+      store_info->is_large = true;\n+      store_info->positions_needed.large.count = 0;\n+      store_info->positions_needed.large.bitmap = BITMAP_ALLOC (NULL);\n+    }\n+  else\n+    {\n+      store_info->is_large = false;\n+      store_info->positions_needed.small_bitmask = lowpart_bitmask (width);\n+    }\n   store_info->group_id = group_id;\n   store_info->begin = offset;\n   store_info->end = offset + width;\n   store_info->is_set = GET_CODE (body) == SET;\n+  store_info->rhs = rhs;\n+  store_info->const_rhs = const_rhs;\n+  store_info->redundant_reason = redundant_reason;\n \n-  if (store_info->is_set \n-      /* No place to keep the value after ra.  */\n-      && !reload_completed\n-      && (REG_P (SET_SRC (body))\n-\t  || GET_CODE (SET_SRC (body)) == SUBREG\n-\t  || CONSTANT_P (SET_SRC (body)))\n-      /* Sometimes the store and reload is used for truncation and\n-\t rounding.  */\n-      && !(FLOAT_MODE_P (GET_MODE (mem)) && (flag_float_store)))\n-    store_info->rhs = SET_SRC (body);\n-  else\n-    store_info->rhs = NULL;\n-  \n   /* If this is a clobber, we return 0.  We will only be able to\n      delete this insn if there is only one store USED store, but we\n      can use the clobber to delete other stores earlier.  */\n@@ -1435,12 +1629,10 @@ dump_insn_info (const char * start, insn_info_t insn_info)\n static rtx\n find_shift_sequence (int access_size,\n \t\t     store_info_t store_info,\n-\t\t     read_info_t read_info,\n-\t\t     int shift,\n-\t\t     bool speed)\n+\t\t     enum machine_mode read_mode,\n+\t\t     int shift, bool speed, bool require_cst)\n {\n   enum machine_mode store_mode = GET_MODE (store_info->mem);\n-  enum machine_mode read_mode = GET_MODE (read_info->mem);\n   enum machine_mode new_mode;\n   rtx read_reg = NULL;\n \n@@ -1462,11 +1654,11 @@ find_shift_sequence (int access_size,\n       /* If a constant was stored into memory, try to simplify it here,\n \t otherwise the cost of the shift might preclude this optimization\n \t e.g. at -Os, even when no actual shift will be needed.  */\n-      if (CONSTANT_P (store_info->rhs))\n+      if (store_info->const_rhs)\n \t{\n \t  unsigned int byte = subreg_lowpart_offset (new_mode, store_mode);\n-\t  rtx ret = simplify_subreg (new_mode, store_info->rhs, store_mode,\n-\t\t\t\t     byte);\n+\t  rtx ret = simplify_subreg (new_mode, store_info->const_rhs,\n+\t\t\t\t     store_mode, byte);\n \t  if (ret && CONSTANT_P (ret))\n \t    {\n \t      ret = simplify_const_binary_operation (LSHIFTRT, new_mode,\n@@ -1482,6 +1674,9 @@ find_shift_sequence (int access_size,\n \t    }\n \t}\n \n+      if (require_cst)\n+\treturn NULL_RTX;\n+\n       /* Try a wider mode if truncating the store mode to NEW_MODE\n \t requires a real instruction.  */\n       if (GET_MODE_BITSIZE (new_mode) < GET_MODE_BITSIZE (store_mode)\n@@ -1563,6 +1758,79 @@ look_for_hardregs (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n     }\n }\n \n+/* Helper function for replace_read and record_store.\n+   Attempt to return a value stored in STORE_INFO, from READ_BEGIN\n+   to one before READ_END bytes read in READ_MODE.  Return NULL\n+   if not successful.  If REQUIRE_CST is true, return always constant.  */\n+\n+static rtx\n+get_stored_val (store_info_t store_info, enum machine_mode read_mode,\n+\t\tHOST_WIDE_INT read_begin, HOST_WIDE_INT read_end,\n+\t\tbasic_block bb, bool require_cst)\n+{\n+  enum machine_mode store_mode = GET_MODE (store_info->mem);\n+  int shift;\n+  int access_size; /* In bytes.  */\n+  rtx read_reg;\n+\n+  /* To get here the read is within the boundaries of the write so\n+     shift will never be negative.  Start out with the shift being in\n+     bytes.  */\n+  if (store_mode == BLKmode)\n+    shift = 0;\n+  else if (BYTES_BIG_ENDIAN)\n+    shift = store_info->end - read_end;\n+  else\n+    shift = read_begin - store_info->begin;\n+\n+  access_size = shift + GET_MODE_SIZE (read_mode);\n+\n+  /* From now on it is bits.  */\n+  shift *= BITS_PER_UNIT;\n+\n+  if (shift)\n+    read_reg = find_shift_sequence (access_size, store_info, read_mode, shift,\n+    \t\t\t\t    optimize_bb_for_speed_p (bb),\n+\t\t\t\t    require_cst);\n+  else if (store_mode == BLKmode)\n+    {\n+      /* The store is a memset (addr, const_val, const_size).  */\n+      gcc_assert (CONST_INT_P (store_info->rhs));\n+      store_mode = int_mode_for_mode (read_mode);\n+      if (store_mode == BLKmode)\n+\tread_reg = NULL_RTX;\n+      else if (store_info->rhs == const0_rtx)\n+\tread_reg = extract_low_bits (read_mode, store_mode, const0_rtx);\n+      else if (GET_MODE_BITSIZE (store_mode) > HOST_BITS_PER_WIDE_INT\n+\t       || BITS_PER_UNIT >= HOST_BITS_PER_WIDE_INT)\n+\tread_reg = NULL_RTX;\n+      else\n+\t{\n+\t  unsigned HOST_WIDE_INT c\n+\t    = INTVAL (store_info->rhs)\n+\t      & (((HOST_WIDE_INT) 1 << BITS_PER_UNIT) - 1);\n+\t  int shift = BITS_PER_UNIT;\n+\t  while (shift < HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      c |= (c << shift);\n+\t      shift <<= 1;\n+\t    }\n+\t  read_reg = GEN_INT (trunc_int_for_mode (c, store_mode));\n+\t  read_reg = extract_low_bits (read_mode, store_mode, read_reg);\n+\t}\n+    }\n+  else if (store_info->const_rhs\n+\t   && (require_cst\n+\t       || GET_MODE_CLASS (read_mode) != GET_MODE_CLASS (store_mode)))\n+    read_reg = extract_low_bits (read_mode, store_mode,\n+\t\t\t\t copy_rtx (store_info->const_rhs));\n+  else\n+    read_reg = extract_low_bits (read_mode, store_mode,\n+\t\t\t\t copy_rtx (store_info->rhs));\n+  if (require_cst && read_reg && !CONSTANT_P (read_reg))\n+    read_reg = NULL_RTX;\n+  return read_reg;\n+}\n \n /* Take a sequence of:\n      A <- r1\n@@ -1597,30 +1865,17 @@ look_for_hardregs (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n \n static bool\n replace_read (store_info_t store_info, insn_info_t store_insn, \n-\t      read_info_t read_info, insn_info_t read_insn, rtx *loc, bitmap regs_live)\n+\t      read_info_t read_info, insn_info_t read_insn, rtx *loc,\n+\t      bitmap regs_live)\n {\n   enum machine_mode store_mode = GET_MODE (store_info->mem);\n   enum machine_mode read_mode = GET_MODE (read_info->mem);\n-  int shift;\n-  int access_size; /* In bytes.  */\n   rtx insns, this_insn, read_reg;\n+  basic_block bb;\n \n   if (!dbg_cnt (dse))\n     return false;\n \n-  /* To get here the read is within the boundaries of the write so\n-     shift will never be negative.  Start out with the shift being in\n-     bytes.  */\n-  if (BYTES_BIG_ENDIAN)\n-    shift = store_info->end - read_info->end;\n-  else\n-    shift = read_info->begin - store_info->begin;\n-\n-  access_size = shift + GET_MODE_SIZE (read_mode);\n-\n-  /* From now on it is bits.  */\n-  shift *= BITS_PER_UNIT;\n-\n   /* Create a sequence of instructions to set up the read register.\n      This sequence goes immediately before the store and its result\n      is read by the load.\n@@ -1636,12 +1891,10 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \t     GET_MODE_NAME (read_mode), INSN_UID (read_insn->insn),\n \t     GET_MODE_NAME (store_mode), INSN_UID (store_insn->insn));\n   start_sequence ();\n-  if (shift)\n-    read_reg = find_shift_sequence (access_size, store_info, read_info, shift,\n-    \t\t\t\t    optimize_bb_for_speed_p (BLOCK_FOR_INSN (read_insn->insn)));\n-  else\n-    read_reg = extract_low_bits (read_mode, store_mode,\n-\t\t\t\t copy_rtx (store_info->rhs));\n+  bb = BLOCK_FOR_INSN (read_insn->insn);\n+  read_reg = get_stored_val (store_info,\n+\t\t\t     read_mode, read_info->begin, read_info->end,\n+\t\t\t     bb, false);\n   if (read_reg == NULL_RTX)\n     {\n       end_sequence ();\n@@ -1892,18 +2145,15 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t      else \n \t\t{\n \t\t  if (store_info->rhs\n-\t\t      && (offset >= store_info->begin)\n-\t\t      && (offset + width <= store_info->end))\n-\t\t    {\n-\t\t      unsigned HOST_WIDE_INT mask\n-\t\t\t= (lowpart_bitmask (width)\n-\t\t\t   << (offset - store_info->begin));\n-\n-\t\t      if ((store_info->positions_needed & mask) == mask\n-\t\t\t  && replace_read (store_info, i_ptr, \n-\t\t\t\t\t   read_info, insn_info, loc, bb_info->regs_live))\n-\t\t\treturn 0;\n-\t\t    }\n+\t\t      && offset >= store_info->begin\n+\t\t      && offset + width <= store_info->end\n+\t\t      && all_positions_needed_p (store_info,\n+\t\t\t\t\t\t offset - store_info->begin,\n+\t\t\t\t\t\t width)\n+\t\t      && replace_read (store_info, i_ptr, read_info,\n+\t\t\t\t       insn_info, loc, bb_info->regs_live))\n+\t\t    return 0;\n+\n \t\t  /* The bases are the same, just see if the offsets\n \t\t     overlap.  */\n \t\t  if ((offset < store_info->end) \n@@ -1961,18 +2211,13 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t  if (store_info->rhs\n \t      && store_info->group_id == -1\n \t      && store_info->cse_base == base\n-\t      && (offset >= store_info->begin)\n-\t      && (offset + width <= store_info->end))\n-\t    {\n-\t      unsigned HOST_WIDE_INT mask\n-\t\t= (lowpart_bitmask (width)\n-\t\t   << (offset - store_info->begin));\n-\n-\t      if ((store_info->positions_needed & mask) == mask\n-\t\t  && replace_read (store_info, i_ptr, \n-\t\t\t\t   read_info, insn_info, loc, bb_info->regs_live))\n-\t\treturn 0;\n-\t    }\n+\t      && offset >= store_info->begin\n+\t      && offset + width <= store_info->end\n+\t      && all_positions_needed_p (store_info,\n+\t\t\t\t\t offset - store_info->begin, width)\n+\t      && replace_read (store_info, i_ptr,  read_info, insn_info, loc,\n+\t\t\t       bb_info->regs_live))\n+\t    return 0;\n \n \t  if (!store_info->alias_set)\n \t    remove = canon_true_dependence (store_info->mem, \n@@ -2008,6 +2253,67 @@ check_mem_read_use (rtx *loc, void *data)\n   for_each_rtx (loc, check_mem_read_rtx, data);\n }\n \n+\n+/* Get arguments passed to CALL_INSN.  Return TRUE if successful.\n+   So far it only handles arguments passed in registers.  */\n+\n+static bool\n+get_call_args (rtx call_insn, tree fn, rtx *args, int nargs)\n+{\n+  CUMULATIVE_ARGS args_so_far;\n+  tree arg;\n+  int idx;\n+\n+  INIT_CUMULATIVE_ARGS (args_so_far, TREE_TYPE (fn), NULL_RTX, 0, 3);\n+\n+  arg = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  for (idx = 0;\n+       arg != void_list_node && idx < nargs;\n+       arg = TREE_CHAIN (arg), idx++)\n+    {\n+      enum machine_mode mode = TYPE_MODE (TREE_VALUE (arg));\n+      rtx reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1), link, tmp;\n+      if (!reg || !REG_P (reg) || GET_MODE (reg) != mode\n+\t  || GET_MODE_CLASS (mode) != MODE_INT)\n+\treturn false;\n+\n+      for (link = CALL_INSN_FUNCTION_USAGE (call_insn);\n+\t   link;\n+\t   link = XEXP (link, 1))\n+\tif (GET_CODE (XEXP (link, 0)) == USE)\n+\t  {\n+\t    args[idx] = XEXP (XEXP (link, 0), 0);\n+\t    if (REG_P (args[idx])\n+\t\t&& REGNO (args[idx]) == REGNO (reg)\n+\t\t&& (GET_MODE (args[idx]) == mode\n+\t\t    || (GET_MODE_CLASS (GET_MODE (args[idx])) == MODE_INT\n+\t\t\t&& (GET_MODE_SIZE (GET_MODE (args[idx]))\n+\t\t\t    <= UNITS_PER_WORD)\n+\t\t\t&& (GET_MODE_SIZE (GET_MODE (args[idx]))\n+\t\t\t    > GET_MODE_SIZE (mode)))))\n+\t      break;\n+\t  }\n+      if (!link)\n+\treturn false;\n+\n+      tmp = cselib_expand_value_rtx (args[idx], scratch, 5);\n+      if (GET_MODE (args[idx]) != mode)\n+\t{\n+\t  if (!tmp || !CONST_INT_P (tmp))\n+\t    return false;\n+\t  tmp = GEN_INT (trunc_int_for_mode (INTVAL (tmp), mode));\n+\t}\n+      if (tmp)\n+\targs[idx] = tmp;\n+\n+      FUNCTION_ARG_ADVANCE (args_so_far, mode, NULL_TREE, 1);\n+    }\n+  if (arg != void_list_node || idx != nargs)\n+    return false;\n+  return true;\n+}\n+\n+\n /* Apply record_store to all candidate stores in INSN.  Mark INSN\n    if some part of it is not a candidate store and assigns to a\n    non-register target.  */\n@@ -2045,18 +2351,48 @@ scan_insn (bb_info_t bb_info, rtx insn)\n \n   if (CALL_P (insn))\n     {\n+      bool const_call;\n+      tree memset_call = NULL_TREE;\n+\n       insn_info->cannot_delete = true;\n \n       /* Const functions cannot do anything bad i.e. read memory,\n \t however, they can read their parameters which may have\n-\t been pushed onto the stack.  */\n-      if (RTL_CONST_CALL_P (insn))\n+\t been pushed onto the stack.\n+\t memset and bzero don't read memory either.  */\n+      const_call = RTL_CONST_CALL_P (insn);\n+      if (!const_call)\n+\t{\n+\t  rtx call = PATTERN (insn);\n+\t  if (GET_CODE (call) == PARALLEL)\n+\t    call = XVECEXP (call, 0, 0);\n+\t  if (GET_CODE (call) == SET)\n+\t    call = SET_SRC (call);\n+\t  if (GET_CODE (call) == CALL\n+\t      && MEM_P (XEXP (call, 0))\n+\t      && GET_CODE (XEXP (XEXP (call, 0), 0)) == SYMBOL_REF)\n+\t    {\n+\t      rtx symbol = XEXP (XEXP (call, 0), 0);\n+\t      if (SYMBOL_REF_DECL (symbol)\n+\t\t  && TREE_CODE (SYMBOL_REF_DECL (symbol)) == FUNCTION_DECL)\n+\t\t{\n+\t\t  if ((DECL_BUILT_IN_CLASS (SYMBOL_REF_DECL (symbol))\n+\t\t       == BUILT_IN_NORMAL\n+\t\t       && (DECL_FUNCTION_CODE (SYMBOL_REF_DECL (symbol))\n+\t\t\t   == BUILT_IN_MEMSET))\n+\t\t      || SYMBOL_REF_DECL (symbol) == block_clear_fn)\n+\t\t    memset_call = SYMBOL_REF_DECL (symbol);\n+\t\t}\n+\t    }\n+\t}\n+      if (const_call || memset_call)\n \t{\n \t  insn_info_t i_ptr = active_local_stores;\n \t  insn_info_t last = NULL;\n \n \t  if (dump_file)\n-\t    fprintf (dump_file, \"const call %d\\n\", INSN_UID (insn));\n+\t    fprintf (dump_file, \"%s call %d\\n\",\n+\t\t     const_call ? \"const\" : \"memset\", INSN_UID (insn));\n \n \t  /* See the head comment of the frame_read field.  */\n \t  if (reload_completed)\n@@ -2102,6 +2438,28 @@ scan_insn (bb_info_t bb_info, rtx insn)\n \n \t      i_ptr = i_ptr->next_local_store;\n \t    }\n+\n+\t  if (memset_call)\n+\t    {\n+\t      rtx args[3];\n+\t      if (get_call_args (insn, memset_call, args, 3)\n+\t\t  && CONST_INT_P (args[1])\n+\t\t  && CONST_INT_P (args[2])\n+\t\t  && INTVAL (args[2]) > 0)\n+\t\t{\n+\t\t  rtx mem = gen_rtx_MEM (BLKmode, args[0]);\n+\t\t  set_mem_size (mem, args[2]);\n+\t\t  body = gen_rtx_SET (VOIDmode, mem, args[1]);\n+\t\t  mems_found += record_store (body, bb_info);\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"handling memset as BLKmode store\\n\");\n+\t\t  if (mems_found == 1)\n+\t\t    {\n+\t\t      insn_info->next_local_store = active_local_stores;\n+\t\t      active_local_stores = insn_info;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n \n       else\n@@ -2134,11 +2492,11 @@ scan_insn (bb_info_t bb_info, rtx insn)\n     fprintf (dump_file, \"mems_found = %d, cannot_delete = %s\\n\", \n \t     mems_found, insn_info->cannot_delete ? \"true\" : \"false\");\n \n-  /* If we found some sets of mems, and the insn has not been marked\n-     cannot delete, add it into the active_local_stores so that it can\n-     be locally deleted if found dead.  Otherwise mark it as cannot\n-     delete.  This simplifies the processing later.  */ \n-  if (mems_found == 1 && !insn_info->cannot_delete)\n+  /* If we found some sets of mems, add it into the active_local_stores so\n+     that it can be locally deleted if found dead or used for\n+     replace_read and redundant constant store elimination.  Otherwise mark\n+     it as cannot delete.  This simplifies the processing later.  */\n+  if (mems_found == 1)\n     {\n       insn_info->next_local_store = active_local_stores;\n       active_local_stores = insn_info;\n@@ -2263,14 +2621,14 @@ dse_step1 (void)\n \t\t  /* Skip the clobbers.  */\n \t\t  while (!store_info->is_set)\n \t\t    store_info = store_info->next;\n-\t\t  if (store_info->alias_set)\n+\t\t  if (store_info->alias_set && !i_ptr->cannot_delete)\n \t\t    delete_dead_store_insn (i_ptr);\n \t\t  else \n \t\t    if (store_info->group_id >= 0)\n \t\t      {\n \t\t\tgroup_info_t group \n \t\t\t  = VEC_index (group_info_t, rtx_group_vec, store_info->group_id);\n-\t\t\tif (group->frame_related)\n+\t\t\tif (group->frame_related && !i_ptr->cannot_delete)\n \t\t\t  delete_dead_store_insn (i_ptr);\n \t\t      }\n \n@@ -2298,7 +2656,40 @@ dse_step1 (void)\n \t  while (ptr)\n \t    {\n \t      if (ptr->contains_cselib_groups)\n-\t\tfree_store_info (ptr);\n+\t\t{\n+\t\t  store_info_t s_info = ptr->store_rec;\n+\t\t  while (s_info && !s_info->is_set)\n+\t\t    s_info = s_info->next;\n+\t\t  if (s_info\n+\t\t      && s_info->redundant_reason\n+\t\t      && s_info->redundant_reason->insn\n+\t\t      && !ptr->cannot_delete)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"Locally deleting insn %d \"\n+\t\t\t\t\t    \"because insn %d stores the \"\n+\t\t\t\t\t    \"same value and couldn't be \"\n+\t\t\t\t\t    \"eliminated\\n\",\n+\t\t\t\t INSN_UID (ptr->insn),\n+\t\t\t\t INSN_UID (s_info->redundant_reason->insn));\n+\t\t      delete_dead_store_insn (ptr);\n+\t\t    }\n+\t\t  if (s_info)\n+\t\t    s_info->redundant_reason = NULL;\n+\t\t  free_store_info (ptr);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  store_info_t s_info;\n+\n+\t\t  /* Free at least positions_needed bitmaps.  */\n+\t\t  for (s_info = ptr->store_rec; s_info; s_info = s_info->next)\n+\t\t    if (s_info->is_large)\n+\t\t      {\n+\t\t\tBITMAP_FREE (s_info->positions_needed.large.bitmap);\n+\t\t\ts_info->is_large = false;\n+\t\t      }\n+\t\t}\n \t      ptr = ptr->prev_insn;\n \t    }\n \n@@ -3236,11 +3627,61 @@ dse_step5_spill (void)\n /*----------------------------------------------------------------------------\n    Sixth step.\n \n+   Delete stores made redundant by earlier stores (which store the same\n+   value) that couldn't be eliminated.\n+----------------------------------------------------------------------------*/\n+\n+static void\n+dse_step6 (void)\n+{\n+  basic_block bb;\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      bb_info_t bb_info = bb_table[bb->index];\n+      insn_info_t insn_info = bb_info->last_insn;\n+\n+      while (insn_info)\n+\t{\n+\t  /* There may have been code deleted by the dce pass run before\n+\t     this phase.  */\n+\t  if (insn_info->insn\n+\t      && INSN_P (insn_info->insn)\n+\t      && !insn_info->cannot_delete)\n+\t    {\n+\t      store_info_t s_info = insn_info->store_rec;\n+\n+\t      while (s_info && !s_info->is_set)\n+\t\ts_info = s_info->next;\n+\t      if (s_info\n+\t\t  && s_info->redundant_reason\n+\t\t  && s_info->redundant_reason->insn\n+\t\t  && INSN_P (s_info->redundant_reason->insn))\n+\t\t{\n+\t\t  rtx rinsn = s_info->redundant_reason->insn;\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Locally deleting insn %d \"\n+\t\t\t\t\t\"because insn %d stores the \"\n+\t\t\t\t\t\"same value and couldn't be \"\n+\t\t\t\t\t\"eliminated\\n\",\n+\t\t\t\t\tINSN_UID (insn_info->insn),\n+\t\t\t\t\tINSN_UID (rinsn));\n+\t\t  delete_dead_store_insn (insn_info);\n+\t\t}\n+\t    }\n+\t  insn_info = insn_info->prev_insn;\n+\t}\n+    }\n+}\n+\f\n+/*----------------------------------------------------------------------------\n+   Seventh step.\n+\n    Destroy everything left standing. \n ----------------------------------------------------------------------------*/\n \n static void \n-dse_step6 (bool global_done)\n+dse_step7 (bool global_done)\n {\n   unsigned int i;\n   group_info_t group;\n@@ -3346,8 +3787,9 @@ rest_of_handle_dse (void)\n       dse_step4 ();\n       dse_step5_spill ();\n     }\n-  \n-  dse_step6 (did_global);\n+\n+  dse_step6 ();\n+  dse_step7 (did_global);\n \n   if (dump_file)\n     fprintf (dump_file, \"dse: local deletions = %d, global deletions = %d, spill deletions = %d\\n\","}, {"sha": "9eb1ae70a0df96369a1a7bbdbd1c4828ed37de63", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8dd5516b4c01d6301161716b8d626b999fa42d56", "patch": "@@ -2698,7 +2698,7 @@ set_storage_via_libcall (rtx object, rtx size, rtx val, bool tailcall)\n    for the function we use for block clears.  The first time FOR_CALL\n    is true, we call assemble_external.  */\n \n-static GTY(()) tree block_clear_fn;\n+tree block_clear_fn;\n \n void\n init_block_clear_fn (const char *asmspec)"}, {"sha": "f3f208a141dc7b16ce8ee0db0aee515cdb9e217e", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=8dd5516b4c01d6301161716b8d626b999fa42d56", "patch": "@@ -404,6 +404,7 @@ enum block_op_methods\n   BLOCK_OP_TAILCALL\n };\n \n+extern tree GTY(()) block_clear_fn;\n extern void init_block_move_fn (const char *);\n extern void init_block_clear_fn (const char *);\n "}, {"sha": "e4f5e1ead8e1b06dbb998362fe075fb5c33b34db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8dd5516b4c01d6301161716b8d626b999fa42d56", "patch": "@@ -1,3 +1,8 @@\n+2008-12-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/31150\n+\t* gcc.c-torture/execute/20081218-1.c: New test.\n+\n 2008-12-22  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/35780"}, {"sha": "24b7bdd73a76bf2b8f6faee2d53e9bf197ecb9d6", "filename": "gcc/testsuite/gcc.c-torture/execute/20081218-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20081218-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5516b4c01d6301161716b8d626b999fa42d56/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20081218-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20081218-1.c?ref=8dd5516b4c01d6301161716b8d626b999fa42d56", "patch": "@@ -0,0 +1,39 @@\n+struct A { int i, j; char pad[512]; } a;\n+\n+int __attribute__((noinline))\n+foo (void)\n+{\n+  __builtin_memset (&a, 0x26, sizeof a);\n+  return a.i;\n+}\n+\n+void __attribute__((noinline))\n+bar (void)\n+{\n+  __builtin_memset (&a, 0x36, sizeof a);\n+  a.i = 0x36363636;\n+  a.j = 0x36373636;\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+  if (sizeof (int) != 4 || __CHAR_BIT__ != 8)\n+    return 0;\n+\n+  if (foo () != 0x26262626)\n+    __builtin_abort ();\n+  for (i = 0; i < sizeof a; i++)\n+    if (((char *)&a)[i] != 0x26)\n+      __builtin_abort ();\n+\n+  bar ();\n+  if (a.j != 0x36373636)\n+    __builtin_abort ();\n+  a.j = 0x36363636;\n+  for (i = 0; i < sizeof a; i++)\n+    if (((char *)&a)[i] != 0x36)\n+      __builtin_abort ();\n+  return 0;\n+}"}]}