{"sha": "18c038b9ca6f4e60c625636506cfe5a3290475a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThjMDM4YjljYTZmNGU2MGM2MjU2MzY1MDZjZmU1YTMyOTA0NzVhOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-02-28T09:51:42Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-02-28T09:51:42Z"}, "message": "emit-rtl.c (remove_unncessary_notes): Remove notes for empty blocks.\n\n\t* emit-rtl.c (remove_unncessary_notes): Remove notes for empty\n\tblocks.\n\t* final.c (next_block_index): Remove.\n\t(max_block_depth): Likewise.\n\t(pending_blocks): Likewise.\n\t(init_final): Don't initialize them.\n\t(final_start_function): Don't set next_block_index.  Set up\n\tBLOCK_NUMBER.\n\t(final_scan_insn): Use BLOCK_NUMBER, not next_block_index.\n\t* function.h (number_blocks): New function.\n\t* function.c (get_block_vector): New function.\n\t(identify_blocks): Use it.\n\t(reorder_blocks): Set NOTE_BLOCK.\n\t(number_blocks): New function.\n\t* tree.def (BLOCK): Add documentation for TREE_ASM_WRITTEN flag.\n\t* tree.h (BLOCK_NUMBER): New macro.\n\t(tree_block): Add block_num field.\n\t* dbxout.c (next_block_number): Remove.\n\t(dbxout_init): Don't set it.\n\t(dbxout_block): Only output blocks that have TREE_ASM_WRITTEN\n\tset.  Use BLOCK_NUMBER, rather than next_block_num, to determine\n\tblock numbers.\n\t* toplev.c (rest_of_compilation): Always call\n\tfind_loop_tree_blocks.  Fix indentation.\n\t* dwarf2out.c (next_block_number): Remove.\n\t(gen_lexical_block_die): Use BLOCK_NUMBER, not next_block_number,\n\tto determine block numbers.\n\t(gen_inlined_subroutine_die): Likewise.\n\t(gen_block_die): Only output blocks that have TREE_ASM_WRITTEN set.\n\t(decls_for_scope): Don't increment next_block_number.\n\t* dwarfout.c (next_block_number): Remove.\n\t(output_lexical_block_die): Use BLOCK_NUMBER, not next_block_number,\n\tto determine block numbers.\n\t(output_inlined_subroutine_die): Likewise.\n\t(output_block): Only output blocks that have TREE_ASM_WRITTEN set.\n\t(output_decls_for_scope): Don't increment next_block_number.\n\t* sdbout.c (next_block_number): Remove.\n\t(sdbout_block): Use BLOCK_NUMBER.\n\t(sdbout_begin_block): Simplify.\n\t* xcoffout.c (next_block_number): Remove.\n\t(xcoffout_block): Use BLOCK_NUMBER, not next_block_number.\n\t(xcoffout_begin_block): Don't set next_block_number.\n\t(xcoffout_begin_function): Likewise. Use BLOCK_NUMBER, not\n\tnext_block_number.\n\nFrom-SVN: r32228", "tree": {"sha": "c60c5f52d93613b9b8942daef3cae9ee63895c8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c60c5f52d93613b9b8942daef3cae9ee63895c8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18c038b9ca6f4e60c625636506cfe5a3290475a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c038b9ca6f4e60c625636506cfe5a3290475a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c038b9ca6f4e60c625636506cfe5a3290475a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c038b9ca6f4e60c625636506cfe5a3290475a9/comments", "author": null, "committer": null, "parents": [{"sha": "8181bf427b0f5b094bf402e03304d66c64cdaf68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8181bf427b0f5b094bf402e03304d66c64cdaf68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8181bf427b0f5b094bf402e03304d66c64cdaf68"}], "stats": {"total": 388, "additions": 229, "deletions": 159}, "files": [{"sha": "d77780484d0ef1e0ab6d1ba5a72fdeffbdc1cd6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -1,3 +1,50 @@\n+2000-02-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* emit-rtl.c (remove_unncessary_notes): Remove notes for empty\n+\tblocks.\n+\t* final.c (next_block_index): Remove.\n+\t(max_block_depth): Likewise.\n+\t(pending_blocks): Likewise.\n+\t(init_final): Don't initialize them.\n+\t(final_start_function): Don't set next_block_index.  Set up\n+\tBLOCK_NUMBER.\n+\t(final_scan_insn): Use BLOCK_NUMBER, not next_block_index.\n+\t* function.h (number_blocks): New function.\n+\t* function.c (get_block_vector): New function.\n+\t(identify_blocks): Use it.\n+\t(reorder_blocks): Set NOTE_BLOCK.\n+\t(number_blocks): New function.\n+\t* tree.def (BLOCK): Add documentation for TREE_ASM_WRITTEN flag.\n+\t* tree.h (BLOCK_NUMBER): New macro.\n+\t(tree_block): Add block_num field.\n+\t* dbxout.c (next_block_number): Remove.\n+\t(dbxout_init): Don't set it.\n+\t(dbxout_block): Only output blocks that have TREE_ASM_WRITTEN\n+\tset.  Use BLOCK_NUMBER, rather than next_block_num, to determine\n+\tblock numbers.\n+\t* toplev.c (rest_of_compilation): Always call\n+\tfind_loop_tree_blocks.  Fix indentation.\n+\t* dwarf2out.c (next_block_number): Remove.\n+\t(gen_lexical_block_die): Use BLOCK_NUMBER, not next_block_number,\n+\tto determine block numbers.\n+\t(gen_inlined_subroutine_die): Likewise.\n+\t(gen_block_die): Only output blocks that have TREE_ASM_WRITTEN set.\n+\t(decls_for_scope): Don't increment next_block_number.\n+\t* dwarfout.c (next_block_number): Remove.\n+\t(output_lexical_block_die): Use BLOCK_NUMBER, not next_block_number,\n+\tto determine block numbers. \n+\t(output_inlined_subroutine_die): Likewise.\n+\t(output_block): Only output blocks that have TREE_ASM_WRITTEN set.\n+\t(output_decls_for_scope): Don't increment next_block_number.\n+\t* sdbout.c (next_block_number): Remove.\n+\t(sdbout_block): Use BLOCK_NUMBER.\n+\t(sdbout_begin_block): Simplify.\n+\t* xcoffout.c (next_block_number): Remove.\n+\t(xcoffout_block): Use BLOCK_NUMBER, not next_block_number.\n+\t(xcoffout_begin_block): Don't set next_block_number.\n+\t(xcoffout_begin_function): Likewise. Use BLOCK_NUMBER, not\n+\tnext_block_number.\n+\t\n Sun Feb 27 16:40:33 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* builtins.c (c_strlen): Use size_diffop and return ssizetype value."}, {"sha": "c09b31835dfb54f807602e75710684afc2196d09", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -273,16 +273,6 @@ static int next_file_number;\n \n #endif /* DBX_USE_BINCL */\n \n-/* In dbx output, we must assign symbol-blocks id numbers\n-   in the order in which their beginnings are encountered.\n-   We output debugging info that refers to the beginning and\n-   end of the ranges of code in each block\n-   with assembler labels LBBn and LBEn, where n is the block number.\n-   The labels are generated in final, which assigns numbers to the\n-   blocks in the same way.  */\n-\n-static int next_block_number;\n-\n /* These variables are for dbxout_symbol to communicate to\n    dbxout_finish_symbol.\n    current_sym_code is the symbol-type-code, a symbol N_... define in stab.h.\n@@ -437,7 +427,6 @@ dbxout_init (asm_file, input_file_name, syms)\n   lastfile = input_file_name;\n \n   next_type_number = 1;\n-  next_block_number = 2;\n \n #ifdef DBX_USE_BINCL\n   current_file = (struct dbx_file *) xmalloc (sizeof *current_file);\n@@ -2630,7 +2619,7 @@ dbxout_block (block, depth, args)\n   while (block)\n     {\n       /* Ignore blocks never expanded or otherwise marked as real.  */\n-      if (TREE_USED (block))\n+      if (TREE_USED (block) && TREE_ASM_WRITTEN (block))\n \t{\n #ifndef DBX_LBRAC_FIRST\n \t  /* In dbx format, the syms of a block come before the N_LBRAC.  */\n@@ -2647,7 +2636,7 @@ dbxout_block (block, depth, args)\n \t  if (depth > 0 && debug_info_level != DINFO_LEVEL_TERSE)\n \t    {\n \t      char buf[20];\n-\t      blocknum = next_block_number++;\n+\t      blocknum = BLOCK_NUMBER (block);\n \t      ASM_GENERATE_INTERNAL_LABEL (buf, \"LBB\", blocknum);\n \n \t      if (BLOCK_HANDLER_BLOCK (block))\n@@ -2680,9 +2669,6 @@ dbxout_block (block, depth, args)\n \t      fprintf (asmfile, \"\\n\");\n #endif\n \t    }\n-\t  else if (depth > 0)\n-\t    /* Count blocks the same way regardless of debug_info_level.  */\n-\t    next_block_number++;\n \n #ifdef DBX_LBRAC_FIRST\n \t  /* On some weird machines, the syms of a block"}, {"sha": "aa1600aa7b152be7e20fbba6c96abacad81ab557", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -2202,13 +2202,6 @@ static unsigned file_table_in_use;\n    dwarf2out_init.  */\n static char *primary_filename;\n \n-/* For Dwarf output, we must assign lexical-blocks id numbers in the order in\n-   which their beginnings are encountered. We output Dwarf debugging info\n-   that refers to the beginnings and ends of the ranges of code for each\n-   lexical block.  The labels themselves are generated in final.c, which\n-   assigns numbers to the blocks in the same way.  */\n-static unsigned next_block_number = 2;\n-\n /* A pointer to the base of a table of references to DIE's that describe\n    declarations.  The table is indexed by DECL_UID() which is a unique\n    number identifying each decl.  */\n@@ -8534,9 +8527,10 @@ gen_lexical_block_die (stmt, context_die, depth)\n   if (! BLOCK_ABSTRACT (stmt))\n     {\n       ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n-\t\t\t\t   next_block_number);\n+\t\t\t\t   BLOCK_NUMBER (stmt));\n       add_AT_lbl_id (stmt_die, DW_AT_low_pc, label);\n-      ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_END_LABEL, next_block_number);\n+      ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_END_LABEL,\n+\t\t\t\t   BLOCK_NUMBER (stmt));\n       add_AT_lbl_id (stmt_die, DW_AT_high_pc, label);\n     }\n \n@@ -8563,9 +8557,10 @@ gen_inlined_subroutine_die (stmt, context_die, depth)\n \n       add_abstract_origin_attribute (subr_die, decl);\n       ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n-\t\t\t\t   next_block_number);\n+\t\t\t\t   BLOCK_NUMBER (stmt));\n       add_AT_lbl_id (subr_die, DW_AT_low_pc, label);\n-      ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_END_LABEL, next_block_number);\n+      ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_END_LABEL,\n+\t\t\t\t   BLOCK_NUMBER (stmt));\n       add_AT_lbl_id (subr_die, DW_AT_high_pc, label);\n       decls_for_scope (stmt, subr_die, depth);\n       current_function_has_inlines = 1;\n@@ -9154,7 +9149,7 @@ gen_block_die (stmt, context_die, depth)\n \n   /* Ignore blocks never really used to make RTL.  */\n \n-  if (stmt == NULL_TREE || !TREE_USED (stmt))\n+  if (stmt == NULL_TREE || !TREE_USED (stmt) || !TREE_ASM_WRITTEN (stmt))\n     return;\n \n   /* Determine the \"ultimate origin\" of this block.  This block may be an\n@@ -9237,9 +9232,6 @@ decls_for_scope (stmt, context_die, depth)\n   if (stmt == NULL_TREE || ! TREE_USED (stmt))\n     return;\n \n-  if (!BLOCK_ABSTRACT (stmt) && depth > 0)\n-    next_block_number++;\n-\n   /* Output the DIEs to represent all of the data objects and typedefs\n      declared directly within this block but not within any nested\n      sub-blocks.  Also, nested function and tag DIEs have been"}, {"sha": "08dc41cfdb7f855d22521e60805acd228f0b4c7f", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -195,16 +195,6 @@ static char *primary_filename;\n \n static char *last_filename;\n \n-/* For Dwarf output, we must assign lexical-blocks id numbers\n-   in the order in which their beginnings are encountered.\n-   We output Dwarf debugging info that refers to the beginnings\n-   and ends of the ranges of code for each lexical block with\n-   assembler labels ..Bn and ..Bn.e, where n is the block number.\n-   The labels themselves are generated in final.c, which assigns\n-   numbers to the blocks in the same way.  */\n-\n-static unsigned next_block_number = 2;\n-\n /* Counter to generate unique names for DIEs.  */\n \n static unsigned next_unused_dienum = 1;\n@@ -3601,9 +3591,9 @@ output_lexical_block_die (arg)\n       char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n       char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n-      sprintf (begin_label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n+      sprintf (begin_label, BLOCK_BEGIN_LABEL_FMT, BLOCK_NUMBER (stmt));\n       low_pc_attribute (begin_label);\n-      sprintf (end_label, BLOCK_END_LABEL_FMT, next_block_number);\n+      sprintf (end_label, BLOCK_END_LABEL_FMT, BLOCK_NUMBER (stmt));\n       high_pc_attribute (end_label);\n     }\n }\n@@ -3623,9 +3613,9 @@ output_inlined_subroutine_die (arg)\n       char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n       char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n-      sprintf (begin_label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n+      sprintf (begin_label, BLOCK_BEGIN_LABEL_FMT, BLOCK_NUMBER (stmt));\n       low_pc_attribute (begin_label);\n-      sprintf (end_label, BLOCK_END_LABEL_FMT, next_block_number);\n+      sprintf (end_label, BLOCK_END_LABEL_FMT, BLOCK_NUMBER (stmt));\n       high_pc_attribute (end_label);\n     }\n }\n@@ -4633,7 +4623,7 @@ output_block (stmt, depth)\n \n   /* Ignore blocks never really used to make RTL.  */\n \n-  if (! stmt || ! TREE_USED (stmt))\n+  if (! stmt || ! TREE_USED (stmt) || !TREE_ASM_WRITTEN (stmt))\n     return;\n \n   /* Determine the \"ultimate origin\" of this block.  This block may be an\n@@ -4725,9 +4715,6 @@ output_decls_for_scope (stmt, depth)\n   if (! stmt || ! TREE_USED (stmt))\n     return;\n \n-  if (! BLOCK_ABSTRACT (stmt) && depth > 0)\n-    next_block_number++;\n-\n   /* Output the DIEs to represent all of the data objects, functions,\n      typedefs, and tagged types declared directly within this block\n      but not within any nested sub-blocks.  */"}, {"sha": "c6e5cb1b7d23289027a00c8cd1e8db73a6ee5807", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -2681,6 +2681,48 @@ remove_unncessary_notes ()\n \n       if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n \tremove_insn (insn);\n+      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t{\n+\t  /* Scan back to see if there are any non-note instructions\n+\t     between INSN and the beginning of this block.  If not,\n+\t     then there is no PC range in the generated code that will\n+\t     actually be in this block, so there's no point in\n+\t     remembering the existence of the block.  */\n+\t  rtx prev;\n+\n+\t  for (prev = PREV_INSN (insn); prev; prev = PREV_INSN (prev))\n+\t    {\n+\t      /* This block contains a real instruction.  Note that we\n+\t\t don't include labels; if the only thing in the block\n+\t\t is a label, then there are still no PC values that\n+\t\t lie within the block.  */\n+\t      if (GET_RTX_CLASS (GET_CODE (prev)) == 'i')\n+\t\tbreak;\n+\n+\t      /* We're only interested in NOTEs.  */\n+\t      if (GET_CODE (prev) != NOTE)\n+\t\tcontinue;\n+\n+\t      if (NOTE_LINE_NUMBER (prev) == NOTE_INSN_BLOCK_BEG)\n+\t\t{\n+\t\t  /* If the BLOCKs referred to by these notes don't\n+\t\t     match, then something is wrong with our BLOCK\n+\t\t     nesting structure.  */\n+\t\t  if (NOTE_BLOCK (prev) != NOTE_BLOCK (insn))\n+\t\t    abort ();\n+\t\t  \n+\t\t  remove_insn (prev);\n+\t\t  remove_insn (insn);\n+\t\t  break;\n+\t\t}\n+\t      else if (NOTE_LINE_NUMBER (prev) == NOTE_INSN_BLOCK_END)\n+\t\t/* There's a nested block.  We need to leave the\n+\t\t   current block in place since otherwise the debugger\n+\t\t   wouldn't be able to show symbols from our block in\n+\t\t   the nested block.  */\n+\t\tbreak;\n+\t    }\n+\t}\n     }\n }\n "}, {"sha": "1346b37675f7709663e10baedcd13f6f77eef07f", "filename": "gcc/final.c", "status": "modified", "additions": 30, "deletions": 65, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -174,22 +174,6 @@ static rtx last_ignored_compare = 0;\n \n static int new_block = 1;\n \n-/* All the symbol-blocks (levels of scoping) in the compilation\n-   are assigned sequence numbers in order of appearance of the\n-   beginnings of the symbol-blocks.  Both final and dbxout do this,\n-   and assume that they will both give the same number to each block.\n-   Final uses these sequence numbers to generate assembler label names\n-   LBBnnn and LBEnnn for the beginning and end of the symbol-block.\n-   Dbxout uses the sequence numbers to generate references to the same labels\n-   from the dbx debugging information.\n-\n-   Sdb records this level at the beginning of each function,\n-   in order to find the current level when recursing down declarations.\n-   It outputs the block beginning and endings\n-   at the point in the asm file where the blocks would begin and end.  */\n-\n-int next_block_index;\n-\n /* Assign a unique number to each insn that is output.\n    This can be used to generate unique local labels.  */\n \n@@ -229,18 +213,7 @@ int frame_pointer_needed;\n \n int profile_label_no;\n \n-/* Length so far allocated in PENDING_BLOCKS.  */\n-\n-static int max_block_depth;\n-\n-/* Stack of sequence numbers of symbol-blocks of which we have seen the\n-   beginning but not yet the end.  Sequence numbers are assigned at\n-   the beginning; this stack allows us to find the sequence number\n-   of a block that is ending.  */\n-\n-static int *pending_blocks;\n-\n-/* Number of elements currently in use in PENDING_BLOCKS.  */\n+/* Number of unmatched NOTE_INSN_BLOCK_BEG notes we have seen.  */\n \n static int block_depth;\n \n@@ -320,10 +293,7 @@ void\n init_final (filename)\n      const char *filename ATTRIBUTE_UNUSED;\n {\n-  next_block_index = 2;\n   app_on = 0;\n-  max_block_depth = 20;\n-  pending_blocks = (int *) xmalloc (20 * sizeof *pending_blocks);\n   final_sequence = 0;\n \n #ifdef ASSEMBLER_DIALECT\n@@ -1667,16 +1637,23 @@ final_start_function (first, file, optimize)\n     dwarf2out_frame_debug (NULL_RTX);\n #endif\n \n+  /* If debugging, assign block numbers to all of the blocks in this\n+     function.  */\n+  if (write_symbols)\n+    {\n+      number_blocks (current_function_decl);\n+      remove_unncessary_notes ();\n+      /* We never actually put out begin/end notes for the top-level\n+\t block in the function.  But, conceptually, that block is\n+\t always needed.  */\n+      TREE_ASM_WRITTEN (DECL_INITIAL (current_function_decl)) = 1;\n+    }\n+\n #ifdef FUNCTION_PROLOGUE\n   /* First output the function prologue: code to set up the stack frame.  */\n   FUNCTION_PROLOGUE (file, get_frame_size ());\n #endif\n \n-#if defined (SDB_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n-  if (write_symbols == SDB_DEBUG || write_symbols == XCOFF_DEBUG)\n-    next_block_index = 1;\n-#endif\n-\n   /* If the machine represents the prologue as RTL, the profiling code must\n      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */\n #ifdef HAVE_prologue\n@@ -2174,81 +2151,69 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t      || write_symbols == DWARF_DEBUG\n \t      || write_symbols == DWARF2_DEBUG))\n \t{\n-\t  /* Beginning of a symbol-block.  Assign it a sequence number\n-\t     and push the number onto the stack PENDING_BLOCKS.  */\n-\n-\t  if (block_depth == max_block_depth)\n-\t    {\n-\t      /* PENDING_BLOCKS is full; make it longer.  */\n-\t      max_block_depth *= 2;\n-\t      pending_blocks\n-\t\t= (int *) xrealloc (pending_blocks,\n-\t\t\t\t    max_block_depth * sizeof (int));\n-\t    }\n-\t  pending_blocks[block_depth++] = next_block_index;\n+\t  int n = BLOCK_NUMBER (NOTE_BLOCK (insn));\n \n+\t  ++block_depth;\n \t  high_block_linenum = last_linenum;\n \n \t  /* Output debugging info about the symbol-block beginning.  */\n-\n #ifdef SDB_DEBUGGING_INFO\n \t  if (write_symbols == SDB_DEBUG)\n-\t    sdbout_begin_block (file, last_linenum, next_block_index);\n+\t    sdbout_begin_block (file, last_linenum, n);\n #endif\n #ifdef XCOFF_DEBUGGING_INFO\n \t  if (write_symbols == XCOFF_DEBUG)\n-\t    xcoffout_begin_block (file, last_linenum, next_block_index);\n+\t    xcoffout_begin_block (file, last_linenum, n);\n #endif\n #ifdef DBX_DEBUGGING_INFO\n \t  if (write_symbols == DBX_DEBUG)\n-\t    ASM_OUTPUT_INTERNAL_LABEL (file, \"LBB\", next_block_index);\n+\t    ASM_OUTPUT_INTERNAL_LABEL (file, \"LBB\", n);\n #endif\n #ifdef DWARF_DEBUGGING_INFO\n \t  if (write_symbols == DWARF_DEBUG)\n-\t    dwarfout_begin_block (next_block_index);\n+\t    dwarfout_begin_block (n);\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n \t  if (write_symbols == DWARF2_DEBUG)\n-\t    dwarf2out_begin_block (next_block_index);\n+\t    dwarf2out_begin_block (n);\n #endif\n \n-\t  next_block_index++;\n+\t  /* Mark this block as output.  */\n+\t  TREE_ASM_WRITTEN (NOTE_BLOCK (insn)) = 1;\n \t}\n       else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END\n \t       && (debug_info_level == DINFO_LEVEL_NORMAL\n \t\t   || debug_info_level == DINFO_LEVEL_VERBOSE\n \t           || write_symbols == DWARF_DEBUG\n \t           || write_symbols == DWARF2_DEBUG))\n \t{\n-\t  /* End of a symbol-block.  Pop its sequence number off\n-\t     PENDING_BLOCKS and output debugging info based on that.  */\n+\t  int n = BLOCK_NUMBER (NOTE_BLOCK (insn));\n+\n+\t  /* End of a symbol-block.  */\n \n \t  --block_depth;\n \t  if (block_depth < 0)\n \t    abort ();\n \n #ifdef XCOFF_DEBUGGING_INFO\n \t  if (write_symbols == XCOFF_DEBUG)\n-\t    xcoffout_end_block (file, high_block_linenum,\n-\t\t\t\tpending_blocks[block_depth]);\n+\t    xcoffout_end_block (file, high_block_linenum, n);\n #endif\n #ifdef DBX_DEBUGGING_INFO\n \t  if (write_symbols == DBX_DEBUG)\n-\t    ASM_OUTPUT_INTERNAL_LABEL (file, \"LBE\",\n-\t\t\t\t       pending_blocks[block_depth]);\n+\t    ASM_OUTPUT_INTERNAL_LABEL (file, \"LBE\", n);\n #endif\n #ifdef SDB_DEBUGGING_INFO\n \t  if (write_symbols == SDB_DEBUG)\n-\t    sdbout_end_block (file, high_block_linenum,\n-\t\t\t      pending_blocks[block_depth]);\n+\t    sdbout_end_block (file, high_block_linenum, n);\n #endif\n #ifdef DWARF_DEBUGGING_INFO\n \t  if (write_symbols == DWARF_DEBUG)\n-\t    dwarfout_end_block (pending_blocks[block_depth]);\n+\t    dwarfout_end_block (n);\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n \t  if (write_symbols == DWARF2_DEBUG)\n-\t    dwarf2out_end_block (pending_blocks[block_depth]);\n+\t    dwarf2out_end_block (n);\n #endif\n \t}\n       else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL"}, {"sha": "ce5fef21e29aaee9c50f203d50ee8b87def0cb6d", "filename": "gcc/function.c", "status": "modified", "additions": 70, "deletions": 14, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -268,6 +268,7 @@ static tree round_down\t\tPARAMS ((tree, int));\n static rtx round_trampoline_addr PARAMS ((rtx));\n static tree blocks_nreverse\tPARAMS ((tree));\n static int all_blocks\t\tPARAMS ((tree, tree *));\n+static tree *get_block_vector   PARAMS ((tree, int *));\n /* We always define `record_insns' even if its not used so that we\n    can always export `prologue_epilogue_contains'.  */\n static int *record_insns\tPARAMS ((rtx)) ATTRIBUTE_UNUSED;\n@@ -5489,10 +5490,7 @@ identify_blocks (block, insns)\n \n   /* Fill the BLOCK_VECTOR with all of the BLOCKs in this function, in\n      depth-first order.  */\n-  n_blocks = all_blocks (block, 0);\n-  block_vector = (tree *) xmalloc (n_blocks * sizeof (tree));\n-  all_blocks (block, block_vector);\n-\n+  block_vector = get_block_vector (block, &n_blocks);\n   block_stack = (tree *) xmalloc (n_blocks * sizeof (tree));\n \n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n@@ -5522,12 +5520,6 @@ identify_blocks (block, insns)\n \t  }\n       }\n \n-  /* In whole-function mode, we might not have seen the whole function\n-     yet, so we might not use up all the blocks.  */\n-  if (n_blocks != current_block_number \n-      && !cfun->x_whole_function_mode_p)\n-    abort ();\n-\n   free (block_vector);\n   free (block_stack);\n }\n@@ -5544,10 +5536,13 @@ reorder_blocks (block, insns)\n {\n   tree current_block = block;\n   rtx insn;\n+  varray_type block_stack;\n \n   if (block == NULL_TREE)\n     return NULL_TREE;\n \n+  VARRAY_TREE_INIT (block_stack, 10, \"block_stack\");\n+\n   /* Prune the old trees away, so that it doesn't get in the way.  */\n   BLOCK_SUBBLOCKS (current_block) = 0;\n   BLOCK_CHAIN (current_block) = 0;\n@@ -5560,16 +5555,22 @@ reorder_blocks (block, insns)\n \t    tree block = NOTE_BLOCK (insn);\n \t    /* If we have seen this block before, copy it.  */\n \t    if (TREE_ASM_WRITTEN (block))\n-\t      block = copy_node (block);\n+\t      {\n+\t\tblock = copy_node (block);\n+\t\tNOTE_BLOCK (insn) = block;\n+\t      }\n \t    BLOCK_SUBBLOCKS (block) = 0;\n \t    TREE_ASM_WRITTEN (block) = 1;\n \t    BLOCK_SUPERCONTEXT (block) = current_block; \n \t    BLOCK_CHAIN (block) = BLOCK_SUBBLOCKS (current_block);\n \t    BLOCK_SUBBLOCKS (current_block) = block;\n \t    current_block = block;\n+\t    VARRAY_PUSH_TREE (block_stack, block);\n \t  }\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\telse if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n \t  {\n+\t    NOTE_BLOCK (insn) = VARRAY_TOP_TREE (block_stack);\n+\t    VARRAY_POP (block_stack);\n \t    BLOCK_SUBBLOCKS (current_block)\n \t      = blocks_nreverse (BLOCK_SUBBLOCKS (current_block));\n \t    current_block = BLOCK_SUPERCONTEXT (current_block);\n@@ -5578,6 +5579,9 @@ reorder_blocks (block, insns)\n \n   BLOCK_SUBBLOCKS (current_block)\n     = blocks_nreverse (BLOCK_SUBBLOCKS (current_block));\n+\n+  VARRAY_FREE (block_stack);\n+\n   return current_block;\n }\n \n@@ -5598,8 +5602,9 @@ blocks_nreverse (t)\n   return prev;\n }\n \n-/* Count the subblocks of the list starting with BLOCK, and list them\n-   all into the vector VECTOR.  Also clear TREE_ASM_WRITTEN in all\n+/* Count the subblocks of the list starting with BLOCK.  If VECTOR is\n+   non-NULL, list them all into VECTOR, in a depth-first preorder\n+   traversal of the block tree.  Also clear TREE_ASM_WRITTEN in all\n    blocks.  */\n \n static int\n@@ -5627,6 +5632,57 @@ all_blocks (block, vector)\n \n   return n_blocks;\n }\n+\n+/* Return a vector containing all the blocks rooted at BLOCK.  The\n+   number of elements in the vector is stored in N_BLOCKS_P.  The\n+   vector is dynamically allocated; it is the caller's responsibility\n+   to call `free' on the pointer returned.  */\n+  \n+static tree *\n+get_block_vector (block, n_blocks_p)\n+     tree block;\n+     int *n_blocks_p;\n+{\n+  tree *block_vector;\n+\n+  *n_blocks_p = all_blocks (block, NULL);\n+  block_vector = (tree *) xmalloc (*n_blocks_p * sizeof (tree));\n+  all_blocks (block, block_vector);\n+\n+  return block_vector;\n+}\n+\n+static int next_block_index = 2;\n+\n+/* Set BLOCK_NUMBER for all the blocks in FN.  */\n+\n+void\n+number_blocks (fn)\n+     tree fn;\n+{\n+  int i;\n+  int n_blocks;\n+  tree *block_vector;\n+\n+  /* For SDB and XCOFF debugging output, we start numbering the blocks\n+     from 1 within each function, rather than keeping a running\n+     count.  */\n+#if defined (SDB_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n+  next_block_index = 1;\n+#endif\n+\n+  block_vector = get_block_vector (DECL_INITIAL (fn), &n_blocks);\n+\n+  /* The top-level BLOCK isn't numbered at all.  */\n+  for (i = 1; i < n_blocks; ++i)\n+    /* We number the blocks from two.  */\n+    BLOCK_NUMBER (block_vector[i]) = next_block_index++;\n+\n+  free (block_vector);\n+\n+  return;\n+}\n+\n \f\n /* Allocate a function structure and reset its contents to the defaults.  */\n static void"}, {"sha": "fb3ef497563345a61f689ce6a2cd899ee64961da", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -548,6 +548,9 @@ extern struct function *outer_function_chain;\n    the index of that block in the vector.  */\n extern void identify_blocks PARAMS ((tree, rtx));\n \n+/* Set BLOCK_NUMBER for all the blocks in FN.  */\n+extern void number_blocks PARAMS ((tree));\n+\n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to STACK_BOUNDARY;\n    the caller may have to do that.  */"}, {"sha": "5f6b01b22a9cc31c4bfd88faf03a50787b4d3088", "filename": "gcc/sdbout.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -679,15 +679,12 @@ plain_type_1 (type, level)\n }\n \f\n /* Output the symbols defined in block number DO_BLOCK.\n-   Set NEXT_BLOCK_NUMBER to 0 before calling.\n \n    This function works by walking the tree structure of blocks,\n    counting blocks until it finds the desired block.  */\n \n static int do_block = 0;\n \n-static int next_block_number;\n-\n static void\n sdbout_block (block)\n      register tree block;\n@@ -698,17 +695,13 @@ sdbout_block (block)\n       if (TREE_USED (block))\n \t{\n \t  /* When we reach the specified block, output its symbols.  */\n-\t  if (next_block_number == do_block)\n-\t    {\n-\t      sdbout_syms (BLOCK_VARS (block));\n-\t    }\n+\t  if (BLOCK_NUMBER (block) == do_block)\n+\t    sdbout_syms (BLOCK_VARS (block));\n \n \t  /* If we are past the specified block, stop the scan.  */\n-\t  if (next_block_number > do_block)\n+\t  if (BLOCK_NUMBER (block) > do_block)\n \t    return;\n \n-\t  next_block_number++;\n-\n \t  /* Scan the blocks within this block.  */\n \t  sdbout_block (BLOCK_SUBBLOCKS (block));\n \t}\n@@ -1546,15 +1539,13 @@ sdbout_begin_block (file, line, n)\n   if (n == 1)\n     {\n       /* Include the outermost BLOCK's variables in block 1.  */\n-      next_block_number = 0;\n-      do_block = 0;\n+      do_block = BLOCK_NUMBER (DECL_INITIAL (decl));\n       sdbout_block (DECL_INITIAL (decl));\n     }\n   /* If -g1, suppress all the internal symbols of functions\n      except for arguments.  */\n   if (debug_info_level != DINFO_LEVEL_TERSE)\n     {\n-      next_block_number = 0;\n       do_block = n;\n       sdbout_block (DECL_INITIAL (decl));\n     }"}, {"sha": "c8319f8d9b3756febdd0b3a63db12060a9706ac9", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -2842,13 +2842,13 @@ rest_of_compilation (decl)\n      collector to reclaim the memory used by the notes.  */\n   remove_unncessary_notes ();\n \n+  /* We need to make sure that NOTE_BLOCK is set correctly\n+     for each NOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END note.  */\n+  find_loop_tree_blocks ();\n   /* In function-at-a-time mode, we do not attempt to keep the BLOCK\n      tree in sensible shape.  So, we just recalculate it here.  */\n   if (cfun->x_whole_function_mode_p)\n-    {\n-      find_loop_tree_blocks ();\n-      unroll_block_trees ();\n-    }\n+    unroll_block_trees ();\n \n   /* If we are reconsidering an inline function\n      at the end of compilation, skip the stuff for making it inline.  */\n@@ -3705,8 +3705,8 @@ rest_of_compilation (decl)\n \t     regset_release_memory ();\n \t   });\n \n-   if (ggc_p)\n-     ggc_collect ();\n+  if (ggc_p)\n+    ggc_collect ();\n \n   /* Write DBX symbols if requested */\n "}, {"sha": "551d5cb17582cb52705fcb687b313e639b36b548", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -1,6 +1,6 @@\n /* This file contains the definitions and documentation for the\n    tree codes used in the GNU C compiler.\n-   Copyright (C) 1987, 1988, 1993, 1995, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1993, 1995, 1997, 1998, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -82,7 +82,9 @@ DEFTREECODE (TREE_VEC, \"tree_vec\", 'x', 2)\n    outermost scope of a particular inlining of a function).\n    BLOCK_ABSTRACT is non-zero if the block represents an abstract\n    instance of a block (i.e. one which is nested within an abstract\n-   instance of an inline function). */\n+   instance of an inline function). \n+   TREE_ASM_WRITTEN is non-zero if the block was actually referenced\n+   in the generated assembly.  */\n DEFTREECODE (BLOCK, \"block\", 'b', 0)\n \f\n /* Each data type is represented by a tree node whose code is one of"}, {"sha": "c472e307685191fb3e3754d7d6c264eb61f6f649", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -797,12 +797,18 @@ struct tree_exp\n    listed in the BLOCK_VARS slot.  */\n #define BLOCK_HANDLER_BLOCK(NODE) (BLOCK_CHECK (NODE)->block.handler_block_flag)\n \n+/* An index number for this block.  These values are not guaranteed to\n+   be unique across functions -- whether or not they are depends on\n+   the debugging output format in use.  */\n+#define BLOCK_NUMBER(NODE) (BLOCK_CHECK (NODE)->block.block_num)\n+\n struct tree_block\n {\n   char common[sizeof (struct tree_common)];\n \n   unsigned handler_block_flag : 1;\n   unsigned abstract_flag : 1;\n+  unsigned block_num : 30;\n \n   union tree_node *vars;\n   union tree_node *subblocks;"}, {"sha": "2857af4f492a4df9753d22367fd2233a35547f97", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c038b9ca6f4e60c625636506cfe5a3290475a9/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=18c038b9ca6f4e60c625636506cfe5a3290475a9", "patch": "@@ -375,15 +375,12 @@ xcoffout_source_line (file, filename, note)\n }\n \f\n /* Output the symbols defined in block number DO_BLOCK.\n-   Set NEXT_BLOCK_NUMBER to 0 before calling.\n \n    This function works by walking the tree structure of blocks,\n    counting blocks until it finds the desired block.  */\n \n static int do_block = 0;\n \n-static int next_block_number;\n-\n static void\n xcoffout_block (block, depth, args)\n      register tree block;\n@@ -396,7 +393,7 @@ xcoffout_block (block, depth, args)\n       if (TREE_USED (block))\n \t{\n \t  /* When we reach the specified block, output its symbols.  */\n-\t  if (next_block_number == do_block)\n+\t  if (BLOCK_NUMBER (block) == do_block)\n \t    {\n \t      /* Output the syms of the block.  */\n \t      if (debug_info_level != DINFO_LEVEL_TERSE || depth == 0)\n@@ -408,11 +405,9 @@ xcoffout_block (block, depth, args)\n \t      return;\n \t    }\n \t  /* If we are past the specified block, stop the scan.  */\n-\t  else if (next_block_number >= do_block)\n+\t  else if (BLOCK_NUMBER (block) >= do_block)\n \t    return;\n \n-\t  next_block_number++;\n-\n \t  /* Output the subblocks.  */\n \t  xcoffout_block (BLOCK_SUBBLOCKS (block), depth + 1, NULL_TREE);\n \t}\n@@ -443,7 +438,6 @@ xcoffout_begin_block (file, line, n)\n     ASM_OUTPUT_LBB (file, line, n);\n \n   do_block = n;\n-  next_block_number = 0;\n   xcoffout_block (DECL_INITIAL (decl), 0, DECL_ARGUMENTS (decl));\n }\n \n@@ -513,8 +507,7 @@ xcoffout_begin_function (file, last_linenum)\n      in sdbout_begin_block, but there is no guarantee that there will be any\n      inner block 1, so we must do it here.  This gives a result similar to\n      dbxout, so it does make some sense.  */\n-  do_block = 0;\n-  next_block_number = 0;\n+  do_block = BLOCK_NUMBER (DECL_INITIAL (decl));\n   xcoffout_block (DECL_INITIAL (current_function_decl), 0,\n \t\t  DECL_ARGUMENTS (current_function_decl));\n "}]}