{"sha": "fac0ad800a96280835d6eb5310d6c99fc5148d7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFjMGFkODAwYTk2MjgwODM1ZDZlYjUzMTBkNmM5OWZjNTE0OGQ3Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-15T13:31:09Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-15T13:31:09Z"}, "message": "(emit_library_call_value): Finish making it work.\n\nFrom-SVN: r5326", "tree": {"sha": "4cb18941e506f56998bd6baee0c301c950d305ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cb18941e506f56998bd6baee0c301c950d305ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fac0ad800a96280835d6eb5310d6c99fc5148d7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac0ad800a96280835d6eb5310d6c99fc5148d7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fac0ad800a96280835d6eb5310d6c99fc5148d7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac0ad800a96280835d6eb5310d6c99fc5148d7f/comments", "author": null, "committer": null, "parents": [{"sha": "f70ad14cb484fe7388cbafc6d38dc04a08a71ac9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70ad14cb484fe7388cbafc6d38dc04a08a71ac9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f70ad14cb484fe7388cbafc6d38dc04a08a71ac9"}], "stats": {"total": 99, "additions": 65, "deletions": 34}, "files": [{"sha": "e76412c6f75a7ca6cc3a345f62765e689e09510e", "filename": "gcc/calls.c", "status": "modified", "additions": 65, "deletions": 34, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac0ad800a96280835d6eb5310d6c99fc5148d7f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac0ad800a96280835d6eb5310d6c99fc5148d7f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=fac0ad800a96280835d6eb5310d6c99fc5148d7f", "patch": "@@ -2294,9 +2294,13 @@ emit_library_call (va_alist)\n \f\n /* Like emit_library_call except that an extra argument, VALUE,\n    comes second and says where to store the result.\n-   (If VALUE is zero, the result comes in the function value register.)  */\n+   (If VALUE is zero, this function chooses a convenient way\n+   to return the value.\n \n-void\n+   This function returns an rtx for where the value is to be found.\n+   If VALUE is nonzero, VALUE is returned.  */\n+\n+rtx\n emit_library_call_value (va_alist)\n      va_dcl\n {\n@@ -2322,6 +2326,7 @@ emit_library_call_value (va_alist)\n   rtx use_insns;\n   rtx value;\n   rtx mem_value = 0;\n+  int pcc_struct_value = 0;\n   /* library calls are never indirect calls.  */\n   int current_call_is_indirect = 0;\n \n@@ -2334,12 +2339,22 @@ emit_library_call_value (va_alist)\n \n   /* If this kind of value comes back in memory,\n      decide where in memory it should come back.  */\n-  if (RETURN_IN_MEMORY (type_for_mode (outmode, 0)))\n+  if (aggregate_value_p (type_for_mode (outmode, 0)))\n     {\n-      if (GET_CODE (value) == MEM)\n+#ifdef PCC_STATIC_STRUCT_RETURN\n+      rtx pointer_reg\n+\t= hard_function_value (build_pointer_type (type_for_mode (outmode, 0)),\n+\t\t\t       0);\n+      mem_value = gen_rtx (MEM, outmode, pointer_reg);\n+      pcc_struct_value = 1;\n+      if (value == 0)\n+\tvalue = gen_reg_rtx (outmode);\n+#else /* not PCC_STATIC_STRUCT_RETURN */\n+      if (value != 0 && GET_CODE (value) == MEM)\n \tmem_value = value;\n       else\n \tmem_value = assign_stack_temp (outmode, GET_MODE_SIZE (outmode), 0);\n+#endif\n     }\n \n   /* ??? Unfinished: must pass the memory address as an argument.  */\n@@ -2362,44 +2377,42 @@ emit_library_call_value (va_alist)\n \n   /* If there's a structure value address to be passed,\n      either pass it in the special place, or pass it as an extra argument.  */\n-  if (mem_value)\n+  if (mem_value && struct_value_rtx == 0 && ! pcc_struct_value)\n     {\n       rtx addr = XEXP (mem_value, 0);\n+      nargs++;\n \n-      if (! struct_value_rtx)\n-\t{\n-\t  nargs++;\n-\n-\t  /* Make sure it is a reasonable operand for a move or push insn.  */\n-\t  if (GET_CODE (addr) != REG && GET_CODE (addr) != MEM\n-\t      && ! (CONSTANT_P (addr) && LEGITIMATE_CONSTANT_P (addr)))\n-\t    addr = force_operand (addr, NULL_RTX);\n+      /* Make sure it is a reasonable operand for a move or push insn.  */\n+      if (GET_CODE (addr) != REG && GET_CODE (addr) != MEM\n+\t  && ! (CONSTANT_P (addr) && LEGITIMATE_CONSTANT_P (addr)))\n+\taddr = force_operand (addr, NULL_RTX);\n \n-\t  argvec[count].value = addr;\n-\t  argvec[count].mode = outmode;\n-\t  argvec[count].partial = 0;\n+      argvec[count].value = addr;\n+      argvec[count].mode = outmode;\n+      argvec[count].partial = 0;\n \n-\t  argvec[count].reg = FUNCTION_ARG (args_so_far, outmode, NULL_TREE, 1);\n+      argvec[count].reg = FUNCTION_ARG (args_so_far, outmode, NULL_TREE, 1);\n #ifdef FUNCTION_ARG_PARTIAL_NREGS\n-\t  if (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, outmode, NULL_TREE, 1))\n-\t    abort ();\n+      if (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, outmode, NULL_TREE, 1))\n+\tabort ();\n #endif\n \n-\t  locate_and_pad_parm (outmode, NULL_TREE,\n-\t\t\t       argvec[count].reg && argvec[count].partial == 0,\n-\t\t\t       NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t       &argvec[count].size);\n+      locate_and_pad_parm (outmode, NULL_TREE,\n+\t\t\t   argvec[count].reg && argvec[count].partial == 0,\n+\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n+\t\t\t   &argvec[count].size);\n \n \n-\t  if (argvec[count].reg == 0 || argvec[count].partial != 0\n+      if (argvec[count].reg == 0 || argvec[count].partial != 0\n #ifdef REG_PARM_STACK_SPACE\n-\t      || 1\n+\t  || 1\n #endif\n-\t      )\n-\t    args_size.constant += argvec[count].size.constant;\n+\t  )\n+\targs_size.constant += argvec[count].size.constant;\n \n-\t  FUNCTION_ARG_ADVANCE (args_so_far, outmode, (tree)0, 1);\n-\t}\n+      FUNCTION_ARG_ADVANCE (args_so_far, outmode, (tree)0, 1);\n+\n+      count++;\n     }\n \n   for (; count < nargs; count++)\n@@ -2562,9 +2575,6 @@ emit_library_call_value (va_alist)\n \n   /* Now load any reg parms into their regs.  */\n \n-  if (mem_value != 0 && struct_value_rtx != 0)\n-    emit_move_insn (struct_value_rtx, XEXP (mem_value, 0));\n-\n   for (count = 0; count < nargs; count++, argnum += inc)\n     {\n       register enum machine_mode mode = argvec[argnum].mode;\n@@ -2592,6 +2602,22 @@ emit_library_call_value (va_alist)\n   use_insns = get_insns ();\n   end_sequence ();\n \n+  /* Pass the function the address in which to return a structure value.  */\n+  if (mem_value != 0 && struct_value_rtx != 0 && ! pcc_struct_value)\n+    {\n+      emit_move_insn (struct_value_rtx,\n+\t\t      force_reg (Pmode,\n+\t\t\t\t force_operand (XEXP (mem_value, 0),\n+\t\t\t\t\t\tNULL_RTX)));\n+      if (GET_CODE (struct_value_rtx) == REG)\n+\t{\n+\t  push_to_sequence (use_insns);\n+\t  emit_insn (gen_rtx (USE, VOIDmode, struct_value_rtx));\n+\t  use_insns = get_insns ();\n+\t  end_sequence ();\n+\t}\n+    }\n+\n   fun = prepare_call_address (fun, NULL_TREE, &use_insns);\n \n   /* Don't allow popping to be deferred, since then\n@@ -2603,7 +2629,8 @@ emit_library_call_value (va_alist)\n \n   emit_call_1 (fun, get_identifier (XSTR (orgfun, 0)), args_size.constant, 0,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n-\t       outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n+\t       (outmode != VOIDmode && mem_value == 0\n+\t\t? hard_libcall_value (outmode) : NULL_RTX),\n \t       old_inhibit_defer_pop + 1, use_insns, no_queue);\n \n   /* Now restore inhibit_defer_pop to its actual original value.  */\n@@ -2615,13 +2642,17 @@ emit_library_call_value (va_alist)\n       if (mem_value)\n \t{\n \t  if (value == 0)\n-\t    value = hard_libcall_value (outmode);\n+\t    value = mem_value;\n \t  if (value != mem_value)\n \t    emit_move_insn (value, mem_value);\n \t}\n       else if (value != 0)\n \temit_move_insn (value, hard_libcall_value (outmode));\n+      else\n+\tvalue = hard_libcall_value (outmode);\n     }\n+\n+  return value;\n }\n \f\n #if 0"}]}