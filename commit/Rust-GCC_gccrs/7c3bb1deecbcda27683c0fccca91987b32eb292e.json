{"sha": "7c3bb1deecbcda27683c0fccca91987b32eb292e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MzYmIxZGVlY2JjZGEyNzY4M2MwZmNjY2E5MTk4N2IzMmViMjkyZQ==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-04-02T22:12:14Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-04-02T22:12:14Z"}, "message": "cppexp.c: New typedef op_t.\n\n\t* cppexp.c:  New typedef op_t.  struct operation and struct\n\ttoken updated to use it.\n\t(op_to_str): New function.\n\t(_cpp_parse_expr): Error messages modified to use op_to_str.\n\nFrom-SVN: r32869", "tree": {"sha": "c07bff86eb0aa101cac0e15fb95788b4f2bea702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c07bff86eb0aa101cac0e15fb95788b4f2bea702"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c3bb1deecbcda27683c0fccca91987b32eb292e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3bb1deecbcda27683c0fccca91987b32eb292e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c3bb1deecbcda27683c0fccca91987b32eb292e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3bb1deecbcda27683c0fccca91987b32eb292e/comments", "author": null, "committer": null, "parents": [{"sha": "a7862cf746cd632e4ef12a008e6a4eed743bbcaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7862cf746cd632e4ef12a008e6a4eed743bbcaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7862cf746cd632e4ef12a008e6a4eed743bbcaf"}], "stats": {"total": 57, "additions": 43, "deletions": 14}, "files": [{"sha": "099177cc95473addba1ab470634c4588b86bd2f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3bb1deecbcda27683c0fccca91987b32eb292e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3bb1deecbcda27683c0fccca91987b32eb292e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c3bb1deecbcda27683c0fccca91987b32eb292e", "patch": "@@ -1,3 +1,10 @@\n+2000-04-02  Neil Booth <NeilB@earthling.net>\n+\n+\t* cppexp.c:  New typedef op_t.  struct operation and struct \n+\ttoken updated to use it.\n+\t(op_to_str): New function.\n+\t(_cpp_parse_expr): Error messages modified to use op_to_str.\n+\n 2000-04-02  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.c (c4x_function_arg): Check for void_type_node"}, {"sha": "a2c60b71935a7a8f29a31982a165bc5e4af12846", "filename": "gcc/cppexp.c", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3bb1deecbcda27683c0fccca91987b32eb292e/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3bb1deecbcda27683c0fccca91987b32eb292e/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=7c3bb1deecbcda27683c0fccca91987b32eb292e", "patch": "@@ -73,6 +73,8 @@ Written by Per Bothner 1994.  */\n    number with SUM's sign, where A, B, and SUM are all C integers.  */\n #define possible_sum_sign(a, b, sum) ((((a) ^ (b)) | ~ ((a) ^ (sum))) < 0)\n \n+typedef short op_t;\n+\n static void integer_overflow PARAMS ((cpp_reader *));\n static HOST_WIDEST_INT left_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n \t\t\t\t\t   unsigned int,\n@@ -88,7 +90,7 @@ static struct operation parse_defined PARAMS ((cpp_reader *));\n static HOST_WIDEST_INT parse_escape PARAMS ((cpp_reader *, U_CHAR **,\n \t\t\t\t\t     HOST_WIDEST_INT));\n static struct operation lex PARAMS ((cpp_reader *, int));\n-\n+static const char * op_to_str PARAMS ((op_t));\n \n #define ERROR 299\n #define OROR 300\n@@ -106,7 +108,7 @@ static struct operation lex PARAMS ((cpp_reader *, int));\n \n struct operation\n {\n-  short op;\n+  op_t op;\n   U_CHAR prio;         /* Priority of op.  */\n   U_CHAR flags;\n   U_CHAR unsignedp;    /* True if value should be treated as unsigned.  */\n@@ -379,13 +381,14 @@ parse_defined (pfile)\n   return op;\n }\n \n-\n-struct token {\n+struct token\n+{\n   const char *operator;\n-  int token;\n+  op_t token;\n };\n \n-static const struct token tokentab2[] = {\n+static const struct token tokentab2[] =\n+{\n   {\"&&\", ANDAND},\n   {\"||\", OROR},\n   {\"<<\", LSH},\n@@ -476,6 +479,25 @@ lex (pfile, skip_evaluation)\n   }\n }\n \n+/* Convert an operator ID to a string.  */\n+static const char *\n+op_to_str (op)\n+     op_t op;\n+{\n+  static char str[5];\t\t/* XXX static variable.  */\n+  const struct token *toktab;\n+\n+  /* See if it is a special token of length 2.  */\n+  for (toktab = tokentab2; toktab->operator != NULL; toktab++)\n+    if (op == toktab->token)\n+      return toktab->operator;\n+\n+  if (ISGRAPH (op))\n+    sprintf (str, \"%c\", (int) op);\n+  else\n+    sprintf (str, \"\\\\%03o\", (int) op);\n+  return str;\n+}\n \n /* Parse a C escape sequence.  STRING_PTR points to a variable\n    containing a pointer to the string to parse.  That pointer\n@@ -830,7 +852,8 @@ _cpp_parse_expr (pfile)\n \t      if (top->op == '(')\n \t\tcpp_error (pfile, \"void expression between '(' and ')'\");\n \t      else\n-\t\tcpp_error (pfile, \"operator has no right operand\");\n+\t\tcpp_error (pfile, \"operator `%s' has no right operand\",\n+\t\t\t   op_to_str (top->op));\n \t      goto syntax_error;\n \t    }\n \n@@ -993,11 +1016,8 @@ _cpp_parse_expr (pfile)\n \t      op.unsignedp = unsigned2;\n \t      goto push_immediate;\n \t    default:\n-\t      if (ISGRAPH (top[1].op))\n-\t\tcpp_error (pfile, \"unimplemented operator '%c'\", top[1].op);\n-\t      else\n-\t\tcpp_error (pfile, \"unimplemented operator '\\\\%03o'\",\n-\t\t\t   top[1].op);\n+\t      cpp_error (pfile, \"unimplemented operator `%s'\",\n+\t\t\t op_to_str (top[1].op));\n \t      break;\n \t    case FINISHED:\n \t      /* Reducing this dummy operator indicates we've finished.  */\n@@ -1029,9 +1049,11 @@ _cpp_parse_expr (pfile)\n       if (((flags & NO_L_OPERAND) != 0) ^ ((top->flags & HAVE_VALUE) == 0))\n \t{\n \t  if (flags & NO_L_OPERAND)\n-\t    cpp_error (pfile, \"missing binary operator\");\n+\t    cpp_error (pfile, \"missing binary operator before `%s'\",\n+\t\t       op_to_str (op.op));\n \t  else\n-\t    cpp_error (pfile, \"operator has no left operand\");\n+\t    cpp_error (pfile, \"operator `%s' has no left operand\",\n+\t\t       op_to_str (op.op));\n \t  goto syntax_error;\n \t}\n "}]}