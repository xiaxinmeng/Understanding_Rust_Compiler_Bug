{"sha": "f607cacf5db527077abc7904c4dc511468c82c0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYwN2NhY2Y1ZGI1MjcwNzdhYmM3OTA0YzRkYzUxMTQ2OGM4MmMwYQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2017-04-25T08:23:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T08:23:06Z"}, "message": "uintp.adb (Most_Sig_2_Digits): In case Direct (Right)...\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* uintp.adb (Most_Sig_2_Digits): In case Direct (Right), fetch\n\tDirect_Val (Right), instead of the incorrect Direct_Val (Left).\n\t(UI_GCD): Remove ??? comment involving possible efficiency\n\timprovements. This just isn't important after all these years.\n\tAlso minor cleanup.\n\t* uintp.ads: Minor cleanup.\n\nFrom-SVN: r247144", "tree": {"sha": "b3a532479d308517de4607be3ab55c5e4e41942c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3a532479d308517de4607be3ab55c5e4e41942c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f607cacf5db527077abc7904c4dc511468c82c0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f607cacf5db527077abc7904c4dc511468c82c0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f607cacf5db527077abc7904c4dc511468c82c0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f607cacf5db527077abc7904c4dc511468c82c0a/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28ad2460d238188741c7e2a0207ed99578cb3e4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ad2460d238188741c7e2a0207ed99578cb3e4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ad2460d238188741c7e2a0207ed99578cb3e4d"}], "stats": {"total": 48, "additions": 22, "deletions": 26}, "files": [{"sha": "9899f93fe3faa0f60d90c89b0008ba60f184b733", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f607cacf5db527077abc7904c4dc511468c82c0a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f607cacf5db527077abc7904c4dc511468c82c0a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f607cacf5db527077abc7904c4dc511468c82c0a", "patch": "@@ -1,3 +1,12 @@\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* uintp.adb (Most_Sig_2_Digits): In case Direct (Right), fetch\n+\tDirect_Val (Right), instead of the incorrect Direct_Val (Left).\n+\t(UI_GCD): Remove ??? comment involving possible efficiency\n+\timprovements. This just isn't important after all these years.\n+\tAlso minor cleanup.\n+\t* uintp.ads: Minor cleanup.\n+\n 2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_util.adb, exp_util.ads, sem_ch7.adb, sem_prag.adb, exp_ch3.adb:"}, {"sha": "d6e4495b4097d9ff2b048b7e4824697f96247650", "filename": "gcc/ada/uintp.adb", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f607cacf5db527077abc7904c4dc511468c82c0a/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f607cacf5db527077abc7904c4dc511468c82c0a/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=f607cacf5db527077abc7904c4dc511468c82c0a", "patch": "@@ -52,7 +52,7 @@ package body Uintp is\n \n    UI_Power_2 : array (Int range 0 .. 64) of Uint;\n    --  This table is used to memoize exponentiations by powers of 2. The Nth\n-   --  entry, if set, contains the Uint value 2 ** N. Initially UI_Power_2_Set\n+   --  entry, if set, contains the Uint value 2**N. Initially UI_Power_2_Set\n    --  is zero and only the 0'th entry is set, the invariant being that all\n    --  entries in the range 0 .. UI_Power_2_Set are initialized.\n \n@@ -149,9 +149,9 @@ package body Uintp is\n       Left_Hat  : out Int;\n       Right_Hat : out Int);\n    --  Returns leading two significant digits from the given pair of Uint's.\n-   --  Mathematically: returns Left / (Base ** K) and Right / (Base ** K) where\n+   --  Mathematically: returns Left / (Base**K) and Right / (Base**K) where\n    --  K is as small as possible S.T. Right_Hat < Base * Base. It is required\n-   --  that Left > Right for the algorithm to work.\n+   --  that Left >= Right for the algorithm to work.\n \n    function N_Digits (Input : Uint) return Int;\n    pragma Inline (N_Digits);\n@@ -264,7 +264,7 @@ package body Uintp is\n       -------------------\n \n       function Better_In_Hex return Boolean is\n-         T16 : constant Uint := Uint_2 ** Int'(16);\n+         T16 : constant Uint := Uint_2**Int'(16);\n          A   : Uint;\n \n       begin\n@@ -506,6 +506,7 @@ package body Uintp is\n       pragma Assert (Left >= Right);\n \n       if Direct (Left) then\n+         pragma Assert (Direct (Right));\n          Left_Hat  := Direct_Val (Left);\n          Right_Hat := Direct_Val (Right);\n          return;\n@@ -533,7 +534,7 @@ package body Uintp is\n \n       begin\n          if Direct (Right) then\n-            T := Direct_Val (Left);\n+            T := Direct_Val (Right);\n             R1 := abs (T / Base);\n             R2 := T rem Base;\n             Length_R := 2;\n@@ -1370,7 +1371,7 @@ package body Uintp is\n \n       elsif Right <= Uint_64 then\n \n-         --  2 ** N for N in 2 .. 64\n+         --  2**N for N in 2 .. 64\n \n          if Left = Uint_2 then\n             declare\n@@ -1390,7 +1391,7 @@ package body Uintp is\n                return UI_Power_2 (Right_Int);\n             end;\n \n-         --  10 ** N for N in 2 .. 64\n+         --  10**N for N in 2 .. 64\n \n          elsif Left = Uint_10 then\n             declare\n@@ -1585,20 +1586,6 @@ package body Uintp is\n          else\n             --  Use prior single precision steps to compute this Euclid step\n \n-            --  For constructs such as:\n-            --  sqrt_2: constant := 1.41421_35623_73095_04880_16887_24209_698;\n-            --  sqrt_eps: constant long_float := long_float( 1.0 / sqrt_2)\n-            --    ** long_float'machine_mantissa;\n-            --\n-            --  we spend 80% of our time working on this step. Perhaps we need\n-            --  a special case Int / Uint dot product to speed things up. ???\n-\n-            --  Alternatively we could increase the single precision iterations\n-            --  to handle Uint's of some small size ( <5 digits?). Then we\n-            --  would have more iterations on small Uint. On the code above, we\n-            --  only get 5 (on average) single precision iterations per large\n-            --  iteration. ???\n-\n             Tmp_UI := (UI_From_Int (A) * U) + (UI_From_Int (B) * V);\n             V := (UI_From_Int (C) * U) + (UI_From_Int (D) * V);\n             U := Tmp_UI;"}, {"sha": "f59a8d9b523b1364afb72ba52439c5cf0b31e5b8", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f607cacf5db527077abc7904c4dc511468c82c0a/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f607cacf5db527077abc7904c4dc511468c82c0a/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=f607cacf5db527077abc7904c4dc511468c82c0a", "patch": "@@ -238,7 +238,7 @@ package Uintp is\n      (B      : Uint;\n       E      : Uint;\n       Modulo : Uint) return Uint;\n-   --  Efficiently compute (B ** E) rem Modulo\n+   --  Efficiently compute (B**E) rem Modulo\n \n    function UI_Modular_Inverse (N : Uint; Modulo : Uint) return Uint;\n    --  Compute the multiplicative inverse of N in modular arithmetics with the\n@@ -438,7 +438,7 @@ private\n    Base_Bits : constant := 15;\n    --  Number of bits in base value\n \n-   Base : constant Int := 2 ** Base_Bits;\n+   Base : constant Int := 2**Base_Bits;\n \n    --  Values in the range -(Base-1) .. Max_Direct are encoded directly as\n    --  Uint values by adding a bias value. The value of Max_Direct is chosen\n@@ -454,13 +454,13 @@ private\n    --  avoid accidental use of Uint arithmetic on these values, which is never\n    --  correct.\n \n-   type Ctrl is range Int'First .. Int'Last;\n+   type Ctrl is new Int;\n \n    Uint_Direct_Bias  : constant Ctrl := Ctrl (Uint_Low_Bound) + Ctrl (Base);\n    Uint_Direct_First : constant Ctrl := Uint_Direct_Bias + Ctrl (Min_Direct);\n    Uint_Direct_Last  : constant Ctrl := Uint_Direct_Bias + Ctrl (Max_Direct);\n \n-   Uint_0   : constant Uint := Uint (Uint_Direct_Bias);\n+   Uint_0   : constant Uint := Uint (Uint_Direct_Bias + 0);\n    Uint_1   : constant Uint := Uint (Uint_Direct_Bias + 1);\n    Uint_2   : constant Uint := Uint (Uint_Direct_Bias + 2);\n    Uint_3   : constant Uint := Uint (Uint_Direct_Bias + 3);\n@@ -499,7 +499,7 @@ private\n    Uint_Minus_80  : constant Uint := Uint (Uint_Direct_Bias - 80);\n    Uint_Minus_128 : constant Uint := Uint (Uint_Direct_Bias - 128);\n \n-   Uint_Max_Simple_Mul : constant := Uint_Direct_Bias + 2 ** 15;\n+   Uint_Max_Simple_Mul : constant := Uint_Direct_Bias + 2**15;\n    --  If two values are directly represented and less than or equal to this\n    --  value, then we know the product fits in a 32-bit integer. This allows\n    --  UI_Mul to efficiently compute the product in this case."}]}