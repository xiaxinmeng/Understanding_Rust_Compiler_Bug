{"sha": "aa4a53af510109ace50301adba3ee39237056cb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0YTUzYWY1MTAxMDlhY2U1MDMwMWFkYmEzZWUzOTIzNzA1NmNiNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-25T02:00:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-25T02:00:16Z"}, "message": "Update whitespace and comments\n\nFrom-SVN: r83632", "tree": {"sha": "2ccb66f3019da5e4546c851ef404388d009b80ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ccb66f3019da5e4546c851ef404388d009b80ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa4a53af510109ace50301adba3ee39237056cb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4a53af510109ace50301adba3ee39237056cb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa4a53af510109ace50301adba3ee39237056cb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4a53af510109ace50301adba3ee39237056cb6/comments", "author": null, "committer": null, "parents": [{"sha": "eb6127a4f9e593f6f00a8f3b5c4c50967f9340f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6127a4f9e593f6f00a8f3b5c4c50967f9340f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6127a4f9e593f6f00a8f3b5c4c50967f9340f6"}], "stats": {"total": 171, "additions": 88, "deletions": 83}, "files": [{"sha": "7d1b71544a459bccfd80a6e532b0e8fb7e5eb609", "filename": "gcc/gimplify.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4a53af510109ace50301adba3ee39237056cb6/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4a53af510109ace50301adba3ee39237056cb6/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=aa4a53af510109ace50301adba3ee39237056cb6", "patch": "@@ -77,13 +77,12 @@ static enum gimplify_status gimplify_modify_expr_rhs (tree *, tree *, tree *,\n static enum gimplify_status gimplify_compound_expr (tree *, tree *, bool);\n \n \n-\n /* Return a hash value for a formal temporary table entry.  */\n \n static hashval_t\n gimple_tree_hash (const void *p)\n {\n-  tree t = ((const elt_t *)p)->val;\n+  tree t = ((const elt_t *) p)->val;\n   return iterative_hash_expr (t, 0);\n }\n \n@@ -92,8 +91,8 @@ gimple_tree_hash (const void *p)\n static int\n gimple_tree_eq (const void *p1, const void *p2)\n {\n-  tree t1 = ((const elt_t *)p1)->val;\n-  tree t2 = ((const elt_t *)p2)->val;\n+  tree t1 = ((const elt_t *) p1)->val;\n+  tree t2 = ((const elt_t *) p2)->val;\n   enum tree_code code = TREE_CODE (t1);\n \n   if (TREE_CODE (t2) != code\n@@ -194,6 +193,7 @@ static void\n gimple_pop_condition (tree *pre_p)\n {\n   int conds = --(gimplify_ctxp->conditions);\n+\n   if (conds == 0)\n     {\n       append_to_statement_list (gimplify_ctxp->conditional_cleanups, pre_p);\n@@ -281,6 +281,7 @@ tree\n create_artificial_label (void)\n {\n   tree lab = build_decl (LABEL_DECL, NULL_TREE, void_type_node);\n+\n   DECL_ARTIFICIAL (lab) = 1;\n   DECL_CONTEXT (lab) = current_function_decl;\n   return lab;\n@@ -298,6 +299,7 @@ create_tmp_var_name (const char *prefix)\n   if (prefix)\n     {\n       char *preftmp = ASTRDUP (prefix);\n+\n       remove_suffix (preftmp, strlen (preftmp));\n       prefix = preftmp;\n     }\n@@ -486,8 +488,7 @@ is_gimple_tmp_var (tree t)\n \t  && !TREE_STATIC (t) && !DECL_EXTERNAL (t));\n }\n \n-/* Declares all the variables in VARS in SCOPE.  Returns the last\n-   DECL_STMT emitted.  */\n+/* Declares all the variables in VARS in SCOPE.  */\n \n void\n declare_tmp_vars (tree vars, tree scope)\n@@ -497,7 +498,7 @@ declare_tmp_vars (tree vars, tree scope)\n     {\n       tree temps;\n \n-      /* C99 mode puts the default 'return 0;' for main() outside the outer\n+      /* C99 mode puts the default 'return 0;' for main outside the outer\n \t braces.  So drill down until we find an actual scope.  */\n       while (TREE_CODE (scope) == COMPOUND_EXPR)\n \tscope = TREE_OPERAND (scope, 0);\n@@ -1577,9 +1578,8 @@ canonicalize_component_ref (tree *expr_p)\n       (T *)&array\n    ==>\n       &array[L]\n-   where L is the lower bound.  Only do this for constant lower bound since\n-   we have no place to put any statements made during gimplification of\n-   the lower bound.  */\n+   where L is the lower bound.  For simplicity, only do this for constant\n+   lower bound.  */\n \n static void\n canonicalize_addr_expr (tree *expr_p)"}, {"sha": "2778d53a8b3768e03da571abc8828462ccdc5bab", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4a53af510109ace50301adba3ee39237056cb6/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4a53af510109ace50301adba3ee39237056cb6/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=aa4a53af510109ace50301adba3ee39237056cb6", "patch": "@@ -852,24 +852,19 @@ collect_dfa_stats_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n static tree\n find_vars_r (tree *tp, int *walk_subtrees, void *data)\n {\n-  tree t = *tp;\n-  struct walk_state *walk_state = (struct walk_state *)data;\n-\n-  if (SSA_VAR_P (t))\n-    {\n-      /* If T is a regular variable that the optimizers are interested\n-\t in, add it to the list of variables.  */\n-      add_referenced_var (t, walk_state);\n-    }\n-  else if (DECL_P (t)\n-\t   || TYPE_P (t)\n-\t   || TREE_CODE_CLASS (TREE_CODE (t)) == 'c')\n-    {\n-      /* Type, _DECL and constant nodes have no interesting children.\n-\t Ignore them.  */\n-      *walk_subtrees = 0;\n-    }\n-\n+  struct walk_state *walk_state = (struct walk_state *) data;\n+\n+  /* If T is a regular variable that the optimizers are interested\n+     in, add it to the list of variables.  */\n+  if (SSA_VAR_P (*tp))\n+    add_referenced_var (*tp, walk_state);\n+\n+  /* Type, _DECL and constant nodes have no interesting children.\n+     Ignore them.  */\n+  else if (DECL_P (*tp)\n+\t   || TYPE_P (*tp)\n+\t   || TREE_CODE_CLASS (TREE_CODE (*tp)) == 'c')\n+    *walk_subtrees = 0;\n \n   return NULL_TREE;\n }"}, {"sha": "36e4393d2b31d49b93bea210be0c3e17b4030668", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4a53af510109ace50301adba3ee39237056cb6/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4a53af510109ace50301adba3ee39237056cb6/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=aa4a53af510109ace50301adba3ee39237056cb6", "patch": "@@ -1,5 +1,5 @@\n /* Functions to analyze and validate GIMPLE trees.\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n    Rewritten by Jason Merrill <jason@redhat.com>\n "}, {"sha": "75fb12436f9d584bcfd2e93862f335296fc71f4b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 64, "deletions": 54, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4a53af510109ace50301adba3ee39237056cb6/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4a53af510109ace50301adba3ee39237056cb6/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=aa4a53af510109ace50301adba3ee39237056cb6", "patch": "@@ -446,8 +446,8 @@ copy_bind_expr (tree *tp, int *walk_subtrees, inline_data *id)\n     BIND_EXPR_VARS (*tp) = remap_decls (BIND_EXPR_VARS (*tp), id);\n }\n \n-/* Called from copy_body via walk_tree.  DATA is really an\n-   `inline_data *'.  */\n+/* Called from copy_body via walk_tree.  DATA is really an `inline_data *'.  */\n+\n static tree\n copy_body_r (tree *tp, int *walk_subtrees, void *data)\n {\n@@ -648,9 +648,9 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t    }\n \t  else\n \t    {\n-              struct cgraph_edge *edge;\n+              struct cgraph_edge *edge\n+\t\t= cgraph_edge (id->current_node, old_node);\n \n-\t      edge = cgraph_edge (id->current_node, old_node);\n \t      if (edge)\n \t        cgraph_clone_edge (edge, id->node, *tp);\n \t    }\n@@ -691,9 +691,8 @@ copy_body (inline_data *id)\n }\n \n static void\n-setup_one_parameter (inline_data *id, tree p, tree value,\n-\t\t     tree fn, tree *init_stmts, tree *vars,\n-\t\t     bool *gimplify_init_stmts_p)\n+setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n+\t\t     tree *init_stmts, tree *vars, bool *gimplify_init_stmts_p)\n {\n   tree init_stmt;\n   tree var;\n@@ -864,9 +863,9 @@ initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n }\n \n /* Declare a return variable to replace the RESULT_DECL for the\n-   function we are calling.  An appropriate DECL_STMT is returned.\n-   The USE_STMT is filled in to contain a use of the declaration to\n-   indicate the return value of the function.  */\n+   function we are calling.  An appropriate decl is returned.\n+ \n+   ??? Needs documentation of parameters. */\n \n static tree\n declare_return_variable (inline_data *id, tree return_slot_addr, tree *use_p)\n@@ -964,7 +963,6 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n       if (! t)\n \tbreak;\n \n-\n       /* We cannot inline functions that call setjmp.  */\n       if (setjmp_call_p (t))\n \t{\n@@ -1151,8 +1149,7 @@ inlinable_function_p (tree fn)\n \t\t\t && DECL_DECLARED_INLINE_P (fn)\n \t\t\t && !DECL_IN_SYSTEM_HEADER (fn));\n \n-      if (lookup_attribute (\"always_inline\",\n-\t\t\t    DECL_ATTRIBUTES (fn)))\n+      if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)))\n \tsorry (inline_forbidden_reason, fn, fn);\n       else if (do_warning)\n \twarning (inline_forbidden_reason, fn, fn);\n@@ -1168,6 +1165,7 @@ inlinable_function_p (tree fn)\n \n /* Used by estimate_num_insns.  Estimate number of instructions seen\n    by given statement.  */\n+\n static tree\n estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n {\n@@ -1233,6 +1231,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case LOOP_EXPR:\n     case PHI_NODE:\n       break;\n+\n     /* We don't account constants for now.  Assume that the cost is amortized\n        by operations that do use them.  We may re-consider this decision once\n        we are able to optimize the tree before estimating it's size and break\n@@ -1375,6 +1374,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n }\n \n /* Estimate number of instructions that will be created by expanding EXPR.  */\n+\n int\n estimate_num_insns (tree expr)\n {\n@@ -1647,10 +1647,10 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n       BIND_EXPR_BODY (expr)\n \t= rationalize_compound_expr (BIND_EXPR_BODY (expr));\n \n-      /* We want to create a new variable to hold the result of the\n-\t inlined body.  This new variable needs to be added to the\n-\t function which we are inlining into, thus the saving and\n-\t restoring of current_function_decl.  */\n+      /* We want to create a new variable to hold the result of the inlined\n+\t body.  This new variable needs to be added to the function which we\n+\t are inlining into, thus the saving and restoring of\n+\t current_function_decl.  */\n       save_decl = current_function_decl;\n       current_function_decl = id->node->decl;\n       inline_result = voidify_wrapper_expr (expr, NULL);\n@@ -1668,18 +1668,18 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n       else\n \t*tp = expr;\n \n-      /* When we gimplify a function call, we may clear TREE_SIDE_EFFECTS\n-\t on the call if it is to a \"const\" function.  Thus the copy of\n-\t TREE_SIDE_EFFECTS from the CALL_EXPR to the BIND_EXPR above\n-\t with result in TREE_SIDE_EFFECTS not being set for the inlined\n-\t copy of a \"const\" function.\n+      /* When we gimplify a function call, we may clear TREE_SIDE_EFFECTS on\n+\t the call if it is to a \"const\" function.  Thus the copy of\n+\t TREE_SIDE_EFFECTS from the CALL_EXPR to the BIND_EXPR above with\n+\t result in TREE_SIDE_EFFECTS not being set for the inlined copy of a\n+\t \"const\" function.\n \n-\t Unfortunately, that is wrong as inlining the function\n-\t can create/expose interesting side effects (such as setting\n-\t of a return value).\n+\t Unfortunately, that is wrong as inlining the function can\n+\t create/expose interesting side effects (such as setting of a return\n+\t value).\n \n-\t The easiest solution is to simply recalculate TREE_SIDE_EFFECTS\n-\t for the toplevel expression.  */\n+\t The easiest solution is to simply recalculate TREE_SIDE_EFFECTS for\n+\t the toplevel expression.  */\n       recalculate_side_effects (expr);\n     }\n   else\n@@ -1743,17 +1743,21 @@ gimple_expand_calls_inline (tree *stmt_p, inline_data *id)\n       gimple_expand_calls_inline (&COND_EXPR_THEN (stmt), id);\n       gimple_expand_calls_inline (&COND_EXPR_ELSE (stmt), id);\n       break;\n+\n     case CATCH_EXPR:\n       gimple_expand_calls_inline (&CATCH_BODY (stmt), id);\n       break;\n+\n     case EH_FILTER_EXPR:\n       gimple_expand_calls_inline (&EH_FILTER_FAILURE (stmt), id);\n       break;\n+\n     case TRY_CATCH_EXPR:\n     case TRY_FINALLY_EXPR:\n       gimple_expand_calls_inline (&TREE_OPERAND (stmt, 0), id);\n       gimple_expand_calls_inline (&TREE_OPERAND (stmt, 1), id);\n       break;\n+\n     case BIND_EXPR:\n       gimple_expand_calls_inline (&BIND_EXPR_BODY (stmt), id);\n       break;\n@@ -1767,13 +1771,17 @@ gimple_expand_calls_inline (tree *stmt_p, inline_data *id)\n       stmt = *stmt_p;\n       if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n \tbreak;\n+\n       /* FALLTHRU */\n+\n     case MODIFY_EXPR:\n       stmt_p = &TREE_OPERAND (stmt, 1);\n       stmt = *stmt_p;\n       if (TREE_CODE (stmt) != CALL_EXPR)\n \tbreak;\n+\n       /* FALLTHRU */\n+\n     case CALL_EXPR:\n       expand_call_inline (stmt_p, &dummy, id);\n       break;\n@@ -1836,8 +1844,7 @@ optimize_inline_calls (tree fn)\n       prev_fn = current_function_decl;\n     }\n \n-  prev_fn = (lang_hooks.tree_inlining.add_pending_fn_decls\n-\t     (&id.fns, prev_fn));\n+  prev_fn = lang_hooks.tree_inlining.add_pending_fn_decls (&id.fns, prev_fn);\n \n   /* Create the list of functions this call will inline.  */\n   VARRAY_TREE_INIT (id.inlined_fns, 32, \"inlined_fns\");\n@@ -1848,8 +1855,7 @@ optimize_inline_calls (tree fn)\n \n   /* Replace all calls to inline functions with the bodies of those\n      functions.  */\n-  id.tree_pruner = htab_create (37, htab_hash_pointer,\n-\t\t\t\thtab_eq_pointer, NULL);\n+  id.tree_pruner = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);\n   expand_calls_inline (&DECL_SAVED_TREE (fn), &id);\n \n   /* Clean up.  */\n@@ -1878,19 +1884,18 @@ optimize_inline_calls (tree fn)\n #endif\n }\n \n-/* FN is a function that has a complete body, and CLONE is a function\n-   whose body is to be set to a copy of FN, mapping argument\n-   declarations according to the ARG_MAP splay_tree.  */\n+/* FN is a function that has a complete body, and CLONE is a function whose\n+   body is to be set to a copy of FN, mapping argument declarations according\n+   to the ARG_MAP splay_tree.  */\n \n void\n clone_body (tree clone, tree fn, void *arg_map)\n {\n   inline_data id;\n \n-  /* Clone the body, as if we were making an inline call.  But, remap\n-     the parameters in the callee to the parameters of caller.  If\n-     there's an in-charge parameter, map it to an appropriate\n-     constant.  */\n+  /* Clone the body, as if we were making an inline call.  But, remap the\n+     parameters in the callee to the parameters of caller.  If there's an\n+     in-charge parameter, map it to an appropriate constant.  */\n   memset (&id, 0, sizeof (id));\n   VARRAY_TREE_INIT (id.fns, 2, \"fns\");\n   VARRAY_PUSH_TREE (id.fns, clone);\n@@ -1920,15 +1925,18 @@ save_body (tree fn, tree *arg_copy)\n   id.saving_p = true;\n   id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n   *arg_copy = DECL_ARGUMENTS (fn);\n+\n   for (parg = arg_copy; *parg; parg = &TREE_CHAIN (*parg))\n     {\n       tree new = copy_node (*parg);\n+\n       lang_hooks.dup_lang_specific_decl (new);\n       DECL_ABSTRACT_ORIGIN (new) = DECL_ORIGIN (*parg);\n       insert_decl_map (&id, *parg, new);\n       TREE_CHAIN (new) = TREE_CHAIN (*parg);\n       *parg = new;\n     }\n+\n   insert_decl_map (&id, DECL_RESULT (fn), DECL_RESULT (fn));\n \n   /* Actually copy the body.  */\n@@ -1939,12 +1947,11 @@ save_body (tree fn, tree *arg_copy)\n   return body;\n }\n \n-/* Apply FUNC to all the sub-trees of TP in a pre-order traversal.\n-   FUNC is called with the DATA and the address of each sub-tree.  If\n-   FUNC returns a non-NULL value, the traversal is aborted, and the\n-   value returned by FUNC is returned.  If HTAB is non-NULL it is used\n-   to record the nodes visited, and to avoid visiting a node more than\n-   once.  */\n+/* Apply FUNC to all the sub-trees of TP in a pre-order traversal.  FUNC is\n+   called with the DATA and the address of each sub-tree.  If FUNC returns a\n+   non-NULL value, the traversal is aborted, and the value returned by FUNC\n+   is returned.  If HTAB is non-NULL it is used to record the nodes visited,\n+   and to avoid visiting a node more than once.  */\n \n tree\n walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n@@ -2028,6 +2035,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n       if (code == TARGET_EXPR\n \t  && TREE_OPERAND (*tp, 3) == TREE_OPERAND (*tp, 1))\n \t--len;\n+\n       /* Go through the subtrees.  We need to do this in forward order so\n          that the scope of a FOR_EXPR is handled properly.  */\n #ifdef DEBUG_WALK_TREE\n@@ -2227,8 +2235,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n #undef WALK_SUBTREE_TAIL\n }\n \n-/* Like walk_tree, but does not walk duplicate nodes more than\n-   once.  */\n+/* Like walk_tree, but does not walk duplicate nodes more than once.  */\n \n tree\n walk_tree_without_duplicates (tree *tp, walk_tree_fn func, void *data)\n@@ -2280,20 +2287,21 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       if (TREE_CODE (*tp) == BIND_EXPR)\n \tBIND_EXPR_BLOCK (*tp) = NULL_TREE;\n     }\n+ \n   else if (TREE_CODE_CLASS (code) == 't')\n     *walk_subtrees = 0;\n   else if (TREE_CODE_CLASS (code) == 'd')\n     *walk_subtrees = 0;\n-  else if (code == STATEMENT_LIST)\n+ else if (code == STATEMENT_LIST)\n     abort ();\n \n   return NULL_TREE;\n }\n \n /* The SAVE_EXPR pointed to by TP is being copied.  If ST contains\n-   information indicating to what new SAVE_EXPR this one should be\n-   mapped, use that one.  Otherwise, create a new node and enter it in\n-   ST.  FN is the function into which the copy will be placed.  */\n+   information indicating to what new SAVE_EXPR this one should be mapped,\n+   use that one.  Otherwise, create a new node and enter it in ST.  FN is the\n+   function into which the copy will be placed.  */\n \n void\n remap_save_expr (tree *tp, void *st_, tree fn, int *walk_subtrees)\n@@ -2331,9 +2339,9 @@ remap_save_expr (tree *tp, void *st_, tree fn, int *walk_subtrees)\n   *tp = t;\n }\n \n-/* Called via walk_tree.  If *TP points to a DECL_STMT for a local\n-   declaration, copies the declaration and enters it in the splay_tree\n-   in DATA (which is really an `inline_data *').  */\n+/* Called via walk_tree.  If *TP points to a DECL_STMT for a local label,\n+   copies the declaration and enters it in the splay_tree in DATA (which is\n+   really an `inline_data *').  */\n \n static tree\n mark_local_for_remap_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n@@ -2394,6 +2402,7 @@ unsave_r (tree *tp, int *walk_subtrees, void *data)\n       if (n)\n \t*tp = (tree) n->value;\n     }\n+\n   else if (TREE_CODE (*tp) == STATEMENT_LIST)\n     copy_statement_list (tp);\n   else if (TREE_CODE (*tp) == BIND_EXPR)\n@@ -2443,6 +2452,7 @@ lhd_unsave_expr_now (tree expr)\n }\n \n /* Allow someone to determine if SEARCH is a child of TOP from gdb.  */\n+\n static tree\n debug_find_tree_1 (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n {\n@@ -2458,7 +2468,6 @@ debug_find_tree (tree top, tree search)\n   return walk_tree_without_duplicates (&top, debug_find_tree_1, search) != 0;\n }\n \n-\n /* Declare the variables created by the inliner.  Add all the variables in\n    VARS to BIND_EXPR.  */\n \n@@ -2468,6 +2477,7 @@ declare_inline_vars (tree bind_expr, tree vars)\n   if (lang_hooks.gimple_before_inlining)\n     {\n       tree t;\n+\n       for (t = vars; t; t = TREE_CHAIN (t))\n \tvars->decl.seen_in_bind_expr = 1;\n     }"}]}