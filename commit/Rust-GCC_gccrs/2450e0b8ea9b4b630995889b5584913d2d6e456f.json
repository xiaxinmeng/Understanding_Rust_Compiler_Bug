{"sha": "2450e0b8ea9b4b630995889b5584913d2d6e456f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ1MGUwYjhlYTliNGI2MzA5OTU4ODliNTU4NDkxM2QyZDZlNDU2Zg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-02-23T20:21:39Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-02-23T20:21:39Z"}, "message": "cpplib.c (glue_header_name): Use local buffer to build up header name.\n\n\t* cpplib.c (glue_header_name): Use local buffer to build up\n\theader name.\n\nFrom-SVN: r49998", "tree": {"sha": "7ec695eb7af99d6f51037fc40bf0c114b6f3ff62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ec695eb7af99d6f51037fc40bf0c114b6f3ff62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2450e0b8ea9b4b630995889b5584913d2d6e456f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2450e0b8ea9b4b630995889b5584913d2d6e456f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2450e0b8ea9b4b630995889b5584913d2d6e456f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2450e0b8ea9b4b630995889b5584913d2d6e456f/comments", "author": null, "committer": null, "parents": [{"sha": "70b6aaed80b78e1b1e72e84d8efc6574ef506299", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b6aaed80b78e1b1e72e84d8efc6574ef506299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70b6aaed80b78e1b1e72e84d8efc6574ef506299"}], "stats": {"total": 37, "additions": 21, "deletions": 16}, "files": [{"sha": "92381ee95433c88d96c9b350671400c3ebc20ae9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2450e0b8ea9b4b630995889b5584913d2d6e456f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2450e0b8ea9b4b630995889b5584913d2d6e456f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2450e0b8ea9b4b630995889b5584913d2d6e456f", "patch": "@@ -1,3 +1,8 @@\n+2002-02-23  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpplib.c (glue_header_name): Use local buffer to build up\n+\theader name.\n+\n 2002-02-23  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* doc/cpp.texi, doc/invoke.texi: Update documentation for -MM."}, {"sha": "1a38f01c2fb65fc769bcb23f05decda2089afeef", "filename": "gcc/cpplib.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2450e0b8ea9b4b630995889b5584913d2d6e456f/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2450e0b8ea9b4b630995889b5584913d2d6e456f/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=2450e0b8ea9b4b630995889b5584913d2d6e456f", "patch": "@@ -507,48 +507,48 @@ glue_header_name (pfile)\n {\n   cpp_token *header = NULL;\n   const cpp_token *token;\n-  unsigned char *dest;\n-  size_t len;\n+  unsigned char *buffer;\n+  size_t len, total_len = 0, capacity = 1024;\n \n   /* To avoid lexed tokens overwriting our glued name, we can only\n      allocate from the string pool once we've lexed everything.  */\n-\n-  dest = BUFF_FRONT (pfile->u_buff);\n+  buffer = (unsigned char *) xmalloc (capacity);\n   for (;;)\n     {\n       token = cpp_get_token (pfile);\n \n       if (token->type == CPP_GREATER || token->type == CPP_EOF)\n \tbreak;\n \n-      /* + 1 for terminating NUL.  */\n-      len = cpp_token_len (token) + 1;\n-      if ((size_t) (BUFF_LIMIT (pfile->u_buff) - dest) < len)\n+      len = cpp_token_len (token);\n+      if (total_len + len > capacity)\n \t{\n-\t  size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n-\t  _cpp_extend_buff (pfile, &pfile->u_buff, len);\n-\t  dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n+\t  capacity = (capacity + len) * 2;\n+\t  buffer = (unsigned char *) xrealloc (buffer, capacity);\n \t}\n \n       if (token->flags & PREV_WHITE)\n-\t*dest++ = ' ';\n+\tbuffer[total_len++] = ' ';\n \n-      dest = cpp_spell_token (pfile, token, dest);\n+      total_len = cpp_spell_token (pfile, token, &buffer[total_len]) - buffer;\n     }\n \n   if (token->type == CPP_EOF)\n     cpp_error (pfile, \"missing terminating > character\");\n   else\n     {\n+      unsigned char *token_mem = _cpp_unaligned_alloc (pfile, total_len + 1);\n+      memcpy (token_mem, buffer, total_len);\n+      token_mem[total_len] = '\\0';\n+\n       header = _cpp_temp_token (pfile);\n       header->type = CPP_HEADER_NAME;\n       header->flags = 0;\n-      header->val.str.len = dest - BUFF_FRONT (pfile->u_buff);\n-      header->val.str.text = BUFF_FRONT (pfile->u_buff);\n-      *dest++ = '\\0';\n-      BUFF_FRONT (pfile->u_buff) = dest;\n+      header->val.str.len = total_len;\n+      header->val.str.text = token_mem;\n     }\n \n+  free ((PTR) buffer);\n   return header;\n }\n "}]}