{"sha": "d7dce787ebe0df76e9811d3565ad3ce113bfee78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdkY2U3ODdlYmUwZGY3NmU5ODExZDM1NjVhZDNjZTExM2JmZWU3OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-11-22T23:00:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-11-22T23:00:43Z"}, "message": "lto.c (cmp_type_location): Remove.\n\n\t* lto.c (cmp_type_location): Remove.\n\t(lto_read_decls): Do not allocate odr_types.\n\nFrom-SVN: r266395", "tree": {"sha": "e57d69830ef043039768cda98f04fccd89675f7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e57d69830ef043039768cda98f04fccd89675f7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7dce787ebe0df76e9811d3565ad3ce113bfee78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7dce787ebe0df76e9811d3565ad3ce113bfee78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7dce787ebe0df76e9811d3565ad3ce113bfee78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7dce787ebe0df76e9811d3565ad3ce113bfee78/comments", "author": null, "committer": null, "parents": [{"sha": "95e3eb80a8148663288821987ffab98e0b30062b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e3eb80a8148663288821987ffab98e0b30062b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95e3eb80a8148663288821987ffab98e0b30062b"}], "stats": {"total": 47, "additions": 6, "deletions": 41}, "files": [{"sha": "56f8a9867a97657d966c1ff9c0a8a1d289e65735", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7dce787ebe0df76e9811d3565ad3ce113bfee78/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7dce787ebe0df76e9811d3565ad3ce113bfee78/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=d7dce787ebe0df76e9811d3565ad3ce113bfee78", "patch": "@@ -1,3 +1,8 @@\n+2018-11-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (cmp_type_location): Remove.\n+\t(lto_read_decls): Do not allocate odr_types.\n+\n 2018-11-19  Martin Liska  <mliska@suse.cz>\n \n \tPR lto/88077"}, {"sha": "a5195fdd5570b318658e61f1ca3eb359850b988c", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7dce787ebe0df76e9811d3565ad3ce113bfee78/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7dce787ebe0df76e9811d3565ad3ce113bfee78/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=d7dce787ebe0df76e9811d3565ad3ce113bfee78", "patch": "@@ -1712,36 +1712,6 @@ unify_scc (struct data_in *data_in, unsigned from,\n }\n \n \n-/* Compare types based on source file location.  */\n-\n-static int\n-cmp_type_location (const void *p1_, const void *p2_)\n-{\n-  tree *p1 = (tree*)(const_cast<void *>(p1_));\n-  tree *p2 = (tree*)(const_cast<void *>(p2_));\n-  if (*p1 == *p2)\n-    return 0;\n-\n-  tree tname1 = TYPE_NAME (*p1);\n-  tree tname2 = TYPE_NAME (*p2);\n-  expanded_location xloc1 = expand_location (DECL_SOURCE_LOCATION (tname1));\n-  expanded_location xloc2 = expand_location (DECL_SOURCE_LOCATION (tname2));\n-\n-  const char *f1 = lbasename (xloc1.file);\n-  const char *f2 = lbasename (xloc2.file);\n-  int r = strcmp (f1, f2);\n-  if (r == 0)\n-    {\n-      int l1 = xloc1.line;\n-      int l2 = xloc2.line;\n-      if (l1 != l2)\n-\treturn l1 - l2;\n-      return xloc1.column - xloc2.column;\n-    }\n-  else\n-    return r;\n-}\n-\n /* Read all the symbols from buffer DATA, using descriptors in DECL_DATA.\n    RESOLUTIONS is the set of symbols picked by the linker (read from the\n    resolution file when the linker plugin is being used).  */\n@@ -1758,7 +1728,6 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n   unsigned int i;\n   const uint32_t *data_ptr, *data_end;\n   uint32_t num_decl_states;\n-  auto_vec<tree> odr_types;\n \n   lto_input_block ib_main ((const char *) data + main_offset,\n \t\t\t   header->main_size, decl_data->mode_table);\n@@ -1828,7 +1797,7 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t\t  if (!TYPE_CANONICAL (t))\n \t\t    gimple_register_canonical_type (t);\n \t\t  if (TYPE_MAIN_VARIANT (t) == t && odr_type_p (t))\n-\t\t    odr_types.safe_push (t);\n+\t\t    register_odr_type (t);\n \t\t}\n \t      /* Link shared INTEGER_CSTs into TYPE_CACHED_VALUEs of its\n \t\t type which is also member of this SCC.  */\n@@ -1890,15 +1859,6 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n       *slot = state;\n     }\n \n-  /* Sort types for the file before registering in ODR machinery.  */\n-  if (lto_location_cache::current_cache)\n-    lto_location_cache::current_cache->apply_location_cache ();\n-  odr_types.qsort (cmp_type_location);\n-\n-  /* Register ODR types.  */\n-  for (unsigned i = 0; i < odr_types.length (); i++)\n-    register_odr_type (odr_types[i]);\n-\n   if (data_ptr != data_end)\n     internal_error (\"bytecode stream: garbage at the end of symbols section\");\n "}]}