{"sha": "b46be8a2b70f416b8c12697885b5c7a315a3aeba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ2YmU4YTJiNzBmNDE2YjhjMTI2OTc4ODViNWM3YTMxNWEzYWViYQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-07-07T10:36:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-07T10:36:25Z"}, "message": "scng.adb: Minor reformattting\n\n2009-07-07  Robert Dewar  <dewar@adacore.com>\n\n\t* scng.adb: Minor reformattting\n\n\t* par-ch2.adb (Scan_Pragma_Argument_Association): Pragma argument\n\tassociation allows conditional expression without parens.\n\n\t* par-ch4.adb (P_Name): Attribute arguments can be conditional\n\texpressions without enclosing parentheses, and also as parameters,\n\tindexing expressions etc.\n\t(P_Conditional_Expression): New procedure\n\t(P_Expression_If_OK): New procedure\n\n\t* par.adb (P_Conditional_Expression): New procedure\n\t(P_Expression_If_OK): New procedure\n\n\t* sem_ch4.adb (Analyze_Conditional_Expression): Allow for two argument\n\tform of conditional expression.\n\n\t* sem_res.adb (Resolve_Conditional_Expression): Deal with supplying\n\tmissing True argument if ELSE argument missing.\n\n\t* sinfo.adb (Is_Elsif): New flag\n\n\t* sinfo.ads (N_Conditional_Expression): This node is now a syntactic\n\tpart of the language, and the documentation is modified accordingly.\n\t(Is_Elsif): New flag\n\nFrom-SVN: r149316", "tree": {"sha": "11684252ac8961c0cd28bf14e54a318aa0ed8157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11684252ac8961c0cd28bf14e54a318aa0ed8157"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b46be8a2b70f416b8c12697885b5c7a315a3aeba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46be8a2b70f416b8c12697885b5c7a315a3aeba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b46be8a2b70f416b8c12697885b5c7a315a3aeba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46be8a2b70f416b8c12697885b5c7a315a3aeba/comments", "author": null, "committer": null, "parents": [{"sha": "f062f8f2307ae66bdeb176260841bd09a8765beb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f062f8f2307ae66bdeb176260841bd09a8765beb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f062f8f2307ae66bdeb176260841bd09a8765beb"}], "stats": {"total": 334, "additions": 299, "deletions": 35}, "files": [{"sha": "455f0a51dfefe16cab1093db735b37227dd75dbe", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b46be8a2b70f416b8c12697885b5c7a315a3aeba", "patch": "@@ -1,3 +1,31 @@\n+2009-07-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* scng.adb: Minor reformattting\n+\n+\t* par-ch2.adb (Scan_Pragma_Argument_Association): Pragma argument\n+\tassociation allows conditional expression without parens.\n+\n+\t* par-ch4.adb (P_Name): Attribute arguments can be conditional\n+\texpressions without enclosing parentheses, and also as parameters,\n+\tindexing expressions etc.\n+\t(P_Conditional_Expression): New procedure\n+\t(P_Expression_If_OK): New procedure\n+\n+\t* par.adb (P_Conditional_Expression): New procedure\n+\t(P_Expression_If_OK): New procedure\n+\n+\t* sem_ch4.adb (Analyze_Conditional_Expression): Allow for two argument\n+\tform of conditional expression.\n+\n+\t* sem_res.adb (Resolve_Conditional_Expression): Deal with supplying\n+\tmissing True argument if ELSE argument missing.\n+\n+\t* sinfo.adb (Is_Elsif): New flag\n+\n+\t* sinfo.ads (N_Conditional_Expression): This node is now a syntactic\n+\tpart of the language, and the documentation is modified accordingly.\n+\t(Is_Elsif): New flag\n+\n 2009-07-06  Olivier Hainque  <hainque@adacore.com>\n \n \t* gcc-interface/trans.c (Handled_Sequence_Of_Statements_to_gnu,"}, {"sha": "e96c3794f9939773c5aef7857d48513c559be0af", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=b46be8a2b70f416b8c12697885b5c7a315a3aeba", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -506,7 +506,11 @@ package body Ch2 is\n            (\"|pragma argument identifier required here (RM 2.8(4))\");\n       end if;\n \n-      Set_Expression (Association, P_Expression);\n+      if Id_Present then\n+         Set_Expression (Association, P_Expression);\n+      else\n+         Set_Expression (Association, P_Expression_If_OK);\n+      end if;\n    end Scan_Pragma_Argument_Association;\n \n end Ch2;"}, {"sha": "38eccb192946bcb213edfad7b9290133f232f7bd", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 154, "deletions": 16, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=b46be8a2b70f416b8c12697885b5c7a315a3aeba", "patch": "@@ -79,9 +79,7 @@ package body Ch4 is\n    --  Called to place complaint about bad range attribute at the given\n    --  source location. Terminates by raising Error_Resync.\n \n-   function P_Range_Attribute_Reference\n-     (Prefix_Node : Node_Id)\n-      return        Node_Id;\n+   function P_Range_Attribute_Reference (Prefix_Node : Node_Id) return Node_Id;\n    --  Scan a range attribute reference. The caller has scanned out the\n    --  prefix. The current token is known to be an apostrophe and the\n    --  following token is known to be RANGE.\n@@ -454,7 +452,7 @@ package body Ch4 is\n                         Scan; -- past left paren\n \n                         loop\n-                           Discard_Junk_Node (P_Expression);\n+                           Discard_Junk_Node (P_Expression_If_OK);\n                            exit when not Comma_Present;\n                         end loop;\n \n@@ -519,7 +517,7 @@ package body Ch4 is\n \n                loop\n                   declare\n-                     Expr : constant Node_Id := P_Expression;\n+                     Expr : constant Node_Id := P_Expression_If_OK;\n \n                   begin\n                      if Token = Tok_Arrow then\n@@ -558,6 +556,9 @@ package body Ch4 is\n          --      case of a name which can be extended in the normal manner.\n          --      This case is handled by LP_State_Name or LP_State_Expr.\n \n+         --      Note: conditional expressions (without an extra level of\n+         --      parentheses) are permitted in this context).\n+\n          --   (..., identifier => expression , ...)\n \n          --      If there is at least one occurrence of identifier => (but\n@@ -583,7 +584,7 @@ package body Ch4 is\n \n          --  Here we have an expression after all\n \n-         Expr_Node := P_Expression_Or_Range_Attribute;\n+         Expr_Node := P_Expression_Or_Range_Attribute_If_OK;\n \n          --  Check cases of discrete range for a slice\n \n@@ -707,7 +708,7 @@ package body Ch4 is\n \n          --  Here we have an expression after all, so stay in this state\n \n-         Expr_Node := P_Expression;\n+         Expr_Node := P_Expression_If_OK;\n          goto LP_State_Expr;\n \n       --  LP_State_Call corresponds to the situation in which at least\n@@ -728,8 +729,7 @@ package body Ch4 is\n             --  Deal with => (allow := as erroneous substitute)\n \n             if Token = Tok_Arrow or else Token = Tok_Colon_Equal then\n-               Arg_Node :=\n-                 New_Node (N_Parameter_Association, Prev_Token_Ptr);\n+               Arg_Node := New_Node (N_Parameter_Association, Prev_Token_Ptr);\n                Set_Selector_Name (Arg_Node, Ident_Node);\n                T_Arrow;\n                Set_Explicit_Actual_Parameter (Arg_Node, P_Expression);\n@@ -744,8 +744,7 @@ package body Ch4 is\n \n                else\n                   Prefix_Node := Name_Node;\n-                  Name_Node :=\n-                    New_Node (N_Function_Call, Sloc (Prefix_Node));\n+                  Name_Node := New_Node (N_Function_Call, Sloc (Prefix_Node));\n                   Set_Name (Name_Node, Prefix_Node);\n                   Set_Parameter_Associations (Name_Node, Arg_List);\n                   T_Right_Paren;\n@@ -776,7 +775,7 @@ package body Ch4 is\n             (\"positional parameter association \" &\n               \"not allowed after named one\");\n \n-         Expr_Node := P_Expression;\n+         Expr_Node := P_Expression_If_OK;\n \n          --  Leaving the '>' in an association is not unusual, so suggest\n          --  a possible fix.\n@@ -1101,7 +1100,7 @@ package body Ch4 is\n \n       if Token = Tok_Left_Paren then\n          Scan; -- past left paren\n-         Set_Expressions (Attr_Node, New_List (P_Expression));\n+         Set_Expressions (Attr_Node, New_List (P_Expression_If_OK));\n          T_Right_Paren;\n       end if;\n \n@@ -1204,13 +1203,20 @@ package body Ch4 is\n       Lparen_Sloc := Token_Ptr;\n       T_Left_Paren;\n \n+      --  Conditional expression case\n+\n+      if Token = Tok_If then\n+         Expr_Node := P_Conditional_Expression;\n+         T_Right_Paren;\n+         return Expr_Node;\n+\n       --  Note: the mechanism used here of rescanning the initial expression\n       --  is distinctly unpleasant, but it saves a lot of fiddling in scanning\n       --  out the discrete choice list.\n \n       --  Deal with expression and extension aggregate cases first\n \n-      if Token /= Tok_Others then\n+      elsif Token /= Tok_Others then\n          Save_Scan_State (Scan_State); -- at start of expression\n \n          --  Deal with (NULL RECORD) case\n@@ -1243,7 +1249,7 @@ package body Ch4 is\n             return Aggregate_Node;\n          end if;\n \n-         Expr_Node := P_Expression_Or_Range_Attribute;\n+         Expr_Node := P_Expression_Or_Range_Attribute_If_OK;\n \n          --  Extension aggregate case\n \n@@ -1413,7 +1419,7 @@ package body Ch4 is\n             Expr_Node := Empty;\n          else\n             Save_Scan_State (Scan_State); -- at start of expression\n-            Expr_Node := P_Expression_Or_Range_Attribute;\n+            Expr_Node := P_Expression_Or_Range_Attribute_If_OK;\n \n          end if;\n       end loop;\n@@ -1597,6 +1603,19 @@ package body Ch4 is\n       end if;\n    end P_Expression;\n \n+   --  This function is identical to the normal P_Expression, except that it\n+   --  also permits the appearence of a conditional expression without the\n+   --  usual surrounding parentheses.\n+\n+   function P_Expression_If_OK return Node_Id is\n+   begin\n+      if Token = Tok_If then\n+         return P_Conditional_Expression;\n+      else\n+         return P_Expression;\n+      end if;\n+   end P_Expression_If_OK;\n+\n    --  This function is identical to the normal P_Expression, except that it\n    --  checks that the expression scan did not stop on a right paren. It is\n    --  called in all contexts where a right parenthesis cannot legitimately\n@@ -1688,6 +1707,17 @@ package body Ch4 is\n       end if;\n    end P_Expression_Or_Range_Attribute;\n \n+   --  Version that allows a non-parenthesized conditional expression\n+\n+   function P_Expression_Or_Range_Attribute_If_OK return Node_Id is\n+   begin\n+      if Token = Tok_If then\n+         return P_Conditional_Expression;\n+      else\n+         return P_Expression_Or_Range_Attribute;\n+      end if;\n+   end P_Expression_Or_Range_Attribute_If_OK;\n+\n    -------------------\n    -- 4.4  Relation --\n    -------------------\n@@ -2332,6 +2362,32 @@ package body Ch4 is\n             when Tok_Pragma =>\n                P_Pragmas_Misplaced;\n \n+            --  Deal with IF (possible unparenthesized conditional expression)\n+\n+            when Tok_If =>\n+\n+               --  If this looks like a real if, defined as an IF appearing at\n+               --  the start of a new line, then we consider we have a missing\n+               --  operand.\n+\n+               if Token_Is_At_Start_Of_Line then\n+                  Error_Msg_AP (\"missing operand\");\n+                  return Error;\n+\n+               --  If this looks like a conditional expression, then treat it\n+               --  that way with an error messasge.\n+\n+               elsif Extensions_Allowed then\n+                  Error_Msg_SC\n+                    (\"conditional expression must be parenthesized\");\n+                  return P_Conditional_Expression;\n+\n+               --  Otherwise treat as misused identifier\n+\n+               else\n+                  return P_Identifier;\n+               end if;\n+\n             --  Anything else is illegal as the first token of a primary, but\n             --  we test for a reserved identifier so that it is treated nicely\n \n@@ -2600,4 +2656,86 @@ package body Ch4 is\n       return Alloc_Node;\n    end P_Allocator;\n \n+   ------------------------------\n+   -- P_Conditional_Expression --\n+   ------------------------------\n+\n+   function P_Conditional_Expression return Node_Id is\n+      Exprs : constant List_Id    := New_List;\n+      Loc   : constant Source_Ptr := Scan_Ptr;\n+      Expr  : Node_Id;\n+      State : Saved_Scan_State;\n+\n+   begin\n+      Inside_Conditional_Expression := Inside_Conditional_Expression + 1;\n+\n+      if Token = Tok_If and then not Extensions_Allowed then\n+         Error_Msg_SC (\"conditional expression is an Ada extension\");\n+         Error_Msg_SC (\"\\use -gnatX switch to compile this unit\");\n+      end if;\n+\n+      Scan; -- past IF or ELSIF\n+      Append_To (Exprs, P_Expression_No_Right_Paren);\n+      TF_Then;\n+      Append_To (Exprs, P_Expression);\n+\n+      --  We now have scanned out IF expr THEN expr\n+\n+      --  Check for common error of semicolon before the ELSE\n+\n+      if Token = Tok_Semicolon then\n+         Save_Scan_State (State);\n+         Scan; -- past semicolon\n+\n+         if Token = Tok_Else or else Token = Tok_Elsif then\n+            Error_Msg_SP (\"|extra \"\";\"\" ignored\");\n+\n+         else\n+            Restore_Scan_State (State);\n+         end if;\n+      end if;\n+\n+      --  Scan out ELSIF sequence if present\n+\n+      if Token = Tok_Elsif then\n+         Expr := P_Conditional_Expression;\n+         Set_Is_Elsif (Expr);\n+         Append_To (Exprs, Expr);\n+\n+      --  Scan out ELSE phrase if present\n+\n+      elsif Token = Tok_Else then\n+\n+         --  Scan out ELSE expression\n+\n+         Scan; -- Past ELSE\n+         Append_To (Exprs, P_Expression);\n+\n+      --  Two expression case (implied True, filled in during semantics)\n+\n+      else\n+         null;\n+      end if;\n+\n+      --  If we have an END IF, diagnose as not needed\n+\n+      if Token = Tok_End then\n+         Error_Msg_SC\n+           (\"`END IF` not allowed at end of conditional expression\");\n+         Scan; -- past END\n+\n+         if Token = Tok_If then\n+            Scan; -- past IF;\n+         end if;\n+      end if;\n+\n+      Inside_Conditional_Expression := Inside_Conditional_Expression - 1;\n+\n+      --  Return the Conditional_Expression node\n+\n+      return\n+        Make_Conditional_Expression (Loc,\n+          Expressions => Exprs);\n+   end P_Conditional_Expression;\n+\n end Ch4;"}, {"sha": "769e3e47c3425f9141e9ec57e8412c0217282fa6", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=b46be8a2b70f416b8c12697885b5c7a315a3aeba", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -664,7 +664,6 @@ is\n    package Ch4 is\n       function P_Aggregate                            return Node_Id;\n       function P_Expression                           return Node_Id;\n-      function P_Expression_No_Right_Paren            return Node_Id;\n       function P_Expression_Or_Range_Attribute        return Node_Id;\n       function P_Function_Name                        return Node_Id;\n       function P_Name                                 return Node_Id;\n@@ -673,9 +672,25 @@ is\n       function P_Simple_Expression                    return Node_Id;\n       function P_Simple_Expression_Or_Range_Attribute return Node_Id;\n \n-      function P_Qualified_Expression\n-        (Subtype_Mark : Node_Id)\n-         return         Node_Id;\n+      function P_Conditional_Expression return Node_Id;\n+      --  Scans out a conditional expression. Called with token pointing to\n+      --  the IF keyword, and returns pointing to the terminating right paren,\n+      --  semicolon or comma, but does not consume this terminating token.\n+\n+      function P_Expression_If_OK return Node_Id;\n+      --  Scans out an expression in a context where a conditional expression\n+      --  is permitted to appear without surrounding parentheses.\n+\n+      function P_Expression_No_Right_Paren return Node_Id;\n+      --  Scans out an expression in contexts where the expression cannot be\n+      --  terminated by a right paren (gives better error recovery if an errant\n+      --  right paren is found after the expression).\n+\n+      function P_Expression_Or_Range_Attribute_If_OK return Node_Id;\n+      --  Scans out an expression or range attribute where a conditional\n+      --  expression is permitted to appear without surrounding parentheses.\n+\n+      function P_Qualified_Expression (Subtype_Mark : Node_Id) return Node_Id;\n       --  This routine scans out a qualified expression when the caller has\n       --  already scanned out the name and apostrophe of the construct.\n    end Ch4;\n@@ -1131,6 +1146,7 @@ is\n \n       function Token_Is_At_End_Of_Line return Boolean;\n       --  Determines if the current token is the last token on the line\n+\n    end Util;\n \n    --------------"}, {"sha": "30da224d90540e02f255b4a481e2d6dc31783bf3", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=b46be8a2b70f416b8c12697885b5c7a315a3aeba", "patch": "@@ -2412,11 +2412,16 @@ package body Scng is\n                   Style.Non_Lower_Case_Keyword;\n                end if;\n \n+               --  Check THEN/ELSE style rules. These do not apply to AND THEN\n+               --  or OR ELSE, and do not apply in conditional expressions.\n+\n                if (Token = Tok_Then and then Prev_Token /= Tok_And)\n                     or else\n                   (Token = Tok_Else and then Prev_Token /= Tok_Or)\n                then\n-                  Style.Check_Separate_Stmt_Lines;\n+                  if Inside_Conditional_Expression = 0 then\n+                     Style.Check_Separate_Stmt_Lines;\n+                  end if;\n                end if;\n             end if;\n \n@@ -2550,7 +2555,6 @@ package body Scng is\n          else\n             exit Tabs_Loop;\n          end if;\n-\n       end loop Tabs_Loop;\n \n       return Start_Column;"}, {"sha": "6303dd1ac418395158248e4187d69a938d167117", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=b46be8a2b70f416b8c12697885b5c7a315a3aeba", "patch": "@@ -1237,10 +1237,19 @@ package body Sem_Ch4 is\n       Condition : constant Node_Id := First (Expressions (N));\n       Then_Expr : constant Node_Id := Next (Condition);\n       Else_Expr : constant Node_Id := Next (Then_Expr);\n+\n    begin\n+      if Comes_From_Source (N) then\n+         Check_Compiler_Unit (N);\n+      end if;\n+\n       Analyze_Expression (Condition);\n       Analyze_Expression (Then_Expr);\n-      Analyze_Expression (Else_Expr);\n+\n+      if Present (Else_Expr) then\n+         Analyze_Expression (Else_Expr);\n+      end if;\n+\n       Set_Etype (N, Etype (Then_Expr));\n    end Analyze_Conditional_Expression;\n "}, {"sha": "95f3c9b147018de77de6675c03420dead17c8afa", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b46be8a2b70f416b8c12697885b5c7a315a3aeba", "patch": "@@ -3990,7 +3990,7 @@ package body Sem_Res is\n             null;\n \n          elsif (Is_Class_Wide_Type (Etype (Expression (E)))\n-              or else Is_Class_Wide_Type (Etype (E)))\n+                 or else Is_Class_Wide_Type (Etype (E)))\n            and then Base_Type (Etype (Expression (E))) /= Base_Type (Etype (E))\n          then\n             Wrong_Type (Expression (E), Etype (E));\n@@ -5530,11 +5530,32 @@ package body Sem_Res is\n    procedure Resolve_Conditional_Expression (N : Node_Id; Typ : Entity_Id) is\n       Condition : constant Node_Id := First (Expressions (N));\n       Then_Expr : constant Node_Id := Next (Condition);\n-      Else_Expr : constant Node_Id := Next (Then_Expr);\n+      Else_Expr : Node_Id := Next (Then_Expr);\n+\n    begin\n-      Resolve (Condition, Standard_Boolean);\n+      Resolve (Condition, Any_Boolean);\n       Resolve (Then_Expr, Typ);\n-      Resolve (Else_Expr, Typ);\n+\n+      --  If ELSE expression present, just resolve using the determined type\n+\n+      if Present (Else_Expr) then\n+         Resolve (Else_Expr, Typ);\n+\n+      --  If no ELSE expression is present, root type must be Standard.Boolean\n+      --  and we provide a Standard.True result converted to the appropriate\n+      --  Boolean type (in case it is a derived boolean type).\n+\n+      elsif Root_Type (Typ) = Standard_Boolean then\n+         Else_Expr :=\n+           Convert_To (Typ, New_Occurrence_Of (Standard_True, Sloc (N)));\n+         Analyze_And_Resolve (Else_Expr, Typ);\n+         Append_To (Expressions (N), Else_Expr);\n+\n+      else\n+         Error_Msg_N (\"can only omit ELSE expression in Boolean case\", N);\n+         Append_To (Expressions (N), Error);\n+      end if;\n+\n       Set_Etype (N, Typ);\n       Eval_Conditional_Expression (N);\n    end Resolve_Conditional_Expression;"}, {"sha": "866dd5f72cd601010ae72612cbe46ad53436fd1b", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=b46be8a2b70f416b8c12697885b5c7a315a3aeba", "patch": "@@ -1605,6 +1605,14 @@ package body Sinfo is\n       return Flag18 (N);\n    end Is_Dynamic_Coextension;\n \n+   function Is_Elsif\n+     (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Conditional_Expression);\n+      return Flag13 (N);\n+   end Is_Elsif;\n+\n    function Is_Entry_Barrier_Function\n       (N : Node_Id) return Boolean is\n    begin\n@@ -4393,6 +4401,14 @@ package body Sinfo is\n       Set_Flag18 (N, Val);\n    end Set_Is_Dynamic_Coextension;\n \n+   procedure Set_Is_Elsif\n+     (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Conditional_Expression);\n+      Set_Flag13 (N, Val);\n+   end Set_Is_Elsif;\n+\n    procedure Set_Is_Entry_Barrier_Function\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "7f04e8878767b4fcec85b0a48631c8ddb6cb7f06", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46be8a2b70f416b8c12697885b5c7a315a3aeba/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=b46be8a2b70f416b8c12697885b5c7a315a3aeba", "patch": "@@ -6438,6 +6438,11 @@ package Sinfo is\n    --  reconstructed tree printed by Sprint, and the node descriptions here\n    --  show this syntax.\n \n+   --  Note: Conditional_Expression is in this section for historical reasons.\n+   --  We will move it to its appropriate place when it is officially approved\n+   --  as an extension (and then we will know what the exact grammar and place\n+   --  in the Reference Manual is!)\n+\n       ----------------------------\n       -- Conditional Expression --\n       ----------------------------\n@@ -6452,18 +6457,33 @@ package Sinfo is\n       --  No_List in the tree passed to Gigi. These fields are used only\n       --  for temporary processing purposes in the expander.\n \n-      --  Sprint syntax: (if expr then expr else expr)\n+      --  The Ada language does not permit conditional expressions, however\n+      --  this is under discussion as a possible extension by the ARG, and we\n+      --  have implemented a form of this capability in GNAT under control of\n+      --  the -X switch. The syntax is:\n+\n+      --  CONDITIONAL_EXPRESSION ::=\n+      --    if EXPRESSION then EXPRESSION\n+      --                  {elsif EXPRESSION then EXPRESSION}\n+      --                  [else EXPRESSION]\n+\n+      --  And we add the additional constructs\n+\n+      --  PRIMARY ::= ( CONDITIONAL_EXPRESION )\n+      --  PRAGMA_ARGUMENT_ASSOCIATION ::= CONDITIONAL_EXPRESSION\n+\n+      --  Note: if we have (IF x1 THEN x2 ELSIF x3 THEN x4 ELSE x5) then it\n+      --  is represented as (IF x1 THEN x2 ELSE (IF x3 THEN x4 ELSE x5)) and\n+      --  the Is_Elsif flag is set on the inner conditional expression.\n \n       --  N_Conditional_Expression\n-      --  Sloc points to related node\n+      --  Sloc points to IF or ELSIF keyword\n       --  Expressions (List1)\n       --  Then_Actions (List2-Sem)\n       --  Else_Actions (List3-Sem)\n+      --  Is_Elsif (Flag13) (set if comes from ELSIF)\n       --  plus fields for expression\n \n-      --  Note: in the case where a debug source file is generated, the Sloc\n-      --  for this node points to the IF keyword in the Sprint file output.\n-\n       -------------------\n       -- Expanded_Name --\n       -------------------\n@@ -7956,6 +7976,9 @@ package Sinfo is\n    function Is_Dynamic_Coextension\n      (N : Node_Id) return Boolean;    -- Flag18\n \n+   function Is_Elsif\n+     (N : Node_Id) return Boolean;    -- Flag13\n+\n    function Is_Entry_Barrier_Function\n      (N : Node_Id) return Boolean;    -- Flag8\n \n@@ -8844,6 +8867,9 @@ package Sinfo is\n    procedure Set_Is_Dynamic_Coextension\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n+   procedure Set_Is_Elsif\n+     (N : Node_Id; Val : Boolean := True);    -- Flag13\n+\n    procedure Set_Is_Entry_Barrier_Function\n      (N : Node_Id; Val : Boolean := True);    -- Flag8\n \n@@ -11042,6 +11068,7 @@ package Sinfo is\n    pragma Inline (Is_Component_Right_Opnd);\n    pragma Inline (Is_Controlling_Actual);\n    pragma Inline (Is_Dynamic_Coextension);\n+   pragma Inline (Is_Elsif);\n    pragma Inline (Is_Entry_Barrier_Function);\n    pragma Inline (Is_Expanded_Build_In_Place_Call);\n    pragma Inline (Is_Folded_In_Parser);\n@@ -11334,6 +11361,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Component_Right_Opnd);\n    pragma Inline (Set_Is_Controlling_Actual);\n    pragma Inline (Set_Is_Dynamic_Coextension);\n+   pragma Inline (Set_Is_Elsif);\n    pragma Inline (Set_Is_Entry_Barrier_Function);\n    pragma Inline (Set_Is_Expanded_Build_In_Place_Call);\n    pragma Inline (Set_Is_Folded_In_Parser);"}]}