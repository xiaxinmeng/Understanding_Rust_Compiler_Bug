{"sha": "0df38d45e19aecc86c549ec57be93b7c7d9ac867", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRmMzhkNDVlMTlhZWNjODZjNTQ5ZWM1N2JlOTNiN2M3ZDlhYzg2Nw==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2007-04-18T17:10:32Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2007-04-18T17:10:32Z"}, "message": "natVMProxy.cc (ncode_closure): Add method_index.\n\n2007-04-18  Andrew Haley  <aph@redhat.com>\n\n        * java/lang/reflect/natVMProxy.cc (ncode_closure): Add\n        method_index.\n        (generateProxyClass): Add field $Proxy0.m.  Store methods array in\n        it.\n        (run_proxy): Retrieve the method to invoke from in $Proxy0.m.\n        * java/lang/Class.h: Remove _Jv_LookupProxyMethod.\n        * java/lang/natClass.cc: Likewise.\n        * headers.txt: Likewise.\n\nFrom-SVN: r123953", "tree": {"sha": "53c69afa81897fd48bf2309e77c09532bfa1178f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53c69afa81897fd48bf2309e77c09532bfa1178f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0df38d45e19aecc86c549ec57be93b7c7d9ac867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0df38d45e19aecc86c549ec57be93b7c7d9ac867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0df38d45e19aecc86c549ec57be93b7c7d9ac867", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0df38d45e19aecc86c549ec57be93b7c7d9ac867/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "431f60c0eb439bfe4808f549d5bb1fe20e72b29c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/431f60c0eb439bfe4808f549d5bb1fe20e72b29c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/431f60c0eb439bfe4808f549d5bb1fe20e72b29c"}], "stats": {"total": 102, "additions": 50, "deletions": 52}, "files": [{"sha": "9a874aea297c57bc3e434f56691f4b1b48decfb2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0df38d45e19aecc86c549ec57be93b7c7d9ac867/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0df38d45e19aecc86c549ec57be93b7c7d9ac867/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0df38d45e19aecc86c549ec57be93b7c7d9ac867", "patch": "@@ -1,3 +1,14 @@\n+2007-04-18  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/reflect/natVMProxy.cc (ncode_closure): Add\n+\tmethod_index.\n+\t(generateProxyClass): Add field $Proxy0.m.  Store methods array in\n+\tit.\n+\t(run_proxy): Retrieve the method to invoke from in $Proxy0.m.\n+\t* java/lang/Class.h: Remove _Jv_LookupProxyMethod.\n+\t* java/lang/natClass.cc: Likewise.\n+\t* headers.txt: Likewise.\n+\n 2007-04-16  Andrew Haley  <aph@redhat.com>\n \n \t* gnu/gcj/runtime/BootClassLoader.java (getBootURLLoader): New"}, {"sha": "c7a4caa3bf4f73c0b85aa0c7a8d8a30844e028f5", "filename": "libjava/headers.txt", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0df38d45e19aecc86c549ec57be93b7c7d9ac867/libjava%2Fheaders.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0df38d45e19aecc86c549ec57be93b7c7d9ac867/libjava%2Fheaders.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fheaders.txt?ref=0df38d45e19aecc86c549ec57be93b7c7d9ac867", "patch": "@@ -57,13 +57,11 @@ class java/lang/reflect/Method\n prepend jmethodID _Jv_FromReflectedMethod (java::lang::reflect::Method *);\n prepend jobject _Jv_JNI_ToReflectedMethod (_Jv_JNIEnv *, jclass, jmethodID, jboolean);\n prepend ::java::lang::reflect::Method *_Jv_GetReflectedMethod (jclass, _Jv_Utf8Const*, _Jv_Utf8Const*);\n-prepend ::java::lang::reflect::Method *_Jv_LookupProxyMethod (jclass, _Jv_Utf8Const *, _Jv_Utf8Const *);\n friend jmethodID (::_Jv_FromReflectedMethod) (java::lang::reflect::Method *);\n friend jobject (::_Jv_JNI_ToReflectedMethod) (_Jv_JNIEnv *, jclass, jmethodID, jboolean);\n friend class java::lang::Class;\n friend class java::io::ObjectInputStream;\n friend java::lang::reflect::Method* ::_Jv_GetReflectedMethod (jclass, _Jv_Utf8Const*, _Jv_Utf8Const*);\n-friend java::lang::reflect::Method* ::_Jv_LookupProxyMethod (jclass, _Jv_Utf8Const *, _Jv_Utf8Const *);\n \n class gnu/gcj/runtime/ExtensionClassLoader\n friend class ::java::lang::ClassLoader;"}, {"sha": "af0219892f1ec102f2779a3ba994a4e8f1cd11c3", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0df38d45e19aecc86c549ec57be93b7c7d9ac867/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0df38d45e19aecc86c549ec57be93b7c7d9ac867/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=0df38d45e19aecc86c549ec57be93b7c7d9ac867", "patch": "@@ -237,8 +237,6 @@ _Jv_Method* _Jv_LookupDeclaredMethod (jclass, _Jv_Utf8Const *,\n java::lang::reflect::Method *_Jv_GetReflectedMethod (jclass klass, \n \t\t\t\t\t\t    _Jv_Utf8Const *name,\n \t\t\t\t\t\t    _Jv_Utf8Const *signature);\n-java::lang::reflect::Method *_Jv_LookupProxyMethod (jclass, _Jv_Utf8Const *,\n-\t\t\t\t\t\t    _Jv_Utf8Const *);\n jfieldID JvGetFirstInstanceField (jclass);\n jint JvNumInstanceFields (jclass);\n jfieldID JvGetFirstStaticField (jclass);\n@@ -547,9 +545,6 @@ class java::lang::Class : public java::lang::Object\n   friend java::lang::reflect::Method* ::_Jv_GetReflectedMethod (jclass klass, \n \t\t\t\t\t\t    _Jv_Utf8Const *name,\n \t\t\t\t\t\t    _Jv_Utf8Const *signature);\n-  friend java::lang::reflect::Method *::_Jv_LookupProxyMethod (jclass, _Jv_Utf8Const *,\n-\t\t\t\t\t\t\t       _Jv_Utf8Const *);\n-\n   friend jfieldID (::JvGetFirstInstanceField) (jclass);\n   friend jint (::JvNumInstanceFields) (jclass);\n   friend jfieldID (::JvGetFirstStaticField) (jclass);"}, {"sha": "754681d832abb1b99f6fb0cb23757cff63fe1bbc", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0df38d45e19aecc86c549ec57be93b7c7d9ac867/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0df38d45e19aecc86c549ec57be93b7c7d9ac867/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=0df38d45e19aecc86c549ec57be93b7c7d9ac867", "patch": "@@ -1653,39 +1653,6 @@ _Jv_LookupDeclaredMethod (jclass klass, _Jv_Utf8Const *name,\n   return NULL;\n }\n \n-// The rules for finding proxy methods are different: first we search\n-// the interfaces implemented by a proxy, then the methods declared in\n-// class Proxy.\n-\n-java::lang::reflect::Method *\n-_Jv_LookupProxyMethod (jclass proxyClass, _Jv_Utf8Const *name,\n-\t\t       _Jv_Utf8Const *signature)\n-{\n-  using namespace java::lang::reflect;\n-  jclass declaringClass;\n-  _Jv_Method * m;\n-\n-  for (int i = 0; i < proxyClass->interface_count; i++)\n-    {\n-      declaringClass = proxyClass->interfaces[i];\n-      m = _Jv_GetMethodLocal (declaringClass, name, signature);\n-      if (m)\n-\tbreak;\n-    }\n-  if (!m)\n-    m = _Jv_LookupDeclaredMethod (&Proxy::class$,\n-\t\t\t\t  name,\n-\t\t\t\t  signature,\n-\t\t\t\t  &declaringClass);\n-\n-  Method *rmethod = new Method ();\n-  rmethod->offset = (char*) m - (char*) declaringClass->methods;\n-  rmethod->declaringClass = declaringClass;\n-  return rmethod;\n-}\n-\n-\n-\n java::lang::reflect::Method *\n _Jv_GetReflectedMethod (jclass klass, _Jv_Utf8Const *name,\n \t\t       _Jv_Utf8Const *signature)"}, {"sha": "e5f8fbe52aa2681983dff4536e8626c385a3a164", "filename": "libjava/java/lang/reflect/natVMProxy.cc", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0df38d45e19aecc86c549ec57be93b7c7d9ac867/libjava%2Fjava%2Flang%2Freflect%2FnatVMProxy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0df38d45e19aecc86c549ec57be93b7c7d9ac867/libjava%2Fjava%2Flang%2Freflect%2FnatVMProxy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatVMProxy.cc?ref=0df38d45e19aecc86c549ec57be93b7c7d9ac867", "patch": "@@ -66,7 +66,7 @@ using namespace java::lang::reflect;\n using namespace java::lang;\n \n typedef void (*closure_fun) (ffi_cif*, void*, void**, void*);\n-static void *ncode (jclass klass, _Jv_Method *self, closure_fun fun);\n+static void *ncode (int method_index, jclass klass, _Jv_Method *self, closure_fun fun);\n static void run_proxy (ffi_cif*, void*, void**, void*);\n \n typedef jobject invoke_t (jobject, Proxy *, Method *, JArray< jobject > *);\n@@ -92,15 +92,24 @@ java::lang::reflect::VMProxy::generateProxyClass\n     return (new Proxy$ClassFactory(d))->generate(loader);\n \n   jclass klass = new Class ();\n-  klass->superclass = &Proxy::class$;\n-  klass->engine = &_Jv_soleIndirectCompiledEngine;\n-  klass->size_in_bytes = Proxy::class$.size_in_bytes;\n-  klass->vtable_method_count = -1;\n \n   // Synchronize on the class, so that it is not attempted initialized\n   // until we're done.\n   JvSynchronize sync (klass);\n \n+  klass->superclass = &Proxy::class$;\n+  klass->engine = &_Jv_soleIndirectCompiledEngine;\n+  klass->size_in_bytes = -1;\n+  klass->vtable_method_count = -1;\n+\n+  // Declare  private static transient java.lang.reflect.Method[] $Proxy0.m\n+  klass->field_count = klass->static_field_count = 1;\n+  klass->fields = (_Jv_Field*)_Jv_AllocRawObj (sizeof (_Jv_Field));\n+  klass->fields[0].name = _Jv_makeUtf8Const (\"m\");\n+  klass->fields[0].type = d->methods->getClass();\n+  klass->fields[0].flags = (Modifier::PRIVATE | Modifier::STATIC \n+\t\t\t    | Modifier::TRANSIENT);\n+\n   // Record the defining loader.  For the bootstrap class loader,\n   // we record NULL.\n   if (loader != VMClassLoader::bootLoader)\n@@ -158,20 +167,27 @@ java::lang::reflect::VMProxy::generateProxyClass\n   for (size_t i = 0; i < count; i++)\n     {\n       _Jv_Method &method = klass->methods[method_count++];\n-      const _Jv_Method &imethod = *_Jv_FromReflectedMethod (elements(d->methods)[i]);\n+      const _Jv_Method &imethod \n+\t= *_Jv_FromReflectedMethod (elements(d->methods)[i]);\n       // We use a shallow copy of IMETHOD rather than a deep copy;\n       // this means that the pointer fields of METHOD point into the\n       // interface.  As long as this subclass of Proxy is reachable,\n       // the interfaces of which it is a proxy will also be reachable,\n       // so this is safe.\n       method = imethod;\n-      method.ncode = ncode (klass, &method, run_proxy);\n+      method.ncode = ncode (i, klass, &method, run_proxy);\n       method.accflags &= ~Modifier::ABSTRACT;\n     }\n \n   _Jv_Linker::layout_vtable_methods (klass);\n   _Jv_RegisterInitiatingLoader (klass, klass->loader);\n \n+  // Set $Proxy0.m to point to the methods arrray\n+  java::lang::reflect::Field *f\n+    = klass->getDeclaredField (JvNewStringLatin1 (\"m\"));\n+  f->flag = true;\n+  f->set(NULL, d->methods);\n+\n   return klass;\n }\n \n@@ -292,6 +308,7 @@ typedef struct {\n   _Jv_ClosureList list;\n   ffi_cif   cif;\n   _Jv_Method *self;\n+  int method_index;\n   ffi_type *arg_types[0];\n } ncode_closure;\n \n@@ -306,17 +323,26 @@ run_proxy (ffi_cif *cif,\n   Proxy *proxy = *(Proxy**)args[0];\n   ncode_closure *self = (ncode_closure *) user_data;\n \n+  jclass proxyClass = proxy->getClass();\n+\n   // FRAME_DESC registers this particular invocation as the top-most\n   // interpreter frame.  This lets the stack tracing code (for\n   // Throwable) print information about the Proxy being run rather\n   // than about Proxy.class itself.  FRAME_DESC has a destructor so it\n   // cleans up automatically when this proxy invocation returns.\n   Thread *thread = Thread::currentThread();\n-  _Jv_InterpFrame frame_desc (self->self, thread, proxy->getClass());\n+  _Jv_InterpFrame frame_desc (self->self, thread, proxyClass);\n+\n+  // The method to invoke is saved in $Proxy0.m[method_index].\n+  // FIXME: We could somewhat improve efficiency by storing a pointer\n+  // to the method (rather than its index) in ncode_closure.  This\n+  // would avoid the lookup, but it probably wouldn't make a huge\n+  // difference.  We'd still have to save the method array because\n+  // ncode structs are not scanned by the gc.\n+  Field *f = proxyClass->getDeclaredField (JvNewStringLatin1 (\"m\"));\n+  JArray<Method*> *methods = (JArray<Method*>*)f->get (NULL);\n+  Method *meth = elements(methods)[self->method_index];\n \n-  Method *meth = _Jv_LookupProxyMethod (proxy->getClass(), \n-\t\t\t\t\tself->self->name,\n-\t\t\t\t\tself->self->signature);\n   JArray<jclass> *parameter_types = meth->internalGetParameterTypes ();\n   JArray<jclass> *exception_types = meth->internalGetExceptionTypes ();\n \n@@ -374,7 +400,7 @@ run_proxy (ffi_cif *cif,\n // the address of its closure.\n \n static void *\n-ncode (jclass klass, _Jv_Method *self, closure_fun fun)\n+ncode (int method_index, jclass klass, _Jv_Method *self, closure_fun fun)\n {\n   using namespace java::lang::reflect;\n \n@@ -386,6 +412,7 @@ ncode (jclass klass, _Jv_Method *self, closure_fun fun)\n     (ncode_closure*)ffi_closure_alloc (sizeof (ncode_closure)\n \t\t\t\t       + arg_count * sizeof (ffi_type*),\n \t\t\t\t       &code);\n+  closure->method_index = method_index;\n   closure->list.registerClosure (klass, closure);\n \n   _Jv_init_cif (self->signature,"}]}