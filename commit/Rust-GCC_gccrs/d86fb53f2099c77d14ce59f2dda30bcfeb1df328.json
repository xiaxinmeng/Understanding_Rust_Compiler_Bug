{"sha": "d86fb53f2099c77d14ce59f2dda30bcfeb1df328", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg2ZmI1M2YyMDk5Yzc3ZDE0Y2U1OWYyZGRhMzBiY2ZlYjFkZjMyOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-05-02T08:47:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-05-02T08:47:29Z"}, "message": "[multiple changes]\n\n2017-05-02  Bob Duff  <duff@adacore.com>\n\n\t* s-taprop-linux.adb (Prio_To_Linux_Prio): New function to correctly\n\tcompute the linux priority from the Ada priority. Call this everywhere\n\trequired. In particular, the previous version was not doing this\n\tcomputation when setting the ceiling priority in various places. It\n\twas just converting to C.int, which results in a ceiling that is off\n\tby 1.\n\n2017-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb: Comment predicate inheritance.\n\nFrom-SVN: r247473", "tree": {"sha": "fa9f0c3f1c24c8e266bc699e969ce08c9b7a2d41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa9f0c3f1c24c8e266bc699e969ce08c9b7a2d41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d86fb53f2099c77d14ce59f2dda30bcfeb1df328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d86fb53f2099c77d14ce59f2dda30bcfeb1df328", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d86fb53f2099c77d14ce59f2dda30bcfeb1df328", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d86fb53f2099c77d14ce59f2dda30bcfeb1df328/comments", "author": null, "committer": null, "parents": [{"sha": "c5b4738f5730e10f2f4200c950adebd5f38bba49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b4738f5730e10f2f4200c950adebd5f38bba49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5b4738f5730e10f2f4200c950adebd5f38bba49"}], "stats": {"total": 265, "additions": 145, "deletions": 120}, "files": [{"sha": "0d53e03c9258163b221c67862d263c8db01bcd5b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86fb53f2099c77d14ce59f2dda30bcfeb1df328/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86fb53f2099c77d14ce59f2dda30bcfeb1df328/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d86fb53f2099c77d14ce59f2dda30bcfeb1df328", "patch": "@@ -1,3 +1,16 @@\n+2017-05-02  Bob Duff  <duff@adacore.com>\n+\n+\t* s-taprop-linux.adb (Prio_To_Linux_Prio): New function to correctly\n+\tcompute the linux priority from the Ada priority. Call this everywhere\n+\trequired. In particular, the previous version was not doing this\n+\tcomputation when setting the ceiling priority in various places. It\n+\twas just converting to C.int, which results in a ceiling that is off\n+\tby 1.\n+\n+2017-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb: Comment predicate inheritance.\n+\n 2017-05-02  Tristan Gingold  <gingold@adacore.com>\n \n \t* s-trasym.ads: Add comment."}, {"sha": "1d829de6ee023d45e5af11bd975ea98183a33e20", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 127, "deletions": 119, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86fb53f2099c77d14ce59f2dda30bcfeb1df328/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86fb53f2099c77d14ce59f2dda30bcfeb1df328/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=d86fb53f2099c77d14ce59f2dda30bcfeb1df328", "patch": "@@ -38,7 +38,7 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n-with Interfaces.C;\n+with Interfaces.C; use Interfaces; use type Interfaces.C.int;\n \n with System.Task_Info;\n with System.Tasking.Debug;\n@@ -60,7 +60,6 @@ package body System.Task_Primitives.Operations is\n \n    use System.Tasking.Debug;\n    use System.Tasking;\n-   use Interfaces.C;\n    use System.OS_Interface;\n    use System.Parameters;\n    use System.OS_Primitives;\n@@ -111,14 +110,6 @@ package body System.Task_Primitives.Operations is\n    --  Constant to indicate that the thread identifier has not yet been\n    --  initialized.\n \n-   function geteuid return Integer;\n-   pragma Import (C, geteuid, \"geteuid\");\n-   pragma Warnings (Off, \"non-static call not allowed in preelaborated unit\");\n-   Superuser : constant Boolean := geteuid = 0;\n-   pragma Warnings (On, \"non-static call not allowed in preelaborated unit\");\n-   --  True if we are running as 'root'. On Linux, ceiling priorities work only\n-   --  in that case, so if this is False, we ignore Locking_Policy = 'C'.\n-\n    --------------------\n    -- Local Packages --\n    --------------------\n@@ -170,17 +161,52 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Handler (signo : Signal);\n \n    function GNAT_pthread_condattr_setup\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C,\n-     GNAT_pthread_condattr_setup, \"__gnat_pthread_condattr_setup\");\n+     (attr : access pthread_condattr_t) return C.int;\n+   pragma Import\n+     (C, GNAT_pthread_condattr_setup, \"__gnat_pthread_condattr_setup\");\n+\n+   function Prio_To_Linux_Prio (Prio : Any_Priority) return C.int is\n+     (C.int (Prio) + 1);\n+   --  Convert Ada priority to Linux priority. Priorities are 1 .. 99 on\n+   --  GNU/Linux, so we map 0 .. 98 to 1 .. 99.\n+\n+   function Get_Ceiling_Support return Boolean;\n+   --  Get the value of the Ceiling_Support constant (see below).\n+   --  ???For now, we're returning True only if running as superuser,\n+   --  and ignore capabilities.\n+\n+   function Get_Ceiling_Support return Boolean is\n+      Ceiling_Support : Boolean := False;\n+   begin\n+      if Locking_Policy = 'C' then\n+         declare\n+            function geteuid return Integer;\n+            pragma Import (C, geteuid, \"geteuid\");\n+            Superuser : constant Boolean := geteuid = 0;\n+         begin\n+            if Superuser then\n+               Ceiling_Support := True;\n+            end if;\n+         end;\n+      end if;\n+\n+      return Ceiling_Support;\n+   end Get_Ceiling_Support;\n+\n+   pragma Warnings (Off, \"non-static call not allowed in preelaborated unit\");\n+   Ceiling_Support : constant Boolean := Get_Ceiling_Support;\n+   pragma Warnings (On, \"non-static call not allowed in preelaborated unit\");\n+   --  True if the locking policy is Ceiling_Locking, and the current process\n+   --  has permission to use this policy. The process has permission if it is\n+   --  running as 'root', or if the capability was set by the setcap command,\n+   --  as in \"sudo /sbin/setcap cap_sys_nice=ep exe_file\". If it doesn't have\n+   --  permission, then a request for Ceiling_Locking is ignored.\n \n    type RTS_Lock_Ptr is not null access all RTS_Lock;\n \n-   function Init_Mutex\n-     (L : RTS_Lock_Ptr; Prio : Any_Priority)\n-     return Interfaces.C.int;\n-   --  Initialize the mutex L. If the locking policy is Ceiling_Locking, then\n-   --  set the ceiling to Prio.\n+   function Init_Mutex (L : RTS_Lock_Ptr; Prio : Any_Priority) return C.int;\n+   --  Initialize the mutex L. If Ceiling_Support is True, then set the ceiling\n+   --  to Prio. Returns 0 for success, or ENOMEM for out-of-memory.\n \n    -------------------\n    -- Abort_Handler --\n@@ -190,7 +216,7 @@ package body System.Task_Primitives.Operations is\n       pragma Unreferenced (signo);\n \n       Self_Id : constant Task_Id := Self;\n-      Result  : Interfaces.C.int;\n+      Result  : C.int;\n       Old_Set : aliased sigset_t;\n \n    begin\n@@ -272,30 +298,26 @@ package body System.Task_Primitives.Operations is\n    -- Init_Mutex --\n    ----------------\n \n-   function Init_Mutex\n-     (L : RTS_Lock_Ptr; Prio : Any_Priority)\n-     return Interfaces.C.int\n-   is\n+   function Init_Mutex (L : RTS_Lock_Ptr; Prio : Any_Priority) return C.int is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n+      Result, Result_2 : C.int;\n+\n    begin\n       Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+      pragma Assert (Result in 0 | ENOMEM);\n \n       if Result = ENOMEM then\n-         return ENOMEM;\n+         return Result;\n       end if;\n \n-      if Locking_Policy = 'C' then\n-         if Superuser then\n-            Result := pthread_mutexattr_setprotocol\n-              (Mutex_Attr'Access, PTHREAD_PRIO_PROTECT);\n-            pragma Assert (Result = 0);\n+      if Ceiling_Support then\n+         Result := pthread_mutexattr_setprotocol\n+           (Mutex_Attr'Access, PTHREAD_PRIO_PROTECT);\n+         pragma Assert (Result = 0);\n \n-            Result := pthread_mutexattr_setprioceiling\n-              (Mutex_Attr'Access, Interfaces.C.int (Prio));\n-            pragma Assert (Result = 0);\n-         end if;\n+         Result := pthread_mutexattr_setprioceiling\n+           (Mutex_Attr'Access, Prio_To_Linux_Prio (Prio));\n+         pragma Assert (Result = 0);\n \n       elsif Locking_Policy = 'I' then\n          Result := pthread_mutexattr_setprotocol\n@@ -304,16 +326,11 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Result := pthread_mutex_init (L, Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+      pragma Assert (Result in 0 | ENOMEM);\n \n-      if Result = ENOMEM then\n-         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-         return ENOMEM;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-      pragma Assert (Result = 0);\n-      return 0;\n+      Result_2 := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result_2 = 0);\n+      return Result; -- of pthread_mutex_init, not pthread_mutexattr_destroy\n    end Init_Mutex;\n \n    ---------------------\n@@ -327,14 +344,14 @@ package body System.Task_Primitives.Operations is\n    --  routines should be able to be handled safely.\n \n    procedure Initialize_Lock\n-     (Prio : System.Any_Priority;\n+     (Prio : Any_Priority;\n       L    : not null access Lock)\n    is\n    begin\n       if Locking_Policy = 'R' then\n          declare\n             RWlock_Attr : aliased pthread_rwlockattr_t;\n-            Result      : Interfaces.C.int;\n+            Result      : C.int;\n \n          begin\n             --  Set the rwlock to prefer writer to avoid writers starvation\n@@ -349,7 +366,7 @@ package body System.Task_Primitives.Operations is\n \n             Result := pthread_rwlock_init (L.RW'Access, RWlock_Attr'Access);\n \n-            pragma Assert (Result = 0 or else Result = ENOMEM);\n+            pragma Assert (Result in 0 | ENOMEM);\n \n             if Result = ENOMEM then\n                raise Storage_Error with \"Failed to allocate a lock\";\n@@ -378,7 +395,7 @@ package body System.Task_Primitives.Operations is\n    -------------------\n \n    procedure Finalize_Lock (L : not null access Lock) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n    begin\n       if Locking_Policy = 'R' then\n          Result := pthread_rwlock_destroy (L.RW'Access);\n@@ -389,7 +406,7 @@ package body System.Task_Primitives.Operations is\n    end Finalize_Lock;\n \n    procedure Finalize_Lock (L : not null access RTS_Lock) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n    begin\n       Result := pthread_mutex_destroy (L);\n       pragma Assert (Result = 0);\n@@ -403,7 +420,7 @@ package body System.Task_Primitives.Operations is\n      (L                 : not null access Lock;\n       Ceiling_Violation : out Boolean)\n    is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n    begin\n       if Locking_Policy = 'R' then\n          Result := pthread_rwlock_wrlock (L.RW'Access);\n@@ -413,15 +430,15 @@ package body System.Task_Primitives.Operations is\n \n       --  The cause of EINVAL is a priority ceiling violation\n \n+      pragma Assert (Result in 0 | EINVAL);\n       Ceiling_Violation := Result = EINVAL;\n-      pragma Assert (Result = 0 or else Ceiling_Violation);\n    end Write_Lock;\n \n    procedure Write_Lock\n      (L           : not null access RTS_Lock;\n       Global_Lock : Boolean := False)\n    is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n    begin\n       if not Single_Lock or else Global_Lock then\n          Result := pthread_mutex_lock (L);\n@@ -430,7 +447,7 @@ package body System.Task_Primitives.Operations is\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_Id) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n    begin\n       if not Single_Lock then\n          Result := pthread_mutex_lock (T.Common.LL.L'Access);\n@@ -446,7 +463,7 @@ package body System.Task_Primitives.Operations is\n      (L                 : not null access Lock;\n       Ceiling_Violation : out Boolean)\n    is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n    begin\n       if Locking_Policy = 'R' then\n          Result := pthread_rwlock_rdlock (L.RW'Access);\n@@ -456,16 +473,16 @@ package body System.Task_Primitives.Operations is\n \n       --  The cause of EINVAL is a priority ceiling violation\n \n+      pragma Assert (Result in 0 | EINVAL);\n       Ceiling_Violation := Result = EINVAL;\n-      pragma Assert (Result = 0 or else Ceiling_Violation);\n    end Read_Lock;\n \n    ------------\n    -- Unlock --\n    ------------\n \n    procedure Unlock (L : not null access Lock) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n    begin\n       if Locking_Policy = 'R' then\n          Result := pthread_rwlock_unlock (L.RW'Access);\n@@ -479,7 +496,7 @@ package body System.Task_Primitives.Operations is\n      (L           : not null access RTS_Lock;\n       Global_Lock : Boolean := False)\n    is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n    begin\n       if not Single_Lock or else Global_Lock then\n          Result := pthread_mutex_unlock (L);\n@@ -488,7 +505,7 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock (T : Task_Id) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n    begin\n       if not Single_Lock then\n          Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n@@ -504,7 +521,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_Ceiling\n      (L    : not null access Lock;\n-      Prio : System.Any_Priority)\n+      Prio : Any_Priority)\n    is\n       pragma Unreferenced (L, Prio);\n    begin\n@@ -521,7 +538,7 @@ package body System.Task_Primitives.Operations is\n    is\n       pragma Unreferenced (Reason);\n \n-      Result : Interfaces.C.int;\n+      Result : C.int;\n \n    begin\n       pragma Assert (Self_ID = Self);\n@@ -535,7 +552,7 @@ package body System.Task_Primitives.Operations is\n \n       --  EINTR is not considered a failure\n \n-      pragma Assert (Result = 0 or else Result = EINTR);\n+      pragma Assert (Result in 0 | EINTR);\n    end Sleep;\n \n    -----------------\n@@ -560,7 +577,7 @@ package body System.Task_Primitives.Operations is\n       Check_Time : Duration := Base_Time;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n-      Result     : Interfaces.C.int;\n+      Result     : C.int;\n \n    begin\n       Timedout := True;\n@@ -588,7 +605,7 @@ package body System.Task_Primitives.Operations is\n             Check_Time := Monotonic_Clock;\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n-            if Result = 0 or else Result = EINTR then\n+            if Result in 0 | EINTR then\n \n                --  Somebody may have called Wakeup for us\n \n@@ -618,7 +635,7 @@ package body System.Task_Primitives.Operations is\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n \n-      Result : Interfaces.C.int;\n+      Result : C.int;\n       pragma Warnings (Off, Result);\n \n    begin\n@@ -651,9 +668,7 @@ package body System.Task_Primitives.Operations is\n             Check_Time := Monotonic_Clock;\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n-            pragma Assert (Result = 0 or else\n-              Result = ETIMEDOUT or else\n-              Result = EINTR);\n+            pragma Assert (Result in 0 | ETIMEDOUT | EINTR);\n          end loop;\n \n          Self_ID.Common.State := Runnable;\n@@ -674,7 +689,7 @@ package body System.Task_Primitives.Operations is\n \n    function Monotonic_Clock return Duration is\n       TS     : aliased timespec;\n-      Result : int;\n+      Result : C.int;\n    begin\n       Result := clock_gettime\n         (clock_id => OSC.CLOCK_RT_Ada, tp => TS'Unchecked_Access);\n@@ -689,7 +704,7 @@ package body System.Task_Primitives.Operations is\n \n    function RT_Resolution return Duration is\n       TS     : aliased timespec;\n-      Result : int;\n+      Result : C.int;\n \n    begin\n       Result := clock_getres (OSC.CLOCK_REALTIME, TS'Unchecked_Access);\n@@ -704,7 +719,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n    begin\n       Result := pthread_cond_signal (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -715,7 +730,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Yield (Do_Yield : Boolean := True) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n       pragma Unreferenced (Result);\n    begin\n       if Do_Yield then\n@@ -729,15 +744,15 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_Priority\n      (T                   : Task_Id;\n-      Prio                : System.Any_Priority;\n+      Prio                : Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n       pragma Unreferenced (Loss_Of_Inheritance);\n \n-      Result : Interfaces.C.int;\n+      Result : C.int;\n       Param  : aliased struct_sched_param;\n \n-      function Get_Policy (Prio : System.Any_Priority) return Character;\n+      function Get_Policy (Prio : Any_Priority) return Character;\n       pragma Import (C, Get_Policy, \"__gnat_get_specific_dispatching\");\n       --  Get priority specific dispatching policy\n \n@@ -748,9 +763,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       T.Common.Current_Priority := Prio;\n \n-      --  Priorities are 1 .. 99 on GNU/Linux, so we map 0 .. 98 to 1 .. 99\n-\n-      Param.sched_priority := Interfaces.C.int (Prio) + 1;\n+      Param.sched_priority := Prio_To_Linux_Prio (Prio);\n \n       if Dispatching_Policy = 'R'\n         or else Priority_Specific_Policy = 'R'\n@@ -776,14 +789,14 @@ package body System.Task_Primitives.Operations is\n               SCHED_OTHER, Param'Access);\n       end if;\n \n-      pragma Assert (Result = 0 or else Result = EPERM);\n+      pragma Assert (Result in 0 | EPERM | EINVAL);\n    end Set_Priority;\n \n    ------------------\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_Id) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -817,7 +830,7 @@ package body System.Task_Primitives.Operations is\n             Len    : Natural := 0;\n             --  Length of the task name contained in Task_Name\n \n-            Result : int;\n+            Result : C.int;\n             --  Result from the prctl call\n          begin\n             Result := prctl (PR_GET_NAME, unsigned_long (Thread_Name'Address));\n@@ -849,7 +862,7 @@ package body System.Task_Primitives.Operations is\n       elsif Self_ID.Common.Task_Image_Len > 0 then\n          declare\n             Task_Name : String (1 .. Parameters.Max_Task_Image_Length + 1);\n-            Result    : int;\n+            Result    : C.int;\n \n          begin\n             Task_Name (1 .. Self_ID.Common.Task_Image_Len) :=\n@@ -868,7 +881,7 @@ package body System.Task_Primitives.Operations is\n       then\n          declare\n             Stack  : aliased stack_t;\n-            Result : Interfaces.C.int;\n+            Result : C.int;\n          begin\n             Stack.ss_sp    := Self_ID.Common.Task_Alternate_Stack;\n             Stack.ss_size  := Alternate_Stack_Size;\n@@ -903,7 +916,7 @@ package body System.Task_Primitives.Operations is\n    --------------------\n \n    procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n-      Result    : Interfaces.C.int;\n+      Result    : C.int;\n       Cond_Attr : aliased pthread_condattr_t;\n \n    begin\n@@ -917,15 +930,15 @@ package body System.Task_Primitives.Operations is\n \n       if not Single_Lock then\n          if Init_Mutex\n-           (Self_ID.Common.LL.L'Access, System.Any_Priority'Last) /= 0\n+           (Self_ID.Common.LL.L'Access, Any_Priority'Last) /= 0\n          then\n             Succeeded := False;\n             return;\n          end if;\n       end if;\n \n       Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+      pragma Assert (Result in 0 | ENOMEM);\n \n       if Result = 0 then\n          Result := GNAT_pthread_condattr_setup (Cond_Attr'Access);\n@@ -934,7 +947,7 @@ package body System.Task_Primitives.Operations is\n          Result :=\n            pthread_cond_init\n              (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n+         pragma Assert (Result in 0 | ENOMEM);\n       end if;\n \n       if Result = 0 then\n@@ -960,22 +973,22 @@ package body System.Task_Primitives.Operations is\n      (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n-      Priority   : System.Any_Priority;\n+      Priority   : Any_Priority;\n       Succeeded  : out Boolean)\n    is\n       Thread_Attr         : aliased pthread_attr_t;\n-      Adjusted_Stack_Size : Interfaces.C.size_t;\n-      Result              : Interfaces.C.int;\n+      Adjusted_Stack_Size : C.size_t;\n+      Result              : C.int;\n \n-      use type System.Multiprocessors.CPU_Range;\n+      use type Multiprocessors.CPU_Range, Interfaces.C.size_t;\n \n    begin\n       --  Check whether both Dispatching_Domain and CPU are specified for\n       --  the task, and the CPU value is not contained within the range of\n       --  processors for the domain.\n \n       if T.Common.Domain /= null\n-        and then T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU\n+        and then T.Common.Base_CPU /= Multiprocessors.Not_A_Specific_CPU\n         and then\n           (T.Common.Base_CPU not in T.Common.Domain'Range\n             or else not T.Common.Domain (T.Common.Base_CPU))\n@@ -984,11 +997,10 @@ package body System.Task_Primitives.Operations is\n          return;\n       end if;\n \n-      Adjusted_Stack_Size :=\n-         Interfaces.C.size_t (Stack_Size + Alternate_Stack_Size);\n+      Adjusted_Stack_Size := C.size_t (Stack_Size + Alternate_Stack_Size);\n \n       Result := pthread_attr_init (Thread_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+      pragma Assert (Result in 0 | ENOMEM);\n \n       if Result /= 0 then\n          Succeeded := False;\n@@ -1013,16 +1025,15 @@ package body System.Task_Primitives.Operations is\n \n       --  Do nothing if required support not provided by the operating system\n \n-      if pthread_attr_setaffinity_np'Address = System.Null_Address then\n+      if pthread_attr_setaffinity_np'Address = Null_Address then\n          null;\n \n       --  Support is available\n \n-      elsif T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU then\n+      elsif T.Common.Base_CPU /= Multiprocessors.Not_A_Specific_CPU then\n          declare\n             CPUs    : constant size_t :=\n-                        Interfaces.C.size_t\n-                          (System.Multiprocessors.Number_Of_CPUs);\n+                        C.size_t (Multiprocessors.Number_Of_CPUs);\n             CPU_Set : constant cpu_set_t_ptr := CPU_ALLOC (CPUs);\n             Size    : constant size_t := CPU_ALLOC_SIZE (CPUs);\n \n@@ -1061,8 +1072,7 @@ package body System.Task_Primitives.Operations is\n       then\n          declare\n             CPUs    : constant size_t :=\n-                        Interfaces.C.size_t\n-                          (System.Multiprocessors.Number_Of_CPUs);\n+                        C.size_t (Multiprocessors.Number_Of_CPUs);\n             CPU_Set : constant cpu_set_t_ptr := CPU_ALLOC (CPUs);\n             Size    : constant size_t := CPU_ALLOC_SIZE (CPUs);\n \n@@ -1103,8 +1113,7 @@ package body System.Task_Primitives.Operations is\n          Thread_Body_Access (Wrapper),\n          To_Address (T));\n \n-      pragma Assert\n-        (Result = 0 or else Result = EAGAIN or else Result = ENOMEM);\n+      pragma Assert (Result in 0 | EAGAIN | ENOMEM);\n \n       if Result /= 0 then\n          Succeeded := False;\n@@ -1126,7 +1135,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_Id) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n \n    begin\n       if not Single_Lock then\n@@ -1158,7 +1167,7 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Abort_Task (T : Task_Id) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n \n       ESRCH : constant := 3; -- No such process\n       --  It can happen that T has already vanished, in which case pthread_kill\n@@ -1170,7 +1179,7 @@ package body System.Task_Primitives.Operations is\n            pthread_kill\n              (T.Common.LL.Thread,\n               Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n-         pragma Assert (Result = 0 or else Result = ESRCH);\n+         pragma Assert (Result in 0 | ESRCH);\n       end if;\n    end Abort_Task;\n \n@@ -1179,7 +1188,7 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Initialize (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n \n    begin\n       --  Initialize internal state (always to False (RM D.10(6)))\n@@ -1191,7 +1200,7 @@ package body System.Task_Primitives.Operations is\n \n       Result := pthread_mutex_init (S.L'Access, null);\n \n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+      pragma Assert (Result in 0 | ENOMEM);\n \n       if Result = ENOMEM then\n          raise Storage_Error;\n@@ -1201,7 +1210,7 @@ package body System.Task_Primitives.Operations is\n \n       Result := pthread_cond_init (S.CV'Access, null);\n \n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+      pragma Assert (Result in 0 | ENOMEM);\n \n       if Result /= 0 then\n          Result := pthread_mutex_destroy (S.L'Access);\n@@ -1218,7 +1227,7 @@ package body System.Task_Primitives.Operations is\n    --------------\n \n    procedure Finalize (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n \n    begin\n       --  Destroy internal mutex\n@@ -1249,7 +1258,7 @@ package body System.Task_Primitives.Operations is\n    ---------------\n \n    procedure Set_False (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n \n    begin\n       SSL.Abort_Defer.all;\n@@ -1270,7 +1279,7 @@ package body System.Task_Primitives.Operations is\n    --------------\n \n    procedure Set_True (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n \n    begin\n       SSL.Abort_Defer.all;\n@@ -1305,7 +1314,7 @@ package body System.Task_Primitives.Operations is\n    ------------------------\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n+      Result : C.int;\n \n    begin\n       SSL.Abort_Defer.all;\n@@ -1343,7 +1352,7 @@ package body System.Task_Primitives.Operations is\n                --  POSIX does not guarantee it so this may change in future.\n \n                Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n-               pragma Assert (Result = 0 or else Result = EINTR);\n+               pragma Assert (Result in 0 | EINTR);\n \n                exit when not S.Waiting;\n             end loop;\n@@ -1456,7 +1465,7 @@ package body System.Task_Primitives.Operations is\n       act     : aliased struct_sigaction;\n       old_act : aliased struct_sigaction;\n       Tmp_Set : aliased sigset_t;\n-      Result  : Interfaces.C.int;\n+      Result  : C.int;\n       --  Whether to use an alternate signal stack for stack overflows\n \n       function State\n@@ -1538,25 +1547,24 @@ package body System.Task_Primitives.Operations is\n    -----------------------\n \n    procedure Set_Task_Affinity (T : ST.Task_Id) is\n-      use type System.Multiprocessors.CPU_Range;\n+      use type Multiprocessors.CPU_Range;\n \n    begin\n       --  Do nothing if there is no support for setting affinities or the\n       --  underlying thread has not yet been created. If the thread has not\n       --  yet been created then the proper affinity will be set during its\n       --  creation.\n \n-      if pthread_setaffinity_np'Address /= System.Null_Address\n+      if pthread_setaffinity_np'Address /= Null_Address\n         and then T.Common.LL.Thread /= Null_Thread_Id\n       then\n          declare\n             CPUs    : constant size_t :=\n-                        Interfaces.C.size_t\n-                          (System.Multiprocessors.Number_Of_CPUs);\n+                        C.size_t (Multiprocessors.Number_Of_CPUs);\n             CPU_Set : cpu_set_t_ptr := null;\n             Size    : constant size_t := CPU_ALLOC_SIZE (CPUs);\n \n-            Result  : Interfaces.C.int;\n+            Result  : C.int;\n \n          begin\n             --  We look at the specific CPU (Base_CPU) first, then at the"}, {"sha": "e92a954fe503ad177096c153bc5324d32e848c45", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d86fb53f2099c77d14ce59f2dda30bcfeb1df328/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d86fb53f2099c77d14ce59f2dda30bcfeb1df328/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d86fb53f2099c77d14ce59f2dda30bcfeb1df328", "patch": "@@ -3133,7 +3133,11 @@ package body Sem_Ch3 is\n \n             when N_Derived_Type_Definition =>\n                Derived_Type_Declaration (T, N, T /= Def_Id);\n-               if Ekind (T) /= E_Void and then Has_Predicates (T) then -- ????\n+\n+               --  Inherit predicates from parent, and protect against\n+               --  illegal derivations.\n+\n+               if Is_Type (T) and then Has_Predicates (T) then\n                   Set_Has_Predicates (Def_Id);\n                end if;\n "}]}