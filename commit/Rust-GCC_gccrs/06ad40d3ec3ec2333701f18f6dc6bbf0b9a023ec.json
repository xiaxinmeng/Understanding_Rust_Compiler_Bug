{"sha": "06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZhZDQwZDNlYzNlYzIzMzM3MDFmMThmNmRjNmJiZjBiOWEwMjNlYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-12-05T11:15:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-12-05T11:15:35Z"}, "message": "[multiple changes]\n\n2012-12-05  Thomas Quinot  <quinot@adacore.com>\n\n\t* par_sco.adb, scos.ads, put_scos.adb, put_scos.ads,\n\tget_scos.adb: Generation of SCOs for aspects.\n\n2012-12-05  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_prag.adb (Check_Precondition_Postcondition): Remove\n\tredundant call to Set_SCO_Pragma_Enabled (the pragma will be\n\trewritten into a pragma Check later on, and the call will be\n\tmade when processing the rewritten pragma).\n\t(Analyze_Pragma, case Pragma_Check): Omit call to\n\tSet_SCO_Pragma_Enabled if Split_PPC is set.\n\n2012-12-05  Olivier Hainque  <hainque@adacore.com>\n\n\t* tracebak.c: Add partial support for Lynx178.\n\n2012-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): Improve\n\tthe error message related to loop assertions.\n\n2012-12-05  Gary Dismukes  <dismukes@adacore.com>\n\n\t* atree.ads: Minor reformatting.\n\nFrom-SVN: r194211", "tree": {"sha": "c11a325254c0fff96f54a201f14e401c959ece35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c11a325254c0fff96f54a201f14e401c959ece35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/comments", "author": null, "committer": null, "parents": [{"sha": "af31bd57502fd7fef4891658c74cb5fdb3c160e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af31bd57502fd7fef4891658c74cb5fdb3c160e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af31bd57502fd7fef4891658c74cb5fdb3c160e4"}], "stats": {"total": 544, "additions": 375, "deletions": 169}, "files": [{"sha": "c323d7cf4aa553e70dbd9dc03bae3d592c0b1396", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "patch": "@@ -1,3 +1,30 @@\n+2012-12-05  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par_sco.adb, scos.ads, put_scos.adb, put_scos.ads,\n+\tget_scos.adb: Generation of SCOs for aspects.\n+\n+2012-12-05  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_prag.adb (Check_Precondition_Postcondition): Remove\n+\tredundant call to Set_SCO_Pragma_Enabled (the pragma will be\n+\trewritten into a pragma Check later on, and the call will be\n+\tmade when processing the rewritten pragma).\n+\t(Analyze_Pragma, case Pragma_Check): Omit call to\n+\tSet_SCO_Pragma_Enabled if Split_PPC is set.\n+\n+2012-12-05  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* tracebak.c: Add partial support for Lynx178.\n+\n+2012-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): Improve\n+\tthe error message related to loop assertions.\n+\n+2012-12-05  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* atree.ads: Minor reformatting.\n+\n 2012-12-05  Robert Dewar  <dewar@adacore.com>\n \n \t* atree.ads, par-ch4.adb, sem_attr.adb, sem_ch13.adb: Minor"}, {"sha": "d503dc2a66082446cabec07fa4d9acaa82f769a3", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "patch": "@@ -107,7 +107,7 @@ package Atree is\n \n    --                 Note: the required parentheses surrounding conditional\n    --                 and quantified expressions count as a level of parens\n-   --                 for this purposes, so e.g. in X := (if A then B else C);\n+   --                 for this purpose, so e.g. in X := (if A then B else C);\n    --                 Paren_Count for the right side will be 1.\n \n    --   Comes_From_Source"}, {"sha": "0020bea086809033bd3181d5d2eef9acac681ed4", "filename": "gcc/ada/get_scos.adb", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fget_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fget_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_scos.adb?ref=06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "patch": "@@ -28,8 +28,8 @@ pragma Ada_2005;\n --  read SCO information from ALI files (Xcov and sco_test). Ada 2005\n --  constructs may therefore be used freely (and are indeed).\n \n+with Namet;  use Namet;\n with SCOs;   use SCOs;\n-with Snames; use Snames;\n with Types;  use Types;\n \n with Ada.IO_Exceptions; use Ada.IO_Exceptions;\n@@ -203,6 +203,8 @@ procedure Get_SCOs is\n    N   : Natural;\n    --  Scratch buffer, and index into it\n \n+   Nam : Name_Id;\n+\n --  Start of processing for Get_Scos\n \n begin\n@@ -308,7 +310,6 @@ begin\n             declare\n                Typ : Character;\n                Key : Character;\n-               Pid : Pragma_Id;\n \n             begin\n                Key := 'S';\n@@ -327,7 +328,7 @@ begin\n                --  Loop through items on one line\n \n                loop\n-                  Pid := Unknown_Pragma;\n+                  Nam := No_Name;\n                   Typ := Nextc;\n \n                   case Typ is\n@@ -348,25 +349,16 @@ begin\n                         Skipc;\n                         if Typ = 'P' or else Typ = 'p' then\n                            if Nextc not in '1' .. '9' then\n-                              N := 1;\n+                              Name_Len := 0;\n                               loop\n-                                 Buf (N) := Getc;\n+                                 Name_Len := Name_Len + 1;\n+                                 Name_Buffer (Name_Len) := Getc;\n                                  exit when Nextc = ':';\n-                                 N := N + 1;\n                               end loop;\n \n-                              Skipc;\n-\n-                              begin\n-                                 Pid :=\n-                                   Pragma_Id'Value (\"pragma_\" & Buf (1 .. N));\n-                              exception\n-                                 when Constraint_Error =>\n+                              Skipc;  --  Past ':'\n \n-                                    --  Pid remains set to Unknown_Pragma\n-\n-                                    null;\n-                              end;\n+                              Nam := Name_Find;\n                            end if;\n                         end if;\n                   end case;\n@@ -379,13 +371,13 @@ begin\n                   end if;\n \n                   SCO_Table.Append\n-                    ((C1          => Key,\n-                      C2          => Typ,\n-                      From        => Loc1,\n-                      To          => Loc2,\n-                      Last        => At_EOL,\n-                      Pragma_Sloc => No_Location,\n-                      Pragma_Name => Pid));\n+                    ((C1                 => Key,\n+                      C2                 => Typ,\n+                      From               => Loc1,\n+                      To                 => Loc2,\n+                      Last               => At_EOL,\n+                      Pragma_Sloc        => No_Location,\n+                      Pragma_Aspect_Name => Nam));\n \n                   if Key = '>' then\n                      Key := 'S';\n@@ -397,8 +389,21 @@ begin\n \n          --  Decision entry\n \n-         when 'E' | 'G' | 'I' | 'P' | 'W' | 'X' =>\n+         when 'E' | 'G' | 'I' | 'P' | 'W' | 'X' | 'A' =>\n             Dtyp := C;\n+\n+            if C = 'A' then\n+               Name_Len := 0;\n+               while Nextc /= ' ' loop\n+                  Name_Len := Name_Len + 1;\n+                  Name_Buffer (Name_Len) := Getc;\n+               end loop;\n+               Nam := Name_Find;\n+\n+            else\n+               Nam := No_Name;\n+            end if;\n+\n             Skip_Spaces;\n \n             --  Output header\n@@ -416,12 +421,13 @@ begin\n                end if;\n \n                SCO_Table.Append\n-                 ((C1     => Dtyp,\n-                   C2     => ' ',\n-                   From   => Loc,\n-                   To     => No_Source_Location,\n-                   Last   => False,\n-                   others => <>));\n+                 ((C1                 => Dtyp,\n+                   C2                 => ' ',\n+                   From               => Loc,\n+                   To                 => No_Source_Location,\n+                   Last               => False,\n+                   Pragma_Aspect_Name => Nam,\n+                   others             => <>));\n             end;\n \n             --  Loop through terms in complex expression"}, {"sha": "4ce6951a755212a9a0202402bb57a47930cfce8e", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 208, "deletions": 57, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Debug;    use Debug;\n with Errout;   use Errout;\n@@ -125,13 +126,13 @@ package body Par_SCO is\n    --  Calls above procedure for each element of the list L\n \n    procedure Set_Table_Entry\n-     (C1          : Character;\n-      C2          : Character;\n-      From        : Source_Ptr;\n-      To          : Source_Ptr;\n-      Last        : Boolean;\n-      Pragma_Sloc : Source_Ptr := No_Location;\n-      Pragma_Name : Pragma_Id  := Unknown_Pragma);\n+     (C1                 : Character;\n+      C2                 : Character;\n+      From               : Source_Ptr;\n+      To                 : Source_Ptr;\n+      Last               : Boolean;\n+      Pragma_Sloc        : Source_Ptr := No_Location;\n+      Pragma_Aspect_Name : Name_Id    := No_Name);\n    --  Append an entry to SCO_Table with fields set as per arguments\n \n    type Dominant_Info is record\n@@ -487,15 +488,22 @@ package body Par_SCO is\n          Loc : Source_Ptr := No_Location;\n          --  Node whose Sloc is used for the decision\n \n+         Nam : Name_Id := No_Name;\n+         --  For the case of an aspect, aspect name\n+\n       begin\n          case T is\n-            when 'I' | 'E' | 'W' =>\n+            when 'I' | 'E' | 'W' | 'a' =>\n \n-               --  For IF, EXIT, WHILE, the token SLOC can be found from\n-               --  the SLOC of the parent of the expression.\n+               --  For IF, EXIT, WHILE, or aspects, the token SLOC is that of\n+               --  the parent of the expression.\n \n                Loc := Sloc (Parent (N));\n \n+               if T = 'a' then\n+                  Nam := Chars (Identifier (Parent (N)));\n+               end if;\n+\n             when 'G' | 'P' =>\n \n                --  For entry guard, the token sloc is from the N_Entry_Body.\n@@ -533,12 +541,20 @@ package body Par_SCO is\n          end case;\n \n          Set_Table_Entry\n-           (C1          => T,\n-            C2          => ' ',\n-            From        => Loc,\n-            To          => No_Location,\n-            Last        => False,\n-            Pragma_Sloc => Pragma_Sloc);\n+           (C1                 => T,\n+            C2                 => ' ',\n+            From               => Loc,\n+            To                 => No_Location,\n+            Last               => False,\n+            Pragma_Sloc        => Pragma_Sloc,\n+            Pragma_Aspect_Name => Nam);\n+\n+         --  For an aspect specification, which will be rewritten into a\n+         --  pragma, enter a hash table entry now.\n+\n+         if T = 'a' then\n+            Condition_Pragma_Hash_Table.Set (Loc, SCO_Table.Last);\n+         end if;\n       end Output_Header;\n \n       ------------------------------\n@@ -731,6 +747,8 @@ package body Par_SCO is\n       procedure Populate_SCO_Instance_Table is\n         new Sinput.Iterate_On_Instances (Record_Instance);\n \n+      SCO_Index : Nat;\n+\n    begin\n       if Debug_Flag_Dot_OO then\n          dsco;\n@@ -796,6 +814,24 @@ package body Par_SCO is\n          end;\n       end loop;\n \n+      --  Stamp out SCO entries for decisions in disabled constructs (pragmas\n+      --  or aspects).\n+\n+      SCO_Index := 1;\n+      while SCO_Index <= SCO_Table.Last loop\n+         if Is_Decision (SCO_Table.Table (SCO_Index).C1)\n+           and then SCO_Pragma_Disabled\n+                      (SCO_Table.Table (SCO_Index).Pragma_Sloc)\n+         then\n+            loop\n+               SCO_Table.Table (SCO_Index).C1 := ASCII.NUL;\n+               exit when SCO_Table.Table (SCO_Index).Last;\n+               SCO_Index := SCO_Index + 1;\n+            end loop;\n+         end if;\n+         SCO_Index := SCO_Index + 1;\n+      end loop;\n+\n       --  Now the tables are all setup for output to the ALI file\n \n       Write_SCOs_To_ALI_File;\n@@ -824,8 +860,30 @@ package body Par_SCO is\n          declare\n             T : SCO_Table_Entry renames SCO_Table.Table (Index);\n          begin\n-            pragma Assert (T.C1 = 'S');\n-            return T.C2 = 'p';\n+            case T.C1 is\n+               when 'S' =>\n+                  --  Pragma statement\n+\n+                  return T.C2 = 'p';\n+\n+               when 'A' =>\n+                  --  Aspect decision (enabled)\n+\n+                  return False;\n+\n+               when 'a' =>\n+                  --  Aspect decision (not enabled)\n+\n+                  return True;\n+\n+               when ASCII.NUL =>\n+                  --  Nullified disabled SCO\n+\n+                  return True;\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n          end;\n \n       else\n@@ -976,13 +1034,28 @@ package body Par_SCO is\n             T : SCO_Table_Entry renames SCO_Table.Table (Index);\n \n          begin\n-            --  Called multiple times for the same sloc (need to allow for\n-            --  C2 = 'P') ???\n+            --  Note: may be called multiple times for the same sloc, so\n+            --  account for the fact that the entry may already have been\n+            --  marked enabled.\n+\n+            case T.C1 is\n+               --  Aspect (decision SCO)\n+\n+               when 'a' =>\n+                  T.C1 := 'A';\n \n-            pragma Assert (T.C1 = 'S'\n-                             and then\n-                           (T.C2 = 'p' or else T.C2 = 'P'));\n-            T.C2 := 'P';\n+               when 'A' =>\n+                  null;\n+\n+               --  Pragma (statement SCO)\n+\n+               when 'S' =>\n+                  pragma Assert (T.C2 = 'p' or else T.C2 = 'P');\n+                  T.C2 := 'P';\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n          end;\n       end if;\n    end Set_SCO_Pragma_Enabled;\n@@ -992,23 +1065,23 @@ package body Par_SCO is\n    ---------------------\n \n    procedure Set_Table_Entry\n-     (C1          : Character;\n-      C2          : Character;\n-      From        : Source_Ptr;\n-      To          : Source_Ptr;\n-      Last        : Boolean;\n-      Pragma_Sloc : Source_Ptr := No_Location;\n-      Pragma_Name : Pragma_Id  := Unknown_Pragma)\n+     (C1                 : Character;\n+      C2                 : Character;\n+      From               : Source_Ptr;\n+      To                 : Source_Ptr;\n+      Last               : Boolean;\n+      Pragma_Sloc        : Source_Ptr := No_Location;\n+      Pragma_Aspect_Name : Name_Id    := No_Name)\n    is\n    begin\n       SCO_Table.Append\n-        ((C1          => C1,\n-          C2          => C2,\n-          From        => To_Source_Location (From),\n-          To          => To_Source_Location (To),\n-          Last        => Last,\n-          Pragma_Sloc => Pragma_Sloc,\n-          Pragma_Name => Pragma_Name));\n+        ((C1                 => C1,\n+          C2                 => C2,\n+          From               => To_Source_Location (From),\n+          To                 => To_Source_Location (To),\n+          Last               => Last,\n+          Pragma_Sloc        => Pragma_Sloc,\n+          Pragma_Aspect_Name => Pragma_Aspect_Name));\n    end Set_Table_Entry;\n \n    ------------------------\n@@ -1133,6 +1206,9 @@ package body Par_SCO is\n       procedure Traverse_One (N : Node_Id);\n       --  Traverse one declaration or statement\n \n+      procedure Traverse_Aspects (N : Node_Id);\n+      --  Helper for Traverse_One: traverse N's aspect specifications\n+\n       -------------------------\n       -- Set_Statement_Entry --\n       -------------------------\n@@ -1156,21 +1232,21 @@ package body Par_SCO is\n                         To := No_Location;\n                      end if;\n                      Set_Table_Entry\n-                       (C1          => '>',\n-                        C2          => Current_Dominant.K,\n-                        From        => From,\n-                        To          => To,\n-                        Last        => False,\n-                        Pragma_Sloc => No_Location,\n-                        Pragma_Name => Unknown_Pragma);\n+                       (C1                 => '>',\n+                        C2                 => Current_Dominant.K,\n+                        From               => From,\n+                        To                 => To,\n+                        Last               => False,\n+                        Pragma_Sloc        => No_Location,\n+                        Pragma_Aspect_Name => No_Name);\n                   end;\n                end if;\n             end if;\n \n             declare\n-               SCE         : SC_Entry renames SC.Table (J);\n-               Pragma_Sloc : Source_Ptr := No_Location;\n-               Pragma_Name : Pragma_Id  := Unknown_Pragma;\n+               SCE                : SC_Entry renames SC.Table (J);\n+               Pragma_Sloc        : Source_Ptr := No_Location;\n+               Pragma_Aspect_Name : Name_Id    := No_Name;\n             begin\n                --  For the case of a statement SCO for a pragma controlled by\n                --  Set_SCO_Pragma_Enabled, set Pragma_Sloc so that the SCO (and\n@@ -1181,20 +1257,22 @@ package body Par_SCO is\n                   Pragma_Sloc := SCE.From;\n                   Condition_Pragma_Hash_Table.Set\n                     (Pragma_Sloc, SCO_Table.Last + 1);\n-                  Pragma_Name := Get_Pragma_Id (Sinfo.Pragma_Name (SCE.N));\n+                  Pragma_Aspect_Name := Pragma_Name (SCE.N);\n+                  pragma Assert (Pragma_Aspect_Name /= No_Name);\n \n                elsif SCE.Typ = 'P' then\n-                  Pragma_Name := Get_Pragma_Id (Sinfo.Pragma_Name (SCE.N));\n+                  Pragma_Aspect_Name := Pragma_Name (SCE.N);\n+                  pragma Assert (Pragma_Aspect_Name /= No_Name);\n                end if;\n \n                Set_Table_Entry\n-                 (C1          => 'S',\n-                  C2          => SCE.Typ,\n-                  From        => SCE.From,\n-                  To          => SCE.To,\n-                  Last        => (J = SC_Last),\n-                  Pragma_Sloc => Pragma_Sloc,\n-                  Pragma_Name => Pragma_Name);\n+                 (C1                 => 'S',\n+                  C2                 => SCE.Typ,\n+                  From               => SCE.From,\n+                  To                 => SCE.To,\n+                  Last               => (J = SC_Last),\n+                  Pragma_Sloc        => Pragma_Sloc,\n+                  Pragma_Aspect_Name => Pragma_Aspect_Name);\n             end;\n          end loop;\n \n@@ -1293,6 +1371,76 @@ package body Par_SCO is\n          SD.Append ((Empty, L, T, Current_Pragma_Sloc));\n       end Process_Decisions_Defer;\n \n+      ----------------------\n+      -- Traverse_Aspects --\n+      ----------------------\n+\n+      procedure Traverse_Aspects (N : Node_Id) is\n+         AN : Node_Id;\n+         AE : Node_Id;\n+\n+      begin\n+         AN := First (Aspect_Specifications (N));\n+         while Present (AN) loop\n+            AE := Expression (AN);\n+\n+            case Get_Aspect_Id (Chars (Identifier (AN))) is\n+\n+               --  Aspects rewritten into pragmas controlled by a Check_Policy:\n+               --  Current_Pragma_Sloc must be set to the sloc of the aspect\n+               --  specification. The corresponding pragma will have the same\n+               --  sloc.\n+\n+               when Aspect_Pre               |\n+                    Aspect_Precondition      |\n+                    Aspect_Post              |\n+                    Aspect_Postcondition     =>\n+\n+                  --  SCOs are generated before semantic analysis/expansion:\n+                  --  PPCs are not split yet.\n+\n+                  pragma Assert (not Split_PPC (AN));\n+\n+                  --  A Pre/Post aspect will be rewritten into a pragma\n+                  --  Precondition/Postcondition with the same sloc.\n+\n+                  pragma Assert (Current_Pragma_Sloc = No_Location);\n+\n+                  Current_Pragma_Sloc := Sloc (AN);\n+\n+                  --  Create the decision as potentially disabled aspect ('a').\n+                  --  Set_SCO_Pragma_Enabled will subsequently switch to 'A'.\n+\n+                  Process_Decisions_Defer (AE, 'a');\n+                  Current_Pragma_Sloc := No_Location;\n+\n+               --  Aspects whose checks are generated in client units,\n+               --  regardless of whether or not the check is activated in the\n+               --  unit which contains the declaration.\n+\n+               when Aspect_Predicate         |\n+                    Aspect_Static_Predicate  |\n+                    Aspect_Dynamic_Predicate |\n+                    Aspect_Invariant         |\n+                    Aspect_Type_Invariant    =>\n+\n+                  Process_Decisions_Defer (AE, 'A');\n+\n+               --  Other aspects: just process any decision nested in the\n+               --  aspect expression.\n+\n+               when others =>\n+\n+                  if Has_Decision (AE) then\n+                     Process_Decisions_Defer (AE, 'X');\n+                  end if;\n+\n+            end case;\n+\n+            Next (AN);\n+         end loop;\n+      end Traverse_Aspects;\n+\n       ------------------\n       -- Traverse_One --\n       ------------------\n@@ -1825,6 +1973,9 @@ package body Par_SCO is\n                end if;\n          end case;\n \n+         --  Process aspects if present\n+\n+         Traverse_Aspects (N);\n       end Traverse_One;\n \n    --  Start of processing for Traverse_Declarations_Or_Statements"}, {"sha": "e9b03fc8294ff5ecb367d6e6a9f54bf9305186fa", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "patch": "@@ -23,10 +23,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Namet;   use Namet;\n with Opt;     use Opt;\n-with Par_SCO; use Par_SCO;\n with SCOs;    use SCOs;\n-with Snames;  use Snames;\n \n procedure Put_SCOs is\n    Current_SCO_Unit : SCO_Unit_Index := 0;\n@@ -195,18 +194,10 @@ begin\n \n                               if Sent.C1 = 'S'\n                                 and then (Sent.C2 = 'P' or else Sent.C2 = 'p')\n-                                and then Sent.Pragma_Name /= Unknown_Pragma\n+                                and then Sent.Pragma_Aspect_Name /= No_Name\n                               then\n-                                 --  Strip leading \"PRAGMA_\"\n-\n-                                 declare\n-                                    Pnam : constant String :=\n-                                             Sent.Pragma_Name'Img;\n-                                 begin\n-                                    Output_String\n-                                      (Pnam (Pnam'First + 7 .. Pnam'Last));\n-                                    Write_Info_Char (':');\n-                                 end;\n+                                 Write_Info_Name (Sent.Pragma_Aspect_Name);\n+                                 Write_Info_Char (':');\n                               end if;\n                            end if;\n \n@@ -240,57 +231,55 @@ begin\n \n                   --  Decision\n \n-                  when 'E' | 'G' | 'I' | 'P' | 'W' | 'X' =>\n+                  when 'E' | 'G' | 'I' | 'P' | 'W' | 'X' | 'A' =>\n                      Start := Start + 1;\n \n-                     --  For disabled pragma, or nested decision therein, skip\n-                     --  decision output.\n+                     Write_SCO_Initiate (U);\n+                     Write_Info_Char (T.C1);\n \n-                     if SCO_Pragma_Disabled (T.Pragma_Sloc) then\n-                        while not SCO_Table.Table (Start).Last loop\n-                           Start := Start + 1;\n-                        end loop;\n+                     if T.C1 = 'A' then\n+                        Write_Info_Name (T.Pragma_Aspect_Name);\n+                     end if;\n+\n+                     if T.C1 /= 'X' then\n+                        Write_Info_Char (' ');\n+                        Output_Source_Location (T.From);\n+                     end if;\n \n-                     --  For all other cases output decision line\n+                     --  Loop through table entries for this decision\n \n-                     else\n-                        Write_SCO_Initiate (U);\n-                        Write_Info_Char (T.C1);\n+                     loop\n+                        declare\n+                           T : SCO_Table_Entry\n+                                 renames SCO_Table.Table (Start);\n \n-                        if T.C1 /= 'X' then\n+                        begin\n                            Write_Info_Char (' ');\n-                           Output_Source_Location (T.From);\n-                        end if;\n \n-                        --  Loop through table entries for this decision\n+                           if T.C1 = '!' or else\n+                              T.C1 = '&' or else\n+                              T.C1 = '|'\n+                           then\n+                              Write_Info_Char (T.C1);\n+                              Output_Source_Location (T.From);\n \n-                        loop\n-                           declare\n-                              T : SCO_Table_Entry\n-                                    renames SCO_Table.Table (Start);\n+                           else\n+                              Write_Info_Char (T.C2);\n+                              Output_Range (T);\n+                           end if;\n \n-                           begin\n-                              Write_Info_Char (' ');\n+                           exit when T.Last;\n+                           Start := Start + 1;\n+                        end;\n+                     end loop;\n \n-                              if T.C1 = '!' or else\n-                                 T.C1 = '&' or else\n-                                 T.C1 = '|'\n-                              then\n-                                 Write_Info_Char (T.C1);\n-                                 Output_Source_Location (T.From);\n+                     Write_Info_Terminate;\n \n-                              else\n-                                 Write_Info_Char (T.C2);\n-                                 Output_Range (T);\n-                              end if;\n+                  when ASCII.NUL =>\n \n-                              exit when T.Last;\n-                              Start := Start + 1;\n-                           end;\n-                        end loop;\n+                     --  Nullified entry: skip\n \n-                        Write_Info_Terminate;\n-                     end if;\n+                     null;\n \n                   when others =>\n                      raise Program_Error;"}, {"sha": "323e65284588376fe95dc1cdb80b5efb17ea93fb", "filename": "gcc/ada/put_scos.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fput_scos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fput_scos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.ads?ref=06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                             P U T _ S C O S                               --\n+--                              P U T _ S C O S                             --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,6 +28,7 @@\n --  the ALI file. The interface allows control over the destination of the\n --  output, so that this routine can also be used for debugging purposes.\n \n+with Namet; use Namet;\n with Types; use Types;\n \n generic\n@@ -43,6 +44,9 @@ generic\n    --  Initiates write of new line to output file, the parameter is the\n    --  keyword character for the line.\n \n+   with procedure Write_Info_Name (Nam : Name_Id) is <>;\n+   --  Outputs one name\n+\n    with procedure Write_Info_Nat (N : Nat) is <>;\n    --  Writes image of N to output file with no leading or trailing blanks\n "}, {"sha": "0082099afb487be3218ab6901ea21f0c8c7a971b", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "patch": "@@ -28,11 +28,8 @@\n --  the ALI file, and by Get_SCO/Put_SCO to read and write the text form that\n --  is used in the ALI file.\n \n-with Snames; use Snames;\n---  Note: used for Pragma_Id only, no other feature from Snames should be used,\n---  as a simplified version is maintained in Xcov.\n-\n-with Types;  use Types;\n+with Namet; use Namet;\n+with Types; use Types;\n \n with GNAT.Table;\n \n@@ -248,18 +245,21 @@ package SCOs is\n \n    --      C* sloc expression\n \n-   --    Here * is one of the following characters:\n+   --    Here * is one of the following:\n \n-   --      E  decision in EXIT WHEN statement\n-   --      G  decision in entry guard\n-   --      I  decision in IF statement or if expression\n-   --      P  decision in pragma Assert/Check/Pre_Condition/Post_Condition\n-   --      W  decision in WHILE iteration scheme\n-   --      X  decision appearing in some other expression context\n+   --      E       decision in EXIT WHEN statement\n+   --      G       decision in entry guard\n+   --      I       decision in IF statement or if expression\n+   --      P       decision in pragma Assert / Check / Pre/Post_Condition\n+   --      A[name] decision in aspect Pre/Post (aspect name optional)\n+   --      W       decision in WHILE iteration scheme\n+   --      X       decision in some other expression context\n \n    --    For E, G, I, P, W, sloc is the source location of the EXIT, ENTRY, IF,\n    --    PRAGMA or WHILE token, respectively\n \n+   --    For A sloc is the source location of the aspect identifier\n+\n    --    For X, sloc is omitted\n \n    --    The expression is a prefix polish form indicating the structure of\n@@ -369,10 +369,12 @@ package SCOs is\n       Pragma_Sloc : Source_Ptr := No_Location;\n       --  For the statement SCO for a pragma, or for any expression SCO nested\n       --  in a pragma Debug/Assert/PPC, location of PRAGMA token (used for\n-      --  control of SCO output, value not recorded in ALI file).\n+      --  control of SCO output, value not recorded in ALI file). For the\n+      --  decision SCO for an aspect, or for any expression SCO nested in an\n+      --  aspect, location of aspect identifier token (likewise).\n \n-      Pragma_Name : Pragma_Id := Unknown_Pragma;\n-      --  For the statement SCO for a pragma, gives the pragma name\n+      Pragma_Aspect_Name : Name_Id := No_Name;\n+      --  For the SCO for a pragma/aspect, gives the pragma/apsect name\n    end record;\n \n    package SCO_Table is new GNAT.Table (\n@@ -382,6 +384,11 @@ package SCOs is\n      Table_Initial        => 500,\n      Table_Increment      => 300);\n \n+   Is_Decision : constant array (Character) of Boolean :=\n+     ('E' | 'G' | 'I' | 'P' | 'A' | 'W' | 'X' => True,\n+      others                                  => False);\n+   --  Indicates which C1 values correspond to decisions\n+\n    --  The SCO_Table_Entry values appear as follows:\n \n    --    Statements\n@@ -432,7 +439,20 @@ package SCOs is\n    --    SCO contexts, the only pragmas with decisions are Assert, Check,\n    --    dyadic Debug, Precondition and Postcondition). These entries will\n    --    be omitted in output if the pragma is disabled (see comments for\n-   --    statement entries).\n+   --    statement entries). This is achieved by setting C1 to NUL for all\n+   --    SCO entries of the decision.\n+\n+   --    Decision (ASPECT)\n+   --      C1   = 'A'\n+   --      C2   = ' '\n+   --      From = aspect identifier\n+   --      To   = No_Source_Location\n+   --      Last = unused\n+\n+   --    Note: when the parse tree is first scanned, we unconditionally build a\n+   --    pragma decision entry for any decision in an aspect (Pre/Post/\n+   --    [Type_]Invariant/[Static_|Dynamic_]Predicate). Entries for disabled\n+   --    Pre/Post aspects will be omitted from output.\n \n    --    Decision (Expression)\n    --      C1   = 'X'"}, {"sha": "94cbd9e730a51867fc706bef8e6630fbb8cba380", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "patch": "@@ -3847,7 +3847,8 @@ package body Sem_Attr is\n \n          if not In_Loop_Assertion then\n             Error_Attr\n-              (\"attribute % must appear within pragma Loop_Assertion\", N);\n+              (\"attribute % must appear within pragma Loop_Variant or \" &\n+               \"Loop_Invariant\", N);\n          end if;\n \n          --  A Loop_Entry that applies to a given loop statement shall not"}, {"sha": "ddd84822ce179f0a15f0ef09dc5266c08a8013d6", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "patch": "@@ -2181,13 +2181,6 @@ package body Sem_Prag is\n               (Get_Pragma_Arg (Arg2), Standard_String);\n          end if;\n \n-         --  For a pragma in the extended main source unit, record enabled\n-         --  status in SCO (note: there is never any SCO for an instance).\n-\n-         if Check_Enabled (Pname) then\n-            Set_SCO_Pragma_Enabled (Loc);\n-         end if;\n-\n          --  If we are within an inlined body, the legality of the pragma\n          --  has been checked already.\n \n@@ -7407,7 +7400,7 @@ package body Sem_Prag is\n \n             Check_On := Check_Enabled (Chars (Get_Pragma_Arg (Arg1)));\n \n-            if Check_On then\n+            if Check_On and then not Split_PPC (N) then\n                Set_SCO_Pragma_Enabled (Loc);\n             end if;\n "}, {"sha": "01b96548baf9b4dc6409173d0d457510bb5833b4", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=06ad40d3ec3ec2333701f18f6dc6bbf0b9a023ec", "patch": "@@ -287,9 +287,10 @@ __gnat_backtrace (void **array,\n #error Unhandled darwin architecture.\n #endif\n \n-/*------------------------ PPC AIX/Older Darwin -------------------------*/\n+/*---------------------- PPC AIX/PPC Lynx 178/Older Darwin ------------------*/\n #elif ((defined (_POWER) && defined (_AIX)) || \\\n-(defined (__ppc__) && defined (__APPLE__)))\n+       (defined (__powerpc__) && defined (__Lynx__) && !defined(__ELF__)) || \\\n+       (defined (__ppc__) && defined (__APPLE__)))\n \n #define USE_GENERIC_UNWINDER\n \n@@ -307,9 +308,23 @@ struct layout\n    should to feature a null backchain, AIX might expose a null return\n    address instead.  */\n \n+/* Then LynxOS-178 features yet another variation, with return_address\n+   == &__start, which we only add conditionally as this symbol is not\n+   necessarily present elsewhere.  Beware that &bla returns the\n+   address of a descriptor when \"bla\" is a function.  Getting the code\n+   address requires an extra dereference.  */\n+\n+#if defined (__Lynx__)\n+extern void __start();\n+#define EXTRA_STOP_CONDITION(CURRENT) ((CURRENT)->return_address == *(void**)&__start)\n+#else\n+#define EXTRA_STOP_CONDITION(CURRENT) (0)\n+#endif\n+\n #define STOP_FRAME(CURRENT, TOP_STACK) \\\n   (((void *) (CURRENT) < (TOP_STACK)) \\\n-   || (CURRENT)->return_address == NULL)\n+   || (CURRENT)->return_address == NULL \\\n+   || EXTRA_STOP_CONDITION(CURRENT))\n \n /* The PPC ABI has an interesting specificity: the return address saved by a\n    function is located in it's caller's frame, and the save operation only"}]}