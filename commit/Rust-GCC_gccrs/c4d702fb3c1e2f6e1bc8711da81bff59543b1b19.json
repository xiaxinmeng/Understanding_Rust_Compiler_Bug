{"sha": "c4d702fb3c1e2f6e1bc8711da81bff59543b1b19", "node_id": "C_kwDOANBUbNoAKGM0ZDcwMmZiM2MxZTJmNmUxYmM4NzExZGE4MWJmZjU5NTQzYjFiMTk", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-05-31T20:22:06Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-01T14:31:34Z"}, "message": "c++: Cleanup static init generation\n\nThe static init/fini generation is showing some bitrot.  This cleans\nup several places to use C++, and also take advantage of already\nhaving checked a variable for non-nullness.\n\n\tgcc/cp/\n\t* decl2.cc (ssdf_decl): Delete global.\n\t(start_static_storage_duration_function): Use some RAII.\n\t(do_static_initialization_or_destruction): Likewise.\n\t(c_parse_final_cleanups): Likewise.  Avoid rechecking 'vars'.", "tree": {"sha": "a8f31d00c007495dd686b09d74ff7f6ef7a4174d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8f31d00c007495dd686b09d74ff7f6ef7a4174d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4d702fb3c1e2f6e1bc8711da81bff59543b1b19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d702fb3c1e2f6e1bc8711da81bff59543b1b19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4d702fb3c1e2f6e1bc8711da81bff59543b1b19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d702fb3c1e2f6e1bc8711da81bff59543b1b19/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee21974c8ecbbaa2a1d44f2dba873f8724ed9ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee21974c8ecbbaa2a1d44f2dba873f8724ed9ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee21974c8ecbbaa2a1d44f2dba873f8724ed9ad4"}], "stats": {"total": 71, "additions": 25, "deletions": 46}, "files": [{"sha": "9de3f806e9500ce1faabc07be766e22f864a4803", "filename": "gcc/cp/decl2.cc", "status": "modified", "additions": 25, "deletions": 46, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d702fb3c1e2f6e1bc8711da81bff59543b1b19/gcc%2Fcp%2Fdecl2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d702fb3c1e2f6e1bc8711da81bff59543b1b19/gcc%2Fcp%2Fdecl2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.cc?ref=c4d702fb3c1e2f6e1bc8711da81bff59543b1b19", "patch": "@@ -3943,9 +3943,6 @@ static GTY(()) tree initialize_p_decl;\n /* The declaration for the __PRIORITY argument.  */\n static GTY(()) tree priority_decl;\n \n-/* The declaration for the static storage duration function.  */\n-static GTY(()) tree ssdf_decl;\n-\n /* All the static storage duration functions created in this\n    translation unit.  */\n static GTY(()) vec<tree, va_gc> *ssdf_decls;\n@@ -3970,24 +3967,20 @@ static splay_tree priority_info_map;\n static tree\n start_static_storage_duration_function (unsigned count)\n {\n-  tree type;\n-  tree body;\n   char id[sizeof (SSDF_IDENTIFIER) + 1 /* '\\0' */ + 32];\n \n   /* Create the identifier for this function.  It will be of the form\n      SSDF_IDENTIFIER_<number>.  */\n   sprintf (id, \"%s_%u\", SSDF_IDENTIFIER, count);\n \n-  type = build_function_type_list (void_type_node,\n-\t\t\t\t   integer_type_node, integer_type_node,\n-\t\t\t\t   NULL_TREE);\n+  tree type = build_function_type_list (void_type_node,\n+\t\t\t\t\tinteger_type_node, integer_type_node,\n+\t\t\t\t\tNULL_TREE);\n \n   /* Create the FUNCTION_DECL itself.  */\n-  ssdf_decl = build_lang_decl (FUNCTION_DECL,\n-\t\t\t       get_identifier (id),\n-\t\t\t       type);\n-  TREE_PUBLIC (ssdf_decl) = 0;\n-  DECL_ARTIFICIAL (ssdf_decl) = 1;\n+  tree fn = build_lang_decl (FUNCTION_DECL, get_identifier (id), type);\n+  TREE_PUBLIC (fn) = 0;\n+  DECL_ARTIFICIAL (fn) = 1;\n \n   /* Put this function in the list of functions to be called from the\n      static constructors and destructors.  */\n@@ -4009,21 +4002,21 @@ start_static_storage_duration_function (unsigned count)\n       get_priority_info (DEFAULT_INIT_PRIORITY);\n     }\n \n-  vec_safe_push (ssdf_decls, ssdf_decl);\n+  vec_safe_push (ssdf_decls, fn);\n \n   /* Create the argument list.  */\n   initialize_p_decl = cp_build_parm_decl\n-    (ssdf_decl, get_identifier (INITIALIZE_P_IDENTIFIER), integer_type_node);\n+    (fn, get_identifier (INITIALIZE_P_IDENTIFIER), integer_type_node);\n   TREE_USED (initialize_p_decl) = 1;\n   priority_decl = cp_build_parm_decl\n-    (ssdf_decl, get_identifier (PRIORITY_IDENTIFIER), integer_type_node);\n+    (fn, get_identifier (PRIORITY_IDENTIFIER), integer_type_node);\n   TREE_USED (priority_decl) = 1;\n \n   DECL_CHAIN (initialize_p_decl) = priority_decl;\n-  DECL_ARGUMENTS (ssdf_decl) = initialize_p_decl;\n+  DECL_ARGUMENTS (fn) = initialize_p_decl;\n \n   /* Put the function in the global scope.  */\n-  pushdecl (ssdf_decl);\n+  pushdecl (fn);\n \n   /* Start the function itself.  This is equivalent to declaring the\n      function as:\n@@ -4032,14 +4025,10 @@ start_static_storage_duration_function (unsigned count)\n \n      It is static because we only need to call this function from the\n      various constructor and destructor functions for this module.  */\n-  start_preparsed_function (ssdf_decl,\n-\t\t\t    /*attrs=*/NULL_TREE,\n-\t\t\t    SF_PRE_PARSED);\n+  start_preparsed_function (fn, /*attrs=*/NULL_TREE, SF_PRE_PARSED);\n \n   /* Set up the scope of the outermost block in the function.  */\n-  body = begin_compound_stmt (BCS_FN_BODY);\n-\n-  return body;\n+  return begin_compound_stmt (BCS_FN_BODY);\n }\n \n /* Finish the generation of the function which performs initialization\n@@ -4234,7 +4223,6 @@ one_static_initialization_or_destruction (bool initp, tree decl, tree init)\n       finish_if_stmt_cond (guard_cond, guard_if_stmt);\n     }\n \n-\n   /* If we're using __cxa_atexit, we have not already set the GUARD,\n      so we must do so now.  */\n   if (guard && initp && flag_use_cxa_atexit)\n@@ -4282,11 +4270,9 @@ one_static_initialization_or_destruction (bool initp, tree decl, tree init)\n static void\n do_static_initialization_or_destruction (bool initp, tree vars)\n {\n-  tree node, init_if_stmt, cond;\n-\n   /* Build the outer if-stmt to check for initialization or destruction.  */\n-  init_if_stmt = begin_if_stmt ();\n-  cond = initp ? integer_one_node : integer_zero_node;\n+  tree init_if_stmt = begin_if_stmt ();\n+  tree cond = initp ? integer_one_node : integer_zero_node;\n   cond = cp_build_binary_op (input_location,\n \t\t\t     EQ_EXPR,\n \t\t\t     initialize_p_decl,\n@@ -4304,12 +4290,9 @@ do_static_initialization_or_destruction (bool initp, tree vars)\n   if (initp && (flag_sanitize & SANITIZE_ADDRESS))\n     finish_expr_stmt (asan_dynamic_init_call (/*after_p=*/false));\n \n-  node = vars;\n+  tree node = vars;\n   do {\n     tree decl = TREE_VALUE (node);\n-    tree priority_if_stmt;\n-    int priority;\n-    priority_info pi;\n \n     /* If we don't need a destructor, there's nothing to do.  Avoid\n        creating a possibly empty if-stmt.  */\n@@ -4321,16 +4304,16 @@ do_static_initialization_or_destruction (bool initp, tree vars)\n \n     /* Remember that we had an initialization or finalization at this\n        priority.  */\n-    priority = DECL_EFFECTIVE_INIT_PRIORITY (decl);\n-    pi = get_priority_info (priority);\n+    int priority = DECL_EFFECTIVE_INIT_PRIORITY (decl);\n+    priority_info pi = get_priority_info (priority);\n     if (initp)\n       pi->initializations_p = 1;\n     else\n       pi->destructions_p = 1;\n \n     /* Conditionalize this initialization on being in the right priority\n        and being initializing/finalizing appropriately.  */\n-    priority_if_stmt = begin_if_stmt ();\n+    tree priority_if_stmt = begin_if_stmt ();\n     cond = cp_build_binary_op (input_location,\n \t\t\t       EQ_EXPR,\n \t\t\t       priority_decl,\n@@ -5165,40 +5148,36 @@ c_parse_final_cleanups (void)\n \t      hash_map_safe_put<hm_ggc> (dynamic_initializers,\n \t\t\t\t\t TREE_VALUE (t), TREE_PURPOSE (t));\n \n+\t  /* Make sure the back end knows about all the variables.  */\n+\t  write_out_vars (vars);\n+\n \t  /* We need to start a new initialization function each time\n \t     through the loop.  That's because we need to know which\n \t     vtables have been referenced, and TREE_SYMBOL_REFERENCED\n \t     isn't computed until a function is finished, and written\n \t     out.  That's a deficiency in the back end.  When this is\n \t     fixed, these initialization functions could all become\n \t     inline, with resulting performance improvements.  */\n-\t  tree ssdf_body;\n-\n-\t  /* Make sure the back end knows about all the variables.  */\n-\t  write_out_vars (vars);\n \n \t  /* Set the line and file, so that it is obviously not from\n \t     the source file.  */\n \t  input_location = locus_at_end_of_parsing;\n-\t  ssdf_body = start_static_storage_duration_function (ssdf_count);\n+\t  tree ssdf_body = start_static_storage_duration_function (ssdf_count);\n \n \t  /* First generate code to do all the initializations.  */\n-\t  if (vars)\n-\t    do_static_initialization_or_destruction (/*initp=*/true, vars);\n+\t  do_static_initialization_or_destruction (/*initp=*/true, vars);\n \n \t  /* Then, generate code to do all the destructions.  Do these\n \t     in reverse order so that the most recently constructed\n \t     variable is the first destroyed.  If we're using\n \t     __cxa_atexit, then we don't need to do this; functions\n \t     were registered at initialization time to destroy the\n \t     local statics.  */\n-\t  if (!flag_use_cxa_atexit && vars)\n+\t  if (!flag_use_cxa_atexit)\n \t    {\n \t      vars = nreverse (vars);\n \t      do_static_initialization_or_destruction (/*initp=*/false, vars);\n \t    }\n-\t  else\n-\t    vars = NULL_TREE;\n \n \t  /* Finish up the static storage duration function for this\n \t     round.  */"}]}