{"sha": "b9e2e732a2955fdab92572e608a28a702f1056fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjllMmU3MzJhMjk1NWZkYWI5MjU3MmU2MDhhMjhhNzAyZjEwNTZmYw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2015-04-23T20:18:10Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2015-04-23T20:18:10Z"}, "message": "altivec.md (*altivec_lvx_<mode>_internal): Remove asterisk from name so this can be generated directly.\n\n2015-04-23  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* config/rs6000/altivec.md (*altivec_lvx_<mode>_internal): Remove\n\tasterisk from name so this can be generated directly.\n\t(*altivec_stvx_<mode>_internal): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_emit_le_vsx_store): Add assert\n\tthat this is never called during or after reload/lra.\n\t(rs6000_frame_related): Remove split_reg\n\targument and logic that references it.\n\t(emit_frame_save): Remove last parameter from call to\n\trs6000_frame_related.\n\t(rs6000_emit_prologue): Remove last parameter from eight calls to\n\trs6000_frame_related.  Force generation of stvx instruction for\n\tAltivec register saves.  Remove split_reg handling, which is no\n\tlonger needed.\n\t(rs6000_emit_epilogue):  Force generation of lvx instruction for\n\tAltivec register restores.\n\nFrom-SVN: r222385", "tree": {"sha": "b1a81cce23444d08f22ffbbf437ee56062916197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1a81cce23444d08f22ffbbf437ee56062916197"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9e2e732a2955fdab92572e608a28a702f1056fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9e2e732a2955fdab92572e608a28a702f1056fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9e2e732a2955fdab92572e608a28a702f1056fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9e2e732a2955fdab92572e608a28a702f1056fc/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb7ec730fe407f84e27c6e0e0cdcf71c0fe50c3a"}], "stats": {"total": 79, "additions": 48, "deletions": 31}, "files": [{"sha": "44c775c8e8c74a2d4f804a6e74d1c4d5ca344915", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e2e732a2955fdab92572e608a28a702f1056fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e2e732a2955fdab92572e608a28a702f1056fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9e2e732a2955fdab92572e608a28a702f1056fc", "patch": "@@ -1,3 +1,21 @@\n+2015-04-23  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/altivec.md (*altivec_lvx_<mode>_internal): Remove\n+\tasterisk from name so this can be generated directly.\n+\t(*altivec_stvx_<mode>_internal): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_emit_le_vsx_store): Add assert\n+\tthat this is never called during or after reload/lra.\n+\t(rs6000_frame_related): Remove split_reg\n+\targument and logic that references it.\n+\t(emit_frame_save): Remove last parameter from call to\n+\trs6000_frame_related.\n+\t(rs6000_emit_prologue): Remove last parameter from eight calls to\n+\trs6000_frame_related.  Force generation of stvx instruction for\n+\tAltivec register saves.  Remove split_reg handling, which is no\n+\tlonger needed.\n+\t(rs6000_emit_epilogue):  Force generation of lvx instruction for\n+\tAltivec register restores.\n+\n 2015-04-23  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.opt (mcrypto): Change option description to"}, {"sha": "f7684026b27280c7bdd882e0993c99691d8290f3", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e2e732a2955fdab92572e608a28a702f1056fc/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e2e732a2955fdab92572e608a28a702f1056fc/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=b9e2e732a2955fdab92572e608a28a702f1056fc", "patch": "@@ -2455,7 +2455,7 @@\n     }\n })\n \n-(define_insn \"*altivec_lvx_<mode>_internal\"\n+(define_insn \"altivec_lvx_<mode>_internal\"\n   [(parallel\n     [(set (match_operand:VM2 0 \"register_operand\" \"=v\")\n \t  (match_operand:VM2 1 \"memory_operand\" \"Z\"))\n@@ -2478,7 +2478,7 @@\n     }\n })\n \n-(define_insn \"*altivec_stvx_<mode>_internal\"\n+(define_insn \"altivec_stvx_<mode>_internal\"\n   [(parallel\n     [(set (match_operand:VM2 0 \"memory_operand\" \"=Z\")\n \t  (match_operand:VM2 1 \"register_operand\" \"v\"))"}, {"sha": "c5781033713b78763f33066d0bc4b4d4f96a2a69", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e2e732a2955fdab92572e608a28a702f1056fc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e2e732a2955fdab92572e608a28a702f1056fc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b9e2e732a2955fdab92572e608a28a702f1056fc", "patch": "@@ -8398,6 +8398,11 @@ rs6000_emit_le_vsx_store (rtx dest, rtx source, machine_mode mode)\n {\n   rtx tmp, permute_src, permute_tmp;\n \n+  /* This should never be called during or after reload, because it does\n+     not re-permute the source register.  It is intended only for use\n+     during expand.  */\n+  gcc_assert (!reload_in_progress && !lra_in_progress && !reload_completed);\n+\n   /* Use V2DImode to do swaps of types with 128-bit scalare parts (TImode,\n      V1TImode).  */\n   if (mode == TImode || mode == V1TImode)\n@@ -22795,7 +22800,7 @@ output_probe_stack_range (rtx reg1, rtx reg2)\n \n static rtx\n rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n-\t\t      rtx reg2, rtx rreg, rtx split_reg)\n+\t\t      rtx reg2, rtx rreg)\n {\n   rtx real, temp;\n \n@@ -22886,11 +22891,6 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \t  }\n     }\n \n-  /* If a store insn has been split into multiple insns, the\n-     true source register is given by split_reg.  */\n-  if (split_reg != NULL_RTX)\n-    real = gen_rtx_SET (VOIDmode, SET_DEST (real), split_reg);\n-\n   RTX_FRAME_RELATED_P (insn) = 1;\n   add_reg_note (insn, REG_FRAME_RELATED_EXPR, real);\n \n@@ -22998,7 +22998,7 @@ emit_frame_save (rtx frame_reg, machine_mode mode,\n   reg = gen_rtx_REG (mode, regno);\n   insn = emit_insn (gen_frame_store (reg, frame_reg, offset));\n   return rs6000_frame_related (insn, frame_reg, frame_reg_to_sp,\n-\t\t\t       NULL_RTX, NULL_RTX, NULL_RTX);\n+\t\t\t       NULL_RTX, NULL_RTX);\n }\n \n /* Emit an offset memory reference suitable for a frame store, while\n@@ -23578,7 +23578,7 @@ rs6000_emit_prologue (void)\n \n       insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n       rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n-\t\t\t    treg, GEN_INT (-info->total_size), NULL_RTX);\n+\t\t\t    treg, GEN_INT (-info->total_size));\n       sp_off = frame_off = info->total_size;\n     }\n \n@@ -23663,7 +23663,7 @@ rs6000_emit_prologue (void)\n \n \t  insn = emit_move_insn (mem, reg);\n \t  rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n-\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX);\n+\t\t\t\tNULL_RTX, NULL_RTX);\n \t  END_USE (0);\n \t}\n     }\n@@ -23719,7 +23719,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t     info->lr_save_offset,\n \t\t\t\t     DFmode, sel);\n       rs6000_frame_related (insn, ptr_reg, sp_off,\n-\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n+\t\t\t    NULL_RTX, NULL_RTX);\n       if (lr)\n \tEND_USE (0);\n     }\n@@ -23798,7 +23798,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t\t SAVRES_SAVE | SAVRES_GPR);\n \n \t  rs6000_frame_related (insn, spe_save_area_ptr, sp_off - save_off,\n-\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX);\n+\t\t\t\tNULL_RTX, NULL_RTX);\n \t}\n \n       /* Move the static chain pointer back.  */\n@@ -23848,7 +23848,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t     info->lr_save_offset + ptr_off,\n \t\t\t\t     reg_mode, sel);\n       rs6000_frame_related (insn, ptr_reg, sp_off - ptr_off,\n-\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n+\t\t\t    NULL_RTX, NULL_RTX);\n       if (lr)\n \tEND_USE (0);\n     }\n@@ -23864,7 +23864,7 @@ rs6000_emit_prologue (void)\n \t\t\t     info->gp_save_offset + frame_off + reg_size * i);\n       insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n       rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n-\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n+\t\t\t    NULL_RTX, NULL_RTX);\n     }\n   else if (!WORLD_SAVE_P (info))\n     {\n@@ -24187,7 +24187,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t     info->altivec_save_offset + ptr_off,\n \t\t\t\t     0, V4SImode, SAVRES_SAVE | SAVRES_VR);\n       rs6000_frame_related (insn, scratch_reg, sp_off - ptr_off,\n-\t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n+\t\t\t    NULL_RTX, NULL_RTX);\n       if (REGNO (frame_reg_rtx) == REGNO (scratch_reg))\n \t{\n \t  /* The oddity mentioned above clobbered our frame reg.  */\n@@ -24203,7 +24203,7 @@ rs6000_emit_prologue (void)\n       for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n \tif (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n \t  {\n-\t    rtx areg, savereg, mem, split_reg;\n+\t    rtx areg, savereg, mem;\n \t    int offset;\n \n \t    offset = (info->altivec_save_offset + frame_off\n@@ -24219,20 +24219,13 @@ rs6000_emit_prologue (void)\n \t    mem = gen_frame_mem (V4SImode,\n \t\t\t\t gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));\n \n-\t    insn = emit_move_insn (mem, savereg);\n-\n-\t    /* When we split a VSX store into two insns, we need to make\n-\t       sure the DWARF info knows which register we are storing.\n-\t       Pass it in to be used on the appropriate note.  */\n-\t    if (!BYTES_BIG_ENDIAN\n-\t\t&& GET_CODE (PATTERN (insn)) == SET\n-\t\t&& GET_CODE (SET_SRC (PATTERN (insn))) == VEC_SELECT)\n-\t      split_reg = savereg;\n-\t    else\n-\t      split_reg = NULL_RTX;\n+\t    /* Rather than emitting a generic move, force use of the stvx\n+\t       instruction, which we always want.  In particular we don't\n+\t       want xxpermdi/stxvd2x for little endian.  */\n+\t    insn = emit_insn (gen_altivec_stvx_v4si_internal (mem, savereg));\n \n \t    rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n-\t\t\t\t  areg, GEN_INT (offset), split_reg);\n+\t\t\t\t  areg, GEN_INT (offset));\n \t  }\n     }\n \n@@ -24873,7 +24866,10 @@ rs6000_emit_epilogue (int sibcall)\n \t\tmem = gen_frame_mem (V4SImode, addr);\n \n \t\treg = gen_rtx_REG (V4SImode, i);\n-\t\temit_move_insn (reg, mem);\n+\t\t/* Rather than emitting a generic move, force use of the\n+\t\t   lvx instruction, which we always want.  In particular\n+\t\t   we don't want lxvd2x/xxpermdi for little endian.  */\n+\t\t(void) emit_insn (gen_altivec_lvx_v4si_internal (reg, mem));\n \t      }\n \t}\n \n@@ -25076,7 +25072,10 @@ rs6000_emit_epilogue (int sibcall)\n \t\tmem = gen_frame_mem (V4SImode, addr);\n \n \t\treg = gen_rtx_REG (V4SImode, i);\n-\t\temit_move_insn (reg, mem);\n+\t\t/* Rather than emitting a generic move, force use of the\n+\t\t   lvx instruction, which we always want.  In particular\n+\t\t   we don't want lxvd2x/xxpermdi for little endian.  */\n+\t\t(void) emit_insn (gen_altivec_lvx_v4si_internal (reg, mem));\n \t      }\n \t}\n "}]}