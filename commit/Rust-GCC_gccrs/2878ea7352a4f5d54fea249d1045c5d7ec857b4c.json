{"sha": "2878ea7352a4f5d54fea249d1045c5d7ec857b4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg3OGVhNzM1MmE0ZjVkNTRmZWEyNDlkMTA0NWM1ZDdlYzg1N2I0Yw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2007-04-06T00:58:34Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2007-04-06T00:58:34Z"}, "message": "Cleanup whitespacing\n\nFrom-SVN: r123536", "tree": {"sha": "d443fa9cebd0cbf375c0b96707036a604255fa34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d443fa9cebd0cbf375c0b96707036a604255fa34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2878ea7352a4f5d54fea249d1045c5d7ec857b4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2878ea7352a4f5d54fea249d1045c5d7ec857b4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2878ea7352a4f5d54fea249d1045c5d7ec857b4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2878ea7352a4f5d54fea249d1045c5d7ec857b4c/comments", "author": null, "committer": null, "parents": [{"sha": "c7b89fc411f3904b337d15b77eef5a51d1ae82bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7b89fc411f3904b337d15b77eef5a51d1ae82bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7b89fc411f3904b337d15b77eef5a51d1ae82bf"}], "stats": {"total": 200, "additions": 100, "deletions": 100}, "files": [{"sha": "467ba2b1eecdd0f758318d72f8d448f26394fb89", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2878ea7352a4f5d54fea249d1045c5d7ec857b4c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2878ea7352a4f5d54fea249d1045c5d7ec857b4c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2878ea7352a4f5d54fea249d1045c5d7ec857b4c", "patch": "@@ -468,13 +468,13 @@ expand_builtin_init_dwarf_reg_sizes (tree address)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       int rnum = DWARF2_FRAME_REG_OUT (DWARF_FRAME_REGNUM (i), 1);\n-      \n+\n       if (rnum < DWARF_FRAME_REGISTERS)\n \t{\n \t  HOST_WIDE_INT offset = rnum * GET_MODE_SIZE (mode);\n \t  enum machine_mode save_mode = reg_raw_mode[i];\n \t  HOST_WIDE_INT size;\n-\t  \n+\n \t  if (HARD_REGNO_CALL_PART_CLOBBERED (i, save_mode))\n \t    save_mode = choose_hard_reg_mode (i, 1, true);\n \t  if (DWARF_FRAME_REGNUM (i) == DWARF_FRAME_RETURN_COLUMN)\n@@ -486,7 +486,7 @@ expand_builtin_init_dwarf_reg_sizes (tree address)\n \t  size = GET_MODE_SIZE (save_mode);\n \t  if (offset < 0)\n \t    continue;\n-\t  \n+\n \t  emit_move_insn (adjust_address (mem, mode, offset),\n \t\t\t  gen_int_mode (size, mode));\n \t}\n@@ -2218,7 +2218,7 @@ output_call_frame_info (int for_eh)\n       && for_eh)\n     for (i = 0; i < fde_table_in_use; i++)\n       if ((fde_table[i].nothrow || fde_table[i].all_throwers_are_sibcalls)\n-          && !fde_table[i].uses_eh_lsda\n+\t  && !fde_table[i].uses_eh_lsda\n \t  && ! DECL_WEAK (fde_table[i].decl))\n \ttargetm.asm_out.unwind_label (asm_out_file, fde_table[i].decl,\n \t\t\t\t      for_eh, /* empty */ 1);\n@@ -2234,7 +2234,7 @@ output_call_frame_info (int for_eh)\n       for (i = 0; i < fde_table_in_use; i++)\n \tif (fde_table[i].uses_eh_lsda)\n \t  any_eh_needed = any_lsda_needed = true;\n-        else if (TARGET_USES_WEAK_UNWIND_INFO && DECL_WEAK (fde_table[i].decl))\n+\telse if (TARGET_USES_WEAK_UNWIND_INFO && DECL_WEAK (fde_table[i].decl))\n \t  any_eh_needed = true;\n \telse if (! fde_table[i].nothrow\n \t\t && ! fde_table[i].all_throwers_are_sibcalls)\n@@ -2422,9 +2422,9 @@ output_call_frame_info (int for_eh)\n \t\t\t\t\t   \"FDE initial location\");\n \t  if (fde->dw_fde_switched_sections)\n \t    {\n-\t      rtx sym_ref2 = gen_rtx_SYMBOL_REF (Pmode, \n+\t      rtx sym_ref2 = gen_rtx_SYMBOL_REF (Pmode,\n \t\t\t\t      fde->dw_fde_unlikely_section_label);\n-\t      rtx sym_ref3= gen_rtx_SYMBOL_REF (Pmode, \n+\t      rtx sym_ref3= gen_rtx_SYMBOL_REF (Pmode,\n \t\t\t\t      fde->dw_fde_hot_section_label);\n \t      SYMBOL_REF_FLAGS (sym_ref2) |= SYMBOL_FLAG_LOCAL;\n \t      SYMBOL_REF_FLAGS (sym_ref3) |= SYMBOL_FLAG_LOCAL;\n@@ -2462,7 +2462,7 @@ output_call_frame_info (int for_eh)\n \t      dw2_asm_output_addr (DWARF2_ADDR_SIZE,\n \t\t\t\t   fde->dw_fde_unlikely_section_label,\n \t\t\t\t   \"FDE initial location\");\n-\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, \n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE,\n \t\t\t\t    fde->dw_fde_unlikely_section_end_label,\n \t\t\t\t    fde->dw_fde_unlikely_section_label,\n \t\t\t\t    \"FDE address range\");\n@@ -3838,14 +3838,14 @@ limbo_die_node;\n /* Fixed size portion of the address range info.  */\n #define DWARF_ARANGES_HEADER_SIZE\t\t\t\t\t\\\n   (DWARF_ROUND (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4,\t\\\n-                DWARF2_ADDR_SIZE * 2)\t\t\t\t\t\\\n+\t\tDWARF2_ADDR_SIZE * 2)\t\t\t\t\t\\\n    - DWARF_INITIAL_LENGTH_SIZE)\n \n /* Size of padding portion in the address range info.  It must be\n    aligned to twice the pointer size.  */\n #define DWARF_ARANGES_PAD_SIZE \\\n   (DWARF_ROUND (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4, \\\n-                DWARF2_ADDR_SIZE * 2) \\\n+\t\tDWARF2_ADDR_SIZE * 2)\t\t\t\t   \\\n    - (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4))\n \n /* Use assembler line directives if available.  */\n@@ -4347,7 +4347,7 @@ static int maybe_emit_file (struct dwarf_file_data *fd);\n static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char cold_text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-static char cold_end_label[MAX_ARTIFICIAL_LABEL_BYTES]; \n+static char cold_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char abbrev_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_info_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -4863,7 +4863,7 @@ block_ultimate_origin (tree block)\n \t\t       ? BLOCK_ABSTRACT_ORIGIN (ret_val) : NULL);\n \t}\n       while (lookahead != NULL && lookahead != ret_val);\n-      \n+\n       /* The block's abstract origin chain may not be the *ultimate* origin of\n \t the block. It could lead to a DECL that has an abstract origin set.\n \t If so, we want that DECL's abstract origin (which is what DECL_ORIGIN\n@@ -4906,7 +4906,7 @@ add_dwarf_attr (dw_die_ref die, dw_attr_ref attr)\n   /* Maybe this should be an assert?  */\n   if (die == NULL)\n     return;\n-  \n+\n   if (die->die_attr == NULL)\n     die->die_attr = VEC_alloc (dw_attr_node, gc, 1);\n   VEC_safe_push (dw_attr_node, gc, die->die_attr, attr);\n@@ -5345,7 +5345,7 @@ get_AT (dw_die_ref die, enum dwarf_attribute attr_kind)\n     else if (a->dw_attr == DW_AT_specification\n \t     || a->dw_attr == DW_AT_abstract_origin)\n       spec = AT_ref (a);\n-  \n+\n   if (spec)\n     return get_AT (spec, attr_kind);\n \n@@ -5443,7 +5443,7 @@ static inline bool\n is_cxx (void)\n {\n   unsigned int lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n-  \n+\n   return lang == DW_LANG_C_plus_plus || lang == DW_LANG_ObjC_plus_plus;\n }\n \n@@ -5530,7 +5530,7 @@ static void\n remove_child_TAG (dw_die_ref die, enum dwarf_tag tag)\n {\n   dw_die_ref c;\n-  \n+\n   c = die->die_child;\n   if (c) do {\n     dw_die_ref prev = c;\n@@ -5568,7 +5568,7 @@ add_child_die (dw_die_ref die, dw_die_ref child_die)\n }\n \n /* Move CHILD, which must be a child of PARENT or the DIE for which PARENT\n-   is the specification, to the end of PARENT's list of children.  \n+   is the specification, to the end of PARENT's list of children.\n    This is done by removing and re-adding it.  */\n \n static void\n@@ -5589,7 +5589,7 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n   gcc_assert (child->die_parent == parent\n \t      || (child->die_parent\n \t\t  == get_AT_ref (parent, DW_AT_specification)));\n-  \n+\n   for (p = child->die_parent->die_child; ; p = p->die_sib)\n     if (p->die_sib == child)\n       {\n@@ -6145,7 +6145,7 @@ same_die_p (dw_die_ref die1, dw_die_ref die2, int *mark)\n   if (VEC_length (dw_attr_node, die1->die_attr)\n       != VEC_length (dw_attr_node, die2->die_attr))\n     return 0;\n-  \n+\n   for (ix = 0; VEC_iterate (dw_attr_node, die1->die_attr, ix, a1); ix++)\n     if (!same_attr_p (a1, VEC_index (dw_attr_node, die2->die_attr, ix), mark))\n       return 0;\n@@ -6450,7 +6450,7 @@ break_out_includes (dw_die_ref die)\n \n \t/* This DIE is for a secondary CU; remove it from the main one.  */\n \tremove_child_with_prev (c, prev);\n-\t\n+\n \tif (c->die_tag == DW_TAG_GNU_BINCL)\n \t  unit = push_new_compile_unit (unit, c);\n \telse if (c->die_tag == DW_TAG_GNU_EINCL)\n@@ -6558,16 +6558,16 @@ build_abbrev_table (dw_die_ref die)\n       dw_attr_ref die_a, abbrev_a;\n       unsigned ix;\n       bool ok = true;\n-      \n+\n       if (abbrev->die_tag != die->die_tag)\n \tcontinue;\n       if ((abbrev->die_child != NULL) != (die->die_child != NULL))\n \tcontinue;\n-      \n+\n       if (VEC_length (dw_attr_node, abbrev->die_attr)\n \t  != VEC_length (dw_attr_node, die->die_attr))\n \tcontinue;\n-  \n+\n       for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, die_a); ix++)\n \t{\n \t  abbrev_a = VEC_index (dw_attr_node, abbrev->die_attr, ix);\n@@ -6775,7 +6775,7 @@ unmark_all_dies (dw_die_ref die)\n       unmark_all_dies (AT_ref (a));\n }\n \n-/* Return the size of the .debug_pubnames or .debug_pubtypes table  \n+/* Return the size of the .debug_pubnames or .debug_pubtypes table\n    generated for the compilation unit.  */\n \n static unsigned long\n@@ -7255,7 +7255,7 @@ output_die (dw_die_ref die)\n \tcase dw_val_class_file:\n \t  {\n \t    int f = maybe_emit_file (a->dw_attr_val.v.val_file);\n-\t    \n+\n \t    dw2_asm_output_data (constant_size (f), f, \"%s (%s)\", name,\n \t\t\t\t a->dw_attr_val.v.val_file->filename);\n \t    break;\n@@ -7284,7 +7284,7 @@ output_compilation_unit_header (void)\n     dw2_asm_output_data (4, 0xffffffff,\n       \"Initial length escape value indicating 64-bit DWARF extension\");\n   dw2_asm_output_data (DWARF_OFFSET_SIZE,\n-                       next_die_offset - DWARF_INITIAL_LENGTH_SIZE,\n+\t\t       next_die_offset - DWARF_INITIAL_LENGTH_SIZE,\n \t\t       \"Length of Compilation Unit Info\");\n   dw2_asm_output_data (2, DWARF_VERSION, \"DWARF version number\");\n   dw2_asm_output_offset (DWARF_OFFSET_SIZE, abbrev_section_label,\n@@ -7389,11 +7389,11 @@ add_pubtype (tree decl, dw_die_ref die)\n \t      else if (TREE_CODE (TYPE_NAME (decl)) == TYPE_DECL\n \t\t       && DECL_NAME (TYPE_NAME (decl)))\n \t\te.name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (decl)));\n-             else\n+\t      else\n \t       e.name = xstrdup ((const char *) get_AT_string (die, DW_AT_name));\n \t    }\n \t}\n-      else \n+      else\n \te.name = xstrdup (dwarf2_name (decl, 1));\n \n       /* If we don't have a name for the type, there's no point in adding\n@@ -7431,7 +7431,7 @@ output_pubnames (VEC (pubname_entry, gc) * names)\n \n   for (i = 0; VEC_iterate (pubname_entry, names, i, pub); i++)\n     {\n-      /* We shouldn't see pubnames for DIEs outside of the main CU.  */      \n+      /* We shouldn't see pubnames for DIEs outside of the main CU.  */\n       if (names == pubname_table)\n \tgcc_assert (pub->die->die_mark);\n \n@@ -7508,7 +7508,7 @@ output_aranges (void)\n \t\t\ttext_section_label, \"Length\");\n   if (flag_reorder_blocks_and_partition)\n     {\n-      dw2_asm_output_addr (DWARF2_ADDR_SIZE, cold_text_section_label, \n+      dw2_asm_output_addr (DWARF2_ADDR_SIZE, cold_text_section_label,\n \t\t\t   \"Address\");\n       dw2_asm_output_delta (DWARF2_ADDR_SIZE, cold_end_label,\n \t\t\t    cold_text_section_label, \"Length\");\n@@ -7690,7 +7690,7 @@ file_info_cmp (const void *p1, const void *p2)\n     }\n }\n \n-struct file_name_acquire_data \n+struct file_name_acquire_data\n {\n   struct file_info *files;\n   int used_files;\n@@ -7720,12 +7720,12 @@ file_name_acquire (void ** slot, void *data)\n   f = d->filename;\n   while (f[0] == '.' && IS_DIR_SEPARATOR (f[1]))\n     f += 2;\n-  \n+\n   /* Create a new array entry.  */\n   fi->path = f;\n   fi->length = strlen (f);\n   fi->file_idx = d;\n-  \n+\n   /* Search for the file name part.  */\n   f = strrchr (f, DIR_SEPARATOR);\n #if defined (DIR_SEPARATOR_2)\n@@ -8396,26 +8396,26 @@ is_subrange_type (tree type)\n       && tree_int_cst_equal (TYPE_MAX_VALUE (type), TYPE_MAX_VALUE (subtype)))\n     {\n       /* The type and its subtype have the same representation.  If in\n-         addition the two types also have the same name, then the given\n-         type is not a subrange type, but rather a plain base type.  */\n+\t addition the two types also have the same name, then the given\n+\t type is not a subrange type, but rather a plain base type.  */\n       /* FIXME: brobecker/2004-03-22:\n-         Sizetype INTEGER_CSTs nodes are canonicalized.  It should\n-         therefore be sufficient to check the TYPE_SIZE node pointers\n-         rather than checking the actual size.  Unfortunately, we have\n-         found some cases, such as in the Ada \"integer\" type, where\n-         this is not the case.  Until this problem is solved, we need to\n-         keep checking the actual size.  */\n+\t Sizetype INTEGER_CSTs nodes are canonicalized.  It should\n+\t therefore be sufficient to check the TYPE_SIZE node pointers\n+\t rather than checking the actual size.  Unfortunately, we have\n+\t found some cases, such as in the Ada \"integer\" type, where\n+\t this is not the case.  Until this problem is solved, we need to\n+\t keep checking the actual size.  */\n       tree type_name = TYPE_NAME (type);\n       tree subtype_name = TYPE_NAME (subtype);\n \n       if (type_name != NULL && TREE_CODE (type_name) == TYPE_DECL)\n-        type_name = DECL_NAME (type_name);\n+\ttype_name = DECL_NAME (type_name);\n \n       if (subtype_name != NULL && TREE_CODE (subtype_name) == TYPE_DECL)\n-        subtype_name = DECL_NAME (subtype_name);\n+\tsubtype_name = DECL_NAME (subtype_name);\n \n       if (type_name == subtype_name)\n-        return false;\n+\treturn false;\n     }\n \n   return true;\n@@ -8438,16 +8438,16 @@ subrange_type_die (tree type, dw_die_ref context_die)\n   if (int_size_in_bytes (TREE_TYPE (type)) != size_in_bytes)\n     {\n       /* The size of the subrange type and its base type do not match,\n-         so we need to generate a size attribute for the subrange type.  */\n+\t so we need to generate a size attribute for the subrange type.  */\n       add_AT_unsigned (subrange_die, DW_AT_byte_size, size_in_bytes);\n     }\n \n   if (TYPE_MIN_VALUE (type) != NULL)\n     add_bound_info (subrange_die, DW_AT_lower_bound,\n-                    TYPE_MIN_VALUE (type));\n+\t\t    TYPE_MIN_VALUE (type));\n   if (TYPE_MAX_VALUE (type) != NULL)\n     add_bound_info (subrange_die, DW_AT_upper_bound,\n-                    TYPE_MAX_VALUE (type));\n+\t\t    TYPE_MAX_VALUE (type));\n \n   return subrange_die;\n }\n@@ -8475,22 +8475,22 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n     = get_qualified_type (type,\n \t\t\t  ((is_const_type ? TYPE_QUAL_CONST : 0)\n \t\t\t   | (is_volatile_type ? TYPE_QUAL_VOLATILE : 0)));\n-  \n+\n   /* If we do, then we can just use its DIE, if it exists.  */\n   if (qualified_type)\n     {\n       mod_type_die = lookup_type_die (qualified_type);\n       if (mod_type_die)\n \treturn mod_type_die;\n     }\n-  \n+\n   name = qualified_type ? TYPE_NAME (qualified_type) : NULL;\n-  \n+\n   /* Handle C typedef types.  */\n   if (name && TREE_CODE (name) == TYPE_DECL && DECL_ORIGINAL_TYPE (name))\n     {\n       tree dtype = TREE_TYPE (name);\n-      \n+\n       if (qualified_type == dtype)\n \t{\n \t  /* For a named type, use the typedef.  */\n@@ -8509,7 +8509,7 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n \t\t\t\t  context_die);\n       /* Else cv-qualified version of named type; fall through.  */\n     }\n-  \n+\n   if (is_const_type)\n     {\n       mod_type_die = new_die (DW_TAG_const_type, comp_unit_die, type);\n@@ -8544,7 +8544,7 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n   else\n     {\n       gen_type_die (type, context_die);\n-      \n+\n       /* We have to get the type_main_variant here (and pass that to the\n \t `lookup_type_die' routine) because the ..._TYPE node we have\n \t might simply be a *copy* of some original type node (where the\n@@ -8558,7 +8558,7 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n \t   not the main variant.  */\n \treturn lookup_type_die (type);\n     }\n-  \n+\n   /* Builtin types don't have a DECL_ORIGINAL_TYPE.  For those,\n      don't output a DW_TAG_typedef, since there isn't one in the\n      user's program; just attach a DW_AT_name to the type.  */\n@@ -8572,7 +8572,7 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n \tname = DECL_NAME (name);\n       add_name_attribute (mod_type_die, IDENTIFIER_POINTER (name));\n     }\n-  \n+\n   if (qualified_type)\n     equate_type_number_to_die (qualified_type, mod_type_die);\n \n@@ -8795,9 +8795,9 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset)\n \t    }\n \t  gcc_assert (elim == (frame_pointer_needed ? hard_frame_pointer_rtx\n \t\t      : stack_pointer_rtx));\n-          offset += frame_pointer_fb_offset;\n+\t  offset += frame_pointer_fb_offset;\n \n-          return new_loc_descr (DW_OP_fbreg, offset, 0);\n+\t  return new_loc_descr (DW_OP_fbreg, offset, 0);\n \t}\n     }\n \n@@ -9277,7 +9277,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \n \tif (rtl == NULL_RTX)\n \t  return 0;\n-        else if (GET_CODE (rtl) == CONST_INT)\n+\telse if (GET_CODE (rtl) == CONST_INT)\n \t  {\n \t    HOST_WIDE_INT val = INTVAL (rtl);\n \t    if (TYPE_UNSIGNED (TREE_TYPE (loc)))\n@@ -9528,13 +9528,13 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n     case MIN_EXPR:\n     case MAX_EXPR:\n       {\n-        const enum tree_code code =\n-          TREE_CODE (loc) == MIN_EXPR ? GT_EXPR : LT_EXPR;\n+\tconst enum tree_code code =\n+\t  TREE_CODE (loc) == MIN_EXPR ? GT_EXPR : LT_EXPR;\n \n-        loc = build3 (COND_EXPR, TREE_TYPE (loc),\n+\tloc = build3 (COND_EXPR, TREE_TYPE (loc),\n \t\t      build2 (code, integer_type_node,\n \t\t\t      TREE_OPERAND (loc, 0), TREE_OPERAND (loc, 1)),\n-                      TREE_OPERAND (loc, 1), TREE_OPERAND (loc, 0));\n+\t\t      TREE_OPERAND (loc, 1), TREE_OPERAND (loc, 0));\n       }\n \n       /* ... fall through ...  */\n@@ -9577,7 +9577,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n       /* Leave front-end specific codes as simply unknown.  This comes\n \t up, for instance, with the C STMT_EXPR.  */\n       if ((unsigned int) TREE_CODE (loc)\n-          >= (unsigned int) LAST_AND_UNUSED_TREE_CODE)\n+\t  >= (unsigned int) LAST_AND_UNUSED_TREE_CODE)\n \treturn 0;\n \n #ifdef ENABLE_CHECKING\n@@ -10117,7 +10117,7 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n {\n   if (! EXPR_P (*tp) && ! GIMPLE_STMT_P (*tp) && ! CONSTANT_CLASS_P (*tp))\n     *walk_subtrees = 0;\n-  \n+\n   if (DECL_P (*tp) && ! TREE_PUBLIC (*tp) && ! TREE_USED (*tp)\n       && ! TREE_ASM_WRITTEN (*tp))\n     return *tp;\n@@ -10137,7 +10137,7 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n     {\n       struct cgraph_node *node = cgraph_node (*tp);\n       if (!node->output)\n-        return *tp;\n+\treturn *tp;\n     }\n \n   return NULL_TREE;\n@@ -10173,7 +10173,7 @@ rtl_for_decl_init (tree init, tree type)\n      CONCAT: FIXME!  */\n   else if (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == COMPLEX_TYPE)\n     ;\n-  /* Vectors only work if their mode is supported by the target.  \n+  /* Vectors only work if their mode is supported by the target.\n      FIXME: generic vectors ought to work too.  */\n   else if (TREE_CODE (type) == VECTOR_TYPE && TYPE_MODE (type) == BLKmode)\n     ;\n@@ -10448,7 +10448,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL\n \t      || TREE_CODE (decl) == RESULT_DECL);\n-\t     \n+\n   /* See if we possibly have multiple locations for this variable.  */\n   loc_list = lookup_decl_loc (decl);\n \n@@ -10461,7 +10461,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       rtx varloc;\n \n       /* Now that we know what section we are using for a base,\n-         actually construct the list of locations.\n+\t actually construct the list of locations.\n \t The first location information is what is passed to the\n \t function that creates the location list, and the remaining\n \t locations just get added on to that list.\n@@ -10515,14 +10515,14 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \n   /* Try to get some constant RTL for this decl, and use that as the value of\n      the location.  */\n-  \n+\n   rtl = rtl_for_decl_location (decl);\n   if (rtl && (CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING))\n     {\n       add_const_value_attribute (die, rtl);\n       return;\n     }\n-  \n+\n   /* If we have tried to generate the location otherwise, and it\n      didn't work out (we wouldn't be here if we did), and we have a one entry\n      location list, try generating a location from that.  */\n@@ -11004,7 +11004,7 @@ add_abstract_origin_attribute (dw_die_ref die, tree origin)\n \n       if (TYPE_P (fn))\n \tfn = TYPE_STUB_DECL (fn);\n-      \n+\n       fn = decl_function_context (fn);\n       if (fn)\n \tdwarf2out_abstract_function (fn);\n@@ -11907,17 +11907,17 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n     {\n       if (DECL_DECLARED_INLINE_P (decl))\n \t{\n-          if (cgraph_function_possibly_inlined_p (decl))\n+\t  if (cgraph_function_possibly_inlined_p (decl))\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_declared_inlined);\n \t  else\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_declared_not_inlined);\n \t}\n       else\n \t{\n \t  if (cgraph_function_possibly_inlined_p (decl))\n-            add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_inlined);\n+\t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_inlined);\n \t  else\n-            add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_not_inlined);\n+\t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_not_inlined);\n \t}\n \n       equate_decl_number_to_die (decl, subr_die);\n@@ -11937,7 +11937,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n \t\t\t\t       current_function_funcdef_no);\n \t  add_AT_lbl_id (subr_die, DW_AT_high_pc, label_id);\n-\t  \n+\n \t  add_pubname (decl, subr_die);\n \t  add_arange (decl, subr_die);\n \t}\n@@ -11986,7 +11986,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n       /* Compute a displacement from the \"steady-state frame pointer\" to\n \t the CFA.  The former is what all stack slots and argument slots\n-\t will reference in the rtl; the later is what we've told the \n+\t will reference in the rtl; the later is what we've told the\n \t debugger about.  We'll need to adjust all frame_base references\n \t by this displacement.  */\n       compute_frame_pointer_to_fb_displacement (cfa_fb_offset);\n@@ -12109,17 +12109,17 @@ gen_variable_die (tree decl, dw_die_ref context_die)\n \t\t\tthe program.  For example, consider the C++\n \t\t\ttest case:\n \n-                          template <class T>\n-                          struct S { static const int i = 7; };\n+\t\t\t  template <class T>\n+\t\t\t  struct S { static const int i = 7; };\n \n-                          template <class T>\n-                          const int S<T>::i;\n+\t\t\t  template <class T>\n+\t\t\t  const int S<T>::i;\n+\n+\t\t\t  int f() { return S<int>::i; }\n \n-                          int f() { return S<int>::i; }\n-\t\t\t  \n \t\t\tHere, S<int>::i is not DECL_EXTERNAL, but no\n \t\t\tdefinition is required, so the compiler will\n-\t\t\tnot emit a definition.  */  \n+\t\t\tnot emit a definition.  */\n \t\t     || (TREE_CODE (decl) == VAR_DECL\n \t\t\t && DECL_COMDAT (decl) && !TREE_ASM_WRITTEN (decl))\n \t\t     || class_or_namespace_scope_p (context_die));\n@@ -12997,8 +12997,8 @@ gen_block_die (tree stmt, dw_die_ref context_die, int depth)\n \t  if (debug_info_level > DINFO_LEVEL_TERSE)\n \t    /* We are not in terse mode so *any* local declaration counts\n \t       as being a \"significant\" one.  */\n-\t    must_output_die = (BLOCK_VARS (stmt) != NULL \n-\t\t\t       && (TREE_USED (stmt) \n+\t    must_output_die = (BLOCK_VARS (stmt) != NULL\n+\t\t\t       && (TREE_USED (stmt)\n \t\t\t\t   || TREE_ASM_WRITTEN (stmt)\n \t\t\t\t   || BLOCK_ABSTRACT (stmt)));\n \t  else\n@@ -13055,14 +13055,14 @@ decls_for_scope (tree stmt, dw_die_ref context_die, int depth)\n       for (decl = BLOCK_VARS (stmt); decl != NULL; decl = TREE_CHAIN (decl))\n \t{\n \t  dw_die_ref die;\n-\t  \n+\n \t  if (TREE_CODE (decl) == FUNCTION_DECL)\n \t    die = lookup_decl_die (decl);\n \t  else if (TREE_CODE (decl) == TYPE_DECL && TYPE_DECL_IS_STUB (decl))\n \t    die = lookup_type_die (TREE_TYPE (decl));\n \t  else\n \t    die = NULL;\n-\t  \n+\n \t  if (die != NULL && die->die_parent == NULL)\n \t    add_child_die (context_die, die);\n \t  /* Do not produce debug information for static variables since\n@@ -13622,7 +13622,7 @@ dwarf2out_decl (tree decl)\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \treturn;\n       if (lookup_decl_die (decl) != NULL)\n-        return;\n+\treturn;\n       break;\n \n     case TYPE_DECL:\n@@ -13773,15 +13773,15 @@ maybe_emit_file (struct dwarf_file_data * fd)\n       else\n \tfd->emitted_number = 1;\n       last_emitted_file = fd;\n-      \n+\n       if (DWARF2_ASM_LINE_DEBUG_INFO)\n \t{\n \t  fprintf (asm_out_file, \"\\t.file %u \", fd->emitted_number);\n \t  output_quoted_string (asm_out_file, fd->filename);\n \t  fputc ('\\n', asm_out_file);\n \t}\n     }\n-  \n+\n   return fd->emitted_number;\n }\n \n@@ -13844,7 +13844,7 @@ static void\n dwarf2out_begin_function (tree fun)\n {\n   htab_empty (decl_loc_table);\n-  \n+\n   if (function_section (fun) != text_section)\n     have_multiple_function_sections = true;\n }\n@@ -13860,7 +13860,7 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n       && line != 0)\n     {\n       int file_num = maybe_emit_file (lookup_filename (filename));\n-      \n+\n       switch_to_section (current_function_section ());\n \n       /* If requested, emit something human-readable.  */\n@@ -13879,7 +13879,7 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n       else if (function_section (current_function_decl) != text_section)\n \t{\n \t  dw_separate_line_info_ref line_info;\n-\t  targetm.asm_out.internal_label (asm_out_file, \n+\t  targetm.asm_out.internal_label (asm_out_file,\n \t\t\t\t\t  SEPARATE_LINE_CODE_LABEL,\n \t\t\t\t\t  separate_line_info_table_in_use);\n \n@@ -14090,7 +14090,7 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   ASM_GENERATE_INTERNAL_LABEL (abbrev_section_label,\n \t\t\t       DEBUG_ABBREV_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (text_section_label, TEXT_SECTION_LABEL, 0);\n-  ASM_GENERATE_INTERNAL_LABEL (cold_text_section_label, \n+  ASM_GENERATE_INTERNAL_LABEL (cold_text_section_label,\n \t\t\t       COLD_TEXT_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (cold_end_label, COLD_END_LABEL, 0);\n \n@@ -14149,7 +14149,7 @@ static void\n verify_marks_clear (dw_die_ref die)\n {\n   dw_die_ref c;\n-  \n+\n   gcc_assert (! die->die_mark);\n   FOR_EACH_CHILD (die, c, verify_marks_clear (c));\n }\n@@ -14162,7 +14162,7 @@ static void\n prune_unmark_dies (dw_die_ref die)\n {\n   dw_die_ref c;\n-  \n+\n   if (die->die_mark)\n     die->die_mark = 0;\n   FOR_EACH_CHILD (die, c, prune_unmark_dies (c));\n@@ -14215,9 +14215,9 @@ prune_unused_types_mark (dw_die_ref die, int dokids)\n       prune_unused_types_walk_attribs (die);\n \n       /* If this node is a specification,\n-         also mark the definition, if it exists.  */\n+\t also mark the definition, if it exists.  */\n       if (get_AT_flag (die, DW_AT_declaration) && die->die_definition)\n-        prune_unused_types_mark (die->die_definition, 1);\n+\tprune_unused_types_mark (die->die_definition, 1);\n     }\n \n   if (dokids && die->die_mark != 2)\n@@ -14329,7 +14329,7 @@ prune_unused_types_prune (dw_die_ref die)\n \n   if (! die->die_child)\n     return;\n-  \n+\n   c = die->die_child;\n   do {\n     dw_die_ref prev = c;\n@@ -14574,7 +14574,7 @@ dwarf2out_finish (const char *filename)\n       output_pubnames (pubtype_table);\n     }\n #endif\n-  \n+\n   /* Output the address range information.  We only put functions in the arange\n      table, so don't write it out if we don't have any.  */\n   if (fde_table_in_use)"}]}