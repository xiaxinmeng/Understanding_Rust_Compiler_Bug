{"sha": "84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRhNWI0Zjg1OGZjMmFlYzVmODcxZTYwNmNkZmVmM2RkNGExNTk0OA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dan@cgsoftware.com", "date": "2001-07-04T17:55:20Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2001-07-04T17:55:20Z"}, "message": "c-lex.c (cb_file_change): Pass line number to debug_start_source_file.\n\n2001-07-04  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* c-lex.c (cb_file_change): Pass line number to\n\tdebug_start_source_file.\n\t(cb_undefine): Pass correct line number to debug_undef.\n\n\t* toplev.c (debug_start_source_file): Add line number to\n\tparameters. Pass it along to dwarf2out_start_source_file.\n\t(decode_g_option): Stop resetting debug level back to normal when\n\twe change debug formats, unless the current level is\n\tnone. (Before, -g3 -gdwarf-2 would use debug level 2, rather than\n\t3).\n\n\t* toplev.h (debug_start_source_file): Add line number to\n\tparameters.\n\n\t* dwarf2out.h (dwarf2out_start_source_file): Add line number to parameters.\n\n\t* dwarf2out.c (dwarf2out_start_source_file): Add line number to\n\tparameters.\n\tOutput debug_macinfo data for starting file if requested.\n\t(dwarf2out_end_source_file): Output debug_macinfo data for ending\n\tfile if requested.\n\t(dwarf2out_define): Output debug_macinfo data for defining a macro if requested.\n\t(dwarf2out_undef): Output debug_macinfo data for undefining a\n\tmacro if requested.\n\t(DEBUG_MACINFO_SECTION): New. DWARF2 macro info section name.\n\t(DEBUG_MACINFO_SECTION_LABEL): New. DWARF2 macro info section label.\n\t(macinfo_section_label): New. DWARF2 macro info section label.\n\t(dwarf2out_init): If we want macro info, output the start label\n\tfor the section.\n\t(dwarf2out_finish): If we want macro info, add a DW_AT_macro_info\n\tattribute to the compilation unit die pointing to the macro info.\n\n2001-07-04  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* dwarf2out.c (new_loc_list): Move to inside #ifdef\n\tDWARF2_DEBUGGING_INFO.\n\t(add_loc_descr_to_loc_list): Ditto.\n\t(output_loc_list): Ditto.\n\tAlso, fix thinko in curr not being initialized.\n\t(gen_internal_sym): Ditto.\n\nFrom-SVN: r43763", "tree": {"sha": "866053af775f4ecaac850dcdb59314ecf5745f95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/866053af775f4ecaac850dcdb59314ecf5745f95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/comments", "author": null, "committer": null, "parents": [{"sha": "792760b9e9c015cabd3d5f1f7cf4942081f646d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792760b9e9c015cabd3d5f1f7cf4942081f646d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792760b9e9c015cabd3d5f1f7cf4942081f646d6"}], "stats": {"total": 225, "additions": 156, "deletions": 69}, "files": [{"sha": "9283fa1badbd20d449daf46df01eaab1dc628278", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "patch": "@@ -1,3 +1,46 @@\n+2001-07-04  Daniel Berlin  <dan@cgsoftware.com>\n+\n+\t* c-lex.c (cb_file_change): Pass line number to\n+\tdebug_start_source_file. \n+\t(cb_undefine): Pass correct line number to debug_undef.\n+\n+\t* toplev.c (debug_start_source_file): Add line number to\n+\tparameters. Pass it along to dwarf2out_start_source_file.\n+\t(decode_g_option): Stop resetting debug level back to normal when\n+\twe change debug formats, unless the current level is\n+\tnone. (Before, -g3 -gdwarf-2 would use debug level 2, rather than\n+\t3).\n+\t\n+\t* toplev.h (debug_start_source_file): Add line number to\n+\tparameters.\n+\t\n+\t* dwarf2out.h (dwarf2out_start_source_file): Add line number to parameters.\n+\n+\t* dwarf2out.c (dwarf2out_start_source_file): Add line number to\n+\tparameters.\n+\tOutput debug_macinfo data for starting file if requested. \n+\t(dwarf2out_end_source_file): Output debug_macinfo data for ending\n+\tfile if requested.\n+\t(dwarf2out_define): Output debug_macinfo data for defining a macro if requested.\n+\t(dwarf2out_undef): Output debug_macinfo data for undefining a\n+\tmacro if requested.\n+\t(DEBUG_MACINFO_SECTION): New. DWARF2 macro info section name.\n+\t(DEBUG_MACINFO_SECTION_LABEL): New. DWARF2 macro info section label.\n+\t(macinfo_section_label): New. DWARF2 macro info section label.\n+\t(dwarf2out_init): If we want macro info, output the start label\n+\tfor the section.\n+\t(dwarf2out_finish): If we want macro info, add a DW_AT_macro_info\n+\tattribute to the compilation unit die pointing to the macro info.\n+\n+2001-07-04  Daniel Berlin  <dan@cgsoftware.com>\n+\n+\t* dwarf2out.c (new_loc_list): Move to inside #ifdef\n+\tDWARF2_DEBUGGING_INFO.\n+\t(add_loc_descr_to_loc_list): Ditto.\n+\t(output_loc_list): Ditto.\n+\tAlso, fix thinko in curr not being initialized.\n+\t(gen_internal_sym): Ditto.\n+     \n Wed Jul  4 13:40:02 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* emit-rtl.c (replace_equiv_address): New function."}, {"sha": "714de0c807f4e2472466d8f0bdd717c78e948041", "filename": "gcc/c-lex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "patch": "@@ -249,7 +249,7 @@ cb_file_change (pfile, fc)\n \t  lineno = fc->from.lineno;\n \t  push_srcloc (fc->to.filename, 1);\n \t  input_file_stack->indent_level = indent_level;\n-\t  debug_start_source_file (fc->to.filename);\n+\t  debug_start_source_file (fc->from.lineno, fc->to.filename);\n #ifndef NO_IMPLICIT_EXTERN_C\n \t  if (c_header_level)\n \t    ++c_header_level;\n@@ -334,7 +334,7 @@ cb_define (pfile, node)\n      cpp_reader *pfile;\n      cpp_hashnode *node;\n {\n-  debug_define (lineno, (const char *) cpp_macro_definition (pfile, node));\n+  debug_define (cpp_get_line (parse_in)->line,  (const char *) cpp_macro_definition (pfile, node));\n }\n \n /* #undef callback for DWARF and DWARF2 debug info.  */\n@@ -343,7 +343,7 @@ cb_undef (pfile, node)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n      cpp_hashnode *node;\n {\n-  debug_undef (lineno, (const char *) NODE_NAME (node));\n+  debug_undef (cpp_get_line (parse_in)->line, (const char *) NODE_NAME (node));\n }\n \n #if 0 /* not yet */"}, {"sha": "5879a8edb9145f3cd3005defb92944fee8cbc84c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 97, "deletions": 59, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "patch": "@@ -2223,14 +2223,6 @@ static unsigned long size_of_locs\tPARAMS ((dw_loc_descr_ref));\n static void output_loc_operands\t\tPARAMS ((dw_loc_descr_ref));\n static void output_loc_sequence\t\tPARAMS ((dw_loc_descr_ref));\n \n-static dw_loc_list_ref new_loc_list     PARAMS ((dw_loc_descr_ref, \n-\t\t\t\t\t\t const char *, const char *,\n-\t\t\t\t\t\t const char *, unsigned));\n-static void add_loc_descr_to_loc_list   PARAMS ((dw_loc_list_ref *,\n-\t\t\t\t\t\t dw_loc_descr_ref,\n-\t\t\t\t\t\t const char *, const char *, const char *));\n-static void output_loc_list\t\tPARAMS ((dw_loc_list_ref));\n-static char *gen_internal_sym \t\tPARAMS ((const char *));\n /* Convert a DWARF stack opcode into its string name.  */\n \n static const char *\n@@ -2558,28 +2550,6 @@ new_loc_descr (op, oprnd1, oprnd2)\n   return descr;\n }\n \n-/* Return a new location list, given the begin and end range, and the\n-   expression. gensym tells us whether to generate a new internal\n-   symbol for this location list node, which is done for the head of\n-   the list only. */ \n-static inline dw_loc_list_ref\n-new_loc_list (expr, begin, end, section, gensym)\n-     register dw_loc_descr_ref expr;\n-     register const char *begin;\n-     register const char *end;\n-     register const char *section;\n-     register unsigned gensym;\n-{\n-  register dw_loc_list_ref retlist\n-    = (dw_loc_list_ref) xcalloc (1, sizeof (dw_loc_list_node));\n-  retlist->begin = begin;\n-  retlist->end = end;\n-  retlist->expr = expr;\n-  retlist->section = section;\n-  if (gensym) \n-    retlist->ll_symbol = gen_internal_sym (\"LLST\");\n-  return retlist;\n-}\n \n /* Add a location description term to a location description expression.  */\n \n@@ -2597,24 +2567,6 @@ add_loc_descr (list_head, descr)\n   *d = descr;\n }\n \n-/* Add a location description expression to a location list */\n-static inline void\n-add_loc_descr_to_loc_list (list_head, descr, begin, end, section)\n-     register dw_loc_list_ref *list_head;\n-     register dw_loc_descr_ref descr;\n-     register const char *begin;\n-     register const char *end;\n-     register const char *section;\n-{\n-  register dw_loc_list_ref *d;\n-  \n-  /* Find the end of the chain. */\n-  for (d = list_head; (*d) != NULL; d = &(*d)->dw_loc_next)\n-    ;\n-  /* Add a new location list node to the list */\n-  *d = new_loc_list (descr, begin, end, section, 0);\n-}\n-\n /* Return the size of a location descriptor.  */\n \n static unsigned long\n@@ -3592,6 +3544,14 @@ static void gen_type_die_for_member\tPARAMS ((tree, tree, dw_die_ref));\n static rtx save_rtx\t\t\tPARAMS ((rtx));\n static void splice_child_die\t\tPARAMS ((dw_die_ref, dw_die_ref));\n static int file_info_cmp\t\tPARAMS ((const void *, const void *));\n+static dw_loc_list_ref new_loc_list     PARAMS ((dw_loc_descr_ref, \n+\t\t\t\t\t\t const char *, const char *,\n+\t\t\t\t\t\t const char *, unsigned));\n+static void add_loc_descr_to_loc_list   PARAMS ((dw_loc_list_ref *,\n+\t\t\t\t\t\t dw_loc_descr_ref,\n+\t\t\t\t\t\t const char *, const char *, const char *));\n+static void output_loc_list\t\tPARAMS ((dw_loc_list_ref));\n+static char *gen_internal_sym \t\tPARAMS ((const char *));\n \n /* Section names used to hold DWARF debugging information.  */\n #ifndef DEBUG_INFO_SECTION\n@@ -3648,7 +3608,9 @@ static int file_info_cmp\t\tPARAMS ((const void *, const void *));\n #ifndef DEBUG_LOC_SECTION_LABEL\n #define DEBUG_LOC_SECTION_LABEL\t\t\"Ldebug_loc\"\n #endif\n-\n+#ifndef DEBUG_MACINFO_SECTION_LABEL\n+#define DEBUG_MACINFO_SECTION_LABEL     \"Ldebug_macinfo\"\n+#endif\n /* Definitions of defaults for formats and names of various special\n    (artificial) labels which may be generated within this file (when the -g\n    options is used and DWARF_DEBUGGING_INFO is in effect.\n@@ -3660,6 +3622,7 @@ static char text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char abbrev_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_info_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+static char macinfo_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char loc_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n #ifndef TEXT_END_LABEL\n #define TEXT_END_LABEL\t\t\"Letext\"\n@@ -5931,21 +5894,64 @@ output_die_symbol (die)\n   ASM_OUTPUT_LABEL (asm_out_file, sym);\n }\n \n+/* Return a new location list, given the begin and end range, and the\n+   expression. gensym tells us whether to generate a new internal\n+   symbol for this location list node, which is done for the head of\n+   the list only. */ \n+static inline dw_loc_list_ref\n+new_loc_list (expr, begin, end, section, gensym)\n+     register dw_loc_descr_ref expr;\n+     register const char *begin;\n+     register const char *end;\n+     register const char *section;\n+     register unsigned gensym;\n+{\n+  register dw_loc_list_ref retlist\n+    = (dw_loc_list_ref) xcalloc (1, sizeof (dw_loc_list_node));\n+  retlist->begin = begin;\n+  retlist->end = end;\n+  retlist->expr = expr;\n+  retlist->section = section;\n+  if (gensym) \n+    retlist->ll_symbol = gen_internal_sym (\"LLST\");\n+  return retlist;\n+}\n+\n+/* Add a location description expression to a location list */\n+static inline void\n+add_loc_descr_to_loc_list (list_head, descr, begin, end, section)\n+     register dw_loc_list_ref *list_head;\n+     register dw_loc_descr_ref descr;\n+     register const char *begin;\n+     register const char *end;\n+     register const char *section;\n+{\n+  register dw_loc_list_ref *d;\n+  \n+  /* Find the end of the chain. */\n+  for (d = list_head; (*d) != NULL; d = &(*d)->dw_loc_next)\n+    ;\n+  /* Add a new location list node to the list */\n+  *d = new_loc_list (descr, begin, end, section, 0);\n+}\n+\n+\n+\n /* Output the location list given to us */\n static void\n output_loc_list (list_head)\n      register dw_loc_list_ref list_head;\n {\n-  register dw_loc_list_ref curr;\n+  register dw_loc_list_ref curr=list_head;\n   ASM_OUTPUT_LABEL (asm_out_file, list_head->ll_symbol);\n   if (strcmp (curr->section, \".text\") == 0)\n     {\n       if (DWARF2_ADDR_SIZE == 4)\n-        dw2_asm_output_data (DWARF2_ADDR_SIZE, 0xffffffff, \"Location list base address specifier fake entry\");\n+\tdw2_asm_output_data (DWARF2_ADDR_SIZE, 0xffffffff, \"Location list base address specifier fake entry\");\n       else if (DWARF2_ADDR_SIZE == 8)\n \tdw2_asm_output_data (DWARF2_ADDR_SIZE, 0xffffffffffffffffLL, \"Location list base address specifier fake entry\");\n       else\n-        abort();\n+\tabort();\n       dw2_asm_output_offset (DWARF2_ADDR_SIZE, curr->section, \"Location list base address specifier base\");\n     }\n   for (curr = list_head; curr != NULL; curr=curr->dw_loc_next)\n@@ -11263,10 +11269,11 @@ dwarf2out_line (filename, line)\n }\n \n /* Record the beginning of a new source file, for later output\n-   of the .debug_macinfo section.  At present, unimplemented.  */\n+   of the .debug_macinfo section.*/\n \n void\n-dwarf2out_start_source_file (filename)\n+dwarf2out_start_source_file (lineno, filename)\n+     register unsigned int lineno ATTRIBUTE_UNUSED;\n      register const char *filename ATTRIBUTE_UNUSED;\n {\n   if (flag_eliminate_dwarf2_dups)\n@@ -11275,6 +11282,13 @@ dwarf2out_start_source_file (filename)\n       dw_die_ref bincl_die = new_die (DW_TAG_GNU_BINCL, comp_unit_die);\n       add_AT_string (bincl_die, DW_AT_name, filename);\n     }\n+  if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n+    {\n+      ASM_OUTPUT_SECTION (asm_out_file, DEBUG_MACINFO_SECTION);\n+      dw2_asm_output_data (1, DW_MACINFO_start_file, \"Start new file\");\n+      dw2_asm_output_data_uleb128 (lineno, \"Included from line number %d\", lineno);\n+      dw2_asm_output_data_uleb128 (lookup_filename (filename), \"Filename we just started\");\n+    }\n }\n \n /* Record the end of a source file, for later output\n@@ -11288,6 +11302,11 @@ dwarf2out_end_source_file ()\n       /* Record the end of the file for break_out_includes.  */\n       new_die (DW_TAG_GNU_EINCL, comp_unit_die);\n     }\n+  if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n+    {\n+      ASM_OUTPUT_SECTION (asm_out_file, DEBUG_MACINFO_SECTION);\n+      dw2_asm_output_data (1, DW_MACINFO_end_file, \"End file\");\n+    }\n }\n \n /* Called from check_newline in c-parse.y.  The `buffer' parameter contains\n@@ -11302,9 +11321,16 @@ dwarf2out_define (lineno, buffer)\n   static int initialized = 0;\n   if (!initialized)\n     {\n-      dwarf2out_start_source_file (primary_filename);\n+      dwarf2out_start_source_file (0, primary_filename);\n       initialized = 1;\n     }\n+  if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n+    {\n+      ASM_OUTPUT_SECTION (asm_out_file, DEBUG_MACINFO_SECTION);\n+      dw2_asm_output_data (1, DW_MACINFO_define, \"Define macro\");\n+      dw2_asm_output_data_uleb128 (lineno, \"At line number %d\", lineno);\n+      dw2_asm_output_nstring (buffer, -1, \"The macro\");\n+    }\n }\n \n /* Called from check_newline in c-parse.y.  The `buffer' parameter contains\n@@ -11316,6 +11342,13 @@ dwarf2out_undef (lineno, buffer)\n      register unsigned lineno ATTRIBUTE_UNUSED;\n      register const char *buffer ATTRIBUTE_UNUSED;\n {\n+  if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n+    {\n+      ASM_OUTPUT_SECTION (asm_out_file, DEBUG_MACINFO_SECTION);\n+      dw2_asm_output_data (1, DW_MACINFO_undef, \"Undefine macro\");\n+      dw2_asm_output_data_uleb128 (lineno, \"At line number %d\", lineno);\n+      dw2_asm_output_nstring (buffer, -1, \"The macro\");\n+    }\n }\n \n /* Set up for Dwarf output at the start of compilation.  */\n@@ -11398,6 +11431,13 @@ dwarf2out_init (asm_out_file, main_input_filename)\n   ASM_OUTPUT_LABEL (asm_out_file, debug_info_section_label);\n   ASM_OUTPUT_SECTION (asm_out_file, DEBUG_LINE_SECTION);\n   ASM_OUTPUT_LABEL (asm_out_file, debug_line_section_label);\n+  if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n+    {\n+      ASM_OUTPUT_SECTION (asm_out_file, DEBUG_MACINFO_SECTION);\n+      ASM_GENERATE_INTERNAL_LABEL (macinfo_section_label,\n+\t\t\t\t   DEBUG_MACINFO_SECTION_LABEL, 0);\n+      ASM_OUTPUT_LABEL (asm_out_file, macinfo_section_label);\n+    }\n }\n \n /* Output stuff that dwarf requires at the end of every file,\n@@ -11489,10 +11529,8 @@ dwarf2out_finish ()\n     add_AT_lbl_offset (comp_unit_die, DW_AT_stmt_list,\n \t\t       debug_line_section_label);\n \n-#if 0 /* unimplemented */\n-  if (debug_info_level >= DINFO_LEVEL_VERBOSE && primary)\n-    add_AT_unsigned (die, DW_AT_macro_info, 0);\n-#endif\n+  if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n+    add_AT_lbl_offset (comp_unit_die, DW_AT_macro_info, macinfo_section_label);\n \n   /* Output all of the compilation units.  We put the main one last so that\n      the offsets are available to output_pubnames.  */"}, {"sha": "6c657cbc20b27af0b46b2193124de7dcd80715c9", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "patch": "@@ -23,7 +23,7 @@ extern void dwarf2out_finish\t\tPARAMS ((void));\n \n extern void dwarf2out_define\t\tPARAMS ((unsigned, const char *));\n extern void dwarf2out_undef \t\tPARAMS ((unsigned, const char *));\n-extern void dwarf2out_start_source_file\tPARAMS ((const char *));\n+extern void dwarf2out_start_source_file\tPARAMS ((unsigned, const char *));\n extern void dwarf2out_end_source_file \tPARAMS ((void));\n \n extern void dwarf2out_begin_block\tPARAMS ((unsigned));"}, {"sha": "6a730858b319a6b5e679eb6e29626e4f7794f53a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "patch": "@@ -1,3 +1,8 @@\n+2001-07-04  Daniel Berlin  <dan@cgsoftware.com>\n+\n+\t* jcf-parse.c (parse_class_file): Add lineno parameter to\n+\tdebug_start_source_file call.\n+\n 2001-07-04  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcj.texi: Use gpl.texi."}, {"sha": "b4d5ba03aa77474d4b9885cc9931979fe5cae38e", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "patch": "@@ -773,7 +773,7 @@ parse_class_file ()\n \n   input_filename = DECL_SOURCE_FILE (TYPE_NAME (current_class));\n   lineno = 0;\n-  debug_start_source_file (input_filename);\n+  debug_start_source_file (lineno, input_filename);\n   init_outgoing_cpool ();\n \n   /* Currently we always have to emit calls to _Jv_InitClass when"}, {"sha": "94b830e99527417c01fbf18abc6d688feda036e5", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "patch": "@@ -4272,7 +4272,7 @@ static int\n decode_g_option (arg)\n      const char *arg;\n {\n-  unsigned level;\n+  static unsigned level=0;\n   /* A lot of code assumes write_symbols == NO_DEBUG if the\n      debugging level is 0 (thus -gstabs1 -gstabs0 would lose track\n      of what debugging type has been selected).  This records the\n@@ -4316,7 +4316,7 @@ decode_g_option (arg)\n \t  if (*p)\n \t    level = read_integral_parameter (p, 0, max_debug_level + 1);\n \t  else\n-\t    level = 2;\n+\t    level = (level == 0) ? 2 : level;\n \n \t  if (da_len > 1 && *p && !strncmp (arg, \"dwarf\", da_len))\n \t    {\n@@ -5177,7 +5177,8 @@ print_switch_values (file, pos, max, indent, sep, term)\n /* Record the beginning of a new source file, named FILENAME.  */\n \n void\n-debug_start_source_file (filename)\n+debug_start_source_file (lineno, filename)\n+     register unsigned int lineno ATTRIBUTE_UNUSED;\n      register const char *filename ATTRIBUTE_UNUSED;\n {\n #ifdef DBX_DEBUGGING_INFO\n@@ -5191,7 +5192,7 @@ debug_start_source_file (filename)\n #endif /* DWARF_DEBUGGING_INFO  */\n #ifdef DWARF2_DEBUGGING_INFO\n   if (write_symbols == DWARF2_DEBUG)\n-    dwarf2out_start_source_file (filename);\n+    dwarf2out_start_source_file (lineno, filename);\n #endif /* DWARF2_DEBUGGING_INFO  */\n #ifdef SDB_DEBUGGING_INFO\n   if (write_symbols == SDB_DEBUG)"}, {"sha": "a9ea1258bff32de430d8c77243e79127934982a7", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a5b4f858fc2aec5f871e606cdfef3dd4a15948/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=84a5b4f858fc2aec5f871e606cdfef3dd4a15948", "patch": "@@ -37,7 +37,7 @@ extern int read_integral_parameter\tPARAMS ((const char *, const char *,\n extern int count_error\t\t\tPARAMS ((int));\n extern void strip_off_ending\t\tPARAMS ((char *, int));\n extern void print_time\t\t\tPARAMS ((const char *, long));\n-extern void debug_start_source_file\tPARAMS ((const char *));\n+extern void debug_start_source_file\tPARAMS ((unsigned, const char *));\n extern void debug_end_source_file\tPARAMS ((unsigned));\n extern void debug_define\t\tPARAMS ((unsigned, const char *));\n extern void debug_undef\t\t\tPARAMS ((unsigned, const char *));"}]}