{"sha": "6144a8363cf4ced1145ae059466fbf6c8562c6d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE0NGE4MzYzY2Y0Y2VkMTE0NWFlMDU5NDY2ZmJmNmM4NTYyYzZkNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-26T17:42:13Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-26T17:42:13Z"}, "message": "insn_t becomes an rtx_insn *\n\ngcc/\n\t* sel-sched-ir.h (insn_t): Strengthen from rtx to rtx_insn *.\n\t(BND_TO): Delete this function and...\n\t(SET_BND_TO): ...this functions in favor of...\n\t(BND_TO): ...reinstating this macro.\n\t(struct _fence): Strengthen field \"executing_insns\" from\n\tvec<rtx, va_gc> * to vec<rtx_insn *, va_gc> *.  Strengthen fields\n\t\"last_scheduled_insn\" and \"sched_next\" from rtx to rtx_insn *.\n\t(_succ_iter_cond): Update param \"succp\" from rtx * to insn_t *\n\tand param \"insn\" from rtx to insn_t.\n\t(create_vinsn_from_insn_rtx): Strengthen first param from rtx to\n\trtx_insn *.\n\n\t* sched-int.h (insn_vec_t): Strengthen from vec<rtx> to\n\tvec<rtx_insn *> .\n\t(rtx_vec_t): Likewise.\n\t(struct sched_deps_info_def): Strengthen param of \"start_insn\"\n\tcallback from rtx to rtx_insn *.  Likewise for param \"insn2\" of\n\t\"note_mem_dep\" callback and first param of \"note_dep\" callback.\n\n\t* haifa-sched.c (add_to_speculative_block): Strengthen param\n\t\"insn\" from rtx to rtx_insn *.\n\t(clear_priorities): Likewise.\n\t(calc_priorities): Likewise for local \"insn\".\n\n\t* sched-deps.c (haifa_start_insn): Likewise for param \"insn\".\n\tRemove redundant checked cast.\n\t(haifa_note_mem_dep): Likewise for param \"pending_insn\".\n\t(haifa_note_dep): Likewise for param \"elem\".\n\t(note_mem_dep): Likewise for param \"e\".\n\t(sched_analyze_1): Add checked casts.\n\t(sched_analyze_2): Likewise.\n\n\t* sel-sched-dump.c (dump_insn_vector): Strengthen local \"succ\"\n\tfrom rtx to rtx_insn *.\n\t(debug): Update param from vec<rtx> & to vec<rtx_insn *>, and\n\tfrom vec<rtx> * to vec<rtx_insn *> *.\n\n\t* sel-sched-ir.c (blist_add): Remove use of SET_BND_TO\n\tscaffolding.\n\t(flist_add): Strengthen param \"executing_insns\" from\n\tvec<rtx, va_gc> * to vec<rtx_insn *, va_gc> *.\n\t(advance_deps_context): Remove now-redundant checked cast.\n\t(init_fences): Replace uses of NULL_RTX with NULL.\n\t(merge_fences): Strengthen params \"last_scheduled_insn\" and\n\t\"sched_next\" from rtx to rtx_insn * and \"executing_insns\" from\n\tvec<rtx, va_gc> * to vec<rtx_insn *, va_gc> *.\n\t(add_clean_fence_to_fences): Replace uses of NULL_RTX with NULL.\n\t(get_nop_from_pool): Add local \"nop_pat\" so that \"nop\" can be\n\tan instruction, rather than doing double-duty as a pattern.\n\t(return_nop_to_pool): Update for change of insn_t.\n\t(deps_init_id): Remove now-redundant checked cast.\n\t(struct sched_scan_info_def): Strengthen param of \"init_insn\"\n\tcallback from rtx to insn_t.\n\t(sched_scan): Strengthen local \"insn\" from rtx to rtx_insn *.\n\t(init_global_and_expr_for_insn): Replace uses of NULL_RTX with\n\tNULL.\n\t(get_seqno_by_succs): Strengthen param \"insn\" and locals \"tmp\",\n\t\"end\" from rtx to rtx_insn *.\n\t(create_vinsn_from_insn_rtx): Likewise for param \"insn_rtx\".\n\t(rtx insn_rtx, bool force_unique_p)\n\t(BND_TO): Delete function.\n\t(SET_BND_TO): Delete function.\n\n\t* sel-sched.c (advance_one_cycle): Strengthen local \"insn\" from\n\trtx to rtx_insn *.\n\t(extract_new_fences_from): Replace uses of NULL_RTX with NULL.\n\t(replace_dest_with_reg_in_expr): Strengthen local \"insn_rtx\" from\n\trtx to rtx_insn *.\n\t(undo_transformations): Likewise for param \"insn\".\n\t(update_liveness_on_insn): Likewise.\n\t(compute_live_below_insn): Likewise for param \"insn\" and local\n\t\"succ\".\n\t(update_data_sets): Likewise for param \"insn\".\n\t(fill_vec_av_set): Replace uses of NULL_RTX with NULL.\n\t(convert_vec_av_set_to_ready): Drop now-redundant checked cast.\n\t(invoke_aftermath_hooks): Strengthen param \"best_insn\" from rtx to\n\trtx_insn *.\n\t(move_cond_jump): Likewise for param \"insn\".\n\t(move_cond_jump): Drop use of SET_BND_TO.\n\t(compute_av_set_on_boundaries): Likewise.\n\t(update_fence_and_insn): Replace uses of NULL_RTX with NULL.\n\t(update_and_record_unavailable_insns): Strengthen local \"bb_end\"\n\tfrom rtx to rtx_insn *.\n\t(maybe_emit_renaming_copy): Likewise for param \"insn\".\n\t(maybe_emit_speculative_check): Likewise.\n\t(handle_emitting_transformations): Likewise.\n\t(remove_insn_from_stream): Likewise.\n\t(code_motion_process_successors): Strengthen local \"succ\" from rtx\n\tto insn_t.\n\n/\n\t* rtx-classes-status.txt (TODO): Remove SET_BND_TO.\n\nFrom-SVN: r214528", "tree": {"sha": "9babbe59771ad0a35d0d496cda114e8073c7978d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9babbe59771ad0a35d0d496cda114e8073c7978d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6144a8363cf4ced1145ae059466fbf6c8562c6d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6144a8363cf4ced1145ae059466fbf6c8562c6d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6144a8363cf4ced1145ae059466fbf6c8562c6d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6144a8363cf4ced1145ae059466fbf6c8562c6d5/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de8ea9631cf1709077dab89c903d713a1d5c9bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de8ea9631cf1709077dab89c903d713a1d5c9bd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de8ea9631cf1709077dab89c903d713a1d5c9bd7"}], "stats": {"total": 260, "additions": 175, "deletions": 85}, "files": [{"sha": "337c3a52d354e6654429b39ce7310f705240d91b", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6144a8363cf4ced1145ae059466fbf6c8562c6d5/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6144a8363cf4ced1145ae059466fbf6c8562c6d5/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=6144a8363cf4ced1145ae059466fbf6c8562c6d5", "patch": "@@ -1,3 +1,7 @@\n+2014-08-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* rtx-classes-status.txt (TODO): Remove SET_BND_TO.\n+\n 2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n \n \t* rtx-classes-status.txt (TODO): Remove SET_BB_NOTE_LIST."}, {"sha": "d315fac52dea6e0a1c08978960f729b39a56b251", "filename": "gcc/ChangeLog", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6144a8363cf4ced1145ae059466fbf6c8562c6d5", "patch": "@@ -1,3 +1,95 @@\n+2014-08-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* sel-sched-ir.h (insn_t): Strengthen from rtx to rtx_insn *.\n+\t(BND_TO): Delete this function and...\n+\t(SET_BND_TO): ...this functions in favor of...\n+\t(BND_TO): ...reinstating this macro.\n+\t(struct _fence): Strengthen field \"executing_insns\" from\n+\tvec<rtx, va_gc> * to vec<rtx_insn *, va_gc> *.  Strengthen fields\n+\t\"last_scheduled_insn\" and \"sched_next\" from rtx to rtx_insn *.\n+\t(_succ_iter_cond): Update param \"succp\" from rtx * to insn_t *\n+\tand param \"insn\" from rtx to insn_t.\n+\t(create_vinsn_from_insn_rtx): Strengthen first param from rtx to\n+\trtx_insn *.\n+\n+\t* sched-int.h (insn_vec_t): Strengthen from vec<rtx> to\n+\tvec<rtx_insn *> .\n+\t(rtx_vec_t): Likewise.\n+\t(struct sched_deps_info_def): Strengthen param of \"start_insn\"\n+\tcallback from rtx to rtx_insn *.  Likewise for param \"insn2\" of\n+\t\"note_mem_dep\" callback and first param of \"note_dep\" callback.\n+\n+\t* haifa-sched.c (add_to_speculative_block): Strengthen param\n+\t\"insn\" from rtx to rtx_insn *.\n+\t(clear_priorities): Likewise.\n+\t(calc_priorities): Likewise for local \"insn\".\n+\n+\t* sched-deps.c (haifa_start_insn): Likewise for param \"insn\".\n+\tRemove redundant checked cast.\n+\t(haifa_note_mem_dep): Likewise for param \"pending_insn\".\n+\t(haifa_note_dep): Likewise for param \"elem\".\n+\t(note_mem_dep): Likewise for param \"e\".\n+\t(sched_analyze_1): Add checked casts.\n+\t(sched_analyze_2): Likewise.\n+\n+\t* sel-sched-dump.c (dump_insn_vector): Strengthen local \"succ\"\n+\tfrom rtx to rtx_insn *.\n+\t(debug): Update param from vec<rtx> & to vec<rtx_insn *>, and\n+\tfrom vec<rtx> * to vec<rtx_insn *> *.\n+\n+\t* sel-sched-ir.c (blist_add): Remove use of SET_BND_TO\n+\tscaffolding.\n+\t(flist_add): Strengthen param \"executing_insns\" from\n+\tvec<rtx, va_gc> * to vec<rtx_insn *, va_gc> *.\n+\t(advance_deps_context): Remove now-redundant checked cast.\n+\t(init_fences): Replace uses of NULL_RTX with NULL.\n+\t(merge_fences): Strengthen params \"last_scheduled_insn\" and\n+\t\"sched_next\" from rtx to rtx_insn * and \"executing_insns\" from\n+\tvec<rtx, va_gc> * to vec<rtx_insn *, va_gc> *.\n+\t(add_clean_fence_to_fences): Replace uses of NULL_RTX with NULL.\n+\t(get_nop_from_pool): Add local \"nop_pat\" so that \"nop\" can be\n+\tan instruction, rather than doing double-duty as a pattern.\n+\t(return_nop_to_pool): Update for change of insn_t.\n+\t(deps_init_id): Remove now-redundant checked cast.\n+\t(struct sched_scan_info_def): Strengthen param of \"init_insn\"\n+\tcallback from rtx to insn_t.\n+\t(sched_scan): Strengthen local \"insn\" from rtx to rtx_insn *.\n+\t(init_global_and_expr_for_insn): Replace uses of NULL_RTX with\n+\tNULL.\n+\t(get_seqno_by_succs): Strengthen param \"insn\" and locals \"tmp\",\n+\t\"end\" from rtx to rtx_insn *.\n+\t(create_vinsn_from_insn_rtx): Likewise for param \"insn_rtx\".\n+\t(rtx insn_rtx, bool force_unique_p)\n+\t(BND_TO): Delete function.\n+\t(SET_BND_TO): Delete function.\n+\n+\t* sel-sched.c (advance_one_cycle): Strengthen local \"insn\" from\n+\trtx to rtx_insn *.\n+\t(extract_new_fences_from): Replace uses of NULL_RTX with NULL.\n+\t(replace_dest_with_reg_in_expr): Strengthen local \"insn_rtx\" from\n+\trtx to rtx_insn *.\n+\t(undo_transformations): Likewise for param \"insn\".\n+\t(update_liveness_on_insn): Likewise.\n+\t(compute_live_below_insn): Likewise for param \"insn\" and local\n+\t\"succ\".\n+\t(update_data_sets): Likewise for param \"insn\".\n+\t(fill_vec_av_set): Replace uses of NULL_RTX with NULL.\n+\t(convert_vec_av_set_to_ready): Drop now-redundant checked cast.\n+\t(invoke_aftermath_hooks): Strengthen param \"best_insn\" from rtx to\n+\trtx_insn *.\n+\t(move_cond_jump): Likewise for param \"insn\".\n+\t(move_cond_jump): Drop use of SET_BND_TO.\n+\t(compute_av_set_on_boundaries): Likewise.\n+\t(update_fence_and_insn): Replace uses of NULL_RTX with NULL.\n+\t(update_and_record_unavailable_insns): Strengthen local \"bb_end\"\n+\tfrom rtx to rtx_insn *.\n+\t(maybe_emit_renaming_copy): Likewise for param \"insn\".\n+\t(maybe_emit_speculative_check): Likewise.\n+\t(handle_emitting_transformations): Likewise.\n+\t(remove_insn_from_stream): Likewise.\n+\t(code_motion_process_successors): Strengthen local \"succ\" from rtx\n+\tto insn_t.\n+\n 2014-08-26  David Malcolm  <dmalcolm@redhat.com>\n \n \t* sel-sched-ir.h (ilist_t): Redefine this typedef in terms of"}, {"sha": "4ff2b78ee28a0acd7c75c8a41903f7331176dda8", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=6144a8363cf4ced1145ae059466fbf6c8562c6d5", "patch": "@@ -877,7 +877,7 @@ static int haifa_speculate_insn (rtx, ds_t, rtx *);\n static void generate_recovery_code (rtx_insn *);\n static void process_insn_forw_deps_be_in_spec (rtx, rtx, ds_t);\n static void begin_speculative_block (rtx_insn *);\n-static void add_to_speculative_block (rtx);\n+static void add_to_speculative_block (rtx_insn *);\n static void init_before_recovery (basic_block *);\n static void create_check_block_twin (rtx_insn *, bool);\n static void fix_recovery_deps (basic_block);\n@@ -888,7 +888,7 @@ static void fix_jump_move (rtx);\n static void move_block_after_check (rtx);\n static void move_succs (vec<edge, va_gc> **, basic_block);\n static void sched_remove_insn (rtx_insn *);\n-static void clear_priorities (rtx, rtx_vec_t *);\n+static void clear_priorities (rtx_insn *, rtx_vec_t *);\n static void calc_priorities (rtx_vec_t);\n static void add_jump_dependencies (rtx, rtx);\n \n@@ -7417,7 +7417,7 @@ static void haifa_init_insn (rtx);\n \n /* Generates recovery code for BE_IN speculative INSN.  */\n static void\n-add_to_speculative_block (rtx insn)\n+add_to_speculative_block (rtx_insn *insn)\n {\n   ds_t ts;\n   sd_iterator_def sd_it;\n@@ -8383,7 +8383,7 @@ sched_remove_insn (rtx_insn *insn)\n    Store in vector pointed to by ROOTS_PTR insns on which priority () should\n    be invoked to initialize all cleared priorities.  */\n static void\n-clear_priorities (rtx insn, rtx_vec_t *roots_ptr)\n+clear_priorities (rtx_insn *insn, rtx_vec_t *roots_ptr)\n {\n   sd_iterator_def sd_it;\n   dep_t dep;\n@@ -8419,7 +8419,7 @@ static void\n calc_priorities (rtx_vec_t roots)\n {\n   int i;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   FOR_EACH_VEC_ELT (roots, i, insn)\n     priority (insn);"}, {"sha": "58196f7282e0e6f8179bea70c4009a861342f7da", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=6144a8363cf4ced1145ae059466fbf6c8562c6d5", "patch": "@@ -1801,11 +1801,11 @@ static rtx_insn *cur_insn = NULL;\n /* Implement hooks for haifa scheduler.  */\n \n static void\n-haifa_start_insn (rtx insn)\n+haifa_start_insn (rtx_insn *insn)\n {\n   gcc_assert (insn && !cur_insn);\n \n-  cur_insn = as_a <rtx_insn *> (insn);\n+  cur_insn = insn;\n }\n \n static void\n@@ -1833,7 +1833,7 @@ haifa_note_reg_use (int regno)\n }\n \n static void\n-haifa_note_mem_dep (rtx mem, rtx pending_mem, rtx pending_insn, ds_t ds)\n+haifa_note_mem_dep (rtx mem, rtx pending_mem, rtx_insn *pending_insn, ds_t ds)\n {\n   if (!(ds & SPECULATIVE))\n     {\n@@ -1855,7 +1855,7 @@ haifa_note_mem_dep (rtx mem, rtx pending_mem, rtx pending_insn, ds_t ds)\n }\n \n static void\n-haifa_note_dep (rtx elem, ds_t ds)\n+haifa_note_dep (rtx_insn *elem, ds_t ds)\n {\n   dep_def _dep;\n   dep_t dep = &_dep;\n@@ -1888,7 +1888,7 @@ note_reg_clobber (int r)\n }\n \n static void\n-note_mem_dep (rtx m1, rtx m2, rtx e, ds_t ds)\n+note_mem_dep (rtx m1, rtx m2, rtx_insn *e, ds_t ds)\n {\n   if (sched_deps_info->note_mem_dep)\n     sched_deps_info->note_mem_dep (m1, m2, e, ds);\n@@ -2501,7 +2501,7 @@ sched_analyze_1 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t    {\n \t      if (anti_dependence (XEXP (pending_mem, 0), t)\n \t\t  && ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t\tnote_mem_dep (t, XEXP (pending_mem, 0), XEXP (pending, 0),\n+\t\tnote_mem_dep (t, XEXP (pending_mem, 0), as_a <rtx_insn *> (XEXP (pending, 0)),\n \t\t\t      DEP_ANTI);\n \n \t      pending = XEXP (pending, 1);\n@@ -2514,7 +2514,8 @@ sched_analyze_1 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t    {\n \t      if (output_dependence (XEXP (pending_mem, 0), t)\n \t\t  && ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t\tnote_mem_dep (t, XEXP (pending_mem, 0), XEXP (pending, 0),\n+\t\tnote_mem_dep (t, XEXP (pending_mem, 0),\n+\t\t\t      as_a <rtx_insn *> (XEXP (pending, 0)),\n \t\t\t      DEP_OUTPUT);\n \n \t      pending = XEXP (pending, 1);\n@@ -2646,7 +2647,8 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t\tif (read_dependence (XEXP (pending_mem, 0), t)\n \t\t    && ! sched_insns_conditions_mutex_p (insn,\n \t\t\t\t\t\t\t XEXP (pending, 0)))\n-\t\t  note_mem_dep (t, XEXP (pending_mem, 0), XEXP (pending, 0),\n+\t\t  note_mem_dep (t, XEXP (pending_mem, 0),\n+\t\t\t\tas_a <rtx_insn *> (XEXP (pending, 0)),\n \t\t\t\tDEP_ANTI);\n \n \t\tpending = XEXP (pending, 1);\n@@ -2660,7 +2662,8 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t\tif (true_dependence (XEXP (pending_mem, 0), VOIDmode, t)\n \t\t    && ! sched_insns_conditions_mutex_p (insn,\n \t\t\t\t\t\t\t XEXP (pending, 0)))\n-\t\t  note_mem_dep (t, XEXP (pending_mem, 0), XEXP (pending, 0),\n+\t\t  note_mem_dep (t, XEXP (pending_mem, 0),\n+\t\t\t\tas_a <rtx_insn *> (XEXP (pending, 0)),\n \t\t\t\tsched_deps_info->generate_spec_deps\n \t\t\t\t? BEGIN_DATA | DEP_TRUE : DEP_TRUE);\n "}, {"sha": "7ac0c8e20af3c334ab5a99b365fd6f23e89285f1", "filename": "gcc/sched-int.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=6144a8363cf4ced1145ae059466fbf6c8562c6d5", "patch": "@@ -41,8 +41,8 @@ enum sched_pressure_algorithm\n };\n \n typedef vec<basic_block> bb_vec_t;\n-typedef vec<rtx> insn_vec_t;\n-typedef vec<rtx> rtx_vec_t;\n+typedef vec<rtx_insn *> insn_vec_t;\n+typedef vec<rtx_insn *> rtx_vec_t;\n \n extern void sched_init_bbs (void);\n \n@@ -1241,7 +1241,7 @@ struct sched_deps_info_def\n   void (*compute_jump_reg_dependencies) (rtx, regset);\n \n   /* Start analyzing insn.  */\n-  void (*start_insn) (rtx);\n+  void (*start_insn) (rtx_insn *);\n \n   /* Finish analyzing insn.  */\n   void (*finish_insn) (void);\n@@ -1269,10 +1269,10 @@ struct sched_deps_info_def\n \n   /* Note memory dependence of type DS between MEM1 and MEM2 (which is\n      in the INSN2).  */\n-  void (*note_mem_dep) (rtx mem1, rtx mem2, rtx insn2, ds_t ds);\n+  void (*note_mem_dep) (rtx mem1, rtx mem2, rtx_insn *insn2, ds_t ds);\n \n   /* Note a dependence of type DS from the INSN.  */\n-  void (*note_dep) (rtx, ds_t ds);\n+  void (*note_dep) (rtx_insn *, ds_t ds);\n \n   /* Nonzero if we should use cselib for better alias analysis.  This\n      must be 0 if the dependency information is used after sched_analyze"}, {"sha": "d2169c8c6eace6fe45f68758b48fa6e66f734b1b", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=6144a8363cf4ced1145ae059466fbf6c8562c6d5", "patch": "@@ -534,7 +534,7 @@ void\n dump_insn_vector (rtx_vec_t succs)\n {\n   int i;\n-  rtx succ;\n+  rtx_insn *succ;\n \n   FOR_EACH_VEC_ELT (succs, i, succ)\n     if (succ)\n@@ -996,7 +996,7 @@ debug_blist (blist_t bnds)\n \n /* Dump a rtx vector REF.  */\n DEBUG_FUNCTION void\n-debug (vec<rtx> &ref)\n+debug (vec<rtx_insn *> &ref)\n {\n   switch_dump (stderr);\n   dump_insn_vector (ref);\n@@ -1005,7 +1005,7 @@ debug (vec<rtx> &ref)\n }\n \n DEBUG_FUNCTION void\n-debug (vec<rtx> *ptr)\n+debug (vec<rtx_insn *> *ptr)\n {\n   if (ptr)\n     debug (*ptr);"}, {"sha": "8d699160843fd2b76f2d4d907914ffdbab382d6a", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=6144a8363cf4ced1145ae059466fbf6c8562c6d5", "patch": "@@ -207,7 +207,7 @@ blist_add (blist_t *lp, insn_t to, ilist_t ptr, deps_t dc)\n   _list_add (lp);\n   bnd = BLIST_BND (*lp);\n \n-  SET_BND_TO (bnd) = to;\n+  BND_TO (bnd) = to;\n   BND_PTR (bnd) = ptr;\n   BND_AV (bnd) = NULL;\n   BND_AV1 (bnd) = NULL;\n@@ -262,7 +262,7 @@ init_fence_for_scheduling (fence_t f)\n /* Add new fence consisting of INSN and STATE to the list pointed to by LP.  */\n static void\n flist_add (flist_t *lp, insn_t insn, state_t state, deps_t dc, void *tc,\n-           insn_t last_scheduled_insn, vec<rtx, va_gc> *executing_insns,\n+           insn_t last_scheduled_insn, vec<rtx_insn *, va_gc> *executing_insns,\n            int *ready_ticks, int ready_ticks_size, insn_t sched_next,\n            int cycle, int cycle_issued_insns, int issue_more,\n            bool starts_cycle_p, bool after_stall_p)\n@@ -516,7 +516,7 @@ void\n advance_deps_context (deps_t dc, insn_t insn)\n {\n   sched_deps_info = &advance_deps_context_sched_deps_info;\n-  deps_analyze_insn (dc, as_a <rtx_insn *> (insn));\n+  deps_analyze_insn (dc, insn);\n }\n \f\n \n@@ -614,11 +614,11 @@ init_fences (insn_t old_fence)\n \t\t state_create (),\n \t\t create_deps_context () /* dc */,\n \t\t create_target_context (true) /* tc */,\n-\t\t NULL_RTX /* last_scheduled_insn */,\n+\t\t NULL /* last_scheduled_insn */,\n                  NULL, /* executing_insns */\n                  XCNEWVEC (int, ready_ticks_size), /* ready_ticks */\n                  ready_ticks_size,\n-                 NULL_RTX /* sched_next */,\n+                 NULL /* sched_next */,\n \t\t 1 /* cycle */, 0 /* cycle_issued_insns */,\n \t\t issue_rate, /* issue_more */\n \t\t 1 /* starts_cycle_p */, 0 /* after_stall_p */);\n@@ -637,7 +637,8 @@ init_fences (insn_t old_fence)\n static void\n merge_fences (fence_t f, insn_t insn,\n \t      state_t state, deps_t dc, void *tc,\n-              rtx last_scheduled_insn, vec<rtx, va_gc> *executing_insns,\n+              rtx_insn *last_scheduled_insn,\n+\t      vec<rtx_insn *, va_gc> *executing_insns,\n               int *ready_ticks, int ready_ticks_size,\n \t      rtx sched_next, int cycle, int issue_more, bool after_stall_p)\n {\n@@ -802,9 +803,10 @@ merge_fences (fence_t f, insn_t insn,\n    other parameters.  */\n static void\n add_to_fences (flist_tail_t new_fences, insn_t insn,\n-               state_t state, deps_t dc, void *tc, rtx last_scheduled_insn,\n-               vec<rtx, va_gc> *executing_insns, int *ready_ticks,\n-               int ready_ticks_size, rtx sched_next, int cycle,\n+               state_t state, deps_t dc, void *tc,\n+\t       rtx_insn *last_scheduled_insn,\n+               vec<rtx_insn *, va_gc> *executing_insns, int *ready_ticks,\n+               int ready_ticks_size, rtx_insn *sched_next, int cycle,\n                int cycle_issued_insns, int issue_rate,\n \t       bool starts_cycle_p, bool after_stall_p)\n {\n@@ -866,9 +868,9 @@ add_clean_fence_to_fences (flist_tail_t new_fences, insn_t succ, fence_t fence)\n   add_to_fences (new_fences,\n                  succ, state_create (), create_deps_context (),\n                  create_target_context (true),\n-                 NULL_RTX, NULL,\n+                 NULL, NULL,\n                  XCNEWVEC (int, ready_ticks_size), ready_ticks_size,\n-                 NULL_RTX, FENCE_CYCLE (fence) + 1,\n+                 NULL, FENCE_CYCLE (fence) + 1,\n                  0, issue_rate, 1, FENCE_AFTER_STALL_P (fence));\n }\n \n@@ -1036,16 +1038,17 @@ static vinsn_t nop_vinsn = NULL;\n insn_t\n get_nop_from_pool (insn_t insn)\n {\n+  rtx nop_pat;\n   insn_t nop;\n   bool old_p = nop_pool.n != 0;\n   int flags;\n \n   if (old_p)\n-    nop = nop_pool.v[--nop_pool.n];\n+    nop_pat = nop_pool.v[--nop_pool.n];\n   else\n-    nop = nop_pattern;\n+    nop_pat = nop_pattern;\n \n-  nop = emit_insn_before (nop, insn);\n+  nop = emit_insn_before (nop_pat, insn);\n \n   if (old_p)\n     flags = INSN_INIT_TODO_SSID;\n@@ -1069,7 +1072,7 @@ return_nop_to_pool (insn_t nop, bool full_tidying)\n   INSN_DELETED_P (nop) = 0;\n \n   if (nop_pool.n == nop_pool.s)\n-    nop_pool.v = XRESIZEVEC (rtx, nop_pool.v,\n+    nop_pool.v = XRESIZEVEC (rtx_insn *, nop_pool.v,\n                              (nop_pool.s = 2 * nop_pool.s + 1));\n   nop_pool.v[nop_pool.n++] = nop;\n }\n@@ -2748,7 +2751,7 @@ deps_init_id (idata_t id, insn_t insn, bool force_unique_p)\n \n   sched_deps_info = &deps_init_id_sched_deps_info;\n \n-  deps_analyze_insn (dc, as_a <rtx_insn *> (insn));\n+  deps_analyze_insn (dc, insn);\n \n   free_deps (dc);\n \n@@ -2774,7 +2777,7 @@ struct sched_scan_info_def\n \n   /* This hook makes scheduler frontend to initialize its internal data\n      structures for the passed insn.  */\n-  void (*init_insn) (rtx);\n+  void (*init_insn) (insn_t);\n };\n \n /* A driver function to add a set of basic blocks (BBS) to the\n@@ -2798,7 +2801,7 @@ sched_scan (const struct sched_scan_info_def *ssi, bb_vec_t bbs)\n   if (ssi->init_insn)\n     FOR_EACH_VEC_ELT (bbs, i, bb)\n       {\n-\trtx insn;\n+\trtx_insn *insn;\n \n \tFOR_BB_INSNS (bb, insn)\n \t  ssi->init_insn (insn);\n@@ -2937,7 +2940,7 @@ init_global_and_expr_for_insn (insn_t insn)\n \n   if (NOTE_INSN_BASIC_BLOCK_P (insn))\n     {\n-      init_global_data.prev_insn = NULL_RTX;\n+      init_global_data.prev_insn = NULL;\n       return;\n     }\n \n@@ -2954,7 +2957,7 @@ init_global_and_expr_for_insn (insn_t insn)\n       init_global_data.prev_insn = insn;\n     }\n   else\n-    init_global_data.prev_insn = NULL_RTX;\n+    init_global_data.prev_insn = NULL;\n \n   if (GET_CODE (PATTERN (insn)) == ASM_INPUT\n       || asm_noperands (PATTERN (insn)) >= 0)\n@@ -3978,10 +3981,10 @@ sel_luid_for_non_insn (rtx x)\n /*  Find the proper seqno for inserting at INSN by successors.\n     Return -1 if no successors with positive seqno exist.  */\n static int\n-get_seqno_by_succs (rtx insn)\n+get_seqno_by_succs (rtx_insn *insn)\n {\n   basic_block bb = BLOCK_FOR_INSN (insn);\n-  rtx tmp = insn, end = BB_END (bb);\n+  rtx_insn *tmp = insn, *end = BB_END (bb);\n   int seqno;\n   insn_t succ = NULL;\n   succ_iterator si;\n@@ -5756,7 +5759,7 @@ create_insn_rtx_from_pattern (rtx pattern, rtx label)\n /* Create a new vinsn for INSN_RTX.  FORCE_UNIQUE_P is true when the vinsn\n    must not be clonable.  */\n vinsn_t\n-create_vinsn_from_insn_rtx (rtx insn_rtx, bool force_unique_p)\n+create_vinsn_from_insn_rtx (rtx_insn *insn_rtx, bool force_unique_p)\n {\n   gcc_assert (INSN_P (insn_rtx) && !INSN_IN_STREAM_P (insn_rtx));\n \n@@ -6456,14 +6459,4 @@ rtx& SET_VINSN_INSN_RTX (vinsn_t vi)\n   return vi->insn_rtx;\n }\n \n-rtx_insn *BND_TO (bnd_t bnd)\n-{\n-  return safe_as_a <rtx_insn *> (bnd->to);\n-}\n-\n-insn_t& SET_BND_TO (bnd_t bnd)\n-{\n-  return bnd->to;\n-}\n-\n #endif"}, {"sha": "118e001a56f9e7bb2101afb95879fbb5f14cdfcc", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=6144a8363cf4ced1145ae059466fbf6c8562c6d5", "patch": "@@ -60,7 +60,7 @@ typedef _list_t _xlist_t;\n #define _XLIST_NEXT(L) (_LIST_NEXT (L))\n \n /* Instruction.  */\n-typedef rtx insn_t;\n+typedef rtx_insn *insn_t;\n \n /* List of insns.  */\n typedef _list_t ilist_t;\n@@ -233,8 +233,7 @@ struct _bnd\n   deps_t dc;\n };\n typedef struct _bnd *bnd_t;\n-extern rtx_insn *BND_TO (bnd_t bnd);\n-extern insn_t& SET_BND_TO (bnd_t bnd);\n+#define BND_TO(B) ((B)->to)\n \n /* PTR stands not for pointer as you might think, but as a Path To Root of the\n    current instruction group from boundary B.  */\n@@ -279,7 +278,7 @@ struct _fence\n   tc_t tc;\n \n   /* A vector of insns that are scheduled but not yet completed.  */\n-  vec<rtx, va_gc> *executing_insns;\n+  vec<rtx_insn *, va_gc> *executing_insns;\n \n   /* A vector indexed by UIDs that caches the earliest cycle on which\n      an insn can be scheduled on this fence.  */\n@@ -289,13 +288,13 @@ struct _fence\n   int ready_ticks_size;\n \n   /* Insn, which has been scheduled last on this fence.  */\n-  rtx last_scheduled_insn;\n+  rtx_insn *last_scheduled_insn;\n \n   /* The last value of can_issue_more variable on this fence.  */\n   int issue_more;\n \n   /* If non-NULL force the next scheduled insn to be SCHED_NEXT.  */\n-  rtx sched_next;\n+  rtx_insn *sched_next;\n \n   /* True if fill_insns processed this fence.  */\n   BOOL_BITFIELD processed_p : 1;\n@@ -1255,7 +1254,7 @@ _succ_iter_start (insn_t *succp, insn_t insn, int flags)\n }\n \n static inline bool\n-_succ_iter_cond (succ_iterator *ip, rtx *succp, rtx insn,\n+_succ_iter_cond (succ_iterator *ip, insn_t *succp, insn_t insn,\n                  bool check (edge, succ_iterator *))\n {\n   if (!ip->bb_end)\n@@ -1661,7 +1660,7 @@ extern void sel_unregister_cfg_hooks (void);\n \n /* Expression transformation routines.  */\n extern rtx_insn *create_insn_rtx_from_pattern (rtx, rtx);\n-extern vinsn_t create_vinsn_from_insn_rtx (rtx, bool);\n+extern vinsn_t create_vinsn_from_insn_rtx (rtx_insn *, bool);\n extern rtx_insn *create_copy_of_insn_rtx (rtx);\n extern void change_vinsn_in_expr (expr_t, vinsn_t);\n "}, {"sha": "7a8710043459356080802f2aa03fb38e0ddce40f", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6144a8363cf4ced1145ae059466fbf6c8562c6d5/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=6144a8363cf4ced1145ae059466fbf6c8562c6d5", "patch": "@@ -572,7 +572,7 @@ advance_one_cycle (fence_t fence)\n {\n   unsigned i;\n   int cycle;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   advance_state (FENCE_STATE (fence));\n   cycle = ++FENCE_CYCLE (fence);\n@@ -630,7 +630,7 @@ extract_new_fences_from (flist_t old_fences, flist_tail_t new_fences,\n \t\t\t int orig_max_seqno)\n {\n   bool was_here_p = false;\n-  insn_t insn = NULL_RTX;\n+  insn_t insn = NULL;\n   insn_t succ;\n   succ_iterator si;\n   ilist_iterator ii;\n@@ -965,7 +965,7 @@ create_insn_rtx_with_lhs (vinsn_t vi, rtx lhs_rtx)\n static void\n replace_dest_with_reg_in_expr (expr_t expr, rtx new_reg)\n {\n-  rtx insn_rtx;\n+  rtx_insn *insn_rtx;\n   vinsn_t vinsn;\n \n   insn_rtx = create_insn_rtx_with_lhs (EXPR_VINSN (expr), new_reg);\n@@ -1894,7 +1894,7 @@ identical_copy_p (rtx insn)\n /* Undo all transformations on *AV_PTR that were done when\n    moving through INSN.  */\n static void\n-undo_transformations (av_set_t *av_ptr, rtx insn)\n+undo_transformations (av_set_t *av_ptr, rtx_insn *insn)\n {\n   av_set_iterator av_iter;\n   expr_t expr;\n@@ -3189,17 +3189,17 @@ compute_live (insn_t insn)\n \n /* Update liveness sets for INSN.  */\n static inline void\n-update_liveness_on_insn (rtx insn)\n+update_liveness_on_insn (rtx_insn *insn)\n {\n   ignore_first = true;\n   compute_live (insn);\n }\n \n /* Compute liveness below INSN and write it into REGS.  */\n static inline void\n-compute_live_below_insn (rtx insn, regset regs)\n+compute_live_below_insn (rtx_insn *insn, regset regs)\n {\n-  rtx succ;\n+  rtx_insn *succ;\n   succ_iterator si;\n \n   FOR_EACH_SUCC_1 (succ, si, insn, SUCCS_ALL)\n@@ -3208,7 +3208,7 @@ compute_live_below_insn (rtx insn, regset regs)\n \n /* Update the data gathered in av and lv sets starting from INSN.  */\n static void\n-update_data_sets (rtx insn)\n+update_data_sets (rtx_insn *insn)\n {\n   update_liveness_on_insn (insn);\n   if (sel_bb_head_p (insn))\n@@ -3955,7 +3955,7 @@ fill_vec_av_set (av_set_t av, blist_t bnds, fence_t fence,\n   if (FENCE_SCHED_NEXT (fence))\n     {\n       gcc_assert (sched_next_worked == 1);\n-      FENCE_SCHED_NEXT (fence) = NULL_RTX;\n+      FENCE_SCHED_NEXT (fence) = NULL;\n     }\n \n   /* No need to stall if this variable was not initialized.  */\n@@ -4015,7 +4015,7 @@ convert_vec_av_set_to_ready (void)\n       insn_t insn = VINSN_INSN_RTX (vi);\n \n       ready_try[n] = 0;\n-      ready.vec[n] = as_a <rtx_insn *> (insn);\n+      ready.vec[n] = insn;\n     }\n }\n \n@@ -4281,7 +4281,7 @@ calculate_privileged_insns (void)\n    number is ISSUE_MORE.  FENCE and BEST_INSN are the current fence\n    and the insn chosen for scheduling, respectively.  */\n static int\n-invoke_aftermath_hooks (fence_t fence, rtx best_insn, int issue_more)\n+invoke_aftermath_hooks (fence_t fence, rtx_insn *best_insn, int issue_more)\n {\n   gcc_assert (INSN_P (best_insn));\n \n@@ -4922,7 +4922,7 @@ remove_insns_that_need_bookkeeping (fence_t fence, av_set_t *av_ptr)\n       ...\n */\n static void\n-move_cond_jump (rtx insn, bnd_t bnd)\n+move_cond_jump (rtx_insn *insn, bnd_t bnd)\n {\n   edge ft_edge;\n   basic_block block_from, block_next, block_new, block_bnd, bb;\n@@ -4955,7 +4955,7 @@ move_cond_jump (rtx insn, bnd_t bnd)\n \n   /* Jump is moved to the boundary.  */\n   next = PREV_INSN (insn);\n-  SET_BND_TO (bnd) = insn;\n+  BND_TO (bnd) = insn;\n \n   ft_edge = find_fallthru_edge_from (block_from);\n   block_next = ft_edge->dest;\n@@ -5096,7 +5096,7 @@ compute_av_set_on_boundaries (fence_t fence, blist_t bnds, av_set_t *av_vliw_p)\n \t{\n   \t  gcc_assert (FENCE_INSN (fence) == BND_TO (bnd));\n \t  FENCE_INSN (fence) = bnd_to;\n-\t  SET_BND_TO (bnd) = bnd_to;\n+\t  BND_TO (bnd) = bnd_to;\n \t}\n \n       av_set_clear (&BND_AV (bnd));\n@@ -5373,7 +5373,7 @@ update_fence_and_insn (fence_t fence, insn_t insn, int need_stall)\n       SCHED_GROUP_P (insn) = 0;\n     }\n   else\n-    FENCE_SCHED_NEXT (fence) = NULL_RTX;\n+    FENCE_SCHED_NEXT (fence) = NULL;\n   if (INSN_UID (insn) < FENCE_READY_TICKS_SIZE (fence))\n     FENCE_READY_TICKS (fence) [INSN_UID (insn)] = 0;\n \n@@ -5707,7 +5707,7 @@ update_and_record_unavailable_insns (basic_block book_block)\n   av_set_iterator i;\n   av_set_t old_av_set = NULL;\n   expr_t cur_expr;\n-  rtx bb_end = sel_bb_end (book_block);\n+  rtx_insn *bb_end = sel_bb_end (book_block);\n \n   /* First, get correct liveness in the bookkeeping block.  The problem is\n      the range between the bookeeping insn and the end of block.  */\n@@ -5875,7 +5875,7 @@ track_scheduled_insns_and_blocks (rtx insn)\n /* Emit a register-register copy for INSN if needed.  Return true if\n    emitted one.  PARAMS is the move_op static parameters.  */\n static bool\n-maybe_emit_renaming_copy (rtx insn,\n+maybe_emit_renaming_copy (rtx_insn *insn,\n                           moveop_static_params_p params)\n {\n   bool insn_emitted  = false;\n@@ -5915,7 +5915,7 @@ maybe_emit_renaming_copy (rtx insn,\n    Return true if we've  emitted one.  PARAMS is the move_op static\n    parameters.  */\n static bool\n-maybe_emit_speculative_check (rtx insn, expr_t expr,\n+maybe_emit_speculative_check (rtx_insn *insn, expr_t expr,\n                               moveop_static_params_p params)\n {\n   bool insn_emitted = false;\n@@ -5944,7 +5944,7 @@ maybe_emit_speculative_check (rtx insn, expr_t expr,\n    insn such as renaming/speculation.  Return true if one of such\n    transformations actually happened, and we have emitted this insn.  */\n static bool\n-handle_emitting_transformations (rtx insn, expr_t expr,\n+handle_emitting_transformations (rtx_insn *insn, expr_t expr,\n                                  moveop_static_params_p params)\n {\n   bool insn_emitted = false;\n@@ -6003,7 +6003,7 @@ need_nop_to_preserve_insn_bb (rtx insn)\n /* Remove INSN from stream.  When ONLY_DISCONNECT is true, its data\n    is not removed but reused when INSN is re-emitted.  */\n static void\n-remove_insn_from_stream (rtx insn, bool only_disconnect)\n+remove_insn_from_stream (rtx_insn *insn, bool only_disconnect)\n {\n   /* If there's only one insn in the BB, make sure that a nop is\n      inserted into it, so the basic block won't disappear when we'll\n@@ -6351,7 +6351,7 @@ code_motion_process_successors (insn_t insn, av_set_t orig_ops,\n {\n   int res = 0;\n   succ_iterator succ_i;\n-  rtx succ;\n+  insn_t succ;\n   basic_block bb;\n   int old_index;\n   unsigned old_succs;"}, {"sha": "e44e115aaa8a0b69dff3b87525cfe12cd152399e", "filename": "rtx-classes-status.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6144a8363cf4ced1145ae059466fbf6c8562c6d5/rtx-classes-status.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6144a8363cf4ced1145ae059466fbf6c8562c6d5/rtx-classes-status.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/rtx-classes-status.txt?ref=6144a8363cf4ced1145ae059466fbf6c8562c6d5", "patch": "@@ -16,7 +16,6 @@ TODO: \"Scaffolding\" to be removed\n =================================\n * DF_REF_INSN\n * SET_BB_HEAD, SET_BB_END, SET_BB_HEADER\n-* SET_BND_TO\n * SET_DEP_PRO, SET_DEP_CON\n * SET_NEXT_INSN, SET_PREV_INSN\n * SET_VINSN_INSN_RTX"}]}