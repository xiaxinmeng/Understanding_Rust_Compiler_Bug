{"sha": "bc9587eb19f6407f5815d46d68325890e29f076a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM5NTg3ZWIxOWY2NDA3ZjU4MTVkNDZkNjgzMjU4OTBlMjlmMDc2YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:47:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:47:19Z"}, "message": "Split out gather load mask building\n\nThis patch splits out the code to build an all-bits-one or all-bits-zero\ninput to a gather load.  The catch is that both masks can have\nfloating-point type, in which case they are implicitly treated in\nthe same way as an integer bitmask.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vect-stmts.c (vect_build_all_ones_mask)\n\t(vect_build_zero_merge_argument): New functions, split out from...\n\t(vectorizable_load): ...here.\n\nFrom-SVN: r256214", "tree": {"sha": "dd930059b01533978ba691e01387b8dccee4e47f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd930059b01533978ba691e01387b8dccee4e47f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc9587eb19f6407f5815d46d68325890e29f076a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9587eb19f6407f5815d46d68325890e29f076a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc9587eb19f6407f5815d46d68325890e29f076a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9587eb19f6407f5815d46d68325890e29f076a/comments", "author": null, "committer": null, "parents": [{"sha": "3133c3b628da0e39a3ae9cdbd4973de04b214589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3133c3b628da0e39a3ae9cdbd4973de04b214589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3133c3b628da0e39a3ae9cdbd4973de04b214589"}], "stats": {"total": 99, "additions": 61, "deletions": 38}, "files": [{"sha": "8083abca82eb5b69dba06fd64325e806fcec3c73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9587eb19f6407f5815d46d68325890e29f076a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9587eb19f6407f5815d46d68325890e29f076a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc9587eb19f6407f5815d46d68325890e29f076a", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vect-stmts.c (vect_build_all_ones_mask)\n+\t(vect_build_zero_merge_argument): New functions, split out from...\n+\t(vectorizable_load): ...here.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vect-stmts.c (vect_check_store_rhs): New function,"}, {"sha": "c66b650ecdc88c995428366e009acf3a0639572f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 55, "deletions": 38, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9587eb19f6407f5815d46d68325890e29f076a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9587eb19f6407f5815d46d68325890e29f076a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=bc9587eb19f6407f5815d46d68325890e29f076a", "patch": "@@ -2141,6 +2141,59 @@ vect_check_store_rhs (gimple *stmt, tree rhs, tree *rhs_vectype_out,\n   return true;\n }\n \n+/* Build an all-ones vector mask of type MASKTYPE while vectorizing STMT.\n+   Note that we support masks with floating-point type, in which case the\n+   floats are interpreted as a bitmask.  */\n+\n+static tree\n+vect_build_all_ones_mask (gimple *stmt, tree masktype)\n+{\n+  if (TREE_CODE (masktype) == INTEGER_TYPE)\n+    return build_int_cst (masktype, -1);\n+  else if (TREE_CODE (TREE_TYPE (masktype)) == INTEGER_TYPE)\n+    {\n+      tree mask = build_int_cst (TREE_TYPE (masktype), -1);\n+      mask = build_vector_from_val (masktype, mask);\n+      return vect_init_vector (stmt, mask, masktype, NULL);\n+    }\n+  else if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (masktype)))\n+    {\n+      REAL_VALUE_TYPE r;\n+      long tmp[6];\n+      for (int j = 0; j < 6; ++j)\n+\ttmp[j] = -1;\n+      real_from_target (&r, tmp, TYPE_MODE (TREE_TYPE (masktype)));\n+      tree mask = build_real (TREE_TYPE (masktype), r);\n+      mask = build_vector_from_val (masktype, mask);\n+      return vect_init_vector (stmt, mask, masktype, NULL);\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Build an all-zero merge value of type VECTYPE while vectorizing\n+   STMT as a gather load.  */\n+\n+static tree\n+vect_build_zero_merge_argument (gimple *stmt, tree vectype)\n+{\n+  tree merge;\n+  if (TREE_CODE (TREE_TYPE (vectype)) == INTEGER_TYPE)\n+    merge = build_int_cst (TREE_TYPE (vectype), 0);\n+  else if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (vectype)))\n+    {\n+      REAL_VALUE_TYPE r;\n+      long tmp[6];\n+      for (int j = 0; j < 6; ++j)\n+\ttmp[j] = 0;\n+      real_from_target (&r, tmp, TYPE_MODE (TREE_TYPE (vectype)));\n+      merge = build_real (TREE_TYPE (vectype), r);\n+    }\n+  else\n+    gcc_unreachable ();\n+  merge = build_vector_from_val (vectype, merge);\n+  return vect_init_vector (stmt, merge, vectype, NULL);\n+}\n+\n /* Function vectorizable_mask_load_store.\n \n    Check if STMT performs a conditional load or store that can be vectorized.\n@@ -7011,45 +7064,9 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       /* Currently we support only unconditional gather loads,\n \t so mask should be all ones.  */\n-      if (TREE_CODE (masktype) == INTEGER_TYPE)\n-\tmask = build_int_cst (masktype, -1);\n-      else if (TREE_CODE (TREE_TYPE (masktype)) == INTEGER_TYPE)\n-\t{\n-\t  mask = build_int_cst (TREE_TYPE (masktype), -1);\n-\t  mask = build_vector_from_val (masktype, mask);\n-\t  mask = vect_init_vector (stmt, mask, masktype, NULL);\n-\t}\n-      else if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (masktype)))\n-\t{\n-\t  REAL_VALUE_TYPE r;\n-\t  long tmp[6];\n-\t  for (j = 0; j < 6; ++j)\n-\t    tmp[j] = -1;\n-\t  real_from_target (&r, tmp, TYPE_MODE (TREE_TYPE (masktype)));\n-\t  mask = build_real (TREE_TYPE (masktype), r);\n-\t  mask = build_vector_from_val (masktype, mask);\n-\t  mask = vect_init_vector (stmt, mask, masktype, NULL);\n-\t}\n-      else\n-\tgcc_unreachable ();\n-\n+      mask = vect_build_all_ones_mask (stmt, masktype);\n       scale = build_int_cst (scaletype, gs_info.scale);\n-\n-      if (TREE_CODE (TREE_TYPE (rettype)) == INTEGER_TYPE)\n-\tmerge = build_int_cst (TREE_TYPE (rettype), 0);\n-      else if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (rettype)))\n-\t{\n-\t  REAL_VALUE_TYPE r;\n-\t  long tmp[6];\n-\t  for (j = 0; j < 6; ++j)\n-\t    tmp[j] = 0;\n-\t  real_from_target (&r, tmp, TYPE_MODE (TREE_TYPE (rettype)));\n-\t  merge = build_real (TREE_TYPE (rettype), r);\n-\t}\n-      else\n-\tgcc_unreachable ();\n-      merge = build_vector_from_val (rettype, merge);\n-      merge = vect_init_vector (stmt, merge, rettype, NULL);\n+      merge = vect_build_zero_merge_argument (stmt, rettype);\n \n       prev_stmt_info = NULL;\n       for (j = 0; j < ncopies; ++j)"}]}