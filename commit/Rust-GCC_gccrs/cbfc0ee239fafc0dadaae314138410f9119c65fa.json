{"sha": "cbfc0ee239fafc0dadaae314138410f9119c65fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JmYzBlZTIzOWZhZmMwZGFkYWFlMzE0MTM4NDEwZjkxMTljNjVmYQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-22T13:33:23Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-22T13:56:27Z"}, "message": "This allows for query based compilation\n\nRust can forward declare items to avoid the need for prototypes for\nexample. This means when a path resolved to a node we must look it up\nand see if it is already compiled or go and compiler it. This also applies\nto generics which are monomorphized and might have already been compiled.\n\nThis adds two new keyword arguments bool query_mode and ref_locus, these\nsay to the classes that this is query based mode and ICE when we get\nerror_mark_node when we fail to compile something. This will need to be\nchanged once we get to a certain level of maturity but this helps\ndiagnose bugs for now. The ref_locus refers to the location of the\nreference to this item such that the compilation of an item can give us\na reference expression to this item with this ref_locus. For example:\n\n  call (123)\n\nAnd call is query compiled and the ref_locus is this call_expression.", "tree": {"sha": "3b8d92a090ee0665df75c9b4e7c197d692e2d951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b8d92a090ee0665df75c9b4e7c197d692e2d951"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbfc0ee239fafc0dadaae314138410f9119c65fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbfc0ee239fafc0dadaae314138410f9119c65fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbfc0ee239fafc0dadaae314138410f9119c65fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbfc0ee239fafc0dadaae314138410f9119c65fa/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79092784f20b99f26da847d2b921d3ea1ffc1a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79092784f20b99f26da847d2b921d3ea1ffc1a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79092784f20b99f26da847d2b921d3ea1ffc1a24"}], "stats": {"total": 287, "additions": 184, "deletions": 103}, "files": [{"sha": "bdeda2200f50b31a7e11047df875bed9ea850f77", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 85, "deletions": 13, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbfc0ee239fafc0dadaae314138410f9119c65fa/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbfc0ee239fafc0dadaae314138410f9119c65fa/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=cbfc0ee239fafc0dadaae314138410f9119c65fa", "patch": "@@ -34,11 +34,25 @@ class CompileInherentImplItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static void Compile (TyTy::BaseType *self, HIR::ImplItem *item, Context *ctx,\n-\t\t       bool compile_fns, TyTy::BaseType *concrete = nullptr)\n+  static Bexpression *Compile (TyTy::BaseType *self, HIR::ImplItem *item,\n+\t\t\t       Context *ctx, bool compile_fns,\n+\t\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t\t       bool is_query_mode = false,\n+\t\t\t       Location ref_locus = Location ())\n   {\n-    CompileInherentImplItem compiler (self, ctx, compile_fns, concrete);\n+    CompileInherentImplItem compiler (self, ctx, compile_fns, concrete,\n+\t\t\t\t      ref_locus);\n     item->accept_vis (compiler);\n+\n+    if (is_query_mode\n+\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+      {\n+\trust_error_at (ref_locus, \"failed to compile impl item: %s\",\n+\t\t       item->as_string ().c_str ());\n+\trust_assert (\n+\t  !ctx->get_backend ()->is_error_expression (compiler.reference));\n+      }\n+    return compiler.reference;\n   }\n \n   void visit (HIR::ConstantItem &constant) override\n@@ -63,6 +77,8 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     ctx->push_const (const_expr);\n     ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+\n+    reference = const_expr;\n   }\n \n   void visit (HIR::Function &function) override\n@@ -104,8 +120,13 @@ class CompileInherentImplItem : public HIRCompileBase\n \t  {\n \t    Bfunction *dummy = nullptr;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n-\n+\t      {\n+\t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n+\t\t\t\t\t   fntype);\n+\t      }\n+\t    reference\n+\t      = ctx->get_backend ()->function_code_expression (lookup,\n+\t\t\t\t\t\t\t       ref_locus);\n \t    return;\n \t  }\n       }\n@@ -281,32 +302,73 @@ class CompileInherentImplItem : public HIRCompileBase\n       }\n \n     ctx->pop_fn ();\n-\n     ctx->push_function (fndecl);\n+\n+    reference\n+      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n   }\n \n private:\n   CompileInherentImplItem (TyTy::BaseType *self, Context *ctx, bool compile_fns,\n-\t\t\t   TyTy::BaseType *concrete)\n+\t\t\t   TyTy::BaseType *concrete, Location ref_locus)\n     : HIRCompileBase (ctx), self (self), compile_fns (compile_fns),\n-      concrete (concrete)\n+      concrete (concrete), reference (ctx->get_backend ()->error_expression ()),\n+      ref_locus (ref_locus)\n   {}\n \n   TyTy::BaseType *self;\n   bool compile_fns;\n   TyTy::BaseType *concrete;\n+  Bexpression *reference;\n+  Location ref_locus;\n };\n \n class CompileTraitItem : public HIRCompileBase\n {\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static void Compile (TyTy::BaseType *self, HIR::TraitItem *item, Context *ctx,\n-\t\t       TyTy::BaseType *concrete)\n+  static Bexpression *Compile (TyTy::BaseType *self, HIR::TraitItem *item,\n+\t\t\t       Context *ctx, TyTy::BaseType *concrete,\n+\t\t\t       bool is_query_mode = false,\n+\t\t\t       Location ref_locus = Location ())\n   {\n-    CompileTraitItem compiler (self, ctx, concrete);\n+    CompileTraitItem compiler (self, ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n+\n+    if (is_query_mode\n+\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+      {\n+\trust_error_at (ref_locus, \"failed to compile trait item: %s\",\n+\t\t       item->as_string ().c_str ());\n+\trust_assert (\n+\t  !ctx->get_backend ()->is_error_expression (compiler.reference));\n+      }\n+    return compiler.reference;\n+  }\n+\n+  void visit (HIR::TraitItemConst &constant) override\n+  {\n+    rust_assert (concrete != nullptr);\n+    TyTy::BaseType *resolved_type = concrete;\n+\n+    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    Bexpression *value\n+      = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n+\n+    const Resolver::CanonicalPath *canonical_path = nullptr;\n+    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+      constant.get_mappings ().get_crate_num (),\n+      constant.get_mappings ().get_nodeid (), &canonical_path));\n+\n+    std::string ident = canonical_path->get ();\n+    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n+      type, constant.get_name (), value, constant.get_locus ());\n+\n+    ctx->push_const (const_expr);\n+    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+\n+    reference = const_expr;\n   }\n \n   void visit (HIR::TraitItemFunc &func) override\n@@ -330,6 +392,9 @@ class CompileTraitItem : public HIRCompileBase\n \t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n \t\t\t\t\t   fntype);\n \t      }\n+\t    reference\n+\t      = ctx->get_backend ()->function_code_expression (lookup,\n+\t\t\t\t\t\t\t       ref_locus);\n \t    return;\n \t  }\n       }\n@@ -499,16 +564,23 @@ class CompileTraitItem : public HIRCompileBase\n \n     ctx->pop_fn ();\n     ctx->push_function (fndecl);\n+\n+    reference\n+      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n   }\n \n private:\n   CompileTraitItem (TyTy::BaseType *self, Context *ctx,\n-\t\t    TyTy::BaseType *concrete)\n-    : HIRCompileBase (ctx), self (self), concrete (concrete)\n+\t\t    TyTy::BaseType *concrete, Location ref_locus)\n+    : HIRCompileBase (ctx), self (self), concrete (concrete),\n+      reference (ctx->get_backend ()->error_expression ()),\n+      ref_locus (ref_locus)\n   {}\n \n   TyTy::BaseType *self;\n   TyTy::BaseType *concrete;\n+  Bexpression *reference;\n+  Location ref_locus;\n };\n \n } // namespace Compile"}, {"sha": "eb7d9eff79dd1c12480b7752ddb7acb11994356e", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbfc0ee239fafc0dadaae314138410f9119c65fa/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbfc0ee239fafc0dadaae314138410f9119c65fa/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=cbfc0ee239fafc0dadaae314138410f9119c65fa", "patch": "@@ -33,14 +33,28 @@ namespace Compile {\n \n class CompileItem : public HIRCompileBase\n {\n+protected:\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static void compile (HIR::Item *item, Context *ctx, bool compile_fns = true,\n-\t\t       TyTy::BaseType *concrete = nullptr)\n+  static Bexpression *compile (HIR::Item *item, Context *ctx,\n+\t\t\t       bool compile_fns = true,\n+\t\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t\t       bool is_query_mode = false,\n+\t\t\t       Location ref_locus = Location ())\n   {\n-    CompileItem compiler (ctx, compile_fns, concrete);\n+    CompileItem compiler (ctx, compile_fns, concrete, ref_locus);\n     item->accept_vis (compiler);\n+\n+    if (is_query_mode\n+\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+      {\n+\trust_error_at (ref_locus, \"failed to compile item: %s\",\n+\t\t       item->as_string ().c_str ());\n+\trust_assert (\n+\t  !ctx->get_backend ()->is_error_expression (compiler.reference));\n+      }\n+    return compiler.reference;\n   }\n \n   void visit (HIR::StaticItem &var) override\n@@ -73,6 +87,8 @@ class CompileItem : public HIRCompileBase\n \n     ctx->insert_var_decl (var.get_mappings ().get_hirid (), static_global);\n     ctx->push_var (static_global);\n+\n+    reference = ctx->get_backend ()->var_expression (static_global, ref_locus);\n   }\n \n   void visit (HIR::ConstantItem &constant) override\n@@ -98,6 +114,8 @@ class CompileItem : public HIRCompileBase\n \n     ctx->push_const (const_expr);\n     ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+\n+    reference = const_expr;\n   }\n \n   void visit (HIR::Function &function) override\n@@ -139,8 +157,14 @@ class CompileItem : public HIRCompileBase\n \t  {\n \t    Bfunction *dummy = nullptr;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n-\n+\t      {\n+\t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n+\t\t\t\t\t   fntype);\n+\t      }\n+\n+\t    reference\n+\t      = ctx->get_backend ()->function_code_expression (lookup,\n+\t\t\t\t\t\t\t       ref_locus);\n \t    return;\n \t  }\n       }\n@@ -287,6 +311,9 @@ class CompileItem : public HIRCompileBase\n \n     ctx->pop_fn ();\n     ctx->push_function (fndecl);\n+\n+    reference\n+      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n   }\n \n   void visit (HIR::ImplBlock &impl_block) override\n@@ -319,13 +346,18 @@ class CompileItem : public HIRCompileBase\n       CompileItem::compile (item.get (), ctx, compile_fns);\n   }\n \n-private:\n-  CompileItem (Context *ctx, bool compile_fns, TyTy::BaseType *concrete)\n-    : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete)\n+protected:\n+  CompileItem (Context *ctx, bool compile_fns, TyTy::BaseType *concrete,\n+\t       Location ref_locus)\n+    : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete),\n+      reference (ctx->get_backend ()->error_expression ()),\n+      ref_locus (ref_locus)\n   {}\n \n   bool compile_fns;\n   TyTy::BaseType *concrete;\n+  Bexpression *reference;\n+  Location ref_locus;\n };\n \n } // namespace Compile"}, {"sha": "98c04dfe37920dcd0b61c052316eb8fdbf710aee", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 51, "deletions": 73, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbfc0ee239fafc0dadaae314138410f9119c65fa/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbfc0ee239fafc0dadaae314138410f9119c65fa/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=cbfc0ee239fafc0dadaae314138410f9119c65fa", "patch": "@@ -29,18 +29,18 @@ namespace Compile {\n void\n ResolvePathRef::visit (HIR::QualifiedPathInExpression &expr)\n {\n-  resolve (expr.get_final_segment ().get_segment (), expr.get_mappings (),\n-\t   expr.get_locus (), true);\n+  resolved = resolve (expr.get_final_segment ().get_segment (),\n+\t\t      expr.get_mappings (), expr.get_locus (), true);\n }\n \n void\n ResolvePathRef::visit (HIR::PathInExpression &expr)\n {\n-  resolve (expr.get_final_segment ().get_segment (), expr.get_mappings (),\n-\t   expr.get_locus (), false);\n+  resolved = resolve (expr.get_final_segment ().get_segment (),\n+\t\t      expr.get_mappings (), expr.get_locus (), false);\n }\n \n-void\n+Bexpression *\n ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\t const Analysis::NodeMapping &mappings,\n \t\t\t Location expr_locus, bool is_qualified_path)\n@@ -54,89 +54,73 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n \t{\n \t  rust_error_at (expr_locus, \"unknown reference for resolved name\");\n-\t  return;\n+\t  return ctx->get_backend ()->error_expression ();\n \t}\n       ref_node_id = def.parent;\n     }\n \n   // this can fail because it might be a Constructor for something\n   // in that case the caller should attempt ResolvePathType::Compile\n   if (ref_node_id == UNKNOWN_NODEID)\n-    return;\n+    {\n+      rust_error_at (expr_locus, \"unknown nodeid for path expr\");\n+      return ctx->get_backend ()->error_expression ();\n+    }\n \n   HirId ref;\n   if (!ctx->get_mappings ()->lookup_node_to_hir (mappings.get_crate_num (),\n \t\t\t\t\t\t ref_node_id, &ref))\n     {\n       rust_error_at (expr_locus, \"reverse call path lookup failure\");\n-      return;\n+      return ctx->get_backend ()->error_expression ();\n     }\n \n   // might be a constant\n-  if (ctx->lookup_const_decl (ref, &resolved))\n-    return;\n+  Bexpression *constant_expr;\n+  if (ctx->lookup_const_decl (ref, &constant_expr))\n+    return constant_expr;\n \n   // this might be a variable reference or a function reference\n   Bvariable *var = nullptr;\n   if (ctx->lookup_var_decl (ref, &var))\n-    {\n-      resolved = ctx->get_backend ()->var_expression (var, expr_locus);\n-      return;\n-    }\n+    return ctx->get_backend ()->var_expression (var, expr_locus);\n \n-  // must be a function call but it might be a generic function which needs to\n-  // be compiled first\n+  // it might be a function call\n   TyTy::BaseType *lookup = nullptr;\n   bool ok = ctx->get_tyctx ()->lookup_type (mappings.get_hirid (), &lookup);\n   rust_assert (ok);\n   if (lookup->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-\n       Bfunction *fn = nullptr;\n       if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n-\t  resolved\n-\t    = ctx->get_backend ()->function_code_expression (fn, expr_locus);\n-\t}\n-      else\n-\t{\n-\t  resolved\n-\t    = query_compile_function (ref, fntype, final_segment, mappings,\n-\t\t\t\t      expr_locus, is_qualified_path);\n+\t  return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n \t}\n     }\n-  else\n-    {\n-      HIR::Item *resolved_item\n-\t= ctx->get_mappings ()->lookup_hir_item (mappings.get_crate_num (),\n-\t\t\t\t\t\t ref);\n-      HirId parent_impl_id = UNKNOWN_HIRID;\n-      HIR::ImplItem *resolved_impl_item\n-\t= ctx->get_mappings ()->lookup_hir_implitem (mappings.get_crate_num (),\n-\t\t\t\t\t\t     ref, &parent_impl_id);\n-      bool is_impl_item = resolved_impl_item != nullptr;\n-      bool is_item = resolved_item != nullptr;\n \n-      gcc_unreachable ();\n-    }\n+  // let the query system figure it out\n+  return query_compile (ref, lookup, final_segment, mappings, expr_locus,\n+\t\t\tis_qualified_path);\n }\n \n Bexpression *\n-ResolvePathRef::query_compile_function (\n-  HirId ref, TyTy::FnType *fntype, const HIR::PathIdentSegment &final_segment,\n-  const Analysis::NodeMapping &mappings, Location expr_locus,\n-  bool is_qualified_path)\n+ResolvePathRef::query_compile (HirId ref, TyTy::BaseType *lookup,\n+\t\t\t       const HIR::PathIdentSegment &final_segment,\n+\t\t\t       const Analysis::NodeMapping &mappings,\n+\t\t\t       Location expr_locus, bool is_qualified_path)\n {\n   HIR::Item *resolved_item\n     = ctx->get_mappings ()->lookup_hir_item (mappings.get_crate_num (), ref);\n   bool is_hir_item = resolved_item != nullptr;\n   if (is_hir_item)\n     {\n-      if (!fntype->has_subsititions_defined ())\n-\tCompileItem::compile (resolved_item, ctx);\n+      if (!lookup->has_subsititions_defined ())\n+\treturn CompileItem::compile (resolved_item, ctx, true, nullptr, true,\n+\t\t\t\t     expr_locus);\n       else\n-\tCompileItem::compile (resolved_item, ctx, true, fntype);\n+\treturn CompileItem::compile (resolved_item, ctx, true, lookup, true,\n+\t\t\t\t     expr_locus);\n     }\n   else\n     {\n@@ -159,11 +143,14 @@ ResolvePathRef::query_compile_function (\n \t    impl->get_type ()->get_mappings ().get_hirid (), &self);\n \t  rust_assert (ok);\n \n-\t  if (!fntype->has_subsititions_defined ())\n-\t    CompileInherentImplItem::Compile (self, resolved_item, ctx, true);\n+\t  if (!lookup->has_subsititions_defined ())\n+\t    return CompileInherentImplItem::Compile (self, resolved_item, ctx,\n+\t\t\t\t\t\t     true, nullptr, true,\n+\t\t\t\t\t\t     expr_locus);\n \t  else\n-\t    CompileInherentImplItem::Compile (self, resolved_item, ctx, true,\n-\t\t\t\t\t      fntype);\n+\t    return CompileInherentImplItem::Compile (self, resolved_item, ctx,\n+\t\t\t\t\t\t     true, lookup, true,\n+\t\t\t\t\t\t     expr_locus);\n \t}\n       else\n \t{\n@@ -195,14 +182,9 @@ ResolvePathRef::query_compile_function (\n \t  // item so its up to us to figure out if this path should resolve\n \t  // to an trait-impl-block-item or if it can be defaulted to the\n \t  // trait-impl-item's definition\n-\t  std::vector<Resolver::PathProbeCandidate> candidates;\n-\t  if (!is_qualified_path)\n-\t    {\n-\t      candidates\n-\t\t= Resolver::PathProbeType::Probe (receiver, final_segment, true,\n-\t\t\t\t\t\t  false, true);\n-\t    }\n-\n+\t  std::vector<Resolver::PathProbeCandidate> candidates\n+\t    = Resolver::PathProbeImplTrait::Probe (receiver, final_segment,\n+\t\t\t\t\t\t   trait_ref);\n \t  if (candidates.size () == 0)\n \t    {\n \t      // this means we are defaulting back to the trait_item if\n@@ -228,9 +210,9 @@ ResolvePathRef::query_compile_function (\n \t      rust_assert (found_associated_trait_impl);\n \t      associated->setup_associated_types ();\n \n-\t      CompileTraitItem::Compile (receiver,\n-\t\t\t\t\t trait_item_ref->get_hir_trait_item (),\n-\t\t\t\t\t ctx, fntype);\n+\t      return CompileTraitItem::Compile (\n+\t\treceiver, trait_item_ref->get_hir_trait_item (), ctx, lookup,\n+\t\ttrue, expr_locus);\n \t    }\n \t  else\n \t    {\n@@ -245,25 +227,21 @@ ResolvePathRef::query_compile_function (\n \t\timpl->get_type ()->get_mappings ().get_hirid (), &self);\n \t      rust_assert (ok);\n \n-\t      if (!fntype->has_subsititions_defined ())\n-\t\tCompileInherentImplItem::Compile (self, impl_item, ctx, true);\n+\t      if (!lookup->has_subsititions_defined ())\n+\t\treturn CompileInherentImplItem::Compile (self, impl_item, ctx,\n+\t\t\t\t\t\t\t true, nullptr, true,\n+\t\t\t\t\t\t\t expr_locus);\n \t      else\n-\t\tCompileInherentImplItem::Compile (self, impl_item, ctx, true,\n-\t\t\t\t\t\t  fntype);\n+\t\treturn CompileInherentImplItem::Compile (self, impl_item, ctx,\n+\t\t\t\t\t\t\t true, lookup, true,\n+\t\t\t\t\t\t\t expr_locus);\n \n-\t      fntype->set_ty_ref (impl_item->get_impl_mappings ().get_hirid ());\n+\t      lookup->set_ty_ref (impl_item->get_impl_mappings ().get_hirid ());\n \t    }\n \t}\n     }\n \n-  Bfunction *fn;\n-  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-    {\n-      rust_error_at (expr_locus, \"forward declaration was not compiled\");\n-      return ctx->get_backend ()->error_expression ();\n-    }\n-\n-  return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+  return ctx->get_backend ()->error_expression ();\n }\n \n } // namespace Compile"}, {"sha": "2b50ec13fa18e7b344df8b7ec8e1dd1ac9e9dca9", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbfc0ee239fafc0dadaae314138410f9119c65fa/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbfc0ee239fafc0dadaae314138410f9119c65fa/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=cbfc0ee239fafc0dadaae314138410f9119c65fa", "patch": "@@ -54,15 +54,14 @@ class ResolvePathRef : public HIRCompileBase\n     : HIRCompileBase (ctx), resolved (ctx->get_backend ()->error_expression ())\n   {}\n \n-  void resolve (const HIR::PathIdentSegment &final_segment,\n-\t\tconst Analysis::NodeMapping &mappings, Location locus,\n-\t\tbool is_qualified_path);\n-\n-  Bexpression *\n-  query_compile_function (HirId ref, TyTy::FnType *fntype,\n-\t\t\t  const HIR::PathIdentSegment &final_segment,\n-\t\t\t  const Analysis::NodeMapping &mappings,\n-\t\t\t  Location expr_locus, bool is_qualified_path);\n+  Bexpression *resolve (const HIR::PathIdentSegment &final_segment,\n+\t\t\tconst Analysis::NodeMapping &mappings, Location locus,\n+\t\t\tbool is_qualified_path);\n+\n+  Bexpression *query_compile (HirId ref, TyTy::BaseType *lookup,\n+\t\t\t      const HIR::PathIdentSegment &final_segment,\n+\t\t\t      const Analysis::NodeMapping &mappings,\n+\t\t\t      Location expr_locus, bool is_qualified_path);\n \n   Bexpression *resolved;\n };"}]}