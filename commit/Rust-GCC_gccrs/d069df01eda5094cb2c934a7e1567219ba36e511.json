{"sha": "d069df01eda5094cb2c934a7e1567219ba36e511", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA2OWRmMDFlZGE1MDk0Y2IyYzkzNGE3ZTE1NjcyMTliYTM2ZTUxMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-05-16T20:30:35Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-05-16T20:30:35Z"}, "message": "Implement sane variant converting constructor (P0608R3)\n\n\t* include/std/variant (__overload_set): Remove.\n\t(_Arr): New helper.\n\t(_Build_FUN): New class template to define a single FUN overload,\n\twith specializations to prevent unwanted conversions, as per P0608R3.\n\t(_Build_FUNs): New class template to build an overload set of FUN.\n\t(_FUN_type): New alias template to perform overload resolution.\n\t(__accepted_type): Use integer_constant base for failure case. Use\n\t_FUN_type for successful case.\n\t(variant::__accepted_index): Use _Tp instead of _Tp&&.\n\t(variant::variant(_Tp&&)): Likewise.\n\t(variant::operator=(_Tp&&)): Likewise.\n\nFrom-SVN: r271296", "tree": {"sha": "7ff15df0c3b8141371e384465d6b7d8ea68ce04f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ff15df0c3b8141371e384465d6b7d8ea68ce04f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d069df01eda5094cb2c934a7e1567219ba36e511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d069df01eda5094cb2c934a7e1567219ba36e511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d069df01eda5094cb2c934a7e1567219ba36e511", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d069df01eda5094cb2c934a7e1567219ba36e511/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b62dcd16aa033968075f19631c757bb39a16ef92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b62dcd16aa033968075f19631c757bb39a16ef92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b62dcd16aa033968075f19631c757bb39a16ef92"}], "stats": {"total": 148, "additions": 118, "deletions": 30}, "files": [{"sha": "ac7914db65ef3f19d5e142e371b87064e93317e8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d069df01eda5094cb2c934a7e1567219ba36e511/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d069df01eda5094cb2c934a7e1567219ba36e511/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d069df01eda5094cb2c934a7e1567219ba36e511", "patch": "@@ -1,5 +1,17 @@\n 2019-05-16  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/std/variant (__overload_set): Remove.\n+\t(_Arr): New helper.\n+\t(_Build_FUN): New class template to define a single FUN overload,\n+\twith specializations to prevent unwanted conversions, as per P0608R3.\n+\t(_Build_FUNs): New class template to build an overload set of FUN.\n+\t(_FUN_type): New alias template to perform overload resolution.\n+\t(__accepted_type): Use integer_constant base for failure case. Use\n+\t_FUN_type for successful case.\n+\t(variant::__accepted_index): Use _Tp instead of _Tp&&.\n+\t(variant::variant(_Tp&&)): Likewise.\n+\t(variant::operator=(_Tp&&)): Likewise.\n+\n \t* include/std/variant (_Variant_storage<false, _Types...>::_M_reset):\n \tReplace raw visitation with a runtime check for the valueless state\n \tand a non-raw visitor."}, {"sha": "eec41750da758c25d3a17c887794c3c172fc3728", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d069df01eda5094cb2c934a7e1567219ba36e511/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d069df01eda5094cb2c934a7e1567219ba36e511/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=d069df01eda5094cb2c934a7e1567219ba36e511", "patch": "@@ -161,7 +161,7 @@ namespace __detail\n {\n namespace __variant\n {\n-  // Returns the first apparence of _Tp in _Types.\n+  // Returns the first appearence of _Tp in _Types.\n   // Returns sizeof...(_Types) if _Tp is not in _Types.\n   template<typename _Tp, typename... _Types>\n     struct __index_of : std::integral_constant<size_t, 0> {};\n@@ -727,42 +727,66 @@ namespace __variant\n     inline constexpr bool __exactly_once =\n       __tuple_count_v<_Tp, tuple<_Types...>> == 1;\n \n-  // Takes _Types and create an overloaded _S_fun for each type.\n-  // If a type appears more than once in _Types, create only one overload.\n-  template<typename... _Types>\n-    struct __overload_set\n-    { static void _S_fun(); };\n+  // Helper used to check for valid conversions that don't involve narrowing.\n+  template<typename _Ti> struct _Arr { _Ti _M_x[1]; };\n \n-  template<typename _First, typename... _Rest>\n-    struct __overload_set<_First, _Rest...> : __overload_set<_Rest...>\n+  // Build an imaginary function FUN(Ti) for each alternative type Ti\n+  template<size_t _Ind, typename _Tp, typename _Ti,\n+\t   bool _Ti_is_cv_bool = is_same_v<remove_cv_t<_Ti>, bool>,\n+\t   typename = void>\n+    struct _Build_FUN\n     {\n-      using __overload_set<_Rest...>::_S_fun;\n-      static integral_constant<size_t, sizeof...(_Rest)> _S_fun(_First);\n+      // This function means 'using _Build_FUN<I, T, Ti>::_S_fun;' is valid,\n+      // but only static functions will be considered in the call below.\n+      void _S_fun();\n     };\n \n-  template<typename... _Rest>\n-    struct __overload_set<void, _Rest...> : __overload_set<_Rest...>\n+  // ... for which Ti x[] = {std::forward<T>(t)}; is well-formed,\n+  template<size_t _Ind, typename _Tp, typename _Ti>\n+    struct _Build_FUN<_Ind, _Tp, _Ti, false,\n+\t\t      void_t<decltype(_Arr<_Ti>{{std::declval<_Tp>()}})>>\n     {\n-      using __overload_set<_Rest...>::_S_fun;\n+      // This is the FUN function for type _Ti, with index _Ind\n+      static integral_constant<size_t, _Ind> _S_fun(_Ti);\n     };\n \n-  // Helper for variant(_Tp&&) and variant::operator=(_Tp&&).\n-  // __accepted_index maps an arbitrary _Tp to an alternative type in _Variant\n-  // (or to variant_npos).\n-  template<typename _Tp, typename _Variant, typename = void>\n-    struct __accepted_index\n-    { static constexpr size_t value = variant_npos; };\n+  // ... and if Ti is cv bool, remove_cvref_t<T> is bool.\n+  template<size_t _Ind, typename _Tp, typename _Ti>\n+    struct _Build_FUN<_Ind, _Tp, _Ti, true,\n+\t\t      enable_if_t<is_same_v<__remove_cvref_t<_Tp>, bool>>>\n+    {\n+      // This is the FUN function for when _Ti is cv bool, with index _Ind\n+      static integral_constant<size_t, _Ind> _S_fun(_Ti);\n+    };\n \n-  template<typename _Tp, typename... _Types>\n-    struct __accepted_index<\n-      _Tp, variant<_Types...>,\n-      void_t<decltype(__overload_set<_Types...>::_S_fun(std::declval<_Tp>()))>>\n+  template<typename _Tp, typename _Variant,\n+\t   typename = make_index_sequence<variant_size_v<_Variant>>>\n+    struct _Build_FUNs;\n+\n+  template<typename _Tp, typename... _Ti, size_t... _Ind>\n+    struct _Build_FUNs<_Tp, variant<_Ti...>, index_sequence<_Ind...>>\n+    : _Build_FUN<_Ind, _Tp, _Ti>...\n     {\n-      static constexpr size_t value = sizeof...(_Types) - 1\n-\t- decltype(__overload_set<_Types...>::\n-\t\t   _S_fun(std::declval<_Tp>()))::value;\n+      using _Build_FUN<_Ind, _Tp, _Ti>::_S_fun...;\n     };\n \n+  // The index j of the overload FUN(Tj) selected by overload resolution\n+  // for FUN(std::forward<_Tp>(t))\n+  template<typename _Tp, typename _Variant>\n+    using _FUN_type\n+      = decltype(_Build_FUNs<_Tp, _Variant>::_S_fun(std::declval<_Tp>()));\n+\n+  // The index selected for FUN(std::forward<T>(t)), or variant_npos if none.\n+  template<typename _Tp, typename _Variant, typename = void>\n+    struct __accepted_index\n+    : integral_constant<size_t, variant_npos>\n+    { };\n+\n+  template<typename _Tp, typename _Variant>\n+    struct __accepted_index<_Tp, _Variant, void_t<_FUN_type<_Tp, _Variant>>>\n+    : _FUN_type<_Tp, _Variant>\n+    { };\n+\n   // Returns the raw storage for __v.\n   template<typename _Variant>\n     void* __get_storage(_Variant&& __v) noexcept\n@@ -1247,8 +1271,8 @@ namespace __variant\n \t__exactly_once = __detail::__variant::__exactly_once<_Tp, _Types...>;\n \n       template<typename _Tp>\n-\tstatic constexpr size_t __accepted_index =\n-\t  __detail::__variant::__accepted_index<_Tp&&, variant>::value;\n+\tstatic constexpr size_t __accepted_index\n+\t  = __detail::__variant::__accepted_index<_Tp, variant>::value;\n \n       template<size_t _Np, typename = enable_if_t<(_Np < sizeof...(_Types))>>\n \tusing __to_type = variant_alternative_t<_Np, variant>;\n@@ -1290,7 +1314,7 @@ namespace __variant\n \tconstexpr\n \tvariant(_Tp&& __t)\n \tnoexcept(is_nothrow_constructible_v<_Tj, _Tp>)\n-\t: variant(in_place_index<__accepted_index<_Tp&&>>,\n+\t: variant(in_place_index<__accepted_index<_Tp>>,\n \t\t  std::forward<_Tp>(__t))\n \t{ }\n \n@@ -1344,7 +1368,7 @@ namespace __variant\n \tnoexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>\n \t\t && is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp>)\n \t{\n-\t  constexpr auto __index = __accepted_index<_Tp&&>;\n+\t  constexpr auto __index = __accepted_index<_Tp>;\n \t  if (index() == __index)\n \t    std::get<__index>(*this) = std::forward<_Tp>(__rhs);\n \t  else"}, {"sha": "4560f77445229682c7fe2008edec112abcf1a88b", "filename": "libstdc++-v3/testsuite/20_util/variant/compile.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d069df01eda5094cb2c934a7e1567219ba36e511/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d069df01eda5094cb2c934a7e1567219ba36e511/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc?ref=d069df01eda5094cb2c934a7e1567219ba36e511", "patch": "@@ -142,6 +142,11 @@ void arbitrary_ctor()\n   static_assert(noexcept(variant<int, DefaultNoexcept>(int{})));\n   static_assert(!noexcept(variant<int, Empty>(Empty{})));\n   static_assert(noexcept(variant<int, DefaultNoexcept>(DefaultNoexcept{})));\n+\n+  // P0608R3 disallow narrowing conversions and boolean conversions\n+  static_assert(!is_constructible_v<variant<int>, long>);\n+  static_assert(!is_constructible_v<variant<bool>, int>);\n+  static_assert(!is_constructible_v<variant<bool>, void*>);\n }\n \n struct none { none() = delete; };"}, {"sha": "ac60ccbc13e83ef93a784bce9b230b257eb2d63e", "filename": "libstdc++-v3/testsuite/20_util/variant/run.cc", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d069df01eda5094cb2c934a7e1567219ba36e511/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d069df01eda5094cb2c934a7e1567219ba36e511/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc?ref=d069df01eda5094cb2c934a7e1567219ba36e511", "patch": "@@ -102,6 +102,32 @@ void arbitrary_ctor()\n   variant<int, string> v(\"a\");\n   VERIFY(holds_alternative<string>(v));\n   VERIFY(get<1>(v) == \"a\");\n+\n+  {\n+    // P0608R3\n+    variant<string, bool> x = \"abc\";\n+    VERIFY(x.index() == 0);\n+  }\n+\n+  {\n+    // P0608R3\n+    struct U {\n+      U(char16_t c) : c(c) { }\n+      char16_t c;\n+    };\n+    variant<char, U> x = u'\\u2043';\n+    VERIFY(x.index() == 1);\n+    VERIFY(std::get<1>(x).c == u'\\u2043');\n+\n+    struct Double {\n+      Double(double& d) : d(d) { }\n+      double& d;\n+    };\n+    double d = 3.14;\n+    variant<int, Double> y = d;\n+    VERIFY(y.index() == 1);\n+    VERIFY(std::get<1>(y).d == d);\n+  }\n }\n \n struct ThrowingMoveCtorThrowsCopyCtor\n@@ -168,6 +194,27 @@ void arbitrary_assign()\n \n   VERIFY(holds_alternative<string>(variant<int, string>(\"a\")));\n   VERIFY(get<1>(v) == \"a\");\n+\n+  {\n+    // P0608R3\n+    using T1 = variant<float, int>;\n+    T1 v1;\n+    v1 = 0;\n+    VERIFY(v1.index() == 1);\n+\n+    using T2 = variant<float, long>;\n+    T2 v2;\n+    v2 = 0;\n+    VERIFY(v2.index() == 1);\n+\n+    struct big_int {\n+      big_int(int) { }\n+    };\n+    using T3 = variant<float, big_int>;\n+    T3 v3;\n+    v3 = 0;\n+    VERIFY(v3.index() == 1);\n+  }\n }\n \n void dtor()"}]}