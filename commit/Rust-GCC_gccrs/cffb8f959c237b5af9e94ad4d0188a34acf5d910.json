{"sha": "cffb8f959c237b5af9e94ad4d0188a34acf5d910", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZmYjhmOTU5YzIzN2I1YWY5ZTk0YWQ0ZDAxODhhMzRhY2Y1ZDkxMA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2019-08-13T08:08:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-13T08:08:40Z"}, "message": "[Ada] Legality rule on ancestors of type extensions in generic bodies\n\nThis patch adds an RM reference for the rule that in a generic body a\ntype extension cannot have ancestors that are generic formal types. The\npatch also extends the check to interface progenitors that may appear in\na derived type declaration or private extension declaration.\n\n2019-08-13  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch3.adb (Check_Generic_Ancestor): New subprogram,\n\taubsidiary to Build_Derived_Record_Type. to enforce the rule\n\tthat a type extension declared in a generic body cznnot have an\n\tancestor that is a generic formal (RM 3.9.1 (4/2)). The rule\n\tapplies to all ancestors of the type, including interface\n\tprogenitors.\n\ngcc/testsuite/\n\n\t* gnat.dg/tagged4.adb: New testcase.\n\nFrom-SVN: r274358", "tree": {"sha": "18bb05f70bc117e2914071be092fac67bcf7aef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18bb05f70bc117e2914071be092fac67bcf7aef9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cffb8f959c237b5af9e94ad4d0188a34acf5d910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cffb8f959c237b5af9e94ad4d0188a34acf5d910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cffb8f959c237b5af9e94ad4d0188a34acf5d910", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cffb8f959c237b5af9e94ad4d0188a34acf5d910/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f078d5b3e3ae2cdf527e6a163edd73238726a80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f078d5b3e3ae2cdf527e6a163edd73238726a80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f078d5b3e3ae2cdf527e6a163edd73238726a80"}], "stats": {"total": 168, "additions": 122, "deletions": 46}, "files": [{"sha": "9ea478d1c985a94a29bbd2814b35806e6d0c79b6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffb8f959c237b5af9e94ad4d0188a34acf5d910/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffb8f959c237b5af9e94ad4d0188a34acf5d910/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cffb8f959c237b5af9e94ad4d0188a34acf5d910", "patch": "@@ -1,3 +1,12 @@\n+2019-08-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Check_Generic_Ancestor): New subprogram,\n+\taubsidiary to Build_Derived_Record_Type. to enforce the rule\n+\tthat a type extension declared in a generic body cznnot have an\n+\tancestor that is a generic formal (RM 3.9.1 (4/2)). The rule\n+\tapplies to all ancestors of the type, including interface\n+\tprogenitors.\n+\n 2019-08-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_ch3.adb (Build_Underlying_Full_View): Delete."}, {"sha": "c5655ee84802f05ff2fb50b2d956338d41095ab2", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 81, "deletions": 46, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffb8f959c237b5af9e94ad4d0188a34acf5d910/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffb8f959c237b5af9e94ad4d0188a34acf5d910/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=cffb8f959c237b5af9e94ad4d0188a34acf5d910", "patch": "@@ -8574,6 +8574,84 @@ package body Sem_Ch3 is\n       --  An empty Discs list means that there were no constraints in the\n       --  subtype indication or that there was an error processing it.\n \n+      procedure Check_Generic_Ancestors;\n+      --  In Ada 2005 (AI-344), the restriction that a derived tagged type\n+      --  cannot be declared at a deeper level than its parent type is\n+      --  removed. The check on derivation within a generic body is also\n+      --  relaxed, but there's a restriction that a derived tagged type\n+      --  cannot be declared in a generic body if it's derived directly\n+      --  or indirectly from a formal type of that generic. This applies\n+      --  to progenitors as well.\n+\n+      -----------------------------\n+      -- Check_Generic_Ancestors --\n+      -----------------------------\n+\n+      procedure Check_Generic_Ancestors is\n+         Ancestor_Type : Entity_Id;\n+         Intf_List     : List_Id;\n+         Intf_Name     : Node_Id;\n+\n+         procedure Check_Ancestor;\n+         --  For parent and progenitors.\n+\n+         --------------------\n+         -- Check_Ancestor --\n+         --------------------\n+\n+         procedure Check_Ancestor is\n+         begin\n+            --  If the derived type does have a formal type as an ancestor\n+            --  then it's an error if the derived type is declared within\n+            --  the body of the generic unit that declares the formal type\n+            --  in its generic formal part. It's sufficient to check whether\n+            --  the ancestor type is declared inside the same generic body\n+            --  as the derived type (such as within a nested generic spec),\n+            --  in which case the derivation is legal. If the formal type is\n+            --  declared outside of that generic body, then it's certain\n+            --  that the derived type is declared within the generic body\n+            --  of the generic unit declaring the formal type.\n+\n+            if Is_Generic_Type (Ancestor_Type)\n+              and then Enclosing_Generic_Body (Ancestor_Type) /=\n+                         Enclosing_Generic_Body (Derived_Type)\n+            then\n+               Error_Msg_NE\n+                 (\"ancestor type& is formal type of enclosing\"\n+                    & \" generic unit (RM 3.9.1 (4/2))\",\n+                      Indic, Ancestor_Type);\n+            end if;\n+         end Check_Ancestor;\n+\n+      begin\n+         if Nkind (N) = N_Private_Extension_Declaration then\n+            Intf_List := Interface_List (N);\n+         else\n+            Intf_List := Interface_List (Type_Definition (N));\n+         end if;\n+\n+         if Present (Enclosing_Generic_Body (Derived_Type)) then\n+            Ancestor_Type := Parent_Type;\n+\n+            while not Is_Generic_Type (Ancestor_Type)\n+              and then Etype (Ancestor_Type) /= Ancestor_Type\n+            loop\n+               Ancestor_Type := Etype (Ancestor_Type);\n+            end loop;\n+\n+            Check_Ancestor;\n+\n+            if Present (Intf_List) then\n+               Intf_Name := First (Intf_List);\n+               while Present (Intf_Name) loop\n+                  Ancestor_Type := Entity (Intf_Name);\n+                  Check_Ancestor;\n+                  Next (Intf_Name);\n+               end loop;\n+            end if;\n+         end if;\n+      end Check_Generic_Ancestors;\n+\n    begin\n       if Ekind (Parent_Type) = E_Record_Type_With_Private\n         and then Present (Full_View (Parent_Type))\n@@ -8680,7 +8758,8 @@ package body Sem_Ch3 is\n \n       --  Indic can either be an N_Identifier if the subtype indication\n       --  contains no constraint or an N_Subtype_Indication if the subtype\n-      --  indication has a constraint.\n+      --  indecation has a constraint. In either case it can include an\n+      --  interface list.\n \n       Indic := Subtype_Indication (Type_Def);\n       Constraint_Present := (Nkind (Indic) = N_Subtype_Indication);\n@@ -8909,52 +8988,8 @@ package body Sem_Ch3 is\n             Freeze_Before (N, Parent_Type);\n          end if;\n \n-         --  In Ada 2005 (AI-344), the restriction that a derived tagged type\n-         --  cannot be declared at a deeper level than its parent type is\n-         --  removed. The check on derivation within a generic body is also\n-         --  relaxed, but there's a restriction that a derived tagged type\n-         --  cannot be declared in a generic body if it's derived directly\n-         --  or indirectly from a formal type of that generic.\n-\n          if Ada_Version >= Ada_2005 then\n-            if Present (Enclosing_Generic_Body (Derived_Type)) then\n-               declare\n-                  Ancestor_Type : Entity_Id;\n-\n-               begin\n-                  --  Check to see if any ancestor of the derived type is a\n-                  --  formal type.\n-\n-                  Ancestor_Type := Parent_Type;\n-                  while not Is_Generic_Type (Ancestor_Type)\n-                    and then Etype (Ancestor_Type) /= Ancestor_Type\n-                  loop\n-                     Ancestor_Type := Etype (Ancestor_Type);\n-                  end loop;\n-\n-                  --  If the derived type does have a formal type as an\n-                  --  ancestor, then it's an error if the derived type is\n-                  --  declared within the body of the generic unit that\n-                  --  declares the formal type in its generic formal part. It's\n-                  --  sufficient to check whether the ancestor type is declared\n-                  --  inside the same generic body as the derived type (such as\n-                  --  within a nested generic spec), in which case the\n-                  --  derivation is legal. If the formal type is declared\n-                  --  outside of that generic body, then it's guaranteed that\n-                  --  the derived type is declared within the generic body of\n-                  --  the generic unit declaring the formal type.\n-\n-                  if Is_Generic_Type (Ancestor_Type)\n-                    and then Enclosing_Generic_Body (Ancestor_Type) /=\n-                               Enclosing_Generic_Body (Derived_Type)\n-                  then\n-                     Error_Msg_NE\n-                       (\"parent type of& must not be descendant of formal type\"\n-                          & \" of an enclosing generic body\",\n-                            Indic, Derived_Type);\n-                  end if;\n-               end;\n-            end if;\n+            Check_Generic_Ancestors;\n \n          elsif Type_Access_Level (Derived_Type) /=\n                  Type_Access_Level (Parent_Type)"}, {"sha": "2960f5b40afc58cba31989bc6b10cad5c907dfa2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffb8f959c237b5af9e94ad4d0188a34acf5d910/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffb8f959c237b5af9e94ad4d0188a34acf5d910/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cffb8f959c237b5af9e94ad4d0188a34acf5d910", "patch": "@@ -1,3 +1,7 @@\n+2019-08-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* gnat.dg/tagged4.adb: New testcase.\n+\n 2019-08-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/generic_inst10.adb, gnat.dg/generic_inst10_pkg.ads:"}, {"sha": "7611b9e9d13767d2d4ca7800f448bf937348593d", "filename": "gcc/testsuite/gnat.dg/tagged4.adb", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffb8f959c237b5af9e94ad4d0188a34acf5d910/gcc%2Ftestsuite%2Fgnat.dg%2Ftagged4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffb8f959c237b5af9e94ad4d0188a34acf5d910/gcc%2Ftestsuite%2Fgnat.dg%2Ftagged4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Ftagged4.adb?ref=cffb8f959c237b5af9e94ad4d0188a34acf5d910", "patch": "@@ -0,0 +1,28 @@\n+--  { dg-do compile }\n+\n+procedure Tagged4 is\n+   type T0 is tagged null record;\n+\n+   generic\n+      type F1 is tagged private;\n+   procedure Gen1;\n+\n+   procedure Gen1 is\n+      type Inst1 is new F1 with null record;  --  { dg-error \"ancestor type \\\"F1\\\" is formal type of enclosing generic unit \\\\(RM 3\\\\.9\\\\.1 \\\\(4\\\\/2\\\\)\\\\)\" }\n+   begin\n+      null;\n+   end Gen1;\n+\n+   generic\n+      type F2 is interface;\n+   procedure Gen2;\n+\n+   procedure Gen2 is\n+      type Inst2 is new T0 and F2 with null record;  --  { dg-error \"ancestor type \\\"F2\\\" is formal type of enclosing generic unit \\\\(RM 3\\\\.9\\\\.1 \\\\(4\\\\/2\\\\)\\\\)\" }\n+   begin\n+      null;\n+   end Gen2;\n+\n+begin\n+   null;\n+end Tagged4;"}]}