{"sha": "c5d753640d06e51da60056f0ee354b5134cad1f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVkNzUzNjQwZDA2ZTUxZGE2MDA1NmYwZWUzNTRiNTEzNGNhZDFmNw==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-07-07T02:55:59Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-07-07T02:55:59Z"}, "message": "cgraphunit.c: Replace %J by an explicit location.\n\n2009-07-07  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\t* cgraphunit.c: Replace %J by an explicit location. Update all\n\tcalls.\n\t* c-decl.c: Likewise.\n\t* function.c: Likewise.\n\t* varasm.c: Likewise.\n\t* tree-ssa.c: Likewise.\n\t* c-common.c: Likewise.\n\t* tree-cfg.c: Likewise.\n\t* config/spu/spu.c: Likewise.\n\t* config/ia64/ia64.c: Likewise.\n\t* config/v850/v850.c: Likewise.\njava/\t\n\t* class.c: Replace %J by an explicit location. Update all calls.\nobjc/\t\n\t* objc-act.c: Replace %J by an explicit location. Update all\n\tcalls.\ncp/\n\t* init.c: Replace %J by an explicit location. Update all calls.\n\t* decl.c: Likewise.\n\t* typeck2.c: Likewise.\n\t* pt.c: Likewise.\n\t* name-lookup.c: Likewise.\n\nFrom-SVN: r149312", "tree": {"sha": "d34263b5ff9f1576a23b9f95e545dc831212bc84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d34263b5ff9f1576a23b9f95e545dc831212bc84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5d753640d06e51da60056f0ee354b5134cad1f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d753640d06e51da60056f0ee354b5134cad1f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5d753640d06e51da60056f0ee354b5134cad1f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d753640d06e51da60056f0ee354b5134cad1f7/comments", "author": null, "committer": null, "parents": [{"sha": "b932c20b25c7516eb5fa2a813b8bfa786569c0b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b932c20b25c7516eb5fa2a813b8bfa786569c0b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b932c20b25c7516eb5fa2a813b8bfa786569c0b4"}], "stats": {"total": 376, "additions": 231, "deletions": 145}, "files": [{"sha": "870dcea7c045296fd6739d13949f354a07c9e694", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -1,3 +1,17 @@\n+2009-07-07  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\t* cgraphunit.c: Replace %J by an explicit location. Update all\n+\tcalls.\n+\t* c-decl.c: Likewise.\n+\t* function.c: Likewise.\n+\t* varasm.c: Likewise.\n+\t* tree-ssa.c: Likewise.\n+\t* c-common.c: Likewise.\n+\t* tree-cfg.c: Likewise.\n+\t* config/spu/spu.c: Likewise.\n+\t* config/ia64/ia64.c: Likewise.\n+\t* config/v850/v850.c: Likewise.\n+\n 2009-07-06  DJ Delorie  <dj@redhat.com>\n \n \t* config/mep/mep-core.cpu (fsft, ssarb): Mark as VOLATILE."}, {"sha": "1c883d15308ed3bf11130a9b9e2379641cadb23d", "filename": "gcc/c-common.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -5417,13 +5417,15 @@ match_case_to_enum_1 (tree key, tree type, tree label)\n \t      (unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (key));\n \n   if (TYPE_NAME (type) == 0)\n-    warning (warn_switch ? OPT_Wswitch : OPT_Wswitch_enum,\n-\t     \"%Jcase value %qs not in enumerated type\",\n-\t     CASE_LABEL (label), buf);\n+    warning_at (DECL_SOURCE_LOCATION (CASE_LABEL (label)),\n+\t\twarn_switch ? OPT_Wswitch : OPT_Wswitch_enum,\n+\t\t\"case value %qs not in enumerated type\",\n+\t\tbuf);\n   else\n-    warning (warn_switch ? OPT_Wswitch : OPT_Wswitch_enum,\n-\t     \"%Jcase value %qs not in enumerated type %qT\",\n-\t     CASE_LABEL (label), buf, type);\n+    warning_at (DECL_SOURCE_LOCATION (CASE_LABEL (label)),\n+\t\twarn_switch ? OPT_Wswitch : OPT_Wswitch_enum,\n+\t\t\"case value %qs not in enumerated type %qT\",\n+\t\tbuf, type);\n }\n \n /* Subroutine of c_do_switch_warnings, called via splay_tree_foreach.\n@@ -6493,8 +6495,9 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \t      && current_function_decl != NULL_TREE\n \t      && !TREE_STATIC (decl))\n \t    {\n-\t      error (\"%Jsection attribute cannot be specified for \"\n-\t\t     \"local variables\", decl);\n+\t      error_at (DECL_SOURCE_LOCATION (decl), \n+\t\t\t\"section attribute cannot be specified for \"\n+\t\t\t\"local variables\");\n \t      *no_add_attrs = true;\n \t    }\n \n@@ -6526,7 +6529,8 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n     }\n   else\n     {\n-      error (\"%Jsection attributes are not supported for this target\", *node);\n+      error_at (DECL_SOURCE_LOCATION (*node),\n+\t\t\"section attributes are not supported for this target\");\n       *no_add_attrs = true;\n     }\n \n@@ -6745,8 +6749,8 @@ handle_weakref_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n   else\n     {\n       if (lookup_attribute (\"alias\", DECL_ATTRIBUTES (*node)))\n-\terror (\"%Jweakref attribute must appear before alias attribute\",\n-\t       *node);\n+\terror_at (DECL_SOURCE_LOCATION (*node),\n+\t\t  \"weakref attribute must appear before alias attribute\");\n \n       /* Can't call declare_weak because it wants this to be TREE_PUBLIC,\n \t and that isn't supported; and because it wants to add it to\n@@ -6956,12 +6960,14 @@ handle_no_instrument_function_attribute (tree *node, tree name,\n \n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n-      error (\"%J%qE attribute applies only to functions\", decl, name);\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute applies only to functions\", name);\n       *no_add_attrs = true;\n     }\n   else if (DECL_INITIAL (decl))\n     {\n-      error (\"%Jcan%'t set %qE attribute after definition\", decl, name);\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"can%'t set %qE attribute after definition\", name);\n       *no_add_attrs = true;\n     }\n   else\n@@ -7046,12 +7052,14 @@ handle_no_limit_stack_attribute (tree *node, tree name,\n \n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n-      error (\"%J%qE attribute applies only to functions\", decl, name);\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t     \"%qE attribute applies only to functions\", name);\n       *no_add_attrs = true;\n     }\n   else if (DECL_INITIAL (decl))\n     {\n-      error (\"%Jcan%'t set %qE attribute after definition\", decl, name);\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"can%'t set %qE attribute after definition\", name);\n       *no_add_attrs = true;\n     }\n   else"}, {"sha": "fa578cb65292cd7d775d41027d28f130b07fc8da", "filename": "gcc/c-decl.c", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -1890,9 +1890,10 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t\t\t\tDECL_ATTRIBUTES (olddecl)) != NULL;\n \t  if (newa != olda)\n \t    {\n-\t      error (\"%<gnu_inline%> attribute present on %q+D\",\n-\t\t     newa ? newdecl : olddecl);\n-\t      error (\"%Jbut not here\", newa ? olddecl : newdecl);\n+\t      error_at (input_location, \"%<gnu_inline%> attribute present on %q+D\",\n+\t\t\tnewa ? newdecl : olddecl);\n+\t      error_at (DECL_SOURCE_LOCATION (newa ? olddecl : newdecl),\n+\t\t\t\"but not here\");\n \t    }\n \t}\n     }\n@@ -2489,7 +2490,8 @@ warn_if_shadowing (tree new_decl)\n \t  warning (OPT_Wshadow, \"declaration of %q+D shadows a previous local\",\n \t\t   new_decl);\n \n-\twarning (OPT_Wshadow, \"%Jshadowed declaration is here\", old_decl);\n+\twarning_at (DECL_SOURCE_LOCATION (old_decl), OPT_Wshadow,\n+\t\t    \"shadowed declaration is here\");\n \n \tbreak;\n       }\n@@ -6002,23 +6004,27 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n \t      if (funcdef_flag)\n \t\t{\n \t\t  if (DECL_NAME (parm))\n-\t\t    error (\"parameter %u (%q+D) has incomplete type\",\n-\t\t\t   parmno, parm);\n+\t\t    error_at (input_location,\n+\t\t\t      \"parameter %u (%q+D) has incomplete type\",\n+\t\t\t      parmno, parm);\n \t\t  else\n-\t\t    error (\"%Jparameter %u has incomplete type\",\n-\t\t\t   parm, parmno);\n+\t\t    error_at (DECL_SOURCE_LOCATION (parm),\n+\t\t\t      \"parameter %u has incomplete type\",\n+\t\t\t      parmno);\n \n \t\t  TREE_VALUE (typelt) = error_mark_node;\n \t\t  TREE_TYPE (parm) = error_mark_node;\n \t\t}\n \t      else if (VOID_TYPE_P (type))\n \t\t{\n \t\t  if (DECL_NAME (parm))\n-\t\t    warning (0, \"parameter %u (%q+D) has void type\",\n-\t\t\t     parmno, parm);\n+\t\t    warning_at (input_location, 0,\n+\t\t\t\t\"parameter %u (%q+D) has void type\",\n+\t\t\t\tparmno, parm);\n \t\t  else\n-\t\t    warning (0, \"%Jparameter %u has void type\",\n-\t\t\t     parm, parmno);\n+\t\t    warning_at (DECL_SOURCE_LOCATION (parm), 0,\n+\t\t\t\t\"parameter %u has void type\",\n+\t\t\t\tparmno);\n \t\t}\n \t    }\n \n@@ -6722,28 +6728,27 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t  if (TREE_CODE (t) == UNION_TYPE)\n \t    {\n \t      error_at (DECL_SOURCE_LOCATION (x),\n-\t\t\t\"%Jflexible array member in union\", x);\n+\t\t\t\"flexible array member in union\");\n \t      TREE_TYPE (x) = error_mark_node;\n \t    }\n \t  else if (TREE_CHAIN (x) != NULL_TREE)\n \t    {\n \t      error_at (DECL_SOURCE_LOCATION (x),\n-\t\t\t\"%Jflexible array member not at end of struct\", x);\n+\t\t\t\"flexible array member not at end of struct\");\n \t      TREE_TYPE (x) = error_mark_node;\n \t    }\n \t  else if (!saw_named_field)\n \t    {\n \t      error_at (DECL_SOURCE_LOCATION (x),\n-\t\t\t\"%Jflexible array member in otherwise empty struct\",\n-\t\t\tx);\n+\t\t\t\"flexible array member in otherwise empty struct\");\n \t      TREE_TYPE (x) = error_mark_node;\n \t    }\n \t}\n \n-      if (pedantic && !in_system_header && TREE_CODE (t) == RECORD_TYPE\n+      if (pedantic && TREE_CODE (t) == RECORD_TYPE\n \t  && flexible_array_type_p (TREE_TYPE (x)))\n-\tpedwarn (loc, OPT_pedantic, \n-\t\t \"%Jinvalid use of structure with flexible array member\", x);\n+\tpedwarn (DECL_SOURCE_LOCATION (x), OPT_pedantic, \n+\t\t \"invalid use of structure with flexible array member\");\n \n       if (DECL_NAME (x))\n \tsaw_named_field = 1;\n@@ -7465,8 +7470,9 @@ store_parm_decls_newstyle (tree fndecl, const struct c_arg_info *arg_info)\n \n   if (current_scope->bindings)\n     {\n-      error (\"%Jold-style parameter declarations in prototyped \"\n-\t     \"function definition\", fndecl);\n+      error_at (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\"old-style parameter declarations in prototyped \"\n+\t\t\"function definition\");\n \n       /* Get rid of the old-style declarations.  */\n       pop_scope ();\n@@ -7478,9 +7484,8 @@ store_parm_decls_newstyle (tree fndecl, const struct c_arg_info *arg_info)\n      its parameter list).  */\n   else if (!in_system_header && !current_function_scope\n \t   && arg_info->types != error_mark_node)\n-    warning (OPT_Wtraditional,\n-\t     \"%Jtraditional C rejects ISO C style function definitions\",\n-\t     fndecl);\n+    warning_at (DECL_SOURCE_LOCATION (fndecl), OPT_Wtraditional,\n+\t\t\"traditional C rejects ISO C style function definitions\");\n \n   /* Now make all the parameter declarations visible in the function body.\n      We can bypass most of the grunt work of pushdecl.  */\n@@ -7496,7 +7501,7 @@ store_parm_decls_newstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t    warn_if_shadowing (decl);\n \t}\n       else\n-\terror (\"%Jparameter name omitted\", decl);\n+\terror_at (DECL_SOURCE_LOCATION (decl), \"parameter name omitted\");\n     }\n \n   /* Record the parameter list in the function declaration.  */"}, {"sha": "4521f3b7641f4663416328dca6943260ce4c345c", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -845,9 +845,9 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n       if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n \t  if (! TREE_PUBLIC (node->decl))\n-\t    warning (OPT_Wattributes,\n-\t\t     \"%J%<externally_visible%> attribute have effect only on public objects\",\n-\t\t     node->decl);\n+\t    warning_at (DECL_SOURCE_LOCATION (node->decl), OPT_Wattributes,\n+\t\t\t\"%<externally_visible%>\"\n+\t\t\t\" attribute have effect only on public objects\");\n \t  else\n \t    {\n \t      if (node->local.finalized)\n@@ -868,9 +868,9 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n       if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n \t  if (! TREE_PUBLIC (vnode->decl))\n-\t    warning (OPT_Wattributes,\n-\t\t     \"%J%<externally_visible%> attribute have effect only on public objects\",\n-\t\t     vnode->decl);\n+\t    warning_at (DECL_SOURCE_LOCATION (vnode->decl), OPT_Wattributes,\n+\t\t\t\"%<externally_visible%>\"\n+\t\t\t\" attribute have effect only on public objects\");\n \t  else\n \t    {\n \t      if (vnode->finalized)"}, {"sha": "b863fd3ac9ad55082909389de03f43472318f568", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -593,8 +593,9 @@ ia64_handle_model_attribute (tree *node, tree name, tree args,\n \t   == FUNCTION_DECL)\n \t  && !TREE_STATIC (decl))\n \t{\n-\t  error (\"%Jan address area attribute cannot be specified for \"\n-\t\t \"local variables\", decl);\n+\t  error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t    \"an address area attribute cannot be specified for \"\n+\t\t    \"local variables\");\n \t  *no_add_attrs = true;\n \t}\n       area = ia64_get_addr_area (decl);\n@@ -607,8 +608,9 @@ ia64_handle_model_attribute (tree *node, tree name, tree args,\n       break;\n \n     case FUNCTION_DECL:\n-      error (\"%Jaddress area attribute cannot be specified for functions\",\n-\t     decl);\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"address area attribute cannot be specified for functions\",\n+\t\tdecl);\n       *no_add_attrs = true;\n       break;\n "}, {"sha": "37488b2c14b477b68a91c29a118807152d6127d1", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -4944,8 +4944,7 @@ array_to_constant (enum machine_mode mode, unsigned char arr[16])\n static void\n reloc_diagnostic (rtx x)\n {\n-  tree loc_decl, decl = 0;\n-  const char *msg;\n+  tree decl = 0;\n   if (!flag_pic || !(TARGET_WARN_RELOC || TARGET_ERROR_RELOC))\n     return;\n \n@@ -4959,24 +4958,32 @@ reloc_diagnostic (rtx x)\n   if (decl && !DECL_P (decl))\n     decl = 0;\n \n-  /* We use last_assemble_variable_decl to get line information.  It's\n-     not always going to be right and might not even be close, but will\n-     be right for the more common cases. */\n-  if (!last_assemble_variable_decl || in_section == ctors_section)\n-    loc_decl = decl;\n-  else\n-    loc_decl = last_assemble_variable_decl;\n-\n   /* The decl could be a string constant.  */\n   if (decl && DECL_P (decl))\n-    msg = \"%Jcreating run-time relocation for %qD\";\n-  else\n-    msg = \"creating run-time relocation\";\n+    {\n+      location_t loc;\n+      /* We use last_assemble_variable_decl to get line information.  It's\n+\t not always going to be right and might not even be close, but will\n+\t be right for the more common cases. */\n+      if (!last_assemble_variable_decl || in_section == ctors_section)\n+\tloc = DECL_SOURCE_LOCATION (decl);\n+      else\n+\tloc = DECL_SOURCE_LOCATION (last_assemble_variable_decl);\n \n-  if (TARGET_WARN_RELOC)\n-    warning (0, msg, loc_decl, decl);\n-  else\n-    error (msg, loc_decl, decl);\n+      if (TARGET_WARN_RELOC)\n+\twarning_at (loc, 0,\n+\t\t    \"creating run-time relocation for %qD\", decl);\n+      else\n+\terror_at (loc,\n+\t\t  \"creating run-time relocation for %qD\", decl);\n+    }\n+  else \n+    {\n+      if (TARGET_WARN_RELOC)\n+\twarning_at (input_location, 0, \"creating run-time relocation\");\n+      else\n+\terror_at (input_location, \"creating run-time relocation\");\n+    }\n }\n \n /* Hook into assemble_integer so we can generate an error for run-time"}, {"sha": "5e1594a9be562c61bfdc132ded20088b38091d8f", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -2090,8 +2090,9 @@ v850_handle_data_area_attribute (tree* node,\n     case VAR_DECL:\n       if (current_function_decl != NULL_TREE)\n \t{\n-          error (\"%Jdata area attributes cannot be specified for \"\n-                 \"local variables\", decl);\n+          error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t    \"data area attributes cannot be specified for \"\n+\t\t    \"local variables\");\n \t  *no_add_attrs = true;\n \t}\n "}, {"sha": "15408276d7aaa1f0d514d89c3aad8823bd207b44", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -1,3 +1,11 @@\n+2009-07-07  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\t* init.c: Replace %J by an explicit location. Update all calls.\n+\t* decl.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t\n 2009-07-06  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* decl.c: Replace %H by an explicit location. Update all calls."}, {"sha": "c0dccdc9cc3f8a80f09bca7276ed46befd9c45e8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -1469,8 +1469,9 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t       && TYPE_ARG_TYPES (TREE_TYPE (newdecl)) != NULL_TREE)\n \t{\n \t  /* Prototype decl follows defn w/o prototype.  */\n-\t  warning (0, \"prototype for %q+#D\", newdecl);\n-\t  warning (0, \"%Jfollows non-prototype definition here\", olddecl);\n+\t  warning_at (input_location, 0, \"prototype for %q+#D\", newdecl);\n+\t  warning_at (DECL_SOURCE_LOCATION (olddecl), 0,\n+\t\t      \"follows non-prototype definition here\");\n \t}\n       else if ((TREE_CODE (olddecl) == FUNCTION_DECL\n \t\t|| TREE_CODE (olddecl) == VAR_DECL)\n@@ -2051,10 +2052,10 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       && DECL_VISIBILITY_SPECIFIED (newdecl)\n       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n-      warning (OPT_Wattributes, \"%q+D: visibility attribute ignored \"\n-\t       \"because it\", newdecl);\n-      warning (OPT_Wattributes, \"%Jconflicts with previous \"\n-\t       \"declaration here\", olddecl);\n+      warning_at (input_location, OPT_Wattributes,\n+\t\t  \"%q+D: visibility attribute ignored because it\", newdecl);\n+      warning_at (DECL_SOURCE_LOCATION (olddecl), OPT_Wattributes,\n+\t\t  \"conflicts with previous declaration here\");\n     }\n   /* Choose the declaration which specified visibility.  */\n   if (DECL_VISIBILITY_SPECIFIED (olddecl))\n@@ -2641,7 +2642,7 @@ check_goto (tree decl)\n       if (u > 1 && DECL_ARTIFICIAL (b))\n \t{\n \t  /* Can't skip init of __exception_info.  */\n-\t  error (\"%J  enters catch block\", b);\n+\t  error_at (DECL_SOURCE_LOCATION (b), \"  enters catch block\");\n \t  saw_catch = true;\n \t}\n       else if (u > 1)\n@@ -3795,9 +3796,11 @@ fixup_anonymous_aggr (tree t)\n       tree decl = TYPE_MAIN_DECL (t);\n \n       if (TREE_CODE (t) != UNION_TYPE)\n-\terror (\"%Jan anonymous struct cannot have function members\", decl);\n+\terror_at (DECL_SOURCE_LOCATION (decl), \n+\t\t  \"an anonymous struct cannot have function members\");\n       else\n-\terror (\"%Jan anonymous union cannot have function members\", decl);\n+\terror_at (DECL_SOURCE_LOCATION (decl),\n+\t\t  \"an anonymous union cannot have function members\");\n     }\n \n   /* Anonymous aggregates cannot have fields with ctors, dtors or complex\n@@ -4629,12 +4632,13 @@ maybe_commonize_var (tree decl)\n \t\t be merged.  */\n \t      TREE_PUBLIC (decl) = 0;\n \t      DECL_COMMON (decl) = 0;\n-\t      warning (0, \"sorry: semantics of inline function static \"\n-\t\t       \"data %q+#D are wrong (you'll wind up \"\n-\t\t       \"with multiple copies)\", decl);\n-\t      warning (0, \"%J  you can work around this by removing \"\n-\t\t       \"the initializer\",\n-\t\t       decl);\n+\t      warning_at (input_location, 0,\n+\t\t\t  \"sorry: semantics of inline function static \"\n+\t\t\t  \"data %q+#D are wrong (you'll wind up \"\n+\t\t\t  \"with multiple copies)\", decl);\n+\t      warning_at (DECL_SOURCE_LOCATION (decl), 0, \n+\t\t\t  \"  you can work around this by removing \"\n+\t\t\t  \"the initializer\");\n \t    }\n \t}\n     }\n@@ -8815,7 +8819,8 @@ grokdeclarator (const cp_declarator *declarator,\n       else\n \tdecl = build_decl (input_location, TYPE_DECL, unqualified_id, type);\n       if (id_declarator && declarator->u.id.qualifying_scope) {\n-\terror (\"%Jtypedef name may not be a nested-name-specifier\", decl);\n+\terror_at (DECL_SOURCE_LOCATION (decl), \n+\t\t  \"typedef name may not be a nested-name-specifier\");\n \tTREE_TYPE (decl) = error_mark_node;\n       }\n \n@@ -10996,8 +11001,9 @@ start_enum (tree name, tree underlying_type, bool scoped_enum_p)\n \n   if (enumtype != NULL_TREE && TREE_CODE (enumtype) == ENUMERAL_TYPE)\n     {\n-      error (\"multiple definition of %q#T\", enumtype);\n-      error (\"%Jprevious definition here\", TYPE_MAIN_DECL (enumtype));\n+      error_at (input_location, \"multiple definition of %q#T\", enumtype);\n+      error_at (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (enumtype)),\n+\t\t\"previous definition here\");\n       /* Clear out TYPE_VALUES, and start again.  */\n       TYPE_VALUES (enumtype) = NULL_TREE;\n     }"}, {"sha": "96dd6c1dfadcd28f8357b823fbd10f2db6a51871", "filename": "gcc/cp/init.c", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -426,8 +426,9 @@ perform_member_init (tree member, tree init)\n   /* Effective C++ rule 12 requires that all data members be\n      initialized.  */\n   if (warn_ecpp && init == NULL_TREE && TREE_CODE (type) != ARRAY_TYPE)\n-    warning (OPT_Weffc__, \"%J%qD should be initialized in the member initialization \"\n-\t     \"list\", current_function_decl, member);\n+    warning_at (DECL_SOURCE_LOCATION (current_function_decl), OPT_Weffc__,\n+\t\t\"%qD should be initialized in the member initialization list\",\n+\t\tmember);\n \n   /* Get an lvalue for the data member.  */\n   decl = build_class_member_access_expr (current_class_ref, member,\n@@ -451,9 +452,9 @@ perform_member_init (tree member, tree init)\n       else\n \t{\n \t  if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t    permerror (input_location, \"%Jvalue-initialization of %q#D, \"\n-\t\t\t\t       \"which has reference type\",\n-\t\t       current_function_decl, member);\n+\t    permerror (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t       \"value-initialization of %q#D, which has reference type\",\n+\t\t       member);\n \t  else\n \t    {\n \t      init = build2 (INIT_EXPR, type, decl, build_value_init (type));\n@@ -492,8 +493,9 @@ perform_member_init (tree member, tree init)\n \t      && !type_has_user_provided_default_constructor (type))\n \t    /* TYPE_NEEDS_CONSTRUCTING can be set just because we have a\n \t       vtable; still give this diagnostic.  */\n-\t    permerror (input_location, \"%Juninitialized member %qD with %<const%> type %qT\",\n-\t\t       current_function_decl, member, type);\n+\t    permerror (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t       \"uninitialized member %qD with %<const%> type %qT\",\n+\t\t       member, type);\n \t  finish_expr_stmt (build_aggr_init (decl, init, 0, \n \t\t\t\t\t     tf_warning_or_error));\n \t}\n@@ -504,11 +506,13 @@ perform_member_init (tree member, tree init)\n \t{\n \t  /* member traversal: note it leaves init NULL */\n \t  if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t    permerror (input_location, \"%Juninitialized reference member %qD\",\n-\t\t       current_function_decl, member);\n+\t    permerror (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t       \"uninitialized reference member %qD\",\n+\t\t       member);\n \t  else if (CP_TYPE_CONST_P (type))\n-\t    permerror (input_location, \"%Juninitialized member %qD with %<const%> type %qT\",\n-\t\t       current_function_decl, member, type);\n+\t    permerror (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t       \"uninitialized member %qD with %<const%> type %qT\",\n+\t\t       member, type);\n \t}\n       else if (TREE_CODE (init) == TREE_LIST)\n \t/* There was an explicit member initialization.  Do some work\n@@ -661,7 +665,8 @@ sort_mem_initializers (tree t, tree mem_inits)\n \t    warning (OPT_Wreorder, \"  %q+#D\", subobject);\n \t  else\n \t    warning (OPT_Wreorder, \"  base %qT\", subobject);\n-\t  warning (OPT_Wreorder, \"%J  when initialized here\", current_function_decl);\n+\t  warning_at (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t      OPT_Wreorder, \"  when initialized here\");\n \t}\n \n       /* Look again, from the beginning of the list.  */\n@@ -677,11 +682,13 @@ sort_mem_initializers (tree t, tree mem_inits)\n       if (TREE_VALUE (subobject_init))\n \t{\n \t  if (TREE_CODE (subobject) == FIELD_DECL)\n-\t    error (\"%Jmultiple initializations given for %qD\",\n-\t\t   current_function_decl, subobject);\n+\t    error_at (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t      \"multiple initializations given for %qD\",\n+\t\t      subobject);\n \t  else\n-\t    error (\"%Jmultiple initializations given for base %qT\",\n-\t\t   current_function_decl, subobject);\n+\t    error_at (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t      \"multiple initializations given for base %qT\",\n+\t\t      subobject);\n \t}\n \n       /* Record the initialization.  */\n@@ -747,8 +754,9 @@ sort_mem_initializers (tree t, tree mem_inits)\n \t\t  if (same_type_p (last_field_type, field_type))\n \t\t    {\n \t\t      if (TREE_CODE (field_type) == UNION_TYPE)\n-\t\t\terror (\"%Jinitializations for multiple members of %qT\",\n-\t\t\t       current_function_decl, last_field_type);\n+\t\t\terror_at (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t\t  \"initializations for multiple members of %qT\",\n+\t\t\t\t  last_field_type);\n \t\t      done = 1;\n \t\t      break;\n \t\t    }\n@@ -810,9 +818,10 @@ emit_mem_initializers (tree mem_inits)\n       if (extra_warnings && !arguments\n \t  && DECL_COPY_CONSTRUCTOR_P (current_function_decl)\n \t  && type_has_user_nondefault_constructor (BINFO_TYPE (subobject)))\n-\twarning (OPT_Wextra, \"%Jbase class %q#T should be explicitly initialized in the \"\n-\t\t \"copy constructor\",\n-\t\t current_function_decl, BINFO_TYPE (subobject));\n+\twarning_at (DECL_SOURCE_LOCATION (current_function_decl), OPT_Wextra,\n+\t\t    \"base class %q#T should be explicitly initialized in the \"\n+\t\t    \"copy constructor\",\n+\t\t    BINFO_TYPE (subobject));\n \n       /* Initialize the base.  */\n       if (BINFO_VIRTUAL_P (subobject))"}, {"sha": "c1032e3f80ccb92d91ac542ca383ba3abedbdb7f", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -1044,8 +1044,10 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \n \t      if (warn_shadow && !err)\n \t\t{\n-\t\t  warning (OPT_Wshadow, \"declaration of %q#D shadows a parameter\", x);\n-\t\t  warning (OPT_Wshadow, \"%Jshadowed declaration is here\", oldlocal);\n+\t\t  warning_at (input_location, OPT_Wshadow,\n+\t\t\t      \"declaration of %q#D shadows a parameter\", x);\n+\t\t  warning_at (DECL_SOURCE_LOCATION (oldlocal), OPT_Wshadow,\n+\t\t\t      \"shadowed declaration is here\");\n \t\t}\n \t    }\n \n@@ -1075,16 +1077,19 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t      else if (oldlocal != NULL_TREE\n \t\t       && TREE_CODE (oldlocal) == VAR_DECL)\n \t\t{\n-\t\t  warning (OPT_Wshadow, \"declaration of %qD shadows a previous local\", x);\n-\t\t  warning (OPT_Wshadow, \"%Jshadowed declaration is here\", oldlocal);\n+\t\t  warning_at (input_location, OPT_Wshadow,\n+\t\t\t      \"declaration of %qD shadows a previous local\", x);\n+\t\t  warning_at (DECL_SOURCE_LOCATION (oldlocal), OPT_Wshadow,\n+\t\t\t      \"shadowed declaration is here\");\n \t\t}\n \t      else if (oldglobal != NULL_TREE\n \t\t       && TREE_CODE (oldglobal) == VAR_DECL)\n \t\t/* XXX shadow warnings in outer-more namespaces */\n \t\t{\n-\t\t  warning (OPT_Wshadow, \"declaration of %qD shadows a global declaration\",\n-\t\t\t   x);\n-\t\t  warning (OPT_Wshadow, \"%Jshadowed declaration is here\", oldglobal);\n+\t\t  warning_at (input_location, OPT_Wshadow,\n+\t\t\t      \"declaration of %qD shadows a global declaration\", x);\n+\t\t  warning_at (DECL_SOURCE_LOCATION (oldglobal), OPT_Wshadow,\n+\t\t\t      \"shadowed declaration is here\");\n \t\t}\n \t    }\n \t}"}, {"sha": "2fc2223703c0970e52768bc3f7a9bf7e7c652618", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -4430,8 +4430,9 @@ redeclare_class_template (tree type, tree parms)\n \n \t     A template-parameter may not be given default arguments\n \t     by two different declarations in the same scope.  */\n-\t  error (\"redefinition of default argument for %q#D\", parm);\n-\t  inform (input_location, \"%Joriginal definition appeared here\", tmpl_parm);\n+\t  error_at (input_location, \"redefinition of default argument for %q#D\", parm);\n+\t  inform (DECL_SOURCE_LOCATION (tmpl_parm),\n+\t\t  \"original definition appeared here\");\n \t  return false;\n \t}\n "}, {"sha": "c43fd763dc07ca4df70aa1b6d345d4cd70a25d9e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -312,8 +312,9 @@ abstract_virtuals_error (tree decl, tree type)\n       unsigned ix;\n       tree fn;\n \n-      inform (input_location, \"%J  because the following virtual functions are pure \"\n-\t      \"within %qT:\", TYPE_MAIN_DECL (type), type);\n+      inform (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type)),\n+\t      \"  because the following virtual functions are pure within %qT:\",\n+\t      type);\n \n       for (ix = 0; VEC_iterate (tree, pure, ix, fn); ix++)\n \tinform (input_location, \"\\t%+#D\", fn);\n@@ -323,8 +324,9 @@ abstract_virtuals_error (tree decl, tree type)\n       VEC_truncate (tree, pure, 0);\n     }\n   else\n-    inform (input_location, \"%J  since type %qT has pure virtual functions\",\n-\t    TYPE_MAIN_DECL (type), type);\n+    inform (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type)),\n+\t    \"  since type %qT has pure virtual functions\",\n+\t    type);\n \n   return 1;\n }"}, {"sha": "93244dba76b5e7609080c08ca3a137912d5cddfa", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -246,7 +246,8 @@ frame_offset_overflow (HOST_WIDE_INT offset, tree func)\n \t       /* Leave room for the fixed part of the frame.  */\n \t       - 64 * UNITS_PER_WORD)\n     {\n-      error (\"%Jtotal size of local objects too large\", func);\n+      error_at (DECL_SOURCE_LOCATION (func),\n+\t\t\"total size of local objects too large\");\n       return TRUE;\n     }\n "}, {"sha": "9f90f53b4d680f7ac89c1ac4481d11120392c07d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -1,3 +1,7 @@\n+2009-07-07  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\t* class.c: Replace %J by an explicit location. Update all calls.\n+\t\n 2009-07-07  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* jcf-parse.c: Replace %H by an explicit location. Update all calls."}, {"sha": "db9c8a8e88cd54e456a7b6f701c3ee2b549e48e4", "filename": "gcc/java/class.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -1609,7 +1609,8 @@ get_dispatch_table (tree type, tree this_class_addr)\n       if (METHOD_ABSTRACT (method))\n \t{\n \t  if (! abstract_p)\n-\t    warning (0, \"%Jabstract method in non-abstract class\", method);\n+\t    warning_at (DECL_SOURCE_LOCATION (method), 0,\n+\t\t\t\"abstract method in non-abstract class\");\n \n \t  if (TARGET_VTABLE_USES_DESCRIPTORS)\n \t    for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)"}, {"sha": "2268413b508e7564a3199391f4dc6e6194189b9a", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -1,3 +1,8 @@\n+2009-07-07  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\t* objc-act.c: Replace %J by an explicit location. Update all\n+\tcalls.\n+\t\n 2009-07-07  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* objc-act.c: Replace %H by an explicit location. Update all"}, {"sha": "917caf1fbe2e7807125088da7bcede8aeab04c1f", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -5015,8 +5015,8 @@ synth_forward_declarations (void)\n static void\n error_with_ivar (const char *message, tree decl)\n {\n-  error (\"%J%s %qs\", decl,\n-         message, identifier_to_locale (gen_declaration (decl)));\n+  error_at (DECL_SOURCE_LOCATION (decl), \"%s %qs\",\n+\t    message, identifier_to_locale (gen_declaration (decl)));\n \n }\n \n@@ -6150,21 +6150,23 @@ check_duplicates (hash hsh, int methods, int is_class)\n \t    {\n \t      bool type = TREE_CODE (meth) == INSTANCE_METHOD_DECL;\n \n-\t      warning (0, \"multiple methods named %<%c%E%> found\",\n-\t\t       (is_class ? '+' : '-'),\n-\t\t       METHOD_SEL_NAME (meth));\n-\t      inform (0, \"%Jusing %<%c%s%>\", meth,\n+\t      warning_at (input_location, 0,\n+\t\t\t  \"multiple methods named %<%c%E%> found\",\n+\t\t\t  (is_class ? '+' : '-'),\n+\t\t\t  METHOD_SEL_NAME (meth));\n+\t      inform (DECL_SOURCE_LOCATION (meth), \"using %<%c%s%>\",\n \t\t      (type ? '-' : '+'),\n \t\t      identifier_to_locale (gen_method_decl (meth)));\n \t    }\n \t  else\n \t    {\n \t      bool type = TREE_CODE (meth) == INSTANCE_METHOD_DECL;\n \n-\t      warning (0, \"multiple selectors named %<%c%E%> found\",\n-\t\t       (is_class ? '+' : '-'),\n-\t\t       METHOD_SEL_NAME (meth));\n-\t      inform (0, \"%Jfound %<%c%s%>\", meth,\n+\t      warning_at (input_location, 0,\n+\t\t\t  \"multiple selectors named %<%c%E%> found\",\n+\t\t\t  (is_class ? '+' : '-'),\n+\t\t\t  METHOD_SEL_NAME (meth));\n+\t      inform (DECL_SOURCE_LOCATION (meth), \"found %<%c%s%>\",\n \t\t      (type ? '-' : '+'),\n \t\t      identifier_to_locale (gen_method_decl (meth)));\n \t    }\n@@ -6173,7 +6175,7 @@ check_duplicates (hash hsh, int methods, int is_class)\n \t    {\n \t      bool type = TREE_CODE (loop->value) == INSTANCE_METHOD_DECL;\n \n-\t      inform (0, \"%Jalso found %<%c%s%>\", loop->value, \n+\t      inform (DECL_SOURCE_LOCATION (loop->value), \"also found %<%c%s%>\",\n \t\t      (type ? '-' : '+'),\n \t\t      identifier_to_locale (gen_method_decl (loop->value)));\n \t    }\n@@ -8733,10 +8735,12 @@ really_start_method (tree method,\n \t    {\n \t      bool type = TREE_CODE (method) == INSTANCE_METHOD_DECL;\n \n-\t      warning (0, \"%Jconflicting types for %<%c%s%>\", method,\n-\t\t       (type ? '-' : '+'),\n-\t\t       identifier_to_locale (gen_method_decl (method)));\n-\t      inform (0, \"%Jprevious declaration of %<%c%s%>\", proto,\n+\t      warning_at (DECL_SOURCE_LOCATION (method), 0,\n+\t\t\t  \"conflicting types for %<%c%s%>\",\n+\t\t\t  (type ? '-' : '+'),\n+\t\t\t  identifier_to_locale (gen_method_decl (method)));\n+\t      inform (DECL_SOURCE_LOCATION (proto),\n+\t\t      \"previous declaration of %<%c%s%>\",\n \t\t      (type ? '-' : '+'),\n \t\t      identifier_to_locale (gen_method_decl (proto)));\n \t    }"}, {"sha": "f18bb97848768e1d9ddde539a65a361c41a14d9e", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -7342,9 +7342,9 @@ execute_warn_function_noreturn (void)\n       && !TREE_THIS_VOLATILE (cfun->decl)\n       && EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 0\n       && !lang_hooks.missing_noreturn_ok_p (cfun->decl))\n-    warning (OPT_Wmissing_noreturn, \"%Jfunction might be possible candidate \"\n-\t     \"for attribute %<noreturn%>\",\n-\t     cfun->decl);\n+    warning_at (DECL_SOURCE_LOCATION (cfun->decl), OPT_Wmissing_noreturn,\n+\t\t\"function might be possible candidate \"\n+\t\t\"for attribute %<noreturn%>\");\n   return 0;\n }\n "}, {"sha": "c8a48a3b227691958aa075d8420526c0098f0f8b", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -1270,7 +1270,7 @@ warn_uninit (tree t, const char *gmsgid, void *data)\n       if (xloc.file != floc.file\n \t  || xloc.line < floc.line\n \t  || xloc.line > LOCATION_LINE (cfun->function_end_locus))\n-\tinform (location, \"%J%qD was declared here\", var, var);\n+\tinform (DECL_SOURCE_LOCATION (var), \"%qD was declared here\", var);\n     }\n }\n "}, {"sha": "f8744f72846f42452e5fe87e3f4d860b82db538b", "filename": "gcc/varasm.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d753640d06e51da60056f0ee354b5134cad1f7/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=c5d753640d06e51da60056f0ee354b5134cad1f7", "patch": "@@ -5465,7 +5465,8 @@ do_assemble_alias (tree decl, tree target)\n #else\n       if (!SUPPORTS_WEAK)\n \t{\n-\t  error (\"%Jweakref is not supported in this configuration\", decl);\n+\t  error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t    \"weakref is not supported in this configuration\");\n \t  return;\n \t}\n #endif\n@@ -5605,12 +5606,14 @@ assemble_alias (tree decl, tree target)\n     {\n #if !defined (ASM_OUTPUT_DEF)\n # if !defined(ASM_OUTPUT_WEAK_ALIAS) && !defined (ASM_WEAKEN_DECL)\n-      error (\"%Jalias definitions not supported in this configuration\", decl);\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"alias definitions not supported in this configuration\");\n       return;\n # else\n       if (!DECL_WEAK (decl))\n \t{\n-\t  error (\"%Jonly weak aliases are supported in this configuration\", decl);\n+\t  error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t    \"only weak aliases are supported in this configuration\");\n \t  return;\n \t}\n # endif"}]}