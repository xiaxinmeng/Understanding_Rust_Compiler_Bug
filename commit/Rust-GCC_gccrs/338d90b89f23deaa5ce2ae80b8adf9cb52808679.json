{"sha": "338d90b89f23deaa5ce2ae80b8adf9cb52808679", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM4ZDkwYjg5ZjIzZGVhYTVjZTJhZTgwYjhhZGY5Y2I1MjgwODY3OQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-11-25T13:21:45Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-11-25T13:21:45Z"}, "message": "re PR c++/3145 (virtual inheritance still creates wrong code)\n\ncp:\n\tPR g++/3145\n\t* class.c (build_vbase_pointer): Remove.\n\t(build_vbase_path): Remove.\n\t(build_base_path): New function.\n\t* cp-tree.h (base_access, base_kind): New enumerations.\n\t(build_base_path): Declare.\n\t(convert_pointer_to_real): Remove.\n\t(convert_pointer_to): Remove.\n\t(lookup_base): Declare.\n\t(convert_pointer_to_vbase): Remove.\n\t* call.c (build_scoped_method_call): Use lookup_base &\n\tbuild_base_path instead of convert_pointer_to_real,\n\tget_base_distance & get_binfo.\n\t(build_over_call): Likewise.\n\t* cvt.c (cp_convert_to_pointer): Likewise.\n\t(convert_to_pointer_force): Likewise.\n\t(build_up_reference): Likewise.\n\t(convert_pointer_to_real): Remove.\n\t(convert_pointer_to): Remove.\n\t* init.c (dfs_initialize_vtbl_ptrs): Use build_base_path\n\tinstead of convert_pointer_to_vbase & build_vbase_path.\n\t(emit_base_init): Use build_base_path instead of\n\tconvert_pointer_to_real.\n\t(expand_virtual_init): Lose unrequired conversions.\n\t(resolve_offset_ref): Use lookup_base and build_base_path\n\tinstead of convert_pointer_to.\n\t* rtti.c (build_dynamic_cast_1): Use lookup_base &\n\tbuild_base_path instead of get_base_distance & build_vbase_path.\n\t* search.c (get_vbase_1): Remove.\n\t(get_vbase): Remove.\n\t(convert_pointer_to_vbase): Remove.\n\t(lookup_base_recursive): New function.\n\t(lookup_base): New function.\n\t* typeck.c (require_complete_type): Use lookup_base &\n\tbuild_base_path instead of convert_pointer_to.\n\t(build_component_ref): Likewise.\n\t(build_x_function_call): Likewise.\n\t(get_member_function_from_ptrfunc): Likewise.\n\t(build_component_addr): Likewise.\n\t* typeck2.c (build_scoped_ref): Likewise.\ntestsuite:\n\t* g++.dg/abi/vbase8-4.C: New test.\n\nFrom-SVN: r47316", "tree": {"sha": "0d461fab9e84fd53ebc0b813e9c60b27eb83f6e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d461fab9e84fd53ebc0b813e9c60b27eb83f6e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/338d90b89f23deaa5ce2ae80b8adf9cb52808679", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/338d90b89f23deaa5ce2ae80b8adf9cb52808679", "html_url": "https://github.com/Rust-GCC/gccrs/commit/338d90b89f23deaa5ce2ae80b8adf9cb52808679", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/338d90b89f23deaa5ce2ae80b8adf9cb52808679/comments", "author": null, "committer": null, "parents": [{"sha": "92fa4733ab20d5f4a8e9eb7c6f5c924427677549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92fa4733ab20d5f4a8e9eb7c6f5c924427677549", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92fa4733ab20d5f4a8e9eb7c6f5c924427677549"}], "stats": {"total": 1038, "additions": 568, "deletions": 470}, "files": [{"sha": "3512f20ae8c6da61da0dc39d0387a566f27c9cc7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -1,3 +1,46 @@\n+2001-11-25  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR g++/3145\n+\t* class.c (build_vbase_pointer): Remove.\n+\t(build_vbase_path): Remove.\n+\t(build_base_path): New function.\n+\t* cp-tree.h (base_access, base_kind): New enumerations.\n+\t(build_base_path): Declare.\n+\t(convert_pointer_to_real): Remove.\n+\t(convert_pointer_to): Remove.\n+\t(lookup_base): Declare.\n+\t(convert_pointer_to_vbase): Remove.\n+\t* call.c (build_scoped_method_call): Use lookup_base &\n+\tbuild_base_path instead of convert_pointer_to_real,\n+\tget_base_distance & get_binfo.\n+\t(build_over_call): Likewise.\n+\t* cvt.c (cp_convert_to_pointer): Likewise.\n+\t(convert_to_pointer_force): Likewise.\n+\t(build_up_reference): Likewise.\n+\t(convert_pointer_to_real): Remove.\n+\t(convert_pointer_to): Remove.\n+\t* init.c (dfs_initialize_vtbl_ptrs): Use build_base_path\n+\tinstead of convert_pointer_to_vbase & build_vbase_path.\n+\t(emit_base_init): Use build_base_path instead of\n+\tconvert_pointer_to_real.\n+\t(expand_virtual_init): Lose unrequired conversions.\n+\t(resolve_offset_ref): Use lookup_base and build_base_path\n+\tinstead of convert_pointer_to.\n+\t* rtti.c (build_dynamic_cast_1): Use lookup_base &\n+\tbuild_base_path instead of get_base_distance & build_vbase_path.\n+\t* search.c (get_vbase_1): Remove.\n+\t(get_vbase): Remove.\n+\t(convert_pointer_to_vbase): Remove.\n+\t(lookup_base_recursive): New function.\n+\t(lookup_base): New function.\n+\t* typeck.c (require_complete_type): Use lookup_base &\n+\tbuild_base_path instead of convert_pointer_to.\n+\t(build_component_ref): Likewise.\n+\t(build_x_function_call): Likewise.\n+\t(get_member_function_from_ptrfunc): Likewise.\n+\t(build_component_addr): Likewise.\n+\t* typeck2.c (build_scoped_ref): Likewise.\n+\n 2001-11-22  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* cp-tree.h (CP_TYPE_QUALS): Removed."}, {"sha": "c0ab2c2191d1d19e981111c16f64e736f425f616", "filename": "gcc/cp/call.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -298,7 +298,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n \n   if (! binfo)\n     {\n-      binfo = get_binfo (basetype, type, 1);\n+      binfo = lookup_base (type, basetype, ba_check, NULL);\n       if (binfo == error_mark_node)\n \treturn error_mark_node;\n       if (! binfo)\n@@ -308,9 +308,12 @@ build_scoped_method_call (exp, basetype, name, parms)\n   if (binfo)\n     {\n       if (TREE_CODE (exp) == INDIRECT_REF)\n-\tdecl = build_indirect_ref\n-\t  (convert_pointer_to_real\n-\t   (binfo, build_unary_op (ADDR_EXPR, exp, 0)), NULL);\n+\t{\n+\t  decl = build_base_path (PLUS_EXPR,\n+\t\t\t\t  build_unary_op (ADDR_EXPR, exp, 0),\n+\t\t\t\t  binfo, 1);\n+\t  decl = build_indirect_ref (decl, NULL);\n+\t}\n       else\n \tdecl = build_scoped_ref (exp, basetype);\n \n@@ -4157,7 +4160,9 @@ build_over_call (cand, args, flags)\n          So we can assume that anything passed as 'this' is non-null, and\n \t optimize accordingly.  */\n       my_friendly_assert (TREE_CODE (parmtype) == POINTER_TYPE, 19990811);\n-      t = convert_pointer_to_real (TREE_TYPE (parmtype), TREE_VALUE (arg));\n+      t = lookup_base (TREE_TYPE (TREE_TYPE (TREE_VALUE (arg))),\n+\t\t       TREE_TYPE (parmtype), ba_ignore, NULL);\n+      t = build_base_path (PLUS_EXPR, TREE_VALUE (arg), t, 1);\n       converted_args = tree_cons (NULL_TREE, t, converted_args);\n       parm = TREE_CHAIN (parm);\n       arg = TREE_CHAIN (arg);\n@@ -4307,9 +4312,12 @@ build_over_call (cand, args, flags)\n   if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n     {\n       tree t, *p = &TREE_VALUE (converted_args);\n-      tree binfo = get_binfo\n-\t(DECL_VIRTUAL_CONTEXT (fn), TREE_TYPE (TREE_TYPE (*p)), 0);\n-      *p = convert_pointer_to_real (binfo, *p);\n+      tree binfo = lookup_base (TREE_TYPE (TREE_TYPE (*p)),\n+\t\t\t\tDECL_VIRTUAL_CONTEXT (fn),\n+\t\t\t\tba_any, NULL);\n+      my_friendly_assert (binfo && binfo != error_mark_node, 20010730);\n+      \n+      *p = build_base_path (PLUS_EXPR, *p, binfo, 1);\n       if (TREE_SIDE_EFFECTS (*p))\n \t*p = save_expr (*p);\n       t = build_pointer_type (TREE_TYPE (fn));"}, {"sha": "3afaf5d75da8597c546661405b3bc8f6e47945dc", "filename": "gcc/cp/class.c", "status": "modified", "additions": 101, "deletions": 169, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -106,7 +106,6 @@ varray_type local_classes;\n \n static tree get_vfield_name PARAMS ((tree));\n static void finish_struct_anon PARAMS ((tree));\n-static tree build_vbase_pointer PARAMS ((tree, tree));\n static tree build_vtable_entry PARAMS ((tree, tree, tree));\n static tree get_vtable_name PARAMS ((tree));\n static tree get_basefndecls PARAMS ((tree, tree));\n@@ -236,190 +235,122 @@ int n_build_method_call = 0;\n int n_inner_fields_searched = 0;\n #endif\n \n-/* Virtual base class layout.  */\n-\n-/* Returns a pointer to the virtual base class of EXP that has the\n-   indicated TYPE.  EXP is of class type, not a pointer type.  */\n-\n-static tree\n-build_vbase_pointer (exp, type)\n-     tree exp, type;\n-{\n-  tree vbase;\n-  tree vbase_ptr;\n-\n-  /* Find the shared copy of TYPE; that's where the vtable offset is\n-     recorded.  */\n-  vbase = binfo_for_vbase (type, TREE_TYPE (exp));\n-  /* Find the virtual function table pointer.  */\n-  vbase_ptr = build_vfield_ref (exp, TREE_TYPE (exp));\n-  /* Compute the location where the offset will lie.  */\n-  vbase_ptr = build (PLUS_EXPR, \n-\t\t     TREE_TYPE (vbase_ptr),\n-\t\t     vbase_ptr,\n-\t\t     BINFO_VPTR_FIELD (vbase));\n-  vbase_ptr = build1 (NOP_EXPR, \n-\t\t      build_pointer_type (ptrdiff_type_node),\n-\t\t      vbase_ptr);\n-  /* Add the contents of this location to EXP.  */\n-  return build (PLUS_EXPR,\n-\t\tbuild_pointer_type (type),\n-\t\tbuild_unary_op (ADDR_EXPR, exp, /*noconvert=*/0),\n-\t\tbuild1 (INDIRECT_REF, ptrdiff_type_node, vbase_ptr));\n-}\n-\n-/* Build multi-level access to EXPR using hierarchy path PATH.\n-   CODE is PLUS_EXPR if we are going with the grain,\n-   and MINUS_EXPR if we are not (in which case, we cannot traverse\n-   virtual baseclass links).\n-\n-   TYPE is the type we want this path to have on exit.\n-\n-   NONNULL is non-zero if  we know (for any reason) that EXPR is\n-   not, in fact, zero.  */\n+/* Convert to or from a base subobject.  EXPR is an expression of type\n+   `A' or `A*', an expression of type `B' or `B*' is returned.  To\n+   convert A to a base B, CODE is PLUS_EXPR and BINFO is the binfo for\n+   the B base instance within A.  To convert base A to derived B, CODE\n+   is MINUS_EXPR and BINFO is the binfo for the A instance within B.\n+   In this latter case, A must not be a morally virtual base of B.\n+   NONNULL is true if EXPR is known to be non-NULL (this is only\n+   needed when EXPR is of pointer type).  CV qualifiers are preserved\n+   from EXPR.  */\n \n tree\n-build_vbase_path (code, type, expr, path, nonnull)\n+build_base_path (code, expr, binfo, nonnull)\n      enum tree_code code;\n-     tree type, expr, path;\n+     tree expr;\n+     tree binfo;\n      int nonnull;\n {\n-  register int changed = 0;\n-  tree last = NULL_TREE, last_virtual = NULL_TREE;\n+  tree v_binfo = NULL_TREE;\n+  tree t;\n+  tree probe;\n+  tree offset;\n+  tree target_type;\n+  tree null_test = NULL;\n+  tree ptr_target_type;\n   int fixed_type_p;\n-  tree null_expr = 0, nonnull_expr;\n-  tree basetype;\n-  tree offset = integer_zero_node;\n+  int want_pointer = TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE;\n \n-  if (BINFO_INHERITANCE_CHAIN (path) == NULL_TREE)\n-    return build1 (NOP_EXPR, type, expr);\n+  if (expr == error_mark_node || binfo == error_mark_node || !binfo)\n+    return error_mark_node;\n+  \n+  for (probe = binfo; probe;\n+       t = probe, probe = BINFO_INHERITANCE_CHAIN (probe))\n+    if (!v_binfo && TREE_VIA_VIRTUAL (probe))\n+      v_binfo = probe;\n+\n+  probe = TYPE_MAIN_VARIANT (TREE_TYPE (expr));\n+  if (want_pointer)\n+    probe = TYPE_MAIN_VARIANT (TREE_TYPE (probe));\n+  \n+  my_friendly_assert (code == MINUS_EXPR\n+\t\t      ? same_type_p (BINFO_TYPE (binfo), probe)\n+\t\t      : code == PLUS_EXPR\n+\t\t      ? same_type_p (BINFO_TYPE (t), probe)\n+\t\t      : false, 20010723);\n+  \n+  if (code == MINUS_EXPR && v_binfo)\n+    {\n+      cp_error (\"cannot convert from base `%T' to derived type `%T' via virtual base `%T'\",\n+\t\tBINFO_TYPE (binfo), BINFO_TYPE (t), BINFO_TYPE (v_binfo));\n+      return error_mark_node;\n+    }\n \n-  /* We could do better if we had additional logic to convert back to the\n-     unconverted type (the static type of the complete object), and then\n-     convert back to the type we want.  Until that is done, we only optimize\n-     if the complete type is the same type as expr has.  */\n   fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n   if (fixed_type_p < 0)\n     /* Virtual base layout is not fixed, even in ctors and dtors. */\n     fixed_type_p = 0;\n-\n   if (!fixed_type_p && TREE_SIDE_EFFECTS (expr))\n     expr = save_expr (expr);\n-  nonnull_expr = expr;\n-\n-  path = reverse_path (path);\n-\n-  basetype = BINFO_TYPE (path);\n-\n-  while (path)\n+    \n+  if (!want_pointer)\n+    expr = build_unary_op (ADDR_EXPR, expr, 0);\n+  else if (!nonnull)\n+    null_test = build (EQ_EXPR, boolean_type_node, expr, integer_zero_node);\n+  \n+  offset = BINFO_OFFSET (binfo);\n+  \n+  if (v_binfo && !fixed_type_p)\n     {\n-      if (TREE_VIA_VIRTUAL (TREE_VALUE (path)))\n-\t{\n-\t  last_virtual = BINFO_TYPE (TREE_VALUE (path));\n-\t  if (code == PLUS_EXPR)\n-\t    {\n-\t      changed = ! fixed_type_p;\n-\n-\t      if (changed)\n-\t\t{\n-\t\t  tree ind;\n-\n-\t\t  /* We already check for ambiguous things in the caller, just\n-\t\t     find a path.  */\n-\t\t  if (last)\n-\t\t    {\n-\t\t      tree binfo = get_binfo (last, TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (nonnull_expr))), 0);\n-\t\t      nonnull_expr = convert_pointer_to_real (binfo, nonnull_expr);\n-\t\t    }\n-\t\t  ind = build_indirect_ref (nonnull_expr, NULL);\n-\t\t  nonnull_expr = build_vbase_pointer (ind, last_virtual);\n-\t\t  if (nonnull == 0\n-\t\t      && TREE_CODE (type) == POINTER_TYPE\n-\t\t      && null_expr == NULL_TREE)\n-\t\t    {\n-\t\t      null_expr = build1 (NOP_EXPR, build_pointer_type (last_virtual), integer_zero_node);\n-\t\t      expr = build (COND_EXPR, build_pointer_type (last_virtual),\n-\t\t\t\t    build (EQ_EXPR, boolean_type_node, expr,\n-\t\t\t\t\t   integer_zero_node),\n-\t\t\t\t    null_expr, nonnull_expr);\n-\t\t    }\n-\t\t}\n-\t      /* else we'll figure out the offset below.  */\n-\n-\t      /* Happens in the case of parse errors.  */\n-\t      if (nonnull_expr == error_mark_node)\n-\t\treturn error_mark_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      cp_error (\"cannot cast up from virtual baseclass `%T'\",\n-\t\t\t  last_virtual);\n-\t      return error_mark_node;\n-\t    }\n-\t}\n-      last = TREE_VALUE (path);\n-      path = TREE_CHAIN (path);\n-    }\n-  /* LAST is now the last basetype assoc on the path.  */\n+      /* Going via virtual base V_BINFO.  We need the static offset\n+         from V_BINFO to BINFO, and the dynamic offset from T to\n+         V_BINFO.  That offset is an entry in T's vtable.  */\n+      tree v_offset = build_vfield_ref (build_indirect_ref (expr, NULL),\n+\t\t\t\t\tTREE_TYPE (TREE_TYPE (expr)));\n+      \n+      v_binfo = binfo_for_vbase (BINFO_TYPE (v_binfo), BINFO_TYPE (t));\n+      \n+      v_offset = build (PLUS_EXPR, TREE_TYPE (v_offset),\n+\t\t\tv_offset,  BINFO_VPTR_FIELD (v_binfo));\n+      v_offset = build1 (NOP_EXPR, \n+\t\t\t build_pointer_type (ptrdiff_type_node),\n+\t\t\t v_offset);\n+      v_offset = build_indirect_ref (v_offset, NULL);\n+      \n+      offset = cp_convert (ptrdiff_type_node,\n+\t\t\t   size_diffop (offset, BINFO_OFFSET (v_binfo)));\n \n-  /* A pointer to a virtual base member of a non-null object\n-     is non-null.  Therefore, we only need to test for zeroness once.\n-     Make EXPR the canonical expression to deal with here.  */\n-  if (null_expr)\n-    {\n-      TREE_OPERAND (expr, 2) = nonnull_expr;\n-      TREE_TYPE (expr) = TREE_TYPE (TREE_OPERAND (expr, 1))\n-\t= TREE_TYPE (nonnull_expr);\n+      if (!integer_zerop (offset))\n+\toffset = build (code, ptrdiff_type_node, v_offset, offset);\n+      else\n+\toffset = v_offset;\n     }\n-  else\n-    expr = nonnull_expr;\n \n-  /* If we go through any virtual base pointers, make sure that\n-     casts to BASETYPE from the last virtual base class use\n-     the right value for BASETYPE.  */\n-  if (changed)\n-    {\n-      tree intype = TREE_TYPE (TREE_TYPE (expr));\n+  target_type = code == PLUS_EXPR ? BINFO_TYPE (binfo) : BINFO_TYPE (t);\n+  \n+  target_type = cp_build_qualified_type\n+    (target_type, cp_type_quals (TREE_TYPE (TREE_TYPE (expr))));\n+  ptr_target_type = build_pointer_type (target_type);\n+  if (want_pointer)\n+    target_type = ptr_target_type;\n+  \n+  expr = build1 (NOP_EXPR, ptr_target_type, expr);\n \n-      if (TYPE_MAIN_VARIANT (intype) != BINFO_TYPE (last))\n-\toffset\n-\t  = BINFO_OFFSET (get_binfo (last, TYPE_MAIN_VARIANT (intype), 0));\n-    }\n+  if (!integer_zerop (offset))\n+    expr = build (code, ptr_target_type, expr, offset);\n   else\n-    offset = BINFO_OFFSET (last);\n-\n-  if (! integer_zerop (offset))\n-    {\n-      /* Bash types to make the backend happy.  */\n-      offset = cp_convert (type, offset);\n-\n-      /* If expr might be 0, we need to preserve that zeroness.  */\n-      if (nonnull == 0)\n-\t{\n-\t  if (null_expr)\n-\t    TREE_TYPE (null_expr) = type;\n-\t  else\n-\t    null_expr = build1 (NOP_EXPR, type, integer_zero_node);\n-\t  if (TREE_SIDE_EFFECTS (expr))\n-\t    expr = save_expr (expr);\n-\n-\t  return build (COND_EXPR, type,\n-\t\t\tbuild (EQ_EXPR, boolean_type_node, expr, integer_zero_node),\n-\t\t\tnull_expr,\n-\t\t\tbuild (code, type, expr, offset));\n-\t}\n-      else return build (code, type, expr, offset);\n-    }\n+    null_test = NULL;\n+  \n+  if (!want_pointer)\n+    expr = build_indirect_ref (expr, NULL);\n \n-  /* Cannot change the TREE_TYPE of a NOP_EXPR here, since it may\n-     be used multiple times in initialization of multiple inheritance.  */\n-  if (null_expr)\n-    {\n-      TREE_TYPE (expr) = type;\n-      return expr;\n-    }\n-  else\n-    return build1 (NOP_EXPR, type, expr);\n+  if (null_test)\n+    expr = build (COND_EXPR, target_type, null_test,\n+\t\t  build1 (NOP_EXPR, target_type, integer_zero_node),\n+\t\t  expr);\n+  \n+  return expr;\n }\n \n \f\n@@ -5468,11 +5399,12 @@ fixed_type_or_null (instance, nonnull, cdtorp)\n     }\n }\n \n-/* Return non-zero if the dynamic type of INSTANCE is known, and equivalent\n-   to the static type.  We also handle the case where INSTANCE is really\n-   a pointer. Return negative if this is a ctor/dtor. There the dynamic type\n-   is known, but this might not be the most derived base of the original object,\n-   and hence virtual bases may not be layed out according to this type.\n+/* Return non-zero if the dynamic type of INSTANCE is known, and\n+   equivalent to the static type.  We also handle the case where\n+   INSTANCE is really a pointer. Return negative if this is a\n+   ctor/dtor. There the dynamic type is known, but this might not be\n+   the most derived base of the original object, and hence virtual\n+   bases may not be layed out according to this type.\n \n    Used to determine whether the virtual function table is needed\n    or not."}, {"sha": "f82e4fe901b7e2e559f7ac3b531bc5d365ca3535", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -3018,6 +3018,29 @@ typedef enum instantiate_type_flags {\n   itf_ptrmem_ok = 1 << 2,     /* pointers to member ok (internal use) */\n } instantiate_type_flags;\n \n+/* The kind of checking we can do looking in a class heirarchy. */\n+typedef enum base_access {\n+  ba_any = -2,     /* Do not check access, allow an ambiguous base,\n+\t\t      prefer a non-virtual base */\n+  ba_ignore = -1,  /* Do not check access */\n+  ba_check = 0,    /* Check access */\n+  ba_not_special   /* Do not consider special privilege\n+\t\t      current_class_type might give. */\n+} base_access;\n+\n+/* The kind of base we can find, looking in a class heirarchy.\n+   values <0 indicate we failed. */\n+typedef enum base_kind {\n+  bk_inaccessible = -3,   /* The base is inaccessible */\n+  bk_ambig = -2,          /* The base is ambiguous */\n+  bk_not_base = -1,       /* It is not a base */\n+  bk_same_type = 0,       /* It is the same type */\n+  bk_proper_base = 1,     /* It is a proper base */\n+  bk_via_virtual = 2      /* It is a proper base, but via a virtual\n+\t\t\t     path. This might not be the canonical\n+\t\t\t     binfo. */\n+} base_kind;\n+\n /* Nonzero means allow Microsoft extensions without a pedwarn.  */\n extern int flag_ms_extensions;\n \n@@ -3508,6 +3531,7 @@ extern tree strip_top_quals                     PARAMS ((tree));\n extern tree perform_implicit_conversion         PARAMS ((tree, tree));\n \n /* in class.c */\n+extern tree build_base_path\t\t\tPARAMS ((enum tree_code, tree, tree, int));\n extern tree build_vbase_path\t\t\tPARAMS ((enum tree_code, tree, tree, tree, int));\n extern tree build_vtbl_ref\t\t\tPARAMS ((tree, tree));\n extern tree build_vfn_ref\t\t\tPARAMS ((tree, tree));\n@@ -3554,8 +3578,6 @@ extern tree get_primary_binfo                   PARAMS ((tree));\n extern tree convert_to_reference\t\tPARAMS ((tree, tree, int, int, tree));\n extern tree convert_from_reference\t\tPARAMS ((tree));\n extern tree convert_lvalue\t\t\tPARAMS ((tree, tree));\n-extern tree convert_pointer_to_real\t\tPARAMS ((tree, tree));\n-extern tree convert_pointer_to\t\t\tPARAMS ((tree, tree));\n extern tree ocp_convert\t\t\t\tPARAMS ((tree, tree, int, int));\n extern tree cp_convert\t\t\t\tPARAMS ((tree, tree));\n extern tree convert_to_void\t\t\tPARAMS ((tree, const char */*implicit context*/));\n@@ -3980,6 +4002,7 @@ extern int tinfo_decl_p                         PARAMS((tree, void *));\n extern int emit_tinfo_decl                      PARAMS((tree *, void *));\n \n /* in search.c */\n+extern tree lookup_base PARAMS ((tree, tree, base_access, base_kind *));\n extern int types_overlap_p\t\t\tPARAMS ((tree, tree));\n extern tree get_vbase\t\t\t\tPARAMS ((tree, tree));\n extern tree get_binfo\t\t\t\tPARAMS ((tree, tree, int));\n@@ -4030,7 +4053,6 @@ extern tree dfs_marked_real_bases_queue_p       PARAMS ((tree, void *));\n extern tree dfs_skip_vbases                     PARAMS ((tree, void *));\n extern tree marked_vtable_pathp                 PARAMS ((tree, void *));\n extern tree unmarked_vtable_pathp               PARAMS ((tree, void *));\n-extern tree convert_pointer_to_vbase            PARAMS ((tree, tree));\n extern tree find_vbase_instance                 PARAMS ((tree, tree));\n extern tree binfo_for_vbase                     PARAMS ((tree, tree));\n extern tree binfo_via_virtual                   PARAMS ((tree, tree));"}, {"sha": "e2b9f3932534ebbd3026f741f8e4ea459ea01380", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 54, "deletions": 153, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -141,44 +141,35 @@ cp_convert_to_pointer (type, expr, force)\n \t  && TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n \t  && IS_AGGR_TYPE (TREE_TYPE (type))\n \t  && IS_AGGR_TYPE (TREE_TYPE (intype))\n-\t  && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE\n-\t  /* If EXPR is NULL, then we don't need to do any arithmetic\n-\t     to convert it:\n-\n-\t       [conv.ptr]\n-\n-\t       The null pointer value is converted to the null pointer\n-\t       value of the destination type.  */\n-\t  && !integer_zerop (expr))\n+\t  && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE)\n \t{\n \t  enum tree_code code = PLUS_EXPR;\n-\t  tree binfo = get_binfo (TREE_TYPE (type), TREE_TYPE (intype), 1);\n-\t  if (binfo == error_mark_node)\n-\t    return error_mark_node;\n-\t  if (binfo == NULL_TREE)\n+\t  tree binfo;\n+\n+\t  /* Try derived to base conversion. */\n+\t  binfo = lookup_base (TREE_TYPE (intype), TREE_TYPE (type),\n+\t\t\t       ba_check, NULL);\n+\t  if (!binfo)\n \t    {\n-\t      binfo = get_binfo (TREE_TYPE (intype), TREE_TYPE (type), 1);\n-\t      if (binfo == error_mark_node)\n-\t\treturn error_mark_node;\n+\t      /* Try base to derived conversion. */\n+\t      binfo = lookup_base (TREE_TYPE (type), TREE_TYPE (intype),\n+\t\t\t\t   ba_check, NULL);\n \t      code = MINUS_EXPR;\n \t    }\n+\t  if (binfo == error_mark_node)\n+\t    return error_mark_node;\n \t  if (binfo)\n \t    {\n-\t      if (TYPE_USES_VIRTUAL_BASECLASSES (TREE_TYPE (type))\n-\t\t  || TYPE_USES_VIRTUAL_BASECLASSES (TREE_TYPE (intype))\n-\t\t  || ! BINFO_OFFSET_ZEROP (binfo))\n+\t      expr = build_base_path (code, expr, binfo, 0);\n+\t      /* Add any qualifier conversions. */\n+\t      if (!same_type_p (TREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t\tTREE_TYPE (type)))\n \t\t{\n-\t\t  /* Need to get the path we took.  */\n-\t\t  tree path;\n-\n-\t\t  if (code == PLUS_EXPR)\n-\t\t    get_base_distance (TREE_TYPE (type), TREE_TYPE (intype),\n-\t\t\t\t       0, &path);\n-\t\t  else\n-\t\t    get_base_distance (TREE_TYPE (intype), TREE_TYPE (type),\n-\t\t\t\t       0, &path);\n-\t\t  return build_vbase_path (code, type, expr, path, 0);\n+\t\t  expr = build1 (NOP_EXPR, type, expr);\n+\t\t  TREE_CONSTANT (expr) =\n+\t\t    TREE_CONSTANT (TREE_OPERAND (expr, 0));\n \t\t}\n+\t      return expr;\n \t    }\n \t}\n \n@@ -187,36 +178,29 @@ cp_convert_to_pointer (type, expr, force)\n \t  tree b1; \n \t  tree b2;\n \t  tree binfo;\n-\t  tree virt_binfo;\n-\t  enum tree_code code;\n+\t  enum tree_code code = PLUS_EXPR;\n+\t  base_kind bk;\n \n \t  b1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (type));\n \t  b2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (intype));\n-\t  binfo = get_binfo (b2, b1, 1);\n-\n-\t  if (binfo == NULL_TREE)\n+\t  binfo = lookup_base (b1, b2, ba_check, &bk);\n+\t  if (!binfo)\n \t    {\n-\t      binfo = get_binfo (b1, b2, 1);\n+\t      binfo = lookup_base (b2, b1, ba_check, &bk);\n \t      code = MINUS_EXPR;\n \t    }\n-\t  else\n-\t    code = PLUS_EXPR;\n-\n \t  if (binfo == error_mark_node)\n \t    return error_mark_node;\n \n-          virt_binfo = binfo_from_vbase (binfo);\n-          if (virt_binfo)\n+          if (bk == bk_via_virtual)\n \t    {\n \t      if (force)\n-\t        cp_warning (\"pointer to member cast via virtual base `%T' of `%T'\",\n-\t                    BINFO_TYPE (virt_binfo),\n-                            BINFO_TYPE (BINFO_INHERITANCE_CHAIN (virt_binfo)));\n+\t        cp_warning (\"pointer to member cast from `%T' to `%T' is via virtual base\",\n+\t                    TREE_TYPE (intype), TREE_TYPE (type));\n               else\n                 {\n-\t          cp_error (\"pointer to member cast via virtual base `%T' of `%T'\",\n-\t                    BINFO_TYPE (virt_binfo),\n-                            BINFO_TYPE (BINFO_INHERITANCE_CHAIN (virt_binfo)));\n+\t\t  cp_error (\"pointer to member cast from `%T' to `%T' is via virtual base\",\n+\t\t\t    TREE_TYPE (intype), TREE_TYPE (type));\n \t          return error_mark_node;\n \t        }\n \t      /* This is a reinterpret cast, whose result is unspecified.\n@@ -319,34 +303,32 @@ convert_to_pointer_force (type, expr)\n \t  && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE)\n \t{\n \t  enum tree_code code = PLUS_EXPR;\n-\t  tree path;\n-\t  int distance = get_base_distance (TREE_TYPE (type),\n-\t\t\t\t\t    TREE_TYPE (intype), 0, &path);\n-\t  if (distance == -2)\n+\t  tree binfo;\n+\n+\t  binfo = lookup_base (TREE_TYPE (intype), TREE_TYPE (type),\n+\t\t\t       ba_ignore, NULL);\n+\t  if (!binfo)\n \t    {\n-\t      cp_error (\"type `%T' is ambiguous base of `%T'\",\n-\t\t\tTREE_TYPE (type),\n-\t\t\tTREE_TYPE (intype));\n-\t      return error_mark_node;\n+\t      binfo = lookup_base (TREE_TYPE (type), TREE_TYPE (intype),\n+\t\t\t\t   ba_ignore, NULL);\n+\t      code = MINUS_EXPR;\n \t    }\n-\t  if (distance == -1)\n+\t  if (binfo == error_mark_node)\n+\t    return error_mark_node;\n+\t  if (binfo)\n \t    {\n-\t      distance = get_base_distance (TREE_TYPE (intype),\n-\t\t\t\t\t    TREE_TYPE (type), 0, &path);\n-\t      if (distance == -2)\n-\t        {\n-\t          cp_error (\"type `%T' is ambiguous base of `%T'\",\n-\t\t\t    TREE_TYPE (intype),\n-\t\t\t    TREE_TYPE (type));\n-\t          return error_mark_node;\n-\t        }\n-\t      if (distance < 0)\n-\t\t/* Doesn't need any special help from us.  */\n-\t\treturn build1 (NOP_EXPR, type, expr);\n-\n-\t      code = MINUS_EXPR;\n+\t      expr = build_base_path (code, expr, binfo, 0);\n+\t      /* Add any qualifier conversions. */\n+\t      if (!same_type_p (TREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t\tTREE_TYPE (type)))\n+\t\t{\n+\t\t  expr = build1 (NOP_EXPR, type, expr);\n+\t\t  TREE_CONSTANT (expr) =\n+\t\t    TREE_CONSTANT (TREE_OPERAND (expr, 0));\n+\t\t}\n+\t      return expr;\n \t    }\n-\t  return build_vbase_path (code, type, expr, path, 0);\n+\t  \n \t}\n     }\n \n@@ -420,12 +402,12 @@ build_up_reference (type, arg, flags, decl)\n       && IS_AGGR_TYPE (target_type))\n     {\n       /* We go through get_binfo for the access control.  */\n-      tree binfo = get_binfo (target_type, argtype, 1);\n+      tree binfo = lookup_base (argtype, target_type, ba_check, NULL);\n       if (binfo == error_mark_node)\n \treturn error_mark_node;\n       if (binfo == NULL_TREE)\n \treturn error_not_base_type (target_type, argtype);\n-      rval = convert_pointer_to_real (binfo, rval);\n+      rval = build_base_path (PLUS_EXPR, rval, binfo, 1);\n     }\n   else\n     rval\n@@ -626,87 +608,6 @@ convert_lvalue (totype, expr)\n   return convert_from_reference (expr);\n }\n \f\n-/* Call this when we know (for any reason) that expr is not, in fact,\n-   zero.  This routine is like convert_pointer_to, but it pays\n-   attention to which specific instance of what type we want to\n-   convert to.  This routine should eventually become\n-   convert_to_pointer after all references to convert_to_pointer\n-   are removed.  */\n-\n-tree\n-convert_pointer_to_real (binfo, expr)\n-     tree binfo, expr;\n-{\n-  register tree intype = TREE_TYPE (expr);\n-  tree ptr_type;\n-  tree type, rval;\n-\n-  if (intype == error_mark_node)\n-    return error_mark_node;\n-\n-  if (TREE_CODE (binfo) == TREE_VEC)\n-    type = BINFO_TYPE (binfo);\n-  else if (IS_AGGR_TYPE (binfo))\n-    {\n-      type = binfo;\n-    }\n-  else\n-    {\n-      type = binfo;\n-      binfo = NULL_TREE;\n-    }\n-\n-  ptr_type = cp_build_qualified_type (type,\n-\t\t\t\t      cp_type_quals (TREE_TYPE (intype)));\n-  ptr_type = build_pointer_type (ptr_type);\n-  if (same_type_p (ptr_type, TYPE_MAIN_VARIANT (intype)))\n-    return expr;\n-\n-  my_friendly_assert (!integer_zerop (expr), 191);\n-\n-  intype = TYPE_MAIN_VARIANT (TREE_TYPE (intype));\n-  if (TREE_CODE (type) == RECORD_TYPE\n-      && TREE_CODE (intype) == RECORD_TYPE\n-      && type != intype)\n-    {\n-      tree path;\n-      int distance\n-\t= get_base_distance (binfo, intype, 0, &path);\n-\n-      /* This function shouldn't be called with unqualified arguments\n-\t but if it is, give them an error message that they can read.  */\n-      if (distance < 0)\n-\t{\n-\t  cp_error (\"cannot convert a pointer of type `%T' to a pointer of type `%T'\",\n-\t\t    intype, type);\n-\n-\t  if (distance == -2)\n-\t    cp_error (\"because `%T' is an ambiguous base class\", type);\n-\t  return error_mark_node;\n-\t}\n-\n-      return build_vbase_path (PLUS_EXPR, ptr_type, expr, path, 1);\n-    }\n-  rval = build1 (NOP_EXPR, ptr_type,\n-\t\t TREE_CODE (expr) == NOP_EXPR ? TREE_OPERAND (expr, 0) : expr);\n-  TREE_CONSTANT (rval) = TREE_CONSTANT (expr);\n-  return rval;\n-}\n-\n-/* Call this when we know (for any reason) that expr is\n-   not, in fact, zero.  This routine gets a type out of the first\n-   argument and uses it to search for the type to convert to.  If there\n-   is more than one instance of that type in the expr, the conversion is\n-   ambiguous.  This routine should eventually go away, and all\n-   callers should use convert_to_pointer_real.  */\n-\n-tree\n-convert_pointer_to (binfo, expr)\n-     tree binfo, expr;\n-{\n-  return convert_pointer_to_real (binfo, expr);\n-}\n-\f\n /* C++ conversions, preference to static cast conversions.  */\n \n tree"}, {"sha": "75ba05a3bd6c70416101cfc50475dfa7b9383ca7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -130,7 +130,9 @@ finish_init_stmts (stmt_expr, compound_stmt)\n \n /* Constructors */\n \n-/* Called from initialize_vtbl_ptrs via dfs_walk.  */\n+/* Called from initialize_vtbl_ptrs via dfs_walk.  BINFO is the base\n+   which we want to initialize the vtable pointer for, DATA is\n+   TREE_LIST whose TREE_VALUE is the this ptr expression.  */\n \n static tree\n dfs_initialize_vtbl_ptrs (binfo, data)\n@@ -142,16 +144,7 @@ dfs_initialize_vtbl_ptrs (binfo, data)\n     {\n       tree base_ptr = TREE_VALUE ((tree) data);\n \n-      if (TREE_VIA_VIRTUAL (binfo))\n-\tbase_ptr = convert_pointer_to_vbase (BINFO_TYPE (binfo),\n-\t\t\t\t\t     base_ptr);\n-      else\n-\tbase_ptr \n-\t  = build_vbase_path (PLUS_EXPR, \n-\t\t\t      build_pointer_type (BINFO_TYPE (binfo)),\n-\t\t\t      base_ptr,\n-\t\t\t      binfo,\n-\t\t\t      /*nonnull=*/1);\n+      base_ptr = build_base_path (PLUS_EXPR, base_ptr, binfo, /*nonnull=*/1);\n \n       expand_virtual_init (binfo, base_ptr);\n     }\n@@ -711,7 +704,8 @@ emit_base_init (mem_init_list, base_init_list)\n \n       if (init != void_list_node)\n \t{\n-\t  member = convert_pointer_to_real (base_binfo, current_class_ptr);\n+\t  member = build_base_path (PLUS_EXPR, current_class_ptr,\n+\t\t\t\t    base_binfo, 1);\n \t  expand_aggr_init_1 (base_binfo, NULL_TREE,\n \t\t\t      build_indirect_ref (member, NULL), init,\n \t\t\t      LOOKUP_NORMAL);\n@@ -802,15 +796,9 @@ static void\n expand_virtual_init (binfo, decl)\n      tree binfo, decl;\n {\n-  tree type = BINFO_TYPE (binfo);\n   tree vtbl, vtbl_ptr;\n-  tree vtype, vtype_binfo;\n   tree vtt_index;\n \n-  /* Compute the location of the vtable.  */\n-  vtype = DECL_CONTEXT (TYPE_VFIELD (type));\n-  vtype_binfo = get_binfo (vtype, TREE_TYPE (TREE_TYPE (decl)), 0);\n-  \n   /* Compute the initializer for vptr.  */\n   vtbl = build_vtbl_address (binfo);\n \n@@ -842,10 +830,9 @@ expand_virtual_init (binfo, decl)\n     }\n \n   /* Compute the location of the vtpr.  */\n-  decl = convert_pointer_to_real (vtype_binfo, decl);\n-  vtbl_ptr = build_vfield_ref (build_indirect_ref (decl, NULL), vtype);\n-  if (vtbl_ptr == error_mark_node)\n-    return;\n+  vtbl_ptr = build_vfield_ref (build_indirect_ref (decl, NULL),\n+\t\t\t       TREE_TYPE (binfo));\n+  my_friendly_assert (vtbl_ptr != error_mark_node, 20010730);\n \n   /* Assign the vtable to the vptr.  */\n   vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl, 0);\n@@ -1842,14 +1829,14 @@ resolve_offset_ref (exp)\n       if (TREE_CODE (exp) == OFFSET_REF && TREE_CODE (type) == OFFSET_TYPE)\n \tbase = build_scoped_ref (base, TYPE_OFFSET_BASETYPE (type));\n \n-      addr = build_unary_op (ADDR_EXPR, base, 0);\n-      addr = convert_pointer_to (basetype, addr);\n-\n-      if (addr == error_mark_node)\n+      basetype = lookup_base (TREE_TYPE (base), basetype, ba_check, NULL);\n+      expr = build_base_path (PLUS_EXPR, base, basetype, 1);\n+      \n+      if (expr == error_mark_node)\n \treturn error_mark_node;\n \n       expr = build (COMPONENT_REF, TREE_TYPE (member),\n-\t\t    build_indirect_ref (addr, NULL), member);\n+\t\t    expr, member);\n       return convert_from_reference (expr);\n     }\n \n@@ -1872,7 +1859,10 @@ resolve_offset_ref (exp)\n \t}\n \n       basetype = TYPE_OFFSET_BASETYPE (TREE_TYPE (TREE_TYPE (member)));\n-      addr = convert_pointer_to (basetype, addr);\n+      basetype = lookup_base (TREE_TYPE (TREE_TYPE (addr)),\n+\t\t\t      basetype, ba_check, NULL);\n+      addr = build_base_path (PLUS_EXPR, addr, basetype, 1);\n+      \n       member = cp_convert (ptrdiff_type_node, member);\n \n       return build1 (INDIRECT_REF, type,"}, {"sha": "3510cc10b380f3eeebb7574c6cd079aaa9af91da", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -472,28 +472,15 @@ build_dynamic_cast_1 (type, expr)\n   /* If *type is an unambiguous accessible base class of *exprtype,\n      convert statically.  */\n   {\n-    int distance;\n-    tree path;\n+    tree binfo;\n \n-    distance = get_base_distance (TREE_TYPE (type), TREE_TYPE (exprtype), 1,\n-\t\t\t\t  &path);\n+    binfo = lookup_base (TREE_TYPE (exprtype), TREE_TYPE (type),\n+\t\t\t ba_not_special, NULL);\n \n-    if (distance == -2)\n+    if (binfo)\n       {\n-\tcp_error (\"dynamic_cast from `%T' to ambiguous base class `%T'\",\n-\t\t  TREE_TYPE (exprtype), TREE_TYPE (type));\n-\treturn error_mark_node;\n-      }\n-    if (distance == -3)\n-      {\n-\tcp_error (\"dynamic_cast from `%T' to private base class `%T'\",\n-\t\t  TREE_TYPE (exprtype), TREE_TYPE (type));\n-\treturn error_mark_node;\n-      }\n-\n-    if (distance >= 0)\n-      {\n-\texpr = build_vbase_path (PLUS_EXPR, type, expr, path, 0);\n+\texpr = build_base_path (PLUS_EXPR, convert_from_reference (expr),\n+\t\t\t\tbinfo, 0);\n \tif (TREE_CODE (exprtype) == POINTER_TYPE)\n \t  expr = non_lvalue (expr);\n \treturn expr;"}, {"sha": "3bc6d9dbfbcf938b6252e11d1b28b6e5c9618d7b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 190, "deletions": 74, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -83,14 +83,16 @@ struct vbase_info\n   tree inits;\n };\n \n-static tree get_vbase_1 PARAMS ((tree, tree, unsigned int *));\n static tree lookup_field_1 PARAMS ((tree, tree));\n static int is_subobject_of_p PARAMS ((tree, tree, tree));\n static tree dfs_check_overlap PARAMS ((tree, void *));\n static tree dfs_no_overlap_yet PARAMS ((tree, void *));\n static int get_base_distance_recursive\n \tPARAMS ((tree, int, int, int, int *, tree *, tree,\n \t       int, int *, int, int));\n+static base_kind lookup_base_r\n+\tPARAMS ((tree, tree, base_access,\n+\t\t int, int, int, tree *));\n static int dynamic_cast_base_recurse PARAMS ((tree, tree, int, tree *));\n static tree marked_pushdecls_p PARAMS ((tree, void *));\n static tree unmarked_pushdecls_p PARAMS ((tree, void *));\n@@ -169,76 +171,6 @@ static int n_contexts_saved;\n #endif /* GATHER_STATISTICS */\n \n \f\n-/* Get a virtual binfo that is found inside BINFO's hierarchy that is\n-   the same type as the type given in PARENT.  To be optimal, we want\n-   the first one that is found by going through the least number of\n-   virtual bases.\n-\n-   This uses a clever algorithm that updates *depth when we find the vbase,\n-   and cuts off other paths of search when they reach that depth.  */\n-\n-static tree\n-get_vbase_1 (parent, binfo, depth)\n-     tree parent, binfo;\n-     unsigned int *depth;\n-{\n-  tree binfos;\n-  int i, n_baselinks;\n-  tree rval = NULL_TREE;\n-  int virtualp = TREE_VIA_VIRTUAL (binfo) != 0;\n-\n-  *depth -= virtualp;\n-  if (virtualp && BINFO_TYPE (binfo) == parent)\n-    {\n-      *depth = 0;\n-      return binfo;\n-    }\n-\n-  binfos = BINFO_BASETYPES (binfo);\n-  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  /* Process base types.  */\n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      tree nrval;\n-\n-      if (*depth == 0)\n-\tbreak;\n-\n-      nrval = get_vbase_1 (parent, base_binfo, depth);\n-      if (nrval)\n-\trval = nrval;\n-    }\n-  *depth += virtualp;\n-  return rval;\n-}\n-\n-/* Return the shortest path to vbase PARENT within BINFO, ignoring\n-   access and ambiguity.  */\n-\n-tree\n-get_vbase (parent, binfo)\n-     tree parent;\n-     tree binfo;\n-{\n-  unsigned int d = (unsigned int)-1;\n-  return get_vbase_1 (parent, binfo, &d);\n-}\n-\n-/* Convert EXPR to a virtual base class of type TYPE.  We know that\n-   EXPR is a non-null POINTER_TYPE to RECORD_TYPE.  We also know that\n-   the type of what expr points to has a virtual base of type TYPE.  */\n-\n-tree\n-convert_pointer_to_vbase (type, expr)\n-     tree type;\n-     tree expr;\n-{\n-  tree vb = get_vbase (type, TYPE_BINFO (TREE_TYPE (TREE_TYPE (expr))));\n-  return convert_pointer_to_real (vb, expr);\n-}\n-\n /* Check whether the type given in BINFO is derived from PARENT.  If\n    it isn't, return 0.  If it is, but the derivation is MI-ambiguous\n    AND protect != 0, emit an error message and return error_mark_node.\n@@ -406,9 +338,6 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n    If PROTECT is greater than 1, ignore any special access the current\n    scope might have when determining whether PARENT is inaccessible.\n \n-   PARENT can also be a binfo, in which case that exact parent is found\n-   and no other.  convert_pointer_to_real uses this functionality.\n-\n    If BINFO is a binfo, its BINFO_INHERITANCE_CHAIN will be left alone.  */\n \n int\n@@ -473,6 +402,193 @@ get_base_distance (parent, binfo, protect, path_ptr)\n   return rval;\n }\n \n+/* Worker for lookup_base.  BINFO is the binfo we are searching at,\n+   BASE is the RECORD_TYPE we are searching for.  ACCESS is the\n+   required access checks.  WITHIN_CURRENT_SCOPE, IS_NON_PUBLIC and\n+   IS_VIRTUAL indicate how BINFO was reached from the start of the\n+   search.  WITHIN_CURRENT_SCOPE is true if we met the current scope,\n+   or friend thereof (this allows us to determine whether a protected\n+   base is accessible or not).  IS_NON_PUBLIC indicates whether BINFO\n+   is accessible and IS_VIRTUAL indicates if it is morally virtual.\n+\n+   If BINFO is of the required type, then *BINFO_PTR is examined to\n+   compare with any other instance of BASE we might have already\n+   discovered. *BINFO_PTR is initialized and a base_kind return value\n+   indicates what kind of base was located.\n+\n+   Otherwise BINFO's bases are searched.  */\n+\n+static base_kind\n+lookup_base_r (binfo, base, access, within_current_scope,\n+\t       is_non_public, is_virtual, binfo_ptr)\n+     tree binfo, base;\n+     base_access access;\n+     int within_current_scope;\n+     int is_non_public;\t\t/* inside a non-public part */\n+     int is_virtual;\t\t/* inside a virtual part */\n+     tree *binfo_ptr;\n+{\n+  int i;\n+  tree bases;\n+  base_kind found = bk_not_base;\n+  \n+  if (access == ba_check\n+      && !within_current_scope\n+      && is_friend (BINFO_TYPE (binfo), current_scope ()))\n+    {\n+      within_current_scope = 1;\n+      is_non_public = 0;\n+    }\n+  \n+  if (same_type_p (BINFO_TYPE (binfo), base))\n+    {\n+      /* We have found a base. Check against what we have found\n+         already. */\n+      found = bk_same_type;\n+      if (is_virtual)\n+\tfound = bk_via_virtual;\n+      if (is_non_public)\n+\tfound = bk_inaccessible;\n+      \n+      if (!*binfo_ptr)\n+\t*binfo_ptr = binfo;\n+      else if (!is_virtual || !tree_int_cst_equal (BINFO_OFFSET (binfo),\n+\t\t\t\t\t\t   BINFO_OFFSET (*binfo_ptr)))\n+\t{\n+\t  if (access != ba_any)\n+\t    *binfo_ptr = NULL;\n+\t  else if (found != is_virtual)\n+\t    /* Prefer a non-virtual base.  */\n+\t    *binfo_ptr = binfo;\n+\t  found = bk_ambig;\n+\t}\n+      else if (found == bk_via_virtual)\n+\t*binfo_ptr = binfo;\n+      \n+      return found;\n+    }\n+  \n+  bases = BINFO_BASETYPES (binfo);\n+  if (!bases)\n+    return bk_not_base;\n+  \n+  for (i = TREE_VEC_LENGTH (bases); i--;)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (bases, i);\n+      int this_non_public = is_non_public;\n+      int this_virtual = is_virtual;\n+\n+      if (access <= ba_ignore)\n+\t; /* no change */\n+      else if (TREE_VIA_PUBLIC (base_binfo))\n+\t; /* no change */\n+      else if (access == ba_not_special)\n+\tthis_non_public = 1;\n+      else if (TREE_VIA_PROTECTED (base_binfo) && within_current_scope)\n+\t; /* no change */\n+      else if (is_friend (BINFO_TYPE (binfo), current_scope ()))\n+\t; /* no change */\n+      else\n+\tthis_non_public = 1;\n+      \n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\tthis_virtual = 1;\n+      \n+      base_kind bk = lookup_base_r (base_binfo, base,\n+\t\t\t\t    access, within_current_scope,\n+\t\t\t\t    this_non_public, this_virtual,\n+\t\t\t\t    binfo_ptr);\n+\n+      switch (bk)\n+\t{\n+\tcase bk_ambig:\n+\t  if (access != ba_any)\n+\t    return bk;\n+\t  found = bk;\n+\t  break;\n+\t  \n+\tcase bk_inaccessible:\n+\t  if (found == bk_not_base)\n+\t    found = bk;\n+\t  my_friendly_assert (found == bk_via_virtual\n+\t\t\t      || found == bk_inaccessible, 20010723);\n+\t  \n+\t  break;\n+\t  \n+\tcase bk_same_type:\n+\t  bk = bk_proper_base;\n+\t  /* FALLTHROUGH */\n+\tcase bk_proper_base:\n+\t  my_friendly_assert (found == bk_not_base, 20010723);\n+\t  found = bk;\n+\t  break;\n+\t  \n+\tcase bk_via_virtual:\n+\t  my_friendly_assert (found == bk_not_base\n+\t\t\t      || found == bk_via_virtual\n+\t\t\t      || found == bk_inaccessible, 20010723);\n+\t  found = bk;\n+\t  break;\n+\t  \n+\tcase bk_not_base:\n+\t  break;\n+\t}\n+    }\n+  return found;\n+}\n+\n+/* Lookup BASE in the hierarchy dominated by T.  Do access checking as\n+   ACCESS specifies.  Return the binfo we discover (which might not be\n+   canonical).  If KIND_PTR is non-NULL, fill with information about\n+   what kind of base we discoveded.\n+\n+   Issue an error message if an inaccessible or ambiguous base is\n+   discovered, and return error_mark_node. */\n+\n+tree\n+lookup_base (t, base, access, kind_ptr)\n+     tree t, base;\n+     base_access access;\n+     base_kind *kind_ptr;\n+{\n+  tree binfo = NULL;\t\t/* The binfo we've found so far. */\n+  base_kind bk;\n+\n+  if (t == error_mark_node || base == error_mark_node)\n+    {\n+      if (kind_ptr)\n+\t*kind_ptr = bk_not_base;\n+      return error_mark_node;\n+    }\n+  \n+  t = TYPE_MAIN_VARIANT (t);\n+  base = TYPE_MAIN_VARIANT (base);\n+  \n+  bk = lookup_base_r (TYPE_BINFO (t), base, access, 0, 0, 0, &binfo);\n+\n+  switch (bk)\n+    {\n+    case bk_inaccessible:\n+      cp_error (\"`%T' is an inaccessible base of `%T'\", base, t);\n+      binfo = error_mark_node;\n+      break;\n+    case bk_ambig:\n+      if (access != ba_any)\n+\t{\n+\t  cp_error (\"`%T' is an ambiguous base of `%T'\", base, t);\n+\t  binfo = error_mark_node;\n+\t}\n+      break;\n+      \n+    default:;\n+    }\n+  \n+  if (kind_ptr)\n+    *kind_ptr = bk;\n+  \n+  return binfo;\n+}\n+\n /* Worker function for get_dynamic_cast_base_type.  */\n \n static int"}, {"sha": "ddd4fc75508ee5e99032c869a4e98495552ccd94", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -116,8 +116,11 @@ require_complete_type (value)\n     {\n       tree base, member = TREE_OPERAND (value, 1);\n       tree basetype = TYPE_OFFSET_BASETYPE (type);\n+      \n       my_friendly_assert (TREE_CODE (member) == FIELD_DECL, 305);\n-      base = convert_pointer_to (basetype, current_class_ptr);\n+      basetype = lookup_base (current_class_type, basetype, ba_check, NULL);\n+      base = build_base_path (PLUS_EXPR, current_class_ptr, basetype, 1);\n+      \n       value = build (COMPONENT_REF, TREE_TYPE (member),\n \t\t     build_indirect_ref (base, NULL), member);\n       return require_complete_type (value);\n@@ -2208,14 +2211,15 @@ build_component_ref (datum, component, basetype_path, protect)\n       /* Handle base classes here...  */\n       if (base != basetype && TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype))\n \t{\n-\t  tree addr = build_unary_op (ADDR_EXPR, datum, 0);\n-\t  if (integer_zerop (addr))\n+ \t  tree binfo = lookup_base (TREE_TYPE (datum), base, ba_check, NULL);\n+ \n+\t  if (TREE_CODE (datum) == INDIRECT_REF\n+\t      && integer_zerop (TREE_OPERAND (datum, 0)))\n \t    {\n \t      error (\"invalid reference to NULL ptr, use ptr-to-member instead\");\n \t      return error_mark_node;\n \t    }\n-\t  addr = convert_pointer_to (base, addr);\n-\t  datum = build_indirect_ref (addr, NULL);\n+ \t  datum = build_base_path (PLUS_EXPR, datum, binfo, 1);\n \t  if (datum == error_mark_node)\n \t    return error_mark_node;\n \t}\n@@ -2806,8 +2810,11 @@ build_x_function_call (function, params, decl)\n       if (TREE_CODE (TREE_TYPE (decl)) != POINTER_TYPE\n \t  && ! TYPE_PTRMEMFUNC_P (TREE_TYPE (decl)))\n \t{\n+\t  tree binfo = lookup_base (TREE_TYPE (decl), TREE_TYPE (ctypeptr),\n+\t\t\t\t    ba_check, NULL);\n+\t  \n \t  decl = build_unary_op (ADDR_EXPR, decl, 0);\n-\t  decl = convert_pointer_to (TREE_TYPE (ctypeptr), decl);\n+\t  decl = build_base_path (PLUS_EXPR, decl, binfo, 1);\n \t}\n       else\n \tdecl = build_c_cast (ctypeptr, decl);\n@@ -2826,9 +2833,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n      tree function;\n {\n   if (TREE_CODE (function) == OFFSET_REF)\n-    {\n-      function = TREE_OPERAND (function, 1);\n-    }\n+    function = TREE_OPERAND (function, 1);\n \n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (function)))\n     {\n@@ -2857,14 +2862,18 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n       basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (fntype));\n \n-      /* Convert down to the right base, before using the instance.  */\n-      instance = convert_pointer_to_real (basetype, instance_ptr);\n+      /* Convert down to the right base, before using the instance. */\n+      instance = lookup_base (TREE_TYPE (TREE_TYPE (instance_ptr)), basetype,\n+\t\t\t      ba_check, NULL);\n+      instance = build_base_path (PLUS_EXPR, instance_ptr, instance, 1);\n       if (instance == error_mark_node && instance_ptr != error_mark_node)\n \treturn instance;\n \n       e3 = PFN_FROM_PTRMEMFUNC (function);\n-\n-      vtbl = convert_pointer_to (ptr_type_node, instance);\n+      \n+      vtbl = build1 (NOP_EXPR, build_pointer_type (ptr_type_node), instance);\n+      TREE_CONSTANT (vtbl) = TREE_CONSTANT (instance);\n+      \n       delta = cp_convert (ptrdiff_type_node,\n \t\t\t  build_component_ref (function, delta_identifier,\n \t\t\t\t\t       NULL_TREE, 0));\n@@ -4229,8 +4238,11 @@ build_component_addr (arg, argtype)\n       /* Can't convert directly to ARGTYPE, since that\n \t may have the same pointer type as one of our\n \t baseclasses.  */\n-      rval = build1 (NOP_EXPR, argtype,\n-\t\t     convert_pointer_to (basetype, rval));\n+      tree binfo = lookup_base (TREE_TYPE (TREE_TYPE (rval)), basetype,\n+\t\t\t\tba_check, NULL);\n+\n+      rval = build_base_path (PLUS_EXPR, rval, binfo, 1);\n+      rval = build1 (NOP_EXPR, argtype, rval);\n       TREE_CONSTANT (rval) = TREE_CONSTANT (TREE_OPERAND (rval, 0));\n     }\n   else"}, {"sha": "39e047927c08137d61646567db5e10acf7b50aee", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -997,12 +997,17 @@ build_scoped_ref (datum, basetype)\n      tree basetype;\n {\n   tree ref;\n+  tree binfo;\n \n   if (datum == error_mark_node)\n     return error_mark_node;\n+  binfo = lookup_base (TREE_TYPE (datum), basetype, ba_check, NULL);\n \n+  if (!binfo)\n+    return error_not_base_type (TREE_TYPE (datum), basetype);\n+  \n   ref = build_unary_op (ADDR_EXPR, datum, 0);\n-  ref = convert_pointer_to (basetype, ref);\n+  ref = build_base_path (PLUS_EXPR, ref, binfo, 1);\n \n   return build_indirect_ref (ref, \"(compiler error in build_scoped_ref)\");\n }"}, {"sha": "c1a7fdeb1db36b9da51a60a0143f1e25b4e77600", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -1,3 +1,7 @@\n+2001-11-25  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/abi/vbase8-4.C: New test.\n+\n 2001-11-24  Ian Lance Taylor  <ian@airs.com>\n \n \t* gcc.c-torture/execute/20011121-1.c: New test."}, {"sha": "2e816f6a801b1c706e2de6f8f4ba1a39a1b057ac", "filename": "gcc/testsuite/g++.dg/abi/vbase8-4.C", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase8-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338d90b89f23deaa5ce2ae80b8adf9cb52808679/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase8-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase8-4.C?ref=338d90b89f23deaa5ce2ae80b8adf9cb52808679", "patch": "@@ -0,0 +1,78 @@\n+// { dg-options -w }\n+// { dg-do run }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 20 Nov 2001 <nathan@codesourcery.com>\n+\n+// Origin stefan@space.twc.de\n+// Bug 3145 case 4. Horribly complicated class hierarchy\n+\n+class C0\n+{};\n+class C1\n+ :  virtual public C0\n+{};\n+class C2\n+ :  public C0\n+ ,  public C1\n+{};\n+class C3\n+ :  virtual public C0\n+ ,  public C1\n+ ,  public C2\n+{};\n+class C4\n+ :  public C2\n+ ,  public C3\n+ ,  virtual public C1\n+ ,  virtual public C0\n+{};\n+class C5\n+ :  virtual public C2\n+ ,  public C1\n+ ,  public C0\n+{};\n+class C6\n+ :  virtual public C0\n+ ,  virtual public C5\n+ ,  public C1\n+ ,  public C3\n+ ,  public C4\n+{};\n+class C7\n+ :  public C6\n+ ,  virtual public C0\n+ ,  public C1\n+ ,  public C2\n+ ,  virtual public C4\n+{};\n+class C8\n+ :  public C2\n+ ,  virtual public C6\n+ ,  virtual public C7\n+ ,  public C5\n+ ,  public C3\n+ ,  virtual public C4\n+{};\n+class C9\n+ :  public C5\n+ ,  virtual public C3\n+ ,  virtual public C8\n+ ,  public C0\n+ ,  public C2\n+ ,  public C7\n+ ,  public C6\n+ ,  public C4\n+{};\n+main() {\n+  C0 c0;\n+  C1 c1;\n+  C2 c2;\n+  C3 c3;\n+  C4 c4;\n+  C5 c5;\n+  C6 c6;\n+  C7 c7;\n+  C8 c8;\n+  C9 c9;\n+}"}]}