{"sha": "014ef6e1323b3a2ac9ff1fd6a182698d78c7326a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE0ZWY2ZTEzMjNiM2EyYWM5ZmYxZmQ2YTE4MjY5OGQ3OGM3MzI2YQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-11T09:47:24Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-11T09:47:24Z"}, "message": "tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Re-associate nonlinear iv_use computation in loop invariant sensitive way.\n\n\t* tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Re-associate\n\tnonlinear iv_use computation in loop invariant sensitive way.\n\nFrom-SVN: r247891", "tree": {"sha": "be8029ce3a6224d98fb4704844342b5da7640dc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be8029ce3a6224d98fb4704844342b5da7640dc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/014ef6e1323b3a2ac9ff1fd6a182698d78c7326a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014ef6e1323b3a2ac9ff1fd6a182698d78c7326a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/014ef6e1323b3a2ac9ff1fd6a182698d78c7326a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014ef6e1323b3a2ac9ff1fd6a182698d78c7326a/comments", "author": null, "committer": null, "parents": [{"sha": "06fd3160aabe468b22ad66c994140ff6cb0ff0d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06fd3160aabe468b22ad66c994140ff6cb0ff0d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06fd3160aabe468b22ad66c994140ff6cb0ff0d4"}], "stats": {"total": 57, "additions": 50, "deletions": 7}, "files": [{"sha": "25dc6faca8ef3e884bd4787be5962e3b83a7888a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014ef6e1323b3a2ac9ff1fd6a182698d78c7326a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014ef6e1323b3a2ac9ff1fd6a182698d78c7326a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=014ef6e1323b3a2ac9ff1fd6a182698d78c7326a", "patch": "@@ -1,3 +1,8 @@\n+2017-05-11  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Re-associate\n+\tnonlinear iv_use computation in loop invariant sensitive way.\n+\n 2017-05-11  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (relate_compare_use_with_all_cands): New."}, {"sha": "059ee11c5deeb2932811caedfe56df501035fe0b", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014ef6e1323b3a2ac9ff1fd6a182698d78c7326a/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014ef6e1323b3a2ac9ff1fd6a182698d78c7326a/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=014ef6e1323b3a2ac9ff1fd6a182698d78c7326a", "patch": "@@ -6659,10 +6659,9 @@ static void\n rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \t\t\t    struct iv_use *use, struct iv_cand *cand)\n {\n-  tree comp;\n-  tree tgt;\n   gassign *ass;\n   gimple_stmt_iterator bsi;\n+  tree comp, type = get_use_type (use), tgt;\n \n   /* An important special case -- if we are asked to express value of\n      the original iv by itself, just exit; there is no need to\n@@ -6706,9 +6705,6 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \t}\n     }\n \n-  comp = get_computation_at (data->current_loop, use->stmt, use, cand);\n-  gcc_assert (comp != NULL_TREE);\n-\n   switch (gimple_code (use->stmt))\n     {\n     case GIMPLE_PHI:\n@@ -6730,15 +6726,56 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n       gcc_unreachable ();\n     }\n \n+  aff_tree aff_inv, aff_var;\n+  if (!get_computation_aff_1 (data->current_loop, use->stmt,\n+\t\t\t      use, cand, &aff_inv, &aff_var))\n+    gcc_unreachable ();\n+\n+  unshare_aff_combination (&aff_inv);\n+  unshare_aff_combination (&aff_var);\n+  /* Prefer CSE opportunity than loop invariant by adding offset at last\n+     so that iv_uses have different offsets can be CSEed.  */\n+  widest_int offset = aff_inv.offset;\n+  aff_inv.offset = 0;\n+\n+  gimple_seq stmt_list = NULL, seq = NULL;\n+  tree comp_op1 = aff_combination_to_tree (&aff_inv);\n+  tree comp_op2 = aff_combination_to_tree (&aff_var);\n+  gcc_assert (comp_op1 && comp_op2);\n+\n+  comp_op1 = force_gimple_operand (comp_op1, &seq, true, NULL);\n+  gimple_seq_add_seq (&stmt_list, seq);\n+  comp_op2 = force_gimple_operand (comp_op2, &seq, true, NULL);\n+  gimple_seq_add_seq (&stmt_list, seq);\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (comp_op2)))\n+    std::swap (comp_op1, comp_op2);\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (comp_op1)))\n+    {\n+      comp = fold_build_pointer_plus (comp_op1,\n+\t\t\t\t      fold_convert (sizetype, comp_op2));\n+      comp = fold_build_pointer_plus (comp,\n+\t\t\t\t      wide_int_to_tree (sizetype, offset));\n+    }\n+  else\n+    {\n+      comp = fold_build2 (PLUS_EXPR, TREE_TYPE (comp_op1), comp_op1,\n+\t\t\t  fold_convert (TREE_TYPE (comp_op1), comp_op2));\n+      comp = fold_build2 (PLUS_EXPR, TREE_TYPE (comp_op1), comp,\n+\t\t\t  wide_int_to_tree (TREE_TYPE (comp_op1), offset));\n+    }\n+\n+  comp = fold_convert (type, comp);\n   if (!valid_gimple_rhs_p (comp)\n       || (gimple_code (use->stmt) != GIMPLE_PHI\n \t  /* We can't allow re-allocating the stmt as it might be pointed\n \t     to still.  */\n \t  && (get_gimple_rhs_num_ops (TREE_CODE (comp))\n \t      >= gimple_num_ops (gsi_stmt (bsi)))))\n     {\n-      comp = force_gimple_operand_gsi (&bsi, comp, true, NULL_TREE,\n-\t\t\t\t       true, GSI_SAME_STMT);\n+      comp = force_gimple_operand (comp, &seq, true, NULL);\n+      gimple_seq_add_seq (&stmt_list, seq);\n       if (POINTER_TYPE_P (TREE_TYPE (tgt)))\n \t{\n \t  duplicate_ssa_name_ptr_info (comp, SSA_NAME_PTR_INFO (tgt));\n@@ -6749,6 +6786,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \t}\n     }\n \n+  gsi_insert_seq_before (&bsi, stmt_list, GSI_SAME_STMT);\n   if (gimple_code (use->stmt) == GIMPLE_PHI)\n     {\n       ass = gimple_build_assign (tgt, comp);"}]}