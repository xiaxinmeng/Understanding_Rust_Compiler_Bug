{"sha": "ca722fe423bdd8c7895a40aac0410b2646917805", "node_id": "C_kwDOANBUbNoAKGNhNzIyZmU0MjNiZGQ4Yzc4OTVhNDBhYWMwNDEwYjI2NDY5MTc4MDU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-02T21:26:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-02T21:26:10Z"}, "message": "Merge #1197\n\n1197: Support recursive coercion sites r=philberty a=philberty\n\nThere are two changes are part of this PR one where we update the address_expression\r\nhelper to take a ptrtype tree. Since the default build_address_expr_loc was automatically\r\nbuilding a pointer type of the TREE_TYPE of the operand which is not correct since we\r\nsometimes want REFERENCE_TYPES instead of POINTER_TYPES. \r\n\r\nThe 2nd commit enhances the coercion_site code to recursively walk the tree and their\r\ntypes to handle coercions to dyn traits or do array bounds checking etc. This gets rid of\r\nthe get_root hack used and cleans up the code in general.\r\n\r\n\r\nFixes #1146 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "52ca965213514c45d7143acff72d9d21f090b4e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52ca965213514c45d7143acff72d9d21f090b4e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca722fe423bdd8c7895a40aac0410b2646917805", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJicExyCRBK7hj4Ov3rIwAAVzUIACjD02bl7JjjMeSA5z4xooTN\nJmfkYG8G65mgIgpJC2kbFJfaQr04hzzS9AmiiX8Ut2VUJBGHEHUG2waJqmA4+i7y\nE32itvrqE98PdBLB2DEQnXtwxy7Ss+I2pZx1dRLCUh+3PTcZgzSlnPoIK6Iglsz1\nDV1qAjxGbHGn+XIoNKmnCa8NEaR+xKyjTHFbbpj7xQPLdk9YtjlxAO8ZGKhkBNWf\nrPIDVapVQifQjm+rQv0jkdZ+AjFJyhoplLkNiiUxspyBryBUr+B06VeI9hkHUsPr\nFet1BZs5WC0Dv1xVVVHpbEEghTsAlNVuzl2Sy54zc31blzt8tE0KNAsJa22EFss=\n=wjNm\n-----END PGP SIGNATURE-----\n", "payload": "tree 52ca965213514c45d7143acff72d9d21f090b4e6\nparent 5aec7cbfa560440801dfd0b26e408ab6fb692ed6\nparent 7e576d70b6a1065bf31c37380a8e39354d961cd6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1651526770 +0000\ncommitter GitHub <noreply@github.com> 1651526770 +0000\n\nMerge #1197\n\n1197: Support recursive coercion sites r=philberty a=philberty\n\nThere are two changes are part of this PR one where we update the address_expression\r\nhelper to take a ptrtype tree. Since the default build_address_expr_loc was automatically\r\nbuilding a pointer type of the TREE_TYPE of the operand which is not correct since we\r\nsometimes want REFERENCE_TYPES instead of POINTER_TYPES. \r\n\r\nThe 2nd commit enhances the coercion_site code to recursively walk the tree and their\r\ntypes to handle coercions to dyn traits or do array bounds checking etc. This gets rid of\r\nthe get_root hack used and cleans up the code in general.\r\n\r\n\r\nFixes #1146 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca722fe423bdd8c7895a40aac0410b2646917805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca722fe423bdd8c7895a40aac0410b2646917805", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca722fe423bdd8c7895a40aac0410b2646917805/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aec7cbfa560440801dfd0b26e408ab6fb692ed6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aec7cbfa560440801dfd0b26e408ab6fb692ed6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aec7cbfa560440801dfd0b26e408ab6fb692ed6"}, {"sha": "7e576d70b6a1065bf31c37380a8e39354d961cd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e576d70b6a1065bf31c37380a8e39354d961cd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e576d70b6a1065bf31c37380a8e39354d961cd6"}], "stats": {"total": 246, "additions": 151, "deletions": 95}, "files": [{"sha": "6773ac61382e7e56d590297d5d1060799b8bb455", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=ca722fe423bdd8c7895a40aac0410b2646917805", "patch": "@@ -317,15 +317,16 @@ HIRCompileBase::mark_addressable (tree exp, Location locus)\n }\n \n tree\n-HIRCompileBase::address_expression (tree expr, Location location)\n+HIRCompileBase::address_expression (tree expr, tree ptrtype, Location location)\n {\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n   if (!mark_addressable (expr, location))\n     return error_mark_node;\n \n-  return build_fold_addr_expr_loc (location.gcc_location (), expr);\n+  return build_fold_addr_expr_with_type_loc (location.gcc_location (), expr,\n+\t\t\t\t\t     ptrtype);\n }\n \n std::vector<Bvariable *>"}, {"sha": "77e6cc34b9f0fd745addb93d6fe6759adff4eb4b", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=ca722fe423bdd8c7895a40aac0410b2646917805", "patch": "@@ -98,7 +98,7 @@ class HIRCompileBase\n \n   static void setup_abi_options (tree fndecl, ABI abi);\n \n-  static tree address_expression (tree, Location);\n+  static tree address_expression (tree expr, tree ptrtype, Location locus);\n \n   static bool mark_addressable (tree, Location);\n "}, {"sha": "422526321b47e8b25b2abb6ac2cdb81c13e13caa", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=ca722fe423bdd8c7895a40aac0410b2646917805", "patch": "@@ -123,7 +123,14 @@ void\n CompileExpr::visit (HIR::BorrowExpr &expr)\n {\n   tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n-  translated = address_expression (main_expr, expr.get_locus ());\n+\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &tyty))\n+    return;\n+\n+  tree ptrtype = TyTyResolveCompile::compile (ctx, tyty);\n+  translated = address_expression (main_expr, ptrtype, expr.get_locus ());\n }\n \n void\n@@ -670,17 +677,6 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n     = ctx->get_backend ()->convert_expression (expected_fntype,\n \t\t\t\t\t       fn_vtable_access, expr_locus);\n \n-  fncontext fnctx = ctx->peek_fn ();\n-  tree enclosing_scope = ctx->peek_enclosing_scope ();\n-  bool is_address_taken = false;\n-  tree ret_var_stmt = NULL_TREE;\n-  Bvariable *fn_convert_expr_tmp\n-    = ctx->get_backend ()->temporary_variable (fnctx.fndecl, enclosing_scope,\n-\t\t\t\t\t       expected_fntype, fn_convert_expr,\n-\t\t\t\t\t       is_address_taken, expr_locus,\n-\t\t\t\t\t       &ret_var_stmt);\n-  ctx->add_statement (ret_var_stmt);\n-\n   std::vector<tree> args;\n   args.push_back (self_argument);\n   for (auto &argument : arguments)\n@@ -689,10 +685,7 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n       args.push_back (compiled_expr);\n     }\n \n-  tree fn_expr\n-    = ctx->get_backend ()->var_expression (fn_convert_expr_tmp, expr_locus);\n-\n-  return ctx->get_backend ()->call_expression (fn_expr, args, nullptr,\n+  return ctx->get_backend ()->call_expression (fn_convert_expr, args, nullptr,\n \t\t\t\t\t       expr_locus);\n }\n \n@@ -707,7 +700,8 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n   tree fn = NULL_TREE;\n   if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n     {\n-      return address_expression (fn, expr_locus);\n+      return address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n+\t\t\t\t expr_locus);\n     }\n \n   // Now we can try and resolve the address since this might be a forward\n@@ -983,7 +977,8 @@ CompileExpr::compile_string_literal (const HIR::LiteralExpr &expr,\n \n   auto base = ctx->get_backend ()->string_constant_expression (\n     literal_value.as_string ());\n-  return address_expression (base, expr.get_locus ());\n+  return address_expression (base, build_pointer_type (TREE_TYPE (base)),\n+\t\t\t     expr.get_locus ());\n }\n \n tree\n@@ -1016,7 +1011,8 @@ CompileExpr::compile_byte_string_literal (const HIR::LiteralExpr &expr,\n \t\t\t\t\t\t\t vals,\n \t\t\t\t\t\t\t expr.get_locus ());\n \n-  return address_expression (constructed, expr.get_locus ());\n+  return address_expression (constructed, build_pointer_type (array_type),\n+\t\t\t     expr.get_locus ());\n }\n \n tree\n@@ -1233,8 +1229,11 @@ HIRCompileBase::resolve_adjustements (\n \t  return error_mark_node;\n \n \tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n-\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n-\t  e = address_expression (e, locus);\n+\t  case Resolver::Adjustment::AdjustmentType::MUT_REF: {\n+\t    tree ptrtype\n+\t      = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+\t    e = address_expression (e, ptrtype, locus);\n+\t  }\n \t  break;\n \n \tcase Resolver::Adjustment::AdjustmentType::DEREF:\n@@ -1280,7 +1279,10 @@ HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n \t\t      != Resolver::Adjustment::AdjustmentType::ERROR;\n   if (needs_borrow)\n     {\n-      adjusted_argument = address_expression (expression, locus);\n+      adjusted_argument\n+\t= address_expression (expression,\n+\t\t\t      build_reference_type (TREE_TYPE (expression)),\n+\t\t\t      locus);\n     }\n \n   // make the call\n@@ -1316,7 +1318,9 @@ HIRCompileBase::resolve_unsized_adjustment (Resolver::Adjustment &adjustment,\n     = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n \n   // make a constructor for this\n-  tree data = address_expression (expression, locus);\n+  tree data\n+    = address_expression (expression,\n+\t\t\t  build_reference_type (TREE_TYPE (expression)), locus);\n \n   // fetch the size from the domain\n   tree domain = TYPE_DOMAIN (expr_type);\n@@ -1414,7 +1418,8 @@ CompileExpr::visit (HIR::IdentifierExpr &expr)\n   else if (ctx->lookup_function_decl (ref, &fn))\n     {\n       TREE_USED (fn) = 1;\n-      translated = address_expression (fn, expr.get_locus ());\n+      translated = address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n+\t\t\t\t       expr.get_locus ());\n     }\n   else if (ctx->lookup_var_decl (ref, &var))\n     {"}, {"sha": "c13556aaa919f9a06cf716d54ed507a026032ab6", "filename": "gcc/rust/backend/rust-compile-implitem.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc?ref=ca722fe423bdd8c7895a40aac0410b2646917805", "patch": "@@ -68,7 +68,10 @@ CompileTraitItem::visit (HIR::TraitItemFunc &func)\n \t    {\n \t      ctx->insert_function_decl (fntype, lookup);\n \t    }\n-\t  reference = address_expression (lookup, ref_locus);\n+\t  reference\n+\t    = address_expression (lookup,\n+\t\t\t\t  build_pointer_type (TREE_TYPE (lookup)),\n+\t\t\t\t  ref_locus);\n \t  return;\n \t}\n     }\n@@ -95,7 +98,9 @@ CompileTraitItem::visit (HIR::TraitItemFunc &func)\n \t\t\tfunc.get_outer_attrs (), func.get_locus (),\n \t\t\tfunc.get_block_expr ().get (), canonical_path, fntype,\n \t\t\tfunction.has_return_type ());\n-  reference = address_expression (fndecl, ref_locus);\n+  reference\n+    = address_expression (fndecl, build_pointer_type (TREE_TYPE (fndecl)),\n+\t\t\t  ref_locus);\n }\n \n } // namespace Compile"}, {"sha": "36fa78757ac520df9cb11f9d8c4e78ea5b97db4b", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=ca722fe423bdd8c7895a40aac0410b2646917805", "patch": "@@ -146,7 +146,10 @@ CompileItem::visit (HIR::Function &function)\n \t      ctx->insert_function_decl (fntype, lookup);\n \t    }\n \n-\t  reference = address_expression (lookup, ref_locus);\n+\t  reference\n+\t    = address_expression (lookup,\n+\t\t\t\t  build_pointer_type (TREE_TYPE (lookup)),\n+\t\t\t\t  ref_locus);\n \t  return;\n \t}\n     }\n@@ -171,7 +174,9 @@ CompileItem::visit (HIR::Function &function)\n \t\t\tfunction.get_outer_attrs (), function.get_locus (),\n \t\t\tfunction.get_definition ().get (), canonical_path,\n \t\t\tfntype, function.has_function_return_type ());\n-  reference = address_expression (fndecl, ref_locus);\n+  reference\n+    = address_expression (fndecl, build_pointer_type (TREE_TYPE (fndecl)),\n+\t\t\t  ref_locus);\n }\n \n void"}, {"sha": "bd44bf45791624591dc772af94c1886b6ca0e42f", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=ca722fe423bdd8c7895a40aac0410b2646917805", "patch": "@@ -141,14 +141,16 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n \t  TREE_USED (fn) = 1;\n-\t  return address_expression (fn, expr_locus);\n+\t  return address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n+\t\t\t\t     expr_locus);\n \t}\n       else if (fntype->get_abi () == ABI::INTRINSIC)\n \t{\n \t  Intrinsics compile (ctx);\n \t  fn = compile.compile (fntype);\n \t  TREE_USED (fn) = 1;\n-\t  return address_expression (fn, expr_locus);\n+\t  return address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n+\t\t\t\t     expr_locus);\n \t}\n     }\n "}, {"sha": "5c9bbf90e66ac03f59b0f7589609d9451967a13b", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 100, "deletions": 62, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca722fe423bdd8c7895a40aac0410b2646917805/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=ca722fe423bdd8c7895a40aac0410b2646917805", "patch": "@@ -202,27 +202,104 @@ HIRCompileBase::coercion_site (tree rvalue, TyTy::BaseType *actual,\n \t\t\t       TyTy::BaseType *expected, Location lvalue_locus,\n \t\t\t       Location rvalue_locus)\n {\n-  auto root_actual_kind = actual->get_root ()->get_kind ();\n-  auto root_expected_kind = expected->get_root ()->get_kind ();\n+  if (rvalue == error_mark_node)\n+    return error_mark_node;\n \n-  if (root_expected_kind == TyTy::TypeKind::ARRAY\n-      && root_actual_kind == TyTy::TypeKind::ARRAY)\n+  if (expected->get_kind () == TyTy::TypeKind::REF)\n     {\n-      tree tree_rval_type\n-\t= TyTyResolveCompile::compile (ctx, actual->get_root ());\n-      tree tree_lval_type\n-\t= TyTyResolveCompile::compile (ctx, expected->get_root ());\n+      // bad coercion... of something to a reference\n+      if (actual->get_kind () != TyTy::TypeKind::REF)\n+\treturn error_mark_node;\n+\n+      TyTy::ReferenceType *exp = static_cast<TyTy::ReferenceType *> (expected);\n+      TyTy::ReferenceType *act = static_cast<TyTy::ReferenceType *> (actual);\n+\n+      tree expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n+      tree deref_rvalue\n+\t= ctx->get_backend ()->indirect_expression (expected_type, rvalue,\n+\t\t\t\t\t\t    false /*known_valid*/,\n+\t\t\t\t\t\t    rvalue_locus);\n+      tree coerced\n+\t= coercion_site (deref_rvalue, act->get_base (), exp->get_base (),\n+\t\t\t lvalue_locus, rvalue_locus);\n+\n+      return address_expression (coerced,\n+\t\t\t\t build_reference_type (TREE_TYPE (coerced)),\n+\t\t\t\t rvalue_locus);\n+    }\n+  else if (expected->get_kind () == TyTy::TypeKind::POINTER)\n+    {\n+      // bad coercion... of something to a reference\n+      bool valid_coercion = actual->get_kind () == TyTy::TypeKind::REF\n+\t\t\t    || actual->get_kind () == TyTy::TypeKind::POINTER;\n+      if (!valid_coercion)\n+\treturn error_mark_node;\n+\n+      TyTy::ReferenceType *exp = static_cast<TyTy::ReferenceType *> (expected);\n+\n+      TyTy::BaseType *actual_base = nullptr;\n+      tree expected_type = error_mark_node;\n+      if (actual->get_kind () == TyTy::TypeKind::REF)\n+\t{\n+\t  TyTy::ReferenceType *act\n+\t    = static_cast<TyTy::ReferenceType *> (actual);\n+\t  actual_base = act->get_base ();\n+\t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n+\t}\n+      else if (actual->get_kind () == TyTy::TypeKind::POINTER)\n+\t{\n+\t  TyTy::PointerType *act = static_cast<TyTy::PointerType *> (actual);\n+\t  actual_base = act->get_base ();\n+\t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n+\t}\n+      rust_assert (actual_base != nullptr);\n+\n+      tree deref_rvalue\n+\t= ctx->get_backend ()->indirect_expression (expected_type, rvalue,\n+\t\t\t\t\t\t    false /*known_valid*/,\n+\t\t\t\t\t\t    rvalue_locus);\n+      tree coerced = coercion_site (deref_rvalue, actual_base, exp->get_base (),\n+\t\t\t\t    lvalue_locus, rvalue_locus);\n+\n+      return address_expression (coerced,\n+\t\t\t\t build_pointer_type (TREE_TYPE (coerced)),\n+\t\t\t\t rvalue_locus);\n+    }\n+  else if (expected->get_kind () == TyTy::TypeKind::ARRAY)\n+    {\n+      if (actual->get_kind () != TyTy::TypeKind::ARRAY)\n+\treturn error_mark_node;\n+\n+      tree tree_rval_type = TyTyResolveCompile::compile (ctx, actual);\n+      tree tree_lval_type = TyTyResolveCompile::compile (ctx, expected);\n       if (!verify_array_capacities (tree_lval_type, tree_rval_type,\n \t\t\t\t    lvalue_locus, rvalue_locus))\n \treturn error_mark_node;\n     }\n-  else if (root_expected_kind == TyTy::TypeKind::DYNAMIC\n-\t   && root_actual_kind != TyTy::TypeKind::DYNAMIC)\n+  else if (expected->get_kind () == TyTy::TypeKind::DYNAMIC\n+\t   && actual->get_kind () != TyTy::TypeKind::DYNAMIC)\n     {\n       const TyTy::DynamicObjectType *dyn\n-\t= static_cast<const TyTy::DynamicObjectType *> (expected->get_root ());\n+\t= static_cast<const TyTy::DynamicObjectType *> (expected);\n       return coerce_to_dyn_object (rvalue, actual, expected, dyn, rvalue_locus);\n     }\n+  else if (expected->get_kind () == TyTy::TypeKind::SLICE)\n+    {\n+      // bad coercion\n+      bool valid_coercion = actual->get_kind () == TyTy::TypeKind::SLICE\n+\t\t\t    || actual->get_kind () == TyTy::TypeKind::ARRAY;\n+      if (!valid_coercion)\n+\treturn error_mark_node;\n+\n+      // nothing to do here\n+      if (actual->get_kind () == TyTy::TypeKind::SLICE)\n+\treturn rvalue;\n+\n+      // return an unsized coercion\n+      Resolver::Adjustment unsize_adj (\n+\tResolver::Adjustment::AdjustmentType::UNSIZE, expected);\n+      return resolve_unsized_adjustment (unsize_adj, rvalue, rvalue_locus);\n+    }\n \n   return rvalue;\n }\n@@ -240,69 +317,30 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n   // __trait_object_ptr\n   // [list of function ptrs]\n \n-  auto root = actual->get_root ();\n   std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n-    probed_bounds_for_receiver = Resolver::TypeBoundsProbe::Probe (root);\n-\n+    probed_bounds_for_receiver = Resolver::TypeBoundsProbe::Probe (actual);\n+\n+  tree address_of_compiled_ref = null_pointer_node;\n+  if (!actual->is_unit ())\n+    address_of_compiled_ref\n+      = address_expression (compiled_ref,\n+\t\t\t    build_pointer_type (TREE_TYPE (compiled_ref)),\n+\t\t\t    locus);\n   std::vector<tree> vals;\n-  vals.push_back (compiled_ref);\n+  vals.push_back (address_of_compiled_ref);\n   for (auto &bound : ty->get_object_items ())\n     {\n       const Resolver::TraitItemReference *item = bound.first;\n       const TyTy::TypeBoundPredicate *predicate = bound.second;\n \n       auto address = compute_address_for_trait_item (item, predicate,\n \t\t\t\t\t\t     probed_bounds_for_receiver,\n-\t\t\t\t\t\t     actual, root, locus);\n+\t\t\t\t\t\t     actual, actual, locus);\n       vals.push_back (address);\n     }\n \n-  tree constructed_trait_object\n-    = ctx->get_backend ()->constructor_expression (dynamic_object, false, vals,\n-\t\t\t\t\t\t   -1, locus);\n-\n-  fncontext fnctx = ctx->peek_fn ();\n-  tree enclosing_scope = ctx->peek_enclosing_scope ();\n-  bool is_address_taken = false;\n-  tree ret_var_stmt = NULL_TREE;\n-\n-  Bvariable *dyn_tmp = ctx->get_backend ()->temporary_variable (\n-    fnctx.fndecl, enclosing_scope, dynamic_object, constructed_trait_object,\n-    is_address_taken, locus, &ret_var_stmt);\n-  ctx->add_statement (ret_var_stmt);\n-\n-  // FIXME this needs to be more generic to apply any covariance\n-\n-  auto e = expected;\n-  std::vector<Resolver::Adjustment> adjustments;\n-  while (e->get_kind () == TyTy::TypeKind::REF)\n-    {\n-      auto r = static_cast<const TyTy::ReferenceType *> (e);\n-      e = r->get_base ();\n-\n-      if (r->is_mutable ())\n-\tadjustments.push_back (\n-\t  Resolver::Adjustment (Resolver::Adjustment::AdjustmentType::MUT_REF,\n-\t\t\t\te));\n-      else\n-\tadjustments.push_back (\n-\t  Resolver::Adjustment (Resolver::Adjustment::AdjustmentType::IMM_REF,\n-\t\t\t\te));\n-    }\n-\n-  auto resulting_dyn_object_ref\n-    = ctx->get_backend ()->var_expression (dyn_tmp, locus);\n-  for (auto it = adjustments.rbegin (); it != adjustments.rend (); it++)\n-    {\n-      bool ok\n-\t= it->get_type () == Resolver::Adjustment::AdjustmentType::IMM_REF\n-\t  || it->get_type () == Resolver::Adjustment::AdjustmentType::MUT_REF;\n-      rust_assert (ok);\n-\n-      resulting_dyn_object_ref\n-\t= address_expression (resulting_dyn_object_ref, locus);\n-    }\n-  return resulting_dyn_object_ref;\n+  return ctx->get_backend ()->constructor_expression (dynamic_object, false,\n+\t\t\t\t\t\t      vals, -1, locus);\n }\n \n tree"}]}