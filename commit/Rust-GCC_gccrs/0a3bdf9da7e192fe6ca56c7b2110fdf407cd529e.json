{"sha": "0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEzYmRmOWRhN2UxOTJmZTZjYTU2YzdiMjExMGZkZjQwN2NkNTI5ZQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-09-12T12:37:17Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-09-12T12:37:17Z"}, "message": "s390-modes.def (CCAPmode, CCANmode): New CC modes.\n\n\t* config/s390/s390-modes.def (CCAPmode, CCANmode): New CC modes.\n\t* config/s390/s390.c (s390_match_ccmode_set): Support new CC modes.\n\t(s390_select_ccmode): Likewise.\n\t(s390_branch_condition_mask): Likewise.\n\t(optimization_options): Do not set flag_branch_on_count.\n\t(s390_split_branches): Handle doloop branches.\n\t(s390_chunkify_pool): Likewise.\n\t* config/s390/s390.md (\"*adddi3_imm_cc\", \"*addsi3_imm_cc\"): New insns.\n\t(\"doloop_end\"): New expander.\n\t(\"doolop_si\", \"*doloop_si_long\", \"doloop_di\", \"*doloop_di_long\",\n\tassociated splitters): New.\n\nFrom-SVN: r57060", "tree": {"sha": "c09f1ced7a79890e1cfd65982f2caf85ad9e44cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c09f1ced7a79890e1cfd65982f2caf85ad9e44cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e/comments", "author": null, "committer": null, "parents": [{"sha": "81ea34e1c1eda6d8715cf95a9f33e86ca0713d40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ea34e1c1eda6d8715cf95a9f33e86ca0713d40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ea34e1c1eda6d8715cf95a9f33e86ca0713d40"}], "stats": {"total": 381, "additions": 297, "deletions": 84}, "files": [{"sha": "96ccecc8b94bc103704d2a51fd850a62632a41c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e", "patch": "@@ -1,3 +1,17 @@\n+2002-09-12  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390-modes.def (CCAPmode, CCANmode): New CC modes.\n+\t* config/s390/s390.c (s390_match_ccmode_set): Support new CC modes.\n+\t(s390_select_ccmode): Likewise.\n+\t(s390_branch_condition_mask): Likewise.\n+\t(optimization_options): Do not set flag_branch_on_count.\n+\t(s390_split_branches): Handle doloop branches.\n+\t(s390_chunkify_pool): Likewise.\n+\t* config/s390/s390.md (\"*adddi3_imm_cc\", \"*addsi3_imm_cc\"): New insns.\n+\t(\"doloop_end\"): New expander.\n+\t(\"doolop_si\", \"*doloop_si_long\", \"doloop_di\", \"*doloop_di_long\",\n+\tassociated splitters): New.\n+\n 2002-09-11  Hartmut Penner  <hpenner@de.ibm.com>\n \n \t* fold-const.c (make_range): Only narrow to signed range if"}, {"sha": "9f9d5265720e987d9937e74a31087c038345b65b", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e", "patch": "@@ -23,6 +23,8 @@ Boston, MA 02111-1307, USA.  */\n \n CC (CCZ)\n CC (CCA)\n+CC (CCAP)\n+CC (CCAN)\n CC (CCL)\n CC (CCL1)\n CC (CCL2)"}, {"sha": "26c4dd2fe3d5430711741ab64ca3b36ee82abc39", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 79, "deletions": 41, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e", "patch": "@@ -182,6 +182,12 @@ s390_match_ccmode_set (set, req_mode)\n \t  && req_mode != CCSRmode && req_mode != CCURmode)\n         return 0;\n       break;\n+\n+    case CCAPmode:\n+    case CCANmode:\n+      if (req_mode != CCAmode)\n+        return 0;\n+      break;\n  \n     default:\n       abort ();\n@@ -274,6 +280,9 @@ s390_select_ccmode (code, op0, op1)\n     {\n       case EQ:\n       case NE:\n+\tif (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t    && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op0, 1)), 'K')) \n+\t  return CCAPmode;\n \tif (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n \t    || GET_CODE (op1) == NEG)\n \t  return CCLmode;\n@@ -306,6 +315,14 @@ s390_select_ccmode (code, op0, op1)\n       case LT:\n       case GE:\n       case GT:\n+\t  if (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op0, 1)), 'K')) \n+            {\n+\t      if (INTVAL (XEXP((op0), 1)) < 0)\n+\t        return CCANmode;\n+              else\n+\t        return CCAPmode;\n+\t    }\n       case UNORDERED:\n       case ORDERED:\n       case UNEQ:\n@@ -461,6 +478,34 @@ s390_branch_condition_mask (code)\n         }\n       break;\n \n+    case CCAPmode:\n+      switch (GET_CODE (code))\n+        {\n+        case EQ:\treturn CC0;\n+        case NE:\treturn CC1 | CC2 | CC3;\n+        case LT:\treturn CC1 | CC3;\n+        case GT:\treturn CC2;\n+        case LE:\treturn CC0 | CC1 | CC3;\n+        case GE:\treturn CC0 | CC2;\n+\tdefault:\n+\t  abort ();\n+        }\n+      break;\n+\n+    case CCANmode:\n+      switch (GET_CODE (code))\n+        {\n+        case EQ:\treturn CC0;\n+        case NE:\treturn CC1 | CC2 | CC3;\n+        case LT:\treturn CC1;\n+        case GT:\treturn CC2 | CC3;\n+        case LE:\treturn CC0 | CC1;\n+        case GE:\treturn CC0 | CC2 | CC3;\n+\tdefault:\n+\t  abort ();\n+        }\n+      break;\n+\n     case CCSmode:\n       switch (GET_CODE (code))\n         {\n@@ -758,11 +803,6 @@ optimization_options (level, size)\n      int level ATTRIBUTE_UNUSED;\n      int size ATTRIBUTE_UNUSED;\n {\n-#ifdef HAVE_decrement_and_branch_on_count\n-  /* When optimizing, enable use of BRCT instruction.  */\n-  if (level >= 1)\n-      flag_branch_on_count_reg = 1;\n-#endif\n }\n \n void\n@@ -2605,12 +2645,8 @@ static void\n s390_split_branches ()\n {\n   rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n-  rtx insn, pat, label, target, jump, tmp;\n-\n-  /* In 64-bit mode we can jump +- 4GB.  */\n-\n-  if (TARGET_64BIT)\n-    return;\n+  rtx insn, pat, tmp, target;\n+  rtx *label;\n \n   /* We need correct insn addresses.  */\n \n@@ -2624,62 +2660,61 @@ s390_split_branches ()\n \tcontinue;\n \n       pat = PATTERN (insn);\n-      if (GET_CODE (pat) != SET)\n+      if (GET_CODE (pat) == PARALLEL && XVECLEN (pat, 0) > 2)\n+\tpat = XVECEXP (pat, 0, 0);\n+      if (GET_CODE (pat) != SET || SET_DEST (pat) != pc_rtx)\n \tcontinue;\n \n       if (GET_CODE (SET_SRC (pat)) == LABEL_REF) \n \t{\n-\t  label = SET_SRC (pat);\n+\t  label = &SET_SRC (pat);\n \t} \n       else if (GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE) \n \t{\n \t  if (GET_CODE (XEXP (SET_SRC (pat), 1)) == LABEL_REF) \n-\t    label = XEXP (SET_SRC (pat), 1);\n+\t    label = &XEXP (SET_SRC (pat), 1);\n           else if (GET_CODE (XEXP (SET_SRC (pat), 2)) == LABEL_REF) \n-            label = XEXP (SET_SRC (pat), 2);\n+            label = &XEXP (SET_SRC (pat), 2);\n \t  else\n \t    continue;\n         }\n       else\n \tcontinue;\n \n-      if (get_attr_length (insn) == 4)\n+      if (get_attr_length (insn) <= (TARGET_64BIT ? 6 : 4))\n \tcontinue;\n \n       regs_ever_live[RETURN_REGNUM] = 1;\n \n-      if (flag_pic)\n+      if (TARGET_64BIT)\n \t{\n-\t  target = gen_rtx_UNSPEC (SImode, gen_rtvec (1, label), 100);\n-\t  target = gen_rtx_CONST (SImode, target);\n-\t  target = force_const_mem (SImode, target);\n-\t  jump = gen_rtx_REG (Pmode, BASE_REGISTER);\n-\t  jump = gen_rtx_PLUS (Pmode, jump, temp_reg);\n+\t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, *label), insn);\n+\t  INSN_ADDRESSES_NEW (tmp, -1);\n+\n+\t  target = temp_reg;\n \t}\n-      else\n+      else if (!flag_pic)\n \t{\n-\t  target = force_const_mem (Pmode, label);\n-\t  jump = temp_reg;\n-\t}\n+\t  tmp = force_const_mem (Pmode, *label);\n+\t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, tmp), insn);\n+\t  INSN_ADDRESSES_NEW (tmp, -1);\n \n-      if (GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE)\n+\t  target = temp_reg;\n+\t}\n+      else\n \t{\n-\t  if (GET_CODE (XEXP (SET_SRC (pat), 1)) == LABEL_REF)\n-\t    jump = gen_rtx_IF_THEN_ELSE (VOIDmode, XEXP (SET_SRC (pat), 0),\n-\t\t\t\t\t jump, pc_rtx);\n-\t  else\n-\t    jump = gen_rtx_IF_THEN_ELSE (VOIDmode, XEXP (SET_SRC (pat), 0),\n-\t\t\t\t\t pc_rtx, jump);\n+\t  tmp = gen_rtx_UNSPEC (SImode, gen_rtvec (1, *label), 100);\n+\t  tmp = gen_rtx_CONST (SImode, tmp);\n+\t  tmp = force_const_mem (SImode, tmp);\n+\t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, tmp), insn);\n+\t  INSN_ADDRESSES_NEW (tmp, -1);\n+\n+\t  target = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\t  target = gen_rtx_PLUS (Pmode, target, temp_reg);\n \t}\n \n-      tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, target), insn);\n-      INSN_ADDRESSES_NEW (tmp, -1);\n-\n-      tmp = emit_jump_insn_before (gen_rtx_SET (VOIDmode, pc_rtx, jump), insn);\n-      INSN_ADDRESSES_NEW (tmp, -1);\n-\n-      remove_insn (insn);\n-      insn = tmp;\n+      if (!validate_change (insn, label, target, 0))\n+\tabort ();\n     }\n }\n \n@@ -3177,6 +3212,9 @@ s390_chunkify_pool ()\n       else if (GET_CODE (insn) == JUMP_INSN) \n \t{\n           rtx pat = PATTERN (insn);\n+\t  if (GET_CODE (pat) == PARALLEL && XVECLEN (pat, 0) > 2)\n+\t    pat = XVECEXP (pat, 0, 0);\n+\n           if (GET_CODE (pat) == SET) \n             {\n \t      rtx label = 0;"}, {"sha": "3974e21cfd446823e1b26ef2d78578f6f502a0f9", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 202, "deletions": 43, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=0a3bdf9da7e192fe6ca56c7b2110fdf407cd529e", "patch": "@@ -3080,6 +3080,20 @@\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"atype\"    \"reg,mem\")])\n \n+(define_insn \"*adddi3_imm_cc\"\n+  [(set (reg 33) \n+        (compare (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n+                          (match_operand:DI 2 \"const_int_operand\" \"K\"))\n+                 (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\t \n+   && s390_match_ccmode (insn, CCAmode) \n+   && CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')\"\n+  \"aghi\\\\t%0,%h2\"\n+  [(set_attr \"op_type\"  \"RI\")\n+   (set_attr \"atype\"    \"reg\")])  \n+\n (define_insn \"*adddi3_cc\"\n   [(set (reg 33) \n         (compare (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n@@ -3210,6 +3224,19 @@\n     (set_attr \"atype\"    \"mem\")\n     (set_attr \"type\"     \"la\")])\n \n+(define_insn \"*addsi3_imm_cc\"\n+  [(set (reg 33) \n+        (compare (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+                          (match_operand:SI 2 \"const_int_operand\" \"K\"))\n+                 (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (plus:SI (match_dup 1) (match_dup 2)))]\n+  \"s390_match_ccmode (insn, CCAmode)\n+   && CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')\"\n+  \"ahi\\\\t%0,%h2\"\n+  [(set_attr \"op_type\"  \"RI\")\n+   (set_attr \"atype\"    \"reg\")])  \n+\n (define_insn \"*addsi3_carry1_cc\"\n   [(set (reg 33) \n         (compare (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n@@ -5945,52 +5972,184 @@\n \n \n ;;\n-;;- Subtract one and jump if not zero.\n+;;- Loop instructions.\n ;;\n+;;  This is all complicated by the fact that since this is a jump insn\n+;;  we must handle our own output reloads.\n+ \n+(define_expand \"doloop_end\"\n+  [(use (match_operand 0 \"\" \"\"))        ; loop pseudo\n+   (use (match_operand 1 \"\" \"\"))        ; iterations; zero if unknown\n+   (use (match_operand 2 \"\" \"\"))        ; max iterations\n+   (use (match_operand 3 \"\" \"\"))        ; loop level\n+   (use (match_operand 4 \"\" \"\"))]       ; label\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE (operands[0]) == SImode)\n+    emit_jump_insn (gen_doloop_si (operands[4], operands[0], operands[0]));\n+  else if (GET_MODE (operands[0]) == DImode && TARGET_64BIT)\n+    emit_jump_insn (gen_doloop_di (operands[4], operands[0], operands[0]));\n+  else\n+    FAIL;\n+\n+  DONE;\n+}\")\n+\n+(define_insn \"doloop_si\"\n+  [(set (pc)\n+        (if_then_else\n+          (ne (match_operand:SI 1 \"register_operand\" \"d,d\")\n+              (const_int 1))\n+          (label_ref (match_operand 0 \"\" \"\"))\n+          (pc)))\n+   (set (match_operand:SI 2 \"register_operand\" \"=1,?*m*d\")\n+        (plus:SI (match_dup 1) (const_int -1)))\n+   (clobber (match_scratch:SI 3 \"=X,&d\"))\n+   (clobber (reg:CC 33))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative != 0)\n+    return \\\"#\\\";\n+  else if (get_attr_length (insn) == 4)\n+    return \\\"brct\\\\t%1,%l0\\\";\n+  else\n+    abort ();\n+}\"\n+  [(set_attr \"op_type\"  \"RI\")\n+   (set (attr \"length\")\n+        (cond [(lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n+                (const_int 4)\n+               (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n+                 (const_int 10)\n+\t       (ne (symbol_ref \"s390_pool_overflow\") (const_int 0))\n+                 (if_then_else (eq (symbol_ref \"flag_pic\") (const_int 0))\n+                               (const_int 12) (const_int 14))\n+               (eq (symbol_ref \"flag_pic\") (const_int 0))\n+                 (const_int 6)] (const_int 8)))])\n+\n+(define_insn \"*doloop_si_long\"\n+  [(set (pc)\n+        (if_then_else\n+          (ne (match_operand:SI 1 \"register_operand\" \"d,d\")\n+              (const_int 1))\n+          (match_operand 0 \"address_operand\" \"p,p\")\n+          (pc)))\n+   (set (match_operand:SI 2 \"register_operand\" \"=1,?*m*d\")\n+        (plus:SI (match_dup 1) (const_int -1)))\n+   (clobber (match_scratch:SI 3 \"=X,&d\"))\n+   (clobber (reg:CC 33))]\n+  \"\"\n+  \"*\n+{\n+  if (get_attr_op_type (insn) == OP_TYPE_RR)\n+    return \\\"bctr\\\\t%0\\\";\n+  else\n+    return \\\"bct\\\\t%a0\\\";\n+}\"\n+  [(set (attr \"op_type\") \n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"RR\") (const_string \"RX\")))\n+   (set_attr \"atype\" \"mem\")])\n \n-;(define_expand \"decrement_and_branch_on_count\"\n-;  [(use (match_operand 0 \"register_operand\" \"\"))\n-;   (use (label_ref (match_operand 1 \"\" \"\")))]\n-;  \"\"\n-;  \"\n-;{\n-;/*  if (TARGET_64BIT)\n-;    emit_jump_insn (gen_brctdi (operands[0], operands[1]));\n-;  else */\n-;    emit_jump_insn (gen_brctsi (operands[0], operands[1]));\n-;  DONE;\n-;}\")\n-;\n-;(define_insn \"brctsi\"\n-;  [(set (pc)\n-;        (if_then_else\n-;           (ne (match_operand:SI 0 \"register_operand\" \"+a\")\n-;               (const_int 1))\n-;           (label_ref (match_operand 1 \"\" \"\"))\n-;           (pc)))\n-;   (set (match_dup 0)\n-;        (plus:SI (match_dup 0) (const_int -1)))]\n-;  \"\"\n-;  \"brct\\\\t%0,%l1\"\n-;   [(set_attr \"op_type\" \"RI\")\n-;    (set_attr \"type\"    \"branch\")]\n-;)\n-;\n-;(define_insn \"ibrctsi\"\n-;  [(set (pc)\n-;        (if_then_else\n-;          (eq (match_operand:SI 0 \"register_operand\" \"+a\")\n-;              (const_int 1))\n-;          (pc)\n-;          (label_ref (match_operand 1 \"\" \"\"))))\n-;   (set (match_dup 0)\n-;        (plus:SI (match_dup 0) (const_int -1)))]\n-;  \"\"\n-;  \"brct\\\\t%0,%l1\"\n-;   [(set_attr \"op_type\" \"RI\")\n-;    (set_attr \"type\"    \"branch\")]\n-;)\n+(define_split\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:SI 1 \"register_operand\" \"\")\n+                          (const_int 1))\n+                      (match_operand 0 \"\" \"\")\n+                      (pc)))\n+   (set (match_operand:SI 2 \"nonimmediate_operand\" \"\")\n+        (plus:SI (match_dup 1) (const_int -1)))\n+   (clobber (match_scratch:SI 3 \"\"))\n+   (clobber (reg:CC 33))]\n+  \"reload_completed\n+   && (! REG_P (operands[2])\n+       || ! rtx_equal_p (operands[1], operands[2]))\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (parallel [(set (reg:CCAN 33)\n+                   (compare:CCAN (plus:SI (match_dup 3) (const_int -1))\n+                                 (const_int 0)))\n+              (set (match_dup 3) (plus:SI (match_dup 3) (const_int -1)))])\n+   (set (match_dup 2) (match_dup 3))\n+   (set (pc) (if_then_else (ne (reg:CCAN 33) (const_int 0))\n+                           (match_dup 0)\n+                           (pc)))]\n+  \"\")\n+\n+(define_insn \"doloop_di\"\n+  [(set (pc)\n+        (if_then_else\n+          (ne (match_operand:DI 1 \"register_operand\" \"d,d\")\n+              (const_int 1))\n+          (label_ref (match_operand 0 \"\" \"\"))\n+          (pc)))\n+   (set (match_operand:DI 2 \"register_operand\" \"=1,?*m*r\")\n+        (plus:DI (match_dup 1) (const_int -1)))\n+   (clobber (match_scratch:DI 3 \"=X,&d\"))\n+   (clobber (reg:CC 33))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  if (which_alternative != 0)\n+    return \\\"#\\\";\n+  else if (get_attr_length (insn) == 4)\n+    return \\\"brctg\\\\t%1,%l0\\\";\n+  else\n+    abort ();\n+}\"\n+  [(set_attr \"op_type\"  \"RI\")\n+   (set (attr \"length\")\n+        (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n+                      (const_int 4) (const_int 12)))])\n+\n+(define_insn \"*doloop_di_long\"\n+  [(set (pc)\n+        (if_then_else\n+          (ne (match_operand:DI 1 \"register_operand\" \"d,d\")\n+              (const_int 1))\n+          (match_operand 0 \"address_operand\" \"p,p\")\n+          (pc)))\n+   (set (match_operand:DI 2 \"register_operand\" \"=1,?*m*d\")\n+        (plus:DI (match_dup 1) (const_int -1)))\n+   (clobber (match_scratch:DI 3 \"=X,&d\"))\n+   (clobber (reg:CC 33))]\n+  \"\"\n+  \"*\n+{\n+  if (get_attr_op_type (insn) == OP_TYPE_RRE)\n+    return \\\"bctgr\\\\t%0\\\";\n+  else\n+    return \\\"bctg\\\\t%a0\\\";\n+}\"\n+  [(set (attr \"op_type\") \n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"RRE\") (const_string \"RXE\")))\n+   (set_attr \"atype\" \"mem\")])\n \n+(define_split\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:DI 1 \"register_operand\" \"\")\n+                          (const_int 1))\n+                      (match_operand 0 \"\" \"\")\n+                      (pc)))\n+   (set (match_operand:DI 2 \"nonimmediate_operand\" \"\")\n+        (plus:DI (match_dup 1) (const_int -1)))\n+   (clobber (match_scratch:DI 3 \"\"))\n+   (clobber (reg:CC 33))]\n+  \"reload_completed\n+   && (! REG_P (operands[2])\n+       || ! rtx_equal_p (operands[1], operands[2]))\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (parallel [(set (reg:CCAN 33)\n+                   (compare:CCAN (plus:DI (match_dup 3) (const_int -1))\n+                                 (const_int 0)))\n+              (set (match_dup 3) (plus:DI (match_dup 3) (const_int -1)))])\n+   (set (match_dup 2) (match_dup 3))\n+   (set (pc) (if_then_else (ne (reg:CCAN 33) (const_int 0))\n+                           (match_dup 0)\n+                           (pc)))]\n+  \"\")\n \n ;;\n ;;- Unconditional jump instructions."}]}