{"sha": "1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE5ODE0MmJhNmM2ZjRlYjRhMDc1NDljNmMzOWY4OWNhNWVjNDhjNg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-03-12T23:53:35Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-03-12T23:53:35Z"}, "message": "* cppinternals.texi: Update for file handling.\n\nFrom-SVN: r40432", "tree": {"sha": "a871ad56cf7e138732a3166b3e79fc6ecfd5c5cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a871ad56cf7e138732a3166b3e79fc6ecfd5c5cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6/comments", "author": null, "committer": null, "parents": [{"sha": "a84efb51f78ec2224091306024e5e52a3563e070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a84efb51f78ec2224091306024e5e52a3563e070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a84efb51f78ec2224091306024e5e52a3563e070"}], "stats": {"total": 85, "additions": 76, "deletions": 9}, "files": [{"sha": "2e3fa88eed7bcb85e5ad3ab73510fa15848549b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6", "patch": "@@ -1,3 +1,7 @@\n+2001-03-12  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppinternals.texi: Update for file handling.\n+\n 2001-03-12  Jeffrey Oldham  <oldham@codesourcery.com>\n \n \t* emit-rtl.c (remove_unnecessary_notes): Reverse Richard Kenner's"}, {"sha": "c60a9a8d32bf4ed742657abf74fbbd1b81f19e5d", "filename": "gcc/cppinternals.texi", "status": "modified", "additions": 72, "deletions": 9, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6/gcc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6/gcc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinternals.texi?ref=1198142ba6c6f4eb4a07549c6c39f89ca5ec48c6", "patch": "@@ -184,7 +184,7 @@ problem.\n \n Another place where state flags are used to change behaviour is whilst\n parsing header names.  Normally, a @samp{<} would be lexed as a single\n-token.  After a @samp{#include} directive, though, it should be lexed\n+token.  After a @code{#include} directive, though, it should be lexed\n as a single token as far as the nearest @samp{>} character.  Note that\n we don't allow the terminators of header names to be escaped; the first\n @samp{\"} or @samp{>} terminates the header name.\n@@ -311,7 +311,7 @@ time, each identifier falls into exactly one of three categories:\n @item Macros\n \n These have been declared to be macros, either on the command line or\n-with @samp{#define}.  A few, such as @samp{__TIME__} are builtins\n+with @code{#define}.  A few, such as @samp{__TIME__} are builtins\n entered in the hash table during initialisation.  The hash node for a\n normal macro points to a structure with more information about the\n macro, such as whether it is function-like, how many arguments it takes,\n@@ -321,29 +321,29 @@ contain an enum indicating which of the various builtin macros it is.\n @item Assertions\n \n Assertions are in a separate namespace to macros.  To enforce this, cpp\n-actually prepends a @samp{#} character before hashing and entering it in\n+actually prepends a @code{#} character before hashing and entering it in\n the hash table.  An assertion's node points to a chain of answers to\n that assertion.\n \n @item Void\n \n Everything else falls into this category - an identifier that is not\n currently a macro, or a macro that has since been undefined with\n-@samp{#undef}.\n+@code{#undef}.\n \n When preprocessing C++, this category also includes the named operators,\n such as @samp{xor}.  In expressions these behave like the operators they\n represent, but in contexts where the spelling of a token matters they\n are spelt differently.  This spelling distinction is relevant when they\n-are operands of the stringizing and pasting macro operators @samp{#} and\n-@samp{##}.  Named operator hash nodes are flagged, both to catch the\n+are operands of the stringizing and pasting macro operators @code{#} and\n+@code{##}.  Named operator hash nodes are flagged, both to catch the\n spelling distinction and to prevent them from being defined as macros.\n @end itemize\n \n The same identifiers share the same hash node.  Since each identifier\n token, after lexing, contains a pointer to its hash node, this is used\n to provide rapid lookup of various information.  For example, when\n-parsing a @samp{#define} statement, CPP flags each argument's identifier\n+parsing a @code{#define} statement, CPP flags each argument's identifier\n hash node with the index of that argument.  This makes duplicated\n argument checking an O(1) operation for each argument.  Similarly, for\n each identifier in the macro's expansion, lookup to see if it is an\n@@ -353,11 +353,74 @@ enum stored in its hash node, so that directive lookup is also O(1).\n \n @node Macro Expansion, Files, Hash Nodes, Top\n @unnumbered Macro Expansion Algorithm\n-@printindex cp\n \n @node Files, Index, Macro Expansion, Top\n @unnumbered File Handling\n-@printindex cp\n+@cindex files\n+\n+Fairly obviously, the file handling code of cpplib resides in the file\n+@samp{cppfiles.c}.  It takes care of the details of file searching,\n+opening, reading and caching, for both the main source file and all the\n+headers it recursively includes.\n+\n+The basic strategy is to minimize the number of system calls.  On many\n+systems, the basic @code{open ()} and @code{fstat ()} system calls can\n+be quite expensive.  For every @code{#include}-d file, we need to try\n+all the directories in the search path until we find a match.  Some\n+projects, such as glibc, pass twenty or thirty include paths on the\n+command line, so this can rapidly become time consuming.\n+\n+For a header file we have not encountered before we have little choice\n+but to do this.  However, it is often the case that the same headers are\n+repeatedly included, and in these cases we try to avoid repeating the\n+filesystem queries whilst searching for the correct file.\n+\n+For each file we try to open, we store the constructed path in a splay\n+tree.  This path first undergoes simplification by the function\n+@code{_cpp_simplify_pathname}.  For example,\n+@samp{/usr/include/bits/../foo.h} is simplified to\n+@samp{/usr/include/foo.h} before we enter it in the splay tree and try\n+to @code{open ()} the file.  CPP will then find subsequent uses of\n+@samp{foo.h}, even as @samp{/usr/include/foo.h}, in the splay tree and\n+save system calls.\n+\n+Further, it is likely the file contents have also been cached, saving a\n+@code{read ()} system call.  We don't bother caching the contents of\n+header files that are re-inclusion protected, and whose re-inclusion\n+macro is defined when we leave the header file for the first time.  If\n+the host supports it, we try to map suitably large files into memory,\n+rather than reading them in directly.\n+\n+The include paths are intenally stored on a null-terminated\n+singly-linked list, starting with the @code{\"header.h\"} directory search\n+chain, which then links into the @code{<header.h>} directory chain.\n+\n+Files included with the @code{<foo.h>} syntax start the lookup directly\n+in the second half of this chain.  However, files included with the\n+@code{\"foo.h\"} syntax start at the beginning of the chain, but with one\n+extra directory prepended.  This is the directory of the current file;\n+the one containing the @code{#include} directive.  Prepending this\n+directory on a per-file basis is handled by the function\n+@code{search_from}.\n+\n+Note that a header included with a directory component, such as\n+@code{#include \"mydir/foo.h\"} and opened as\n+@samp{/usr/local/include/mydir/foo.h}, will have the complete path minus\n+the basename @samp{foo.h} as the current directory.\n+\n+Enough information is stored in the splay tree that CPP can immediately\n+tell whether it can skip the header file because of the multiple include\n+optimisation, whether the file didn't exist or couldn't be opened for\n+some reason, or whether the header was flagged not to be re-used, as it\n+is with the obsolete @code{#import} directive.\n+\n+For the benefit of MS-DOS filesystems with an 8.3 filename limitation,\n+CPP offers the ability to treat various include file names as aliases\n+for the real header files with shorter names.  The map from one to the\n+other is found in a special file called @samp{header.gcc}, stored in the\n+command line (or system) include directories to which the mapping\n+applies.  This may be higher up the directory tree than the full path to\n+the file minus the base name.\n \n @node Index,, Files, Top\n @unnumbered Index"}]}