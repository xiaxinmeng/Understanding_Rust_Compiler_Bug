{"sha": "9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY5OGVlMzNmMDIxNGY5ZDg1YjNlYzY3ZjEzOWEwYmI2MDViMjliZg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-07-15T16:05:13Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-07-15T16:05:13Z"}, "message": "Makefile.in: Rebuilt.\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (awt_java_source_files): Added new files.\n\t* java/beans/ExceptionListener.java: Merged with Classpath.\n\t* java/beans/PropertyChangeEvent.java: Merged with Classpath.\n\t* java/beans/PropertyChangeListener.java: Merged with Classpath.\n\t* java/beans/PropertyChangeListenerProxy.java: Merged with Classpath.\n\t* java/beans/PropertyChangeSupport.java: Merged with Classpath.\n\t* java/beans/VetoableChangeListener.java: Merged with Classpath.\n\t* java/beans/VetoableChangeListenerProxy.java: Merged with Classpath.\n\t* java/beans/VetoableChangeSupport.java: Merged with Classpath.\n\nFrom-SVN: r55459", "tree": {"sha": "aed15e12fb5ec9a4f295ff0702895b39b1a9938a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aed15e12fb5ec9a4f295ff0702895b39b1a9938a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/comments", "author": null, "committer": null, "parents": [{"sha": "ed8d29205b130073bd3147cedf068446689a5386", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed8d29205b130073bd3147cedf068446689a5386", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed8d29205b130073bd3147cedf068446689a5386"}], "stats": {"total": 1996, "additions": 1404, "deletions": 592}, "files": [{"sha": "b8981122027a17127365433f9b91eb6747a5a8d5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -1,3 +1,16 @@\n+2002-07-15  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (awt_java_source_files): Added new files.\n+\t* java/beans/ExceptionListener.java: Merged with Classpath.\n+\t* java/beans/PropertyChangeEvent.java: Merged with Classpath.\n+\t* java/beans/PropertyChangeListener.java: Merged with Classpath.\n+\t* java/beans/PropertyChangeListenerProxy.java: Merged with Classpath.\n+\t* java/beans/PropertyChangeSupport.java: Merged with Classpath.\n+\t* java/beans/VetoableChangeListener.java: Merged with Classpath.\n+\t* java/beans/VetoableChangeListenerProxy.java: Merged with Classpath.\n+\t* java/beans/VetoableChangeSupport.java: Merged with Classpath.\n+\n 2002-07-14  Mark Wielaard  <mark@klomp.org>\n \n \t* gnu/java/security/der/DEREncodingException.java,"}, {"sha": "6e5adb991d0ec590b55e409cac2d9f1f60b4b060", "filename": "libjava/Makefile.am", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -799,6 +799,7 @@ java/beans/Beans.java \\\n java/beans/Customizer.java \\\n java/beans/DesignMode.java \\\n java/beans/EventSetDescriptor.java \\\n+java/beans/ExceptionListener.java \\\n java/beans/FeatureDescriptor.java \\\n java/beans/IndexedPropertyDescriptor.java \\\n java/beans/IntrospectionException.java \\\n@@ -807,6 +808,7 @@ java/beans/MethodDescriptor.java \\\n java/beans/ParameterDescriptor.java \\\n java/beans/PropertyChangeEvent.java \\\n java/beans/PropertyChangeListener.java \\\n+java/beans/PropertyChangeListenerProxy.java \\\n java/beans/PropertyChangeSupport.java \\\n java/beans/PropertyDescriptor.java \\\n java/beans/PropertyEditor.java \\\n@@ -815,6 +817,7 @@ java/beans/PropertyEditorSupport.java \\\n java/beans/PropertyVetoException.java \\\n java/beans/SimpleBeanInfo.java \\\n java/beans/VetoableChangeListener.java \\\n+java/beans/VetoableChangeListenerProxy.java \\\n java/beans/VetoableChangeSupport.java \\\n java/beans/Visibility.java\n "}, {"sha": "81ff3fcbe7c472e226e47fb4acbb1df0ba4279f4", "filename": "libjava/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -568,6 +568,7 @@ java/beans/Beans.java \\\n java/beans/Customizer.java \\\n java/beans/DesignMode.java \\\n java/beans/EventSetDescriptor.java \\\n+java/beans/ExceptionListener.java \\\n java/beans/FeatureDescriptor.java \\\n java/beans/IndexedPropertyDescriptor.java \\\n java/beans/IntrospectionException.java \\\n@@ -576,6 +577,7 @@ java/beans/MethodDescriptor.java \\\n java/beans/ParameterDescriptor.java \\\n java/beans/PropertyChangeEvent.java \\\n java/beans/PropertyChangeListener.java \\\n+java/beans/PropertyChangeListenerProxy.java \\\n java/beans/PropertyChangeSupport.java \\\n java/beans/PropertyDescriptor.java \\\n java/beans/PropertyEditor.java \\\n@@ -584,6 +586,7 @@ java/beans/PropertyEditorSupport.java \\\n java/beans/PropertyVetoException.java \\\n java/beans/SimpleBeanInfo.java \\\n java/beans/VetoableChangeListener.java \\\n+java/beans/VetoableChangeListenerProxy.java \\\n java/beans/VetoableChangeSupport.java \\\n java/beans/Visibility.java\n \n@@ -1776,7 +1779,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -2197,20 +2200,23 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/beans/BeanInfo.P .deps/java/beans/Beans.P \\\n .deps/java/beans/Customizer.P .deps/java/beans/DesignMode.P \\\n .deps/java/beans/EventSetDescriptor.P \\\n+.deps/java/beans/ExceptionListener.P \\\n .deps/java/beans/FeatureDescriptor.P \\\n .deps/java/beans/IndexedPropertyDescriptor.P \\\n .deps/java/beans/IntrospectionException.P \\\n .deps/java/beans/Introspector.P .deps/java/beans/MethodDescriptor.P \\\n .deps/java/beans/ParameterDescriptor.P \\\n .deps/java/beans/PropertyChangeEvent.P \\\n .deps/java/beans/PropertyChangeListener.P \\\n+.deps/java/beans/PropertyChangeListenerProxy.P \\\n .deps/java/beans/PropertyChangeSupport.P \\\n .deps/java/beans/PropertyDescriptor.P .deps/java/beans/PropertyEditor.P \\\n .deps/java/beans/PropertyEditorManager.P \\\n .deps/java/beans/PropertyEditorSupport.P \\\n .deps/java/beans/PropertyVetoException.P \\\n .deps/java/beans/SimpleBeanInfo.P \\\n .deps/java/beans/VetoableChangeListener.P \\\n+.deps/java/beans/VetoableChangeListenerProxy.P \\\n .deps/java/beans/VetoableChangeSupport.P .deps/java/beans/Visibility.P \\\n .deps/java/beans/beancontext/BeanContext.P \\\n .deps/java/beans/beancontext/BeanContextChild.P \\"}, {"sha": "09f7d1a8a2e3149d50c65416832befd81de9e86d", "filename": "libjava/java/beans/ExceptionListener.java", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FExceptionListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FExceptionListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FExceptionListener.java?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -0,0 +1,57 @@\n+/* ExceptionListener.java -- listen for recoverable internal exceptions\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.beans;\n+\n+/**\n+ * This interface allows a class to monitor internal exceptions, to try to\n+ * recover from them.\n+ *\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.4\n+ * @status updated to 1.4\n+ */\n+public interface ExceptionListener\n+{\n+  /**\n+   * Fired after an exception occurs.\n+   *\n+   * @param e the trapped exception\n+   */\n+  void exceptionThrown(Exception e);\n+} // interface ExceptionListener"}, {"sha": "83ca681ce13263dad76e7d2ca91dd1ff52af6675", "filename": "libjava/java/beans/PropertyChangeEvent.java", "status": "modified", "additions": 151, "deletions": 86, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FPropertyChangeEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FPropertyChangeEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyChangeEvent.java?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -1,13 +1,13 @@\n-/* java.beans.PropertyChangeEvent\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+/* PropertyChangeEvent.java -- describes a change in a property\n+   Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -38,87 +38,152 @@\n \n package java.beans;\n \n+import java.util.EventObject;\n+\n /**\n- ** PropertyChangeEvents are fired in the PropertyChange\n- ** and VetoableChange event classes.  They represent the\n- ** old and new values as well as the source Bean.<P>\n- **\n- ** If the old or new value is a primitive type, it must\n- ** be wrapped in the appropriate wrapper type\n- ** (java.lang.Integer for int, etc., etc.).<P>\n- **\n- ** If the old or new values are unknown (although why\n- ** that would be I do not know), they may be null.<P>\n- **\n- ** Right now Sun put in a propagationId, reserved for\n- ** future use.  Read the comments on the constructor\n- ** and on setPropagationId for more information.\n- **\n- ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.1.0, 29 Jul 1998\n- **/\n-\n-public class PropertyChangeEvent extends java.util.EventObject {\n-\tString propertyName;\n-\tObject oldValue;\n-\tObject newValue;\n-\tObject propagationId;\n-\n-\tprivate static final long serialVersionUID = 7042693688939648123L;\n-\n-\t/** Create a new PropertyChangeEvent.  Remember that if\n-\t ** you received a PropertyChangeEvent and are sending\n-\t ** a new one, you should also set the propagation ID\n-\t ** from the old PropertyChangeEvent.\n-\t ** @param source the Bean containing the property.\n-\t ** @param propertyName the property's name.\n-\t ** @param oldValue the old value of the property.\n-\t ** @param newValue the new value of the property.\n-\t **/\n-\tpublic PropertyChangeEvent(Object source, String propertyName, Object oldVal, Object newVal) {\n-\t\tsuper(source);\n-\t\tthis.propertyName = propertyName;\n-\t\toldValue = oldVal;\n-\t\tnewValue = newVal;\n-\t}\n-\n-\t/** Get the property name.\n-\t ** @return the property name.\n-\t **/\n-\tpublic String getPropertyName() {\n-\t\treturn propertyName;\n-\t}\n-\n-\t/** Get the property's old value.\n-\t ** @return the property's old value.\n-\t **/\n-\tpublic Object getOldValue() {\n-\t\treturn oldValue;\n-\t}\n-\n-\t/** Get the property's new value.\n-\t ** @return the property's new value.\n-\t **/\n-\tpublic Object getNewValue() {\n-\t\treturn newValue;\n-\t}\n-\n-\t/** Set the propagation ID.  This is a way for the event\n-\t ** to be passed from hand to hand and retain a little\n-\t ** extra state.  Right now it is unused, but it should\n-\t ** be propagated anyway so that future versions of\n-\t ** JavaBeans can use it, for God knows what.\n-\t ** @param propagationId the propagation ID.\n-\t **/\n-\tpublic void setPropagationId(Object propagationId) {\n-\t\tthis.propagationId = propagationId;\n-\t}\n-\n-\t/** Get the propagation ID.\n-\t ** @return the propagation ID.\n-\t **/\n-\tpublic Object getPropagationId() {\n-\t\treturn propagationId;\n-\t}\n-}\n+ * PropertyChangeEvents are fired in the PropertyChange and VetoableChange\n+ * event classes.  They represent the old and new values as well as the\n+ * source Bean. If the old or new value is a primitive type, it must be\n+ * wrapped in the appropriate wrapper type (java.lang.Integer for int, etc.,\n+ * etc.).\n+ *\n+ * <p>If the old or new values are unknown (although why that would be I do\n+ * not know), they may be null. Also, if the set of properties itself has\n+ * changed, the name should be null, and the old and new values may also be\n+ * null. Right now Sun put in a propagationId, reserved for future use. Read\n+ * the comments on the constructor and on setPropagationId for more\n+ * information.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.1\n+ * @status udpated to 1.4\n+ */\n+public class PropertyChangeEvent extends EventObject\n+{\n+  /**\n+   * Compatible with JDK 1.1+.\n+   */\n+  private static final long serialVersionUID = 7042693688939648123L;\n+\n+  /**\n+   * The name of the property that changed, may be null. Package visible for\n+   * use by PropertyChangeSupport.\n+   *\n+   * @serial the changed property name\n+   */\n+  final String propertyName;\n+\n+  /**\n+   * The new value of the property, may be null. Package visible for use by\n+   * PropertyChangeSupport.\n+   *\n+   * @serial the new property value\n+   */\n+  final Object newValue;\n+\n+  /**\n+   * The old value of the property, may be null. Package visible for use by\n+   * PropertyChangeSupport.\n+   *\n+   * @serial the old property value\n+   */\n+  final Object oldValue;\n+\n+  /**\n+   * The propagation ID, reserved for future use. May be null.\n+   *\n+   * @see #getPropagationId()\n+   * @serial the Propagation ID\n+   */\n+  private Object propagationId;\n+\n+  /**\n+   * Create a new PropertyChangeEvent. Remember that if you received a\n+   * PropertyChangeEvent and are sending a new one, you should also set the\n+   * propagation ID from the old PropertyChangeEvent.\n+   *\n+   * @param source the Bean containing the property\n+   * @param propertyName the property's name\n+   * @param oldValue the old value of the property\n+   * @param newValue the new value of the property\n+   * @throws IllegalArgumentException if source is null\n+   */\n+  public PropertyChangeEvent(Object source, String propertyName,\n+                             Object oldVal, Object newVal)\n+  {\n+    super(source);\n+    this.propertyName = propertyName;\n+    oldValue = oldVal;\n+    newValue = newVal;\n+  }\n+\n+  /**\n+   * Get the property name. May be null if multiple properties changed.\n+   *\n+   * @return the property name\n+   */\n+  public String getPropertyName()\n+  {\n+    return propertyName;\n+  }\n+\n+  /**\n+   * Get the property's new value. May be null if multiple properties changed.\n+   *\n+   * @return the property's new value\n+   */\n+  public Object getNewValue()\n+  {\n+    return newValue;\n+  }\n+\n+  /**\n+   * Get the property's old value. May be null if multiple properties changed.\n+   *\n+   * @return the property's old value\n+   */\n+  public Object getOldValue()\n+  {\n+    return oldValue;\n+  }\n+\n+  /**\n+   * Set the propagation ID.  This is a way for the event to be passed from\n+   * hand to hand and retain a little extra state.  Right now it is unused,\n+   * but it should be propagated anyway so that future versions of JavaBeans\n+   * can use it, for God knows what.\n+   *\n+   * @param propagationId the propagation ID\n+   * @see #getPropagationId()\n+   */\n+  public void setPropagationId(Object propagationId)\n+  {\n+    this.propagationId = propagationId;\n+  }\n+\n+  /**\n+   * Get the propagation ID. Right now, it is not used for anything.\n+   *\n+   * @return the propagation ID\n+   * @see #setPropagationId(Object)\n+   */\n+  public Object getPropagationId()\n+  {\n+    return propagationId;\n+  }\n+\n+  /**\n+   * Utility method to rollback a change.\n+   *\n+   * @param event the event to rollback\n+   * @return a new event with old and new swapped\n+   */\n+  PropertyChangeEvent rollback()\n+  {\n+    PropertyChangeEvent result\n+      = new PropertyChangeEvent(source, propertyName, newValue, oldValue);\n+    result.propagationId = propagationId;\n+    return result;\n+  }\n+} // class PropertyChangeEvent"}, {"sha": "df5bd867d5bd29366749758321f513e19a1244bb", "filename": "libjava/java/beans/PropertyChangeListener.java", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FPropertyChangeListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FPropertyChangeListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyChangeListener.java?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -1,13 +1,13 @@\n-/* java.beans.PropertyChangeListener\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+/* PropertyChangeListener.java -- listen for changes in a bound property\n+   Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -41,22 +41,21 @@\n import java.util.EventListener;\n \n /**\n- ** PropertyChangeListener allows a class to monitor\n- ** properties of a Bean for changes.<P>\n- **\n- ** A propertyChange() event will only be fired\n- ** <EM>after</EM> the property has changed.\n- **\n- ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.1.0, 29 Jul 1998\n- ** @see java.beans.PropertyChangeSupport\n- **/\n-\n+ * PropertyChangeListener allows a class to monitor properties of a Bean for\n+ * changes. A propertyChange() event will only be fired <em>after</em> the\n+ * property has changed.\n+ *\n+ * @author John Keiser\n+ * @see PropertyChangeSupport\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n public interface PropertyChangeListener extends EventListener\n {\n-  /** Fired after a Bean's property has changed.\n-   ** @param e the change (containing the old and new values)\n-   **/\n-  public abstract void propertyChange(PropertyChangeEvent e);\n-}\n+  /**\n+   * Fired after a Bean's property has changed.\n+   *\n+   * @param e the change (containing the old and new values)\n+   */\n+  void propertyChange(PropertyChangeEvent e);\n+} // interface PropertyChangeListener"}, {"sha": "6e707038d0618b7ad1c174a8a69d830f219f1cce", "filename": "libjava/java/beans/PropertyChangeListenerProxy.java", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FPropertyChangeListenerProxy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FPropertyChangeListenerProxy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyChangeListenerProxy.java?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -0,0 +1,102 @@\n+/* PropertyChangeListenerProxy.java -- adds a name to a property listener\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.beans;\n+\n+import java.util.EventListenerProxy;\n+\n+/**\n+ * This class provides an extension to <code>PropertyChangeListener</code> -\n+ * associating a name with the listener. This can be used to filter the\n+ * changes that one is interested in.\n+ *\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.4\n+ * @status udpated to 1.4\n+ */\n+public class PropertyChangeListenerProxy extends EventListenerProxy\n+  implements PropertyChangeListener\n+{\n+  /**\n+   * The name of the property to listen for. Package visible for use by\n+   * PropertyChangeSupport.\n+   */\n+  final String propertyName;\n+\n+  /**\n+   * Create a new proxy which filters property change events and only passes\n+   * changes to the named property on to the delegate. A null propertyName\n+   * or listener does not fail now, but may cause a NullPointerException down\n+   * the road.\n+   *\n+   * @param propertyName the property's name to filter on\n+   * @param listener the delegate listener\n+   */\n+  public PropertyChangeListenerProxy(String propertyName,\n+                                     PropertyChangeListener listener)\n+  {\n+    super(listener);\n+    this.propertyName = propertyName;\n+  }\n+\n+  /**\n+   * Forwards the event on to the delegate if the property name matches.\n+   *\n+   * @param event the event to pass on, if it meets the filter\n+   * @throws NullPointerException if the delegate this was created with is null\n+   */\n+  public void propertyChange(PropertyChangeEvent event)\n+  {\n+    // Note: Sun does not filter, under the assumption that since\n+    // PropertyChangeSupport unwraps proxys, this method should never be\n+    // called by normal use of listeners.\n+    String name = event == null ? null : event.getPropertyName();\n+    if (name == null ? propertyName == null : name.equals(propertyName))\n+      ((PropertyChangeListener) getListener()).propertyChange(event);\n+  }\n+\n+  /**\n+   * Gets the name of the property this proxy is filtering on.\n+   *\n+   * @return the property name\n+   */\n+  public String getPropertyName()\n+  {\n+    return propertyName;\n+  }\n+} // class PropertyChangeListenerProxy"}, {"sha": "86230273591d814c667376cf80e72822b30a809b", "filename": "libjava/java/beans/PropertyChangeSupport.java", "status": "modified", "additions": 447, "deletions": 209, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FPropertyChangeSupport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FPropertyChangeSupport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyChangeSupport.java?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -1,13 +1,13 @@\n-/* java.beans.PropertyChangeSupport\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+/* PropertyChangeSupport.java -- support to manage property change listeners\n+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -37,214 +37,452 @@\n \n \n package java.beans;\n-import java.util.Hashtable;\n-import java.util.Vector;\n-import java.util.Enumeration;\n+\n+import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n-import java.io.IOException;\n import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Vector;\n \n /**\n- ** PropertyChangeSupport makes it easy to fire property\n- ** change events and handle listeners.\n- **\n- ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.2.0, 15 Mar 1999\n- **/\n-\n-public class PropertyChangeSupport implements java.io.Serializable {\n-\ttransient Hashtable propertyListeners = new Hashtable();\n-\ttransient Vector listeners = new Vector();\n-\tHashtable children;\n-\tObject source;\n-\tint propertyChangeSupportSerializedDataVersion = 2;\n-\tprivate static final long serialVersionUID = 6401253773779951803L;\n-\n-\t/**\n-\t * Saves the state of the object to the stream. */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\tchildren = propertyListeners.isEmpty() ? null : propertyListeners;\n-\t\tstream.defaultWriteObject();\n-\t\tfor (Enumeration e = listeners.elements(); e.hasMoreElements(); ) {\n-\t\t\tPropertyChangeListener l = (PropertyChangeListener)e.nextElement();\n-\t\t\tif (l instanceof Serializable)\n-\t\t\t  stream.writeObject(l);\n-\t\t}\n-\t\tstream.writeObject(null);\n-\t}\n-\n-\t/**\n-\t * Reads the object back from stream (deserialization).\n-\t */\n-\tprivate void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n-\t\tstream.defaultReadObject();\n-\t\tpropertyListeners = (children == null) ? new Hashtable() : children;\n-\t\tPropertyChangeListener l;\n-\t\twhile ((l = (PropertyChangeListener)stream.readObject()) != null) {\n-\t\t\taddPropertyChangeListener(l);\n-\t\t}\n-\t\t// FIXME: XXX: There is no spec for JDK 1.1 serialization\n-\t\t// so it is unclear what to do if the value of\n-\t\t// propertyChangeSupportSerializedDataVersion is 1.\n-\t}\n-\n-\t/** Create PropertyChangeSupport to work with a specific\n-\t ** source bean.\n-\t ** @param source the source bean to use.\n-\t **/\n-\tpublic PropertyChangeSupport(Object source) {\n-\t\tthis.source = source;\n-\t}\n-\n-\t/** Adds a PropertyChangeListener to the list of listeners.\n-\t ** All property change events will be sent to this listener.\n-\t ** <P>\n-\t **\n-\t ** The listener add is not unique: that is, <em>n</em> adds with\n-\t ** the same listener will result in <em>n</em> events being sent\n-\t ** to that listener for every property change.\n-\t ** <P>\n-\t **\n-\t ** Adding a null listener will cause undefined behavior.\n-\t **\n-\t ** @param l the listener to add.\n-\t **/\n-\tpublic void addPropertyChangeListener(PropertyChangeListener l) {\n-\t\tlisteners.addElement(l);\n-\t}\n-\n-\t/** Adds a PropertyChangeListener listening on the specified property.\n-\t ** Events will be sent to the listener for that particular property.\n-\t ** <P>\n-\t **\n-\t ** The listener add is not unique; that is, <em>n</em> adds on a\n-\t ** particular property for a particular listener will result in\n-\t ** <em>n</em> events being sent to that listener when that\n-\t ** property is changed.\n-\t ** <P>\n-\t **\n-\t ** The effect is cumulative, too; if you are registered to listen\n-\t ** to receive events on all property changes, and then you\n-\t ** register on a particular property, you will receive change\n-\t ** events for that property twice.\n-\t ** <P>\n-\t **\n-\t ** Adding a null listener will cause undefined behavior.\n-\t **\n-\t ** @param propertyName the name of the property to listen on.\n-\t ** @param l the listener to add.\n-\t **/\n-\tpublic void addPropertyChangeListener(String propertyName, PropertyChangeListener l) {\n-\t\tsynchronized(propertyListeners) {\n-\t\t\tVector v = (Vector)propertyListeners.get(propertyName);\n-\t\t\ttry {\n-\t\t\t\tv.addElement(l);\n-\t\t\t} catch(NullPointerException e) {\n-\t\t\t\t/* If v is not found, create a new vector. */\n-\t\t\t\tv = new Vector();\n-\t\t\t\tv.addElement(l);\n-\t\t\t\tpropertyListeners.put(propertyName, v);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/** Removes a PropertyChangeListener from the list of listeners.\n-\t ** If any specific properties are being listened on, they must\n-\t ** be deregistered by themselves; this will only remove the\n-\t ** general listener to all properties.\n-\t ** <P>\n-\t **\n-\t ** If <code>add()</code> has been called multiple times for a\n-\t ** particular listener, <code>remove()</code> will have to be\n-\t ** called the same number of times to deregister it.\n-\t **\n-\t ** @param l the listener to remove.\n-\t **/\n-\tpublic void removePropertyChangeListener(PropertyChangeListener l) {\n-\t\tlisteners.removeElement(l);\n-\t}\n-\n-\t/** Removes a PropertyChangeListener from listening to a specific property.\n-\t ** <P>\n-\t **\n-\t ** If <code>add()</code> has been called multiple times for a\n-\t ** particular listener on a property, <code>remove()</code> will\n-\t ** have to be called the same number of times to deregister it.\n-\t **\n-\t ** @param propertyName the property to stop listening on.\n-\t ** @param l the listener to remove.\n-\t **/\n-\tpublic void removePropertyChangeListener(String propertyName, PropertyChangeListener l) {\n-\t\tsynchronized(propertyListeners) {\n-\t\t\tVector v = (Vector)propertyListeners.get(propertyName);\n-\t\t\ttry {\n-\t\t\t\tv.removeElement(l);\n-\t\t\t\tif(v.size() == 0) {\n-\t\t\t\t\tpropertyListeners.remove(propertyName);\n-\t\t\t\t}\n-\t\t\t} catch(NullPointerException e) {\n-\t\t\t\t/* if v is not found, do nothing. */\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/** Fire a PropertyChangeEvent to all the listeners.\n-\t **\n-\t ** @param event the event to fire.\n-\t **/\n-\tpublic void firePropertyChange(PropertyChangeEvent event) {\n-\t\tfor(int i=0;i<listeners.size();i++) {\n-\t\t\t((PropertyChangeListener)listeners.elementAt(i)).propertyChange(event);\n-\t\t}\n-\t\tVector moreListeners = (Vector)propertyListeners.get(event.getPropertyName());\n-\t\tif(moreListeners != null) {\n-\t\t\tfor(int i=0;i<moreListeners.size();i++) {\n-\t\t\t\t((PropertyChangeListener)moreListeners.elementAt(i)).propertyChange(event);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/** Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.\n-\t **\n-\t ** @param propertyName the name of the property that changed.\n-\t ** @param oldVal the old value.\n-\t ** @param newVal the new value.\n-\t **/\n-\tpublic void firePropertyChange(String propertyName, Object oldVal, Object newVal) {\n-\t\tfirePropertyChange(new PropertyChangeEvent(source,propertyName,oldVal,newVal));\n-\t}\n-\n-\t/** Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.\n-\t **\n-\t ** @param propertyName the name of the property that changed.\n-\t ** @param oldVal the old value.\n-\t ** @param newVal the new value.\n-\t **/\n-\tpublic void firePropertyChange(String propertyName, boolean oldVal, boolean newVal) {\n-\t\tfirePropertyChange(new PropertyChangeEvent(source, propertyName, new Boolean(oldVal), new Boolean(newVal)));\n-\t}\n-\n-\t/** Fire a PropertyChangeEvent containing the old and new values of the property to all the listeners.\n-\t **\n-\t ** @param propertyName the name of the property that changed.\n-\t ** @param oldVal the old value.\n-\t ** @param newVal the new value.\n-\t **/\n-\tpublic void firePropertyChange(String propertyName, int oldVal, int newVal) {\n-\t\tfirePropertyChange(new PropertyChangeEvent(source, propertyName, new Integer(oldVal), new Integer(newVal)));\n-\t}\n-\n-\t/** Tell whether the specified property is being listened on or not.\n-\t ** This will only return <code>true</code> if there are listeners\n-\t ** on all properties or if there is a listener specifically on this\n-\t ** property.\n-\t **\n-\t ** @param propertyName the property that may be listened on\n-\t ** @return whether the property is being listened on\n-\t **/\n-\t public boolean hasListeners(String propertyName) {\n-\t \treturn listeners.size() > 0  || propertyListeners.get(propertyName) != null;\n-\t }\n-}\n+ * PropertyChangeSupport makes it easy to fire property change events and\n+ * handle listeners. It allows chaining of listeners, as well as filtering\n+ * by property name. In addition, it will serialize only those listeners\n+ * which are serializable, ignoring the others without problem. This class\n+ * is thread-safe.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n+public class PropertyChangeSupport implements Serializable\n+{\n+  /**\n+   * Compatible with JDK 1.1+.\n+   */\n+  private static final long serialVersionUID = 6401253773779951803L;\n+\n+  /**\n+   * Maps property names (String) to named listeners (PropertyChangeSupport).\n+   * If this is a child instance, this field will be null.\n+   *\n+   * @serial the map of property names to named listener managers\n+   * @since 1.2\n+   */\n+  private Hashtable children;\n+\n+  /**\n+   * The non-null source object for any generated events.\n+   *\n+   * @serial the event source\n+   */\n+  private final Object source;\n+\n+  /**\n+   * A field to compare serialization versions - this class uses version 2.\n+   *\n+   * @serial the serialization format\n+   */\n+  private final int propertyChangeSupportSerializedDataVersion = 2;\n+\n+  /**\n+   * The list of all registered property listeners. If this instance was\n+   * created by user code, this only holds the global listeners (ie. not tied\n+   * to a name), and may be null. If it was created by this class, as a\n+   * helper for named properties, then this vector will be non-null, and this\n+   * instance appears as a value in the <code>children</code> hashtable of\n+   * another instance, so that the listeners are tied to the key of that\n+   * hashtable entry.\n+   */\n+  private transient Vector listeners;\n+\n+  /**\n+   * Create a PropertyChangeSupport to work with a specific source bean.\n+   *\n+   * @param source the source bean to use\n+   * @throws NullPointerException if source is null\n+   */\n+  public PropertyChangeSupport(Object source)\n+  {\n+    this.source = source;\n+    if (source == null)\n+      throw new NullPointerException();\n+  }\n+\n+  /**\n+   * Adds a PropertyChangeListener to the list of global listeners. All\n+   * property change events will be sent to this listener. The listener add\n+   * is not unique: that is, <em>n</em> adds with the same listener will\n+   * result in <em>n</em> events being sent to that listener for every\n+   * property change. Adding a null listener may cause a NullPointerException\n+   * down the road. This method will unwrap a PropertyChangeListenerProxy,\n+   * registering the underlying delegate to the named property list.\n+   *\n+   * @param l the listener to add\n+   */\n+  public synchronized void addPropertyChangeListener(PropertyChangeListener l)\n+  {\n+    if (l instanceof PropertyChangeListenerProxy)\n+      {\n+        PropertyChangeListenerProxy p = (PropertyChangeListenerProxy) l;\n+        addPropertyChangeListener(p.propertyName,\n+                                  (PropertyChangeListener) p.getListener());\n+      }\n+    else\n+      {\n+        if (listeners == null)\n+          listeners = new Vector();\n+        listeners.add(l);\n+      }\n+  }\n+\n+  /**\n+   * Removes a PropertyChangeListener from the list of global listeners. If\n+   * any specific properties are being listened on, they must be deregistered\n+   * by themselves; this will only remove the general listener to all\n+   * properties. If <code>add()</code> has been called multiple times for a\n+   * particular listener, <code>remove()</code> will have to be called the\n+   * same number of times to deregister it. This method will unwrap a\n+   * PropertyChangeListenerProxy, removing the underlying delegate from the\n+   * named property list.\n+   *\n+   * @param l the listener to remove\n+   */\n+  public synchronized void\n+    removePropertyChangeListener(PropertyChangeListener l)\n+  {\n+    if (l instanceof PropertyChangeListenerProxy)\n+      {\n+        PropertyChangeListenerProxy p = (PropertyChangeListenerProxy) l;\n+        removePropertyChangeListener(p.propertyName,\n+                                     (PropertyChangeListener) p.getListener());\n+      }\n+    else if (listeners != null)\n+      {\n+        listeners.remove(l);\n+        if (listeners.isEmpty())\n+          listeners = null;\n+      }\n+  }\n+\n+  /**\n+   * Returns an array of all registered property change listeners. Those that\n+   * were registered under a name will be wrapped in a\n+   * <code>PropertyChangeListenerProxy</code>, so you must check whether the\n+   * listener is an instance of the proxy class in order to see what name the\n+   * real listener is registered under. If there are no registered listeners,\n+   * this returns an empty array.\n+   *\n+   * @return the array of registered listeners\n+   * @see PropertyChangeListenerProxy\n+   * @since 1.4\n+   */\n+  public synchronized PropertyChangeListener[] getPropertyChangeListeners()\n+  {\n+    ArrayList list = new ArrayList();\n+    if (listeners != null)\n+      list.addAll(listeners);\n+    if (children != null)\n+      {\n+        int i = children.size();\n+        Iterator iter = children.entrySet().iterator();\n+        while (--i >= 0)\n+          {\n+            Entry e = (Entry) iter.next();\n+            String name = (String) e.getKey();\n+            Vector v = ((PropertyChangeSupport) e.getValue()).listeners;\n+            int j = v.size();\n+            while (--j >= 0)\n+              list.add(new PropertyChangeListenerProxy\n+                (name, (PropertyChangeListener) v.get(j)));\n+          }\n+      }\n+    return (PropertyChangeListener[])\n+      list.toArray(new PropertyChangeListener[list.size()]);\n+  }\n+\n+  /**\n+   * Adds a PropertyChangeListener listening on the specified property. Events\n+   * will be sent to the listener only if the property name matches. The\n+   * listener add is not unique; that is, <em>n</em> adds on a particular\n+   * property for a particular listener will result in <em>n</em> events\n+   * being sent to that listener when that property is changed. The effect is\n+   * cumulative, too; if you are registered to listen to receive events on\n+   * all property changes, and then you register on a particular property,\n+   * you will receive change events for that property twice. Adding a null\n+   * listener may cause a NullPointerException down the road. This method\n+   * will unwrap a PropertyChangeListenerProxy, registering the underlying\n+   * delegate to the named property list if the names match, and discarding\n+   * it otherwise.\n+   *\n+   * @param propertyName the name of the property to listen on\n+   * @param l the listener to add\n+   * @throws NullPointerException if propertyName is null\n+   */\n+  public synchronized void addPropertyChangeListener(String propertyName,\n+                                                     PropertyChangeListener l)\n+  {\n+    while (l instanceof PropertyChangeListenerProxy)\n+      {\n+        PropertyChangeListenerProxy p = (PropertyChangeListenerProxy) l;\n+        if (propertyName == null ? p.propertyName != null\n+            : ! propertyName.equals(p.propertyName))\n+          return;\n+        l = (PropertyChangeListener) p.getListener();\n+      }\n+    PropertyChangeSupport s = null;\n+    if (children == null)\n+      children = new Hashtable();\n+    else\n+      s = (PropertyChangeSupport) children.get(propertyName);\n+    if (s == null)\n+      {\n+        s = new PropertyChangeSupport(source);\n+        s.listeners = new Vector();\n+        children.put(propertyName, s);\n+      }\n+    s.listeners.add(l);\n+  }\n+\n+  /**\n+   * Removes a PropertyChangeListener from listening to a specific property.\n+   * If <code>add()</code> has been called multiple times for a particular\n+   * listener on a property, <code>remove()</code> will have to be called the\n+   * same number of times to deregister it. This method will unwrap a\n+   * PropertyChangeListenerProxy, removing the underlying delegate from the\n+   * named property list if the names match.\n+   *\n+   * @param propertyName the property to stop listening on\n+   * @param l the listener to remove\n+   * @throws NullPointerException if propertyName is null\n+   */\n+  public synchronized void\n+    removePropertyChangeListener(String propertyName, PropertyChangeListener l)\n+  {\n+    if (children == null)\n+      return;\n+    PropertyChangeSupport s\n+      = (PropertyChangeSupport) children.get(propertyName);\n+    if (s == null)\n+      return;\n+    while (l instanceof PropertyChangeListenerProxy)\n+      {\n+        PropertyChangeListenerProxy p = (PropertyChangeListenerProxy) l;\n+        if (propertyName == null ? p.propertyName != null\n+            : ! propertyName.equals(p.propertyName))\n+          return;\n+        l = (PropertyChangeListener) p.getListener();\n+      }\n+    s.listeners.remove(l);\n+    if (s.listeners.isEmpty())\n+      {\n+        children.remove(propertyName);\n+        if (children.isEmpty())\n+          children = null;\n+      }\n+  }\n+\n+  /**\n+   * Returns an array of all property change listeners registered under the\n+   * given property name. If there are no registered listeners, this returns\n+   * an empty array.\n+   *\n+   * @return the array of registered listeners\n+   * @throws NullPointerException if propertyName is null\n+   * @since 1.4\n+   */\n+  public synchronized PropertyChangeListener[]\n+    getPropertyChangeListeners(String propertyName)\n+  {\n+    if (children == null)\n+      return new PropertyChangeListener[0];\n+    PropertyChangeSupport s\n+      = (PropertyChangeSupport) children.get(propertyName);\n+    if (s == null)\n+      return new PropertyChangeListener[0];\n+    return (PropertyChangeListener[])\n+      s.listeners.toArray(new PropertyChangeListener[s.listeners.size()]);\n+  }\n+\n+  /**\n+   * Fire a PropertyChangeEvent containing the old and new values of the\n+   * property to all the global listeners, and to all the listeners for the\n+   * specified property name. This does nothing if old and new are non-null\n+   * and equal.\n+   *\n+   * @param propertyName the name of the property that changed\n+   * @param oldVal the old value\n+   * @param newVal the new value\n+   */\n+  public void firePropertyChange(String propertyName,\n+                                 Object oldVal, Object newVal)\n+  {\n+    firePropertyChange(new PropertyChangeEvent(source, propertyName,\n+                                               oldVal, newVal));\n+  }\n+\n+  /**\n+   * Fire a PropertyChangeEvent containing the old and new values of the\n+   * property to all the global listeners, and to all the listeners for the\n+   * specified property name. This does nothing if old and new are equal.\n+   *\n+   * @param propertyName the name of the property that changed\n+   * @param oldVal the old value\n+   * @param newVal the new value\n+   */\n+  public void firePropertyChange(String propertyName, int oldVal, int newVal)\n+  {\n+    if (oldVal != newVal)\n+      firePropertyChange(new PropertyChangeEvent(source, propertyName,\n+                                                 new Integer(oldVal),\n+                                                 new Integer(newVal)));\n+  }\n+\n+  /**\n+   * Fire a PropertyChangeEvent containing the old and new values of the\n+   * property to all the global listeners, and to all the listeners for the\n+   * specified property name. This does nothing if old and new are equal.\n+   *\n+   * @param propertyName the name of the property that changed\n+   * @param oldVal the old value\n+   * @param newVal the new value\n+   */\n+  public void firePropertyChange(String propertyName,\n+                                 boolean oldVal, boolean newVal)\n+  {\n+    if (oldVal != newVal)\n+      firePropertyChange(new PropertyChangeEvent(source, propertyName,\n+                                                 Boolean.valueOf(oldVal),\n+                                                 Boolean.valueOf(newVal)));\n+  }\n+\n+  /**\n+   * Fire a PropertyChangeEvent to all the global listeners, and to all the\n+   * listeners for the specified property name. This does nothing if old and\n+   * new values of the event are equal.\n+   *\n+   * @param event the event to fire\n+   * @throws NullPointerException if event is null\n+   */\n+  public void firePropertyChange(PropertyChangeEvent event)\n+  {\n+    if (event.oldValue != null && event.oldValue.equals(event.newValue))\n+      return;\n+    Vector v = listeners; // Be thread-safe.\n+    if (v != null)\n+      {\n+        int i = v.size();\n+        while (--i >= 0)\n+          ((PropertyChangeListener) v.get(i)).propertyChange(event);\n+      }\n+    Hashtable h = children; // Be thread-safe.\n+    if (h != null && event.propertyName != null)\n+      {\n+        PropertyChangeSupport s\n+          = (PropertyChangeSupport) h.get(event.propertyName);\n+        if (s != null)\n+          {\n+            v = s.listeners; // Be thread-safe.\n+            int i = v == null ? 0 : v.size();\n+            while (--i >= 0)\n+              ((PropertyChangeListener) v.get(i)).propertyChange(event);\n+          }\n+      }\n+  }\n+\n+  /**\n+   * Tell whether the specified property is being listened on or not. This\n+   * will only return <code>true</code> if there are listeners on all\n+   * properties or if there is a listener specifically on this property.\n+   *\n+   * @param propertyName the property that may be listened on\n+   * @return whether the property is being listened on\n+   * @throws NullPointerException if propertyName is null\n+   */\n+  public synchronized boolean hasListeners(String propertyName)\n+  {\n+    return listeners != null || (children != null\n+                                 && children.get(propertyName) != null);\n+  }\n+\n+  /**\n+   * Saves the state of the object to the stream.\n+   *\n+   * @param s the stream to write to\n+   * @throws IOException if anything goes wrong\n+   * @serialData this writes out a null-terminated list of serializable\n+   *             global property change listeners (the listeners for a named\n+   *             property are written out as the global listeners of the\n+   *             children, when the children hashtable is saved)\n+   */\n+  private synchronized void writeObject(ObjectOutputStream s)\n+    throws IOException\n+  {\n+    s.defaultWriteObject();\n+    if (listeners != null)\n+      {\n+        int i = listeners.size();\n+        while (--i >= 0)\n+          if (listeners.get(i) instanceof Serializable)\n+            s.writeObject(listeners.get(i));\n+      }\n+    s.writeObject(null);\n+  }\n+\n+  /**\n+   * Reads the object back from stream (deserialization).\n+   *\n+   * XXX Since serialization for 1.1 streams was not documented, this may\n+   * not work if propertyChangeSupportSerializedDataVersion is 1.\n+   *\n+   * @param s the stream to read from\n+   * @throws IOException if reading the stream fails\n+   * @throws ClassNotFoundException if deserialization fails\n+   * @serialData this reads in a null-terminated list of serializable\n+   *             global property change listeners (the listeners for a named\n+   *             property are written out as the global listeners of the\n+   *             children, when the children hashtable is saved)\n+   */\n+  private void readObject(ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n+  {\n+    s.defaultReadObject();\n+    PropertyChangeListener l = (PropertyChangeListener) s.readObject();\n+    while (l != null)\n+      {\n+        addPropertyChangeListener(l);\n+        l = (PropertyChangeListener) s.readObject();\n+      }\n+    // Sun is not as careful with children as we are, and lets some proxys\n+    // in that can never receive events. So, we clean up anything that got\n+    // serialized, to make sure our invariants hold.\n+    if (children != null)\n+      {\n+        int i = children.size();\n+        Iterator iter = children.entrySet().iterator();\n+        while (--i >= 0)\n+          {\n+            Entry e = (Entry) iter.next();\n+            String name = (String) e.getKey();\n+            PropertyChangeSupport pcs = (PropertyChangeSupport) e.getValue();\n+            if (pcs.listeners == null)\n+              pcs.listeners = new Vector();\n+            if (pcs.children != null)\n+              pcs.listeners.addAll\n+                (Arrays.asList(pcs.getPropertyChangeListeners(name)));\n+            if (pcs.listeners.size() == 0)\n+              iter.remove();\n+            else\n+              pcs.children = null;\n+          }\n+        if (children.size() == 0)\n+          children = null;\n+      }\n+  }\n+} // class PropertyChangeSupport"}, {"sha": "1620a6620aa8d1f98e10aaccfab1276a41fe1046", "filename": "libjava/java/beans/VetoableChangeListener.java", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FVetoableChangeListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FVetoableChangeListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FVetoableChangeListener.java?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -1,13 +1,13 @@\n-/* java.beans.VetoableChangeListener\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+/* VetoableChangeListener.java -- listen for a change which can be vetoed\n+   Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -41,37 +41,33 @@\n import java.util.EventListener;\n \n /**\n- ** VetoableChangeListener allows a class to monitor\n- ** proposed changes to properties of a Bean and, if\n- ** desired, prevent them from occurring.<P>\n- **\n- ** A vetoableChange() event will be fired <EM>before</EM>\n- ** the property has changed.  If any listener rejects the\n- ** change by throwing the PropertyChangeException, a new\n- ** vetoableChange() event will be fired to all listeners\n- ** who received a vetoableChange() event in the first\n- ** place informing them of a reversion to the old value.\n- ** The value, of course, never actually changed.<P>\n- **\n- ** <STRONG>Note:</STRONG> This class may not be reliably\n- ** used to determine whether a property has actually\n- ** changed.  Use the PropertyChangeListener interface\n- ** for that instead.\n- **\n- ** @author John Keiser\n- ** @version 1.1.0, 29 Jul 1998\n- ** @since JDK1.1\n- ** @see java.beans.PropertyChangeListener\n- ** @see java.beans.VetoableChangeSupport\n- **/\n-\n+ * VetoableChangeListener allows a class to monitor proposed changes to\n+ * properties of a Bean and, if desired, prevent them from occurring. A\n+ * vetoableChange() event will be fired <em>after</em> the property change has\n+ * been requested, but before it is permanent. If any listener rejects the\n+ * change by throwing the PropertyChangeException, a new vetoableChange()\n+ * event will be fired to all listeners who received a vetoableChange() event\n+ * in the first place, informing them to revert back to the old value. Thus,\n+ * the listener that threw the exception the first time should be prepared\n+ * to rethrow it the second time. The value, of course, never actually changed.\n+ *\n+ * <p><strong>Note:</strong> This class may not be reliably used to determine\n+ * whether a property has actually changed.  Use the PropertyChangeListener\n+ * interface for that instead.\n+ *\n+ * @author John Keiser\n+ * @see java.beans.PropertyChangeListener\n+ * @see java.beans.VetoableChangeSupport\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n public interface VetoableChangeListener extends EventListener\n {\n-  /** Fired before a Bean's property changes.\n-   ** @param e the change (containing the old and new values)\n-   ** @exception PropertyChangeException if the listener\n-   **            does not desire the change to be made.\n-   **/\n-  public abstract void vetoableChange(PropertyChangeEvent e)\n-    throws PropertyVetoException;\n-}\n+  /**\n+   * Fired before a Bean's property changes.\n+   *\n+   * @param e the change (containing the old and new values)\n+   * @throws PropertyVetoException if the change is vetoed by the listener\n+   */\n+  void vetoableChange(PropertyChangeEvent e) throws PropertyVetoException;\n+} // interface VetoableChangeListener"}, {"sha": "f9d79958705b9497cbf07dd74c90fca1f022c383", "filename": "libjava/java/beans/VetoableChangeListenerProxy.java", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FVetoableChangeListenerProxy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FVetoableChangeListenerProxy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FVetoableChangeListenerProxy.java?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -0,0 +1,102 @@\n+/* VetoableChangeListenerProxy.java -- adds a name to a vetoable listener\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.beans;\n+\n+import java.util.EventListenerProxy;\n+\n+/**\n+ * This class provides an extension to <code>VetoableChangeListener</code> -\n+ * associating a name with the listener. This can be used to filter the\n+ * changes that one is interested in.\n+ *\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.4\n+ * @status udpated to 1.4\n+ */\n+public class VetoableChangeListenerProxy extends EventListenerProxy\n+  implements VetoableChangeListener\n+{\n+  /**\n+   * The name of the property to listen for. Package visible for use by\n+   * VetoableChangeSupport.\n+   */\n+  final String propertyName;\n+\n+  /**\n+   * Create a new proxy which filters property change events and only passes\n+   * changes to the named property on to the delegate.\n+   *\n+   * @param propertyName the property's name to filter on\n+   * @param listener the delegate listener\n+   */\n+  public VetoableChangeListenerProxy(String propertyName,\n+                                     VetoableChangeListener listener)\n+  {\n+    super(listener);\n+    this.propertyName = propertyName;\n+  }\n+\n+  /**\n+   * Forwards the event on to the delegate if the property name matches.\n+   *\n+   * @param event the event to pass on, if it meets the filter\n+   * @throws NullPointerException if the delegate this was created with is null\n+   * @throws PropertyVetoException if the change is vetoed by the listener\n+   */\n+  public void vetoableChange(PropertyChangeEvent event)\n+    throws PropertyVetoException\n+  {\n+    // Note: Sun does not filter, under the assumption that since\n+    // VetoableChangeSupport unwraps proxys, this method should never be\n+    // called by normal use of listeners.\n+    String name = event == null ? null : event.getPropertyName();\n+    if (name == null ? propertyName == null : name.equals(propertyName))\n+      ((VetoableChangeListener) getListener()).vetoableChange(event);\n+  }\n+\n+  /**\n+   * Gets the name of the property this proxy is filtering on.\n+   *\n+   * @return the property name\n+   */\n+  public String getPropertyName()\n+  {\n+    return propertyName;\n+  }\n+} // class VetoableChangeListenerProxy"}, {"sha": "d7d0d2cb59a0f189f14fe940e4fa60c223ea6b48", "filename": "libjava/java/beans/VetoableChangeSupport.java", "status": "modified", "additions": 472, "deletions": 241, "changes": 713, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FVetoableChangeSupport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9698ee33f0214f9d85b3ec67f139a0bb605b29bf/libjava%2Fjava%2Fbeans%2FVetoableChangeSupport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FVetoableChangeSupport.java?ref=9698ee33f0214f9d85b3ec67f139a0bb605b29bf", "patch": "@@ -1,13 +1,13 @@\n-/* java.beans.VetoableChangeSupport\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+/* VetoableChangeSupport.java -- support to manage vetoable change listeners\n+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,265 +35,496 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package java.beans;\n-import java.util.Hashtable;\n-import java.util.Vector;\n-import java.util.Enumeration;\n+\n+import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n-import java.io.IOException;\n import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Vector;\n \n /**\n- ** VetoableChangeSupport makes it easy to fire vetoable\n- ** change events and handle listeners as well as reversion\n- ** of old values when things go wrong.\n- **\n- ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.2.0, 15 Mar 1998\n- **/\n+ * VetoableChangeSupport makes it easy to fire vetoable change events and\n+ * handle listeners. It allows chaining of listeners, as well as filtering\n+ * by property name. In addition, it will serialize only those listeners\n+ * which are serializable, ignoring the others without problem. This class\n+ * is thread-safe.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n+public class VetoableChangeSupport implements Serializable\n+{\n+  /**\n+   * Compatible with JDK 1.1+.\n+   */\n+  private static final long serialVersionUID = -5090210921595982017L;\n \n-public class VetoableChangeSupport implements java.io.Serializable {\n-\ttransient Hashtable propertyListeners = new Hashtable();\n-\ttransient Vector listeners = new Vector();\n-\tHashtable children;\n-\tObject source;\n-\tint vetoableChangeSupportSerializedDataVersion = 2;\n-\tprivate static final long serialVersionUID = -5090210921595982017L;\n+  /**\n+   * Maps property names (String) to named listeners (VetoableChangeSupport).\n+   * If this is a child instance, this field will be null.\n+   *\n+   * @serial the map of property names to named listener managers\n+   * @since 1.2\n+   */\n+  private Hashtable children;\n \n-\t/**\n-\t * Saves the state of the object to the stream. */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\tchildren = propertyListeners.isEmpty() ? null : propertyListeners;\n-\t\tstream.defaultWriteObject();\n-\t\tfor (Enumeration e = listeners.elements(); e.hasMoreElements(); ) {\n-\t\t\tVetoableChangeListener l = (VetoableChangeListener)e.nextElement();\n-\t\t\tif (l instanceof Serializable)\n-\t\t\t  stream.writeObject(l);\n-\t\t}\n-\t\tstream.writeObject(null);\n-\t}\n+  /**\n+   * The non-null source object for any generated events.\n+   *\n+   * @serial the event source\n+   */\n+  private final Object source;\n \n-\t/**\n-\t * Reads the object back from stream (deserialization).\n-\t */\n-\tprivate void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n-\t\tstream.defaultReadObject();\n-\t\tpropertyListeners = (children == null) ? new Hashtable() : children;\n-\t\tVetoableChangeListener l;\n-\t\twhile ((l = (VetoableChangeListener)stream.readObject()) != null) {\n-\t\t\taddVetoableChangeListener(l);\n-\t\t}\n-\t\t// FIXME: XXX: There is no spec for JDK 1.1 serialization\n-\t\t// so it is unclear what to do if the value of\n-\t\t// vetoableChangeSupportSerializedDataVersion is 1.\n-\t}\n+  /**\n+   * A field to compare serialization versions - this class uses version 2.\n+   *\n+   * @serial the serialization format\n+   */\n+  private final int vetoableChangeSupportSerializedDataVersion = 2;\n \n+  /**\n+   * The list of all registered vetoable listeners. If this instance was\n+   * created by user code, this only holds the global listeners (ie. not tied\n+   * to a name), and may be null. If it was created by this class, as a\n+   * helper for named properties, then this vector will be non-null, and this\n+   * instance appears as a value in the <code>children</code> hashtable of\n+   * another instance, so that the listeners are tied to the key of that\n+   * hashtable entry.\n+   */\n+  private transient Vector listeners;\n \n-\t/** Create VetoableChangeSupport to work with a specific\n-\t ** source bean.\n-\t ** @param source the source bean to use.\n-\t **/\n-\tpublic VetoableChangeSupport(Object source) {\n-\t\tthis.source = source;\n-\t}\n+  /**\n+   * Create a VetoableChangeSupport to work with a specific source bean.\n+   *\n+   * @param source the source bean to use\n+   * @throws NullPointerException if source is null\n+   */\n+  public VetoableChangeSupport(Object source)\n+  {\n+    this.source = source;\n+    if (source == null)\n+      throw new NullPointerException();\n+  }\n \n-\t/** Adds a VetoableChangeListener to the list of listeners.\n-\t ** All property change events will be sent to this listener.\n-\t ** <P>\n-\t **\n-\t ** The listener add is not unique: that is, <em>n</em> adds with\n-\t ** the same listener will result in <em>n</em> events being sent\n-\t ** to that listener for every property change.\n-\t ** <P>\n-\t **\n-\t ** Adding a null listener will cause undefined behavior.\n-\t **\n-\t ** @param l the listener to add.\n-\t **/\n-\tpublic void addVetoableChangeListener(VetoableChangeListener l) {\n-\t\tlisteners.addElement(l);\n-\t}\n+  /**\n+   * Adds a VetoableChangeListener to the list of global listeners. All\n+   * vetoable change events will be sent to this listener. The listener add\n+   * is not unique: that is, <em>n</em> adds with the same listener will\n+   * result in <em>n</em> events being sent to that listener for every\n+   * vetoable change. Adding a null listener may cause a NullPointerException\n+   * down the road. This method will unwrap a VetoableChangeListenerProxy,\n+   * registering the underlying delegate to the named property list.\n+   *\n+   * @param l the listener to add\n+   */\n+  public synchronized void addVetoableChangeListener(VetoableChangeListener l)\n+  {\n+    if (l instanceof VetoableChangeListenerProxy)\n+      {\n+        VetoableChangeListenerProxy p = (VetoableChangeListenerProxy) l;\n+        addVetoableChangeListener(p.propertyName,\n+                                  (VetoableChangeListener) p.getListener());\n+      }\n+    else\n+      {\n+        if (listeners == null)\n+          listeners = new Vector();\n+        listeners.add(l);\n+      }\n+  }\n \n-\t/** Adds a VetoableChangeListener listening on the specified property.\n-\t ** Events will be sent to the listener for that particular property.\n-\t ** <P>\n-\t **\n-\t ** The listener add is not unique; that is, <em>n</em> adds on a\n-\t ** particular property for a particular listener will result in\n-\t ** <em>n</em> events being sent to that listener when that\n-\t ** property is changed.\n-\t ** <P>\n-\t **\n-\t ** The effect is cumulative, too; if you are registered to listen\n-\t ** to receive events on all property changes, and then you\n-\t ** register on a particular property, you will receive change\n-\t ** events for that property twice.\n-\t ** <P>\n-\t **\n-\t ** Adding a null listener will cause undefined behavior.\n-\t **\n-\t ** @param propertyName the name of the property to listen on.\n-\t ** @param l the listener to add.\n-\t **/\n-\tpublic void addVetoableChangeListener(String propertyName, VetoableChangeListener l) {\n-\t\tsynchronized(propertyListeners) {\n-\t\t\tVector v = (Vector)propertyListeners.get(propertyName);\n-\t\t\ttry {\n-\t\t\t\tv.addElement(l);\n-\t\t\t} catch(NullPointerException e) {\n-\t\t\t\t/* If v is not found, create a new vector. */\n-\t\t\t\tv = new Vector();\n-\t\t\t\tv.addElement(l);\n-\t\t\t\tpropertyListeners.put(propertyName, v);\n-\t\t\t}\n-\t\t}\n-\t}\n+  /**\n+   * Removes a VetoableChangeListener from the list of global listeners. If\n+   * any specific properties are being listened on, they must be deregistered\n+   * by themselves; this will only remove the general listener to all\n+   * properties. If <code>add()</code> has been called multiple times for a\n+   * particular listener, <code>remove()</code> will have to be called the\n+   * same number of times to deregister it. This method will unwrap a\n+   * VetoableChangeListenerProxy, removing the underlying delegate from the\n+   * named property list.\n+   *\n+   * @param l the listener to remove\n+   */\n+  public synchronized void\n+    removeVetoableChangeListener(VetoableChangeListener l)\n+  {\n+    if (l instanceof VetoableChangeListenerProxy)\n+      {\n+        VetoableChangeListenerProxy p = (VetoableChangeListenerProxy) l;\n+        removeVetoableChangeListener(p.propertyName,\n+                                     (VetoableChangeListener) p.getListener());\n+      }\n+    else if (listeners != null)\n+      {\n+        listeners.remove(l);\n+        if (listeners.isEmpty())\n+          listeners = null;\n+      }\n+  }\n \n-\t/** Removes a VetoableChangeListener from the list of listeners.\n-\t ** If any specific properties are being listened on, they must\n-\t ** be deregistered by themselves; this will only remove the\n-\t ** general listener to all properties.\n-\t ** <P>\n-\t **\n-\t ** If <code>add()</code> has been called multiple times for a\n-\t ** particular listener, <code>remove()</code> will have to be\n-\t ** called the same number of times to deregister it.\n-\t **\n-\t ** @param l the listener to remove.\n-\t **/\n-\tpublic void removeVetoableChangeListener(VetoableChangeListener l) {\n-\t\tlisteners.removeElement(l);\n-\t}\n+  /**\n+   * Returns an array of all registered vetoable change listeners. Those that\n+   * were registered under a name will be wrapped in a\n+   * <code>VetoableChangeListenerProxy</code>, so you must check whether the\n+   * listener is an instance of the proxy class in order to see what name the\n+   * real listener is registered under. If there are no registered listeners,\n+   * this returns an empty array.\n+   *\n+   * @return the array of registered listeners\n+   * @see VetoableChangeListenerProxy\n+   * @since 1.4\n+   */\n+  public synchronized VetoableChangeListener[] getVetoableChangeListeners()\n+  {\n+    ArrayList list = new ArrayList();\n+    if (listeners != null)\n+      list.addAll(listeners);\n+    if (children != null)\n+      {\n+        int i = children.size();\n+        Iterator iter = children.entrySet().iterator();\n+        while (--i >= 0)\n+          {\n+            Entry e = (Entry) iter.next();\n+            String name = (String) e.getKey();\n+            Vector v = ((VetoableChangeSupport) e.getValue()).listeners;\n+            int j = v.size();\n+            while (--j >= 0)\n+              list.add(new VetoableChangeListenerProxy\n+                (name, (VetoableChangeListener) v.get(j)));\n+          }\n+      }\n+    return (VetoableChangeListener[])\n+      list.toArray(new VetoableChangeListener[list.size()]);\n+  }\n \n-\t/** Removes a VetoableChangeListener from listening to a specific property.\n-\t ** <P>\n-\t **\n-\t ** If <code>add()</code> has been called multiple times for a\n-\t ** particular listener on a property, <code>remove()</code> will\n-\t ** have to be called the same number of times to deregister it.\n-\t **\n-\t ** @param propertyName the property to stop listening on.\n-\t ** @param l the listener to remove.\n-\t **/\n-\tpublic void removeVetoableChangeListener(String propertyName, VetoableChangeListener l) {\n-\t\tsynchronized(propertyListeners) {\n-\t\t\tVector v = (Vector)propertyListeners.get(propertyName);\n-\t\t\ttry {\n-\t\t\t\tv.removeElement(l);\n-\t\t\t\tif(v.size() == 0) {\n-\t\t\t\t\tpropertyListeners.remove(propertyName);\n-\t\t\t\t}\n-\t\t\t} catch(NullPointerException e) {\n-\t\t\t\t/* if v is not found, do nothing. */\n-\t\t\t}\n-\t\t}\n-\t}\n+  /**\n+   * Adds a VetoableChangeListener listening on the specified property. Events\n+   * will be sent to the listener only if the property name matches. The\n+   * listener add is not unique; that is, <em>n</em> adds on a particular\n+   * property for a particular listener will result in <em>n</em> events\n+   * being sent to that listener when that property is changed. The effect is\n+   * cumulative, too; if you are registered to listen to receive events on\n+   * all vetoable changes, and then you register on a particular property,\n+   * you will receive change events for that property twice. Adding a null\n+   * listener may cause a NullPointerException down the road. This method\n+   * will unwrap a VetoableChangeListenerProxy, registering the underlying\n+   * delegate to the named property list if the names match, and discarding\n+   * it otherwise.\n+   *\n+   * @param propertyName the name of the property to listen on\n+   * @param l the listener to add\n+   * @throws NullPointerException if propertyName is null\n+   */\n+  public synchronized void addVetoableChangeListener(String propertyName,\n+                                                     VetoableChangeListener l)\n+  {\n+    while (l instanceof VetoableChangeListenerProxy)\n+      {\n+        VetoableChangeListenerProxy p = (VetoableChangeListenerProxy) l;\n+        if (propertyName == null ? p.propertyName != null\n+            : ! propertyName.equals(p.propertyName))\n+          return;\n+        l = (VetoableChangeListener) p.getListener();\n+      }\n+    VetoableChangeSupport s = null;\n+    if (children == null)\n+      children = new Hashtable();\n+    else\n+      s = (VetoableChangeSupport) children.get(propertyName);\n+    if (s == null)\n+      {\n+        s = new VetoableChangeSupport(source);\n+        s.listeners = new Vector();\n+        children.put(propertyName, s);\n+      }\n+    s.listeners.add(l);\n+  }\n \n+  /**\n+   * Removes a VetoableChangeListener from listening to a specific property.\n+   * If <code>add()</code> has been called multiple times for a particular\n+   * listener on a property, <code>remove()</code> will have to be called the\n+   * same number of times to deregister it. This method will unwrap a\n+   * VetoableChangeListenerProxy, removing the underlying delegate from the\n+   * named property list if the names match.\n+   *\n+   * @param propertyName the property to stop listening on\n+   * @param l the listener to remove\n+   * @throws NullPointerException if propertyName is null\n+   */\n+  public synchronized void\n+    removeVetoableChangeListener(String propertyName, VetoableChangeListener l)\n+  {\n+    if (children == null)\n+      return;\n+    VetoableChangeSupport s\n+      = (VetoableChangeSupport) children.get(propertyName);\n+    if (s == null)\n+      return;\n+    while (l instanceof VetoableChangeListenerProxy)\n+      {\n+        VetoableChangeListenerProxy p = (VetoableChangeListenerProxy) l;\n+        if (propertyName == null ? p.propertyName != null\n+            : ! propertyName.equals(p.propertyName))\n+          return;\n+        l = (VetoableChangeListener) p.getListener();\n+      }\n+    s.listeners.remove(l);\n+    if (s.listeners.isEmpty())\n+      {\n+        children.remove(propertyName);\n+        if (children.isEmpty())\n+          children = null;\n+      }\n+  }\n \n-\t/** Fire a VetoableChangeEvent to all the listeners.\n-\t ** If any listener objects, a reversion event will be sent to\n-\t ** those listeners who received the initial event.\n-\t **\n-\t ** @param proposedChange the event to send.\n-\t ** @exception PropertyVetoException if the change is vetoed.\n-\t **/\n-\tpublic void fireVetoableChange(PropertyChangeEvent proposedChange) throws PropertyVetoException {\n-\t\tint currentListener=0;\n-\t\ttry {\n-\t\t\tfor(;currentListener<listeners.size();currentListener++) {\n-\t\t\t\t((VetoableChangeListener)listeners.elementAt(currentListener)).vetoableChange(proposedChange);\n-\t\t\t}\n-\t\t} catch(PropertyVetoException e) {\n-\t\t\tPropertyChangeEvent reversion = new PropertyChangeEvent(proposedChange.getSource(),proposedChange.getPropertyName(),proposedChange.getNewValue(),proposedChange.getOldValue());\n-\t\t\tfor(int sendAgain=0;sendAgain<currentListener;sendAgain++) {\n-\t\t\t\ttry {\n-\t\t\t\t\t((VetoableChangeListener)listeners.elementAt(sendAgain)).vetoableChange(reversion);\n-\t\t\t\t} catch(PropertyVetoException e2) {\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tthrow e;\n-\t\t}\n+  /**\n+   * Returns an array of all vetoable change listeners registered under the\n+   * given property name. If there are no registered listeners, this returns\n+   * an empty array.\n+   *\n+   * @return the array of registered listeners\n+   * @throws NullPointerException if propertyName is null\n+   * @since 1.4\n+   */\n+  public synchronized VetoableChangeListener[]\n+    getVetoableChangeListeners(String propertyName)\n+  {\n+    if (children == null)\n+      return new VetoableChangeListener[0];\n+    VetoableChangeSupport s\n+      = (VetoableChangeSupport) children.get(propertyName);\n+    if (s == null)\n+      return new VetoableChangeListener[0];\n+    return (VetoableChangeListener[])\n+      s.listeners.toArray(new VetoableChangeListener[s.listeners.size()]);\n+  }\n \n-\t\tVector moreListeners = (Vector)propertyListeners.get(proposedChange.getPropertyName());\n-\t\tif(moreListeners != null) {\n-\t\t\ttry {\n-\t\t\t\tfor(currentListener = 0; currentListener < moreListeners.size(); currentListener++) {\n-\t\t\t\t\t((VetoableChangeListener)moreListeners.elementAt(currentListener)).vetoableChange(proposedChange);\n-\t\t\t\t}\n-\t\t\t} catch(PropertyVetoException e) {\n-\t\t\t\tPropertyChangeEvent reversion = new PropertyChangeEvent(proposedChange.getSource(),proposedChange.getPropertyName(),proposedChange.getNewValue(),proposedChange.getOldValue());\n-\t\t\t\tfor(int sendAgain=0;sendAgain<listeners.size();sendAgain++) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\t((VetoableChangeListener)listeners.elementAt(currentListener)).vetoableChange(proposedChange);\n-\t\t\t\t\t} catch(PropertyVetoException e2) {\t\t\n-\t\t\t\t\t}\n-\t\t\t\t}\n+  /**\n+   * Fire a PropertyChangeEvent containing the old and new values of the\n+   * property to all the global listeners, and to all the listeners for the\n+   * specified property name. This does nothing if old and new are non-null\n+   * and equal. If the change is vetoed, a new event is fired to notify\n+   * listeners about the rollback before the exception is thrown.\n+   *\n+   * @param propertyName the name of the property that changed\n+   * @param oldVal the old value\n+   * @param newVal the new value\n+   * @throws PropertyVetoException if the change is vetoed by a listener\n+   */\n+  public void fireVetoableChange(String propertyName,\n+                                 Object oldVal, Object newVal)\n+    throws PropertyVetoException\n+  {\n+    fireVetoableChange(new PropertyChangeEvent(source, propertyName,\n+                                               oldVal, newVal));\n+  }\n \n-\t\t\t\tfor(int sendAgain=0;sendAgain<currentListener;sendAgain++) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\t((VetoableChangeListener)moreListeners.elementAt(sendAgain)).vetoableChange(reversion);\n-\t\t\t\t\t} catch(PropertyVetoException e2) {\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tthrow e;\n-\t\t\t}\n-\t\t}\n-\t}\n+  /**\n+   * Fire a PropertyChangeEvent containing the old and new values of the\n+   * property to all the global listeners, and to all the listeners for the\n+   * specified property name. This does nothing if old and new are equal.\n+   * If the change is vetoed, a new event is fired to notify listeners about\n+   * the rollback before the exception is thrown.\n+   *\n+   * @param propertyName the name of the property that changed\n+   * @param oldVal the old value\n+   * @param newVal the new value\n+   * @throws PropertyVetoException if the change is vetoed by a listener\n+   */\n+  public void fireVetoableChange(String propertyName, int oldVal, int newVal)\n+    throws PropertyVetoException\n+  {\n+    if (oldVal != newVal)\n+      fireVetoableChange(new PropertyChangeEvent(source, propertyName,\n+                                                 new Integer(oldVal),\n+                                                 new Integer(newVal)));\n+  }\n \n-\t/** Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.\n-\t ** If any listener objects, a reversion event will be sent to\n-\t ** those listeners who received the initial event.\n-\t **\n-\t ** @param propertyName the name of the property that\n-\t ** changed.\n-\t ** @param oldVal the old value.\n-\t ** @param newVal the new value.\n-\t ** @exception PropertyVetoException if the change is vetoed.\n-\t **/\n-\tpublic void fireVetoableChange(String propertyName, Object oldVal, Object newVal) throws PropertyVetoException {\n-\t\tfireVetoableChange(new PropertyChangeEvent(source,propertyName,oldVal,newVal));\n-\t}\n+  /**\n+   * Fire a PropertyChangeEvent containing the old and new values of the\n+   * property to all the global listeners, and to all the listeners for the\n+   * specified property name. This does nothing if old and new are equal.\n+   * If the change is vetoed, a new event is fired to notify listeners about\n+   * the rollback before the exception is thrown.\n+   *\n+   * @param propertyName the name of the property that changed\n+   * @param oldVal the old value\n+   * @param newVal the new value\n+   * @throws PropertyVetoException if the change is vetoed by a listener\n+   */\n+  public void fireVetoableChange(String propertyName,\n+                                 boolean oldVal, boolean newVal)\n+    throws PropertyVetoException\n+  {\n+    if (oldVal != newVal)\n+      fireVetoableChange(new PropertyChangeEvent(source, propertyName,\n+                                                 Boolean.valueOf(oldVal),\n+                                                 Boolean.valueOf(newVal)));\n+  }\n \n-\t/** Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.\n-\t ** If any listener objects, a reversion event will be sent to\n-\t ** those listeners who received the initial event.\n-\t **\n-\t ** @param propertyName the name of the property that\n-\t ** changed.\n-\t ** @param oldVal the old value.\n-\t ** @param newVal the new value.\n-\t ** @exception PropertyVetoException if the change is vetoed.\n-\t **/\n-\tpublic void fireVetoableChange(String propertyName, boolean oldVal, boolean newVal) throws PropertyVetoException {\n-\t\tfireVetoableChange(new PropertyChangeEvent(source,propertyName,new Boolean(oldVal),new Boolean(newVal)));\n-\t}\n+  /**\n+   * Fire a PropertyChangeEvent to all the global listeners, and to all the\n+   * listeners for the specified property name. This does nothing if old and\n+   * new values of the event are equal. If the change is vetoed, a new event\n+   * is fired to notify listeners about the rollback before the exception is\n+   * thrown.\n+   *\n+   * @param event the event to fire\n+   * @throws NullPointerException if event is null\n+   * @throws PropertyVetoException if the change is vetoed by a listener\n+   */\n+  public void fireVetoableChange(PropertyChangeEvent event)\n+    throws PropertyVetoException\n+  {\n+    if (event.oldValue != null && event.oldValue.equals(event.newValue))\n+      return;\n+    Vector v = listeners; // Be thread-safe.\n+    if (v != null)\n+      {\n+        int i = v.size();\n+        try\n+          {\n+            while (--i >= 0)\n+              ((VetoableChangeListener) v.get(i)).vetoableChange(event);\n+          }\n+        catch (PropertyVetoException e)\n+          {\n+            event = event.rollback();\n+            int limit = i;\n+            i = v.size();\n+            while (--i >= limit)\n+              ((VetoableChangeListener) v.get(i)).vetoableChange(event);\n+            throw e;\n+          }\n+      }\n+    Hashtable h = children; // Be thread-safe.\n+    if (h != null && event.propertyName != null)\n+      {\n+        VetoableChangeSupport s\n+          = (VetoableChangeSupport) h.get(event.propertyName);\n+        if (s != null)\n+          {\n+            Vector v1 = s.listeners; // Be thread-safe.\n+            int i = v1 == null ? 0 : v1.size();\n+            try\n+              {\n+                while (--i >= 0)\n+                  ((VetoableChangeListener) v1.get(i)).vetoableChange(event);\n+              }\n+            catch (PropertyVetoException e)\n+              {\n+                event = event.rollback();\n+                int limit = i;\n+                i = v.size();\n+                while (--i >= 0)\n+                  ((VetoableChangeListener) v.get(i)).vetoableChange(event);\n+                i = v1.size();\n+                while (--i >= limit)\n+                  ((VetoableChangeListener) v1.get(i)).vetoableChange(event);\n+                throw e;\n+              }\n+          }\n+      }\n+  }\n \n-\t/** Fire a VetoableChangeEvent containing the old and new values of the property to all the listeners.\n-\t ** If any listener objects, a reversion event will be sent to\n-\t ** those listeners who received the initial event.\n-\t **\n-\t ** @param propertyName the name of the property that\n-\t ** changed.\n-\t ** @param oldVal the old value.\n-\t ** @param newVal the new value.\n-\t ** @exception PropertyVetoException if the change is vetoed.\n-\t **/\n-\tpublic void fireVetoableChange(String propertyName, int oldVal, int newVal) throws PropertyVetoException {\n-\t\tfireVetoableChange(new PropertyChangeEvent(source,propertyName,new Integer(oldVal),new Integer(newVal)));\n-\t}\n+  /**\n+   * Tell whether the specified property is being listened on or not. This\n+   * will only return <code>true</code> if there are listeners on all\n+   * properties or if there is a listener specifically on this property.\n+   *\n+   * @param propertyName the property that may be listened on\n+   * @return whether the property is being listened on\n+   * @throws NullPointerException if propertyName is null\n+   */\n+  public synchronized boolean hasListeners(String propertyName)\n+  {\n+    return listeners != null || (children != null\n+                                 && children.get(propertyName) != null);\n+  }\n \n+  /**\n+   * Saves the state of the object to the stream.\n+   *\n+   * @param s the stream to write to\n+   * @throws IOException if anything goes wrong\n+   * @serialData this writes out a null-terminated list of serializable\n+   *             global vetoable change listeners (the listeners for a named\n+   *             property are written out as the global listeners of the\n+   *             children, when the children hashtable is saved)\n+   */\n+  private synchronized void writeObject(ObjectOutputStream s)\n+    throws IOException\n+  {\n+    s.defaultWriteObject();\n+    if (listeners != null)\n+      {\n+        int i = listeners.size();\n+        while (--i >= 0)\n+          if (listeners.get(i) instanceof Serializable)\n+            s.writeObject(listeners.get(i));\n+      }\n+    s.writeObject(null);\n+  }\n \n-\t/** Tell whether the specified property is being listened on or not.\n-\t ** This will only return <code>true</code> if there are listeners\n-\t ** on all properties or if there is a listener specifically on this\n-\t ** property.\n-\t **\n-\t ** @param propertyName the property that may be listened on\n-\t ** @return whether the property is being listened on\n-\t **/\n-\tpublic boolean hasListeners(String propertyName) {\n-\t\treturn listeners.size() > 0  || propertyListeners.get(propertyName) != null;\n-\t}\n-}\n+  /**\n+   * Reads the object back from stream (deserialization).\n+   *\n+   * XXX Since serialization for 1.1 streams was not documented, this may\n+   * not work if vetoableChangeSupportSerializedDataVersion is 1.\n+   *\n+   * @param s the stream to read from\n+   * @throws IOException if reading the stream fails\n+   * @throws ClassNotFoundException if deserialization fails\n+   * @serialData this reads in a null-terminated list of serializable\n+   *             global vetoable change listeners (the listeners for a named\n+   *             property are written out as the global listeners of the\n+   *             children, when the children hashtable is saved)\n+   */\n+  private void readObject(ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n+  {\n+    s.defaultReadObject();\n+    VetoableChangeListener l = (VetoableChangeListener) s.readObject();\n+    while (l != null)\n+      {\n+        addVetoableChangeListener(l);\n+        l = (VetoableChangeListener) s.readObject();\n+      }\n+    // Sun is not as careful with children as we are, and lets some proxys\n+    // in that can never receive events. So, we clean up anything that got\n+    // serialized, to make sure our invariants hold.\n+    if (children != null)\n+      {\n+        int i = children.size();\n+        Iterator iter = children.entrySet().iterator();\n+        while (--i >= 0)\n+          {\n+            Entry e = (Entry) iter.next();\n+            String name = (String) e.getKey();\n+            VetoableChangeSupport vcs = (VetoableChangeSupport) e.getValue();\n+            if (vcs.listeners == null)\n+              vcs.listeners = new Vector();\n+            if (vcs.children != null)\n+              vcs.listeners.addAll\n+                (Arrays.asList(vcs.getVetoableChangeListeners(name)));\n+            if (vcs.listeners.size() == 0)\n+              iter.remove();\n+            else\n+              vcs.children = null;\n+          }\n+        if (children.size() == 0)\n+          children = null;\n+      }\n+  }\n+} // class VetoableChangeSupport"}]}