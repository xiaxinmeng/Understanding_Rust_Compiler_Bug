{"sha": "1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE2NmNkNjdlMmViNDM5MWUyYjcxZjAzMmFhZjAzNmVmZTVhNzI4ZA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2000-09-02T03:28:47Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2000-09-02T03:28:47Z"}, "message": "t-elf, [...]: New files.\n\n* config/sh/t-elf, config/sh/crt1.asm, config/sh/crti.asm,\nconfig/sh/crtn.asm: New files.\n* config/sh/t-sh (EXTRA_MULTILIB_PARTS): Set.\n(crt1.o, crti.o, crtn.o): New targets.\n* configure.in [sh-*-elf*, sh-*-rtemself*] (tmake_file): Added\nsh/t-elf.\n* configure: Rebuilt.\n* config/sh/sh.h (INIT_SECTION_ASM_OP, FINI_SECTION_ASM_OP,\nSTARTFILE_SPEC, ENDFILE_SPEC, CRT_CALL_STATIC_FUNCTION): Define.\n* config/sh/elf.h (INIT_SECTION_ASM_OP, FINI_SECTION_ASM_OP):\nUndefine for config/elfos.h to redefine.\n(STARTFILE_SPEC, ENDFILE_SPEC): Redefine after config/elfos.h.\n\n\n* config/sh/sh-protos.h (nonpic_symbol_mentioned_p,\nlegitimize_pic_address, output_pic_addr_const): Declare.\n* config/sh/sh.h (CONDITIONAL_REGISTER_USAGE): Fix PIC register.\n(PREFERGOT_BIT, TARGET_PREFERGOT): Likewise.\n(TARGET_SWITCHES): New switch -mprefergot.\n(OVERRIDE_OPTIONS): Set flag_no_function_cse unless -mprefergot.\n(PIC_OFFSET_TABLE_REGNUM): Define.\n(GOT_SYMBOL_TABLE): Likewise.\n(LEGITIMIZE_ADDRESS): Use legitimize_pic_address.\n(ENCODE_SECTION_INFO): Define.\n(FINALIZE_PIC): New macros.\n(LEGITIMATE_PIC_OPERAND_P, SYMBOLIC_CONST_P): New macro.\n(ASM_OUTPUT_INT, ASM_OUTPUT_SHORT): Use output_pic_addr_const.\n* config/sh/sh.c (print_operand_address): Use output_pic_addr_const.\n(prepare_move_operands): Call emit_pic_move or\nemit_pic_const_move if appropriate.\n(output_far_jump): For PIC, use braf and output long offset.\n(machine_dependent_reorg):\n(sh_expand_prologue): Save and initialize the PIC register.\n(sh_expand_epilogue): Restore it.\n(initial_elimination_offset): Account for it.\n(nonpic_symbol_mentioned_p): New function.\n(legitimize_pic_address): Likewise.\n(output_pic_addr_const): Likewise.\n* config/sh/sh.md (calli_pcrel, call_valuei_pcrel): New insns.\n(call, call_value): Use them.\n(GOTaddr2picreg, sym_label2reg, symGOT2reg, symGOTOFF2reg,\nsymPLT_label2reg): New expands.\n* invoke.texi (SH Options): Document -mprefergot.\n\nFrom-SVN: r36111", "tree": {"sha": "778c9a0d798070b0eff6fbf93318bc7e2b6452f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/778c9a0d798070b0eff6fbf93318bc7e2b6452f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/comments", "author": null, "committer": null, "parents": [{"sha": "6462bb432fe58e6dba719b88df693f768a05e5a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6462bb432fe58e6dba719b88df693f768a05e5a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6462bb432fe58e6dba719b88df693f768a05e5a6"}], "stats": {"total": 828, "additions": 812, "deletions": 16}, "files": [{"sha": "03a624c8f5961ae0f480afa28a758c26cad89c5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -1,3 +1,50 @@\n+2000-09-02  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* config/sh/t-elf, config/sh/crt1.asm, config/sh/crti.asm,\n+\tconfig/sh/crtn.asm: New files.\n+\t* config/sh/t-sh (EXTRA_MULTILIB_PARTS): Set.\n+\t(crt1.o, crti.o, crtn.o): New targets.\n+\t* configure.in [sh-*-elf*, sh-*-rtemself*] (tmake_file): Added\n+\tsh/t-elf.\n+\t* configure: Rebuilt.\n+\t* config/sh/sh.h (INIT_SECTION_ASM_OP, FINI_SECTION_ASM_OP,\n+\tSTARTFILE_SPEC, ENDFILE_SPEC, CRT_CALL_STATIC_FUNCTION): Define.\n+\t* config/sh/elf.h (INIT_SECTION_ASM_OP, FINI_SECTION_ASM_OP):\n+\tUndefine for config/elfos.h to redefine.\n+\t(STARTFILE_SPEC, ENDFILE_SPEC): Redefine after config/elfos.h.\n+\n+2000-09-02  Alexandre Oliva  <aoliva@redhat.com>, Niibe Yutaka  <gniibe@m17n.org>, Kaz Kojima  <kkojima@rr.iij4u.or.jp>\n+\n+\t* config/sh/sh-protos.h (nonpic_symbol_mentioned_p,\n+\tlegitimize_pic_address, output_pic_addr_const): Declare.\n+\t* config/sh/sh.h (CONDITIONAL_REGISTER_USAGE): Fix PIC register.\n+\t(PREFERGOT_BIT, TARGET_PREFERGOT): Likewise.\n+\t(TARGET_SWITCHES): New switch -mprefergot.\n+\t(OVERRIDE_OPTIONS): Set flag_no_function_cse unless -mprefergot.\n+\t(PIC_OFFSET_TABLE_REGNUM): Define.\n+\t(GOT_SYMBOL_TABLE): Likewise.\n+\t(LEGITIMIZE_ADDRESS): Use legitimize_pic_address.\n+\t(ENCODE_SECTION_INFO): Define.\n+\t(FINALIZE_PIC): New macros.\n+\t(LEGITIMATE_PIC_OPERAND_P, SYMBOLIC_CONST_P): New macro.\n+\t(ASM_OUTPUT_INT, ASM_OUTPUT_SHORT): Use output_pic_addr_const.\n+\t* config/sh/sh.c (print_operand_address): Use output_pic_addr_const.\n+\t(prepare_move_operands): Call emit_pic_move or\n+\temit_pic_const_move if appropriate.\n+\t(output_far_jump): For PIC, use braf and output long offset.\n+\t(machine_dependent_reorg): \n+\t(sh_expand_prologue): Save and initialize the PIC register.\n+\t(sh_expand_epilogue): Restore it.\n+\t(initial_elimination_offset): Account for it.\n+\t(nonpic_symbol_mentioned_p): New function.\n+\t(legitimize_pic_address): Likewise.\n+\t(output_pic_addr_const): Likewise.\n+\t* config/sh/sh.md (calli_pcrel, call_valuei_pcrel): New insns.\n+\t(call, call_value): Use them.\n+\t(GOTaddr2picreg, sym_label2reg, symGOT2reg, symGOTOFF2reg,\n+\tsymPLT_label2reg): New expands.\n+\t* invoke.texi (SH Options): Document -mprefergot.\n+\n 2000-09-01  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* rtl.h (ASM_OPERANDS_INPUT_CONSTRAINT_EXP): New macro."}, {"sha": "a5eb4b4e7e5e049f0107e0e75e9003605d314fef", "filename": "gcc/config/sh/crt1.asm", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fcrt1.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fcrt1.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fcrt1.asm?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -0,0 +1,107 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.\n+   This file was pretty much copied from newlib.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\t.section .text\n+\t.global\tstart\n+start:\n+\tmov.l\tstack_k,r15\n+\n+\t! zero out bss\n+\tmov.l\tedata_k,r0\n+\tmov.l\tend_k,r1\n+\tmov\t#0,r2\n+start_l:\n+\tmov.l\tr2,@r0\n+\tadd\t#4,r0\n+\tcmp/ge\tr0,r1\n+\tbt\tstart_l\n+\n+#if defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY)\n+\tmov.l set_fpscr_k, r1\n+\tjsr @r1\n+\tmov #0,r4\n+\tlds r3,fpscr\n+#endif /*  defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) */\n+\n+\t! arrange for exit to call fini\n+\tmov.l\tatexit_k,r0\n+\tjsr\t@r0\n+\tmov.l\tfini_k,r4\n+\n+\t! call init\n+\tmov.l\tinit_k,r0\n+\tjsr\t@r0\n+\tnop\n+\n+\t! call the mainline\t\n+\tmov.l\tmain_k,r0\n+\tjsr\t@r0\n+\tnop\n+\n+\t! call exit\n+\tmov\tr0,r4\n+\tmov.l\texit_k,r0\n+\tjsr\t@r0\n+\tnop\n+\n+\t.align 2\n+#if defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__)\n+set_fpscr_k:\n+\t.long\t___set_fpscr\n+#endif /*  defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(SH4_SINGLE_ONLY) */\n+stack_k:\n+\t.long\t_stack\t\n+edata_k:\n+\t.long\t_edata\n+end_k:\n+\t.long\t_end\n+main_k:\n+\t.long\t_main\n+exit_k:\n+\t.long\t_exit\n+atexit_k:\n+\t.long\t_atexit\n+init_k:\n+\t.long\t_init\n+fini_k:\n+\t.long\t_fini\n+\n+\t! supplied for backward compatibility only, in case of linking\n+\t! code whose main() was compiled with an older version of GCC.\n+\t.global\t___main\n+___main:\n+\trts\n+\tnop\n+\n+#ifdef __ELF__\n+\t.section .stack,\"aw\"\n+#else\n+\t.section .stack\n+#endif\n+_stack:\t.long\t0xdeaddead"}, {"sha": "ece86667e74f5a383a607fc8a52f14cd38903614", "filename": "gcc/config/sh/crti.asm", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fcrti.asm?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -0,0 +1,101 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.\n+   This file was adapted from glibc sources.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* The code in sections .init and .fini is supposed to be a single\n+   regular function.  The function in .init is called directly from\n+   start in crt1.asm.  The function in .fini is atexit()ed in crt1.asm\n+   too.\n+\n+   crti.asm contributes the prologue of a function to these sections,\n+   and crtn.asm comes up the epilogue.  STARTFILE_SPEC should list\n+   crti.o before any other object files that might add code to .init\n+   or .fini sections, and ENDFILE_SPEC should list crtn.o after any\n+   such object files.  */\n+\n+\t.section .init\n+/* The alignment below can't be smaller, otherwide the mova below\n+   breaks.  Yes, we might align just the label, but then we'd be\n+   exchanging an alignment here for one there, since the code fragment\n+   below ensures 4-byte alignment on __ELF__.  */\n+#ifdef __ELF__\n+\t.p2align 2\n+#else\n+\t.p2align 1\n+#endif\n+\t.global\t _init\n+_init:\n+#ifdef __ELF__\n+\tmov.l\tr12,@-r15\n+\tmova\t0f,r0\n+\tmov.l\t0f,r12\n+#endif\n+\tmov.l\tr14,@-r15\n+#ifdef __ELF__\n+\tadd\tr0,r12\n+#endif\n+\tsts.l\tpr,@-r15\n+#ifdef __ELF__\n+\tbra\t1f\n+#endif\n+\tmov\tr15,r14\n+#ifdef __ELF__\n+0:\t.long\t_GLOBAL_OFFSET_TABLE_\n+1:\n+#endif\n+\n+\t.section .fini\n+/* The alignment below can't be smaller, otherwide the mova below\n+   breaks.  Yes, we might align just the label, but then we'd be\n+   exchanging an alignment here for one there, since the code fragment\n+   below ensures 4-byte alignment on __ELF__.  */\n+#ifdef __ELF__\n+\t.p2align 2\n+#else\n+\t.p2align 1\n+#endif\n+\t.global  _fini\n+_fini:\t\n+#ifdef __ELF__\n+\tmov.l\tr12,@-r15\n+\tmova\t0f,r0\n+\tmov.l\t0f,r12\n+#endif\n+\tmov.l\tr14,@-r15\n+#ifdef __ELF__\n+\tadd\tr0,r12\n+#endif\n+\tsts.l\tpr,@-r15\n+#ifdef __ELF__\n+\tbra\t1f\n+#endif\n+\tmov\tr15,r14\n+#ifdef __ELF__\n+0:\t.long\t_GLOBAL_OFFSET_TABLE_\n+1:\n+#endif"}, {"sha": "86a4ee3f976d460e3cd7e98509c7780a046ce4e7", "filename": "gcc/config/sh/crtn.asm", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fcrtn.asm?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -0,0 +1,52 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.\n+   This file was adapted from glibc sources.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* See an explanation about .init and .fini in crti.asm.  */\n+\n+\t.section .init\n+\tmov\tr15,r14\n+\tlds.l\t@r15+,pr\n+\tmov.l\t@r15+,r14\n+\trts\n+#ifdef __ELF__\n+\tmov.l\t@r15+,r12\n+#else\n+\tnop\n+#endif\n+\n+\t.section .fini\n+\tmov\tr15,r14\n+\tlds.l\t@r15+,pr\n+\tmov.l\t@r15+,r14\n+\trts\n+#ifdef __ELF__\n+\tmov.l\t@r15+,r12\n+#else\n+\tnop\n+#endif"}, {"sha": "148b6b973b1b3b1efe8f58cee887489e6b19e020", "filename": "gcc/config/sh/elf.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Felf.h?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -43,6 +43,8 @@ Boston, MA 02111-1307, USA.  */\n #undef ASM_OUTPUT_DESTRUCTOR\n #undef ASM_DECLARE_FUNCTION_NAME\n #undef MAX_OFILE_ALIGNMENT\n+#undef INIT_SECTION_ASM_OP\n+#undef FINI_SECTION_ASM_OP\n \n /* Be ELF-like.  */\n #include \"svr4.h\"\n@@ -110,13 +112,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fprintf ((FILE), \"\\t.stabs \\\"\\\",%d,0,0,Letext\\nLetext:\\n\", N_SO);\t\\\n } while (0)\n \n-/* Arrange to call __main, rather than using crtbegin.o and crtend.o\n-   and relying on .init and .fini being executed at appropriate times.  */\n-#undef INIT_SECTION_ASM_OP\n-#undef FINI_SECTION_ASM_OP\n-#undef STARTFILE_SPEC\n-#undef ENDFILE_SPEC\n-\n /* HANDLE_SYSV_PRAGMA (defined by svr4.h) takes precedence over HANDLE_PRAGMA.\n    We want to use the HANDLE_PRAGMA from sh.h.  */\n #undef HANDLE_SYSV_PRAGMA\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+  \"%{!shared: crt1.o%s} crti.o%s \\\n+   %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \\\n+  \"%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s\""}, {"sha": "375ade8b7d91cb79d0b5372669ebb655ea37d7ad", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -42,10 +42,13 @@ extern int fp_zero_operand PARAMS ((rtx));\n extern int fp_one_operand PARAMS ((rtx));\n extern int fp_int_operand PARAMS ((rtx));\n extern rtx get_fpscr_rtx PARAMS ((void));\n+extern rtx legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n+extern int nonpic_symbol_mentioned_p PARAMS ((rtx));\n extern void emit_sf_insn PARAMS ((rtx));\n extern void emit_df_insn PARAMS ((rtx));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n+extern void output_pic_addr_const PARAMS ((FILE *, rtx));\n extern int expand_block_move PARAMS ((rtx *));\n extern int prepare_move_operands PARAMS ((rtx[], enum machine_mode mode));\n extern void from_compare PARAMS ((rtx *, int));"}, {"sha": "930ff738b05b40a07e0dfd185d8efac0b2caa2bd", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 248, "deletions": 3, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -201,7 +201,7 @@ print_operand_address (stream, x)\n       break;\n \n     default:\n-      output_addr_const (stream, x);\n+      output_pic_addr_const (stream, x);\n       break;\n     }\n }\n@@ -457,6 +457,31 @@ prepare_move_operands (operands, mode)\n      rtx operands[];\n      enum machine_mode mode;\n {\n+  if (mode == SImode && flag_pic)\n+    {\n+      rtx temp;\n+      if (SYMBOLIC_CONST_P (operands[1]))\n+\t{\n+\t  if (GET_CODE (operands[0]) == MEM)\n+\t    operands[1] = force_reg (Pmode, operands[1]);\n+\t  else\n+\t    {\n+\t      temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+\t      operands[1] = legitimize_pic_address (operands[1], SImode, temp);\n+\t    }\n+\t}\n+      else if (GET_CODE (operands[1]) == CONST\n+\t       && GET_CODE (XEXP (operands[1], 0)) == PLUS\n+\t       && SYMBOLIC_CONST_P (XEXP (XEXP (operands[1], 0), 0)))\n+\t{\n+\t  temp = legitimize_pic_address (XEXP (XEXP (operands[1], 0), 0),\n+\t\t\t\t\t SImode, gen_reg_rtx (Pmode));\n+\t  operands[1] = expand_binop (SImode, add_optab, temp,\n+\t\t\t\t      XEXP (XEXP (operands[1], 0), 1),\n+\t\t\t\t      gen_reg_rtx (Pmode), 0, OPTAB_LIB_WIDEN);\n+\t}\n+    }\n+\n   if (! reload_in_progress && ! reload_completed)\n     {\n       /* Copy the source to a register if both operands aren't registers.  */\n@@ -702,7 +727,10 @@ output_far_jump (insn, op)\n   else\n     {\n       far = 1;\n-      jump = \"mov.l\t%O0,%1;jmp\t@%1\";\n+      if (flag_pic)\n+\tjump = \"mov.l\t%O0,%1;braf\t%1\";\n+      else\n+\tjump = \"mov.l\t%O0,%1;jmp\t@%1\";\n     }\n   /* If we have a scratch register available, use it.  */\n   if (GET_CODE (PREV_INSN (insn)) == INSN\n@@ -730,7 +758,10 @@ output_far_jump (insn, op)\n     output_asm_insn (\".align\t2\", 0);\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (this.lab));\n   this.op = op;\n-  output_asm_insn (far ? \".long\t%O2\" : \".word %O2-%O0\", &this.lab);\n+  if (far && flag_pic)\n+    output_asm_insn (\".long\t%O2-%O0\", &this.lab);\n+  else\n+    output_asm_insn (far ? \".long\t%O2\" : \".word %O2-%O0\", &this.lab);\n   return \"\";\n }\n \n@@ -3214,6 +3245,19 @@ machine_dependent_reorg (first)\n \t\t      /* Remove the clobber of r0.  */\n \t\t      XEXP (clobber, 0) = gen_rtx_SCRATCH (Pmode);\n \t\t    }\n+\t\t  /* This is a mova needing a label.  Create it.  */\n+\t\t  else if (GET_CODE (src) == CONST\n+\t\t\t   && GET_CODE (XEXP (src, 0)) == UNSPEC\n+\t\t\t   && XINT (XEXP (src, 0), 1) == 1\n+\t\t\t   && GET_CODE (XVECEXP (XEXP (src, 0),\n+\t\t\t\t\t\t 0, 0)) == CONST)\n+\t\t    {\n+\t\t      lab = add_constant (XVECEXP (XEXP (src, 0),\n+\t\t\t\t\t\t   0, 0), mode, 0);\n+\t\t      newsrc = gen_rtx_LABEL_REF (VOIDmode, lab);\n+\t\t      newsrc = gen_rtx_UNSPEC (VOIDmode,\n+\t\t\t\t\t       gen_rtvec (1, newsrc), 1);\n+\t\t    }\n \t\t  else\n \t\t    {\n \t\t      lab = add_constant (src, mode, 0);\n@@ -3874,7 +3918,20 @@ sh_expand_prologue ()\n      that already happens to be at the function start into the prologue.  */\n   if (target_flags != save_flags)\n     emit_insn (gen_toggle_sz ());\n+  if (flag_pic && (current_function_uses_pic_offset_table\n+\t\t   || regs_ever_live[PIC_OFFSET_TABLE_REGNUM]))\n+    {\n+      if ((live_regs_mask & (1 << PIC_OFFSET_TABLE_REGNUM)) != 0)\n+\tabort ();\n+      d += UNITS_PER_WORD;\n+      live_regs_mask |= (1 << PIC_OFFSET_TABLE_REGNUM);\n+    }\n   push_regs (live_regs_mask, live_regs_mask2);\n+\n+  if (flag_pic && (current_function_uses_pic_offset_table\n+\t\t   || regs_ever_live[PIC_OFFSET_TABLE_REGNUM]))\n+    emit_insn (gen_GOTaddr2picreg ());\n+\n   if (target_flags != save_flags)\n     emit_insn (gen_toggle_sz ());\n \n@@ -3926,6 +3983,8 @@ sh_expand_epilogue ()\n \n   if (target_flags != save_flags)\n     emit_insn (gen_toggle_sz ());\n+  if (flag_pic && current_function_uses_pic_offset_table)\n+    live_regs_mask |= (1 << PIC_OFFSET_TABLE_REGNUM);\n   if (live_regs_mask & (1 << PR_REG))\n     pop (PR_REG);\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -4329,6 +4388,11 @@ initial_elimination_offset (from, to)\n \n   int live_regs_mask, live_regs_mask2;\n   live_regs_mask = calc_live_regs (&regs_saved, &live_regs_mask2);\n+  if (flag_pic && current_function_uses_pic_offset_table)\n+    {\n+      regs_saved++;\n+      live_regs_mask |= (1 << PIC_OFFSET_TABLE_REGNUM);\n+    }\n   total_auto_space = rounded_frame_size (regs_saved);\n   target_flags = save_flags;\n \n@@ -5189,3 +5253,184 @@ sh_insn_length_adjustment (insn)\n     }\n   return 0;\n }\n+\f\n+/* Return TRUE if X references a SYMBOL_REF whose symbol doesn't have\n+   @GOT or @GOTOFF.  */\n+int\n+nonpic_symbol_mentioned_p (x)\n+     rtx x;\n+{\n+  register const char *fmt;\n+  register int i;\n+\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return 1;\n+\n+  if (GET_CODE (x) == UNSPEC\n+      && (XINT (x, 1) >= 6 && XINT (x, 1) <= 9))\n+      return 0;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (nonpic_symbol_mentioned_p (XVECEXP (x, i, j)))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e' && nonpic_symbol_mentioned_p (XEXP (x, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Convert a non-PIC address in `orig' to a PIC address using @GOT or\n+   @GOTOFF in `reg'. */\n+rtx\n+legitimize_pic_address (orig, mode, reg)\n+     rtx orig;\n+     enum machine_mode mode;\n+     rtx reg;\n+{\n+  if (GET_CODE (orig) == LABEL_REF\n+      || (GET_CODE (orig) == SYMBOL_REF\n+\t  && (CONSTANT_POOL_ADDRESS_P (orig)\n+\t      /* SYMBOL_REF_FLAG is set on static symbols.  */\n+\t      || SYMBOL_REF_FLAG (orig))))\n+    {\n+      if (reg == 0)\n+\treg = gen_reg_rtx (Pmode);\n+\n+      emit_insn (gen_symGOTOFF2reg (reg, orig));\n+      return reg;\n+    }\n+  else if (GET_CODE (orig) == SYMBOL_REF)\n+    {\n+      if (reg == 0)\n+\treg = gen_reg_rtx (Pmode);\n+\n+      emit_insn (gen_symGOT2reg (reg, orig));\n+      return reg;\n+    }\n+  return orig;\n+}\n+\f\n+/* Like output_addr_const(), but recognize PIC unspecs and special\n+   expressions.  */\n+void\n+output_pic_addr_const (file, x)\n+     FILE *file;\n+     rtx x;\n+{\n+  char buf[256];\n+\n+  switch (GET_CODE (x))\n+    {\n+    case PC:\n+      if (flag_pic)\n+\tputc ('.', file);\n+      else\n+\tabort ();\n+      break;\n+\n+    case SYMBOL_REF:\n+      assemble_name (file, XSTR (x, 0));\n+      break;\n+\n+    case LABEL_REF:\n+      x = XEXP (x, 0);\n+      /* FALLTHRU */\n+    case CODE_LABEL:\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (x));\n+      assemble_name (asm_out_file, buf);\n+      break;\n+\n+    case CONST:\n+      output_pic_addr_const (file, XEXP (x, 0));\n+      break;\n+\n+    case CONST_INT:\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));\n+      break;\n+\n+    case CONST_DOUBLE:\n+      if (GET_MODE (x) == VOIDmode)\n+\t{\n+\t  /* We can use %d if the number is <32 bits and positive.  */\n+\t  if (CONST_DOUBLE_HIGH (x) || CONST_DOUBLE_LOW (x) < 0)\n+\t    fprintf (file, \"0x%lx%08lx\",\n+\t\t     (unsigned long) CONST_DOUBLE_HIGH (x),\n+\t\t     (unsigned long) CONST_DOUBLE_LOW (x));\n+\t  else\n+\t    fprintf (file, HOST_WIDE_INT_PRINT_DEC, CONST_DOUBLE_LOW (x));\n+\t}\n+      else\n+\t/* We can't handle floating point constants;\n+\t   PRINT_OPERAND must handle them.  */\n+\toutput_operand_lossage (\"floating constant misused\");\n+      break;\n+\n+    case PLUS:\n+      /* Some assemblers need integer constants to appear first.  */\n+      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+\t{\n+\t  output_pic_addr_const (file, XEXP (x, 0));\n+\t  fprintf (file, \"+\");\n+\t  output_pic_addr_const (file, XEXP (x, 1));\n+\t}\n+      else if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t       || GET_CODE (XEXP (x, 0)) == PC)\n+\t{\n+\t  output_pic_addr_const (file, XEXP (x, 1));\n+\t  fprintf (file, \"+\");\n+\t  output_pic_addr_const (file, XEXP (x, 0));\n+\t}\n+      else\n+\tabort ();\n+      break;\n+\n+    case MINUS:\n+      output_pic_addr_const (file, XEXP (x, 0));\n+      fprintf (file, \"-\");\n+      if (GET_CODE (XEXP (x, 1)) == CONST)\n+\t{\n+\t  putc ('(', file);\n+\t  output_pic_addr_const (file, XEXP (x, 1));\n+\t  putc (')', file);\n+\t}\n+      else\n+\toutput_pic_addr_const (file, XEXP (x, 1));\n+      break;\n+\n+    case UNSPEC:\n+      if ((XVECLEN (x, 0)) > 3)\n+ \tabort ();\n+      output_pic_addr_const (file, XVECEXP (x, 0, 0));\n+      switch (XINT (x, 1))\n+ \t{\n+\tcase 6:\n+\t  /* GLOBAL_OFFSET_TABLE or local symbols, no suffix.  */\n+\t  break;\n+ \tcase 7:\n+ \t  fputs (\"@GOT\", file);\n+ \t  break;\n+\tcase 8:\n+\t  fputs (\"@GOTOFF\", file);\n+\t  break;\n+        case 9:\n+\t  fputs (\"@PLT\", file);\n+\t  break;\n+ \tdefault:\n+ \t  output_operand_lossage (\"invalid UNSPEC as operand\");\n+ \t  break;\n+ \t}\n+      break;\n+\n+    default:\n+      output_operand_lossage (\"invalid expression as operand\");\n+    }\n+}"}, {"sha": "82b56b55f04076b2ec85f27b1092e739c2fbffef", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -78,6 +78,11 @@ extern int code_for_indirect_jump_scratch;\n \t    }\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\t\\\n+      call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   /* Hitachi saves and restores mac registers on call.  */\t\t\\\n   if (TARGET_HITACHI && ! TARGET_NOMACSAVE)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -106,6 +111,7 @@ extern int target_flags;\n #define RELAX_BIT\t(1<<15)\n #define HITACHI_BIT     (1<<22)\n #define NOMACSAVE_BIT   (1<<23)\n+#define PREFERGOT_BIT\t(1<<24)\n #define PADSTRUCT_BIT  (1<<28)\n #define LITTLE_ENDIAN_BIT (1<<29)\n #define IEEE_BIT (1<<30)\n@@ -178,6 +184,9 @@ extern int target_flags;\n /* Nonzero if generating code for a little endian SH.  */\n #define TARGET_LITTLE_ENDIAN     (target_flags & LITTLE_ENDIAN_BIT)\n \n+/* Nonzero if we should prefer @GOT calls when generating PIC.  */\n+#define TARGET_PREFERGOT\t(target_flags & PREFERGOT_BIT)\n+\n #define TARGET_SWITCHES  \t\t\t\\\n { {\"1\",\t        SH1_BIT},\t\t\t\\\n   {\"2\",\t        SH2_BIT},\t\t\t\\\n@@ -198,6 +207,7 @@ extern int target_flags;\n   {\"l\",\t\tLITTLE_ENDIAN_BIT},  \t\t\\\n   {\"no-ieee\",  \t-IEEE_BIT},\t\t\t\\\n   {\"padstruct\", PADSTRUCT_BIT},    \t\t\\\n+  {\"prefergot\",\tPREFERGOT_BIT},\t\t\t\\\n   {\"relax\",\tRELAX_BIT},\t\t\t\\\n   {\"space\", \tSPACE_BIT},\t\t\t\\\n   SUBTARGET_SWITCHES                            \\\n@@ -256,6 +266,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\t\\\n     flag_omit_frame_pointer = 0;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  if (! TARGET_PREFERGOT)\t\t\t\t\t\t\\\n+    flag_no_function_cse = 1;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   /* Never run scheduling before reload, since that can\t\t\t\\\n      break global alloc, and generates slower code anyway due\t\t\\\n      to the pressure on R0.  */\t\t\t\t\t\t\\\n@@ -538,6 +551,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n    current function's return address.  */\n #define RETURN_ADDRESS_POINTER_REGNUM 23\n \n+/* Register to hold the addressing base for position independent\n+   code access to data items.  */\n+#define PIC_OFFSET_TABLE_REGNUM\t12\n+\n+#define GOT_SYMBOL_NAME \"*_GLOBAL_OFFSET_TABLE_\"\n+\n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may be accessed\n    via the stack pointer) in functions that seem suitable.  */\n@@ -1400,6 +1419,8 @@ extern int current_function_anonymous_args;\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\\\n+    (X) = legitimize_pic_address (OLDX, MODE, NULL_RTX);\t\\\n   if (GET_CODE (X) == PLUS\t\t\t\t\t\\\n       && (GET_MODE_SIZE (MODE) == 4\t\t\t\t\\\n \t  || GET_MODE_SIZE (MODE) == 8)\t\t\t\t\\\n@@ -1708,6 +1729,44 @@ extern int current_function_anonymous_args;\n     && GET_CODE (PATTERN (X)) != CLOBBER\t\\\n     && get_attr_is_sfunc (X)))\n \n+\f\n+/* Position Independent Code.  */\n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or function\n+   named by the symbol (such as what section it is in).\n+\n+   On SH, if using PIC, mark a SYMBOL_REF for a non-global symbol\n+   so that we may access it using GOTOFF instead of GOT.  */\n+\n+#define ENCODE_SECTION_INFO(DECL) \\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\trtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\\\n+\t\t   ? TREE_CST_RTL (DECL) : DECL_RTL (DECL));\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tSYMBOL_REF_FLAG (XEXP (rtl, 0)) =\t\t\t\t\\\n+\t  (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\t\\\n+\t   || ! TREE_PUBLIC (DECL));\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#define FINALIZE_PIC\t\t\t\t\t\t\t\\\n+  current_function_uses_pic_offset_table |= profile_flag | profile_block_flag\n+\n+/* We can't directly access anything that contains a symbol,\n+   nor can we indirect via the constant pool.  */\n+#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n+\t(! nonpic_symbol_mentioned_p (X)\t\t\t\\\n+\t && (! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\\\n+\t     || ! nonpic_symbol_mentioned_p (get_pool_constant (X))))\n+\n+#define SYMBOLIC_CONST_P(X)\t\\\n+((GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == LABEL_REF)\t\\\n+  && nonpic_symbol_mentioned_p (X))\n+\f\n /* Compute the cost of an address.  For the SH, all valid addresses are\n    the same cost.  */\n /* ??? Perhaps we should make reg+reg addresses have higher cost because\n@@ -2003,12 +2062,12 @@ do { char dstr[30];\t\t\t\t\t\\\n \n #define ASM_OUTPUT_INT(STREAM, EXP)\t\t\\\n   (fprintf ((STREAM), \"\\t.long\\t\"),      \t\\\n-   output_addr_const ((STREAM), (EXP)),  \t\\\n+   output_pic_addr_const ((STREAM), (EXP)),  \t\\\n    fputc ('\\n', (STREAM)))\n \n #define ASM_OUTPUT_SHORT(STREAM, EXP)\t\\\n   (fprintf ((STREAM), \"\\t.short\\t\"),\t\\\n-   output_addr_const ((STREAM), (EXP)),\t\\\n+   output_pic_addr_const ((STREAM), (EXP)),\t\\\n    fputc ('\\n', (STREAM)))\n \n #define ASM_OUTPUT_CHAR(STREAM, EXP)\t\t\\\n@@ -2279,3 +2338,34 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fpscr_set_from_mem ((MODE), (HARD_REGS_LIVE))\n \n #define DWARF_LINE_MIN_INSTR_LENGTH 2\n+\n+#undef INIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP\t\".section\\t.init\"\n+#undef FINI_SECTION_ASM_OP\n+#define FINI_SECTION_ASM_OP\t\".section\\t.fini\"\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+  \"crt1.o%s crti.o%s crtbegin.o%s\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \\\n+  \"crtend.o%s crtn.o%s\"\n+\n+/* SH constant pool breaks the devices in crtstuff.c to control section\n+   in where code resides.  We have to write it as asm code.  */\n+#define CRT_CALL_STATIC_FUNCTION(func) \\\n+  if (0) \\\n+     /* This avoids warnings about the static function being unused.  */ \\\n+     func (); \\\n+  else \\\n+    /* We should be passing FUNC to the asm statement as an asm input\t\\\n+       operand, but this breaks with -fPIC.  FIXME.  */\t\t\t\\\n+    asm \\\n+      (\"mov.l\t1f,r1\\n\\\n+\tmova\t2f,r0\\n\\\n+\tbraf\tr1\\n\\\n+\tlds\tr0,pr\\n\\\n+0:\t.p2align 2\\n\\\n+1:\t.long\t\" USER_LABEL_PREFIX #func \" - 0b\\n\\\n+2:\")"}, {"sha": "9ac6436d189be6940ab602822c983e10beab69c5", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 124, "deletions": 2, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -3295,6 +3295,22 @@\n \t\t      (const_string \"single\") (const_string \"double\")))\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n+;; This is a pc-rel call, using bsrf, for use with PIC.\n+\n+(define_insn \"calli_pcrel\"\n+  [(call (mem:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (reg:SI 48))\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"bsrf\t%0\\\\n%O2:%#\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n (define_insn \"call_valuei\"\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -3309,13 +3325,44 @@\n \t\t      (const_string \"single\") (const_string \"double\")))\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n+(define_insn \"call_valuei_pcrel\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (reg:SI 48))\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"bsrf\t%1\\\\n%O3:%#\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n (define_expand \"call\"\n   [(parallel [(call (mem:SI (match_operand 0 \"arith_reg_operand\" \"\"))\n \t\t\t    (match_operand 1 \"\" \"\"))\n \t      (use (reg:SI 48))\n \t      (clobber (reg:SI 17))])]\n   \"\"\n-  \"operands[0] = force_reg (SImode, XEXP (operands[0], 0));\")\n+  \"\n+if (flag_pic && ! TARGET_SH1 && ! flag_unroll_loops\n+    && GET_CODE (operands[0]) == MEM\n+    && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n+  {\n+    rtx reg = gen_reg_rtx (SImode), lab = gen_label_rtx ();\n+\n+    if (SYMBOL_REF_FLAG (XEXP (operands[0], 0)))\n+      emit_insn (gen_sym_label2reg (reg, XEXP (operands[0], 0), lab));\n+    else\n+      emit_insn (gen_symPLT_label2reg (reg, XEXP (operands[0], 0), lab));\n+    operands[0] = reg;\n+    emit_call_insn (gen_calli_pcrel (operands[0], operands[1], lab));\n+    DONE;\n+  }\n+else\n+  operands[0] = force_reg (SImode, XEXP (operands[0], 0));\")\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"arith_reg_operand\" \"\")\n@@ -3324,7 +3371,24 @@\n \t      (use (reg:SI 48))\n \t      (clobber (reg:SI 17))])]\n   \"\"\n-  \"operands[1] = force_reg (SImode, XEXP (operands[1], 0));\")\n+  \"\n+if (flag_pic && ! TARGET_SH1 && ! flag_unroll_loops\n+    && GET_CODE (operands[1]) == MEM\n+    && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n+  {\n+    rtx reg = gen_reg_rtx (SImode), lab = gen_label_rtx ();\n+\n+    if (SYMBOL_REF_FLAG (XEXP (operands[1], 0)))\n+      emit_insn (gen_sym_label2reg (reg, XEXP (operands[1], 0), lab));\n+    else\n+      emit_insn (gen_symPLT_label2reg (reg, XEXP (operands[1], 0), lab));\n+    operands[1] = reg;\n+    emit_call_insn (gen_call_valuei_pcrel (operands[0], operands[1],\n+\t\t\t\t\t   operands[2], lab));\n+    DONE;\n+  }\n+else\n+  operands[1] = force_reg (SImode, XEXP (operands[1], 0));\")\n \n (define_insn \"indirect_jump\"\n   [(set (pc)\n@@ -3418,6 +3482,58 @@\n   [(set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"type\" \"arith\")])\n \n+(define_expand \"GOTaddr2picreg\"\n+  [(set (reg:SI 0) (const (unspec [(const (unspec [(match_dup 1)] 6))] 1)))\n+  (set (match_dup 0) (const (unspec [(match_dup 1)] 6)))\n+  (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI 0)))]\n+  \"\" \"\n+{\n+  operands[0] = pic_offset_table_rtx;\n+  current_function_uses_pic_offset_table = 1;\n+  operands[1] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);\n+}\n+\")\n+\n+(define_expand \"sym_label2reg\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+\t(const (minus:SI\n+\t\t(unspec [(match_operand:SI 1 \"\" \"\")] 6)\n+\t\t(const (plus:SI (label_ref (match_operand:SI 2 \"\" \"\"))\n+\t\t\t\t(const_int 2))))))]\n+  \"\" \"\")\n+\n+(define_expand \"symGOT2reg\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+        (const (unspec [(match_operand:SI 1 \"\" \"\")] 7)))\n+  (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))\n+  (set (match_dup 0) (mem:SI (match_dup 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = pic_offset_table_rtx;\n+  current_function_uses_pic_offset_table = 1;\n+}\")\n+\n+(define_expand \"symGOTOFF2reg\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+\t(const (unspec [(match_operand:SI 1 \"\" \"\")] 8)))\n+  (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = pic_offset_table_rtx;\n+  current_function_uses_pic_offset_table = 1;\n+}\")\n+\n+(define_expand \"symPLT_label2reg\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+\t(const (minus:SI\n+\t\t(plus:SI (pc)\n+\t\t\t (unspec [(match_operand:SI 1 \"\" \"\")] 9))\n+\t\t(const (plus:SI (label_ref (match_operand:SI 2 \"\" \"\"))\n+\t\t\t\t(const_int 2))))))]\n+  \"\" \"\")\n+\n ;; case instruction for switch statements.\n \n ;; Operand 0 is index\n@@ -3912,6 +4028,9 @@\n {\n   operands[1] = get_fpscr_rtx ();\n   operands[2] = gen_rtx_SYMBOL_REF (SImode, \\\"__fpscr_values\\\");\n+  if (flag_pic)\n+    operands[2] = legitimize_pic_address (operands[2], SImode,\n+\t\t\t\t\t  no_new_pseudos ? operands[0] : 0);\n }\")\n \n (define_expand \"fpu_switch1\"\n@@ -3923,6 +4042,9 @@\n {\n   operands[1] = get_fpscr_rtx ();\n   operands[2] = gen_rtx_SYMBOL_REF (SImode, \\\"__fpscr_values\\\");\n+  if (flag_pic)\n+    operands[2] = legitimize_pic_address (operands[2], SImode,\n+\t\t\t\t\t  no_new_pseudos ? operands[0] : 0);\n   operands[3] = no_new_pseudos ? operands[0] : gen_reg_rtx (SImode);\n }\")\n "}, {"sha": "29807d79c24110d1885c8f592fddb822b0a0f753", "filename": "gcc/config/sh/t-elf", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Ft-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Ft-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-elf?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -0,0 +1,9 @@\n+EXTRA_MULTILIB_PARTS= crt1.o crti.o crtn.o \\\n+\tcrtbegin.o crtend.o crtbeginS.o crtendS.o\n+\n+# Compile crtbeginS.o and crtendS.o with pic.\n+CRTSTUFF_T_CFLAGS_S = -fPIC\n+\n+# Don't compile libgcc with -fpic for now.  It's unlikely that we'll\n+# build shared libraries for embedded SH.\n+# TARGET_LIBGCC2_CFLAGS = -fpic"}, {"sha": "99ae929d0f0e0b39718cfcc066f398c90544ebb7", "filename": "gcc/config/sh/t-sh", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -27,3 +27,12 @@ MULTILIB_MATCHES = m2=m3 m2=m4-nofpu\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n+\n+$(T)crt1.o: $(srcdir)/config/sh/crt1.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crt1.o -x assembler-with-cpp $(srcdir)/config/sh/crt1.asm\n+$(T)crti.o: $(srcdir)/config/sh/crti.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/sh/crti.asm\n+$(T)crtn.o: $(srcdir)/config/sh/crtn.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/sh/crtn.asm\n+\n+EXTRA_MULTILIB_PARTS= crt1.o crti.o crtn.o crtbegin.o crtend.o"}, {"sha": "ed7f32a6872fb447e27eedfc0489265f5e12c17a", "filename": "gcc/configure", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -6308,11 +6308,12 @@ for machine in $build $host $target; do\n \t\tuse_collect2=yes\n \t\t;;\n \tsh-*-elf*)\n+\t\ttmake_file=\"sh/t-sh sh/t-elf\"\n \t\ttm_file=\"sh/sh.h sh/elf.h\"\n \t\tfloat_format=sh\n \t\t;;\n \tsh-*-rtemself*)\n-\t\ttmake_file=\"sh/t-sh t-rtems\"\n+\t\ttmake_file=\"sh/t-sh sh/t-elf t-rtems\"\n \t\ttm_file=\"sh/sh.h sh/elf.h sh/rtemself.h\"\n \t\tfloat_format=sh\n \t\t;;"}, {"sha": "bee31c0643775c923c4c7bbc995d56110ea2f95d", "filename": "gcc/configure.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -3344,11 +3344,12 @@ changequote([,])dnl\n \t\tuse_collect2=yes\n \t\t;;\n \tsh-*-elf*)\n+\t\ttmake_file=\"sh/t-sh sh/t-elf\"\n \t\ttm_file=\"sh/sh.h sh/elf.h\"\n \t\tfloat_format=sh\n \t\t;;\n \tsh-*-rtemself*)\n-\t\ttmake_file=\"sh/t-sh t-rtems\"\n+\t\ttmake_file=\"sh/t-sh sh/t-elf t-rtems\"\n \t\ttm_file=\"sh/sh.h sh/elf.h sh/rtemself.h\"\n \t\tfloat_format=sh\n \t\t;;"}, {"sha": "523c320253d8ae5d695ae1d00ba1249d7fb07f7e", "filename": "gcc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66cd67e2eb4391e2b71f032aaf036efe5a728d/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=1a66cd67e2eb4391e2b71f032aaf036efe5a728d", "patch": "@@ -418,6 +418,7 @@ in the following sections.\n -mb  -ml  -mdalign  -mrelax\n -mbigtable  -mfmovd  -mhitachi  -mnomacsave\n -misize  -mpadstruct  -mspace\n+-mprefergot\n \n @emph{System V Options}\n -Qy  -Qn  -YP,@var{paths}  -Ym,@var{dir}\n@@ -6713,6 +6714,10 @@ which is incompatible with the SH ABI.\n \n @item -mspace\n Optimize for space instead of speed.  Implied by @code{-Os}.\n+\n+@item -mprefergot\n+When generating position-independent code, emit function calls using\n+the Global Offset Table instead of the Procedure Linkage Table.\n @end table\n \n @node System V Options"}]}