{"sha": "bfdade77da046cd5d11e2b8096e0b33e6f927141", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZkYWRlNzdkYTA0NmNkNWQxMWUyYjgwOTZlMGIzM2U2ZjkyNzE0MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-12-22T15:37:09Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-12-22T15:37:09Z"}, "message": "* predict.c: Reformatting and minor cleanups.\n\nFrom-SVN: r48269", "tree": {"sha": "94e3cac34477090fc691adec726e5559e403d1a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94e3cac34477090fc691adec726e5559e403d1a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfdade77da046cd5d11e2b8096e0b33e6f927141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfdade77da046cd5d11e2b8096e0b33e6f927141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfdade77da046cd5d11e2b8096e0b33e6f927141", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfdade77da046cd5d11e2b8096e0b33e6f927141/comments", "author": null, "committer": null, "parents": [{"sha": "6c7d86ec5e891cdd8ce1c8cfd1d28fe484e21e6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7d86ec5e891cdd8ce1c8cfd1d28fe484e21e6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c7d86ec5e891cdd8ce1c8cfd1d28fe484e21e6b"}], "stats": {"total": 332, "additions": 171, "deletions": 161}, "files": [{"sha": "baef9d71a65bcdcc343925d7e924a7c3b9ddb579", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfdade77da046cd5d11e2b8096e0b33e6f927141/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfdade77da046cd5d11e2b8096e0b33e6f927141/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfdade77da046cd5d11e2b8096e0b33e6f927141", "patch": "@@ -1,5 +1,7 @@\n Sat Dec 22 08:59:50 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* predict.c: Reformatting and minor cleanups.\n+\n \t* expr.c (expand_expr, case ADDR_EXPR): Handling taking address of\n \tSAVE_EXPR.\n \t* function.c (gen_mem_addressof): Add missing tests for SAVE_EXPR."}, {"sha": "35a6af233da4eca8a6bf39e37dffecc680919cab", "filename": "gcc/predict.c", "status": "modified", "additions": 169, "deletions": 161, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfdade77da046cd5d11e2b8096e0b33e6f927141/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfdade77da046cd5d11e2b8096e0b33e6f927141/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=bfdade77da046cd5d11e2b8096e0b33e6f927141", "patch": "@@ -1,22 +1,22 @@\n /* Branch prediction routines for the GNU compiler.\n    Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of GCC.\n+This file is part of GCC.\n \n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n \n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-   02111-1307, USA.  */\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n \n /* References:\n \n@@ -25,9 +25,7 @@\n    [2] \"Static Branch Frequency and Program Profile Analysis\"\n        Wu and Larus; MICRO-27.\n    [3] \"Corpus-based Static Branch Prediction\"\n-       Calder, Grunwald, Lindsay, Martin, Mozer, and Zorn; PLDI '95.\n-\n-*/\n+       Calder, Grunwald, Lindsay, Martin, Mozer, and Zorn; PLDI '95.   */\n \n \n #include \"config.h\"\n@@ -67,6 +65,7 @@ static void counts_to_freqs\t\t PARAMS ((void));\n \n /* Information we hold about each branch predictor.\n    Filled using information from predict.def.  */\n+\n struct predictor_info\n {\n   const char *const name;\t/* Name used in the debugging dumps.  */\n@@ -81,10 +80,10 @@ struct predictor_info\n \n /* Recompute hitrate in percent to our representation.  */\n \n-#define HITRATE(VAL) ((int)((VAL) * REG_BR_PROB_BASE + 50) / 100)\n+#define HITRATE(VAL) ((int) ((VAL) * REG_BR_PROB_BASE + 50) / 100)\n \n #define DEF_PREDICTOR(ENUM, NAME, HITRATE, FLAGS) {NAME, HITRATE, FLAGS},\n-static const struct predictor_info predictor_info[] = {\n+static const struct predictor_info predictor_info[]= {\n #include \"predict.def\"\n \n   /* Upper bound on predictors.  */\n@@ -100,6 +99,7 @@ predict_insn (insn, predictor, probability)\n {\n   if (!any_condjump_p (insn))\n     abort ();\n+\n   REG_NOTES (insn)\n     = gen_rtx_EXPR_LIST (REG_BR_PRED,\n \t\t\t gen_rtx_CONCAT (VOIDmode,\n@@ -109,19 +109,23 @@ predict_insn (insn, predictor, probability)\n }\n \n /* Predict insn by given predictor.  */\n+\n void\n predict_insn_def (insn, predictor, taken)\n      rtx insn;\n      enum br_predictor predictor;\n      enum prediction taken;\n {\n    int probability = predictor_info[(int) predictor].hitrate;\n+\n    if (taken != TAKEN)\n      probability = REG_BR_PROB_BASE - probability;\n+\n    predict_insn (insn, predictor, probability);\n }\n \n /* Predict edge E with given probability if possible.  */\n+\n void\n predict_edge (e, predictor, probability)\n      edge e;\n@@ -144,6 +148,7 @@ predict_edge (e, predictor, probability)\n }\n \n /* Predict edge E by given predictor if possible.  */\n+\n void\n predict_edge_def (e, predictor, taken)\n      edge e;\n@@ -154,29 +159,29 @@ predict_edge_def (e, predictor, taken)\n \n    if (taken != TAKEN)\n      probability = REG_BR_PROB_BASE - probability;\n+\n    predict_edge (e, predictor, probability);\n }\n \n /* Invert all branch predictions or probability notes in the INSN.  This needs\n    to be done each time we invert the condition used by the jump.  */\n+\n void\n invert_br_probabilities (insn)\n      rtx insn;\n {\n-  rtx note = REG_NOTES (insn);\n-\n-  while (note)\n-    {\n-      if (REG_NOTE_KIND (note) == REG_BR_PROB)\n-\tXEXP (note, 0) = GEN_INT (REG_BR_PROB_BASE - INTVAL (XEXP (note, 0)));\n-      else if (REG_NOTE_KIND (note) == REG_BR_PRED)\n-\tXEXP (XEXP (note, 0), 1)\n-\t  = GEN_INT (REG_BR_PROB_BASE - INTVAL (XEXP (XEXP (note, 0), 1)));\n-      note = XEXP (note, 1);\n-    }\n+  rtx note;\n+\n+  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+    if (REG_NOTE_KIND (note) == REG_BR_PROB)\n+      XEXP (note, 0) = GEN_INT (REG_BR_PROB_BASE - INTVAL (XEXP (note, 0)));\n+    else if (REG_NOTE_KIND (note) == REG_BR_PRED)\n+      XEXP (XEXP (note, 0), 1)\n+\t= GEN_INT (REG_BR_PROB_BASE - INTVAL (XEXP (XEXP (note, 0), 1)));\n }\n \n /* Dump information about the branch prediction to the output file.  */\n+\n static void\n dump_prediction (predictor, probability, bb, used)\n      enum br_predictor predictor;\n@@ -194,33 +199,31 @@ dump_prediction (predictor, probability, bb, used)\n \n   fprintf (rtl_dump_file, \"  %s heuristics%s: %.1f%%\",\n \t   predictor_info[predictor].name,\n-\t   used ? \"\" : \" (ignored)\",\n-\t   probability * 100.0 / REG_BR_PROB_BASE);\n+\t   used ? \"\" : \" (ignored)\", probability * 100.0 / REG_BR_PROB_BASE);\n \n   if (bb->count)\n     {\n       fprintf (rtl_dump_file, \"  exec \");\n-      fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC,\n-\t       (HOST_WIDEST_INT) bb->count);\n+      fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC, bb->count);\n       fprintf (rtl_dump_file, \" hit \");\n-      fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC,\n-\t       (HOST_WIDEST_INT) e->count);\n-      fprintf (rtl_dump_file, \" (%.1f%%)\",\n-\t       e->count * 100.0 / bb->count);\n+      fprintf (rtl_dump_file, HOST_WIDEST_INT_PRINT_DEC, e->count);\n+      fprintf (rtl_dump_file, \" (%.1f%%)\", e->count * 100.0 / bb->count);\n     }\n+\n   fprintf (rtl_dump_file, \"\\n\");\n }\n \n /* Combine all REG_BR_PRED notes into single probability and attach REG_BR_PROB\n    note if not already present.  Remove now useless REG_BR_PRED notes.  */\n+\n static void\n combine_predictions_for_insn (insn, bb)\n      rtx insn;\n      basic_block bb;\n {\n   rtx prob_note = find_reg_note (insn, REG_BR_PROB, 0);\n   rtx *pnote = &REG_NOTES (insn);\n-  rtx note = REG_NOTES (insn);\n+  rtx note;\n   int best_probability = PROB_EVEN;\n   int best_predictor = END_PREDICTORS;\n   int combined_probability = REG_BR_PROB_BASE / 2;\n@@ -235,29 +238,27 @@ combine_predictions_for_insn (insn, bb)\n   /* We implement \"first match\" heuristics and use probability guessed\n      by predictor with smallest index.  In the future we will use better\n      probability combination techniques.  */\n-  while (note)\n-    {\n-      if (REG_NOTE_KIND (note) == REG_BR_PRED)\n-\t{\n-\t  int predictor = INTVAL (XEXP (XEXP (note, 0), 0));\n-\t  int probability = INTVAL (XEXP (XEXP (note, 0), 1));\n-\n-\t  found = true;\n-\t  if (best_predictor > predictor)\n-\t    best_probability = probability, best_predictor = predictor;\n-\n-\t  d = (combined_probability * probability\n-\t       + (REG_BR_PROB_BASE - combined_probability)\n-\t       * (REG_BR_PROB_BASE - probability));\n-\t  /* An FP math to avoid overflows of 32bit integers.  */\n-\t  combined_probability = (((double)combined_probability) * probability\n-\t\t\t\t  * REG_BR_PROB_BASE / d + 0.5);\n-\t}\n-      note = XEXP (note, 1);\n-    }\n-\n-  /* Decide heuristic to use.  In case we didn't match anything, use\n-     no_prediction heuristic, in case we did match, use either\n+  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+    if (REG_NOTE_KIND (note) == REG_BR_PRED)\n+      {\n+\tint predictor = INTVAL (XEXP (XEXP (note, 0), 0));\n+\tint probability = INTVAL (XEXP (XEXP (note, 0), 1));\n+\n+\tfound = true;\n+\tif (best_predictor > predictor)\n+\t  best_probability = probability, best_predictor = predictor;\n+\n+\td = (combined_probability * probability\n+\t     + (REG_BR_PROB_BASE - combined_probability)\n+\t     * (REG_BR_PROB_BASE - probability));\n+\n+\t/* Use FP math to avoid overflows of 32bit integers.  */\n+\tcombined_probability = (((double) combined_probability) * probability\n+\t\t\t\t* REG_BR_PROB_BASE / d + 0.5);\n+      }\n+\n+  /* Decide which heuristic to use.  In case we didn't match anything,\n+     use no_prediction heuristic, in case we did match, use either\n      first match or Dempster-Shaffer theory depending on the flags.  */\n \n   if (predictor_info [best_predictor].flags & PRED_FLAG_FIRST_MATCH)\n@@ -267,8 +268,7 @@ combine_predictions_for_insn (insn, bb)\n     dump_prediction (PRED_NO_PREDICTION, combined_probability, bb, true);\n   else\n     {\n-      dump_prediction (PRED_DS_THEORY, combined_probability, bb,\n-\t\t       !first_match);\n+      dump_prediction (PRED_DS_THEORY, combined_probability, bb, !first_match);\n       dump_prediction (PRED_FIRST_MATCH, best_probability, bb, first_match);\n     }\n \n@@ -290,17 +290,20 @@ combine_predictions_for_insn (insn, bb)\n       else\n         pnote = &XEXP (*pnote, 1);\n     }\n+\n   if (!prob_note)\n     {\n       REG_NOTES (insn)\n \t= gen_rtx_EXPR_LIST (REG_BR_PROB,\n \t\t\t     GEN_INT (combined_probability), REG_NOTES (insn));\n+\n       /* Save the prediction into CFG in case we are seeing non-degenerated\n \t conditional jump.  */\n       if (bb->succ->succ_next)\n \t{\n \t  BRANCH_EDGE (bb)->probability = combined_probability;\n-\t  FALLTHRU_EDGE (bb)->probability = REG_BR_PROB_BASE - combined_probability;\n+\t  FALLTHRU_EDGE (bb)->probability\n+\t    = REG_BR_PROB_BASE - combined_probability;\n \t}\n     }\n }\n@@ -335,37 +338,34 @@ estimate_probability (loops_info)\n       flow_loop_scan (loops_info, loop, LOOP_EXIT_EDGES);\n       exits = loop->num_exits;\n \n-      for (j = loop->first->index;\n-\t   j <= loop->last->index;\n-\t   ++j)\n-\t{\n-\t  if (TEST_BIT (loop->nodes, j))\n-\t    {\n-\t      int header_found = 0;\n-\t      edge e;\n-\n-\t      /* Loop branch heuristics - predict as taken an edge back to\n-\t         a loop's head.  */\n+      for (j = loop->first->index; j <= loop->last->index; ++j)\n+\tif (TEST_BIT (loop->nodes, j))\n+\t  {\n+\t    int header_found = 0;\n+\t    edge e;\n+\n+\t    /* Loop branch heuristics - predict an edge back to a\n+\t       loop's head as taken.  */\n+\t    for (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n+\t      if (e->dest == loop->header\n+\t\t  && e->src == loop->latch)\n+\t\t{\n+\t\t  header_found = 1;\n+\t\t  predict_edge_def (e, PRED_LOOP_BRANCH, TAKEN);\n+\t\t}\n+\n+\t    /* Loop exit heuristics - predict an edge exiting the loop if the\n+\t       conditinal has no loop header successors as not taken.  */\n+\t    if (!header_found)\n \t      for (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n-\t\tif (e->dest == loop->header\n-\t\t    && e->src == loop->latch)\n-\t\t  {\n-\t\t    header_found = 1;\n-\t\t    predict_edge_def (e, PRED_LOOP_BRANCH, TAKEN);\n-\t\t  }\n-\t      /* Loop exit heuristics - predict as not taken an edge\n-\t         exiting the loop if the conditinal has no loop header\n-\t         successors.  */\n-\t      if (!header_found)\n-\t\tfor (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n-\t\t  if (e->dest->index < 0\n-\t\t      || !TEST_BIT (loop->nodes, e->dest->index))\n-\t\t    predict_edge (e, PRED_LOOP_EXIT,\n-\t\t\t\t  (REG_BR_PROB_BASE\n-\t\t\t\t   - predictor_info [(int)PRED_LOOP_EXIT].hitrate)\n-\t\t\t\t  / exits);\n-\t    }\n-\t}\n+\t\tif (e->dest->index < 0\n+\t\t    || !TEST_BIT (loop->nodes, e->dest->index))\n+\t\t  predict_edge\n+\t\t    (e, PRED_LOOP_EXIT,\n+\t\t     (REG_BR_PROB_BASE\n+\t\t      - predictor_info [(int)PRED_LOOP_EXIT].hitrate)\n+\t\t     / exits);\n+\t  }\n     }\n \n   /* Attempt to predict conditional jumps using a number of heuristics.  */\n@@ -376,30 +376,27 @@ estimate_probability (loops_info)\n       rtx cond, earliest;\n       edge e;\n \n-      /* If block has no successor, predict all possible paths to\n-         it as improbable, as the block contains a call to a noreturn\n-\t function and thus can be executed only once.  */\n+      /* If block has no successor, predict all possible paths to it as\n+         improbable, as the block contains a call to a noreturn function and\n+         thus can be executed only once.  */\n       if (bb->succ == NULL && !found_noreturn)\n \t{\n \t  int y;\n \n \t  /* ??? Postdominator claims each noreturn block to be postdominated\n \t     by each, so we need to run only once.  This needs to be changed\n-\t     once postdominace algorithm is updated to say something more sane.\n-\t     */\n+\t     once postdominace algorithm is updated to say something more\n+\t     sane. */\n \t  found_noreturn = 1;\n \t  for (y = 0; y < n_basic_blocks; y++)\n \t    if (!TEST_BIT (post_dominators[y], i))\n-\t      {\n-\t\tfor (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n+\t      for (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n \t\tif (e->dest->index >= 0\n \t\t    && TEST_BIT (post_dominators[e->dest->index], i))\n \t\t  predict_edge_def (e, PRED_NORETURN, NOT_TAKEN);\n-\t      }\n \t}\n \n-      if (GET_CODE (last_insn) != JUMP_INSN\n-\t  || ! any_condjump_p (last_insn))\n+      if (GET_CODE (last_insn) != JUMP_INSN || ! any_condjump_p (last_insn))\n \tcontinue;\n \n       for (e = bb->succ; e; e = e->succ_next)\n@@ -413,12 +410,12 @@ estimate_probability (loops_info)\n \n \t  /* Look for block we are guarding (ie we dominate it,\n \t     but it doesn't postdominate us).  */\n-\t  if (e->dest != EXIT_BLOCK_PTR\n-\t      && e->dest != bb\n+\t  if (e->dest != EXIT_BLOCK_PTR && e->dest != bb\n \t      && TEST_BIT (dominators[e->dest->index], e->src->index)\n \t      && !TEST_BIT (post_dominators[e->src->index], e->dest->index))\n \t    {\n \t      rtx insn;\n+\n \t      /* The call heuristic claims that a guarded function call\n \t\t is improbable.  This is because such calls are often used\n \t\t to signal exceptional situations such as printing error\n@@ -446,18 +443,14 @@ estimate_probability (loops_info)\n       if (GET_RTX_CLASS (GET_CODE (cond)) == '<'\n \t  && ((REG_P (XEXP (cond, 0)) && REG_POINTER (XEXP (cond, 0)))\n \t      || (REG_P (XEXP (cond, 1)) && REG_POINTER (XEXP (cond, 1)))))\n-\tswitch (GET_CODE (cond))\n-\t  {\n-\t  case EQ:\n+\t{\n+\t  if (GET_CODE (cond) == EQ)\n \t    predict_insn_def (last_insn, PRED_POINTER, NOT_TAKEN);\n-\t    break;\n-\t  case NE:\n+\t  else if (GET_CODE (cond) == NE)\n \t    predict_insn_def (last_insn, PRED_POINTER, TAKEN);\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n+\t}\n       else\n+\n       /* Try \"opcode heuristic.\"\n \t EQ tests are usually false and NE tests are usually true. Also,\n \t most quantities are positive, so we can make the appropriate guesses\n@@ -479,11 +472,13 @@ estimate_probability (loops_info)\n \t      ;\n \t    /* Comparisons with 0 are often used for booleans and there is\n \t       nothing usefull to predict about them.  */\n-\t    else if (XEXP (cond, 1) == const0_rtx || XEXP (cond, 0) == const0_rtx)\n+\t    else if (XEXP (cond, 1) == const0_rtx\n+\t\t     || XEXP (cond, 0) == const0_rtx)\n \t      ;\n \t    else\n \t      predict_insn_def (last_insn, PRED_OPCODE_NONEQUAL, NOT_TAKEN);\n \t    break;\n+\n \t  case NE:\n \t  case LTGT:\n \t    /* Floating point comparisons appears to behave in a very\n@@ -493,23 +488,28 @@ estimate_probability (loops_info)\n \t      ;\n \t    /* Comparisons with 0 are often used for booleans and there is\n \t       nothing usefull to predict about them.  */\n-\t    else if (XEXP (cond, 1) == const0_rtx || XEXP (cond, 0) == const0_rtx)\n+\t    else if (XEXP (cond, 1) == const0_rtx\n+\t\t     || XEXP (cond, 0) == const0_rtx)\n \t      ;\n \t    else\n \t      predict_insn_def (last_insn, PRED_OPCODE_NONEQUAL, TAKEN);\n \t    break;\n+\n \t  case ORDERED:\n \t    predict_insn_def (last_insn, PRED_FPOPCODE, TAKEN);\n \t    break;\n+\n \t  case UNORDERED:\n \t    predict_insn_def (last_insn, PRED_FPOPCODE, NOT_TAKEN);\n \t    break;\n+\n \t  case LE:\n \t  case LT:\n \t    if (XEXP (cond, 1) == const0_rtx || XEXP (cond, 1) == const1_rtx\n \t\t|| XEXP (cond, 1) == constm1_rtx)\n \t      predict_insn_def (last_insn, PRED_OPCODE_POSITIVE, NOT_TAKEN);\n \t    break;\n+\n \t  case GE:\n \t  case GT:\n \t    if (XEXP (cond, 1) == const0_rtx || XEXP (cond, 1) == const1_rtx\n@@ -524,23 +524,19 @@ estimate_probability (loops_info)\n \n   /* Attach the combined probability to each conditional jump.  */\n   for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      rtx last_insn = BLOCK_END (i);\n+    if (GET_CODE (BLOCK_END (i)) == JUMP_INSN\n+\t&& any_condjump_p (BLOCK_END (i)))\n+      combine_predictions_for_insn (BLOCK_END (i), BASIC_BLOCK (i));\n \n-      if (GET_CODE (last_insn) != JUMP_INSN\n-\t  || ! any_condjump_p (last_insn))\n-\tcontinue;\n-      combine_predictions_for_insn (last_insn, BASIC_BLOCK (i));\n-    }\n   sbitmap_vector_free (post_dominators);\n   sbitmap_vector_free (dominators);\n \n   estimate_bb_frequencies (loops_info);\n }\n \f\n-/* __builtin_expect dropped tokens into the insn stream describing\n-   expected values of registers.  Generate branch probabilities\n-   based off these values.  */\n+/* __builtin_expect dropped tokens into the insn stream describing expected\n+   values of registers.  Generate branch probabilities based off these\n+   values.  */\n \n void\n expected_value_to_br_prob ()\n@@ -566,20 +562,19 @@ expected_value_to_br_prob ()\n \t  ev = NULL_RTX;\n \t  continue;\n \n-\tdefault:\n-\t  /* Look for insns that clobber the EV register.  */\n-\t  if (ev && reg_set_p (ev_reg, insn))\n-\t    ev = NULL_RTX;\n-\t  continue;\n-\n \tcase JUMP_INSN:\n \t  /* Look for simple conditional branches.  If we haven't got an\n \t     expected value yet, no point going further.  */\n-\t  if (GET_CODE (insn) != JUMP_INSN || ev == NULL_RTX)\n-\t    continue;\n-\t  if (! any_condjump_p (insn))\n+\t  if (GET_CODE (insn) != JUMP_INSN || ev == NULL_RTX\n+\t      || ! any_condjump_p (insn))\n \t    continue;\n \t  break;\n+\n+\tdefault:\n+\t  /* Look for insns that clobber the EV register.  */\n+\t  if (ev && reg_set_p (ev_reg, insn))\n+\t    ev = NULL_RTX;\n+\t  continue;\n \t}\n \n       /* Collect the branch condition, hopefully relative to EV_REG.  */\n@@ -593,8 +588,7 @@ expected_value_to_br_prob ()\n \t Could use cselib to try and reduce this further.  */\n       cond = XEXP (SET_SRC (pc_set (insn)), 0);\n       cond = canonicalize_condition (insn, cond, 0, NULL, ev_reg);\n-      if (! cond\n-\t  || XEXP (cond, 0) != ev_reg\n+      if (! cond || XEXP (cond, 0) != ev_reg\n \t  || GET_CODE (XEXP (cond, 1)) != CONST_INT)\n \tcontinue;\n \n@@ -650,6 +644,7 @@ typedef struct edge_info_def\n \n /* Helper function for estimate_bb_frequencies.\n    Propagate the frequencies for loops headed by HEAD.  */\n+\n static void\n propagate_freq (head)\n      basic_block head;\n@@ -668,6 +663,7 @@ propagate_freq (head)\n       if (BLOCK_INFO (bb)->tovisit)\n \t{\n \t  int count = 0;\n+\n \t  for (e = bb->pred; e; e = e->pred_next)\n \t    if (BLOCK_INFO (e->src)->tovisit && !(e->flags & EDGE_DFS_BACK))\n \t      count++;\n@@ -683,7 +679,7 @@ propagate_freq (head)\n   BLOCK_INFO (head)->frequency = 1;\n   for (; bb; bb = nextbb)\n     {\n-      volatile double cyclic_probability = 0, frequency = 0;\n+      double cyclic_probability = 0, frequency = 0;\n \n       nextbb = BLOCK_INFO (bb)->next;\n       BLOCK_INFO (bb)->next = NULL;\n@@ -716,9 +712,9 @@ propagate_freq (head)\n       /* Compute back edge frequencies.  */\n       for (e = bb->succ; e; e = e->succ_next)\n \tif (e->dest == head)\n-\t  EDGE_INFO (e)->back_edge_prob = (e->probability\n-\t\t\t\t\t   * BLOCK_INFO (bb)->frequency\n-\t\t\t\t\t   / REG_BR_PROB_BASE);\n+\t  EDGE_INFO (e)->back_edge_prob\n+\t    = ((e->probability * BLOCK_INFO (bb)->frequency)\n+\t       / REG_BR_PROB_BASE);\n \n       /* Propagate to successor blocks.  */\n       for (e = bb->succ; e; e = e->succ_next)\n@@ -732,13 +728,15 @@ propagate_freq (head)\n \t\t  nextbb = e->dest;\n \t\telse\n \t\t  BLOCK_INFO (last)->next = e->dest;\n+\n \t\tlast = e->dest;\n \t      }\n \t   }\n     }\n }\n \n /* Estimate probabilities of loopback edges in loops at same nest level.  */\n+\n static void\n estimate_loops_at_level (first_loop)\n      struct loop *first_loop;\n@@ -753,7 +751,8 @@ estimate_loops_at_level (first_loop)\n       estimate_loops_at_level (loop->inner);\n \n       /* Find current loop back edge and mark it.  */\n-      for (e = loop->latch->succ; e->dest != loop->header; e = e->succ_next);\n+      for (e = loop->latch->succ; e->dest != loop->header; e = e->succ_next)\n+\t;\n \n       EDGE_INFO (e)->back_edge = 1;\n \n@@ -764,6 +763,7 @@ estimate_loops_at_level (first_loop)\n \t  for (l = loop->next; l; l = l->next)\n \t    if (l->header == loop->header)\n \t      break;\n+\n \t  if (l)\n \t    continue;\n \t}\n@@ -774,40 +774,42 @@ estimate_loops_at_level (first_loop)\n \t  EXECUTE_IF_SET_IN_SBITMAP (l->nodes, 0, n,\n \t\t\t\t     BLOCK_INFO (BASIC_BLOCK (n))->tovisit = 1\n \t\t\t\t     );\n+\n       propagate_freq (loop->header);\n     }\n }\n \n /* Convert counts measured by profile driven feedback to frequencies.  */\n+\n static void\n counts_to_freqs ()\n {\n   HOST_WIDEST_INT count_max = 1;\n   int i;\n \n   for (i = 0; i < n_basic_blocks; i++)\n-    if (BASIC_BLOCK (i)->count > count_max)\n-      count_max = BASIC_BLOCK (i)->count;\n+    count_max = MAX (BASIC_BLOCK (i)->count, count_max);\n \n   for (i = -2; i < n_basic_blocks; i++)\n     {\n       basic_block bb;\n+\n       if (i == -2)\n \tbb = ENTRY_BLOCK_PTR;\n       else if (i == -1)\n \tbb = EXIT_BLOCK_PTR;\n       else\n \tbb = BASIC_BLOCK (i);\n-      bb->frequency = ((bb->count * BB_FREQ_MAX + count_max / 2)\n-\t\t       / count_max);\n+\n+      bb->frequency = (bb->count * BB_FREQ_MAX + count_max / 2) / count_max;\n     }\n }\n \n-/* Return true if function is likely to be expensive, so there is no point\n-   to optimizer performance of prologue, epilogue or do inlining at the\n-   expense of code size growth.  THRESHOLD is the limit of number\n-   of isntructions function can execute at average to be still considered\n-   not expensive.  */\n+/* Return true if function is likely to be expensive, so there is no point to\n+   optimize performance of prologue, epilogue or do inlining at the expense\n+   of code size growth.  THRESHOLD is the limit of number of isntructions\n+   function can execute at average to be still considered not expensive.  */\n+\n bool\n expensive_function_p (threshold)\n \tint threshold;\n@@ -836,19 +838,19 @@ expensive_function_p (threshold)\n \n       for (insn = bb->head; insn != NEXT_INSN (bb->end);\n \t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (active_insn_p (insn))\n-\t    {\n-\t      sum += bb->frequency;\n-\t      if (sum > limit)\n-\t\treturn true;\n-\t    }\n+\tif (active_insn_p (insn))\n+\t  {\n+\t    sum += bb->frequency;\n+\t    if (sum > limit)\n+\t      return true;\n \t}\n     }\n+\n   return false;\n }\n \n /* Estimate basic blocks frequency by given branch probabilities.  */\n+\n static void\n estimate_bb_frequencies (loops)\n      struct loops *loops;\n@@ -906,6 +908,7 @@ estimate_bb_frequencies (loops)\n \t  fallthru->probability = REG_BR_PROB_BASE - probability;\n \t}\n     }\n+\n   ENTRY_BLOCK_PTR->succ->probability = REG_BR_PROB_BASE;\n \n   /* Set up block info for each basic block.  */\n@@ -922,36 +925,41 @@ estimate_bb_frequencies (loops)\n \tbb = EXIT_BLOCK_PTR;\n       else\n \tbb = BASIC_BLOCK (i);\n+\n       BLOCK_INFO (bb)->tovisit = 0;\n       for (e = bb->succ; e; e = e->succ_next)\n \tEDGE_INFO (e)->back_edge_prob = ((double) e->probability\n \t\t\t\t\t / REG_BR_PROB_BASE);\n     }\n+\n   /* First compute probabilities locally for each loop from innermost\n      to outermost to examine probabilities for back edges.  */\n   estimate_loops_at_level (loops->tree_root);\n \n   /* Now fake loop around whole function to finalize probabilities.  */\n   for (i = 0; i < n_basic_blocks; i++)\n     BLOCK_INFO (BASIC_BLOCK (i))->tovisit = 1;\n+\n   BLOCK_INFO (ENTRY_BLOCK_PTR)->tovisit = 1;\n   BLOCK_INFO (EXIT_BLOCK_PTR)->tovisit = 1;\n   propagate_freq (ENTRY_BLOCK_PTR);\n \n   for (i = 0; i < n_basic_blocks; i++)\n     if (BLOCK_INFO (BASIC_BLOCK (i))->frequency > freq_max)\n       freq_max = BLOCK_INFO (BASIC_BLOCK (i))->frequency;\n+\n   for (i = -2; i < n_basic_blocks; i++)\n     {\n       basic_block bb;\n+\n       if (i == -2)\n \tbb = ENTRY_BLOCK_PTR;\n       else if (i == -1)\n \tbb = EXIT_BLOCK_PTR;\n       else\n \tbb = BASIC_BLOCK (i);\n-      bb->frequency = (BLOCK_INFO (bb)->frequency * BB_FREQ_MAX / freq_max\n-\t\t       + 0.5);\n+      bb->frequency\n+\t= BLOCK_INFO (bb)->frequency * BB_FREQ_MAX / freq_max + 0.5;\n     }\n \n   free_aux_for_blocks ();"}]}