{"sha": "5025f3793e879f9011890fc0641c51693165ffc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAyNWYzNzkzZTg3OWY5MDExODkwZmMwNjQxYzUxNjkzMTY1ZmZjMg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-18T17:16:25Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-18T17:16:25Z"}, "message": "objc-act.c (objc_start_class_interface, [...]): Avoid C++ keywords.\n\n\t* objc-act.c (objc_start_class_interface,\n\tobjc_start_category_interface, objc_start_class_implementation,\n\tobjc_start_category_implementation, objc_build_struct,\n\tgenerate_static_references, build_private_template,\n\tlookup_category, objc_add_method, add_category,\n\tadd_instance_variable, objc_is_public, conforms_to_protocol,\n\tstart_class, continue_class, finish_class): Avoid C++ keywords.\n\nFrom-SVN: r137958", "tree": {"sha": "f516d441570851e434820c5397038692cde9b09a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f516d441570851e434820c5397038692cde9b09a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5025f3793e879f9011890fc0641c51693165ffc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5025f3793e879f9011890fc0641c51693165ffc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5025f3793e879f9011890fc0641c51693165ffc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5025f3793e879f9011890fc0641c51693165ffc2/comments", "author": null, "committer": null, "parents": [{"sha": "920d063d0751208d5b0392d57d9b308c1573f2b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/920d063d0751208d5b0392d57d9b308c1573f2b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/920d063d0751208d5b0392d57d9b308c1573f2b2"}], "stats": {"total": 186, "additions": 98, "deletions": 88}, "files": [{"sha": "50bedc14c719b1c5ebe039b3375fb9116bd279c0", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5025f3793e879f9011890fc0641c51693165ffc2/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5025f3793e879f9011890fc0641c51693165ffc2/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=5025f3793e879f9011890fc0641c51693165ffc2", "patch": "@@ -1,3 +1,13 @@\n+2008-07-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* objc-act.c (objc_start_class_interface,\n+\tobjc_start_category_interface, objc_start_class_implementation,\n+\tobjc_start_category_implementation, objc_build_struct,\n+\tgenerate_static_references, build_private_template,\n+\tlookup_category, objc_add_method, add_category,\n+\tadd_instance_variable, objc_is_public, conforms_to_protocol,\n+\tstart_class, continue_class, finish_class): Avoid C++ keywords.\n+\n 2008-07-14  Jason Merrill  <jason@redhat.com>\n \n \tPR objc++/36723"}, {"sha": "5230f556e5fbac37b2baa9babd562ed22b852c2c", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5025f3793e879f9011890fc0641c51693165ffc2/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5025f3793e879f9011890fc0641c51693165ffc2/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=5025f3793e879f9011890fc0641c51693165ffc2", "patch": "@@ -617,19 +617,19 @@ lookup_protocol_in_reflist (tree rproto_list, tree lproto)\n }\n \n void\n-objc_start_class_interface (tree class, tree super_class, tree protos)\n+objc_start_class_interface (tree klass, tree super_class, tree protos)\n {\n   objc_interface_context\n     = objc_ivar_context\n-    = start_class (CLASS_INTERFACE_TYPE, class, super_class, protos);\n+    = start_class (CLASS_INTERFACE_TYPE, klass, super_class, protos);\n   objc_public_flag = 0;\n }\n \n void\n-objc_start_category_interface (tree class, tree categ, tree protos)\n+objc_start_category_interface (tree klass, tree categ, tree protos)\n {\n   objc_interface_context\n-    = start_class (CATEGORY_INTERFACE_TYPE, class, categ, protos);\n+    = start_class (CATEGORY_INTERFACE_TYPE, klass, categ, protos);\n   objc_ivar_chain\n     = continue_class (objc_interface_context);\n }\n@@ -656,19 +656,19 @@ objc_finish_interface (void)\n }\n \n void\n-objc_start_class_implementation (tree class, tree super_class)\n+objc_start_class_implementation (tree klass, tree super_class)\n {\n   objc_implementation_context\n     = objc_ivar_context\n-    = start_class (CLASS_IMPLEMENTATION_TYPE, class, super_class, NULL_TREE);\n+    = start_class (CLASS_IMPLEMENTATION_TYPE, klass, super_class, NULL_TREE);\n   objc_public_flag = 0;\n }\n \n void\n-objc_start_category_implementation (tree class, tree categ)\n+objc_start_category_implementation (tree klass, tree categ)\n {\n   objc_implementation_context\n-    = start_class (CATEGORY_IMPLEMENTATION_TYPE, class, categ, NULL_TREE);\n+    = start_class (CATEGORY_IMPLEMENTATION_TYPE, klass, categ, NULL_TREE);\n   objc_ivar_chain\n     = continue_class (objc_implementation_context);\n }\n@@ -779,13 +779,13 @@ objc_is_class_id (tree type)\n   return OBJC_TYPE_NAME (type) == objc_class_id;\n }\n \n-/* Construct a C struct with same name as CLASS, a base struct with tag\n+/* Construct a C struct with same name as KLASS, a base struct with tag\n    SUPER_NAME (if any), and FIELDS indicated.  */\n \n static tree\n-objc_build_struct (tree class, tree fields, tree super_name)\n+objc_build_struct (tree klass, tree fields, tree super_name)\n {\n-  tree name = CLASS_NAME (class);\n+  tree name = CLASS_NAME (klass);\n   tree s = start_struct (RECORD_TYPE, name);\n   tree super = (super_name ? xref_tag (RECORD_TYPE, super_name) : NULL_TREE);\n   tree t, objc_info = NULL_TREE;\n@@ -845,7 +845,7 @@ objc_build_struct (tree class, tree fields, tree super_name)\n \n   /* Point the struct at its related Objective-C class.  */\n   INIT_TYPE_OBJC_INFO (s);\n-  TYPE_OBJC_INTERFACE (s) = class;\n+  TYPE_OBJC_INTERFACE (s) = klass;\n \n   s = finish_struct (s, fields, NULL_TREE);\n \n@@ -854,14 +854,14 @@ objc_build_struct (tree class, tree fields, tree super_name)\n     {\n       TYPE_OBJC_INFO (t) = TREE_VALUE (objc_info);\n       /* Replace the IDENTIFIER_NODE with an actual @interface.  */\n-      TYPE_OBJC_INTERFACE (t) = class;\n+      TYPE_OBJC_INTERFACE (t) = klass;\n     }\n \n   /* Use TYPE_BINFO structures to point at the super class, if any.  */\n   objc_xref_basetypes (s, super);\n \n   /* Mark this struct as a class template.  */\n-  CLASS_STATIC_TEMPLATE (class) = s;\n+  CLASS_STATIC_TEMPLATE (klass) = s;\n \n   return s;\n }\n@@ -2418,7 +2418,7 @@ static void\n generate_static_references (void)\n {\n   tree decls = NULL_TREE, expr = NULL_TREE;\n-  tree class_name, class, decl, initlist;\n+  tree class_name, klass, decl, initlist;\n   tree cl_chain, in_chain, type\n     = build_array_type (build_pointer_type (void_type_node), NULL_TREE);\n   int num_inst, num_class;\n@@ -2437,8 +2437,8 @@ generate_static_references (void)\n       decl = start_var_decl (type, buf);\n \n       /* Output {class_name, ...}.  */\n-      class = TREE_VALUE (cl_chain);\n-      class_name = get_objc_string_decl (OBJC_TYPE_NAME (class), class_names);\n+      klass = TREE_VALUE (cl_chain);\n+      class_name = get_objc_string_decl (OBJC_TYPE_NAME (klass), class_names);\n       initlist = build_tree_list (NULL_TREE,\n \t\t\t\t  build_unary_op (ADDR_EXPR, class_name, 1));\n \n@@ -4102,13 +4102,13 @@ build_objc_exception_stuff (void)\n    };  */\n \n static void\n-build_private_template (tree class)\n+build_private_template (tree klass)\n {\n-  if (!CLASS_STATIC_TEMPLATE (class))\n+  if (!CLASS_STATIC_TEMPLATE (klass))\n     {\n-      tree record = objc_build_struct (class,\n-\t\t\t\t       get_class_ivars (class, false),\n-\t\t\t\t       CLASS_SUPER_NAME (class));\n+      tree record = objc_build_struct (klass,\n+\t\t\t\t       get_class_ivars (klass, false),\n+\t\t\t\t       CLASS_SUPER_NAME (klass));\n \n       /* Set the TREE_USED bit for this struct, so that stab generator\n \t can emit stabs for this struct type.  */\n@@ -5646,9 +5646,9 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n /* Retrieve category interface CAT_NAME (if any) associated with CLASS.  */\n \n static inline tree\n-lookup_category (tree class, tree cat_name)\n+lookup_category (tree klass, tree cat_name)\n {\n-  tree category = CLASS_CATEGORY_LIST (class);\n+  tree category = CLASS_CATEGORY_LIST (klass);\n \n   while (category && CLASS_SUPER_NAME (category) != cat_name)\n     category = CLASS_CATEGORY_LIST (category);\n@@ -6911,24 +6911,24 @@ add_method_to_hash_list (hash *hash_list, tree method)\n }\n \n static tree\n-objc_add_method (tree class, tree method, int is_class)\n+objc_add_method (tree klass, tree method, int is_class)\n {\n   tree mth;\n \n   if (!(mth = lookup_method (is_class\n-\t\t\t     ? CLASS_CLS_METHODS (class)\n-\t\t\t     : CLASS_NST_METHODS (class), method)))\n+\t\t\t     ? CLASS_CLS_METHODS (klass)\n+\t\t\t     : CLASS_NST_METHODS (klass), method)))\n     {\n       /* put method on list in reverse order */\n       if (is_class)\n \t{\n-\t  TREE_CHAIN (method) = CLASS_CLS_METHODS (class);\n-\t  CLASS_CLS_METHODS (class) = method;\n+\t  TREE_CHAIN (method) = CLASS_CLS_METHODS (klass);\n+\t  CLASS_CLS_METHODS (klass) = method;\n \t}\n       else\n \t{\n-\t  TREE_CHAIN (method) = CLASS_NST_METHODS (class);\n-\t  CLASS_NST_METHODS (class) = method;\n+\t  TREE_CHAIN (method) = CLASS_NST_METHODS (klass);\n+\t  CLASS_NST_METHODS (klass) = method;\n \t}\n     }\n   else\n@@ -6938,8 +6938,8 @@ objc_add_method (tree class, tree method, int is_class)\n \t and/or return types. We do not do this for @implementations, because\n \t C/C++ will do it for us (i.e., there will be duplicate function\n \t definition errors).  */\n-      if ((TREE_CODE (class) == CLASS_INTERFACE_TYPE\n-\t   || TREE_CODE (class) == CATEGORY_INTERFACE_TYPE)\n+      if ((TREE_CODE (klass) == CLASS_INTERFACE_TYPE\n+\t   || TREE_CODE (klass) == CATEGORY_INTERFACE_TYPE)\n \t  && !comp_proto_with_proto (method, mth, 1))\n \terror (\"duplicate declaration of method %<%c%s%>\",\n \t\tis_class ? '+' : '-',\n@@ -6957,12 +6957,12 @@ objc_add_method (tree class, tree method, int is_class)\n \t instance methods listed in @protocol declarations to\n \t the class hash table, on the assumption that @protocols\n \t may be adopted by root classes or categories.  */\n-      if (TREE_CODE (class) == CATEGORY_INTERFACE_TYPE\n-\t  || TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)\n-\tclass = lookup_interface (CLASS_NAME (class));\n+      if (TREE_CODE (klass) == CATEGORY_INTERFACE_TYPE\n+\t  || TREE_CODE (klass) == CATEGORY_IMPLEMENTATION_TYPE)\n+\tklass = lookup_interface (CLASS_NAME (klass));\n \n-      if (TREE_CODE (class) == PROTOCOL_INTERFACE_TYPE\n-\t  || !CLASS_SUPER_NAME (class))\n+      if (TREE_CODE (klass) == PROTOCOL_INTERFACE_TYPE\n+\t  || !CLASS_SUPER_NAME (klass))\n \tadd_method_to_hash_list (cls_method_hash_list, method);\n     }\n \n@@ -6995,31 +6995,31 @@ add_class (tree class_name, tree name)\n }\n \n static void\n-add_category (tree class, tree category)\n+add_category (tree klass, tree category)\n {\n   /* Put categories on list in reverse order.  */\n-  tree cat = lookup_category (class, CLASS_SUPER_NAME (category));\n+  tree cat = lookup_category (klass, CLASS_SUPER_NAME (category));\n \n   if (cat)\n     {\n       warning (0, \"duplicate interface declaration for category %<%s(%s)%>\",\n-\t       IDENTIFIER_POINTER (CLASS_NAME (class)),\n+\t       IDENTIFIER_POINTER (CLASS_NAME (klass)),\n \t       IDENTIFIER_POINTER (CLASS_SUPER_NAME (category)));\n     }\n   else\n     {\n-      CLASS_CATEGORY_LIST (category) = CLASS_CATEGORY_LIST (class);\n-      CLASS_CATEGORY_LIST (class) = category;\n+      CLASS_CATEGORY_LIST (category) = CLASS_CATEGORY_LIST (klass);\n+      CLASS_CATEGORY_LIST (klass) = category;\n     }\n }\n \n /* Called after parsing each instance variable declaration. Necessary to\n    preserve typedefs and implement public/private...\n \n-   PUBLIC is 1 for public, 0 for protected, and 2 for private.  */\n+   VISIBILITY is 1 for public, 0 for protected, and 2 for private.  */\n \n static tree\n-add_instance_variable (tree class, int public, tree field_decl)\n+add_instance_variable (tree klass, int visibility, tree field_decl)\n {\n   tree field_type = TREE_TYPE (field_decl);\n   const char *ivar_name = DECL_NAME (field_decl)\n@@ -7032,7 +7032,7 @@ add_instance_variable (tree class, int public, tree field_decl)\n       error (\"illegal reference type specified for instance variable %qs\",\n \t     ivar_name);\n       /* Return class as is without adding this ivar.  */\n-      return class;\n+      return klass;\n     }\n #endif\n \n@@ -7042,7 +7042,7 @@ add_instance_variable (tree class, int public, tree field_decl)\n     {\n       error (\"instance variable %qs has unknown size\", ivar_name);\n       /* Return class as is without adding this ivar.  */\n-      return class;\n+      return klass;\n     }\n \n #ifdef OBJCPLUS\n@@ -7088,7 +7088,7 @@ add_instance_variable (tree class, int public, tree field_decl)\n \t\t     \"for instance variable %qs\",\n \t\t     type_name, ivar_name);\n \t      /* Return class as is without adding this ivar.  */\n-\t      return class;\n+\t      return klass;\n \t    }\n \n \t  /* User-defined constructors and destructors are not known to Obj-C\n@@ -7109,7 +7109,7 @@ add_instance_variable (tree class, int public, tree field_decl)\n #endif\n \n   /* Overload the public attribute, it is not used for FIELD_DECLs.  */\n-  switch (public)\n+  switch (visibility)\n     {\n     case 0:\n       TREE_PUBLIC (field_decl) = 0;\n@@ -7131,9 +7131,9 @@ add_instance_variable (tree class, int public, tree field_decl)\n \n     }\n \n-  CLASS_RAW_IVARS (class) = chainon (CLASS_RAW_IVARS (class), field_decl);\n+  CLASS_RAW_IVARS (klass) = chainon (CLASS_RAW_IVARS (klass), field_decl);\n \n-  return class;\n+  return klass;\n }\n \f\n static tree\n@@ -7176,16 +7176,16 @@ objc_is_public (tree expr, tree identifier)\n     {\n       if (TYPE_HAS_OBJC_INFO (basetype) && TYPE_OBJC_INTERFACE (basetype))\n \t{\n-\t  tree class = lookup_interface (OBJC_TYPE_NAME (basetype));\n+\t  tree klass = lookup_interface (OBJC_TYPE_NAME (basetype));\n \n-\t  if (!class)\n+\t  if (!klass)\n \t    {\n \t      error (\"cannot find interface declaration for %qs\",\n \t\t     IDENTIFIER_POINTER (OBJC_TYPE_NAME (basetype)));\n \t      return 0;\n \t    }\n \n-\t  if ((decl = is_ivar (get_class_ivars (class, true), identifier)))\n+\t  if ((decl = is_ivar (get_class_ivars (klass, true), identifier)))\n \t    {\n \t      if (TREE_PUBLIC (decl))\n \t\treturn 1;\n@@ -7206,13 +7206,13 @@ objc_is_public (tree expr, tree identifier)\n \t\t  if (basetype == curtype\n \t\t      || DERIVED_FROM_P (basetype, curtype))\n \t\t    {\n-\t\t      int private = is_private (decl);\n+\t\t      int priv = is_private (decl);\n \n-\t\t      if (private)\n+\t\t      if (priv)\n \t\t\terror (\"instance variable %qs is declared private\",\n \t\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n \n-\t\t      return !private;\n+\t\t      return !priv;\n \t\t    }\n \t\t}\n \n@@ -7272,21 +7272,21 @@ check_methods (tree chain, tree list, int mtype)\n     return first;\n }\n \n-/* Check if CLASS, or its superclasses, explicitly conforms to PROTOCOL.  */\n+/* Check if KLASS, or its superclasses, explicitly conforms to PROTOCOL.  */\n \n static int\n-conforms_to_protocol (tree class, tree protocol)\n+conforms_to_protocol (tree klass, tree protocol)\n {\n    if (TREE_CODE (protocol) == PROTOCOL_INTERFACE_TYPE)\n      {\n-       tree p = CLASS_PROTOCOL_LIST (class);\n+       tree p = CLASS_PROTOCOL_LIST (klass);\n        while (p && TREE_VALUE (p) != protocol)\n \t p = TREE_CHAIN (p);\n \n        if (!p)\n \t {\n-\t   tree super = (CLASS_SUPER_NAME (class)\n-\t\t\t ? lookup_interface (CLASS_SUPER_NAME (class))\n+\t   tree super = (CLASS_SUPER_NAME (klass)\n+\t\t\t ? lookup_interface (CLASS_SUPER_NAME (klass))\n \t\t\t : NULL_TREE);\n \t   int tmp = super ? conforms_to_protocol (super, protocol) : 0;\n \t   if (!tmp)\n@@ -7440,7 +7440,7 @@ static tree\n start_class (enum tree_code code, tree class_name, tree super_name,\n \t     tree protocol_list)\n {\n-  tree class, decl;\n+  tree klass, decl;\n \n #ifdef OBJCPLUS\n   if (current_namespace != global_namespace) {\n@@ -7456,8 +7456,8 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n       objc_implementation_context = NULL_TREE;\n     }\n \n-  class = make_node (code);\n-  TYPE_LANG_SLOT_1 (class) = make_tree_vec (CLASS_LANG_SLOT_ELTS);\n+  klass = make_node (code);\n+  TYPE_LANG_SLOT_1 (klass) = make_tree_vec (CLASS_LANG_SLOT_ELTS);\n \n   /* Check for existence of the super class, if one was specified.  Note\n      that we must have seen an @interface, not just a @class.  If we\n@@ -7478,9 +7478,9 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \tsuper_name = super;\n     }\n \n-  CLASS_NAME (class) = class_name;\n-  CLASS_SUPER_NAME (class) = super_name;\n-  CLASS_CLS_METHODS (class) = NULL_TREE;\n+  CLASS_NAME (klass) = class_name;\n+  CLASS_SUPER_NAME (klass) = super_name;\n+  CLASS_CLS_METHODS (klass) = NULL_TREE;\n \n   if (! objc_is_class_name (class_name)\n       && (decl = lookup_name (class_name)))\n@@ -7510,7 +7510,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n       /* Reset for multiple classes per file.  */\n       method_slot = 0;\n \n-      objc_implementation_context = class;\n+      objc_implementation_context = klass;\n \n       /* Lookup the interface for this implementation.  */\n \n@@ -7553,10 +7553,10 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n #endif\n         IDENTIFIER_POINTER (class_name));\n       else\n-        add_class (class, class_name);\n+        add_class (klass, class_name);\n \n       if (protocol_list)\n-\tCLASS_PROTOCOL_LIST (class)\n+\tCLASS_PROTOCOL_LIST (klass)\n \t  = lookup_and_install_protocols (protocol_list);\n     }\n \n@@ -7575,10 +7575,10 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t  exit (FATAL_EXIT_CODE);\n \t}\n       else\n-        add_category (class_category_is_assoc_with, class);\n+        add_category (class_category_is_assoc_with, klass);\n \n       if (protocol_list)\n-\tCLASS_PROTOCOL_LIST (class)\n+\tCLASS_PROTOCOL_LIST (klass)\n \t  = lookup_and_install_protocols (protocol_list);\n     }\n \n@@ -7587,7 +7587,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n       /* Reset for multiple classes per file.  */\n       method_slot = 0;\n \n-      objc_implementation_context = class;\n+      objc_implementation_context = klass;\n \n       /* For a category, class_name is really the name of the class that\n \t the following set of methods will be associated with.  We must\n@@ -7600,21 +7600,21 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t  exit (FATAL_EXIT_CODE);\n         }\n     }\n-  return class;\n+  return klass;\n }\n \n static tree\n-continue_class (tree class)\n+continue_class (tree klass)\n {\n-  if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE\n-      || TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)\n+  if (TREE_CODE (klass) == CLASS_IMPLEMENTATION_TYPE\n+      || TREE_CODE (klass) == CATEGORY_IMPLEMENTATION_TYPE)\n     {\n       struct imp_entry *imp_entry;\n \n       /* Check consistency of the instance variables.  */\n \n-      if (CLASS_RAW_IVARS (class))\n-\tcheck_ivars (implementation_template, class);\n+      if (CLASS_RAW_IVARS (klass))\n+\tcheck_ivars (implementation_template, klass);\n \n       /* code generation */\n \n@@ -7629,7 +7629,7 @@ continue_class (tree class)\n       imp_entry = (struct imp_entry *) ggc_alloc (sizeof (struct imp_entry));\n \n       imp_entry->next = imp_list;\n-      imp_entry->imp_context = class;\n+      imp_entry->imp_context = klass;\n       imp_entry->imp_template = implementation_template;\n \n       synth_forward_declarations ();\n@@ -7639,7 +7639,7 @@ continue_class (tree class)\n \n       /* Append to front and increment count.  */\n       imp_list = imp_entry;\n-      if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE)\n+      if (TREE_CODE (klass) == CLASS_IMPLEMENTATION_TYPE)\n \timp_count++;\n       else\n \tcat_count++;\n@@ -7651,13 +7651,13 @@ continue_class (tree class)\n       return get_class_ivars (implementation_template, true);\n     }\n \n-  else if (TREE_CODE (class) == CLASS_INTERFACE_TYPE)\n+  else if (TREE_CODE (klass) == CLASS_INTERFACE_TYPE)\n     {\n #ifdef OBJCPLUS\n       push_lang_context (lang_name_c);\n #endif /* OBJCPLUS */\n \n-      build_private_template (class);\n+      build_private_template (klass);\n \n #ifdef OBJCPLUS\n       pop_lang_context ();\n@@ -7673,9 +7673,9 @@ continue_class (tree class)\n /* This is called once we see the \"@end\" in an interface/implementation.  */\n \n static void\n-finish_class (tree class)\n+finish_class (tree klass)\n {\n-  if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE)\n+  if (TREE_CODE (klass) == CLASS_IMPLEMENTATION_TYPE)\n     {\n       /* All code generation is done in finish_objc.  */\n \n@@ -7694,9 +7694,9 @@ finish_class (tree class)\n \t}\n     }\n \n-  else if (TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)\n+  else if (TREE_CODE (klass) == CATEGORY_IMPLEMENTATION_TYPE)\n     {\n-      tree category = lookup_category (implementation_template, CLASS_SUPER_NAME (class));\n+      tree category = lookup_category (implementation_template, CLASS_SUPER_NAME (klass));\n \n       if (category)\n \t{"}]}