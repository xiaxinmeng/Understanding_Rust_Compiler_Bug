{"sha": "d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg1ZDNkNTc4YTVjMmFiY2YyYjA3MWVmNDJhNTU4YTRlZDE4YjU1Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-12-27T09:05:17Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-12-27T09:05:17Z"}, "message": "re PR c++/25439 (\"template<> int A<0>\" accepted)\n\n\tPR c++/25439\n\t* decl.c (grokdeclarator): Remove dead code.\n\t* ptree.c (cxx_print_xnode): Handle BASELINK.\n\t* parser.c (make_id_declarator): Add sfk parameter.  \n\t(cp_parser_direct_declarator): Do not pass TYPE_DECLs to\n\tmake_id_declarator.\n\t(cp_parser_declarator_id): Simplify BASELINKs here.\n\t(cp_parser_member_declaration): Adjust calls to\n\tmake_id_declarator.\n\tPR c++/25439\n\t* g++.dg/parse/crash17.C: Adjust error markers.\n\t* g++.dg/template/error20.C: New test.\n\nFrom-SVN: r109079", "tree": {"sha": "54ef59d674eb69b32d822563e62bc42a55204106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54ef59d674eb69b32d822563e62bc42a55204106"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/comments", "author": null, "committer": null, "parents": [{"sha": "dec2f8810bf2a30c8fa8d0714074df10dc04bc5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec2f8810bf2a30c8fa8d0714074df10dc04bc5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dec2f8810bf2a30c8fa8d0714074df10dc04bc5c"}], "stats": {"total": 152, "additions": 99, "deletions": 53}, "files": [{"sha": "ae0fcf5a9a6a8d6b8612b873309db8019909c10b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "patch": "@@ -1,3 +1,15 @@\n+2005-12-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25439\n+\t* decl.c (grokdeclarator): Remove dead code.\n+\t* ptree.c (cxx_print_xnode): Handle BASELINK.\n+\t* parser.c (make_id_declarator): Add sfk parameter.  \n+\t(cp_parser_direct_declarator): Do not pass TYPE_DECLs to\n+\tmake_id_declarator.\n+\t(cp_parser_declarator_id): Simplify BASELINKs here.\n+\t(cp_parser_member_declaration): Adjust calls to\n+\tmake_id_declarator.\n+\n 2005-12-26  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/23171, c++/23172, c++/25417."}, {"sha": "d6074d7edc965f29fb63751cf2cc6a812a77a991", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "patch": "@@ -6725,10 +6725,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\telse if (TREE_CODE (qualifying_scope) == NAMESPACE_DECL)\n \t\t  in_namespace = qualifying_scope;\n \t      }\n-\t    if (TREE_CODE (decl) == BASELINK)\n-\t      decl = BASELINK_FUNCTIONS (decl);\n-\t    if (decl == error_mark_node)\n-\t      return error_mark_node;\n \t    switch (TREE_CODE (decl))\n \t      {\n \t      case BIT_NOT_EXPR:\n@@ -6792,11 +6788,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \t\tbreak;\n \n-\t      case TYPE_DECL:\n-\t\tdname = constructor_name (TREE_TYPE (decl));\n-\t\tname = IDENTIFIER_POINTER (dname);\n-\t\tbreak;\n-\n \t      default:\n \t\tgcc_unreachable ();\n \t      }\n@@ -7262,20 +7253,13 @@ grokdeclarator (const cp_declarator *declarator,\n   else\n     {\n       unqualified_id = id_declarator->u.id.unqualified_name;\n-      if (TREE_CODE (unqualified_id) == BASELINK)\n-\tunqualified_id = BASELINK_FUNCTIONS (unqualified_id);\n       switch (TREE_CODE (unqualified_id))\n \t{\n \tcase BIT_NOT_EXPR:\n \t  unqualified_id\n \t    = constructor_name (TREE_OPERAND (unqualified_id, 0));\n \t  break;\n \n-\tcase TYPE_DECL:\n-\t  unqualified_id\n-\t    = constructor_name (TREE_TYPE (unqualified_id));\n-\t  break;\n-\n \tcase IDENTIFIER_NODE:\n \tcase TEMPLATE_ID_EXPR:\n \t  break;"}, {"sha": "86d7edbcc47a3eee0a18131a4b30ee8733393e1a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "patch": "@@ -833,12 +833,15 @@ make_declarator (cp_declarator_kind kind)\n   return declarator;\n }\n \n-/* Make a declarator for a generalized identifier.  If non-NULL, the\n-   identifier is QUALIFYING_SCOPE::UNQUALIFIED_NAME; otherwise, it is\n-   just UNQUALIFIED_NAME.  */\n+/* Make a declarator for a generalized identifier.  If\n+   QUALIFYING_SCOPE is non-NULL, the identifier is\n+   QUALIFYING_SCOPE::UNQUALIFIED_NAME; otherwise, it is just\n+   UNQUALIFIED_NAME.  SFK indicates the kind of special function this\n+   is, if any.   */\n \n static cp_declarator *\n-make_id_declarator (tree qualifying_scope, tree unqualified_name)\n+make_id_declarator (tree qualifying_scope, tree unqualified_name,\n+\t\t    special_function_kind sfk)\n {\n   cp_declarator *declarator;\n \n@@ -855,10 +858,14 @@ make_id_declarator (tree qualifying_scope, tree unqualified_name)\n   if (qualifying_scope && TYPE_P (qualifying_scope))\n     qualifying_scope = TYPE_MAIN_VARIANT (qualifying_scope);\n \n+  gcc_assert (TREE_CODE (unqualified_name) == IDENTIFIER_NODE\n+\t      || TREE_CODE (unqualified_name) == BIT_NOT_EXPR\n+\t      || TREE_CODE (unqualified_name) == TEMPLATE_ID_EXPR);\n+\n   declarator = make_declarator (cdk_id);\n   declarator->u.id.qualifying_scope = qualifying_scope;\n   declarator->u.id.unqualified_name = unqualified_name;\n-  declarator->u.id.sfk = sfk_none;\n+  declarator->u.id.sfk = sfk;\n \n   return declarator;\n }\n@@ -11354,6 +11361,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t{\n \t  tree qualifying_scope;\n \t  tree unqualified_name;\n+\t  special_function_kind sfk;\n \n \t  /* Parse a declarator-id */\n \t  if (dcl_kind == CP_PARSER_DECLARATOR_EITHER)\n@@ -11411,9 +11419,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      qualifying_scope = type;\n \t    }\n \n-\t  declarator = make_id_declarator (qualifying_scope,\n-\t\t\t\t\t   unqualified_name);\n-\t  declarator->id_loc = token->location;\n+\t  sfk = sfk_none;\n \t  if (unqualified_name)\n \t    {\n \t      tree class_type;\n@@ -11424,28 +11430,9 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      else\n \t\tclass_type = current_class_type;\n \n-\t      if (class_type)\n+\t      if (TREE_CODE (unqualified_name) == TYPE_DECL)\n \t\t{\n-\t\t  if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR)\n-\t\t    declarator->u.id.sfk = sfk_destructor;\n-\t\t  else if (IDENTIFIER_TYPENAME_P (unqualified_name))\n-\t\t    declarator->u.id.sfk = sfk_conversion;\n-\t\t  else if (/* There's no way to declare a constructor\n-\t\t\t      for an anonymous type, even if the type\n-\t\t\t      got a name for linkage purposes.  */\n-\t\t\t   !TYPE_WAS_ANONYMOUS (class_type)\n-\t\t\t   && (constructor_name_p (unqualified_name,\n-\t\t\t\t\t\t   class_type)\n-\t\t\t       || (TREE_CODE (unqualified_name) == TYPE_DECL\n-\t\t\t\t   && (same_type_p\n-\t\t\t\t       (TREE_TYPE (unqualified_name),\n-\t\t\t\t\tclass_type)))))\n-\t\t    declarator->u.id.sfk = sfk_constructor;\n-\n-\t\t  if (ctor_dtor_or_conv_p && declarator->u.id.sfk != sfk_none)\n-\t\t    *ctor_dtor_or_conv_p = -1;\n-\t\t  if (qualifying_scope\n-\t\t      && TREE_CODE (unqualified_name) == TYPE_DECL\n+\t\t  if (qualifying_scope \n \t\t      && CLASSTYPE_USE_TEMPLATE (TREE_TYPE (unqualified_name)))\n \t\t    {\n \t\t      error (\"invalid use of constructor as a template\");\n@@ -11454,9 +11441,50 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t      class_type,\n \t\t\t      DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n \t\t\t      class_type, class_type);\n+\t\t      declarator = cp_error_declarator;\n+\t\t      break;\n+\t\t    }\n+\t\t  else if (class_type\n+\t\t\t   && same_type_p (TREE_TYPE (unqualified_name),\n+\t\t\t\t\t   class_type))\n+\t\t    unqualified_name = constructor_name (class_type);\n+\t\t  else\n+\t\t    {\n+\t\t      /* We do not attempt to print the declarator\n+\t\t\t here because we do not have enough\n+\t\t\t information about its original syntactic\n+\t\t\t form.  */\n+\t\t      error (\"invalid declarator\");\n+\t\t      declarator = cp_error_declarator;\n+\t\t      break;\n \t\t    }\n \t\t}\n+\n+\t      if (class_type)\n+\t\t{\n+\t\t  if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR)\n+\t\t    sfk = sfk_destructor;\n+\t\t  else if (IDENTIFIER_TYPENAME_P (unqualified_name))\n+\t\t    sfk = sfk_conversion;\n+\t\t  else if (/* There's no way to declare a constructor\n+\t\t\t      for an anonymous type, even if the type\n+\t\t\t      got a name for linkage purposes.  */\n+\t\t\t   !TYPE_WAS_ANONYMOUS (class_type)\n+\t\t\t   && constructor_name_p (unqualified_name,\n+\t\t\t\t\t\t  class_type))\n+\t\t    {\n+\t\t      unqualified_name = constructor_name (class_type);\n+\t\t      sfk = sfk_constructor;\n+\t\t    }\n+\n+\t\t  if (ctor_dtor_or_conv_p && sfk != sfk_none)\n+\t\t    *ctor_dtor_or_conv_p = -1;\n+\t\t}\n \t    }\n+\t  declarator = make_id_declarator (qualifying_scope, \n+\t\t\t\t\t   unqualified_name,\n+\t\t\t\t\t   sfk);\n+\t  declarator->id_loc = token->location;\n \n \thandle_declarator:;\n \t  scope = get_scope_of_declarator (declarator);\n@@ -11666,6 +11694,7 @@ cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n static tree\n cp_parser_declarator_id (cp_parser* parser)\n {\n+  tree id;\n   /* The expression must be an id-expression.  Assume that qualified\n      names are the names of types so that:\n \n@@ -11680,11 +11709,14 @@ cp_parser_declarator_id (cp_parser* parser)\n        int S<T>::R<T>::i = 3;\n \n      will work, too.  */\n-  return cp_parser_id_expression (parser,\n-\t\t\t\t  /*template_keyword_p=*/false,\n-\t\t\t\t  /*check_dependency_p=*/false,\n-\t\t\t\t  /*template_p=*/NULL,\n-\t\t\t\t  /*declarator_p=*/true);\n+  id = cp_parser_id_expression (parser,\n+\t\t\t\t/*template_keyword_p=*/false,\n+\t\t\t\t/*check_dependency_p=*/false,\n+\t\t\t\t/*template_p=*/NULL,\n+\t\t\t\t/*declarator_p=*/true);\n+  if (BASELINK_P (id))\n+    id = BASELINK_FUNCTIONS (id);\n+  return id;\n }\n \n /* Parse a type-id.\n@@ -13464,7 +13496,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      /* Create the bitfield declaration.  */\n \t      decl = grokbitfield (identifier\n \t\t\t\t   ? make_id_declarator (NULL_TREE,\n-\t\t\t\t\t\t\t identifier)\n+\t\t\t\t\t\t\t identifier,\n+\t\t\t\t\t\t\t sfk_none)\n \t\t\t\t   : NULL,\n \t\t\t\t   &decl_specifiers,\n \t\t\t\t   width);\n@@ -17095,7 +17128,8 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t    {\n \t      /* Get the name of the bitfield.  */\n \t      declarator = make_id_declarator (NULL_TREE,\n-\t\t\t\t\t       cp_parser_identifier (parser));\n+\t\t\t\t\t       cp_parser_identifier (parser),\n+\t\t\t\t\t       sfk_none);\n \n \t     eat_colon:\n \t      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */"}, {"sha": "c222bdcaecd82bac67690b043e5578f2a9c54315", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "patch": "@@ -169,6 +169,12 @@ cxx_print_xnode (FILE *file, tree node, int indent)\n {\n   switch (TREE_CODE (node))\n     {\n+    case BASELINK:\n+      print_node (file, \"functions\", BASELINK_FUNCTIONS (node), indent + 4);\n+      print_node (file, \"binfo\", BASELINK_BINFO (node), indent + 4);\n+      print_node (file, \"access_binfo\", BASELINK_ACCESS_BINFO (node), \n+\t\t  indent + 4);\n+      break;\n     case OVERLOAD:\n       print_node (file, \"function\", OVL_FUNCTION (node), indent+4);\n       print_node (file, \"chain\", TREE_CHAIN (node), indent+4);"}, {"sha": "91cb4e2803ce73ded57389061a71a6297c40ff61", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "patch": "@@ -1,3 +1,9 @@\n+2005-12-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25439\n+\t* g++.dg/parse/crash17.C: Adjust error markers.\n+\t* g++.dg/template/error20.C: New test.\n+\n 2005-12-26  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/23172"}, {"sha": "e50f07af4a85da6857290e97c604a9fbd9c35ce4", "filename": "gcc/testsuite/g++.dg/parse/crash17.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash17.C?ref=d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "patch": "@@ -5,5 +5,5 @@ template <typename> class allocator;\n template<typename T> class vector { \n   // With the dg-error on the next line, we are really just trying to\n   // check that the message is not an ICE message.\n-  typedef typename allocator<T> allocator_type; // { dg-error \"expected|forbids\" }\n+  typedef typename allocator<T> allocator_type; // { dg-error \"expected|invalid\" }\n }; "}, {"sha": "f81378fdb618af654d621837ea16eb1d0464b70e", "filename": "gcc/testsuite/g++.dg/template/error20.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85d3d578a5c2abcf2b071ef42a558a4ed18b55c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror20.C?ref=d85d3d578a5c2abcf2b071ef42a558a4ed18b55c", "patch": "@@ -0,0 +1,4 @@\n+// PR c++/25439\n+\n+template<int> struct A;\n+template<> int A<0>; // { dg-error \"invalid\" }"}]}