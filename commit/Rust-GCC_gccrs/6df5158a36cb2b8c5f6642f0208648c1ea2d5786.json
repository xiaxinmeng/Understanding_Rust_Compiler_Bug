{"sha": "6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmNTE1OGEzNmNiMmI4YzVmNjY0MmYwMjA4NjQ4YzFlYTJkNTc4Ng==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-06-24T15:40:06Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-06-24T15:40:06Z"}, "message": "call.c (enforce_access): Assert we get a binfo.\n\n\t* call.c (enforce_access): Assert we get a binfo.\n\t(build_op_delete_call): Pass a binfo to\n\tperform_or_defer_access_check.\n\t* class.c (alter_access): Likewise.\n\t* decl.c (make_typename_type): Likewise.\n\t(make_unbound_class_template): Likewise.\n\t* lex.c (do_identifier): Likewise.\n\t* method.c (hack_identifier): Likewise.\n\t* parser.c (cp_parser_lookup_name): Likewise.\n\t* search.c (lookup_member): Likewise. Move IDENTIFIER_CLASS_VALUE\n\ttest.\n\t* semantics.c (finish_non_static_data_member): Likewise.\n\t(perform_or_defer_access_check): Expect a binfo.\n\t* typeck.c (comptypes): Expect types.\n\n\t* mangle.c (find_substitution): Don't pass a non-type to same_type_p\n\t* friend.c (make_friend_class): Likewise.\n\t* pt.c (check_default_tmpl_args): Likewise.\n\t(lookup_template_class): Likewise.\n\nFrom-SVN: r68424", "tree": {"sha": "d50a764e01dcd1dc880e14a21c3e985f121b8667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d50a764e01dcd1dc880e14a21c3e985f121b8667"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/comments", "author": null, "committer": null, "parents": [{"sha": "401f376dfd4f9c976cb452cc71bc4199cf9c8087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/401f376dfd4f9c976cb452cc71bc4199cf9c8087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/401f376dfd4f9c976cb452cc71bc4199cf9c8087"}], "stats": {"total": 177, "additions": 108, "deletions": 69}, "files": [{"sha": "65ca03d9e563e9bca9d06b37eb15db04a1202636", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -1,3 +1,25 @@\n+2003-06-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* call.c (enforce_access): Assert we get a binfo.\n+\t(build_op_delete_call): Pass a binfo to\n+\tperform_or_defer_access_check.\n+\t* class.c (alter_access): Likewise.\n+\t* decl.c (make_typename_type): Likewise.\n+\t(make_unbound_class_template): Likewise.\n+\t* lex.c (do_identifier): Likewise.\n+\t* method.c (hack_identifier): Likewise.\n+\t* parser.c (cp_parser_lookup_name): Likewise.\n+\t* search.c (lookup_member): Likewise. Move IDENTIFIER_CLASS_VALUE\n+\ttest.\n+\t* semantics.c (finish_non_static_data_member): Likewise.\n+\t(perform_or_defer_access_check): Expect a binfo.\n+\t* typeck.c (comptypes): Expect types.\n+\n+\t* mangle.c (find_substitution): Don't pass a non-type to same_type_p\n+\t* friend.c (make_friend_class): Likewise.\n+\t* pt.c (check_default_tmpl_args): Likewise.\n+\t(lookup_template_class): Likewise.\n+\n Tue Jun 24 15:30:05 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* method.c (thunk_labelno): Move outside ifdef block to make garbage\n@@ -41,7 +63,7 @@ Mon Jun 23 19:41:27 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-06-23  Jakub Jelinek  <jakub@redhat.com>\n \n-\t* mangle.c (hash_type): val is the TREE_LIST itself, not a pointer\n+\t* mangle.c (hash_type): Val is the TREE_LIST itself, not a pointer\n \tto it.\n \n 2003-06-21  Gabriel Dos Reis <gdr@integrable-solutions.net>"}, {"sha": "77ed3e8686ff31ff90d43b698c9633087a681512", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -4071,7 +4071,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n       /* If the FN is a member function, make sure that it is\n \t accessible.  */\n       if (DECL_CLASS_SCOPE_P (fn))\n-\tperform_or_defer_access_check (type, fn);\n+\tperform_or_defer_access_check (TYPE_BINFO (type), fn);\n \n       if (pass == 0)\n \targs = tree_cons (NULL_TREE, addr, args);\n@@ -4098,6 +4098,8 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n bool\n enforce_access (tree basetype_path, tree decl)\n {\n+  my_friendly_assert (TREE_CODE (basetype_path) == TREE_VEC, 20030624);\n+  \n   if (!accessible_p (basetype_path, decl))\n     {\n       if (TREE_PRIVATE (decl))"}, {"sha": "b5eb245f4f298dc1d580c332eede371f11dffe12", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -1064,8 +1064,7 @@ alter_access (tree t, tree fdecl, tree access)\n   if (!DECL_LANG_SPECIFIC (fdecl))\n     retrofit_lang_decl (fdecl);\n \n-  if (DECL_DISCRIMINATOR_P (fdecl))\n-    abort ();\n+  my_friendly_assert (!DECL_DISCRIMINATOR_P (fdecl), 20030624);\n \n   elem = purpose_member (t, DECL_ACCESS (fdecl));\n   if (elem)\n@@ -1087,7 +1086,7 @@ alter_access (tree t, tree fdecl, tree access)\n     }\n   else\n     {\n-      perform_or_defer_access_check (t, fdecl);\n+      perform_or_defer_access_check (TYPE_BINFO (t), fdecl);\n       DECL_ACCESS (fdecl) = tree_cons (t, access, DECL_ACCESS (fdecl));\n       return 1;\n     }"}, {"sha": "b9c59af6cc72b4f8c58bb53ddf9c6d5fe135d091", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -5525,7 +5525,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t    }\n \n \t  if (complain & tf_error)\n-\t    perform_or_defer_access_check (context, tmpl);\n+\t    perform_or_defer_access_check (TYPE_BINFO (context), tmpl);\n \n \t  return lookup_template_class (tmpl,\n \t\t\t\t\tTREE_OPERAND (fullname, 1),\n@@ -5555,7 +5555,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t\t}\n \n \t      if (complain & tf_error)\n-\t\tperform_or_defer_access_check (context, t);\n+\t\tperform_or_defer_access_check (TYPE_BINFO (context), t);\n \n \t      if (DECL_ARTIFICIAL (t) || !(complain & tf_keep_type_decl))\n \t\tt = TREE_TYPE (t);\n@@ -5612,7 +5612,7 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n \t}\n       \n       if (complain & tf_error)\n-\tperform_or_defer_access_check (context, tmpl);\n+\tperform_or_defer_access_check (TYPE_BINFO (context), tmpl);\n \n       return tmpl;\n     }"}, {"sha": "0a0e82c7fcdbd522c7f18337b2c080e69c1ad541", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -264,17 +264,34 @@ make_friend_class (type, friend_type)\n   if (is_template_friend)\n     friend_type = CLASSTYPE_TI_TEMPLATE (friend_type);\n \n-  classes = CLASSTYPE_FRIEND_CLASSES (type);\n-  while (classes \n-\t /* Stop if we find the same type on the list.  */\n-\t && !(TREE_CODE (TREE_VALUE (classes)) == TEMPLATE_DECL ?\n-\t      friend_type == TREE_VALUE (classes) :\n-\t      same_type_p (TREE_VALUE (classes), friend_type)))\n-    classes = TREE_CHAIN (classes);\n-  if (classes) \n-    warning (\"`%T' is already a friend of `%T'\",\n-\t\tTREE_VALUE (classes), type);\n-  else\n+  /* See if it is already a friend.  */\n+  for (classes = CLASSTYPE_FRIEND_CLASSES (type);\n+       classes;\n+       classes = TREE_CHAIN (classes))\n+    {\n+      tree probe = TREE_VALUE (classes);\n+\n+      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n+\t{\n+\t  if (friend_type == probe)\n+\t    {\n+\t      warning (\"`%D' is already a friend of `%T'\",\n+\t\t       probe, type);\n+\t      break;\n+\t    }\n+\t}\n+      else if (TREE_CODE (probe) != TEMPLATE_DECL)\n+\t{\n+\t  if (same_type_p (probe, friend_type))\n+\t    {\n+\t      warning (\"`%T' is already a friend of `%T'\",\n+\t\t       probe, type);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  \n+  if (!classes) \n     {\n       maybe_add_class_template_decl_list (type, friend_type, /*friend_p=*/1);\n "}, {"sha": "b378dc1724a64418be5e53ce4a1e06a2646e0550", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -777,7 +777,7 @@ do_identifier (register tree token, tree args)\n     {\n       /* Check access.  */\n       if (IDENTIFIER_CLASS_VALUE (token) == id)\n-\tperform_or_defer_access_check (CP_DECL_CONTEXT(id), id);\n+\tperform_or_defer_access_check (TYPE_BINFO (DECL_CONTEXT (id)), id);\n       if (!processing_template_decl || DECL_TEMPLATE_PARM_P (id))\n \tid = DECL_INITIAL (id);\n     }"}, {"sha": "b5d0a645af492f749451c1c47db2ff02f055e001", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -546,6 +546,7 @@ find_substitution (tree node)\n \t args <char, std::char_traits<char> > .  */\n       tree args = CLASSTYPE_TI_ARGS (type);\n       if (TREE_VEC_LENGTH (args) == 2\n+\t  && TYPE_P (TREE_VEC_ELT (args, 0))\n \t  && same_type_p (TREE_VEC_ELT (args, 0), char_type_node)\n \t  && is_std_substitution_char (TREE_VEC_ELT (args, 1),\n \t\t\t\t       SUBID_CHAR_TRAITS))"}, {"sha": "cb2c864bfca89428c9ea50a8e24a3115f98cd3d7", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -182,7 +182,7 @@ hack_identifier (tree value, tree name)\n \t{\n \t  tree path;\n \t  path = currently_open_derived_class (DECL_CONTEXT (value));\n-\t  perform_or_defer_access_check (path, value);\n+\t  perform_or_defer_access_check (TYPE_BINFO (path), value);\n \t}\n     }\n   else if (TREE_CODE (value) == TREE_LIST "}, {"sha": "6240c244607a5c1805b796046e95acf2c677f7eb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -13353,7 +13353,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t\t\t\t\t       object_type,\n \t\t\t\t\t\t       parser->scope);\n       if (qualifying_type)\n-\tperform_or_defer_access_check (qualifying_type, decl);\n+\tperform_or_defer_access_check (TYPE_BINFO (qualifying_type), decl);\n     }\n \n   return decl;"}, {"sha": "e29d434c00097d8c5d999b3dee945b91a67945ce", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -2528,14 +2528,15 @@ check_default_tmpl_args (tree decl, tree parms, int is_primary, int is_partial)\n       && DECL_LANG_SPECIFIC (decl)\n       /* If this is either a friend defined in the scope of the class\n \t or a member function.  */\n-      && ((DECL_CONTEXT (decl) \n-\t   && same_type_p (DECL_CONTEXT (decl), current_class_type))\n-\t  || (DECL_FRIEND_CONTEXT (decl)\n-\t      && same_type_p (DECL_FRIEND_CONTEXT (decl), \n-\t\t\t      current_class_type)))\n+      && (DECL_FUNCTION_MEMBER_P (decl)\n+\t  ? same_type_p (DECL_CONTEXT (decl), current_class_type)\n+\t  : DECL_FRIEND_CONTEXT (decl)\n+\t  ? same_type_p (DECL_FRIEND_CONTEXT (decl), current_class_type)\n+\t  : false)\n       /* And, if it was a member function, it really was defined in\n \t the scope of the class.  */\n-      && (!DECL_FUNCTION_MEMBER_P (decl) || DECL_INITIALIZED_IN_CLASS_P (decl)))\n+      && (!DECL_FUNCTION_MEMBER_P (decl)\n+\t  || DECL_INITIALIZED_IN_CLASS_P (decl)))\n     /* We already checked these parameters when the template was\n        declared, so there's no need to do it again now.  This function\n        was defined in class scope, but we're processing it's body now\n@@ -4234,21 +4235,20 @@ lookup_template_class (tree d1,\n \t    {\n \t      tree ctx;\n \t      \n-\t      /* Note that we use DECL_CONTEXT, rather than\n-\t\t CP_DECL_CONTEXT, so that the termination test is\n-\t\t always just `ctx'.  We're not interested in namespace\n-\t\t scopes.  */\n \t      for (ctx = current_class_type; \n \t\t   ctx; \n-\t\t   ctx = (TYPE_P (ctx)) ? TYPE_CONTEXT (ctx) : DECL_CONTEXT (ctx))\n-\t\tif (same_type_p (ctx, template_type))\n-\t\t  break;\n+\t\t   ctx = TYPE_CONTEXT (ctx))\n+\t\t{\n+\t\t  if (TREE_CODE (ctx) == NAMESPACE_DECL)\n+\t\t    break;\n+\t\t  if (same_type_p (ctx, template_type))\n+\t\t    goto found_ctx;\n+\t\t}\n \t      \n-\t      if (!ctx)\n-\t\t/* We're not in the scope of the class, so the\n-\t\t   TEMPLATE_TYPE is not the type we want after\n-\t\t   all.  */\n-\t\tfound = NULL_TREE;\n+\t      /* We're not in the scope of the class, so the\n+\t\t TEMPLATE_TYPE is not the type we want after all.  */\n+\t      found = NULL_TREE;\n+\t    found_ctx:;\n \t    }\n \t}\n       if (found)"}, {"sha": "a853c208bdf586e5a2998e28ca6e30fc32344e8d", "filename": "gcc/cp/search.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -1226,35 +1226,31 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n \n   const char *errstr = 0;\n \n-  /* Sanity check.  */\n-  if (TREE_CODE (name) != IDENTIFIER_NODE)\n-    abort ();\n-\n-  if (xbasetype == current_class_type && TYPE_BEING_DEFINED (xbasetype)\n-      && IDENTIFIER_CLASS_VALUE (name))\n-    {\n-      tree field = IDENTIFIER_CLASS_VALUE (name);\n-      if (! is_overloaded_fn (field)\n-\t  && ! (want_type && TREE_CODE (field) != TYPE_DECL))\n-\t/* We're in the scope of this class, and the value has already\n-\t   been looked up.  Just return the cached value.  */\n-\treturn field;\n-    }\n+  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 20030624);\n \n   if (TREE_CODE (xbasetype) == TREE_VEC)\n     {\n       type = BINFO_TYPE (xbasetype);\n       basetype_path = xbasetype;\n     }\n-  else if (IS_AGGR_TYPE_CODE (TREE_CODE (xbasetype)))\n+  else\n     {\n+      my_friendly_assert (IS_AGGR_TYPE_CODE (TREE_CODE (xbasetype)), 20030624);\n       type = xbasetype;\n       basetype_path = TYPE_BINFO (type);\n-      my_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path) == NULL_TREE,\n-\t\t\t  980827);\n+      my_friendly_assert (!BINFO_INHERITANCE_CHAIN (basetype_path), 980827);\n+    }\n+\n+  if (type == current_class_type && TYPE_BEING_DEFINED (type)\n+      && IDENTIFIER_CLASS_VALUE (name))\n+    {\n+      tree field = IDENTIFIER_CLASS_VALUE (name);\n+      if (! is_overloaded_fn (field)\n+\t  && ! (want_type && TREE_CODE (field) != TYPE_DECL))\n+\t/* We're in the scope of this class, and the value has already\n+\t   been looked up.  Just return the cached value.  */\n+\treturn field;\n     }\n-  else\n-    abort ();\n \n   complete_type (type);\n \n@@ -1291,7 +1287,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n      In the case of overloaded function names, access control is\n      applied to the function selected by overloaded resolution.  */\n   if (rval && protect && !is_overloaded_fn (rval))\n-    perform_or_defer_access_check (xbasetype, rval);\n+    perform_or_defer_access_check (basetype_path, rval);\n \n   if (errstr && protect)\n     {"}, {"sha": "3272284d9c7a5f098f1da05d3e1f035ac46822e5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -262,16 +262,18 @@ void perform_deferred_access_checks (void)\n }\n \n /* Defer checking the accessibility of DECL, when looked up in\n-   CLASS_TYPE.  */\n+   BINFO.  */\n \n-void perform_or_defer_access_check (tree class_type, tree decl)\n+void perform_or_defer_access_check (tree binfo, tree decl)\n {\n   tree check;\n \n+  my_friendly_assert (TREE_CODE (binfo) == TREE_VEC, 20030623);\n+  \n   /* If we are not supposed to defer access checks, just check now.  */\n   if (deferred_access_stack->deferring_access_checks_kind == dk_no_deferred)\n     {\n-      enforce_access (class_type, decl);\n+      enforce_access (binfo, decl);\n       return;\n     }\n   /* Exit if we are in a context that no access checking is performed.  */\n@@ -282,13 +284,11 @@ void perform_or_defer_access_check (tree class_type, tree decl)\n   for (check = deferred_access_stack->deferred_access_checks;\n        check;\n        check = TREE_CHAIN (check))\n-    if (TREE_VALUE (check) == decl\n-\t&& TYPE_P (TREE_PURPOSE (check))\n-\t&& same_type_p (TREE_PURPOSE (check), class_type))\n+    if (TREE_VALUE (check) == decl && TREE_PURPOSE (check) == binfo)\n       return;\n   /* If not, record the check.  */\n   deferred_access_stack->deferred_access_checks\n-    = tree_cons (class_type, decl,\n+    = tree_cons (binfo, decl,\n \t\t deferred_access_stack->deferred_access_checks);\n }\n \n@@ -1255,7 +1255,7 @@ finish_non_static_data_member (tree decl, tree qualifying_scope)\n \t  return error_mark_node;\n \t}\n \n-      perform_or_defer_access_check (access_type, decl);\n+      perform_or_defer_access_check (TYPE_BINFO (access_type), decl);\n \n       /* If the data member was named `C::M', convert `*this' to `C'\n \t first.  */"}, {"sha": "be53d45154593c2923c00e6cbad5614c84ceeb79", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df5158a36cb2b8c5f6642f0208648c1ea2d5786/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "patch": "@@ -883,7 +883,9 @@ comptypes (tree t1, tree t2, int strict)\n   /* Suppress errors caused by previously reported errors */\n   if (t2 == error_mark_node)\n     return false;\n-\n+  \n+  my_friendly_assert (TYPE_P (t1) && TYPE_P (t2), 20030623);\n+  \n   /* TYPENAME_TYPEs should be resolved if the qualifying scope is the\n      current instantiation.  */\n   if (TREE_CODE (t1) == TYPENAME_TYPE)"}]}