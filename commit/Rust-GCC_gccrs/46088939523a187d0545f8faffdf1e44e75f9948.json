{"sha": "46088939523a187d0545f8faffdf1e44e75f9948", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYwODg5Mzk1MjNhMTg3ZDA1NDVmOGZhZmZkZjFlNDRlNzVmOTk0OA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-30T19:21:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-30T19:21:27Z"}, "message": "re PR rtl-optimization/58369 (ICE in subreg_get_info when compiling boost for m68k-linux)\n\n\tPR rtl-optimization/58369\n\t* reload1.c (compute_reload_subreg_offset): New function.\n\t(choose_reload_regs): Use it to pass endian-correct\n\toffset to subreg_regno_offset.\n\n\t* PR rtl-optimization/58369\n\t* g++.dg/torture/pr58369.C: New test.\n\nFrom-SVN: r204224", "tree": {"sha": "9730e61d0cbc4fe7f623500a10ded2df4bce0b1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9730e61d0cbc4fe7f623500a10ded2df4bce0b1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46088939523a187d0545f8faffdf1e44e75f9948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46088939523a187d0545f8faffdf1e44e75f9948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46088939523a187d0545f8faffdf1e44e75f9948", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46088939523a187d0545f8faffdf1e44e75f9948/comments", "author": null, "committer": null, "parents": [{"sha": "c5028d807fd315cfeb2f1d44e5ffb1c6ca470aff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5028d807fd315cfeb2f1d44e5ffb1c6ca470aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5028d807fd315cfeb2f1d44e5ffb1c6ca470aff"}], "stats": {"total": 161, "additions": 160, "deletions": 1}, "files": [{"sha": "e3d2abda205e59a7ccb3f0f3a9ceb84ed2073870", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46088939523a187d0545f8faffdf1e44e75f9948/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46088939523a187d0545f8faffdf1e44e75f9948/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46088939523a187d0545f8faffdf1e44e75f9948", "patch": "@@ -1,3 +1,10 @@\n+2013-10-18  Mikael Pettersson  <mikpelinux@gmail.com>\n+\n+\tPR rtl-optimization/58369\n+\t* reload1.c (compute_reload_subreg_offset): New function.\n+\t(choose_reload_regs): Use it to pass endian-correct\n+\toffset to subreg_regno_offset.\n+\n 2013-10-30  Tobias Burnus  <burnus@net-b.de>\n \n \tPR other/33426"}, {"sha": "b62b047b070e1d9c73697824876512e4e39208e3", "filename": "gcc/reload1.c", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46088939523a187d0545f8faffdf1e44e75f9948/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46088939523a187d0545f8faffdf1e44e75f9948/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=46088939523a187d0545f8faffdf1e44e75f9948", "patch": "@@ -6371,6 +6371,37 @@ replaced_subreg (rtx x)\n }\n #endif\n \n+/* Compute the offset to pass to subreg_regno_offset, for a pseudo of\n+   mode OUTERMODE that is available in a hard reg of mode INNERMODE.\n+   SUBREG is non-NULL if the pseudo is a subreg whose reg is a pseudo,\n+   otherwise it is NULL.  */\n+\n+static int\n+compute_reload_subreg_offset (enum machine_mode outermode,\n+\t\t\t      rtx subreg,\n+\t\t\t      enum machine_mode innermode)\n+{\n+  int outer_offset;\n+  enum machine_mode middlemode;\n+\n+  if (!subreg)\n+    return subreg_lowpart_offset (outermode, innermode);\n+\n+  outer_offset = SUBREG_BYTE (subreg);\n+  middlemode = GET_MODE (SUBREG_REG (subreg));\n+\n+  /* If SUBREG is paradoxical then return the normal lowpart offset\n+     for OUTERMODE and INNERMODE.  Our caller has already checked\n+     that OUTERMODE fits in INNERMODE.  */\n+  if (outer_offset == 0\n+      && GET_MODE_SIZE (outermode) > GET_MODE_SIZE (middlemode))\n+    return subreg_lowpart_offset (outermode, innermode);\n+\n+  /* SUBREG is normal, but may not be lowpart; return OUTER_OFFSET\n+     plus the normal lowpart offset for MIDDLEMODE and INNERMODE.  */\n+  return outer_offset + subreg_lowpart_offset (middlemode, innermode);\n+}\n+\n /* Assign hard reg targets for the pseudo-registers we must reload\n    into hard regs for this insn.\n    Also output the instructions to copy them in and out of the hard regs.\n@@ -6508,6 +6539,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t      int byte = 0;\n \t      int regno = -1;\n \t      enum machine_mode mode = VOIDmode;\n+\t      rtx subreg = NULL_RTX;\n \n \t      if (rld[r].in == 0)\n \t\t;\n@@ -6528,7 +6560,10 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t  if (regno < FIRST_PSEUDO_REGISTER)\n \t\t    regno = subreg_regno (rld[r].in_reg);\n \t\t  else\n-\t\t    byte = SUBREG_BYTE (rld[r].in_reg);\n+\t\t    {\n+\t\t      subreg = rld[r].in_reg;\n+\t\t      byte = SUBREG_BYTE (subreg);\n+\t\t    }\n \t\t  mode = GET_MODE (rld[r].in_reg);\n \t\t}\n #ifdef AUTO_INC_DEC\n@@ -6566,6 +6601,9 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t  rtx last_reg = reg_last_reload_reg[regno];\n \n \t\t  i = REGNO (last_reg);\n+\t\t  byte = compute_reload_subreg_offset (mode,\n+\t\t\t\t\t\t       subreg,\n+\t\t\t\t\t\t       GET_MODE (last_reg));\n \t\t  i += subreg_regno_offset (i, GET_MODE (last_reg), byte, mode);\n \t\t  last_class = REGNO_REG_CLASS (i);\n "}, {"sha": "748ab127cba6fcfe885b4d1da1f70806d669c9bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46088939523a187d0545f8faffdf1e44e75f9948/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46088939523a187d0545f8faffdf1e44e75f9948/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46088939523a187d0545f8faffdf1e44e75f9948", "patch": "@@ -1,3 +1,8 @@\n+2013-10-30  Mikael Pettersson  <mikpe@it.uu.se>\n+\n+\t* PR rtl-optimization/58369\n+\t* g++.dg/torture/pr58369.C: New test.\n+\n 2013-10-30  Tobias Burnus  <burnus@net-b.de>\n \n \tPR other/33426"}, {"sha": "9284e2ca7684a04d183e72ab2570d9aac477e406", "filename": "gcc/testsuite/g++.dg/torture/pr58369.C", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46088939523a187d0545f8faffdf1e44e75f9948/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58369.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46088939523a187d0545f8faffdf1e44e75f9948/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58369.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58369.C?ref=46088939523a187d0545f8faffdf1e44e75f9948", "patch": "@@ -0,0 +1,109 @@\n+// { dg-do compile }\n+// Reduced from boost-1.54\n+\n+int pow(int, int);\n+int sqrt(int);\n+\n+class PolicyA { };\n+\n+template <class>\n+int max_value() { return 0x7fffffff; }\n+\n+template <class>\n+int min_value() { return 1; }\n+\n+void raise_denorm_error();\n+\n+template <class T>\n+void raise_domain_error(int, int, const T &, const PolicyA &);\n+\n+template <class>\n+int check_overflow(long double p1) {\n+  long double __trans_tmp_2 = __builtin_fabsl(p1);\n+  if (__trans_tmp_2 > max_value<int>())\n+    return 1;\n+  return 0;\n+}\n+\n+template <class>\n+int check_underflow(long double p1) {\n+  if (p1 && (double)p1)\n+    return 1;\n+  return 0;\n+}\n+\n+template <class>\n+int check_denorm(long double p1) {\n+  long double __trans_tmp_3 = __builtin_fabsl(p1);\n+  if (__trans_tmp_3 < min_value<int>() && (double)p1) {\n+    raise_denorm_error();\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+template <class, class>\n+double checked_narrowing_cast(long double p1) {\n+  if (check_overflow<int>(p1))\n+    return 0;\n+  if (check_underflow<int>(p1))\n+    return 0;\n+  if (check_denorm<int>(p1))\n+    return 0;\n+  return (double)p1;\n+}\n+\n+long double ellint_rf_imp(long double, long double, long double);\n+\n+template <typename T, typename Policy>\n+T ellint_rj_imp(T p1, T p2, T p3, T p4, Policy &p5) {\n+  T value, tolerance, P, S3;\n+  if (p4)\n+    return 0;\n+  if (p3 || p1)\n+    raise_domain_error(0, 0, 0, p5);\n+  tolerance = pow(0, 0);\n+  if (p4) {\n+    T q = -p4;\n+    {\n+      long double q6 = ellint_rj_imp((long double)p1, (long double)(double)p2, (long double)(double)p3, (long double)(int)0, p5);\n+      value = checked_narrowing_cast<T, int>(q6);\n+    }\n+    {\n+      long double q7 = ellint_rf_imp((long double)p1, (long double)(double)p2, (long double)(double)p3);\n+      value -= checked_narrowing_cast<T, const int>(q7);\n+    }\n+    value += p1 * p3 + p4 * q;\n+    return value;\n+  }\n+  do {\n+    P = p4 / p1;\n+    if (0 < tolerance)\n+      break;\n+    sqrt(p3);\n+  } while (1);\n+  S3 = P * p2 * 0;\n+  value = S3 / p1;\n+  return value;\n+}\n+\n+template <typename Policy>\n+void ellint_pi_imp4(double, double p3, Policy &p4) {\n+  double x, y, z;\n+  ellint_rj_imp(x, y, z, p3, p4);\n+}\n+\n+template <typename Policy>\n+double ellint_pi_imp5(double, double p3, double p4, Policy &p5) {\n+  double x, y, z, p;\n+  if (p3 > 0)\n+    return 0;\n+  ellint_rj_imp(x, y, z, p, p5);\n+  ellint_pi_imp4((double)0, p4, p5);\n+}\n+\n+void boost_ellint_3f() {\n+  PolicyA p4;\n+  ellint_pi_imp5((double)0, (double)0, (double)0, p4);\n+}\n+"}]}