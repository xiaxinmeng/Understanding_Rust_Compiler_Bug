{"sha": "616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE2ZjE0MzFiZjNhZDkxMzU2NDYwMTY0ZmNkN2Q0ZDhhNmYzYmQzZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-05-19T17:53:58Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-05-19T17:53:58Z"}, "message": "langhooks.h (struct lang_hooks): Add new field deep_unsharing.\n\n\t* langhooks.h (struct lang_hooks): Add new field deep_unsharing.\n\t* langhooks-def.h (LANG_HOOKS_DEEP_UNSHARING): New macro.\n\t(LANG_HOOKS_INITIALIZER): Add LANG_HOOKS_DEEP_UNSHARING.\n\t* gimplify.c: (mostly_copy_tree_r): Copy trees under SAVE_EXPR and\n\tTARGET_EXPR nodes, but only once, if instructed to do so.  Do not\n\tpropagate the 'data' argument to copy_tree_r.\n\t(copy_if_shared_r): Remove bogus ATTRIBUTE_UNUSED marker.\n\tPropagate 'data' argument to walk_tree.\n\t(copy_if_shared): New function.\n\t(unmark_visited_r): Remove bogus ATTRIBUTE_UNUSED marker.\n\t(unmark_visited): New function.\n\t(unshare_body): Call copy_if_shared instead of doing it manually.\n\t(unvisit_body): Call unmark_visited instead of doing it manually.\nada/\n\t* gcc-interface/misc.c (LANG_HOOKS_DEEP_UNSHARING): Redefine.\n\t* gcc-interface/trans.c (unshare_save_expr): Delete.\n\t(gigi): Do not unshare trees under SAVE_EXPRs here.\n\nFrom-SVN: r159592", "tree": {"sha": "e941e9d3872b8da1472eb83529eb4f4677ae6331", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e941e9d3872b8da1472eb83529eb4f4677ae6331"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/comments", "author": null, "committer": null, "parents": [{"sha": "daf8c6f03b7b7ae33e2e8e301d367eb8cce80e5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daf8c6f03b7b7ae33e2e8e301d367eb8cce80e5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daf8c6f03b7b7ae33e2e8e301d367eb8cce80e5c"}], "stats": {"total": 290, "additions": 230, "deletions": 60}, "files": [{"sha": "aaaa6cbef0634105b5b78a5ecfc71274943e4a8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -1,3 +1,19 @@\n+2010-05-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* langhooks.h (struct lang_hooks): Add new field deep_unsharing.\n+\t* langhooks-def.h (LANG_HOOKS_DEEP_UNSHARING): New macro.\n+\t(LANG_HOOKS_INITIALIZER): Add LANG_HOOKS_DEEP_UNSHARING.\n+\t* gimplify.c: (mostly_copy_tree_r): Copy trees under SAVE_EXPR and\n+\tTARGET_EXPR nodes, but only once, if instructed to do so.  Do not\n+\tpropagate the 'data' argument to copy_tree_r.\n+\t(copy_if_shared_r): Remove bogus ATTRIBUTE_UNUSED marker.\n+\tPropagate 'data' argument to walk_tree.\n+\t(copy_if_shared): New function.\n+\t(unmark_visited_r): Remove bogus ATTRIBUTE_UNUSED marker.\n+\t(unmark_visited): New function.\n+\t(unshare_body): Call copy_if_shared instead of doing it manually.\n+\t(unvisit_body): Call unmark_visited instead of doing it manually.\n+\n 2010-05-19  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* hooks.h (hook_tree_tree_tree_bool_null): Rename to..."}, {"sha": "d5aa53a0a57b0278c79b3792e782c22736d432c9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -1,3 +1,9 @@\n+2010-05-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/misc.c (LANG_HOOKS_DEEP_UNSHARING): Redefine.\n+\t* gcc-interface/trans.c (unshare_save_expr): Delete.\n+\t(gigi): Do not unshare trees under SAVE_EXPRs here.\n+\n 2010-05-18  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* gcc-interface/trans.c (call_to_gnu): Use build_call_vec instead of"}, {"sha": "dba6dca887c044dfa27d9b7e246ca7d3c30cda5d", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -132,6 +132,8 @@ static tree gnat_eh_personality\t\t(void);\n #define LANG_HOOKS_BUILTIN_FUNCTION\tgnat_builtin_function\n #undef  LANG_HOOKS_EH_PERSONALITY\n #define LANG_HOOKS_EH_PERSONALITY\tgnat_eh_personality\n+#undef  LANG_HOOKS_DEEP_UNSHARING\n+#define LANG_HOOKS_DEEP_UNSHARING\ttrue\n \n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n "}, {"sha": "b02502044f3dec63d323cf72cec18e9d43e457a1", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -191,7 +191,6 @@ static void Compilation_Unit_to_gnu (Node_Id);\n static void record_code_position (Node_Id);\n static void insert_code_for (Node_Id);\n static void add_cleanup (tree, Node_Id);\n-static tree unshare_save_expr (tree *, int *, void *);\n static void add_stmt_list (List_Id);\n static void push_exception_label_stack (tree *, Entity_Id);\n static tree build_stmt_group (List_Id, bool);\n@@ -636,16 +635,6 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n     {\n       tree gnu_body = DECL_SAVED_TREE (info->elab_proc), gnu_stmts;\n \n-      /* Unshare SAVE_EXPRs between subprograms.  These are not unshared by\n-\t the gimplifier for obvious reasons, but it turns out that we need to\n-\t unshare them for the global level because of SAVE_EXPRs made around\n-\t checks for global objects and around allocators for global objects\n-\t of variable size, in order to prevent node sharing in the underlying\n-\t expression.  Note that this implicitly assumes that the SAVE_EXPR\n-\t nodes themselves are not shared between subprograms, which would be\n-\t an upstream bug for which we would not change the outcome.  */\n-      walk_tree_without_duplicates (&gnu_body, unshare_save_expr, NULL);\n-\n       /* We should have a BIND_EXPR but it may not have any statements in it.\n \t If it doesn't have any, we have nothing to do except for setting the\n \t flag on the GNAT node.  Otherwise, process the function as others.  */\n@@ -5865,20 +5854,6 @@ mark_visited (tree t)\n   walk_tree (&t, mark_visited_r, NULL, NULL);\n }\n \n-/* Utility function to unshare expressions wrapped up in a SAVE_EXPR.  */\n-\n-static tree\n-unshare_save_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t   void *data ATTRIBUTE_UNUSED)\n-{\n-  tree t = *tp;\n-\n-  if (TREE_CODE (t) == SAVE_EXPR)\n-    TREE_OPERAND (t, 0) = unshare_expr (TREE_OPERAND (t, 0));\n-\n-  return NULL_TREE;\n-}\n-\n /* Add GNU_CLEANUP, a cleanup action, to the current code group and\n    set its location to that of GNAT_NODE if present.  */\n "}, {"sha": "8f19cedb053ae1fc477b566520f326383e51f85d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 113, "deletions": 35, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -820,48 +820,95 @@ annotate_all_with_location (gimple_seq stmt_p, location_t location)\n       annotate_one_with_location (gs, location);\n     }\n }\n-\n-\n-/* Similar to copy_tree_r() but do not copy SAVE_EXPR or TARGET_EXPR nodes.\n+\f\n+/* This page contains routines to unshare tree nodes, i.e. to duplicate tree\n+   nodes that are referenced more than once in GENERIC functions.  This is\n+   necessary because gimplification (translation into GIMPLE) is performed\n+   by modifying tree nodes in-place, so gimplication of a shared node in a\n+   first context could generate an invalid GIMPLE form in a second context.\n+\n+   This is achieved with a simple mark/copy/unmark algorithm that walks the\n+   GENERIC representation top-down, marks nodes with TREE_VISITED the first\n+   time it encounters them, duplicates them if they already have TREE_VISITED\n+   set, and finally removes the TREE_VISITED marks it has set.\n+\n+   The algorithm works only at the function level, i.e. it generates a GENERIC\n+   representation of a function with no nodes shared within the function when\n+   passed a GENERIC function (except for nodes that are allowed to be shared).\n+\n+   At the global level, it is also necessary to unshare tree nodes that are\n+   referenced in more than one function, for the same aforementioned reason.\n+   This requires some cooperation from the front-end.  There are 2 strategies:\n+\n+     1. Manual unsharing.  The front-end needs to call unshare_expr on every\n+        expression that might end up being shared across functions.\n+\n+     2. Deep unsharing.  This is an extension of regular unsharing.  Instead\n+        of calling unshare_expr on expressions that might be shared across\n+        functions, the front-end pre-marks them with TREE_VISITED.  This will\n+        ensure that they are unshared on the first reference within functions\n+        when the regular unsharing algorithm runs.  The counterpart is that\n+        this algorithm must look deeper than for manual unsharing, which is\n+        specified by LANG_HOOKS_DEEP_UNSHARING.\n+\n+  If there are only few specific cases of node sharing across functions, it is\n+  probably easier for a front-end to unshare the expressions manually.  On the\n+  contrary, if the expressions generated at the global level are as widespread\n+  as expressions generated within functions, deep unsharing is very likely the\n+  way to go.  */\n+\n+/* Similar to copy_tree_r but do not copy SAVE_EXPR or TARGET_EXPR nodes.\n    These nodes model computations that should only be done once.  If we\n    were to unshare something like SAVE_EXPR(i++), the gimplification\n    process would create wrong code.  */\n \n static tree\n mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)\n {\n-  enum tree_code code = TREE_CODE (*tp);\n-  /* Don't unshare types, decls, constants and SAVE_EXPR nodes.  */\n-  if (TREE_CODE_CLASS (code) == tcc_type\n-      || TREE_CODE_CLASS (code) == tcc_declaration\n-      || TREE_CODE_CLASS (code) == tcc_constant\n-      || code == SAVE_EXPR || code == TARGET_EXPR\n-      /* We can't do anything sensible with a BLOCK used as an expression,\n-\t but we also can't just die when we see it because of non-expression\n-\t uses.  So just avert our eyes and cross our fingers.  Silly Java.  */\n-      || code == BLOCK)\n+  tree t = *tp;\n+  enum tree_code code = TREE_CODE (t);\n+\n+  /* Do not copy SAVE_EXPR or TARGET_EXPR nodes themselves, but copy\n+     their subtrees if we can make sure to do it only once.  */\n+  if (code == SAVE_EXPR || code == TARGET_EXPR)\n+    {\n+      if (data && !pointer_set_insert ((struct pointer_set_t *)data, t))\n+\t;\n+      else\n+\t*walk_subtrees = 0;\n+    }\n+\n+  /* Stop at types, decls, constants like copy_tree_r.  */\n+  else if (TREE_CODE_CLASS (code) == tcc_type\n+\t   || TREE_CODE_CLASS (code) == tcc_declaration\n+\t   || TREE_CODE_CLASS (code) == tcc_constant\n+\t   /* We can't do anything sensible with a BLOCK used as an\n+\t      expression, but we also can't just die when we see it\n+\t      because of non-expression uses.  So we avert our eyes\n+\t      and cross our fingers.  Silly Java.  */\n+\t   || code == BLOCK)\n     *walk_subtrees = 0;\n+\n+  /* Cope with the statement expression extension.  */\n+  else if (code == STATEMENT_LIST)\n+    ;\n+\n+  /* Leave the bulk of the work to copy_tree_r itself.  */\n   else\n     {\n       gcc_assert (code != BIND_EXPR);\n-      copy_tree_r (tp, walk_subtrees, data);\n+      copy_tree_r (tp, walk_subtrees, NULL);\n     }\n \n   return NULL_TREE;\n }\n \n /* Callback for walk_tree to unshare most of the shared trees rooted at\n    *TP.  If *TP has been visited already (i.e., TREE_VISITED (*TP) == 1),\n-   then *TP is deep copied by calling copy_tree_r.\n-\n-   This unshares the same trees as copy_tree_r with the exception of\n-   SAVE_EXPR nodes.  These nodes model computations that should only be\n-   done once.  If we were to unshare something like SAVE_EXPR(i++), the\n-   gimplification process would create wrong code.  */\n+   then *TP is deep copied by calling mostly_copy_tree_r.  */\n \n static tree\n-copy_if_shared_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t  void *data ATTRIBUTE_UNUSED)\n+copy_if_shared_r (tree *tp, int *walk_subtrees, void *data)\n {\n   tree t = *tp;\n   enum tree_code code = TREE_CODE (t);\n@@ -884,27 +931,29 @@ copy_if_shared_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n      any deeper.  */\n   else if (TREE_VISITED (t))\n     {\n-      walk_tree (tp, mostly_copy_tree_r, NULL, NULL);\n+      walk_tree (tp, mostly_copy_tree_r, data, NULL);\n       *walk_subtrees = 0;\n     }\n \n-  /* Otherwise, mark the tree as visited and keep looking.  */\n+  /* Otherwise, mark the node as visited and keep looking.  */\n   else\n     TREE_VISITED (t) = 1;\n \n   return NULL_TREE;\n }\n \n-static tree\n-unmark_visited_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t  void *data ATTRIBUTE_UNUSED)\n-{\n-  if (TREE_VISITED (*tp))\n-    TREE_VISITED (*tp) = 0;\n-  else\n-    *walk_subtrees = 0;\n+/* Unshare most of the shared trees rooted at *TP. */\n \n-  return NULL_TREE;\n+static inline void\n+copy_if_shared (tree *tp)\n+{\n+  /* If the language requires deep unsharing, we need a pointer set to make\n+     sure we don't repeatedly unshare subtrees of unshareable nodes.  */\n+  struct pointer_set_t *visited\n+    = lang_hooks.deep_unsharing ? pointer_set_create () : NULL;\n+  walk_tree (tp, copy_if_shared_r, visited, NULL);\n+  if (visited)\n+    pointer_set_destroy (visited);\n }\n \n /* Unshare all the trees in BODY_P, a pointer into the body of FNDECL, and the\n@@ -916,20 +965,49 @@ unshare_body (tree *body_p, tree fndecl)\n {\n   struct cgraph_node *cgn = cgraph_node (fndecl);\n \n-  walk_tree (body_p, copy_if_shared_r, NULL, NULL);\n+  copy_if_shared (body_p);\n+\n   if (body_p == &DECL_SAVED_TREE (fndecl))\n     for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n       unshare_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);\n }\n \n+/* Callback for walk_tree to unmark the visited trees rooted at *TP.\n+   Subtrees are walked until the first unvisited node is encountered.  */\n+\n+static tree\n+unmark_visited_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n+{\n+  tree t = *tp;\n+\n+  /* If this node has been visited, unmark it and keep looking.  */\n+  if (TREE_VISITED (t))\n+    TREE_VISITED (t) = 0;\n+\n+  /* Otherwise, don't look any deeper.  */\n+  else\n+    *walk_subtrees = 0;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Unmark the visited trees rooted at *TP.  */\n+\n+static inline void\n+unmark_visited (tree *tp)\n+{\n+  walk_tree (tp, unmark_visited_r, NULL, NULL);\n+}\n+\n /* Likewise, but mark all trees as not visited.  */\n \n static void\n unvisit_body (tree *body_p, tree fndecl)\n {\n   struct cgraph_node *cgn = cgraph_node (fndecl);\n \n-  walk_tree (body_p, unmark_visited_r, NULL, NULL);\n+  unmark_visited (body_p);\n+\n   if (body_p == &DECL_SAVED_TREE (fndecl))\n     for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n       unvisit_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);"}, {"sha": "68b5b72bfc670a36f537a29e6171b6fa2ae4a075", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -111,6 +111,7 @@ extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n #define LANG_HOOKS_EH_PERSONALITY\tlhd_gcc_personality\n #define LANG_HOOKS_EH_RUNTIME_TYPE\tlhd_pass_through_t\n #define LANG_HOOKS_EH_USE_CXA_END_CLEANUP\tfalse\n+#define LANG_HOOKS_DEEP_UNSHARING\tfalse\n \n /* Attribute hooks.  */\n #define LANG_HOOKS_ATTRIBUTE_TABLE\t\tNULL\n@@ -297,6 +298,7 @@ extern void lhd_end_section (void);\n   LANG_HOOKS_EH_PERSONALITY, \\\n   LANG_HOOKS_EH_RUNTIME_TYPE, \\\n   LANG_HOOKS_EH_USE_CXA_END_CLEANUP, \\\n+  LANG_HOOKS_DEEP_UNSHARING \\\n }\n \n #endif /* GCC_LANG_HOOKS_DEF_H */"}, {"sha": "c0744e878987216939b354cd339dd8383f363050", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -446,6 +446,10 @@ struct lang_hooks\n      is enabled.  */\n   bool eh_use_cxa_end_cleanup;\n \n+  /* True if this language requires deep unsharing of tree nodes prior to\n+     gimplification.  */\n+  bool deep_unsharing;\n+\n   /* Whenever you add entries here, make sure you adjust langhooks-def.h\n      and langhooks.c accordingly.  */\n };"}, {"sha": "dc5afe30b2edab1de82413d01a3c2aeaa6e0ab17", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -1,3 +1,11 @@\n+2010-05-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/discr23.ad[sb]: New test.\n+\t* gnat.dg/discr23_pkg.ads: New helper.\n+\n+\t* gnat.dg/specs/controlled1.ads: New test.\n+\t* gnat.dg/specs/controlled1_pkg.ads: New helper.\n+\n 2010-05-19  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/44055"}, {"sha": "1d1e695e9d905b8161889fb58716f20a392cdaa9", "filename": "gcc/testsuite/gnat.dg/discr23.adb", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr23.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr23.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr23.adb?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -0,0 +1,18 @@\n+--  { dg-do compile }\n+\n+with Discr23_Pkg; use Discr23_Pkg;\n+\n+package body Discr23 is\n+\n+  N : constant Text := Get;\n+\n+  function Try (A : in Text) return Text is\n+  begin\n+    return A;\n+  exception\n+    when others => return N;\n+  end;\n+\n+  procedure Dummy is begin null; end;\n+\n+end Discr23;"}, {"sha": "8e673b382a9b22bdcfa70e484809b30e2d9d3a4a", "filename": "gcc/testsuite/gnat.dg/discr23.ads", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr23.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr23.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr23.ads?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -0,0 +1,7 @@\n+-- { dg-do compile }\n+\n+package Discr23 is\n+\n+  procedure Dummy;\n+\n+end Discr23;"}, {"sha": "339734be868b7fa4c24ee8b797f636c86e832e19", "filename": "gcc/testsuite/gnat.dg/discr23_pkg.ads", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr23_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr23_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr23_pkg.ads?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -0,0 +1,12 @@\n+package Discr23_Pkg is\n+\n+  subtype Size_Range is Positive range 1 .. 256;\n+\n+  type Text (Size : Size_Range) is\n+    record\n+      Characters : String( 1.. Size);\n+    end record;\n+\n+  function Get return Text;\n+\n+end Discr23_Pkg;"}, {"sha": "1ceedaf37799f95e1668cbbdfa47f576996c483a", "filename": "gcc/testsuite/gnat.dg/specs/controlled1.ads", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fcontrolled1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fcontrolled1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fcontrolled1.ads?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -0,0 +1,35 @@\n+--  { dg-do compile }\n+\n+with Ada.Finalization;\n+with Controlled1_Pkg; use Controlled1_Pkg;\n+\n+package Controlled1 is\n+\n+   type Collection is new Ada.Finalization.Controlled with null record;\n+\n+   type Object_Kind_Type is (One, Two);\n+\n+   type Byte_Array is array (Natural range <>) of Integer;\n+\n+   type Bounded_Byte_Array_Type is record\n+     A : Byte_Array (1 .. Value);\n+   end record;\n+\n+   type Object_Type is tagged record\n+     A : Bounded_Byte_Array_Type;\n+   end record;\n+\n+   type R_Object_Type is new Object_Type with record\n+      L : Collection;\n+   end record;\n+\n+   type Obj_Type (Kind : Object_Kind_Type := One) is record\n+      case Kind is\n+         when One => R : R_Object_Type;\n+         when others => null;\n+      end case;\n+   end record;\n+\n+   type Obj_Array_Type is array (Positive range <>) of Obj_Type;\n+\n+end Controlled1;"}, {"sha": "3d08c1ee9bf8fc6b094d3bb09a5494aa2325a3d3", "filename": "gcc/testsuite/gnat.dg/specs/controlled1_pkg.ads", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fcontrolled1_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/616f1431bf3ad91356460164fcd7d4d8a6f3bd3f/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fcontrolled1_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fcontrolled1_pkg.ads?ref=616f1431bf3ad91356460164fcd7d4d8a6f3bd3f", "patch": "@@ -0,0 +1,7 @@\n+-- { dg-excess-errors \"no code generated\" }\n+\n+package Controlled1_Pkg is\n+\n+  function Value return Natural;\n+\n+end Controlled1_Pkg;"}]}