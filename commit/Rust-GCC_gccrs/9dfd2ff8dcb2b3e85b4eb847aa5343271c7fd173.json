{"sha": "9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRmZDJmZjhkY2IyYjNlODViNGViODQ3YWE1MzQzMjcxYzdmZDE3Mw==", "commit": {"author": {"name": "Cyrille Comar", "email": "comar@adacore.com", "date": "2005-09-05T08:00:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T08:00:11Z"}, "message": "sem_ch3.ads, [...] (Analyze_Object_Declaration): Go to the underlying type to check if a type is Constrained in cases related to...\n\n2005-09-01  Cyrille Comar  <comar@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.ads, sem_ch3.adb (Analyze_Object_Declaration): Go to the\n\tunderlying type\n\tto check if a type is Constrained in cases related to code generation\n\t(rather than semantic checking) since otherwise we do not generate\n\tsimilar code for mutable private types depending if their\n\tdiscriminants are visible or not.\n\t(Check_Abstract_Overriding): Do not complain about failure to override\n\tthe primitive operations used in dispatching selects since they will\n\talways be overriden at the freeze point of the type.\n\t(Access_Definition): Separate out handling for resetting the scope\n\tof an anonymous access function result type. Retrieve the scope\n\tof the associated function rather than using Current_Scope, which\n\tdoes not have a consistent value (depends on whether we're in the\n\tmiddle of analyzing formal parameters). Add ??? comment about\n\tfinding a cleaner way to handle the special cases of scope setting.\n\t(Process_Incomplete_Dependents): A protected operation is never a\n\tdispatching operation (only its wrapper may be).\n\t(Build_Derived_Record_Type): In case of tagged private types that\n\timplement interfaces add derivation of predefined primitive\n\toperations.\n\t(Derive_Subprograms): Replace the Is_Interface_Derivation parameter\n\tby two parameters that are used in case of derivation from abstract\n\tinterface types: No_Predefined_Prims is used to avoid the derivation\n\tof predefined primitives from the interface, and Predefined\n\tPrims_Only is used to complete the derivation predefined primitives\n\tin case of private tagged types implementing interfaces.\n\tFix typo in comments\n\t(Find_Interface_In_Descendant): Protect the frontend against\n\twrong code with large circularity chains.\n\t(Is_Private_Overriding): Add support for entities overriding interface\n\tsubprograms. The test failed because Entities associated with overriden\n\tinterface subprograms are always marked as hidden (and used to build\n\tthe secondary dispatch table); in this case the overriden entity is\n\tavailable through the field abstract_interface_alias (cf. override_\n\tdispatching_operation)\n\t(Access_Definition): Set the scope of the type to Current_Scope for the\n\tcase of a function with an anonymous access result type.\n\t(Access_Subprogram_Declaration): Handle creation of the type entity for\n\tan access-to-function type with an anonymous access result.\n\t(Check_Anonymous_Access_Types): Change Subtype_Mark to Result_Definition\n\tin handling for N_Access_Function_Definition.\n\t(Analyze_Subtype_Declaration): Modify the text of error message.\n\t(Derived_Type_Declaration): Modify the text of error message.\n\t(Process_Subtype): Modify the text of error message plus cleanup\n\tof one redundant error message.\n\t(Analyze_Component_Declaration): Code cleanup.\n\t(Analyze_Object_Declaration): Code cleanup.\n\t(Analyze_Subtype_Declaration): Propagate the null-exclusion\n\tattribute in case of access types. Code cleanup.\n\t(Array_Type_Declaration): Code cleanup.\n\t(Process_Discriminants): Create the new null-excluding itype\n\tif required. Code cleanup.\n\t(Process_Subtype): Create the new null-excluding itype if\n\trequired. Code cleanup.\n\t(Build_Derived_Record_Type): Code cleanup to avoid calling\n\ttwice the subprogram derive_subprograms in case of private\n\ttypes that implement interfaces. In this particular case the\n\tsubprogram Complete_Subprograms_Derivation already does the\n\tjob associated with the second call.\n\n        * exp_strm.adb (Build_Elementary_Input_Call): Add an explicit\n        conversion to the full view when generating an operation for a\n        discriminant whose type may currently be private.\n\nFrom-SVN: r103881", "tree": {"sha": "7c78c56e9b191891fadab9eabdb8ced0b705ca95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c78c56e9b191891fadab9eabdb8ced0b705ca95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173/comments", "author": {"login": "CyrilleComar", "id": 18616717, "node_id": "MDQ6VXNlcjE4NjE2NzE3", "avatar_url": "https://avatars.githubusercontent.com/u/18616717?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CyrilleComar", "html_url": "https://github.com/CyrilleComar", "followers_url": "https://api.github.com/users/CyrilleComar/followers", "following_url": "https://api.github.com/users/CyrilleComar/following{/other_user}", "gists_url": "https://api.github.com/users/CyrilleComar/gists{/gist_id}", "starred_url": "https://api.github.com/users/CyrilleComar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CyrilleComar/subscriptions", "organizations_url": "https://api.github.com/users/CyrilleComar/orgs", "repos_url": "https://api.github.com/users/CyrilleComar/repos", "events_url": "https://api.github.com/users/CyrilleComar/events{/privacy}", "received_events_url": "https://api.github.com/users/CyrilleComar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27e6455d37aad17fccb935a6643ad976b61068f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e6455d37aad17fccb935a6643ad976b61068f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27e6455d37aad17fccb935a6643ad976b61068f3"}], "stats": {"total": 879, "additions": 541, "deletions": 338}, "files": [{"sha": "f6e5d5c61ad9962748abdbe70b3b513b5cbbae5e", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173", "patch": "@@ -26,7 +26,6 @@\n \n with Atree;    use Atree;\n with Einfo;    use Einfo;\n-with Exp_Tss;  use Exp_Tss;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -594,19 +593,25 @@ package body Exp_Strm is\n       --  to the actual type of the prefix. If the target is a discriminant,\n       --  and we are in the body of the default implementation of a 'Read\n       --  attribute, set target type to force a constraint check (13.13.2(35)).\n+      --  If the type of the discriminant is currently private, add another\n+      --  unchecked conversion from the full view.\n \n       if Nkind (Targ) = N_Identifier\n         and then Is_Internal_Name (Chars (Targ))\n         and then Is_TSS (Scope (Entity (Targ)), TSS_Stream_Read)\n       then\n          Res :=\n-           Unchecked_Convert_To (Base_Type (P_Type),\n+           Unchecked_Convert_To (Base_Type (U_Type),\n              Make_Function_Call (Loc,\n                Name => New_Occurrence_Of (RTE (Lib_RE), Loc),\n                Parameter_Associations => New_List (\n                  Relocate_Node (Strm))));\n \n          Set_Do_Range_Check (Res);\n+         if Base_Type (P_Type) /= Base_Type (U_Type) then\n+            Res := Unchecked_Convert_To (Base_Type (P_Type), Res);\n+         end if;\n+\n          return Res;\n \n       else\n@@ -1327,7 +1332,7 @@ package body Exp_Strm is\n          return\n            Make_Attribute_Reference (Loc,\n              Prefix =>\n-               New_Occurrence_Of (Stream_Base_Type (Etype (C)), Loc),\n+               New_Occurrence_Of (Field_Typ, Loc),\n              Attribute_Name => Nam,\n              Expressions => New_List (\n                Make_Identifier (Loc, Name_S),\n@@ -1490,7 +1495,7 @@ package body Exp_Strm is\n                   Subtype_Mark => New_Reference_To (\n                     Class_Wide_Type (RTE (RE_Root_Stream_Type)), Loc)))),\n \n-          Subtype_Mark => New_Occurrence_Of (Typ, Loc));\n+          Result_Definition => New_Occurrence_Of (Typ, Loc));\n \n       Decl :=\n         Make_Subprogram_Body (Loc,"}, {"sha": "adefc6a4b599b77e518bd602ed0be7e3b3cfd772", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 514, "deletions": 324, "changes": 838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173", "patch": "@@ -88,21 +88,22 @@ package body Sem_Ch3 is\n       Derived_Type  : Entity_Id;\n       Is_Completion : Boolean;\n       Derive_Subps  : Boolean := True);\n-   --  Create and decorate a Derived_Type given the Parent_Type entity.\n-   --  N is the N_Full_Type_Declaration node containing the derived type\n-   --  definition. Parent_Type is the entity for the parent type in the derived\n-   --  type definition and Derived_Type the actual derived type. Is_Completion\n-   --  must be set to False if Derived_Type is the N_Defining_Identifier node\n-   --  in N (ie Derived_Type = Defining_Identifier (N)). In this case N is not\n-   --  the completion of a private type declaration. If Is_Completion is\n-   --  set to True, N is the completion of a private type declaration and\n-   --  Derived_Type is different from the defining identifier inside N (i.e.\n-   --  Derived_Type /= Defining_Identifier (N)). Derive_Subps indicates whether\n-   --  the parent subprograms should be derived. The only case where this\n-   --  parameter is False is when Build_Derived_Type is recursively called to\n-   --  process an implicit derived full type for a type derived from a private\n-   --  type (in that case the subprograms must only be derived for the private\n-   --  view of the type).\n+   --  Create and decorate a Derived_Type given the Parent_Type entity. N is\n+   --  the N_Full_Type_Declaration node containing the derived type definition.\n+   --  Parent_Type is the entity for the parent type in the derived type\n+   --  definition and Derived_Type the actual derived type. Is_Completion must\n+   --  be set to False if Derived_Type is the N_Defining_Identifier node in N\n+   --  (ie Derived_Type = Defining_Identifier (N)). In this case N is not the\n+   --  completion of a private type declaration. If Is_Completion is set to\n+   --  True, N is the completion of a private type declaration and Derived_Type\n+   --  is different from the defining identifier inside N (i.e. Derived_Type /=\n+   --  Defining_Identifier (N)). Derive_Subps indicates whether the parent\n+   --  subprograms should be derived. The only case where this parameter is\n+   --  False is when Build_Derived_Type is recursively called to process an\n+   --  implicit derived full type for a type derived from a private type (in\n+   --  that case the subprograms must only be derived for the private view of\n+   --  the type).\n+\n    --  ??? These flags need a bit of re-examination and re-documentation:\n    --  ???  are they both necessary (both seem related to the recursion)?\n \n@@ -160,7 +161,7 @@ package body Sem_Ch3 is\n       Parent_Type  : Entity_Id;\n       Derived_Type : Entity_Id;\n       Derive_Subps : Boolean := True);\n-   --  Subsidiary procedure to Build_Derived_Type and\n+   --  Subsidiary procedure for Build_Derived_Type and\n    --  Analyze_Private_Extension_Declaration used for tagged and untagged\n    --  record types. All parameters are as in Build_Derived_Type except that\n    --  N, in addition to being an N_Full_Type_Declaration node, can also be an\n@@ -199,9 +200,9 @@ package body Sem_Ch3 is\n    --  For more information on derived types and component inheritance please\n    --  consult the comment above the body of Build_Derived_Record_Type.\n    --\n-   --    N is the original derived type declaration.\n+   --    N is the original derived type declaration\n    --\n-   --    Is_Tagged is set if we are dealing with tagged types.\n+   --    Is_Tagged is set if we are dealing with tagged types\n    --\n    --    If Inherit_Discr is set, Derived_Base inherits its discriminants\n    --    from Parent_Base, otherwise no discriminants are inherited.\n@@ -243,14 +244,14 @@ package body Sem_Ch3 is\n       Derived_Def : Boolean := False) return Elist_Id;\n    --  Validate discriminant constraints, and return the list of the\n    --  constraints in order of discriminant declarations. T is the\n-   --  discriminated unconstrained type. Def is the N_Subtype_Indication\n-   --  node where the discriminants constraints for T are specified.\n-   --  Derived_Def is True if we are building the discriminant constraints\n-   --  in a derived type definition of the form \"type D (...) is new T (xxx)\".\n-   --  In this case T is the parent type and Def is the constraint \"(xxx)\" on\n-   --  T and this routine sets the Corresponding_Discriminant field of the\n-   --  discriminants in the derived type D to point to the corresponding\n-   --  discriminants in the parent type T.\n+   --  discriminated unconstrained type. Def is the N_Subtype_Indication node\n+   --  where the discriminants constraints for T are specified. Derived_Def is\n+   --  True if we are building the discriminant constraints in a derived type\n+   --  definition of the form \"type D (...) is new T (xxx)\". In this case T is\n+   --  the parent type and Def is the constraint \"(xxx)\" on T and this routine\n+   --  sets the Corresponding_Discriminant field of the discriminants in the\n+   --  derived type D to point to the corresponding discriminants in the parent\n+   --  type T.\n \n    procedure Build_Discriminated_Subtype\n      (T           : Entity_Id;\n@@ -391,9 +392,9 @@ package body Sem_Ch3 is\n      (Def_Id      : in out Entity_Id;\n       S           : Node_Id;\n       Related_Nod : Node_Id);\n-   --  Apply a list of constraints to an access type. If Def_Id is empty,\n-   --  it is an anonymous type created for a subtype indication. In that\n-   --  case it is created in the procedure and attached to Related_Nod.\n+   --  Apply a list of constraints to an access type. If Def_Id is empty, it is\n+   --  an anonymous type created for a subtype indication. In that case it is\n+   --  created in the procedure and attached to Related_Nod.\n \n    procedure Constrain_Array\n      (Def_Id      : in out Entity_Id;\n@@ -460,9 +461,8 @@ package body Sem_Ch3 is\n    --  of For_Access.\n \n    procedure Constrain_Enumeration (Def_Id : Node_Id; S : Node_Id);\n-   --  Constrain an enumeration type with a range constraint. This is\n-   --  identical to Constrain_Integer, but for the Ekind of the\n-   --  resulting subtype.\n+   --  Constrain an enumeration type with a range constraint. This is identical\n+   --  to Constrain_Integer, but for the Ekind of the resulting subtype.\n \n    procedure Constrain_Float (Def_Id : Node_Id; S : Node_Id);\n    --  Constrain a floating point type with either a digits constraint\n@@ -504,9 +504,9 @@ package body Sem_Ch3 is\n       Full        : Entity_Id;\n       Full_Base   : Entity_Id;\n       Related_Nod : Node_Id);\n-   --  Complete the implicit full view of a private subtype by setting\n-   --  the appropriate semantic fields. If the full view of the parent is\n-   --  a record type, build constrained components of subtype.\n+   --  Complete the implicit full view of a private subtype by setting the\n+   --  appropriate semantic fields. If the full view of the parent is a record\n+   --  type, build constrained components of subtype.\n \n    procedure Derive_Interface_Subprograms\n      (Derived_Type : Entity_Id);\n@@ -529,24 +529,22 @@ package body Sem_Ch3 is\n    --  Build_Derived_Type to process the actual derived type definition.\n    --  Parameters N and Is_Completion have the same meaning as in\n    --  Build_Derived_Type. T is the N_Defining_Identifier for the entity\n-   --  defined in the N_Full_Type_Declaration node N, that is T is the\n-   --  derived type.\n+   --  defined in the N_Full_Type_Declaration node N, that is T is the derived\n+   --  type.\n \n    procedure Enumeration_Type_Declaration (T : Entity_Id; Def : Node_Id);\n-   --  Insert each literal in symbol table, as an overloadable identifier\n-   --  Each enumeration type is mapped into a sequence of integers, and\n-   --  each literal is defined as a constant with integer value. If any\n-   --  of the literals are character literals, the type is a character\n-   --  type, which means that strings are legal aggregates for arrays of\n-   --  components of the type.\n+   --  Insert each literal in symbol table, as an overloadable identifier. Each\n+   --  enumeration type is mapped into a sequence of integers, and each literal\n+   --  is defined as a constant with integer value. If any of the literals are\n+   --  character literals, the type is a character type, which means that\n+   --  strings are legal aggregates for arrays of components of the type.\n \n    function Expand_To_Stored_Constraint\n      (Typ        : Entity_Id;\n       Constraint : Elist_Id) return Elist_Id;\n-   --  Given a Constraint (ie a list of expressions) on the discriminants of\n-   --  Typ, expand it into a constraint on the stored discriminants and\n-   --  return the new list of expressions constraining the stored\n-   --  discriminants.\n+   --  Given a Constraint (i.e. a list of expressions) on the discriminants of\n+   --  Typ, expand it into a constraint on the stored discriminants and return\n+   --  the new list of expressions constraining the stored discriminants.\n \n    function Find_Type_Of_Object\n      (Obj_Def     : Node_Id;\n@@ -566,9 +564,8 @@ package body Sem_Ch3 is\n    function Is_Valid_Constraint_Kind\n      (T_Kind          : Type_Kind;\n       Constraint_Kind : Node_Kind) return Boolean;\n-   --  Returns True if it is legal to apply the given kind of constraint\n-   --  to the given kind of type (index constraint to an array type,\n-   --  for example).\n+   --  Returns True if it is legal to apply the given kind of constraint to the\n+   --  given kind of type (index constraint to an array type, for example).\n \n    procedure Modular_Type_Declaration (T : Entity_Id; Def : Node_Id);\n    --  Create new modular type. Verify that modulus is in  bounds and is\n@@ -581,8 +578,8 @@ package body Sem_Ch3 is\n    procedure Ordinary_Fixed_Point_Type_Declaration\n      (T   : Entity_Id;\n       Def : Node_Id);\n-   --  Create a new ordinary fixed point type, and apply the constraint\n-   --  to obtain subtype of it.\n+   --  Create a new ordinary fixed point type, and apply the constraint to\n+   --  obtain subtype of it.\n \n    procedure Prepare_Private_Subtype_Completion\n      (Id          : Entity_Id;\n@@ -631,10 +628,10 @@ package body Sem_Ch3 is\n       Prev : Entity_Id);\n    --  Process a record type declaration (for both untagged and tagged\n    --  records). Parameters T and N are exactly like in procedure\n-   --  Derived_Type_Declaration, except that no flag Is_Completion is\n-   --  needed for this routine. If this is the completion of an incomplete\n-   --  type declaration, Prev is the entity of the incomplete declaration,\n-   --  used for cross-referencing. Otherwise Prev = T.\n+   --  Derived_Type_Declaration, except that no flag Is_Completion is needed\n+   --  for this routine. If this is the completion of an incomplete type\n+   --  declaration, Prev is the entity of the incomplete declaration, used for\n+   --  cross-referencing. Otherwise Prev = T.\n \n    procedure Record_Type_Definition (Def : Node_Id; Prev_T : Entity_Id);\n    --  This routine is used to process the actual record type definition\n@@ -702,13 +699,28 @@ package body Sem_Ch3 is\n          Error_Msg_N (\"task entries cannot have access parameters\", N);\n       end if;\n \n-      --  Ada 2005: for an object declaration, the corresponding anonymous\n-      --  type is declared in the current scope. For access formals, access\n-      --  components, and access discriminants, the scope is that of the\n-      --  enclosing declaration, as set above.\n+      --  Ada 2005: for an object declaration or function with an anonymous\n+      --  access result, the corresponding anonymous type is declared in the\n+      --  current scope. For access formals, access components, and access\n+      --  discriminants, the scope is that of the enclosing declaration,\n+      --  as set above. This special-case handling of resetting the scope\n+      --  is awkward, and it might be better to pass in the required scope\n+      --  as a parameter. ???\n \n       if Nkind (Related_Nod) = N_Object_Declaration then\n          Set_Scope (Anon_Type, Current_Scope);\n+\n+      --  For the anonymous function result case, retrieve the scope of\n+      --  the function specification's associated entity rather than using\n+      --  the current scope. The current scope will be the function itself\n+      --  if the formal part is currently being analyzed, but will be the\n+      --  parent scope in the case of a parameterless function, and we\n+      --  always want to use the function's parent scope.\n+\n+      elsif Nkind (Related_Nod) = N_Function_Specification\n+         and then Nkind (Parent (N)) /= N_Parameter_Specification\n+      then\n+         Set_Scope (Anon_Type, Scope (Defining_Unit_Name (Related_Nod)));\n       end if;\n \n       if All_Present (N)\n@@ -800,10 +812,10 @@ package body Sem_Ch3 is\n    is\n       Formals : constant List_Id := Parameter_Specifications (T_Def);\n       Formal  : Entity_Id;\n+      D_Ityp  : Node_Id;\n \n       Desig_Type : constant Entity_Id :=\n                      Create_Itype (E_Subprogram_Type, Parent (T_Def));\n-      D_Ityp     : Node_Id := Associated_Node_For_Itype (Desig_Type);\n \n    begin\n       --  Associate the Itype node with the inner full-type declaration\n@@ -815,6 +827,7 @@ package body Sem_Ch3 is\n       --                     (Y : access procedure\n       --                                   (Z : access T)))\n \n+      D_Ityp := Associated_Node_For_Itype (Desig_Type);\n       while Nkind (D_Ityp) /= N_Full_Type_Declaration\n          and then Nkind (D_Ityp) /= N_Procedure_Specification\n          and then Nkind (D_Ityp) /= N_Function_Specification\n@@ -842,12 +855,19 @@ package body Sem_Ch3 is\n       end if;\n \n       if Nkind (T_Def) = N_Access_Function_Definition then\n-         Analyze (Subtype_Mark (T_Def));\n-         Set_Etype (Desig_Type, Entity (Subtype_Mark (T_Def)));\n+         if Nkind (Result_Definition (T_Def)) = N_Access_Definition then\n+            Set_Etype\n+              (Desig_Type,\n+               Access_Definition (T_Def, Result_Definition (T_Def)));\n+         else\n+            Analyze (Result_Definition (T_Def));\n+            Set_Etype (Desig_Type, Entity (Result_Definition (T_Def)));\n+         end if;\n \n          if not (Is_Type (Etype (Desig_Type))) then\n             Error_Msg_N\n-             (\"expect type in function specification\", Subtype_Mark (T_Def));\n+              (\"expect type in function specification\",\n+               Result_Definition (T_Def));\n          end if;\n \n       else\n@@ -875,7 +895,6 @@ package body Sem_Ch3 is\n \n       if Present (Formals) then\n          Formal := First_Formal (Desig_Type);\n-\n          while Present (Formal) loop\n             if Ekind (Formal) /= E_In_Parameter\n               and then Nkind (T_Def) = N_Access_Function_Definition\n@@ -956,6 +975,16 @@ package body Sem_Ch3 is\n \n       if Base_Type (Designated_Type (T)) = T then\n          Error_Msg_N (\"access type cannot designate itself\", S);\n+\n+      --  In Ada 2005, the type may have a limited view through some unit\n+      --  in its own context, allowing the following circularity that cannot\n+      --  be detected earlier\n+\n+      elsif Is_Class_Wide_Type (Designated_Type (T))\n+        and then Etype (Designated_Type (T)) = T\n+      then\n+         Error_Msg_N\n+           (\"access type cannot designate its own classwide type\", S);\n       end if;\n \n       Set_Etype (T, T);\n@@ -1084,7 +1113,7 @@ package body Sem_Ch3 is\n          Last_Tag := Decl;\n       end Add_Tag;\n \n-   --  Start of procesing for Add_Interface_Tag_Components\n+   --  Start of processing for Add_Interface_Tag_Components\n \n    begin\n       if Ekind (Typ) /= E_Record_Type\n@@ -1129,7 +1158,6 @@ package body Sem_Ch3 is\n             --  Find the last tag component\n \n             Comp := First (L);\n-\n             while Present (Comp) loop\n                if Is_Tag (Defining_Identifier (Comp)) then\n                   Last_Tag := Comp;\n@@ -1188,12 +1216,13 @@ package body Sem_Ch3 is\n \n             when N_Index_Or_Discriminant_Constraint =>\n                declare\n-                  IDC : Node_Id := First (Constraints (Constr));\n+                  IDC : Node_Id;\n \n                begin\n+                  IDC := First (Constraints (Constr));\n                   while Present (IDC) loop\n \n-                     --  One per-object constraint is sufficent\n+                     --  One per-object constraint is sufficient\n \n                      if Contains_POC (IDC) then\n                         return True;\n@@ -1253,8 +1282,8 @@ package body Sem_Ch3 is\n       end if;\n \n       --  If the subtype is a constrained subtype of the enclosing record,\n-      --  (which must have a partial view) the back-end does not handle\n-      --  properly the recursion. Rewrite the component declaration with an\n+      --  (which must have a partial view) the back-end does not properly\n+      --  handle the recursion. Rewrite the component declaration with an\n       --  explicit subtype indication, which is acceptable to Gigi. We can copy\n       --  the tree directly because side effects have already been removed from\n       --  discriminant constraints.\n@@ -1330,10 +1359,8 @@ package body Sem_Ch3 is\n       --  out some static checks.\n \n       if Ada_Version >= Ada_05\n-        and then (Null_Exclusion_Present (Component_Definition (N))\n-                    or else Can_Never_Be_Null (T))\n+        and then Can_Never_Be_Null (T)\n       then\n-         Set_Can_Never_Be_Null (Id);\n          Null_Exclusion_Static_Checks (N);\n       end if;\n \n@@ -1530,8 +1557,8 @@ package body Sem_Ch3 is\n       Set_Is_First_Subtype (T, True);\n       Set_Etype (T, T);\n \n-      --  Ada 2005 (AI-326): Mininum decoration to give support to tagged\n-      --  incomplete types\n+      --  Ada 2005 (AI-326): Minimum decoration to give support to tagged\n+      --  incomplete types.\n \n       if Tagged_Present (N) then\n          Set_Is_Tagged_Type (T);\n@@ -1561,8 +1588,8 @@ package body Sem_Ch3 is\n    -- Analyze_Itype_Reference --\n    -----------------------------\n \n-   --  Nothing to do. This node is placed in the tree only for the benefit\n-   --  of Gigi processing, and has no effect on the semantic processing.\n+   --  Nothing to do. This node is placed in the tree only for the benefit of\n+   --  back end processing, and has no effect on the semantic processing.\n \n    procedure Analyze_Itype_Reference (N : Node_Id) is\n    begin\n@@ -1621,8 +1648,8 @@ package body Sem_Ch3 is\n \n       else\n          T := Any_Type;\n-         Get_First_Interp (E, Index, It);\n \n+         Get_First_Interp (E, Index, It);\n          while Present (It.Typ) loop\n             if (Is_Integer_Type (It.Typ)\n                  or else Is_Real_Type (It.Typ))\n@@ -1652,8 +1679,8 @@ package body Sem_Ch3 is\n \n       elsif Is_Real_Type (T) then\n \n-         --  Because the real value is converted to universal_real, this\n-         --  is a legal context for a universal fixed expression.\n+         --  Because the real value is converted to universal_real, this is a\n+         --  legal context for a universal fixed expression.\n \n          if T = Universal_Fixed then\n             declare\n@@ -1671,8 +1698,8 @@ package body Sem_Ch3 is\n          elsif T = Any_Fixed then\n             Error_Msg_N (\"illegal context for mixed mode operation\", E);\n \n-            --  Expression is of the form : universal_fixed * integer.\n-            --  Try to resolve as universal_real.\n+            --  Expression is of the form : universal_fixed * integer. Try to\n+            --  resolve as universal_real.\n \n             T := Universal_Real;\n             Set_Etype (E, T);\n@@ -1727,7 +1754,7 @@ package body Sem_Ch3 is\n       --  If the object is limited or aliased, and if the type is unconstrained\n       --  and there is no expression, the discriminants cannot be modified and\n       --  the subtype of the object is constrained by the defaults, so it is\n-      --  worthile building the corresponding subtype.\n+      --  worthwhile building the corresponding subtype.\n \n       function Count_Tasks (T : Entity_Id) return Uint;\n       --  This function is called when a library level object of type is\n@@ -1879,8 +1906,8 @@ package body Sem_Ch3 is\n             return;\n          end if;\n \n-      --  In the normal case, enter identifier at the start to catch\n-      --  premature usage in the initialization expression.\n+      --  In the normal case, enter identifier at the start to catch premature\n+      --  usage in the initialization expression.\n \n       else\n          Generate_Definition (Id);\n@@ -1899,11 +1926,26 @@ package body Sem_Ch3 is\n       --  out some static checks\n \n       if Ada_Version >= Ada_05\n-        and then (Null_Exclusion_Present (N)\n-                    or else Can_Never_Be_Null (T))\n+        and then Can_Never_Be_Null (T)\n       then\n-         Set_Can_Never_Be_Null (Id);\n-         Null_Exclusion_Static_Checks (N);\n+         --  In case of aggregates we must also take care of the correct\n+         --  initialization of nested aggregates bug this is done at the\n+         --  point of the analysis of the aggregate (see sem_aggr.adb)\n+\n+         if Present (Expression (N))\n+           and then Nkind (Expression (N)) = N_Aggregate\n+         then\n+            null;\n+\n+         else\n+            declare\n+               Save_Typ : constant Entity_Id := Etype (Id);\n+            begin\n+               Set_Etype (Id, T); --  Temp. decoration for static checks\n+               Null_Exclusion_Static_Checks (N);\n+               Set_Etype (Id, Save_Typ);\n+            end;\n+         end if;\n       end if;\n \n       Set_Is_Pure (Id, Is_Pure (Current_Scope));\n@@ -2182,10 +2224,11 @@ package body Sem_Ch3 is\n          Act_T := Build_Default_Subtype;\n          Rewrite (Object_Definition (N), New_Occurrence_Of (Act_T, Loc));\n \n-      elsif not Is_Constrained (T)\n-        and then Has_Discriminants (T)\n-        and then Constant_Present (N)\n+      elsif Present (Underlying_Type (T))\n+        and then not Is_Constrained (Underlying_Type (T))\n+        and then Has_Discriminants (Underlying_Type (T))\n         and then Nkind (E) = N_Function_Call\n+        and then Constant_Present (N)\n       then\n          --  The back-end has problems with constants of a discriminated type\n          --  with defaults, if the initial value is a function call. We\n@@ -2271,13 +2314,14 @@ package body Sem_Ch3 is\n             Validate_Controlled_Object (Id);\n          end if;\n \n-         --  Generate a warning when an initialization causes an obvious\n-         --  ABE violation. If the init expression is a simple aggregate\n-         --  there shouldn't be any initialize/adjust call generated. This\n-         --  will be true as soon as aggregates are built in place when\n-         --  possible. ??? at the moment we do not generate warnings for\n-         --  temporaries created for those aggregates although a\n-         --  Program_Error might be generated if compiled with -gnato\n+         --  Generate a warning when an initialization causes an obvious ABE\n+         --  violation. If the init expression is a simple aggregate there\n+         --  shouldn't be any initialize/adjust call generated. This will be\n+         --  true as soon as aggregates are built in place when possible.\n+\n+         --  ??? at the moment we do not generate warnings for temporaries\n+         --  created for those aggregates although Program_Error might be\n+         --  generated if compiled with -gnato.\n \n          if Is_Controlled (Etype (Id))\n             and then Comes_From_Source (Id)\n@@ -2287,7 +2331,7 @@ package body Sem_Ch3 is\n \n                Implicit_Call : Entity_Id;\n                pragma Warnings (Off, Implicit_Call);\n-               --  What is this about, it is never referenced ???\n+               --  ??? what is this for (never referenced!)\n \n                function Is_Aggr (N : Node_Id) return Boolean;\n                --  Check that N is an aggregate\n@@ -2313,8 +2357,8 @@ package body Sem_Ch3 is\n                end Is_Aggr;\n \n             begin\n-               --  If no underlying type, we already are in an error situation\n-               --  don't try to add a warning since we do not have access\n+               --  If no underlying type, we already are in an error situation.\n+               --  Do not try to add a warning since we do not have access to\n                --  prim-op list.\n \n                if No (Underlying_Type (BT)) then\n@@ -2326,13 +2370,13 @@ package body Sem_Ch3 is\n                elsif Is_Generic_Type (BT) then\n                   Implicit_Call := Empty;\n \n-               --  if the init expression is not an aggregate, an adjust\n-               --  call will be generated\n+               --  If the init expression is not an aggregate, an adjust call\n+               --  will be generated\n \n                elsif Present (E) and then not Is_Aggr (E) then\n                   Implicit_Call := Find_Prim_Op (BT, Name_Adjust);\n \n-               --  if no init expression and we are not in the deferred\n+               --  If no init expression and we are not in the deferred\n                --  constant case, an Initialize call will be generated\n \n                elsif No (E) and then not Constant_Present (N) then\n@@ -2420,7 +2464,7 @@ package body Sem_Ch3 is\n         and then Nkind (E) = N_Explicit_Dereference\n         and then Nkind (Original_Node (E)) = N_Function_Call\n         and then not Is_Library_Level_Entity (Id)\n-        and then not Is_Constrained (T)\n+        and then not Is_Constrained (Underlying_Type (T))\n         and then not Is_Aliased (Id)\n         and then not Is_Class_Wide_Type (T)\n         and then not Is_Controlled (T)\n@@ -2437,8 +2481,8 @@ package body Sem_Ch3 is\n \n          Set_Renamed_Object (Id, E);\n \n-         --  Force generation of debugging information for the constant\n-         --  and for the renamed function call.\n+         --  Force generation of debugging information for the constant and for\n+         --  the renamed function call.\n \n          Set_Needs_Debug_Info (Id);\n          Set_Needs_Debug_Info (Entity (Prefix (E)));\n@@ -2490,22 +2534,23 @@ package body Sem_Ch3 is\n       Parent_Base : Entity_Id;\n \n    begin\n-      --  Ada 2005 (AI-251): Decorate all the names in the list of ancestor\n-      --  interfaces\n+      --  Ada 2005 (AI-251): Decorate all names in list of ancestor interfaces\n \n       if Is_Non_Empty_List (Interface_List (N)) then\n          declare\n-            I : Node_Id := First (Interface_List (N));\n-            T : Entity_Id;\n+            Intf : Node_Id;\n+            T    : Entity_Id;\n+\n          begin\n-            while Present (I) loop\n-               T := Find_Type_Of_Subtype_Indic (I);\n+            Intf := First (Interface_List (N));\n+            while Present (Intf) loop\n+               T := Find_Type_Of_Subtype_Indic (Intf);\n \n                if not Is_Interface (T) then\n-                  Error_Msg_NE (\"(Ada 2005) & must be an interface\", I, T);\n+                  Error_Msg_NE (\"(Ada 2005) & must be an interface\", Intf, T);\n                end if;\n \n-               Next (I);\n+               Next (Intf);\n             end loop;\n          end;\n       end if;\n@@ -2588,17 +2633,17 @@ package body Sem_Ch3 is\n       Set_Is_Pure (Id, Is_Pure (Current_Scope));\n       Init_Size_Align (Id);\n \n-      --  The following guard condition on Enter_Name is to handle cases\n-      --  where the defining identifier has already been entered into the\n-      --  scope but the declaration as a whole needs to be analyzed.\n+      --  The following guard condition on Enter_Name is to handle cases where\n+      --  the defining identifier has already been entered into the scope but\n+      --  the declaration as a whole needs to be analyzed.\n \n       --  This case in particular happens for derived enumeration types. The\n-      --  derived enumeration type is processed as an inserted enumeration\n-      --  type declaration followed by a rewritten subtype declaration. The\n-      --  defining identifier, however, is entered into the name scope very\n-      --  early in the processing of the original type declaration and\n-      --  therefore needs to be avoided here, when the created subtype\n-      --  declaration is analyzed. (See Build_Derived_Types)\n+      --  derived enumeration type is processed as an inserted enumeration type\n+      --  declaration followed by a rewritten subtype declaration. The defining\n+      --  identifier, however, is entered into the name scope very early in the\n+      --  processing of the original type declaration and therefore needs to be\n+      --  avoided here, when the created subtype declaration is analyzed. (See\n+      --  Build_Derived_Types)\n \n       --  This also happens when the full view of a private type is derived\n       --  type with constraints. In this case the entity has been introduced\n@@ -2626,8 +2671,8 @@ package body Sem_Ch3 is\n       Set_Is_Ada_2005       (Id, Is_Ada_2005       (T));\n \n       --  In the case where there is no constraint given in the subtype\n-      --  indication, Process_Subtype just returns the Subtype_Mark,\n-      --  so its semantic attributes must be established here.\n+      --  indication, Process_Subtype just returns the Subtype_Mark, so its\n+      --  semantic attributes must be established here.\n \n       if Nkind (Subtype_Indication (N)) /= N_Subtype_Indication then\n          Set_Etype (Id, Base_Type (T));\n@@ -2751,11 +2796,11 @@ package body Sem_Ch3 is\n                   Set_Class_Wide_Type (Id, Class_Wide_Type (T));\n                end if;\n \n-               --  In general the attributes of the subtype of a private\n-               --  type are the attributes of the partial view of parent.\n-               --  However, the full view may be a discriminated type,\n-               --  and the subtype must share the discriminant constraint\n-               --  to generate correct calls to initialization procedures.\n+               --  In general the attributes of the subtype of a private type\n+               --  are the attributes of the partial view of parent. However,\n+               --  the full view may be a discriminated type, and the subtype\n+               --  must share the discriminant constraint to generate correct\n+               --  calls to initialization procedures.\n \n                if Has_Discriminants (T) then\n                   Set_Discriminant_Constraint\n@@ -2784,23 +2829,7 @@ package body Sem_Ch3 is\n                                      (Id, Is_Access_Constant    (T));\n                Set_Directly_Designated_Type\n                                      (Id, Designated_Type       (T));\n-\n-               --  Ada 2005 (AI-231): Propagate the null-excluding attribute\n-               --  and carry out some static checks\n-\n-               if Null_Exclusion_Present (N)\n-                 or else Can_Never_Be_Null (T)\n-               then\n-                  Set_Can_Never_Be_Null (Id);\n-\n-                  if Null_Exclusion_Present (N)\n-                    and then Can_Never_Be_Null (T)\n-                  then\n-                     Error_Msg_N\n-                       (\"(Ada 2005) null exclusion not allowed if parent \"\n-                        & \"is already non-null\", Subtype_Indication (N));\n-                  end if;\n-               end if;\n+               Set_Can_Never_Be_Null (Id, Can_Never_Be_Null     (T));\n \n                --  A Pure library_item must not contain the declaration of a\n                --  named access type, except within a subprogram, generic\n@@ -2830,8 +2859,8 @@ package body Sem_Ch3 is\n                   Set_Stored_Constraint_From_Discriminant_Constraint (Id);\n                end if;\n \n-            --  If the subtype name denotes an incomplete type\n-            --  an error was already reported by Process_Subtype.\n+            --  If the subtype name denotes an incomplete type an error was\n+            --  already reported by Process_Subtype.\n \n             when E_Incomplete_Type =>\n                Set_Etype (Id, Any_Type);\n@@ -3402,16 +3431,20 @@ package body Sem_Ch3 is\n       end if;\n \n       --  Ada 2005 (AI-231): Propagate the null-excluding attribute to the\n-      --  array to ensure that objects of this type are initialized.\n+      --  array type to ensure that objects of this type are initialized.\n \n       if Ada_Version >= Ada_05\n-        and then (Null_Exclusion_Present (Component_Definition (Def))\n-                    or else Can_Never_Be_Null (Element_Type))\n+        and then Can_Never_Be_Null (Element_Type)\n       then\n          Set_Can_Never_Be_Null (T);\n \n          if Null_Exclusion_Present (Component_Definition (Def))\n            and then Can_Never_Be_Null (Element_Type)\n+\n+            --  No need to check itypes because in their case this check\n+            --  was done at their point of creation\n+\n+           and then not Is_Itype (Element_Type)\n          then\n             Error_Msg_N\n               (\"(Ada 2005) already a null-excluding type\",\n@@ -3490,7 +3523,7 @@ package body Sem_Ch3 is\n       Acc  : Node_Id;\n       Comp : Node_Id;\n       Decl : Node_Id;\n-      P    : Node_Id := Parent (N);\n+      P    : Node_Id;\n \n    begin\n       Set_Is_Internal (Anon);\n@@ -3523,6 +3556,7 @@ package body Sem_Ch3 is\n \n       --  Insert the new declaration in the nearest enclosing scope\n \n+      P := Parent (N);\n       while Present (P) and then not Has_Declarations (P) loop\n          P := Parent (P);\n       end loop;\n@@ -3536,7 +3570,7 @@ package body Sem_Ch3 is\n       end if;\n \n       --  Replace the anonymous type with an occurrence of the new declaration.\n-      --  In all cases the rewriten node does not have the null-exclusion\n+      --  In all cases the rewritten node does not have the null-exclusion\n       --  attribute because (if present) it was already inherited by the\n       --  anonymous entity (Anon). Thus, in case of components we do not\n       --  inherit this attribute.\n@@ -3744,12 +3778,11 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      --  If the parent type is not a derived type itself, and is\n-      --  declared in a closed scope (e.g., a subprogram), then we\n-      --  need to explicitly introduce the new type's concatenation\n-      --  operator since Derive_Subprograms will not inherit the\n-      --  parent's operator. If the parent type is unconstrained, the\n-      --  operator is of the unconstrained base type.\n+      --  If parent type is not a derived type itself, and is declared in\n+      --  closed scope (e.g. a subprogram), then we must explicitly introduce\n+      --  the new type's concatenation operator since Derive_Subprograms\n+      --  will not inherit the parent's operator. If the parent type is\n+      --  unconstrained, the operator is of the unconstrained base type.\n \n       if Number_Dimensions (Parent_Type) = 1\n         and then not Is_Limited_Type (Parent_Type)\n@@ -3839,19 +3872,17 @@ package body Sem_Ch3 is\n \n          elsif Present (Discriminant_Specifications (N)) then\n \n-            --  Verify that new discriminants are used to constrain\n-            --  the old ones.\n+            --  Verify that new discriminants are used to constrain old ones\n \n-            Old_Disc   := First_Discriminant (Parent_Type);\n-            New_Disc   := First_Discriminant (Derived_Type);\n-            Disc_Spec  := First (Discriminant_Specifications (N));\n             D_Constraint :=\n               First\n                 (Constraints\n                   (Constraint (Subtype_Indication (Type_Definition (N)))));\n \n+            Old_Disc  := First_Discriminant (Parent_Type);\n+            New_Disc  := First_Discriminant (Derived_Type);\n+            Disc_Spec := First (Discriminant_Specifications (N));\n             while Present (Old_Disc) and then Present (Disc_Spec) loop\n-\n                if Nkind (Discriminant_Type (Disc_Spec)) /=\n                                               N_Access_Definition\n                then\n@@ -4002,7 +4033,6 @@ package body Sem_Ch3 is\n \n          Literal := First_Literal (Parent_Type);\n          Literals_List := New_List;\n-\n          while Present (Literal)\n            and then Ekind (Literal) = E_Enumeration_Literal\n          loop\n@@ -4011,7 +4041,7 @@ package body Sem_Ch3 is\n             --  overridden by an explicit representation clause. Indicate\n             --  that there is no explicit representation given yet. These\n             --  derived literals are implicit operations of the new type,\n-            --  and can be overriden by explicit ones.\n+            --  and can be overridden by explicit ones.\n \n             if Nkind (Literal) = N_Defining_Character_Literal then\n                New_Lit :=\n@@ -5314,7 +5344,6 @@ package body Sem_Ch3 is\n                begin\n                   C1 := First_Elmt (New_Discrs);\n                   C2 := First_Elmt (Discriminant_Constraint (Derived_Type));\n-\n                   while Present (C1) and then Present (C2) loop\n                      if not\n                        Fully_Conformant_Expressions (Node (C1), Node (C2))\n@@ -5323,6 +5352,7 @@ package body Sem_Ch3 is\n                           \"constraint not conformant to previous declaration\",\n                              Node (C1));\n                      end if;\n+\n                      Next_Elmt (C1);\n                      Next_Elmt (C2);\n                   end loop;\n@@ -5451,12 +5481,13 @@ package body Sem_Ch3 is\n          if Ada_Version >= Ada_05 then\n             if Present (Enclosing_Generic_Body (Derived_Type)) then\n                declare\n-                  Ancestor_Type : Entity_Id := Parent_Type;\n+                  Ancestor_Type : Entity_Id;\n \n                begin\n                   --  Check to see if any ancestor of the derived type is a\n                   --  formal type.\n \n+                  Ancestor_Type := Parent_Type;\n                   while not Is_Generic_Type (Ancestor_Type)\n                     and then Etype (Ancestor_Type) /= Ancestor_Type\n                   loop\n@@ -5532,7 +5563,6 @@ package body Sem_Ch3 is\n          begin\n             if Is_Non_Empty_List (Interface_List (Type_Def)) then\n                Iface := First (Interface_List (Type_Def));\n-\n                while Present (Iface) loop\n                   Freeze_Before (N, Etype (Iface));\n                   Next (Iface);\n@@ -5896,7 +5926,6 @@ package body Sem_Ch3 is\n                     and then not Is_Empty_List (Interface_List (N_Partial))\n                   then\n                      Iface_Partial := First (Interface_List (N_Partial));\n-\n                      while Present (Iface_Partial) loop\n                         Num_Ifaces_Partial := Num_Ifaces_Partial + 1;\n                         Next (Iface_Partial);\n@@ -5919,7 +5948,6 @@ package body Sem_Ch3 is\n                   then\n                      Iface_Full := First (Interface_List\n                                           (Type_Definition (N_Full)));\n-\n                      while Present (Iface_Full) loop\n                         Num_Ifaces_Full := Num_Ifaces_Full + 1;\n                         Next (Iface_Full);\n@@ -5938,16 +5966,13 @@ package body Sem_Ch3 is\n                   if Num_Ifaces_Full > 0\n                     and then Num_Ifaces_Full = Num_Ifaces_Partial\n                   then\n-\n                      --  Check that the full-view and the private-view have\n-                     --  the same list of interfaces\n+                     --  the same list of interfaces.\n \n                      Iface_Full := First (Interface_List\n                                            (Type_Definition (N_Full)));\n-\n                      while Present (Iface_Full) loop\n                         Iface_Partial := First (Interface_List (N_Partial));\n-\n                         while Present (Iface_Partial)\n                           and then Etype (Iface_Partial) /= Etype (Iface_Full)\n                         loop\n@@ -6096,7 +6121,6 @@ package body Sem_Ch3 is\n       Set_Has_Delayed_Freeze (Derived_Type);\n \n       if Derive_Subps then\n-         Derive_Subprograms (Parent_Type, Derived_Type);\n \n          --  Ada 2005 (AI-251): Check if this tagged type implements abstract\n          --  interfaces\n@@ -6133,26 +6157,33 @@ package body Sem_Ch3 is\n          --  Ada 2005 (AI-251): Keep separate the management of tagged types\n          --  implementing interfaces\n \n-         if Is_Tagged_Type (Derived_Type)\n-           and then Has_Interfaces\n+         if not Is_Tagged_Type (Derived_Type)\n+           or else not Has_Interfaces\n          then\n-            --  Complete the decoration of private tagged types\n+            Derive_Subprograms (Parent_Type, Derived_Type);\n+\n+         else\n+            --  Ada 2005 (AI-251): Complete the decoration of tagged private\n+            --  types that implement interfaces\n \n             if Present (Tagged_Partial_View) then\n+               Derive_Subprograms\n+                 (Parent_Type, Derived_Type, Predefined_Prims_Only => True);\n+\n                Complete_Subprograms_Derivation\n                  (Partial_View => Tagged_Partial_View,\n                   Derived_Type => Derived_Type);\n-            end if;\n \n             --  Ada 2005 (AI-251): Derive the interface subprograms of all the\n             --  implemented interfaces and check if some of the subprograms\n             --  inherited from the ancestor cover some interface subprogram.\n \n-            if not Present (Tagged_Partial_View) then\n+            else\n+               Derive_Subprograms (Parent_Type, Derived_Type);\n+\n                declare\n-                  Subp_Elmt         : Elmt_Id := First_Elmt\n-                                                   (Primitive_Operations\n-                                                     (Derived_Type));\n+                  Subp_Elmt         : Elmt_Id;\n+                  First_Iface_Elmt  : Elmt_Id;\n                   Iface_Subp_Elmt   : Elmt_Id;\n                   Subp              : Entity_Id;\n                   Iface_Subp        : Entity_Id;\n@@ -6166,25 +6197,28 @@ package body Sem_Ch3 is\n \n                   Last_Inherited_Prim_Op := No_Elmt;\n \n+                  Subp_Elmt :=\n+                    First_Elmt (Primitive_Operations (Derived_Type));\n                   while Present (Subp_Elmt) loop\n                      Last_Inherited_Prim_Op := Subp_Elmt;\n                      Next_Elmt (Subp_Elmt);\n                   end loop;\n \n                   --  Ada 2005 (AI-251): Derive subprograms in abstract\n-                  --  interfaces\n+                  --  interfaces.\n \n                   Derive_Interface_Subprograms (Derived_Type);\n \n                   --  Ada 2005 (AI-251): Check if some of the inherited\n                   --  subprograms cover some of the new interfaces.\n \n                   if Present (Last_Inherited_Prim_Op) then\n-                     Iface_Subp_Elmt := Next_Elmt (Last_Inherited_Prim_Op);\n+                     First_Iface_Elmt := Next_Elmt (Last_Inherited_Prim_Op);\n+                     Iface_Subp_Elmt  := First_Iface_Elmt;\n                      while Present (Iface_Subp_Elmt) loop\n                         Subp_Elmt := First_Elmt (Primitive_Operations\n                                                   (Derived_Type));\n-                        while Subp_Elmt /= Last_Inherited_Prim_Op loop\n+                        while Subp_Elmt /= First_Iface_Elmt loop\n                            Subp       := Node (Subp_Elmt);\n                            Iface_Subp := Node (Iface_Subp_Elmt);\n \n@@ -6207,11 +6241,14 @@ package body Sem_Ch3 is\n                               --  Traverse the list of aliased subprograms\n \n                               declare\n-                                 E : Entity_Id := Alias (Subp);\n+                                 E : Entity_Id;\n+\n                               begin\n+                                 E := Alias (Subp);\n                                  while Present (Alias (E)) loop\n                                     E := Alias (E);\n                                  end loop;\n+\n                                  Set_Alias (Subp, E);\n                               end;\n \n@@ -6301,10 +6338,11 @@ package body Sem_Ch3 is\n          --  from a private extension declaration.\n \n          declare\n-            Rep   : Node_Id := First_Rep_Item (Derived_Type);\n+            Rep   : Node_Id;\n             Found : Boolean := False;\n \n          begin\n+            Rep := First_Rep_Item (Derived_Type);\n             while Present (Rep) loop\n                if Rep = First_Rep_Item (Parent_Type) then\n                   Found := True;\n@@ -6927,7 +6965,6 @@ package body Sem_Ch3 is\n \n          if Has_Discriminants (Typ) then\n             Disc := First_Discriminant (Typ);\n-\n             while Present (Disc) loop\n                if Chars (Disc) = Chars (Id)\n                  and then Present (Corresponding_Discriminant (Disc))\n@@ -7015,15 +7052,21 @@ package body Sem_Ch3 is\n          Subp := Node (Elmt);\n \n          --  Special exception, do not complain about failure to override the\n-         --  stream routines _Input and _Output, since we always provide\n+         --  stream routines _Input and _Output, as well as the primitive\n+         --  operations used in dispatching selects since we always provide\n          --  automatic overridings for these subprograms.\n \n          if Is_Abstract (Subp)\n            and then not Is_TSS (Subp, TSS_Stream_Input)\n            and then not Is_TSS (Subp, TSS_Stream_Output)\n            and then not Is_Abstract (T)\n+           and then Chars (Subp) /= Name_uDisp_Asynchronous_Select\n+           and then Chars (Subp) /= Name_uDisp_Conditional_Select\n+           and then Chars (Subp) /= Name_uDisp_Get_Prim_Op_Kind\n+           and then Chars (Subp) /= Name_uDisp_Timed_Select\n          then\n             if Present (Alias (Subp)) then\n+\n                --  Only perform the check for a derived subprogram when\n                --  the type has an explicit record extension. This avoids\n                --  incorrectly flagging abstract subprograms for the case\n@@ -7038,8 +7081,34 @@ package body Sem_Ch3 is\n                     (\"type must be declared abstract or & overridden\",\n                      T, Subp);\n \n+                  --  Traverse the whole chain of aliased subprograms to\n+                  --  complete the error notification. This is useful for\n+                  --  traceability of the chain of entities when the subprogram\n+                  --  corresponds with interface subprogram (that may be\n+                  --  defined in another package)\n+\n+                  if Ada_Version >= Ada_05\n+                    and then Present (Alias (Subp))\n+                  then\n+                     declare\n+                        E : Entity_Id;\n+\n+                     begin\n+                        E := Subp;\n+                        while Present (Alias (E)) loop\n+                           Error_Msg_Sloc := Sloc (E);\n+                           Error_Msg_NE (\"\\& has been inherited #\", T, Subp);\n+                           E := Alias (E);\n+                        end loop;\n+\n+                        Error_Msg_Sloc := Sloc (E);\n+                        Error_Msg_NE\n+                          (\"\\& has been inherited from subprogram #\", T, Subp);\n+                     end;\n+                  end if;\n+\n                --  Ada 2005 (AI-345): Protected or task type implementing\n-               --  abstract interfaces\n+               --  abstract interfaces.\n \n                elsif Is_Concurrent_Record_Type (T)\n                    and then Present (Abstract_Interfaces (T))\n@@ -7071,10 +7140,10 @@ package body Sem_Ch3 is\n       Loc : Node_Id)\n    is\n    begin\n-      --  A discriminant_specification for an access discriminant\n-      --  shall appear only in the declaration for a task or protected\n-      --  type, or for a type with the reserved word 'limited' in\n-      --  its definition or in one of its ancestors. (RM 3.7(10))\n+      --  A discriminant_specification for an access discriminant shall appear\n+      --  only in the declaration for a task or protected type, or for a type\n+      --  with the reserved word 'limited' in its definition or in one of its\n+      --  ancestors. (RM 3.7(10))\n \n       if Nkind (Discriminant_Type (D)) = N_Access_Definition\n         and then not Is_Concurrent_Type (Current_Scope)\n@@ -7098,10 +7167,10 @@ package body Sem_Ch3 is\n       --  ??? Also need to check components of record extensions, but not\n       --  components of protected types (which are always limited).\n \n-      --  Ada 2005: AI-363 relaxes this rule, to allow heap objects\n-      --  of such types to be unconstrained. This is safe because it is\n-      --  illegal to create access subtypes to such types with explicit\n-      --  discriminant constraints.\n+      --  Ada 2005: AI-363 relaxes this rule, to allow heap objects of such\n+      --  types to be unconstrained. This is safe because it is illegal to\n+      --  create access subtypes to such types with explicit discriminant\n+      --  constraints.\n \n       if not Is_Limited_Type (T) then\n          if Ekind (T) = E_Record_Type then\n@@ -7164,7 +7233,6 @@ package body Sem_Ch3 is\n \n                begin\n                   Var := First_Entity (Current_Scope);\n-\n                   while Present (Var) loop\n                      exit when Etype (Var) = E\n                        and then Comes_From_Source (Var);\n@@ -7439,10 +7507,10 @@ package body Sem_Ch3 is\n    -- Check_Or_Process_Discriminants --\n    ------------------------------------\n \n-   --  If an incomplete or private type declaration was already given for\n-   --  the type, the discriminants may have already been processed if they\n-   --  were present on the incomplete declaration. In this case a full\n-   --  conformance check is performed otherwise just process them.\n+   --  If an incomplete or private type declaration was already given for the\n+   --  type, the discriminants may have already been processed if they were\n+   --  present on the incomplete declaration. In this case a full conformance\n+   --  check is performed otherwise just process them.\n \n    procedure Check_Or_Process_Discriminants\n      (N    : Node_Id;\n@@ -7455,10 +7523,11 @@ package body Sem_Ch3 is\n          --  Make the discriminants visible to component declarations\n \n          declare\n-            D    : Entity_Id := First_Discriminant (T);\n+            D    : Entity_Id;\n             Prev : Entity_Id;\n \n          begin\n+            D := First_Discriminant (T);\n             while Present (D) loop\n                Prev := Current_Entity (D);\n                Set_Current_Entity (D);\n@@ -7470,8 +7539,8 @@ package body Sem_Ch3 is\n \n                if Ada_Version < Ada_05 then\n \n-                  --  This restriction gets applied to the full type here; it\n-                  --  has already been applied earlier to the partial view\n+                  --  This restriction gets applied to the full type here. It\n+                  --  has already been applied earlier to the partial view.\n \n                   Check_Access_Discriminant_Requires_Limited (Parent (D), N);\n                end if;\n@@ -7514,14 +7583,20 @@ package body Sem_Ch3 is\n    ------------------------\n \n    procedure Collect_Interfaces (N : Node_Id; Derived_Type : Entity_Id) is\n-      I          : Node_Id;\n+      Intf : Node_Id;\n \n       procedure Add_Interface (Iface : Entity_Id);\n+      --  Add one interface\n+\n+      -------------------\n+      -- Add_Interface --\n+      -------------------\n \n       procedure Add_Interface (Iface : Entity_Id) is\n-         Elmt : Elmt_Id := First_Elmt (Abstract_Interfaces (Derived_Type));\n+         Elmt : Elmt_Id;\n \n       begin\n+         Elmt := First_Elmt (Abstract_Interfaces (Derived_Type));\n          while Present (Elmt) and then Node (Elmt) /= Iface loop\n             Next_Elmt (Elmt);\n          end loop;\n@@ -7532,6 +7607,8 @@ package body Sem_Ch3 is\n          end if;\n       end Add_Interface;\n \n+   --  Start of processing for Add_Interface\n+\n    begin\n       pragma Assert (False\n          or else Nkind (N) = N_Derived_Type_Definition\n@@ -7541,31 +7618,30 @@ package body Sem_Ch3 is\n       --  Traverse the graph of ancestor interfaces\n \n       if Is_Non_Empty_List (Interface_List (N)) then\n-         I := First (Interface_List (N));\n-\n-         while Present (I) loop\n+         Intf := First (Interface_List (N));\n+         while Present (Intf) loop\n \n             --  Protect against wrong uses. For example:\n             --    type I is interface;\n             --    type O is tagged null record;\n             --    type Wrong is new I and O with null record; -- ERROR\n \n-            if Is_Interface (Etype (I)) then\n+            if Is_Interface (Etype (Intf)) then\n \n                --  Do not add the interface when the derived type already\n                --  implements this interface\n \n                if not Interface_Present_In_Ancestor (Derived_Type,\n-                                                     Etype (I))\n+                                                     Etype (Intf))\n                then\n                   Collect_Interfaces\n-                     (Type_Definition (Parent (Etype (I))),\n+                     (Type_Definition (Parent (Etype (Intf))),\n                       Derived_Type);\n-                  Add_Interface (Etype (I));\n+                  Add_Interface (Etype (Intf));\n                end if;\n             end if;\n \n-            Next (I);\n+            Next (Intf);\n          end loop;\n       end if;\n    end Collect_Interfaces;\n@@ -7591,9 +7667,9 @@ package body Sem_Ch3 is\n       --  Next_Entity field of full to ensure that the calls to Copy_Node\n       --  do not corrupt the entity chain.\n \n-      --  Note that the type of the full view is the same entity as the\n-      --  type of the partial view. In this fashion, the subtype has\n-      --  access to the correct view of the parent.\n+      --  Note that the type of the full view is the same entity as the type of\n+      --  the partial view. In this fashion, the subtype has access to the\n+      --  correct view of the parent.\n \n       Save_Next_Entity := Next_Entity (Full);\n       Save_Homonym     := Homonym (Priv);\n@@ -7701,8 +7777,8 @@ package body Sem_Ch3 is\n       --  If the full base is itself derived from private, build a congruent\n       --  subtype of its underlying type, for use by the back end. For a\n       --  constrained record component, the declaration cannot be placed on\n-      --  the component list, but it must neverthess be built an analyzed, to\n-      --  supply enough information for gigi to compute the size of component.\n+      --  the component list, but it must nevertheless be built an analyzed, to\n+      --  supply enough information for Gigi to compute the size of component.\n \n       elsif Ekind (Full_Base) in Private_Kind\n         and then Is_Derived_Type (Full_Base)\n@@ -7790,7 +7866,7 @@ package body Sem_Ch3 is\n       Derived_Type : Entity_Id)\n    is\n       Result  : constant Elist_Id := New_Elmt_List;\n-      Elmt_P  : Elmt_Id := No_Elmt;\n+      Elmt_P  : Elmt_Id;\n       Elmt_D  : Elmt_Id;\n       Found   : Boolean;\n       Prim_Op : Entity_Id;\n@@ -7799,6 +7875,8 @@ package body Sem_Ch3 is\n    begin\n       if Is_Tagged_Type (Partial_View) then\n          Elmt_P := First_Elmt (Primitive_Operations (Partial_View));\n+      else\n+         Elmt_P := No_Elmt;\n       end if;\n \n       --  Inherit primitives declared with the partial-view\n@@ -7822,7 +7900,7 @@ package body Sem_Ch3 is\n             --  Search for entries associated with abstract interfaces that\n             --  have been covered by this primitive\n \n-            Elmt_D  := First_Elmt (Primitive_Operations (Derived_Type));\n+            Elmt_D := First_Elmt (Primitive_Operations (Derived_Type));\n             while Present (Elmt_D) loop\n                E := Node (Elmt_D);\n \n@@ -7843,9 +7921,9 @@ package body Sem_Ch3 is\n       end loop;\n \n       --  Append the entities of the full-view to the list of primitives\n-      --  of derived_type\n+      --  of derived_type.\n \n-      Elmt_D  := First_Elmt (Result);\n+      Elmt_D := First_Elmt (Result);\n       while Present (Elmt_D) loop\n          Append_Elmt (Node (Elmt_D), Primitive_Operations (Derived_Type));\n          Next_Elmt (Elmt_D);\n@@ -7866,11 +7944,11 @@ package body Sem_Ch3 is\n       New_T   : Entity_Id;\n \n       procedure Check_Recursive_Declaration (Typ : Entity_Id);\n-      --  If deferred constant is an access type initialized with an\n-      --  allocator, check whether there is an illegal recursion in the\n-      --  definition, through a default value of some record subcomponent.\n-      --  This is normally detected when generating init procs, but requires\n-      --  this additional mechanism when expansion is disabled.\n+      --  If deferred constant is an access type initialized with an allocator,\n+      --  check whether there is an illegal recursion in the definition,\n+      --  through a default value of some record subcomponent. This is normally\n+      --  detected when generating init procs, but requires this additional\n+      --  mechanism when expansion is disabled.\n \n       ---------------------------------\n       -- Check_Recursive_Declaration --\n@@ -8169,11 +8247,11 @@ package body Sem_Ch3 is\n \n       Conditional_Delay (Def_Id, T);\n \n-      --  AI-363 : Subtypes of general access types whose designated\n-      --  types have default discriminants are disallowed. In instances,\n-      --  the rule has to be checked against the actual, of which T is\n-      --  the subtype. In a generic body, the rule is checked assuming\n-      --  that the actual type has defaulted discriminants.\n+      --  AI-363 : Subtypes of general access types whose designated types have\n+      --  default discriminants are disallowed. In instances, the rule has to\n+      --  be checked against the actual, of which T is the subtype. In a\n+      --  generic body, the rule is checked assuming that the actual type has\n+      --  defaulted discriminants.\n \n       if Ada_Version >=  Ada_05 then\n          if Ekind (Base_Type (T)) = E_General_Access_Type\n@@ -8232,7 +8310,6 @@ package body Sem_Ch3 is\n \n       else\n          S := First (Constraints (C));\n-\n          while Present (S) loop\n             Number_Of_Constraints := Number_Of_Constraints + 1;\n             Next (S);\n@@ -8584,8 +8661,8 @@ package body Sem_Ch3 is\n       ---------------------\n \n       function Get_Discr_Value (Discrim : Entity_Id) return Node_Id is\n-         D : Entity_Id := First_Discriminant (Typ);\n-         E : Elmt_Id   := First_Elmt (Constraints);\n+         D : Entity_Id;\n+         E : Elmt_Id;\n          G : Elmt_Id;\n \n       begin\n@@ -8596,6 +8673,8 @@ package body Sem_Ch3 is\n          --  case when constraining an inherited component whose constraint is\n          --  given by a discriminant of the parent.\n \n+         D := First_Discriminant (Typ);\n+         E := First_Elmt (Constraints);\n          while Present (D) loop\n             if D = Entity (Discrim)\n               or else Corresponding_Discriminant (D) = Entity (Discrim)\n@@ -8620,7 +8699,6 @@ package body Sem_Ch3 is\n             D := First_Discriminant (Etype (Typ));\n             E := First_Elmt (Constraints);\n             G := First_Elmt (Stored_Constraint (Typ));\n-\n             while Present (D) loop\n                if D = Entity (Discrim) then\n                   return Node (E);\n@@ -9686,9 +9764,8 @@ package body Sem_Ch3 is\n          Create_All_Components;\n \n       else\n-         --  If the discriminants are not static, or if this is a multi-level\n-         --  type extension, we have to include all the components of the\n-         --  parent type.\n+         --  If discriminants are not static, or if this is a multi-level type\n+         --  extension, we have to include all components of the parent type.\n \n          Old_C := First_Component (Typ);\n          while Present (Old_C) loop\n@@ -9745,10 +9822,11 @@ package body Sem_Ch3 is\n       --  Check delta is power of 10, and determine scale value from it\n \n       declare\n-         Val : Ureal := Delta_Val;\n+         Val : Ureal;\n \n       begin\n          Scale_Val := Uint_0;\n+         Val := Delta_Val;\n \n          if Val < Ureal_1 then\n             while Val < Ureal_1 loop\n@@ -9891,12 +9969,11 @@ package body Sem_Ch3 is\n            and then not Is_Empty_Elmt_List (Abstract_Interfaces (T))\n          then\n             AI := First_Elmt (Abstract_Interfaces (T));\n-\n             while Present (AI) loop\n                Derive_Subprograms\n-                 (Parent_Type             => Node (AI),\n-                  Derived_Type            => Derived_Type,\n-                  Is_Interface_Derivation => True);\n+                 (Parent_Type         => Node (AI),\n+                  Derived_Type        => Derived_Type,\n+                  No_Predefined_Prims => True);\n \n                Next_Elmt (AI);\n             end loop;\n@@ -9913,7 +9990,7 @@ package body Sem_Ch3 is\n       --  allocated in its corresponding virtual table.\n \n       --  Its alias attribute references its original interface subprogram.\n-      --  When overriden, the alias attribute is later saved in the\n+      --  When overridden, the alias attribute is later saved in the\n       --  Abstract_Interface_Alias attribute.\n \n    end Derive_Interface_Subprograms;\n@@ -9962,18 +10039,28 @@ package body Sem_Ch3 is\n          Prev : Entity_Id;\n \n       begin\n-         --  The visible operation that is overriden is a homonym of the\n+         --  The visible operation that is overridden is a homonym of the\n          --  parent subprogram. We scan the homonym chain to find the one\n          --  whose alias is the subprogram we are deriving.\n \n-         Prev := Homonym (Parent_Subp);\n+         Prev := Current_Entity (Parent_Subp);\n          while Present (Prev) loop\n             if Is_Dispatching_Operation (Parent_Subp)\n               and then Present (Prev)\n               and then Ekind (Prev) = Ekind (Parent_Subp)\n               and then Alias (Prev) = Parent_Subp\n               and then Scope (Parent_Subp) = Scope (Prev)\n-              and then not Is_Hidden (Prev)\n+              and then\n+                (not Is_Hidden (Prev)\n+                   or else\n+\n+                  --  Ada 2005 (AI-251): Entities associated with overridden\n+                  --  interface subprograms are always marked as hidden; in\n+                  --  this case the field abstract_interface_alias references\n+                  --  the original entity (cf. override_dispatching_operation).\n+\n+                 (Atree.Present (Abstract_Interface_Alias (Prev))\n+                    and then not Is_Hidden (Abstract_Interface_Alias (Prev))))\n             then\n                Visible_Subp := Prev;\n                return True;\n@@ -10301,16 +10388,18 @@ package body Sem_Ch3 is\n    ------------------------\n \n    procedure Derive_Subprograms\n-     (Parent_Type             : Entity_Id;\n-      Derived_Type            : Entity_Id;\n-      Generic_Actual          : Entity_Id := Empty;\n-      Is_Interface_Derivation : Boolean   := False)\n+     (Parent_Type           : Entity_Id;\n+      Derived_Type          : Entity_Id;\n+      Generic_Actual        : Entity_Id := Empty;\n+      No_Predefined_Prims   : Boolean   := False;\n+      Predefined_Prims_Only : Boolean   := False)\n    is\n       Op_List     : constant Elist_Id :=\n                       Collect_Primitive_Operations (Parent_Type);\n       Act_List    : Elist_Id;\n       Act_Elmt    : Elmt_Id;\n       Elmt        : Elmt_Id;\n+      Is_Predef   : Boolean;\n       Subp        : Entity_Id;\n       New_Subp    : Entity_Id := Empty;\n       Parent_Base : Entity_Id;\n@@ -10340,11 +10429,15 @@ package body Sem_Ch3 is\n          Subp := Node (Elmt);\n \n          if Ekind (Subp) /= E_Enumeration_Literal then\n-            if Is_Interface_Derivation then\n-               if not Is_Predefined_Dispatching_Operation (Subp) then\n-                  Derive_Subprogram\n-                    (New_Subp, Subp, Derived_Type, Parent_Base);\n-               end if;\n+            Is_Predef :=\n+              Is_Dispatching_Operation (Subp)\n+                and then Is_Predefined_Dispatching_Operation (Subp);\n+\n+            if No_Predefined_Prims and then Is_Predef then\n+               null;\n+\n+            elsif Predefined_Prims_Only and then not Is_Predef then\n+               null;\n \n             elsif No (Generic_Actual) then\n                Derive_Subprogram\n@@ -10558,17 +10651,19 @@ package body Sem_Ch3 is\n         and then Is_Non_Empty_List (Interface_List (Def))\n       then\n          declare\n-            I : Node_Id := First (Interface_List (Def));\n-            T : Entity_Id;\n+            Intf : Node_Id;\n+            T    : Entity_Id;\n+\n          begin\n-            while Present (I) loop\n-               T := Find_Type_Of_Subtype_Indic (I);\n+            Intf := First (Interface_List (Def));\n+            while Present (Intf) loop\n+               T := Find_Type_Of_Subtype_Indic (Intf);\n \n                if not Is_Interface (T) then\n-                  Error_Msg_NE (\"(Ada 2005) & must be an interface\", I, T);\n+                  Error_Msg_NE (\"(Ada 2005) & must be an interface\", Intf, T);\n                end if;\n \n-               Next (I);\n+               Next (Intf);\n             end loop;\n          end;\n       end if;\n@@ -10597,15 +10692,6 @@ package body Sem_Ch3 is\n          end if;\n \n          return;\n-\n-      --  Ada 2005 (AI-231): Static check\n-\n-      elsif Is_Access_Type (Parent_Type)\n-        and then Null_Exclusion_Present (Type_Definition (N))\n-        and then Can_Never_Be_Null (Parent_Type)\n-      then\n-         Error_Msg_N (\"(Ada 2005) null exclusion not allowed if parent is \"\n-                      & \"already non-null\", Type_Definition (N));\n       end if;\n \n       --  Only composite types other than array types are allowed to have\n@@ -11562,10 +11648,12 @@ package body Sem_Ch3 is\n \n       if Base_Type (Scope (Discriminant)) = Base_Type (Typ_For_Constraint) then\n          declare\n-            D : Entity_Id := First_Discriminant (Typ_For_Constraint);\n-            E : Elmt_Id   := First_Elmt (Constraint);\n+            D : Entity_Id;\n+            E : Elmt_Id;\n \n          begin\n+            D := First_Discriminant (Typ_For_Constraint);\n+            E := First_Elmt (Constraint);\n             while Present (D) loop\n                if Chars (D) = Chars (Discriminant) then\n                   return Node (E);\n@@ -11584,10 +11672,12 @@ package body Sem_Ch3 is\n \n       if  Nkind (Result) = N_Defining_Identifier then\n          declare\n-            D : Entity_Id := First_Discriminant (Typ_For_Constraint);\n-            E : Elmt_Id   := First_Elmt (Constraint);\n+            D : Entity_Id;\n+            E : Elmt_Id;\n \n          begin\n+            D := First_Discriminant (Typ_For_Constraint);\n+            E := First_Elmt (Constraint);\n             while Present (D) loop\n                if Corresponding_Discriminant (D) = Discriminant then\n                   return Node (E);\n@@ -11738,7 +11828,7 @@ package body Sem_Ch3 is\n             while Present (Discrim) loop\n                Corr_Discrim := Corresponding_Discriminant (Discrim);\n \n-               --  Corr_Discrimm could be missing in an error situation\n+               --  Corr_Discrim could be missing in an error situation\n \n                if Present (Corr_Discrim)\n                  and then Original_Record_Component (Corr_Discrim) = Old_C\n@@ -11952,9 +12042,10 @@ package body Sem_Ch3 is\n       -------------------\n \n       function Is_Local_Type (Typ : Entity_Id) return Boolean is\n-         Scop : Entity_Id := Scope (Typ);\n+         Scop : Entity_Id;\n \n       begin\n+         Scop := Scope (Typ);\n          while Present (Scop)\n            and then Scop /= Standard_Standard\n          loop\n@@ -12212,7 +12303,6 @@ package body Sem_Ch3 is\n \n             begin\n                Get_First_Interp (I, Ind, It);\n-\n                while Present (It.Typ) loop\n                   if Is_Discrete_Type (It.Typ) then\n \n@@ -12635,10 +12725,13 @@ package body Sem_Ch3 is\n       --  of two that does not exceed the given delta value.\n \n       declare\n-         Tmp   : Ureal := Ureal_1;\n-         Scale : Int   := 0;\n+         Tmp   : Ureal;\n+         Scale : Int;\n \n       begin\n+         Tmp := Ureal_1;\n+         Scale := 0;\n+\n          if Delta_Val < Ureal_1 then\n             while Delta_Val < Tmp loop\n                Tmp := Tmp / Ureal_2;\n@@ -12902,15 +12995,35 @@ package body Sem_Ch3 is\n             Default_Not_Present := True;\n          end if;\n \n-         --  Ada 2005 (AI-231): Set the null-excluding attribute and carry\n-         --  out some static checks.\n+         --  Ada 2005 (AI-231): Create an Itype that is a duplicate of\n+         --  Discr_Type but with the null-exclusion attribute\n+\n+         if Ada_Version >= Ada_05 then\n+\n+            --  Ada 2005 (AI-231): Static checks\n+\n+            if Can_Never_Be_Null (Discr_Type) then\n+               Null_Exclusion_Static_Checks (Discr);\n+\n+            elsif Is_Access_Type (Discr_Type)\n+              and then Null_Exclusion_Present (Discr)\n+\n+               --  No need to check itypes because in their case this check\n+               --  was done at their point of creation\n+\n+              and then not Is_Itype (Discr_Type)\n+            then\n+               if Can_Never_Be_Null (Discr_Type) then\n+                  Error_Msg_N\n+                    (\"(Ada 2005) already a null-excluding type\", Discr);\n+               end if;\n+\n+               Set_Etype (Defining_Identifier (Discr),\n+                 Create_Null_Excluding_Itype\n+                   (T           => Discr_Type,\n+                    Related_Nod => Discr));\n+            end if;\n \n-         if Ada_Version >= Ada_05\n-           and then (Null_Exclusion_Present (Discr)\n-                       or else Can_Never_Be_Null (Discr_Type))\n-         then\n-            Set_Can_Never_Be_Null (Defining_Identifier (Discr));\n-            Null_Exclusion_Static_Checks (Discr);\n          end if;\n \n          Next (Discr);\n@@ -12948,7 +13061,6 @@ package body Sem_Ch3 is\n \n       Discr := First (Discriminant_Specifications (N));\n       Discr_Number := Uint_1;\n-\n       while Present (Discr) loop\n          Id := Defining_Identifier (Discr);\n          Set_Ekind (Id, E_Discriminant);\n@@ -13007,6 +13119,11 @@ package body Sem_Ch3 is\n             end if;\n \n             T := Etype (T);\n+\n+            --  Protect us against erroneous code that has a large\n+            --  chain of circularity dependencies\n+\n+            exit when T = Typ;\n          end loop;\n \n          return Empty;\n@@ -13176,7 +13293,6 @@ package body Sem_Ch3 is\n             begin\n                Priv_Discr := First_Discriminant (Priv_Parent);\n                Full_Discr := First_Discriminant (Full_Parent);\n-\n                while Present (Priv_Discr) and then Present (Full_Discr) loop\n                   if Original_Record_Component (Priv_Discr) =\n                      Original_Record_Component (Full_Discr)\n@@ -13373,7 +13489,7 @@ package body Sem_Ch3 is\n                      then\n \n                         --  Verify that it is not otherwise controlled by\n-                        --  a formal or a return value ot type T.\n+                        --  a formal or a return value of type T.\n \n                         Check_Controlling_Formals (D_Type, Prim);\n                      end if;\n@@ -13420,15 +13536,13 @@ package body Sem_Ch3 is\n    begin\n       if No (Private_Dependents (Inc_T)) then\n          return;\n-\n-      else\n-         Inc_Elmt := First_Elmt (Private_Dependents (Inc_T));\n-\n-         --  Itypes that may be generated by the completion of an incomplete\n-         --  subtype are not used by the back-end and not attached to the tree.\n-         --  They are created only for constraint-checking purposes.\n       end if;\n \n+      --  Itypes that may be generated by the completion of an incomplete\n+      --  subtype are not used by the back-end and not attached to the tree.\n+      --  They are created only for constraint-checking purposes.\n+\n+      Inc_Elmt := First_Elmt (Private_Dependents (Inc_T));\n       while Present (Inc_Elmt) loop\n          Priv_Dep := Node (Inc_Elmt);\n \n@@ -13446,9 +13560,7 @@ package body Sem_Ch3 is\n \n             begin\n                Formal := First_Formal (Priv_Dep);\n-\n                while Present (Formal) loop\n-\n                   if Etype (Formal) = Inc_T then\n                      Set_Etype (Formal, Full_T);\n                   end if;\n@@ -13457,9 +13569,14 @@ package body Sem_Ch3 is\n                end loop;\n             end;\n \n-         elsif  Is_Overloadable (Priv_Dep) then\n+         elsif Is_Overloadable (Priv_Dep) then\n \n-            if Is_Tagged_Type (Full_T) then\n+            --  A protected operation is never dispatching: only its\n+            --  wrapper operation (which has convention Ada) is.\n+\n+            if Is_Tagged_Type (Full_T)\n+              and then Convention (Priv_Dep) /= Convention_Protected\n+            then\n \n                --  Subprogram has an access parameter whose designated type\n                --  was incomplete. Reexamine declaration now, because it may\n@@ -13614,12 +13731,12 @@ package body Sem_Ch3 is\n \n             if not R_Check_Off then\n                R_Checks := Range_Check (R, T);\n-               Type_Decl := Parent (R);\n \n                --  Look up tree to find an appropriate insertion point.\n                --  This seems really junk code, and very brittle, couldn't\n                --  we just use an insert actions call of some kind ???\n \n+               Type_Decl := Parent (R);\n                while Present (Type_Decl) and then not\n                  (Nkind (Type_Decl) = N_Full_Type_Declaration\n                     or else\n@@ -13647,9 +13764,10 @@ package body Sem_Ch3 is\n \n                   if Nkind (Type_Decl) = N_Loop_Statement then\n                      declare\n-                        Indic : Node_Id := Parent (R);\n+                        Indic : Node_Id;\n \n                      begin\n+                        Indic := Parent (R);\n                         while Present (Indic) and then not\n                           (Nkind (Indic) = N_Subtype_Indication)\n                         loop\n@@ -13757,9 +13875,12 @@ package body Sem_Ch3 is\n    is\n       P               : Node_Id;\n       Def_Id          : Entity_Id;\n+      Error_Node      : Node_Id;\n       Full_View_Id    : Entity_Id;\n       Subtype_Mark_Id : Entity_Id;\n \n+      May_Have_Null_Exclusion : Boolean;\n+\n       procedure Check_Incomplete (T : Entity_Id);\n       --  Called to verify that an incomplete type is not used prematurely\n \n@@ -13783,18 +13904,90 @@ package body Sem_Ch3 is\n \n          Find_Type (S);\n          Check_Incomplete (S);\n+         P := Parent (S);\n \n          --  Ada 2005 (AI-231): Static check\n \n          if Ada_Version >= Ada_05\n-           and then Present (Parent (S))\n-           and then Null_Exclusion_Present (Parent (S))\n-           and then Nkind (Parent (S)) /= N_Access_To_Object_Definition\n+           and then Present (P)\n+           and then Null_Exclusion_Present (P)\n+           and then Nkind (P) /= N_Access_To_Object_Definition\n            and then not Is_Access_Type (Entity (S))\n          then\n             Error_Msg_N\n-              (\"(Ada 2005) null-exclusion part requires an access type\", S);\n+              (\"(Ada 2005) the null-exclusion part requires an access type\",\n+               S);\n+         end if;\n+\n+         May_Have_Null_Exclusion :=\n+           Nkind (P) = N_Access_Definition\n+           or else Nkind (P) = N_Access_Function_Definition\n+           or else Nkind (P) = N_Access_Procedure_Definition\n+           or else Nkind (P) = N_Access_To_Object_Definition\n+           or else Nkind (P) = N_Allocator\n+           or else Nkind (P) = N_Component_Definition\n+           or else Nkind (P) = N_Derived_Type_Definition\n+           or else Nkind (P) = N_Discriminant_Specification\n+           or else Nkind (P) = N_Object_Declaration\n+           or else Nkind (P) = N_Parameter_Specification\n+           or else Nkind (P) = N_Subtype_Declaration;\n+\n+         --  Create an Itype that is a duplicate of Entity (S) but with the\n+         --  null-exclusion attribute\n+\n+         if May_Have_Null_Exclusion\n+           and then Is_Access_Type (Entity (S))\n+           and then Null_Exclusion_Present (P)\n+\n+            --  No need to check the case of an access to object definition.\n+            --  It is correct to define double not-null pointers.\n+            --  Example:\n+            --     type Not_Null_Int_Ptr is not null access Integer;\n+            --     type Acc is not null access Not_Null_Int_Ptr;\n+\n+           and then Nkind (P) /= N_Access_To_Object_Definition\n+         then\n+            if Can_Never_Be_Null (Entity (S)) then\n+               case Nkind (Related_Nod) is\n+                  when N_Full_Type_Declaration =>\n+                     if Nkind (Type_Definition (Related_Nod))\n+                       in N_Array_Type_Definition\n+                     then\n+                        Error_Node :=\n+                          Subtype_Indication\n+                            (Component_Definition\n+                             (Type_Definition (Related_Nod)));\n+                     else\n+                        Error_Node :=\n+                          Subtype_Indication (Type_Definition (Related_Nod));\n+                     end if;\n+\n+                  when N_Subtype_Declaration =>\n+                     Error_Node := Subtype_Indication (Related_Nod);\n+\n+                  when N_Object_Declaration =>\n+                     Error_Node := Object_Definition (Related_Nod);\n+\n+                  when N_Component_Declaration =>\n+                     Error_Node :=\n+                       Subtype_Indication (Component_Definition (Related_Nod));\n+\n+                  when others =>\n+                     pragma Assert (False);\n+                     Error_Node := Related_Nod;\n+               end case;\n+\n+               Error_Msg_N\n+                 (\"(Ada 2005) already a null-excluding type\", Error_Node);\n+            end if;\n+\n+            Set_Etype  (S,\n+              Create_Null_Excluding_Itype\n+                (T           => Entity (S),\n+                 Related_Nod => P));\n+            Set_Entity (S, Etype (S));\n          end if;\n+\n          return Entity (S);\n \n       --  Case of constraint present, so that we have an N_Subtype_Indication\n@@ -13975,7 +14168,7 @@ package body Sem_Ch3 is\n       --  to a component, so that accessibility checks are properly performed\n       --  on it. The declaration of the access type is placed ahead of that\n       --  of the record, to prevent circular order-of-elaboration issues in\n-      --  gigi. We create an incomplete type for the record declaration, which\n+      --  Gigi. We create an incomplete type for the record declaration, which\n       --  is the designated type of the anonymous access.\n \n       procedure Make_Incomplete_Type_Declaration;\n@@ -14084,7 +14277,7 @@ package body Sem_Ch3 is\n                        Make_Access_Function_Definition (Loc,\n                          Parameter_Specifications =>\n                            Parameter_Specifications (Acc_Def),\n-                         Subtype_Mark => Subtype_Mark (Acc_Def));\n+                         Result_Definition => Result_Definition (Acc_Def));\n                   else\n                      Type_Def :=\n                        Make_Access_Procedure_Definition (Loc,\n@@ -14248,7 +14441,6 @@ package body Sem_Ch3 is\n             Iface_Typ : Entity_Id;\n          begin\n             Iface := First (Interface_List (Def));\n-\n             while Present (Iface) loop\n                Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n                Iface_Def := Type_Definition (Parent (Iface_Typ));\n@@ -14518,7 +14710,6 @@ package body Sem_Ch3 is\n       begin\n          if Nkind (N) = N_Discriminant_Specification then\n             Comp := First_Discriminant (Typ);\n-\n             while Present (Comp) loop\n                if Chars (Comp) = Chars (Defining_Identifier (N)) then\n                   Set_Defining_Identifier (N, Comp);\n@@ -14530,7 +14721,6 @@ package body Sem_Ch3 is\n \n          elsif Nkind (N) = N_Component_Declaration then\n             Comp := First_Component (Typ);\n-\n             while Present (Comp) loop\n                if Chars (Comp) = Chars (Defining_Identifier (N)) then\n                   Set_Defining_Identifier (N, Comp);"}, {"sha": "608666d18e60c7bb1f6d89b1e7d1344061c662e6", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=9dfd2ff8dcb2b3e85b4eb847aa5343271c7fd173", "patch": "@@ -98,11 +98,11 @@ package Sem_Ch3  is\n    --  declaration.\n \n    procedure Derive_Subprogram\n-     (New_Subp       : in out Entity_Id;\n-      Parent_Subp    : Entity_Id;\n-      Derived_Type   : Entity_Id;\n-      Parent_Type    : Entity_Id;\n-      Actual_Subp    : Entity_Id := Empty);\n+     (New_Subp     : in out Entity_Id;\n+      Parent_Subp  : Entity_Id;\n+      Derived_Type : Entity_Id;\n+      Parent_Type  : Entity_Id;\n+      Actual_Subp  : Entity_Id := Empty);\n    --  Derive the subprogram Parent_Subp from Parent_Type, and replace the\n    --  subsidiary subtypes with the derived type to build the specification\n    --  of the inherited subprogram (returned in New_Subp). For tagged types,\n@@ -111,17 +111,25 @@ package Sem_Ch3  is\n    --  subprogram of the parent type.\n \n    procedure Derive_Subprograms\n-     (Parent_Type             : Entity_Id;\n-      Derived_Type            : Entity_Id;\n-      Generic_Actual          : Entity_Id := Empty;\n-      Is_Interface_Derivation : Boolean   := False);\n+     (Parent_Type           : Entity_Id;\n+      Derived_Type          : Entity_Id;\n+      Generic_Actual        : Entity_Id := Empty;\n+      No_Predefined_Prims   : Boolean   := False;\n+      Predefined_Prims_Only : Boolean   := False);\n    --  To complete type derivation, collect/retrieve the primitive operations\n    --  of the parent type, and replace the subsidiary subtypes with the derived\n    --  type, to build the specs of the inherited ops. For generic actuals, the\n    --  mapping of the primitive operations to those of the parent type is also\n    --  done by rederiving the operations within the instance. For tagged types,\n    --  the derived subprograms are aliased to those of the actual, not those of\n-   --  the ancestor.\n+   --  the ancestor. The last two params are used in case of derivation from\n+   --  abstract interface types: No_Predefined_Prims is used to avoid the\n+   --  derivation of predefined primitives from the interface, and Predefined\n+   --  Prims_Only is used to complete the derivation predefined primitives\n+   --  in case of private tagged types implementing interfaces.\n+   --\n+   --  Note: one might expect this to be private to the package body, but\n+   --  there is one rather unusual usage in package Exp_Dist.\n \n    function Find_Type_Of_Subtype_Indic (S : Node_Id) return Entity_Id;\n    --  Given a subtype indication S (which is really an N_Subtype_Indication"}]}