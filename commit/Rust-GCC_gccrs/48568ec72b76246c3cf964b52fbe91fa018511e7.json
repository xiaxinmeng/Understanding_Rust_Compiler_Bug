{"sha": "48568ec72b76246c3cf964b52fbe91fa018511e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg1NjhlYzcyYjc2MjQ2YzNjZjk2NGI1MmZiZTkxZmEwMTg1MTFlNw==", "commit": {"author": {"name": "Markus F.X.J. Oberhumer", "email": "markus@oberhumer.com", "date": "2004-01-12T03:55:43Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2004-01-12T03:55:43Z"}, "message": "re PR target/12148 (longstanding m68k libgcc.a bug when using ` -mshort')\n\n\tPR c/12148\n\t* config/m68k/fpgnulib.c: Fix `-mshort' bugs: Use `long' instead of\n\t`int' in a number of places to make sure we always have a SImode\n\tand not a HImode.  Add a 'L' suffix to a number of constants.\n\nFrom-SVN: r75703", "tree": {"sha": "8fdb709f78ef4f79c2fcc8f4f819dda5431b9bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fdb709f78ef4f79c2fcc8f4f819dda5431b9bc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48568ec72b76246c3cf964b52fbe91fa018511e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48568ec72b76246c3cf964b52fbe91fa018511e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48568ec72b76246c3cf964b52fbe91fa018511e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48568ec72b76246c3cf964b52fbe91fa018511e7/comments", "author": {"login": "markus-oberhumer", "id": 2130496, "node_id": "MDQ6VXNlcjIxMzA0OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/2130496?v=4", "gravatar_id": "", "url": "https://api.github.com/users/markus-oberhumer", "html_url": "https://github.com/markus-oberhumer", "followers_url": "https://api.github.com/users/markus-oberhumer/followers", "following_url": "https://api.github.com/users/markus-oberhumer/following{/other_user}", "gists_url": "https://api.github.com/users/markus-oberhumer/gists{/gist_id}", "starred_url": "https://api.github.com/users/markus-oberhumer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/markus-oberhumer/subscriptions", "organizations_url": "https://api.github.com/users/markus-oberhumer/orgs", "repos_url": "https://api.github.com/users/markus-oberhumer/repos", "events_url": "https://api.github.com/users/markus-oberhumer/events{/privacy}", "received_events_url": "https://api.github.com/users/markus-oberhumer/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "124c9423a1f0326dcda66539ed507f6078157061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124c9423a1f0326dcda66539ed507f6078157061", "html_url": "https://github.com/Rust-GCC/gccrs/commit/124c9423a1f0326dcda66539ed507f6078157061"}], "stats": {"total": 47, "additions": 27, "deletions": 20}, "files": [{"sha": "a79c36e065a2f1f28f644113987806dbcaa7994e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48568ec72b76246c3cf964b52fbe91fa018511e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48568ec72b76246c3cf964b52fbe91fa018511e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48568ec72b76246c3cf964b52fbe91fa018511e7", "patch": "@@ -1,3 +1,10 @@\n+2004-01-12  Markus F.X.J. Oberhumer  <markus@oberhumer.com>\n+\n+\tPR c/12148\n+\t* config/m68k/fpgnulib.c: Fix `-mshort' bugs: Use `long' instead of\n+\t`int' in a number of places to make sure we always have a SImode\n+\tand not a HImode.  Add a 'L' suffix to a number of constants.\n+\n 2004-01-11  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa.c: Don't include obstack.h."}, {"sha": "5368559d4dde64c9a7256147b18bedde72084d2f", "filename": "gcc/config/m68k/fpgnulib.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48568ec72b76246c3cf964b52fbe91fa018511e7/gcc%2Fconfig%2Fm68k%2Ffpgnulib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48568ec72b76246c3cf964b52fbe91fa018511e7/gcc%2Fconfig%2Fm68k%2Ffpgnulib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ffpgnulib.c?ref=48568ec72b76246c3cf964b52fbe91fa018511e7", "patch": "@@ -59,24 +59,24 @@\n #define PACK(s,e,m)\t((s) | ((e) << 23L) | (m))\n \n /* the following deal with IEEE double-precision numbers */\n-#define EXCESSD\t\t1022\n+#define EXCESSD\t\t1022L\n #define HIDDEND\t\t(1L << 20L)\n #define EXPDBITS\t11\n-#define EXPDMASK\t0x7FF\n+#define EXPDMASK\t0x7FFL\n #define EXPD(fp)\t(((fp.l.upper) >> 20L) & 0x7FFL)\n #define SIGND(fp)\t((fp.l.upper) & SIGNBIT)\n #define MANTD(fp)\t(((((fp.l.upper) & 0xFFFFF) | HIDDEND) << 10) | \\\n \t\t\t\t(fp.l.lower >> 22))\n-#define MANTDMASK\t0xFFFFF /* mask of upper part */\n+#define MANTDMASK\t0xFFFFFL /* mask of upper part */\n \n /* the following deal with IEEE extended-precision numbers */\n-#define EXCESSX\t\t16382\n+#define EXCESSX\t\t16382L\n #define HIDDENX\t\t(1L << 31L)\n #define EXPXBITS\t15\n #define EXPXMASK\t0x7FFF\n #define EXPX(fp)\t(((fp.l.upper) >> 16) & EXPXMASK)\n #define SIGNX(fp)\t((fp.l.upper) & SIGNBIT)\n-#define MANTXMASK\t0x7FFFFFFF /* mask of upper part */\n+#define MANTXMASK\t0x7FFFFFFFL /* mask of upper part */\n \n union double_long \n {\n@@ -107,7 +107,7 @@ union long_double_long\n \n /* convert int to double */\n double\n-__floatsidf (int a1)\n+__floatsidf (long a1)\n {\n   long sign = 0, exp = 31 + EXCESSD;\n   union double_long dl;\n@@ -130,13 +130,13 @@ __floatsidf (int a1)\n         }\n     }\n \n-  while (a1 < 0x1000000)\n+  while (a1 < 0x1000000L)\n     {\n       a1 <<= 4;\n       exp -= 4;\n     }\n \n-  while (a1 < 0x40000000)\n+  while (a1 < 0x40000000L)\n     {\n       a1 <<= 1;\n       exp--;\n@@ -153,7 +153,7 @@ __floatsidf (int a1)\n \n /* convert int to float */\n float\n-__floatsisf (int l)\n+__floatsisf (long l)\n {\n   double foo = __floatsidf (l);\n   return foo;\n@@ -208,7 +208,7 @@ __truncdfsf2 (double a1)\n   mant >>= 1;\n \n   /* did the round overflow? */\n-  if (mant & 0xFF000000)\n+  if (mant & 0xFF000000L)\n     {\n       mant >>= 1;\n       exp++;\n@@ -222,7 +222,7 @@ __truncdfsf2 (double a1)\n }\n \n /* convert double to int */\n-int\n+long\n __fixdfsi (double a1)\n {\n   register union double_long dl1;\n@@ -240,7 +240,7 @@ __fixdfsi (double a1)\n   if (exp > 0) \n     {\n       /* Return largest integer.  */\n-      return SIGND (dl1) ? 0x80000000 : 0x7fffffff;\n+      return SIGND (dl1) ? 0x80000000L : 0x7fffffffL;\n     }\n \n   if (exp <= -32)\n@@ -254,7 +254,7 @@ __fixdfsi (double a1)\n }\n \n /* convert float to int */\n-int\n+long\n __fixsfsi (float a1)\n {\n   double foo = a1;\n@@ -268,12 +268,12 @@ __fixsfsi (float a1)\n    We assume all numbers are normalized, don't do any rounding, etc.  */\n \n /* Prototypes for the above in case we use them.  */\n-double __floatsidf (int);\n-float __floatsisf (int);\n+double __floatsidf (long);\n+float __floatsisf (long);\n double __extendsfdf2 (float);\n float __truncdfsf2 (double);\n-int __fixdfsi (double);\n-int __fixsfsi (float);\n+long __fixdfsi (double);\n+long __fixsfsi (float);\n \n /* convert double to long double */\n long double\n@@ -351,17 +351,17 @@ __truncxfsf2 (long double ld)\n \n /* convert an int to a long double */\n long double\n-__floatsixf (int l)\n+__floatsixf (long l)\n {\n   double foo = __floatsidf (l);\n   return foo;\n }\n \n /* convert a long double to an int */\n-int\n+long\n __fixxfsi (long double ld)\n {\n-  int foo = __fixdfsi ((double) ld);\n+  long foo = __fixdfsi ((double) ld);\n   return foo;\n }\n "}]}