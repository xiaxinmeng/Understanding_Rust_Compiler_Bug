{"sha": "078fe40a489e7a4f62553feab15288066906d146", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc4ZmU0MGE0ODllN2E0ZjYyNTUzZmVhYjE1Mjg4MDY2OTA2ZDE0Ng==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-01-19T14:14:56Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2016-01-19T14:14:56Z"}, "message": "[PATCH 4/4] Add CCMP selection based on rtx costs\n\n    2015-01-19  Wilco Dijkstra  <wdijkstr@arm.com>\n\t\tJiong Wang  <jiong.wang@arm.com>\n\n    gcc/\n\t* ccmp.c (expand_ccmp_expr_1): Cost the instruction sequences\n\tgenerated from different expand order.\n\n    gcc/testsuite/\n        * gcc.target/aarch64/ccmp_1.c: Add new tests.\n\n\nCo-Authored-By: Jiong Wang <jiong.wang@arm.com>\n\nFrom-SVN: r232565", "tree": {"sha": "8b9c7e2731d1acece79c506065da6b6bbed8eed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b9c7e2731d1acece79c506065da6b6bbed8eed0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/078fe40a489e7a4f62553feab15288066906d146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078fe40a489e7a4f62553feab15288066906d146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078fe40a489e7a4f62553feab15288066906d146", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078fe40a489e7a4f62553feab15288066906d146/comments", "author": null, "committer": null, "parents": [{"sha": "786298dc13355be8942ad82002d4c675e7255299", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786298dc13355be8942ad82002d4c675e7255299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/786298dc13355be8942ad82002d4c675e7255299"}], "stats": {"total": 92, "additions": 75, "deletions": 17}, "files": [{"sha": "de730d43807deed675a581c71996b51e261fbe4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078fe40a489e7a4f62553feab15288066906d146/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078fe40a489e7a4f62553feab15288066906d146/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=078fe40a489e7a4f62553feab15288066906d146", "patch": "@@ -1,4 +1,10 @@\n-2016-01-19  Wilco Dijkstra  <wdijkstr@arm.com>\n+2015-01-19  Wilco Dijkstra  <wdijkstr@arm.com>\n+\t    Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* ccmp.c (expand_ccmp_expr_1): Cost the instruction sequences\n+\tgenerated from different expand order.\n+\n+2015-01-19  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* /config/aarch64/aarch64.c (aarch64_if_then_else_costs):\n \tAdd support for CCMP costing."}, {"sha": "9e49d1e4e4a4c46ebb802596c83e2c5c37a7d499", "filename": "gcc/ccmp.c", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078fe40a489e7a4f62553feab15288066906d146/gcc%2Fccmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078fe40a489e7a4f62553feab15288066906d146/gcc%2Fccmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.c?ref=078fe40a489e7a4f62553feab15288066906d146", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-outof-ssa.h\"\n #include \"cfgexpand.h\"\n #include \"ccmp.h\"\n+#include \"predict.h\"\n \n /* The following functions expand conditional compare (CCMP) instructions.\n    Here is a short description about the over all algorithm:\n@@ -72,7 +73,7 @@ ccmp_candidate_p (gimple *g)\n   tree rhs = gimple_assign_rhs_to_tree (g);\n   tree lhs, op0, op1;\n   gimple *gs0, *gs1;\n-  enum tree_code tcode, tcode0, tcode1;\n+  tree_code tcode, tcode0, tcode1;\n   tcode = TREE_CODE (rhs);\n \n   if (tcode != BIT_AND_EXPR && tcode != BIT_IOR_EXPR)\n@@ -119,10 +120,10 @@ ccmp_candidate_p (gimple *g)\n    PREP_SEQ returns all insns to prepare opearands for compare.\n    GEN_SEQ returns all compare insns.  */\n static rtx\n-expand_ccmp_next (gimple *g, enum tree_code code, rtx prev,\n+expand_ccmp_next (gimple *g, tree_code code, rtx prev,\n \t\t  rtx *prep_seq, rtx *gen_seq)\n {\n-  enum rtx_code rcode;\n+  rtx_code rcode;\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (g)));\n \n   gcc_assert (code == BIT_AND_EXPR || code == BIT_IOR_EXPR);\n@@ -149,13 +150,15 @@ expand_ccmp_next (gimple *g, enum tree_code code, rtx prev,\n static rtx\n expand_ccmp_expr_1 (gimple *g, rtx *prep_seq, rtx *gen_seq)\n {\n+  rtx prep_seq_1, gen_seq_1;\n+  rtx prep_seq_2, gen_seq_2;\n   tree exp = gimple_assign_rhs_to_tree (g);\n-  enum tree_code code = TREE_CODE (exp);\n+  tree_code code = TREE_CODE (exp);\n   gimple *gs0 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 0));\n   gimple *gs1 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 1));\n   rtx tmp;\n-  enum tree_code code0 = gimple_assign_rhs_code (gs0);\n-  enum tree_code code1 = gimple_assign_rhs_code (gs1);\n+  tree_code code0 = gimple_assign_rhs_code (gs0);\n+  tree_code code1 = gimple_assign_rhs_code (gs1);\n \n   gcc_assert (code == BIT_AND_EXPR || code == BIT_IOR_EXPR);\n   gcc_assert (gs0 && gs1 && is_gimple_assign (gs0) && is_gimple_assign (gs1));\n@@ -164,19 +167,53 @@ expand_ccmp_expr_1 (gimple *g, rtx *prep_seq, rtx *gen_seq)\n     {\n       if (TREE_CODE_CLASS (code1) == tcc_comparison)\n \t{\n-\t  int unsignedp0;\n-\t  enum rtx_code rcode0;\n+\t  int unsignedp0, unsignedp1;\n+\t  rtx_code rcode0, rcode1;\n+\t  int speed_p = optimize_insn_for_speed_p ();\n+\t  rtx tmp2, ret, ret2;\n+\t  unsigned cost1 = MAX_COST;\n+\t  unsigned cost2 = MAX_COST;\n \n \t  unsignedp0 = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs0)));\n+\t  unsignedp1 = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs1)));\n \t  rcode0 = get_rtx_code (code0, unsignedp0);\n+\t  rcode1 = get_rtx_code (code1, unsignedp1);\n \n-\t  tmp = targetm.gen_ccmp_first (prep_seq, gen_seq, rcode0,\n+\t  tmp = targetm.gen_ccmp_first (&prep_seq_1, &gen_seq_1, rcode0,\n \t\t\t\t\tgimple_assign_rhs1 (gs0),\n \t\t\t\t\tgimple_assign_rhs2 (gs0));\n-\t  if (!tmp)\n+\n+\t  tmp2 = targetm.gen_ccmp_first (&prep_seq_2, &gen_seq_2, rcode1,\n+\t\t\t\t\t gimple_assign_rhs1 (gs1),\n+\t\t\t\t\t gimple_assign_rhs2 (gs1));\n+\n+\t  if (!tmp && !tmp2)\n \t    return NULL_RTX;\n \n-\t  return expand_ccmp_next (gs1, code, tmp, prep_seq, gen_seq);\n+\t  if (tmp != NULL)\n+\t    {\n+\t      ret = expand_ccmp_next (gs1, code, tmp, &prep_seq_1, &gen_seq_1);\n+\t      cost1 = seq_cost (safe_as_a <rtx_insn *> (prep_seq_1), speed_p);\n+\t      cost1 += seq_cost (safe_as_a <rtx_insn *> (gen_seq_1), speed_p);\n+\t    }\n+\t  if (tmp2 != NULL)\n+\t    {\n+\t      ret2 = expand_ccmp_next (gs0, code, tmp2, &prep_seq_2,\n+\t\t\t\t       &gen_seq_2);\n+\t      cost2 = seq_cost (safe_as_a <rtx_insn *> (prep_seq_2), speed_p);\n+\t      cost2 += seq_cost (safe_as_a <rtx_insn *> (gen_seq_2), speed_p);\n+\t    }\n+\n+\t  if (cost2 < cost1)\n+\t    {\n+\t      *prep_seq = prep_seq_2;\n+\t      *gen_seq = gen_seq_2;\n+\t      return ret2;\n+\t    }\n+\n+\t  *prep_seq = prep_seq_1;\n+\t  *gen_seq = gen_seq_1;\n+\t  return ret;\n \t}\n       else\n \t{\n@@ -230,8 +267,8 @@ expand_ccmp_expr (gimple *g)\n \n   if (tmp)\n     {\n-      enum insn_code icode;\n-      enum machine_mode cc_mode = CCmode;\n+      insn_code icode;\n+      machine_mode cc_mode = CCmode;\n       tree lhs = gimple_assign_lhs (g);\n       rtx_code cmp_code = GET_CODE (tmp);\n \n@@ -241,7 +278,7 @@ expand_ccmp_expr (gimple *g)\n       icode = optab_handler (cstore_optab, cc_mode);\n       if (icode != CODE_FOR_nothing)\n \t{\n-\t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+\t  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n \t  rtx target = gen_reg_rtx (mode);\n \n \t  emit_insn (prep_seq);"}, {"sha": "057dc1e9e88b741257b4646bc76e14611fc2ec5d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078fe40a489e7a4f62553feab15288066906d146/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078fe40a489e7a4f62553feab15288066906d146/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=078fe40a489e7a4f62553feab15288066906d146", "patch": "@@ -1,3 +1,7 @@\n+2015-01-19  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* gcc.target/aarch64/ccmp_1.c: Add new tests.\n+\n 2015-01-19  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* gcc.target/aarch64/ccmp_1.c: New testcase."}, {"sha": "7c39b61a585a1d4d662b0736e1c80e06bdc6b4ce", "filename": "gcc/testsuite/gcc.target/aarch64/ccmp_1.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078fe40a489e7a4f62553feab15288066906d146/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fccmp_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078fe40a489e7a4f62553feab15288066906d146/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fccmp_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fccmp_1.c?ref=078fe40a489e7a4f62553feab15288066906d146", "patch": "@@ -80,5 +80,16 @@ f13 (int a, int b)\n   return a == 3 || a == 0;\n }\n \n-/* { dg-final { scan-assembler \"fccmp\\t\" } } */\n-/* { dg-final { scan-assembler \"fccmpe\\t\" } } */\n+/* { dg-final { scan-assembler \"cmp\\t(.)+32\" } } */\n+/* { dg-final { scan-assembler \"cmp\\t(.)+33\" } } */\n+/* { dg-final { scan-assembler \"cmp\\t(.)+34\" } } */\n+/* { dg-final { scan-assembler \"cmp\\t(.)+35\" } } */\n+\n+/* { dg-final { scan-assembler-times \"\\tcmp\\tw\\[0-9\\]+, 0\" 4 } } */\n+/* { dg-final { scan-assembler-times \"fcmpe\\t(.)+0\\\\.0\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fcmp\\t(.)+0\\\\.0\" 2 } } */\n+\n+/* { dg-final { scan-assembler \"adds\\t\" } } */\n+/* { dg-final { scan-assembler-times \"\\tccmp\\t\" 11 } } */\n+/* { dg-final { scan-assembler-times \"fccmp\\t.*0\\\\.0\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fccmpe\\t.*0\\\\.0\" 1 } } */"}]}