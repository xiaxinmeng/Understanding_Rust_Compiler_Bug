{"sha": "11f5b71a765d329b8ace0cbeb568b6cb3d1549d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFmNWI3MWE3NjVkMzI5YjhhY2UwY2JlYjU2OGI2Y2IzZDE1NDlkMA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-06-19T23:57:22Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-06-19T23:57:22Z"}, "message": "re PR bootstrap/57604 (LRA related bootstrap comparison failure on s390x --with-arch=zEC12)\n\n2013-06-19  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR bootstrap/57604\n\t* lra.c (emit_add3_insn, emit_add2_insn): New functions.\n\t(lra_emit_add): Use the functions.  Add comment about Y as an\n\taddress segment.\n\nFrom-SVN: r200227", "tree": {"sha": "d16c37305ee09af444427a7dbfd27a40d88b4e34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d16c37305ee09af444427a7dbfd27a40d88b4e34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11f5b71a765d329b8ace0cbeb568b6cb3d1549d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f5b71a765d329b8ace0cbeb568b6cb3d1549d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f5b71a765d329b8ace0cbeb568b6cb3d1549d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f5b71a765d329b8ace0cbeb568b6cb3d1549d0/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1f9340b007679e863f99d26c29fd6ee2ddbd92e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f9340b007679e863f99d26c29fd6ee2ddbd92e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f9340b007679e863f99d26c29fd6ee2ddbd92e"}], "stats": {"total": 87, "additions": 64, "deletions": 23}, "files": [{"sha": "b0fa317f3c573c040514c83bdc53db8ae40cc2b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f5b71a765d329b8ace0cbeb568b6cb3d1549d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f5b71a765d329b8ace0cbeb568b6cb3d1549d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=11f5b71a765d329b8ace0cbeb568b6cb3d1549d0", "patch": "@@ -1,3 +1,10 @@\n+2013-06-19  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR bootstrap/57604\n+\t* lra.c (emit_add3_insn, emit_add2_insn): New functions.\n+\t(lra_emit_add): Use the functions.  Add comment about Y as an\n+\taddress segment.\n+\n 2013-06-19  David Edelsohn  <dje.gcc@gmail.com>\n \n \tPR driver/57652"}, {"sha": "6b505c508c37c273471b6847961b864c4b05f9ae", "filename": "gcc/lra.c", "status": "modified", "additions": 57, "deletions": 23, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f5b71a765d329b8ace0cbeb568b6cb3d1549d0/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f5b71a765d329b8ace0cbeb568b6cb3d1549d0/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=11f5b71a765d329b8ace0cbeb568b6cb3d1549d0", "patch": "@@ -242,6 +242,42 @@ lra_delete_dead_insn (rtx insn)\n   lra_set_insn_deleted (insn);\n }\n \n+/* Emit insn x = y + z.  Return NULL if we failed to do it.\n+   Otherwise, return the insn.  We don't use gen_add3_insn as it might\n+   clobber CC.  */\n+static rtx\n+emit_add3_insn (rtx x, rtx y, rtx z)\n+{\n+  rtx insn, last;\n+\n+  last = get_last_insn ();\n+  insn = emit_insn (gen_rtx_SET (VOIDmode, x,\n+\t\t\t\t gen_rtx_PLUS (GET_MODE (y), y, z)));\n+  if (recog_memoized (insn) < 0)\n+    {\n+      delete_insns_since (last);\n+      insn = NULL_RTX;\n+    }\n+  return insn;\n+}\n+\n+/* Emit insn x = x + y.  Return the insn.  We use gen_add2_insn as the\n+   last resort.  */\n+static rtx\n+emit_add2_insn (rtx x, rtx y)\n+{\n+  rtx insn;\n+\n+  insn = emit_add3_insn (x, x, y);\n+  if (insn == NULL_RTX)\n+    {\n+      insn = gen_add2_insn (x, y);\n+      if (insn != NULL_RTX)\n+\temit_insn (insn);\n+    }\n+  return insn;\n+}\n+\n /* Target checks operands through operand predicates to recognize an\n    insn.  We should have a special precaution to generate add insns\n    which are frequent results of elimination.\n@@ -260,10 +296,10 @@ lra_emit_add (rtx x, rtx y, rtx z)\n   rtx a1, a2, base, index, disp, scale, index_scale;\n   bool ok_p;\n \n-  insn = gen_add3_insn (x, y, z);\n+  insn = emit_add3_insn (x, y, z);\n   old = max_reg_num ();\n   if (insn != NULL_RTX)\n-    emit_insn (insn);\n+    ;\n   else\n     {\n       disp = a2 = NULL_RTX;\n@@ -306,12 +342,14 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t  || (disp != NULL_RTX && ! CONSTANT_P (disp))\n \t  || (scale != NULL_RTX && ! CONSTANT_P (scale)))\n \t{\n-\t  /* It is not an address generation.\tProbably we have no 3 op\n-\t     add.  Last chance is to use 2-op add insn.\t */\n+\t  /* Probably we have no 3 op add.  Last chance is to use 2-op\n+\t     add insn.  To succeed, don't move Z to X as an address\n+\t     segment always comes in Y.  Otherwise, we might fail when\n+\t     adding the address segment to register.  */\n \t  lra_assert (x != y && x != z);\n \t  emit_move_insn (x, y);\n-\t  insn = gen_add2_insn (x, z);\n-\t  emit_insn (insn);\n+\t  insn = emit_add2_insn (x, z);\n+\t  lra_assert (insn != NULL_RTX);\n \t}\n       else\n \t{\n@@ -322,8 +360,8 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t      /* Generate x = index_scale; x = x + base.  */\n \t      lra_assert (index_scale != NULL_RTX && base != NULL_RTX);\n \t      emit_move_insn (x, index_scale);\n-\t      insn = gen_add2_insn (x, base);\n-\t      emit_insn (insn);\n+\t      insn = emit_add2_insn (x, base);\n+\t      lra_assert (insn != NULL_RTX);\n \t    }\n \t  else if (scale == NULL_RTX)\n \t    {\n@@ -337,14 +375,14 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t\t  delete_insns_since (last);\n \t\t  /* Generate x = disp; x = x + base.  */\n \t\t  emit_move_insn (x, disp);\n-\t\t  insn = gen_add2_insn (x, base);\n-\t\t  emit_insn (insn);\n+\t\t  insn = emit_add2_insn (x, base);\n+\t\t  lra_assert (insn != NULL_RTX);\n \t\t}\n \t      /* Generate x = x + index.  */\n \t      if (index != NULL_RTX)\n \t\t{\n-\t\t  insn = gen_add2_insn (x, index);\n-\t\t  emit_insn (insn);\n+\t\t  insn = emit_add2_insn (x, index);\n+\t\t  lra_assert (insn != NULL_RTX);\n \t\t}\n \t    }\n \t  else\n@@ -355,27 +393,23 @@ lra_emit_add (rtx x, rtx y, rtx z)\n \t      ok_p = false;\n \t      if (recog_memoized (insn) >= 0)\n \t\t{\n-\t\t  insn = gen_add2_insn (x, disp);\n+\t\t  insn = emit_add2_insn (x, disp);\n \t\t  if (insn != NULL_RTX)\n \t\t    {\n-\t\t      emit_insn (insn);\n-\t\t      insn = gen_add2_insn (x, disp);\n+\t\t      insn = emit_add2_insn (x, disp);\n \t\t      if (insn != NULL_RTX)\n-\t\t\t{\n-\t\t\t  emit_insn (insn);\n-\t\t\t  ok_p = true;\n-\t\t\t}\n+\t\t\tok_p = true;\n \t\t    }\n \t\t}\n \t      if (! ok_p)\n \t\t{\n \t\t  delete_insns_since (last);\n \t\t  /* Generate x = disp; x = x + base; x = x + index_scale.  */\n \t\t  emit_move_insn (x, disp);\n-\t\t  insn = gen_add2_insn (x, base);\n-\t\t  emit_insn (insn);\n-\t\t  insn = gen_add2_insn (x, index_scale);\n-\t\t  emit_insn (insn);\n+\t\t  insn = emit_add2_insn (x, base);\n+\t\t  lra_assert (insn != NULL_RTX);\n+\t\t  insn = emit_add2_insn (x, index_scale);\n+\t\t  lra_assert (insn != NULL_RTX);\n \t\t}\n \t    }\n \t}"}]}