{"sha": "7d0aa05b9ead1b114958d8230377c2c25ef54876", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QwYWEwNWI5ZWFkMWIxMTQ5NThkODIzMDM3N2MyYzI1ZWY1NDg3Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-08-07T20:58:17Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-08-07T20:58:17Z"}, "message": "ipa-devirt.c: Include gimple-pretty-print.h\n\n\n\t* ipa-devirt.c: Include gimple-pretty-print.h\n\t(referenced_from_vtable_p): Exclude DECL_EXTERNAL from\n\tfurther tests.\n\t(decl_maybe_in_construction_p): Fix conditional on cdtor check\n\t(get_polymorphic_call_info): Fix return value\n\t(type_change_info): New sturcture based on ipa-prop\n\tvariant.\n\t(noncall_stmt_may_be_vtbl_ptr_store): New predicate\n\tbased on ipa-prop variant.\n\t(extr_type_from_vtbl_ptr_store): New function\n\tbased on ipa-prop variant.\n\t(record_known_type): New function.\n\t(check_stmt_for_type_change): New function.\n\t(get_dynamic_type): New function.\n\t* ipa-prop.c (ipa_analyze_call_uses): Use get_dynamic_type.\n\t* tree-ssa-pre.c: ipa-utils.h\n\t(eliminate_dom_walker::before_dom_children): Use ipa-devirt\n\tmachinery; sanity check with ipa-prop devirtualization.\n\t* trans-mem.c (ipa_tm_insert_gettmclone_call): Clear\n\tpolymorphic flag.\n\n\t* g++.dg/ipa/devirt-35.C: New testcase.\n\t* g++.dg/ipa/devirt-36.C: New testcase.\n\nFrom-SVN: r213739", "tree": {"sha": "3358c76f8c1af0e9fe0b8b19fef9b3fe6f0935ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3358c76f8c1af0e9fe0b8b19fef9b3fe6f0935ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d0aa05b9ead1b114958d8230377c2c25ef54876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d0aa05b9ead1b114958d8230377c2c25ef54876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d0aa05b9ead1b114958d8230377c2c25ef54876", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d0aa05b9ead1b114958d8230377c2c25ef54876/comments", "author": null, "committer": null, "parents": [{"sha": "9f25a338f91f9c448d57681b6d17a91233222d43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f25a338f91f9c448d57681b6d17a91233222d43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f25a338f91f9c448d57681b6d17a91233222d43"}], "stats": {"total": 685, "additions": 673, "deletions": 12}, "files": [{"sha": "beee78f21afe058ebaac513a29ef1f9e6edf2104", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d0aa05b9ead1b114958d8230377c2c25ef54876", "patch": "@@ -1,3 +1,26 @@\n+2014-08-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c: Include gimple-pretty-print.h\n+\t(referenced_from_vtable_p): Exclude DECL_EXTERNAL from\n+\tfurther tests.\n+\t(decl_maybe_in_construction_p): Fix conditional on cdtor check\n+\t(get_polymorphic_call_info): Fix return value\n+\t(type_change_info): New sturcture based on ipa-prop\n+\tvariant.\n+\t(noncall_stmt_may_be_vtbl_ptr_store): New predicate\n+\tbased on ipa-prop variant.\n+\t(extr_type_from_vtbl_ptr_store): New function\n+\tbased on ipa-prop variant.\n+\t(record_known_type): New function.\n+\t(check_stmt_for_type_change): New function.\n+\t(get_dynamic_type): New function.\n+\t* ipa-prop.c (ipa_analyze_call_uses): Use get_dynamic_type.\n+\t* tree-ssa-pre.c: ipa-utils.h\n+\t(eliminate_dom_walker::before_dom_children): Use ipa-devirt\n+\tmachinery; sanity check with ipa-prop devirtualization.\n+\t* trans-mem.c (ipa_tm_insert_gettmclone_call): Clear\n+\tpolymorphic flag.\n+\n 2014-08-07  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* Makefile.in: Remove references to pointer-set.c and pointer-set.h."}, {"sha": "8827d0ecb523db8b585a2074896cac75829dd8c9", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 521, "deletions": 6, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=7d0aa05b9ead1b114958d8230377c2c25ef54876", "patch": "@@ -131,6 +131,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"demangle.h\"\n #include \"dbgcnt.h\"\n+#include \"gimple-pretty-print.h\"\n #include \"stor-layout.h\"\n #include \"intl.h\"\n #include \"hash-map.h\"\n@@ -1323,6 +1324,7 @@ referenced_from_vtable_p (struct cgraph_node *node)\n   bool found = false;\n \n   if (node->externally_visible\n+      || DECL_EXTERNAL (node->decl)\n       || node->used_from_other_partition)\n     return true;\n \n@@ -2113,7 +2115,7 @@ decl_maybe_in_construction_p (tree base, tree outer_type,\n \n \tif (TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE\n \t    || (!DECL_CXX_CONSTRUCTOR_P (fn)\n-\t\t|| !DECL_CXX_DESTRUCTOR_P (fn)))\n+\t\t&& !DECL_CXX_DESTRUCTOR_P (fn)))\n \t  {\n \t    /* Watch for clones where we constant propagated the first\n \t       argument (pointer to the instance).  */\n@@ -2122,7 +2124,7 @@ decl_maybe_in_construction_p (tree base, tree outer_type,\n \t\t|| !is_global_var (base)\n \t        || TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE\n \t\t|| (!DECL_CXX_CONSTRUCTOR_P (fn)\n-\t\t    || !DECL_CXX_DESTRUCTOR_P (fn)))\n+\t\t    && !DECL_CXX_DESTRUCTOR_P (fn)))\n \t      continue;\n \t  }\n \tif (flags_from_decl_or_type (fn) & (ECF_PURE | ECF_CONST))\n@@ -2142,7 +2144,7 @@ decl_maybe_in_construction_p (tree base, tree outer_type,\n     {\n       if (TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE\n \t  || (!DECL_CXX_CONSTRUCTOR_P (function)\n-\t      || !DECL_CXX_DESTRUCTOR_P (function)))\n+\t      && !DECL_CXX_DESTRUCTOR_P (function)))\n \t{\n \t  if (!DECL_ABSTRACT_ORIGIN (function))\n \t    return false;\n@@ -2152,7 +2154,7 @@ decl_maybe_in_construction_p (tree base, tree outer_type,\n \t  if (!function\n \t      || TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE\n \t      || (!DECL_CXX_CONSTRUCTOR_P (function)\n-\t\t  || !DECL_CXX_DESTRUCTOR_P (function)))\n+\t\t  && !DECL_CXX_DESTRUCTOR_P (function)))\n \t    return false;\n \t}\n       /* FIXME: this can go away once we have ODR types equivalency on\n@@ -2243,7 +2245,8 @@ walk_ssa_copies (tree op)\n    call (OTR_TYPE), its token (OTR_TOKEN) and CONTEXT.\n    CALL is optional argument giving the actual statement (usually call) where\n    the context is used.\n-   Return pointer to object described by the context  */\n+   Return pointer to object described by the context or an declaration if\n+   we found the instance to be stored in the static storage.  */\n \n tree\n get_polymorphic_call_info (tree fndecl,\n@@ -2317,7 +2320,7 @@ get_polymorphic_call_info (tree fndecl,\n \t\t\t\t\t\t     context->outer_type,\n \t\t\t\t\t\t     call,\n \t\t\t\t\t\t     current_function_decl);\n-\t\t  return base_pointer;\n+\t\t  return base;\n \t\t}\n \t      else\n \t\tbreak;\n@@ -2436,6 +2439,515 @@ get_polymorphic_call_info (tree fndecl,\n   return base_pointer;\n }\n \n+/* Structure to be passed in between detect_type_change and\n+   check_stmt_for_type_change.  */\n+\n+struct type_change_info\n+{\n+  /* Offset into the object where there is the virtual method pointer we are\n+     looking for.  */\n+  HOST_WIDE_INT offset;\n+  /* The declaration or SSA_NAME pointer of the base that we are checking for\n+     type change.  */\n+  tree instance;\n+  /* The reference to virtual table pointer used.  */\n+  tree vtbl_ptr_ref;\n+  tree otr_type;\n+  /* If we actually can tell the type that the object has changed to, it is\n+     stored in this field.  Otherwise it remains NULL_TREE.  */\n+  tree known_current_type;\n+  HOST_WIDE_INT known_current_offset;\n+\n+  /* Set to true if dynamic type change has been detected.  */\n+  bool type_maybe_changed;\n+  /* Set to true if multiple types have been encountered.  known_current_type\n+     must be disregarded in that case.  */\n+  bool multiple_types_encountered;\n+  /* Set to true if we possibly missed some dynamic type changes and we should\n+     consider the set to be speculative.  */\n+  bool speculative;\n+  bool seen_unanalyzed_store;\n+};\n+\n+/* Return true if STMT is not call and can modify a virtual method table pointer.\n+   We take advantage of fact that vtable stores must appear within constructor\n+   and destructor functions.  */\n+\n+bool\n+noncall_stmt_may_be_vtbl_ptr_store (gimple stmt)\n+{\n+  if (is_gimple_assign (stmt))\n+    {\n+      tree lhs = gimple_assign_lhs (stmt);\n+\n+      if (gimple_clobber_p (stmt))\n+\treturn false;\n+      if (!AGGREGATE_TYPE_P (TREE_TYPE (lhs)))\n+\t{\n+\t  if (flag_strict_aliasing\n+\t      && !POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t    return false;\n+\n+\t  if (TREE_CODE (lhs) == COMPONENT_REF\n+\t      && !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1)))\n+\t    return false;\n+\t  /* In the future we might want to use get_base_ref_and_offset to find\n+\t     if there is a field corresponding to the offset and if so, proceed\n+\t     almost like if it was a component ref.  */\n+\t}\n+    }\n+\n+  /* Code unification may mess with inline stacks.  */\n+  if (cfun->after_inlining)\n+    return true;\n+\n+  /* Walk the inline stack and watch out for ctors/dtors.\n+     TODO: Maybe we can require the store to appear in toplevel\n+     block of CTOR/DTOR.  */\n+  for (tree block = gimple_block (stmt); block && TREE_CODE (block) == BLOCK;\n+       block = BLOCK_SUPERCONTEXT (block))\n+    if (BLOCK_ABSTRACT_ORIGIN (block)\n+\t&& TREE_CODE (BLOCK_ABSTRACT_ORIGIN (block)) == FUNCTION_DECL)\n+      {\n+\ttree fn = BLOCK_ABSTRACT_ORIGIN (block);\n+\n+\tif (flags_from_decl_or_type (fn) & (ECF_PURE | ECF_CONST))\n+\t  return false;\n+\treturn (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n+\t\t&& (DECL_CXX_CONSTRUCTOR_P (fn)\n+\t\t    || DECL_CXX_DESTRUCTOR_P (fn)));\n+      }\n+  return (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE\n+\t  && (DECL_CXX_CONSTRUCTOR_P (current_function_decl)\n+\t      || DECL_CXX_DESTRUCTOR_P (current_function_decl)));\n+}\n+\n+/* If STMT can be proved to be an assignment to the virtual method table\n+   pointer of ANALYZED_OBJ and the type associated with the new table\n+   identified, return the type.  Otherwise return NULL_TREE.  */\n+\n+static tree\n+extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci,\n+\t\t\t       HOST_WIDE_INT *type_offset)\n+{\n+  HOST_WIDE_INT offset, size, max_size;\n+  tree lhs, rhs, base, binfo;\n+\n+  if (!gimple_assign_single_p (stmt))\n+    return NULL_TREE;\n+\n+  lhs = gimple_assign_lhs (stmt);\n+  rhs = gimple_assign_rhs1 (stmt);\n+  if (TREE_CODE (lhs) != COMPONENT_REF\n+      || !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1)))\n+    return NULL_TREE;\n+\n+  if (tci->vtbl_ptr_ref && operand_equal_p (lhs, tci->vtbl_ptr_ref, 0))\n+    ;\n+  else\n+    {\n+      base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n+      if (offset != tci->offset\n+\t  || size != POINTER_SIZE\n+\t  || max_size != POINTER_SIZE)\n+\treturn NULL_TREE;\n+      if (DECL_P (tci->instance))\n+\t{\n+\t  if (base != tci->instance)\n+\t    return NULL_TREE;\n+\t}\n+      else if (TREE_CODE (base) == MEM_REF)\n+\t{\n+\t  if (!operand_equal_p (tci->instance, TREE_OPERAND (base, 0), 0)\n+\t      || !integer_zerop (TREE_OPERAND (base, 1)))\n+\t    return NULL_TREE;\n+\t}\n+      else if (!operand_equal_p (tci->instance, base, 0)\n+\t       || tci->offset)\n+\treturn NULL_TREE;\n+    }\n+\n+  binfo = vtable_pointer_value_to_binfo (rhs);\n+\n+  if (!binfo)\n+    return NULL;\n+  *type_offset = tree_to_shwi (BINFO_OFFSET (binfo)) * BITS_PER_UNIT;\n+  if (TYPE_BINFO (BINFO_TYPE (binfo)) == binfo)\n+    return BINFO_TYPE (binfo);\n+\n+  /* TODO: Figure out the type containing BINFO.  */\n+  return NULL;\n+}\n+\n+/* Record dynamic type change of TCI to TYPE.  */\n+\n+void\n+record_known_type (struct type_change_info *tci, tree type, HOST_WIDE_INT offset)\n+{\n+  if (dump_file)\n+    {\n+      if (type)\n+\t{\n+          fprintf (dump_file, \"  Recording type: \");\n+\t  print_generic_expr (dump_file, type, TDF_SLIM);\n+          fprintf (dump_file, \" at offset %i\\n\", (int)offset);\n+\t}\n+     else\n+       fprintf (dump_file, \"  Recording unknown type\\n\");\n+    }\n+  if (tci->type_maybe_changed\n+      && (type != tci->known_current_type\n+\t  || offset != tci->known_current_offset))\n+    tci->multiple_types_encountered = true;\n+  tci->known_current_type = type;\n+  tci->known_current_offset = offset;\n+  tci->type_maybe_changed = true;\n+}\n+\n+/* Callback of walk_aliased_vdefs and a helper function for\n+   detect_type_change to check whether a particular statement may modify\n+   the virtual table pointer, and if possible also determine the new type of\n+   the (sub-)object.  It stores its result into DATA, which points to a\n+   type_change_info structure.  */\n+\n+static bool\n+check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n+{\n+  gimple stmt = SSA_NAME_DEF_STMT (vdef);\n+  struct type_change_info *tci = (struct type_change_info *) data;\n+  tree fn;\n+\n+  /* If we already gave up, just terminate the rest of walk.  */\n+  if (tci->multiple_types_encountered)\n+    return true;\n+\n+  if (is_gimple_call (stmt))\n+    {\n+      if (gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE))\n+\treturn false;\n+\n+      /* Check for a constructor call.  */\n+      if ((fn = gimple_call_fndecl (stmt)) != NULL_TREE\n+\t  && DECL_CXX_CONSTRUCTOR_P (fn)\n+\t  && TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n+\t  && gimple_call_num_args (stmt))\n+      {\n+\ttree op = walk_ssa_copies (gimple_call_arg (stmt, 0));\n+\ttree type = method_class_type (TREE_TYPE (fn));\n+\tHOST_WIDE_INT offset = 0, size, max_size;\n+\n+\tif (dump_file)\n+\t  {\n+\t    fprintf (dump_file, \"  Checking constructor call: \");\n+\t    print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t  }\n+\n+\t/* See if THIS parameter seems like instance pointer.  */\n+\tif (TREE_CODE (op) == ADDR_EXPR)\n+\t  {\n+\t    op = get_ref_base_and_extent (TREE_OPERAND (op, 0),\n+\t\t\t\t\t  &offset, &size, &max_size);\n+\t    if (size != max_size || max_size == -1)\n+\t      {\n+                tci->speculative = true;\n+\t        return false;\n+\t      }\n+\t    if (op && TREE_CODE (op) == MEM_REF)\n+\t      {\n+\t\tif (!tree_fits_shwi_p (TREE_OPERAND (op, 1)))\n+\t\t  {\n+                    tci->speculative = true;\n+\t\t    return false;\n+\t\t  }\n+\t\toffset += tree_to_shwi (TREE_OPERAND (op, 1))\n+\t\t\t  * BITS_PER_UNIT;\n+\t\top = TREE_OPERAND (op, 0);\n+\t      }\n+\t    else\n+\t      {\n+                tci->speculative = true;\n+\t        return false;\n+\t      }\n+\t    op = walk_ssa_copies (op);\n+\t  }\n+\tif (operand_equal_p (op, tci->instance, 0)\n+\t    && TYPE_SIZE (type)\n+\t    && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t    && tree_fits_shwi_p (TYPE_SIZE (type))\n+\t    && tree_to_shwi (TYPE_SIZE (type)) + offset > tci->offset)\n+\t  {\n+\t    record_known_type (tci, type, tci->offset - offset);\n+\t    return true;\n+\t  }\n+      }\n+     /* Calls may possibly change dynamic type by placement new. Assume\n+        it will not happen, but make result speculative only.  */\n+     if (dump_file)\n+\t{\n+          fprintf (dump_file, \"  Function call may change dynamic type:\");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t}\n+     tci->speculative = true;\n+     return false;\n+   }\n+  /* Check for inlined virtual table store.  */\n+  else if (noncall_stmt_may_be_vtbl_ptr_store (stmt))\n+    {\n+      tree type;\n+      HOST_WIDE_INT offset = 0;\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"  Checking vtbl store: \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t}\n+\n+      type = extr_type_from_vtbl_ptr_store (stmt, tci, &offset);\n+      gcc_assert (!type || TYPE_MAIN_VARIANT (type) == type);\n+      if (!type)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Unanalyzed store may change type.\\n\");\n+\t  tci->seen_unanalyzed_store = true;\n+\t  tci->speculative = true;\n+\t}\n+      else\n+        record_known_type (tci, type, offset);\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* CONTEXT is polymorphic call context obtained from get_polymorphic_context.\n+   OTR_OBJECT is pointer to the instance returned by OBJ_TYPE_REF_OBJECT.\n+   INSTANCE is pointer to the outer instance as returned by\n+   get_polymorphic_context.  To avoid creation of temporary expressions,\n+   INSTANCE may also be an declaration of get_polymorphic_context found the\n+   value to be in static storage.\n+\n+   If the type of instance is not fully determined\n+   (either OUTER_TYPE is unknown or MAYBE_IN_CONSTRUCTION/INCLUDE_DERIVED_TYPES\n+   is set), try to walk memory writes and find the actual construction of the\n+   instance.\n+\n+   We do not include this analysis in the context analysis itself, because\n+   it needs memory SSA to be fully built and the walk may be expensive.\n+   So it is not suitable for use withing fold_stmt and similar uses.  */\n+\n+bool\n+get_dynamic_type (tree instance,\n+\t\t  ipa_polymorphic_call_context *context,\n+\t\t  tree otr_object,\n+\t\t  tree otr_type,\n+\t\t  gimple call)\n+{\n+  struct type_change_info tci;\n+  ao_ref ao;\n+  bool function_entry_reached = false;\n+  tree instance_ref = NULL;\n+  gimple stmt = call;\n+\n+  if (!context->maybe_in_construction && !context->maybe_derived_type)\n+    return false;\n+\n+  /* We need to obtain refernce to virtual table pointer.  It is better\n+     to look it up in the code rather than build our own.  This require bit\n+     of pattern matching, but we end up verifying that what we found is\n+     correct. \n+\n+     What we pattern match is:\n+\n+       tmp = instance->_vptr.A;   // vtbl ptr load\n+       tmp2 = tmp[otr_token];\t  // vtable lookup\n+       OBJ_TYPE_REF(tmp2;instance->0) (instance);\n+ \n+     We want to start alias oracle walk from vtbl pointer load,\n+     but we may not be able to identify it, for example, when PRE moved the\n+     load around.  */\n+\n+  if (gimple_code (call) == GIMPLE_CALL)\n+    {\n+      tree ref = gimple_call_fn (call);\n+      HOST_WIDE_INT offset2, size, max_size;\n+\n+      if (TREE_CODE (ref) == OBJ_TYPE_REF)\n+\t{\n+\t  ref = OBJ_TYPE_REF_EXPR (ref);\n+\t  ref = walk_ssa_copies (ref);\n+\n+\t  /* Check if definition looks like vtable lookup.  */\n+\t  if (TREE_CODE (ref) == SSA_NAME\n+\t      && !SSA_NAME_IS_DEFAULT_DEF (ref)\n+\t      && gimple_assign_load_p (SSA_NAME_DEF_STMT (ref))\n+\t      && TREE_CODE (gimple_assign_rhs1\n+\t\t\t     (SSA_NAME_DEF_STMT (ref))) == MEM_REF)\n+\t    {\n+\t      ref = get_base_address\n+\t\t     (TREE_OPERAND (gimple_assign_rhs1\n+\t\t\t\t     (SSA_NAME_DEF_STMT (ref)), 0));\n+\t      ref = walk_ssa_copies (ref);\n+\t      /* Find base address of the lookup and see if it looks like\n+\t\t vptr load.  */\n+\t      if (TREE_CODE (ref) == SSA_NAME\n+\t\t  && !SSA_NAME_IS_DEFAULT_DEF (ref)\n+\t\t  && gimple_assign_load_p (SSA_NAME_DEF_STMT (ref)))\n+\t\t{\n+\t\t  tree ref_exp = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (ref));\n+\t\t  tree base_ref = get_ref_base_and_extent\n+\t\t\t\t   (ref_exp, &offset2, &size, &max_size);\n+\n+\t\t  /* Finally verify that what we found looks like read from OTR_OBJECT\n+\t\t     or from INSTANCE with offset OFFSET.  */\n+\t\t  if (base_ref\n+\t\t      && TREE_CODE (base_ref) == MEM_REF\n+\t\t      && ((offset2 == context->offset\n+\t\t           && TREE_OPERAND (base_ref, 0) == instance)\n+\t\t\t  || (!offset2 && TREE_OPERAND (base_ref, 0) == otr_object)))\n+\t\t    {\n+\t\t      stmt = SSA_NAME_DEF_STMT (ref);\n+\t\t      instance_ref = ref_exp;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+ \n+  /* If we failed to look up the refernece in code, build our own.  */\n+  if (!instance_ref)\n+    {\n+      /* If the statement in question does not use memory, we can't tell\n+\t anything.  */\n+      if (!gimple_vuse (stmt))\n+\treturn false;\n+      ao_ref_init_from_ptr_and_size (&ao, otr_object, NULL);\n+    }\n+  else\n+  /* Otherwise use the real reference.  */\n+    ao_ref_init (&ao, instance_ref);\n+\n+  /* We look for vtbl pointer read.  */\n+  ao.size = POINTER_SIZE;\n+  ao.max_size = ao.size;\n+  ao.ref_alias_set\n+    = get_deref_alias_set (TREE_TYPE (BINFO_VTABLE (TYPE_BINFO (otr_type))));\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Determining dynamic type for call: \");\n+      print_gimple_stmt (dump_file, call, 0, 0);\n+      fprintf (dump_file, \"  Starting walk at: \");\n+      print_gimple_stmt (dump_file, stmt, 0, 0);\n+      fprintf (dump_file, \"  instance pointer: \");\n+      print_generic_expr (dump_file, otr_object, TDF_SLIM);\n+      fprintf (dump_file, \"  Outer instance pointer: \");\n+      print_generic_expr (dump_file, instance, TDF_SLIM);\n+      fprintf (dump_file, \" offset: %i (bits)\", (int)context->offset);\n+      fprintf (dump_file, \" vtbl reference: \");\n+      print_generic_expr (dump_file, instance_ref, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  tci.offset = context->offset;\n+  tci.instance = instance;\n+  tci.vtbl_ptr_ref = instance_ref;\n+  gcc_assert (TREE_CODE (instance) != MEM_REF);\n+  tci.known_current_type = NULL_TREE;\n+  tci.known_current_offset = 0;\n+  tci.otr_type = otr_type;\n+  tci.type_maybe_changed = false;\n+  tci.multiple_types_encountered = false;\n+  tci.speculative = false;\n+  tci.seen_unanalyzed_store = false;\n+\n+  walk_aliased_vdefs (&ao, gimple_vuse (stmt), check_stmt_for_type_change,\n+\t\t      &tci, NULL, &function_entry_reached);\n+\n+  /* If we did not find any type changing statements, we may still drop\n+     maybe_in_construction flag if the context already have outer type. \n+\n+     Here we make special assumptions about both constructors and\n+     destructors which are all the functions that are allowed to alter the\n+     VMT pointers.  It assumes that destructors begin with assignment into\n+     all VMT pointers and that constructors essentially look in the\n+     following way:\n+\n+     1) The very first thing they do is that they call constructors of\n+     ancestor sub-objects that have them.\n+\n+     2) Then VMT pointers of this and all its ancestors is set to new\n+     values corresponding to the type corresponding to the constructor.\n+\n+     3) Only afterwards, other stuff such as constructor of member\n+     sub-objects and the code written by the user is run.  Only this may\n+     include calling virtual functions, directly or indirectly.\n+\n+     4) placement new can not be used to change type of non-POD statically\n+     allocated variables.\n+\n+     There is no way to call a constructor of an ancestor sub-object in any\n+     other way.\n+\n+     This means that we do not have to care whether constructors get the\n+     correct type information because they will always change it (in fact,\n+     if we define the type to be given by the VMT pointer, it is undefined).\n+\n+     The most important fact to derive from the above is that if, for some\n+     statement in the section 3, we try to detect whether the dynamic type\n+     has changed, we can safely ignore all calls as we examine the function\n+     body backwards until we reach statements in section 2 because these\n+     calls cannot be ancestor constructors or destructors (if the input is\n+     not bogus) and so do not change the dynamic type (this holds true only\n+     for automatically allocated objects but at the moment we devirtualize\n+     only these).  We then must detect that statements in section 2 change\n+     the dynamic type and can try to derive the new type.  That is enough\n+     and we can stop, we will never see the calls into constructors of\n+     sub-objects in this code. \n+\n+     Therefore if the static outer type was found (context->outer_type)\n+     we can safely ignore tci.speculative that is set on calls and give up\n+     only if there was dyanmic type store that may affect given variable\n+     (seen_unanalyzed_store)  */\n+\n+  if (!tci.type_maybe_changed)\n+    {\n+      if (!context->outer_type || tci.seen_unanalyzed_store)\n+\treturn false;\n+      if (context->maybe_in_construction)\n+        context->maybe_in_construction = false;\n+      if (dump_file)\n+\tfprintf (dump_file, \"  No dynamic type change found.\\n\");\n+      return true;\n+    }\n+\n+  if (tci.known_current_type\n+      && !function_entry_reached\n+      && !tci.multiple_types_encountered)\n+    {\n+      if (!tci.speculative)\n+\t{\n+\t  context->outer_type = tci.known_current_type;\n+\t  context->offset = tci.known_current_offset;\n+\t  context->maybe_in_construction = false;\n+\t  context->maybe_derived_type = false;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Determined dynamic type.\\n\");\n+\t}\n+      else if (!context->speculative_outer_type\n+\t       || context->speculative_maybe_derived_type)\n+\t{\n+\t  context->speculative_outer_type = tci.known_current_type;\n+\t  context->speculative_offset = tci.known_current_offset;\n+\t  context->speculative_maybe_derived_type = false;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Determined speculative dynamic type.\\n\");\n+\t}\n+    }\n+  else if (dump_file)\n+    fprintf (dump_file, \"  Found multiple types.\\n\");\n+\n+  return true;\n+}\n+\n /* Walk bases of OUTER_TYPE that contain OTR_TYPE at OFFSET.\n    Lookup their respecitve virtual methods for OTR_TOKEN and OTR_TYPE\n    and insert them to NODES.\n@@ -2516,6 +3028,7 @@ devirt_variable_node_removal_hook (varpool_node *n,\n }\n \n /* Record about how many calls would benefit from given type to be final.  */\n+\n struct odr_type_warn_count\n {\n   tree type;\n@@ -2524,6 +3037,7 @@ struct odr_type_warn_count\n };\n \n /* Record about how many calls would benefit from given method to be final.  */\n+\n struct decl_warn_count\n {\n   tree decl;\n@@ -2532,6 +3046,7 @@ struct decl_warn_count\n };\n \n /* Information about type and decl warnings.  */\n+\n struct final_warning_record\n {\n   gcov_type dyn_count;"}, {"sha": "3e975d6d497cc94eda979ee4424983b95fa797ee", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=7d0aa05b9ead1b114958d8230377c2c25ef54876", "patch": "@@ -2337,11 +2337,46 @@ ipa_analyze_call_uses (struct func_body_info *fbi, gimple call)\n           && !virtual_method_call_p (target)))\n     return;\n \n+  struct cgraph_edge *cs = fbi->node->get_edge (call);\n   /* If we previously turned the call into a direct call, there is\n      no need to analyze.  */\n-  struct cgraph_edge *cs = fbi->node->get_edge (call);\n   if (cs && !cs->indirect_unknown_callee)\n     return;\n+\n+  if (cs->indirect_info->polymorphic)\n+    {\n+      tree otr_type;\n+      HOST_WIDE_INT otr_token;\n+      ipa_polymorphic_call_context context;\n+      tree instance;\n+      tree target = gimple_call_fn (call);\n+\n+      instance = get_polymorphic_call_info (current_function_decl,\n+\t\t\t\t\t    target,\n+\t\t\t\t\t    &otr_type, &otr_token,\n+\t\t\t\t\t    &context, call);\n+\n+      if (get_dynamic_type (instance, &context,\n+\t\t\t    OBJ_TYPE_REF_OBJECT (target),\n+\t\t\t    otr_type, call))\n+\t{\n+\t  gcc_assert (TREE_CODE (otr_type) == RECORD_TYPE);\n+\t  cs->indirect_info->polymorphic = true;\n+\t  cs->indirect_info->param_index = -1;\n+\t  cs->indirect_info->otr_token = otr_token;\n+\t  cs->indirect_info->otr_type = otr_type;\n+\t  cs->indirect_info->outer_type = context.outer_type;\n+\t  cs->indirect_info->speculative_outer_type = context.speculative_outer_type;\n+\t  cs->indirect_info->offset = context.offset;\n+\t  cs->indirect_info->speculative_offset = context.speculative_offset;\n+\t  cs->indirect_info->maybe_in_construction\n+\t     = context.maybe_in_construction;\n+\t  cs->indirect_info->maybe_derived_type = context.maybe_derived_type;\n+\t  cs->indirect_info->speculative_maybe_derived_type\n+\t     = context.speculative_maybe_derived_type;\n+\t}\n+    }\n+\n   if (TREE_CODE (target) == SSA_NAME)\n     ipa_analyze_indirect_call_uses (fbi, call, target);\n   else if (virtual_method_call_p (target))"}, {"sha": "3801525ae7d28532d811cb0177c48932ad5d3ba2", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=7d0aa05b9ead1b114958d8230377c2c25ef54876", "patch": "@@ -95,7 +95,7 @@ tree get_polymorphic_call_info (tree, tree, tree *,\n \t\t\t\tHOST_WIDE_INT *,\n \t\t\t\tipa_polymorphic_call_context *,\n \t\t\t\tgimple call = NULL);\n-bool get_dynamic_type (tree, ipa_polymorphic_call_context *, tree, gimple);\n+bool get_dynamic_type (tree, ipa_polymorphic_call_context *, tree, tree, gimple);\n bool get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *,\n \t\t\t\t\t       tree, tree, HOST_WIDE_INT);\n bool decl_maybe_in_construction_p (tree, tree, gimple, tree);"}, {"sha": "c62648022351946344d33cd3e2f4d1f1eb4c2940", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7d0aa05b9ead1b114958d8230377c2c25ef54876", "patch": "@@ -1,3 +1,8 @@\n+2014-08-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/ipa/devirt-35.C: New testcase.\n+\t* g++.dg/ipa/devirt-36.C: New testcase.\n+\n 2014-08-07  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51312"}, {"sha": "6c304304f29674bd4a900858bd7d472b6e2c9dd0", "filename": "gcc/testsuite/g++.dg/ipa/devirt-35.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-35.C?ref=7d0aa05b9ead1b114958d8230377c2c25ef54876", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-options \"-O2 -fdump-ipa-devirt-details -fdump-tree-fre1-details\"  } */\n+struct A {virtual int t(void) {return 1;}};\n+struct B:A {B(); virtual int t(void) {return 2;}};\n+void test2(struct A *);\n+int\n+m(struct B *b)\n+{\n+  struct A *a = new (B);\n+  a->t(); // This call should be devirtualized by \n+          // FRE because we know type from ctor call\n+  ((struct B *)a)->B::t(); // Make devirt possible \n+                           // C++ FE won't produce inline body without this\n+  test2(a);\n+  return a->t();  // This call should be devirtualized speculatively because\n+                  //  test2 may change the type of A by placement new.\n+                  // C++ standard is bit imprecise about this.\n+}\n+/* { dg-final { scan-ipa-dump \"converting indirect call to function virtual int B::t\"  \"fre1\"  } } */\n+/* { dg-final { scan-ipa-dump \"to virtual int B::t\"  \"devirt\"  } } */\n+/* { dg-final { scan-ipa-dump \"1 speculatively devirtualized\"  \"devirt\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"devirt\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */\n+"}, {"sha": "c32531ded585598ccd2132ab8ba4c615c800d3d1", "filename": "gcc/testsuite/g++.dg/ipa/devirt-36.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-36.C?ref=7d0aa05b9ead1b114958d8230377c2c25ef54876", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-O2 -fdump-ipa-devirt-details -fdump-tree-fre1-details\"  } */\n+struct A {virtual int t(void) {return 1;}};\n+struct B:A {B(); virtual int t(void) {return 2;}};\n+struct C {int a; struct B b;};\n+void test2(struct A *);\n+int\n+m(struct B *b)\n+{\n+  struct C *c = new (C);\n+  struct A *a = &c->b;\n+  a->t(); // This call should be devirtualized by \n+          // FRE because we know type from ctor call\n+  ((struct B *)a)->B::t(); // Make devirt possible \n+                           // C++ FE won't produce inline body without this\n+  test2(a);\n+  return a->t();  // This call should be devirtualized speculatively because\n+                  //  test2 may change the type of A by placement new.\n+                  // C++ standard is bit imprecise about this.\n+}\n+/* { dg-final { scan-ipa-dump \"converting indirect call to function virtual int B::t\"  \"fre1\"  } } */\n+/* { dg-final { scan-ipa-dump \"to virtual int B::t\"  \"devirt\"  } } */\n+/* { dg-final { scan-ipa-dump \"1 speculatively devirtualized\"  \"devirt\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"devirt\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */\n+"}, {"sha": "36412319aa95281900d789d53a228b6a632a4ada", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=7d0aa05b9ead1b114958d8230377c2c25ef54876", "patch": "@@ -5042,6 +5042,9 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n   }\n \n   update_stmt (stmt);\n+  cgraph_edge *e = cgraph_node::get (current_function_decl)->get_edge (stmt);\n+  if (e && e->indirect_info)\n+    e->indirect_info->polymorphic = false;\n \n   return true;\n }"}, {"sha": "0e968d5e22ce2dbbb72771fdd4881e40b40caa37", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0aa05b9ead1b114958d8230377c2c25ef54876/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=7d0aa05b9ead1b114958d8230377c2c25ef54876", "patch": "@@ -64,6 +64,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"domwalk.h\"\n #include \"ipa-prop.h\"\n #include \"tree-ssa-propagate.h\"\n+#include \"ipa-utils.h\"\n \n /* TODO:\n \n@@ -4360,12 +4361,41 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t{\n \t  tree fn = gimple_call_fn (stmt);\n \t  if (fn\n-\t      && TREE_CODE (fn) == OBJ_TYPE_REF\n-\t      && TREE_CODE (OBJ_TYPE_REF_EXPR (fn)) == SSA_NAME)\n+\t      && flag_devirtualize\n+\t      && virtual_method_call_p (fn))\n \t    {\n-\t      fn = ipa_intraprocedural_devirtualization (stmt);\n-\t      if (fn && dbg_cnt (devirt))\n+\t      tree otr_type;\n+\t      HOST_WIDE_INT otr_token;\n+\t      ipa_polymorphic_call_context context;\n+\t      tree instance;\n+\t      bool final;\n+\n+\t      instance = get_polymorphic_call_info (current_function_decl,\n+\t\t\t\t\t\t    fn,\n+\t\t\t\t\t\t    &otr_type, &otr_token, &context, stmt);\n+\n+\t      get_dynamic_type (instance, &context,\n+\t\t\t\tOBJ_TYPE_REF_OBJECT (fn), otr_type, stmt);\n+\n+\t      vec <cgraph_node *>targets\n+\t\t= possible_polymorphic_call_targets (obj_type_ref_class (fn),\n+\t\t\t\t\t\t     tree_to_uhwi\n+\t\t\t\t\t\t       (OBJ_TYPE_REF_TOKEN (fn)),\n+\t\t\t\t\t\t     context,\n+\t\t\t\t\t\t     &final);\n+\t      if (dump_enabled_p ())\n+\t\tdump_possible_polymorphic_call_targets (dump_file, \n+\t\t\t\t\t\t\tobj_type_ref_class (fn),\n+\t\t\t\t\t\t\ttree_to_uhwi\n+\t\t\t\t\t\t\t  (OBJ_TYPE_REF_TOKEN (fn)),\n+\t\t\t\t\t\t\tcontext);\n+\t      if (final && targets.length () <= 1 && dbg_cnt (devirt))\n \t\t{\n+\t\t  tree fn;\n+\t\t  if (targets.length () == 1)\n+\t\t    fn = targets[0]->decl;\n+\t\t  else\n+\t\t    fn = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n \t\t  if (dump_enabled_p ())\n \t\t    {\n \t\t      location_t loc = gimple_location_safe (stmt);\n@@ -4377,6 +4407,8 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t  gimple_call_set_fndecl (stmt, fn);\n \t\t  gimple_set_modified (stmt, true);\n \t\t}\n+\t      else\n+\t        gcc_assert (!ipa_intraprocedural_devirtualization (stmt));\n \t    }\n \t}\n "}]}