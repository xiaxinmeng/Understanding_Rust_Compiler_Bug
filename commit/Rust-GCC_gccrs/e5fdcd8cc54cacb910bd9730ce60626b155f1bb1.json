{"sha": "e5fdcd8cc54cacb910bd9730ce60626b155f1bb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVmZGNkOGNjNTRjYWNiOTEwYmQ5NzMwY2U2MDYyNmIxNTVmMWJiMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-08-13T08:19:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-08-13T08:19:10Z"}, "message": "re PR middle-end/41047 (gcc.target/mips/memcpy-1.c failing)\n\n2009-08-13  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/41047\n\t* tree-ssa-ccp.c (ccp_fold): When folding pointer additions\n\tuse the constant pointer type.\n\t* gimplify.c (canonicalize_addr_expr): Canonicalize independent\n\tof CV qualifiers on the target pointer type.\n\t* tree-ssa.c (useless_type_conversion_p): Move incomplete pointer\n\tconversion check before restrict check.\n\n\t* gcc.dg/tree-ssa/ssa-ccp-27.c: New testcase.\n\nFrom-SVN: r150715", "tree": {"sha": "19e33361b8467654e1998b29231dec999536e09a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19e33361b8467654e1998b29231dec999536e09a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "61a28f2135b9e22ef505ee60f92031a48263e0b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a28f2135b9e22ef505ee60f92031a48263e0b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a28f2135b9e22ef505ee60f92031a48263e0b0"}], "stats": {"total": 69, "additions": 56, "deletions": 13}, "files": [{"sha": "42d8bf4fe50c419613aeea2ba1a95567dc6aa402", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5fdcd8cc54cacb910bd9730ce60626b155f1bb1", "patch": "@@ -1,3 +1,13 @@\n+2009-08-13  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/41047\n+\t* tree-ssa-ccp.c (ccp_fold): When folding pointer additions\n+\tuse the constant pointer type.\n+\t* gimplify.c (canonicalize_addr_expr): Canonicalize independent\n+\tof CV qualifiers on the target pointer type.\n+\t* tree-ssa.c (useless_type_conversion_p): Move incomplete pointer\n+\tconversion check before restrict check.\n+\n 2009-08-12  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR target/41029"}, {"sha": "7de2a7e183f2a9f0f3a5b8fe64a4cc1ae81ed2c5", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e5fdcd8cc54cacb910bd9730ce60626b155f1bb1", "patch": "@@ -1763,7 +1763,8 @@ canonicalize_addr_expr (tree *expr_p)\n      the expression pointer type.  */\n   ddatype = TREE_TYPE (datype);\n   pddatype = build_pointer_type (ddatype);\n-  if (!useless_type_conversion_p (pddatype, ddatype))\n+  if (!useless_type_conversion_p (TYPE_MAIN_VARIANT (TREE_TYPE (expr)),\n+\t\t\t\t  pddatype))\n     return;\n \n   /* The lower bound and element sizes must be constant.  */\n@@ -1778,6 +1779,10 @@ canonicalize_addr_expr (tree *expr_p)\n \t\t    TYPE_MIN_VALUE (TYPE_DOMAIN (datype)),\n \t\t    NULL_TREE, NULL_TREE);\n   *expr_p = build1 (ADDR_EXPR, pddatype, *expr_p);\n+\n+  /* We can have stripped a required restrict qualifier above.  */\n+  if (!useless_type_conversion_p (TREE_TYPE (expr), TREE_TYPE (*expr_p)))\n+    *expr_p = fold_convert (TREE_TYPE (expr), *expr_p);\n }\n \n /* *EXPR_P is a NOP_EXPR or CONVERT_EXPR.  Remove it and/or other conversions"}, {"sha": "92575a3e06ae261d5f013b09c6403a1b8fa115d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e5fdcd8cc54cacb910bd9730ce60626b155f1bb1", "patch": "@@ -1,3 +1,8 @@\n+2009-08-13  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/41047\n+\t* gcc.dg/tree-ssa/ssa-ccp-27.c: New testcase.\n+\n 2009-08-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/41011"}, {"sha": "c27963454713d4f52fbe88fe78aa69331ede6dea", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-27.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-27.c?ref=e5fdcd8cc54cacb910bd9730ce60626b155f1bb1", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ccp1\" } */\n+\n+#include <string.h>\n+\n+char c[10];\n+\n+void\n+f1 ()\n+{\n+  const char *p = \"123456\";\n+  memcpy (c, p, 6);\n+}\n+\n+void\n+f2 ()\n+{\n+  const char *p = \"12345678\";\n+  p += 2;\n+  memcpy (c, p, 6);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"memcpy\\[^\\n\\]*123456\" 2 \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "b359d4c8d767fb0bdc2c17f75a0b4259cd4e36de", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=e5fdcd8cc54cacb910bd9730ce60626b155f1bb1", "patch": "@@ -1093,9 +1093,8 @@ ccp_fold (gimple stmt)\n \t\t  && TREE_CODE (op0) == ADDR_EXPR\n \t\t  && TREE_CODE (op1) == INTEGER_CST)\n \t\t{\n-\t\t  tree lhs = gimple_assign_lhs (stmt);\n \t\t  tree tem = maybe_fold_offset_to_address\n-\t\t    (loc, op0, op1, TREE_TYPE (lhs));\n+\t\t    (loc, op0, op1, TREE_TYPE (op0));\n \t\t  if (tem != NULL_TREE)\n \t\t    return tem;\n \t\t}"}, {"sha": "76e4e8b7f1b3c0ae0e18eae355cb424ac4b92828", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5fdcd8cc54cacb910bd9730ce60626b155f1bb1/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=e5fdcd8cc54cacb910bd9730ce60626b155f1bb1", "patch": "@@ -874,6 +874,16 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n   if (POINTER_TYPE_P (inner_type)\n       && POINTER_TYPE_P (outer_type))\n     {\n+      /* If the outer type is (void *) or a pointer to an incomplete\n+\t record type, then the conversion is not necessary.  */\n+      if (VOID_TYPE_P (TREE_TYPE (outer_type))\n+\t  || (AGGREGATE_TYPE_P (TREE_TYPE (outer_type))\n+\t      && TREE_CODE (TREE_TYPE (outer_type)) != ARRAY_TYPE\n+\t      && (TREE_CODE (TREE_TYPE (outer_type))\n+\t\t  == TREE_CODE (TREE_TYPE (inner_type)))\n+\t      && !COMPLETE_TYPE_P (TREE_TYPE (outer_type))))\n+\treturn true;\n+\n       /* Do not lose casts to restrict qualified pointers.  */\n       if ((TYPE_RESTRICT (outer_type)\n \t   != TYPE_RESTRICT (inner_type))\n@@ -930,16 +940,6 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n   else if (POINTER_TYPE_P (inner_type)\n \t   && POINTER_TYPE_P (outer_type))\n     {\n-      /* If the outer type is (void *) or a pointer to an incomplete\n-\t record type, then the conversion is not necessary.  */\n-      if (VOID_TYPE_P (TREE_TYPE (outer_type))\n-\t  || (AGGREGATE_TYPE_P (TREE_TYPE (outer_type))\n-\t      && TREE_CODE (TREE_TYPE (outer_type)) != ARRAY_TYPE\n-\t      && (TREE_CODE (TREE_TYPE (outer_type))\n-\t\t  == TREE_CODE (TREE_TYPE (inner_type)))\n-\t      && !COMPLETE_TYPE_P (TREE_TYPE (outer_type))))\n-\treturn true;\n-\n       /* Don't lose casts between pointers to volatile and non-volatile\n \t qualified types.  Doing so would result in changing the semantics\n \t of later accesses.  For function types the volatile qualifier"}]}