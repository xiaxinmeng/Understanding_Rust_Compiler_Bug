{"sha": "0baa170258181471cfbc1ca6dc1d0e86c0459f53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJhYTE3MDI1ODE4MTQ3MWNmYmMxY2E2ZGMxZDBlODZjMDQ1OWY1Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-05-16T20:53:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-05-16T20:53:04Z"}, "message": "gcc-dg.exp (gcc-dg-test): Rename to ...\n\n\t* lib/gcc-dg.exp (gcc-dg-test): Rename to ...\n\t(gcc-dg-test-1): ... this.  Add target_compile parameter.  Add\n\tsupport for \"repo\" mode.\n\t* lib/g++-dg.exp: Use gcc-dg.exp to implement all functionality.\n\t* lib/g77-dg.exp: Likewise.\n\t* lib/obj-dg.exp: Likewise.\n\nFrom-SVN: r66881", "tree": {"sha": "4b534d589ea500d2358811fc5722ed1f0d5e6806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b534d589ea500d2358811fc5722ed1f0d5e6806"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0baa170258181471cfbc1ca6dc1d0e86c0459f53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0baa170258181471cfbc1ca6dc1d0e86c0459f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0baa170258181471cfbc1ca6dc1d0e86c0459f53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0baa170258181471cfbc1ca6dc1d0e86c0459f53/comments", "author": null, "committer": null, "parents": [{"sha": "13a8b496ce8381051e5cc7089034cdd909d5afb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a8b496ce8381051e5cc7089034cdd909d5afb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13a8b496ce8381051e5cc7089034cdd909d5afb0"}], "stats": {"total": 407, "additions": 55, "deletions": 352}, "files": [{"sha": "329bc2bc052aa6f2a28ce82a6e8a617c234bb7f7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0baa170258181471cfbc1ca6dc1d0e86c0459f53/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0baa170258181471cfbc1ca6dc1d0e86c0459f53/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0baa170258181471cfbc1ca6dc1d0e86c0459f53", "patch": "@@ -1,3 +1,12 @@\n+2003-05-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* lib/gcc-dg.exp (gcc-dg-test): Rename to ...\n+\t(gcc-dg-test-1): ... this.  Add target_compile parameter.  Add\n+\tsupport for \"repo\" mode.\n+\t* lib/g++-dg.exp: Use gcc-dg.exp to implement all functionality.\n+\t* lib/g77-dg.exp: Likewise.\n+\t* lib/obj-dg.exp: Likewise.\n+\t\n 2003-05-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tMerge from gcc-3_2-rhl8-branch:"}, {"sha": "9f6364576a04cee0bf19bbfb841ff3043a9771f9", "filename": "gcc/testsuite/lib/g++-dg.exp", "status": "modified", "additions": 3, "deletions": 84, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0baa170258181471cfbc1ca6dc1d0e86c0459f53/gcc%2Ftestsuite%2Flib%2Fg%2B%2B-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0baa170258181471cfbc1ca6dc1d0e86c0459f53/gcc%2Ftestsuite%2Flib%2Fg%2B%2B-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fg%2B%2B-dg.exp?ref=0baa170258181471cfbc1ca6dc1d0e86c0459f53", "patch": "@@ -16,96 +16,15 @@\n \n # Define g++ callbacks for dg.exp.\n \n-load_lib dg.exp\n-load_lib file-format.exp\n-load_lib target-supports.exp\n-load_lib scanasm.exp\n+load_lib gcc-dg.exp\n \n proc g++-dg-test { prog do_what extra_tool_flags } {\n-    # Set up the compiler flags, based on what we're going to do.\n-\n-    set options [list]\n-\n-    # Tests should be able to use \"dg-do repo\".  However, the dg test\n-    # driver checks the argument to dg-do against a list of acceptable\n-    # options, and \"repo\" is not among them.  Therefore, we resort to\n-    # this ugly approach.\n-    if [string match \"*-frepo*\" $extra_tool_flags] then {\n-\tset do_what \"repo\"\n-    }\n-\n-    switch $do_what {\n-\t\"preprocess\" {\n-\t    set compile_type \"preprocess\"\n-\t    set output_file \"[file rootname [file tail $prog]].i\"\n-\t}\n-\t\"compile\" {\n-\t    set compile_type \"assembly\"\n-\t    set output_file \"[file rootname [file tail $prog]].s\"\n-\t}\n-\t\"assemble\" {\n-\t    set compile_type \"object\"\n-\t    set output_file \"[file rootname [file tail $prog]].o\"\n-\t}\n-\t\"precompile\" {\n-\t    set compile_type \"precompiled_header\"\n-\t    set output_file \"[file tail $prog].gch\"\n-\t}\n-\t\"link\" {\n-\t    set compile_type \"executable\"\n-\t    set output_file \"[file rootname [file tail $prog]].exe\"\n-\t    # The following line is needed for targets like the i960 where\n-\t    # the default output file is b.out.  Sigh.\n-\t}\n-\t\"repo\" {\n-\t    set compile_type \"object\"\n-\t    set output_file \"[file rootname [file tail $prog]].o\"\n-\t}\n-\t\"run\" {\n-\t    set compile_type \"executable\"\n-\t    # FIXME: \"./\" is to cope with \".\" not being in $PATH.\n-\t    # Should this be handled elsewhere?\n-\t    # YES.\n-\t    set output_file \"./[file rootname [file tail $prog]].exe\"\n-\t    # This is the only place where we care if an executable was\n-\t    # created or not.  If it was, dg.exp will try to run it.\n-\t    remote_file build delete $output_file;\n-\t}\n-\tdefault {\n-\t    perror \"$do_what: not a valid dg-do keyword\"\n-\t    return \"\"\n-\t}\n-    }\n-\n-    if { $extra_tool_flags != \"\" } {\n-\tlappend options \"additional_flags=$extra_tool_flags\"\n-    }\n-\n-    set comp_output [g++_target_compile \"$prog\" \"$output_file\" \"$compile_type\" $options];\n-\n-    if { $do_what == \"repo\" } {\n-\tset object_file \"$output_file\"\n-\tset output_file \"[file rootname [file tail $prog]].exe\"\n-\tconcat comp_output \\\n-\t       [g++_target_compile \"$object_file\" \"$output_file\" \"executable\" $options]\n-    }\n-\n-    return [list $comp_output $output_file]\n+    return [gcc-dg-test-1 g++_target_compile $prog $do_what $extra_tool_flags]\n }\n \n \n proc g++-dg-prune { system text } {\n-    set text [prune_gcc_output $text]\n-\n-    # If we see \"region xxx is full\" then the testcase is too big for ram.\n-    # This is tricky to deal with in a large testsuite like c-torture so\n-    # deal with it here.  Just mark the testcase as unsupported.\n-    if [regexp \"(^|\\n)\\[^\\n\\]*: region \\[^\\n\\]* is full\" $text] {\n-\t# The format here is important.  See dg.exp.\n-\treturn \"::unsupported::memory full\"\n-    }\n-\n-    return $text\n+    return [gcc-dg-prune $system $text]\n }\n \n # Record additional sources files that must be compiled along with the"}, {"sha": "4734075fe52c9cd081e0e57e03cbf9a5cbd36e8b", "filename": "gcc/testsuite/lib/g77-dg.exp", "status": "modified", "additions": 9, "deletions": 130, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0baa170258181471cfbc1ca6dc1d0e86c0459f53/gcc%2Ftestsuite%2Flib%2Fg77-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0baa170258181471cfbc1ca6dc1d0e86c0459f53/gcc%2Ftestsuite%2Flib%2Fg77-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fg77-dg.exp?ref=0baa170258181471cfbc1ca6dc1d0e86c0459f53", "patch": "@@ -1,4 +1,4 @@\n-#   Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n+#   Copyright (C) 1997, 1999, 2000, 2003 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -14,88 +14,16 @@\n # along with this program; if not, write to the Free Software\n # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n \n-load_lib dg.exp\n-load_lib file-format.exp\n-load_lib target-supports.exp\n-load_lib scanasm.exp\n-load_lib prune.exp\n-\n-if ![info exists TORTURE_OPTIONS] {\n-    # It is theoretically beneficial to group all of the O2/O3 options together,\n-    # as in many cases the compiler will generate identical executables for\n-    # all of them--and the c-torture testsuite will skip testing identical\n-    # executables multiple times.\n-    # Also note that -finline-functions is explicitly included in one of the\n-    # items below, even though -O3 is also specified, because some ports may\n-    # choose to disable inlining functions by default, even when optimizing.\n-    set TORTURE_OPTIONS [list \\\n-\t{ -O0 } \\\n-\t{ -O1 } \\\n-\t{ -O2 } \\\n-\t{ -O3 -fomit-frame-pointer } \\\n-\t{ -O3 -fomit-frame-pointer -funroll-loops } \\\n-\t{ -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions } \\\n-\t{ -O3 -g } \\\n-\t{ -Os } ]\n-}\n-\n-\n-# Split TORTURE_OPTIONS into two choices: one for testcases with loops and\n-# one for testcases without loops.\n-\n-set torture_with_loops $TORTURE_OPTIONS\n-set torture_without_loops \"\"\n-foreach option $TORTURE_OPTIONS {\n-    if ![string match \"*loop*\" $option] {\n-\tlappend torture_without_loops $option\n-    }\n-}\n+load_lib gcc-dg.exp\n \n # Define g77 callbacks for dg.exp.\n \n proc g77-dg-test { prog do_what extra_tool_flags } {\n-    # Set up the compiler flags, based on what we're going to do.\n-\n-    switch $do_what {\n-\t\"preprocess\" {\n-\t    set compile_type \"preprocess\"\n-\t    set output_file \"[file rootname [file tail $prog]].i\"\n-\t}\n-\t\"compile\" {\n-\t    set compile_type \"assembly\"\n-\t    set output_file \"[file rootname [file tail $prog]].s\"\n-\t}\n-\t\"assemble\" {\n-\t    set compile_type \"object\"\n-\t    set output_file \"[file rootname [file tail $prog]].o\"\n-\t}\n-\t\"link\" {\n-\t    set compile_type \"executable\"\n-\t    set output_file \"[file rootname [file tail $prog]].exe\"\n-\t    # The following line is needed for targets like the i960 where\n-\t    # the default output file is b.out.  Sigh.\n-\t}\n-\t\"run\" {\n-\t    set compile_type \"executable\"\n-\t    # FIXME: \"./\" is to cope with \".\" not being in $PATH.\n-\t    # Should this be handled elsewhere?\n-\t    # YES.\n-\t    set output_file \"./[file rootname [file tail $prog]].exe\"\n-\t    # This is the only place where we care if an executable was\n-\t    # created or not.  If it was, dg.exp will try to run it.\n-\t    remote_file build delete $output_file;\n-\t}\n-\tdefault {\n-\t    perror \"$do_what: not a valid dg-do keyword\"\n-\t    return \"\"\n-\t}\n-    }\n-    set options \"\"\n-    if { $extra_tool_flags != \"\" } {\n-\tlappend options \"additional_flags=$extra_tool_flags\"\n-    }\n-\n-    set comp_output [g77_target_compile \"$prog\" \"$output_file\" \"$compile_type\" $options];\n+    set result \\\n+\t[gcc-dg-test-1 g77_target_compile $prog $do_what $extra_tool_flags]\n+    \n+    set comp_output [lindex $result 0]\n+    set output_file [lindex $result 1]\n \n     # Put the error message on the same line as the line number\n     # Remove the line of source code with the error and\n@@ -106,62 +34,13 @@ proc g77-dg-test { prog do_what extra_tool_flags } {\n }\n \n proc g77-dg-prune { system text } {\n-    set text [prune_gcc_output $text]\n-\n-    # If we see \"region xxx is full\" then the testcase is too big for ram.\n-    # This is tricky to deal with in a large testsuite like c-torture so\n-    # deal with it here.  Just mark the testcase as unsupported.\n-    if [regexp \"(^|\\n)\\[^\\n\\]*: region \\[^\\n\\]* is full\" $text] {\n-\t# The format here is important.  See dg.exp.\n-\treturn \"::unsupported::memory full\"\n-    }\n-\n-    return $text\n+    return [gcc-dg-prune $system $text]\n }\n \n # Utility routines.\n \n-#\n-# search_for -- looks for a string match in a file\n-#\n-proc search_for { file pattern } {\n-    set fd [open $file r]\n-    while { [gets $fd cur_line]>=0 } {\n-\tif [string match \"*$pattern*\" $cur_line] then {\n-\t    close $fd\n-\t    return 1\n-\t}\n-    }\n-    close $fd\n-    return 0\n-}\n-\n # Modified dg-runtest that can cycle through a list of optimization options\n # as c-torture does.\n proc g77-dg-runtest { testcases default-extra-flags } {\n-    global runtests\n-\n-    foreach test $testcases {\n-\t# If we're only testing specific files and this isn't one of \n-\t# them, skip it.\n-\tif ![runtest_file_p $runtests $test] {\n-\t    continue\n-        }\n-\n-\t# Look for a loop within the source code - if we don't find one,\n-\t# don't pass -funroll[-all]-loops.\n-\tglobal torture_with_loops torture_without_loops\n-\tif [expr [search_for $test \"do *\\[0-9\\]\"]+[search_for $test \"end *do\"]] {\n-\t    set option_list $torture_with_loops\n-\t} else {\n-\t    set option_list $torture_without_loops\n-\t}\n-\n-\tset nshort [file tail [file dirname $test]]/[file tail $test]\n-\n-\tforeach flags $option_list {\n-\t    verbose \"Testing $nshort, $flags\" 1\n-\t    dg-test $test $flags ${default-extra-flags}\n-\t}\n-    }\n+    return [gcc-dg-runtest $testcases ${default-extra-flags}]\n }"}, {"sha": "e0362ad682f2bd0c46ce77750d189bf3728a91c0", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0baa170258181471cfbc1ca6dc1d0e86c0459f53/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0baa170258181471cfbc1ca6dc1d0e86c0459f53/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=0baa170258181471cfbc1ca6dc1d0e86c0459f53", "patch": "@@ -1,4 +1,4 @@\n-#   Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n+#   Copyright (C) 1997, 1999, 2000, 2003 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -53,9 +53,19 @@ foreach option $TORTURE_OPTIONS {\n \n # Define gcc callbacks for dg.exp.\n \n-proc gcc-dg-test { prog do_what extra_tool_flags } {\n+proc gcc-dg-test-1 { target_compile prog do_what extra_tool_flags } {\n     # Set up the compiler flags, based on what we're going to do.\n \n+    set options [list]\n+\n+    # Tests should be able to use \"dg-do repo\".  However, the dg test\n+    # driver checks the argument to dg-do against a list of acceptable\n+    # options, and \"repo\" is not among them.  Therefore, we resort to\n+    # this ugly approach.\n+    if [string match \"*-frepo*\" $extra_tool_flags] then {\n+\tset do_what \"repo\"\n+    }\n+\n     switch $do_what {\n \t\"preprocess\" {\n \t    set compile_type \"preprocess\"\n@@ -79,6 +89,10 @@ proc gcc-dg-test { prog do_what extra_tool_flags } {\n \t    # The following line is needed for targets like the i960 where\n \t    # the default output file is b.out.  Sigh.\n \t}\n+\t\"repo\" {\n+\t    set compile_type \"object\"\n+\t    set output_file \"[file rootname [file tail $prog]].o\"\n+\t}\n \t\"run\" {\n \t    set compile_type \"executable\"\n \t    # FIXME: \"./\" is to cope with \".\" not being in $PATH.\n@@ -94,16 +108,27 @@ proc gcc-dg-test { prog do_what extra_tool_flags } {\n \t    return \"\"\n \t}\n     }\n-    set options \"\"\n+\n     if { $extra_tool_flags != \"\" } {\n \tlappend options \"additional_flags=$extra_tool_flags\"\n     }\n \n-    set comp_output [gcc_target_compile \"$prog\" \"$output_file\" \"$compile_type\" $options];\n+    set comp_output [$target_compile \"$prog\" \"$output_file\" \"$compile_type\" $options];\n+\n+    if { $do_what == \"repo\" } {\n+\tset object_file \"$output_file\"\n+\tset output_file \"[file rootname [file tail $prog]].exe\"\n+\tconcat comp_output \\\n+\t       [$target_compile \"$object_file\" \"$output_file\" \"executable\" $options]\n+    }\n \n     return [list $comp_output $output_file]\n }\n \n+proc gcc-dg-test { prog do_what extra_tool_flags } {\n+    return [gcc-dg-test-1 gcc_target_compile $prog $do_what $extra_tool_flags]\n+}\n+\n proc gcc-dg-prune { system text } {\n     set text [prune_gcc_output $text]\n "}, {"sha": "5f7b609b1f2cf2ee177904bc4ba19acae6b82bbb", "filename": "gcc/testsuite/lib/objc-dg.exp", "status": "modified", "additions": 5, "deletions": 134, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0baa170258181471cfbc1ca6dc1d0e86c0459f53/gcc%2Ftestsuite%2Flib%2Fobjc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0baa170258181471cfbc1ca6dc1d0e86c0459f53/gcc%2Ftestsuite%2Flib%2Fobjc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fobjc-dg.exp?ref=0baa170258181471cfbc1ca6dc1d0e86c0459f53", "patch": "@@ -1,4 +1,4 @@\n-#   Copyright (C) 1997, 1999, 2000, 2001 Free Software Foundation, Inc.\n+#   Copyright (C) 1997, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -14,151 +14,22 @@\n # along with this program; if not, write to the Free Software\n # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n \n-load_lib dg.exp\n-load_lib file-format.exp\n-load_lib target-supports.exp\n-load_lib scanasm.exp\n-\n-# For prune_gcc_output.\n-load_lib gcc.exp\n-\n-if ![info exists TORTURE_OPTIONS] {\n-    # It is theoretically beneficial to group all of the O2/O3 options together,\n-    # as in many cases the compiler will generate identical executables for\n-    # all of them--and the c-torture testsuite will skip testing identical\n-    # executables multiple times.\n-    # Also note that -finline-functions is explicitly included in one of the\n-    # items below, even though -O3 is also specified, because some ports may\n-    # choose to disable inlining functions by default, even when optimizing.\n-    set TORTURE_OPTIONS [list \\\n-\t{ -O0 } \\\n-\t{ -O1 } \\\n-\t{ -O2 } \\\n-\t{ -O3 -fomit-frame-pointer } \\\n-\t{ -O3 -fomit-frame-pointer -funroll-loops } \\\n-\t{ -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions } \\\n-\t{ -O3 -g } \\\n-\t{ -Os } ]\n-}\n-\n-\n-# Split TORTURE_OPTIONS into two choices: one for testcases with loops and\n-# one for testcases without loops.\n-\n-set torture_with_loops $TORTURE_OPTIONS\n-set torture_without_loops \"\"\n-foreach option $TORTURE_OPTIONS {\n-    if ![string match \"*loop*\" $option] {\n-\tlappend torture_without_loops $option\n-    }\n-}\n+load_lib gcc-dg.exp\n \n # Define gcc callbacks for dg.exp.\n \n proc objc-dg-test { prog do_what extra_tool_flags } {\n-    # Set up the compiler flags, based on what we're going to do.\n-\n-    switch $do_what {\n-\t\"preprocess\" {\n-\t    set compile_type \"preprocess\"\n-\t    set output_file \"[file rootname [file tail $prog]].i\"\n-\t}\n-\t\"compile\" {\n-\t    set compile_type \"assembly\"\n-\t    set output_file \"[file rootname [file tail $prog]].s\"\n-\t}\n-\t\"assemble\" {\n-\t    set compile_type \"object\"\n-\t    set output_file \"[file rootname [file tail $prog]].o\"\n-\t}\n-\t\"link\" {\n-\t    set compile_type \"executable\"\n-\t    set output_file \"[file rootname [file tail $prog]].exe\"\n-\t    # The following line is needed for targets like the i960 where\n-\t    # the default output file is b.out.  Sigh.\n-\t}\n-\t\"run\" {\n-\t    set compile_type \"executable\"\n-\t    # FIXME: \"./\" is to cope with \".\" not being in $PATH.\n-\t    # Should this be handled elsewhere?\n-\t    # YES.\n-\t    set output_file \"./[file rootname [file tail $prog]].exe\"\n-\t    # This is the only place where we care if an executable was\n-\t    # created or not.  If it was, dg.exp will try to run it.\n-\t    remote_file build delete $output_file;\n-\t}\n-\tdefault {\n-\t    perror \"$do_what: not a valid dg-do keyword\"\n-\t    return \"\"\n-\t}\n-    }\n-    set options \"\"\n-    if { $extra_tool_flags != \"\" } {\n-\tlappend options \"additional_flags=$extra_tool_flags\"\n-    }\n-\n-    set comp_output [objc_target_compile \"$prog\" \"$output_file\" \"$compile_type\" $options];\n-\n-    return [list $comp_output $output_file]\n+    return [gcc-dg-test-1 objc_target_compile $prog $do_what $extra_tool_flags]\n }\n \n proc objc-dg-prune { system text } {\n-    set text [prune_gcc_output $text]\n-\n-    # If we see \"region xxx is full\" then the testcase is too big for ram.\n-    # This is tricky to deal with in a large testsuite like c-torture so\n-    # deal with it here.  Just mark the testcase as unsupported.\n-    if [regexp \"(^|\\n)\\[^\\n\\]*: region \\[^\\n\\]* is full\" $text] {\n-\t# The format here is important.  See dg.exp.\n-\treturn \"::unsupported::memory full\"\n-    }\n-\n-    return $text\n+    return [gcc-dg-prune $system $text]\n }\n \n # Utility routines.\n \n-#\n-# search_for -- looks for a string match in a file\n-#\n-proc search_for { file pattern } {\n-    set fd [open $file r]\n-    while { [gets $fd cur_line]>=0 } {\n-\tif [string match \"*$pattern*\" $cur_line] then {\n-\t    close $fd\n-\t    return 1\n-\t}\n-    }\n-    close $fd\n-    return 0\n-}\n-\n # Modified dg-runtest that can cycle through a list of optimization options\n # as c-torture does.\n proc objc-dg-runtest { testcases default-extra-flags } {\n-    global runtests\n-\n-    foreach test $testcases {\n-\t# If we're only testing specific files and this isn't one of \n-\t# them, skip it.\n-\tif ![runtest_file_p $runtests $test] {\n-\t    continue\n-        }\n-\n-\t# Look for a loop within the source code - if we don't find one,\n-\t# don't pass -funroll[-all]-loops.\n-\tglobal torture_with_loops torture_without_loops\n-\tif [expr [search_for $test \"for*(\"]+[search_for $test \"while*(\"]] {\n-\t    set option_list $torture_with_loops\n-\t} else {\n-\t    set option_list $torture_without_loops\n-\t}\n-\n-\tset nshort [file tail [file dirname $test]]/[file tail $test]\n-\n-\tforeach flags $option_list {\n-\t    verbose \"Testing $nshort, $flags\" 1\n-\t    dg-test $test $flags ${default-extra-flags}\n-\t}\n-    }\n+    return [gcc-dg-runtest $testcases ${default-extra-flags}]\n }"}]}