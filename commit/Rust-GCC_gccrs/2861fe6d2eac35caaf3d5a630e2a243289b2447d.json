{"sha": "2861fe6d2eac35caaf3d5a630e2a243289b2447d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg2MWZlNmQyZWFjMzVjYWFmM2Q1YTYzMGUyYTI0MzI4OWIyNDQ3ZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-24T15:38:27Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-24T15:38:27Z"}, "message": "Initial revision\n\nFrom-SVN: r140", "tree": {"sha": "4a0e8d38cb821313ec5672313ed375a13e5ca1df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a0e8d38cb821313ec5672313ed375a13e5ca1df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2861fe6d2eac35caaf3d5a630e2a243289b2447d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2861fe6d2eac35caaf3d5a630e2a243289b2447d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2861fe6d2eac35caaf3d5a630e2a243289b2447d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2861fe6d2eac35caaf3d5a630e2a243289b2447d/comments", "author": null, "committer": null, "parents": [{"sha": "a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b22788aeaf14e9d9e9b83e95e8a47b843dfa22"}], "stats": {"total": 667, "additions": 667, "deletions": 0}, "files": [{"sha": "f63f05a6891c630ba9e64f3a3cd7d027ba1aaafe", "filename": "gcc/config/ns32k/ns32k.c", "status": "added", "additions": 667, "deletions": 0, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2861fe6d2eac35caaf3d5a630e2a243289b2447d/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2861fe6d2eac35caaf3d5a630e2a243289b2447d/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=2861fe6d2eac35caaf3d5a630e2a243289b2447d", "patch": "@@ -0,0 +1,667 @@\n+/* Subroutines for assembler code output on the NS32000.\n+   Copyright (C) 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Some output-actions in ns32k.md need these.  */\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+\n+#ifdef OSF_OS\n+int ns32k_num_files = 0;\n+#endif\n+\n+void\n+trace (s, s1, s2)\n+     char *s, *s1, *s2;\n+{\n+    fprintf (stderr, s, s1, s2);\n+}\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */ \n+\n+int\n+hard_regno_mode_ok( regno, mode )\n+int regno;\n+int mode;\n+{\n+\tswitch( mode ) {\n+\t\tcase QImode:\n+\t\tcase HImode:\n+\t\tcase PSImode:\n+\t\tcase SImode:\n+\t\tcase PDImode:\n+\t\tcase VOIDmode:\n+\t\tcase BLKmode:\n+\t\t\tif( (regno < 8) || (regno == 16) || (regno == 17) ) {\n+\t\t\t\treturn( 1 );\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\treturn( 0 );\n+\t\t\t}\n+\n+\t\tcase DImode:\n+\t\t\tif( (regno < 8) && ((regno & 1) == 0) ) {\n+\t\t\t\treturn( 1 );\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\treturn( 0 );\n+\t\t\t}\n+\n+\n+\t\tcase SFmode:\n+\t\tcase SCmode:\n+\t\t\tif( TARGET_32081 ) {\n+\t\t\t\tif( regno < 16 ) {\n+\t\t\t\t\treturn( 1 );\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\treturn( 0 );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tif( regno < 8 ) {\n+\t\t\t\t\treturn( 1 );\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\treturn( 0 );\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tcase DFmode:\n+\t\tcase DCmode:\n+\t\t\tif( (regno & 1) == 0 ) {\n+\t\t\t\tif( TARGET_32081 ) {\n+\t\t\t\t\tif( regno < 16 ) {\n+\t\t\t\t\t\treturn( 1 );\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn( 0 );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tif( regno < 8 ) {\n+\t\t\t\t\t\treturn( 1 );\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn( 0 );\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\treturn( 0 );\n+\t\t\t}\n+ \n+\t\tcase XFmode:\n+\t\t\tabort( 0 );\n+\t\tcase CCmode:\n+\t\t\tabort( 0 );\n+\t\tcase TImode:\n+\t\t\tabort( 0 );\n+\t\tcase XCmode:\t\n+\t\t\tabort( 0 );\n+\t\tcase TFmode:\n+\t\t\tabort( 0 );\n+\t\tcase TCmode:\n+\t\t\tabort( 0 );\n+\n+\n+\t\tdefault:\n+\t\t\tfprintf( stderr, \"cant match mode %d\\n\", mode );\n+\t\t\tabort( 0 );\n+\t}\n+\tabort(0);\n+}\n+\n+/* ADDRESS_COST calls this.  This function is not optimal\n+   for the 32032 & 32332, but it probably is better than\n+   the default. */\n+\n+int\n+calc_address_cost (operand)\n+     rtx operand;\n+{\n+  int i;\n+  int cost = 0;\n+  \n+  if (GET_CODE (operand) == MEM)\n+    cost += 3;\n+  if (GET_CODE (operand) == MULT)\n+    cost += 2;\n+#if 0\n+  if (GET_CODE (operand) == REG)\n+    cost += 1;\t\t\t/* not really, but the documentation\n+\t\t\t\t   says different amount of registers\n+\t\t\t\t   shouldn't return the same costs */\n+#endif\n+  switch (GET_CODE (operand))\n+    {\n+    case REG:\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case POST_DEC:\n+    case PRE_DEC:\n+      break;\n+    case MULT:\n+    case MEM:\n+    case PLUS:\n+      for (i = 0; i < GET_RTX_LENGTH (GET_CODE (operand)); i++)\n+\t{\n+\t  cost += calc_address_cost (XEXP (operand, i));\n+\t}\n+    default:\n+      break;\n+    }\n+  return cost;\n+}\n+\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+\n+enum reg_class\n+secondary_reload_class (class, mode, in)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx in;\n+{\n+  int regno = true_regnum (in);\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    regno = -1;\n+\n+  /* We can place anything into GENERAL_REGS and can put GENERAL_REGS\n+     into anything.  */\n+  if (class == GENERAL_REGS || (regno >= 0 && regno < 8))\n+    return NO_REGS;\n+\n+  /* Constants, memory, and FP registers can go into FP registers */\n+  if ((regno == -1 || (regno >= 8 && regno < 16)) && (class == FLOAT_REGS))\n+    return NO_REGS;\n+\n+  /* Otherwise, we need GENERAL_REGS. */\n+  return GENERAL_REGS;\n+}\n+/* Generate the rtx that comes from an address expression in the md file */\n+/* The expression to be build is BASE[INDEX:SCALE].  To recognize this,\n+   scale must be converted from an exponent (from ASHIFT) to a\n+   muliplier (for MULT). */\n+rtx\n+gen_indexed_expr (base, index, scale)\n+     rtx base, index, scale;\n+{\n+  rtx addr;\n+\n+  /* This generates an illegal addressing mode, if BASE is\n+     fp or sp.  This is handled by PRINT_OPERAND_ADDRESS.  */\n+  if (GET_CODE (base) != REG && GET_CODE (base) != CONST_INT)\n+    base = gen_rtx (MEM, SImode, base);\n+  addr = gen_rtx (MULT, SImode, index,\n+\t\t  gen_rtx (CONST_INT, VOIDmode, 1 << INTVAL (scale)));\n+  addr = gen_rtx (PLUS, SImode, base, addr);\n+  return addr;\n+}\n+\n+/* Return 1 if OP is a valid operand of mode MODE.  This\n+   predicate rejects operands which do not have a mode\n+   (such as CONST_INT which are VOIDmode).  */\n+int\n+reg_or_mem_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_MODE (op) == mode\n+\t  && (GET_CODE (op) == REG\n+\t      || GET_CODE (op) == SUBREG\n+\t      || GET_CODE (op) == MEM));\n+}\n+\f\n+/* Return the best assembler insn template\n+   for moving operands[1] into operands[0] as a fullword.  */\n+\n+static char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && INTVAL (operands[1]) <= 7\n+      && INTVAL (operands[1]) >= -8)\n+    return \"movqd %1,%0\";\n+  return \"movd %1,%0\";\n+}\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum anon1 { REGOP, OFFSOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    optype0 = POPOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_ADDRESS_P (operands[1])\n+\t   || GET_CODE (operands[1]) == CONST_DOUBLE)\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n+    optype1 = POPOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    abort ();\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+  else if (optype1 == CNSTOP)\n+    {\n+      if (CONSTANT_ADDRESS_P (operands[1]))\n+\tlatehalf[1] = const0_rtx;\n+      else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n+    }\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If one or both operands autodecrementing,\n+     do the two words, high-numbered first.  */\n+\n+  if (optype0 == POPOP || optype1 == POPOP)\n+    {\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+      return singlemove_string (operands);\n+    }\n+\n+  /* Not autodecrementing.  Do the two words, low-numbered first.  */\n+\n+  output_asm_insn (singlemove_string (operands), operands);\n+\n+  operands[0] = latehalf[0];\n+  operands[1] = latehalf[1];\n+  return singlemove_string (operands);\n+}\n+\n+int\n+check_reg (oper, reg)\n+     rtx oper;\n+     int reg;\n+{\n+  register int i;\n+\n+  if (oper == 0)\n+    return 0;\n+  switch (GET_CODE(oper))\n+    {\n+    case REG:\n+      return (REGNO(oper) == reg) ? 1 : 0;\n+    case MEM:\n+      return check_reg(XEXP(oper, 0), reg);\n+    case PLUS:\n+    case MULT:\n+      return check_reg(XEXP(oper, 0), reg) || check_reg(XEXP(oper, 1), reg);\n+    }\n+  return 0;\n+}\n+\f\n+/* PRINT_OPERAND is defined to call this function,\n+   which is easier to debug than putting all the code in\n+   a macro definition in ns32k.h.  */\n+\n+void\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     char code;\n+{\n+  if (code == '$')\n+    PUT_IMMEDIATE_PREFIX(file);\n+  else if (code == '?')\n+    PUT_EXTERNAL_PREFIX(file);\n+  else if (GET_CODE (x) == REG)\n+    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+  else if (GET_CODE (x) == MEM)\n+    output_address (XEXP (x, 0));\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != DImode)\n+    if (GET_MODE (x) == DFmode)\n+      { \n+        union { double d; int i[2]; } u;\n+\tu.i[0] = CONST_DOUBLE_LOW (x); u.i[1] = CONST_DOUBLE_HIGH (x);\n+\tPUT_IMMEDIATE_PREFIX(file);\n+\tfprintf (file, \"0d%.20e\", u.d); \n+      }\n+    else\n+      { \n+        union { double d; int i[2]; } u;\n+\tu.i[0] = CONST_DOUBLE_LOW (x); u.i[1] = CONST_DOUBLE_HIGH (x);\n+\tPUT_IMMEDIATE_PREFIX(file);\n+\tfprintf (file, \"0f%.20e\", u.d); \n+      }\n+  else\n+    {\n+      PUT_IMMEDIATE_PREFIX(file);\n+      output_addr_const (file, x);\n+    }\n+}\n+\f\n+/* PRINT_OPERAND_ADDRESS is defined to call this function,\n+   which is easier to debug than putting all the code in\n+   a macro definition in ns32k.h .  */\n+\n+/* Completely rewritten to get this to work with Gas for PC532 Mach.\n+   This function didn't work and I just wasn't able (nor very willing) to\n+   figure out how it worked.\n+   90-11-25 Tatu Yl|nen <ylo@cs.hut.fi> */\n+\n+print_operand_address (file, addr)\n+     register FILE *file;\n+     register rtx addr;\n+{\n+  static char scales[] = { 'b', 'w', 'd', 0, 'q', };\n+  rtx offset, base, indexexp, tmp;\n+  int scale;\n+\n+  if (GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == POST_DEC)\n+    {\n+      fprintf (file, \"tos\");\n+      return;\n+    }\n+\n+  offset = NULL;\n+  base = NULL;\n+  indexexp = NULL;\n+  while (addr != NULL)\n+    {\n+      if (GET_CODE (addr) == PLUS)\n+\t{\n+\t  if (GET_CODE (XEXP (addr, 0)) == PLUS)\n+\t    {\n+\t      tmp = XEXP (addr, 1);\n+\t      addr = XEXP (addr, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      tmp = XEXP (addr,0);\n+\t      addr = XEXP (addr,1);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  tmp = addr;\n+\t  addr = NULL;\n+\t}\n+      switch (GET_CODE (tmp))\n+\t{\n+\tcase PLUS:\n+\t  abort ();\n+\tcase MEM:\n+\t  if (base)\n+\t    {\n+\t      indexexp = base;\n+\t      base = tmp;\n+\t    }\n+\t  else\n+\t    base = tmp;\n+\t  break;\n+\tcase REG:\n+\t  if (REGNO (tmp) < 8)\n+\t    if (base)\n+\t      {\n+\t\tindexexp = tmp;\n+\t      }\n+\t    else\n+\t      base = tmp;\n+\t  else\n+\t    if (base)\n+\t      {\n+\t\tindexexp = base;\n+\t\tbase = tmp;\n+\t      }\n+\t    else\n+\t      base = tmp;\n+\t  break;\n+\tcase MULT:\n+\t  indexexp = tmp;\n+\t  break;\n+\tcase CONST:\n+\tcase CONST_INT:\n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\t  if (offset)\n+\t    offset = gen_rtx (PLUS, SImode, tmp, offset);\n+\t  else\n+\t    offset = tmp;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  if (! offset)\n+    offset = const0_rtx;\n+  /* now, offset, base and indexexp are set */\n+  if (! base)\n+#ifdef PC_RELATIVE\n+    {\n+      if (GET_CODE (offset) == LABEL_REF || GET_CODE (offset) == SYMBOL_REF)\n+\t;\n+      else\n+#endif\n+\tPUT_ABSOLUTE_PREFIX (file);\n+#ifdef PC_RELATIVE\n+    }\n+#endif\n+\n+  output_addr_const (file,offset);\n+  if (base) /* base can be (REG ...) or (MEM ...) */\n+    switch (GET_CODE (base))\n+      {\n+\t/* now we must output base.  Possible alternatives are:\n+\t   (rN)       (REG ...)\n+\t   (sp)\t(REG ...)\n+\t   (fp)       (REG ...)\n+\t   (pc)       (REG ...)  used for SYMBOL_REF and LABEL_REF, output\n+\t   (disp(fp)) (MEM ...)       just before possible [rX:y]\n+\t   (disp(sp)) (MEM ...)\n+\t   (disp(sb)) (MEM ...)\n+\t   */\n+      case REG:\n+\tfprintf (file, \"(%s)\", reg_names[REGNO (base)]);\n+\tbreak;\n+      case MEM:\n+\taddr = XEXP(base,0);\n+\tbase = NULL;\n+\toffset = NULL;\n+\twhile (addr != NULL)\n+\t  {\n+\t    if (GET_CODE (addr) == PLUS)\n+\t      {\n+\t\tif (GET_CODE (XEXP (addr, 0)) == PLUS)\n+\t\t  {\n+\t\t    tmp = XEXP (addr, 1);\n+\t\t    addr = XEXP (addr, 0);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    tmp = XEXP (addr, 0);\n+\t\t    addr = XEXP (addr, 1);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\ttmp = addr;\n+\t\taddr = NULL;\n+\t      }\n+\t    switch (GET_CODE (tmp))\n+\t      {\n+\t      case REG:\n+\t\tbase = tmp;\n+\t\tbreak;\n+\t      case CONST:\n+\t      case CONST_INT:\n+\t      case SYMBOL_REF:\n+\t      case LABEL_REF:\n+\t\tif (offset)\n+\t\t  offset = gen_rtx (PLUS, SImode, tmp, offset);\n+\t\telse\n+\t\t  offset = tmp;\n+\t\tbreak;\n+\t      default:\n+\t\tabort ();\n+\t      }\n+\t  }\n+\tif (! offset)\n+\t  offset = const0_rtx;\n+\tfprintf (file, \"(\");\n+\toutput_addr_const (file, offset);\n+\tif (base)\n+\t  fprintf (file, \"(%s)\", reg_names[REGNO (base)]);\n+\telse if (TARGET_SB)\n+\t  fprintf (file, \"(sb)\");\n+\telse\n+\t  abort ();\n+\tfprintf (file, \")\");\n+\tbreak;\n+\n+      default:\n+\tabort ();\n+      }\n+#ifdef PC_RELATIVE\n+  else\t\t\t\t/* no base */\n+    if (GET_CODE (offset) == LABEL_REF || GET_CODE (offset) == SYMBOL_REF)\n+      fprintf (file, \"(pc)\");\n+#endif\n+#ifdef BASE_REG_NEEDED\t\t/* this is defined if the assembler always\n+\t\t\t   \t   needs a base register */\n+    else if (TARGET_SB)\n+      fprintf (file, \"(sb)\");\n+    else\n+      abort ();\n+#endif\n+  /* now print index if we have one */\n+  if (indexexp)\n+    {\n+      if (GET_CODE (indexexp) == MULT)\n+\t{\n+\t  scale = INTVAL (XEXP (indexexp, 1)) >> 1;\n+\t  indexexp = XEXP (indexexp, 0);\n+\t}\n+      else\n+\tscale = 0;\n+      if (GET_CODE (indexexp) != REG || REGNO (indexexp) >= 8)\n+\tabort ();\n+\n+      fprintf (file, \"[%s:%c]\",\n+\t       reg_names[REGNO (indexexp)],\n+\t       scales[scale]);\n+    }\n+}\n+\f\n+/* National 32032 shifting is so bad that we can get\n+   better performance in many common cases by using other\n+   techniques.  */\n+char *\n+output_shift_insn (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) > 0\n+      && INTVAL (operands[2]) <= 3)\n+    if (GET_CODE (operands[0]) == REG)\n+      {\n+\tif (GET_CODE (operands[1]) == REG)\n+\t  {\n+\t    if (REGNO (operands[0]) == REGNO (operands[1]))\n+\t      {\n+\t\tif (operands[2] == const1_rtx)\n+\t\t  return \"addd %0,%0\";\n+\t\telse if (INTVAL (operands[2]) == 2)\n+\t\t  return \"addd %0,%0\\n\\taddd %0,%0\";\n+\t      }\n+\t    if (operands[2] == const1_rtx)\n+\t      return \"movd %1,%0\\n\\taddd %0,%0\";\n+\t    \n+\t    operands[1] = gen_indexed_expr (const0_rtx, operands[1], operands[2]);\n+\t    return \"addr %a1,%0\";\n+\t  }\n+\tif (operands[2] == const1_rtx)\n+\t  return \"movd %1,%0\\n\\taddd %0,%0\";\n+      }\n+    else if (GET_CODE (operands[1]) == REG)\n+      {\n+\toperands[1] = gen_indexed_expr (const0_rtx, operands[1], operands[2]);\n+\treturn \"addr %a1,%0\";\n+      }\n+    else if (INTVAL (operands[2]) == 1\n+\t     && GET_CODE (operands[1]) == MEM\n+\t     && rtx_equal_p (operands [0], operands[1]))\n+      {\n+\trtx temp = XEXP (operands[1], 0);\n+\t\n+\tif (GET_CODE (temp) == REG\n+\t    || (GET_CODE (temp) == PLUS\n+\t\t&& GET_CODE (XEXP (temp, 0)) == REG\n+\t\t&& GET_CODE (XEXP (temp, 1)) == CONST_INT))\n+\t  return \"addd %0,%0\";\n+      }\n+    else return \"ashd %2,%0\";\n+  return \"ashd %2,%0\";\n+}"}]}