{"sha": "2c1c10ec5ac5cf9ca1bafa6dd97eaa3710033b4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMxYzEwZWM1YWM1Y2Y5Y2ExYmFmYTZkZDk3ZWFhMzcxMDAzM2I0YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-07-28T23:56:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-07-28T23:56:18Z"}, "message": "(output_decl...\n\n(output_decl, case FUNCTION_DECL): Corrected and simplified code that\ndetermined when to generate varargs or ANSI stdargs variable length\nparameter list DWARF information.\n\nFrom-SVN: r7816", "tree": {"sha": "2a1d63bd7161cc3926b82c6d249fc684d1d1e388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a1d63bd7161cc3926b82c6d249fc684d1d1e388"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c1c10ec5ac5cf9ca1bafa6dd97eaa3710033b4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c1c10ec5ac5cf9ca1bafa6dd97eaa3710033b4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c1c10ec5ac5cf9ca1bafa6dd97eaa3710033b4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c1c10ec5ac5cf9ca1bafa6dd97eaa3710033b4a/comments", "author": null, "committer": null, "parents": [{"sha": "62acb9781ff34c6da24a07e35c76927c86a20250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62acb9781ff34c6da24a07e35c76927c86a20250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62acb9781ff34c6da24a07e35c76927c86a20250"}], "stats": {"total": 173, "additions": 73, "deletions": 100}, "files": [{"sha": "ccf436b5d18da71584df9efdc49ea92222586b12", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 73, "deletions": 100, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c1c10ec5ac5cf9ca1bafa6dd97eaa3710033b4a/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c1c10ec5ac5cf9ca1bafa6dd97eaa3710033b4a/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=2c1c10ec5ac5cf9ca1bafa6dd97eaa3710033b4a", "patch": "@@ -4435,118 +4435,91 @@ output_decl (decl, containing_scope)\n \toutput_formal_types (TREE_TYPE (decl));\n       else\n \t{\n+\t  /* Generate DIEs to represent all known formal parameters */\n+\n \t  register tree arg_decls = DECL_ARGUMENTS (decl);\n+\t  register tree parm;\n+\n+\t  /* WARNING!  Kludge zone ahead!  Here we have a special\n+\t     hack for svr4 SDB compatibility.  Instead of passing the\n+\t     current FUNCTION_DECL node as the second parameter (i.e.\n+\t     the `containing_scope' parameter) to `output_decl' (as\n+\t     we ought to) we instead pass a pointer to our own private\n+\t     fake_containing_scope node.  That node is a RECORD_TYPE\n+\t     node which NO OTHER TYPE may ever actually be a member of.\n+\n+\t     This pointer will ultimately get passed into `output_type'\n+\t     as its `containing_scope' parameter.  `Output_type' will\n+\t     then perform its part in the hack... i.e. it will pend\n+\t     the type of the formal parameter onto the pending_types\n+\t     list.  Later on, when we are done generating the whole\n+\t     sequence of formal parameter DIEs for this function\n+\t     definition, we will un-pend all previously pended types\n+\t     of formal parameters for this function definition.\n+\n+\t     This whole kludge prevents any type DIEs from being\n+\t     mixed in with the formal parameter DIEs.  That's good\n+\t     because svr4 SDB believes that the list of formal\n+\t     parameter DIEs for a function ends wherever the first\n+\t     non-formal-parameter DIE appears.  Thus, we have to\n+\t     keep the formal parameter DIEs segregated.  They must\n+\t     all appear (consecutively) at the start of the list of\n+\t     children for the DIE representing the function definition.\n+\t     Then (and only then) may we output any additional DIEs\n+\t     needed to represent the types of these formal parameters.\n+\t  */\n \n-\t  {\n-\t    register tree last_arg;\n+\t  /*\n+\t     When generating DIEs, generate the unspecified_parameters\n+\t     DIE instead if we come across the arg \"__builtin_va_alist\"\n+\t  */\n \n-\t    last_arg = (arg_decls && TREE_CODE (arg_decls) != ERROR_MARK)\n-\t\t\t? tree_last (arg_decls)\n-\t\t\t: NULL;\n+\t  for (parm = arg_decls; parm; parm = TREE_CHAIN (parm))\n+\t    if (TREE_CODE (parm) == PARM_DECL)\n+              {\n+\t\tif (DECL_NAME(parm) &&\n+\t\t    !strcmp(IDENTIFIER_POINTER(DECL_NAME(parm)),\n+\t\t\t    \"__builtin_va_alist\") )\n+\t\t  output_die (output_unspecified_parameters_die, decl);\n+\t        else\n+\t\t  output_decl (parm, fake_containing_scope);\n+\t      }\n \n-\t    /* Generate DIEs to represent all known formal parameters, but\n-\t       don't do it if this looks like a varargs function.  A given\n-\t       function is considered to be a varargs function if (and only\n-\t       if) its last named argument is named `__builtin_va_alist'.  */\n+\t  /*\n+\t     Now that we have finished generating all of the DIEs to\n+\t     represent the formal parameters themselves, force out\n+\t     any DIEs needed to represent their types.  We do this\n+\t     simply by un-pending all previously pended types which\n+\t     can legitimately go into the chain of children DIEs for\n+\t     the current FUNCTION_DECL.\n+\t  */\n \n-\t    if (! last_arg\n-\t        || ! DECL_NAME (last_arg)\n-\t        || strcmp (IDENTIFIER_POINTER (DECL_NAME (last_arg)),\n-\t\t\t   \"__builtin_va_alist\"))\n-\t      {\n-\t        register tree parm;\n-\n-\t\t/* WARNING!  Kludge zone ahead!  Here we have a special\n-\t\t   hack for svr4 SDB compatibility.  Instead of passing the\n-\t\t   current FUNCTION_DECL node as the second parameter (i.e.\n-\t\t   the `containing_scope' parameter) to `output_decl' (as\n-\t\t   we ought to) we instead pass a pointer to our own private\n-\t\t   fake_containing_scope node.  That node is a RECORD_TYPE\n-\t\t   node which NO OTHER TYPE may ever actually be a member of.\n-\n-\t\t   This pointer will ultimately get passed into `output_type'\n-\t\t   as its `containing_scope' parameter.  `Output_type' will\n-\t\t   then perform its part in the hack... i.e. it will pend\n-\t\t   the type of the formal parameter onto the pending_types\n-\t\t   list.  Later on, when we are done generating the whole\n-\t\t   sequence of formal parameter DIEs for this function\n-\t\t   definition, we will un-pend all previously pended types\n-\t\t   of formal parameters for this function definition.\n-\n-\t\t   This whole kludge prevents any type DIEs from being\n-\t\t   mixed in with the formal parameter DIEs.  That's good\n-\t\t   because svr4 SDB believes that the list of formal\n-\t\t   parameter DIEs for a function ends wherever the first\n-\t\t   non-formal-parameter DIE appears.  Thus, we have to\n-\t\t   keep the formal parameter DIEs segregated.  They must\n-\t\t   all appear (consecutively) at the start of the list of\n-\t\t   children for the DIE representing the function definition.\n-\t\t   Then (and only then) may we output any additional DIEs\n-\t\t   needed to represent the types of these formal parameters.\n-\t\t*/\n-\n-\t        for (parm = arg_decls; parm; parm = TREE_CHAIN (parm))\n-\t\t  if (TREE_CODE (parm) == PARM_DECL)\n-\t\t    output_decl (parm, fake_containing_scope);\n-\n-\t\t/* Now that we have finished generating all of the DIEs to\n-\t\t   represent the formal parameters themselves, force out\n-\t\t   any DIEs needed to represent their types.  We do this\n-\t\t   simply by un-pending all previously pended types which\n-\t\t   can legitimately go into the chain of children DIEs for\n-\t\t   the current FUNCTION_DECL.  */\n-\n-\t\toutput_pending_types_for_scope (decl);\n-\t      }\n-\t  }\n+\t  output_pending_types_for_scope (decl);\n \n-\t  /* Now try to decide if we should put an ellipsis at the end. */\n+\t  /*\n+\t    Decide whether we need a unspecified_parameters DIE at the end.\n+\t    There are 2 more cases to do this for:\n+\t    1) the ansi ... declaration - this is detectable when the end\n+\t\tof the arg list is not a void_type_node\n+\t    2) an unprototyped function declaration (not a definition).  This\n+\t\tjust means that we have no info about the parameters at all.\n+\t  */\n \n \t  {\n-\t    register int has_ellipsis = TRUE;\t/* default assumption */\n \t    register tree fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n \n \t    if (fn_arg_types)\n \t      {\n-\t\t/* This function declaration/definition was prototyped.\t */\n-\n-\t\t/* If the list of formal argument types ends with a\n-\t\t   void_type_node, then the formals list did *not* end\n-\t\t   with an ellipsis.  */\n-\n-\t\tif (TREE_VALUE (tree_last (fn_arg_types)) == void_type_node)\n-\t\t  has_ellipsis = FALSE;\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* This function declaration/definition was not prototyped.  */\n-\n-\t\t/* Note that all non-prototyped function *declarations* are\n-\t\t   assumed to represent varargs functions (until proven\n-\t\t   otherwise).\t*/\n-\n-\t\tif (DECL_INITIAL (decl)) /* if this is a func definition */\n-\t\t  {\n-\t\t    if (!arg_decls)\n-\t\t      has_ellipsis = FALSE; /* no args == (void) */\n-\t\t    else\n-\t\t      {\n-\t\t\t/* For a non-prototyped function definition which\n-\t\t\t   declares one or more formal parameters, if the name\n-\t\t\t   of the first formal parameter is *not*\n-\t\t\t   __builtin_va_alist then we must assume that this\n-\t\t\t   is *not* a varargs function.\t */\n-\n-\t\t\tif (DECL_NAME (arg_decls)\n-\t\t\t  && strcmp (IDENTIFIER_POINTER (DECL_NAME (arg_decls)),\n-\t\t\t\t     \"__builtin_va_alist\"))\n-\t\t\t  has_ellipsis = FALSE;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\n-\t    if (has_ellipsis)\n-\t      output_die (output_unspecified_parameters_die, decl);\n+\t      /* this is the prototyped case, check for ... */\n+\t      if (TREE_VALUE (tree_last (fn_arg_types)) != void_type_node)\n+\t        output_die (output_unspecified_parameters_die, decl);\n+              }\n+            else\n+              {\n+\t      /* this is unprotoyped, check for undefined (just declaration) */\n+              if (!DECL_INITIAL (decl))\n+                output_die (output_unspecified_parameters_die, decl);\n+              }\n \t  }\n \t}\n "}]}