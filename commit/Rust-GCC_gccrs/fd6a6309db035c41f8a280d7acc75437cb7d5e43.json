{"sha": "fd6a6309db035c41f8a280d7acc75437cb7d5e43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ2YTYzMDlkYjAzNWM0MWY4YTI4MGQ3YWNjNzU0MzdjYjdkNWU0Mw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-11-01T20:48:50Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-11-01T20:48:50Z"}, "message": "Initial revision\n\nFrom-SVN: r30324", "tree": {"sha": "f27124748edbed386955ef2ec344e832258663ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f27124748edbed386955ef2ec344e832258663ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd6a6309db035c41f8a280d7acc75437cb7d5e43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd6a6309db035c41f8a280d7acc75437cb7d5e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd6a6309db035c41f8a280d7acc75437cb7d5e43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd6a6309db035c41f8a280d7acc75437cb7d5e43/comments", "author": null, "committer": null, "parents": [{"sha": "d9bba9c3ed159dda315f6536cf3da2739bd55e5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9bba9c3ed159dda315f6536cf3da2739bd55e5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9bba9c3ed159dda315f6536cf3da2739bd55e5e"}], "stats": {"total": 3400, "additions": 3400, "deletions": 0}, "files": [{"sha": "0fd22b70d6033132fee18c6936202d6b2bcc151c", "filename": "boehm-gc/NT_THREADS_MAKEFILE", "status": "added", "additions": 2087, "deletions": 0, "changes": 2087, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2FNT_THREADS_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2FNT_THREADS_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FNT_THREADS_MAKEFILE?ref=fd6a6309db035c41f8a280d7acc75437cb7d5e43", "patch": "@@ -0,0 +1,2087 @@\n+# Microsoft Developer Studio Generated NMAKE File, Format Version 4.10\n+# ** DO NOT EDIT **\n+\n+# TARGTYPE \"Win32 (x86) Application\" 0x0101\n+# TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\n+\n+!IF \"$(CFG)\" == \"\"\n+CFG=gctest - Win32 Release\n+!MESSAGE No configuration specified.  Defaulting to cord - Win32 Debug.\n+!ENDIF \n+\n+!IF \"$(CFG)\" != \"gc - Win32 Release\" && \"$(CFG)\" != \"gc - Win32 Debug\" &&\\\n+ \"$(CFG)\" != \"gctest - Win32 Release\" && \"$(CFG)\" != \"gctest - Win32 Debug\" &&\\\n+ \"$(CFG)\" != \"cord - Win32 Release\" && \"$(CFG)\" != \"cord - Win32 Debug\"\n+!MESSAGE Invalid configuration \"$(CFG)\" specified.\n+!MESSAGE You can specify a configuration when running NMAKE on this makefile\n+!MESSAGE by defining the macro CFG on the command line.  For example:\n+!MESSAGE \n+!MESSAGE NMAKE /f \"gc.mak\" CFG=\"cord - Win32 Debug\"\n+!MESSAGE \n+!MESSAGE Possible choices for configuration are:\n+!MESSAGE \n+!MESSAGE \"gc - Win32 Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \"gc - Win32 Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \"gctest - Win32 Release\" (based on \"Win32 (x86) Application\")\n+!MESSAGE \"gctest - Win32 Debug\" (based on \"Win32 (x86) Application\")\n+!MESSAGE \"cord - Win32 Release\" (based on \"Win32 (x86) Application\")\n+!MESSAGE \"cord - Win32 Debug\" (based on \"Win32 (x86) Application\")\n+!MESSAGE \n+!ERROR An invalid configuration is specified.\n+!ENDIF \n+\n+!IF \"$(OS)\" == \"Windows_NT\"\n+NULL=\n+!ELSE \n+NULL=nul\n+!ENDIF \n+################################################################################\n+# Begin Project\n+# PROP Target_Last_Scanned \"gctest - Win32 Debug\"\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"Release\"\n+# PROP BASE Intermediate_Dir \"Release\"\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"Release\"\n+# PROP Intermediate_Dir \"Release\"\n+# PROP Target_Dir \"\"\n+OUTDIR=.\\Release\n+INTDIR=.\\Release\n+\n+ALL : \".\\Release\\gc.dll\" \".\\Release\\gc.bsc\"\n+\n+CLEAN : \n+\t-@erase \".\\Release\\allchblk.obj\"\n+\t-@erase \".\\Release\\allchblk.sbr\"\n+\t-@erase \".\\Release\\alloc.obj\"\n+\t-@erase \".\\Release\\alloc.sbr\"\n+\t-@erase \".\\Release\\blacklst.obj\"\n+\t-@erase \".\\Release\\blacklst.sbr\"\n+\t-@erase \".\\Release\\checksums.obj\"\n+\t-@erase \".\\Release\\checksums.sbr\"\n+\t-@erase \".\\Release\\dbg_mlc.obj\"\n+\t-@erase \".\\Release\\dbg_mlc.sbr\"\n+\t-@erase \".\\Release\\dyn_load.obj\"\n+\t-@erase \".\\Release\\dyn_load.sbr\"\n+\t-@erase \".\\Release\\finalize.obj\"\n+\t-@erase \".\\Release\\finalize.sbr\"\n+\t-@erase \".\\Release\\gc.bsc\"\n+\t-@erase \".\\Release\\gc.dll\"\n+\t-@erase \".\\Release\\gc.exp\"\n+\t-@erase \".\\Release\\gc.lib\"\n+\t-@erase \".\\Release\\headers.obj\"\n+\t-@erase \".\\Release\\headers.sbr\"\n+\t-@erase \".\\Release\\mach_dep.obj\"\n+\t-@erase \".\\Release\\mach_dep.sbr\"\n+\t-@erase \".\\Release\\malloc.obj\"\n+\t-@erase \".\\Release\\malloc.sbr\"\n+\t-@erase \".\\Release\\mallocx.obj\"\n+\t-@erase \".\\Release\\mallocx.sbr\"\n+\t-@erase \".\\Release\\mark.obj\"\n+\t-@erase \".\\Release\\mark.sbr\"\n+\t-@erase \".\\Release\\mark_rts.obj\"\n+\t-@erase \".\\Release\\mark_rts.sbr\"\n+\t-@erase \".\\Release\\misc.obj\"\n+\t-@erase \".\\Release\\misc.sbr\"\n+\t-@erase \".\\Release\\new_hblk.obj\"\n+\t-@erase \".\\Release\\new_hblk.sbr\"\n+\t-@erase \".\\Release\\obj_map.obj\"\n+\t-@erase \".\\Release\\obj_map.sbr\"\n+\t-@erase \".\\Release\\os_dep.obj\"\n+\t-@erase \".\\Release\\os_dep.sbr\"\n+\t-@erase \".\\Release\\ptr_chck.obj\"\n+\t-@erase \".\\Release\\ptr_chck.sbr\"\n+\t-@erase \".\\Release\\reclaim.obj\"\n+\t-@erase \".\\Release\\reclaim.sbr\"\n+\t-@erase \".\\Release\\stubborn.obj\"\n+\t-@erase \".\\Release\\stubborn.sbr\"\n+\t-@erase \".\\Release\\typd_mlc.obj\"\n+\t-@erase \".\\Release\\typd_mlc.sbr\"\n+\t-@erase \".\\Release\\win32_threads.obj\"\n+\t-@erase \".\\Release\\win32_threads.sbr\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D\\\n+ \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n+ \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\Release/\n+CPP_SBRS=.\\Release/\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /win32\n+MTL_PROJ=/nologo /D \"NDEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"NDEBUG\"\n+# ADD RSC /l 0x809 /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gc.bsc\" \n+BSC32_SBRS= \\\n+\t\".\\Release\\allchblk.sbr\" \\\n+\t\".\\Release\\alloc.sbr\" \\\n+\t\".\\Release\\blacklst.sbr\" \\\n+\t\".\\Release\\checksums.sbr\" \\\n+\t\".\\Release\\dbg_mlc.sbr\" \\\n+\t\".\\Release\\dyn_load.sbr\" \\\n+\t\".\\Release\\finalize.sbr\" \\\n+\t\".\\Release\\headers.sbr\" \\\n+\t\".\\Release\\mach_dep.sbr\" \\\n+\t\".\\Release\\malloc.sbr\" \\\n+\t\".\\Release\\mallocx.sbr\" \\\n+\t\".\\Release\\mark.sbr\" \\\n+\t\".\\Release\\mark_rts.sbr\" \\\n+\t\".\\Release\\misc.sbr\" \\\n+\t\".\\Release\\new_hblk.sbr\" \\\n+\t\".\\Release\\obj_map.sbr\" \\\n+\t\".\\Release\\os_dep.sbr\" \\\n+\t\".\\Release\\ptr_chck.sbr\" \\\n+\t\".\\Release\\reclaim.sbr\" \\\n+\t\".\\Release\\stubborn.sbr\" \\\n+\t\".\\Release\\typd_mlc.sbr\" \\\n+\t\".\\Release\\win32_threads.sbr\"\n+\n+\".\\Release\\gc.bsc\" : \"$(OUTDIR)\" $(BSC32_SBRS)\n+    $(BSC32) @<<\n+  $(BSC32_FLAGS) $(BSC32_SBRS)\n+<<\n+\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /dll /incremental:no\\\n+ /pdb:\"$(OUTDIR)/gc.pdb\" /machine:I386 /out:\"$(OUTDIR)/gc.dll\"\\\n+ /implib:\"$(OUTDIR)/gc.lib\" \n+LINK32_OBJS= \\\n+\t\".\\Release\\allchblk.obj\" \\\n+\t\".\\Release\\alloc.obj\" \\\n+\t\".\\Release\\blacklst.obj\" \\\n+\t\".\\Release\\checksums.obj\" \\\n+\t\".\\Release\\dbg_mlc.obj\" \\\n+\t\".\\Release\\dyn_load.obj\" \\\n+\t\".\\Release\\finalize.obj\" \\\n+\t\".\\Release\\headers.obj\" \\\n+\t\".\\Release\\mach_dep.obj\" \\\n+\t\".\\Release\\malloc.obj\" \\\n+\t\".\\Release\\mallocx.obj\" \\\n+\t\".\\Release\\mark.obj\" \\\n+\t\".\\Release\\mark_rts.obj\" \\\n+\t\".\\Release\\misc.obj\" \\\n+\t\".\\Release\\new_hblk.obj\" \\\n+\t\".\\Release\\obj_map.obj\" \\\n+\t\".\\Release\\os_dep.obj\" \\\n+\t\".\\Release\\ptr_chck.obj\" \\\n+\t\".\\Release\\reclaim.obj\" \\\n+\t\".\\Release\\stubborn.obj\" \\\n+\t\".\\Release\\typd_mlc.obj\" \\\n+\t\".\\Release\\win32_threads.obj\"\n+\n+\".\\Release\\gc.dll\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 1\n+# PROP BASE Output_Dir \"Debug\"\n+# PROP BASE Intermediate_Dir \"Debug\"\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 1\n+# PROP Output_Dir \"Debug\"\n+# PROP Intermediate_Dir \"Debug\"\n+# PROP Target_Dir \"\"\n+OUTDIR=.\\Debug\n+INTDIR=.\\Debug\n+\n+ALL : \".\\Debug\\gc.dll\" \".\\Debug\\gc.bsc\"\n+\n+CLEAN : \n+\t-@erase \".\\Debug\\allchblk.obj\"\n+\t-@erase \".\\Debug\\allchblk.sbr\"\n+\t-@erase \".\\Debug\\alloc.obj\"\n+\t-@erase \".\\Debug\\alloc.sbr\"\n+\t-@erase \".\\Debug\\blacklst.obj\"\n+\t-@erase \".\\Debug\\blacklst.sbr\"\n+\t-@erase \".\\Debug\\checksums.obj\"\n+\t-@erase \".\\Debug\\checksums.sbr\"\n+\t-@erase \".\\Debug\\dbg_mlc.obj\"\n+\t-@erase \".\\Debug\\dbg_mlc.sbr\"\n+\t-@erase \".\\Debug\\dyn_load.obj\"\n+\t-@erase \".\\Debug\\dyn_load.sbr\"\n+\t-@erase \".\\Debug\\finalize.obj\"\n+\t-@erase \".\\Debug\\finalize.sbr\"\n+\t-@erase \".\\Debug\\gc.bsc\"\n+\t-@erase \".\\Debug\\gc.dll\"\n+\t-@erase \".\\Debug\\gc.exp\"\n+\t-@erase \".\\Debug\\gc.lib\"\n+\t-@erase \".\\Debug\\gc.map\"\n+\t-@erase \".\\Debug\\gc.pdb\"\n+\t-@erase \".\\Debug\\headers.obj\"\n+\t-@erase \".\\Debug\\headers.sbr\"\n+\t-@erase \".\\Debug\\mach_dep.obj\"\n+\t-@erase \".\\Debug\\mach_dep.sbr\"\n+\t-@erase \".\\Debug\\malloc.obj\"\n+\t-@erase \".\\Debug\\malloc.sbr\"\n+\t-@erase \".\\Debug\\mallocx.obj\"\n+\t-@erase \".\\Debug\\mallocx.sbr\"\n+\t-@erase \".\\Debug\\mark.obj\"\n+\t-@erase \".\\Debug\\mark.sbr\"\n+\t-@erase \".\\Debug\\mark_rts.obj\"\n+\t-@erase \".\\Debug\\mark_rts.sbr\"\n+\t-@erase \".\\Debug\\misc.obj\"\n+\t-@erase \".\\Debug\\misc.sbr\"\n+\t-@erase \".\\Debug\\new_hblk.obj\"\n+\t-@erase \".\\Debug\\new_hblk.sbr\"\n+\t-@erase \".\\Debug\\obj_map.obj\"\n+\t-@erase \".\\Debug\\obj_map.sbr\"\n+\t-@erase \".\\Debug\\os_dep.obj\"\n+\t-@erase \".\\Debug\\os_dep.sbr\"\n+\t-@erase \".\\Debug\\ptr_chck.obj\"\n+\t-@erase \".\\Debug\\ptr_chck.sbr\"\n+\t-@erase \".\\Debug\\reclaim.obj\"\n+\t-@erase \".\\Debug\\reclaim.sbr\"\n+\t-@erase \".\\Debug\\stubborn.obj\"\n+\t-@erase \".\\Debug\\stubborn.sbr\"\n+\t-@erase \".\\Debug\\typd_mlc.obj\"\n+\t-@erase \".\\Debug\\typd_mlc.sbr\"\n+\t-@erase \".\\Debug\\vc40.idb\"\n+\t-@erase \".\\Debug\\vc40.pdb\"\n+\t-@erase \".\\Debug\\win32_threads.obj\"\n+\t-@erase \".\\Debug\\win32_threads.sbr\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\"\\\n+ /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n+ \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\"\\\n+ /Fd\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\Debug/\n+CPP_SBRS=.\\Debug/\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n+# ADD MTL /nologo /D \"_DEBUG\" /win32\n+MTL_PROJ=/nologo /D \"_DEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"_DEBUG\"\n+# ADD RSC /l 0x809 /d \"_DEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gc.bsc\" \n+BSC32_SBRS= \\\n+\t\".\\Debug\\allchblk.sbr\" \\\n+\t\".\\Debug\\alloc.sbr\" \\\n+\t\".\\Debug\\blacklst.sbr\" \\\n+\t\".\\Debug\\checksums.sbr\" \\\n+\t\".\\Debug\\dbg_mlc.sbr\" \\\n+\t\".\\Debug\\dyn_load.sbr\" \\\n+\t\".\\Debug\\finalize.sbr\" \\\n+\t\".\\Debug\\headers.sbr\" \\\n+\t\".\\Debug\\mach_dep.sbr\" \\\n+\t\".\\Debug\\malloc.sbr\" \\\n+\t\".\\Debug\\mallocx.sbr\" \\\n+\t\".\\Debug\\mark.sbr\" \\\n+\t\".\\Debug\\mark_rts.sbr\" \\\n+\t\".\\Debug\\misc.sbr\" \\\n+\t\".\\Debug\\new_hblk.sbr\" \\\n+\t\".\\Debug\\obj_map.sbr\" \\\n+\t\".\\Debug\\os_dep.sbr\" \\\n+\t\".\\Debug\\ptr_chck.sbr\" \\\n+\t\".\\Debug\\reclaim.sbr\" \\\n+\t\".\\Debug\\stubborn.sbr\" \\\n+\t\".\\Debug\\typd_mlc.sbr\" \\\n+\t\".\\Debug\\win32_threads.sbr\"\n+\n+\".\\Debug\\gc.bsc\" : \"$(OUTDIR)\" $(BSC32_SBRS)\n+    $(BSC32) @<<\n+  $(BSC32_FLAGS) $(BSC32_SBRS)\n+<<\n+\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /incremental:no /map /debug /machine:I386\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /dll /incremental:no\\\n+ /pdb:\"$(OUTDIR)/gc.pdb\" /map:\"$(INTDIR)/gc.map\" /debug /machine:I386\\\n+ /out:\"$(OUTDIR)/gc.dll\" /implib:\"$(OUTDIR)/gc.lib\" \n+LINK32_OBJS= \\\n+\t\".\\Debug\\allchblk.obj\" \\\n+\t\".\\Debug\\alloc.obj\" \\\n+\t\".\\Debug\\blacklst.obj\" \\\n+\t\".\\Debug\\checksums.obj\" \\\n+\t\".\\Debug\\dbg_mlc.obj\" \\\n+\t\".\\Debug\\dyn_load.obj\" \\\n+\t\".\\Debug\\finalize.obj\" \\\n+\t\".\\Debug\\headers.obj\" \\\n+\t\".\\Debug\\mach_dep.obj\" \\\n+\t\".\\Debug\\malloc.obj\" \\\n+\t\".\\Debug\\mallocx.obj\" \\\n+\t\".\\Debug\\mark.obj\" \\\n+\t\".\\Debug\\mark_rts.obj\" \\\n+\t\".\\Debug\\misc.obj\" \\\n+\t\".\\Debug\\new_hblk.obj\" \\\n+\t\".\\Debug\\obj_map.obj\" \\\n+\t\".\\Debug\\os_dep.obj\" \\\n+\t\".\\Debug\\ptr_chck.obj\" \\\n+\t\".\\Debug\\reclaim.obj\" \\\n+\t\".\\Debug\\stubborn.obj\" \\\n+\t\".\\Debug\\typd_mlc.obj\" \\\n+\t\".\\Debug\\win32_threads.obj\"\n+\n+\".\\Debug\\gc.dll\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Release\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"gctest\\Release\"\n+# PROP BASE Intermediate_Dir \"gctest\\Release\"\n+# PROP BASE Target_Dir \"gctest\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"gctest\\Release\"\n+# PROP Intermediate_Dir \"gctest\\Release\"\n+# PROP Target_Dir \"gctest\"\n+OUTDIR=.\\gctest\\Release\n+INTDIR=.\\gctest\\Release\n+\n+ALL : \"gc - Win32 Release\" \".\\Release\\gctest.exe\"\n+\n+CLEAN : \n+\t-@erase \".\\gctest\\Release\\test.obj\"\n+\t-@erase \".\\Release\\gctest.exe\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /YX /c\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n+ \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\"\\\n+ /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\gctest\\Release/\n+CPP_SBRS=.\\.\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /win32\n+MTL_PROJ=/nologo /D \"NDEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"NDEBUG\"\n+# ADD RSC /l 0x809 /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gctest.bsc\" \n+BSC32_SBRS= \\\n+\t\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386 /out:\"Release/gctest.exe\"\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /incremental:no\\\n+ /pdb:\"$(OUTDIR)/gctest.pdb\" /machine:I386 /out:\"Release/gctest.exe\" \n+LINK32_OBJS= \\\n+\t\".\\gctest\\Release\\test.obj\" \\\n+\t\".\\Release\\gc.lib\"\n+\n+\".\\Release\\gctest.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 1\n+# PROP BASE Output_Dir \"gctest\\Debug\"\n+# PROP BASE Intermediate_Dir \"gctest\\Debug\"\n+# PROP BASE Target_Dir \"gctest\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 1\n+# PROP Output_Dir \"gctest\\Debug\"\n+# PROP Intermediate_Dir \"gctest\\Debug\"\n+# PROP Target_Dir \"gctest\"\n+OUTDIR=.\\gctest\\Debug\n+INTDIR=.\\gctest\\Debug\n+\n+ALL : \"gc - Win32 Debug\" \".\\Debug\\gctest.exe\" \".\\gctest\\Debug\\gctest.bsc\"\n+\n+CLEAN : \n+\t-@erase \".\\Debug\\gctest.exe\"\n+\t-@erase \".\\gctest\\Debug\\gctest.bsc\"\n+\t-@erase \".\\gctest\\Debug\\gctest.map\"\n+\t-@erase \".\\gctest\\Debug\\gctest.pdb\"\n+\t-@erase \".\\gctest\\Debug\\test.obj\"\n+\t-@erase \".\\gctest\\Debug\\test.sbr\"\n+\t-@erase \".\\gctest\\Debug\\vc40.idb\"\n+\t-@erase \".\\gctest\\Debug\\vc40.pdb\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\"\\\n+ /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR\"$(INTDIR)/\"\\\n+ /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\gctest\\Debug/\n+CPP_SBRS=.\\gctest\\Debug/\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n+# ADD MTL /nologo /D \"_DEBUG\" /win32\n+MTL_PROJ=/nologo /D \"_DEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"_DEBUG\"\n+# ADD RSC /l 0x809 /d \"_DEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gctest.bsc\" \n+BSC32_SBRS= \\\n+\t\".\\gctest\\Debug\\test.sbr\"\n+\n+\".\\gctest\\Debug\\gctest.bsc\" : \"$(OUTDIR)\" $(BSC32_SBRS)\n+    $(BSC32) @<<\n+  $(BSC32_FLAGS) $(BSC32_SBRS)\n+<<\n+\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /incremental:no /map /debug /machine:I386 /out:\"Debug/gctest.exe\"\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /incremental:no\\\n+ /pdb:\"$(OUTDIR)/gctest.pdb\" /map:\"$(INTDIR)/gctest.map\" /debug /machine:I386\\\n+ /out:\"Debug/gctest.exe\" \n+LINK32_OBJS= \\\n+\t\".\\Debug\\gc.lib\" \\\n+\t\".\\gctest\\Debug\\test.obj\"\n+\n+\".\\Debug\\gctest.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"cord\\Release\"\n+# PROP BASE Intermediate_Dir \"cord\\Release\"\n+# PROP BASE Target_Dir \"cord\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"cord\\Release\"\n+# PROP Intermediate_Dir \"cord\\Release\"\n+# PROP Target_Dir \"cord\"\n+OUTDIR=.\\cord\\Release\n+INTDIR=.\\cord\\Release\n+\n+ALL : \"gc - Win32 Release\" \".\\Release\\de.exe\"\n+\n+CLEAN : \n+\t-@erase \".\\cord\\Release\\cordbscs.obj\"\n+\t-@erase \".\\cord\\Release\\cordxtra.obj\"\n+\t-@erase \".\\cord\\Release\\de.obj\"\n+\t-@erase \".\\cord\\Release\\de_win.obj\"\n+\t-@erase \".\\cord\\Release\\de_win.res\"\n+\t-@erase \".\\Release\\de.exe\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MD /W3 /GX /O2 /I \".\" /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /YX /c\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /I \".\" /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n+ \"ALL_INTERIOR_POINTERS\" /Fp\"$(INTDIR)/cord.pch\" /YX /Fo\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\cord\\Release/\n+CPP_SBRS=.\\.\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /win32\n+MTL_PROJ=/nologo /D \"NDEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"NDEBUG\"\n+# ADD RSC /l 0x809 /d \"NDEBUG\"\n+RSC_PROJ=/l 0x809 /fo\"$(INTDIR)/de_win.res\" /d \"NDEBUG\" \n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/cord.bsc\" \n+BSC32_SBRS= \\\n+\t\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386 /out:\"Release/de.exe\"\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /incremental:no /pdb:\"$(OUTDIR)/de.pdb\"\\\n+ /machine:I386 /out:\"Release/de.exe\" \n+LINK32_OBJS= \\\n+\t\".\\cord\\Release\\cordbscs.obj\" \\\n+\t\".\\cord\\Release\\cordxtra.obj\" \\\n+\t\".\\cord\\Release\\de.obj\" \\\n+\t\".\\cord\\Release\\de_win.obj\" \\\n+\t\".\\cord\\Release\\de_win.res\" \\\n+\t\".\\Release\\gc.lib\"\n+\n+\".\\Release\\de.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 1\n+# PROP BASE Output_Dir \"cord\\Debug\"\n+# PROP BASE Intermediate_Dir \"cord\\Debug\"\n+# PROP BASE Target_Dir \"cord\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 1\n+# PROP Output_Dir \"cord\\Debug\"\n+# PROP Intermediate_Dir \"cord\\Debug\"\n+# PROP Target_Dir \"cord\"\n+OUTDIR=.\\cord\\Debug\n+INTDIR=.\\cord\\Debug\n+\n+ALL : \"gc - Win32 Debug\" \".\\Debug\\de.exe\"\n+\n+CLEAN : \n+\t-@erase \".\\cord\\Debug\\cordbscs.obj\"\n+\t-@erase \".\\cord\\Debug\\cordxtra.obj\"\n+\t-@erase \".\\cord\\Debug\\de.obj\"\n+\t-@erase \".\\cord\\Debug\\de.pdb\"\n+\t-@erase \".\\cord\\Debug\\de_win.obj\"\n+\t-@erase \".\\cord\\Debug\\de_win.res\"\n+\t-@erase \".\\cord\\Debug\\vc40.idb\"\n+\t-@erase \".\\cord\\Debug\\vc40.pdb\"\n+\t-@erase \".\\Debug\\de.exe\"\n+\t-@erase \".\\Debug\\de.ilk\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /YX /c\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /D \"_DEBUG\" /D \"WIN32\" /D\\\n+ \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /Fp\"$(INTDIR)/cord.pch\" /YX\\\n+ /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\cord\\Debug/\n+CPP_SBRS=.\\.\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n+# ADD MTL /nologo /D \"_DEBUG\" /win32\n+MTL_PROJ=/nologo /D \"_DEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"_DEBUG\"\n+# ADD RSC /l 0x809 /d \"_DEBUG\"\n+RSC_PROJ=/l 0x809 /fo\"$(INTDIR)/de_win.res\" /d \"_DEBUG\" \n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/cord.bsc\" \n+BSC32_SBRS= \\\n+\t\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /out:\"Debug/de.exe\"\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /incremental:yes\\\n+ /pdb:\"$(OUTDIR)/de.pdb\" /debug /machine:I386 /out:\"Debug/de.exe\" \n+LINK32_OBJS= \\\n+\t\".\\cord\\Debug\\cordbscs.obj\" \\\n+\t\".\\cord\\Debug\\cordxtra.obj\" \\\n+\t\".\\cord\\Debug\\de.obj\" \\\n+\t\".\\cord\\Debug\\de_win.obj\" \\\n+\t\".\\cord\\Debug\\de_win.res\" \\\n+\t\".\\Debug\\gc.lib\"\n+\n+\".\\Debug\\de.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ENDIF \n+\n+################################################################################\n+# Begin Target\n+\n+# Name \"gc - Win32 Release\"\n+# Name \"gc - Win32 Debug\"\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+!ENDIF \n+\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\reclaim.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_RECLA=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_RECLA=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\reclaim.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\".\\Release\\reclaim.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_RECLA=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_RECLA=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\reclaim.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\".\\Debug\\reclaim.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\os_dep.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_OS_DE=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_OS_DE=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\mm\\PCR_MM.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\".\\vd\\PCR_VD.h\"\\\n+\t\n+\n+\".\\Release\\os_dep.obj\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n+\n+\".\\Release\\os_dep.sbr\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_OS_DE=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_OS_DE=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\mm\\PCR_MM.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\".\\vd\\PCR_VD.h\"\\\n+\t\n+\n+\".\\Debug\\os_dep.obj\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n+\n+\".\\Debug\\os_dep.sbr\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\misc.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MISC_=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MISC_=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\misc.obj\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n+\n+\".\\Release\\misc.sbr\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MISC_=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MISC_=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\misc.obj\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n+\n+\".\\Debug\\misc.sbr\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\mark_rts.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MARK_=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MARK_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\mark_rts.obj\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n+\n+\".\\Release\\mark_rts.sbr\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MARK_=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MARK_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\mark_rts.obj\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n+\n+\".\\Debug\\mark_rts.sbr\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\mach_dep.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MACH_=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MACH_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\mach_dep.obj\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n+\n+\".\\Release\\mach_dep.sbr\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MACH_=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MACH_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\mach_dep.obj\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n+\n+\".\\Debug\\mach_dep.sbr\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\headers.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_HEADE=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_HEADE=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\headers.obj\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n+\n+\".\\Release\\headers.sbr\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_HEADE=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_HEADE=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\headers.obj\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n+\n+\".\\Debug\\headers.sbr\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\alloc.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_ALLOC=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_ALLOC=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\alloc.obj\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n+\n+\".\\Release\\alloc.sbr\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_ALLOC=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_ALLOC=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\alloc.obj\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n+\n+\".\\Debug\\alloc.sbr\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\allchblk.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_ALLCH=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_ALLCH=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\allchblk.obj\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n+\n+\".\\Release\\allchblk.sbr\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_ALLCH=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_ALLCH=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\allchblk.obj\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n+\n+\".\\Debug\\allchblk.sbr\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\stubborn.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_STUBB=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_STUBB=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\stubborn.obj\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n+\n+\".\\Release\\stubborn.sbr\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_STUBB=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_STUBB=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\stubborn.obj\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n+\n+\".\\Debug\\stubborn.sbr\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\obj_map.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_OBJ_M=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_OBJ_M=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\obj_map.obj\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n+\n+\".\\Release\\obj_map.sbr\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_OBJ_M=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_OBJ_M=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\obj_map.obj\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n+\n+\".\\Debug\\obj_map.sbr\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\new_hblk.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_NEW_H=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_NEW_H=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\new_hblk.obj\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n+\n+\".\\Release\\new_hblk.sbr\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_NEW_H=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_NEW_H=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\new_hblk.obj\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n+\n+\".\\Debug\\new_hblk.sbr\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\mark.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MARK_C=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MARK_C=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\mark.obj\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n+\n+\".\\Release\\mark.sbr\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MARK_C=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MARK_C=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\mark.obj\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n+\n+\".\\Debug\\mark.sbr\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\malloc.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MALLO=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MALLO=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\malloc.obj\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n+\n+\".\\Release\\malloc.sbr\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MALLO=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MALLO=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\malloc.obj\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n+\n+\".\\Debug\\malloc.sbr\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\mallocx.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MALLX=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MALLX=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\mallocx.obj\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n+\n+\".\\Release\\mallocx.sbr\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MALLX=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MALLX=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\mallocx.obj\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n+\n+\".\\Debug\\mallocx.sbr\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\finalize.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_FINAL=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_FINAL=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\finalize.obj\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n+\n+\".\\Release\\finalize.sbr\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_FINAL=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_FINAL=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\finalize.obj\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n+\n+\".\\Debug\\finalize.sbr\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\dbg_mlc.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_DBG_M=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_DBG_M=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\dbg_mlc.obj\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n+\n+\".\\Release\\dbg_mlc.sbr\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_DBG_M=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_DBG_M=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\dbg_mlc.obj\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n+\n+\".\\Debug\\dbg_mlc.sbr\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\blacklst.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_BLACK=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_BLACK=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\blacklst.obj\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n+\n+\".\\Release\\blacklst.sbr\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_BLACK=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_BLACK=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\blacklst.obj\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n+\n+\".\\Debug\\blacklst.sbr\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\typd_mlc.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_TYPD_=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t\".\\gc_typed.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_TYPD_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\typd_mlc.obj\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n+\n+\".\\Release\\typd_mlc.sbr\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_TYPD_=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t\".\\gc_typed.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_TYPD_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\typd_mlc.obj\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n+\n+\".\\Debug\\typd_mlc.sbr\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\ptr_chck.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_PTR_C=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_PTR_C=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\ptr_chck.obj\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n+\n+\".\\Release\\ptr_chck.sbr\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_PTR_C=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_PTR_C=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\ptr_chck.obj\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n+\n+\".\\Debug\\ptr_chck.sbr\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\dyn_load.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_DYN_L=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_DYN_L=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\mm\\PCR_MM.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\dyn_load.obj\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n+\n+\".\\Release\\dyn_load.sbr\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_DYN_L=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_DYN_L=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\mm\\PCR_MM.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\dyn_load.obj\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n+\n+\".\\Debug\\dyn_load.sbr\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\win32_threads.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_WIN32=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_WIN32=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\win32_threads.obj\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n+\n+\".\\Release\\win32_threads.sbr\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_WIN32=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_WIN32=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\win32_threads.obj\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n+\n+\".\\Debug\\win32_threads.sbr\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\checksums.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_CHECK=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_CHECK=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\checksums.obj\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n+\n+\".\\Release\\checksums.sbr\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_CHECK=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_CHECK=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\checksums.obj\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n+\n+\".\\Debug\\checksums.sbr\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+# End Target\n+################################################################################\n+# Begin Target\n+\n+# Name \"gctest - Win32 Release\"\n+# Name \"gctest - Win32 Debug\"\n+\n+!IF  \"$(CFG)\" == \"gctest - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n+\n+!ENDIF \n+\n+################################################################################\n+# Begin Project Dependency\n+\n+# Project_Dep_Name \"gc\"\n+\n+!IF  \"$(CFG)\" == \"gctest - Win32 Release\"\n+\n+\"gc - Win32 Release\" : \n+   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Release\" \n+\n+!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n+\n+\"gc - Win32 Debug\" : \n+   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Debug\" \n+\n+!ENDIF \n+\n+# End Project Dependency\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\test.c\n+DEP_CPP_TEST_=\\\n+\t\".\\gcconfig.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t\".\\gc_typed.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_TEST_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+!IF  \"$(CFG)\" == \"gctest - Win32 Release\"\n+\n+\n+\".\\gctest\\Release\\test.obj\" : $(SOURCE) $(DEP_CPP_TEST_) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n+\n+\n+\".\\gctest\\Debug\\test.obj\" : $(SOURCE) $(DEP_CPP_TEST_) \"$(INTDIR)\"\n+\n+\".\\gctest\\Debug\\test.sbr\" : $(SOURCE) $(DEP_CPP_TEST_) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+# End Target\n+################################################################################\n+# Begin Target\n+\n+# Name \"cord - Win32 Release\"\n+# Name \"cord - Win32 Debug\"\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+!ENDIF \n+\n+################################################################################\n+# Begin Project Dependency\n+\n+# Project_Dep_Name \"gc\"\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\"gc - Win32 Release\" : \n+   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Release\" \n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\"gc - Win32 Debug\" : \n+   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Debug\" \n+\n+!ENDIF \n+\n+# End Project Dependency\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\cord\\de_win.c\n+DEP_CPP_DE_WI=\\\n+\t\".\\cord\\cord.h\"\\\n+\t\".\\cord\\de_cmds.h\"\\\n+\t\".\\cord\\de_win.h\"\\\n+\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\n+NODEP_CPP_DE_WI=\\\n+\t\".\\cord\\gc.h\"\\\n+\t\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\n+\".\\cord\\Release\\de_win.obj\" : $(SOURCE) $(DEP_CPP_DE_WI) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\n+\".\\cord\\Debug\\de_win.obj\" : $(SOURCE) $(DEP_CPP_DE_WI) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\cord\\de.c\n+DEP_CPP_DE_C2e=\\\n+\t\".\\cord\\cord.h\"\\\n+\t\".\\cord\\de_cmds.h\"\\\n+\t\".\\cord\\de_win.h\"\\\n+\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\n+NODEP_CPP_DE_C2e=\\\n+\t\".\\cord\\gc.h\"\\\n+\t\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\n+\".\\cord\\Release\\de.obj\" : $(SOURCE) $(DEP_CPP_DE_C2e) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\n+\".\\cord\\Debug\\de.obj\" : $(SOURCE) $(DEP_CPP_DE_C2e) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\cord\\cordxtra.c\n+DEP_CPP_CORDX=\\\n+\t\".\\cord\\cord.h\"\\\n+\t\".\\cord\\ec.h\"\\\n+\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\n+NODEP_CPP_CORDX=\\\n+\t\".\\cord\\gc.h\"\\\n+\t\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\n+\".\\cord\\Release\\cordxtra.obj\" : $(SOURCE) $(DEP_CPP_CORDX) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\n+\".\\cord\\Debug\\cordxtra.obj\" : $(SOURCE) $(DEP_CPP_CORDX) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\cord\\cordbscs.c\n+DEP_CPP_CORDB=\\\n+\t\".\\cord\\cord.h\"\\\n+\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\n+NODEP_CPP_CORDB=\\\n+\t\".\\cord\\gc.h\"\\\n+\t\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\n+\".\\cord\\Release\\cordbscs.obj\" : $(SOURCE) $(DEP_CPP_CORDB) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\n+\".\\cord\\Debug\\cordbscs.obj\" : $(SOURCE) $(DEP_CPP_CORDB) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\cord\\de_win.RC\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\n+\".\\cord\\Release\\de_win.res\" : $(SOURCE) \"$(INTDIR)\"\n+   $(RSC) /l 0x809 /fo\"$(INTDIR)/de_win.res\" /i \"cord\" /d \"NDEBUG\" $(SOURCE)\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\n+\".\\cord\\Debug\\de_win.res\" : $(SOURCE) \"$(INTDIR)\"\n+   $(RSC) /l 0x809 /fo\"$(INTDIR)/de_win.res\" /i \"cord\" /d \"_DEBUG\" $(SOURCE)\n+\n+\n+!ENDIF \n+\n+# End Source File\n+# End Target\n+# End Project\n+################################################################################"}, {"sha": "d34224e42ced2a56ba216d231cd2fd326661530c", "filename": "boehm-gc/backptr.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Fbackptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Fbackptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fbackptr.h?ref=fd6a6309db035c41f8a280d7acc75437cb7d5e43", "patch": "@@ -0,0 +1,56 @@\n+/*\n+ * This is a simple API to implement pointer back tracing, i.e.\n+ * to answer questions such as \"who is pointing to this\" or\n+ * \"why is this object being retained by the collector\"\n+ *\n+ * This API assumes that we have an ANSI C compiler.\n+ *\n+ * Most of these calls yield useful information on only after\n+ * a garbage collection.  Usually the client will first force\n+ * a full collection and then gather information, preferably\n+ * before much intervening allocation.\n+ *\n+ * The implementation of the interface is only about 99.9999%\n+ * correct.  It is intended to be good enough for profiling,\n+ * but is not intended to be used with production code.\n+ *\n+ * Results are likely to be much more useful if all allocation is\n+ * accomplished through the debugging allocators.\n+ *\n+ * The implementation idea is due to A. Demers.\n+ */\n+\n+/* Store information about the object referencing dest in *base_p     */\n+/* and *offset_p.                                                     */\n+/* If multiple objects or roots point to dest, the one reported\t      */\n+/* will be the last on used by the garbage collector to trace the     */\n+/* object.\t\t\t\t\t\t\t      */\n+/*   source is root ==> *base_p = address, *offset_p = 0\t      */\n+/*   source is heap object ==> *base_p != 0, *offset_p = offset       */\n+/*   Returns 1 on success, 0 if source couldn't be determined.        */\n+/* Dest can be any address within a heap object.                      */\n+typedef enum {  GC_UNREFERENCED, /* No refence info available.\t\t*/\n+\t\tGC_NO_SPACE,\t/* Dest not allocated with debug alloc  */\n+\t\tGC_REFD_FROM_ROOT, /* Referenced directly by root *base_p */\n+\t\tGC_REFD_FROM_HEAP, /* Referenced from another heap obj. */\n+\t\tGC_FINALIZER_REFD /* Finalizable and hence accessible.  */\n+} GC_ref_kind;\n+\n+GC_ref_kind GC_get_back_ptr_info(void *dest, void **base_p, size_t *offset_p);\n+\n+/* Generate a random heap address.            */\n+/* The resulting address is in the heap, but  */\n+/* not necessarily inside a valid object.     */\n+void * GC_generate_random_heap_address(void);\n+\n+/* Generate a random address inside a valid marked heap object. */\n+void * GC_generate_random_valid_address(void);\n+\n+/* Force a garbage collection and generate a backtrace from a */\n+/* random heap address.                                       */\n+/* This uses the GC logging mechanism (GC_printf) to produce  */\n+/* output.  It can often be called from a debugger.  The      */\n+/* source in dbg_mlc.c also serves as a sample client.\t      */\n+void GC_generate_random_backtrace(void);\n+\n+"}, {"sha": "a5b2cce5f85e24a19ec3c96f64364f4e6ba2ad78", "filename": "boehm-gc/hpux_irix_threads.c", "status": "added", "additions": 745, "deletions": 0, "changes": 745, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Fhpux_irix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Fhpux_irix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fhpux_irix_threads.c?ref=fd6a6309db035c41f8a280d7acc75437cb7d5e43", "patch": "@@ -0,0 +1,745 @@\n+/* \n+ * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/*\n+ * Support code for Irix (>=6.2) Pthreads.  This relies on properties\n+ * not guaranteed by the Pthread standard.  It may or may not be portable\n+ * to other implementations.\n+ *\n+ * This now also includes an initial attempt at thread support for\n+ * HP/UX 11.\n+ *\n+ * Note that there is a lot of code duplication between linux_threads.c\n+ * and hpux_irix_threads.c; any changes made here may need to be reflected\n+ * there too.\n+ */\n+\n+# if defined(IRIX_THREADS) || defined(HPUX_THREADS)\n+\n+# if defined(HPUX_THREADS)\n+#   include <sys/semaphore.h>\n+# endif\n+\n+# include \"gc_priv.h\"\n+# include <pthread.h>\n+# include <semaphore.h>\n+# include <time.h>\n+# include <errno.h>\n+# include <unistd.h>\n+# include <sys/mman.h>\n+# include <sys/time.h>\n+\n+#undef pthread_create\n+#undef pthread_sigmask\n+#undef pthread_join\n+\n+void GC_thr_init();\n+\n+#if 0\n+void GC_print_sig_mask()\n+{\n+    sigset_t blocked;\n+    int i;\n+\n+    if (pthread_sigmask(SIG_BLOCK, NULL, &blocked) != 0)\n+    \tABORT(\"pthread_sigmask\");\n+    GC_printf0(\"Blocked: \");\n+    for (i = 1; i <= MAXSIG; i++) {\n+        if (sigismember(&blocked, i)) { GC_printf1(\"%ld \",(long) i); }\n+    }\n+    GC_printf0(\"\\n\");\n+}\n+#endif\n+\n+/* We use the allocation lock to protect thread-related data structures. */\n+\n+/* The set of all known threads.  We intercept thread creation and \t*/\n+/* joins.  We never actually create detached threads.  We allocate all \t*/\n+/* new thread stacks ourselves.  These allow us to maintain this\t*/\n+/* data structure.\t\t\t\t\t\t\t*/\n+/* Protected by GC_thr_lock.\t\t\t\t\t\t*/\n+/* Some of this should be declared volatile, but that's incosnsistent\t*/\n+/* with some library routine declarations.  \t\t \t\t*/\n+typedef struct GC_Thread_Rep {\n+    struct GC_Thread_Rep * next;  /* More recently allocated threads\t*/\n+\t\t\t\t  /* with a given pthread id come \t*/\n+\t\t\t\t  /* first.  (All but the first are\t*/\n+\t\t\t\t  /* guaranteed to be dead, but we may  */\n+\t\t\t\t  /* not yet have registered the join.) */\n+    pthread_t id;\n+    word stop;\n+#\tdefine NOT_STOPPED 0\n+#\tdefine PLEASE_STOP 1\n+#\tdefine STOPPED 2\n+    word flags;\n+#\tdefine FINISHED 1   \t/* Thread has exited.\t*/\n+#\tdefine DETACHED 2\t/* Thread is intended to be detached.\t*/\n+#\tdefine CLIENT_OWNS_STACK\t4\n+\t\t\t\t/* Stack was supplied by client.\t*/\n+    ptr_t stack;\n+    ptr_t stack_ptr;  \t\t/* Valid only when stopped. */\n+\t\t\t\t/* But must be within stack region at\t*/\n+\t\t\t\t/* all times.\t\t\t\t*/\n+    size_t stack_size;\t\t/* 0 for original thread.\t*/\n+    void * status;\t\t/* Used only to avoid premature \t*/\n+\t\t\t\t/* reclamation of any data it might \t*/\n+\t\t\t\t/* reference.\t\t\t\t*/\n+} * GC_thread;\n+\n+GC_thread GC_lookup_thread(pthread_t id);\n+\n+/*\n+ * The only way to suspend threads given the pthread interface is to send\n+ * signals.  Unfortunately, this means we have to reserve\n+ * a signal, and intercept client calls to change the signal mask.\n+ */\n+# define SIG_SUSPEND (SIGRTMIN + 6)\n+\n+pthread_mutex_t GC_suspend_lock = PTHREAD_MUTEX_INITIALIZER;\n+\t\t\t\t/* Number of threads stopped so far\t*/\n+pthread_cond_t GC_suspend_ack_cv = PTHREAD_COND_INITIALIZER;\n+pthread_cond_t GC_continue_cv = PTHREAD_COND_INITIALIZER;\n+\n+void GC_suspend_handler(int sig)\n+{\n+    int dummy;\n+    GC_thread me;\n+    sigset_t all_sigs;\n+    sigset_t old_sigs;\n+    int i;\n+\n+    if (sig != SIG_SUSPEND) ABORT(\"Bad signal in suspend_handler\");\n+    me = GC_lookup_thread(pthread_self());\n+    /* The lookup here is safe, since I'm doing this on behalf  */\n+    /* of a thread which holds the allocation lock in order\t*/\n+    /* to stop the world.  Thus concurrent modification of the\t*/\n+    /* data structure is impossible.\t\t\t\t*/\n+    if (PLEASE_STOP != me -> stop) {\n+\t/* Misdirected signal.\t*/\n+\tpthread_mutex_unlock(&GC_suspend_lock);\n+\treturn;\n+    }\n+    pthread_mutex_lock(&GC_suspend_lock);\n+    me -> stack_ptr = (ptr_t)(&dummy);\n+    me -> stop = STOPPED;\n+    pthread_cond_signal(&GC_suspend_ack_cv);\n+    pthread_cond_wait(&GC_continue_cv, &GC_suspend_lock);\n+    pthread_mutex_unlock(&GC_suspend_lock);\n+    /* GC_printf1(\"Continuing 0x%x\\n\", pthread_self()); */\n+}\n+\n+\n+GC_bool GC_thr_initialized = FALSE;\n+\n+size_t GC_min_stack_sz;\n+\n+size_t GC_page_sz;\n+\n+# define N_FREE_LISTS 25\n+ptr_t GC_stack_free_lists[N_FREE_LISTS] = { 0 };\n+\t\t/* GC_stack_free_lists[i] is free list for stacks of \t*/\n+\t\t/* size GC_min_stack_sz*2**i.\t\t\t\t*/\n+\t\t/* Free lists are linked through first word.\t\t*/\n+\n+/* Return a stack of size at least *stack_size.  *stack_size is\t*/\n+/* replaced by the actual stack size.\t\t\t\t*/\n+/* Caller holds allocation lock.\t\t\t\t*/\n+ptr_t GC_stack_alloc(size_t * stack_size)\n+{\n+    register size_t requested_sz = *stack_size;\n+    register size_t search_sz = GC_min_stack_sz;\n+    register int index = 0;\t/* = log2(search_sz/GC_min_stack_sz) */\n+    register ptr_t result;\n+    \n+    while (search_sz < requested_sz) {\n+        search_sz *= 2;\n+        index++;\n+    }\n+    if ((result = GC_stack_free_lists[index]) == 0\n+        && (result = GC_stack_free_lists[index+1]) != 0) {\n+        /* Try next size up. */\n+        search_sz *= 2; index++;\n+    }\n+    if (result != 0) {\n+        GC_stack_free_lists[index] = *(ptr_t *)result;\n+    } else {\n+        result = (ptr_t) GC_scratch_alloc(search_sz + 2*GC_page_sz);\n+        result = (ptr_t)(((word)result + GC_page_sz) & ~(GC_page_sz - 1));\n+        /* Protect hottest page to detect overflow. */\n+#\tifdef STACK_GROWS_UP\n+          /* mprotect(result + search_sz, GC_page_sz, PROT_NONE); */\n+#\telse\n+          /* mprotect(result, GC_page_sz, PROT_NONE); */\n+          result += GC_page_sz;\n+#\tendif\n+    }\n+    *stack_size = search_sz;\n+    return(result);\n+}\n+\n+/* Caller holds allocation lock.\t\t\t\t\t*/\n+void GC_stack_free(ptr_t stack, size_t size)\n+{\n+    register int index = 0;\n+    register size_t search_sz = GC_min_stack_sz;\n+    \n+    while (search_sz < size) {\n+        search_sz *= 2;\n+        index++;\n+    }\n+    if (search_sz != size) ABORT(\"Bad stack size\");\n+    *(ptr_t *)stack = GC_stack_free_lists[index];\n+    GC_stack_free_lists[index] = stack;\n+}\n+\n+\n+\n+# define THREAD_TABLE_SZ 128\t/* Must be power of 2\t*/\n+volatile GC_thread GC_threads[THREAD_TABLE_SZ];\n+\n+/* Add a thread to GC_threads.  We assume it wasn't already there.\t*/\n+/* Caller holds allocation lock.\t\t\t\t\t*/\n+GC_thread GC_new_thread(pthread_t id)\n+{\n+    int hv = ((word)id) % THREAD_TABLE_SZ;\n+    GC_thread result;\n+    static struct GC_Thread_Rep first_thread;\n+    static GC_bool first_thread_used = FALSE;\n+    \n+    if (!first_thread_used) {\n+    \tresult = &first_thread;\n+    \tfirst_thread_used = TRUE;\n+    \t/* Dont acquire allocation lock, since we may already hold it. */\n+    } else {\n+        result = (struct GC_Thread_Rep *)\n+        \t GC_generic_malloc_inner(sizeof(struct GC_Thread_Rep), NORMAL);\n+    }\n+    if (result == 0) return(0);\n+    result -> id = id;\n+    result -> next = GC_threads[hv];\n+    GC_threads[hv] = result;\n+    /* result -> flags = 0;     */\n+    /* result -> stop = 0;\t*/\n+    return(result);\n+}\n+\n+/* Delete a thread from GC_threads.  We assume it is there.\t*/\n+/* (The code intentionally traps if it wasn't.)\t\t\t*/\n+/* Caller holds allocation lock.\t\t\t\t*/\n+void GC_delete_thread(pthread_t id)\n+{\n+    int hv = ((word)id) % THREAD_TABLE_SZ;\n+    register GC_thread p = GC_threads[hv];\n+    register GC_thread prev = 0;\n+    \n+    while (!pthread_equal(p -> id, id)) {\n+        prev = p;\n+        p = p -> next;\n+    }\n+    if (prev == 0) {\n+        GC_threads[hv] = p -> next;\n+    } else {\n+        prev -> next = p -> next;\n+    }\n+}\n+\n+/* If a thread has been joined, but we have not yet\t\t*/\n+/* been notified, then there may be more than one thread \t*/\n+/* in the table with the same pthread id.\t\t\t*/\n+/* This is OK, but we need a way to delete a specific one.\t*/\n+void GC_delete_gc_thread(pthread_t id, GC_thread gc_id)\n+{\n+    int hv = ((word)id) % THREAD_TABLE_SZ;\n+    register GC_thread p = GC_threads[hv];\n+    register GC_thread prev = 0;\n+\n+    while (p != gc_id) {\n+        prev = p;\n+        p = p -> next;\n+    }\n+    if (prev == 0) {\n+        GC_threads[hv] = p -> next;\n+    } else {\n+        prev -> next = p -> next;\n+    }\n+}\n+\n+/* Return a GC_thread corresponding to a given thread_t.\t*/\n+/* Returns 0 if it's not there.\t\t\t\t\t*/\n+/* Caller holds  allocation lock or otherwise inhibits \t\t*/\n+/* updates.\t\t\t\t\t\t\t*/\n+/* If there is more than one thread with the given id we \t*/\n+/* return the most recent one.\t\t\t\t\t*/\n+GC_thread GC_lookup_thread(pthread_t id)\n+{\n+    int hv = ((word)id) % THREAD_TABLE_SZ;\n+    register GC_thread p = GC_threads[hv];\n+    \n+    while (p != 0 && !pthread_equal(p -> id, id)) p = p -> next;\n+    return(p);\n+}\n+\n+\n+/* Caller holds allocation lock.\t*/\n+void GC_stop_world()\n+{\n+    pthread_t my_thread = pthread_self();\n+    register int i;\n+    register GC_thread p;\n+    register int result;\n+    struct timespec timeout;\n+    \n+    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n+      for (p = GC_threads[i]; p != 0; p = p -> next) {\n+        if (p -> id != my_thread) {\n+            if (p -> flags & FINISHED) {\n+\t\tp -> stop = STOPPED;\n+\t\tcontinue;\n+\t    }\n+\t    p -> stop = PLEASE_STOP;\n+            result = pthread_kill(p -> id, SIG_SUSPEND);\n+\t    /* GC_printf1(\"Sent signal to 0x%x\\n\", p -> id); */\n+\t    switch(result) {\n+                case ESRCH:\n+                    /* Not really there anymore.  Possible? */\n+                    p -> stop = STOPPED;\n+                    break;\n+                case 0:\n+                    break;\n+                default:\n+                    ABORT(\"pthread_kill failed\");\n+            }\n+        }\n+      }\n+    }\n+    pthread_mutex_lock(&GC_suspend_lock);\n+    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n+      for (p = GC_threads[i]; p != 0; p = p -> next) {\n+        while (p -> id != my_thread && p -> stop != STOPPED) {\n+\t    clock_gettime(CLOCK_REALTIME, &timeout);\n+            timeout.tv_nsec += 50000000; /* 50 msecs */\n+            if (timeout.tv_nsec >= 1000000000) {\n+                timeout.tv_nsec -= 1000000000;\n+                ++timeout.tv_sec;\n+            }\n+            result = pthread_cond_timedwait(&GC_suspend_ack_cv,\n+\t\t\t\t\t    &GC_suspend_lock,\n+                                            &timeout);\n+            if (result == ETIMEDOUT) {\n+                /* Signal was lost or misdirected.  Try again.      */\n+                /* Duplicate signals should be benign.              */\n+                result = pthread_kill(p -> id, SIG_SUSPEND);\n+\t    }\n+\t}\n+      }\n+    }\n+    pthread_mutex_unlock(&GC_suspend_lock);\n+    /* GC_printf1(\"World stopped 0x%x\\n\", pthread_self()); */\n+}\n+\n+/* Caller holds allocation lock.\t*/\n+void GC_start_world()\n+{\n+    GC_thread p;\n+    unsigned i;\n+\n+    /* GC_printf0(\"World starting\\n\"); */\n+    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n+      for (p = GC_threads[i]; p != 0; p = p -> next) {\n+\tp -> stop = NOT_STOPPED;\n+      }\n+    }\n+    pthread_mutex_lock(&GC_suspend_lock);\n+    /* All other threads are at pthread_cond_wait in signal handler.\t*/\n+    /* Otherwise we couldn't have acquired the lock.\t\t\t*/\n+    pthread_mutex_unlock(&GC_suspend_lock);\n+    pthread_cond_broadcast(&GC_continue_cv);\n+}\n+\n+# ifdef MMAP_STACKS\n+--> not really supported yet.\n+int GC_is_thread_stack(ptr_t addr)\n+{\n+    register int i;\n+    register GC_thread p;\n+\n+    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n+      for (p = GC_threads[i]; p != 0; p = p -> next) {\n+        if (p -> stack_size != 0) {\n+            if (p -> stack <= addr &&\n+                addr < p -> stack + p -> stack_size)\n+                   return 1;\n+       }\n+      }\n+    }\n+    return 0;\n+}\n+# endif\n+\n+/* We hold allocation lock.  We assume the world is stopped.\t*/\n+void GC_push_all_stacks()\n+{\n+    register int i;\n+    register GC_thread p;\n+    register ptr_t sp = GC_approx_sp();\n+    register ptr_t hot, cold;\n+    pthread_t me = pthread_self();\n+    \n+    if (!GC_thr_initialized) GC_thr_init();\n+    /* GC_printf1(\"Pushing stacks from thread 0x%x\\n\", me); */\n+    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n+      for (p = GC_threads[i]; p != 0; p = p -> next) {\n+        if (p -> flags & FINISHED) continue;\n+        if (pthread_equal(p -> id, me)) {\n+\t    hot = GC_approx_sp();\n+\t} else {\n+\t    hot = p -> stack_ptr;\n+\t}\n+        if (p -> stack_size != 0) {\n+#\t  ifdef STACK_GROWS_UP\n+\t    cold = p -> stack;\n+#\t  else\n+            cold = p -> stack + p -> stack_size;\n+#\t  endif\n+        } else {\n+            /* The original stack. */\n+            cold = GC_stackbottom;\n+        }\n+#\tifdef STACK_GROWS_UP\n+          GC_push_all_stack(cold, hot);\n+#\telse\n+          GC_push_all_stack(hot, cold);\n+#\tendif\n+      }\n+    }\n+}\n+\n+\n+/* We hold the allocation lock.\t*/\n+void GC_thr_init()\n+{\n+    GC_thread t;\n+    struct sigaction act;\n+\n+    if (GC_thr_initialized) return;\n+    GC_thr_initialized = TRUE;\n+    GC_min_stack_sz = HBLKSIZE;\n+    GC_page_sz = sysconf(_SC_PAGESIZE);\n+    (void) sigaction(SIG_SUSPEND, 0, &act);\n+    if (act.sa_handler != SIG_DFL)\n+    \tABORT(\"Previously installed SIG_SUSPEND handler\");\n+    /* Install handler.\t*/\n+\tact.sa_handler = GC_suspend_handler;\n+\tact.sa_flags = SA_RESTART;\n+\t(void) sigemptyset(&act.sa_mask);\n+        if (0 != sigaction(SIG_SUSPEND, &act, 0))\n+\t    ABORT(\"Failed to install SIG_SUSPEND handler\");\n+    /* Add the initial thread, so we can stop it.\t*/\n+      t = GC_new_thread(pthread_self());\n+      t -> stack_size = 0;\n+      t -> stack_ptr = (ptr_t)(&t);\n+      t -> flags = DETACHED;\n+}\n+\n+int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset)\n+{\n+    sigset_t fudged_set;\n+    \n+    if (set != NULL && (how == SIG_BLOCK || how == SIG_SETMASK)) {\n+        fudged_set = *set;\n+        sigdelset(&fudged_set, SIG_SUSPEND);\n+        set = &fudged_set;\n+    }\n+    return(pthread_sigmask(how, set, oset));\n+}\n+\n+struct start_info {\n+    void *(*start_routine)(void *);\n+    void *arg;\n+    word flags;\n+    ptr_t stack;\n+    size_t stack_size;\n+    sem_t registered;   \t/* 1 ==> in our thread table, but \t*/\n+\t\t\t\t/* parent hasn't yet noticed.\t\t*/\n+};\n+\n+void GC_thread_exit_proc(void *arg)\n+{\n+    GC_thread me;\n+\n+    LOCK();\n+    me = GC_lookup_thread(pthread_self());\n+    if (me -> flags & DETACHED) {\n+    \tGC_delete_thread(pthread_self());\n+    } else {\n+\tme -> flags |= FINISHED;\n+    }\n+    UNLOCK();\n+}\n+\n+int GC_pthread_join(pthread_t thread, void **retval)\n+{\n+    int result;\n+    GC_thread thread_gc_id;\n+    \n+    LOCK();\n+    thread_gc_id = GC_lookup_thread(thread);\n+    /* This is guaranteed to be the intended one, since the thread id\t*/\n+    /* cant have been recycled by pthreads.\t\t\t\t*/\n+    UNLOCK();\n+    result = pthread_join(thread, retval);\n+    /* Some versions of the Irix pthreads library can erroneously \t*/\n+    /* return EINTR when the call succeeds.\t\t\t\t*/\n+\tif (EINTR == result) result = 0;\n+    LOCK();\n+    /* Here the pthread thread id may have been recycled. */\n+    GC_delete_gc_thread(thread, thread_gc_id);\n+    UNLOCK();\n+    return result;\n+}\n+\n+void * GC_start_routine(void * arg)\n+{\n+    struct start_info * si = arg;\n+    void * result;\n+    GC_thread me;\n+    pthread_t my_pthread;\n+    void *(*start)(void *);\n+    void *start_arg;\n+\n+    my_pthread = pthread_self();\n+    /* If a GC occurs before the thread is registered, that GC will\t*/\n+    /* ignore this thread.  That's fine, since it will block trying to  */\n+    /* acquire the allocation lock, and won't yet hold interesting \t*/\n+    /* pointers.\t\t\t\t\t\t\t*/\n+    LOCK();\n+    /* We register the thread here instead of in the parent, so that\t*/\n+    /* we don't need to hold the allocation lock during pthread_create. */\n+    /* Holding the allocation lock there would make REDIRECT_MALLOC\t*/\n+    /* impossible.  It probably still doesn't work, but we're a little  */\n+    /* closer ...\t\t\t\t\t\t\t*/\n+    /* This unfortunately means that we have to be careful the parent\t*/\n+    /* doesn't try to do a pthread_join before we're registered.\t*/\n+    me = GC_new_thread(my_pthread);\n+    me -> flags = si -> flags;\n+    me -> stack = si -> stack;\n+    me -> stack_size = si -> stack_size;\n+    me -> stack_ptr = (ptr_t)si -> stack + si -> stack_size - sizeof(word);\n+    UNLOCK();\n+    start = si -> start_routine;\n+    start_arg = si -> arg;\n+    sem_post(&(si -> registered));\n+    pthread_cleanup_push(GC_thread_exit_proc, 0);\n+    result = (*start)(start_arg);\n+    me -> status = result;\n+    me -> flags |= FINISHED;\n+    pthread_cleanup_pop(1);\n+\t/* This involves acquiring the lock, ensuring that we can't exit */\n+\t/* while a collection that thinks we're alive is trying to stop  */\n+\t/* us.\t\t\t\t\t\t\t\t */\n+    return(result);\n+}\n+\n+# ifdef HPUX_THREADS\n+  /* pthread_attr_t is not a structure, thus a simple structure copy\t*/\n+  /* won't work.\t\t\t\t\t\t\t*/\n+  static void copy_attr(pthread_attr_t * pa_ptr,\n+\t\t\tconst pthread_attr_t  * source) {\n+    int tmp;\n+    size_t stmp;\n+    void * vtmp;\n+    struct sched_param sp_tmp;\n+    pthread_spu_t ps_tmp;\n+    (void) pthread_attr_init(pa_ptr);\n+    (void) pthread_attr_getdetachstate(source, &tmp);\n+    (void) pthread_attr_setdetachstate(pa_ptr, tmp);\n+    (void) pthread_attr_getinheritsched(source, &tmp);\n+    (void) pthread_attr_setinheritsched(pa_ptr, tmp);\n+    (void) pthread_attr_getschedpolicy(source, &tmp);\n+    (void) pthread_attr_setschedpolicy(pa_ptr, tmp);\n+    (void) pthread_attr_getstacksize(source, &stmp);\n+    (void) pthread_attr_setstacksize(pa_ptr, stmp);\n+    (void) pthread_attr_getguardsize(source, &stmp);\n+    (void) pthread_attr_setguardsize(pa_ptr, stmp);\n+    (void) pthread_attr_getstackaddr(source, &vtmp);\n+    (void) pthread_attr_setstackaddr(pa_ptr, vtmp);\n+    (void) pthread_attr_getscope(source, &tmp);\n+    (void) pthread_attr_setscope(pa_ptr, tmp);\n+    (void) pthread_attr_getschedparam(source, &sp_tmp);\n+    (void) pthread_attr_setschedparam(pa_ptr, &sp_tmp);\n+    (void) pthread_attr_getprocessor_np(source, &ps_tmp, &tmp);\n+    (void) pthread_attr_setprocessor_np(pa_ptr, ps_tmp, tmp);\n+  }\n+# else\n+#   define copy_attr(pa_ptr, source) *(pa_ptr) = *(source)\n+# endif\n+\n+int\n+GC_pthread_create(pthread_t *new_thread,\n+\t\t  const pthread_attr_t *attr,\n+                  void *(*start_routine)(void *), void *arg)\n+{\n+    int result;\n+    GC_thread t;\n+    void * stack;\n+    size_t stacksize;\n+    pthread_attr_t new_attr;\n+    int detachstate;\n+    word my_flags = 0;\n+    struct start_info * si = GC_malloc(sizeof(struct start_info)); \n+\t/* This is otherwise saved only in an area mmapped by the thread */\n+\t/* library, which isn't visible to the collector.\t\t */\n+\n+    if (0 == si) return(ENOMEM);\n+    if (0 != sem_init(&(si -> registered), 0, 0)) {\n+        ABORT(\"sem_init failed\");\n+    }\n+    si -> start_routine = start_routine;\n+    si -> arg = arg;\n+    LOCK();\n+    if (!GC_thr_initialized) GC_thr_init();\n+    if (NULL == attr) {\n+        stack = 0;\n+\t(void) pthread_attr_init(&new_attr);\n+    } else {\n+\tcopy_attr(&new_attr, attr);\n+\tpthread_attr_getstackaddr(&new_attr, &stack);\n+    }\n+    pthread_attr_getstacksize(&new_attr, &stacksize);\n+    pthread_attr_getdetachstate(&new_attr, &detachstate);\n+    if (stacksize < GC_min_stack_sz) ABORT(\"Stack too small\");\n+    if (0 == stack) {\n+     \tstack = (void *)GC_stack_alloc(&stacksize);\n+     \tif (0 == stack) {\n+     \t    UNLOCK();\n+     \t    return(ENOMEM);\n+     \t}\n+\tpthread_attr_setstackaddr(&new_attr, stack);\n+    } else {\n+    \tmy_flags |= CLIENT_OWNS_STACK;\n+    }\n+    if (PTHREAD_CREATE_DETACHED == detachstate) my_flags |= DETACHED;\n+    si -> flags = my_flags;\n+    si -> stack = stack;\n+    si -> stack_size = stacksize;\n+    result = pthread_create(new_thread, &new_attr, GC_start_routine, si);\n+    if (0 == new_thread && !(my_flags & CLIENT_OWNS_STACK)) {\n+      \tGC_stack_free(stack, stacksize);\n+    }        \n+    UNLOCK();  \n+    /* Wait until child has been added to the thread table.\t\t*/\n+    /* This also ensures that we hold onto si until the child is done\t*/\n+    /* with it.  Thus it doesn't matter whether it is otherwise\t\t*/\n+    /* visible to the collector.\t\t\t\t\t*/\n+        while (0 != sem_wait(&(si -> registered))) {\n+\t  if (errno != EINTR) {\n+\t    GC_printf1(\"Sem_wait: errno = %ld\\n\", (unsigned long) errno);\n+\t    ABORT(\"sem_wait failed\");\n+\t  }\n+\t}\n+        sem_destroy(&(si -> registered));\n+    pthread_attr_destroy(&new_attr);  /* Not a no-op under HPUX */\n+    return(result);\n+}\n+\n+#ifndef HPUX_THREADS\n+/* For now we use the pthreads locking primitives on HP/UX */\n+\n+GC_bool GC_collecting = 0; /* A hint that we're in the collector and       */\n+                        /* holding the allocation lock for an           */\n+                        /* extended period.                             */\n+\n+/* Reasonably fast spin locks.  Basically the same implementation */\n+/* as STL alloc.h.\t\t\t\t\t\t  */\n+\n+#define SLEEP_THRESHOLD 3\n+\n+#ifdef HPUX\n+   unsigned long GC_allocate_lock = 1;\n+#  define GC_TRY_LOCK() GC_test_and_clear(&GC_allocate_lock)\n+#  define GC_LOCK_TAKEN !GC_allocate_lock\n+#else\n+   unsigned long GC_allocate_lock = 0;\n+#  define GC_TRY_LOCK() !GC_test_and_set(&GC_allocate_lock,1)\n+#  define GC_LOCK_TAKEN GC_allocate_lock\n+#endif\n+\n+void GC_lock()\n+{\n+#   define low_spin_max 30  /* spin cycles if we suspect uniprocessor */\n+#   define high_spin_max 1000 /* spin cycles for multiprocessor */\n+    static unsigned spin_max = low_spin_max;\n+    unsigned my_spin_max;\n+    static unsigned last_spins = 0;\n+    unsigned my_last_spins;\n+    volatile unsigned junk;\n+#   define PAUSE junk *= junk; junk *= junk; junk *= junk; junk *= junk\n+    int i;\n+\n+    if (GC_TRY_LOCK()) {\n+        return;\n+    }\n+    junk = 0;\n+    my_spin_max = spin_max;\n+    my_last_spins = last_spins;\n+    for (i = 0; i < my_spin_max; i++) {\n+        if (GC_collecting) goto yield;\n+        if (i < my_last_spins/2 || GC_LOCK_TAKEN) {\n+            PAUSE; \n+            continue;\n+        }\n+        if (GC_TRY_LOCK()) {\n+\t    /*\n+             * got it!\n+             * Spinning worked.  Thus we're probably not being scheduled\n+             * against the other process with which we were contending.\n+             * Thus it makes sense to spin longer the next time.\n+\t     */\n+            last_spins = i;\n+            spin_max = high_spin_max;\n+            return;\n+        }\n+    }\n+    /* We are probably being scheduled against the other process.  Sleep. */\n+    spin_max = low_spin_max;\n+yield:\n+    for (i = 0;; ++i) {\n+        if (GC_TRY_LOCK()) {\n+            return;\n+        }\n+        if (i < SLEEP_THRESHOLD) {\n+            sched_yield();\n+\t} else {\n+\t    struct timespec ts;\n+\t\n+\t    if (i > 26) i = 26;\n+\t\t\t/* Don't wait for more than about 60msecs, even\t*/\n+\t\t\t/* under extreme contention.\t\t\t*/\n+\t    ts.tv_sec = 0;\n+\t    ts.tv_nsec = 1 << i;\n+\t    nanosleep(&ts, 0);\n+\t}\n+    }\n+}\n+\n+#endif /* !HPUX_THREADS */\n+\n+# else\n+\n+#ifndef LINT\n+  int GC_no_Irix_threads;\n+#endif\n+\n+# endif /* IRIX_THREADS */\n+"}, {"sha": "f09b211404bf7cbb6f58d88e369b9f0794074f6c", "filename": "boehm-gc/hpux_test_and_clear.s", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Fhpux_test_and_clear.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Fhpux_test_and_clear.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fhpux_test_and_clear.s?ref=fd6a6309db035c41f8a280d7acc75437cb7d5e43", "patch": "@@ -0,0 +1,21 @@\n+\t.SPACE $PRIVATE$\n+\t.SUBSPA $DATA$,QUAD=1,ALIGN=8,ACCESS=31\n+\t.SUBSPA $BSS$,QUAD=1,ALIGN=8,ACCESS=31,ZERO,SORT=82\n+\t.SPACE $TEXT$\n+\t.SUBSPA $LIT$,QUAD=0,ALIGN=8,ACCESS=44\n+\t.SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n+\t.IMPORT $global$,DATA\n+\t.IMPORT $$dyncall,MILLICODE\n+\t.SPACE $TEXT$\n+\t.SUBSPA $CODE$\n+\n+\t.align 4\n+\t.EXPORT GC_test_and_clear,ENTRY,PRIV_LEV=3,ARGW0=GR,RTNVAL=GR\n+GC_test_and_clear\n+\t.PROC\n+\t.CALLINFO FRAME=0,NO_CALLS\n+\t.ENTRY\n+\tldcw,co (%r26),%r28\n+\tbv,n 0(%r2)\n+\t.EXIT\n+\t.PROCEND"}, {"sha": "d34224e42ced2a56ba216d231cd2fd326661530c", "filename": "boehm-gc/include/backptr.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Finclude%2Fbackptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Finclude%2Fbackptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fbackptr.h?ref=fd6a6309db035c41f8a280d7acc75437cb7d5e43", "patch": "@@ -0,0 +1,56 @@\n+/*\n+ * This is a simple API to implement pointer back tracing, i.e.\n+ * to answer questions such as \"who is pointing to this\" or\n+ * \"why is this object being retained by the collector\"\n+ *\n+ * This API assumes that we have an ANSI C compiler.\n+ *\n+ * Most of these calls yield useful information on only after\n+ * a garbage collection.  Usually the client will first force\n+ * a full collection and then gather information, preferably\n+ * before much intervening allocation.\n+ *\n+ * The implementation of the interface is only about 99.9999%\n+ * correct.  It is intended to be good enough for profiling,\n+ * but is not intended to be used with production code.\n+ *\n+ * Results are likely to be much more useful if all allocation is\n+ * accomplished through the debugging allocators.\n+ *\n+ * The implementation idea is due to A. Demers.\n+ */\n+\n+/* Store information about the object referencing dest in *base_p     */\n+/* and *offset_p.                                                     */\n+/* If multiple objects or roots point to dest, the one reported\t      */\n+/* will be the last on used by the garbage collector to trace the     */\n+/* object.\t\t\t\t\t\t\t      */\n+/*   source is root ==> *base_p = address, *offset_p = 0\t      */\n+/*   source is heap object ==> *base_p != 0, *offset_p = offset       */\n+/*   Returns 1 on success, 0 if source couldn't be determined.        */\n+/* Dest can be any address within a heap object.                      */\n+typedef enum {  GC_UNREFERENCED, /* No refence info available.\t\t*/\n+\t\tGC_NO_SPACE,\t/* Dest not allocated with debug alloc  */\n+\t\tGC_REFD_FROM_ROOT, /* Referenced directly by root *base_p */\n+\t\tGC_REFD_FROM_HEAP, /* Referenced from another heap obj. */\n+\t\tGC_FINALIZER_REFD /* Finalizable and hence accessible.  */\n+} GC_ref_kind;\n+\n+GC_ref_kind GC_get_back_ptr_info(void *dest, void **base_p, size_t *offset_p);\n+\n+/* Generate a random heap address.            */\n+/* The resulting address is in the heap, but  */\n+/* not necessarily inside a valid object.     */\n+void * GC_generate_random_heap_address(void);\n+\n+/* Generate a random address inside a valid marked heap object. */\n+void * GC_generate_random_valid_address(void);\n+\n+/* Force a garbage collection and generate a backtrace from a */\n+/* random heap address.                                       */\n+/* This uses the GC logging mechanism (GC_printf) to produce  */\n+/* output.  It can often be called from a debugger.  The      */\n+/* source in dbg_mlc.c also serves as a sample client.\t      */\n+void GC_generate_random_backtrace(void);\n+\n+"}, {"sha": "212c99e28dce62a8d9e072442a0cb5aa3d4fabaf", "filename": "boehm-gc/include/gc_copy_descr.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Finclude%2Fgc_copy_descr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Finclude%2Fgc_copy_descr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_copy_descr.h?ref=fd6a6309db035c41f8a280d7acc75437cb7d5e43", "patch": "@@ -0,0 +1,26 @@\n+\n+/* \n+ * Copyright (c) 1999 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Descriptor for allocation request. May be redefined by client. */\n+typedef struct {\n+    GC_word bitmap;\t/* Bitmap describing pointer locations.\t*/\n+\t\t\t/* High order bit correspond to 0th\t*/\n+\t\t\t/* word.  2 lsbs must be 0.\t\t*/\n+    size_t length;      /* In bytes, must be multiple of word\t*/\n+\t\t\t/* size.  Must be >0, <= 512\t\t*/\n+} * GC_copy_descriptor;\n+\n+/* The collector accesses descriptors only through these two macros. */\n+#define GC_SIZE_FROM_DESCRIPTOR(d) ((d) -> length)\n+#define GC_BIT_MAP_FROM_DESCRIPTOR(d) ((d) -> bitmap)\n+"}, {"sha": "d109ff090dc162c5b8894d3395f80eae33a2a881", "filename": "boehm-gc/include/gc_nursery.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Finclude%2Fgc_nursery.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Finclude%2Fgc_nursery.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_nursery.h?ref=fd6a6309db035c41f8a280d7acc75437cb7d5e43", "patch": "@@ -0,0 +1,90 @@\n+\n+/* \n+ * Copyright (c) 1999 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+/*\n+ * THIS IMPLEMENTATION FOR THIS INTERFACE IS INCOMPLETE.\n+ * NONE OF THIS HAS BEEN TESTED.  DO NOT USE.\n+ *\n+ * Comments on the interface are appreciated, especially from\n+ * potential users of the interface.\n+ *\n+ * This is a Bartlett style copying collector for young objects.\n+ * We assume for now that all objects allocated through this\n+ * mechanism have pointers only in the first BITMAP_BITS words.\n+ * (On a 32-bit machine, BITMAP_BITS is 30.)\n+ * Objects allocated in this manner should be rarely referenced\n+ * by objects not allocated either through this interface, or through\n+ * the typed allocation interface.\n+ * If this interface is used, we assume that type information provided\n+ * through either this or the typed allocation interface is valid\n+ * in a stronger sense:\n+ *\n+ * 1) No pointers are stored in fields not marked as such.\n+ *    (Otherwise it is only necessary that objects referenced by\n+ *    fields marked as nonpointers are also reachable via another\n+ *    path.)\n+ * 2) Values stored in pointer fields are either not addresses in\n+ *    the heap, or they really are pointers.  In the latter case, it\n+ *    is acceptable to move the object they refer to, and to update\n+ *    the pointer.\n+ *\n+ * GC_free may not be invoked on objects allocated with GC_copying_malloc.\n+ *\n+ * No extra space is added to the end of objects allocated through this\n+ * interface.  If the client needs to maintain pointers past the\n+ * end, the size should be explicitly padded.\n+ * \n+ * We assume that calls to this will usually be compiler generated.\n+ * Hence the interface is allowed to be a bit ugly in return for speed.\n+ */\n+\n+#include \"gc_copy_descr.h\"\n+\n+/* GC_copy_descr.h must define\t\t\t\t\t\t*/\n+/* GC_SIZE_FROM_DESCRIPTOR(descr) and\t\t\t\t\t*/\n+/* GC_BIT_MAP_FROM_DESCRIPTOR(descr).\t\t\t\t\t*/\n+/* It may either be the GC supplied version of the header file, or a\t*/\n+/* client specific one that derives the information from a client-\t*/\n+/* specific type descriptor.\t\t\t\t\t\t*/\n+\n+typedef GC_PTR GC_copy_alloc_state;\n+\t\t\t\t/* Current allocator state.\t*/\n+\t\t\t\t/* Multiple allocation states\t*/\n+\t\t\t\t/* may be used for concurrent\t*/\n+\t\t\t\t/* allocation, or to enhance\t*/\n+\t\t\t\t/* locality.\t\t\t*/\n+\t\t\t\t/* Should be treated as opaque.\t*/\n+\n+/* Allocate a memory block of size given in the descriptor, and with\t*/\n+/* pointer layout given by the descriptor.  The resulting block may not\t*/\n+/* be cleared, and should immediately be initialized by the client.\t*/\n+/* (A concurrent GC may see an uninitialized pointer field.  If it\t*/\n+/* points outside the nursery, that's fine.  If it points inside, it\t*/\n+/* may retain an object, and be relocated.  But that's also fine, since\t*/\n+/* the new value will be immediately overwritten.\t\t\t*/\n+/* This variant acquires the allocation lock, and uses a default \t*/\n+/* global allocation state.\t\t\t\t\t\t*/\n+GC_PTR GC_copying_malloc(GC_copy_descriptor);\n+\n+/* A variant of the above that does no locking on the fast path,\t*/\n+/* and passes an explicit pointer to an allocation state.\t\t*/\n+/* The allocation state is updated.\t\t\t\t\t*/\n+/* There will eventually need to be a macro or inline function version\t*/\n+/* of this.\t\t\t\t\t\t\t\t*/\n+GC_PTR GC_copying_malloc2(GC_copy_descriptor, GC_copy_alloc_state *);\n+\n+/* Initialize an allocation state so that it can be used for \t*/\n+/* allocation.  This implicitly reserves a small section of the\t*/\n+/* nursery for use with this allocator.\t\t\t\t*/\n+void GC_init_copy_alloc_state(GC_copy_alloc_state *);"}, {"sha": "6786825ab6d56d40d95af987530226f3734e860b", "filename": "boehm-gc/include/leak_detector.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Finclude%2Fleak_detector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Finclude%2Fleak_detector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fleak_detector.h?ref=fd6a6309db035c41f8a280d7acc75437cb7d5e43", "patch": "@@ -0,0 +1,7 @@\n+#define GC_DEBUG\n+#include \"gc.h\"\n+#define malloc(n) GC_MALLOC(n)\n+#define calloc(m,n) GC_MALLOC(m*n)\n+#define free(p) GC_FREE(p)\n+#define realloc(p,n) GC_REALLOC(n)\n+#define CHECK_LEAKS() GC_gcollect()"}, {"sha": "ab83afbaaf2f58e38d4a15de2ecba66f3c011683", "filename": "boehm-gc/nursery.c", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Fnursery.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6a6309db035c41f8a280d7acc75437cb7d5e43/boehm-gc%2Fnursery.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fnursery.c?ref=fd6a6309db035c41f8a280d7acc75437cb7d5e43", "patch": "@@ -0,0 +1,312 @@\n+/* \n+ * Copyright (c) 1999 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+#ifdef NURSERY\n+??? This implementation is incomplete.  If you are trying to\n+??? compile this you are doing something wrong.\n+\n+#include \"nursery.h\"\n+\n+#define SCAN_STATICS_FOR_NURSERY\n+\t/* If this is not defined, the collector will not see \t*/\n+\t/* references from static data areas to the nursery.\t*/\n+\n+struct copy_obj {\n+    ptr_t forward;\t/* Forwarding link for copied objects.\t*/\n+    GC_copy_descriptor descr; /* Object descriptor\t*/\n+    word data[1];\n+}\n+\n+ptr_t GC_nursery_start;\t/* Start of nursery area.\t*/\n+\t\t\t/* Must be NURSERY_BLOCK_SIZE\t*/\n+\t\t\t/* aligned.\t\t\t*/\n+ptr_t GC_nursery_end;\t/* End of nursery area.\t\t*/\n+unsigned char * GC_nursery_map;\n+\t\t\t/* GC_nursery_map[i] != 0 if an object\t*/\n+\t\t\t/* starts on the ith 64-bit \"word\" of \t*/\n+\t\t\t/* nursery.  This simple structure has\t*/\n+\t\t\t/* the advantage that \t\t\t*/\n+\t\t\t/* allocation is cheap.  Lookup is \t*/\n+\t\t\t/* cheap for pointers to the head of\t*/\n+\t\t\t/* an object, which should be the\t*/\n+\t\t\t/* usual case.\t\t\t\t*/\n+#   define NURSERY_MAP_NOT_START\t0  /* Not start of object. */\n+#   define NURSERY_MAP_START\t\t1  /* Start of object.\t   */\n+#   define NURSERY_MAP_PINNED\t\t2  /* Start of pinned obj. */\n+\n+# ifdef ALIGN_DOUBLE\n+#   define NURSERY_WORD_SIZE (2 * sizeof(word))\n+# else\n+#   define NURSERY_WORD_SIZE sizeof(word)\n+# endif\n+\n+# define NURSERY_BLOCK_SIZE (HBLKSIZE/2)\t\n+\t/* HBLKSIZE must be a multiple of NURSERY_BLOCK_SIZE */\n+# define NURSERY_SIZE (1024 * NURSERY_BLOCK_SIZE)\n+\n+size_t GC_nursery_size = NURSERY_SIZE;\n+\t\t\t/* Must be multiple of NURSERY_BLOCK_SIZE\t*/\n+\n+size_t GC_nursery_blocks; /* Number of blocks in the nursery.\t*/\n+\n+unsigned GC_next_nursery_block; /* index of next block we will attempt \t*/\n+\t\t\t\t/* allocate from during this cycle.\t*/\n+\t\t\t\t/* If it is pinned, we won't actually\t*/\n+\t\t\t\t/* use it.\t\t\t\t*/\n+\n+unsigned short *GC_pinned;\t/* Number of pinned objects in ith\t*/\n+\t\t\t\t/* nursery block.\t\t\t*/\n+\t\t\t\t/* GC_pinned[i] != 0 if the ith nursery */\n+\t\t\t\t/* block is pinned, and thus not used\t*/\n+\t\t\t\t/* for allocation.\t\t\t*/\n+\n+GC_copy_alloc_state global_alloc_state = (ptr_t)(-1);\t/* will overflow. */\n+\n+/* Array of known rescuing pointers from the heap to the nursery.\t*/\n+  ptr_t ** nursery_rescuers;\n+  /* Pointer to one past the last slot in rescuer table\t*/\n+  ptr_t ** nursery_rescuers_end;\n+  /* Maximum number of known rescuing pointers.\t\t\t*/\n+# define MAX_NURSERY_RESCUERS 32*1024\n+  /* Add a rescuer to the list\t*/\n+# define ADD_NURSERY_RESCUER(p) \\\n+    if (nursery_rescuers_end >= nursery_rescuers + MAX_NURSERY_RESCUERS) { \\\n+      ABORT(\"Nursery recuers overflow\"); /* Fix later !!! */ \\\n+    } else { \\\n+      *nursery_rescuers_end++ = p; \\\n+    }\n+  /* Remove rescuer at the given position in the table\t*/\n+# define REMOVE_RESCUER(p) \\\n+    *p = *--nursery_rescuers_end\n+\n+/* Should be called with allocator lock held.\t*/\n+GC_nursery_init() {\n+    GC_nursery_start = GET_MEM(GC_nursery_size);\n+    GC_nursery_end = GC_nursery_start + GC_nursery_size;\n+    GC_next_nursery_block = 0;\n+    if (GC_nursery_start < GC_least_plausible_heap_addr) { \n+        GC_least_plausible_heap_addr = GC_nursery_start;   \n+    }\n+    if (GC_nursery_end > GC_greatest_plausible_heap_addr) {\n+        GC_greatest_plausible_heap_addr = GC_nursery_end;  \n+    }\n+    if (GC_nursery_start & (NURSERY_BLOCK_SIZE-1)) {\n+\tGC_err_printf1(\"Nursery area is misaligned!!\");\n+\t/* This should be impossible, since GET_MEM returns HBLKSIZE */\n+\t/* aligned chunks, and that should be a multiple of \t     */\n+\t/* NURSERY_BLOCK_SIZE\t\t\t\t\t     */\n+\tABORT(\"misaligned nursery\");\n+    }\n+    GC_nursery_map = GET_MEM(GC_nursery_size/NURSERY_WORD_SIZE);\n+    /* Map is cleared a block at a time when we allocate from the block. */\n+    /* BZERO(GC_nursery_map, GC_nursery_size/NURSERY_WORD_SIZE);\t */\n+    GC_nursery_blocks = GC_nursery_size/NURSERY_BLOCK_SIZE;\n+    GC_pinned = GC_scratch_alloc(GC_nursery_blocks * sizeof(unsigned short));\n+    BZERO(GC_pinned, GC_nursery_blocks);\n+    nursery_rescuers = GET_MEM(MAX_NURSERY_RESCUERS * sizeof(ptr_t *));\n+    nursery_rescuers_end = nursery_rescuers;\n+    if (0 == GC_nursery_start || 0 == GC_nursery_map || 0 == nursery_rescuers)\n+\tABORT(\"Insufficient memory for nursery\");\n+}\n+\n+#define PIN_OBJ(p) \\\n+    if (p >= GC_nursery_start && p < GC_nursery_end) { GC_pin_obj_checked(p); }\n+\n+/* Pin the object at p, if it's in the nursery.\t*/\n+void GC_pin_obj(ptr_t p) {\n+    PIN_OBJ(p);\n+}\n+\n+void (*GC_push_proc)(ptr_t) = 0;\n+\n+/* Pin the object at p, which is known to be in the nursery.\t*/\n+void GC_pin_obj_checked(ptr_t p) {\n+    unsigned offset = p - GC_nursery_start;\n+    unsigned word_offset = BYTES_TO_WORDS(offset);\n+    unsigned blockno = (current - GC_nursery_start)/NURSERY_BLOCK_SIZE;\n+    while (GC_nursery_map[word_offset] == NURSERY_MAP_NOT_START) {\n+\t--word_offset;    \n+    }\n+    if (GC_nursery_map[word_offset] != NURSERY_MAP_PINNED) {\n+        GC_nursery_map[word_offset] = NURSERY_MAP_PINNED;\n+        ++GC_pinned[blockno];\n+        ??Push object at GC_nursery_start + WORDS_TO_BYTES(word_offset)\n+        ??onto mark stack. \n+    }\n+}\n+\n+void GC_scan_region_for_nursery(ptr_t low, ptr_t high) {\n+#   if CPP_WORDSZ/8 != ALIGNMENT\n+      --> fix this\n+#   endif\n+    word * l = (word *)((word)low + ALIGNMENT - 1 & ~(ALIGNMENT - 1));\n+    word * h = (word *)((word)high & ~(ALIGNMENT - 1));\n+    word * p;\n+    for (p = l; p < h; ++p) {\n+\tPIN_OBJ(p);\n+    }\n+}\n+\n+/* Invoke GC_scan_region_for_nursery on ranges that are not excluded. */\n+void GC_scan_region_for_nursery_with_exclusions(ptr_t bottom, ptr_t top)\n+{\n+    struct exclusion * next;\n+    ptr_t excl_start;\n+\n+    while (bottom < top) {\n+        next = GC_next_exclusion(bottom);\n+\tif (0 == next || (excl_start = next -> e_start) >= top) {\n+\t    GC_scan_region_for_nursery(bottom, top);\n+\t    return;\n+\t}\n+\tif (excl_start > bottom)\n+\t\tGC_scan_region_for_nursery(bottom, excl_start);\n+\tbottom = next -> e_end;\n+    }\n+}\n+\n+\n+void GC_scan_stacks_for_nursery(void) {\n+#   ifdef THREADS\n+\t--> fix this\n+#   endif\n+#   ifdef STACK_GROWS_DOWN\n+      ptr_t stack_low = GC_approx_sp();\n+      ptr_t stack_high = GC_stackbottom;\n+#   else\n+      ptr_t stack_low = GC_stackbottom;\n+      ptr_t stack_high = GC_approx_sp();\n+#   endif\n+    GC_scan_region_for_nursery(stack_low, stack_high);\n+#   ifdef IA64\n+      GC_scan_region_for_nursery(BACKING_STORE_BASE,\n+\t\t\t\t (ptr_t) GC_save_regs_ret_val);\n+#   endif\n+}\n+\n+void GC_scan_roots_for_nursery(void) {\n+  /* Scan registers.\t*/\n+    /* Direct GC_push_one to call GC_pin_obj instead of marking\t*/\n+    /* and pushing objects.\t\t\t\t\t*/\n+    /* This is a bit ugly, but we don't have to touch the\t*/\n+    /* platform-dependent code.\t\t\t\t\t*/\n+     \n+    void (*old_push_proc)(ptr_t) = GC_push_proc;\n+    GC_push_proc = GC_pin_obj;\n+    GC_push_regs();\n+    GC_push_proc = old_push_proc;\n+  GC_scan_stacks_for_nursery();\n+# ifdef SCAN_STATICS_FOR_NURSERY\n+#   if (defined(DYNAMIC_LOADING) || defined(MSWIN32) || defined(PCR)) \\\n+        && !defined(SRC_M3)\n+      GC_remove_tmp_roots();\n+      GC_register_dynamic_libraries();\n+#   endif\n+    /* Mark everything in static data areas                             */\n+      for (i = 0; i < n_root_sets; i++) {\n+        GC_scan_region_for_nursery_with_exclusions (\n+\t\t\t     GC_static_roots[i].r_start,\n+\t\t\t     GC_static_roots[i].r_end);\n+     }\n+# endif\n+}\n+\n+/* Array of known rescuing pointers from the heap to the nursery.\t*/\n+ptr_t ** nursery_rescuers;\n+\n+/* Caller holds allocation lock.\t*/\n+void GC_collect_nursery(void) {\n+    int i;\n+    ptr_t scan_ptr = 0;\n+    STOP_WORLD;\n+    for (i = 0; i < GC_nursery_blocks; ++i) GC_pinned[i] = 0;\n+    GC_scan_roots_for_nursery();\n+    /* All objects referenced by roots are now pinned. \t\t*/\n+    /* Their contents are described by \t\t\t \t*/\n+    /* mark stack entries.\t\t\t\t\t*/\n+\n+    /* Pin blocks corresponding to valid allocation states.\t*/\n+    /* that probably happens automagically if the allocation\t*/\n+    /* states are kept where we can see them.\t\t\t*/\n+    /* It will take work if static roots are not scanned.\t*/\n+    /* We want to do this both for correctness and to avoid\t*/\n+    /* promoting very young objects.\t\t\t\t*/\n+\n+    /* Somehow capture dirty bits.  Update rescuers array to\t*/\n+    /* reflect newly valid and invalid references from dirty \t*/\n+    /* pages.  Other references should remain valid, since the\t*/\n+    /* referents should have been pinned.\t\t\t*/\n+\n+    /* Traverse the old object heap.  Pin objects in the \t*/\n+    /* nursery that are ambiguously referenced, copy those\t*/\n+    /* that are unambiguously referenced.\t\t\t*/\n+\n+    /* Traverse objects in mark stack.\t\t\t\t*/\n+    /* If referenced object is in pinned block, add contents\t*/\n+    /* to mark stack.  If referenced object is forwarded,\t*/\n+    /* update pointer.  Otherwise reallocate the object\tin the\t*/\n+    /* old heap, copy its contents, and then enqueue its \t*/\n+    /* contents in the mark stack.\t\t\t\t*/\n+    START_WORLD;\n+}\n+\n+/* Initialize an allocation state so that it can be used for \t*/\n+/* allocation.  This implicitly reserves a small section of the\t*/\n+/* nursery for use with this allocator.\t\t\t\t*/\n+/* Also called to replenish an allocator that has been \t\t*/\n+/* exhausted.\t\t\t\t\t\t\t*/\n+void GC_init_copy_alloc_state(GC_copy_alloc_state *)\n+    unsigned next_block;\n+    ptr_t block_addr;\n+    LOCK();\n+    next_block = GC_next_nursery_block;\n+    while(is_pinned[next_block] && next_block < GC_nursery_blocks) {\n+\t++next_block;\n+    }\n+    if (next_block < GC_nursery_blocks) {\n+\tblock_addr = GC_nursery_start + NURSERY_BLOCK_SIZE * next_block;\n+   \tGC_next_nursery_block = next_block + 1;\n+\tBZERO(GC_nursery_map + next_block *\n+\t\t\t\t(NURSERY_BLOCK_SIZE/NURSERY_WORD_SIZE),\n+\t      NURSERY_BLOCK_SIZE/NURSERY_WORD_SIZE);\n+\t*GC_copy_alloc_state = block_addr;\n+\tUNLOCK();\n+    } else {\n+     \tGC_collect_nursery();\n+    \tGC_next_nursery_block = 0;\n+    \tUNLOCK();\n+    \tget_new_block(s);\n+    }\n+}\n+\n+GC_PTR GC_copying_malloc2(GC_copy_descriptor *d, GC_copy_alloc_state *s) {\n+    size_t sz = GC_SIZE_FROM_DESCRIPTOR(d);\n+    ptrdiff_t offset;\n+    ptr_t result = *s;\n+    ptr_t new = result + sz;\n+    if (new & COPY_BLOCK_MASK <= result & COPY_BLOCK_MASK> {\n+\tGC_init_copy_alloc_state(s);\n+\tresult = *s;\n+\tnew = result + sz;\n+        GC_ASSERT(new & COPY_BLOCK_MASK > result & COPY_BLOCK_MASK>\n+    }\n+    (struct copy_obj *)result -> descr = d;      \n+    (struct copy_obj *)result -> forward = 0;      \n+    offset = (result - GC_nursery_start)/NURSERY_WORD_SIZE;\n+    GC_nursery_map[offset] = NURSERY_MAP_NOT_START;\n+}\n+\n+GC_PTR GC_copying_malloc(GC_copy_descriptor *d) {\n+}\n+\n+#endif /* NURSERY */"}]}