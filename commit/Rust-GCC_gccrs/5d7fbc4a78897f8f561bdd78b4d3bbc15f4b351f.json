{"sha": "5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3ZmJjNGE3ODg5N2Y4ZjU2MWJkZDc4YjRkM2JiYzE1ZjRiMzUxZg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-13T14:36:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-13T14:36:25Z"}, "message": "Merge #427\n\n427: Fix duplicate function generation in the backend r=philberty a=philberty\n\nFix duplicated function generation for generics\r\n    \r\nWhen emitting the backend IR we need to check if we have already compiled\r\none already. This is all due to the fact when we do generic substitutions\r\nin type resolution its only upon usage of a function the function is\r\nsubstituted it gains a new unique ty_ref HIR ID to make sure new\r\nsubstituted versions of a type have unique ids.\r\n    \r\nFixes #403\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "167d95c3c3e816ddb3284ed078027f8a9ef1b7c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/167d95c3c3e816ddb3284ed078027f8a9ef1b7c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgnTlpCRBK7hj4Ov3rIwAAJVUIAGoY+XQTEFOXlPiww2KhhA44\nUuT8wT2XrRnPR3BoJJ7r2AUnRPeo8WzPlc6qtMYeiYy9ft8hIILeTSUVYOusO4h9\nYwLocHX2eJLsAuJUMwVID7e1grMwWKl5eMrNmy71MaySF3OHO+4Kjd8AQSSa9DHm\nEVsiGpuohW+lBcWj6CAoSzzoNDogJMcXrZB9WR/fUCziA6GZ1PCVN8eRU34xRyGx\nY9jVxx5CbsB3I5OeTv7d9ecGP9iEuUUnxMlOnsSee0ZrNHcS/Dg5YHN5iaez0wyD\navC16QlDPBDQwoBsWUpXy0LWLK2D+Ohq0BZx2rZl8Zm5ZYuUbtGc5RYTWGgkRI0=\n=p6SI\n-----END PGP SIGNATURE-----\n", "payload": "tree 167d95c3c3e816ddb3284ed078027f8a9ef1b7c6\nparent 5134aaa9f0b37ea372cb185fe7aa6c26fe0a4c2e\nparent fcd4ed431272414157eb90773f174405431eb6bd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1620916585 +0000\ncommitter GitHub <noreply@github.com> 1620916585 +0000\n\nMerge #427\n\n427: Fix duplicate function generation in the backend r=philberty a=philberty\n\nFix duplicated function generation for generics\r\n    \r\nWhen emitting the backend IR we need to check if we have already compiled\r\none already. This is all due to the fact when we do generic substitutions\r\nin type resolution its only upon usage of a function the function is\r\nsubstituted it gains a new unique ty_ref HIR ID to make sure new\r\nsubstituted versions of a type have unique ids.\r\n    \r\nFixes #403\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5134aaa9f0b37ea372cb185fe7aa6c26fe0a4c2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5134aaa9f0b37ea372cb185fe7aa6c26fe0a4c2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5134aaa9f0b37ea372cb185fe7aa6c26fe0a4c2e"}, {"sha": "fcd4ed431272414157eb90773f174405431eb6bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcd4ed431272414157eb90773f174405431eb6bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcd4ed431272414157eb90773f174405431eb6bd"}], "stats": {"total": 238, "additions": 156, "deletions": 82}, "files": [{"sha": "45fb6c221275a22052ff3fcf948c9852ab7457de", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "patch": "@@ -157,13 +157,38 @@ class Context\n     return true;\n   }\n \n-  void insert_function_decl (HirId id, ::Bfunction *fn)\n+  void insert_function_decl (HirId id, ::Bfunction *fn,\n+\t\t\t     const TyTy::BaseType *ref)\n   {\n+    rust_assert (compiled_fn_map.find (id) == compiled_fn_map.end ());\n     compiled_fn_map[id] = fn;\n+    if (ref != nullptr)\n+      {\n+\tstd::pair<HirId, ::Bfunction *> elem (id, fn);\n+\tmono_fns[ref] = std::move (elem);\n+      }\n   }\n \n-  bool lookup_function_decl (HirId id, ::Bfunction **fn)\n+  bool lookup_function_decl (HirId id, ::Bfunction **fn,\n+\t\t\t     const TyTy::BaseType *ref = nullptr)\n   {\n+    // for for any monomorphized fns\n+    if (ref != nullptr)\n+      {\n+\tfor (auto it = mono_fns.begin (); it != mono_fns.end (); it++)\n+\t  {\n+\t    std::pair<HirId, ::Bfunction *> &val = it->second;\n+\t    const TyTy::BaseType *r = it->first;\n+\t    if (ref->is_equal (*r))\n+\t      {\n+\t\t*fn = val.second;\n+\n+\t\treturn true;\n+\t      }\n+\t  }\n+\treturn false;\n+      }\n+\n     auto it = compiled_fn_map.find (id);\n     if (it == compiled_fn_map.end ())\n       return false;\n@@ -282,6 +307,7 @@ class Context\n   std::vector< ::Bvariable *> loop_value_stack;\n   std::vector< ::Blabel *> loop_begin_labels;\n   std::map<const TyTy::BaseType *, std::pair<HirId, ::Btype *> > mono;\n+  std::map<const TyTy::BaseType *, std::pair<HirId, ::Bfunction *> > mono_fns;\n \n   // To GCC middle-end\n   std::vector< ::Btype *> type_decls;"}, {"sha": "b071d94676f0cde1f52445062188270539072561", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "patch": "@@ -66,17 +66,6 @@ class CompileInherentImplItem : public HIRCompileBase\n     if (!compile_fns)\n       return;\n \n-    // items can be forward compiled which means we may not need to invoke this\n-    // code\n-    Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (function.get_mappings ().get_hirid (),\n-\t\t\t\t   &lookup))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  return;\n-      }\n-\n     TyTy::BaseType *fntype_tyty;\n     if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n@@ -86,28 +75,43 @@ class CompileInherentImplItem : public HIRCompileBase\n \treturn;\n       }\n \n-    if (fntype_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\trust_error_at (function.get_locus (), \"invalid TyTy for function item\");\n-\treturn;\n-      }\n-\n+    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n     TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n     if (fntype->has_subsititions_defined ())\n       {\n-\t// we cant do anything for this only when it is used\n+\t// we cant do anything for this only when it is used and a concrete type\n+\t// is given\n \tif (concrete == nullptr)\n \t  return;\n \telse\n \t  {\n \t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n \t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\t  }\n+      }\n \n-\t    // override the Hir Lookups for the substituions in this context\n-\t    fntype->override_context ();\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code. We might also have already compiled this generic function as well.\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  {\n+\t    Bfunction *dummy = nullptr;\n+\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n+\n+\t    return;\n \t  }\n       }\n \n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// override the Hir Lookups for the substituions in this context\n+\tfntype->override_context ();\n+      }\n+\n     // convert to the actual function type\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n@@ -126,7 +130,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl);\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n \n     // setup the params\n     TyTy::BaseType *tyret = fntype->get_return_type ();\n@@ -247,17 +251,6 @@ class CompileInherentImplItem : public HIRCompileBase\n     if (!compile_fns)\n       return;\n \n-    // items can be forward compiled which means we may not need to invoke this\n-    // code\n-    Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (method.get_mappings ().get_hirid (),\n-\t\t\t\t   &lookup))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  return;\n-      }\n-\n     TyTy::BaseType *fntype_tyty;\n     if (!ctx->get_tyctx ()->lookup_type (method.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n@@ -267,28 +260,43 @@ class CompileInherentImplItem : public HIRCompileBase\n \treturn;\n       }\n \n-    if (fntype_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\trust_error_at (method.get_locus (), \"invalid TyTy for function item\");\n-\treturn;\n-      }\n-\n+    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n     TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n     if (fntype->has_subsititions_defined ())\n       {\n-\t// we cant do anything for this only when it is used\n+\t// we cant do anything for this only when it is used and a concrete type\n+\t// is given\n \tif (concrete == nullptr)\n \t  return;\n \telse\n \t  {\n \t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n \t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\t  }\n+      }\n \n-\t    // override the Hir Lookups for the substituions in this context\n-\t    fntype->override_context ();\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code. We might also have already compiled this generic function as well.\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  {\n+\t    Bfunction *dummy = nullptr;\n+\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n+\n+\t    return;\n \t  }\n       }\n \n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// override the Hir Lookups for the substituions in this context\n+\tfntype->override_context ();\n+      }\n+\n     // convert to the actual function type\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n@@ -307,7 +315,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, method.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl);\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n \n     // setup the params\n     TyTy::BaseType *tyret = fntype->get_return_type ();"}, {"sha": "c3dc279268c4d475682d3abdd9d163c2450feff1", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "patch": "@@ -92,17 +92,6 @@ class CompileItem : public HIRCompileBase\n     if (!compile_fns)\n       return;\n \n-    // items can be forward compiled which means we may not need to invoke this\n-    // code\n-    Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (function.get_mappings ().get_hirid (),\n-\t\t\t\t   &lookup))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  return;\n-      }\n-\n     TyTy::BaseType *fntype_tyty;\n     if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n@@ -112,28 +101,43 @@ class CompileItem : public HIRCompileBase\n \treturn;\n       }\n \n-    if (fntype_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\trust_error_at (function.get_locus (), \"invalid TyTy for function item\");\n-\treturn;\n-      }\n-\n+    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n     TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n     if (fntype->has_subsititions_defined ())\n       {\n-\t// we cant do anything for this only when it is used\n+\t// we cant do anything for this only when it is used and a concrete type\n+\t// is given\n \tif (concrete == nullptr)\n \t  return;\n \telse\n \t  {\n \t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n \t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\t  }\n+      }\n \n-\t    // override the Hir Lookups for the substituions in this context\n-\t    fntype->override_context ();\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code. We might also have already compiled this generic function as well.\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  {\n+\t    Bfunction *dummy = nullptr;\n+\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n+\n+\t    return;\n \t  }\n       }\n \n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// override the Hir Lookups for the substituions in this context\n+\tfntype->override_context ();\n+      }\n+\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n@@ -155,7 +159,7 @@ class CompileItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl);\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n \n     // setup the params\n     TyTy::BaseType *tyret = fntype->get_return_type ();"}, {"sha": "81f558a202f85fdc684f7c78052f020f0717924b", "filename": "gcc/rust/rust-diagnostics.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Frust-diagnostics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Frust-diagnostics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.h?ref=5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "patch": "@@ -114,10 +114,13 @@ struct Error\n \t ...) /*RUST_ATTRIBUTE_GCC_DIAG (2, 3)*/ RUST_ATTRIBUTE_GCC_DIAG (3, 4);\n \n   // Irreversibly emits the error as an error.\n-  void emit_error () const { rust_error_at (locus, message.c_str ()); }\n+  void emit_error () const { rust_error_at (locus, \"%s\", message.c_str ()); }\n \n   // Irreversibly emits the error as a fatal error.\n-  void emit_fatal_error () const { rust_fatal_error (locus, message.c_str ()); }\n+  void emit_fatal_error () const\n+  {\n+    rust_fatal_error (locus, \"%s\", message.c_str ());\n+  }\n };\n } // namespace Rust\n "}, {"sha": "2f54d0cbe60301ea60165ab778652f39e636c6b5", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "patch": "@@ -112,7 +112,8 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       }\n \n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    false, std::move (params), ret_type,\n+\t\t\t\t    function.get_function_name (), false,\n+\t\t\t\t    std::move (params), ret_type,\n \t\t\t\t    std::move (substitutions));\n     context->insert_type (function.get_mappings (), fnType);\n   }\n@@ -189,9 +190,10 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n-    auto fnType = new TyTy::FnType (method.get_mappings ().get_hirid (), true,\n-\t\t\t\t    std::move (params), ret_type,\n-\t\t\t\t    std::move (substitutions));\n+    auto fnType\n+      = new TyTy::FnType (method.get_mappings ().get_hirid (),\n+\t\t\t  method.get_method_name (), true, std::move (params),\n+\t\t\t  ret_type, std::move (substitutions));\n     context->insert_type (method.get_mappings (), fnType);\n   }\n "}, {"sha": "e01b46fc5ec1892dc47ab7556ab1890d3bce3875", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "patch": "@@ -229,7 +229,8 @@ class TypeCheckTopLevel : public TypeCheckBase\n       }\n \n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    false, std::move (params), ret_type,\n+\t\t\t\t    function.get_function_name (), false,\n+\t\t\t\t    std::move (params), ret_type,\n \t\t\t\t    std::move (substitutions));\n     context->insert_type (function.get_mappings (), fnType);\n   }"}, {"sha": "0859570e44f4f2c1083d36544885a22f15a3c69d", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "patch": "@@ -679,9 +679,21 @@ FnType::is_equal (const BaseType &other) const\n     return false;\n \n   auto other2 = static_cast<const FnType &> (other);\n+  if (get_identifier ().compare (other2.get_identifier ()) != 0)\n+    return false;\n+\n   if (!get_return_type ()->is_equal (*other2.get_return_type ()))\n     return false;\n \n+  if (has_subsititions_defined () != other2.has_subsititions_defined ())\n+    return false;\n+\n+  if (has_subsititions_defined ())\n+    {\n+      if (get_num_substitutions () != other2.get_num_substitutions ())\n+\treturn false;\n+    }\n+\n   if (num_params () != other2.num_params ())\n     return false;\n \n@@ -703,9 +715,10 @@ FnType::clone ()\n     cloned_params.push_back (\n       std::pair<HIR::Pattern *, BaseType *> (p.first, p.second->clone ()));\n \n-  return new FnType (get_ref (), get_ty_ref (), is_method_flag,\n-\t\t     std::move (cloned_params), get_return_type ()->clone (),\n-\t\t     clone_substs (), get_combined_refs ());\n+  return new FnType (get_ref (), get_ty_ref (), get_identifier (),\n+\t\t     is_method_flag, std::move (cloned_params),\n+\t\t     get_return_type ()->clone (), clone_substs (),\n+\t\t     get_combined_refs ());\n }\n \n FnType *\n@@ -1381,10 +1394,22 @@ ParamType::resolve () const\n bool\n ParamType::is_equal (const BaseType &other) const\n {\n-  if (!can_resolve ())\n-    return BaseType::is_equal (other);\n+  if (get_kind () != other.get_kind ())\n+    {\n+      if (!can_resolve ())\n+\treturn false;\n+\n+      return resolve ()->is_equal (other);\n+    }\n+\n+  auto other2 = static_cast<const ParamType &> (other);\n+  if (can_resolve () != other2.can_resolve ())\n+    return false;\n+\n+  if (can_resolve ())\n+    return resolve ()->can_eq (other2.resolve ());\n \n-  return resolve ()->is_equal (other);\n+  return get_symbol ().compare (other2.get_symbol ()) == 0;\n }\n \n ParamType *"}, {"sha": "5acc9e7805d59bc034abb3695198ff6eea3e302e", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=5d7fbc4a78897f8f561bdd78b4d3bbc15f4b351f", "patch": "@@ -855,24 +855,26 @@ class ADTType : public BaseType, public SubstitutionRef\n class FnType : public BaseType, public SubstitutionRef\n {\n public:\n-  FnType (HirId ref, bool is_method,\n+  FnType (HirId ref, std::string identifier, bool is_method,\n \t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::FNDEF, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n-      params (std::move (params)), type (type), is_method_flag (is_method)\n+      params (std::move (params)), type (type), is_method_flag (is_method),\n+      identifier (identifier)\n   {}\n \n-  FnType (HirId ref, HirId ty_ref, bool is_method,\n+  FnType (HirId ref, HirId ty_ref, std::string identifier, bool is_method,\n \t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::FNDEF, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n-      params (params), type (type), is_method_flag (is_method)\n+      params (params), type (type), is_method_flag (is_method),\n+      identifier (identifier)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -881,6 +883,8 @@ class FnType : public BaseType, public SubstitutionRef\n \n   std::string get_name () const override final { return as_string (); }\n \n+  std::string get_identifier () const { return identifier; }\n+\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (BaseType *other) override;\n \n@@ -947,6 +951,7 @@ class FnType : public BaseType, public SubstitutionRef\n   std::vector<std::pair<HIR::Pattern *, BaseType *> > params;\n   BaseType *type;\n   bool is_method_flag;\n+  std::string identifier;\n };\n \n class FnPtr : public BaseType"}]}