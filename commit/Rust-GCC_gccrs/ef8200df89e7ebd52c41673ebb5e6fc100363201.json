{"sha": "ef8200df89e7ebd52c41673ebb5e6fc100363201", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY4MjAwZGY4OWU3ZWJkNTJjNDE2NzNlYmI1ZTZmYzEwMDM2MzIwMQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-01T19:26:24Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-01T19:26:24Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r662", "tree": {"sha": "4d29cdffed68570bbcfa0a41d3d8773e88665237", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d29cdffed68570bbcfa0a41d3d8773e88665237"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef8200df89e7ebd52c41673ebb5e6fc100363201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef8200df89e7ebd52c41673ebb5e6fc100363201", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef8200df89e7ebd52c41673ebb5e6fc100363201", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef8200df89e7ebd52c41673ebb5e6fc100363201/comments", "author": null, "committer": null, "parents": [{"sha": "9b30bae257e22976ef002e7a38e15a7c0f4b533e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b30bae257e22976ef002e7a38e15a7c0f4b533e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b30bae257e22976ef002e7a38e15a7c0f4b533e"}], "stats": {"total": 204, "additions": 33, "deletions": 171}, "files": [{"sha": "c9a7e35e762fb11b44b99e4b4b7ccb9834160582", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 32, "deletions": 159, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef8200df89e7ebd52c41673ebb5e6fc100363201/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef8200df89e7ebd52c41673ebb5e6fc100363201/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ef8200df89e7ebd52c41673ebb5e6fc100363201", "patch": "@@ -1923,17 +1923,16 @@ output_function_prologue (file, size, leaf_function)\n }\n \n void\n-output_function_epilogue (file, size, leaf_function, true_epilogue)\n+output_function_epilogue (file, size, leaf_function)\n      FILE *file;\n      int size;\n+     int leaf_function;\n {\n   int n_fregs, i;\n   char *ret;\n \n   if (leaf_label)\n     {\n-      if (leaf_function < 0)\n-\tabort ();\n       emit_label_after (leaf_label, get_last_insn ());\n       final_scan_insn (get_last_insn (), file, 0, 0, 1);\n     }\n@@ -1962,66 +1961,46 @@ output_function_epilogue (file, size, leaf_function, true_epilogue)\n   else\n     ret = (current_function_returns_struct ? \"jmp %i7+12\" : \"ret\");\n \n-  /* Tail calls have to do this work themselves.  */\n-  if (leaf_function >= 0)\n+  if (TARGET_EPILOGUE || leaf_label)\n     {\n-      if (TARGET_EPILOGUE || leaf_label)\n-\t{\n-\t  int old_target_epilogue = TARGET_EPILOGUE;\n-\t  target_flags &= ~old_target_epilogue;\n+      int old_target_epilogue = TARGET_EPILOGUE;\n+      target_flags &= ~old_target_epilogue;\n \n-\t  if (! leaf_function)\n+      if (! leaf_function)\n+\t{\n+\t  /* If we wound up with things in our delay slot, flush them here.  */\n+\t  if (current_function_epilogue_delay_list)\n \t    {\n-\t      /* If we wound up with things in our delay slot,\n-\t\t flush them here.  */\n-\t      if (current_function_epilogue_delay_list)\n-\t\t{\n-\t\t  rtx insn = emit_jump_insn_after (gen_rtx (RETURN, VOIDmode),\n-\t\t\t\t\t\t   get_last_insn ());\n-\t\t  PATTERN (insn) = gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t\t\t    gen_rtvec (2,\n-\t\t\t\t\t\t       PATTERN (XEXP (current_function_epilogue_delay_list, 0)),\n-\t\t\t\t\t\t       PATTERN (insn)));\n-\t\t  final_scan_insn (insn, file, 1, 0, 1);\n-\t\t}\n-\t      else\n-\t\tfprintf (file, \"\\t%s\\n\\trestore\\n\", ret);\n-\t    }\n-\t  else if (actual_fsize < 4096)\n-\t    {\n-\t      if (current_function_epilogue_delay_list)\n-\t\t{\n-\t\t  fprintf (file, \"\\t%s\\n\", ret);\n-\t\t  final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n-\t\t\t\t   file, 1, 0, 1);\n-\t\t}\n-\t      else\n-\t\tfprintf (file, \"\\t%s\\n\\tadd %%sp,%d,%%sp\\n\",\n-\t\t\t ret, actual_fsize);\n+\t      rtx insn = emit_jump_insn_after (gen_rtx (RETURN, VOIDmode),\n+\t\t\t\t\t       get_last_insn ());\n+\t      PATTERN (insn) = gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t\t\tgen_rtvec (2,\n+\t\t\t\t\t\t   PATTERN (XEXP (current_function_epilogue_delay_list, 0)),\n+\t\t\t\t\t\t   PATTERN (insn)));\n+\t      final_scan_insn (insn, file, 1, 0, 1);\n \t    }\n \t  else\n+\t    fprintf (file, \"\\t%s\\n\\trestore\\n\", ret);\n+\t}\n+      else if (actual_fsize < 4096)\n+\t{\n+\t  if (current_function_epilogue_delay_list)\n \t    {\n-\t      if (current_function_epilogue_delay_list)\n-\t\tabort ();\n-\t      fprintf (file, \"\\tsethi %%hi(%d),%%g1\\n\\tor %%g1,%%lo(%d),%%g1\\n\\t%s\\n\\tadd %%sp,%%g1,%%sp\\n\",\n-\t\t       actual_fsize, actual_fsize, ret);\n+\t      fprintf (file, \"\\t%s\\n\", ret);\n+\t      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n+\t\t\t       file, 1, 0, 1);\n \t    }\n-\t  target_flags |= old_target_epilogue;\n+\t  else\n+\t    fprintf (file, \"\\t%s\\n\\tadd %%sp,%d,%%sp\\n\", ret, actual_fsize);\n \t}\n-    }\n-  else if (true_epilogue)\n-    {\n-      /* We may still need a return insn!  Somebody could jump around\n-\t the tail-calls that this function makes.  */\n-      if (TARGET_EPILOGUE)\n+      else\n \t{\n-\t  rtx last = get_last_insn ();\n-\n-\t  last = prev_nonnote_insn (last);\n-\t  if (last == 0\n-\t      || (GET_CODE (last) != JUMP_INSN && GET_CODE (last) != BARRIER))\n-\t    fprintf (file, \"\\t%s\\n\\tnop\\n\", ret);\n+\t  if (current_function_epilogue_delay_list)\n+\t    abort ();\n+\t  fprintf (file, \"\\tsethi %%hi(%d),%%g1\\n\\tor %%g1,%%lo(%d),%%g1\\n\\t%s\\n\\tadd %%sp,%%g1,%%sp\\n\",\n+\t\t   actual_fsize, actual_fsize, ret);\n \t}\n+      target_flags |= old_target_epilogue;\n     }\n }\n \f\n@@ -2213,25 +2192,6 @@ output_floatsidf2 (operands)\n     return \"fitod %1,%0\";\n   return \"st %r1,[%%fp-4]\\n\\tld [%%fp-4],%0\\n\\tfitod %0,%0\";\n }\n-\n-int\n-tail_call_valid_p ()\n-{\n-  static int checked = 0;\n-  static int valid_p = 0;\n-\n-  if (! checked)\n-    {\n-      register int i;\n-\n-      checked = 1;\n-      for (i = 32; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (! fixed_regs[i] && ! call_used_regs[i])\n-\t  return 0;\n-      valid_p = 1;\n-    }\n-  return valid_p;\n-}\n \f\n /* Leaf functions and non-leaf functions have different needs.  */\n \n@@ -2308,93 +2268,6 @@ output_arc_profiler (arcno, insert_after)\n \t\t   insert_after);\n }\n \f\n-/* All the remaining routines in this file have been turned off.  */\n-#if 0\n-char *\n-output_tail_call (operands, insn)\n-     rtx *operands;\n-     rtx insn;\n-{\n-  int this_fsize = actual_fsize;\n-  rtx next;\n-  int need_nop_at_end = 0;\n-\n-  next = next_real_insn (insn);\n-  while (next && GET_CODE (next) == CODE_LABEL)\n-    next = next_real_insn (insn);\n-\n-  if (final_sequence && this_fsize > 0)\n-    {\n-      rtx xoperands[1];\n-\n-      /* If we have to restore any registers, don't take any chances\n-\t restoring a register before we discharge it into\n-\t its home.  If the frame size is only 88, we are guaranteed\n-\t that the epilogue will fit in the delay slot.  */\n-      rtx delay_insn = XVECEXP (final_sequence, 0, 1);\n-      if (GET_CODE (PATTERN (delay_insn)) == SET)\n-\t{\n-\t  rtx dest = SET_DEST (PATTERN (delay_insn));\n-\t  if (GET_CODE (dest) == REG\n-\t      && reg_mentioned_p (dest, insn))\n-\t    abort ();\n-\t}\n-      else if (GET_CODE (PATTERN (delay_insn)) == PARALLEL)\n-\tabort ();\n-      xoperands[0] = operands[0];\n-      final_scan_insn (delay_insn, asm_out_file, 0, 0, 1);\n-      operands[0] = xoperands[0];\n-      final_sequence = 0;\n-    }\n-\n-  /* Make sure we are clear to return.  */\n-  output_function_epilogue (asm_out_file, get_frame_size (), -1, 0);\n-\n-  /* Strip the MEM.  */\n-  operands[0] = XEXP (operands[0], 0);\n-\n-  if (final_sequence == 0\n-      && (next == 0\n-\t  || GET_CODE (next) == CALL_INSN\n-\t  || GET_CODE (next) == JUMP_INSN))\n-    need_nop_at_end = 1;\n-\n-  if (flag_pic)\n-    return output_pic_sequence_2 (2, 3, 0, \"jmpl %%g1+%3\", operands, need_nop_at_end);\n-\n-  if (GET_CODE (operands[0]) == REG)\n-    output_asm_insn (\"jmpl %a0,%%g0\", operands);\n-  else if (TARGET_TAIL_CALL)\n-    {\n-      /* We assume all labels will be within 16 MB of our call.  */\n-      if (need_nop_at_end || final_sequence)\n-\toutput_asm_insn (\"b %a0\", operands);\n-      else\n-\toutput_asm_insn (\"b,a %a0\", operands);\n-    }\n-  else if (! final_sequence)\n-    {\n-      output_asm_insn (\"sethi %%hi(%a0),%%g1\\n\\tjmpl %%g1+%%lo(%a0),%%g1\",\n-\t\t       operands);\n-    }\n-  else\n-    {\n-      int i;\n-      rtx x = PATTERN (XVECEXP (final_sequence, 0, 1));\n-      for (i = 1; i < 32; i++)\n-\tif ((i == 1 || ! fixed_regs[i])\n-\t    && call_used_regs[i]\n-\t    && ! refers_to_regno_p (i, i+1, x, 0))\n-\t  break;\n-      if (i == 32)\n-\tabort ();\n-      operands[1] = gen_rtx (REG, SImode, i);\n-      output_asm_insn (\"sethi %%hi(%a0),%1\\n\\tjmpl %1+%%lo(%a0),%1\", operands);\n-    }\n-  return (need_nop_at_end ? \"nop\" : \"\");\n-}\n-#endif\n-\f\n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n    For `%' followed by punctuation, CODE is the punctuation and X is null.  */"}, {"sha": "8f1cee393ea04fa96339038374cfbf23c5a77de6", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef8200df89e7ebd52c41673ebb5e6fc100363201/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef8200df89e7ebd52c41673ebb5e6fc100363201/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=ef8200df89e7ebd52c41673ebb5e6fc100363201", "patch": "@@ -83,10 +83,6 @@ extern int target_flags;\n    use fast return insns, but lose some generality.  */\n #define TARGET_EPILOGUE (target_flags & 2)\n \n-/* Nonzero if we assume that all calls will fall within a 16MB\n-   pc-relative range.  Useful with -fomit-frame-pointer.  */\n-#define TARGET_TAIL_CALL (target_flags & 8)\n-\n /* Nonzero means that reference doublewords as if they were guaranteed\n    to be aligned...if they aren't, too bad for the user!\n    Like -fast in Sun cc.  */\n@@ -106,7 +102,6 @@ extern int target_flags;\n     {\"soft-float\", -1},\t\t\\\n     {\"epilogue\", 2},\t\t\\\n     {\"no-epilogue\", -2},\t\\\n-    {\"tail-call\", 8},\t\t\\\n     {\"hope-align\", 16},\t\t\\\n     {\"force-align\", 48},\t\\\n     { \"\", TARGET_DEFAULT}}\n@@ -866,7 +861,7 @@ extern int current_function_outgoing_args_size;\n extern union tree_node *current_function_decl;\n \n #define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-  output_function_epilogue (FILE, SIZE, leaf_function, 1)\n+  output_function_epilogue (FILE, SIZE, leaf_function)\n \n #define DELAY_SLOTS_FOR_EPILOGUE 1\n #define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled)\t\\"}, {"sha": "993ed4ea93d973db09fbb1135ad57886ba4d0f44", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef8200df89e7ebd52c41673ebb5e6fc100363201/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef8200df89e7ebd52c41673ebb5e6fc100363201/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=ef8200df89e7ebd52c41673ebb5e6fc100363201", "patch": "@@ -2317,12 +2317,6 @@\n   \"jmp %%o0+0\\;restore\"\n   [(set_attr \"type\" \"misc\")\n    (set_attr \"length\" \"2\")])\n-\n-;(define_insn \"tail_call\" ;; tail call\n-;  [(set (pc) (match_operand 0 \"memory_operand\" \"m\"))]\n-;  \"tail_call_valid_p ()\"\n-;  \"* return output_tail_call (operands, insn);\"\n-;  [(set_attr \"type\" \"branch\")])\n \f\n ;; Split up troublesome insns for better scheduling.  */\n "}]}