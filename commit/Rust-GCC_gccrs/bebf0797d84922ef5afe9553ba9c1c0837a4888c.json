{"sha": "bebf0797d84922ef5afe9553ba9c1c0837a4888c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmViZjA3OTdkODQ5MjJlZjVhZmU5NTUzYmE5YzFjMDgzN2E0ODg4Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-10-23T19:14:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-10-23T19:14:09Z"}, "message": "expmed.c (lowpart_bit_field_p): New function.\n\ngcc/\n\t* expmed.c (lowpart_bit_field_p): New function.\n\t(store_bit_field_1): Remove unit, offset, bitpos and byte_offset\n\tfrom the outermost scope.  Express conditions in terms of bitnum\n\trather than offset, bitpos and byte_offset.  Split the plain move\n\tcases into two, one for memory accesses and one for register accesses.\n\tAllow simplify_gen_subreg to fail rather than calling validate_subreg.\n\tMove the handling of multiword OP0s after the code that coerces VALUE\n\tto an integer mode.  Use simplify_gen_subreg for this case and assert\n\tthat it succeeds.  If the field still spans several words, pass it\n\tdirectly to store_split_bit_field.  Assume after that point that\n\tboth sources and register targets fit within a word.  Replace\n\tx-prefixed variables with non-prefixed forms.  Compute the bitpos\n\tfor insv register operands directly in the chosen unit size, rather\n\tthan going through an intermediate BITS_PER_WORD unit size.\n\tUpdate the call to store_fixed_bit_field.\n\t(store_fixed_bit_field): Replace the bitpos and offset parameters\n\twith a single bitnum parameter, of the same form as store_bit_field.\n\tAssume that OP0 contains the full field.  Simplify the memory offset\n\tcalculation.  Assert that the processed OP0 has an integral mode.\n\t(store_split_bit_field): Update the call to store_fixed_bit_field.\n\nFrom-SVN: r192740", "tree": {"sha": "753f3926533f34587f689a5e3f9cb358034052fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/753f3926533f34587f689a5e3f9cb358034052fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bebf0797d84922ef5afe9553ba9c1c0837a4888c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bebf0797d84922ef5afe9553ba9c1c0837a4888c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bebf0797d84922ef5afe9553ba9c1c0837a4888c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bebf0797d84922ef5afe9553ba9c1c0837a4888c/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a17d5a98417753708f385f0aab3a9cbcd2f1952a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a17d5a98417753708f385f0aab3a9cbcd2f1952a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a17d5a98417753708f385f0aab3a9cbcd2f1952a"}], "stats": {"total": 307, "additions": 143, "deletions": 164}, "files": [{"sha": "d667e8a83e3e99b5d004ca0b55ce1859d54e46b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bebf0797d84922ef5afe9553ba9c1c0837a4888c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bebf0797d84922ef5afe9553ba9c1c0837a4888c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bebf0797d84922ef5afe9553ba9c1c0837a4888c", "patch": "@@ -1,3 +1,26 @@\n+2012-10-23  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* expmed.c (lowpart_bit_field_p): New function.\n+\t(store_bit_field_1): Remove unit, offset, bitpos and byte_offset\n+\tfrom the outermost scope.  Express conditions in terms of bitnum\n+\trather than offset, bitpos and byte_offset.  Split the plain move\n+\tcases into two, one for memory accesses and one for register accesses.\n+\tAllow simplify_gen_subreg to fail rather than calling validate_subreg.\n+\tMove the handling of multiword OP0s after the code that coerces VALUE\n+\tto an integer mode.  Use simplify_gen_subreg for this case and assert\n+\tthat it succeeds.  If the field still spans several words, pass it\n+\tdirectly to store_split_bit_field.  Assume after that point that\n+\tboth sources and register targets fit within a word.  Replace\n+\tx-prefixed variables with non-prefixed forms.  Compute the bitpos\n+\tfor insv register operands directly in the chosen unit size, rather\n+\tthan going through an intermediate BITS_PER_WORD unit size.\n+\tUpdate the call to store_fixed_bit_field.\n+\t(store_fixed_bit_field): Replace the bitpos and offset parameters\n+\twith a single bitnum parameter, of the same form as store_bit_field.\n+\tAssume that OP0 contains the full field.  Simplify the memory offset\n+\tcalculation.  Assert that the processed OP0 has an integral mode.\n+\t(store_split_bit_field): Update the call to store_fixed_bit_field.\n+\n 2012-10-23  Paul Koning  <ni1d@arrl.net>\n \n \tPR debug/54508"}, {"sha": "3ea3e83d8d334f971af38c1a8f88810ab61a7a38", "filename": "gcc/expmed.c", "status": "modified", "additions": 120, "deletions": 164, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bebf0797d84922ef5afe9553ba9c1c0837a4888c/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bebf0797d84922ef5afe9553ba9c1c0837a4888c/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=bebf0797d84922ef5afe9553ba9c1c0837a4888c", "patch": "@@ -49,7 +49,6 @@ static void store_fixed_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   rtx);\n static void store_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n@@ -393,6 +392,23 @@ mode_for_extraction (enum extraction_pattern pattern, int opno)\n     return word_mode;\n   return data->operand[opno].mode;\n }\n+\n+/* Return true if a bitfield of size BITSIZE at bit number BITNUM within\n+   a structure of mode STRUCT_MODE represents a lowpart subreg.   The subreg\n+   offset is then BITNUM / BITS_PER_UNIT.  */\n+\n+static bool\n+lowpart_bit_field_p (unsigned HOST_WIDE_INT bitnum,\n+\t\t     unsigned HOST_WIDE_INT bitsize,\n+\t\t     enum machine_mode struct_mode)\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    return (bitnum % BITS_PER_UNIT\n+\t    && (bitnum + bitsize == GET_MODE_BITSIZE (struct_mode)\n+\t\t|| (bitnum + bitsize) % BITS_PER_WORD == 0));\n+  else\n+    return bitnum % BITS_PER_WORD == 0;\n+}\n \f\n /* A subroutine of store_bit_field, with the same arguments.  Return true\n    if the operation could be implemented.\n@@ -409,15 +425,9 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t   enum machine_mode fieldmode,\n \t\t   rtx value, bool fallback_p)\n {\n-  unsigned int unit\n-    = (MEM_P (str_rtx)) ? BITS_PER_UNIT : BITS_PER_WORD;\n-  unsigned HOST_WIDE_INT offset, bitpos;\n   rtx op0 = str_rtx;\n-  int byte_offset;\n   rtx orig_value;\n \n-  enum machine_mode op_mode = mode_for_extraction (EP_insv, 3);\n-\n   while (GET_CODE (op0) == SUBREG)\n     {\n       /* The following line once was done only if WORDS_BIG_ENDIAN,\n@@ -427,8 +437,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t always get higher addresses.  */\n       int inner_mode_size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)));\n       int outer_mode_size = GET_MODE_SIZE (GET_MODE (op0));\n-\n-      byte_offset = 0;\n+      int byte_offset = 0;\n \n       /* Paradoxical subregs need special handling on big endian machines.  */\n       if (SUBREG_BYTE (op0) == 0 && inner_mode_size < outer_mode_size)\n@@ -476,34 +485,34 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     }\n \n   /* If the target is a register, overwriting the entire object, or storing\n-     a full-word or multi-word field can be done with just a SUBREG.\n+     a full-word or multi-word field can be done with just a SUBREG.  */\n+  if (!MEM_P (op0)\n+      && bitsize == GET_MODE_BITSIZE (fieldmode)\n+      && ((bitsize == GET_MODE_BITSIZE (GET_MODE (op0)) && bitnum == 0)\n+\t  || (bitsize % BITS_PER_WORD == 0 && bitnum % BITS_PER_WORD == 0)))\n+    {\n+      /* Use the subreg machinery either to narrow OP0 to the required\n+\t words or to cope with mode punning between equal-sized modes.  */\n+      rtx sub = simplify_gen_subreg (fieldmode, op0, GET_MODE (op0),\n+\t\t\t\t     bitnum / BITS_PER_UNIT);\n+      if (sub)\n+\t{\n+\t  emit_move_insn (sub, value);\n+\t  return true;\n+\t}\n+    }\n \n-     If the target is memory, storing any naturally aligned field can be\n+  /* If the target is memory, storing any naturally aligned field can be\n      done with a simple store.  For targets that support fast unaligned\n      memory, any naturally sized, unit aligned field can be done directly.  */\n-\n-  offset = bitnum / unit;\n-  bitpos = bitnum % unit;\n-  byte_offset = (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n-                + (offset * UNITS_PER_WORD);\n-\n-  if (bitpos == 0\n+  if (MEM_P (op0)\n+      && bitnum % BITS_PER_UNIT == 0\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n-      && (!MEM_P (op0)\n-\t  ? ((GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD\n-\t      || GET_MODE_SIZE (GET_MODE (op0)) == GET_MODE_SIZE (fieldmode))\n-\t     && ((GET_MODE (op0) == fieldmode && byte_offset == 0)\n-\t\t || validate_subreg (fieldmode, GET_MODE (op0), op0,\n-\t\t\t\t     byte_offset)))\n-\t  : (! SLOW_UNALIGNED_ACCESS (fieldmode, MEM_ALIGN (op0))\n-\t     || (offset * BITS_PER_UNIT % bitsize == 0\n-\t\t && MEM_ALIGN (op0) % GET_MODE_BITSIZE (fieldmode) == 0))))\n+      && (!SLOW_UNALIGNED_ACCESS (fieldmode, MEM_ALIGN (op0))\n+\t  || (bitnum % bitsize == 0\n+\t      && MEM_ALIGN (op0) % bitsize == 0)))\n     {\n-      if (MEM_P (op0))\n-\top0 = adjust_bitfield_address (op0, fieldmode, offset);\n-      else if (GET_MODE (op0) != fieldmode)\n-\top0 = simplify_gen_subreg (fieldmode, op0, GET_MODE (op0),\n-\t\t\t\t   byte_offset);\n+      op0 = adjust_bitfield_address (op0, fieldmode, bitnum / BITS_PER_UNIT);\n       emit_move_insn (op0, value);\n       return true;\n     }\n@@ -526,19 +535,11 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       }\n   }\n \n-  /* If OP0 is a register, BITPOS must count within a word.\n-     But as we have it, it counts within whatever size OP0 now has.\n-     On a bigendian machine, these are not the same, so convert.  */\n-  if (BYTES_BIG_ENDIAN\n-      && !MEM_P (op0)\n-      && unit > GET_MODE_BITSIZE (GET_MODE (op0)))\n-    bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n-\n   /* Storing an lsb-aligned field in a register\n-     can be done with a movestrict instruction.  */\n+     can be done with a movstrict instruction.  */\n \n   if (!MEM_P (op0)\n-      && (BYTES_BIG_ENDIAN ? bitpos + bitsize == unit : bitpos == 0)\n+      && lowpart_bit_field_p (bitnum, bitsize, GET_MODE (op0))\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n       && optab_handler (movstrict_optab, fieldmode) != CODE_FOR_nothing)\n     {\n@@ -558,8 +559,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  arg0 = SUBREG_REG (arg0);\n \t}\n \n-      subreg_off = (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n-\t\t   + (offset * UNITS_PER_WORD);\n+      subreg_off = bitnum / BITS_PER_UNIT;\n       if (validate_subreg (fieldmode, GET_MODE (arg0), arg0, subreg_off))\n \t{\n \t  arg0 = gen_rtx_SUBREG (fieldmode, arg0, subreg_off);\n@@ -638,34 +638,6 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       return true;\n     }\n \n-  /* From here on we can assume that the field to be stored in is\n-     a full-word (whatever type that is), since it is shorter than a word.  */\n-\n-  /* OFFSET is the number of words or bytes (UNIT says which)\n-     from STR_RTX to the first word or byte containing part of the field.  */\n-\n-  if (!MEM_P (op0))\n-    {\n-      if (offset != 0\n-\t  || GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n-\t{\n-\t  if (!REG_P (op0))\n-\t    {\n-\t      /* Since this is a destination (lvalue), we can't copy\n-\t\t it to a pseudo.  We can remove a SUBREG that does not\n-\t\t change the size of the operand.  Such a SUBREG may\n-\t\t have been added above.  */\n-\t      gcc_assert (GET_CODE (op0) == SUBREG\n-\t\t\t  && (GET_MODE_SIZE (GET_MODE (op0))\n-\t\t\t      == GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)))));\n-\t      op0 = SUBREG_REG (op0);\n-\t    }\n-\t  op0 = gen_rtx_SUBREG (mode_for_size (BITS_PER_WORD, MODE_INT, 0),\n-\t\t                op0, (offset * UNITS_PER_WORD));\n-\t}\n-      offset = 0;\n-    }\n-\n   /* If VALUE has a floating-point or complex mode, access it as an\n      integer of the corresponding size.  This can occur on a machine\n      with 64 bit registers that uses SFmode for float.  It can also\n@@ -679,9 +651,30 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       emit_move_insn (gen_lowpart (GET_MODE (orig_value), value), orig_value);\n     }\n \n-  /* Now OFFSET is nonzero only if OP0 is memory\n-     and is therefore always measured in bytes.  */\n+  /* If OP0 is a multi-word register, narrow it to the affected word.\n+     If the region spans two words, defer to store_split_bit_field.  */\n+  if (!MEM_P (op0) && GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n+    {\n+      op0 = simplify_gen_subreg (word_mode, op0, GET_MODE (op0),\n+\t\t\t\t bitnum / BITS_PER_WORD * UNITS_PER_WORD);\n+      gcc_assert (op0);\n+      bitnum %= BITS_PER_WORD;\n+      if (bitnum + bitsize > BITS_PER_WORD)\n+\t{\n+\t  if (!fallback_p)\n+\t    return false;\n \n+\t  store_split_bit_field (op0, bitsize, bitnum, bitregion_start,\n+\t\t\t\t bitregion_end, value);\n+\t  return true;\n+\t}\n+    }\n+\n+  /* From here on we can assume that the field to be stored in fits\n+     within a word.  If the destination is a register, it too fits\n+     in a word.  */\n+\n+  enum machine_mode op_mode = mode_for_extraction (EP_insv, 3);\n   if (HAVE_insv\n       && GET_MODE (value) != BLKmode\n       && bitsize > 0\n@@ -690,25 +683,34 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n          -fstrict-volatile-bitfields is in effect.  */\n       && !(MEM_P (op0) && MEM_VOLATILE_P (op0)\n \t   && flag_strict_volatile_bitfields > 0)\n-      && ! ((REG_P (op0) || GET_CODE (op0) == SUBREG)\n-\t    && (bitsize + bitpos > GET_MODE_BITSIZE (op_mode)))\n       /* Do not use insv if the bit region is restricted and\n \t op_mode integer at offset doesn't fit into the\n \t restricted region.  */\n       && !(MEM_P (op0) && bitregion_end\n-\t   && bitnum - bitpos + GET_MODE_BITSIZE (op_mode)\n+\t   && bitnum - (bitnum % BITS_PER_UNIT) + GET_MODE_BITSIZE (op_mode)\n \t      > bitregion_end + 1))\n     {\n       struct expand_operand ops[4];\n-      int xbitpos = bitpos;\n+      unsigned HOST_WIDE_INT bitpos = bitnum;\n       rtx value1;\n       rtx xop0 = op0;\n       rtx last = get_last_insn ();\n       bool copy_back = false;\n \n-      /* Add OFFSET into OP0's address.  */\n+      unsigned int unit = GET_MODE_BITSIZE (op_mode);\n       if (MEM_P (xop0))\n-\txop0 = adjust_bitfield_address (xop0, byte_mode, offset);\n+\t{\n+\t  /* Get a reference to the first byte of the field.  */\n+\t  xop0 = adjust_bitfield_address (xop0, byte_mode,\n+\t\t\t\t\t  bitpos / BITS_PER_UNIT);\n+\t  bitpos %= BITS_PER_UNIT;\n+\t}\n+      else\n+\t{\n+\t  /* Convert from counting within OP0 to counting in OP_MODE.  */\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n+\t}\n \n       /* If xop0 is a register, we need it in OP_MODE\n \t to make it acceptable to the format of insv.  */\n@@ -735,20 +737,13 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  copy_back = true;\n \t}\n \n-      /* We have been counting XBITPOS within UNIT.\n-\t Count instead within the size of the register.  */\n-      if (BYTES_BIG_ENDIAN && !MEM_P (xop0))\n-\txbitpos += GET_MODE_BITSIZE (op_mode) - unit;\n-\n-      unit = GET_MODE_BITSIZE (op_mode);\n-\n       /* If BITS_BIG_ENDIAN is zero on a BYTES_BIG_ENDIAN machine, we count\n          \"backwards\" from the size of the unit we are inserting into.\n \t Otherwise, we count bits from the most significant on a\n \t BYTES/BITS_BIG_ENDIAN machine.  */\n \n       if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n-\txbitpos = unit - bitsize - xbitpos;\n+\tbitpos = unit - bitsize - bitpos;\n \n       /* Convert VALUE to op_mode (which insv insn wants) in VALUE1.  */\n       value1 = value;\n@@ -787,7 +782,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n       create_fixed_operand (&ops[0], xop0);\n       create_integer_operand (&ops[1], bitsize);\n-      create_integer_operand (&ops[2], xbitpos);\n+      create_integer_operand (&ops[2], bitpos);\n       create_input_operand (&ops[3], value1, op_mode);\n       if (maybe_expand_insn (CODE_FOR_insv, 4, ops))\n \t{\n@@ -832,22 +827,23 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t       && GET_MODE_BITSIZE (bestmode) > MEM_ALIGN (op0)))\n \t{\n \t  rtx last, tempreg, xop0;\n-\t  unsigned HOST_WIDE_INT xoffset, xbitpos;\n+\t  unsigned int unit;\n+\t  unsigned HOST_WIDE_INT offset, bitpos;\n \n \t  last = get_last_insn ();\n \n \t  /* Adjust address to point to the containing unit of\n \t     that mode.  Compute the offset as a multiple of this unit,\n \t     counting in bytes.  */\n \t  unit = GET_MODE_BITSIZE (bestmode);\n-\t  xoffset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n-\t  xbitpos = bitnum % unit;\n-\t  xop0 = adjust_bitfield_address (op0, bestmode, xoffset);\n+\t  offset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n+\t  bitpos = bitnum % unit;\n+\t  xop0 = adjust_bitfield_address (op0, bestmode, offset);\n \n \t  /* Fetch that unit, store the bitfield in it, then store\n \t     the unit.  */\n \t  tempreg = copy_to_reg (xop0);\n-\t  if (store_bit_field_1 (tempreg, bitsize, xbitpos,\n+\t  if (store_bit_field_1 (tempreg, bitsize, bitpos,\n \t\t\t\t bitregion_start, bitregion_end,\n \t\t\t\t fieldmode, orig_value, false))\n \t    {\n@@ -861,8 +857,8 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (!fallback_p)\n     return false;\n \n-  store_fixed_bit_field (op0, offset, bitsize, bitpos,\n-\t\t\t bitregion_start, bitregion_end, value);\n+  store_fixed_bit_field (op0, bitsize, bitnum, bitregion_start,\n+\t\t\t bitregion_end, value);\n   return true;\n }\n \n@@ -918,25 +914,17 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     gcc_unreachable ();\n }\n \f\n-/* Use shifts and boolean operations to store VALUE\n-   into a bit field of width BITSIZE\n-   in a memory location specified by OP0 except offset by OFFSET bytes.\n-     (OFFSET must be 0 if OP0 is a register.)\n-   The field starts at position BITPOS within the byte.\n-    (If OP0 is a register, it may be a full word or a narrower mode,\n-     but BITPOS still counts within a full word,\n-     which is significant on bigendian machines.)  */\n+/* Use shifts and boolean operations to store VALUE into a bit field of\n+   width BITSIZE in OP0, starting at bit BITNUM.  */\n \n static void\n-store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n-\t\t       unsigned HOST_WIDE_INT bitsize,\n-\t\t       unsigned HOST_WIDE_INT bitpos,\n+store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+\t\t       unsigned HOST_WIDE_INT bitnum,\n \t\t       unsigned HOST_WIDE_INT bitregion_start,\n \t\t       unsigned HOST_WIDE_INT bitregion_end,\n \t\t       rtx value)\n {\n   enum machine_mode mode;\n-  unsigned int total_bits = BITS_PER_WORD;\n   rtx temp;\n   int all_zero = 0;\n   int all_one = 0;\n@@ -948,19 +936,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n      and a field split across two bytes.\n      Such cases are not supposed to be able to occur.  */\n \n-  if (REG_P (op0) || GET_CODE (op0) == SUBREG)\n-    {\n-      gcc_assert (!offset);\n-      /* Special treatment for a bit field split across two registers.  */\n-      if (bitsize + bitpos > BITS_PER_WORD)\n-\t{\n-\t  store_split_bit_field (op0, bitsize, bitpos,\n-\t\t\t\t bitregion_start, bitregion_end,\n-\t\t\t\t value);\n-\t  return;\n-\t}\n-    }\n-  else\n+  if (MEM_P (op0))\n     {\n       unsigned HOST_WIDE_INT maxbits = MAX_FIXED_MODE_SIZE;\n \n@@ -983,58 +959,39 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \t  && flag_strict_volatile_bitfields > 0)\n \tmode = GET_MODE (op0);\n       else\n-\tmode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT,\n-\t\t\t      bitregion_start, bitregion_end,\n+\tmode = get_best_mode (bitsize, bitnum, bitregion_start, bitregion_end,\n \t\t\t      MEM_ALIGN (op0), mode, MEM_VOLATILE_P (op0));\n \n       if (mode == VOIDmode)\n \t{\n \t  /* The only way this should occur is if the field spans word\n \t     boundaries.  */\n-\t  store_split_bit_field (op0, bitsize, bitpos + offset * BITS_PER_UNIT,\n-\t\t\t\t bitregion_start, bitregion_end, value);\n+\t  store_split_bit_field (op0, bitsize, bitnum, bitregion_start,\n+\t\t\t\t bitregion_end, value);\n \t  return;\n \t}\n \n-      total_bits = GET_MODE_BITSIZE (mode);\n-\n-      /* Make sure bitpos is valid for the chosen mode.  Adjust BITPOS to\n-\t be in the range 0 to total_bits-1, and put any excess bytes in\n-\t OFFSET.  */\n-      if (bitpos >= total_bits)\n-\t{\n-\t  offset += (bitpos / total_bits) * (total_bits / BITS_PER_UNIT);\n-\t  bitpos -= ((bitpos / total_bits) * (total_bits / BITS_PER_UNIT)\n-\t\t     * BITS_PER_UNIT);\n-\t}\n-\n-      /* Get ref to an aligned byte, halfword, or word containing the field.\n-\t Adjust BITPOS to be position within a word,\n-\t and OFFSET to be the offset of that word.\n-\t Then alter OP0 to refer to that word.  */\n-      bitpos += (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT;\n-      offset -= (offset % (total_bits / BITS_PER_UNIT));\n-      op0 = adjust_bitfield_address (op0, mode, offset);\n+      HOST_WIDE_INT bit_offset = bitnum - bitnum % GET_MODE_BITSIZE (mode);\n+      op0 = adjust_bitfield_address (op0, mode, bit_offset / BITS_PER_UNIT);\n+      bitnum -= bit_offset;\n     }\n \n   mode = GET_MODE (op0);\n+  gcc_assert (SCALAR_INT_MODE_P (mode));\n \n-  /* Now MODE is either some integral mode for a MEM as OP0,\n-     or is a full-word for a REG as OP0.  TOTAL_BITS corresponds.\n-     The bit field is contained entirely within OP0.\n-     BITPOS is the starting bit number within OP0.\n-     (OP0's mode may actually be narrower than MODE.)  */\n+  /* Note that bitsize + bitnum can be greater than GET_MODE_BITSIZE (mode)\n+     for invalid input, such as f5 from gcc.dg/pr48335-2.c.  */\n \n   if (BYTES_BIG_ENDIAN)\n-      /* BITPOS is the distance between our msb\n-\t and that of the containing datum.\n-\t Convert it to the distance from the lsb.  */\n-      bitpos = total_bits - bitsize - bitpos;\n+    /* BITNUM is the distance between our msb\n+       and that of the containing datum.\n+       Convert it to the distance from the lsb.  */\n+    bitnum = GET_MODE_BITSIZE (mode) - bitsize - bitnum;\n \n-  /* Now BITPOS is always the distance between our lsb\n+  /* Now BITNUM is always the distance between our lsb\n      and that of OP0.  */\n \n-  /* Shift VALUE left by BITPOS bits.  If VALUE is not constant,\n+  /* Shift VALUE left by BITNUM bits.  If VALUE is not constant,\n      we must first convert its mode to MODE.  */\n \n   if (CONST_INT_P (value))\n@@ -1051,12 +1008,12 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \t       || (bitsize == HOST_BITS_PER_WIDE_INT && v == -1))\n \tall_one = 1;\n \n-      value = lshift_value (mode, value, bitpos, bitsize);\n+      value = lshift_value (mode, value, bitnum, bitsize);\n     }\n   else\n     {\n       int must_and = (GET_MODE_BITSIZE (GET_MODE (value)) != bitsize\n-\t\t      && bitpos + bitsize != GET_MODE_BITSIZE (mode));\n+\t\t      && bitnum + bitsize != GET_MODE_BITSIZE (mode));\n \n       if (GET_MODE (value) != mode)\n \tvalue = convert_to_mode (mode, value, 1);\n@@ -1065,9 +1022,9 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \tvalue = expand_binop (mode, and_optab, value,\n \t\t\t      mask_rtx (mode, 0, bitsize, 0),\n \t\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-      if (bitpos > 0)\n+      if (bitnum > 0)\n \tvalue = expand_shift (LSHIFT_EXPR, mode, value,\n-\t\t\t      bitpos, NULL_RTX, 1);\n+\t\t\t      bitnum, NULL_RTX, 1);\n     }\n \n   /* Now clear the chosen bits in OP0,\n@@ -1080,7 +1037,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n   if (! all_one)\n     {\n       temp = expand_binop (mode, and_optab, temp,\n-\t\t\t   mask_rtx (mode, bitpos, bitsize, 1),\n+\t\t\t   mask_rtx (mode, bitnum, bitsize, 1),\n \t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n       temp = force_reg (mode, temp);\n     }\n@@ -1235,12 +1192,11 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n       else\n \tword = op0;\n \n-      /* OFFSET is in UNITs, and UNIT is in bits.\n-\t store_fixed_bit_field wants offset in bytes.  If WORD is const0_rtx,\n+      /* OFFSET is in UNITs, and UNIT is in bits.  If WORD is const0_rtx,\n \t it is just an out-of-bounds access.  Ignore it.  */\n       if (word != const0_rtx)\n-\tstore_fixed_bit_field (word, offset * unit / BITS_PER_UNIT, thissize,\n-\t\t\t       thispos, bitregion_start, bitregion_end, part);\n+\tstore_fixed_bit_field (word, thissize, offset * unit + thispos,\n+\t\t\t       bitregion_start, bitregion_end, part);\n       bitsdone += thissize;\n     }\n }"}]}