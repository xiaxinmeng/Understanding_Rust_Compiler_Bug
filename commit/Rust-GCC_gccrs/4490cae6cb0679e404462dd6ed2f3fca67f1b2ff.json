{"sha": "4490cae6cb0679e404462dd6ed2f3fca67f1b2ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ5MGNhZTZjYjA2NzllNDA0NDYyZGQ2ZWQyZjNmY2E2N2YxYjJmZg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-10-22T17:50:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-10-22T17:50:19Z"}, "message": "gimple.h (gimple_register_canonical_type): Declare.\n\n2010-10-22  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.h (gimple_register_canonical_type): Declare.\n\t* gimple.c (gimple_canonical_types): New global hashtable.\n\t(struct gimple_type_leader_entry_s): New type.\n\t(gimple_type_leader): New global cache.\n\t(gimple_lookup_type_leader): New function.\n\t(gtc_visit): Query the proper cache.\n\t(gimple_types_compatible_p): Likewise.\n\t(gimple_register_type): Use the new cache instead of TYPE_CANONICAL.\n\t(gimple_canonical_type_eq): New function.\n\t(gimple_register_canonical_type): Likewise.\n\t(print_gimple_types_stats): Adjust for gimple_canonical_types.\n\t(free_gimple_type_tables): Likewise.  Free gimple_type_leader.\n\t* tree-ssa.c (useless_type_conversion_p): Do not dispatch to\n\tgimple_types_compatible_p for LTO.\n\n\tlto/\n\t* lto.c (lto_fixup_type): Fixup TYPE_CANONICAL again, via\n\tthe new gimple_register_canonical_type.\n\nFrom-SVN: r165848", "tree": {"sha": "51747a7400d09696fd222abfe130d3208c339e37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51747a7400d09696fd222abfe130d3208c339e37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5ab2c5cb69db963a15fee5fca519db220310230d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab2c5cb69db963a15fee5fca519db220310230d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ab2c5cb69db963a15fee5fca519db220310230d"}], "stats": {"total": 198, "additions": 177, "deletions": 21}, "files": [{"sha": "6c0d98d7200d72d8322f5dfdf365f23ae4454273", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4490cae6cb0679e404462dd6ed2f3fca67f1b2ff", "patch": "@@ -1,3 +1,20 @@\n+2010-10-22  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.h (gimple_register_canonical_type): Declare.\n+\t* gimple.c (gimple_canonical_types): New global hashtable.\n+\t(struct gimple_type_leader_entry_s): New type.\n+\t(gimple_type_leader): New global cache.\n+\t(gimple_lookup_type_leader): New function.\n+\t(gtc_visit): Query the proper cache.\n+\t(gimple_types_compatible_p): Likewise.\n+\t(gimple_register_type): Use the new cache instead of TYPE_CANONICAL.\n+\t(gimple_canonical_type_eq): New function.\n+\t(gimple_register_canonical_type): Likewise.\n+\t(print_gimple_types_stats): Adjust for gimple_canonical_types.\n+\t(free_gimple_type_tables): Likewise.  Free gimple_type_leader.\n+\t* tree-ssa.c (useless_type_conversion_p): Do not dispatch to\n+\tgimple_types_compatible_p for LTO.\n+\n 2010-10-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/46098"}, {"sha": "dea0b8355d2c9623e36e2eed2070399824cb428e", "filename": "gcc/gimple.c", "status": "modified", "additions": 145, "deletions": 15, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4490cae6cb0679e404462dd6ed2f3fca67f1b2ff", "patch": "@@ -44,6 +44,8 @@ along with GCC; see the file COPYING3.  If not see\n    build_*_type routines which is not the case with the streamer.  */\n static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n   htab_t gimple_types;\n+static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n+  htab_t gimple_canonical_types;\n static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n   htab_t type_hash_cache;\n \n@@ -3257,6 +3259,36 @@ struct sccs\n static unsigned int next_dfs_num;\n static unsigned int gtc_next_dfs_num;\n \n+\n+/* GIMPLE type merging cache.  A direct-mapped cache based on TYPE_UID.  */\n+\n+typedef struct GTY(()) gimple_type_leader_entry_s {\n+  tree type;\n+  tree leader;\n+} gimple_type_leader_entry;\n+\n+#define GIMPLE_TYPE_LEADER_SIZE 16381\n+static GTY((length(\"GIMPLE_TYPE_LEADER_SIZE\"))) gimple_type_leader_entry\n+  *gimple_type_leader;\n+\n+/* Lookup an existing leader for T and return it or NULL_TREE, if\n+   there is none in the cache.  */\n+\n+static tree\n+gimple_lookup_type_leader (tree t)\n+{\n+  gimple_type_leader_entry *leader;\n+\n+  if (!gimple_type_leader)\n+    return NULL_TREE;\n+\n+  leader = &gimple_type_leader[TYPE_UID (t) % GIMPLE_TYPE_LEADER_SIZE];\n+  if (leader->type != t)\n+    return NULL_TREE;\n+\n+  return leader->leader;\n+}\n+\n /* Return true if T1 and T2 have the same name.  If FOR_COMPLETION_P is\n    true then if any type has no name return false, otherwise return\n    true if both types have no names.  */\n@@ -3401,9 +3433,21 @@ gtc_visit (tree t1, tree t2, enum gtc_mode mode,\n \n   /* If the types have been previously registered and found equal\n      they still are.  */\n-  if (TYPE_CANONICAL (t1)\n-      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n-    return true;\n+  if (mode == GTC_MERGE)\n+    {\n+      tree leader1 = gimple_lookup_type_leader (t1);\n+      tree leader2 = gimple_lookup_type_leader (t2);\n+      if (leader1 == t2\n+\t  || t1 == leader2\n+\t  || (leader1 && leader1 == leader2))\n+\treturn true;\n+    }\n+  else if (mode == GTC_DIAG)\n+    {\n+      if (TYPE_CANONICAL (t1)\n+\t  && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n+\treturn true;\n+    }\n \n   /* Can't be the same type if the types don't have the same code.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n@@ -3826,9 +3870,21 @@ gimple_types_compatible_p (tree t1, tree t2, enum gtc_mode mode)\n \n   /* If the types have been previously registered and found equal\n      they still are.  */\n-  if (TYPE_CANONICAL (t1)\n-      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n-    return true;\n+  if (mode == GTC_MERGE)\n+    {\n+      tree leader1 = gimple_lookup_type_leader (t1);\n+      tree leader2 = gimple_lookup_type_leader (t2);\n+      if (leader1 == t2\n+\t  || t1 == leader2\n+\t  || (leader1 && leader1 == leader2))\n+\treturn true;\n+    }\n+  else if (mode == GTC_DIAG)\n+    {\n+      if (TYPE_CANONICAL (t1)\n+\t  && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n+\treturn true;\n+    }\n \n   /* Can't be the same type if the types don't have the same code.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n@@ -4226,14 +4282,17 @@ tree\n gimple_register_type (tree t)\n {\n   void **slot;\n+  gimple_type_leader_entry *leader;\n \n   gcc_assert (TYPE_P (t));\n \n-  /* In TYPE_CANONICAL we cache the result of gimple_register_type.\n-     It is initially set to NULL during LTO streaming.\n-     But do not mess with TYPE_CANONICAL when not in WPA or link phase.  */\n-  if (in_lto_p && TYPE_CANONICAL (t))\n-    return TYPE_CANONICAL (t);\n+  if (!gimple_type_leader)\n+    gimple_type_leader = ggc_alloc_cleared_vec_gimple_type_leader_entry_s\n+\t\t\t\t(GIMPLE_TYPE_LEADER_SIZE);\n+  /* If we registered this type before return the cached result.  */\n+  leader = &gimple_type_leader[TYPE_UID (t) % GIMPLE_TYPE_LEADER_SIZE];\n+  if (leader->type == t)\n+    return leader->leader;\n \n   /* Always register the main variant first.  This is important so we\n      pick up the non-typedef variants as canonical, otherwise we'll end\n@@ -4298,14 +4357,69 @@ gimple_register_type (tree t)\n \t  TYPE_NEXT_REF_TO (t) = NULL_TREE;\n \t}\n \n-      if (in_lto_p)\n-\tTYPE_CANONICAL (t) = new_type;\n+      leader->type = t;\n+      leader->leader = new_type;\n       t = new_type;\n     }\n   else\n     {\n-      if (in_lto_p)\n-\tTYPE_CANONICAL (t) = t;\n+      leader->type = t;\n+      leader->leader = t;\n+      *slot = (void *) t;\n+    }\n+\n+  return t;\n+}\n+\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+gimple_canonical_type_eq (const void *p1, const void *p2)\n+{\n+  const_tree t1 = (const_tree) p1;\n+  const_tree t2 = (const_tree) p2;\n+  return gimple_types_compatible_p (CONST_CAST_TREE (t1),\n+\t\t\t\t    CONST_CAST_TREE (t2), GTC_DIAG);\n+}\n+\n+/* Register type T in the global type table gimple_types.\n+   If another type T', compatible with T, already existed in\n+   gimple_types then return T', otherwise return T.  This is used by\n+   LTO to merge identical types read from different TUs.  */\n+\n+tree\n+gimple_register_canonical_type (tree t)\n+{\n+  void **slot;\n+\n+  gcc_assert (TYPE_P (t));\n+\n+  if (TYPE_CANONICAL (t))\n+    return TYPE_CANONICAL (t);\n+\n+  /* Always register the main variant first.  This is important so we\n+     pick up the non-typedef variants as canonical, otherwise we'll end\n+     up taking typedef ids for structure tags during comparison.  */\n+  if (TYPE_MAIN_VARIANT (t) != t)\n+    gimple_register_canonical_type (TYPE_MAIN_VARIANT (t));\n+\n+  if (gimple_canonical_types == NULL)\n+    gimple_canonical_types = htab_create_ggc (16381, gimple_type_hash,\n+\t\t\t\t\t      gimple_canonical_type_eq, 0);\n+\n+  slot = htab_find_slot (gimple_canonical_types, t, INSERT);\n+  if (*slot\n+      && *(tree *)slot != t)\n+    {\n+      tree new_type = (tree) *((tree *) slot);\n+\n+      TYPE_CANONICAL (t) = new_type;\n+      t = new_type;\n+    }\n+  else\n+    {\n+      TYPE_CANONICAL (t) = t;\n       *slot = (void *) t;\n     }\n \n@@ -4328,6 +4442,16 @@ print_gimple_types_stats (void)\n \t     htab_collisions (gimple_types));\n   else\n     fprintf (stderr, \"GIMPLE type table is empty\\n\");\n+  if (gimple_canonical_types)\n+    fprintf (stderr, \"GIMPLE canonical type table: size %ld, %ld elements, \"\n+\t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n+\t     (long) htab_size (gimple_canonical_types),\n+\t     (long) htab_elements (gimple_canonical_types),\n+\t     (long) gimple_canonical_types->searches,\n+\t     (long) gimple_canonical_types->collisions,\n+\t     htab_collisions (gimple_canonical_types));\n+  else\n+    fprintf (stderr, \"GIMPLE canonical type table is empty\\n\");\n   if (type_hash_cache)\n     fprintf (stderr, \"GIMPLE type hash table: size %ld, %ld elements, \"\n \t     \"%ld searches, %ld collisions (ratio: %f)\\n\",\n@@ -4364,6 +4488,11 @@ free_gimple_type_tables (void)\n       htab_delete (gimple_types);\n       gimple_types = NULL;\n     }\n+  if (gimple_canonical_types)\n+    {\n+      htab_delete (gimple_canonical_types);\n+      gimple_canonical_types = NULL;\n+    }\n   if (type_hash_cache)\n     {\n       htab_delete (type_hash_cache);\n@@ -4375,6 +4504,7 @@ free_gimple_type_tables (void)\n       obstack_free (&gtc_ob, NULL);\n       gtc_visited = NULL;\n     }\n+  gimple_type_leader = NULL;\n }\n \n "}, {"sha": "150b836d55f8b25d6aa1406cd4c9cdb70fcb1e31", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=4490cae6cb0679e404462dd6ed2f3fca67f1b2ff", "patch": "@@ -957,6 +957,7 @@ extern tree get_call_expr_in (tree t);\n extern void recalculate_side_effects (tree);\n extern bool gimple_compare_field_offset (tree, tree);\n extern tree gimple_register_type (tree);\n+extern tree gimple_register_canonical_type (tree);\n enum gtc_mode { GTC_MERGE = 0, GTC_DIAG = 1 };\n extern bool gimple_types_compatible_p (tree, tree, enum gtc_mode);\n extern void print_gimple_types_stats (void);"}, {"sha": "6df206f988bfa179aa2765b65a871956e660c4bd", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=4490cae6cb0679e404462dd6ed2f3fca67f1b2ff", "patch": "@@ -1,3 +1,8 @@\n+2010-10-22  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto.c (lto_fixup_type): Fixup TYPE_CANONICAL again, via\n+\tthe new gimple_register_canonical_type.\n+\n 2010-10-20  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR bootstrap/45954"}, {"sha": "429b3d2d3a9ca27572d4cc62e7ced5cdb932c1ce", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=4490cae6cb0679e404462dd6ed2f3fca67f1b2ff", "patch": "@@ -1710,10 +1710,14 @@ lto_fixup_type (tree t, void *data)\n \tLTO_FIXUP_SUBTREE (TYPE_CONTEXT (t));\n     }\n \n-  /* TYPE_CANONICAL does not need to be fixed up, instead it should\n-     always point to ourselves at this time as we never fixup\n-     non-canonical ones.  */\n-  gcc_assert (TYPE_CANONICAL (t) == t);\n+  /* Compute the canonical type of t and fix that up.  From this point\n+     there are no longer any types with TYPE_STRUCTURAL_EQUALITY_P\n+     and its type-based alias problems.  */\n+  if (!TYPE_CANONICAL (t))\n+    {\n+      TYPE_CANONICAL (t) = gimple_register_canonical_type (t);\n+      LTO_FIXUP_SUBTREE (TYPE_CANONICAL (t));\n+    }\n \n   /* The following re-creates proper variant lists while fixing up\n      the variant leaders.  We do not stream TYPE_NEXT_VARIANT so the"}, {"sha": "60abc6b55fc39151ccb23ca1e7b9d77f8c8bf4e8", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4490cae6cb0679e404462dd6ed2f3fca67f1b2ff/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=4490cae6cb0679e404462dd6ed2f3fca67f1b2ff", "patch": "@@ -1442,8 +1442,7 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n      compared types.  */\n   else if (AGGREGATE_TYPE_P (inner_type)\n \t   && TREE_CODE (inner_type) == TREE_CODE (outer_type))\n-    return (in_lto_p\n-\t    && gimple_types_compatible_p (outer_type, inner_type, GTC_DIAG));\n+    return false;\n \n   return false;\n }"}]}