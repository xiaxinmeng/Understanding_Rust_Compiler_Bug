{"sha": "6786ba1aaa8533e286b8d8f333cc9d75cf5c9989", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc4NmJhMWFhYTg1MzNlMjg2YjhkOGYzMzNjYzlkNzVjZjVjOTk4OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-16T11:03:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-16T11:03:23Z"}, "message": "* final.c (compute_alignments): Use counts rather than frequencies.\n\nFrom-SVN: r254809", "tree": {"sha": "a7290a648b9724c739ce7a1f3f24a79ed262c873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7290a648b9724c739ce7a1f3f24a79ed262c873"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6786ba1aaa8533e286b8d8f333cc9d75cf5c9989", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6786ba1aaa8533e286b8d8f333cc9d75cf5c9989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6786ba1aaa8533e286b8d8f333cc9d75cf5c9989", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6786ba1aaa8533e286b8d8f333cc9d75cf5c9989/comments", "author": null, "committer": null, "parents": [{"sha": "debc8f4a0c23f9cacd6391319432357fbc9049eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/debc8f4a0c23f9cacd6391319432357fbc9049eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/debc8f4a0c23f9cacd6391319432357fbc9049eb"}], "stats": {"total": 64, "additions": 37, "deletions": 27}, "files": [{"sha": "93d4cb3423c3972ba4d4000cb6219f5a0ba3bdc2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6786ba1aaa8533e286b8d8f333cc9d75cf5c9989/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6786ba1aaa8533e286b8d8f333cc9d75cf5c9989/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6786ba1aaa8533e286b8d8f333cc9d75cf5c9989", "patch": "@@ -1,3 +1,7 @@\n+2017-11-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* final.c (compute_alignments): Use counts rather than frequencies.\n+\n 2017-11-14  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cfgloopanal.c: Include sreal.h"}, {"sha": "672c5bbc49c3d7eaf2ec7a56156a813107e9476b", "filename": "gcc/final.c", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6786ba1aaa8533e286b8d8f333cc9d75cf5c9989/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6786ba1aaa8533e286b8d8f333cc9d75cf5c9989/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=6786ba1aaa8533e286b8d8f333cc9d75cf5c9989", "patch": "@@ -661,16 +661,13 @@ insn_current_reference_address (rtx_insn *branch)\n     }\n }\n \f\n-/* Compute branch alignments based on frequency information in the\n-   CFG.  */\n+/* Compute branch alignments based on CFG profile.  */\n \n unsigned int\n compute_alignments (void)\n {\n   int log, max_skip, max_log;\n   basic_block bb;\n-  int freq_max = 0;\n-  int freq_threshold = 0;\n \n   if (label_align)\n     {\n@@ -693,17 +690,19 @@ compute_alignments (void)\n       flow_loops_dump (dump_file, NULL, 1);\n     }\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n-  FOR_EACH_BB_FN (bb, cfun)\n-    if (bb->count.to_frequency (cfun) > freq_max)\n-      freq_max = bb->count.to_frequency (cfun);\n-  freq_threshold = freq_max / PARAM_VALUE (PARAM_ALIGN_THRESHOLD);\n+  profile_count count_threshold = cfun->cfg->count_max.apply_scale\n+\t\t (1, PARAM_VALUE (PARAM_ALIGN_THRESHOLD));\n \n   if (dump_file)\n-    fprintf (dump_file, \"freq_max: %i\\n\",freq_max);\n+    {\n+      fprintf (dump_file, \"count_max: \");\n+      cfun->cfg->count_max.dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       rtx_insn *label = BB_HEAD (bb);\n-      int fallthru_frequency = 0, branch_frequency = 0, has_fallthru = 0;\n+      bool has_fallthru = 0;\n       edge e;\n       edge_iterator ei;\n \n@@ -712,35 +711,41 @@ compute_alignments (void)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n-\t\t     \"BB %4i freq %4i loop %2i loop_depth %2i skipped.\\n\",\n-\t\t     bb->index, bb->count.to_frequency (cfun),\n+\t\t     \"BB %4i loop %2i loop_depth %2i skipped.\\n\",\n+\t\t     bb->index,\n \t\t     bb->loop_father->num,\n \t\t     bb_loop_depth (bb));\n \t  continue;\n \t}\n       max_log = LABEL_ALIGN (label);\n       max_skip = targetm.asm_out.label_align_max_skip (label);\n+      profile_count fallthru_count = profile_count::zero ();\n+      profile_count branch_count = profile_count::zero ();\n \n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  if (e->flags & EDGE_FALLTHRU)\n-\t    has_fallthru = 1, fallthru_frequency += EDGE_FREQUENCY (e);\n+\t    has_fallthru = 1, fallthru_count += e->count ();\n \t  else\n-\t    branch_frequency += EDGE_FREQUENCY (e);\n+\t    branch_count += e->count ();\n \t}\n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \"BB %4i freq %4i loop %2i loop_depth\"\n-\t\t   \" %2i fall %4i branch %4i\",\n-\t\t   bb->index, bb->count.to_frequency (cfun), bb->loop_father->num,\n-\t\t   bb_loop_depth (bb),\n-\t\t   fallthru_frequency, branch_frequency);\n+\t  fprintf (dump_file, \"BB %4i loop %2i loop_depth\"\n+\t\t   \" %2i fall \",\n+\t\t   bb->index, bb->loop_father->num,\n+\t\t   bb_loop_depth (bb));\n+\t  fallthru_count.dump (dump_file);\n+\t  fprintf (dump_file, \" branch \");\n+\t  branch_count.dump (dump_file);\n \t  if (!bb->loop_father->inner && bb->loop_father->num)\n \t    fprintf (dump_file, \" inner_loop\");\n \t  if (bb->loop_father->header == bb)\n \t    fprintf (dump_file, \" loop_header\");\n \t  fprintf (dump_file, \"\\n\");\n \t}\n+      if (!fallthru_count.initialized_p () || !branch_count.initialized_p ())\n+\tcontinue;\n \n       /* There are two purposes to align block with no fallthru incoming edge:\n \t 1) to avoid fetch stalls when branch destination is near cache boundary\n@@ -753,11 +758,11 @@ compute_alignments (void)\n \t when function is called.  */\n \n       if (!has_fallthru\n-\t  && (branch_frequency > freq_threshold\n-\t      || (bb->count.to_frequency (cfun) \n-\t\t\t> bb->prev_bb->count.to_frequency (cfun) * 10\n-\t\t  && (bb->prev_bb->count.to_frequency (cfun)\n-\t\t      <= ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun) / 2))))\n+\t  && (branch_count > count_threshold\n+\t      || (bb->count > bb->prev_bb->count.apply_scale (10, 1)\n+\t\t  && (bb->prev_bb->count \n+\t\t      <= ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t\t\t   ->count.apply_scale (1, 2)))))\n \t{\n \t  log = JUMP_ALIGN (label);\n \t  if (dump_file)\n@@ -774,9 +779,10 @@ compute_alignments (void)\n \t  && !(single_succ_p (bb)\n \t       && single_succ (bb) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  && optimize_bb_for_speed_p (bb)\n-\t  && branch_frequency + fallthru_frequency > freq_threshold\n-\t  && (branch_frequency\n-\t      > fallthru_frequency * PARAM_VALUE (PARAM_ALIGN_LOOP_ITERATIONS)))\n+\t  && branch_count + fallthru_count > count_threshold\n+\t  && (branch_count\n+\t      > fallthru_count.apply_scale\n+\t\t    (PARAM_VALUE (PARAM_ALIGN_LOOP_ITERATIONS), 1)))\n \t{\n \t  log = LOOP_ALIGN (label);\n \t  if (dump_file)"}]}