{"sha": "257eb6e3ef00aa111907c4b9411aaa81cdc80396", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU3ZWI2ZTNlZjAwYWExMTE5MDdjNGI5NDExYWFhODFjZGM4MDM5Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-03-28T12:04:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-03-28T12:04:38Z"}, "message": "cgraph.c (dump_cgraph_node): Add replace output flag by process.\n\n\t* cgraph.c (dump_cgraph_node): Add replace output flag by process.\n\t* cgraph.h (cgraph_node): Likewise.\n\t* cgraphunit.c (cgraph_process_new_functions): Set process flag.\n\t(cgraph_reset_node): Use process flag.\n\t(cgraph_mark_functions_to_output): Likewise.\n\t(cgraph_expand_function): Likewise.\n\t(cgraph_expand_all_functions): Likewise.\n\t(cgraph_output_in_order): Likewise.\n\t* dwarf2out.c (reference_to_unused): Likewise.\n\t* passes.c do_per_function_toporder): Likewise.\n\nFrom-SVN: r145178", "tree": {"sha": "69b155323bbc7a05d3f5fd2ca7a7962ead5a3ce3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69b155323bbc7a05d3f5fd2ca7a7962ead5a3ce3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/257eb6e3ef00aa111907c4b9411aaa81cdc80396", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/257eb6e3ef00aa111907c4b9411aaa81cdc80396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/257eb6e3ef00aa111907c4b9411aaa81cdc80396", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/257eb6e3ef00aa111907c4b9411aaa81cdc80396/comments", "author": null, "committer": null, "parents": [{"sha": "b7551676632af6f5641aaeb500acc566c4e20922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7551676632af6f5641aaeb500acc566c4e20922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7551676632af6f5641aaeb500acc566c4e20922"}], "stats": {"total": 47, "additions": 32, "deletions": 15}, "files": [{"sha": "f6adff60e5c93dc2a4ce8153c14f30a7e86f41c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=257eb6e3ef00aa111907c4b9411aaa81cdc80396", "patch": "@@ -1,3 +1,16 @@\n+2009-03-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (dump_cgraph_node): Add replace output flag by process.\n+\t* cgraph.h (cgraph_node): Likewise.\n+\t* cgraphunit.c (cgraph_process_new_functions): Set process flag.\n+\t(cgraph_reset_node): Use process flag.\n+\t(cgraph_mark_functions_to_output): Likewise.\n+\t(cgraph_expand_function): Likewise.\n+\t(cgraph_expand_all_functions): Likewise.\n+\t(cgraph_output_in_order): Likewise.\n+\t* dwarf2out.c (reference_to_unused): Likewise.\n+\t* passes.c do_per_function_toporder): Likewise.\n+\n 2009-03-28  Jan Hubicka  <jh@suse.cz>\n \n \tBring from lto-branch:"}, {"sha": "8eb0381d2bea1600d502626f1cf8028850d18b64", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=257eb6e3ef00aa111907c4b9411aaa81cdc80396", "patch": "@@ -1168,8 +1168,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" reachable\");\n   if (gimple_has_body_p (node->decl))\n     fprintf (f, \" body\");\n-  if (node->output)\n-    fprintf (f, \" output\");\n+  if (node->process)\n+    fprintf (f, \" process\");\n   if (node->local.local)\n     fprintf (f, \" local\");\n   if (node->local.externally_visible)"}, {"sha": "0e01a659419adc6dea22a4c308ece7ea8042d315", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=257eb6e3ef00aa111907c4b9411aaa81cdc80396", "patch": "@@ -178,8 +178,8 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   /* Set once the function has been instantiated and its callee\n      lists created.  */\n   unsigned analyzed : 1;\n-  /* Set when function is scheduled to be assembled.  */\n-  unsigned output : 1;\n+  /* Set when function is scheduled to be processed by local passes.  */\n+  unsigned process : 1;\n   /* Set for aliases once they got through assemble_alias.  */\n   unsigned alias : 1;\n "}, {"sha": "9f6a50ddcbea5b519deb5915b955d237c00388cf", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=257eb6e3ef00aa111907c4b9411aaa81cdc80396", "patch": "@@ -426,7 +426,7 @@ cgraph_process_new_functions (void)\n \tcase CGRAPH_STATE_EXPANSION:\n \t  /* Functions created during expansion shall be compiled\n \t     directly.  */\n-\t  node->output = 0;\n+\t  node->process = 0;\n \t  cgraph_expand_function (node);\n \t  break;\n \n@@ -452,12 +452,12 @@ cgraph_process_new_functions (void)\n static void\n cgraph_reset_node (struct cgraph_node *node)\n {\n-  /* If node->output is set, then we have already begun whole-unit analysis.\n+  /* If node->process is set, then we have already begun whole-unit analysis.\n      This is *not* testing for whether we've already emitted the function.\n      That case can be sort-of legitimately seen with real function redefinition\n      errors.  I would argue that the front end should never present us with\n      such a case, but don't enforce that for now.  */\n-  gcc_assert (!node->output);\n+  gcc_assert (!node->process);\n \n   /* Reset our data structures so we can analyze the function again.  */\n   memset (&node->local, 0, sizeof (node->local));\n@@ -990,7 +990,7 @@ cgraph_mark_functions_to_output (void)\n       tree decl = node->decl;\n       struct cgraph_edge *e;\n \n-      gcc_assert (!node->output);\n+      gcc_assert (!node->process);\n \n       for (e = node->callers; e; e = e->next_caller)\n \tif (e->inline_failed)\n@@ -1005,7 +1005,7 @@ cgraph_mark_functions_to_output (void)\n \t      || (e && node->reachable))\n \t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n-\tnode->output = 1;\n+\tnode->process = 1;\n       else\n \t{\n \t  /* We should've reclaimed all functions that are not needed.  */\n@@ -1038,6 +1038,7 @@ cgraph_expand_function (struct cgraph_node *node)\n   gcc_assert (!node->global.inlined_to);\n \n   announce_function (decl);\n+  node->process = 0;\n \n   gcc_assert (node->lowered);\n \n@@ -1093,16 +1094,16 @@ cgraph_expand_all_functions (void)\n   /* Garbage collector may remove inline clones we eliminate during\n      optimization.  So we must be sure to not reference them.  */\n   for (i = 0; i < order_pos; i++)\n-    if (order[i]->output)\n+    if (order[i]->process)\n       order[new_order_pos++] = order[i];\n \n   for (i = new_order_pos - 1; i >= 0; i--)\n     {\n       node = order[i];\n-      if (node->output)\n+      if (node->process)\n \t{\n \t  gcc_assert (node->reachable);\n-\t  node->output = 0;\n+\t  node->process = 0;\n \t  cgraph_expand_function (node);\n \t}\n     }\n@@ -1151,7 +1152,7 @@ cgraph_output_in_order (void)\n \n   for (pf = cgraph_nodes; pf; pf = pf->next)\n     {\n-      if (pf->output)\n+      if (pf->process)\n \t{\n \t  i = pf->order;\n \t  gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n@@ -1191,7 +1192,7 @@ cgraph_output_in_order (void)\n       switch (nodes[i].kind)\n \t{\n \tcase ORDER_FUNCTION:\n-\t  nodes[i].u.f->output = 0;\n+\t  nodes[i].u.f->process = 0;\n \t  cgraph_expand_function (nodes[i].u.f);\n \t  break;\n "}, {"sha": "9bab2a42934d1283461933eb627a212019ada2d2", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=257eb6e3ef00aa111907c4b9411aaa81cdc80396", "patch": "@@ -11319,7 +11319,7 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n \t   && (!DECL_EXTERNAL (*tp) || DECL_DECLARED_INLINE_P (*tp)))\n     {\n       struct cgraph_node *node = cgraph_node (*tp);\n-      if (!node->output)\n+      if (node->process || TREE_ASM_WRITTEN (*tp))\n \treturn *tp;\n     }\n   else if (TREE_CODE (*tp) == STRING_CST && !TREE_ASM_WRITTEN (*tp))"}, {"sha": "b77b518ccf8f22222734981770de3a93b7ad264f", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/257eb6e3ef00aa111907c4b9411aaa81cdc80396/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=257eb6e3ef00aa111907c4b9411aaa81cdc80396", "patch": "@@ -877,12 +877,15 @@ do_per_function_toporder (void (*callback) (void *data), void *data)\n       gcc_assert (!order);\n       order = GGC_NEWVEC (struct cgraph_node *, cgraph_n_nodes);\n       nnodes = cgraph_postorder (order);\n+      for (i = nnodes - 1; i >= 0; i--)\n+        order[i]->process = 1;\n       for (i = nnodes - 1; i >= 0; i--)\n \t{\n \t  struct cgraph_node *node = order[i];\n \n \t  /* Allow possibly removed nodes to be garbage collected.  */\n \t  order[i] = NULL;\n+\t  node->process = 0;\n \t  if (node->analyzed && (node->needed || node->reachable))\n \t    {\n \t      push_cfun (DECL_STRUCT_FUNCTION (node->decl));"}]}