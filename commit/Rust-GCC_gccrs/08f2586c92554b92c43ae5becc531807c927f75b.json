{"sha": "08f2586c92554b92c43ae5becc531807c927f75b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhmMjU4NmM5MjU1NGI5MmM0M2FlNWJlY2M1MzE4MDdjOTI3Zjc1Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-12-09T10:54:50Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-12-09T10:54:50Z"}, "message": "tree.def (SET_TYPE): Remove.\n\n\t* tree.def (SET_TYPE): Remove.\n\t(CONSTRUCTOR): Update description.\n\t* builtins.c (type_to_class) Remove SET_TYPE case.\n\t* dbxout.c (dbxout_type): Likewise.\n\t* dwarf2out.c (is_base_type): Likewise.\n\t(gen_set_type_die): Remove.\n\t(gen_type_die): Remove SET_TYPE case.\n\t* expr.c (count_type_elements): Likewise.\n\t(mostly_zeroes_p): Likewise.\n\t(store_constructor): Likewise.\n\t* print_tree.c (print_node): Likewise.\n\t* stor-layout.c (layout_type): Likewise.\n\t* tree-browser.c (browse_tree): Likewise.\n\t* tree-inline.c (remap_type): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree.c (type_contains_plaeholder_1, type_hash_eq,\n\tvariably_modified_type_p, initializer_zerop): Likewise.\n\t* tree.h (SET_OR_ARRAY_CHECK): Remove.\n\t(AGGREGATE_TYPE_P): Remove SET_TYPE check.\n\t(TYPE_DOMAIN): Use ARRAY_TYPE_CHECK.\n\t* typeclass.h (enum type_class): Remove set_type_class.\n\t* varasm.c (const_hash_1): Remove SET_TYPE case.\n\t(compare_constant, copy_constant, output_constant): Likewise.\n\t* config/i386/i386.c (classify_argument): Likewise.\n\t* config/ia64/ia64.c (hfa_element_mode): Likewise.\n\t* config/sparc/sparc.c (sparc_type_code): Likewise.\n\n\t* ada/decl.c (gnat_substitute_in_type): Remove SET_TYPE case.\n\nFrom-SVN: r91931", "tree": {"sha": "0ebc77b705976f6aa26d0801d2f77bd111850b5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ebc77b705976f6aa26d0801d2f77bd111850b5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08f2586c92554b92c43ae5becc531807c927f75b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08f2586c92554b92c43ae5becc531807c927f75b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08f2586c92554b92c43ae5becc531807c927f75b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08f2586c92554b92c43ae5becc531807c927f75b/comments", "author": null, "committer": null, "parents": [{"sha": "61fcaeec1e95fdaf23a7c41222f895dafe84af7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61fcaeec1e95fdaf23a7c41222f895dafe84af7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61fcaeec1e95fdaf23a7c41222f895dafe84af7f"}], "stats": {"total": 516, "additions": 95, "deletions": 421}, "files": [{"sha": "e2348975fe8420a2668372e794e08f077b10f89e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -1,5 +1,32 @@\n 2004-12-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* tree.def (SET_TYPE): Remove.\n+\t(CONSTRUCTOR): Update description.\n+\t* builtins.c (type_to_class) Remove SET_TYPE case.\n+\t* dbxout.c (dbxout_type): Likewise.\n+\t* dwarf2out.c (is_base_type): Likewise.\n+\t(gen_set_type_die): Remove.\n+\t(gen_type_die): Remove SET_TYPE case.\n+\t* expr.c (count_type_elements): Likewise.\n+\t(mostly_zeroes_p): Likewise.\n+\t(store_constructor): Likewise.\n+\t* print_tree.c (print_node): Likewise.\n+\t* stor-layout.c (layout_type): Likewise.\n+\t* tree-browser.c (browse_tree): Likewise.\n+\t* tree-inline.c (remap_type): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree.c (type_contains_plaeholder_1, type_hash_eq,\n+\tvariably_modified_type_p, initializer_zerop): Likewise.\n+\t* tree.h (SET_OR_ARRAY_CHECK): Remove.\n+\t(AGGREGATE_TYPE_P): Remove SET_TYPE check.\n+\t(TYPE_DOMAIN): Use ARRAY_TYPE_CHECK.\n+\t* typeclass.h (enum type_class): Remove set_type_class.\n+\t* varasm.c (const_hash_1): Remove SET_TYPE case.\n+\t(compare_constant, copy_constant, output_constant): Likewise.\n+\t* config/i386/i386.c (classify_argument): Likewise.\n+\t* config/ia64/ia64.c (hfa_element_mode): Likewise.\n+\t* config/sparc/sparc.c (sparc_type_code): Likewise.\n+\n \tPR c++/16681\n \t* tree-inline.c (estimate_num_insns_1): Add RANGE_EXPR case.\n "}, {"sha": "44e0cb7209ff31d1e8c89574b795ee701f728c6f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -1,3 +1,7 @@\n+2004-12-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* decl.c (gnat_substitute_in_type): Remove SET_TYPE case.\n+\n 2004-12-07  Ed Falis  <falis@adacore.com>\n \n \t* s-intman-vxworks.adb (Notify_Exception): removed useless check for"}, {"sha": "d11b11af8e4f921cb3d78a8f675cf356f0371c59", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -6276,7 +6276,6 @@ gnat_substitute_in_type (tree t, tree f, tree r)\n     case OFFSET_TYPE:\n     case METHOD_TYPE:\n     case FILE_TYPE:\n-    case SET_TYPE:\n     case FUNCTION_TYPE:\n     case LANG_TYPE:\n       /* Don't know how to do these yet.  */"}, {"sha": "dfad35ca3e2683e74f25bc9ad9863982e3325337", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -1475,7 +1475,6 @@ type_to_class (tree type)\n     case QUAL_UNION_TYPE:  return union_type_class;\n     case ARRAY_TYPE:\t   return (TYPE_STRING_FLAG (type)\n \t\t\t\t   ? string_type_class : array_type_class);\n-    case SET_TYPE:\t   return set_type_class;\n     case FILE_TYPE:\t   return file_type_class;\n     case LANG_TYPE:\t   return lang_type_class;\n     default:\t\t   return no_type_class;"}, {"sha": "31be4d163b998973e707dcae56cd55802c608338", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -2255,31 +2255,6 @@ classify_argument (enum machine_mode mode, tree type,\n \t\t}\n \t    }\n \t}\n-      else if (TREE_CODE (type) == SET_TYPE)\n-\t{\n-\t  if (bytes <= 4)\n-\t    {\n-\t      classes[0] = X86_64_INTEGERSI_CLASS;\n-\t      return 1;\n-\t    }\n-\t  else if (bytes <= 8)\n-\t    {\n-\t      classes[0] = X86_64_INTEGER_CLASS;\n-\t      return 1;\n-\t    }\n-\t  else if (bytes <= 12)\n-\t    {\n-\t      classes[0] = X86_64_INTEGER_CLASS;\n-\t      classes[1] = X86_64_INTEGERSI_CLASS;\n-\t      return 2;\n-\t    }\n-\t  else\n-\t    {\n-\t      classes[0] = X86_64_INTEGER_CLASS;\n-\t      classes[1] = X86_64_INTEGER_CLASS;\n-\t      return 2;\n-\t    }\n-\t}\n       else\n \tabort ();\n "}, {"sha": "64a4e54a56ca207a2192e978bf38dcbf2a7de6a3", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -2975,8 +2975,7 @@ hfa_element_mode (tree type, int nested)\n     case VOID_TYPE:\tcase INTEGER_TYPE:\tcase ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\tcase CHAR_TYPE:\t\tcase POINTER_TYPE:\n     case OFFSET_TYPE:\tcase REFERENCE_TYPE:\tcase METHOD_TYPE:\n-    case FILE_TYPE:\tcase SET_TYPE:\t\tcase LANG_TYPE:\n-    case FUNCTION_TYPE:\n+    case FILE_TYPE:\tcase LANG_TYPE:\t\tcase FUNCTION_TYPE:\n       return VOIDmode;\n \n       /* Fortran complex types are supposed to be HFAs, so we need to handle"}, {"sha": "0eff775bbb21c26f840e5f0ca0a0538f7bf9a672", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -7709,7 +7709,6 @@ sparc_type_code (register tree type)\n \tcase CHAR_TYPE:\t\t/* GNU Pascal CHAR type.  Not used in C.  */\n \tcase BOOLEAN_TYPE:\t/* GNU Fortran BOOLEAN type.  */\n \tcase FILE_TYPE:\t\t/* GNU Pascal FILE type.  */\n-\tcase SET_TYPE:\t\t/* GNU Pascal SET type.  */\n \tcase LANG_TYPE:\t\t/* ? */\n \t  return qualifiers;\n   "}, {"sha": "8c2d6eac5e46a53ac11c0e64e458ffdc67cc6601", "filename": "gcc/dbxout.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -1967,23 +1967,6 @@ dbxout_type (tree type, int full)\n \t}\n       break;\n \n-    case SET_TYPE:\n-      if (use_gnu_debug_info_extensions)\n-\t{\n-\t  have_used_extensions = 1;\n-\t  stabstr_S (\"@s\");\n-\t  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  stabstr_C (';');\n-\n-\t  /* Check if a bitstring type, which in Chill is\n-\t     different from a [power]set.  */\n-\t  if (TYPE_STRING_FLAG (type))\n-\t    stabstr_S (\"@S;\");\n-\t}\n-      stabstr_C ('S');\n-      dbxout_type (TYPE_DOMAIN (type), 0);\n-      break;\n-\n     case ARRAY_TYPE:\n       /* Make arrays of packed bits look like bitstrings for chill.  */\n       if (TYPE_PACKED (type) && use_gnu_debug_info_extensions)"}, {"sha": "74303c2dff070a2cc71de36459a22f6cf7d6f254", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -3963,7 +3963,6 @@ static tree member_declared_type (tree);\n static const char *decl_start_label (tree);\n #endif\n static void gen_array_type_die (tree, dw_die_ref);\n-static void gen_set_type_die (tree, dw_die_ref);\n #if 0\n static void gen_entry_point_die (tree, dw_die_ref);\n #endif\n@@ -8031,7 +8030,6 @@ is_base_type (tree type)\n     case CHAR_TYPE:\n       return 1;\n \n-    case SET_TYPE:\n     case ARRAY_TYPE:\n     case RECORD_TYPE:\n     case UNION_TYPE:\n@@ -10813,16 +10811,6 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n   add_type_attribute (array_die, element_type, 0, 0, context_die);\n }\n \n-static void\n-gen_set_type_die (tree type, dw_die_ref context_die)\n-{\n-  dw_die_ref type_die\n-    = new_die (DW_TAG_set_type, scope_die_for (type, context_die), type);\n-\n-  equate_type_number_to_die (type, type_die);\n-  add_type_attribute (type_die, TREE_TYPE (type), 0, 0, context_die);\n-}\n-\n #if 0\n static void\n gen_entry_point_die (tree decl, dw_die_ref context_die)\n@@ -12091,11 +12079,6 @@ gen_type_die (tree type, dw_die_ref context_die)\n       gen_ptr_to_mbr_type_die (type, context_die);\n       break;\n \n-    case SET_TYPE:\n-      gen_type_die (TYPE_DOMAIN (type), context_die);\n-      gen_set_type_die (type, context_die);\n-      break;\n-\n     case FILE_TYPE:\n       gen_type_die (TREE_TYPE (type), context_die);\n       /* No way to represent these in Dwarf yet!  */"}, {"sha": "1f4d140332f7ba7223d92fe0f5ad39fe70e739f3", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 183, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -4371,7 +4371,6 @@ count_type_elements (tree type)\n     case VOID_TYPE:\n     case METHOD_TYPE:\n     case FILE_TYPE:\n-    case SET_TYPE:\n     case FUNCTION_TYPE:\n     case LANG_TYPE:\n     default:\n@@ -4389,10 +4388,6 @@ mostly_zeros_p (tree exp)\n     {\n       HOST_WIDE_INT nz_elts, nc_elts, elts;\n \n-      /* If there are no ranges of true bits, it is all zero.  */\n-      if (TREE_TYPE (exp) && TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n-\treturn CONSTRUCTOR_ELTS (exp) == NULL_TREE;\n-\n       categorize_ctor_elements (exp, &nz_elts, &nc_elts);\n       elts = count_type_elements (TREE_TYPE (exp));\n \n@@ -5011,184 +5006,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t\tgen_rtvec_v (n_elts, vector))));\n \tbreak;\n       }\n-\n-      /* Set constructor assignments.  */\n-    case SET_TYPE:\n-      {\n-\ttree elt = CONSTRUCTOR_ELTS (exp);\n-\tunsigned HOST_WIDE_INT nbytes = int_size_in_bytes (type), nbits;\n-\ttree domain = TYPE_DOMAIN (type);\n-\ttree domain_min, domain_max, bitlength;\n-\t\n-\t/* The default implementation strategy is to extract the\n-\t   constant parts of the constructor, use that to initialize\n-\t   the target, and then \"or\" in whatever non-constant ranges\n-\t   we need in addition.\n-\n-\t   If a large set is all zero or all ones, it is probably\n-\t   better to set it using memset.  Also, if a large set has\n-\t   just a single range, it may also be better to first clear\n-\t   all the first clear the set (using memset), and set the\n-\t   bits we want.  */\n-\n-\t/* Check for all zeros.  */\n-\tif (elt == NULL_TREE && size > 0)\n-\t  {\n-\t    if (!cleared)\n-\t      clear_storage (target, GEN_INT (size));\n-\t    return;\n-\t  }\n-\t\n-\tdomain_min = convert (sizetype, TYPE_MIN_VALUE (domain));\n-\tdomain_max = convert (sizetype, TYPE_MAX_VALUE (domain));\n-\tbitlength = size_binop (PLUS_EXPR,\n-\t\t\t\tsize_diffop (domain_max, domain_min),\n-\t\t\t\tssize_int (1));\n-\t\n-\tnbits = tree_low_cst (bitlength, 1);\n-\n-        /* For \"small\" sets, or \"medium-sized\" (up to 32 bytes) sets\n-\t   that are \"complicated\" (more than one range), initialize\n-\t   (the constant parts) by copying from a constant.  */\n-\tif (GET_MODE (target) != BLKmode || nbits <= 2 * BITS_PER_WORD\n-\t    || (nbytes <= 32 && TREE_CHAIN (elt) != NULL_TREE))\n-\t  {\n-\t    unsigned int set_word_size = TYPE_ALIGN (TREE_TYPE (exp));\n-\t    enum machine_mode mode = mode_for_size (set_word_size, MODE_INT, 1);\n-\t    char *bit_buffer = alloca (nbits);\n-\t    HOST_WIDE_INT word = 0;\n-\t    unsigned int bit_pos = 0;\n-\t    unsigned int ibit = 0;\n-\t    unsigned int offset = 0;  /* In bytes from beginning of set.  */\n-\t    \n-\t    elt = get_set_constructor_bits (exp, bit_buffer, nbits);\n-\t    for (;;)\n-\t      {\n-\t\tif (bit_buffer[ibit])\n-\t\t  {\n-\t\t    if (BYTES_BIG_ENDIAN)\n-\t\t      word |= (1 << (set_word_size - 1 - bit_pos));\n-\t\t    else\n-\t\t      word |= 1 << bit_pos;\n-\t\t  }\n-\t\t\n-\t\tbit_pos++;  ibit++;\n-\t\tif (bit_pos >= set_word_size || ibit == nbits)\n-\t\t  {\n-\t\t    if (word != 0 || ! cleared)\n-\t\t      {\n-\t\t\trtx datum = gen_int_mode (word, mode);\n-\t\t\trtx to_rtx;\n-\t\t\t\n-\t\t\t/* The assumption here is that it is safe to\n-\t\t\t   use XEXP if the set is multi-word, but not\n-\t\t\t   if it's single-word.  */\n-\t\t\tif (MEM_P (target))\n-\t\t\t  to_rtx = adjust_address (target, mode, offset);\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    gcc_assert (!offset);\n-\t\t\t    to_rtx = target;\n-\t\t\t  }\n-\t\t\temit_move_insn (to_rtx, datum);\n-\t\t      }\n-\t\t    \n-\t\t    if (ibit == nbits)\n-\t\t      break;\n-\t\t    word = 0;\n-\t\t    bit_pos = 0;\n-\t\t    offset += set_word_size / BITS_PER_UNIT;\n-\t\t  }\n-\t      }\n-\t  }\n-\telse if (!cleared)\n-\t  /* Don't bother clearing storage if the set is all ones.  */\n-\t  if (TREE_CHAIN (elt) != NULL_TREE\n-\t      || (TREE_PURPOSE (elt) == NULL_TREE\n-\t\t  ? nbits != 1\n-\t\t  : ( ! host_integerp (TREE_VALUE (elt), 0)\n-\t\t      || ! host_integerp (TREE_PURPOSE (elt), 0)\n-\t\t      || (tree_low_cst (TREE_VALUE (elt), 0)\n-\t\t\t  - tree_low_cst (TREE_PURPOSE (elt), 0) + 1\n-\t\t\t  != (HOST_WIDE_INT) nbits))))\n-\t    clear_storage (target, expr_size (exp));\n-\t\n-\tfor (; elt != NULL_TREE; elt = TREE_CHAIN (elt))\n-\t  {\n-\t    /* Start of range of element or NULL.  */\n-\t    tree startbit = TREE_PURPOSE (elt);\n- \t    /* End of range of element, or element value.  */\n-\t    tree endbit   = TREE_VALUE (elt);\n-\t    HOST_WIDE_INT startb, endb;\n-\t    rtx bitlength_rtx, startbit_rtx, endbit_rtx, targetx;\n-\t    \n-\t    bitlength_rtx = expand_expr (bitlength,\n-\t\t\t\t\t NULL_RTX, MEM, EXPAND_CONST_ADDRESS);\n-\t    \n-\t    /* Handle non-range tuple element like [ expr ].  */\n-\t    if (startbit == NULL_TREE)\n-\t      {\n-\t\tstartbit = save_expr (endbit);\n-\t\tendbit = startbit;\n-\t      }\n-\t    \n-\t    startbit = convert (sizetype, startbit);\n-\t    endbit = convert (sizetype, endbit);\n-\t    if (! integer_zerop (domain_min))\n-\t      {\n-\t\tstartbit = size_binop (MINUS_EXPR, startbit, domain_min);\n-\t\tendbit = size_binop (MINUS_EXPR, endbit, domain_min);\n-\t      }\n-\t    startbit_rtx = expand_expr (startbit, NULL_RTX, MEM,\n-\t\t\t\t\tEXPAND_CONST_ADDRESS);\n-\t    endbit_rtx = expand_expr (endbit, NULL_RTX, MEM,\n-\t\t\t\t      EXPAND_CONST_ADDRESS);\n-\t    \n-\t    if (REG_P (target))\n-\t      {\n-\t\ttargetx\n-\t\t  = assign_temp\n-\t\t  ((build_qualified_type (lang_hooks.types.type_for_mode\n-\t\t\t\t\t  (GET_MODE (target), 0),\n-\t\t\t\t\t  TYPE_QUAL_CONST)),\n-\t\t   0, 1, 1);\n-\t\temit_move_insn (targetx, target);\n-\t      }\n-\t    \n-\t    else\n-\t      {\n-\t\tgcc_assert (MEM_P (target));\n-\t\ttargetx = target;\n-\t      }\n-\n-\t    /* Optimization:  If startbit and endbit are constants divisible\n-\t       by BITS_PER_UNIT, call memset instead.  */\n-\t    if (TREE_CODE (startbit) == INTEGER_CST\n-\t\t&& TREE_CODE (endbit) == INTEGER_CST\n-\t\t&& (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0\n-\t\t&& (endb = TREE_INT_CST_LOW (endbit) + 1) % BITS_PER_UNIT == 0)\n-\t      {\n-\t\temit_library_call (memset_libfunc, LCT_NORMAL,\n-\t\t\t\t   VOIDmode, 3,\n-\t\t\t\t   plus_constant (XEXP (targetx, 0),\n-\t\t\t\t\t\t  startb / BITS_PER_UNIT),\n-\t\t\t\t   Pmode,\n-\t\t\t\t   constm1_rtx, TYPE_MODE (integer_type_node),\n-\t\t\t\t   GEN_INT ((endb - startb) / BITS_PER_UNIT),\n-\t\t\t\t   TYPE_MODE (sizetype));\n-\t      }\n-\t    else\n-\t      emit_library_call (setbits_libfunc, LCT_NORMAL,\n-\t\t\t\t VOIDmode, 4, XEXP (targetx, 0),\n-\t\t\t\t Pmode, bitlength_rtx, TYPE_MODE (sizetype),\n-\t\t\t\t startbit_rtx, TYPE_MODE (sizetype),\n-\t\t\t\t endbit_rtx, TYPE_MODE (sizetype));\n-\t    \n-\t    if (REG_P (target))\n-\t      emit_move_insn (target, targetx);\n-\t  }\n-\tbreak;\n-      }\n+      \n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "8d8cbffc389c0c96f68085cc3eb28545dcaa929d", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -537,7 +537,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \n       if (TREE_CODE (node) == ENUMERAL_TYPE)\n \tprint_node (file, \"values\", TYPE_VALUES (node), indent + 4);\n-      else if (TREE_CODE (node) == ARRAY_TYPE || TREE_CODE (node) == SET_TYPE)\n+      else if (TREE_CODE (node) == ARRAY_TYPE)\n \tprint_node (file, \"domain\", TYPE_DOMAIN (node), indent + 4);\n       else if (TREE_CODE (node) == VECTOR_TYPE)\n \tfprintf (file, \" nunits %d\", (int) TYPE_VECTOR_SUBPARTS (node));"}, {"sha": "ac7fb744f66b365b846e3418c970e94bff5ad680", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -1763,40 +1763,6 @@ layout_type (tree type)\n       }\n       break;\n \n-    case SET_TYPE:  /* Used by Chill and Pascal.  */\n-      {\n-\tunsigned int alignment;\n-\tHOST_WIDE_INT size_in_bits;\n-\tHOST_WIDE_INT rounded_size;\n-\n-\tgcc_assert (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n-\t\t    == INTEGER_CST);\n-\tgcc_assert (TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type)))\n-\t\t    == INTEGER_CST);\n-\n-#ifndef SET_WORD_SIZE\n-#define SET_WORD_SIZE BITS_PER_WORD\n-#endif\n-\talignment = set_alignment ? set_alignment : SET_WORD_SIZE;\n-\tsize_in_bits\n-\t  = (tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), 0)\n-\t     - tree_low_cst (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), 0) + 1);\n-\trounded_size\n-\t  = ((size_in_bits + alignment - 1) / alignment) * alignment;\n-\n-\tif (rounded_size > (int) alignment)\n-\t  TYPE_MODE (type) = BLKmode;\n-\telse\n-\t  TYPE_MODE (type) = mode_for_size (alignment, MODE_INT, 1);\n-\n-\tTYPE_SIZE (type) = bitsize_int (rounded_size);\n-\tTYPE_SIZE_UNIT (type) = size_int (rounded_size / BITS_PER_UNIT);\n-\tTYPE_ALIGN (type) = alignment;\n-\tTYPE_USER_ALIGN (type) = 0;\n-\tTYPE_PRECISION (type) = size_in_bits;\n-      }\n-      break;\n-\n     case FILE_TYPE:\n       /* The size may vary in different languages, so the language front end\n \t should fill in the size.  */"}, {"sha": "ccbccde2696f4d72cd8c752985bc2f346ac6e9c3", "filename": "gcc/tree-browser.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -309,8 +309,7 @@ browse_tree (tree begin)\n \t  break;\n \n \tcase TB_DOMAIN:\n-\t  if (head && (TREE_CODE (head) == ARRAY_TYPE\n-\t\t       || TREE_CODE (head) == SET_TYPE))\n+\t  if (head && TREE_CODE (head) == ARRAY_TYPE)\n \t    TB_SET_HEAD (TYPE_DOMAIN (head));\n \t  else\n \t    TB_WF;"}, {"sha": "29740df72b07c929c1d5928936038aa0a472cc4e", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -323,7 +323,6 @@ remap_type (tree type, inline_data *id)\n       break;\n \n     case FILE_TYPE:\n-    case SET_TYPE:\n     case OFFSET_TYPE:\n     default:\n       /* Shouldn't have been thought variable sized.  */"}, {"sha": "6c1eed84dcc8af41c19c642aa4f337776c63834d", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -461,10 +461,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \tbreak;\n       }\n \n-    case SET_TYPE:\n-      NIY;\n-      break;\n-\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:"}, {"sha": "c2fb1b448505b2661b0808c16e10806673abc5f4", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -1888,7 +1888,6 @@ type_contains_placeholder_1 (tree type)\n \t      || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (type)));\n \n     case ARRAY_TYPE:\n-    case SET_TYPE:\n     case VECTOR_TYPE:\n       /* We're already checked the component type (TREE_TYPE), so just check\n \t the index type.  */\n@@ -3475,7 +3474,6 @@ type_hash_eq (const void *va, const void *vb)\n \t\t\t\t\t  TYPE_ARG_TYPES (b->type)))));\n \n     case ARRAY_TYPE:\n-    case SET_TYPE:\n       return TYPE_DOMAIN (a->type) == TYPE_DOMAIN (b->type);\n \n     case RECORD_TYPE:\n@@ -4984,7 +4982,6 @@ variably_modified_type_p (tree type, tree fn)\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n     case ARRAY_TYPE:\n-    case SET_TYPE:\n     case VECTOR_TYPE:\n       if (variably_modified_type_p (TREE_TYPE (type), fn))\n \treturn true;\n@@ -5871,10 +5868,6 @@ initializer_zerop (tree init)\n       if (elt == NULL_TREE)\n \treturn true;\n \n-      /* A set is empty only if it has no elements.  */\n-      if (TREE_CODE (TREE_TYPE (init)) == SET_TYPE)\n-\treturn false;\n-\n       for (; elt ; elt = TREE_CHAIN (elt))\n \tif (! initializer_zerop (TREE_VALUE (elt)))\n \t  return false;"}, {"sha": "b09f066213765f58b0f3ba12c65293d64274c818", "filename": "gcc/tree.def", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -200,12 +200,6 @@ DEFTREECODE (FILE_TYPE, \"file_type\", tcc_type, 0)\n /* Array types in C or Pascal */\n DEFTREECODE (ARRAY_TYPE, \"array_type\", tcc_type, 0)\n \n-/* Types of sets for Pascal.  Special fields are the same as\n-   in an array type.  The target type is always a boolean type.\n-   Used for both bitstrings and powersets in Chill;\n-   TYPE_STRING_FLAG indicates a bitstring.  */\n-DEFTREECODE (SET_TYPE, \"set_type\", tcc_type, 0)\n-\n /* Struct in C, or record in Pascal.  */\n /* Special fields:\n    TYPE_FIELDS  chain of FIELD_DECLs for the fields of the struct,\n@@ -409,7 +403,6 @@ DEFTREECODE (FILTER_EXPR, \"filter_expr\", tcc_expression, 0)\n \n /* Constructor: return an aggregate value made from specified components.\n    In C, this is used only for structure and array initializers.\n-   Also used for SET_TYPE in Chill (and potentially Pascal).\n    The operand is a list of component values made out of a chain of\n    TREE_LIST nodes.\n \n@@ -421,12 +414,7 @@ DEFTREECODE (FILTER_EXPR, \"filter_expr\", tcc_expression, 0)\n    value in a SAVE_EXPR if you want to evaluate side effects only once.)\n \n    For RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE:\n-   The TREE_PURPOSE of each node is a FIELD_DECL.\n-\n-   For SET_TYPE:\n-   The TREE_VALUE specifies a value (index) in the set that is true.\n-   If TREE_PURPOSE is non-NULL, it specifies the lower limit of a\n-   range of true values.  Elements not listed are false (not in the set).  */\n+   The TREE_PURPOSE of each node is a FIELD_DECL.  */\n DEFTREECODE (CONSTRUCTOR, \"constructor\", tcc_expression, 1)\n \n /* The expression types are mostly straightforward, with the fourth argument"}, {"sha": "457d72cd12f2c19f038480de0b654fdb1648febe", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -648,9 +648,6 @@ extern void tree_operand_check_failed (int, enum tree_code,\n #define FUNC_OR_METHOD_CHECK(T)\tTREE_CHECK2 (T, FUNCTION_TYPE, METHOD_TYPE)\n #define PTR_OR_REF_CHECK(T)\tTREE_CHECK2 (T, POINTER_TYPE, REFERENCE_TYPE)\n \n-#define SET_OR_ARRAY_CHECK(T) \\\n-  TREE_CHECK2 (T, ARRAY_TYPE, SET_TYPE)\n-\n #define RECORD_OR_UNION_CHECK(T)\t\\\n   TREE_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)\n #define NOT_RECORD_OR_UNION_CHECK(T) \\\n@@ -773,8 +770,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n \n #define AGGREGATE_TYPE_P(TYPE) \\\n   (TREE_CODE (TYPE) == ARRAY_TYPE || TREE_CODE (TYPE) == RECORD_TYPE \\\n-   || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE \\\n-   || TREE_CODE (TYPE) == SET_TYPE)\n+   || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE)\n \n /* Nonzero if TYPE represents a pointer or reference type.\n    (It should be renamed to INDIRECT_TYPE_P.)  */\n@@ -1476,7 +1472,7 @@ struct tree_block GTY(())\n #define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type.size_unit)\n #define TYPE_MODE(NODE) (TYPE_CHECK (NODE)->type.mode)\n #define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type.values)\n-#define TYPE_DOMAIN(NODE) (SET_OR_ARRAY_CHECK (NODE)->type.values)\n+#define TYPE_DOMAIN(NODE) (ARRAY_TYPE_CHECK (NODE)->type.values)\n #define TYPE_FIELDS(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.values)\n #define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK(NODE)->type.values)\n #define TYPE_ORIG_SIZE_TYPE(NODE)\t\t\t\\"}, {"sha": "5f36214257504bbdac0a13fdaa1d58bb3216bba5", "filename": "gcc/typeclass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftypeclass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Ftypeclass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftypeclass.h?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -39,7 +39,7 @@ enum type_class\n   real_type_class, complex_type_class,\n   function_type_class, method_type_class,\n   record_type_class, union_type_class,\n-  array_type_class, string_type_class, set_type_class, file_type_class,\n+  array_type_class, string_type_class, file_type_class,\n   lang_type_class\n };\n "}, {"sha": "078959f739e866792ff637001f9807120b5809b1", "filename": "gcc/varasm.c", "status": "modified", "additions": 56, "deletions": 105, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08f2586c92554b92c43ae5becc531807c927f75b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=08f2586c92554b92c43ae5becc531807c927f75b", "patch": "@@ -2287,28 +2287,17 @@ const_hash_1 (const tree exp)\n \t      + const_hash_1 (TREE_IMAGPART (exp)));\n \n     case CONSTRUCTOR:\n-      if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n-\t{\n-\t  char *tmp;\n-\n-\t  len = int_size_in_bytes (TREE_TYPE (exp));\n-\t  tmp = alloca (len);\n-\t  get_set_constructor_bytes (exp, (unsigned char *) tmp, len);\n-\t  p = tmp;\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  tree link;\n-\n-\t  hi = 5 + int_size_in_bytes (TREE_TYPE (exp));\n-\n-\t  for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n-\t    if (TREE_VALUE (link))\n-\t      hi = hi * 603 + const_hash_1 (TREE_VALUE (link));\n-\n-\t  return hi;\n-\t}\n+      {\n+\ttree link;\n+\t\n+\thi = 5 + int_size_in_bytes (TREE_TYPE (exp));\n+\t\n+\tfor (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+\t  if (TREE_VALUE (link))\n+\t    hi = hi * 603 + const_hash_1 (TREE_VALUE (link));\n+\t\n+\treturn hi;\n+      }\n \n     case ADDR_EXPR:\n     case FDESC_EXPR:\n@@ -2407,72 +2396,53 @@ compare_constant (const tree t1, const tree t2)\n \t      && compare_constant (TREE_IMAGPART (t1), TREE_IMAGPART (t2)));\n \n     case CONSTRUCTOR:\n-      typecode = TREE_CODE (TREE_TYPE (t1));\n-      if (typecode != TREE_CODE (TREE_TYPE (t2)))\n-\treturn 0;\n-\n-      if (typecode == SET_TYPE)\n-\t{\n-\t  int len = int_size_in_bytes (TREE_TYPE (t2));\n-\t  unsigned char *tmp1, *tmp2;\n-\n-\t  if (int_size_in_bytes (TREE_TYPE (t1)) != len)\n-\t    return 0;\n-\n-\t  tmp1 = alloca (len);\n-\t  tmp2 = alloca (len);\n-\n-\t  if (get_set_constructor_bytes (t1, tmp1, len) != NULL_TREE)\n-\t    return 0;\n-\t  if (get_set_constructor_bytes (t2, tmp2, len) != NULL_TREE)\n-\t    return 0;\n-\n-\t  return memcmp (tmp1, tmp2, len) == 0;\n-\t}\n-      else\n-\t{\n-\t  tree l1, l2;\n-\n-\t  if (typecode == ARRAY_TYPE)\n-\t    {\n-\t      HOST_WIDE_INT size_1 = int_size_in_bytes (TREE_TYPE (t1));\n-\t      /* For arrays, check that the sizes all match.  */\n-\t      if (TYPE_MODE (TREE_TYPE (t1)) != TYPE_MODE (TREE_TYPE (t2))\n-\t\t  || size_1 == -1\n-\t\t  || size_1 != int_size_in_bytes (TREE_TYPE (t2)))\n-\t\treturn 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* For record and union constructors, require exact type\n-                 equality.  */\n-\t      if (TREE_TYPE (t1) != TREE_TYPE (t2))\n-\t\treturn 0;\n-\t    }\n+      {\n+\ttree l1, l2;\n+\t\n+\ttypecode = TREE_CODE (TREE_TYPE (t1));\n+\tif (typecode != TREE_CODE (TREE_TYPE (t2)))\n+\t  return 0;\n \n-\t  for (l1 = CONSTRUCTOR_ELTS (t1), l2 = CONSTRUCTOR_ELTS (t2);\n-\t       l1 && l2;\n-\t       l1 = TREE_CHAIN (l1), l2 = TREE_CHAIN (l2))\n-\t    {\n-\t      /* Check that each value is the same...  */\n-\t      if (! compare_constant (TREE_VALUE (l1), TREE_VALUE (l2)))\n-\t\treturn 0;\n-\t      /* ... and that they apply to the same fields!  */\n-\t      if (typecode == ARRAY_TYPE)\n-\t\t{\n-\t\t  if (! compare_constant (TREE_PURPOSE (l1),\n-\t\t\t\t\t  TREE_PURPOSE (l2)))\n-\t\t    return 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (TREE_PURPOSE (l1) != TREE_PURPOSE (l2))\n-\t\t    return 0;\n-\t\t}\n-\t    }\n+\tif (typecode == ARRAY_TYPE)\n+\t  {\n+\t    HOST_WIDE_INT size_1 = int_size_in_bytes (TREE_TYPE (t1));\n+\t    /* For arrays, check that the sizes all match.  */\n+\t    if (TYPE_MODE (TREE_TYPE (t1)) != TYPE_MODE (TREE_TYPE (t2))\n+\t\t|| size_1 == -1\n+\t\t|| size_1 != int_size_in_bytes (TREE_TYPE (t2)))\n+\t      return 0;\n+\t  }\n+\telse\n+\t  {\n+\t    /* For record and union constructors, require exact type\n+               equality.  */\n+\t    if (TREE_TYPE (t1) != TREE_TYPE (t2))\n+\t      return 0;\n+\t  }\n \n-\t  return l1 == NULL_TREE && l2 == NULL_TREE;\n-\t}\n+\tfor (l1 = CONSTRUCTOR_ELTS (t1), l2 = CONSTRUCTOR_ELTS (t2);\n+\t     l1 && l2;\n+\t     l1 = TREE_CHAIN (l1), l2 = TREE_CHAIN (l2))\n+\t  {\n+\t    /* Check that each value is the same...  */\n+\t    if (! compare_constant (TREE_VALUE (l1), TREE_VALUE (l2)))\n+\t      return 0;\n+\t    /* ... and that they apply to the same fields!  */\n+\t    if (typecode == ARRAY_TYPE)\n+\t      {\n+\t\tif (! compare_constant (TREE_PURPOSE (l1),\n+\t\t\t\t\tTREE_PURPOSE (l2)))\n+\t\t  return 0;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (TREE_PURPOSE (l1) != TREE_PURPOSE (l2))\n+\t\t  return 0;\n+\t      }\n+\t  }\n+\t\n+\treturn l1 == NULL_TREE && l2 == NULL_TREE;\n+      }\n \n     case ADDR_EXPR:\n     case FDESC_EXPR:\n@@ -2562,9 +2532,6 @@ copy_constant (tree exp)\n \tCONSTRUCTOR_ELTS (copy) = list;\n \tfor (tail = list; tail; tail = TREE_CHAIN (tail))\n \t  TREE_VALUE (tail) = copy_constant (TREE_VALUE (tail));\n-\tif (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n-\t  for (tail = list; tail; tail = TREE_CHAIN (tail))\n-\t    TREE_PURPOSE (tail) = copy_constant (TREE_PURPOSE (tail));\n \n \treturn copy;\n       }\n@@ -3827,22 +3794,6 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n \tabort ();\n       return;\n \n-    case SET_TYPE:\n-      if (TREE_CODE (exp) == INTEGER_CST)\n-\tassemble_integer (expand_expr (exp, NULL_RTX,\n-\t\t\t\t       VOIDmode, EXPAND_INITIALIZER),\n-\t\t\t  thissize, align, 1);\n-      else if (TREE_CODE (exp) == CONSTRUCTOR)\n-\t{\n-\t  unsigned char *buffer = alloca (thissize);\n-\t  if (get_set_constructor_bytes (exp, buffer, thissize))\n-\t    abort ();\n-\t  assemble_string ((char *) buffer, thissize);\n-\t}\n-      else\n-\terror (\"unknown set constructor type\");\n-      return;\n-\n     case ERROR_MARK:\n       return;\n "}]}