{"sha": "5277cab69bcf175da5fb53b32ae24a61401e610e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI3N2NhYjY5YmNmMTc1ZGE1ZmI1M2IzMmFlMjRhNjE0MDFlNjEwZQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-04-06T09:19:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:19:53Z"}, "message": "exp_aggr.adb: If the array component is a discriminated record...\n\n2007-04-06  Ed Schonberg  <schonberg@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_aggr.adb:\n\tIf the array component is a discriminated record, the array aggregate\n\tis non-static even if the component is given by an aggregate with\n\tstatic components.\n\t(Expand_Record_Aggregate): Use First/Next_Component_Or_Discriminant\n\t(Convert_Aggr_In_Allocator): If the allocator is for an access\n\tdiscriminant and the type is controlled. do not place on a finalization\n\tlist at this point. The proper list will be determined from the\n\tenclosing object.\n\t(Build_Record_Aggr_Code): If aggregate has box-initialized components,\n\tinitialize record controller if needed, before the components, to ensure\n\tthat they are properly finalized.\n\t(Build_Record_Aggr_Code): For the case of an array component that has a\n\tcorresponding array aggregate in the record aggregate, perform sliding\n\tif required.\n\nFrom-SVN: r123561", "tree": {"sha": "0a5da656edd636dc5669b2ecbcfcde3234767bb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a5da656edd636dc5669b2ecbcfcde3234767bb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5277cab69bcf175da5fb53b32ae24a61401e610e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5277cab69bcf175da5fb53b32ae24a61401e610e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5277cab69bcf175da5fb53b32ae24a61401e610e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5277cab69bcf175da5fb53b32ae24a61401e610e/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "958a816e69e829d04e175512a09f8b6f43cd2ffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/958a816e69e829d04e175512a09f8b6f43cd2ffd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/958a816e69e829d04e175512a09f8b6f43cd2ffd"}], "stats": {"total": 179, "additions": 99, "deletions": 80}, "files": [{"sha": "97df2bc880fcab4baeb4e5e4267263a4515a30a5", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 99, "deletions": 80, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5277cab69bcf175da5fb53b32ae24a61401e610e/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5277cab69bcf175da5fb53b32ae24a61401e610e/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=5277cab69bcf175da5fb53b32ae24a61401e610e", "patch": "@@ -133,7 +133,12 @@ package body Exp_Aggr is\n    --  which to attach the controlled components if any. Obj is present in the\n    --  object declaration and dynamic allocation cases, it contains an entity\n    --  that allows to know if the value being created needs to be attached to\n-   --  the final list in case of pragma finalize_Storage_Only.\n+   --  the final list in case of pragma Finalize_Storage_Only.\n+   --\n+   --  ???\n+   --  The meaning of the Obj formal is extremely unclear. *What* entity\n+   --  should be passed? For the object declaration case we may guess that\n+   --  this is the object being declared, but what about the allocator case?\n    --\n    --  Is_Limited_Ancestor_Expansion indicates that the function has been\n    --  called recursively to expand the limited ancestor to avoid copying it.\n@@ -372,8 +377,8 @@ package body Exp_Aggr is\n \n    begin\n       Siz  := Component_Count (Component_Type (Typ));\n-      Indx := First_Index (Typ);\n \n+      Indx := First_Index (Typ);\n       while Present (Indx) loop\n          Lo  := Type_Low_Bound (Etype (Indx));\n          Hi  := Type_High_Bound (Etype (Indx));\n@@ -474,15 +479,22 @@ package body Exp_Aggr is\n \n          --  Recurse to check subaggregates, which may appear in qualified\n          --  expressions. If delayed, the front-end will have to expand.\n+         --  If the component is a discriminated record, treat as non-static,\n+         --  as the back-end cannot handle this properly.\n \n          Expr := First (Expressions (N));\n-\n          while Present (Expr) loop\n-\n             if Is_Delayed_Aggregate (Expr) then\n                return False;\n             end if;\n \n+            if Present (Etype (Expr))\n+              and then Is_Record_Type (Etype (Expr))\n+              and then Has_Discriminants (Etype (Expr))\n+            then\n+               return False;\n+            end if;\n+\n             if Present (Next_Index (Index))\n                and then not Static_Check (Expr, Next_Index (Index))\n             then\n@@ -955,9 +967,10 @@ package body Exp_Aggr is\n                --  do not have an assigned type.\n \n                declare\n-                  P : Node_Id := Parent (Expr);\n+                  P : Node_Id;\n \n                begin\n+                  P := Parent (Expr);\n                   while Present (P) loop\n                      if Nkind (P) = N_Aggregate\n                        and then Present (Etype (P))\n@@ -1551,7 +1564,6 @@ package body Exp_Aggr is\n \n          Expr        := First (Expressions (N));\n          Nb_Elements := -1;\n-\n          while Present (Expr) loop\n             Nb_Elements := Nb_Elements + 1;\n             Append_List (Gen_Assign (Add (Nb_Elements, To => Aggr_L), Expr),\n@@ -1625,7 +1637,9 @@ package body Exp_Aggr is\n \n       Init_Typ : Entity_Id := Empty;\n       Attach   : Node_Id;\n+\n       Ctrl_Stuff_Done : Boolean := False;\n+      --  Could use comments here ???\n \n       function Ancestor_Discriminant_Value (Disc : Entity_Id) return Node_Id;\n       --  Returns the value that the given discriminant of an ancestor\n@@ -1801,11 +1815,12 @@ package body Exp_Aggr is\n       ----------------------------------\n \n       procedure Check_Ancestor_Discriminants (Anc_Typ : Entity_Id) is\n-         Discr      : Entity_Id := First_Discriminant (Base_Type (Anc_Typ));\n+         Discr      : Entity_Id;\n          Disc_Value : Node_Id;\n          Cond       : Node_Id;\n \n       begin\n+         Discr := First_Discriminant (Base_Type (Anc_Typ));\n          while Present (Discr) loop\n             Disc_Value := Ancestor_Discriminant_Value (Discr);\n \n@@ -1958,6 +1973,12 @@ package body Exp_Aggr is\n \n       procedure Gen_Ctrl_Actions_For_Aggr is\n       begin\n+         if not Ctrl_Stuff_Done then\n+            Ctrl_Stuff_Done := True;\n+         else\n+            return;\n+         end if;\n+\n          if Present (Obj)\n           and then Finalize_Storage_Only (Typ)\n           and then (Is_Library_Level_Entity (Obj)\n@@ -2036,11 +2057,9 @@ package body Exp_Aggr is\n                At_Root   : Boolean;\n \n             begin\n-\n-               Outer_Typ := Base_Type (Typ);\n-\n                --  Find outer type with a controller\n \n+               Outer_Typ := Base_Type (Typ);\n                while Outer_Typ /= Init_Typ\n                  and then not Has_New_Controlled_Component (Outer_Typ)\n                loop\n@@ -2372,7 +2391,6 @@ package body Exp_Aggr is\n \n             begin\n                Btype := Base_Type (Typ);\n-\n                while Is_Derived_Type (Btype)\n                   and then Present (Stored_Constraint (Btype))\n                loop\n@@ -2421,9 +2439,7 @@ package body Exp_Aggr is\n \n             begin\n                Discriminant := First_Stored_Discriminant (Typ);\n-\n                while Present (Discriminant) loop\n-\n                   Comp_Expr :=\n                     Make_Selected_Component (Loc,\n                       Prefix        => New_Copy_Tree (Target),\n@@ -2465,6 +2481,10 @@ package body Exp_Aggr is\n          if Box_Present (Comp)\n            and then Has_Non_Null_Base_Init_Proc (Etype (Selector))\n          then\n+            if Ekind (Selector) /= E_Discriminant then\n+               Gen_Ctrl_Actions_For_Aggr;\n+            end if;\n+\n             --  Ada 2005 (AI-287): If the component type has tasks then\n             --  generate the activation chain and master entities (except\n             --  in case of an allocator because in that case these entities\n@@ -2499,6 +2519,7 @@ package body Exp_Aggr is\n                             Selector_Name => New_Occurrence_Of (Selector,\n                                                                    Loc)),\n                 Typ    => Etype (Selector),\n+                Enclos_Type => Typ,\n                 With_Default_Init => True));\n \n             goto Next_Comp;\n@@ -2509,16 +2530,12 @@ package body Exp_Aggr is\n          if Ekind (Selector) /= E_Discriminant\n            or else Nkind (N) = N_Extension_Aggregate\n          then\n-\n             --  All the discriminants have now been assigned\n             --  This is now a good moment to initialize and attach all the\n             --  controllers. Their position may depend on the discriminants.\n \n-            if Ekind (Selector) /= E_Discriminant\n-              and then not Ctrl_Stuff_Done\n-            then\n+            if Ekind (Selector) /= E_Discriminant then\n                Gen_Ctrl_Actions_For_Aggr;\n-               Ctrl_Stuff_Done := True;\n             end if;\n \n             Comp_Type := Etype (Selector);\n@@ -2587,19 +2604,18 @@ package body Exp_Aggr is\n                --    Temp (Y) := (...);\n                --    Obj_Rec_Typ.Obj_Arr_Typ := Temp;\n \n-               if Present (Obj)\n-                 and then Ekind (Comp_Type) = E_Array_Subtype\n+               if Ekind (Comp_Type) = E_Array_Subtype\n                  and then Is_Int_Range_Bounds (Aggregate_Bounds (Expr_Q))\n                  and then Is_Int_Range_Bounds (First_Index (Comp_Type))\n                  and then not\n-                   Compatible_Int_Bounds (\n-                     Agg_Bounds => Aggregate_Bounds (Expr_Q),\n-                     Typ_Bounds => First_Index (Comp_Type))\n+                   Compatible_Int_Bounds\n+                     (Agg_Bounds => Aggregate_Bounds (Expr_Q),\n+                      Typ_Bounds => First_Index (Comp_Type))\n                then\n-                  declare\n-                     --  Create the array subtype with bounds equal to those\n-                     --  of the corresponding aggregate.\n+                  --  Create the array subtype with bounds equal to those of\n+                  --  the corresponding aggregate.\n \n+                  declare\n                      SubE : constant Entity_Id :=\n                               Make_Defining_Identifier (Loc,\n                                 New_Internal_Name ('T'));\n@@ -2637,8 +2653,7 @@ package body Exp_Aggr is\n                      Append_To (L, SubD);\n                      Append_To (L, TmpD);\n \n-                     --  Expand the aggregate into assignments to the temporary\n-                     --  array.\n+                     --  Expand aggregate into assignments to the temp array\n \n                      Append_List_To (L,\n                        Late_Expansion (Expr_Q, Comp_Type,\n@@ -2651,13 +2666,14 @@ package body Exp_Aggr is\n                          Name       => New_Copy_Tree (Comp_Expr),\n                          Expression => New_Reference_To (TmpE, Loc)));\n \n-                     --  Do not pass the original aggregate to Gigi as is\n-                     --  since it will potentially clobber the front or the\n-                     --  end of the array. Setting the expression to empty\n-                     --  is safe since all aggregates will be expanded into\n-                     --  assignments.\n+                     --  Do not pass the original aggregate to Gigi as is,\n+                     --  since it will potentially clobber the front or the end\n+                     --  of the array. Setting the expression to empty is safe\n+                     --  since all aggregates are expanded into assignments.\n \n-                     Set_Expression (Parent (Obj), Empty);\n+                     if Present (Obj) then\n+                        Set_Expression (Parent (Obj), Empty);\n+                     end if;\n                   end;\n \n                --  Normal case (sliding not required)\n@@ -2668,6 +2684,8 @@ package body Exp_Aggr is\n                       Internal_Final_List));\n                end if;\n \n+            --  Expr_Q is not delayed aggregate\n+\n             else\n                Instr :=\n                  Make_OK_Assignment_Statement (Loc,\n@@ -2737,7 +2755,6 @@ package body Exp_Aggr is\n             begin\n                D_Val := First_Elmt (Discriminant_Constraint (Typ));\n                Disc  := First_Discriminant (Typ);\n-\n                while Chars (Disc) /= Chars (Selector) loop\n                   Next_Discriminant (Disc);\n                   Next_Elmt (D_Val);\n@@ -2804,10 +2821,7 @@ package body Exp_Aggr is\n       --  If the controllers have not been initialized yet (by lack of non-\n       --  discriminant components), let's do it now.\n \n-      if not Ctrl_Stuff_Done then\n-         Gen_Ctrl_Actions_For_Aggr;\n-         Ctrl_Stuff_Done := True;\n-      end if;\n+      Gen_Ctrl_Actions_For_Aggr;\n \n       return L;\n    end Build_Record_Aggr_Code;\n@@ -2827,8 +2841,25 @@ package body Exp_Aggr is\n                    New_Reference_To (Temp, Loc)));\n \n       Access_Type : constant Entity_Id := Etype (Temp);\n+      Flist       : Entity_Id;\n \n    begin\n+      --  If the allocator is for an access discriminant, there is no\n+      --  finalization list for the anonymous access type, and the eventual\n+      --  finalization of the object is handled through the coextension\n+      --  mechanism. If the enclosing object is not dynamically allocated,\n+      --  the access discriminant is itself placed on the stack. Otherwise,\n+      --  some other finalization list is used (see exp_ch4.adb).\n+\n+      if Ekind (Access_Type) = E_Anonymous_Access_Type\n+        and then Nkind (Associated_Node_For_Itype (Access_Type)) =\n+                                              N_Discriminant_Specification\n+      then\n+         Flist := Empty;\n+      else\n+         Flist := Find_Final_List (Access_Type);\n+      end if;\n+\n       if Is_Array_Type (Typ) then\n          Convert_Array_Aggr_In_Allocator (Decl, Aggr, Occ);\n \n@@ -2838,19 +2869,28 @@ package body Exp_Aggr is\n             Init_Stmts : List_Id;\n \n          begin\n-            Init_Stmts := Late_Expansion (Aggr, Typ, Occ,\n-                            Find_Final_List (Access_Type),\n-                            Associated_Final_Chain (Base_Type (Access_Type)));\n+            Init_Stmts :=\n+              Late_Expansion\n+                (Aggr, Typ, Occ,\n+                 Flist,\n+                 Associated_Final_Chain (Base_Type (Access_Type)));\n+\n+            --  ??? Dubious actual for Obj: expect 'the original object\n+            --  being initialized'\n \n             Build_Task_Allocate_Block_With_Init_Stmts (L, Aggr, Init_Stmts);\n             Insert_Actions_After (Decl, L);\n          end;\n \n       else\n          Insert_Actions_After (Decl,\n-           Late_Expansion (Aggr, Typ, Occ,\n-             Find_Final_List (Access_Type),\n-             Associated_Final_Chain (Base_Type (Access_Type))));\n+           Late_Expansion\n+             (Aggr, Typ, Occ, Flist,\n+              Associated_Final_Chain (Base_Type (Access_Type))));\n+\n+         --  ??? Dubious actual for Obj: expect 'the original object\n+         --  being initialized'\n+\n       end if;\n    end Convert_Aggr_In_Allocator;\n \n@@ -2869,8 +2909,9 @@ package body Exp_Aggr is\n       end if;\n \n       Insert_Actions_After (N,\n-        Late_Expansion (Aggr, Typ, Occ,\n-          Find_Final_List (Typ, New_Copy_Tree (Occ))));\n+        Late_Expansion\n+          (Aggr, Typ, Occ,\n+           Find_Final_List (Typ, New_Copy_Tree (Occ))));\n    end Convert_Aggr_In_Assignment;\n \n    ---------------------------------\n@@ -2907,7 +2948,6 @@ package body Exp_Aggr is\n          D := First_Discriminant (Typ);\n          Disc1 := First_Elmt (Discriminant_Constraint (Typ));\n          Disc2 := First_Elmt (Discriminant_Constraint (Etype (Obj)));\n-\n          while Present (Disc1) and then Present (Disc2) loop\n             Val1 := Node (Disc1);\n             Val2 := Node (Disc2);\n@@ -3175,7 +3215,6 @@ package body Exp_Aggr is\n          begin\n             if Present (Expressions (N)) then\n                Elmt := First (Expressions (N));\n-\n                while Present (Elmt) loop\n                   if Nkind (Elmt) = N_Aggregate\n                     and then Present (Next_Index (Ix))\n@@ -3336,7 +3375,6 @@ package body Exp_Aggr is\n \n             else\n                Elmt := First (Expressions (N));\n-\n                while Present (Elmt) loop\n                   if not Is_Flat (Elmt, Dims - 1) then\n                      return False;\n@@ -3513,11 +3551,10 @@ package body Exp_Aggr is\n             Sub_Agg := N;\n \n             for D in 1 .. Number_Dimensions (Typ) loop\n-               Comp := First (Expressions (Sub_Agg));\n+               Sub_Agg := First (Expressions (Sub_Agg));\n \n-               Sub_Agg := Comp;\n+               Comp := Sub_Agg;\n                Num := 0;\n-\n                while Present (Comp) loop\n                   Num := Num + 1;\n                   Next (Comp);\n@@ -3789,9 +3826,10 @@ package body Exp_Aggr is\n \n       function Has_Address_Clause (D : Node_Id) return Boolean is\n          Id   : constant Entity_Id := Defining_Identifier (D);\n-         Decl : Node_Id := Next (D);\n+         Decl : Node_Id;\n \n       begin\n+         Decl := Next (D);\n          while Present (Decl) loop\n             if Nkind (Decl) = N_At_Clause\n                and then Chars (Identifier (Decl)) = Chars (Id)\n@@ -3857,7 +3895,6 @@ package body Exp_Aggr is\n          begin\n             if Present (Expressions (Aggr)) then\n                Expr := First (Expressions (Aggr));\n-\n                while Present (Expr) loop\n                   if Nkind (Expr) = N_Aggregate then\n                      if not Safe_Aggregate (Expr) then\n@@ -3874,7 +3911,6 @@ package body Exp_Aggr is\n \n             if Present (Component_Associations (Aggr)) then\n                Expr := First (Component_Associations (Aggr));\n-\n                while Present (Expr) loop\n                   if Nkind (Expression (Expr)) = N_Aggregate then\n                      if not Safe_Aggregate (Expression (Expr)) then\n@@ -4391,7 +4427,6 @@ package body Exp_Aggr is\n \n          begin\n             Index := First_Index (Itype);\n-\n             while Present (Index) loop\n                if not Is_Static_Subtype (Etype (Index)) then\n                   Needs_Type := True;\n@@ -4515,7 +4550,7 @@ package body Exp_Aggr is\n          Set_Expansion_Delayed (N);\n          return;\n \n-      --  In the remaining cases  the aggregate is the RHS of an assignment\n+      --  In the remaining cases the aggregate is the RHS of an assignment\n \n       elsif Maybe_In_Place_OK\n         and then Is_Entity_Name (Name (Parent (N)))\n@@ -4890,7 +4925,6 @@ package body Exp_Aggr is\n                procedure Prepend_Stored_Values (T : Entity_Id) is\n                begin\n                   Discriminant := First_Stored_Discriminant (T);\n-\n                   while Present (Discriminant) loop\n                      New_Comp :=\n                        Make_Component_Association (Loc,\n@@ -4922,13 +4956,12 @@ package body Exp_Aggr is\n                --  the derived type.\n \n                First_Comp := First (Component_Associations (N));\n-\n                while Present (First_Comp) loop\n                   Comp := First_Comp;\n                   Next (First_Comp);\n \n-                  if Ekind (Entity (First (Choices (Comp)))) =\n-                    E_Discriminant\n+                  if Ekind (Entity\n+                             (First (Choices (Comp)))) = E_Discriminant\n                   then\n                      Remove (Comp);\n                      Num_Disc := Num_Disc + 1;\n@@ -4947,7 +4980,6 @@ package body Exp_Aggr is\n                First_Comp := Empty;\n \n                Discriminant := First_Stored_Discriminant (Base_Type (Typ));\n-\n                while Present (Discriminant) loop\n                   Num_Gird := Num_Gird + 1;\n                   Next_Stored_Discriminant (Discriminant);\n@@ -4962,7 +4994,6 @@ package body Exp_Aggr is\n                   --  convert it to the intended target type.\n \n                   Discriminant := First_Stored_Discriminant (Base_Type (Typ));\n-\n                   while Present (Discriminant) loop\n                      New_Comp :=\n                        New_Copy_Tree (\n@@ -5022,19 +5053,12 @@ package body Exp_Aggr is\n             if Present (Parent_Expr)\n               and then Is_Empty_List (Comps)\n             then\n-               Comp := First_Entity (Typ);\n+               Comp := First_Component_Or_Discriminant (Typ);\n                while Present (Comp) loop\n \n-                  --  Skip all entities that aren't discriminants or components\n-\n-                  if Ekind (Comp) /= E_Discriminant\n-                    and then Ekind (Comp) /= E_Component\n-                  then\n-                     null;\n-\n                   --  Skip all expander-generated components\n \n-                  elsif\n+                  if\n                     not Comes_From_Source (Original_Record_Component (Comp))\n                   then\n                      null;\n@@ -5058,7 +5082,7 @@ package body Exp_Aggr is\n                      Analyze_And_Resolve (New_Comp, Etype (Comp));\n                   end if;\n \n-                  Next_Entity (Comp);\n+                  Next_Component_Or_Discriminant (Comp);\n                end loop;\n             end if;\n \n@@ -5093,7 +5117,6 @@ package body Exp_Aggr is\n \n                   First_Comp := First (Component_Associations (N));\n                   Parent_Comps := New_List;\n-\n                   while Present (First_Comp)\n                     and then Scope (Original_Record_Component (\n                             Entity (First (Choices (First_Comp))))) /= Base_Typ\n@@ -5325,10 +5348,8 @@ package body Exp_Aggr is\n \n       Assoc := First (Component_Associations (N));\n       while Present (Assoc) loop\n-\n          Choice := First (Choices (Assoc));\n          while Present (Choice) loop\n-\n             if Nkind (Choice) /= N_Others_Choice then\n                Nb_Choices := Nb_Choices + 1;\n             end if;\n@@ -5569,7 +5590,6 @@ package body Exp_Aggr is\n \n    begin\n       Comp := First_Component (Typ);\n-\n       while Present (Comp) loop\n          if Is_Record_Type (Etype (Comp))\n            and then Has_Discriminants (Etype (Comp))\n@@ -5737,11 +5757,10 @@ package body Exp_Aggr is\n \n    begin\n       K := L;\n-\n       while K /= U loop\n          T := Case_Table (K + 1);\n-         J := K + 1;\n \n+         J := K + 1;\n          while J /= L\n            and then Expr_Value (Case_Table (J - 1).Choice_Lo) >\n                     Expr_Value (T.Choice_Lo)"}]}