{"sha": "b38a52448fcb3a5ab1ab8aa87541dd7269e1c538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM4YTUyNDQ4ZmNiM2E1YWIxYWI4YWE4NzU0MWRkNzI2OWUxYzUzOA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-06-02T14:04:56Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-06-02T14:04:56Z"}, "message": "sh.h (OLD_ARG_MODE): New macro.\n\n\t* sh.h (OLD_ARG_MODE): New macro.\n\t(FUNCTION_ARG_ADVANCE, FUNCTION_ARG_PASS_BY_REFERENCE): Use it.\n\t(FUNCTION_ARG_1): Break out of:\n\t(FUNCTION_ARG).  Use OLD_ARG_MODE.\n\nFrom-SVN: r67329", "tree": {"sha": "127164c84d38300f75e104555c64844a0e38f63b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/127164c84d38300f75e104555c64844a0e38f63b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b38a52448fcb3a5ab1ab8aa87541dd7269e1c538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38a52448fcb3a5ab1ab8aa87541dd7269e1c538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b38a52448fcb3a5ab1ab8aa87541dd7269e1c538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38a52448fcb3a5ab1ab8aa87541dd7269e1c538/comments", "author": null, "committer": null, "parents": [{"sha": "37ec8b7a07840f62b6d20ca327df2e23d9d7f62a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37ec8b7a07840f62b6d20ca327df2e23d9d7f62a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37ec8b7a07840f62b6d20ca327df2e23d9d7f62a"}], "stats": {"total": 53, "additions": 36, "deletions": 17}, "files": [{"sha": "8350f37cf8ad88aa41ff488038ac346fdb63afb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38a52448fcb3a5ab1ab8aa87541dd7269e1c538/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38a52448fcb3a5ab1ab8aa87541dd7269e1c538/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b38a52448fcb3a5ab1ab8aa87541dd7269e1c538", "patch": "@@ -1,3 +1,10 @@\n+2003-06-02  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.h (OLD_ARG_MODE): New macro.\n+\t(FUNCTION_ARG_ADVANCE, FUNCTION_ARG_PASS_BY_REFERENCE): Use it.\n+\t(FUNCTION_ARG_1): Break out of:\n+\t(FUNCTION_ARG).  Use OLD_ARG_MODE.\n+\n 2003-04-16  Kazuhiro Inaoka  <inaoka.kazuhiro@renesas.com>\n \n         * gcc/config.gcc Add support multilib parts for m32rx processor."}, {"sha": "b334f84098fc1c8cf71c0be4a910511e4cfef972", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38a52448fcb3a5ab1ab8aa87541dd7269e1c538/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38a52448fcb3a5ab1ab8aa87541dd7269e1c538/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=b38a52448fcb3a5ab1ab8aa87541dd7269e1c538", "patch": "@@ -1758,30 +1758,38 @@ struct sh_args {\n     (CUM).outgoing = 0;\t\t\t\t\t\t\\\n   } while (0)\n  \n+#define OLD_ARG_MODE(MODE, TYPE) \\\n+  (((TYPE) \\\n+    && (TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE (TYPE) == UNION_TYPE) \\\n+    && (MODE) != BLKmode && GET_MODE_CLASS (MODE) != MODE_INT) \\\n+   ? int_mode_for_mode (MODE) : (MODE))\n+\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be\n    available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+do {\t\t\t\t\t\t\t\\\n+ enum machine_mode MODE_ = OLD_ARG_MODE ((MODE), (TYPE));\\\n  if ((CUM).force_mem)\t\t\t\t\t\\\n    (CUM).force_mem = 0;\t\t\t\t\t\\\n  else if (TARGET_SH5)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      tree TYPE_ = ((CUM).byref && (TYPE)\t\t\\\n \t\t   ? TREE_TYPE (TYPE)\t\t\t\\\n  \t\t   : (TYPE));\t\t\t\t\\\n-     enum machine_mode MODE_ = ((CUM).byref && (TYPE)\t\\\n-\t\t\t\t? TYPE_MODE (TYPE_)\t\\\n-\t\t\t\t: (MODE));\t\t\\\n-     int dwords = (((CUM).byref\t\t\t\t\\\n-\t\t    ? (CUM).byref\t\t\t\\\n-\t\t    : (MODE_) == BLKmode\t\t\\\n-\t\t    ? int_size_in_bytes (TYPE_)\t\t\\\n-\t\t    : GET_MODE_SIZE (MODE_)) + 7) / 8;\t\\\n-     int numregs = MIN (dwords, NPARM_REGS (SImode)\t\\\n-\t\t\t- (CUM).arg_count[(int) SH_ARG_INT]); \\\n+     int dwords, numregs;\t\t\t\t\\\n \t\t\t\t\t\t\t\\\n+     MODE_ = ((CUM).byref && (TYPE)\t\t\t\\\n+\t      ? TYPE_MODE (TYPE_) : (MODE_));\t\t\\\n+     dwords = (((CUM).byref\t\t\t\t\\\n+\t\t? (CUM).byref\t\t\t\t\\\n+\t\t: (MODE_) == BLKmode\t\t\t\\\n+\t\t? int_size_in_bytes (TYPE_)\t\t\\\n+\t\t: GET_MODE_SIZE (MODE_)) + 7) / 8;\t\\\n+     numregs = MIN (dwords, NPARM_REGS (SImode)\t\t\\\n+\t\t    - (CUM).arg_count[(int) SH_ARG_INT]); \\\n      if (numregs)\t\t\t\t\t\\\n        {\t\t\t\t\t\t\\\n \t (CUM).arg_count[(int) SH_ARG_INT] += numregs;\t\\\n@@ -1873,12 +1881,13 @@ struct sh_args {\n \t   }\t\t\t\t\t\t\\\n        }\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\\\n- else if (! TARGET_SH4 || PASS_IN_REG_P ((CUM), (MODE), (TYPE))) \\\n-   ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\\\n-    = (ROUND_REG ((CUM), (MODE))\t\t\t\\\n-       + ((MODE) == BLKmode\t\t\t\t\\\n+ else if (! TARGET_SH4 || PASS_IN_REG_P ((CUM), (MODE_), (TYPE))) \\\n+   ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE_)]\t\\\n+    = (ROUND_REG ((CUM), (MODE_))\t\t\t\\\n+       + ((MODE_) == BLKmode\t\t\t\t\\\n \t  ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\\\n-\t  : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))))\n+\t  : ROUND_ADVANCE (GET_MODE_SIZE (MODE_)))));\t\\\n+} while (0)\n \n /* Return boolean indicating arg of mode MODE will be passed in a reg.\n    This macro is only used in this file.  */\n@@ -1917,10 +1926,13 @@ struct sh_args {\n    its data type forbids.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  FUNCTION_ARG_1 ((CUM), OLD_ARG_MODE ((MODE), (TYPE)), (MODE), (TYPE), (NAMED))\n+\n+#define FUNCTION_ARG_1(CUM, MODE, NEW_MODE, TYPE, NAMED) \\\n   ((! TARGET_SH5 \\\n     && PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n     && ((NAMED) || !TARGET_HITACHI))\t\t\t\t\t\\\n-   ? gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n+   ? gen_rtx_REG ((NEW_MODE),\t\t\t\t\t\t\\\n \t\t  ((BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))) \t\\\n \t\t   ^ ((MODE) == SFmode && TARGET_SH4\t\t\t\\\n \t\t      && TARGET_LITTLE_ENDIAN != 0)))\t\t\t\\\n@@ -1955,7 +1967,7 @@ struct sh_args {\n    loads them into the full 64-bits registers.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM,MODE,TYPE,NAMED) \\\n   (MUST_PASS_IN_STACK ((MODE), (TYPE)) \\\n-   || SHCOMPACT_BYREF ((CUM), (MODE), (TYPE), (NAMED)))\n+   || SHCOMPACT_BYREF ((CUM), OLD_ARG_MODE ((MODE), (TYPE)), (TYPE), (NAMED)))\n \n #define SHCOMPACT_BYREF(CUM, MODE, TYPE, NAMED) \\\n   ((CUM).byref\t\t\t\t\t\t\t\t\\"}]}