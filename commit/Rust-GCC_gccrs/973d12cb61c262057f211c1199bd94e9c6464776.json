{"sha": "973d12cb61c262057f211c1199bd94e9c6464776", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTczZDEyY2I2MWMyNjIwNTdmMjExYzExOTliZDk0ZTljNjQ2NDc3Ng==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-11-10T07:05:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-10T07:05:42Z"}, "message": "flow.c (compute_flow_dominators): No longer treat basic block 0 or (n_basic_blocks - 1) specially.\n\n\n        * flow.c (compute_flow_dominators): No longer treat basic block 0\n        or (n_basic_blocks - 1) specially.  Clear the AUX field before\n        starting computation of doms/pdoms.  Fix initial state for pdoms.\n\nFrom-SVN: r30467", "tree": {"sha": "95fe8040d092baf9407b62eb6734e9dc0627c05c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95fe8040d092baf9407b62eb6734e9dc0627c05c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/973d12cb61c262057f211c1199bd94e9c6464776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973d12cb61c262057f211c1199bd94e9c6464776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/973d12cb61c262057f211c1199bd94e9c6464776", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973d12cb61c262057f211c1199bd94e9c6464776/comments", "author": null, "committer": null, "parents": [{"sha": "ca76ec07e4cbcdbab8568dc32f46cea4a3651288", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca76ec07e4cbcdbab8568dc32f46cea4a3651288", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca76ec07e4cbcdbab8568dc32f46cea4a3651288"}], "stats": {"total": 95, "additions": 83, "deletions": 12}, "files": [{"sha": "3f89016b9f3dc932be4310db94fb05c7145344c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973d12cb61c262057f211c1199bd94e9c6464776/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973d12cb61c262057f211c1199bd94e9c6464776/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=973d12cb61c262057f211c1199bd94e9c6464776", "patch": "@@ -1,3 +1,9 @@\n+Wed Nov 10 00:02:53 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+        * flow.c (compute_flow_dominators): No longer treat basic block 0\n+        or (n_basic_blocks - 1) specially.  Clear the AUX field before\n+        starting computation of doms/pdoms.  Fix initial state for pdoms.\n+\n Wed Nov 10 03:58:08 1999  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>\n \n \t* Makefile.in ($(HOST_PREFIX_1)rtl.o): Update dependencies to"}, {"sha": "96618b537e0f1f9e1d5c05cc0d1468af0409cc79", "filename": "gcc/flow.c", "status": "modified", "additions": 77, "deletions": 12, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973d12cb61c262057f211c1199bd94e9c6464776/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973d12cb61c262057f211c1199bd94e9c6464776/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=973d12cb61c262057f211c1199bd94e9c6464776", "patch": "@@ -5339,26 +5339,58 @@ compute_flow_dominators (dominators, post_dominators)\n \n   if (dominators)\n     {\n+      /* Clear the AUX field for each basic block.  */\n+      for (bb = 0; bb < n_basic_blocks; bb++)\n+\tBASIC_BLOCK (bb)->aux = NULL;\n+\n+      /* We want a maximal solution, so initially assume everything dominates\n+\t everything else.  */\n       sbitmap_vector_ones (dominators, n_basic_blocks);\n-      sbitmap_zero (dominators[0]);\n-      SET_BIT (dominators[0], 0);\n \n       /* Put the successors of the entry block on the worklist.  */\n-      for (e = BASIC_BLOCK (0)->succ; e; e = e->succ_next)\n+      for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n \t{\n \t  *tos++ = e->dest;\n-\t  e->dest->aux = e;\n+\n+\t  /* We use the block's aux field to track blocks which are in\n+\t     the worklist; we also use it to quickly determine which blocks\n+\t     are successors of the ENTRY block.  */\n+\t  e->dest->aux = ENTRY_BLOCK_PTR;\n \t}\n \n       /* Iterate until the worklist is empty.  */\n       while (tos != worklist)\n \t{\n \t  /* Take the first entry off the worklist.  */\n \t  basic_block b = *--tos;\n-\t  b->aux = NULL;\n \t  bb = b->index;\n \n-\t  sbitmap_intersection_of_preds (temp_bitmap[bb], dominators, bb);\n+\t  /* Compute the intersection of the dominators of all the\n+\t     predecessor blocks.\n+\n+\t     If one of the predecessor blocks is the ENTRY block, then the\n+\t     intersection of the dominators of the predecessor blocks is\n+\t     defined as the null set.  We can identify such blocks by the\n+\t     special value in the AUX field in the block structure.  */\n+\t  if (b->aux == ENTRY_BLOCK_PTR)\n+\t    {\n+\t      /* Do not clear the aux field for blocks which are\n+\t\t successors of the ENTRY block.  That way we we never\n+\t\t add them to the worklist again.\n+\n+\t\t The intersect of dominators of the preds of this block is\n+\t\t defined as the null set.  */\n+\t      sbitmap_zero (temp_bitmap[bb]);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Clear the aux field of this block so it can be added to\n+\t\t the worklist again if necessary.  */\n+\t      b->aux = NULL;\n+\t      sbitmap_intersection_of_preds (temp_bitmap[bb], dominators, bb);\n+\t    }\n+\n+\t  /* Make sure each block always dominates itself.  */\n \t  SET_BIT (temp_bitmap[bb], bb);\n \n \t  /* If the out state of this block changed, then we need to\n@@ -5380,26 +5412,59 @@ compute_flow_dominators (dominators, post_dominators)\n \n   if (post_dominators)\n     {\n+      /* Clear the AUX field for each basic block.  */\n+      for (bb = 0; bb < n_basic_blocks; bb++)\n+\tBASIC_BLOCK (bb)->aux = NULL;\n+\n+      /* We want a maximal solution, so initially assume everything post\n+\t dominates everything else.  */\n       sbitmap_vector_ones (post_dominators, n_basic_blocks);\n-      sbitmap_zero (post_dominators[n_basic_blocks - 1]);\n-      SET_BIT (post_dominators[n_basic_blocks - 1], 0);\n \n       /* Put the predecessors of the exit block on the worklist.  */\n-      for (e = BASIC_BLOCK (n_basic_blocks - 1)->pred; e; e = e->pred_next)\n+      for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n \t{\n \t  *tos++ = e->src;\n-\t  e->src->aux = e;\n+\n+\t  /* We use the block's aux field to track blocks which are in\n+\t     the worklist; we also use it to quickly determine which blocks\n+\t     are predecessors of the EXIT block.  */\n+\t  e->src->aux = EXIT_BLOCK_PTR;\n \t}\n \n       /* Iterate until the worklist is empty.  */\n       while (tos != worklist)\n \t{\n \t  /* Take the first entry off the worklist.  */\n \t  basic_block b = *--tos;\n-\t  b->aux = NULL;\n \t  bb = b->index;\n \n-\t  sbitmap_intersection_of_succs (temp_bitmap[bb], post_dominators, bb);\n+\t  /* Compute the intersection of the post dominators of all the\n+\t     successor blocks.\n+\n+\t     If one of the successor blocks is the EXIT block, then the\n+\t     intersection of the dominators of the successor blocks is\n+\t     defined as the null set.  We can identify such blocks by the\n+\t     special value in the AUX field in the block structure.  */\n+\t  if (b->aux == EXIT_BLOCK_PTR)\n+\t    {\n+\t      /* Do not clear the aux field for blocks which are\n+\t\t predecessors of the EXIT block.  That way we we never\n+\t\t add them to the worklist again.\n+\n+\t\t The intersect of dominators of the succs of this block is\n+\t\t defined as the null set.  */\n+\t      sbitmap_zero (temp_bitmap[bb]);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Clear the aux field of this block so it can be added to\n+\t\t the worklist again if necessary.  */\n+\t      b->aux = NULL;\n+\t      sbitmap_intersection_of_succs (temp_bitmap[bb],\n+\t\t\t\t\t     post_dominators, bb);\n+\t    }\n+\n+\t  /* Make sure each block always post dominates itself.  */\n \t  SET_BIT (temp_bitmap[bb], bb);\n \n \t  /* If the out state of this block changed, then we need to"}]}