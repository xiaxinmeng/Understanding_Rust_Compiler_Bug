{"sha": "ffb419d6a46302126944066ef46bd0c9f590ee30", "node_id": "C_kwDOANBUbNoAKGZmYjQxOWQ2YTQ2MzAyMTI2OTQ0MDY2ZWY0NmJkMGM5ZjU5MGVlMzA", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-07-29T13:29:51Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-04T14:48:36Z"}, "message": "Refactor the autoderef cycle to be a reuseable base class\n\nThe autoderef cycle is used to coerce/select apropriate methods during\nmethod resolution. This same cycle of autoderef is also used as coercion\nsites. In order to avoid duplicating the logic this extracts out a useful\nbase class that can be implemented to support this elsewhere.", "tree": {"sha": "7e6e1bbe1074e8dd8288e5312f8608ba487b40e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e6e1bbe1074e8dd8288e5312f8608ba487b40e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffb419d6a46302126944066ef46bd0c9f590ee30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb419d6a46302126944066ef46bd0c9f590ee30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffb419d6a46302126944066ef46bd0c9f590ee30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb419d6a46302126944066ef46bd0c9f590ee30/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c788a806195f326a595cd15b96c59e7584927f1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c788a806195f326a595cd15b96c59e7584927f1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c788a806195f326a595cd15b96c59e7584927f1a"}], "stats": {"total": 363, "additions": 197, "deletions": 166}, "files": [{"sha": "0025e7ef80dde72e6b5d25d657a5b5f611ed1a49", "filename": "gcc/rust/typecheck/rust-autoderef.cc", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb419d6a46302126944066ef46bd0c9f590ee30/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb419d6a46302126944066ef46bd0c9f590ee30/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc?ref=ffb419d6a46302126944066ef46bd0c9f590ee30", "patch": "@@ -268,5 +268,129 @@ resolve_operator_overload_fn (\n   return true;\n }\n \n+AutoderefCycle::AutoderefCycle (bool autoderef_flag)\n+  : autoderef_flag (autoderef_flag)\n+{}\n+\n+AutoderefCycle::~AutoderefCycle () {}\n+\n+void\n+AutoderefCycle::try_hook (const TyTy::BaseType &)\n+{}\n+\n+bool\n+AutoderefCycle::cycle (const TyTy::BaseType *receiver)\n+{\n+  const TyTy::BaseType *r = receiver;\n+  while (true)\n+    {\n+      if (try_autoderefed (r))\n+\treturn true;\n+\n+      // 4. deref to to 1, if cannot deref then quit\n+      if (autoderef_flag)\n+\treturn false;\n+\n+      // try unsize\n+      Adjustment unsize = Adjuster::try_unsize_type (r);\n+      if (!unsize.is_error ())\n+\t{\n+\t  adjustments.push_back (unsize);\n+\t  auto unsize_r = unsize.get_expected ();\n+\n+\t  if (try_autoderefed (unsize_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      Adjustment deref\n+\t= Adjuster::try_deref_type (r, Analysis::RustLangItem::ItemType::DEREF);\n+      if (!deref.is_error ())\n+\t{\n+\t  auto deref_r = deref.get_expected ();\n+\t  adjustments.push_back (deref);\n+\n+\t  if (try_autoderefed (deref_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      Adjustment deref_mut = Adjuster::try_deref_type (\n+\tr, Analysis::RustLangItem::ItemType::DEREF_MUT);\n+      if (!deref_mut.is_error ())\n+\t{\n+\t  auto deref_r = deref_mut.get_expected ();\n+\t  adjustments.push_back (deref_mut);\n+\n+\t  if (try_autoderefed (deref_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      if (!deref_mut.is_error ())\n+\t{\n+\t  auto deref_r = deref_mut.get_expected ();\n+\t  adjustments.push_back (deref_mut);\n+\t  Adjustment raw_deref = Adjuster::try_raw_deref_type (deref_r);\n+\t  adjustments.push_back (raw_deref);\n+\t  deref_r = raw_deref.get_expected ();\n+\n+\t  if (try_autoderefed (deref_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      if (!deref.is_error ())\n+\t{\n+\t  r = deref.get_expected ();\n+\t  adjustments.push_back (deref);\n+\t}\n+      Adjustment raw_deref = Adjuster::try_raw_deref_type (r);\n+      if (raw_deref.is_error ())\n+\treturn false;\n+\n+      r = raw_deref.get_expected ();\n+      adjustments.push_back (raw_deref);\n+    }\n+  return false;\n+}\n+\n+bool\n+AutoderefCycle::try_autoderefed (const TyTy::BaseType *r)\n+{\n+  try_hook (*r);\n+\n+  // 1. try raw\n+  if (select (*r))\n+    return true;\n+\n+  // 2. try ref\n+  TyTy::ReferenceType *r1\n+    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n+\t\t\t       Mutability::Imm);\n+  adjustments.push_back (Adjustment (Adjustment::AdjustmentType::IMM_REF, r1));\n+  if (select (*r1))\n+    return true;\n+\n+  adjustments.pop_back ();\n+\n+  // 3. try mut ref\n+  TyTy::ReferenceType *r2\n+    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n+\t\t\t       Mutability::Mut);\n+  adjustments.push_back (Adjustment (Adjustment::AdjustmentType::MUT_REF, r2));\n+  if (select (*r2))\n+    return true;\n+\n+  adjustments.pop_back ();\n+\n+  return false;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "159f4c06cbc7fce790902853535b2024a3a15c98", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb419d6a46302126944066ef46bd0c9f590ee30/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb419d6a46302126944066ef46bd0c9f590ee30/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=ffb419d6a46302126944066ef46bd0c9f590ee30", "patch": "@@ -144,6 +144,27 @@ class Adjuster\n   const TyTy::BaseType *base;\n };\n \n+class AutoderefCycle\n+{\n+protected:\n+  AutoderefCycle (bool autoderef_flag);\n+\n+  virtual ~AutoderefCycle ();\n+\n+  virtual bool select (const TyTy::BaseType &autoderefed) = 0;\n+\n+  // optional: this is a chance to hook in to grab predicate items on the raw\n+  // type\n+  virtual void try_hook (const TyTy::BaseType &);\n+\n+  bool cycle (const TyTy::BaseType *receiver);\n+\n+  bool try_autoderefed (const TyTy::BaseType *r);\n+\n+  bool autoderef_flag;\n+  std::vector<Adjustment> adjustments;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "d45f09034781f3b7c18696f0c621b1a059e4c1a7", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.cc", "status": "modified", "additions": 32, "deletions": 145, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb419d6a46302126944066ef46bd0c9f590ee30/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb419d6a46302126944066ef46bd0c9f590ee30/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc?ref=ffb419d6a46302126944066ef46bd0c9f590ee30", "patch": "@@ -23,151 +23,32 @@\n namespace Rust {\n namespace Resolver {\n \n+MethodResolver::MethodResolver (bool autoderef_flag,\n+\t\t\t\tconst HIR::PathIdentSegment &segment_name)\n+  : AutoderefCycle (autoderef_flag), mappings (Analysis::Mappings::get ()),\n+    context (TypeCheckContext::get ()), segment_name (segment_name),\n+    try_result (MethodCandidate::get_error ())\n+{}\n+\n MethodCandidate\n MethodResolver::Probe (const TyTy::BaseType *receiver,\n \t\t       const HIR::PathIdentSegment &segment_name,\n \t\t       bool autoderef_flag)\n {\n-  const TyTy::BaseType *r = receiver;\n-  std::vector<Adjustment> adjustments;\n-  while (true)\n-    {\n-      auto res = Try (r, segment_name, adjustments);\n-      if (!res.is_error ())\n-\treturn res;\n-\n-      // 4. deref to to 1, if cannot deref then quit\n-      if (autoderef_flag)\n-\treturn MethodCandidate::get_error ();\n-\n-      // try unsize\n-      Adjustment unsize = Adjuster::try_unsize_type (r);\n-      if (!unsize.is_error ())\n-\t{\n-\t  adjustments.push_back (unsize);\n-\t  auto unsize_r = unsize.get_expected ();\n-\t  auto res = Try (unsize_r, segment_name, adjustments);\n-\t  if (!res.is_error ())\n-\t    {\n-\t      return res;\n-\t    }\n-\n-\t  adjustments.pop_back ();\n-\t}\n-\n-      Adjustment deref\n-\t= Adjuster::try_deref_type (r, Analysis::RustLangItem::ItemType::DEREF);\n-      if (!deref.is_error ())\n-\t{\n-\t  auto deref_r = deref.get_expected ();\n-\t  adjustments.push_back (deref);\n-\t  auto res = Try (deref_r, segment_name, adjustments);\n-\t  if (!res.is_error ())\n-\t    {\n-\t      return res;\n-\t    }\n-\n-\t  adjustments.pop_back ();\n-\t}\n-\n-      Adjustment deref_mut = Adjuster::try_deref_type (\n-\tr, Analysis::RustLangItem::ItemType::DEREF_MUT);\n-      if (!deref_mut.is_error ())\n-\t{\n-\t  auto deref_r = deref_mut.get_expected ();\n-\t  adjustments.push_back (deref_mut);\n-\t  auto res = Try (deref_r, segment_name, adjustments);\n-\t  if (!res.is_error ())\n-\t    {\n-\t      return res;\n-\t    }\n-\n-\t  adjustments.pop_back ();\n-\t}\n-\n-      if (!deref_mut.is_error ())\n-\t{\n-\t  auto deref_r = deref_mut.get_expected ();\n-\t  adjustments.push_back (deref_mut);\n-\t  Adjustment raw_deref = Adjuster::try_raw_deref_type (deref_r);\n-\t  adjustments.push_back (raw_deref);\n-\t  deref_r = raw_deref.get_expected ();\n-\n-\t  auto res = Try (deref_r, segment_name, adjustments);\n-\t  if (!res.is_error ())\n-\t    {\n-\t      return res;\n-\t    }\n-\n-\t  adjustments.pop_back ();\n-\t  adjustments.pop_back ();\n-\t}\n-\n-      if (!deref.is_error ())\n-\t{\n-\t  r = deref.get_expected ();\n-\t  adjustments.push_back (deref);\n-\t}\n-      Adjustment raw_deref = Adjuster::try_raw_deref_type (r);\n-      if (raw_deref.is_error ())\n-\treturn MethodCandidate::get_error ();\n-\n-      r = raw_deref.get_expected ();\n-      adjustments.push_back (raw_deref);\n-    }\n-  return MethodCandidate::get_error ();\n+  MethodResolver resolver (autoderef_flag, segment_name);\n+  bool ok = resolver.cycle (receiver);\n+  return ok ? resolver.try_result : MethodCandidate::get_error ();\n }\n \n-MethodCandidate\n-MethodResolver::Try (const TyTy::BaseType *r,\n-\t\t     const HIR::PathIdentSegment &segment_name,\n-\t\t     std::vector<Adjustment> &adjustments)\n+void\n+MethodResolver::try_hook (const TyTy::BaseType &r)\n {\n-  PathProbeCandidate c = PathProbeCandidate::get_error ();\n-  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds\n-    = r->get_specified_bounds ();\n-  const std::vector<MethodResolver::predicate_candidate> predicate_items\n-    = get_predicate_items (segment_name, *r, specified_bounds);\n-\n-  // 1. try raw\n-  MethodResolver raw (*r, segment_name, predicate_items);\n-  c = raw.select ();\n-  if (!c.is_error ())\n-    {\n-      return MethodCandidate{c, adjustments};\n-    }\n-\n-  // 2. try ref\n-  TyTy::ReferenceType *r1\n-    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n-\t\t\t       Mutability::Imm);\n-  MethodResolver imm_ref (*r1, segment_name, predicate_items);\n-  c = imm_ref.select ();\n-  if (!c.is_error ())\n-    {\n-      adjustments.push_back (\n-\tAdjustment (Adjustment::AdjustmentType::IMM_REF, r1));\n-      return MethodCandidate{c, adjustments};\n-    }\n-\n-  // 3. try mut ref\n-  TyTy::ReferenceType *r2\n-    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n-\t\t\t       Mutability::Mut);\n-  MethodResolver mut_ref (*r2, segment_name, predicate_items);\n-  c = mut_ref.select ();\n-  if (!c.is_error ())\n-    {\n-      adjustments.push_back (\n-\tAdjustment (Adjustment::AdjustmentType::MUT_REF, r2));\n-      return MethodCandidate{c, adjustments};\n-    }\n-\n-  return MethodCandidate::get_error ();\n+  const auto &specified_bounds = r.get_specified_bounds ();\n+  predicate_items = get_predicate_items (segment_name, r, specified_bounds);\n }\n \n-PathProbeCandidate\n-MethodResolver::select ()\n+bool\n+MethodResolver::select (const TyTy::BaseType &receiver)\n {\n   struct impl_item_candidate\n   {\n@@ -300,9 +181,11 @@ MethodResolver::select ()\n \t{\n \t  PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n \t\t\t\t\t\t  impl_item.impl_block};\n-\t  return PathProbeCandidate (\n-\t    PathProbeCandidate::CandidateType::IMPL_FUNC, fn,\n-\t    impl_item.item->get_locus (), c);\n+\t  try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::IMPL_FUNC,\n+\t\t\t\tfn, impl_item.item->get_locus (), c),\n+\t    adjustments};\n+\t  return true;\n \t}\n     }\n \n@@ -317,9 +200,11 @@ MethodResolver::select ()\n \t  PathProbeCandidate::TraitItemCandidate c{trait_item.reference,\n \t\t\t\t\t\t   trait_item.item_ref,\n \t\t\t\t\t\t   nullptr};\n-\t  return PathProbeCandidate (\n-\t    PathProbeCandidate::CandidateType::TRAIT_FUNC, fn,\n-\t    trait_item.item->get_locus (), c);\n+\t  try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n+\t\t\t\tfn, trait_item.item->get_locus (), c),\n+\t    adjustments};\n+\t  return true;\n \t}\n     }\n \n@@ -338,13 +223,15 @@ MethodResolver::select ()\n \n \t  PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n \t\t\t\t\t\t   nullptr};\n-\t  return PathProbeCandidate (\n-\t    PathProbeCandidate::CandidateType::TRAIT_FUNC, fn->clone (),\n-\t    trait_item->get_locus (), c);\n+\t  try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n+\t\t\t\tfn->clone (), trait_item->get_locus (), c),\n+\t    adjustments};\n+\t  return true;\n \t}\n     }\n \n-  return PathProbeCandidate::get_error ();\n+  return false;\n }\n \n std::vector<MethodResolver::predicate_candidate>"}, {"sha": "750601a2d9e6a583786eabfc75b6e7581a3efa36", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb419d6a46302126944066ef46bd0c9f590ee30/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb419d6a46302126944066ef46bd0c9f590ee30/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=ffb419d6a46302126944066ef46bd0c9f590ee30", "patch": "@@ -37,43 +37,42 @@ struct MethodCandidate\n   bool is_error () const { return candidate.is_error (); }\n };\n \n-class MethodResolver : public TypeCheckBase\n+class MethodResolver : protected AutoderefCycle\n {\n-protected:\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n public:\n-  static MethodCandidate Probe (const TyTy::BaseType *receiver,\n-\t\t\t\tconst HIR::PathIdentSegment &segment_name,\n-\t\t\t\tbool autoderef_flag = false);\n-\n-protected:\n   struct predicate_candidate\n   {\n     TyTy::TypeBoundPredicateItem lookup;\n     TyTy::FnType *fntype;\n   };\n \n-  static MethodCandidate Try (const TyTy::BaseType *r,\n-\t\t\t      const HIR::PathIdentSegment &segment_name,\n-\t\t\t      std::vector<Adjustment> &adjustments);\n+  static MethodCandidate Probe (const TyTy::BaseType *receiver,\n+\t\t\t\tconst HIR::PathIdentSegment &segment_name,\n+\t\t\t\tbool autoderef_flag = false);\n \n   static std::vector<predicate_candidate> get_predicate_items (\n     const HIR::PathIdentSegment &segment_name, const TyTy::BaseType &receiver,\n     const std::vector<TyTy::TypeBoundPredicate> &specified_bounds);\n \n-  PathProbeCandidate select ();\n+protected:\n+  MethodResolver (bool autoderef_flag,\n+\t\t  const HIR::PathIdentSegment &segment_name);\n \n-  MethodResolver (\n-    const TyTy::BaseType &receiver, const HIR::PathIdentSegment &segment_name,\n-    const std::vector<MethodResolver::predicate_candidate> &predicate_items)\n-    : receiver (receiver), segment_name (segment_name),\n-      predicate_items (predicate_items)\n-  {}\n+  void try_hook (const TyTy::BaseType &r) override;\n \n-  const TyTy::BaseType &receiver;\n+  bool select (const TyTy::BaseType &receiver) override;\n+\n+private:\n+  // context info\n+  Analysis::Mappings *mappings;\n+  TypeCheckContext *context;\n+\n+  // search\n   const HIR::PathIdentSegment &segment_name;\n-  const std::vector<MethodResolver::predicate_candidate> &predicate_items;\n+  std::vector<MethodResolver::predicate_candidate> predicate_items;\n+\n+  // mutable fields\n+  MethodCandidate try_result;\n };\n \n } // namespace Resolver"}]}