{"sha": "d7a2940444f631047d220da22884d19c69984aaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdhMjk0MDQ0NGY2MzEwNDdkMjIwZGEyMjg4NGQxOWM2OTk4NGFhZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "2000-01-04T14:44:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-01-04T14:44:03Z"}, "message": "i386.c (ix86_expand_move): Allow pushes of memory, offload to memory all FP constants for constant->reg moves.\n\n\t* i386.c (ix86_expand_move): Allow pushes of memory, offload to memory\n\tall FP constants for constant->reg moves.\n\t(ix86_split_to_parts): Try to convert memory address into immediate\n\twhen available in the constant pool.\n\t* i386.h (PREFERRED_RELOAD_CLASS): Allow CONST_DOUBLE->integer reg\n\tmoves.\n\t(LEGITIMATE_CONSTANT_P): Return 1.\n\t* i386.md (pushsf): New splitter to convert constant pool memory\n\treference to immediate.\n\t(mov?f): Likewise; do not allow CONST_DOUBLE for reg moves before\n\treload.\n\nFrom-SVN: r31203", "tree": {"sha": "6e0eb21d8b3748e75a902332e47aa2b50ede898a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e0eb21d8b3748e75a902332e47aa2b50ede898a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7a2940444f631047d220da22884d19c69984aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a2940444f631047d220da22884d19c69984aaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7a2940444f631047d220da22884d19c69984aaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a2940444f631047d220da22884d19c69984aaf/comments", "author": null, "committer": null, "parents": [{"sha": "28cefcd2b6d1d5c7a7683f8c72def31fcc30b89e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28cefcd2b6d1d5c7a7683f8c72def31fcc30b89e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28cefcd2b6d1d5c7a7683f8c72def31fcc30b89e"}], "stats": {"total": 150, "additions": 119, "deletions": 31}, "files": [{"sha": "a879274928867a920d463ad8481118e0eb58b4f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a2940444f631047d220da22884d19c69984aaf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a2940444f631047d220da22884d19c69984aaf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7a2940444f631047d220da22884d19c69984aaf", "patch": "@@ -1,3 +1,17 @@\n+Tue Jan  4 15:34:34 MET 2000  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* i386.c (ix86_expand_move): Allow pushes of memory, offload to memory\n+\tall FP constants for constant->reg moves.\n+\t(ix86_split_to_parts): Try to convert memory address into immediate\n+\twhen available in the constant pool.\n+\t* i386.h (PREFERRED_RELOAD_CLASS): Allow CONST_DOUBLE->integer reg\n+\tmoves.\n+\t(LEGITIMATE_CONSTANT_P): Return 1.\n+\t* i386.md (pushsf): New splitter to convert constant pool memory\n+\treference to immediate.\n+\t(mov?f): Likewise; do not allow CONST_DOUBLE for reg moves before\n+\treload.\n+\n 2000-01-04  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* i386.md (ashlsi3_cmpno): Don't accept variables shifts."}, {"sha": "47460f0bd602fe6e504672365e4c6914a33eec26", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a2940444f631047d220da22884d19c69984aaf/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a2940444f631047d220da22884d19c69984aaf/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d7a2940444f631047d220da22884d19c69984aaf", "patch": "@@ -3690,21 +3690,22 @@ ix86_expand_move (mode, operands)\n     }\n   else\n     {\n-      if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+      if (GET_CODE (operands[0]) == MEM\n+\t  && (GET_MODE (operands[0]) == QImode\n+\t      || !push_operand (operands[0], mode))\n+\t  && GET_CODE (operands[1]) == MEM)\n \toperands[1] = force_reg (mode, operands[1]);\n \n       if (FLOAT_MODE_P (mode))\n \t{\n-\t  /* If we are loading a floating point constant that isn't 0 or 1\n-\t     into a register, force the value to memory now, since we'll \n-\t     get better code out the back end.  */\n+\t  /* If we are loading a floating point constant to a register,\n+\t     force the value to memory now, since we'll get better code\n+\t     out the back end.  */\n \n \t  if (strict)\n \t    ;\n-\t  else if (GET_CODE (operands[0]) == MEM)\n-\t    operands[1] = force_reg (mode, operands[1]);\n \t  else if (GET_CODE (operands[1]) == CONST_DOUBLE\n-\t\t   && ! standard_80387_constant_p (operands[1]))\n+\t\t   && register_operand (operands[0], mode))\n \t    operands[1] = validize_mem (force_const_mem (mode, operands[1]));\n \t}\n     }\n@@ -4759,6 +4760,14 @@ ix86_split_to_parts (operand, parts, mode)\n   if (size < 2 || size > 3)\n     abort ();\n \n+  /* Optimize constant pool reference to immediates.  This is used by fp moves,\n+     that force all constants to memory to allow combining.  */\n+\n+  if (GET_CODE (operand) == MEM\n+      && GET_CODE (XEXP (operand, 0)) == SYMBOL_REF\n+      && CONSTANT_POOL_ADDRESS_P (XEXP (operand, 0)))\n+    operand = get_pool_constant (XEXP (operand, 0));\n+\n   if (GET_CODE (operand) == MEM && !offsettable_memref_p (operand))\n     {\n       /* The only non-offsetable memories we handle are pushes.  */"}, {"sha": "7d5fd2916d5cd9216ad06d1921cb6fb689b4275c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a2940444f631047d220da22884d19c69984aaf/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a2940444f631047d220da22884d19c69984aaf/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d7a2940444f631047d220da22884d19c69984aaf", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler for IA-32.\n-   Copyright (C) 1988, 92, 94-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 92, 94-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1004,11 +1004,11 @@ enum reg_class\n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n   (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != VOIDmode\t\t\\\n    ? (standard_80387_constant_p (X)\t\t\t\t\t\\\n-      ? reg_class_subset_p (CLASS, FLOAT_REGS) ? CLASS : FLOAT_REGS\t\\\n-      : NO_REGS)\t\t\t\t\t\t\t\\\n+      ? CLASS\t\t\t\t\t\t\t\t\\\n+      : (reg_class_subset_p (CLASS, FLOAT_REGS) \t\t\t\\\n+\t ? NO_REGS\t\t\t\t\t\t\t\\\n+\t : reg_class_subset_p (CLASS, GENERAL_REGS) ? CLASS : GENERAL_REGS)) \\\n    : GET_MODE (X) == QImode && ! reg_class_subset_p (CLASS, Q_REGS) ? Q_REGS \\\n-   : ((CLASS) == ALL_REGS\t\t\t\t\t\t\\\n-      && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT) ? GENERAL_REGS\t\\\n    : (CLASS))\n \n /* If we are copying between general and FP registers, we need a memory\n@@ -1525,8 +1525,7 @@ do {\t\t\t\t\t\t\t\t\\\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-#define LEGITIMATE_CONSTANT_P(X) \\\n-  (GET_CODE (X) == CONST_DOUBLE ? standard_80387_constant_p (X) : 1)\n+#define LEGITIMATE_CONSTANT_P(X) 1\n \n #ifdef REG_OK_STRICT\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\"}, {"sha": "3addccbbdd212be2cf146546176377d0fd704aa1", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 83, "deletions": 17, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a2940444f631047d220da22884d19c69984aaf/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a2940444f631047d220da22884d19c69984aaf/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d7a2940444f631047d220da22884d19c69984aaf", "patch": "@@ -1662,7 +1662,7 @@\n \n (define_insn \"*pushdi\"\n   [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n-\t(match_operand:DI 1 \"nonmemory_operand\" \"riF\"))]\n+\t(match_operand:DI 1 \"general_operand\" \"riF*m\"))]\n   \"\"\n   \"#\")\n \n@@ -1721,6 +1721,18 @@\n }\"\n   [(set_attr \"type\" \"multi,push\")])\n \n+(define_split\n+  [(set (match_operand:SF 0 \"push_operand\" \"\")\n+\t(match_operand:SF 1 \"memory_operand\" \"\"))]\n+  \"reload_completed\n+   && GET_CODE (operands[1]) == MEM\n+   && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+   && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0))\"\n+  [(set (match_dup 0)\n+\t(match_dup 1))]\n+  \"operands[1] = get_pool_constant (XEXP (operands[1], 0));\")\n+\n+\n ;; %%% Kill this when call knows how to work this out.\n (define_split\n   [(set (match_operand:SF 0 \"push_operand\" \"\")\n@@ -1732,7 +1744,10 @@\n (define_insn \"*movsf_1\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,m\")\n \t(match_operand:SF 1 \"general_operand\" \"fm#r,f#r,G,rmF#f,Fr#f\"))]\n-  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+  \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && (reload_in_progress || reload_completed\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], SFmode))\" \n   \"*\n {\n   switch (which_alternative)\n@@ -1772,6 +1787,21 @@\n }\"\n   [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov\")])\n \n+(define_split\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"memory_operand\" \"\"))]\n+  \"reload_completed\n+   && GET_CODE (operands[1]) == MEM\n+   && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+   && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0))\n+   && (!(FP_REG_P (operands[0]) || \n+\t (GET_CODE (operands[0]) == SUBREG\n+\t  && FP_REG_P (SUBREG_REG (operands[0]))))\n+       || standard_80387_constant_p (get_pool_constant (XEXP (operands[1], 0))))\"\n+  [(set (match_dup 0)\n+\t(match_dup 1))]\n+  \"operands[1] = get_pool_constant (XEXP (operands[1], 0));\")\n+\n (define_insn \"swapsf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"+f\")\n \t(match_operand:SF 1 \"register_operand\" \"+f\"))\n@@ -1849,7 +1879,10 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n \t(match_operand:DF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n-   && optimize_size\"\n+   && optimize_size\n+   && (reload_in_progress || reload_completed\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], DFmode))\" \n   \"*\n {\n   switch (which_alternative)\n@@ -1893,7 +1926,10 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,o\")\n \t(match_operand:DF 1 \"general_operand\" \"fm#r,f#r,G,roF#f,Fr#f\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n-   && !optimize_size\"\n+   && !optimize_size\n+   && (reload_in_progress || reload_completed\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], DFmode))\" \n   \"*\n {\n   switch (which_alternative)\n@@ -1948,6 +1984,18 @@\n    (set (match_dup 3) (match_dup 6))]\n   \"if (ix86_split_long_move (operands)) DONE;\")\n \n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(match_operand:DF 1 \"memory_operand\" \"\"))]\n+  \"reload_completed\n+   && GET_CODE (operands[1]) == MEM\n+   && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+   && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0))\n+   && standard_80387_constant_p (get_pool_constant (XEXP (operands[1], 0)))\"\n+  [(set (match_dup 0)\n+\t(match_dup 1))]\n+  \"operands[1] = get_pool_constant (XEXP (operands[1], 0));\")\n+\n (define_insn \"swapdf\"\n   [(set (match_operand:DF 0 \"register_operand\" \"+f\")\n \t(match_operand:DF 1 \"register_operand\" \"+f\"))\n@@ -2051,7 +2099,10 @@\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n \t(match_operand:XF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n-   && optimize_size\"\n+   && optimize_size\n+   && (reload_in_progress || reload_completed\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], XFmode))\" \n   \"*\n {\n   switch (which_alternative)\n@@ -2094,7 +2145,10 @@\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,o\")\n \t(match_operand:XF 1 \"general_operand\" \"fm#r,f#r,G,roF#f,Fr#f\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n-   && !optimize_size\"\n+   && !optimize_size\n+   && (reload_in_progress || reload_completed\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], XFmode))\" \n   \"*\n {\n   switch (which_alternative)\n@@ -2149,6 +2203,18 @@\n    (set (match_dup 4) (match_dup 7))]\n   \"if (ix86_split_long_move (operands)) DONE;\")\n \n+(define_split\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n+\t(match_operand:XF 1 \"memory_operand\" \"\"))]\n+  \"reload_completed\n+   && GET_CODE (operands[1]) == MEM\n+   && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+   && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0))\n+   && standard_80387_constant_p (get_pool_constant (XEXP (operands[1], 0)))\"\n+  [(set (match_dup 0)\n+\t(match_dup 1))]\n+  \"operands[1] = get_pool_constant (XEXP (operands[1], 0));\")\n+\n (define_insn \"swapxf\"\n   [(set (match_operand:XF 0 \"register_operand\" \"+f\")\n \t(match_operand:XF 1 \"register_operand\" \"+f\"))\n@@ -2380,7 +2446,7 @@\n \t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))\n    (clobber (reg:CC 17))]\n-  \"(flow2_completed\n+  \"(reload_completed\n     && dead_or_set_p (insn, operands[1])\n     && !reg_mentioned_p (operands[1], operands[0]))\"\n   [(set (match_dup 3) (match_dup 1))\n@@ -2395,7 +2461,7 @@\n \t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))\n    (clobber (reg:CC 17))]\n-  \"flow2_completed\"\n+  \"reload_completed\"\n   [(const_int 0)]\n   \"\n {\n@@ -3119,7 +3185,7 @@\n \t(plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n \t\t (match_operand:DI 2 \"general_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"cse_not_expected\"\n+  \"reload_completed\"\n   [(parallel [(set (reg:CC 17) (plus:CC (match_dup 1) (match_dup 2)))\n \t      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])\n    (parallel [(set (match_dup 3)\n@@ -3620,7 +3686,7 @@\n \t(minus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n \t\t  (match_operand:DI 2 \"general_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"cse_not_expected\"\n+  \"reload_completed\"\n   [(parallel [(set (reg:CC 17) (minus:CC (match_dup 1) (match_dup 2)))\n \t      (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))])\n    (parallel [(set (match_dup 3)\n@@ -4798,7 +4864,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(neg:DI (match_operand:DI 1 \"general_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"cse_not_expected\"\n+  \"reload_completed\"\n   [(parallel\n     [(set (reg:CCNO 17)\n \t  (compare:CCNO (neg:SI (match_dup 2)) (const_int 0)))\n@@ -5458,7 +5524,7 @@\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (match_scratch:SI 3 \"\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_CMOVE && cse_not_expected\"\n+  \"TARGET_CMOVE && reload_completed\"\n   [(const_int 0)]\n   \"ix86_split_ashldi (operands, operands[3]); DONE;\")\n \n@@ -5467,7 +5533,7 @@\n \t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"cse_not_expected\"\n+  \"reload_completed\"\n   [(const_int 0)]\n   \"ix86_split_ashldi (operands, NULL_RTX); DONE;\")\n \n@@ -5842,7 +5908,7 @@\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (match_scratch:SI 3 \"\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_CMOVE && cse_not_expected\"\n+  \"TARGET_CMOVE && reload_completed\"\n   [(const_int 0)]\n   \"ix86_split_ashrdi (operands, operands[3]); DONE;\")\n \n@@ -5851,7 +5917,7 @@\n \t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"cse_not_expected\"\n+  \"reload_completed\"\n   [(const_int 0)]\n   \"ix86_split_ashrdi (operands, NULL_RTX); DONE;\")\n \n@@ -6062,7 +6128,7 @@\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (match_scratch:SI 3 \"\"))\n    (clobber (reg:CC 17))]\n-  \"TARGET_CMOVE && cse_not_expected\"\n+  \"TARGET_CMOVE && reload_completed\"\n   [(const_int 0)]\n   \"ix86_split_lshrdi (operands, operands[3]); DONE;\")\n \n@@ -6071,7 +6137,7 @@\n \t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"cse_not_expected\"\n+  \"reload_completed\"\n   [(const_int 0)]\n   \"ix86_split_lshrdi (operands, NULL_RTX); DONE;\")\n "}]}