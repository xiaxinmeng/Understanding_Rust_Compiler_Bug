{"sha": "1afbe1c4e6d0d9a4b09d942892fe45114ada158c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFmYmUxYzRlNmQwZDlhNGIwOWQ5NDI4OTJmZTQ1MTE0YWRhMTU4Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-02-01T20:03:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-02-01T20:03:23Z"}, "message": "recog.c (check_asm_operands): Treat indeterminate operand ok results as success.\n\n        * recog.c (check_asm_operands): Treat indeterminate operand ok\n        results as success.  Try harder to resolve a matching constraint.\n        * stmt.c (expand_asm_operands): Recognize when an output operand's\n        constraint does not allow memory.  Treat indeterminate operand ok\n        results as failure.  Try harder to resolve a matching constraint.\n\nFrom-SVN: r24959", "tree": {"sha": "4ad9c160c4fe69d4a35626cadecaf2682d7d73f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ad9c160c4fe69d4a35626cadecaf2682d7d73f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1afbe1c4e6d0d9a4b09d942892fe45114ada158c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1afbe1c4e6d0d9a4b09d942892fe45114ada158c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1afbe1c4e6d0d9a4b09d942892fe45114ada158c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1afbe1c4e6d0d9a4b09d942892fe45114ada158c/comments", "author": null, "committer": null, "parents": [{"sha": "5326f06d7f73eae07a3c8825873f7a2358dfa0e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5326f06d7f73eae07a3c8825873f7a2358dfa0e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5326f06d7f73eae07a3c8825873f7a2358dfa0e2"}], "stats": {"total": 73, "additions": 59, "deletions": 14}, "files": [{"sha": "89fd8ab40dc0ca8090d7c2e72fda2a66b9d8f6d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1afbe1c4e6d0d9a4b09d942892fe45114ada158c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1afbe1c4e6d0d9a4b09d942892fe45114ada158c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1afbe1c4e6d0d9a4b09d942892fe45114ada158c", "patch": "@@ -1,3 +1,11 @@\n+Mon Feb  1 20:00:40 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* recog.c (check_asm_operands): Treat indeterminate operand ok\n+\tresults as success.  Try harder to resolve a matching constraint.\n+\t* stmt.c (expand_asm_operands): Recognize when an output operand's\n+\tconstraint does not allow memory.  Treat indeterminate operand ok\n+\tresults as failure.  Try harder to resolve a matching constraint.\n+\t\n Mon Feb  1 15:00:02 1999  Ken Raeburn  <raeburn@cygnus.com>\n \n \tUse varrays for constant-equivalence data:"}, {"sha": "c62929c49386c4ad63aea1311e08cedb15b40825", "filename": "gcc/recog.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1afbe1c4e6d0d9a4b09d942892fe45114ada158c/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1afbe1c4e6d0d9a4b09d942892fe45114ada158c/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=1afbe1c4e6d0d9a4b09d942892fe45114ada158c", "patch": "@@ -188,7 +188,9 @@ check_asm_operands (x)\n   for (i = 0; i < noperands; i++)\n     {\n       const char *c = constraints[i];\n-      if (ISDIGIT ((unsigned char)c[0]))\n+      if (c[0] == '%')\n+\tc++;\n+      if (ISDIGIT ((unsigned char)c[0]) && c[1] == '\\0')\n \tc = constraints[c[0] - '0'];\n \n       if (! asm_operand_ok (operands[i], c))\n@@ -1550,13 +1552,16 @@ decode_asm_operands (body, operands, operand_locs, constraints, modes)\n   return template;\n }\n \n-/* Check if an asm_operand matches it's constraints.  */\n+/* Check if an asm_operand matches it's constraints. \n+   Return > 0 if ok, = 0 if bad, < 0 if inconclusive.  */\n \n int\n asm_operand_ok (op, constraint)\n      rtx op;\n      const char *constraint;\n {\n+  int result = 0;\n+\n   /* Use constrain_operands after reload.  */\n   if (reload_completed)\n     abort ();\n@@ -1578,9 +1583,11 @@ asm_operand_ok (op, constraint)\n \n \tcase '0': case '1': case '2': case '3': case '4':\n \tcase '5': case '6': case '7': case '8': case '9':\n-\t  /* Our caller is supposed to have given us the proper\n-\t     matching constraint.  */\n-\t  /* abort (); */\n+\t  /* For best results, our caller should have given us the\n+\t     proper matching constraint, but we can't actually fail\n+\t     the check if they didn't.  Indicate that results are\n+\t     inconclusive.  */\n+\t  result = -1;\n \t  break;\n \n \tcase 'p':\n@@ -1600,15 +1607,24 @@ asm_operand_ok (op, constraint)\n \t  break;\n \n \tcase '<':\n+\t  /* ??? Before flow, auto inc/dec insns are not supposed to exist,\n+\t     excepting those that expand_call created.  Further, on some\n+\t     machines which do not have generalized auto inc/dec, an inc/dec\n+\t     is not a memory_operand.\n+\n+\t     Match any memory and hope things are resolved after reload.  */\n+\n \t  if (GET_CODE (op) == MEM\n-\t      && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t      && (1\n+\t\t  || GET_CODE (XEXP (op, 0)) == PRE_DEC\n                   || GET_CODE (XEXP (op, 0)) == POST_DEC))\n \t    return 1;\n \t  break;\n \n \tcase '>':\n \t  if (GET_CODE (op) == MEM\n-\t      && (GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t      && (1\n+\t\t  || GET_CODE (XEXP (op, 0)) == PRE_INC\n                   || GET_CODE (XEXP (op, 0)) == POST_INC))\n \t    return 1;\n \t  break;\n@@ -1745,7 +1761,7 @@ asm_operand_ok (op, constraint)\n \t}\n     }\n \n-  return 0;\n+  return result;\n }\n \f\n /* Given an rtx *P, if it is a sum containing an integer constant term,"}, {"sha": "ab7a5cfdd21e13043fd2f3f88ef0c2163799ae86", "filename": "gcc/stmt.c", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1afbe1c4e6d0d9a4b09d942892fe45114ada158c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1afbe1c4e6d0d9a4b09d942892fe45114ada158c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1afbe1c4e6d0d9a4b09d942892fe45114ada158c", "patch": "@@ -1251,6 +1251,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       int j;\n       int is_inout = 0;\n       int allows_reg = 0;\n+      int allows_mem = 0;\n \n       /* If there's an erroneous arg, emit no insn.  */\n       if (TREE_TYPE (val) == error_mark_node)\n@@ -1316,8 +1317,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t    break;\n \n \t  case '?':  case '!':  case '*':  case '&':\n-\t  case 'V':  case 'm':  case 'o':  case '<':  case '>':\n-\t  case 'E':  case 'F':  case 'G':  case 'H':  case 'X':\n+\t  case 'E':  case 'F':  case 'G':  case 'H':\n \t  case 's':  case 'i':  case 'n':\n \t  case 'I':  case 'J':  case 'K':  case 'L':  case 'M':\n \t  case 'N':  case 'O':  case 'P':  case ',':\n@@ -1331,7 +1331,23 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t    error (\"matching constraint not valid in output operand\");\n \t    break;\n \n-\t  case 'p':  case 'g':  case 'r':\n+\t  case 'V':  case 'm':  case 'o':\n+\t    allows_mem = 1;\n+\t    break;\n+\n+\t  case '<':  case '>':\n+          /* ??? Before flow, auto inc/dec insns are not supposed to exist,\n+             excepting those that expand_call created.  So match memory\n+\t     and hope.  */\n+\t    allows_mem = 1;\n+\t    break;\n+\n+\t  case 'g':  case 'X':\n+\t    allows_reg = 1;\n+\t    allows_mem = 1;\n+\t    break;\n+\n+\t  case 'p': case 'r':\n \t  default:\n \t    allows_reg = 1;\n \t    break;\n@@ -1342,8 +1358,10 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t Make the asm insn write into that, then our caller will copy it to\n \t the real output operand.  Likewise for promoted variables.  */\n \n-      if (TREE_CODE (val) == INDIRECT_REF\n+      if ((TREE_CODE (val) == INDIRECT_REF\n+\t   && allows_mem)\n \t  || (TREE_CODE_CLASS (TREE_CODE (val)) == 'd'\n+\t      && (allows_mem || GET_CODE (DECL_RTL (val)) == REG)\n \t      && ! (GET_CODE (DECL_RTL (val)) == REG\n \t\t    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))\n \t  || ! allows_reg\n@@ -1358,6 +1376,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n \t  if (! allows_reg && GET_CODE (output_rtx[i]) != MEM)\n \t    error (\"output number %d not directly addressable\", i);\n+\t  if (! allows_mem && GET_CODE (output_rtx[i]) == MEM)\n+\t    error (\"output number %d not restored to memory\", i);\n \t}\n       else\n \t{\n@@ -1472,7 +1492,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t      }\n \n \t    /* Try and find the real constraint for this dup.  */\n-\t    if (j == 0 && c_len == 1)\n+\t    if ((j == 0 && c_len == 1)\n+\t\t|| (j == 1 && c_len == 2 && constraint[0] == '%'))\n \t      {\n \t\ttree o = outputs;\n \t\tfor (j = constraint[j] - '0'; j > 0; --j)\n@@ -1502,7 +1523,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n       op = expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode, 0);\n \n-      if (! asm_operand_ok (op, constraint))\n+      if (asm_operand_ok (op, constraint) <= 0)\n \t{\n \t  if (allows_reg)\n \t    op = force_reg (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))), op);"}]}