{"sha": "cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FjYmQ1MzI3MGMyY2QzZjY3ZDFlM2M3MmFkMGY3YjViZjViYTEyNA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-06-06T23:02:02Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-06-06T23:02:02Z"}, "message": "(expand_call): Handle NIL in PARALLEL.\n\n(expand_call): Handle NIL in PARALLEL.  Handle PARALLEL\nparameter in REG.  Handle PARALLEL return value in VALREG.\n(emit_library_call, emit_library_call_value): Abort for PARALLEL.\n(store_one_arg): Delete code for handling EXPR_LIST.\n\nFrom-SVN: r12188", "tree": {"sha": "10117a9a4a756e68b55a4cab604d13428c5066b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10117a9a4a756e68b55a4cab604d13428c5066b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124/comments", "author": null, "committer": null, "parents": [{"sha": "1853aadde2b24bc529a21a3fbe2b0acb2ba4dde1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1853aadde2b24bc529a21a3fbe2b0acb2ba4dde1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1853aadde2b24bc529a21a3fbe2b0acb2ba4dde1"}], "stats": {"total": 72, "additions": 39, "deletions": 33}, "files": [{"sha": "191e9487dfee7edb24fdf7d947637925f8bfc9cf", "filename": "gcc/calls.c", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124", "patch": "@@ -60,7 +60,7 @@ struct arg_data\n   /* Initially-compute RTL value for argument; only for const functions.  */\n   rtx initial_value;\n   /* Register to pass this argument in, 0 if passed on stack, or an\n-     EXPR_LIST if the arg is to be copied into multiple different\n+     PARALLEL if the arg is to be copied into multiple non-contiguous\n      registers.  */\n   rtx reg;\n   /* If REG was promoted from the actual mode of the argument expression,\n@@ -1112,12 +1112,12 @@ expand_call (exp, target, ignore)\n \n       args[i].pass_on_stack = MUST_PASS_IN_STACK (mode, type);\n \n-      /* If FUNCTION_ARG returned an (expr_list (nil) FOO), it means that\n-\t we are to pass this arg in the register(s) designated by FOO, but\n-\t also to pass it in the stack.  */\n-      if (args[i].reg && GET_CODE (args[i].reg) == EXPR_LIST\n-\t  && XEXP (args[i].reg, 0) == 0)\n-\targs[i].pass_on_stack = 1, args[i].reg = XEXP (args[i].reg, 1);\n+      /* If FUNCTION_ARG returned a (parallel [(expr_list (nil) ...) ...]),\n+\t it means that we are to pass this arg in the register(s) designated\n+\t by the PARALLEL, but also to pass it in the stack.  */\n+      if (args[i].reg && GET_CODE (args[i].reg) == PARALLEL\n+\t  && XEXP (XVECEXP (args[i].reg, 0, 0), 0) == 0)\n+\targs[i].pass_on_stack = 1;\n \n       /* If this is an addressable type, we must preallocate the stack\n \t since we must evaluate the object into its final location.\n@@ -1846,20 +1846,12 @@ expand_call (exp, target, ignore)\n \n   for (i = 0; i < num_actuals; i++)\n     {\n-      rtx list = args[i].reg;\n+      rtx reg = args[i].reg;\n       int partial = args[i].partial;\n+      int nregs;\n \n-      while (list)\n+      if (reg)\n \t{\n-\t  rtx reg;\n-\t  int nregs;\n-\n-\t  /* Process each register that needs to get this arg.  */\n-\t  if (GET_CODE (list) == EXPR_LIST)\n-\t    reg = XEXP (list, 0), list = XEXP (list, 1);\n-\t  else\n-\t    reg = list, list = 0;\n-\n \t  /* Set to non-negative if must move a word at a time, even if just\n \t     one word (e.g, partial == 1 && mode == DFmode).  Set to -1 if\n \t     we just use a normal move insn.  This value can be zero if the\n@@ -1870,11 +1862,17 @@ expand_call (exp, target, ignore)\n \t\t\t  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n \t\t      : -1));\n \n+\t  /* Handle calls that pass values in multiple non-contiguous\n+\t     locations.  The Irix 6 ABI has examples of this.  */\n+\n+\t  if (GET_CODE (reg) == PARALLEL)\n+\t    emit_group_load (reg, args[i].value);\n+\n \t  /* If simple case, just do move.  If normal partial, store_one_arg\n \t     has already loaded the register for us.  In all other cases,\n \t     load the register(s) from memory.  */\n \n-\t  if (nregs == -1)\n+\t  else if (nregs == -1)\n \t    emit_move_insn (reg, args[i].value);\n \n \t  /* If we have pre-computed the values to put in the registers in\n@@ -1885,19 +1883,19 @@ expand_call (exp, target, ignore)\n \t      emit_move_insn (gen_rtx (REG, word_mode, REGNO (reg) + j),\n \t\t\t      args[i].aligned_regs[j]);\n \n-\t  else if (args[i].partial == 0 || args[i].pass_on_stack)\n+\t  else if (partial == 0 || args[i].pass_on_stack)\n \t    move_block_to_reg (REGNO (reg),\n \t\t\t       validize_mem (args[i].value), nregs,\n \t\t\t       args[i].mode);\n \n-\t  if (nregs == -1)\n+\t  /* Handle calls that pass values in multiple non-contiguous\n+\t     locations.  The Irix 6 ABI has examples of this.  */\n+\t  if (GET_CODE (reg) == PARALLEL)\n+\t    use_group_regs (&call_fusage, reg);\n+\t  else if (nregs == -1)\n \t    use_reg (&call_fusage, reg);\n \t  else\n \t    use_regs (&call_fusage, REGNO (reg), nregs == 0 ? 1 : nregs);\n-\n-\t  /* PARTIAL referred only to the first register, so clear it for the\n-\t     next time.  */\n-\t  partial = 0;\n \t}\n     }\n \n@@ -2032,6 +2030,20 @@ expand_call (exp, target, ignore)\n        If they refer to the same register, this move will be a no-op, except\n        when function inlining is being done.  */\n     emit_move_insn (target, valreg);\n+  /* Handle calls that return values in multiple non-contiguous locations.\n+     The Irix 6 ABI has examples of this.  */\n+  else if (GET_CODE (valreg) == PARALLEL)\n+    {\n+      if (target == 0)\n+\t{\n+\t  int bytes = int_size_in_bytes (TREE_TYPE (exp));\n+\t  target = assign_stack_temp (BLKmode, bytes, 0);\n+\t  MEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (TREE_TYPE (exp));\n+\t  preserve_temp_slots (target);\n+\t}\n+\n+      emit_group_store (target, valreg);\n+    }\n   else if (TYPE_MODE (TREE_TYPE (exp)) == BLKmode)\n     {\n       /* Some machines (the PA for example) want to return all small\n@@ -2326,7 +2338,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n       argvec[count].mode = mode;\n \n       argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n-      if (argvec[count].reg && GET_CODE (argvec[count].reg) == EXPR_LIST)\n+      if (argvec[count].reg && GET_CODE (argvec[count].reg) == PARALLEL)\n \tabort ();\n #ifdef FUNCTION_ARG_PARTIAL_NREGS\n       argvec[count].partial\n@@ -2674,7 +2686,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n       argvec[count].mode = mode;\n \n       argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n-      if (argvec[count].reg && GET_CODE (argvec[count].reg) == EXPR_LIST)\n+      if (argvec[count].reg && GET_CODE (argvec[count].reg) == PARALLEL)\n \tabort ();\n #ifdef FUNCTION_ARG_PARTIAL_NREGS\n       argvec[count].partial\n@@ -3030,12 +3042,6 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n   if (arg->n_aligned_regs != 0)\n     reg = 0;\n   \n-  /* If this is being partially passed in a register, but multiple locations\n-     are specified, we assume that the one partially used is the one that is\n-     listed first.  */\n-  if (reg && GET_CODE (reg) == EXPR_LIST)\n-    reg = XEXP (reg, 0);\n-\n   /* If this is being passed partially in a register, we can't evaluate\n      it directly into its stack slot.  Otherwise, we can.  */\n   if (arg->value == 0)"}]}