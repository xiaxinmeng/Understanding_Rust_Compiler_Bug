{"sha": "4e62f891cdeabc14cf6195a69dc6528aab11e753", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU2MmY4OTFjZGVhYmMxNGNmNjE5NWE2OWRjNjUyOGFhYjExZTc1Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-07-15T21:17:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-07-15T21:17:16Z"}, "message": "runtime: expose the g variable\n    \n    Currently, getg is implemented in C, which loads the thread-local\n    g variable. The g variable is declared static in C.\n    \n    This CL exposes the g variable, so it can be accessed from the Go\n    side. This allows the Go compiler to inline getg calls to direct\n    access of g.\n    \n    Currently, the actual inlining is only implemented in the gollvm\n    compiler. The g variable is thread-local and the compiler backend\n    may choose to cache the TLS address in a register or on stack. If\n    a thread switch happens the cache may become invalid. I don't\n    know how to disable the TLS address cache in gccgo, therefore\n    the inlining of getg is not implemented. In the future gccgo may\n    gain this if we know how to do it safely.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/186238\n\nFrom-SVN: r273499", "tree": {"sha": "3a7e81af0a3e72432c75f043950798b0387de393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a7e81af0a3e72432c75f043950798b0387de393"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e62f891cdeabc14cf6195a69dc6528aab11e753", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e62f891cdeabc14cf6195a69dc6528aab11e753", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e62f891cdeabc14cf6195a69dc6528aab11e753", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e62f891cdeabc14cf6195a69dc6528aab11e753/comments", "author": null, "committer": null, "parents": [{"sha": "2d94f7dea9c73ef3c116a0ddc722724578a860fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d94f7dea9c73ef3c116a0ddc722724578a860fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d94f7dea9c73ef3c116a0ddc722724578a860fe"}], "stats": {"total": 6, "additions": 3, "deletions": 3}, "files": [{"sha": "4e19c524837845401389e556c7fc9b8f0acf2bc6", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62f891cdeabc14cf6195a69dc6528aab11e753/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62f891cdeabc14cf6195a69dc6528aab11e753/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=4e62f891cdeabc14cf6195a69dc6528aab11e753", "patch": "@@ -1,4 +1,4 @@\n-70ceba5e95716653b9f829a457a44a829175d4da\n+0e51b7e9c03c6f6bc3d06343f2050f17349ccdc3\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "523dfd9ff146cf1bbcd48ce45d6398ec084aa409", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62f891cdeabc14cf6195a69dc6528aab11e753/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62f891cdeabc14cf6195a69dc6528aab11e753/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=4e62f891cdeabc14cf6195a69dc6528aab11e753", "patch": "@@ -65,7 +65,7 @@ static void gscanstack(G*);\n #define __thread\n #endif\n \n-static __thread G *g;\n+__thread G *g __asm__(GOSYM_PREFIX \"runtime.g\");\n \n #ifndef SETCONTEXT_CLOBBERS_TLS\n \n@@ -320,7 +320,7 @@ runtime_mcall(FuncVal *fv)\n \tif(gp != nil) {\n \n #ifdef USING_SPLIT_STACK\n-\t\t__splitstack_getcontext((void*)(&g->stackcontext[0]));\n+\t\t__splitstack_getcontext((void*)(&gp->stackcontext[0]));\n #else\n \t\t// We have to point to an address on the stack that is\n \t\t// below the saved registers."}]}