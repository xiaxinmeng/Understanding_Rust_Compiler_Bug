{"sha": "c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhmZTk0YzdlYTNkZWJjZjViNDFjZmFiZmUwY2EzOTViMTgzNGRhNA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-08-10T22:12:04Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-08-10T22:12:04Z"}, "message": "re PR fortran/31270 (print subscript value and array bounds when out-of-bounds error occurs)\n\n\tPR fortran/31270\n\n\t* trans.c (gfc_trans_runtime_check): Reorder arguments and\n\tadd extra variable arguments. Hand them to the library function.\n\t* trans.h (gfc_trans_runtime_check): Update prototype.\n\t* trans-array.c (gfc_trans_array_bound_check): Issue more\n\tdetailled error messages.\n\t(gfc_conv_array_ref): Likewise.\n\t(gfc_conv_ss_startstride): Likewise.\n\t(gfc_trans_dummy_array_bias): Reorder arguments to\n\tgfc_trans_runtime_check.\n\t* trans-expr.c (gfc_conv_substring): Issue more detailled\n\terror messages.\n\t(gfc_conv_function_call): Reorder arguments to gfc_trans_runtime_check.\n\t* trans-stmt.c (gfc_trans_goto): Likewise.\n\t* trans-io.c (set_string): Reorder arguments to\n\tgfc_trans_runtime_check and issue a more detailled error message.\n\t* trans-decl.c (gfc_build_builtin_function_decls): Make\n\truntime_error and runtime_error_at handle a variable number of\n\targuments.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Reorder arguments\n\tto gfc_trans_runtime_check.\n\t(gfc_conv_intrinsic_minmax): Likewise.\n\t(gfc_conv_intrinsic_repeat): Issue more detailled error messages.\n\n\t* runtime/error.c (runtime_error_at): Add a variable number of\n\targuments.\n\t* libgfortran.h (runtime_error_at): Update prototype.\n\nFrom-SVN: r127352", "tree": {"sha": "0df09be0cf775be5c5fc3736c8d20336d1c06fe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0df09be0cf775be5c5fc3736c8d20336d1c06fe9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac2610bf4275ca4edec63ccc0f6ee53309c639c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac2610bf4275ca4edec63ccc0f6ee53309c639c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac2610bf4275ca4edec63ccc0f6ee53309c639c1"}], "stats": {"total": 236, "additions": 169, "deletions": 67}, "files": [{"sha": "d768b08e4da9989790861e21424233aca690b8c7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -1,3 +1,29 @@\n+2007-08-10  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31270\n+\t* trans.c (gfc_trans_runtime_check): Reorder arguments and\n+\tadd extra variable arguments. Hand them to the library function.\n+\t* trans.h (gfc_trans_runtime_check): Update prototype.\n+\t* trans-array.c (gfc_trans_array_bound_check): Issue more\n+\tdetailled error messages.\n+\t(gfc_conv_array_ref): Likewise.\n+\t(gfc_conv_ss_startstride): Likewise.\n+\t(gfc_trans_dummy_array_bias): Reorder arguments to\n+\tgfc_trans_runtime_check.\n+\t* trans-expr.c (gfc_conv_substring): Issue more detailled\n+\terror messages.\n+\t(gfc_conv_function_call): Reorder arguments to gfc_trans_runtime_check.\n+\t* trans-stmt.c (gfc_trans_goto): Likewise.\n+\t* trans-io.c (set_string): Reorder arguments to\n+\tgfc_trans_runtime_check and issue a more detailled error message.\n+\t* trans-decl.c (gfc_build_builtin_function_decls): Make\n+\truntime_error and runtime_error_at handle a variable number of\n+\targuments.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Reorder arguments\n+\tto gfc_trans_runtime_check.\n+\t(gfc_conv_intrinsic_minmax): Likewise.\n+\t(gfc_conv_intrinsic_repeat): Issue more detailled error messages.\n+\n 2007-08-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gfortranspec.c (lang_specific_driver): Use CONST_CAST."}, {"sha": "78b038a4ee7074c23db1308b668431af8879156f", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -2097,9 +2097,11 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n     asprintf (&msg, \"%s for array '%s', lower bound of dimension %d exceeded\",\n \t      gfc_msg_fault, name, n+1);\n   else\n-    asprintf (&msg, \"%s, lower bound of dimension %d exceeded\",\n-\t      gfc_msg_fault, n+1);\n-  gfc_trans_runtime_check (fault, msg, &se->pre, where);\n+    asprintf (&msg, \"%s, lower bound of dimension %d exceeded, %%ld is \"\n+\t      \"smaller than %%ld\", gfc_msg_fault, n+1);\n+  gfc_trans_runtime_check (fault, &se->pre, where, msg,\n+\t\t\t   fold_convert (long_integer_type_node, index),\n+\t\t\t   fold_convert (long_integer_type_node, tmp));\n   gfc_free (msg);\n \n   /* Check upper bound.  */\n@@ -2111,9 +2113,11 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n \tasprintf (&msg, \"%s for array '%s', upper bound of dimension %d \"\n \t\t\t\" exceeded\", gfc_msg_fault, name, n+1);\n       else\n-\tasprintf (&msg, \"%s, upper bound of dimension %d exceeded\",\n-\t\t  gfc_msg_fault, n+1);\n-      gfc_trans_runtime_check (fault, msg, &se->pre, where);\n+\tasprintf (&msg, \"%s, upper bound of dimension %d exceeded, %%ld is \"\n+\t\t  \"larger than %%ld\", gfc_msg_fault, n+1);\n+      gfc_trans_runtime_check (fault, &se->pre, where, msg,\n+\t\t\t       fold_convert (long_integer_type_node, index),\n+\t\t\t       fold_convert (long_integer_type_node, tmp));\n       gfc_free (msg);\n     }\n \n@@ -2300,9 +2304,12 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t  cond = fold_build2 (LT_EXPR, boolean_type_node, \n \t\t\t      indexse.expr, tmp);\n \t  asprintf (&msg, \"%s for array '%s', \"\n-\t            \"lower bound of dimension %d exceeded\", gfc_msg_fault,\n-\t\t    sym->name, n+1);\n-\t  gfc_trans_runtime_check (cond, msg, &se->pre, where);\n+\t            \"lower bound of dimension %d exceeded, %%ld is smaller \"\n+\t\t    \"than %%ld\", gfc_msg_fault, sym->name, n+1);\n+\t  gfc_trans_runtime_check (cond, &se->pre, where, msg,\n+\t\t\t\t   fold_convert (long_integer_type_node,\n+\t\t\t\t\t\t indexse.expr),\n+\t\t\t\t   fold_convert (long_integer_type_node, tmp));\n \t  gfc_free (msg);\n \n \t  /* Upper bound, but not for the last dimension of assumed-size\n@@ -2314,9 +2321,12 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t      cond = fold_build2 (GT_EXPR, boolean_type_node, \n \t\t\t\t  indexse.expr, tmp);\n \t      asprintf (&msg, \"%s for array '%s', \"\n-\t\t\t\"upper bound of dimension %d exceeded\", gfc_msg_fault,\n-\t\t\tsym->name, n+1);\n-\t      gfc_trans_runtime_check (cond, msg, &se->pre, where);\n+\t\t\t\"upper bound of dimension %d exceeded, %%ld is \"\n+\t\t\t\"greater than %%ld\", gfc_msg_fault, sym->name, n+1);\n+\t      gfc_trans_runtime_check (cond, &se->pre, where, msg,\n+\t\t\t\t   fold_convert (long_integer_type_node,\n+\t\t\t\t\t\t indexse.expr),\n+\t\t\t\t   fold_convert (long_integer_type_node, tmp));\n \t      gfc_free (msg);\n \t    }\n \t}\n@@ -2872,7 +2882,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      asprintf (&msg, \"Zero stride is not allowed, for dimension %d \"\n \t\t\t\"of array '%s'\", info->dim[n]+1,\n \t\t\tss->expr->symtree->name);\n-\t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t      gfc_trans_runtime_check (tmp, &block, &ss->expr->where, msg);\n \t      gfc_free (msg);\n \n \t      desc = ss->data.info.descriptor;\n@@ -2912,9 +2922,13 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t non_zerosized, tmp);\n \t      asprintf (&msg, \"%s, lower bound of dimension %d of array '%s'\"\n-\t\t\t\" exceeded\", gfc_msg_fault, info->dim[n]+1,\n-\t\t\tss->expr->symtree->name);\n-\t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t\t\t\" exceeded, %%ld is smaller than %%ld\", gfc_msg_fault,\n+\t\t\tinfo->dim[n]+1, ss->expr->symtree->name);\n+\t      gfc_trans_runtime_check (tmp, &block, &ss->expr->where, msg,\n+\t\t\t\t       fold_convert (long_integer_type_node,\n+\t\t\t\t\t\t     info->start[n]),\n+\t\t\t\t       fold_convert (long_integer_type_node,\n+\t\t\t\t\t\t     lbound));\n \t      gfc_free (msg);\n \n \t      if (check_upper)\n@@ -2924,9 +2938,12 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t     non_zerosized, tmp);\n \t          asprintf (&msg, \"%s, upper bound of dimension %d of array \"\n-\t\t\t    \"'%s' exceeded\", gfc_msg_fault, info->dim[n]+1,\n+\t\t\t    \"'%s' exceeded, %%ld is greater than %%ld\",\n+\t\t\t    gfc_msg_fault, info->dim[n]+1,\n \t\t\t    ss->expr->symtree->name);\n-\t\t  gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t\t  gfc_trans_runtime_check (tmp, &block, &ss->expr->where, msg,\n+\t\t\tfold_convert (long_integer_type_node, info->start[n]),\n+\t\t\tfold_convert (long_integer_type_node, ubound));\n \t\t  gfc_free (msg);\n \t\t}\n \n@@ -2944,9 +2961,13 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t non_zerosized, tmp);\n \t      asprintf (&msg, \"%s, lower bound of dimension %d of array '%s'\"\n-\t\t\t\" exceeded\", gfc_msg_fault, info->dim[n]+1,\n-\t\t\tss->expr->symtree->name);\n-\t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t\t\t\" exceeded, %%ld is smaller than %%ld\", gfc_msg_fault,\n+\t\t\tinfo->dim[n]+1, ss->expr->symtree->name);\n+\t      gfc_trans_runtime_check (tmp, &block, &ss->expr->where, msg,\n+\t\t\t\t       fold_convert (long_integer_type_node,\n+\t\t\t\t\t\t     tmp2),\n+\t\t\t\t       fold_convert (long_integer_type_node,\n+\t\t\t\t\t\t     lbound));\n \t      gfc_free (msg);\n \n \t      if (check_upper)\n@@ -2955,9 +2976,12 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t     non_zerosized, tmp);\n \t\t  asprintf (&msg, \"%s, upper bound of dimension %d of array \"\n-\t\t\t    \"'%s' exceeded\", gfc_msg_fault, info->dim[n]+1,\n+\t\t\t    \"'%s' exceeded, %%ld is greater than %%ld\",\n+\t\t\t    gfc_msg_fault, info->dim[n]+1,\n \t\t\t    ss->expr->symtree->name);\n-\t\t  gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t\t  gfc_trans_runtime_check (tmp, &block, &ss->expr->where, msg,\n+\t\t\tfold_convert (long_integer_type_node, tmp2),\n+\t\t\tfold_convert (long_integer_type_node, ubound));\n \t\t  gfc_free (msg);\n \t\t}\n \n@@ -2970,12 +2994,14 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t         others against this.  */\n \t      if (size[n])\n \t\t{\n-\t\t  tmp =\n-\t\t    fold_build2 (NE_EXPR, boolean_type_node, tmp, size[n]);\n+\t\t  tree tmp3\n+\t\t    = fold_build2 (NE_EXPR, boolean_type_node, tmp, size[n]);\n \t\t  asprintf (&msg, \"%s, size mismatch for dimension %d \"\n-\t\t\t    \"of array '%s'\", gfc_msg_bounds, info->dim[n]+1,\n-\t\t\t    ss->expr->symtree->name);\n-\t\t  gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t\t\t    \"of array '%s' (%%ld/%%ld)\", gfc_msg_bounds,\n+\t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n+\t\t  gfc_trans_runtime_check (tmp3, &block, &ss->expr->where, msg,\n+\t\t\tfold_convert (long_integer_type_node, tmp),\n+\t\t\tfold_convert (long_integer_type_node, size[n]));\n \t\t  gfc_free (msg);\n \t\t}\n \t      else\n@@ -4194,7 +4220,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n               tmp = fold_build2 (NE_EXPR, gfc_array_index_type, tmp, stride2);\n \t      asprintf (&msg, \"%s for dimension %d of array '%s'\",\n \t\t\tgfc_msg_bounds, n+1, sym->name);\n-\t      gfc_trans_runtime_check (tmp, msg, &block, &loc);\n+\t      gfc_trans_runtime_check (tmp, &block, &loc, msg);\n \t      gfc_free (msg);\n \t    }\n \t}"}, {"sha": "58cbc37b4f5810df7ed71def9db8c3374d8d089c", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -2340,13 +2340,13 @@ gfc_build_builtin_function_decls (void)\n \n   gfor_fndecl_runtime_error =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"runtime_error\")),\n-\t\t\t\t     void_type_node, 1, pchar_type_node);\n+\t\t\t\t     void_type_node, -1, pchar_type_node);\n   /* The runtime_error function does not return.  */\n   TREE_THIS_VOLATILE (gfor_fndecl_runtime_error) = 1;\n \n   gfor_fndecl_runtime_error_at =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"runtime_error_at\")),\n-\t\t\t\t     void_type_node, 2, pchar_type_node,\n+\t\t\t\t     void_type_node, -2, pchar_type_node,\n \t\t\t\t     pchar_type_node);\n   /* The runtime_error_at function does not return.  */\n   TREE_THIS_VOLATILE (gfor_fndecl_runtime_error_at) = 1;"}, {"sha": "b24a8ac76c5776c740935015e91a378bb0e713d3", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -296,12 +296,14 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       fault = fold_build2 (TRUTH_ANDIF_EXPR, boolean_type_node,\n \t\t\t   nonempty, fault);\n       if (name)\n-\tasprintf (&msg, \"Substring out of bounds: lower bound of '%s' \"\n+\tasprintf (&msg, \"Substring out of bounds: lower bound (%%ld) of '%s' \"\n \t\t  \"is less than one\", name);\n       else\n-\tasprintf (&msg, \"Substring out of bounds: lower bound \"\n+\tasprintf (&msg, \"Substring out of bounds: lower bound (%%ld)\"\n \t\t  \"is less than one\");\n-      gfc_trans_runtime_check (fault, msg, &se->pre, where);\n+      gfc_trans_runtime_check (fault, &se->pre, where, msg,\n+\t\t\t       fold_convert (long_integer_type_node,\n+\t\t\t\t\t     start.expr));\n       gfc_free (msg);\n \n       /* Check upper bound.  */\n@@ -310,12 +312,15 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       fault = fold_build2 (TRUTH_ANDIF_EXPR, boolean_type_node,\n \t\t\t   nonempty, fault);\n       if (name)\n-\tasprintf (&msg, \"Substring out of bounds: upper bound of '%s' \"\n-\t\t  \"exceeds string length\", name);\n+\tasprintf (&msg, \"Substring out of bounds: upper bound (%%ld) of '%s' \"\n+\t\t  \"exceeds string length (%%ld)\", name);\n       else\n-\tasprintf (&msg, \"Substring out of bounds: upper bound \"\n-\t\t  \"exceeds string length\");\n-      gfc_trans_runtime_check (fault, msg, &se->pre, where);\n+\tasprintf (&msg, \"Substring out of bounds: upper bound (%%ld) \"\n+\t\t  \"exceeds string length (%%ld)\");\n+      gfc_trans_runtime_check (fault, &se->pre, where, msg,\n+\t\t\t       fold_convert (long_integer_type_node, end.expr),\n+\t\t\t       fold_convert (long_integer_type_node,\n+\t\t\t\t\t     se->string_length));\n       gfc_free (msg);\n     }\n \n@@ -2589,7 +2594,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t  tmp = gfc_conv_descriptor_data_get (info->descriptor);\n \t\t  tmp = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t\t     tmp, info->data);\n-\t\t  gfc_trans_runtime_check (tmp, gfc_msg_fault, &se->pre, NULL);\n+\t\t  gfc_trans_runtime_check (tmp, &se->pre, NULL, gfc_msg_fault);\n \t\t}\n \t      se->expr = info->descriptor;\n \t      /* Bundle in the string length.  */"}, {"sha": "b9dbf464c4674b2981cbff22c5a6ccbc74baa41c", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -855,7 +855,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n           tmp = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))];\n           tmp = fold_build2 (GE_EXPR, boolean_type_node, bound, tmp);\n           cond = fold_build2 (TRUTH_ORIF_EXPR, boolean_type_node, cond, tmp);\n-          gfc_trans_runtime_check (cond, gfc_msg_fault, &se->pre, &expr->where);\n+          gfc_trans_runtime_check (cond, &se->pre, &expr->where, gfc_msg_fault);\n         }\n     }\n \n@@ -1485,7 +1485,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n \t\texpr->symtree->n.sym->name);\n       cond = build2 (EQ_EXPR, boolean_type_node, TREE_OPERAND (args[0], 0),\n \t\t     build_int_cst (TREE_TYPE (TREE_OPERAND (args[0], 0)), 0));\n-      gfc_trans_runtime_check (cond, msg, &se->pre, &expr->where);\n+      gfc_trans_runtime_check (cond, &se->pre, &expr->where, msg);\n       gfc_free (msg);\n     }\n \n@@ -1501,7 +1501,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n \t\texpr->symtree->n.sym->name);\n       cond = build2 (EQ_EXPR, boolean_type_node, TREE_OPERAND (args[1], 0),\n \t\t     build_int_cst (TREE_TYPE (TREE_OPERAND (args[1], 0)), 0));\n-      gfc_trans_runtime_check (cond, msg, &se->pre, &expr->where);\n+      gfc_trans_runtime_check (cond, &se->pre, &expr->where, msg);\n       gfc_free (msg);\n     }\n \n@@ -3665,9 +3665,10 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   /* Check that NCOPIES is not negative.  */\n   cond = fold_build2 (LT_EXPR, boolean_type_node, ncopies,\n \t\t      build_int_cst (ncopies_type, 0));\n-  gfc_trans_runtime_check (cond,\n-\t\t\t   \"Argument NCOPIES of REPEAT intrinsic is negative\",\n-\t\t\t   &se->pre, &expr->where);\n+  gfc_trans_runtime_check (cond, &se->pre, &expr->where,\n+\t\t\t   \"Argument NCOPIES of REPEAT intrinsic is negative \"\n+\t\t\t   \"(its value is %lld)\",\n+\t\t\t   fold_convert (long_integer_type_node, ncopies));\n \n   /* If the source length is zero, any non negative value of NCOPIES\n      is valid, and nothing happens.  */\n@@ -3696,9 +3697,9 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n \t\t     build_int_cst (size_type_node, 0));\n   cond = fold_build3 (COND_EXPR, boolean_type_node, tmp, boolean_false_node,\n \t\t      cond);\n-  gfc_trans_runtime_check (cond,\n-\t\t\t   \"Argument NCOPIES of REPEAT intrinsic is too large\",\n-\t\t\t   &se->pre, &expr->where);\n+  gfc_trans_runtime_check (cond, &se->pre, &expr->where,\n+\t\t\t   \"Argument NCOPIES of REPEAT intrinsic is too large\");\n+\t\t\t   \n \n   /* Compute the destination length.  */\n   dlen = fold_build2 (MULT_EXPR, gfc_charlen_type_node,"}, {"sha": "80646cd081943a065018381b1db28e978db51da1", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -653,15 +653,17 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n   if (e->ts.type == BT_INTEGER && e->symtree->n.sym->attr.assign == 1)\n     {\n       char * msg;\n+      tree cond;\n \n       gfc_conv_label_variable (&se, e);\n       tmp = GFC_DECL_STRING_LEN (se.expr);\n-      tmp = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t tmp, build_int_cst (TREE_TYPE (tmp), 0));\n+      cond = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t  tmp, build_int_cst (TREE_TYPE (tmp), 0));\n \n-      asprintf(&msg, \"Label assigned to variable '%s' is not a format label\",\n-\t       e->symtree->name);\n-      gfc_trans_runtime_check (tmp, msg, &se.pre, &e->where);\n+      asprintf(&msg, \"Label assigned to variable '%s' (%%ld) is not a format \"\n+\t       \"label\", e->symtree->name);\n+      gfc_trans_runtime_check (cond, &se.pre, &e->where, msg,\n+\t\t\t       fold_convert (long_integer_type_node, tmp));\n       gfc_free (msg);\n \n       gfc_add_modify_expr (&se.pre, io,"}, {"sha": "47e08229fe9541c900e34816f872b86ced93a4f4", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -153,8 +153,8 @@ gfc_trans_goto (gfc_code * code)\n   tmp = GFC_DECL_STRING_LEN (se.expr);\n   tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n \t\t     build_int_cst (TREE_TYPE (tmp), -1));\n-  gfc_trans_runtime_check (tmp, \"Assigned label is not a target label\",\n-\t\t\t   &se.pre, &loc);\n+  gfc_trans_runtime_check (tmp, &se.pre, &loc,\n+\t\t\t   \"Assigned label is not a target label\");\n \n   assigned_goto = GFC_DECL_ASSIGN_ADDR (se.expr);\n \n@@ -179,8 +179,8 @@ gfc_trans_goto (gfc_code * code)\n       code = code->block;\n     }\n   while (code != NULL);\n-  gfc_trans_runtime_check (boolean_true_node,\n-\t\t\t   \"Assigned label is not in the list\", &se.pre, &loc);\n+  gfc_trans_runtime_check (boolean_true_node, &se.pre, &loc,\n+\t\t\t   \"Assigned label is not in the list\");\n \n   return gfc_finish_block (&se.pre); \n }"}, {"sha": "79112e590ea212f91a437f27ccb95d31f447125d", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -320,19 +320,32 @@ gfc_build_array_ref (tree base, tree offset)\n /* Generate a runtime error if COND is true.  */\n \n void\n-gfc_trans_runtime_check (tree cond, const char * msgid, stmtblock_t * pblock,\n-\t\t\t locus * where)\n+gfc_trans_runtime_check (tree cond, stmtblock_t * pblock, locus * where,\n+\t\t\t const char * msgid, ...)\n {\n+  va_list ap;\n   stmtblock_t block;\n   tree body;\n   tree tmp;\n   tree arg, arg2;\n+  tree *argarray;\n+  tree fntype;\n   char *message;\n-  int line;\n+  const char *p;\n+  int line, nargs, i;\n \n   if (integer_zerop (cond))\n     return;\n \n+  /* Compute the number of extra arguments from the format string.  */\n+  for (p = msgid, nargs = 0; *p; p++)\n+    if (*p == '%')\n+      {\n+\tp++;\n+\tif (*p != '%')\n+\t  nargs++;\n+      }\n+\n   /* The code to generate the error.  */\n   gfc_start_block (&block);\n \n@@ -357,7 +370,23 @@ gfc_trans_runtime_check (tree cond, const char * msgid, stmtblock_t * pblock,\n   arg2 = gfc_build_addr_expr (pchar_type_node, gfc_build_cstring_const(message));\n   gfc_free(message);\n \n-  tmp = build_call_expr (gfor_fndecl_runtime_error_at, 2, arg, arg2);\n+  /* Build the argument array.  */\n+  argarray = (tree *) alloca (sizeof (tree) * (nargs + 2));\n+  argarray[0] = arg;\n+  argarray[1] = arg2;\n+  va_start (ap, msgid);\n+  for (i = 0; i < nargs; i++)\n+    argarray[2+i] = va_arg (ap, tree);\n+  va_end (ap);\n+  \n+  /* Build the function call to runtime_error_at; because of the variable\n+     number of arguments, we can't use build_call_expr directly.  */\n+  fntype = TREE_TYPE (gfor_fndecl_runtime_error_at);\n+  tmp = fold_builtin_call_array (TREE_TYPE (fntype),\n+\t\t\t\t build1 (ADDR_EXPR,\n+\t\t\t\t\t build_pointer_type (fntype),\n+\t\t\t\t\t gfor_fndecl_runtime_error_at),\n+\t\t\t\t nargs + 2, argarray);\n   gfc_add_expr_to_block (&block, tmp);\n \n   body = gfc_finish_block (&block);"}, {"sha": "829551e7b454f7a9f9b8694a6ff2d728920af947", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -442,7 +442,7 @@ void gfc_generate_constructors (void);\n bool get_array_ctor_strlen (stmtblock_t *, gfc_constructor *, tree *);\n \n /* Generate a runtime error check.  */\n-void gfc_trans_runtime_check (tree, const char *, stmtblock_t *, locus *);\n+void gfc_trans_runtime_check (tree, stmtblock_t *, locus *, const char *, ...);\n \n /* Generate a call to free() after checking that its arg is non-NULL.  */\n tree gfc_call_free (tree);"}, {"sha": "46f7282a6396234b1e49ac5509ab274b396cad11", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -1,3 +1,10 @@\n+2007-08-10  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31270\n+\t* runtime/error.c (runtime_error_at): Add a variable number of\n+\targuments.\n+\t* libgfortran.h (runtime_error_at): Update prototype.\n+\n 2007-08-10  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/32933"}, {"sha": "c32b5a37e061345b75d4d81881749ef64b301cae", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -599,8 +599,8 @@ extern void runtime_error (const char *, ...)\n      __attribute__ ((noreturn, format (printf, 1, 2)));\n iexport_proto(runtime_error);\n \n-extern void runtime_error_at (const char *, const char *)\n-__attribute__ ((noreturn));\n+extern void runtime_error_at (const char *, const char *, ...)\n+     __attribute__ ((noreturn, format (printf, 2, 3)));\n iexport_proto(runtime_error_at);\n \n extern void internal_error (st_parameter_common *, const char *)"}, {"sha": "3512ab4e031aedf354206278c51252a6005d992c", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=c8fe94c7ea3debcf5b41cfabfe0ca395b1834da4", "patch": "@@ -267,11 +267,17 @@ iexport(runtime_error);\n  * run time error generated by the front end compiler.  */\n \n void\n-runtime_error_at (const char *where, const char *message)\n+runtime_error_at (const char *where, const char *message, ...)\n {\n+  va_list ap;\n+\n   recursion_check ();\n   st_printf (\"%s\\n\", where);\n-  st_printf (\"Fortran runtime error: %s\\n\", message);\n+  st_printf (\"Fortran runtime error: \");\n+  va_start (ap, message);\n+  st_vprintf (message, ap);\n+  va_end (ap);\n+  st_printf (\"\\n\");\n   sys_exit (2);\n }\n iexport(runtime_error_at);"}]}