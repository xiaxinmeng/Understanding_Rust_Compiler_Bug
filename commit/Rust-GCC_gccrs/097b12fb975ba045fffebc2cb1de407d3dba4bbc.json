{"sha": "097b12fb975ba045fffebc2cb1de407d3dba4bbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk3YjEyZmI5NzViYTA0NWZmZmViYzJjYjFkZTQwN2QzZGJhNGJiYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2012-05-09T21:17:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-09T21:17:23Z"}, "message": "compiler: Add -fgo-pkgpath option.\n\n\t* lang.opt: Add -fgo-pkgpath.\n\t* go-lang.c (go_pkgpath): New static variable.\n\t(go_prefix): New static variable.\n\t(go_langhook_init): Pass go_pkgpath and go_prefix to\n\tgo_create_gogo.\n\t(go_langhook_handle_option): Handle -fgo-pkgpath.  Change\n\t-fgo-prefix handling to just set go_prefix.\n\t* go-c.h (go_set_prefix): Don't declare.\n\t(go_create_gogo): Add pkgpath and prefix to declaration.\n\t* go-gcc.cc (Gcc_backend::global_variable): Change unique_prefix\n\tto pkgpath.  Don't include the package name in the asm name.\n\t* gccgo.texi (Invoking gccgo): Document -fgo-pkgpath.  Update the\n\tdocs for -fgo-prefix.\n\nFrom-SVN: r187356", "tree": {"sha": "35b68564005a08b6b179869395daba334368b0bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35b68564005a08b6b179869395daba334368b0bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/097b12fb975ba045fffebc2cb1de407d3dba4bbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097b12fb975ba045fffebc2cb1de407d3dba4bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/097b12fb975ba045fffebc2cb1de407d3dba4bbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097b12fb975ba045fffebc2cb1de407d3dba4bbc/comments", "author": null, "committer": null, "parents": [{"sha": "1b8b126f386ffff12b02f7c9cb2a00c38996f1ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b8b126f386ffff12b02f7c9cb2a00c38996f1ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b8b126f386ffff12b02f7c9cb2a00c38996f1ea"}], "stats": {"total": 777, "additions": 457, "deletions": 320}, "files": [{"sha": "67989fdb6a5918fbc113a43f06bb87d7ad9060b4", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -1,3 +1,19 @@\n+2012-05-09  Ian Lance Taylor  <iant@google.com>\n+\n+\t* lang.opt: Add -fgo-pkgpath.\n+\t* go-lang.c (go_pkgpath): New static variable.\n+\t(go_prefix): New static variable.\n+\t(go_langhook_init): Pass go_pkgpath and go_prefix to\n+\tgo_create_gogo.\n+\t(go_langhook_handle_option): Handle -fgo-pkgpath.  Change\n+\t-fgo-prefix handling to just set go_prefix.\n+\t* go-c.h (go_set_prefix): Don't declare.\n+\t(go_create_gogo): Add pkgpath and prefix to declaration.\n+\t* go-gcc.cc (Gcc_backend::global_variable): Change unique_prefix\n+\tto pkgpath.  Don't include the package name in the asm name.\n+\t* gccgo.texi (Invoking gccgo): Document -fgo-pkgpath.  Update the\n+\tdocs for -fgo-prefix.\n+\n 2012-04-30  Jan Hubicka  <jh@suse.cz>\n \n \t* gogo-tree.cc (Gogo::write_globals): Use finalize_compilation_unit."}, {"sha": "a5e37e76e800a6e2dfc0b1119b5541c0804a5769", "filename": "gcc/go/gccgo.texi", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgccgo.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgccgo.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgccgo.texi?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -157,14 +157,32 @@ compile time.\n When linking, specify a library search directory, as with\n @command{gcc}.\n \n+@item -fgo-pkgpath=@var{string}\n+@cindex @option{-fgo-pkgpath}\n+Set the package path to use.  This sets the value returned by the\n+PkgPath method of reflect.Type objects.  It is also used for the names\n+of globally visible symbols.  The argument to this option should\n+normally be the string that will be used to import this package after\n+it has been installed; in other words, a pathname within the\n+directories specified by the @option{-I} option.\n+\n @item -fgo-prefix=@var{string}\n @cindex @option{-fgo-prefix}\n+An alternative to @option{-fgo-pkgpath}.  The argument will be\n+combined with the package name from the source file to produce the\n+package path.  If @option{-fgo-pkgpath} is used, @option{-fgo-prefix}\n+will be ignored.\n+\n Go permits a single program to include more than one package with the\n-same name.  This option is required to make this work with\n-@command{gccgo}.  The argument to this option may be any string.  Each\n-package with the same name must use a distinct @option{-fgo-prefix}\n-option.  The argument is typically the full path under which the\n-package will be installed, as that must obviously be unique.\n+same name in the @code{package} clause in the source file, though\n+obviously the two packages must be imported using different pathnames.\n+In order for this to work with @command{gccgo}, either\n+@option{-fgo-pkgpath} or @option{-fgo-prefix} must be specified when\n+compiling a package.\n+\n+Using either @option{-fgo-pkgpath} or @option{-fgo-prefix} disables\n+the special treatment of the @code{main} package and permits that\n+package to be imported like any other.\n \n @item -frequire-return-statement\n @itemx -fno-require-return-statement"}, {"sha": "d46a08796e3ceb37b24d6044886c6b0b4c396da8", "filename": "gcc/go/go-c.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgo-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgo-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-c.h?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -38,11 +38,11 @@ extern \"C\"\n \n extern int go_enable_dump (const char*);\n extern int go_enable_optimize (const char*);\n-extern void go_set_prefix (const char*);\n \n extern void go_add_search_path (const char*);\n \n-extern void go_create_gogo (int int_type_size, int pointer_size);\n+extern void go_create_gogo (int int_type_size, int pointer_size,\n+\t\t\t    const char* pkgpath, const char *prefix);\n \n extern void go_parse_input_files (const char**, unsigned int,\n \t\t\t\t  bool only_check_syntax,"}, {"sha": "4729a3bdbd62475085792c4cfd6da67a99de3541", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -271,7 +271,7 @@ class Gcc_backend : public Backend\n \n   Bvariable*\n   global_variable(const std::string& package_name,\n-\t\t  const std::string& unique_prefix,\n+\t\t  const std::string& pkgpath,\n \t\t  const std::string& name,\n \t\t  Btype* btype,\n \t\t  bool is_external,\n@@ -1281,7 +1281,7 @@ Gcc_backend::non_zero_size_type(tree type)\n \n Bvariable*\n Gcc_backend::global_variable(const std::string& package_name,\n-\t\t\t     const std::string& unique_prefix,\n+\t\t\t     const std::string& pkgpath,\n \t\t\t     const std::string& name,\n \t\t\t     Btype* btype,\n \t\t\t     bool is_external,\n@@ -1310,9 +1310,9 @@ Gcc_backend::global_variable(const std::string& package_name,\n     {\n       TREE_PUBLIC(decl) = 1;\n \n-      std::string asm_name(unique_prefix);\n+      std::string asm_name(pkgpath);\n       asm_name.push_back('.');\n-      asm_name.append(var_name);\n+      asm_name.append(name);\n       SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n     }\n   TREE_USED(decl) = 1;"}, {"sha": "f02f769252b1066c3e78d57d2087468f70c53678", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -81,6 +81,11 @@ struct GTY(()) language_function\n   int dummy;\n };\n \n+/* Option information we need to pass to go_create_gogo.  */\n+\n+static const char *go_pkgpath = NULL;\n+static const char *go_prefix = NULL;\n+\n /* Language hooks.  */\n \n static bool\n@@ -96,7 +101,7 @@ go_langhook_init (void)\n      to, e.g., unsigned_char_type_node) but before calling\n      build_common_builtin_nodes (because it calls, indirectly,\n      go_type_for_size).  */\n-  go_create_gogo (INT_TYPE_SIZE, POINTER_SIZE);\n+  go_create_gogo (INT_TYPE_SIZE, POINTER_SIZE, go_pkgpath, go_prefix);\n \n   build_common_builtin_nodes ();\n \n@@ -227,8 +232,12 @@ go_langhook_handle_option (\n       ret = go_enable_optimize (arg) ? true : false;\n       break;\n \n+    case OPT_fgo_pkgpath_:\n+      go_pkgpath = arg;\n+      break;\n+\n     case OPT_fgo_prefix_:\n-      go_set_prefix (arg);\n+      go_prefix = arg;\n       break;\n \n     default:"}, {"sha": "2b14132804f1f1e8fe68ba3a74670167e4b54f80", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -321,16 +321,16 @@ class Backend\n   error_variable() = 0;\n \n   // Create a global variable.  PACKAGE_NAME is the name of the\n-  // package where the variable is defined.  UNIQUE_PREFIX is the\n-  // prefix for that package, from the -fgo-prefix option.  NAME is\n-  // the name of the variable.  BTYPE is the type of the variable.\n-  // IS_EXTERNAL is true if the variable is defined in some other\n-  // package.  IS_HIDDEN is true if the variable is not exported (name\n-  // begins with a lower case letter).  LOCATION is where the variable\n-  // was defined.\n+  // package where the variable is defined.  PKGPATH is the package\n+  // path for that package, from the -fgo-pkgpath or -fgo-prefix\n+  // option.  NAME is the name of the variable.  BTYPE is the type of\n+  // the variable.  IS_EXTERNAL is true if the variable is defined in\n+  // some other package.  IS_HIDDEN is true if the variable is not\n+  // exported (name begins with a lower case letter).  LOCATION is\n+  // where the variable was defined.\n   virtual Bvariable*\n   global_variable(const std::string& package_name,\n-\t\t  const std::string& unique_prefix,\n+\t\t  const std::string& pkgpath,\n \t\t  const std::string& name,\n \t\t  Btype* btype,\n \t\t  bool is_external,"}, {"sha": "13c61a589fe2f03b956c6ffe5f453411bd305d83", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -33,7 +33,7 @@ const int Export::v1_checksum_len;\n // Constructor.\n \n Export::Export(Stream* stream)\n-  : stream_(stream), type_refs_(), type_index_(1)\n+  : stream_(stream), type_refs_(), type_index_(1), packages_()\n {\n }\n \n@@ -91,7 +91,7 @@ should_export(Named_object* no)\n \n void\n Export::export_globals(const std::string& package_name,\n-\t\t       const std::string& unique_prefix,\n+\t\t       const std::string& pkgpath,\n \t\t       int package_priority,\n \t\t       const std::map<std::string, Package*>& imports,\n \t\t       const std::string& import_init_fn,\n@@ -140,9 +140,9 @@ Export::export_globals(const std::string& package_name,\n   this->write_string(package_name);\n   this->write_c_string(\";\\n\");\n \n-  // The unique prefix.  This prefix is used for all global symbols.\n-  this->write_c_string(\"prefix \");\n-  this->write_string(unique_prefix);\n+  // The package path, used for all global symbols.\n+  this->write_c_string(\"pkgpath \");\n+  this->write_string(pkgpath);\n   this->write_c_string(\";\\n\");\n \n   // The package priority.\n@@ -209,12 +209,14 @@ Export::write_imports(const std::map<std::string, Package*>& imports)\n        ++p)\n     {\n       this->write_c_string(\"import \");\n-      this->write_string(p->second->name());\n+      this->write_string(p->second->package_name());\n       this->write_c_string(\" \");\n-      this->write_string(p->second->unique_prefix());\n+      this->write_string(p->second->pkgpath());\n       this->write_c_string(\" \\\"\");\n       this->write_string(p->first);\n       this->write_c_string(\"\\\";\\n\");\n+\n+      this->packages_.insert(p->second);\n     }\n }\n \n@@ -333,7 +335,7 @@ Export::write_type(const Type* type)\n \t{\n \t  // The builtin types should have been predefined.\n \t  go_assert(!Linemap::is_predeclared_location(named_type->location())\n-\t\t     || (named_type->named_object()->package()->name()\n+\t\t     || (named_type->named_object()->package()->package_name()\n \t\t\t == \"unsafe\"));\n \t  named_object = named_type->named_object();\n \t}\n@@ -345,15 +347,26 @@ Export::write_type(const Type* type)\n       std::string s = \"\\\"\";\n       if (package != NULL && !Gogo::is_hidden_name(named_object->name()))\n \t{\n-\t  s += package->unique_prefix();\n-\t  s += '.';\n-\t  s += package->name();\n+\t  s += package->pkgpath();\n \t  s += '.';\n \t}\n       s += named_object->name();\n       s += \"\\\" \";\n       this->write_string(s);\n \n+      // It is possible that this type was imported indirectly, and is\n+      // not in a package in the import list.  If we have not\n+      // mentioned this package before, write out the package name\n+      // here so that any package importing this one will know it.\n+      if (package != NULL\n+\t  && this->packages_.find(package) == this->packages_.end())\n+\t{\n+\t  this->write_c_string(\"\\\"\");\n+\t  this->write_string(package->package_name());\n+\t  this->packages_.insert(package);\n+\t  this->write_c_string(\"\\\" \");\n+\t}\n+\n       // We must add a named type to the table now, since the\n       // definition of the type may refer to the named type via a\n       // pointer."}, {"sha": "c6a4810510a308f25aefd9c340e96a22ba03c9a0", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -117,15 +117,15 @@ class Export : public String_dump\n   // Export the identifiers in BINDINGS which are marked for export.\n   // The exporting is done via a series of calls to THIS->STREAM_.  If\n   // is nothing to export, this->stream_->write will not be called.\n-  // UNIQUE_PREFIX is a prefix for all global symbols.\n+  // PKGPATH is the package path.\n   // PACKAGE_PRIORITY is the priority to use for this package.\n   // IMPORT_INIT_FN is the name of the import initialization function\n   // for this package; it will be empty if none is needed.\n   // IMPORTED_INIT_FNS is the list of initialization functions for\n   // imported packages.\n   void\n   export_globals(const std::string& package_name,\n-\t\t const std::string& unique_prefix,\n+\t\t const std::string& pkgpath,\n \t\t int package_priority,\n \t\t const std::map<std::string, Package*>& imports,\n \t\t const std::string& import_init_fn,\n@@ -182,6 +182,8 @@ class Export : public String_dump\n   Type_refs type_refs_;\n   // Index number of next type.\n   int type_index_;\n+  // Packages we have written out.\n+  Unordered_set(const Package*) packages_;\n };\n \n // An export streamer which puts the export stream in a named section."}, {"sha": "1f2ce8adcde55178a3e31484fae3e600d11405a7", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -13,50 +13,29 @@\n #include \"backend.h\"\n #include \"gogo.h\"\n \n-// The unique prefix to use for exported symbols.  This is set during\n-// option processing.\n-\n-static std::string unique_prefix;\n-\n // The data structures we build to represent the file.\n static Gogo* gogo;\n \n // Create the main IR data structure.\n \n GO_EXTERN_C\n void\n-go_create_gogo(int int_type_size, int pointer_size)\n+go_create_gogo(int int_type_size, int pointer_size, const char *pkgpath,\n+\t       const char *prefix)\n {\n   go_assert(::gogo == NULL);\n   Linemap* linemap = go_get_linemap();\n   ::gogo = new Gogo(go_get_backend(), linemap, int_type_size, pointer_size);\n-  if (!unique_prefix.empty())\n-    ::gogo->set_unique_prefix(unique_prefix);\n+\n+  if (pkgpath != NULL)\n+    ::gogo->set_pkgpath(pkgpath);\n+  else if (prefix != NULL)\n+    ::gogo->set_prefix(prefix);\n \n   // FIXME: This should be in the gcc dependent code.\n   ::gogo->define_builtin_function_trees();\n }\n \n-// Set the unique prefix we use for exported symbols.\n-\n-GO_EXTERN_C\n-void\n-go_set_prefix(const char* arg)\n-{\n-  unique_prefix = arg;\n-  for (size_t i = 0; i < unique_prefix.length(); ++i)\n-    {\n-      char c = unique_prefix[i];\n-      if ((c >= 'a' && c <= 'z')\n-\t  || (c >= 'A' && c <= 'Z')\n-\t  || (c >= '0' && c <= '9')\n-\t  || c == '_')\n-\t;\n-      else\n-\tunique_prefix[i] = '_';\n-    }\n-}\n-\n // Parse the input files.\n \n GO_EXTERN_C"}, {"sha": "5f74de5a8b3d70a0552e9f38415352bc9c264ecc", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -260,9 +260,7 @@ Gogo::get_init_fn_name()\n \t}\n       else\n \t{\n-\t  std::string s = this->unique_prefix();\n-\t  s.append(1, '.');\n-\t  s.append(this->package_name());\n+\t  std::string s = this->pkgpath_symbol();\n \t  s.append(\"..import\");\n \t  this->init_fn_name_ = s;\n \t}\n@@ -984,7 +982,7 @@ Named_object::get_id(Gogo* gogo)\n       if (this->package_ == NULL)\n \tpackage_name = gogo->package_name();\n       else\n-\tpackage_name = this->package_->name();\n+\tpackage_name = this->package_->package_name();\n \n       decl_name = package_name + '.' + Gogo::unpack_hidden_name(this->name_);\n \n@@ -1277,9 +1275,15 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t\t   || this->type_->is_method())\n \t    {\n \t      TREE_PUBLIC(decl) = 1;\n-\t      std::string asm_name = gogo->unique_prefix();\n+\t      std::string asm_name = gogo->pkgpath_symbol();\n \t      asm_name.append(1, '.');\n-\t      asm_name.append(IDENTIFIER_POINTER(id), IDENTIFIER_LENGTH(id));\n+\t      asm_name.append(Gogo::unpack_hidden_name(no->name()));\n+\t      if (this->type_->is_method())\n+\t\t{\n+\t\t  asm_name.append(1, '.');\n+\t\t  Type* rtype = this->type_->receiver()->type();\n+\t\t  asm_name.append(rtype->mangled_name(gogo));\n+\t\t}\n \t      SET_DECL_ASSEMBLER_NAME(decl,\n \t\t\t\t      get_identifier_from_string(asm_name));\n \t    }\n@@ -1382,10 +1386,16 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t  if (this->asm_name_.empty())\n \t    {\n \t      std::string asm_name = (no->package() == NULL\n-\t\t\t\t      ? gogo->unique_prefix()\n-\t\t\t\t      : no->package()->unique_prefix());\n+\t\t\t\t      ? gogo->pkgpath_symbol()\n+\t\t\t\t      : no->package()->pkgpath_symbol());\n \t      asm_name.append(1, '.');\n-\t      asm_name.append(IDENTIFIER_POINTER(id), IDENTIFIER_LENGTH(id));\n+\t      asm_name.append(Gogo::unpack_hidden_name(no->name()));\n+\t      if (this->fntype_->is_method())\n+\t\t{\n+\t\t  asm_name.append(1, '.');\n+\t\t  Type* rtype = this->fntype_->receiver()->type();\n+\t\t  asm_name.append(rtype->mangled_name(gogo));\n+\t\t}\n \t      SET_DECL_ASSEMBLER_NAME(decl,\n \t\t\t\t      get_identifier_from_string(asm_name));\n \t    }"}, {"sha": "80ffe240c7f58125382ccfb8dc04881f7eeb3918", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 148, "deletions": 108, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -36,8 +36,12 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int int_type_size,\n     need_init_fn_(false),\n     init_fn_name_(),\n     imported_init_fns_(),\n-    unique_prefix_(),\n-    unique_prefix_specified_(false),\n+    pkgpath_(),\n+    pkgpath_symbol_(),\n+    prefix_(),\n+    pkgpath_set_(false),\n+    pkgpath_from_option_(false),\n+    prefix_from_option_(false),\n     verify_types_(),\n     interface_types_(),\n     specific_type_functions_(),\n@@ -233,6 +237,72 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int int_type_size,\n   this->globals_->add_function_declaration(\"delete\", NULL, delete_type, loc);\n }\n \n+// Convert a pkgpath into a string suitable for a symbol.  Note that\n+// this transformation is convenient but imperfect.  A -fgo-pkgpath\n+// option of a/b_c will conflict with a -fgo-pkgpath option of a_b/c,\n+// possibly leading to link time errors.\n+\n+std::string\n+Gogo::pkgpath_for_symbol(const std::string& pkgpath)\n+{\n+  std::string s = pkgpath;\n+  for (size_t i = 0; i < s.length(); ++i)\n+    {\n+      char c = s[i];\n+      if ((c >= 'a' && c <= 'z')\n+\t  || (c >= 'A' && c <= 'Z')\n+\t  || (c >= '0' && c <= '9')\n+\t  || c == '_'\n+\t  || c == '.'\n+\t  || c == '$')\n+\t;\n+      else\n+\ts[i] = '_';\n+    }\n+  return s;\n+}\n+\n+// Get the package path to use for type reflection data.  This should\n+// ideally be unique across the entire link.\n+\n+const std::string&\n+Gogo::pkgpath() const\n+{\n+  go_assert(this->pkgpath_set_);\n+  return this->pkgpath_;\n+}\n+\n+// Set the package path from the -fgo-pkgpath command line option.\n+\n+void\n+Gogo::set_pkgpath(const std::string& arg)\n+{\n+  go_assert(!this->pkgpath_set_);\n+  this->pkgpath_ = arg;\n+  this->pkgpath_set_ = true;\n+  this->pkgpath_from_option_ = true;\n+}\n+\n+// Get the package path to use for symbol names.\n+\n+const std::string&\n+Gogo::pkgpath_symbol() const\n+{\n+  go_assert(this->pkgpath_set_);\n+  return this->pkgpath_symbol_;\n+}\n+\n+// Set the unique prefix to use to determine the package path, from\n+// the -fgo-prefix command line option.\n+\n+void\n+Gogo::set_prefix(const std::string& arg)\n+{\n+  go_assert(!this->prefix_from_option_);\n+  this->prefix_ = arg;\n+  this->prefix_from_option_ = true;\n+}\n+\n // Munge name for use in an error message.\n \n std::string\n@@ -247,7 +317,7 @@ const std::string&\n Gogo::package_name() const\n {\n   go_assert(this->package_ != NULL);\n-  return this->package_->name();\n+  return this->package_->package_name();\n }\n \n // Set the package name.\n@@ -256,24 +326,29 @@ void\n Gogo::set_package_name(const std::string& package_name,\n \t\t       Location location)\n {\n-  if (this->package_ != NULL && this->package_->name() != package_name)\n+  if (this->package_ != NULL)\n     {\n-      error_at(location, \"expected package %<%s%>\",\n-\t       Gogo::message_name(this->package_->name()).c_str());\n+      if (this->package_->package_name() != package_name)\n+\terror_at(location, \"expected package %<%s%>\",\n+\t\t Gogo::message_name(this->package_->package_name()).c_str());\n       return;\n     }\n \n-  // If the user did not specify a unique prefix, we always use \"go\".\n-  // This in effect requires that the package name be unique.\n-  if (this->unique_prefix_.empty())\n-    this->unique_prefix_ = \"go\";\n+  // Now that we know the name of the package we are compiling, set\n+  // the package path to use for reflect.Type.PkgPath and global\n+  // symbol names.\n+  if (!this->pkgpath_set_)\n+    {\n+      if (!this->prefix_from_option_)\n+\tthis->prefix_ = \"go\";\n+      this->pkgpath_ = this->prefix_ + '.' + package_name;\n+      this->pkgpath_set_ = true;\n+    }\n \n-  this->package_ = this->register_package(package_name, this->unique_prefix_,\n-\t\t\t\t\t  location);\n+  this->pkgpath_symbol_ = Gogo::pkgpath_for_symbol(this->pkgpath_);\n \n-  // We used to permit people to qualify symbols with the current\n-  // package name (e.g., P.x), but we no longer do.\n-  // this->globals_->add_package(package_name, this->package_);\n+  this->package_ = this->register_package(this->pkgpath_, location);\n+  this->package_->set_package_name(package_name, location);\n \n   if (this->is_main_package())\n     {\n@@ -287,12 +362,14 @@ Gogo::set_package_name(const std::string& package_name,\n }\n \n // Return whether this is the \"main\" package.  This is not true if\n-// -fgo-prefix was used.\n+// -fgo-pkgpath or -fgo-prefix was used.\n \n bool\n Gogo::is_main_package() const\n {\n-  return this->package_name() == \"main\" && !this->unique_prefix_specified_;\n+  return (this->package_name() == \"main\"\n+\t  && !this->pkgpath_from_option_\n+\t  && !this->prefix_from_option_);\n }\n \n // Import a package.\n@@ -319,7 +396,8 @@ Gogo::import_package(const std::string& filename,\n       bool is_ln_exported = is_local_name_exported;\n       if (ln.empty())\n \t{\n-\t  ln = package->name();\n+\t  ln = package->package_name();\n+\t  go_assert(!ln.empty());\n \t  is_ln_exported = Lex::is_exported_name(ln);\n \t}\n       if (ln == \".\")\n@@ -353,11 +431,10 @@ Gogo::import_package(const std::string& filename,\n   Package* package = imp.import(this, local_name, is_local_name_exported);\n   if (package != NULL)\n     {\n-      if (package->name() == this->package_name()\n-\t  && package->unique_prefix() == this->unique_prefix())\n+      if (package->pkgpath() == this->pkgpath())\n \terror_at(location,\n-\t\t (\"imported package uses same package name and prefix \"\n-\t\t  \"as package being compiled (see -fgo-prefix option)\"));\n+\t\t (\"imported package uses same package path as package \"\n+\t\t  \"being compiled (see -fgo-pkgpath option)\"));\n \n       this->imports_.insert(std::make_pair(filename, package));\n       package->set_is_imported();\n@@ -510,96 +587,59 @@ Package*\n Gogo::add_imported_package(const std::string& real_name,\n \t\t\t   const std::string& alias_arg,\n \t\t\t   bool is_alias_exported,\n-\t\t\t   const std::string& unique_prefix,\n+\t\t\t   const std::string& pkgpath,\n \t\t\t   Location location,\n \t\t\t   bool* padd_to_globals)\n {\n-  // FIXME: Now that we compile packages as a whole, should we permit\n-  // importing the current package?\n-  if (this->package_name() == real_name\n-      && this->unique_prefix() == unique_prefix)\n-    {\n-      *padd_to_globals = false;\n-      if (!alias_arg.empty() && alias_arg != \".\")\n-\t{\n-\t  std::string alias = this->pack_hidden_name(alias_arg,\n-\t\t\t\t\t\t     is_alias_exported);\n-\t  this->package_->bindings()->add_package(alias, this->package_);\n-\t}\n-      return this->package_;\n-    }\n-  else if (alias_arg == \".\")\n-    {\n-      *padd_to_globals = true;\n-      return this->register_package(real_name, unique_prefix, location);\n-    }\n+  Package* ret = this->register_package(pkgpath, location);\n+  ret->set_package_name(real_name, location);\n+\n+  *padd_to_globals = false;\n+\n+  if (alias_arg == \".\")\n+    *padd_to_globals = true;\n   else if (alias_arg == \"_\")\n-    {\n-      Package* ret = this->register_package(real_name, unique_prefix, location);\n-      ret->set_uses_sink_alias();\n-      return ret;\n-    }\n+    ret->set_uses_sink_alias();\n   else\n     {\n-      *padd_to_globals = false;\n       std::string alias = alias_arg;\n       if (alias.empty())\n \t{\n \t  alias = real_name;\n \t  is_alias_exported = Lex::is_exported_name(alias);\n \t}\n       alias = this->pack_hidden_name(alias, is_alias_exported);\n-      Named_object* no = this->add_package(real_name, alias, unique_prefix,\n-\t\t\t\t\t   location);\n+      Named_object* no = this->package_->bindings()->add_package(alias, ret);\n       if (!no->is_package())\n \treturn NULL;\n-      return no->package_value();\n     }\n-}\n \n-// Add a package.\n-\n-Named_object*\n-Gogo::add_package(const std::string& real_name, const std::string& alias,\n-\t\t  const std::string& unique_prefix, Location location)\n-{\n-  go_assert(this->in_global_scope());\n-\n-  // Register the package.  Note that we might have already seen it in\n-  // an earlier import.\n-  Package* package = this->register_package(real_name, unique_prefix, location);\n-\n-  return this->package_->bindings()->add_package(alias, package);\n+  return ret;\n }\n \n // Register a package.  This package may or may not be imported.  This\n // returns the Package structure for the package, creating if it\n-// necessary.\n+// necessary.  LOCATION is the location of the import statement that\n+// led us to see this package.\n \n Package*\n-Gogo::register_package(const std::string& package_name,\n-\t\t       const std::string& unique_prefix,\n-\t\t       Location location)\n+Gogo::register_package(const std::string& pkgpath, Location location)\n {\n-  go_assert(!unique_prefix.empty() && !package_name.empty());\n-  std::string name = unique_prefix + '.' + package_name;\n   Package* package = NULL;\n   std::pair<Packages::iterator, bool> ins =\n-    this->packages_.insert(std::make_pair(name, package));\n+    this->packages_.insert(std::make_pair(pkgpath, package));\n   if (!ins.second)\n     {\n       // We have seen this package name before.\n       package = ins.first->second;\n-      go_assert(package != NULL);\n-      go_assert(package->name() == package_name\n-\t\t && package->unique_prefix() == unique_prefix);\n+      go_assert(package != NULL && package->pkgpath() == pkgpath);\n       if (Linemap::is_unknown_location(package->location()))\n \tpackage->set_location(location);\n     }\n   else\n     {\n       // First time we have seen this package name.\n-      package = new Package(package_name, unique_prefix, location);\n+      package = new Package(pkgpath, location);\n       go_assert(ins.first->second == NULL);\n       ins.first->second = package;\n     }\n@@ -1151,7 +1191,7 @@ Gogo::clear_file_scope()\n \t  && !package->uses_sink_alias()\n \t  && !saw_errors())\n \terror_at(package->location(), \"imported and not used: %s\",\n-\t\t Gogo::message_name(package->name()).c_str());\n+\t\t Gogo::message_name(package->package_name()).c_str());\n       package->clear_is_imported();\n       package->clear_uses_sink_alias();\n       package->clear_used();\n@@ -2822,27 +2862,6 @@ Gogo::check_return_statements()\n   this->traverse(&traverse);\n }\n \n-// Get the unique prefix to use before all exported symbols.  This\n-// must be unique across the entire link.\n-\n-const std::string&\n-Gogo::unique_prefix() const\n-{\n-  go_assert(!this->unique_prefix_.empty());\n-  return this->unique_prefix_;\n-}\n-\n-// Set the unique prefix to use before all exported symbols.  This\n-// comes from the command line option -fgo-prefix=XXX.\n-\n-void\n-Gogo::set_unique_prefix(const std::string& arg)\n-{\n-  go_assert(this->unique_prefix_.empty());\n-  this->unique_prefix_ = arg;\n-  this->unique_prefix_specified_ = true;\n-}\n-\n // Work out the package priority.  It is one more than the maximum\n // priority of an imported package.\n \n@@ -2870,7 +2889,7 @@ Gogo::do_exports()\n   Export exp(&stream);\n   exp.register_builtin_types(this);\n   exp.export_globals(this->package_name(),\n-\t\t     this->unique_prefix(),\n+\t\t     this->pkgpath(),\n \t\t     this->package_priority(),\n \t\t     this->imports_,\n \t\t     (this->need_init_fn_ && !this->is_main_package()\n@@ -4199,10 +4218,10 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t  if (this->is_global_)\n \t    bvar = backend->global_variable((package == NULL\n \t\t\t\t\t     ? gogo->package_name()\n-\t\t\t\t\t     : package->name()),\n+\t\t\t\t\t     : package->package_name()),\n \t\t\t\t\t    (package == NULL\n-\t\t\t\t\t     ? gogo->unique_prefix()\n-\t\t\t\t\t     : package->unique_prefix()),\n+\t\t\t\t\t     ? gogo->pkgpath_symbol()\n+\t\t\t\t\t     : package->pkgpath_symbol()),\n \t\t\t\t\t    n,\n \t\t\t\t\t    btype,\n \t\t\t\t\t    package != NULL,\n@@ -4556,7 +4575,12 @@ Named_object::message_name() const\n {\n   if (this->package_ == NULL)\n     return Gogo::message_name(this->name_);\n-  std::string ret = Gogo::message_name(this->package_->name());\n+  std::string ret;\n+  if (this->package_->has_package_name())\n+    ret = this->package_->package_name();\n+  else\n+    ret = this->package_->pkgpath();\n+  ret = Gogo::message_name(ret);\n   ret += '.';\n   ret += Gogo::message_name(this->name_);\n   return ret;\n@@ -5213,13 +5237,29 @@ Unnamed_label::get_goto(Translate_context* context, Location location)\n \n // Class Package.\n \n-Package::Package(const std::string& name, const std::string& unique_prefix,\n-\t\t Location location)\n-  : name_(name), unique_prefix_(unique_prefix), bindings_(new Bindings(NULL)),\n-    priority_(0), location_(location), used_(false), is_imported_(false),\n+Package::Package(const std::string& pkgpath, Location location)\n+  : pkgpath_(pkgpath), pkgpath_symbol_(Gogo::pkgpath_for_symbol(pkgpath)),\n+    package_name_(), bindings_(new Bindings(NULL)), priority_(0),\n+    location_(location), used_(false), is_imported_(false),\n     uses_sink_alias_(false)\n {\n-  go_assert(!name.empty() && !unique_prefix.empty());\n+  go_assert(!pkgpath.empty());\n+  \n+}\n+\n+// Set the package name.\n+\n+void\n+Package::set_package_name(const std::string& package_name, Location location)\n+{\n+  go_assert(!package_name.empty());\n+  if (this->package_name_.empty())\n+    this->package_name_ = package_name;\n+  else if (this->package_name_ != package_name)\n+    error_at(location,\n+\t     \"saw two different packages with the same package path %s: %s, %s\",\n+\t     this->pkgpath_.c_str(), this->package_name_.c_str(),\n+\t     package_name.c_str());\n }\n \n // Set the priority.  We may see multiple priorities for an imported"}, {"sha": "deb9968e84f25c0379aa64bdcf835c1f2f4fdaf4", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 74, "deletions": 41, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -138,16 +138,14 @@ class Gogo\n   is_main_package() const;\n \n   // If necessary, adjust the name to use for a hidden symbol.  We add\n-  // a prefix of the package name, so that hidden symbols in different\n-  // packages do not collide.\n+  // the package name, so that hidden symbols in different packages do\n+  // not collide.\n   std::string\n   pack_hidden_name(const std::string& name, bool is_exported) const\n   {\n     return (is_exported\n \t    ? name\n-\t    : ('.' + this->unique_prefix()\n-\t       + '.' + this->package_name()\n-\t       + '.' + name));\n+\t    : '.' + this->pkgpath() + '.' + name);\n   }\n \n   // Unpack a name which may have been hidden.  Returns the\n@@ -161,9 +159,9 @@ class Gogo\n   is_hidden_name(const std::string& name)\n   { return name[0] == '.'; }\n \n-  // Return the package prefix of a hidden name.\n+  // Return the package path of a hidden name.\n   static std::string\n-  hidden_name_prefix(const std::string& name)\n+  hidden_name_pkgpath(const std::string& name)\n   {\n     go_assert(Gogo::is_hidden_name(name));\n     return name.substr(1, name.rfind('.') - 1);\n@@ -183,13 +181,30 @@ class Gogo\n \t    && name[name.length() - 2] == '.');\n   }\n \n-  // Return the unique prefix to use for all exported symbols.\n+  // Convert a pkgpath into a string suitable for a symbol\n+  static std::string\n+  pkgpath_for_symbol(const std::string& pkgpath);\n+\n+  // Return the package path to use for reflect.Type.PkgPath.\n+  const std::string&\n+  pkgpath() const;\n+\n+  // Return the package path to use for a symbol name.\n   const std::string&\n-  unique_prefix() const;\n+  pkgpath_symbol() const;\n+\n+  // Set the package path from a command line option.\n+  void\n+  set_pkgpath(const std::string&);\n \n-  // Set the unique prefix.\n+  // Set the prefix from a command line option.\n   void\n-  set_unique_prefix(const std::string&);\n+  set_prefix(const std::string&);\n+\n+  // Return whether pkgpath was set from a command line option.\n+  bool\n+  pkgpath_from_option() const\n+  { return this->pkgpath_from_option_; }\n \n   // Return the priority to use for the package we are compiling.\n   // This is two more than the largest priority of any package we\n@@ -229,16 +244,15 @@ class Gogo\n   Package*\n   add_imported_package(const std::string& real_name, const std::string& alias,\n \t\t       bool is_alias_exported,\n-\t\t       const std::string& unique_prefix,\n+\t\t       const std::string& pkgpath,\n \t\t       Location location,\n \t\t       bool* padd_to_globals);\n \n   // Register a package.  This package may or may not be imported.\n   // This returns the Package structure for the package, creating if\n   // it necessary.\n   Package*\n-  register_package(const std::string& name, const std::string& unique_prefix,\n-\t\t   Location);\n+  register_package(const std::string& pkgpath, Location);\n \n   // Start compiling a function.  ADD_METHOD_TO_TYPE is true if a\n   // method function should be added to the type of its receiver.\n@@ -609,11 +623,6 @@ class Gogo\n   void\n   import_unsafe(const std::string&, bool is_exported, Location);\n \n-  // Add a new imported package.\n-  Named_object*\n-  add_package(const std::string& real_name, const std::string& alias,\n-\t      const std::string& unique_prefix, Location location);\n-\n   // Return the current binding contour.\n   Bindings*\n   current_bindings();\n@@ -711,10 +720,18 @@ class Gogo\n   std::string init_fn_name_;\n   // A list of import control variables for packages that we import.\n   std::set<Import_init> imported_init_fns_;\n-  // The unique prefix used for all global symbols.\n-  std::string unique_prefix_;\n-  // Whether an explicit unique prefix was set by -fgo-prefix.\n-  bool unique_prefix_specified_;\n+  // The package path used for reflection data.\n+  std::string pkgpath_;\n+  // The package path to use for a symbol name.\n+  std::string pkgpath_symbol_;\n+  // The prefix to use for symbols, from the -fgo-prefix option.\n+  std::string prefix_;\n+  // Whether pkgpath_ has been set.\n+  bool pkgpath_set_;\n+  // Whether an explicit package path was set by -fgo-pkgpath.\n+  bool pkgpath_from_option_;\n+  // Whether an explicit prefix was set by -fgo-prefix.\n+  bool prefix_from_option_;\n   // A list of types to verify.\n   std::vector<Type*> verify_types_;\n   // A list of interface types defined while parsing.\n@@ -2409,28 +2426,37 @@ class Unnamed_label\n class Package\n {\n  public:\n-  Package(const std::string& name, const std::string& unique_prefix,\n-\t  Location location);\n+  Package(const std::string& pkgpath, Location location);\n \n-  // The real name of this package.  This may be different from the\n-  // name in the associated Named_object if the import statement used\n-  // an alias.\n+  // Get the package path used for all symbols exported from this\n+  // package.\n   const std::string&\n-  name() const\n-  { return this->name_; }\n+  pkgpath() const\n+  { return this->pkgpath_; }\n+\n+  // Return the package path to use for a symbol name.\n+  const std::string&\n+  pkgpath_symbol() const\n+  { return this->pkgpath_symbol_; }\n \n   // Return the location of the import statement.\n   Location\n   location() const\n   { return this->location_; }\n \n-  // Get the unique prefix used for all symbols exported from this\n-  // package.\n+  // Return whether we know the name of this package yet.\n+  bool\n+  has_package_name() const\n+  { return !this->package_name_.empty(); }\n+\n+  // The name that this package uses in its package clause.  This may\n+  // be different from the name in the associated Named_object if the\n+  // import statement used an alias.\n   const std::string&\n-  unique_prefix() const\n+  package_name() const\n   {\n-    go_assert(!this->unique_prefix_.empty());\n-    return this->unique_prefix_;\n+    go_assert(!this->package_name_.empty());\n+    return this->package_name_;\n   }\n \n   // The priority of this package.  The init function of packages with\n@@ -2500,8 +2526,12 @@ class Package\n   lookup(const std::string& name) const\n   { return this->bindings_->lookup(name); }\n \n-  // Set the location of the package.  This is used if it is seen in a\n-  // different import before it is really imported.\n+  // Set the name of the package.\n+  void\n+  set_package_name(const std::string& name, Location);\n+\n+  // Set the location of the package.  This is used to record the most\n+  // recent import location.\n   void\n   set_location(Location location)\n   { this->location_ = location; }\n@@ -2537,10 +2567,13 @@ class Package\n   determine_types();\n \n  private:\n-  // The real name of this package.\n-  std::string name_;\n-  // The unique prefix for all exported global symbols.\n-  std::string unique_prefix_;\n+  // The package path for type reflection data.\n+  std::string pkgpath_;\n+  // The package path for symbol names.\n+  std::string pkgpath_symbol_;\n+  // The name that this package uses in the package clause.  This may\n+  // be the empty string if it is not yet known.\n+  std::string package_name_;\n   // The names in this package.\n   Bindings* bindings_;\n   // The priority of this package.  A package has a priority higher"}, {"sha": "9febf23189759b85d57b509585b2f361cb26274b", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 56, "deletions": 45, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -281,13 +281,24 @@ Import::import(Gogo* gogo, const std::string& local_name,\n       std::string package_name = this->read_identifier();\n       this->require_c_string(\";\\n\");\n \n-      this->require_c_string(\"prefix \");\n-      std::string unique_prefix = this->read_identifier();\n-      this->require_c_string(\";\\n\");\n+      std::string pkgpath;\n+      if (this->match_c_string(\"prefix \"))\n+\t{\n+\t  this->advance(7);\n+\t  std::string unique_prefix = this->read_identifier();\n+\t  this->require_c_string(\";\\n\");\n+\t  pkgpath = unique_prefix + '.' + package_name;\n+\t}\n+      else\n+\t{\n+\t  this->require_c_string(\"pkgpath \");\n+\t  pkgpath = this->read_identifier();\n+\t  this->require_c_string(\";\\n\");\n+\t}\n \n       this->package_ = gogo->add_imported_package(package_name, local_name,\n \t\t\t\t\t\t  is_local_name_exported,\n-\t\t\t\t\t\t  unique_prefix,\n+\t\t\t\t\t\t  pkgpath,\n \t\t\t\t\t\t  this->location_,\n \t\t\t\t\t\t  &this->add_to_globals_);\n       if (this->package_ == NULL)\n@@ -353,10 +364,18 @@ void\n Import::read_one_import()\n {\n   this->require_c_string(\"import \");\n+  std::string package_name = this->read_identifier();\n+  this->require_c_string(\" \");\n+  std::string pkgpath = this->read_identifier();\n+  this->require_c_string(\" \\\"\");\n   Stream* stream = this->stream_;\n-  while (stream->peek_char() != ';')\n+  while (stream->peek_char() != '\"')\n     stream->advance(1);\n-  this->require_c_string(\";\\n\");\n+  this->require_c_string(\"\\\";\\n\");\n+\n+  Package* p = this->gogo_->register_package(pkgpath,\n+\t\t\t\t\t     Linemap::unknown_location());\n+  p->set_package_name(package_name, this->location());\n }\n \n // Read the list of import control functions.\n@@ -572,64 +591,58 @@ Import::read_type()\n   while ((c = stream->get_char()) != '\"')\n     type_name += c;\n \n-  // If this type is in the current package, the name will be\n-  // .PREFIX.PACKAGE.NAME or simply NAME with no dots.  Otherwise, a\n-  // non-hidden symbol will be PREFIX.PACKAGE.NAME and a hidden symbol\n-  // will be .PREFIX.PACKAGE.NAME.\n-  std::string package_name;\n-  std::string unique_prefix;\n+  // If this type is in the package we are currently importing, the\n+  // name will be .PKGPATH.NAME or simply NAME with no dots.\n+  // Otherwise, a non-hidden symbol will be PKGPATH.NAME and a hidden\n+  // symbol will be .PKGPATH.NAME.\n+  std::string pkgpath;\n   if (type_name.find('.') != std::string::npos)\n     {\n-      bool is_hidden = false;\n       size_t start = 0;\n       if (type_name[0] == '.')\n-\t{\n-\t  ++start;\n-\t  is_hidden = true;\n-\t}\n-      size_t dot1 = type_name.find('.', start);\n-      size_t dot2;\n-      if (dot1 == std::string::npos)\n-\tdot2 = std::string::npos;\n-      else\n-\tdot2 = type_name.find('.', dot1 + 1);\n-      if (dot1 == std::string::npos || dot2 == std::string::npos)\n-\t{\n-\t  error_at(this->location_,\n-\t\t   (\"error at import data at %d: missing dot in type name\"),\n-\t\t   stream->pos());\n-\t  stream->set_saw_error();\n-\t}\n-      else\n-\t{\n-\t  unique_prefix = type_name.substr(start, dot1 - start);\n-\t  package_name = type_name.substr(dot1 + 1, dot2 - (dot1 + 1));\n-\t}\n-      if (!is_hidden)\n-\ttype_name.erase(0, dot2 + 1);\n+\tstart = 1;\n+      size_t dot = type_name.rfind('.');\n+      pkgpath = type_name.substr(start, dot - start);\n+      if (type_name[0] != '.')\n+\ttype_name.erase(0, dot + 1);\n     }\n \n   this->require_c_string(\" \");\n \n+  // The package name may follow.  This is the name of the package in\n+  // the package clause of that package.  The type name will include\n+  // the pkgpath, which may be different.\n+  std::string package_name;\n+  if (stream->peek_char() == '\"')\n+    {\n+      stream->advance(1);\n+      while ((c = stream->get_char()) != '\"')\n+\tpackage_name += c;\n+      this->require_c_string(\" \");\n+    }\n+\n   // Declare the type in the appropriate package.  If we haven't seen\n   // it before, mark it as invisible.  We declare it before we read\n   // the actual definition of the type, since the definition may refer\n   // to the type itself.\n   Package* package;\n-  if (package_name.empty())\n+  if (pkgpath.empty() || pkgpath == this->gogo_->pkgpath())\n     package = this->package_;\n   else\n-    package = this->gogo_->register_package(package_name, unique_prefix,\n-\t\t\t\t\t    Linemap::unknown_location());\n+    {\n+      package = this->gogo_->register_package(pkgpath,\n+\t\t\t\t\t      Linemap::unknown_location());\n+      if (!package_name.empty())\n+\tpackage->set_package_name(package_name, this->location());\n+    }\n \n   Named_object* no = package->bindings()->lookup(type_name);\n   if (no == NULL)\n     no = package->add_type_declaration(type_name, this->location_);\n   else if (!no->is_type_declaration() && !no->is_type())\n     {\n       error_at(this->location_, \"imported %<%s.%s%> both type and non-type\",\n-\t       Gogo::message_name(package->name()).c_str(),\n-\t       Gogo::message_name(type_name).c_str());\n+\t       pkgpath.c_str(), Gogo::message_name(type_name).c_str());\n       stream->set_saw_error();\n       return Type::make_error_type();\n     }\n@@ -772,9 +785,7 @@ Import::read_name()\n   if (ret == \"?\")\n     ret.clear();\n   else if (!Lex::is_exported_name(ret))\n-    ret = ('.' + this->package_->unique_prefix()\n-\t   + '.' + this->package_->name()\n-\t   + '.' + ret);\n+    ret = '.' + this->package_->pkgpath() + '.' + ret;\n   return ret;\n }\n "}, {"sha": "29323f05c6c3010af06498da138787b2ae4455b0", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -323,13 +323,13 @@ Parse::type_name(bool issue_error)\n \t  && package->name() != this->gogo_->package_name())\n \t{\n \t  // Check whether the name is there but hidden.\n-\t  std::string s = ('.' + package->package_value()->unique_prefix()\n-\t\t\t   + '.' + package->package_value()->name()\n+\t  std::string s = ('.' + package->package_value()->pkgpath()\n \t\t\t   + '.' + name);\n \t  named_object = package->package_value()->lookup(s);\n \t  if (named_object != NULL)\n \t    {\n-\t      const std::string& packname(package->package_value()->name());\n+\t      Package* p = package->package_value();\n+\t      const std::string& packname(p->package_name());\n \t      error_at(location, \"invalid reference to hidden type %<%s.%s%>\",\n \t\t       Gogo::message_name(packname).c_str(),\n \t\t       Gogo::message_name(name).c_str());\n@@ -345,7 +345,7 @@ Parse::type_name(bool issue_error)\n \tnamed_object = this->gogo_->add_unknown_name(name, location);\n       else\n \t{\n-\t  const std::string& packname(package->package_value()->name());\n+\t  const std::string& packname(package->package_value()->package_name());\n \t  error_at(location, \"reference to undefined identifier %<%s.%s%>\",\n \t\t   Gogo::message_name(packname).c_str(),\n \t\t   Gogo::message_name(name).c_str());\n@@ -2384,7 +2384,7 @@ Parse::operand(bool may_be_sink)\n \t  {\n \t    go_assert(package != NULL);\n \t    error_at(location, \"invalid reference to hidden type %<%s.%s%>\",\n-\t\t     Gogo::message_name(package->name()).c_str(),\n+\t\t     Gogo::message_name(package->package_name()).c_str(),\n \t\t     Gogo::message_name(id).c_str());\n \t    return Expression::make_error(location);\n \t  }\n@@ -2394,7 +2394,7 @@ Parse::operand(bool may_be_sink)\n \t  {\n \t    if (package != NULL)\n \t      {\n-\t\tstd::string n1 = Gogo::message_name(package->name());\n+\t\tstd::string n1 = Gogo::message_name(package->package_name());\n \t\tstd::string n2 = Gogo::message_name(id);\n \t\tif (!is_exported)\n \t\t  error_at(location,"}, {"sha": "35770c7657269f4bd003b3d092fdad1db8d56686", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -1301,23 +1301,31 @@ Type::type_descriptor_var_name(Gogo* gogo, Named_type* nt)\n     go_assert(in_function == NULL);\n   else\n     {\n-      const std::string& unique_prefix(no->package() == NULL\n-\t\t\t\t       ? gogo->unique_prefix()\n-\t\t\t\t       : no->package()->unique_prefix());\n-      const std::string& package_name(no->package() == NULL\n-\t\t\t\t      ? gogo->package_name()\n-\t\t\t\t      : no->package()->name());\n-      ret.append(unique_prefix);\n-      ret.append(1, '.');\n-      ret.append(package_name);\n+      const std::string& pkgpath(no->package() == NULL\n+\t\t\t\t ? gogo->pkgpath_symbol()\n+\t\t\t\t : no->package()->pkgpath_symbol());\n+      ret.append(pkgpath);\n       ret.append(1, '.');\n       if (in_function != NULL)\n \t{\n \t  ret.append(Gogo::unpack_hidden_name(in_function->name()));\n \t  ret.append(1, '.');\n \t}\n     }\n-  ret.append(no->name());\n+\n+  // FIXME: This adds in pkgpath twice for hidden symbols, which is\n+  // pointless.\n+  const std::string& name(no->name());\n+  if (!Gogo::is_hidden_name(name))\n+    ret.append(name);\n+  else\n+    {\n+      ret.append(1, '.');\n+      ret.append(Gogo::pkgpath_for_symbol(Gogo::hidden_name_pkgpath(name)));\n+      ret.append(1, '.');\n+      ret.append(Gogo::unpack_hidden_name(name));\n+    }\n+\n   return ret;\n }\n \n@@ -1977,15 +1985,10 @@ Type::uncommon_type_constructor(Gogo* gogo, Type* uncommon_type,\n       else\n \t{\n \t  const Package* package = no->package();\n-\t  const std::string& unique_prefix(package == NULL\n-\t\t\t\t\t   ? gogo->unique_prefix()\n-\t\t\t\t\t   : package->unique_prefix());\n-\t  const std::string& package_name(package == NULL\n-\t\t\t\t\t  ? gogo->package_name()\n-\t\t\t\t\t  : package->name());\n-\t  n.assign(unique_prefix);\n-\t  n.append(1, '.');\n-\t  n.append(package_name);\n+\t  const std::string& pkgpath(package == NULL\n+\t\t\t\t     ? gogo->pkgpath()\n+\t\t\t\t     : package->pkgpath());\n+\t  n.assign(pkgpath);\n \t  if (name->in_function() != NULL)\n \t    {\n \t      n.append(1, '.');\n@@ -2096,7 +2099,8 @@ Type::method_constructor(Gogo*, Type* method_type,\n     vals->push_back(Expression::make_nil(bloc));\n   else\n     {\n-      s = Expression::make_string(Gogo::hidden_name_prefix(method_name), bloc);\n+      s = Expression::make_string(Gogo::hidden_name_pkgpath(method_name),\n+\t\t\t\t  bloc);\n       vals->push_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n     }\n \n@@ -4668,7 +4672,7 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \tfvals->push_back(Expression::make_nil(bloc));\n       else\n \t{\n-\t  std::string n = Gogo::hidden_name_prefix(pf->field_name());\n+\t  std::string n = Gogo::hidden_name_pkgpath(pf->field_name());\n \t  Expression* s = Expression::make_string(n, bloc);\n \t  fvals->push_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n \t}\n@@ -7056,7 +7060,7 @@ Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t    mvals->push_back(Expression::make_nil(bloc));\n \t  else\n \t    {\n-\t      s = Gogo::hidden_name_prefix(pm->name());\n+\t      s = Gogo::hidden_name_pkgpath(pm->name());\n \t      e = Expression::make_string(s, bloc);\n \t      mvals->push_back(Expression::make_unary(OPERATOR_AND, e, bloc));\n \t    }\n@@ -7105,11 +7109,15 @@ Interface_type::do_reflection(Gogo* gogo, std::string* ret) const\n \t    {\n \t      if (!Gogo::is_hidden_name(p->name()))\n \t\tret->append(p->name());\n+\t      else if (gogo->pkgpath_from_option())\n+\t\tret->append(p->name().substr(1));\n \t      else\n \t\t{\n-\t\t  // This matches what the gc compiler does.\n-\t\t  std::string prefix = Gogo::hidden_name_prefix(p->name());\n-\t\t  ret->append(prefix.substr(prefix.find('.') + 1));\n+\t\t  // If no -fgo-pkgpath option, backward compatibility\n+\t\t  // for how this used to work before -fgo-pkgpath was\n+\t\t  // introduced.\n+\t\t  std::string pkgpath = Gogo::hidden_name_pkgpath(p->name());\n+\t\t  ret->append(pkgpath.substr(pkgpath.find('.') + 1));\n \t\t  ret->push_back('.');\n \t\t  ret->append(Gogo::unpack_hidden_name(p->name()));\n \t\t}\n@@ -7939,20 +7947,14 @@ Named_type::do_hash_for_method(Gogo* gogo) const\n   // where we are going to be comparing named types for equality.  In\n   // other cases, which are cases where the runtime is going to\n   // compare hash codes to see if the types are the same, we need to\n-  // include the package prefix and name in the hash.\n+  // include the pkgpath in the hash.\n   if (gogo != NULL && !Gogo::is_hidden_name(name) && !this->is_builtin())\n     {\n       const Package* package = this->named_object()->package();\n       if (package == NULL)\n-\t{\n-\t  ret = Type::hash_string(gogo->unique_prefix(), ret);\n-\t  ret = Type::hash_string(gogo->package_name(), ret);\n-\t}\n+\tret = Type::hash_string(gogo->pkgpath(), ret);\n       else\n-\t{\n-\t  ret = Type::hash_string(package->unique_prefix(), ret);\n-\t  ret = Type::hash_string(package->name(), ret);\n-\t}\n+\tret = Type::hash_string(package->pkgpath(), ret);\n     }\n \n   return ret;\n@@ -8324,11 +8326,16 @@ Named_type::do_reflection(Gogo* gogo, std::string* ret) const\n     }\n   if (!this->is_builtin())\n     {\n+      // We handle -fgo-prefix and -fgo-pkgpath differently here for\n+      // compatibility with how the compiler worked before\n+      // -fgo-pkgpath was introduced.\n       const Package* package = this->named_object_->package();\n-      if (package != NULL)\n-\tret->append(package->name());\n+      if (gogo->pkgpath_from_option())\n+\tret->append(package != NULL ? package->pkgpath() : gogo->pkgpath());\n       else\n-\tret->append(gogo->package_name());\n+\tret->append(package != NULL\n+\t\t    ? package->package_name()\n+\t\t    : gogo->package_name());\n       ret->push_back('.');\n     }\n   if (this->in_function_ != NULL)\n@@ -8355,15 +8362,10 @@ Named_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n     go_assert(this->in_function_ == NULL);\n   else\n     {\n-      const std::string& unique_prefix(no->package() == NULL\n-\t\t\t\t       ? gogo->unique_prefix()\n-\t\t\t\t       : no->package()->unique_prefix());\n-      const std::string& package_name(no->package() == NULL\n-\t\t\t\t      ? gogo->package_name()\n-\t\t\t\t      : no->package()->name());\n-      name = unique_prefix;\n-      name.append(1, '.');\n-      name.append(package_name);\n+      const std::string& pkgpath(no->package() == NULL\n+\t\t\t\t ? gogo->pkgpath_symbol()\n+\t\t\t\t : no->package()->pkgpath_symbol());\n+      name = pkgpath;\n       name.append(1, '.');\n       if (this->in_function_ != NULL)\n \t{\n@@ -9487,9 +9489,9 @@ Forward_declaration_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n       const Named_object* no = this->named_object();\n       std::string name;\n       if (no->package() == NULL)\n-\tname = gogo->package_name();\n+\tname = gogo->pkgpath_symbol();\n       else\n-\tname = no->package()->name();\n+\tname = no->package()->pkgpath_symbol();\n       name += '.';\n       name += Gogo::unpack_hidden_name(no->name());\n       char buf[20];"}, {"sha": "5d0c658d523db9e7db9152e4f1949580f7be1ce0", "filename": "gcc/go/gofrontend/unsafe.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Funsafe.cc?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -22,7 +22,7 @@ Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n   bool add_to_globals;\n   Package* package = this->add_imported_package(\"unsafe\", local_name,\n \t\t\t\t\t\tis_local_name_exported,\n-\t\t\t\t\t\t\"libgo_unsafe\",\n+\t\t\t\t\t\t\"libgo_unsafe.unsafe\",\n \t\t\t\t\t\tlocation, &add_to_globals);\n \n   if (package == NULL)"}, {"sha": "eb9ed9a63a09313251f3c70d866c6152ec2e8fa5", "filename": "gcc/go/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097b12fb975ba045fffebc2cb1de407d3dba4bbc/gcc%2Fgo%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Flang.opt?ref=097b12fb975ba045fffebc2cb1de407d3dba4bbc", "patch": "@@ -53,6 +53,10 @@ fgo-optimize-\n Go Joined RejectNegative\n -fgo-optimize-<type>\tTurn on optimization passes in the frontend\n \n+fgo-pkgpath=\n+Go Joined RejectNegative\n+-fgo-pkgpath=<string>\tSet Go package path\n+\n fgo-prefix=\n Go Joined RejectNegative\n -fgo-prefix=<string>\tSet package-specific prefix for exported Go names"}]}