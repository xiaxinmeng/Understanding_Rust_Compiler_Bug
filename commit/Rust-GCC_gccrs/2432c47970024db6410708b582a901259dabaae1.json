{"sha": "2432c47970024db6410708b582a901259dabaae1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQzMmM0Nzk3MDAyNGRiNjQxMDcwOGI1ODJhOTAxMjU5ZGFiYWFlMQ==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2021-02-11T20:15:26Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2021-02-11T20:16:05Z"}, "message": "rs6000: Fix invalid address used in MMA built-in function\n\nThe mma_assemble_input_operand predicate is too lenient on the memory\noperands it will accept, leading to an ICE when illegitimate addresses\nare passed in.  The solution is to only accept memory operands with\naddresses that are valid for quad word memory accesses.  The test case\nis a minimized test case from the Eigen library.  The creduced test case\nis very noisy with respect to warnings, so the test case has added -w to\nsilence them.\n\n2021-02-11  Peter Bergner  <bergner@linux.ibm.com>\n\ngcc/\n\tPR target/99041\n\t* config/rs6000/predicates.md (mma_assemble_input_operand): Restrict\n\tmemory addresses that are legal for quad word accesses.\n\ngcc/testsuite/\n\tPR target/99041\n\t* g++.target/powerpc/pr99041.C: New test.", "tree": {"sha": "069e47893ec78ca29c60ddb3e2423c02fc4f327e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/069e47893ec78ca29c60ddb3e2423c02fc4f327e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2432c47970024db6410708b582a901259dabaae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2432c47970024db6410708b582a901259dabaae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2432c47970024db6410708b582a901259dabaae1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2432c47970024db6410708b582a901259dabaae1/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc0f7db7ebb649fc4c290cb7327fba5c17d4ed28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc0f7db7ebb649fc4c290cb7327fba5c17d4ed28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc0f7db7ebb649fc4c290cb7327fba5c17d4ed28"}], "stats": {"total": 88, "additions": 87, "deletions": 1}, "files": [{"sha": "bd26c62b3a416a2647794722530545206b555a1c", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2432c47970024db6410708b582a901259dabaae1/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2432c47970024db6410708b582a901259dabaae1/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=2432c47970024db6410708b582a901259dabaae1", "patch": "@@ -1156,7 +1156,9 @@\n ;; Return 1 if this operand is valid for a MMA assemble accumulator insn.\n (define_special_predicate \"mma_assemble_input_operand\"\n   (match_test \"(mode == V16QImode\n-\t\t&& (vsx_register_operand (op, mode) || MEM_P (op)))\"))\n+\t\t&& (vsx_register_operand (op, mode)\n+\t\t    || (MEM_P (op)\n+\t\t\t&& quad_address_p (XEXP (op, 0), mode, false))))\"))\n \n ;; Return 1 if this operand is valid for an MMA disassemble insn.\n (define_predicate \"mma_disassemble_output_operand\""}, {"sha": "c83f980657004164de04b9ff9e0416c1bd6742e6", "filename": "gcc/testsuite/g++.target/powerpc/pr99041.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2432c47970024db6410708b582a901259dabaae1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fpowerpc%2Fpr99041.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2432c47970024db6410708b582a901259dabaae1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fpowerpc%2Fpr99041.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fpowerpc%2Fpr99041.C?ref=2432c47970024db6410708b582a901259dabaae1", "patch": "@@ -0,0 +1,84 @@\n+/* PR target/99041 */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10 -w\" } */\n+\n+/* Verify we do not ICE on the following source.  */\n+\n+long a, b, c, d, e;\n+ enum { f };\n+ enum { g, aa };\n+ enum { h };\n+ template < typename > struct ai;\n+ template < typename > struct ad;\n+ template < typename, int, int ah, int = 0, int = f, int = ah > class ab;\n+ template < typename > class ar;\n+ template < typename > class ak;\n+ template < typename, int, int = 1, bool = false > class aj;\n+ template < typename > class an;\n+ template < typename, typename > class al;\n+ template < typename, typename, int = h > class am;\n+ template < typename, unsigned > class ao;\n+ template < typename > struct ap;\n+ template < typename aq > struct av { typedef ar< aq > ac; };\n+ template < typename > struct as {   typedef av< am< al< int, an< aj< ab< double, 5, 2 >, false > > >, int > >::ac       ac; };\n+ template < typename at > at au(const typename ap< at >::ac *);\n+ template < typename at, int > at cc(typename ap< at >::ac *aw) {   return au< at >(aw); }\n+ typedef __attribute__((altivec(vector__))) double ax;\n+ template <> struct ap< ax > { typedef double ac; };\n+ template <> ax au(const double *aw) { return __builtin_vec_vsx_ld(0, aw); }\n+ template < typename > struct ay {};\n+ template < typename aq > class ae : public ad< aq > { public:   typedef typename ai< aq >::ba ba; };\n+ template < typename aq > class ar : public ae< aq > { public:   ak< aq > bk(); };\n+ template < typename > struct ad {};\n+ template < int > class bc;\n+ template < typename bd, typename bf, int bg > struct ai< am< bd, bf, bg > > {   typedef typename bd::ba ba; };\n+ template < typename bh, typename bj, int bg > class am : public bc< bg > { public:   bh bu();   bj k(); };\n+ template < int bg > class bc : public as< am< int, int, bg > >::ac {};\n+ template < typename, typename, typename > struct l;\n+ template < typename m, typename bl, typename ag > void n(m bm, bl bn, ag bo) {   l< m, bl, ag >::bz(bm, bn, bo); }\n+ template < typename, typename, typename, typename > struct bp;\n+ class o { public:   o(double *, long);   double &operator()(long i, long j) { return p[aa ? j + i * w : w]; }   template < typename q, int t > q br(long i, long j) {     double &cl = operator()(i, j);     return cc< q, t >(&cl);   }   double *p;   long w; };\n+ class bt : public o { public:   bt(double *cf, long bv) : o(cf, bv) {} };\n+ struct bw {   enum { bx }; };\n+ template < typename bq > class ak { public:   template < typename by > void operator=(by) {     am< al< const an< const aj< aj< ab< double, 5, 5, 2 >, -1, -1 >, -1 > >,             const an< const aj< aj< ab< double, 5, 5, 2 >, -1, -1 >, -1 > > >,         ao< aj< ab< double, 5, 0 >, 1 >, 0 > >         ck;     n(ca, ck, ay< typename by::ba >());   }   bq ca; };\n+ template < typename aq > class dn : public av< aq >::ac {};\n+ template < typename cd, int af, int ah, int ce, int co, int cg > struct ai< ab< cd, af, ah, ce, co, cg > > {   typedef cd ba;   enum { bs }; };\n+ template < typename, int, int, int, int co, int cg > class ab : public dn< ab< int, co, cg > > { public:   template < typename by > ab(by); };\n+ template < typename, typename ch > class al : public ch {};\n+ template < typename aq > class az { public:   typedef typename ai< aq >::ba ba;   typedef const ba *ci;   ba &cj(long); };\n+ template < typename ct > class bb : public az< ct > { public:   bb(typename bb::ci, long); };\n+ template < typename cx, int cm, int cn, bool da > struct ai< aj< cx, cm, cn, da > > : ai< cx > {};\n+ template < typename > class cp;\n+ template < typename cx, int, int, bool > class aj : public cp< cx > { public:   aj(cx, long, long, long, long); };\n+ template < typename cx > class cp : public av< aj< cx, 1 > >::ac {};\n+ template < typename cq > class an : public cq {};\n+ template < typename cq, unsigned cr > struct ai< ao< cq, cr > > {   typedef cq cs; };\n+ template < typename, unsigned > class ao { public:   typedef aj< ab< double, 5, 0 >, 1 > cq;   typename ai< ao >::cs cu(); };\n+ template < typename, typename > struct cv;\n+ template < typename cw, typename bd, typename bf, int dh, typename ba > struct l< cw, am< bd, bf, dh >, ay< ba > > {   static void bz(cw bm, am< bd, bf > bn, ay< ba >) {     cv< bd, bf >::cy(bm, bn.bu(), bn.k());   } };\n+ template < typename bf, typename aq > struct cz {   template < typename m >   static void   cy(m bm,      al< const an< const aj< aj< ab< double, 5, 5, 2 >, -1, -1 >, -1 > >,          const an< const aj< aj< ab< double, 5, 5, 2 >, -1, -1 >, -1 > > >          bu,      bf) {     dl(bm, bu);   }   template < typename m >   static void   dl(m bm, al< const an< const aj< aj< ab< double, 5, 5, 2 >, -1, -1 >, -1 > >,                const an< const aj< aj< ab< double, 5, 5, 2 >, -1, -1 >, -1 > > >                bu) {     typename alpha;     bf k;     aq::dl(bm, bu, k, alpha);   } };\n+ template < typename, typename, bool > struct u;\n+ template < typename bd, typename bf > struct cv : cz< bf, cv< bd, bf > > {   template < typename v >   static void dl(v bm, bd bu, bf k, typename am< bd, bf >::ba alpha) {     u< bd, typename bf::cq, false >::bz(bm, bu, k.cu(), alpha);   } };\n+ template < typename, int, typename, bool, typename, bool, int, int = g > struct db;\n+ template < typename cb, int x, typename z, bool dc, typename dd, bool de,            int df > struct db< cb, x, z, dc, dd, de, aa, df > {   typedef z dg;   static void bz(cb, cb, const z *, cb, const dd *, cb, dg *, cb, const dg &); };\n+ template < typename cb, int x, typename z, bool dc, typename dd, bool de,            int df > void db< cb, x, z, dc, dd, de, aa, df >::bz(cb, cb, const z *_lhs, cb di,                                             const dd *dj, cb dk, dg *_res,                                             cb dm, const dg &alpha) {   cb cols;   bb< ab< z, 1, aa > > bu(_lhs, cols), res(_res, dm);   bb< ab< dd, 1, 1 > > k(dj, cols);   for (cb pi;;) {     cb actualPanelWidth, s, r;     bp< cb, bt, dd, bt >::bz(actualPanelWidth, r, bt(&bu.cj(s), di),                              bt(&k.cj(s), dk), &res.cj(pi), dm, alpha);   } }\n+ template < int, int > struct trmv_selector;\n+ template < typename bd, typename bf > struct u< bd, bf, false > {   template < typename v >   static void bz(v bm, bd bu, bf k, typename v::ba alpha) {     v dstT(bm);     trmv_selector< 0, ai< bf >::bs ?: aa >::bz(k, bu, dstT, alpha);   } };\n+ template < int x > struct trmv_selector< x, aa > {   template < typename bd, typename bf, typename v >   static void bz(bd, bf, v, typename v::ba) {     typedef typename bf::ba dd;     typedef bw LhsBlasTraits;     typedef bw RhsBlasTraits;     typename actualAlpha;     dd actualRhsPtr;     db< long, x, typename bd::ba, LhsBlasTraits::bx, dd, RhsBlasTraits::bx,         aa >::bz(0, 0, 0, 0, &actualRhsPtr, 1, 0, 0, actualAlpha);   } };\n+ template < typename LhsPacket, typename, bool > void pger_vec(__vector_quad *, __vector_pair &, LhsPacket);\n+ template < typename, typename, typename, typename, typename, typename > void gemv_row(bt alhs) {   typedef ax LhsPacket;   typedef ax RhsPacket;   bt bu(alhs);   enum { LhsAlignment, LhsPacketSize };   long i, j;   __vector_quad c0;   for (;; j += LhsPacketSize) {     RhsPacket b0;     __vector_pair b00;     __builtin_mma_assemble_pair(&b00,                                 (__attribute__((altivec(vector__))) char)                                     bu.br< LhsPacket, LhsAlignment >(1, j),                                 (__attribute__((altivec(vector__))) char)                                     bu.br< LhsPacket, LhsAlignment >(i, j));     pger_vec< LhsPacket, RhsPacket, true >(&c0, b00, b0);   } }\n+ template < typename cb, typename LhsMapper, typename RhsMapper > struct bp< cb, LhsMapper, double, RhsMapper > {   static void bz(cb, cb, LhsMapper bu, RhsMapper, double *, cb, double) {     gemv_row< cb, double, LhsMapper, double, RhsMapper, double >(bu);   } };\n+ class be { public:   template < typename v, typename Workspace > void cy(v, Workspace workspace) {     applyThisOnTheLeft(workspace, true);   }   template < typename v, typename Workspace >   void applyThisOnTheLeft(v bm, Workspace) {     aj< ab< double, 5, 0 >, 1 > sub_vecs1(m_vectors, c, a, c, b);     aj< v, 1 > sub_dst(bm, d, 0, e, 0);     apply_block_householder_on_the_left(sub_dst, sub_vecs1, b);   }   ab< double, 5, 5 > m_vectors; };\n+ template < typename TriangularFactorType, typename VectorsType,            typename CoeffsType > void make_block_householder_triangular_factor(TriangularFactorType triFactor,                                               VectorsType vectors, CoeffsType) {   triFactor.bk() = vectors; }\n+ template < typename cq, typename VectorsType, typename CoeffsType > void apply_block_householder_on_the_left(cq, VectorsType vectors,                                          CoeffsType hCoeffs) {   enum { TFactorSize };   ab< typename cq::ba, TFactorSize, aa > y(0);   make_block_householder_triangular_factor(y, vectors, hCoeffs); }\n+ class HessenbergDecomposition { public:   be matrixQ(); };\n+ template < typename > class RealSchur { public:   enum { MaxColsAtCompileTime };   template < typename InputType >   RealSchur &compute(const ad< InputType > &, bool);   ab< double, 5, 5 > m_matU;   ab< double, MaxColsAtCompileTime, 1 > m_workspaceVector;   HessenbergDecomposition m_hess; };\n+ template < typename cq > template < typename InputType > RealSchur< cq > &RealSchur< cq >::compute(const ad< InputType > &, bool) {   m_hess.matrixQ().cy(m_matU, m_workspaceVector); }\n+ template < typename > class EigenSolver { public:   EigenSolver();   template < typename InputType >   EigenSolver &compute(const ad< InputType > &, bool = true);   RealSchur< int > m_realSchur; };\n+ template < typename cq > template < typename InputType > EigenSolver< cq > &EigenSolver< cq >::compute(const ad< InputType > &matrix,                                               bool computeEigenvectors) {   m_realSchur.compute(matrix, computeEigenvectors); }\n+ class PolynomialSolver { public:   PolynomialSolver(ab< double, 0, 1 >) {     ab< int, 0, 0 > __trans_tmp_1 = m_eigenSolver.compute(__trans_tmp_1);   }   EigenSolver< double > m_eigenSolver; };\n+ struct increment_if_fixed_size {   enum { bi }; };\n+ template < int, typename, typename > void aux_evalSolver(ab< double, 0, 1 > pols) {   PolynomialSolver solve_constr(pols); }\n+ template < int Deg, typename > void evalSolver(ab< double, 0, 1 > pols) {   aux_evalSolver< Deg, ab< double, 0, 1 >, PolynomialSolver >(pols); }\n+ template < typename, int _Deg > void polynomialsolver(int) {   ab< double, increment_if_fixed_size::bi, 1 > pols = 1;   evalSolver< _Deg, ab< double, increment_if_fixed_size::bi, 1 > >(pols); }\n+ void test_polynomialsolver() { polynomialsolver< double, 5 >(5); }"}]}