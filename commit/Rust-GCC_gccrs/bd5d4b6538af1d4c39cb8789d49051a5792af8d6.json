{"sha": "bd5d4b6538af1d4c39cb8789d49051a5792af8d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ1ZDRiNjUzOGFmMWQ0YzM5Y2I4Nzg5ZDQ5MDUxYTU3OTJhZjhkNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-12-15T17:05:01Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-12-15T17:05:01Z"}, "message": "nvptx.md (nvptx_register_operand): Don't accept and then reject subregs.\n\n\t* config/nvptx/nvptx.md (nvptx_register_operand): Don't accept and\n\tthen reject subregs.\n\t(nvptx_reg_or_mem_operand): Likewise.\n\t(nvptx_nonmemory_operand): Likewise.\n\t(call_insn_operand): A regular predicate, check\tSYMBOL_REF_FUNCTION_P.\n\t(call_insn, call_value_insn): Address is not SImode.\n\t* config/nvptx/nvptx.h (FIXED_REGISTERS): Make return reg fixed.\n\t(enum reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS): Remove\n\tRETURN_REG class.\n\t(REGNO_REG_CLASS): Alwaus ALL_REGS.\n\t(PROMOTE_MODE): QI and HI are the only smaller than SI int modes.\n\t(HARD_FRAME_POINTER_REGNUM): Delete.\n\t(REGISTER_NAMES): Move earlier.\n\t(struct nvptx_args): Remove 'off'.\n\t(INIT_CUMULATIVE_ARGS): Don't initialize 'off'.\n\t(ELIMINABLE_REGS): Remove HARD_FRAME_POINTER_REGNUM.\n\t* config/nvptx/nvptx.c (arg_promotion): Delete.\n\t(nvptx_expand_call): Remove check for funtype being an fntype.\n\nFrom-SVN: r231659", "tree": {"sha": "d9aa9198df7b790b77fd9e726c956aebaadd2aaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9aa9198df7b790b77fd9e726c956aebaadd2aaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd5d4b6538af1d4c39cb8789d49051a5792af8d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5d4b6538af1d4c39cb8789d49051a5792af8d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd5d4b6538af1d4c39cb8789d49051a5792af8d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5d4b6538af1d4c39cb8789d49051a5792af8d6/comments", "author": null, "committer": null, "parents": [{"sha": "951c9e90e3c73a73dde3bbeb43a7bf882803b254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/951c9e90e3c73a73dde3bbeb43a7bf882803b254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/951c9e90e3c73a73dde3bbeb43a7bf882803b254"}], "stats": {"total": 113, "additions": 47, "deletions": 66}, "files": [{"sha": "31ea67f20185dedd082b34967c18804d01993ce9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5d4b6538af1d4c39cb8789d49051a5792af8d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5d4b6538af1d4c39cb8789d49051a5792af8d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd5d4b6538af1d4c39cb8789d49051a5792af8d6", "patch": "@@ -1,3 +1,24 @@\n+2015-12-15  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx.md (nvptx_register_operand): Don't accept and\n+\tthen reject subregs.\n+\t(nvptx_reg_or_mem_operand): Likewise.\n+\t(nvptx_nonmemory_operand): Likewise.\n+\t(call_insn_operand): A regular predicate, check\tSYMBOL_REF_FUNCTION_P.\n+\t(call_insn, call_value_insn): Address is not SImode.\n+\t* config/nvptx/nvptx.h (FIXED_REGISTERS): Make return reg fixed.\n+\t(enum reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS): Remove\n+\tRETURN_REG class.\n+\t(REGNO_REG_CLASS): Alwaus ALL_REGS.\n+\t(PROMOTE_MODE): QI and HI are the only smaller than SI int modes.\n+\t(HARD_FRAME_POINTER_REGNUM): Delete.\n+\t(REGISTER_NAMES): Move earlier.\n+\t(struct nvptx_args): Remove 'off'.\n+\t(INIT_CUMULATIVE_ARGS): Don't initialize 'off'.\n+\t(ELIMINABLE_REGS): Remove HARD_FRAME_POINTER_REGNUM.\n+\t* config/nvptx/nvptx.c (arg_promotion): Delete.\n+\t(nvptx_expand_call): Remove check for funtype being an fntype.\n+\n 2015-12-15  Jason Merrill  <jason@redhat.com>\n \n \t* hash-map.h, hash-table.h: Make copy constructors explicit.\n@@ -10,9 +31,10 @@\n \t\"omp declare target link\" variables.\n \t* omp-low.c (scan_sharing_clauses): Do not remove mapping of \"omp\n \tdeclare target link\" variables.\n-\t(add_decls_addresses_to_decl_constructor): For \"omp declare target link\"\n-\tvariables output address of the artificial pointer instead of address of\n-\tthe variable.  Set most significant bit of the size to mark them.\n+\t(add_decls_addresses_to_decl_constructor): For \"omp declare target\n+\tlink\" variables output address of the artificial pointer instead\n+\tof address of the variable.  Set most significant bit of the size\n+\tto mark them.\n \t(pass_data_omp_target_link): New pass_data.\n \t(pass_omp_target_link): New class.\n \t(find_link_var_op): New static function."}, {"sha": "a151af9af0e02476c027c765bbbf0e63e0e6a38a", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5d4b6538af1d4c39cb8789d49051a5792af8d6/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5d4b6538af1d4c39cb8789d49051a5792af8d6/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=bd5d4b6538af1d4c39cb8789d49051a5792af8d6", "patch": "@@ -366,17 +366,6 @@ nvptx_emit_joining (unsigned mask, bool is_call)\n }\n \n \f\n-/* Perform a mode promotion for a function argument with MODE.  Return\n-   the promoted mode.  */\n-\n-static machine_mode\n-arg_promotion (machine_mode mode)\n-{\n-  if (mode == QImode || mode == HImode)\n-    return SImode;\n-  return mode;\n-}\n-\n /* Determine whether MODE and TYPE (possibly NULL) should be passed or\n    returned in memory.  Integer and floating types supported by the\n    machine are passed in registers, everything else is passed in\n@@ -1165,11 +1154,6 @@ nvptx_expand_call (rtx retval, rtx address)\n     }\n \n   if (cfun->machine->funtype\n-      /* It's possible to construct testcases where we call a variable.\n-\t See compile/20020129-1.c.  stdarg_p will crash so avoid calling it\n-\t in such a case.  */\n-      && (TREE_CODE (cfun->machine->funtype) == FUNCTION_TYPE\n-\t  || TREE_CODE (cfun->machine->funtype) == METHOD_TYPE)\n       && stdarg_p (cfun->machine->funtype))\n     {\n       varargs = gen_reg_rtx (Pmode);"}, {"sha": "b5e2b0172abff6502878474bc67138cd33449e54", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5d4b6538af1d4c39cb8789d49051a5792af8d6/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5d4b6538af1d4c39cb8789d49051a5792af8d6/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=bd5d4b6538af1d4c39cb8789d49051a5792af8d6", "patch": "@@ -85,8 +85,10 @@\n    hard registers for special purposes and leave pseudos unallocated.  */\n \n #define FIRST_PSEUDO_REGISTER 16\n+/* We have to have some available hard registers, to keep gcc setup\n+   happy.  */\n #define FIXED_REGISTERS\t\t\t\t\t\\\n-  { 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }\n+  { 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 }\n #define CALL_USED_REGISTERS\t\t\t\t\\\n   { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n \n@@ -102,31 +104,27 @@\n enum reg_class\n   {\n     NO_REGS,\n-    RETURN_REG,\n     ALL_REGS,\n     LIM_REG_CLASSES\n   };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n #define REG_CLASS_NAMES {\t  \\\n-    \"RETURN_REG\",\t\t  \\\n     \"NO_REGS\",\t\t\t  \\\n     \"ALL_REGS\" }\n \n #define REG_CLASS_CONTENTS\t\\\n {\t\t\t\t\\\n   /* NO_REGS.  */\t\t\\\n   { 0x0000 },\t\t\t\\\n-  /* RETURN_REG.  */\t\t\\\n-  { 0x0008 },\t\t\t\\\n   /* ALL_REGS.  */\t\t\\\n   { 0xFFFF },\t\t\t\\\n }\n \n #define GENERAL_REGS ALL_REGS\n \n-#define REGNO_REG_CLASS(R) ((R) == 4 ? RETURN_REG : ALL_REGS)\n+#define REGNO_REG_CLASS(R) ((void)(R), ALL_REGS)\n \n #define BASE_REG_CLASS ALL_REGS\n #define INDEX_REG_CLASS NO_REGS\n@@ -140,10 +138,11 @@ enum reg_class\n #define MODES_TIEABLE_P(M1, M2) false\n \n #define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\t\\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n-      && GET_MODE_SIZE (MODE) < GET_MODE_SIZE (SImode))\t\\\n+  if ((MODE) == QImode || (MODE) == HImode)\t\t\\\n     {\t\t\t\t\t\t\t\\\n       (MODE) = SImode;\t\t\t\t\t\\\n+      (void)(UNSIGNEDP);\t\t\t\t\\\n+      (void)(TYPE);\t\t\t\t\t\\\n     }\n \n /* Stack and Calling.  */\n@@ -153,14 +152,19 @@ enum reg_class\n #define STACK_GROWS_DOWNWARD 1\n \n #define STACK_POINTER_REGNUM 1\n-#define HARD_FRAME_POINTER_REGNUM 2\n #define NVPTX_RETURN_REGNUM 4\n #define FRAME_POINTER_REGNUM 15\n #define ARG_POINTER_REGNUM 14\n \n #define STATIC_CHAIN_REGNUM 12\n #define OUTGOING_STATIC_CHAIN_REGNUM 10\n \n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    \"%hr0\", \"%outargs\", \"%hfp\", \"%hr3\", \"%retval\", \"%hr5\", \"%hr6\", \"%hr7\",\t\\\n+    \"%hr8\", \"%hr9\", \"%chain_out\", \"%hr11\", \"%chain_in\", \"%hr13\", \"%argp\", \"%frame\" \\\n+  }\n+\n #define FIRST_PARM_OFFSET(FNDECL) ((void)(FNDECL), 0)\n #define PUSH_ARGS_REVERSED 1\n #define ACCUMULATE_OUTGOING_ARGS 1\n@@ -173,15 +177,13 @@ struct nvptx_args {\n   tree fntype;\n   /* Number of arguments passed in registers so far.  */\n   int count;\n-  /* Offset into the stdarg area so far.  */\n-  HOST_WIDE_INT off;\n };\n #endif\n \n #define CUMULATIVE_ARGS struct nvptx_args\n \n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n-  ((CUM).fntype = (FNTYPE), (CUM).count = 0, (CUM).off = 0, (void)0)\n+  ((CUM).fntype = (FNTYPE), (CUM).count = 0, (void)0)\n \n #define FUNCTION_ARG_REGNO_P(r) 0\n \n@@ -199,8 +201,7 @@ struct nvptx_args {\n    expand_builtin_setjmp_receiver from generating invalid insns.  */\n #define ELIMINABLE_REGS\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n-    { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n-    { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}\t\\\n+    { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}\t\\\n   }\n \n /* Define the offset between two registers, one to be eliminated, and the other\n@@ -253,12 +254,6 @@ struct GTY(()) machine_function\n #undef ASM_APP_OFF\n #define ASM_APP_OFF \"\\t// #NO_APP \\n\"\n \n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    \"%hr0\", \"%outargs\", \"%hfp\", \"%hr3\", \"%retval\", \"%hr5\", \"%hr6\", \"%hr7\",\t\\\n-    \"%hr8\", \"%hr9\", \"%chain_out\", \"%hr11\", \"%chain_in\", \"%hr13\", \"%argp\", \"%frame\" \\\n-  }\n-\n #define DBX_REGISTER_NUMBER(N) N\n \n #define TEXT_SECTION_ASM_OP \"\""}, {"sha": "50738df39ac098eb1a6ffc741e087349edfc8acd", "filename": "gcc/config/nvptx/nvptx.md", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5d4b6538af1d4c39cb8789d49051a5792af8d6/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5d4b6538af1d4c39cb8789d49051a5792af8d6/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=bd5d4b6538af1d4c39cb8789d49051a5792af8d6", "patch": "@@ -64,26 +64,18 @@\n   (const_string \"false\"))\n \n (define_predicate \"nvptx_register_operand\"\n-  (match_code \"reg,subreg\")\n+  (match_code \"reg\")\n {\n   if (REG_P (op))\n     return !HARD_REGISTER_P (op);\n-  if (GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))\n-    return false;\n-  if (GET_CODE (op) == SUBREG)\n-    return false;\n   return register_operand (op, mode);\n })\n \n (define_predicate \"nvptx_reg_or_mem_operand\"\n-  (match_code \"mem,reg,subreg\")\n+  (match_code \"mem,reg\")\n {\n   if (REG_P (op))\n     return !HARD_REGISTER_P (op);\n-  if (GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))\n-    return false;\n-  if (GET_CODE (op) == SUBREG)\n-    return false;\n   return memory_operand (op, mode) || register_operand (op, mode);\n })\n \n@@ -94,14 +86,10 @@\n ;; Registers or constants for normal instructions.  Does not allow symbolic\n ;; constants.\n (define_predicate \"nvptx_nonmemory_operand\"\n-  (match_code \"reg,subreg,const_int,const_double\")\n+  (match_code \"reg,const_int,const_double\")\n {\n   if (REG_P (op))\n     return !HARD_REGISTER_P (op);\n-  if (GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))\n-    return false;\n-  if (GET_CODE (op) == SUBREG)\n-    return false;\n   return nonmemory_operand (op, mode);\n })\n \n@@ -145,18 +133,10 @@\n   (match_code \"eq,ne,le,ge,lt,gt,uneq,unle,unge,unlt,ungt,unordered,ordered\"))\n \n ;; Test for a valid operand for a call instruction.\n-(define_special_predicate \"call_insn_operand\"\n+(define_predicate \"call_insn_operand\"\n   (match_code \"symbol_ref,reg\")\n {\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    {\n-      tree decl = SYMBOL_REF_DECL (op);\n-      /* This happens for libcalls.  */\n-      if (decl == NULL_TREE)\n-        return true;\n-      return TREE_CODE (SYMBOL_REF_DECL (op)) == FUNCTION_DECL;\n-    }\n-  return true;\n+  return GET_CODE (op) != SYMBOL_REF || SYMBOL_REF_FUNCTION_P (op);\n })\n \n ;; Return true if OP is a call with parallel USEs of the argument\n@@ -753,7 +733,7 @@\n \n (define_insn \"call_insn\"\n   [(match_parallel 2 \"call_operation\"\n-    [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"Rs\"))\n+    [(call (mem:QI (match_operand 0 \"call_insn_operand\" \"Rs\"))\n \t   (match_operand 1))])]\n   \"\"\n {\n@@ -763,7 +743,7 @@\n (define_insn \"call_value_insn\"\n   [(match_parallel 3 \"call_operation\"\n     [(set (match_operand 0 \"nvptx_register_operand\" \"=R\")\n-\t  (call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"Rs\"))\n+\t  (call (mem:QI (match_operand 1 \"call_insn_operand\" \"Rs\"))\n \t\t(match_operand 2)))])]\n   \"\"\n {"}]}