{"sha": "488c624747ddb76a9110a4ada52073b584669d0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg4YzYyNDc0N2RkYjc2YTkxMTBhNGFkYTUyMDczYjU4NDY2OWQwZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-10-14T12:09:51Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-10-14T12:09:51Z"}, "message": "Fold __builtin_memchr function\n\n\t* builtins.h(target_char_cst_p): Declare the function.\n\t* builtins.c (fold_builtin_memchr): Remove.\n\t(target_char_cst_p): Move the function from gimple-fold.c.\n\t(fold_builtin_3): Do not call the function.\n\t* gimple-fold.c (gimple_fold_builtin_memchr): New function.\n\t(gimple_fold_builtin): Call the function.\n\t* fold-const-call.c (fold_const_call_1): Handle CFN_BUILT_IN_MEMCHR.\n\nFrom-SVN: r241160", "tree": {"sha": "ace94ab399d4400cb7af811ab144e00cb1ed65fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ace94ab399d4400cb7af811ab144e00cb1ed65fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/488c624747ddb76a9110a4ada52073b584669d0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/488c624747ddb76a9110a4ada52073b584669d0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/488c624747ddb76a9110a4ada52073b584669d0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/488c624747ddb76a9110a4ada52073b584669d0d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a918bfbf3c5b686362f3f97314c2b4bf142d2f82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a918bfbf3c5b686362f3f97314c2b4bf142d2f82"}], "stats": {"total": 178, "additions": 119, "deletions": 59}, "files": [{"sha": "e30217896e909679babb0b18b3a8bb5b3506fd5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488c624747ddb76a9110a4ada52073b584669d0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488c624747ddb76a9110a4ada52073b584669d0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=488c624747ddb76a9110a4ada52073b584669d0d", "patch": "@@ -1,3 +1,13 @@\n+2016-10-14  Martin Liska  <mliska@suse.cz>\n+\n+\t* builtins.h(target_char_cst_p): Declare the function.\n+\t* builtins.c (fold_builtin_memchr): Remove.\n+\t(target_char_cst_p): Move the function from gimple-fold.c.\n+\t(fold_builtin_3): Do not call the function.\n+\t* gimple-fold.c (gimple_fold_builtin_memchr): New function.\n+\t(gimple_fold_builtin): Call the function.\n+\t* fold-const-call.c (fold_const_call_1): Handle CFN_BUILT_IN_MEMCHR.\n+\n 2016-10-14  Martin Liska  <mliska@suse.cz>\n \n \t* builtins.c (fold_builtin_strcmp): Remove function."}, {"sha": "03d8563f623919cdef8058eb3d5d304efe9a5324", "filename": "gcc/builtins.c", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488c624747ddb76a9110a4ada52073b584669d0d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488c624747ddb76a9110a4ada52073b584669d0d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=488c624747ddb76a9110a4ada52073b584669d0d", "patch": "@@ -148,7 +148,6 @@ static tree rewrite_call_expr (location_t, tree, int, tree, int, ...);\n static bool validate_arg (const_tree, enum tree_code code);\n static rtx expand_builtin_fabs (tree, rtx, rtx);\n static rtx expand_builtin_signbit (tree, rtx);\n-static tree fold_builtin_memchr (location_t, tree, tree, tree, tree);\n static tree fold_builtin_memcmp (location_t, tree, tree, tree);\n static tree fold_builtin_isascii (location_t, tree);\n static tree fold_builtin_toascii (location_t, tree);\n@@ -7242,47 +7241,6 @@ fold_builtin_sincos (location_t loc,\n \t\t\t fold_build1_loc (loc, REALPART_EXPR, type, call)));\n }\n \n-/* Fold function call to builtin memchr.  ARG1, ARG2 and LEN are the\n-   arguments to the call, and TYPE is its return type.\n-   Return NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_memchr (location_t loc, tree arg1, tree arg2, tree len, tree type)\n-{\n-  if (!validate_arg (arg1, POINTER_TYPE)\n-      || !validate_arg (arg2, INTEGER_TYPE)\n-      || !validate_arg (len, INTEGER_TYPE))\n-    return NULL_TREE;\n-  else\n-    {\n-      const char *p1;\n-\n-      if (TREE_CODE (arg2) != INTEGER_CST\n-\t  || !tree_fits_uhwi_p (len))\n-\treturn NULL_TREE;\n-\n-      p1 = c_getstr (arg1);\n-      if (p1 && compare_tree_int (len, strlen (p1) + 1) <= 0)\n-\t{\n-\t  char c;\n-\t  const char *r;\n-\t  tree tem;\n-\n-\t  if (target_char_cast (arg2, &c))\n-\t    return NULL_TREE;\n-\n-\t  r = (const char *) memchr (p1, c, tree_to_uhwi (len));\n-\n-\t  if (r == NULL)\n-\t    return build_int_cst (TREE_TYPE (arg1), 0);\n-\n-\t  tem = fold_build_pointer_plus_hwi_loc (loc, arg1, r - p1);\n-\t  return fold_convert_loc (loc, type, tem);\n-\t}\n-      return NULL_TREE;\n-    }\n-}\n-\n /* Fold function call to builtin memcmp with arguments ARG1 and ARG2.\n    Return NULL_TREE if no simplification can be made.  */\n \n@@ -8338,9 +8296,6 @@ fold_builtin_3 (location_t loc, tree fndecl,\n \treturn do_mpfr_remquo (arg0, arg1, arg2);\n     break;\n \n-    case BUILT_IN_MEMCHR:\n-      return fold_builtin_memchr (loc, arg0, arg1, arg2, type);\n-\n     case BUILT_IN_BCMP:\n     case BUILT_IN_MEMCMP:\n       return fold_builtin_memcmp (loc, arg0, arg1, arg2);;\n@@ -9906,3 +9861,17 @@ is_inexpensive_builtin (tree decl)\n \n   return false;\n }\n+\n+/* Return true if T is a constant and the value cast to a target char\n+   can be represented by a host char.\n+   Store the casted char constant in *P if so.  */\n+\n+bool\n+target_char_cst_p (tree t, char *p)\n+{\n+  if (!tree_fits_uhwi_p (t) || CHAR_TYPE_SIZE != HOST_BITS_PER_CHAR)\n+    return false;\n+\n+  *p = (char)tree_to_uhwi (t);\n+  return true;\n+}"}, {"sha": "5e836468d20639b1136f199272802865e2803e77", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488c624747ddb76a9110a4ada52073b584669d0d/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488c624747ddb76a9110a4ada52073b584669d0d/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=488c624747ddb76a9110a4ada52073b584669d0d", "patch": "@@ -97,6 +97,7 @@ extern unsigned HOST_WIDE_INT target_percent;\n extern char target_percent_s[3];\n extern char target_percent_c[3];\n extern char target_percent_s_newline[4];\n+extern bool target_char_cst_p (tree t, char *p);\n \n extern internal_fn associated_internal_fn (tree);\n extern internal_fn replacement_internal_fn (gcall *);"}, {"sha": "05a15f974e94d9206c0f026c8e8d5a15f26b74f4", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488c624747ddb76a9110a4ada52073b584669d0d/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488c624747ddb76a9110a4ada52073b584669d0d/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=488c624747ddb76a9110a4ada52073b584669d0d", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fold-const-call.h\"\n #include \"case-cfn-macros.h\"\n #include \"tm.h\" /* For C[LT]Z_DEFINED_AT_ZERO.  */\n+#include \"builtins.h\"\n \n /* Functions that test for certain constant types, abstracting away the\n    decision about whether to check for overflow.  */\n@@ -1463,6 +1464,36 @@ fold_const_call_1 (combined_fn fn, tree type, tree arg0, tree arg1, tree arg2)\n       return NULL_TREE;\n     }\n \n+  switch (fn)\n+    {\n+    case CFN_BUILT_IN_MEMCHR:\n+      {\n+\tchar c;\n+\tif (integer_zerop (arg2)\n+\t    && !TREE_SIDE_EFFECTS (arg0)\n+\t    && !TREE_SIDE_EFFECTS (arg1))\n+\t  return build_int_cst (type, 0);\n+\n+\tif (!tree_fits_uhwi_p (arg2) || !target_char_cst_p (arg1, &c))\n+\t  return NULL_TREE;\n+\n+\tunsigned HOST_WIDE_INT length = tree_to_uhwi (arg2);\n+\tunsigned HOST_WIDE_INT string_length;\n+\tconst char *p1 = c_getstr (arg0, &string_length);\n+\tif (p1)\n+\t  {\n+\t    const char *r\n+\t      = (const char *)memchr (p1, c, MIN (length, string_length));\n+\t    if (r == NULL && length <= string_length)\n+\t      return build_int_cst (type, 0);\n+\t  }\n+\n+\tbreak;\n+      }\n+    default:\n+      break;\n+    }\n+\n   return NULL_TREE;\n }\n "}, {"sha": "5d464055a8359879ace52f4b24dd0a451fa212f6", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488c624747ddb76a9110a4ada52073b584669d0d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488c624747ddb76a9110a4ada52073b584669d0d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=488c624747ddb76a9110a4ada52073b584669d0d", "patch": "@@ -57,20 +57,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfg.h\"\n #include \"fold-const-call.h\"\n \n-/* Return true if T is a constant and the value cast to a target char\n-   can be represented by a host char.\n-   Store the casted char constant in *P if so.  */\n-\n-static bool\n-target_char_cst_p (tree t, char *p)\n-{\n-  if (!tree_fits_uhwi_p (t) || CHAR_TYPE_SIZE != HOST_BITS_PER_CHAR)\n-    return false;\n-\n-  *p = (char)tree_to_uhwi (t);\n-  return true;\n-}\n-\n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n    We can get declarations that are not possible to reference for various\n@@ -1967,6 +1953,67 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n   return false;\n }\n \n+/* Fold a call to the memchr pointed by GSI iterator.  */\n+\n+static bool\n+gimple_fold_builtin_memchr (gimple_stmt_iterator *gsi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree arg1 = gimple_call_arg (stmt, 0);\n+  tree arg2 = gimple_call_arg (stmt, 1);\n+  tree len = gimple_call_arg (stmt, 2);\n+\n+  /* If the LEN parameter is zero, return zero.  */\n+  if (integer_zerop (len))\n+    {\n+      replace_call_with_value (gsi, build_int_cst (ptr_type_node, 0));\n+      return true;\n+    }\n+\n+  char c;\n+  if (TREE_CODE (arg2) != INTEGER_CST\n+      || !tree_fits_uhwi_p (len)\n+      || !target_char_cst_p (arg2, &c))\n+    return false;\n+\n+  unsigned HOST_WIDE_INT length = tree_to_uhwi (len);\n+  unsigned HOST_WIDE_INT string_length;\n+  const char *p1 = c_getstr (arg1, &string_length);\n+\n+  if (p1)\n+    {\n+      const char *r = (const char *)memchr (p1, c, MIN (length, string_length));\n+      if (r == NULL)\n+\t{\n+\t  if (length <= string_length)\n+\t    {\n+\t      replace_call_with_value (gsi, build_int_cst (ptr_type_node, 0));\n+\t      return true;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  unsigned HOST_WIDE_INT offset = r - p1;\n+\t  gimple_seq stmts = NULL;\n+\t  if (lhs != NULL_TREE)\n+\t    {\n+\t      tree offset_cst = build_int_cst (TREE_TYPE (len), offset);\n+\t      gassign *stmt = gimple_build_assign (lhs, POINTER_PLUS_EXPR,\n+\t\t\t\t\t\t   arg1, offset_cst);\n+\t      gimple_seq_add_stmt_without_update (&stmts, stmt);\n+\t    }\n+\t  else\n+\t    gimple_seq_add_stmt_without_update (&stmts,\n+\t\t\t\t\t\tgimple_build_nop ());\n+\n+\t  gsi_replace_with_seq_vops (gsi, stmts);\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n \n /* Fold a call to the fputs builtin.  ARG0 and ARG1 are the arguments\n    to the call.  IGNORE is true if the value returned\n@@ -3194,6 +3241,8 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case BUILT_IN_STRNCMP:\n     case BUILT_IN_STRNCASECMP:\n       return gimple_fold_builtin_string_compare (gsi);\n+    case BUILT_IN_MEMCHR:\n+      return gimple_fold_builtin_memchr (gsi);\n     case BUILT_IN_FPUTS:\n       return gimple_fold_builtin_fputs (gsi, gimple_call_arg (stmt, 0),\n \t\t\t\t\tgimple_call_arg (stmt, 1), false);"}]}