{"sha": "3b413743e0719ecca26e5f5426b6baa837e0a13b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I0MTM3NDNlMDcxOWVjY2EyNmU1ZjU0MjZiNmJhYTgzN2UwYTEzYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-01-11T22:37:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-01-11T22:37:20Z"}, "message": "basic-block.h (basic_block_head): Rename to x_basic_block_head.\n\n        * basic-block.h (basic_block_head): Rename to x_basic_block_head.\n        (basic_block_end): Rename to x_basic_block_end.\n        (BLOCK_HEAD, BLOCK_END): Update.\n        * caller-save.c: Change basic_block_head/end references to\n        BLOCK_HEAD/END.\n        * combine.c, flow.c, function.c, gcse.c, global.c: Likewise.\n        * graph.c, haifa-sched.c, local-alloc.c, regclass.c: Likewise.\n        * regmove.c, reload1.c, reorg.c, sched.c: Likewise.\n\nFrom-SVN: r24622", "tree": {"sha": "30a7e0f87a7c337abe0059287db7fcfd192c14ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30a7e0f87a7c337abe0059287db7fcfd192c14ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b413743e0719ecca26e5f5426b6baa837e0a13b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b413743e0719ecca26e5f5426b6baa837e0a13b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b413743e0719ecca26e5f5426b6baa837e0a13b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b413743e0719ecca26e5f5426b6baa837e0a13b/comments", "author": null, "committer": null, "parents": [{"sha": "f0974237d4c4f761f5073cfd93583a571651ba76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0974237d4c4f761f5073cfd93583a571651ba76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0974237d4c4f761f5073cfd93583a571651ba76"}], "stats": {"total": 373, "additions": 192, "deletions": 181}, "files": [{"sha": "f6c2f9cc54e2231cd8b8fda344d6cbbcbadd360b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -1,3 +1,15 @@\n+Mon Jan 11 22:36:01 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* basic-block.h (basic_block_head): Rename to x_basic_block_head.\n+\t(basic_block_end): Rename to x_basic_block_end.\n+\t(BLOCK_HEAD, BLOCK_END): Update.\n+\n+\t* caller-save.c: Change basic_block_head/end references to \n+\tBLOCK_HEAD/END.\n+\t* combine.c, flow.c, function.c, gcse.c, global.c: Likewise.\n+\t* graph.c, haifa-sched.c, local-alloc.c, regclass.c: Likewise.\n+\t* regmove.c, reload1.c, reorg.c, sched.c: Likewise.\n+\n Sat Jan  9 23:54:09 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.c (xstrerror): Renamed from my_strerror.  All callers"}, {"sha": "465587e9ac5e868b7885ba37e9b51a36eb8e0888", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -102,11 +102,11 @@ extern int n_basic_blocks;\n \n /* Index by basic block number, get first insn in the block.  */\n \n-extern rtx *basic_block_head;\n+extern rtx *x_basic_block_head;\n \n /* Index by basic block number, get last insn in the block.  */\n \n-extern rtx *basic_block_end;\n+extern rtx *x_basic_block_end;\n \n /* Index by basic block number, determine whether the block can be reached\n    through a computed jump.  */\n@@ -176,8 +176,8 @@ extern void free_int_list               PROTO ((int_list_block **));\n \f\n /* Stuff for recording basic block info.  */\n \n-#define BLOCK_HEAD(B)      basic_block_head[(B)]\n-#define BLOCK_END(B)       basic_block_end[(B)]\n+#define BLOCK_HEAD(B)      x_basic_block_head[(B)]\n+#define BLOCK_END(B)       x_basic_block_end[(B)]\n \n /* Special block numbers [markers] for entry and exit.  */\n #define ENTRY_BLOCK (-1)"}, {"sha": "e68403f7dbb3a8edd32ecdbb3e8774cb278a4fbd", "filename": "gcc/caller-save.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -732,8 +732,8 @@ insert_one_insn (chain, before_p, code, pat)\n \t registers from the live sets.  */\n       COPY_REG_SET (new->live_before, chain->live_before);\n       COPY_REG_SET (new->live_after, chain->live_before);\n-      if (chain->insn == basic_block_head[chain->block])\n-\tbasic_block_head[chain->block] = new->insn;\n+      if (chain->insn == BLOCK_HEAD (chain->block))\n+\tBLOCK_HEAD (chain->block) = new->insn;\n     }\n   else\n     {\n@@ -747,8 +747,8 @@ insert_one_insn (chain, before_p, code, pat)\n \t registers from the live sets, and observe REG_UNUSED notes.  */\n       COPY_REG_SET (new->live_before, chain->live_after);\n       COPY_REG_SET (new->live_after, chain->live_after);\n-      if (chain->insn == basic_block_end[chain->block])\n-\tbasic_block_end[chain->block] = new->insn;\n+      if (chain->insn == BLOCK_END (chain->block))\n+\tBLOCK_END (chain->block) = new->insn;\n     }\n   new->block = chain->block;\n   new->is_caller_save_insn = 1;"}, {"sha": "8575b8a181e1029bed3fd2794668d4cac29d26d3", "filename": "gcc/combine.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -573,7 +573,7 @@ combine_instructions (f, nregs)\n \n       /* If INSN starts a new basic block, update our basic block number.  */\n       if (this_basic_block + 1 < n_basic_blocks\n-\t  && basic_block_head[this_basic_block + 1] == insn)\n+\t  && BLOCK_HEAD (this_basic_block + 1) == insn)\n \tthis_basic_block++;\n \n       if (GET_CODE (insn) == CODE_LABEL)\n@@ -2124,7 +2124,7 @@ try_combine (i3, i2, i1)\n \n \t  for (insn = NEXT_INSN (i3);\n \t       insn && (this_basic_block == n_basic_blocks - 1\n-\t\t\t|| insn != basic_block_head[this_basic_block + 1]);\n+\t\t\t|| insn != BLOCK_HEAD (this_basic_block + 1));\n \t       insn = NEXT_INSN (insn))\n \t    {\n \t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n@@ -2310,7 +2310,7 @@ try_combine (i3, i2, i1)\n \t\t\t\t  SET_DEST (XVECEXP (PATTERN (i2), 0, i))))\n \t    for (temp = NEXT_INSN (i2);\n \t\t temp && (this_basic_block == n_basic_blocks - 1\n-\t\t\t  || basic_block_head[this_basic_block] != temp);\n+\t\t\t  || BLOCK_HEAD (this_basic_block) != temp);\n \t\t temp = NEXT_INSN (temp))\n \t      if (temp != i3 && GET_RTX_CLASS (GET_CODE (temp)) == 'i')\n \t\tfor (link = LOG_LINKS (temp); link; link = XEXP (link, 1))\n@@ -11035,7 +11035,7 @@ reg_dead_at_p (reg, insn)\n   else\n     {\n       for (block = 0; block < n_basic_blocks; block++)\n-\tif (insn == basic_block_head[block])\n+\tif (insn == BLOCK_HEAD (block))\n \t  break;\n \n       if (block == n_basic_blocks)\n@@ -11726,9 +11726,9 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t\t       tem);\n \n \t\t  /* If this insn was emitted between blocks, then update\n-\t\t     basic_block_head of the current block to include it.  */\n-\t\t  if (basic_block_end[this_basic_block - 1] == tem)\n-\t\t    basic_block_head[this_basic_block] = place;\n+\t\t     BLOCK_HEAD of the current block to include it.  */\n+\t\t  if (BLOCK_END (this_basic_block - 1) == tem)\n+\t\t    BLOCK_HEAD (this_basic_block) = place;\n \t\t}\n \t    }\n \n@@ -11927,7 +11927,7 @@ distribute_links (links)\n \n       for (insn = NEXT_INSN (XEXP (link, 0));\n \t   (insn && (this_basic_block == n_basic_blocks - 1\n-\t\t     || basic_block_head[this_basic_block + 1] != insn));\n+\t\t     || BLOCK_HEAD (this_basic_block + 1) != insn));\n \t   insn = NEXT_INSN (insn))\n \tif (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n \t    && reg_overlap_mentioned_p (reg, PATTERN (insn)))"}, {"sha": "8fb2dea444f65f62536dd07c026a09f00696ffd3", "filename": "gcc/flow.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -195,12 +195,12 @@ int regset_size;\n /* Element N is first insn in basic block N.\n    This info lasts until we finish compiling the function.  */\n \n-rtx *basic_block_head;\n+rtx *x_basic_block_head;\n \n /* Element N is last insn in basic block N.\n    This info lasts until we finish compiling the function.  */\n \n-rtx *basic_block_end;\n+rtx *x_basic_block_end;\n \n /* Element N indicates whether basic block N can be reached through a\n    computed jump.  */\n@@ -344,7 +344,7 @@ find_basic_blocks (f, nregs, file)\n \n \t    /* If the previous insn was a call that did not create an\n \t       abnormal edge, we want to add a nop so that the CALL_INSN\n-\t       itself is not at basic_block_end.  This allows us to easily\n+\t       itself is not at basic block end.  This allows us to easily\n \t       distinguish between normal calls and those which create\n \t       abnormal edges in the flow graph.  */\n \n@@ -393,8 +393,8 @@ find_basic_blocks (f, nregs, file)\n   /* Allocate some tables that last till end of compiling this function\n      and some needed only in find_basic_blocks and life_analysis.  */\n \n-  basic_block_head = XNMALLOC (rtx, n_basic_blocks);\n-  basic_block_end = XNMALLOC (rtx, n_basic_blocks);\n+  x_basic_block_head = XNMALLOC (rtx, n_basic_blocks);\n+  x_basic_block_end = XNMALLOC (rtx, n_basic_blocks);\n   basic_block_succ = XNMALLOC (int_list_ptr, n_basic_blocks);\n   basic_block_pred = XNMALLOC (int_list_ptr, n_basic_blocks);\n   bzero ((char *)basic_block_succ, n_basic_blocks * sizeof (int_list_ptr));\n@@ -497,8 +497,8 @@ find_basic_blocks_1 (f, nonlocal_labels)\n \t\t       || (prev_code == CALL_INSN && call_had_abnormal_edge)\n \t\t       || prev_code == BARRIER)))\n \t{\n-\t  basic_block_head[++i] = insn;\n-\t  basic_block_end[i] = insn;\n+\t  BLOCK_HEAD (++i) = insn;\n+\t  BLOCK_END (i) = insn;\n \t  basic_block_loop_depth[i] = depth;\n \n \t  if (code == CODE_LABEL)\n@@ -513,7 +513,7 @@ find_basic_blocks_1 (f, nonlocal_labels)\n \n       else if (GET_RTX_CLASS (code) == 'i')\n \t{\n-\t  basic_block_end[i] = insn;\n+\t  BLOCK_END (i) = insn;\n \t  basic_block_loop_depth[i] = depth;\n \t}\n \n@@ -720,15 +720,15 @@ make_edges (i)\n   /* See if control drops into the next block.  */\n   if (i + 1 < n_basic_blocks)\n     {\n-      for (insn = PREV_INSN (basic_block_head[i + 1]);\n+      for (insn = PREV_INSN (BLOCK_HEAD (i + 1));\n \t   insn && GET_CODE (insn) == NOTE; insn = PREV_INSN (insn))\n \t;\n \n       if (insn && GET_CODE (insn) != BARRIER)\n \tadd_edge (i, i + 1);\n     }\n \n-  insn = basic_block_end[i];\n+  insn = BLOCK_END (i);\n   if (GET_CODE (insn) == JUMP_INSN)\n     mark_label_ref (i, PATTERN (insn));\n \n@@ -741,8 +741,8 @@ make_edges (i)\n   /* Now scan the insns for this block, we may need to make edges for some of\n      them to various non-obvious locations (exception handlers, nonlocal\n      labels, etc).  */\n-  for (insn = basic_block_head[i];\n-       insn != NEXT_INSN (basic_block_end[i]);\n+  for (insn = BLOCK_HEAD (i);\n+       insn != NEXT_INSN (BLOCK_END (i));\n        insn = NEXT_INSN (insn))\n     {\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n@@ -934,16 +934,16 @@ delete_unreachable_blocks ()\n \n       if (i != j)\n \t{\n-\t  rtx tmp = basic_block_head[i];\n+\t  rtx tmp = BLOCK_HEAD (i);\n \t  for (;;)\n \t    {\n \t      BLOCK_NUM (tmp) = j;\n-\t      if (tmp == basic_block_end[i])\n+\t      if (tmp == BLOCK_END (i))\n \t\tbreak;\n \t      tmp = NEXT_INSN (tmp);\n \t    }\n-\t  basic_block_head[j] = basic_block_head[i];\n-\t  basic_block_end[j] = basic_block_end[i];\n+\t  BLOCK_HEAD (j) = BLOCK_HEAD (i);\n+\t  BLOCK_END (j) = BLOCK_END (i);\n \t  basic_block_pred[j] = basic_block_pred[i];\n \t  basic_block_succ[j] = basic_block_succ[i];\n \t  basic_block_loop_depth[j] = basic_block_loop_depth[i];\n@@ -977,7 +977,7 @@ delete_unreachable_blocks ()\n }\n \n /* Delete the insns in a (non-live) block.  We physically delete every\n-   non-note insn except the start and end (so basic_block_head/end needn't\n+   non-note insn except the start and end (so BLOCK_HEAD/END needn't\n    be updated), we turn the latter into NOTE_INSN_DELETED notes.\n \n    We use to \"delete\" the insns by turning them into notes, but we may be\n@@ -1003,7 +1003,7 @@ delete_block (i)\n      We need to remove the label from the exception_handler_label\n      list and remove the associated NOTE_EH_REGION_BEG and\n      NOTE_EH_REGION_END notes.  */\n-  insn = basic_block_head[i];\n+  insn = BLOCK_HEAD (i);\n   if (GET_CODE (insn) == CODE_LABEL)\n     {\n       rtx x, *prev = &exception_handler_labels;\n@@ -1029,7 +1029,7 @@ delete_block (i)\n \n   /* Walk the insns of the block, building a chain of NOTEs that need to be\n      kept.  */\n-  insn = basic_block_head[i];\n+  insn = BLOCK_HEAD (i);\n   for (;;)\n     {\n       if (GET_CODE (insn) == BARRIER)\n@@ -1045,7 +1045,7 @@ delete_block (i)\n \t      kept_tail = insn;\n \t    }\n \t}\n-      if (insn == basic_block_end[i])\n+      if (insn == BLOCK_END (i))\n \tbreak;\n       insn = NEXT_INSN (insn);\n     }\n@@ -1063,19 +1063,19 @@ delete_block (i)\n      place.  */\n   if (kept_head == 0)\n     {\n-      NEXT_INSN (PREV_INSN (basic_block_head[i])) = insn;\n+      NEXT_INSN (PREV_INSN (BLOCK_HEAD (i))) = insn;\n       if (insn != 0)\n-\tPREV_INSN (insn) = PREV_INSN (basic_block_head[i]);\n+\tPREV_INSN (insn) = PREV_INSN (BLOCK_HEAD (i));\n       else\n-\tset_last_insn (PREV_INSN (basic_block_head[i]));\n+\tset_last_insn (PREV_INSN (BLOCK_HEAD(i)));\n     }\n   else\n     {\n-      NEXT_INSN (PREV_INSN (basic_block_head[i])) = kept_head;\n+      NEXT_INSN (PREV_INSN (BLOCK_HEAD (i))) = kept_head;\n       if (insn != 0)\n \tPREV_INSN (insn) = kept_tail;\n \n-      PREV_INSN (kept_head) = PREV_INSN (basic_block_head[i]);\n+      PREV_INSN (kept_head) = PREV_INSN (BLOCK_HEAD (i));\n       NEXT_INSN (kept_tail) = insn;\n \n       /* This must happen after NEXT_INSN (kept_tail) has been reinitialized\n@@ -1096,7 +1096,7 @@ delete_block (i)\n \tif (block_live_static[j])\n \t  {\n \t    rtx label;\n-\t    insn = basic_block_end[i - 1];\n+\t    insn = BLOCK_END (i - 1);\n \t    if (GET_CODE (insn) == JUMP_INSN\n \t\t/* An unconditional jump is the only possibility\n \t\t   we must check for, since a conditional one\n@@ -1156,7 +1156,7 @@ life_analysis (f, nregs, file)\n \n /* Free the variables allocated by find_basic_blocks.\n \n-   KEEP_HEAD_END_P is non-zero if basic_block_head and basic_block_end\n+   KEEP_HEAD_END_P is non-zero if BLOCK_HEAD and BLOCK_END\n    are not to be freed.  */\n \n void\n@@ -1179,12 +1179,12 @@ free_basic_block_vars (keep_head_end_p)\n       uid_volatile = 0;\n     }\n \n-  if (! keep_head_end_p && basic_block_head)\n+  if (! keep_head_end_p && x_basic_block_head)\n     {\n-      free (basic_block_head);\n-      basic_block_head = 0;\n-      free (basic_block_end);\n-      basic_block_end = 0;\n+      free (x_basic_block_head);\n+      x_basic_block_head = 0;\n+      free (x_basic_block_end);\n+      x_basic_block_end = 0;\n     }\n }\n \n@@ -1524,7 +1524,7 @@ life_analysis_1 (f, nregs)\n \t      COPY_REG_SET (basic_block_live_at_start[i],\n \t\t\t    basic_block_live_at_end[i]);\n \t      propagate_block (basic_block_live_at_start[i],\n-\t\t\t       basic_block_head[i], basic_block_end[i], 0,\n+\t\t\t       BLOCK_HEAD (i), BLOCK_END (i), 0,\n \t\t\t       first_pass ? basic_block_significant[i]\n \t\t\t       : (regset) 0,\n \t\t\t       i);\n@@ -1574,7 +1574,7 @@ life_analysis_1 (f, nregs)\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n       propagate_block (basic_block_live_at_end[i],\n-\t\t       basic_block_head[i], basic_block_end[i], 1,\n+\t\t       BLOCK_HEAD (i), BLOCK_END (i), 1,\n \t\t       (regset) 0, i);\n #ifdef USE_C_ALLOCA\n       alloca (0);\n@@ -2574,8 +2574,8 @@ find_auto_inc (needed, x, insn)\n \t\t new insn(s) and do the updates.  */\n \t      emit_insns_before (insns, insn);\n \n-\t      if (basic_block_head[BLOCK_NUM (insn)] == insn)\n-\t\tbasic_block_head[BLOCK_NUM (insn)] = insns;\n+\t      if (BLOCK_HEAD (BLOCK_NUM (insn)) == insn)\n+\t\tBLOCK_HEAD (BLOCK_NUM (insn)) = insns;\n \n \t      /* INCR will become a NOTE and INSN won't contain a\n \t\t use of ADDR.  If a use of ADDR was just placed in\n@@ -3276,14 +3276,14 @@ print_rtl_with_bb (outf, rtx_first)\n       for (i = n_basic_blocks-1; i >= 0; i--)\n \t{\n \t  rtx x;\n-\t  start[INSN_UID (basic_block_head[i])] = i;\n-\t  end[INSN_UID (basic_block_end[i])] = i;\n-\t  for (x = basic_block_head[i]; x != NULL_RTX; x = NEXT_INSN (x))\n+\t  start[INSN_UID (BLOCK_HEAD (i))] = i;\n+\t  end[INSN_UID (BLOCK_END (i))] = i;\n+\t  for (x = BLOCK_HEAD (i); x != NULL_RTX; x = NEXT_INSN (x))\n \t    {\n \t      in_bb_p[ INSN_UID(x)]\n \t\t= (in_bb_p[ INSN_UID(x)] == NOT_IN_BB)\n \t\t ? IN_ONE_BB : IN_MULTIPLE_BB;\n-\t      if (x == basic_block_end[i])\n+\t      if (x == BLOCK_END (i))\n \t\tbreak;\n \t    }\n \t}"}, {"sha": "865e6791f0608362b10939c1cf4145569f0c11c2", "filename": "gcc/function.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -6267,9 +6267,9 @@ thread_prologue_and_epilogue_insns (f)\n \n       /* Include the new prologue insns in the first block.  Ignore them\n \t if they form a basic block unto themselves.  */\n-      if (basic_block_head && n_basic_blocks\n-\t  && GET_CODE (basic_block_head[0]) != CODE_LABEL)\n-\tbasic_block_head[0] = NEXT_INSN (f);\n+      if (x_basic_block_head && n_basic_blocks\n+\t  && GET_CODE (BLOCK_HEAD (0)) != CODE_LABEL)\n+\tBLOCK_HEAD (0) = NEXT_INSN (f);\n \n       /* Retain a map of the prologue insns.  */\n       prologue = record_insns (GET_CODE (seq) == SEQUENCE ? seq : head);\n@@ -6335,9 +6335,9 @@ thread_prologue_and_epilogue_insns (f)\n \n \t  /* Include the new epilogue insns in the last block.  Ignore\n \t     them if they form a basic block unto themselves.  */\n-\t  if (basic_block_end && n_basic_blocks\n-\t      && GET_CODE (basic_block_end[n_basic_blocks - 1]) != JUMP_INSN)\n-\t    basic_block_end[n_basic_blocks - 1] = tail;\n+\t  if (x_basic_block_end && n_basic_blocks\n+\t      && GET_CODE (BLOCK_END (n_basic_blocks - 1)) != JUMP_INSN)\n+\t    BLOCK_END (n_basic_blocks - 1) = tail;\n \n \t  /* Retain a map of the epilogue insns.  */\n \t  epilogue = record_insns (GET_CODE (seq) == SEQUENCE ? seq : tail);\n@@ -6397,10 +6397,10 @@ reposition_prologue_and_epilogue_notes (f)\n \t\t  if (next)\n \t\t    PREV_INSN (next) = prev;\n \n-\t\t  /* Whether or not we can depend on basic_block_head, \n+\t\t  /* Whether or not we can depend on BLOCK_HEAD, \n \t\t     attempt to keep it up-to-date.  */\n-\t\t  if (basic_block_head[0] == note)\n-\t\t    basic_block_head[0] = next;\n+\t\t  if (BLOCK_HEAD (0) == note)\n+\t\t    BLOCK_HEAD (0) = next;\n \n \t\t  add_insn_after (note, insn);\n \t\t}\n@@ -6441,11 +6441,11 @@ reposition_prologue_and_epilogue_notes (f)\n \t\t  if (next)\n \t\t    PREV_INSN (next) = prev;\n \n-\t\t  /* Whether or not we can depend on basic_block_head, \n+\t\t  /* Whether or not we can depend on BLOCK_HEAD, \n \t\t     attempt to keep it up-to-date.  */\n \t\t  if (n_basic_blocks\n-\t\t      && basic_block_head[n_basic_blocks-1] == insn)\n-\t\t    basic_block_head[n_basic_blocks-1] = note;\n+\t\t      && BLOCK_HEAD (n_basic_blocks-1) == insn)\n+\t\t    BLOCK_HEAD (n_basic_blocks-1) = note;\n \n \t\t  add_insn_before (note, insn);\n \t\t}"}, {"sha": "95516d0cfe9f8f3bc686b628970201a4e89d5bd6", "filename": "gcc/gcse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -2054,8 +2054,8 @@ compute_hash_table (f, set_p)\n       mem_first_set = NEVER_SET;\n       mem_last_set = NEVER_SET;\n \n-      for (insn = basic_block_head[bb];\n-\t   insn && insn != NEXT_INSN (basic_block_end[bb]);\n+      for (insn = BLOCK_HEAD (bb);\n+\t   insn && insn != NEXT_INSN (BLOCK_END (bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n #ifdef NON_SAVING_SETJMP \n@@ -2099,8 +2099,8 @@ compute_hash_table (f, set_p)\n \n       /* The next pass builds the hash table.  */\n \n-      for (insn = basic_block_head[bb], in_libcall_block = 0;\n-\t   insn && insn != NEXT_INSN (basic_block_end[bb]);\n+      for (insn = BLOCK_HEAD (bb), in_libcall_block = 0;\n+\t   insn && insn != NEXT_INSN (BLOCK_END (bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n@@ -3243,8 +3243,8 @@ classic_gcse ()\n \t start of the block].  */\n       reset_opr_set_tables ();\n \n-      for (insn = basic_block_head[bb];\n-\t   insn != NULL && insn != NEXT_INSN (basic_block_end[bb]);\n+      for (insn = BLOCK_HEAD (bb);\n+\t   insn != NULL && insn != NEXT_INSN (BLOCK_END (bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  /* Is insn of form (set (pseudo-reg) ...)?  */\n@@ -3829,8 +3829,8 @@ cprop ()\n \t start of the block].  */\n       reset_opr_set_tables ();\n \n-      for (insn = basic_block_head[bb];\n-\t   insn != NULL && insn != NEXT_INSN (basic_block_end[bb]);\n+      for (insn = BLOCK_HEAD (bb);\n+\t   insn != NULL && insn != NEXT_INSN (BLOCK_END (bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')"}, {"sha": "a3c043b95eea0d360809ecde215323d2c3e6852b", "filename": "gcc/global.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -680,7 +680,7 @@ global_conflicts ()\n #endif\n       }\n \n-      insn = basic_block_head[b];\n+      insn = BLOCK_HEAD (b);\n \n       /* Scan the code of this basic block, noting which allocnos\n \t and hard regs are born or die.  When one is born,\n@@ -777,7 +777,7 @@ global_conflicts ()\n \t\t  mark_reg_death (regs_set[n_regs_set]);\n \t    }\n \n-\t  if (insn == basic_block_end[b])\n+\t  if (insn == BLOCK_END (b))\n \t    break;\n \t  insn = NEXT_INSN (insn);\n \t}\n@@ -1667,7 +1667,7 @@ build_insn_chain (first)\n     {\n       struct insn_chain *c;\n \n-      if (first == basic_block_head[b])\n+      if (first == BLOCK_HEAD (b))\n \t{\n \t  int i;\n \t  CLEAR_REG_SET (live_relevant_regs);\n@@ -1727,7 +1727,7 @@ build_insn_chain (first)\n \t    }\n \t}\n \n-      if (first == basic_block_end[b])\n+      if (first == BLOCK_END (b))\n \tb++;\n \n       /* Stop after we pass the end of the last basic block.  Verify that"}, {"sha": "4de3829809e668dee2f84e60df5d6aba2cc652f4", "filename": "gcc/graph.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -292,14 +292,14 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n       for (i = n_basic_blocks - 1; i >= 0; --i)\n \t{\n \t  rtx x;\n-\t  start[INSN_UID (basic_block_head[i])] = i;\n-\t  end[INSN_UID (basic_block_end[i])] = i;\n-\t  for (x = basic_block_head[i]; x != NULL_RTX; x = NEXT_INSN (x))\n+\t  start[INSN_UID (BLOCK_HEAD (i))] = i;\n+\t  end[INSN_UID (BLOCK_END (i))] = i;\n+\t  for (x = BLOCK_HEAD (i); x != NULL_RTX; x = NEXT_INSN (x))\n \t    {\n \t      in_bb_p[INSN_UID (x)]\n \t\t= (in_bb_p[INSN_UID (x)] == NOT_IN_BB)\n \t\t ? IN_ONE_BB : IN_MULTIPLE_BB;\n-\t      if (x == basic_block_end[i])\n+\t      if (x == BLOCK_END (i))\n \t\tbreak;\n \t    }\n \t}"}, {"sha": "bf1d3cb090a030ae1e0135d566f06778d10ac564", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -136,8 +136,8 @@\n \n    This pass must update information that subsequent passes expect to\n    be correct.  Namely: reg_n_refs, reg_n_sets, reg_n_deaths,\n-   reg_n_calls_crossed, and reg_live_length.  Also, basic_block_head,\n-   basic_block_end.\n+   reg_n_calls_crossed, and reg_live_length.  Also, BLOCK_HEAD,\n+   BLOCK_END.\n \n    The information in the line number notes is carefully retained by\n    this pass.  Notes that refer to the starting and ending of\n@@ -1101,7 +1101,7 @@ is_cfg_nonregular ()\n      the cfg not well structured.  */\n   /* check for labels referred to other thn by jumps */\n   for (b = 0; b < n_basic_blocks; b++)\n-    for (insn = basic_block_head[b];; insn = NEXT_INSN (insn))\n+    for (insn = BLOCK_HEAD (b);; insn = NEXT_INSN (insn))\n       {\n \tcode = GET_CODE (insn);\n \tif (GET_RTX_CLASS (code) == 'i')\n@@ -1113,7 +1113,7 @@ is_cfg_nonregular ()\n \t\treturn 1;\n \t  }\n \n-\tif (insn == basic_block_end[b])\n+\tif (insn == BLOCK_END (b))\n \t  break;\n       }\n \n@@ -1406,8 +1406,8 @@ too_large (block, num_bbs, num_insns)\n      int block, *num_bbs, *num_insns;\n {\n   (*num_bbs)++;\n-  (*num_insns) += (INSN_LUID (basic_block_end[block]) -\n-\t\t   INSN_LUID (basic_block_head[block]));\n+  (*num_insns) += (INSN_LUID (BLOCK_END (block)) -\n+\t\t   INSN_LUID (BLOCK_HEAD (block)));\n   if ((*num_bbs > MAX_RGN_BLOCKS) || (*num_insns > MAX_RGN_INSNS))\n     return 1;\n   else\n@@ -1683,8 +1683,8 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \n \t      /* Estimate # insns, and count # blocks in the region.  */\n \t      num_bbs = 1;\n-\t      num_insns\t= (INSN_LUID (basic_block_end[i])\n-\t\t\t   - INSN_LUID (basic_block_head[i]));\n+\t      num_insns\t= (INSN_LUID (BLOCK_END (i))\n+\t\t\t   - INSN_LUID (BLOCK_HEAD (i)));\n \n \n \t      /* Find all loop latches (blocks which back edges to the loop\n@@ -4840,8 +4840,8 @@ get_block_head_tail (bb, headp, tailp)\n   b = BB_TO_BLOCK (bb);\n \n   /* HEAD and TAIL delimit the basic block being scheduled.  */\n-  head = basic_block_head[b];\n-  tail = basic_block_end[b];\n+  head = BLOCK_HEAD (b);\n+  tail = BLOCK_END (b);\n \n   /* Don't include any notes or labels at the beginning of the\n      basic block, or notes at the ends of basic blocks.  */\n@@ -4922,7 +4922,7 @@ save_line_notes (bb)\n   get_block_head_tail (bb, &head, &tail);\n   next_tail = NEXT_INSN (tail);\n \n-  for (insn = basic_block_head[BB_TO_BLOCK (bb)];\n+  for (insn = BLOCK_HEAD (BB_TO_BLOCK (bb));\n        insn != next_tail;\n        insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n@@ -4945,8 +4945,8 @@ restore_line_notes (bb)\n \n   b = BB_TO_BLOCK (bb);\n \n-  head = basic_block_head[b];\n-  next_tail = NEXT_INSN (basic_block_end[b]);\n+  head = BLOCK_HEAD (b);\n+  next_tail = NEXT_INSN (BLOCK_END (b));\n \n   /* Determine the current line-number.  We want to know the current\n      line number of the first insn of the block here, in case it is\n@@ -6683,8 +6683,7 @@ schedule_block (bb, rgn_n_insns)\n       fprintf (dump, \";;   ======================================================\\n\");\n       fprintf (dump,\n \t       \";;   -- basic block %d from %d to %d -- %s reload\\n\",\n-\t       b, INSN_UID (basic_block_head[b]),\n-\t       INSN_UID (basic_block_end[b]),\n+\t       b, INSN_UID (BLOCK_HEAD (b)), INSN_UID (BLOCK_END (b)),\n \t       (reload_completed ? \"after\" : \"before\"));\n       fprintf (dump, \";;   ======================================================\\n\");\n       fprintf (dump, \"\\n\");\n@@ -6821,9 +6820,9 @@ schedule_block (bb, rgn_n_insns)\n   last = prev_head;\n \n   /* Initialize INSN_QUEUE, LIST and NEW_NEEDS.  */\n-  new_needs = (NEXT_INSN (prev_head) == basic_block_head[b]\n+  new_needs = (NEXT_INSN (prev_head) == BLOCK_HEAD (b)\n \t       ? NEED_HEAD : NEED_NOTHING);\n-  if (PREV_INSN (next_tail) == basic_block_end[b])\n+  if (PREV_INSN (next_tail) == BLOCK_END (b))\n     new_needs |= NEED_TAIL;\n \n   /* loop until all the insns in BB are scheduled.  */\n@@ -6907,29 +6906,29 @@ schedule_block (bb, rgn_n_insns)\n \n \t\t  /* Update source block boundaries.   */\n \t\t  b1 = INSN_BLOCK (temp);\n-\t\t  if (temp == basic_block_head[b1]\n-\t\t      && insn == basic_block_end[b1])\n+\t\t  if (temp == BLOCK_HEAD (b1)\n+\t\t      && insn == BLOCK_END (b1))\n \t\t    {\n \t\t      /* We moved all the insns in the basic block.\n \t\t\t Emit a note after the last insn and update the\n \t\t\t begin/end boundaries to point to the note.  */\n \t\t      emit_note_after (NOTE_INSN_DELETED, insn);\n-\t\t      basic_block_end[b1] = NEXT_INSN (insn);\n-\t\t      basic_block_head[b1] = NEXT_INSN (insn);\n+\t\t      BLOCK_END (b1) = NEXT_INSN (insn);\n+\t\t      BLOCK_HEAD (b1) = NEXT_INSN (insn);\n \t\t    }\n-\t\t  else if (insn == basic_block_end[b1])\n+\t\t  else if (insn == BLOCK_END (b1))\n \t\t    {\n \t\t      /* We took insns from the end of the basic block,\n \t\t\t so update the end of block boundary so that it\n \t\t\t points to the first insn we did not move.  */\n-\t\t      basic_block_end[b1] = PREV_INSN (temp);\n+\t\t      BLOCK_END (b1) = PREV_INSN (temp);\n \t\t    }\n-\t\t  else if (temp == basic_block_head[b1])\n+\t\t  else if (temp == BLOCK_HEAD (b1))\n \t\t    {\n \t\t      /* We took insns from the start of the basic block,\n \t\t\t so update the start of block boundary so that\n \t\t\t it points to the first insn we did not move.  */\n-\t\t      basic_block_head[b1] = NEXT_INSN (insn);\n+\t\t      BLOCK_HEAD (b1) = NEXT_INSN (insn);\n \t\t    }\n \t\t}\n \t      else\n@@ -7005,18 +7004,18 @@ schedule_block (bb, rgn_n_insns)\n \n   /* update target block boundaries.  */\n   if (new_needs & NEED_HEAD)\n-    basic_block_head[b] = head;\n+    BLOCK_HEAD (b) = head;\n \n   if (new_needs & NEED_TAIL)\n-    basic_block_end[b] = tail;\n+    BLOCK_END (b) = tail;\n \n   /* debugging */\n   if (sched_verbose)\n     {\n       fprintf (dump, \";;   total time = %d\\n;;   new basic block head = %d\\n\",\n-\t       clock_var, INSN_UID (basic_block_head[b]));\n+\t       clock_var, INSN_UID (BLOCK_HEAD (b)));\n       fprintf (dump, \";;   new basic block end = %d\\n\\n\",\n-\t       INSN_UID (basic_block_end[b]));\n+\t       INSN_UID (BLOCK_END (b)));\n     }\n \n   return (sched_n_insns);\n@@ -8418,7 +8417,7 @@ split_block_insns (b)\n {\n   rtx insn, next;\n \n-  for (insn = basic_block_head[b];; insn = next)\n+  for (insn = BLOCK_HEAD (b);; insn = next)\n     {\n       rtx set, last, first, notes;\n \n@@ -8427,7 +8426,7 @@ split_block_insns (b)\n       next = NEXT_INSN (insn);\n       if (GET_CODE (insn) != INSN)\n \t{\n-\t  if (insn == basic_block_end[b])\n+\t  if (insn == BLOCK_END (b))\n \t    break;\n \n \t  continue;\n@@ -8439,7 +8438,7 @@ split_block_insns (b)\n       set = single_set (insn);\n       if (set && rtx_equal_p (SET_SRC (set), SET_DEST (set)))\n \t{\n-\t  if (insn == basic_block_end[b])\n+\t  if (insn == BLOCK_END (b))\n \t    break;\n \n \t  /* Nops get in the way while scheduling, so delete them now if\n@@ -8469,16 +8468,16 @@ split_block_insns (b)\n \t  PUT_CODE (insn, NOTE);\n \t  NOTE_SOURCE_FILE (insn) = 0;\n \t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t  if (insn == basic_block_head[b])\n-\t    basic_block_head[b] = first;\n-\t  if (insn == basic_block_end[b])\n+\t  if (insn == BLOCK_HEAD (b))\n+\t    BLOCK_HEAD (b) = first;\n+\t  if (insn == BLOCK_END (b))\n \t    {\n-\t      basic_block_end[b] = last;\n+\t      BLOCK_END (b) = last;\n \t      break;\n \t    }\n \t}\n \n-      if (insn == basic_block_end[b])\n+      if (insn == BLOCK_END (b))\n \tbreak;\n     }\n }\n@@ -8554,12 +8553,12 @@ schedule_insns (dump_file)\n \n   luid = 0;\n   for (b = 0; b < n_basic_blocks; b++)\n-    for (insn = basic_block_head[b];; insn = NEXT_INSN (insn))\n+    for (insn = BLOCK_HEAD (b);; insn = NEXT_INSN (insn))\n       {\n \tINSN_BLOCK (insn) = b;\n \tINSN_LUID (insn) = luid++;\n \n-\tif (insn == basic_block_end[b])\n+\tif (insn == BLOCK_END (b))\n \t  break;\n       }\n \n@@ -8570,7 +8569,7 @@ schedule_insns (dump_file)\n       rtx insn;\n \n       for (b = 0; b < n_basic_blocks; b++)\n-\tfor (insn = basic_block_head[b];; insn = NEXT_INSN (insn))\n+\tfor (insn = BLOCK_HEAD (b);; insn = NEXT_INSN (insn))\n \t  {\n \t    rtx link, prev;\n \n@@ -8592,7 +8591,7 @@ schedule_insns (dump_file)\n \t\t  }\n \t      }\n \n-\t    if (insn == basic_block_end[b])\n+\t    if (insn == BLOCK_END (b))\n \t      break;\n \t  }\n     }\n@@ -8725,7 +8724,7 @@ schedule_insns (dump_file)\n          determine the correct line number for the first insn of the block.  */\n \n       for (b = 0; b < n_basic_blocks; b++)\n-\tfor (line = basic_block_head[b]; line; line = PREV_INSN (line))\n+\tfor (line = BLOCK_HEAD (b); line; line = PREV_INSN (line))\n \t  if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n \t    {\n \t      line_note_head[b] = line;\n@@ -8752,15 +8751,15 @@ schedule_insns (dump_file)\n   /* ??? Add a NOTE after the last insn of the last basic block.  It is not\n      known why this is done.  */\n \n-  insn = basic_block_end[n_basic_blocks - 1];\n+  insn = BLOCK_END (n_basic_blocks - 1);\n   if (NEXT_INSN (insn) == 0\n       || (GET_CODE (insn) != NOTE\n \t  && GET_CODE (insn) != CODE_LABEL\n-  /* Don't emit a NOTE if it would end up between an unconditional\n-     jump and a BARRIER.  */\n+\t  /* Don't emit a NOTE if it would end up between an unconditional\n+\t     jump and a BARRIER.  */\n \t  && !(GET_CODE (insn) == JUMP_INSN\n \t       && GET_CODE (NEXT_INSN (insn)) == BARRIER)))\n-    emit_note_after (NOTE_INSN_DELETED, basic_block_end[n_basic_blocks - 1]);\n+    emit_note_after (NOTE_INSN_DELETED, BLOCK_END (n_basic_blocks - 1));\n \n   /* Schedule every region in the subroutine */\n   for (rgn = 0; rgn < nr_regions; rgn++)"}, {"sha": "660efce62c6fe64bcc36f4dc4bd12fc8cca6e171", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -888,7 +888,7 @@ update_equiv_regs ()\n \n       /* Keep track of which basic block we are in.  */\n       if (block + 1 < n_basic_blocks\n-\t  && basic_block_head[block + 1] == insn)\n+\t  && BLOCK_HEAD (block + 1) == insn)\n \t++block;\n \n       if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n@@ -962,8 +962,8 @@ update_equiv_regs ()\n \t\t  REG_N_CALLS_CROSSED (regno) = 0;\n \t\t  REG_LIVE_LENGTH (regno) = 2;\n \n-\t\t  if (block >= 0 && insn == basic_block_head[block])\n-\t\t    basic_block_head[block] = PREV_INSN (insn);\n+\t\t  if (block >= 0 && insn == BLOCK_HEAD (block))\n+\t\t    BLOCK_HEAD (block) = PREV_INSN (insn);\n \n \t\t  for (l = 0; l < n_basic_blocks; l++)\n \t\t    CLEAR_REGNO_REG_SET (basic_block_live_at_start[l], regno);\n@@ -1020,13 +1020,13 @@ block_alloc (b)\n \n   /* Count the instructions in the basic block.  */\n \n-  insn = basic_block_end[b];\n+  insn = BLOCK_END (b);\n   while (1)\n     {\n       if (GET_CODE (insn) != NOTE)\n \tif (++insn_count > max_uid)\n \t  abort ();\n-      if (insn == basic_block_head[b])\n+      if (insn == BLOCK_HEAD (b))\n \tbreak;\n       insn = PREV_INSN (insn);\n     }\n@@ -1045,7 +1045,7 @@ block_alloc (b)\n      and assigns quantities to registers.\n      It computes which registers to tie.  */\n \n-  insn = basic_block_head[b];\n+  insn = BLOCK_HEAD (b);\n   while (1)\n     {\n       register rtx body = PATTERN (insn);\n@@ -1283,7 +1283,7 @@ block_alloc (b)\n       IOR_HARD_REG_SET (regs_live_at[2 * insn_number], regs_live);\n       IOR_HARD_REG_SET (regs_live_at[2 * insn_number + 1], regs_live);\n \n-      if (insn == basic_block_end[b])\n+      if (insn == BLOCK_END (b))\n \tbreak;\n \n       insn = NEXT_INSN (insn);"}, {"sha": "623dd98784d01e344b6a4f5aa4b1349a028ee942", "filename": "gcc/regclass.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -868,8 +868,8 @@ scan_one_insn (insn, pass)\n \t{\n \t  int b;\n \t  for (b = 0; b < n_basic_blocks; b++)\n-\t    if (insn == basic_block_head[b])\n-\t      basic_block_head[b] = newinsn;\n+\t    if (insn == BLOCK_HEAD (b))\n+\t      BLOCK_HEAD (b) = newinsn;\n \t}\n \n       /* This makes one more setting of new insns's dest.  */"}, {"sha": "843f10e605f4d013acb4830af665abbd6a1353e2", "filename": "gcc/regmove.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -673,7 +673,7 @@ copy_src_to_dest (insn, src, dest, loop_depth)\n       bb = regmove_bb_head[insn_uid];\n       if (bb >= 0)\n \t{\n-\t  basic_block_head[bb] = move_insn;\n+\t  BLOCK_HEAD (bb) = move_insn;\n \t  regmove_bb_head[insn_uid] = -1;\n \t}\n \n@@ -936,7 +936,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n   regmove_bb_head = (int *)alloca (sizeof (int) * (old_max_uid + 1));\n   for (i = old_max_uid; i >= 0; i--) regmove_bb_head[i] = -1;\n   for (i = 0; i < n_basic_blocks; i++)\n-    regmove_bb_head[INSN_UID (basic_block_head[i])] = i;\n+    regmove_bb_head[INSN_UID (BLOCK_HEAD (i))] = i;\n \n   /* A forward/backward pass.  Replace output operands with input operands.  */\n \n@@ -1390,13 +1390,13 @@ regmove_optimize (f, nregs, regmove_dump_file)\n      ends.  Fix that here.  */\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n-      rtx end = basic_block_end[i];\n+      rtx end = BLOCK_END (i);\n       rtx new = end;\n       rtx next = NEXT_INSN (new);\n       while (next != 0 && INSN_UID (next) >= old_max_uid\n-\t     && (i == n_basic_blocks - 1 || basic_block_head[i + 1] != next))\n+\t     && (i == n_basic_blocks - 1 || BLOCK_HEAD (i + 1) != next))\n \tnew = next, next = NEXT_INSN (new);\n-      basic_block_end[i] = new;\n+      BLOCK_END (i) = new;\n     }\n }\n "}, {"sha": "fbb506cb4e4c3c377ac25d1d35c2f2d2aee39a60", "filename": "gcc/reload1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -2039,10 +2039,10 @@ delete_caller_save_insns ()\n \t  struct insn_chain *next = c->next;\n \t  rtx insn = c->insn;\n \n-\t  if (insn == basic_block_head[c->block])\n-\t    basic_block_head[c->block] = NEXT_INSN (insn);\n-\t  if (insn == basic_block_end[c->block])\n-\t    basic_block_end[c->block] = PREV_INSN (insn);\n+\t  if (insn == BLOCK_HEAD (c->block))\n+\t    BLOCK_HEAD (c->block) = NEXT_INSN (insn);\n+\t  if (insn == BLOCK_END (c->block))\n+\t    BLOCK_END (c->block) = PREV_INSN (insn);\n \t  if (c == reload_insn_chain)\n \t    reload_insn_chain = next;\n \n@@ -7308,10 +7308,10 @@ emit_reload_insns (chain)\n   /* Keep basic block info up to date.  */\n   if (n_basic_blocks)\n     {\n-      if (basic_block_head[chain->block] == insn)\n-        basic_block_head[chain->block] = NEXT_INSN (before_insn);\n-      if (basic_block_end[chain->block] == insn)\n-        basic_block_end[chain->block] = PREV_INSN (following_insn);\n+      if (BLOCK_HEAD (chain->block) == insn)\n+        BLOCK_HEAD (chain->block) = NEXT_INSN (before_insn);\n+      if (BLOCK_END (chain->block) == insn)\n+        BLOCK_END (chain->block) = PREV_INSN (following_insn);\n     }\n \n   /* For all the spill regs newly reloaded in this instruction,\n@@ -9464,7 +9464,7 @@ reload_combine ()\n   CLEAR_HARD_REG_SET (ever_live_at_start);\n   for (i = n_basic_blocks - 1; i >= 0; i--)\n     {\n-      insn = basic_block_head[i];\n+      insn = BLOCK_HEAD (i);\n       if (GET_CODE (insn) == CODE_LABEL)\n \t{\n \t  HARD_REG_SET live;"}, {"sha": "d0abf37f2c9e14965f5582a21f465df8ce750ae5", "filename": "gcc/reorg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -2349,7 +2349,7 @@ find_basic_block (insn)\n        insn = next_nonnote_insn (insn))\n     {\n       for (i = 0; i < n_basic_blocks; i++)\n-\tif (insn == basic_block_head[i])\n+\tif (insn == BLOCK_HEAD (i))\n \t  return i;\n     }\n \n@@ -2818,7 +2818,7 @@ mark_target_live_regs (target, res)\n      we can get it from there unless the insn at the start of the basic block\n      has been deleted.  */\n   if (tinfo && tinfo->block != -1\n-      && ! INSN_DELETED_P (basic_block_head[tinfo->block]))\n+      && ! INSN_DELETED_P (BLOCK_HEAD (tinfo->block)))\n     b = tinfo->block;\n \n   if (b == -1)\n@@ -2876,7 +2876,7 @@ mark_target_live_regs (target, res)\n \n       /* Get starting and ending insn, handling the case where each might\n \t be a SEQUENCE.  */\n-      start_insn = (b == 0 ? get_insns () : basic_block_head[b]);\n+      start_insn = (b == 0 ? get_insns () : BLOCK_HEAD (b));\n       stop_insn = target;\n \n       if (GET_CODE (start_insn) == INSN"}, {"sha": "50684b0cf13aeac84f10013c0e0479d6322e80f1", "filename": "gcc/sched.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b413743e0719ecca26e5f5426b6baa837e0a13b/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=3b413743e0719ecca26e5f5426b6baa837e0a13b", "patch": "@@ -108,8 +108,8 @@ Boston, MA 02111-1307, USA.  */\n \n    This pass must update information that subsequent passes expect to be\n    correct.  Namely: reg_n_refs, reg_n_sets, reg_n_deaths,\n-   reg_n_calls_crossed, and reg_live_length.  Also, basic_block_head,\n-   basic_block_end.\n+   reg_n_calls_crossed, and reg_live_length.  Also, BLOCK_HEAD,\n+   BLOCK_END.\n \n    The information in the line number notes is carefully retained by\n    this pass.  Notes that refer to the starting and ending of\n@@ -2616,8 +2616,8 @@ schedule_block (b, file)\n   int new_needs;\n \n   /* HEAD and TAIL delimit the region being scheduled.  */\n-  rtx head = basic_block_head[b];\n-  rtx tail = basic_block_end[b];\n+  rtx head = BLOCK_HEAD (b);\n+  rtx tail = BLOCK_END (b);\n   /* PREV_HEAD and NEXT_TAIL are the boundaries of the insns\n      being scheduled.  When the insns have been ordered,\n      these insns delimit where the new insns are to be\n@@ -2631,7 +2631,7 @@ schedule_block (b, file)\n \n   if (file)\n     fprintf (file, \";;\\t -- basic block number %d from %d to %d --\\n\",\n-\t     b, INSN_UID (basic_block_head[b]), INSN_UID (basic_block_end[b]));\n+\t     b, INSN_UID (BLOCK_HEAD (b)), INSN_UID (BLOCK_END (b)));\n \n   i = max_reg_num ();\n   reg_last_uses = (rtx *) alloca (i * sizeof (rtx));\n@@ -2893,7 +2893,7 @@ schedule_block (b, file)\n \t  /* We don't want to remove any REG_DEAD notes as the code below\n \t     does.  */\n \n-\t  for (insn = basic_block_head[b]; insn != head;\n+\t  for (insn = BLOCK_HEAD (b); insn != head;\n \t       insn = NEXT_INSN (insn))\n \t    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t      {\n@@ -2977,7 +2977,7 @@ schedule_block (b, file)\n \t block may have changed the current line number.  */\n       rtx line = line_note_head[b];\n \n-      for (insn = basic_block_head[b];\n+      for (insn = BLOCK_HEAD (b);\n \t   insn != next_tail;\n \t   insn = NEXT_INSN (insn))\n \tif (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n@@ -3141,9 +3141,9 @@ schedule_block (b, file)\n   /* Where we start inserting insns is after TAIL.  */\n   last = next_tail;\n \n-  new_needs = (NEXT_INSN (prev_head) == basic_block_head[b]\n+  new_needs = (NEXT_INSN (prev_head) == BLOCK_HEAD (b)\n \t       ? NEED_HEAD : NEED_NOTHING);\n-  if (PREV_INSN (next_tail) == basic_block_end[b])\n+  if (PREV_INSN (next_tail) == BLOCK_END (b))\n     new_needs |= NEED_TAIL;\n \n   new_ready = n_ready;\n@@ -3450,12 +3450,12 @@ schedule_block (b, file)\n #endif\n \n   if (new_needs & NEED_HEAD)\n-    basic_block_head[b] = head;\n+    BLOCK_HEAD (b) = head;\n   PREV_INSN (head) = prev_head;\n   NEXT_INSN (prev_head) = head;\n \n   if (new_needs & NEED_TAIL)\n-    basic_block_end[b] = tail;\n+    BLOCK_END (b) = tail;\n   NEXT_INSN (tail) = next_tail;\n   PREV_INSN (next_tail) = tail;\n \n@@ -3465,8 +3465,8 @@ schedule_block (b, file)\n       rtx line, note, prev, new;\n       int notes = 0;\n \n-      head = basic_block_head[b];\n-      next_tail = NEXT_INSN (basic_block_end[b]);\n+      head = BLOCK_HEAD (b);\n+      next_tail = NEXT_INSN (BLOCK_END (b));\n \n       /* Determine the current line-number.  We want to know the current\n \t line number of the first insn of the block here, in case it is\n@@ -3520,7 +3520,7 @@ schedule_block (b, file)\n   if (file)\n     {\n       fprintf (file, \";; total time = %d\\n;; new basic block head = %d\\n;; new basic block end = %d\\n\\n\",\n-\t       clock, INSN_UID (basic_block_head[b]), INSN_UID (basic_block_end[b]));\n+\t       clock, INSN_UID (BLOCK_HEAD (b)), INSN_UID (BLOCK_END (b)));\n     }\n \n   /* Yow! We're done!  */\n@@ -4327,7 +4327,7 @@ schedule_insns (dump_file)\n \t determine the correct line number for the first insn of the block.  */\n \t \n       for (b = 0; b < n_basic_blocks; b++)\n-\tfor (line = basic_block_head[b]; line; line = PREV_INSN (line))\n+\tfor (line = BLOCK_HEAD (b); line; line = PREV_INSN (line))\n \t  if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n \t    {\n \t      line_note_head[b] = line;\n@@ -4350,23 +4350,23 @@ schedule_insns (dump_file)\n   /* ??? Perhaps it's done to ensure NEXT_TAIL in schedule_block is a\n      valid insn.  */\n \n-  insn = basic_block_end[n_basic_blocks-1];\n+  insn = BLOCK_END (n_basic_blocks-1);\n   if (NEXT_INSN (insn) == 0\n       || (GET_CODE (insn) != NOTE\n \t  && GET_CODE (insn) != CODE_LABEL\n \t  /* Don't emit a NOTE if it would end up between an unconditional\n \t     jump and a BARRIER.  */\n \t  && ! (GET_CODE (insn) == JUMP_INSN\n \t\t&& GET_CODE (NEXT_INSN (insn)) == BARRIER)))\n-    emit_note_after (NOTE_INSN_DELETED, basic_block_end[n_basic_blocks-1]);\n+    emit_note_after (NOTE_INSN_DELETED, BLOCK_END (n_basic_blocks-1));\n \n   for (b = 0; b < n_basic_blocks; b++)\n     {\n       rtx insn, next;\n \n       note_list = 0;\n \n-      for (insn = basic_block_head[b]; ; insn = next)\n+      for (insn = BLOCK_HEAD (b); ; insn = next)\n \t{\n \t  rtx prev;\n \t  rtx set;\n@@ -4376,7 +4376,7 @@ schedule_insns (dump_file)\n \t  next = NEXT_INSN (insn);\n \t  if (GET_CODE (insn) != INSN)\n \t    {\n-\t      if (insn == basic_block_end[b])\n+\t      if (insn == BLOCK_END (b))\n \t\tbreak;\n \n \t      continue;\n@@ -4388,7 +4388,7 @@ schedule_insns (dump_file)\n \t  set = single_set (insn);\n \t  if (set && rtx_equal_p (SET_SRC (set), SET_DEST (set)))\n \t    {\n-\t      if (insn == basic_block_end[b])\n+\t      if (insn == BLOCK_END (b))\n \t\tbreak;\n \n \t      /* Nops get in the way while scheduling, so delete them now if\n@@ -4425,17 +4425,17 @@ schedule_insns (dump_file)\n \t\t  PUT_CODE (insn, NOTE);\n \t\t  NOTE_SOURCE_FILE (insn) = 0;\n \t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t  if (insn == basic_block_head[b])\n-\t\t    basic_block_head[b] = first;\n-\t\t  if (insn == basic_block_end[b])\n+\t\t  if (insn == BLOCK_HEAD (b))\n+\t\t    BLOCK_HEAD (b) = first;\n+\t\t  if (insn == BLOCK_END (b))\n \t\t    {\n-\t\t      basic_block_end[b] = last;\n+\t\t      BLOCK_END (b) = last;\n \t\t      break;\n \t\t    }\n \t\t}\n \t    }\n \n-\t  if (insn == basic_block_end[b])\n+\t  if (insn == BLOCK_END (b))\n \t    break;\n \t}\n "}]}