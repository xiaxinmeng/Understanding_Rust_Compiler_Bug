{"sha": "b565d777838af4eea84460c8df8fcc081c5187d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU2NWQ3Nzc4MzhhZjRlZWE4NDQ2MGM4ZGY4ZmNjMDgxYzUxODdkNA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-05-02T22:54:37Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-05-02T22:54:37Z"}, "message": "tree-vrp.c (set_value_range_to_nonnull): Declare inline.\n\n\n\t* tree-vrp.c (set_value_range_to_nonnull): Declare inline.\n\t(set_value_range_to_null): Likewise.\n\t(set_value_range_to_varying): New function.  Use it in all\n\tcall sites that used to call set_value_range (vr, VR_VARYING, ...).\n\t(extract_range_from_assert): If the integral type has a\n\tsuper-type, and LIMIT is not within MIN and MAX values of that\n\ttype, set the resulting range to VR_VARYING.\n\nFrom-SVN: r99125", "tree": {"sha": "6ba2e39d33af8f80765511949ee8498a48006adc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ba2e39d33af8f80765511949ee8498a48006adc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b565d777838af4eea84460c8df8fcc081c5187d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b565d777838af4eea84460c8df8fcc081c5187d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b565d777838af4eea84460c8df8fcc081c5187d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b565d777838af4eea84460c8df8fcc081c5187d4/comments", "author": null, "committer": null, "parents": [{"sha": "eeac8f6b3a358933cf095f7b690a229de9f07b85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeac8f6b3a358933cf095f7b690a229de9f07b85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeac8f6b3a358933cf095f7b690a229de9f07b85"}], "stats": {"total": 139, "additions": 109, "deletions": 30}, "files": [{"sha": "d39c6d26d006a5e744ed9dc71fe8edb07127b275", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565d777838af4eea84460c8df8fcc081c5187d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565d777838af4eea84460c8df8fcc081c5187d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b565d777838af4eea84460c8df8fcc081c5187d4", "patch": "@@ -1,3 +1,13 @@\n+2005-05-02  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-vrp.c (set_value_range_to_nonnull): Declare inline.\n+\t(set_value_range_to_null): Likewise.\n+\t(set_value_range_to_varying): New function.  Use it in all\n+\tcall sites that used to call set_value_range (vr, VR_VARYING, ...).\n+\t(extract_range_from_assert): If the integral type has a\n+\tsuper-type, and LIMIT is not within MIN and MAX values of that\n+\ttype, set the resulting range to VR_VARYING.\n+\n 2005-05-02  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* config/mmix/mmix.opt: New file."}, {"sha": "e2f2a4464372c0203ee030b326e76f8b33cad56d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 99, "deletions": 30, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b565d777838af4eea84460c8df8fcc081c5187d4/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b565d777838af4eea84460c8df8fcc081c5187d4/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b565d777838af4eea84460c8df8fcc081c5187d4", "patch": "@@ -251,7 +251,7 @@ range_is_null (value_range *vr)\n \n /* Set value range VR to a non-NULL range of type TYPE.  */\n \n-static void\n+static inline void\n set_value_range_to_nonnull (value_range *vr, tree type)\n {\n   tree zero = build_int_cst (type, 0);\n@@ -261,14 +261,23 @@ set_value_range_to_nonnull (value_range *vr, tree type)\n \n /* Set value range VR to a NULL range of type TYPE.  */\n \n-static void\n+static inline void\n set_value_range_to_null (value_range *vr, tree type)\n {\n   tree zero = build_int_cst (type, 0);\n   set_value_range (vr, VR_RANGE, zero, zero);\n }\n \n \n+/* Set value range VR to VR_VARYING.  */\n+\n+static inline void\n+set_value_range_to_varying (value_range *vr)\n+{\n+  set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+}\n+\n+\n /* Compare two values VAL1 and VAL2.  Return\n    \n    \t-2 if VAL1 and VAL2 cannot be compared at compile-time,\n@@ -477,9 +486,11 @@ extract_range_from_assert (value_range *vr_p, tree expr)\n {\n   tree var, cond, limit, type;\n   value_range *var_vr;\n+  enum tree_code cond_code;\n \n   var = ASSERT_EXPR_VAR (expr);\n   cond = ASSERT_EXPR_COND (expr);\n+  cond_code = TREE_CODE (cond);\n \n   gcc_assert (COMPARISON_CLASS_P (cond));\n \n@@ -493,12 +504,70 @@ extract_range_from_assert (value_range *vr_p, tree expr)\n      (NE_EXPR).  Notice that we don't need to handle EQ_EXPR in these\n      cases because assertions with equalities are never generated.\n      The assert pass generates straight assignments in those cases.  */\n-  if (POINTER_TYPE_P (type) && TREE_CODE (cond) != NE_EXPR)\n+  if (POINTER_TYPE_P (type) && cond_code != NE_EXPR)\n     {\n-      set_value_range (vr_p, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr_p);\n       return;\n     }\n \n+  /* Special handling for integral types with super-types.  Some FEs\n+     construct integral types derived from other types and restrict\n+     the range of values these new types may take.\n+\n+     It may happen that LIMIT is actually smaller than TYPE's minimum\n+     value.  For instance, the Ada FE is generating code like this\n+     during bootstrap:\n+\n+\t    D.1480_32 = nam_30 - 300000361;\n+\t    if (D.1480_32 <= 1) goto <L112>; else goto <L52>;\n+\t    <L112>:;\n+\t    D.1480_94 = ASSERT_EXPR <D.1480_32, D.1480_32 <= 1>;\n+\n+     All the names are of type types__name_id___XDLU_300000000__399999999\n+     which has min == 300000000 and max == 399999999.  This means that\n+     the ASSERT_EXPR would try to create the range [3000000, 1] which\n+     is invalid.\n+\n+     The fact that the type specifies MIN and MAX values does not\n+     automatically mean that every variable of that type will always\n+     be within that range, so the predicate may well be true at run\n+     time.  If we had symbolic -INF and +INF values, we could\n+     represent this range, but we currently represent -INF and +INF\n+     using the type's min and max values.\n+\t \n+     So, the only sensible thing we can do for now is set the\n+     resulting range to VR_VARYING.  TODO, would having symbolic -INF\n+     and +INF values be worth the trouble?  */\n+  if (TREE_TYPE (type))\n+    {\n+      if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n+\t{\n+\t  tree type_min = TYPE_MIN_VALUE (type);\n+\t  int cmp = compare_values (limit, type_min);\n+\n+\t  /* For < or <= comparisons, if LIMIT is smaller than\n+\t     TYPE_MIN, set the range to VR_VARYING.  */\n+\t  if (cmp == -1 || cmp == 0)\n+\t    {\n+\t      set_value_range_to_varying (vr_p);\n+\t      return;\n+\t    }\n+\t}\n+      else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n+\t{\n+\t  tree type_max = TYPE_MIN_VALUE (type);\n+\t  int cmp = compare_values (limit, type_max);\n+\n+\t  /* For > or >= comparisons, if LIMIT is bigger than\n+\t     TYPE_MAX, set the range to VR_VARYING.  */\n+\t  if (cmp == 1 || cmp == 0)\n+\t    {\n+\t      set_value_range_to_varying (vr_p);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n   if (TREE_CODE (cond) == NE_EXPR)\n     set_value_range (vr_p, VR_ANTI_RANGE, limit, limit);\n   else if (TREE_CODE (cond) == LE_EXPR)\n@@ -599,7 +668,7 @@ extract_range_from_binary_expr (value_range *vr, tree expr)\n       && code != MIN_EXPR\n       && code != MAX_EXPR)\n     {\n-      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr);\n       return;\n     }\n \n@@ -613,7 +682,7 @@ extract_range_from_binary_expr (value_range *vr, tree expr)\n       if (is_gimple_min_invariant (op0))\n \tset_value_range (&vr0, VR_RANGE, op0, op0);\n       else\n-\tset_value_range (&vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+\tset_value_range_to_varying (&vr0);\n     }\n \n   op1 = TREE_OPERAND (expr, 1);\n@@ -624,7 +693,7 @@ extract_range_from_binary_expr (value_range *vr, tree expr)\n       if (is_gimple_min_invariant (op1))\n \tset_value_range (&vr1, VR_RANGE, op1, op1);\n       else\n-\tset_value_range (&vr1, VR_VARYING, 0, 0);\n+\tset_value_range_to_varying (&vr1);\n     }\n \n   /* If either range is UNDEFINED, so is the result.  */\n@@ -637,21 +706,21 @@ extract_range_from_binary_expr (value_range *vr, tree expr)\n   /* If either range is VARYING, so is the result.  */\n   if (vr0.type == VR_VARYING || vr1.type == VR_VARYING)\n     {\n-      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr);\n       return;\n     }\n \n   /* If the ranges are of different types, the result is VARYING.  */\n   if (vr0.type != vr1.type)\n     {\n-      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr);\n       return;\n     }\n \n   /* TODO.  Refuse to do any symbolic range operations for now.  */\n   if (symbolic_range_p (&vr0) || symbolic_range_p (&vr1))\n     {\n-      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr);\n       return;\n     }\n \n@@ -676,7 +745,7 @@ extract_range_from_binary_expr (value_range *vr, tree expr)\n \t{\n \t  /* Subtracting from a pointer, may yield 0, so just drop the\n \t     resulting range to varying.  */\n-\t  set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+\t  set_value_range_to_varying (vr);\n \t}\n \n       return;\n@@ -710,7 +779,7 @@ extract_range_from_binary_expr (value_range *vr, tree expr)\n       /* If the new range has its limits swapped around (MIN > MAX),\n \t then the operation caused one of them to wrap around, mark\n \t the new range VARYING.  */\n-      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr);\n     }\n   else\n     set_value_range (vr, vr0.type, min, max);\n@@ -767,7 +836,7 @@ extract_range_from_unary_expr (value_range *vr, tree expr)\n       if (is_gimple_min_invariant (op0))\n \tset_value_range (&vr0, VR_RANGE, op0, op0);\n       else\n-\tset_value_range (&vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+\tset_value_range_to_varying (&vr0);\n     }\n \n   /* If VR0 is UNDEFINED, so is the result.  */\n@@ -780,14 +849,14 @@ extract_range_from_unary_expr (value_range *vr, tree expr)\n   /* If VR0 is VARYING, so is the result.  */\n   if (vr0.type == VR_VARYING)\n     {\n-      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr);\n       return;\n     }\n \n   /* TODO.  Refuse to do any symbolic range operations for now.  */\n   if (symbolic_range_p (&vr0))\n     {\n-      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr);\n       return;\n     }\n \n@@ -796,7 +865,7 @@ extract_range_from_unary_expr (value_range *vr, tree expr)\n   if (!INTEGRAL_TYPE_P (TREE_TYPE (op0))\n       && !POINTER_TYPE_P (TREE_TYPE (op0)))\n     {\n-      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr);\n       return;\n     }\n \n@@ -809,7 +878,7 @@ extract_range_from_unary_expr (value_range *vr, tree expr)\n       else if (range_is_null (&vr0))\n \tset_value_range_to_null (vr, TREE_TYPE (expr));\n       else\n-\tset_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+\tset_value_range_to_varying (vr);\n \n       return;\n     }\n@@ -824,7 +893,7 @@ extract_range_from_unary_expr (value_range *vr, tree expr)\n \t int' and 'y_5 = (unsigned short) x_3', if x_3 is ~[0, 0], it\n \t is impossible to know at compile time whether y_5 will be\n \t ~[0, 0].  */\n-      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr);\n       return;\n     }\n \n@@ -839,7 +908,7 @@ extract_range_from_unary_expr (value_range *vr, tree expr)\n       /* If the new range has its limits swapped around (MIN > MAX),\n \t then the operation caused one of them to wrap around, mark\n \t the new range VARYING.  */\n-      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr);\n     }\n   else\n     set_value_range (vr, vr0.type, min, max);\n@@ -867,7 +936,7 @@ extract_range_from_expr (value_range *vr, tree expr)\n   else if (TREE_CODE (expr) == INTEGER_CST)\n     set_value_range (vr, VR_RANGE, expr, expr);\n   else\n-    set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+    set_value_range_to_varying (vr);\n }\n \n \n@@ -1791,7 +1860,7 @@ vrp_initialize (void)\n \t  if (!stmt_interesting_for_vrp (phi))\n \t    {\n \t      tree lhs = PHI_RESULT (phi);\n-\t      set_value_range (get_value_range (lhs), VR_VARYING, 0, 0);\n+\t      set_value_range_to_varying (get_value_range (lhs));\n \t      DONT_SIMULATE_AGAIN (phi) = true;\n \t    }\n \t  else\n@@ -1807,7 +1876,7 @@ vrp_initialize (void)\n \t      ssa_op_iter i;\n \t      tree def;\n \t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, i, SSA_OP_DEF)\n-\t\tset_value_range (get_value_range (def), VR_VARYING, 0, 0);\n+\t\tset_value_range_to_varying (get_value_range (def));\n \t      DONT_SIMULATE_AGAIN (stmt) = true;\n \t    }\n \t  else\n@@ -1878,7 +1947,7 @@ vrp_visit_assignment (tree stmt, tree *output_p)\n   \n   /* Every other statements produces no useful ranges.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n-    set_value_range (get_value_range (def), VR_VARYING, 0, 0);\n+    set_value_range_to_varying (get_value_range (def));\n \n   return SSA_PROP_VARYING;\n }\n@@ -2021,7 +2090,7 @@ vrp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n   /* All other statements produce nothing of interest for VRP, so mark\n      their outputs varying and prevent further simulation.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n-    set_value_range (get_value_range (def), VR_VARYING, 0, 0);\n+    set_value_range_to_varying (get_value_range (def));\n \n   return SSA_PROP_VARYING;\n }\n@@ -2067,7 +2136,7 @@ vrp_meet (value_range *vr0, value_range *vr1)\n   /* If either is a symbolic range, drop to VARYING.  */\n   if (symbolic_range_p (vr0) || symbolic_range_p (vr1))\n     {\n-      set_value_range (vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+      set_value_range_to_varying (vr0);\n       return;\n     }\n \n@@ -2097,7 +2166,7 @@ vrp_meet (value_range *vr0, value_range *vr1)\n       else\n \t{\n \t  /* The two ranges don't intersect, set the result to VR_VARYING.  */\n-\t  set_value_range (vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+\t  set_value_range_to_varying (vr0);\n \t}\n     }\n   else if (vr0->type == VR_ANTI_RANGE && vr1->type == VR_ANTI_RANGE)\n@@ -2108,7 +2177,7 @@ vrp_meet (value_range *vr0, value_range *vr1)\n \t  && compare_values (vr0->min, vr0->max) == 0)\n \t/* Nothing to do.  */ ;\n       else\n-\tset_value_range (vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+\tset_value_range_to_varying (vr0);\n     }\n   else if (vr0->type == VR_ANTI_RANGE || vr1->type == VR_ANTI_RANGE)\n     {\n@@ -2121,7 +2190,7 @@ vrp_meet (value_range *vr0, value_range *vr1)\n \t    *vr0 = *vr1;\n \t}\n       else\n-\tset_value_range (vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+\tset_value_range_to_varying (vr0);\n     }\n   else\n     gcc_unreachable ();\n@@ -2190,7 +2259,7 @@ vrp_visit_phi_node (tree phi)\n \n   if (vr_result.type == VR_VARYING)\n     {\n-      set_value_range (lhs_vr, VR_VARYING, 0, 0);\n+      set_value_range_to_varying (lhs_vr);\n       return SSA_PROP_VARYING;\n     }\n \n@@ -2222,7 +2291,7 @@ vrp_visit_phi_node (tree phi)\n \t  if (vr_result.min == TYPE_MIN_VALUE (TREE_TYPE (vr_result.min))\n \t      && vr_result.max == TYPE_MAX_VALUE (TREE_TYPE (vr_result.max)))\n \t    {\n-\t      set_value_range (lhs_vr, VR_VARYING, 0, 0);\n+\t      set_value_range_to_varying (lhs_vr);\n \t      return SSA_PROP_VARYING;\n \t    }\n \t}"}]}