{"sha": "7a90b0ca0cbfa54ad48717911badcb1632f4b3fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E5MGIwY2EwY2JmYTU0YWQ0ODcxNzkxMWJhZGNiMTYzMmY0YjNmYQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2008-10-05T11:01:05Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-10-05T11:01:05Z"}, "message": "invoke.cc: New.\n\n2008-10-05  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* testsuite/20_util/reference_wrapper/invoke.cc: New.\n\t* testsuite/20_util/reference_wrapper/24803.cc: Likewise.\n\t* testsuite/20_util/reference_wrapper/typedefs.cc: Likewise.\n\nFrom-SVN: r140882", "tree": {"sha": "3142c4fab98b28909b8e15a6926252939d653897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3142c4fab98b28909b8e15a6926252939d653897"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa/comments", "author": null, "committer": null, "parents": [{"sha": "b82657f4a84dd4abb65bbf4179a109f1d8a36e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b82657f4a84dd4abb65bbf4179a109f1d8a36e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b82657f4a84dd4abb65bbf4179a109f1d8a36e92"}], "stats": {"total": 298, "additions": 298, "deletions": 0}, "files": [{"sha": "153e6947eb75bd07f448a244a2a1de156440242d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7a90b0ca0cbfa54ad48717911badcb1632f4b3fa", "patch": "@@ -1,3 +1,9 @@\n+2008-10-05  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* testsuite/20_util/reference_wrapper/invoke.cc: New.\n+\t* testsuite/20_util/reference_wrapper/24803.cc: Likewise.\n+\t* testsuite/20_util/reference_wrapper/typedefs.cc: Likewise.\n+\n 2008-10-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* config/locale/generic/c_locale.cc (__convert_to_v): Fix"}, {"sha": "eb3d9975a9ccee0046d4e4b1be497417ddf0ea8c", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/24803.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F24803.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F24803.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2F24803.cc?ref=7a90b0ca0cbfa54ad48717911badcb1632f4b3fa", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <functional>\n+\n+struct test_type\n+{\n+   int member();\n+   int cmember()const;\n+   int member2(char);\n+   int cmember2(char)const;\n+};\n+\n+struct functor1 : public std::unary_function<int, double>\n+{\n+  double operator()(int) const;\n+};\n+\n+struct functor2 : public std::binary_function<int, char, double>\n+{\n+   double operator()(int, char) const;\n+};\n+\n+template <class T>\n+void verify_return_type(T, T)\n+{\n+}\n+\n+void test01()\n+{\n+   test_type* null_tt = 0;\n+   const test_type* null_ttc = 0;\n+   int zero;\n+\n+   std::reference_wrapper<double (int)>* pr1;\n+   verify_return_type((*pr1)(0), double());\n+   std::reference_wrapper<double (*)(int)>* pr2;\n+   verify_return_type((*pr2)(0), double());\n+   std::reference_wrapper<int (test_type::*)()>* pr3;\n+   verify_return_type((*pr3)(null_tt), int());\n+   std::reference_wrapper<int (test_type::*)()const>* pr4;\n+   verify_return_type((*pr4)(null_ttc), int());\n+   std::reference_wrapper<functor1>* pr5;\n+\n+   // libstdc++/24803\n+   // FIXME: verify_return_type((*pr5)(0), double());\n+   verify_return_type((*pr5)(zero), double());\n+\n+   std::reference_wrapper<double (int, char)>* pr1b;\n+   verify_return_type((*pr1b)(0,0), double());\n+   std::reference_wrapper<double (*)(int, char)>* pr2b;\n+   verify_return_type((*pr2b)(0,0), double());\n+   std::reference_wrapper<int (test_type::*)(char)>* pr3b;\n+   verify_return_type((*pr3b)(null_tt,zero), int());\n+   std::reference_wrapper<int (test_type::*)()const>* pr4b;\n+   verify_return_type((*pr4b)(null_ttc), int());\n+   std::reference_wrapper<functor2>* pr5b;\n+\n+   // libstdc++/24803\n+   // FIXME: verify_return_type((*pr5b)(0,0), double());\n+   verify_return_type((*pr5b)(zero,zero), double());\n+}"}, {"sha": "77047db06c4aa3d250f0578a2258993bf1e74b5f", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/invoke.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Finvoke.cc?ref=7a90b0ca0cbfa54ad48717911badcb1632f4b3fa", "patch": "@@ -0,0 +1,115 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <functional>\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+bool test __attribute__((unused)) = true;\n+\n+struct X\n+{\n+  typedef int result_type;\n+\n+  X() : bar(17) {}\n+\n+  int foo(float x)                   { return truncate_float(x); }\n+  int foo_c(float x)  const          { return truncate_float(x); }\n+  int foo_v(float x)  volatile       { return truncate_float(x); }\n+  int foo_cv(float x) const volatile { return truncate_float(x); }\n+\n+  int operator()(float x)\n+  {\n+    return foo(x) + 1;\n+  }\n+\n+  int operator()(float x) const\n+  {\n+    return foo_c(x) + 2;\n+  }\n+\n+  int bar;\n+\n+ private:\n+  X(const X&);\n+  X& operator=(const X&);\n+};\n+\n+int seventeen() { return 17; }\n+\n+struct get_seventeen\n+{\n+  typedef int result_type;\n+  int operator()() const { return 17; }\n+};\n+\n+void test01()\n+{\n+  using std::ref;\n+  using std::cref;\n+\n+  ::get_seventeen get_sev;\n+  ::X x;\n+  ::X* xp = &x;\n+  int (::X::* p_foo)(float) = &::X::foo;\n+  int (::X::* p_foo_c)(float) const = &::X::foo_c;\n+  int (::X::* p_foo_v)(float) volatile = &::X::foo_v;\n+  int (::X::* p_foo_cv)(float) const volatile = &::X::foo_cv;\n+  int ::X::* p_bar = &::X::bar;\n+\n+  const float pi = 3.14;\n+\n+  // Functions\n+  VERIFY(ref(truncate_float)(pi) == 3);\n+  VERIFY(ref(seventeen)() == 17);\n+\n+  // Function pointers\n+  VERIFY(cref(&truncate_float)(pi) == 3);\n+  VERIFY(cref(&seventeen)() == 17);\n+\n+  // Member function pointers\n+  VERIFY(ref(p_foo)(x, pi) == 3);\n+  VERIFY(ref(p_foo)(xp, pi) == 3);\n+  VERIFY(ref(p_foo_c)(x, pi) == 3);\n+  VERIFY(ref(p_foo_c)(xp, pi) == 3);\n+  VERIFY(ref(p_foo_v)(x, pi) == 3);\n+  VERIFY(ref(p_foo_v)(xp, pi) == 3);\n+  VERIFY(ref(p_foo_cv)(x, pi) == 3);\n+  VERIFY(ref(p_foo_cv)(xp, pi) == 3);\n+\n+  // Member data pointers\n+  VERIFY(ref(p_bar)(x) == 17);\n+  VERIFY(ref(p_bar)(xp) == 17);\n+\n+  // Function objects\n+  VERIFY(ref(get_sev)() == 17);\n+  VERIFY(cref(get_sev)() == 17);\n+  VERIFY(ref(x)(pi) == 4);\n+  VERIFY(cref(x)(pi) == 5);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "36b57a89a03de5dce9d83bd48ce3ecb55e021837", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/typedefs.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a90b0ca0cbfa54ad48717911badcb1632f4b3fa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs.cc?ref=7a90b0ca0cbfa54ad48717911badcb1632f4b3fa", "patch": "@@ -0,0 +1,88 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <functional>\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test;\n+\n+struct X {};\n+\n+struct int_result_type { typedef int result_type; };\n+\n+struct derives_unary : std::unary_function<int, int> {};\n+\n+struct derives_binary : std::binary_function<int, float, int> {};\n+\n+struct derives_unary_binary\n+  : std::unary_function<int, int>,\n+    std::binary_function<int, float, int>\n+{\n+  typedef int result_type;\n+};\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using std::reference_wrapper;\n+  using std::is_same;\n+  using std::is_convertible;\n+  using std::unary_function;\n+  using std::binary_function;\n+\n+  // Check result_type typedef\n+  VERIFY((is_same<reference_wrapper<int_result_type>::result_type, int>::value));\n+  VERIFY((is_same<reference_wrapper<derives_unary>::result_type, int>::value));\n+  VERIFY((is_same<reference_wrapper<derives_binary>::result_type, int>::value));\n+  VERIFY((is_same<reference_wrapper<derives_unary_binary>::result_type, int>::value));\n+  VERIFY((is_same<reference_wrapper<int(void)>::result_type, int>::value));\n+  VERIFY((is_same<reference_wrapper<int(*)(void)>::result_type, int>::value));\n+  VERIFY((is_same<reference_wrapper<int (::X::*)()>::result_type, int>::value));\n+  VERIFY((is_same<reference_wrapper<int (::X::*)(float)>::result_type, int>::value));\n+\n+  // Check derivation from unary_function\n+  VERIFY((is_convertible<reference_wrapper<derives_unary>*, unary_function<int, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<derives_unary_binary>*, unary_function<int, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int(int)>*, unary_function<int, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int(*)(int)>*, unary_function<int, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int (::X::*)()>*, unary_function< ::X*, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int (::X::*)() const>*, unary_function<const ::X*, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int (::X::*)() volatile>*, unary_function<volatile ::X*, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int (::X::*)() const volatile>*, unary_function<const volatile ::X*, int>*>::value));\n+\n+  // Check derivation from binary_function\n+  VERIFY((is_convertible<reference_wrapper<derives_binary>*, binary_function<int, float, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<derives_unary_binary>*, binary_function<int, float, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int(int, float)>*, binary_function<int, float, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int(*)(int, float)>*, binary_function<int, float, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int (::X::*)(float)>*, binary_function< ::X*, float, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int (::X::*)(float) const>*, binary_function<const ::X*, float, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int (::X::*)(float) volatile>*, binary_function<volatile ::X*, float, int>*>::value));\n+  VERIFY((is_convertible<reference_wrapper<int (::X::*)(float) const volatile>*, binary_function<const volatile ::X*, float, int>*>::value));\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}