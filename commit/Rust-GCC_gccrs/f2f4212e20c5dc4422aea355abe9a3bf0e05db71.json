{"sha": "f2f4212e20c5dc4422aea355abe9a3bf0e05db71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJmNDIxMmUyMGM1ZGM0NDIyYWVhMzU1YWJlOWEzYmYwZTA1ZGI3MQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-07-27T13:29:02Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-08-03T19:06:49Z"}, "message": "openacc: No attach/detach present/release mappings for array descriptors\n\nStandalone attach and detach clauses should not create present/release\nmappings for Fortran array descriptors (e.g. used when we have a pointer\nto an array), both because it is unnecessary and because those mappings\nwill be incorrectly subject to reference counting. Simply omitting the\nmappings means we just use GOMP_MAP_TO_PSET and GOMP_MAP_{ATTACH,DETACH}\nmappings for array descriptors.\n\nThat requires a tweak in gimplify.c, since we may now see GOMP_MAP_TO_PSET\nwithout a preceding data-movement mapping.\n\n2020-08-03  Julian Brown  <julian@codesourcery.com>\n\t    Thomas Schwinge  <thomas@codesourcery.com>\n\ngcc/fortran/\n\t* trans-openmp.c (gfc_trans_omp_clauses): Don't create present/release\n\tmappings for array descriptors.\n\ngcc/\n\t* gimplify.c (gimplify_omp_target_update): Allow GOMP_MAP_TO_PSET\n\twithout a preceding data-movement mapping.\n\ngcc/testsuite/\n\t* gfortran.dg/goacc/attach-descriptor.f90: Update pattern output. Add\n\tscanning of gimplify dump.\n\nlibgomp/\n\t* testsuite/libgomp.oacc-fortran/attach-descriptor-1.f90: Don't run for\n\tshared-memory devices.  Extend with further checking.\n\nCo-Authored-By: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "23c95d451bd4ea81c4113b6cefc9cf2f30eeb98f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23c95d451bd4ea81c4113b6cefc9cf2f30eeb98f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2f4212e20c5dc4422aea355abe9a3bf0e05db71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2f4212e20c5dc4422aea355abe9a3bf0e05db71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2f4212e20c5dc4422aea355abe9a3bf0e05db71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2f4212e20c5dc4422aea355abe9a3bf0e05db71/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "105fe3e0b896998b4a1b5a79ad6526959c2e2e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105fe3e0b896998b4a1b5a79ad6526959c2e2e7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/105fe3e0b896998b4a1b5a79ad6526959c2e2e7a"}], "stats": {"total": 159, "additions": 128, "deletions": 31}, "files": [{"sha": "98702b1aa226750fc92f2f0c62c48d77ae0aa0de", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f4212e20c5dc4422aea355abe9a3bf0e05db71/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f4212e20c5dc4422aea355abe9a3bf0e05db71/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=f2f4212e20c5dc4422aea355abe9a3bf0e05db71", "patch": "@@ -2718,23 +2718,6 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t      OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n \t\t      node3 = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      if (n->u.map_op == OMP_MAP_ATTACH)\n-\t\t\t{\n-\t\t\t /* Standalone attach clauses used with arrays with\n-\t\t\t    descriptors must copy the descriptor to the target,\n-\t\t\t    else they won't have anything to perform the\n-\t\t\t    attachment onto (see OpenACC 2.6, \"2.6.3. Data\n-\t\t\t    Structures with Pointers\").  */\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALLOC);\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_ATTACH);\n-\t\t\t}\n-\t\t      else if (n->u.map_op == OMP_MAP_DETACH)\n-\t\t\t{\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_RELEASE);\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_DETACH);\n-\t\t\t}\n-\t\t      else\n-\t\t\tOMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_POINTER);\n \t\t      if (present)\n \t\t\t{\n \t\t\t  ptr = gfc_conv_descriptor_data_get (decl);\n@@ -2748,6 +2731,33 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\tOMP_CLAUSE_DECL (node3)\n \t\t\t  = gfc_conv_descriptor_data_get (decl);\n \t\t      OMP_CLAUSE_SIZE (node3) = size_int (0);\n+\t\t      if (n->u.map_op == OMP_MAP_ATTACH)\n+\t\t\t{\n+\t\t\t  /* Standalone attach clauses used with arrays with\n+\t\t\t     descriptors must copy the descriptor to the target,\n+\t\t\t     else they won't have anything to perform the\n+\t\t\t     attachment onto (see OpenACC 2.6, \"2.6.3. Data\n+\t\t\t     Structures with Pointers\").  */\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_ATTACH);\n+\t\t\t  /* We don't want to map PTR at all in this case, so\n+\t\t\t     delete its node and shuffle the others down.  */\n+\t\t\t  node = node2;\n+\t\t\t  node2 = node3;\n+\t\t\t  node3 = NULL;\n+\t\t\t  goto finalize_map_clause;\n+\t\t\t}\n+\t\t      else if (n->u.map_op == OMP_MAP_DETACH)\n+\t\t\t{\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_DETACH);\n+\t\t\t  /* Similarly to above, we don't want to unmap PTR\n+\t\t\t     here.  */\n+\t\t\t  node = node2;\n+\t\t\t  node2 = node3;\n+\t\t\t  node3 = NULL;\n+\t\t\t  goto finalize_map_clause;\n+\t\t\t}\n+\t\t      else\n+\t\t\tOMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_POINTER);\n \n \t\t      /* We have to check for n->sym->attr.dimension because\n \t\t\t of scalar coarrays.  */"}, {"sha": "6a5349cbfdd09a867b793a02d6eb546333320fff", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f4212e20c5dc4422aea355abe9a3bf0e05db71/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f4212e20c5dc4422aea355abe9a3bf0e05db71/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=f2f4212e20c5dc4422aea355abe9a3bf0e05db71", "patch": "@@ -13013,8 +13013,13 @@ gimplify_omp_target_update (tree *expr_p, gimple_seq *pre_p)\n \t      OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_DELETE);\n \t      have_clause = true;\n \t      break;\n-\t    case GOMP_MAP_POINTER:\n \t    case GOMP_MAP_TO_PSET:\n+\t      /* Fortran arrays with descriptors must map that descriptor when\n+\t\t doing standalone \"attach\" operations (in OpenACC).  In that\n+\t\t case GOMP_MAP_TO_PSET appears by itself with no preceding\n+\t\t clause (see trans-openmp.c:gfc_trans_omp_clauses).  */\n+\t      break;\n+\t    case GOMP_MAP_POINTER:\n \t      /* TODO PR92929: we may see these here, but they'll always follow\n \t\t one of the clauses above, and will be handled by libgomp as\n \t\t one group, so no handling required here.  */"}, {"sha": "373bdcb21145a69566e8fa5306c736a463343a33", "filename": "gcc/testsuite/gfortran.dg/goacc/attach-descriptor.f90", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f4212e20c5dc4422aea355abe9a3bf0e05db71/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fattach-descriptor.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f4212e20c5dc4422aea355abe9a3bf0e05db71/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fattach-descriptor.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fattach-descriptor.f90?ref=f2f4212e20c5dc4422aea355abe9a3bf0e05db71", "patch": "@@ -1,4 +1,4 @@\n-! { dg-additional-options \"-fdump-tree-original\" }\n+! { dg-additional-options \"-fdump-tree-original -fdump-tree-gimple\" }\n \n program att\n   implicit none\n@@ -11,8 +11,19 @@ program att\n   integer, pointer :: myptr(:)\n \n   !$acc enter data attach(myvar%arr2, myptr)\n-! { dg-final { scan-tree-dump-times \"(?n)#pragma acc enter data map\\\\(attach:myvar\\\\.arr2 \\\\\\[bias: 0\\\\\\]\\\\) map\\\\(alloc:\\\\*\\\\(c_char \\\\*\\\\) myptr\\\\.data \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:myptr \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(attach:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\*\\\\) myptr\\\\.data \\\\\\[bias: 0\\\\\\]\\\\);$\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)#pragma acc enter data map\\\\(attach:myvar\\\\.arr2 \\\\\\[bias: 0\\\\\\]\\\\) map\\\\(to:myptr \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(attach:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\*\\\\) myptr\\\\.data \\\\\\[bias: 0\\\\\\]\\\\);$\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(attach:myvar\\\\.arr2 \\\\\\[bias: 0\\\\\\]\\\\) map\\\\(to:myptr \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(attach:myptr\\\\.data \\\\\\[bias: 0\\\\\\]\\\\)$\" 1 \"gimple\" } }\n \n   !$acc exit data detach(myvar%arr2, myptr)\n-! { dg-final { scan-tree-dump-times \"(?n)#pragma acc exit data map\\\\(detach:myvar\\\\.arr2 \\\\\\[bias: 0\\\\\\]\\\\) map\\\\(release:\\\\*\\\\(c_char \\\\*\\\\) myptr\\\\.data \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:myptr \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(detach:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\*\\\\) myptr\\\\.data \\\\\\[bias: 0\\\\\\]\\\\);$\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)#pragma acc exit data map\\\\(detach:myvar\\\\.arr2 \\\\\\[bias: 0\\\\\\]\\\\) map\\\\(to:myptr \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(detach:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\*\\\\) myptr\\\\.data \\\\\\[bias: 0\\\\\\]\\\\);$\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(detach:myvar\\\\.arr2 \\\\\\[bias: 0\\\\\\]\\\\) map\\\\(to:myptr \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(detach:myptr\\\\.data \\\\\\[bias: 0\\\\\\]\\\\)$\" 1 \"gimple\" } }\n+\n+  ! Test valid usage and processing of the finalize clause.\n+  !$acc exit data detach(myvar%arr2, myptr) finalize\n+! { dg-final { scan-tree-dump-times \"(?n)#pragma acc exit data map\\\\(detach:myvar\\\\.arr2 \\\\\\[bias: 0\\\\\\]\\\\) map\\\\(to:myptr \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(detach:\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\*\\\\) myptr\\\\.data \\\\\\[bias: 0\\\\\\]\\\\) finalize;$\" 1 \"original\" } }\n+  ! For array-descriptor detaches, we no longer generate a \"release\" mapping\n+  ! for the pointed-to data for gimplify.c to turn into \"delete\".  Make sure\n+  ! the mapping still isn't there.\n+! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(force_detach:myvar\\\\.arr2 \\\\\\[bias: 0\\\\\\]\\\\) map\\\\(to:myptr \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(force_detach:myptr\\\\.data \\\\\\[bias: 0\\\\\\]\\\\) finalize$\" 1 \"gimple\" } }\n+\n end program att"}, {"sha": "960b9f94507ecd5251a5fa89fe61ce0bf5899d8d", "filename": "libgomp/testsuite/libgomp.oacc-fortran/attach-descriptor-1.f90", "status": "modified", "additions": 81, "deletions": 10, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2f4212e20c5dc4422aea355abe9a3bf0e05db71/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fattach-descriptor-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2f4212e20c5dc4422aea355abe9a3bf0e05db71/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fattach-descriptor-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fattach-descriptor-1.f90?ref=f2f4212e20c5dc4422aea355abe9a3bf0e05db71", "patch": "@@ -1,8 +1,10 @@\n ! { dg-do run }\n+! { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } }\n \n-program att\n+subroutine test(variant)\n   use openacc\n   implicit none\n+  integer :: variant\n   type t\n     integer :: arr1(10)\n     integer, allocatable :: arr2(:)\n@@ -26,28 +28,97 @@ program att\n \n   myptr => tarr\n \n-  !$acc enter data attach(myvar%arr2, myptr)\n+  if (variant == 0 &\n+       .or. variant == 3 &\n+       .or. variant == 5) then\n+     !$acc enter data attach(myvar%arr2, myptr)\n+  else if (variant == 1 &\n+       .or. variant == 2 &\n+       .or. variant == 4) then\n+     !$acc enter data attach(myvar%arr2, myptr)\n+     !$acc enter data attach(myvar%arr2, myptr)\n+  else\n+     ! Internal error.\n+     stop 1\n+  end if\n \n   ! FIXME: This warning is emitted on the wrong line number.\n-  ! { dg-warning \"using vector_length \\\\(32\\\\), ignoring 1\" \"\" { target openacc_nvidia_accel_selected } 38 }\n+  ! { dg-warning \"using vector_length \\\\(32\\\\), ignoring 1\" \"\" { target openacc_nvidia_accel_selected } 52 }\n   !$acc serial present(myvar%arr2)\n   do i=1,10\n-    myvar%arr1(i) = i\n-    myvar%arr2(i) = i\n+    myvar%arr1(i) = i + variant\n+    myvar%arr2(i) = i - variant\n   end do\n-  myptr(3) = 99\n+  myptr(3) = 99 - variant\n   !$acc end serial\n \n-  !$acc exit data detach(myvar%arr2, myptr)\n+  if (variant == 0) then\n+     !$acc exit data detach(myvar%arr2, myptr)\n+  else if (variant == 1) then\n+     !$acc exit data detach(myvar%arr2, myptr)\n+     !$acc exit data detach(myvar%arr2, myptr)\n+  else if (variant == 2) then\n+     !$acc exit data detach(myvar%arr2, myptr)\n+     !$acc exit data detach(myvar%arr2, myptr) finalize\n+  else if (variant == 3 &\n+       .or. variant == 4) then\n+     !$acc exit data detach(myvar%arr2, myptr) finalize\n+  else if (variant == 5) then\n+     ! Do not detach.\n+  else\n+     ! Internal error.\n+     stop 2\n+  end if\n+\n+  if (.not. acc_is_present(myvar%arr2)) stop 10\n+  if (.not. acc_is_present(myvar)) stop 11\n+  if (.not. acc_is_present(tarr)) stop 12\n \n   call acc_copyout(myvar%arr2)\n+  if (acc_is_present(myvar%arr2)) stop 20\n+  if (.not. acc_is_present(myvar)) stop 21\n+  if (.not. acc_is_present(tarr)) stop 22\n   call acc_copyout(myvar)\n+  if (acc_is_present(myvar%arr2)) stop 30\n+  if (acc_is_present(myvar)) stop 31\n+  if (.not. acc_is_present(tarr)) stop 32\n   call acc_copyout(tarr)\n+  if (acc_is_present(myvar%arr2)) stop 40\n+  if (acc_is_present(myvar)) stop 41\n+  if (acc_is_present(tarr)) stop 42\n \n   do i=1,10\n-    if (myvar%arr1(i) .ne. i) stop 1\n-    if (myvar%arr2(i) .ne. i) stop 2\n+     if (myvar%arr1(i) .ne. i + variant) stop 50\n+     if (variant == 5) then\n+        ! We have not detached, so have copyied out a device pointer, so cannot\n+        ! access 'myvar%arr2' on the host.\n+     else\n+        if (myvar%arr2(i) .ne. i - variant) stop 51\n+     end if\n   end do\n-  if (tarr(3) .ne. 99) stop 3\n+  if (tarr(3) .ne. 99 - variant) stop 52\n+\n+  if (variant == 5) then\n+     ! If not explicitly stopping here, we'd in the following try to deallocate\n+     ! the device pointer on the host, SIGSEGV.\n+     stop\n+  end if\n+end subroutine test\n+\n+program att\n+  implicit none\n+\n+  call test(0)\n+\n+  call test(1)\n+\n+  call test(2)\n+\n+  call test(3)\n+\n+  call test(4)\n \n+  call test(5)\n+  ! Make sure that 'test(5)' has stopped the program.\n+  stop 60\n end program att"}]}