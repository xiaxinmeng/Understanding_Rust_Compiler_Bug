{"sha": "a3d514f231af029090ba40ebcdae4226b739433c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNkNTE0ZjIzMWFmMDI5MDkwYmE0MGViY2RhZTQyMjZiNzM5NDMzYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-03-16T03:19:35Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-03-16T03:19:35Z"}, "message": "re PR tree-optimization/71437 (Performance regression after r235817)\n\n\tPR tree-optimization/71437\n\t* tree-ssa-dom.c (struct cond_equivalence): Moved from here into\n\ttree-ssa-scopedtables.\n\t(lookup_avail_expr, build_and_record_new_cond): Likewise.\n\t(record_conditions, record_cond, vuse_eq): Likewise.\n\t(record_edge_info): Adjust to API tweak of record_conditions.\n\t(simplify_stmt_for_jump_threading): Similarly for lookup_avail_expr.\n\t(record_temporary_equivalences, optimize_stmt): Likewise.\n\t(eliminate_redundant_computations): Likewise.\n\t(record_equivalences_from_stmt): Likewise.\n\t* tree-ssa-scopedtables.c: Include options.h and params.h.\n\t(vuse_eq): New function, moved from tree-ssa-dom.c\n\t(build_and_record_new_cond): Likewise.\n\t(record_conditions): Likewise.  Accept vector of conditions rather\n\tthan edge_equivalence structure for first argument.\n\tfor the first argument.\n\t(avail_exprs_stack::lookup_avail_expr): New member function, moved\n\tfrom tree-ssa-dom.c.\n\t(avail_exprs_stack::record_cond): Likewise.\n\t* tree-ssa-scopedtables.h (struct cond_equivalence): Moved here\n\tfrom tree-ssa-dom.c.\n\t(avail_exprs_stack): Add new member functions lookup_avail_expr\n\tand record_cond.\n\t(record_conditions): Declare.\n\nFrom-SVN: r246186", "tree": {"sha": "d8b855bb9e915146c36b899deea5e22a52c0e3b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8b855bb9e915146c36b899deea5e22a52c0e3b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3d514f231af029090ba40ebcdae4226b739433c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d514f231af029090ba40ebcdae4226b739433c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3d514f231af029090ba40ebcdae4226b739433c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d514f231af029090ba40ebcdae4226b739433c/comments", "author": null, "committer": null, "parents": [{"sha": "47ee2e074177123e4553654a9c898d46437063c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ee2e074177123e4553654a9c898d46437063c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ee2e074177123e4553654a9c898d46437063c9"}], "stats": {"total": 638, "additions": 329, "deletions": 309}, "files": [{"sha": "23a611236b940667bb99d76d83f43f43db74a557", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d514f231af029090ba40ebcdae4226b739433c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d514f231af029090ba40ebcdae4226b739433c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3d514f231af029090ba40ebcdae4226b739433c", "patch": "@@ -1,3 +1,30 @@\n+2017-03-15  Jeff Law  <law@redhat.com>\n+\t\n+\tPR tree-optimization/71437\n+\t* tree-ssa-dom.c (struct cond_equivalence): Moved from here into\n+\ttree-ssa-scopedtables.\n+\t(lookup_avail_expr, build_and_record_new_cond): Likewise.\n+\t(record_conditions, record_cond, vuse_eq): Likewise.\n+\t(record_edge_info): Adjust to API tweak of record_conditions.\n+\t(simplify_stmt_for_jump_threading): Similarly for lookup_avail_expr.\n+\t(record_temporary_equivalences, optimize_stmt): Likewise.\n+\t(eliminate_redundant_computations): Likewise.\n+\t(record_equivalences_from_stmt): Likewise.\n+\t* tree-ssa-scopedtables.c: Include options.h and params.h.\n+\t(vuse_eq): New function, moved from tree-ssa-dom.c\n+\t(build_and_record_new_cond): Likewise.\n+\t(record_conditions): Likewise.  Accept vector of conditions rather\n+\tthan edge_equivalence structure for first argument.\n+\tfor the first argument.\n+\t(avail_exprs_stack::lookup_avail_expr): New member function, moved\n+\tfrom tree-ssa-dom.c.\n+\t(avail_exprs_stack::record_cond): Likewise.\n+\t* tree-ssa-scopedtables.h (struct cond_equivalence): Moved here\n+\tfrom tree-ssa-dom.c.\n+\t(avail_exprs_stack): Add new member functions lookup_avail_expr\n+\tand record_cond.\n+\t(record_conditions): Declare.\n+\n 2017-03-15  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/80017"}, {"sha": "ad71269ce3d624089e65b3ffcc384e478cd14350", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 10, "deletions": 309, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d514f231af029090ba40ebcdae4226b739433c/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d514f231af029090ba40ebcdae4226b739433c/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=a3d514f231af029090ba40ebcdae4226b739433c", "patch": "@@ -48,15 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n \n /* This file implements optimizations on the dominator tree.  */\n \n-/* Structure for recording known values of a conditional expression\n-   at the exits from its block.  */\n-\n-struct cond_equivalence\n-{\n-  struct hashable_expr cond;\n-  tree value;\n-};\n-\n /* Structure for recording edge equivalences.\n \n    Computing and storing the edge equivalences instead of creating\n@@ -103,9 +94,6 @@ static struct opt_stats_d opt_stats;\n static edge optimize_stmt (basic_block, gimple_stmt_iterator,\n \t\t\t   class const_and_copies *,\n \t\t\t   class avail_exprs_stack *);\n-static tree lookup_avail_expr (gimple *, bool, class avail_exprs_stack *,\n-\t\t\t       bool = true);\n-static void record_cond (cond_equivalence *, class avail_exprs_stack *);\n static void record_equality (tree, tree, class const_and_copies *);\n static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block,\n@@ -175,148 +163,6 @@ free_all_edge_infos (void)\n     }\n }\n \n-/* Build a cond_equivalence record indicating that the comparison\n-   CODE holds between operands OP0 and OP1 and push it to **P.  */\n-\n-static void\n-build_and_record_new_cond (enum tree_code code,\n-                           tree op0, tree op1,\n-                           vec<cond_equivalence> *p,\n-\t\t\t   bool val = true)\n-{\n-  cond_equivalence c;\n-  struct hashable_expr *cond = &c.cond;\n-\n-  gcc_assert (TREE_CODE_CLASS (code) == tcc_comparison);\n-\n-  cond->type = boolean_type_node;\n-  cond->kind = EXPR_BINARY;\n-  cond->ops.binary.op = code;\n-  cond->ops.binary.opnd0 = op0;\n-  cond->ops.binary.opnd1 = op1;\n-\n-  c.value = val ? boolean_true_node : boolean_false_node;\n-  p->safe_push (c);\n-}\n-\n-/* Record that COND is true and INVERTED is false into the edge information\n-   structure.  Also record that any conditions dominated by COND are true\n-   as well.\n-\n-   For example, if a < b is true, then a <= b must also be true.  */\n-\n-static void\n-record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n-{\n-  tree op0, op1;\n-  cond_equivalence c;\n-\n-  if (!COMPARISON_CLASS_P (cond))\n-    return;\n-\n-  op0 = TREE_OPERAND (cond, 0);\n-  op1 = TREE_OPERAND (cond, 1);\n-\n-  switch (TREE_CODE (cond))\n-    {\n-    case LT_EXPR:\n-    case GT_EXPR:\n-      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n-\t{\n-\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences);\n-\t  build_and_record_new_cond (LTGT_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences);\n-\t}\n-\n-      build_and_record_new_cond ((TREE_CODE (cond) == LT_EXPR\n-\t\t\t\t  ? LE_EXPR : GE_EXPR),\n-\t\t\t\t op0, op1, &edge_info->cond_equivalences);\n-      build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (EQ_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences, false);\n-      break;\n-\n-    case GE_EXPR:\n-    case LE_EXPR:\n-      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n-\t{\n-\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences);\n-\t}\n-      break;\n-\n-    case EQ_EXPR:\n-      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n-\t{\n-\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences);\n-\t}\n-      build_and_record_new_cond (LE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (GE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n-\n-    case UNORDERED_EXPR:\n-      build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNLE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNGE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNEQ_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNLT_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNGT_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n-\n-    case UNLT_EXPR:\n-    case UNGT_EXPR:\n-      build_and_record_new_cond ((TREE_CODE (cond) == UNLT_EXPR\n-\t\t\t\t  ? UNLE_EXPR : UNGE_EXPR),\n-\t\t\t\t op0, op1, &edge_info->cond_equivalences);\n-      build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n-\n-    case UNEQ_EXPR:\n-      build_and_record_new_cond (UNLE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNGE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n-\n-    case LTGT_EXPR:\n-      build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Now store the original true and false conditions into the first\n-     two slots.  */\n-  initialize_expr_from_cond (cond, &c.cond);\n-  c.value = boolean_true_node;\n-  edge_info->cond_equivalences.safe_push (c);\n-\n-  /* It is possible for INVERTED to be the negation of a comparison,\n-     and not a valid RHS or GIMPLE_COND condition.  This happens because\n-     invert_truthvalue may return such an expression when asked to invert\n-     a floating-point comparison.  These comparisons are not assumed to\n-     obey the trichotomy law.  */\n-  initialize_expr_from_cond (inverted, &c.cond);\n-  c.value = boolean_false_node;\n-  edge_info->cond_equivalences.safe_push (c);\n-}\n-\n /* We have finished optimizing BB, record any information implied by\n    taking a specific outgoing edge from BB.  */\n \n@@ -435,7 +281,7 @@ record_edge_info (basic_block bb)\n               struct edge_info *edge_info;\n \n               edge_info = allocate_edge_info (true_edge);\n-              record_conditions (edge_info, cond, inverted);\n+              record_conditions (&edge_info->cond_equivalences, cond, inverted);\n \n               if (can_infer_simple_equiv && code == EQ_EXPR)\n                 {\n@@ -444,7 +290,7 @@ record_edge_info (basic_block bb)\n                 }\n \n               edge_info = allocate_edge_info (false_edge);\n-              record_conditions (edge_info, inverted, cond);\n+              record_conditions (&edge_info->cond_equivalences, inverted, cond);\n \n               if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n                 {\n@@ -465,7 +311,7 @@ record_edge_info (basic_block bb)\n               struct edge_info *edge_info;\n \n               edge_info = allocate_edge_info (true_edge);\n-              record_conditions (edge_info, cond, inverted);\n+              record_conditions (&edge_info->cond_equivalences, cond, inverted);\n \n               if (can_infer_simple_equiv && code == EQ_EXPR)\n                 {\n@@ -474,7 +320,7 @@ record_edge_info (basic_block bb)\n                 }\n \n               edge_info = allocate_edge_info (false_edge);\n-              record_conditions (edge_info, inverted, cond);\n+              record_conditions (&edge_info->cond_equivalences, inverted, cond);\n \n               if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n                 {\n@@ -760,7 +606,7 @@ simplify_stmt_for_jump_threading (gimple *stmt,\n \t\t\t\t  gimple *within_stmt ATTRIBUTE_UNUSED,\n \t\t\t\t  class avail_exprs_stack *avail_exprs_stack)\n {\n-  return lookup_avail_expr (stmt, false, avail_exprs_stack);\n+  return avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n }\n \n /* Valueize hook for gimple_fold_stmt_to_constant_1.  */\n@@ -865,7 +711,7 @@ record_temporary_equivalences (edge e,\n       /* If we have 0 = COND or 1 = COND equivalences, record them\n \t into our expression hash tables.  */\n       for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n-\trecord_cond (eq, avail_exprs_stack);\n+\tavail_exprs_stack->record_cond (eq);\n \n       tree lhs = edge_info->lhs;\n       if (!lhs || TREE_CODE (lhs) != SSA_NAME)\n@@ -1105,29 +951,6 @@ dump_dominator_optimization_stats (FILE *file,\n }\n \n \n-/* Enter condition equivalence P into AVAIL_EXPRS_HASH.\n-\n-   This indicates that a conditional expression has a known\n-   boolean value.  */\n-\n-static void\n-record_cond (cond_equivalence *p,\n-\t     class avail_exprs_stack *avail_exprs_stack)\n-{\n-  class expr_hash_elt *element = new expr_hash_elt (&p->cond, p->value);\n-  expr_hash_elt **slot;\n-\n-  hash_table<expr_elt_hasher> *avail_exprs = avail_exprs_stack->avail_exprs ();\n-  slot = avail_exprs->find_slot_with_hash (element, element->hash (), INSERT);\n-  if (*slot == NULL)\n-    {\n-      *slot = element;\n-      avail_exprs_stack->record_expr (element, NULL, '1');\n-    }\n-  else\n-    delete element;\n-}\n-\n /* Similarly, but assume that X and Y are the two operands of an EQ_EXPR.\n    This constrains the cases in which we may treat this as assignment.  */\n \n@@ -1426,7 +1249,7 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi,\n     insert = false;\n \n   /* Check if the expression has been computed before.  */\n-  cached_lhs = lookup_avail_expr (stmt, insert, avail_exprs_stack);\n+  cached_lhs = avail_exprs_stack->lookup_avail_expr (stmt, insert, true);\n \n   opt_stats.num_exprs_considered++;\n \n@@ -1611,7 +1434,7 @@ record_equivalences_from_stmt (gimple *stmt, int may_optimize_p,\n \n       /* Finally enter the statement into the available expression\n \t table.  */\n-      lookup_avail_expr (new_stmt, true, avail_exprs_stack);\n+      avail_exprs_stack->lookup_avail_expr (new_stmt, true, true);\n     }\n }\n \n@@ -1865,8 +1688,8 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t  else\n \t    new_stmt = gimple_build_assign (rhs, lhs);\n \t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n-\t  cached_lhs = lookup_avail_expr (new_stmt, false, avail_exprs_stack,\n-\t\t\t\t\t  false);\n+\t  cached_lhs = avail_exprs_stack->lookup_avail_expr (new_stmt, false,\n+\t\t\t\t\t\t\t     false);\n \t  if (cached_lhs\n \t      && rhs == cached_lhs)\n \t    {\n@@ -1942,125 +1765,3 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n     }\n   return retval;\n }\n-\n-/* Helper for walk_non_aliased_vuses.  Determine if we arrived at\n-   the desired memory state.  */\n-\n-static void *\n-vuse_eq (ao_ref *, tree vuse1, unsigned int cnt, void *data)\n-{\n-  tree vuse2 = (tree) data;\n-  if (vuse1 == vuse2)\n-    return data;\n-\n-  /* This bounds the stmt walks we perform on reference lookups\n-     to O(1) instead of O(N) where N is the number of dominating\n-     stores leading to a candidate.  We re-use the SCCVN param\n-     for this as it is basically the same complexity.  */\n-  if (cnt > (unsigned) PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS))\n-    return (void *)-1;\n-\n-  return NULL;\n-}\n-\n-/* Search for an existing instance of STMT in the AVAIL_EXPRS_STACK table.\n-   If found, return its LHS. Otherwise insert STMT in the table and\n-   return NULL_TREE.\n-\n-   Also, when an expression is first inserted in the  table, it is also\n-   is also added to AVAIL_EXPRS_STACK, so that it can be removed when\n-   we finish processing this block and its children.  */\n-\n-static tree\n-lookup_avail_expr (gimple *stmt, bool insert,\n-\t\t   class avail_exprs_stack *avail_exprs_stack, bool tbaa_p)\n-{\n-  expr_hash_elt **slot;\n-  tree lhs;\n-\n-  /* Get LHS of phi, assignment, or call; else NULL_TREE.  */\n-  if (gimple_code (stmt) == GIMPLE_PHI)\n-    lhs = gimple_phi_result (stmt);\n-  else\n-    lhs = gimple_get_lhs (stmt);\n-\n-  class expr_hash_elt element (stmt, lhs);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"LKUP \");\n-      element.print (dump_file);\n-    }\n-\n-  /* Don't bother remembering constant assignments and copy operations.\n-     Constants and copy operations are handled by the constant/copy propagator\n-     in optimize_stmt.  */\n-  if (element.expr()->kind == EXPR_SINGLE\n-      && (TREE_CODE (element.expr()->ops.single.rhs) == SSA_NAME\n-          || is_gimple_min_invariant (element.expr()->ops.single.rhs)))\n-    return NULL_TREE;\n-\n-  /* Finally try to find the expression in the main expression hash table.  */\n-  hash_table<expr_elt_hasher> *avail_exprs = avail_exprs_stack->avail_exprs ();\n-  slot = avail_exprs->find_slot (&element, (insert ? INSERT : NO_INSERT));\n-  if (slot == NULL)\n-    {\n-      return NULL_TREE;\n-    }\n-  else if (*slot == NULL)\n-    {\n-      class expr_hash_elt *element2 = new expr_hash_elt (element);\n-      *slot = element2;\n-\n-      avail_exprs_stack->record_expr (element2, NULL, '2');\n-      return NULL_TREE;\n-    }\n-\n-  /* If we found a redundant memory operation do an alias walk to\n-     check if we can re-use it.  */\n-  if (gimple_vuse (stmt) != (*slot)->vop ())\n-    {\n-      tree vuse1 = (*slot)->vop ();\n-      tree vuse2 = gimple_vuse (stmt);\n-      /* If we have a load of a register and a candidate in the\n-\t hash with vuse1 then try to reach its stmt by walking\n-\t up the virtual use-def chain using walk_non_aliased_vuses.\n-\t But don't do this when removing expressions from the hash.  */\n-      ao_ref ref;\n-      if (!(vuse1 && vuse2\n-\t    && gimple_assign_single_p (stmt)\n-\t    && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n-\t    && (ao_ref_init (&ref, gimple_assign_rhs1 (stmt)),\n-\t\tref.base_alias_set = ref.ref_alias_set = tbaa_p ? -1 : 0, true)\n-\t    && walk_non_aliased_vuses (&ref, vuse2,\n-\t\t\t\t       vuse_eq, NULL, NULL, vuse1) != NULL))\n-\t{\n-\t  if (insert)\n-\t    {\n-\t      class expr_hash_elt *element2 = new expr_hash_elt (element);\n-\n-\t      /* Insert the expr into the hash by replacing the current\n-\t\t entry and recording the value to restore in the\n-\t\t avail_exprs_stack.  */\n-\t      avail_exprs_stack->record_expr (element2, *slot, '2');\n-\t      *slot = element2;\n-\t    }\n-\t  return NULL_TREE;\n-\t}\n-    }\n-\n-  /* Extract the LHS of the assignment so that it can be used as the current\n-     definition of another variable.  */\n-  lhs = (*slot)->lhs ();\n-\n-  lhs = dom_valueize (lhs);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"FIND: \");\n-      print_generic_expr (dump_file, lhs, 0);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  return lhs;\n-}"}, {"sha": "3e7233376cbf1b91d62663ff6389fbf3f48676f2", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d514f231af029090ba40ebcdae4226b739433c/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d514f231af029090ba40ebcdae4226b739433c/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=a3d514f231af029090ba40ebcdae4226b739433c", "patch": "@@ -33,6 +33,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-eh.h\"\n #include \"internal-fn.h\"\n #include \"tree-dfa.h\"\n+#include \"options.h\"\n+#include \"params.h\"\n \n static bool hashable_expr_equal_p (const struct hashable_expr *,\n \t\t\t\t   const struct hashable_expr *);\n@@ -94,6 +96,153 @@ avail_exprs_stack::record_expr (class expr_hash_elt *elt1,\n   m_stack.safe_push (std::pair<expr_hash_elt_t, expr_hash_elt_t> (elt1, elt2));\n }\n \n+/* Helper for walk_non_aliased_vuses.  Determine if we arrived at\n+   the desired memory state.  */\n+\n+static void *\n+vuse_eq (ao_ref *, tree vuse1, unsigned int cnt, void *data)\n+{\n+  tree vuse2 = (tree) data;\n+  if (vuse1 == vuse2)\n+    return data;\n+\n+  /* This bounds the stmt walks we perform on reference lookups\n+     to O(1) instead of O(N) where N is the number of dominating\n+     stores leading to a candidate.  We re-use the SCCVN param\n+     for this as it is basically the same complexity.  */\n+  if (cnt > (unsigned) PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS))\n+    return (void *)-1;\n+\n+  return NULL;\n+}\n+\n+/* Search for an existing instance of STMT in the AVAIL_EXPRS_STACK table.\n+   If found, return its LHS. Otherwise insert STMT in the table and\n+   return NULL_TREE.\n+\n+   Also, when an expression is first inserted in the  table, it is also\n+   is also added to AVAIL_EXPRS_STACK, so that it can be removed when\n+   we finish processing this block and its children.  */\n+\n+tree\n+avail_exprs_stack::lookup_avail_expr (gimple *stmt, bool insert, bool tbaa_p)\n+{\n+  expr_hash_elt **slot;\n+  tree lhs;\n+\n+  /* Get LHS of phi, assignment, or call; else NULL_TREE.  */\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    lhs = gimple_phi_result (stmt);\n+  else\n+    lhs = gimple_get_lhs (stmt);\n+\n+  class expr_hash_elt element (stmt, lhs);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"LKUP \");\n+      element.print (dump_file);\n+    }\n+\n+  /* Don't bother remembering constant assignments and copy operations.\n+     Constants and copy operations are handled by the constant/copy propagator\n+     in optimize_stmt.  */\n+  if (element.expr()->kind == EXPR_SINGLE\n+      && (TREE_CODE (element.expr()->ops.single.rhs) == SSA_NAME\n+          || is_gimple_min_invariant (element.expr()->ops.single.rhs)))\n+    return NULL_TREE;\n+\n+  /* Finally try to find the expression in the main expression hash table.  */\n+  slot = m_avail_exprs->find_slot (&element, (insert ? INSERT : NO_INSERT));\n+  if (slot == NULL)\n+    {\n+      return NULL_TREE;\n+    }\n+  else if (*slot == NULL)\n+    {\n+      class expr_hash_elt *element2 = new expr_hash_elt (element);\n+      *slot = element2;\n+\n+      record_expr (element2, NULL, '2');\n+      return NULL_TREE;\n+    }\n+\n+  /* If we found a redundant memory operation do an alias walk to\n+     check if we can re-use it.  */\n+  if (gimple_vuse (stmt) != (*slot)->vop ())\n+    {\n+      tree vuse1 = (*slot)->vop ();\n+      tree vuse2 = gimple_vuse (stmt);\n+      /* If we have a load of a register and a candidate in the\n+\t hash with vuse1 then try to reach its stmt by walking\n+\t up the virtual use-def chain using walk_non_aliased_vuses.\n+\t But don't do this when removing expressions from the hash.  */\n+      ao_ref ref;\n+      if (!(vuse1 && vuse2\n+\t    && gimple_assign_single_p (stmt)\n+\t    && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n+\t    && (ao_ref_init (&ref, gimple_assign_rhs1 (stmt)),\n+\t\tref.base_alias_set = ref.ref_alias_set = tbaa_p ? -1 : 0, true)\n+\t    && walk_non_aliased_vuses (&ref, vuse2,\n+\t\t\t\t       vuse_eq, NULL, NULL, vuse1) != NULL))\n+\t{\n+\t  if (insert)\n+\t    {\n+\t      class expr_hash_elt *element2 = new expr_hash_elt (element);\n+\n+\t      /* Insert the expr into the hash by replacing the current\n+\t\t entry and recording the value to restore in the\n+\t\t avail_exprs_stack.  */\n+\t      record_expr (element2, *slot, '2');\n+\t      *slot = element2;\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  /* Extract the LHS of the assignment so that it can be used as the current\n+     definition of another variable.  */\n+  lhs = (*slot)->lhs ();\n+\n+  /* Valueize the result.  */\n+  if (TREE_CODE (lhs) == SSA_NAME)\n+    {\n+      tree tem = SSA_NAME_VALUE (lhs);\n+      if (tem)\n+\tlhs = tem;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"FIND: \");\n+      print_generic_expr (dump_file, lhs, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  return lhs;\n+}\n+\n+/* Enter condition equivalence P into the hash table.\n+\n+   This indicates that a conditional expression has a known\n+   boolean value.  */\n+\n+void\n+avail_exprs_stack::record_cond (cond_equivalence *p)\n+{\n+  class expr_hash_elt *element = new expr_hash_elt (&p->cond, p->value);\n+  expr_hash_elt **slot;\n+\n+  slot = m_avail_exprs->find_slot_with_hash (element, element->hash (), INSERT);\n+  if (*slot == NULL)\n+    {\n+      *slot = element;\n+      record_expr (element, NULL, '1');\n+    }\n+  else\n+    delete element;\n+}\n+\n /* Generate a hash value for a pair of expressions.  This can be used\n    iteratively by passing a previous result in HSTATE.\n \n@@ -798,3 +947,125 @@ initialize_expr_from_cond (tree cond, struct hashable_expr *expr)\n     gcc_unreachable ();\n }\n \n+/* Build a cond_equivalence record indicating that the comparison\n+   CODE holds between operands OP0 and OP1 and push it to **P.  */\n+\n+static void\n+build_and_record_new_cond (enum tree_code code,\n+                           tree op0, tree op1,\n+                           vec<cond_equivalence> *p,\n+\t\t\t   bool val = true)\n+{\n+  cond_equivalence c;\n+  struct hashable_expr *cond = &c.cond;\n+\n+  gcc_assert (TREE_CODE_CLASS (code) == tcc_comparison);\n+\n+  cond->type = boolean_type_node;\n+  cond->kind = EXPR_BINARY;\n+  cond->ops.binary.op = code;\n+  cond->ops.binary.opnd0 = op0;\n+  cond->ops.binary.opnd1 = op1;\n+\n+  c.value = val ? boolean_true_node : boolean_false_node;\n+  p->safe_push (c);\n+}\n+\n+/* Record that COND is true and INVERTED is false into the edge information\n+   structure.  Also record that any conditions dominated by COND are true\n+   as well.\n+\n+   For example, if a < b is true, then a <= b must also be true.  */\n+\n+void\n+record_conditions (vec<cond_equivalence> *p, tree cond, tree inverted)\n+{\n+  tree op0, op1;\n+  cond_equivalence c;\n+\n+  if (!COMPARISON_CLASS_P (cond))\n+    return;\n+\n+  op0 = TREE_OPERAND (cond, 0);\n+  op1 = TREE_OPERAND (cond, 1);\n+\n+  switch (TREE_CODE (cond))\n+    {\n+    case LT_EXPR:\n+    case GT_EXPR:\n+      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n+\t{\n+\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1, p);\n+\t  build_and_record_new_cond (LTGT_EXPR, op0, op1, p);\n+\t}\n+\n+      build_and_record_new_cond ((TREE_CODE (cond) == LT_EXPR\n+\t\t\t\t  ? LE_EXPR : GE_EXPR),\n+\t\t\t\t op0, op1, p);\n+      build_and_record_new_cond (NE_EXPR, op0, op1, p);\n+      build_and_record_new_cond (EQ_EXPR, op0, op1, p, false);\n+      break;\n+\n+    case GE_EXPR:\n+    case LE_EXPR:\n+      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n+\t{\n+\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1, p);\n+\t}\n+      break;\n+\n+    case EQ_EXPR:\n+      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n+\t{\n+\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1, p);\n+\t}\n+      build_and_record_new_cond (LE_EXPR, op0, op1, p);\n+      build_and_record_new_cond (GE_EXPR, op0, op1, p);\n+      break;\n+\n+    case UNORDERED_EXPR:\n+      build_and_record_new_cond (NE_EXPR, op0, op1, p);\n+      build_and_record_new_cond (UNLE_EXPR, op0, op1, p);\n+      build_and_record_new_cond (UNGE_EXPR, op0, op1, p);\n+      build_and_record_new_cond (UNEQ_EXPR, op0, op1, p);\n+      build_and_record_new_cond (UNLT_EXPR, op0, op1, p);\n+      build_and_record_new_cond (UNGT_EXPR, op0, op1, p);\n+      break;\n+\n+    case UNLT_EXPR:\n+    case UNGT_EXPR:\n+      build_and_record_new_cond ((TREE_CODE (cond) == UNLT_EXPR\n+\t\t\t\t  ? UNLE_EXPR : UNGE_EXPR),\n+\t\t\t\t op0, op1, p);\n+      build_and_record_new_cond (NE_EXPR, op0, op1, p);\n+      break;\n+\n+    case UNEQ_EXPR:\n+      build_and_record_new_cond (UNLE_EXPR, op0, op1, p);\n+      build_and_record_new_cond (UNGE_EXPR, op0, op1, p);\n+      break;\n+\n+    case LTGT_EXPR:\n+      build_and_record_new_cond (NE_EXPR, op0, op1, p);\n+      build_and_record_new_cond (ORDERED_EXPR, op0, op1, p);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Now store the original true and false conditions into the first\n+     two slots.  */\n+  initialize_expr_from_cond (cond, &c.cond);\n+  c.value = boolean_true_node;\n+  p->safe_push (c);\n+\n+  /* It is possible for INVERTED to be the negation of a comparison,\n+     and not a valid RHS or GIMPLE_COND condition.  This happens because\n+     invert_truthvalue may return such an expression when asked to invert\n+     a floating-point comparison.  These comparisons are not assumed to\n+     obey the trichotomy law.  */\n+  initialize_expr_from_cond (inverted, &c.cond);\n+  c.value = boolean_false_node;\n+  p->safe_push (c);\n+}"}, {"sha": "df304aedbf4f05a7523e4cbaae7777a2ab51172f", "filename": "gcc/tree-ssa-scopedtables.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d514f231af029090ba40ebcdae4226b739433c/gcc%2Ftree-ssa-scopedtables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d514f231af029090ba40ebcdae4226b739433c/gcc%2Ftree-ssa-scopedtables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.h?ref=a3d514f231af029090ba40ebcdae4226b739433c", "patch": "@@ -47,6 +47,20 @@ struct hashable_expr\n   } ops;\n };\n \n+/* Structure for recording known value of a conditional expression.\n+\n+   Clients build vectors of these objects to record known values\n+   that occur on edges.  */\n+\n+struct cond_equivalence\n+{\n+  /* The condition, in a HASHABLE_EXPR form.  */\n+  struct hashable_expr cond;\n+\n+  /* The result of the condition (true or false.  */\n+  tree value;\n+};\n+\n /* Structure for entries in the expression hash table.  */\n \n typedef class expr_hash_elt * expr_hash_elt_t;\n@@ -132,6 +146,12 @@ class avail_exprs_stack\n   hash_table<expr_elt_hasher> *avail_exprs (void)\n     { return m_avail_exprs; }\n \n+  /* Lookup and conditionally insert an expression into the table,\n+     recording enough information to unwind as needed.  */\n+  tree lookup_avail_expr (gimple *, bool, bool);\n+\n+  void record_cond (cond_equivalence *);\n+\n  private:\n   vec<std::pair<expr_hash_elt_t, expr_hash_elt_t> > m_stack;\n   hash_table<expr_elt_hasher> *m_avail_exprs;\n@@ -182,5 +202,6 @@ class const_and_copies\n };\n \n void initialize_expr_from_cond (tree cond, struct hashable_expr *expr);\n+void record_conditions (vec<cond_equivalence> *p, tree, tree);\n \n #endif /* GCC_TREE_SSA_SCOPED_TABLES_H */"}]}