{"sha": "1ada4c55ae87436c4b93e204cb157ae7e1074257", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFkYTRjNTVhZTg3NDM2YzRiOTNlMjA0Y2IxNTdhZTdlMTA3NDI1Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-29T16:34:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-29T16:34:27Z"}, "message": "Initial revision\n\nFrom-SVN: r19495", "tree": {"sha": "1216797e1b4a51980b8b8beb2631be9c2d05deb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1216797e1b4a51980b8b8beb2631be9c2d05deb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ada4c55ae87436c4b93e204cb157ae7e1074257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ada4c55ae87436c4b93e204cb157ae7e1074257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ada4c55ae87436c4b93e204cb157ae7e1074257", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ada4c55ae87436c4b93e204cb157ae7e1074257/comments", "author": null, "committer": null, "parents": [{"sha": "93da030f633623de87801b2aea0b8cfe79edebc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93da030f633623de87801b2aea0b8cfe79edebc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93da030f633623de87801b2aea0b8cfe79edebc2"}], "stats": {"total": 203, "additions": 203, "deletions": 0}, "files": [{"sha": "d9c3f349e04dee8aad8a06ecc76cacc4ccc187ba", "filename": "gcc/intl/bindtextdom.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ada4c55ae87436c4b93e204cb157ae7e1074257/gcc%2Fintl%2Fbindtextdom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ada4c55ae87436c4b93e204cb157ae7e1074257/gcc%2Fintl%2Fbindtextdom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl%2Fbindtextdom.c?ref=1ada4c55ae87436c4b93e204cb157ae7e1074257", "patch": "@@ -0,0 +1,203 @@\n+/* Implementation of the bindtextdomain(3) function\n+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+# include <config.h>\n+#endif\n+\n+#if defined STDC_HEADERS || defined _LIBC\n+# include <stdlib.h>\n+#else\n+# ifdef HAVE_MALLOC_H\n+#  include <malloc.h>\n+# else\n+void free ();\n+# endif\n+#endif\n+\n+#if defined HAVE_STRING_H || defined _LIBC\n+# include <string.h>\n+#else\n+# include <strings.h>\n+# ifndef memcpy\n+#  define memcpy(Dst, Src, Num) bcopy (Src, Dst, Num)\n+# endif\n+#endif\n+\n+#ifdef _LIBC\n+# include <libintl.h>\n+#else\n+# include \"libgettext.h\"\n+#endif\n+#include \"gettext.h\"\n+#include \"gettextP.h\"\n+\n+/* @@ end of prolog @@ */\n+\n+/* Contains the default location of the message catalogs.  */\n+extern const char _nl_default_dirname[];\n+\n+/* List with bindings of specific domains.  */\n+extern struct binding *_nl_domain_bindings;\n+\n+\n+/* Names for the libintl functions are a problem.  They must not clash\n+   with existing names and they should follow ANSI C.  But this source\n+   code is also used in GNU C Library where the names have a __\n+   prefix.  So we have to make a difference here.  */\n+#ifdef _LIBC\n+# define BINDTEXTDOMAIN __bindtextdomain\n+# ifndef strdup\n+#  define strdup(str) __strdup (str)\n+# endif\n+#else\n+# define BINDTEXTDOMAIN bindtextdomain__\n+#endif\n+\n+/* Specify that the DOMAINNAME message catalog will be found\n+   in DIRNAME rather than in the system locale data base.  */\n+char *\n+BINDTEXTDOMAIN (domainname, dirname)\n+     const char *domainname;\n+     const char *dirname;\n+{\n+  struct binding *binding;\n+\n+  /* Some sanity checks.  */\n+  if (domainname == NULL || domainname[0] == '\\0')\n+    return NULL;\n+\n+  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)\n+    {\n+      int compare = strcmp (domainname, binding->domainname);\n+      if (compare == 0)\n+\t/* We found it!  */\n+\tbreak;\n+      if (compare < 0)\n+\t{\n+\t  /* It is not in the list.  */\n+\t  binding = NULL;\n+\t  break;\n+\t}\n+    }\n+\n+  if (dirname == NULL)\n+    /* The current binding has be to returned.  */\n+    return binding == NULL ? (char *) _nl_default_dirname : binding->dirname;\n+\n+  if (binding != NULL)\n+    {\n+      /* The domain is already bound.  If the new value and the old\n+\t one are equal we simply do nothing.  Otherwise replace the\n+\t old binding.  */\n+      if (strcmp (dirname, binding->dirname) != 0)\n+\t{\n+\t  char *new_dirname;\n+\n+\t  if (strcmp (dirname, _nl_default_dirname) == 0)\n+\t    new_dirname = (char *) _nl_default_dirname;\n+\t  else\n+\t    {\n+#if defined _LIBC || defined HAVE_STRDUP\n+\t      new_dirname = strdup (dirname);\n+\t      if (new_dirname == NULL)\n+\t\treturn NULL;\n+#else\n+\t      size_t len = strlen (dirname) + 1;\n+\t      new_dirname = (char *) malloc (len);\n+\t      if (new_dirname == NULL)\n+\t\treturn NULL;\n+\n+\t      memcpy (new_dirname, dirname, len);\n+#endif\n+\t    }\n+\n+\t  if (binding->dirname != _nl_default_dirname)\n+\t    free (binding->dirname);\n+\n+\t  binding->dirname = new_dirname;\n+\t}\n+    }\n+  else\n+    {\n+      /* We have to create a new binding.  */\n+#if !defined _LIBC && !defined HAVE_STRDUP\n+      size_t len;\n+#endif\n+      struct binding *new_binding =\n+\t(struct binding *) malloc (sizeof (*new_binding));\n+\n+      if (new_binding == NULL)\n+\treturn NULL;\n+\n+#if defined _LIBC || defined HAVE_STRDUP\n+      new_binding->domainname = strdup (domainname);\n+      if (new_binding->domainname == NULL)\n+\treturn NULL;\n+#else\n+      len = strlen (domainname) + 1;\n+      new_binding->domainname = (char *) malloc (len);\n+      if (new_binding->domainname == NULL)\n+\treturn NULL;\n+      memcpy (new_binding->domainname, domainname, len);\n+#endif\n+\n+      if (strcmp (dirname, _nl_default_dirname) == 0)\n+\tnew_binding->dirname = (char *) _nl_default_dirname;\n+      else\n+\t{\n+#if defined _LIBC || defined HAVE_STRDUP\n+\t  new_binding->dirname = strdup (dirname);\n+\t  if (new_binding->dirname == NULL)\n+\t    return NULL;\n+#else\n+\t  len = strlen (dirname) + 1;\n+\t  new_binding->dirname = (char *) malloc (len);\n+\t  if (new_binding->dirname == NULL)\n+\t    return NULL;\n+\t  memcpy (new_binding->dirname, dirname, len);\n+#endif\n+\t}\n+\n+      /* Now enqueue it.  */\n+      if (_nl_domain_bindings == NULL\n+\t  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)\n+\t{\n+\t  new_binding->next = _nl_domain_bindings;\n+\t  _nl_domain_bindings = new_binding;\n+\t}\n+      else\n+\t{\n+\t  binding = _nl_domain_bindings;\n+\t  while (binding->next != NULL\n+\t\t && strcmp (domainname, binding->next->domainname) > 0)\n+\t    binding = binding->next;\n+\n+\t  new_binding->next = binding->next;\n+\t  binding->next = new_binding;\n+\t}\n+\n+      binding = new_binding;\n+    }\n+\n+  return binding->dirname;\n+}\n+\n+#ifdef _LIBC\n+/* Alias for function name in GNU C Library.  */\n+weak_alias (__bindtextdomain, bindtextdomain);\n+#endif"}]}