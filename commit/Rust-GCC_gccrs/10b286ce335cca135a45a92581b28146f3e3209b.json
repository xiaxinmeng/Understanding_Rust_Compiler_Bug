{"sha": "10b286ce335cca135a45a92581b28146f3e3209b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiMjg2Y2UzMzVjY2ExMzVhNDVhOTI1ODFiMjgxNDZmM2UzMjA5Yg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-25T18:34:06Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-25T23:28:04Z"}, "message": "Unify temporal cache with gori dependencies.\n\nMove the temporal cache to strictly be a timestamp, and query GORI for\nthe dependencies rather than trying to register and maintain them.\n\n\t* gimple-range-cache.cc (struct range_timestamp): Delete.\n\t(class temporal_cache): Adjust.\n\t(temporal_cache::get_timestamp): Delete.\n\t(temporal_cache::set_dependency): Delete.\n\t(temporal_cache::temporal_value): Adjust.\n\t(temporal_cache::current_p): Take dependencies as params.\n\t(temporal_cache::set_timestamp): Adjust.\n\t(temporal_cache::set_always_current): Adjust.\n\t(ranger_cache::get_non_stale_global_range): Adjust.\n\t(ranger_cache::register_dependency): Delete.\n\t* gimple-range-cache.h (class range_cache): Adjust.", "tree": {"sha": "2356e23c0318dd35fee1158ceab4dfb2d1b4112f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2356e23c0318dd35fee1158ceab4dfb2d1b4112f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10b286ce335cca135a45a92581b28146f3e3209b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b286ce335cca135a45a92581b28146f3e3209b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b286ce335cca135a45a92581b28146f3e3209b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b286ce335cca135a45a92581b28146f3e3209b/comments", "author": null, "committer": null, "parents": [{"sha": "c21644704160710a17d1ea6c1cd212e079cd5e36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c21644704160710a17d1ea6c1cd212e079cd5e36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c21644704160710a17d1ea6c1cd212e079cd5e36"}], "stats": {"total": 117, "additions": 32, "deletions": 85}, "files": [{"sha": "3969c4de220aab6b04ce3b59ac69053fab1c3636", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 32, "deletions": 84, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b286ce335cca135a45a92581b28146f3e3209b/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b286ce335cca135a45a92581b28146f3e3209b/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=10b286ce335cca135a45a92581b28146f3e3209b", "patch": "@@ -474,43 +474,28 @@ ssa_global_cache::dump (FILE *f)\n // --------------------------------------------------------------------------\n \n \n-// This struct provides a timestamp for a global range calculation.\n-// it contains the time counter, as well as a limited number of ssa-names\n-// that it is dependent upon.  If the timestamp for any of the dependent names\n-// Are newer, then this range could need updating.\n-\n-struct range_timestamp\n-{\n-  unsigned time;\n-  unsigned ssa1;\n-  unsigned ssa2;\n-};\n-\n // This class will manage the timestamps for each ssa_name.\n-// When a value is calcualted, its timestamp is set to the current time.\n-// The ssanames it is dependent on have already been calculated, so they will\n-// have older times.  If one fo those values is ever calculated again, it\n-// will get a newer timestamp, and the \"current_p\" check will fail.\n+// When a value is calculated, the timestamp is set to the current time.\n+// Current time is then incremented.  Any dependencies will already have\n+// been calculated, and will thus have older timestamps.\n+// If one of those values is ever calculated again, it will get a newer\n+// timestamp, and the \"current_p\" check will fail.\n \n class temporal_cache\n {\n public:\n   temporal_cache ();\n   ~temporal_cache ();\n-  bool current_p (tree name) const;\n+  bool current_p (tree name, tree dep1, tree dep2) const;\n   void set_timestamp (tree name);\n-  void set_dependency (tree name, tree dep);\n   void set_always_current (tree name);\n private:\n   unsigned temporal_value (unsigned ssa) const;\n-  const range_timestamp *get_timestamp (unsigned ssa) const;\n-  range_timestamp *get_timestamp (unsigned ssa);\n \n   unsigned m_current_time;\n-  vec <range_timestamp> m_timestamp;\n+  vec <unsigned> m_timestamp;\n };\n \n-\n inline\n temporal_cache::temporal_cache ()\n {\n@@ -525,86 +510,59 @@ temporal_cache::~temporal_cache ()\n   m_timestamp.release ();\n }\n \n-// Return a pointer to the timetamp for ssa-name at index SSA, if there is\n-// one, otherwise return NULL.\n-\n-inline const range_timestamp *\n-temporal_cache::get_timestamp (unsigned ssa) const\n-{\n-  if (ssa >= m_timestamp.length ())\n-    return NULL;\n-  return &(m_timestamp[ssa]);\n-}\n-\n-// Return a reference to the timetamp for ssa-name at index SSA.  If the index\n-// is past the end of the vector, extend the vector.\n-\n-inline range_timestamp *\n-temporal_cache::get_timestamp (unsigned ssa)\n-{\n-  if (ssa >= m_timestamp.length ())\n-    m_timestamp.safe_grow_cleared (num_ssa_names + 20);\n-  return &(m_timestamp[ssa]);\n-}\n-\n-// This routine will fill NAME's next operand slot with DEP if DEP is a valid\n-// SSA_NAME and there is a free slot.\n-\n-inline void\n-temporal_cache::set_dependency (tree name, tree dep)\n-{\n-  if (dep && TREE_CODE (dep) == SSA_NAME)\n-    {\n-      gcc_checking_assert (get_timestamp (SSA_NAME_VERSION (name)));\n-      range_timestamp& ts = *(get_timestamp (SSA_NAME_VERSION (name)));\n-      if (!ts.ssa1)\n-\tts.ssa1 = SSA_NAME_VERSION (dep);\n-      else if (!ts.ssa2 && ts.ssa1 != SSA_NAME_VERSION (name))\n-\tts.ssa2 = SSA_NAME_VERSION (dep);\n-    }\n-}\n-\n // Return the timestamp value for SSA, or 0 if there isnt one.\n+\n inline unsigned\n temporal_cache::temporal_value (unsigned ssa) const\n {\n-  const range_timestamp *ts = get_timestamp (ssa);\n-  return ts ? ts->time : 0;\n+  if (ssa >= m_timestamp.length ())\n+    return 0;\n+  return m_timestamp[ssa];\n }\n \n // Return TRUE if the timestampe for NAME is newer than any of its dependents.\n+// Up to 2 dependencies can be checked.\n \n bool\n-temporal_cache::current_p (tree name) const\n+temporal_cache::current_p (tree name, tree dep1, tree dep2) const\n {\n-  const range_timestamp *ts = get_timestamp (SSA_NAME_VERSION (name));\n-  if (!ts || ts->time == 0)\n+  unsigned ts = temporal_value (SSA_NAME_VERSION (name));\n+  if (ts == 0)\n     return true;\n+\n   // Any non-registered dependencies will have a value of 0 and thus be older.\n   // Return true if time is newer than either dependent.\n-  return ts->time > temporal_value (ts->ssa1)\n-\t && ts->time > temporal_value (ts->ssa2);\n+\n+  if (dep1 && ts < temporal_value (SSA_NAME_VERSION (dep1)))\n+    return false;\n+  if (dep2 && ts < temporal_value (SSA_NAME_VERSION (dep2)))\n+    return false;\n+\n+  return true;\n }\n \n // This increments the global timer and sets the timestamp for NAME.\n \n inline void\n temporal_cache::set_timestamp (tree name)\n {\n-  gcc_checking_assert (get_timestamp (SSA_NAME_VERSION (name)));\n-  get_timestamp (SSA_NAME_VERSION (name))->time = ++m_current_time;\n+  unsigned v = SSA_NAME_VERSION (name);\n+  if (v >= m_timestamp.length ())\n+    m_timestamp.safe_grow_cleared (num_ssa_names + 20);\n+  m_timestamp[v] = ++m_current_time;\n }\n \n // Set the timestamp to 0, marking it as \"always up to date\".\n \n inline void\n temporal_cache::set_always_current (tree name)\n {\n-  gcc_checking_assert (get_timestamp (SSA_NAME_VERSION (name)));\n-  get_timestamp (SSA_NAME_VERSION (name))->time = 0;\n+  unsigned v = SSA_NAME_VERSION (name);\n+  if (v >= m_timestamp.length ())\n+    m_timestamp.safe_grow_cleared (num_ssa_names + 20);\n+  m_timestamp[v] = 0;\n }\n \n-\n // --------------------------------------------------------------------------\n \n ranger_cache::ranger_cache (gimple_ranger &q) : query (q)\n@@ -682,7 +640,7 @@ ranger_cache::get_non_stale_global_range (irange &r, tree name)\n {\n   if (m_globals.get_global_range (r, name))\n     {\n-      if (m_temporal->current_p (name))\n+      if (m_temporal->current_p (name, depend1 (name), depend2 (name)))\n \treturn true;\n     }\n   else\n@@ -728,16 +686,6 @@ ranger_cache::set_global_range (tree name, const irange &r)\n     m_temporal->set_timestamp (name);\n }\n \n-// Register a dependency on DEP to name.  If the timestamp for DEP is ever\n-// greateer than the timestamp for NAME, then it is newer and NAMEs value\n-// becomes stale.\n-\n-void\n-ranger_cache::register_dependency (tree name, tree dep)\n-{\n-  m_temporal->set_dependency (name, dep);\n-}\n-\n // Push a request for a new lookup in block BB of name.  Return true if\n // the request is actually made (ie, isn't a duplicate).\n "}, {"sha": "fe781e0ad1b13f2a4668251a7133b42772acbe5a", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b286ce335cca135a45a92581b28146f3e3209b/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b286ce335cca135a45a92581b28146f3e3209b/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=10b286ce335cca135a45a92581b28146f3e3209b", "patch": "@@ -98,7 +98,6 @@ class ranger_cache : public gori_compute\n   bool get_global_range (irange &r, tree name) const;\n   bool get_non_stale_global_range (irange &r, tree name);\n   void set_global_range (tree name, const irange &r);\n-  void register_dependency (tree name, tree dep);\n \n   non_null_ref m_non_null;\n "}]}