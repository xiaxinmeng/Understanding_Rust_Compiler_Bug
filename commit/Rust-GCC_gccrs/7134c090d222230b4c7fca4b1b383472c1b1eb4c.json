{"sha": "7134c090d222230b4c7fca4b1b383472c1b1eb4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEzNGMwOTBkMjIyMjMwYjRjN2ZjYTRiMWIzODM0NzJjMWIxZWI0Yw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2011-05-03T13:12:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2011-05-03T13:12:29Z"}, "message": "tree-ssa-threadupdate.c (THREAD_TARGET): define.\n\n\n\t* tree-ssa-threadupdate.c (THREAD_TARGET): define.\n\t(remove_ctrl_stmt_and_useless_edges): Clear AUX field of outgoing edges.\n\t(craete_edge_and_update_destination_phis): Use THREAD_TARGET rather\n\tthan accessing AUX field directly.  Free the AUX field before\t\t\tclearing it.\n\t(thread_block, thread_through_loop_header): Likewise.\n\t(thread_single_edge, mark_threaded_blocks): Likewise.\n\t(redirect_edges): Delay clearing the AUX field.  Free the AUX field.\n\t(register_jump_thread): Do not attempt to thread to a NULL edge.\n\nFrom-SVN: r173305", "tree": {"sha": "2390b87f09ded38fe53aa87f3717fbc2051813b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2390b87f09ded38fe53aa87f3717fbc2051813b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7134c090d222230b4c7fca4b1b383472c1b1eb4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7134c090d222230b4c7fca4b1b383472c1b1eb4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7134c090d222230b4c7fca4b1b383472c1b1eb4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7134c090d222230b4c7fca4b1b383472c1b1eb4c/comments", "author": null, "committer": null, "parents": [{"sha": "2c7eebae8a0b49351452b3a98fc1b2f26608bfbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c7eebae8a0b49351452b3a98fc1b2f26608bfbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c7eebae8a0b49351452b3a98fc1b2f26608bfbc"}], "stats": {"total": 88, "additions": 69, "deletions": 19}, "files": [{"sha": "5db305fa730e017efbcbf24b1933c617079e4e89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7134c090d222230b4c7fca4b1b383472c1b1eb4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7134c090d222230b4c7fca4b1b383472c1b1eb4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7134c090d222230b4c7fca4b1b383472c1b1eb4c", "patch": "@@ -1,3 +1,14 @@\n+2011-05-03  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (THREAD_TARGET): define.\n+\t(remove_ctrl_stmt_and_useless_edges): Clear AUX field of outgoing edges.\n+\t(craete_edge_and_update_destination_phis): Use THREAD_TARGET rather\n+\tthan accessing AUX field directly.  Free the AUX field before\t\t\tclearing it.\n+\t(thread_block, thread_through_loop_header): Likewise.\n+\t(thread_single_edge, mark_threaded_blocks): Likewise.\n+\t(redirect_edges): Delay clearing the AUX field.  Free the AUX field.\n+\t(register_jump_thread): Do not attempt to thread to a NULL edge.\n+\t\n 2011-05-03  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* function.c (init_function_start): Call decide_function_section."}, {"sha": "841b710d19bc8603bb4772a50b84561fef7e340e", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7134c090d222230b4c7fca4b1b383472c1b1eb4c/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7134c090d222230b4c7fca4b1b383472c1b1eb4c/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=7134c090d222230b4c7fca4b1b383472c1b1eb4c", "patch": "@@ -149,6 +149,10 @@ struct local_info\n    (original_edge, target_edge).  */\n static VEC(edge,heap) *threaded_edges;\n \n+/* When we start updating the CFG for threading, data necessary for jump\n+   threading is attached to the AUX field for the incoming edge.  Use these\n+   macros to access the underlying structure attached to the AUX field.  */\n+#define THREAD_TARGET(E) ((edge *)(E)->aux)[0]\n \n /* Jump threading statistics.  */\n \n@@ -200,10 +204,16 @@ remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n static void\n create_block_for_threading (basic_block bb, struct redirection_data *rd)\n {\n+  edge_iterator ei;\n+  edge e;\n+\n   /* We can use the generic block duplication code and simply remove\n      the stuff we do not need.  */\n   rd->dup_block = duplicate_block (bb, NULL, NULL);\n \n+  FOR_EACH_EDGE (e, ei, rd->dup_block->succs)\n+    e->aux = NULL;\n+\n   /* Zero out the profile, since the block is unreachable for now.  */\n   rd->dup_block->frequency = 0;\n   rd->dup_block->count = 0;\n@@ -314,7 +324,16 @@ create_edge_and_update_destination_phis (struct redirection_data *rd,\n   rescan_loop_exit (e, true, false);\n   e->probability = REG_BR_PROB_BASE;\n   e->count = bb->count;\n-  e->aux = rd->outgoing_edge->aux;\n+\n+  if (rd->outgoing_edge->aux)\n+    {\n+      e->aux = (edge *) XNEWVEC (edge, 1);\n+      THREAD_TARGET(e) = THREAD_TARGET (rd->outgoing_edge);\n+    }\n+  else\n+    {\n+      e->aux = NULL;\n+    }\n \n   /* If there are any PHI nodes at the destination of the outgoing edge\n      from the duplicate block, then we will need to add a new argument\n@@ -406,10 +425,6 @@ redirect_edges (void **slot, void *data)\n       next = el->next;\n       free (el);\n \n-      /* Go ahead and clear E->aux.  It's not needed anymore and failure\n-         to clear it will cause all kinds of unpleasant problems later.  */\n-      e->aux = NULL;\n-\n       thread_stats.num_threaded_edges++;\n \n       if (rd->dup_block)\n@@ -429,6 +444,12 @@ redirect_edges (void **slot, void *data)\n \t  gcc_assert (e == e2);\n \t  flush_pending_stmts (e2);\n \t}\n+\n+      /* Go ahead and clear E->aux.  It's not needed anymore and failure\n+         to clear it will cause all kinds of unpleasant problems later.  */\n+      free (e->aux);\n+      e->aux = NULL;\n+\n     }\n \n   /* Indicate that we actually threaded one or more jumps.  */\n@@ -512,7 +533,11 @@ thread_block (basic_block bb, bool noloop_only)\n   if (loop->header == bb)\n     {\n       e = loop_latch_edge (loop);\n-      e2 = (edge) e->aux;\n+\n+      if (e->aux)\n+\te2 = THREAD_TARGET (e);\n+      else\n+\te2 = NULL;\n \n       if (e2 && loop_exit_edge_p (loop, e2))\n \t{\n@@ -525,19 +550,22 @@ thread_block (basic_block bb, bool noloop_only)\n      efficient lookups.  */\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n-      e2 = (edge) e->aux;\n+      if (e->aux == NULL)\n+\tcontinue;\n+\n+      e2 = THREAD_TARGET (e);\n \n       if (!e2\n \t  /* If NOLOOP_ONLY is true, we only allow threading through the\n \t     header of a loop to exit edges.  */\n \t  || (noloop_only\n \t      && bb == bb->loop_father->header\n-\t      && !loop_exit_edge_p (bb->loop_father, e2)))\n+\t      && (!loop_exit_edge_p (bb->loop_father, e2))))\n \tcontinue;\n \n       if (e->dest == e2->src)\n \tupdate_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n-\t\t\t\t         e->count, (edge) e->aux);\n+\t\t\t\t         e->count, THREAD_TARGET (e));\n \n       /* Insert the outgoing edge into the hash table if it is not\n \t already in the hash table.  */\n@@ -582,17 +610,18 @@ thread_block (basic_block bb, bool noloop_only)\n   return local_info.jumps_threaded;\n }\n \n-/* Threads edge E through E->dest to the edge E->aux.  Returns the copy\n-   of E->dest created during threading, or E->dest if it was not necessary\n+/* Threads edge E through E->dest to the edge THREAD_TARGET (E).  Returns the\n+   copy of E->dest created during threading, or E->dest if it was not necessary\n    to copy it (E is its single predecessor).  */\n \n static basic_block\n thread_single_edge (edge e)\n {\n   basic_block bb = e->dest;\n-  edge eto = (edge) e->aux;\n+  edge eto = THREAD_TARGET (e);\n   struct redirection_data rd;\n \n+  free (e->aux);\n   e->aux = NULL;\n \n   thread_stats.num_threaded_edges++;\n@@ -794,7 +823,7 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n \n   if (latch->aux)\n     {\n-      tgt_edge = (edge) latch->aux;\n+      tgt_edge = THREAD_TARGET (latch);\n       tgt_bb = tgt_edge->dest;\n     }\n   else if (!may_peel_loop_headers\n@@ -817,7 +846,7 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n \t      goto fail;\n \t    }\n \n-\t  tgt_edge = (edge) e->aux;\n+\t  tgt_edge = THREAD_TARGET (e);\n \t  atgt_bb = tgt_edge->dest;\n \t  if (!tgt_bb)\n \t    tgt_bb = atgt_bb;\n@@ -883,7 +912,7 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n \n       /* Now consider the case entry edges are redirected to the new entry\n \t block.  Remember one entry edge, so that we can find the new\n-\tpreheader (its destination after threading).  */\n+\t preheader (its destination after threading).  */\n       FOR_EACH_EDGE (e, ei, header->preds)\n \t{\n \t  if (e->aux)\n@@ -915,6 +944,7 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n   /* We failed to thread anything.  Cancel the requests.  */\n   FOR_EACH_EDGE (e, ei, header->preds)\n     {\n+      free (e->aux);\n       e->aux = NULL;\n     }\n   return false;\n@@ -946,9 +976,10 @@ mark_threaded_blocks (bitmap threaded_blocks)\n   for (i = 0; i < VEC_length (edge, threaded_edges); i += 2)\n     {\n       edge e = VEC_index (edge, threaded_edges, i);\n-      edge e2 = VEC_index (edge, threaded_edges, i + 1);\n+      edge *x = (edge *) XNEWVEC (edge, 1);\n \n-      e->aux = e2;\n+      x[0] = VEC_index (edge, threaded_edges, i + 1);\n+      e->aux = x;\n       bitmap_set_bit (tmp, e->dest->index);\n     }\n \n@@ -963,7 +994,10 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \t      && !redirection_block_p (bb))\n \t    {\n \t      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t\t      e->aux = NULL;\n+\t\t{\n+\t\t  free (e->aux);\n+\t\t  e->aux = NULL;\n+\t\t}\n \t    }\n \t  else\n \t    bitmap_set_bit (threaded_blocks, i);\n@@ -1059,8 +1093,13 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n void\n register_jump_thread (edge e, edge e2)\n {\n+  /* This can occur if we're jumping to a constant address or\n+     or something similar.  Just get out now.  */\n+  if (e2 == NULL)\n+    return;\n+\n   if (threaded_edges == NULL)\n-    threaded_edges = VEC_alloc (edge, heap, 10);\n+    threaded_edges = VEC_alloc (edge, heap, 15);\n \n   if (dump_file && (dump_flags & TDF_DETAILS)\n       && e->dest != e2->src)"}]}