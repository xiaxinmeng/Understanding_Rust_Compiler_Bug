{"sha": "048d99365055be4021508378e90a90987df38283", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ4ZDk5MzY1MDU1YmU0MDIxNTA4Mzc4ZTkwYTkwOTg3ZGYzODI4Mw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-06-19T01:52:12Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-06-19T01:52:12Z"}, "message": "tree-ssa.c (raise_value): Removed.\n\n\t* tree-ssa.c (raise_value): Removed.\n\t(get_eq_name, check_phi_redundancy): New functions.\n\t(kill_redundant_phi_nodes): Use standard ssa minimalization algorithm.\n\nFrom-SVN: r83380", "tree": {"sha": "eed850cbd63e49331cd77445ef19a7192b869db7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eed850cbd63e49331cd77445ef19a7192b869db7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/048d99365055be4021508378e90a90987df38283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048d99365055be4021508378e90a90987df38283", "html_url": "https://github.com/Rust-GCC/gccrs/commit/048d99365055be4021508378e90a90987df38283", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048d99365055be4021508378e90a90987df38283/comments", "author": null, "committer": null, "parents": [{"sha": "ee8db92b391a602cb93f4ba227b152bcf81cb054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee8db92b391a602cb93f4ba227b152bcf81cb054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee8db92b391a602cb93f4ba227b152bcf81cb054"}], "stats": {"total": 194, "additions": 106, "deletions": 88}, "files": [{"sha": "fb0321165a915ba9d203b352d5626158976ce5ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048d99365055be4021508378e90a90987df38283/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048d99365055be4021508378e90a90987df38283/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=048d99365055be4021508378e90a90987df38283", "patch": "@@ -1,3 +1,9 @@\n+2004-06-18  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* tree-ssa.c (raise_value): Removed.\n+\t(get_eq_name, check_phi_redundancy): New functions.\n+\t(kill_redundant_phi_nodes): Use standard ssa minimalization algorithm.\n+\n 2004-06-18  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (fold) <UNORDERED_EXPR, ORDERED_EXPR, UNLT_EXPR,"}, {"sha": "5ba8f65b510cf357df200268f46b6d5688666445", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 100, "deletions": 88, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048d99365055be4021508378e90a90987df38283/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048d99365055be4021508378e90a90987df38283/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=048d99365055be4021508378e90a90987df38283", "patch": "@@ -831,41 +831,90 @@ replace_immediate_uses (tree var, tree repl)\n     }\n }\n \n-/* Raises value of phi node PHI by joining it with VAL.  Processes immediate\n-   uses of PHI recursively.  */\n+/* Gets the value VAR is equivalent to according to EQ_TO.  */\n+\n+static tree\n+get_eq_name (tree *eq_to, tree var)\n+{\n+  unsigned ver;\n+  tree val = var;\n+\n+  while (TREE_CODE (val) == SSA_NAME)\n+    {\n+      ver = SSA_NAME_VERSION (val);\n+      if (!eq_to[ver])\n+\tbreak;\n+\n+      val = eq_to[ver];\n+    }\n+\n+  while (TREE_CODE (var) == SSA_NAME)\n+    {\n+      ver = SSA_NAME_VERSION (var);\n+      if (!eq_to[ver])\n+\tbreak;\n+\n+      var = eq_to[ver];\n+      eq_to[ver] = val;\n+    }\n+\n+  return val;\n+}\n+\n+/* Checks whether phi node PHI is redundant and if it is, records the ssa name\n+   its result is redundant to to EQ_TO array.  */\n \n static void\n-raise_value (tree phi, tree val, tree *eq_to)\n+check_phi_redundancy (tree phi, tree *eq_to)\n {\n-  int i, n;\n-  tree var = PHI_RESULT (phi), stmt;\n-  int ver = SSA_NAME_VERSION (var);\n+  tree val = NULL_TREE, def, res = PHI_RESULT (phi), stmt;\n+  unsigned i, ver = SSA_NAME_VERSION (res), n;\n   dataflow_t df;\n \n-  if (eq_to[ver] == var)\n+  /* It is unlikely that such large phi node would be redundant.  */\n+  if (PHI_NUM_ARGS (phi) > 16)\n     return;\n \n-  if (eq_to[ver])\n+  for (i = 0; i < (unsigned) PHI_NUM_ARGS (phi); i++)\n     {\n-      if (operand_equal_p (eq_to[ver], val, 0))\n+      def = PHI_ARG_DEF (phi, i);\n+\n+      if (TREE_CODE (def) == SSA_NAME)\n+\t{\n+\t  def = get_eq_name (eq_to, def);\n+\t  if (def == res)\n+\t    continue;\n+\t}\n+\n+      if (val\n+\t  && !operand_equal_p (val, def, 0))\n \treturn;\n \n-      eq_to[ver] = var;\n+      val = def;\n     }\n-  else\n-    eq_to[ver] = val;\n \n-  df = get_immediate_uses (SSA_NAME_DEF_STMT (var));\n+  /* At least one of the arguments should not be equal to the result, or\n+     something strange is happening.  */\n+  if (!val)\n+    abort ();\n+\n+  if (get_eq_name (eq_to, res) == val)\n+    return;\n+\n+  if (!may_propagate_copy (res, val))\n+    return;\n+\n+  eq_to[ver] = val;\n+\n+  df = get_immediate_uses (SSA_NAME_DEF_STMT (res));\n   n = num_immediate_uses (df);\n \n   for (i = 0; i < n; i++)\n     {\n       stmt = immediate_use (df, i);\n \n-      if (TREE_CODE (stmt) != PHI_NODE)\n-\tcontinue;\n-\n-      raise_value (stmt, eq_to[ver], eq_to);\n+      if (TREE_CODE (stmt) == PHI_NODE)\n+\tcheck_phi_redundancy (stmt, eq_to);\n     }\n }\n \n@@ -890,26 +939,17 @@ static void\n kill_redundant_phi_nodes (void)\n {\n   tree *eq_to;\n-  unsigned i;\n+  unsigned i, old_num_ssa_names;\n   basic_block bb;\n-  tree phi, t, stmt, var;\n-\n-  /* The EQ_TO array holds the current value of the ssa name in the\n-     lattice:\n-\n-          top\n-         / | \\\n-     const   variables\n-         \\ | /\n-        bottom\n-\n-     Bottom is represented by NULL and top by the variable itself.\n-\n-     Once the dataflow stabilizes, we know that the phi nodes we need to keep\n-     are exactly those with top as their result. \n-\n-     The remaining phi nodes have their uses replaced with their value\n-     in the lattice and the phi node itself is removed.  */\n+  tree phi, var, repl, stmt;\n+\n+  /* The EQ_TO[VER] holds the value by that the ssa name VER should be\n+     replaced.  If EQ_TO[VER] is ssa name and it is decided to replace it by\n+     other value, it may be necessary to follow the chain till the final value.\n+     We perform path shortening (replacing the entries of the EQ_TO array with\n+     heads of these chains) whenever we access the field to prevent quadratic\n+     complexity (probably would not occur in practice anyway, but let us play\n+     it safe).  */\n   eq_to = xcalloc (num_ssa_names, sizeof (tree));\n \n   /* We have had cases where computing immediate uses takes a\n@@ -918,69 +958,41 @@ kill_redundant_phi_nodes (void)\n      a subset of all the SSA_NAMEs instead of computing it for\n      all of the SSA_NAMEs.  */\n   compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, NULL);\n+  old_num_ssa_names = num_ssa_names;\n \n   FOR_EACH_BB (bb)\n     {\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+      for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n \t{\n \t  var = PHI_RESULT (phi);\n-\n-\t  /* If the destination of the PHI is associated with an\n-\t     abnormal edge, then we can not propagate this PHI away.  */\n-\t  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (var))\n-\t    {\n-\t      raise_value (phi, var, eq_to);\n-\t      continue;\n-\t    }\n-\n-\t  for (i = 0; i < (unsigned) PHI_NUM_ARGS (phi); i++)\n-\t    {\n-\t      t = PHI_ARG_DEF (phi, i);\n-\n-\t      if (TREE_CODE (t) != SSA_NAME)\n-\t\t{\n-\t\t  raise_value (phi, t, eq_to);\n-\t\t  continue;\n-\t\t}\n-\n-\t      stmt = SSA_NAME_DEF_STMT (t);\n-\n-\t      /* If any particular PHI argument is associated with\n-\t\t an abnormal edge, then we know that we should not\n-\t\t be propagating away this PHI.  Go ahead and raise\n-\t\t the result of this PHI to the top of the lattice.  */\n-\t      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (t))\n-\t\t{\n-\t\t  raise_value (phi, var, eq_to);\n-\t\t  continue;\n-\t\t}\n-\t      \n-\t      /* If the defining statement for this argument is not a\n-\t\t phi node then we need to recursively start the forward\n-\t\t dataflow starting with PHI.  */\n-\t      if (TREE_CODE (stmt) != PHI_NODE)\n-\t\t{\n-\t\t  eq_to[SSA_NAME_VERSION (t)] = t;\n-\t\t  raise_value (phi, t, eq_to);\n-\t\t}\n-\t    }\n+\t  check_phi_redundancy (phi, eq_to);\n \t}\n     }\n \n   /* Now propagate the values.  */\n-  for (i = 0; i < num_ssa_names; i++)\n-    if (eq_to[i]\n-\t&& eq_to[i] != ssa_name (i))\n-      replace_immediate_uses (ssa_name (i), eq_to[i]);\n+  for (i = 0; i < old_num_ssa_names; i++)\n+    {\n+      if (!ssa_name (i))\n+\tcontinue;\n+\n+      repl = get_eq_name (eq_to, ssa_name (i));\n+      if (repl != ssa_name (i))\n+\treplace_immediate_uses (ssa_name (i), repl);\n+    }\n \n   /* And remove the dead phis.  */\n-  for (i = 0; i < num_ssa_names; i++)\n-    if (eq_to[i]\n-\t&& eq_to[i] != ssa_name (i))\n-      {\n-\tstmt = SSA_NAME_DEF_STMT (ssa_name (i));\n-\tremove_phi_node (stmt, 0, bb_for_stmt (stmt));\n-      }\n+  for (i = 0; i < old_num_ssa_names; i++)\n+    {\n+      if (!ssa_name (i))\n+\tcontinue;\n+\n+      repl = get_eq_name (eq_to, ssa_name (i));\n+      if (repl != ssa_name (i))\n+\t{\n+\t  stmt = SSA_NAME_DEF_STMT (ssa_name (i));\n+\t  remove_phi_node (stmt, NULL_TREE, bb_for_stmt (stmt));\n+\t}\n+    }\n \n   free_df ();\n   free (eq_to);"}]}