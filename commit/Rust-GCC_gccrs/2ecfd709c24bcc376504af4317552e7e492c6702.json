{"sha": "2ecfd709c24bcc376504af4317552e7e492c6702", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVjZmQ3MDljMjRiY2MzNzY1MDRhZjQzMTc1NTJlN2U0OTJjNjcwMg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2002-06-01T09:24:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-06-01T09:24:41Z"}, "message": "basic-block.h (struct basic_block_def): New field loop_father.\n\n\t* basic-block.h (struct basic_block_def): New field loop_father.\n\t(BB_VISITED): New flag.\n\t(struct loop): New field pred, removed field shared.\n\t(struct loops): New field parray.\n\t(LOOP_EXITS_DOMS): Removed.\n\t(flow_loop_tree_node_add, flow_loop_tree_node_remove,\n\tflow_loop_nested_p, flow_bb_inside_loop_p, get_loop_body,\n\tdfs_enumerate_from, loop_preheader_edge, loop_latch_edge,\n\tadd_bb_to_loop, remove_bb_from_loops, find_common_loop,\n\tverify_loop_structure): Declare.\n\t* cfg.c (entry_exit_blocks): Initialize loop_father field.\n\t* cfganal.c (dfs_enumerate_from): New function.\n\t* cfgloop.c (HEAVY_EDGE_RATIO): New constant.\n\t(flow_loop_entry_edges_find, flow_loop_exit_edges_find,\n\tflow_loop_nodes_find, flow_loop_level_compute, flow_loop_nested_p,\n\tflow_loop_dump, flow_loops_dump, flow_loops_free,\n\tflow_loop_tree_node_add, flow_loop_level_compute,\n\tflow_loops_level_compute, flow_loop_scan, flow_loops_update,\n\tflow_loop_outside_edge_p): Modified for new infrastructure.\n\t(make_forwarder_block, canonicalize_loop_headers, glb_enum_p,\n\tredirect_edge_with_latch_update, flow_loop_free): New static functions.\n\t(flow_loop_tree_node_remove, flow_bb_inside_loop_p,\n\tget_loop_body, add_bb_to_loop, remove_bb_from_loops,\n\tfind_common_loop, verify_loop_structure, loop_latch_edge,\n\tloop_preheader_edge): New functions.\n\t(flow_loops_cfg_dump): Do not show dominators, as this information\n\tdoes not remain up to date long.\n\t(flow_loops_find): Store results in new format.\n\t* predict.c (propagate_freq, estimate_probability,\n\testimate_loops_at_level, estimate_bb_frequencies): Use new loop\n\tinfrastructure.\n\nFrom-SVN: r54142", "tree": {"sha": "32dca2e27bb3e45f9ac6684f98ae4a2fb5d94a27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32dca2e27bb3e45f9ac6684f98ae4a2fb5d94a27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ecfd709c24bcc376504af4317552e7e492c6702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ecfd709c24bcc376504af4317552e7e492c6702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ecfd709c24bcc376504af4317552e7e492c6702", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ecfd709c24bcc376504af4317552e7e492c6702/comments", "author": null, "committer": null, "parents": [{"sha": "d6ee5ebf93778e5d9b7f7ed82e5def46ba793619", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ee5ebf93778e5d9b7f7ed82e5def46ba793619", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6ee5ebf93778e5d9b7f7ed82e5def46ba793619"}], "stats": {"total": 1303, "additions": 884, "deletions": 419}, "files": [{"sha": "a4d913ec2c1eae6ddcd2370e5c1aed6edb518517", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ecfd709c24bcc376504af4317552e7e492c6702", "patch": "@@ -1,3 +1,37 @@\n+Sat Jun  1 11:23:22 CEST 2002  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* basic-block.h (struct basic_block_def): New field loop_father.\n+\t(BB_VISITED): New flag.\n+\t(struct loop): New field pred, removed field shared.\n+\t(struct loops): New field parray.\n+\t(LOOP_EXITS_DOMS): Removed.\n+\t(flow_loop_tree_node_add, flow_loop_tree_node_remove,\n+\tflow_loop_nested_p, flow_bb_inside_loop_p, get_loop_body,\n+\tdfs_enumerate_from, loop_preheader_edge, loop_latch_edge,\n+\tadd_bb_to_loop, remove_bb_from_loops, find_common_loop,\n+\tverify_loop_structure): Declare.\n+\t* cfg.c (entry_exit_blocks): Initialize loop_father field.\n+\t* cfganal.c (dfs_enumerate_from): New function.\n+\t* cfgloop.c (HEAVY_EDGE_RATIO): New constant.\n+\t(flow_loop_entry_edges_find, flow_loop_exit_edges_find,\n+\tflow_loop_nodes_find, flow_loop_level_compute, flow_loop_nested_p,\n+\tflow_loop_dump, flow_loops_dump, flow_loops_free,\n+\tflow_loop_tree_node_add, flow_loop_level_compute,\n+\tflow_loops_level_compute, flow_loop_scan, flow_loops_update,\n+\tflow_loop_outside_edge_p): Modified for new infrastructure.\n+\t(make_forwarder_block, canonicalize_loop_headers, glb_enum_p,\n+\tredirect_edge_with_latch_update, flow_loop_free): New static functions.\n+\t(flow_loop_tree_node_remove, flow_bb_inside_loop_p,\n+\tget_loop_body, add_bb_to_loop, remove_bb_from_loops,\n+\tfind_common_loop, verify_loop_structure, loop_latch_edge,\n+\tloop_preheader_edge): New functions.\n+\t(flow_loops_cfg_dump): Do not show dominators, as this information\n+\tdoes not remain up to date long.\n+\t(flow_loops_find): Store results in new format.\n+\t* predict.c (propagate_freq, estimate_probability,\n+\testimate_loops_at_level, estimate_bb_frequencies): Use new loop\n+\tinfrastructure.\n+\n 2002-06-01  Alan Lehotsky  <apl@alum.mit.edu>\n \t\n \t* except.c (nothrow_function_p): Walk epilogue delay list"}, {"sha": "4fe64d44c92d2b7a74ae04e822dadf16259617d9", "filename": "gcc/basic-block.h", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=2ecfd709c24bcc376504af4317552e7e492c6702", "patch": "@@ -212,6 +212,9 @@ typedef struct basic_block_def {\n   /* The loop depth of this block.  */\n   int loop_depth;\n \n+  /* Outermost loop containing the block.  */\n+  struct loop *loop_father;\n+\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n \n@@ -228,6 +231,7 @@ typedef struct basic_block_def {\n #define BB_DIRTY\t\t1\n #define BB_NEW\t\t\t2\n #define BB_REACHABLE\t\t4\n+#define BB_VISITED\t\t8\n \n /* Number of basic blocks in the current function.  */\n \n@@ -403,6 +407,9 @@ struct loop\n   /* The loop nesting depth.  */\n   int depth;\n \n+  /* Superloops of the loop.  */\n+  struct loop **pred;\n+\n   /* The height of the loop (enclosed loop levels) within the loop\n      hierarchy tree.  */\n   int level;\n@@ -416,9 +423,6 @@ struct loop\n   /* Link to the next (sibling) loop.  */\n   struct loop *next;\n \n-  /* Non-zero if the loop shares a header with another loop.  */\n-  int shared;\n-\n   /* Non-zero if the loop is invalid (e.g., contains setjmp.).  */\n   int invalid;\n \n@@ -484,6 +488,11 @@ struct loops\n      will find the inner loops before their enclosing outer loops).  */\n   struct loop *array;\n \n+  /* The above array is unused in new loop infrastructure and is kept only for\n+     purposes of the old loop optimizer.  Instead we store just pointers to\n+     loops here.  */\n+  struct loop **parray;\n+\n   /* Pointer to root of loop heirachy tree.  */\n   struct loop *tree_root;\n \n@@ -515,6 +524,8 @@ extern void flow_loop_dump PARAMS ((const struct loop *, FILE *,\n \t\t\t\t    void (*)(const struct loop *,\n \t\t\t\t\t     FILE *, int), int));\n extern int flow_loop_scan PARAMS ((struct loops *, struct loop *, int));\n+extern void flow_loop_tree_node_add PARAMS ((struct loop *, struct loop *));\n+extern void flow_loop_tree_node_remove PARAMS ((struct loop *));\n \n /* This structure maintains an edge list vector.  */\n struct edge_list\n@@ -613,8 +624,7 @@ enum update_life_extent\n #define LOOP_ENTRY_EDGES\t4\t/* Find entry edges.  */\n #define LOOP_EXIT_EDGES\t\t8\t/* Find exit edges.  */\n #define LOOP_EDGES\t\t(LOOP_ENTRY_EDGES | LOOP_EXIT_EDGES)\n-#define LOOP_EXITS_DOMS\t       16\t/* Find nodes that dom. all exits.  */\n-#define LOOP_ALL\t       31\t/* All of the above  */\n+#define LOOP_ALL\t       15\t/* All of the above  */\n \n extern void life_analysis\tPARAMS ((rtx, FILE *, int));\n extern int update_life_info\tPARAMS ((sbitmap, enum update_life_extent,\n@@ -701,7 +711,24 @@ extern void free_aux_for_edges\t\tPARAMS ((void));\n    debugger, and it is declared extern so we don't get warnings about\n    it being unused.  */\n extern void verify_flow_info\t\tPARAMS ((void));\n-extern int flow_loop_outside_edge_p\tPARAMS ((const struct loop *, edge));\n+extern bool flow_loop_outside_edge_p\tPARAMS ((const struct loop *, edge));\n+extern bool flow_loop_nested_p PARAMS ((const struct loop *, const struct loop *));\n+extern bool flow_bb_inside_loop_p       PARAMS ((const struct loop *, basic_block));\n+extern basic_block *get_loop_body       PARAMS ((const struct loop *));\n+extern int dfs_enumerate_from           PARAMS ((basic_block, int,\n+\t\t\t\t         bool (*)(basic_block, void *),\n+\t\t\t\t\t basic_block *, int, void *));\n+\n+extern edge loop_preheader_edge PARAMS ((struct loop *));\n+extern edge loop_latch_edge PARAMS ((struct loop *));\n+\n+extern void add_bb_to_loop PARAMS ((basic_block, struct loop *));\n+extern void remove_bb_from_loops PARAMS ((basic_block));\n+extern struct loop * find_common_loop PARAMS ((struct loop *, struct loop *));\n+\n+extern void verify_loop_structure PARAMS ((struct loops *, int));\n+#define VLS_EXPECT_PREHEADERS 1\n+#define VLS_EXPECT_SIMPLE_LATCHES 2\n \n typedef struct conflict_graph_def *conflict_graph;\n "}, {"sha": "33599d354e0b48a837729caacf57820cef792bc9", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=2ecfd709c24bcc376504af4317552e7e492c6702", "patch": "@@ -100,6 +100,7 @@ struct basic_block_def entry_exit_blocks[2]\n     NULL,\t\t\t/* prev_bb */\n     EXIT_BLOCK_PTR,\t\t/* next_bb */\n     0,\t\t\t\t/* loop_depth */\n+    NULL,                       /* loop_father */\n     0,\t\t\t\t/* count */\n     0,\t\t\t\t/* frequency */\n     0\t\t\t\t/* flags */\n@@ -120,6 +121,7 @@ struct basic_block_def entry_exit_blocks[2]\n     ENTRY_BLOCK_PTR,\t\t/* prev_bb */\n     NULL,\t\t\t/* next_bb */\n     0,\t\t\t\t/* loop_depth */\n+    NULL,                       /* loop_father */\n     0,\t\t\t\t/* count */\n     0,\t\t\t\t/* frequency */\n     0\t\t\t\t/* flags */"}, {"sha": "24759e1141ef9f9293c83de3e0d42be6983cd0cd", "filename": "gcc/cfganal.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=2ecfd709c24bcc376504af4317552e7e492c6702", "patch": "@@ -1103,3 +1103,54 @@ flow_dfs_compute_reverse_finish (data)\n   free (data->stack);\n   sbitmap_free (data->visited_blocks);\n }\n+\n+/* Performs dfs search from BB over vertices satisfying PREDICATE;\n+   if REVERSE, go against direction of edges.  Returns number of blocks\n+   found and their list in RSLT.  RSLT can contain at most RSLT_MAX items.  */\n+int\n+dfs_enumerate_from (bb, reverse, predicate, rslt, rslt_max, data)\n+     basic_block bb;\n+     int reverse;\n+     bool (*predicate) (basic_block, void *);\n+     basic_block *rslt;\n+     int rslt_max;\n+     void *data;\n+{\n+  basic_block *st, lbb;\n+  int sp = 0, tv = 0;\n+\n+  st = xcalloc (rslt_max, sizeof (basic_block));\n+  rslt[tv++] = st[sp++] = bb;\n+  bb->flags |= BB_VISITED;\n+  while (sp)\n+    {\n+      edge e;\n+      lbb = st[--sp];\n+      if (reverse)\n+        {\n+          for (e = lbb->pred; e; e = e->pred_next)\n+\t    if (!(e->src->flags & BB_VISITED) && predicate (e->src, data))\n+\t      {\n+\t        if (tv == rslt_max)\n+\t          abort ();\n+\t        rslt[tv++] = st[sp++] = e->src;\n+\t        e->src->flags |= BB_VISITED;\n+\t      }\n+        }\n+      else\n+        {\n+          for (e = lbb->succ; e; e = e->succ_next)\n+\t    if (!(e->dest->flags & BB_VISITED) && predicate (e->dest, data))\n+\t      {\n+\t        if (tv == rslt_max)\n+\t          abort ();\n+\t        rslt[tv++] = st[sp++] = e->dest;\n+\t        e->dest->flags |= BB_VISITED;\n+\t      }\n+\t}\n+    }\n+  free (st);\n+  for (sp = 0; sp < tv; sp++)\n+    rslt[sp]->flags &= ~BB_VISITED;\n+  return tv;\n+}"}, {"sha": "e5cc41b41319131c25d492591c54f74f05d78ee9", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 712, "deletions": 347, "changes": 1059, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=2ecfd709c24bcc376504af4317552e7e492c6702", "patch": "@@ -23,24 +23,28 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"rtl.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n+#include \"toplev.h\"\n+\n+/* Ratio of frequencies of edges so that one of more latch edges is\n+   considered to belong to inner loop with same header.  */\n+#define HEAVY_EDGE_RATIO 8\n \n static void flow_loops_cfg_dump\t\tPARAMS ((const struct loops *,\n \t\t\t\t\t\t FILE *));\n-static int flow_loop_nested_p\t\tPARAMS ((struct loop *,\n-\t\t\t\t\t\t struct loop *));\n-static int flow_loop_entry_edges_find\tPARAMS ((basic_block, const sbitmap,\n-\t\t\t\t\t\t edge **));\n-static int flow_loop_exit_edges_find\tPARAMS ((const sbitmap, edge **));\n-static int flow_loop_nodes_find\t\tPARAMS ((basic_block, basic_block,\n-\t\t\t\t\t\t sbitmap));\n+static void flow_loop_entry_edges_find\tPARAMS ((struct loop *));\n+static void flow_loop_exit_edges_find\tPARAMS ((struct loop *));\n+static int flow_loop_nodes_find\t\tPARAMS ((basic_block, struct loop *));\n static void flow_loop_pre_header_scan\tPARAMS ((struct loop *));\n static basic_block flow_loop_pre_header_find PARAMS ((basic_block,\n \t\t\t\t\t\t      const sbitmap *));\n-static void flow_loop_tree_node_add\tPARAMS ((struct loop *,\n-\t\t\t\t\t\t struct loop *));\n-static void flow_loops_tree_build\tPARAMS ((struct loops *));\n-static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n+static int flow_loop_level_compute\tPARAMS ((struct loop *));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n+static basic_block make_forwarder_block PARAMS ((basic_block, int, int,\n+\t\t\t\t\t\t edge, int));\n+static void canonicalize_loop_headers   PARAMS ((void));\n+static bool glb_enum_p PARAMS ((basic_block, void *));\n+static void redirect_edge_with_latch_update PARAMS ((edge, basic_block));\n+static void flow_loop_free PARAMS ((struct loop *));\n \f\n /* Dump loop related CFG information.  */\n \n@@ -62,7 +66,7 @@ flow_loops_cfg_dump (loops, file)\n       fprintf (file, \";; %d succs { \", bb->index);\n       for (succ = bb->succ; succ; succ = succ->succ_next)\n \tfprintf (file, \"%d \", succ->dest->index);\n-      flow_nodes_print (\"} dom\", loops->cfg.dom[bb->index], file);\n+      fprintf (file, \"}\\n\");\n     }\n \n   /* Dump the DFS node order.  */\n@@ -88,12 +92,13 @@ flow_loops_cfg_dump (loops, file)\n \n /* Return non-zero if the nodes of LOOP are a subset of OUTER.  */\n \n-static int\n+bool\n flow_loop_nested_p (outer, loop)\n-     struct loop *outer;\n-     struct loop *loop;\n+     const struct loop *outer;\n+     const struct loop *loop;\n {\n-  return sbitmap_a_subset_b_p (loop->nodes, outer->nodes);\n+  return loop->depth > outer->depth\n+\t && loop->pred[outer->depth] == outer;\n }\n \n /* Dump the loop information specified by LOOP to the stream FILE\n@@ -106,22 +111,18 @@ flow_loop_dump (loop, file, loop_dump_aux, verbose)\n      void (*loop_dump_aux) PARAMS((const struct loop *, FILE *, int));\n      int verbose;\n {\n+  basic_block *bbs;\n+  int i;\n+\n   if (! loop || ! loop->header)\n     return;\n \n-  if (loop->first->head && loop->last->end)\n-    fprintf (file, \";;\\n;; Loop %d (%d to %d):%s%s\\n\",\n-\t     loop->num, INSN_UID (loop->first->head),\n-\t     INSN_UID (loop->last->end),\n-\t     loop->shared ? \" shared\" : \"\", loop->invalid ? \" invalid\" : \"\");\n-  else\n-    fprintf (file, \";;\\n;; Loop %d:%s%s\\n\", loop->num,\n-\t     loop->shared ? \" shared\" : \"\", loop->invalid ? \" invalid\" : \"\");\n+  fprintf (file, \";;\\n;; Loop %d:%s\\n\", loop->num,\n+\t     loop->invalid ? \" invalid\" : \"\");\n \n-  fprintf (file, \";;  header %d, latch %d, pre-header %d, first %d, last %d\\n\",\n+  fprintf (file, \";;  header %d, latch %d, pre-header %d\\n\",\n \t   loop->header->index, loop->latch->index,\n-\t   loop->pre_header ? loop->pre_header->index : -1,\n-\t   loop->first->index, loop->last->index);\n+\t   loop->pre_header ? loop->pre_header->index : -1);\n   fprintf (file, \";;  depth %d, level %d, outer %ld\\n\",\n \t   loop->depth, loop->level,\n \t   (long) (loop->outer ? loop->outer->num : -1));\n@@ -132,14 +133,15 @@ flow_loop_dump (loop, file, loop_dump_aux, verbose)\n \n   flow_edge_list_print (\";;  entry edges\", loop->entry_edges,\n \t\t\tloop->num_entries, file);\n-  fprintf (file, \";;  %d\", loop->num_nodes);\n-  flow_nodes_print (\" nodes\", loop->nodes, file);\n+  fprintf (file, \";;  nodes:\");\n+  bbs = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    fprintf (file, \" %d\", bbs[i]->index);\n+  free (bbs);\n+  fprintf (file, \"\\n\");\n   flow_edge_list_print (\";;  exit edges\", loop->exit_edges,\n \t\t\tloop->num_exits, file);\n \n-  if (loop->exits_doms)\n-    flow_nodes_print (\";;  exit doms\", loop->exits_doms, file);\n-\n   if (loop_dump_aux)\n     loop_dump_aux (loop, file, verbose);\n }\n@@ -154,55 +156,53 @@ flow_loops_dump (loops, file, loop_dump_aux, verbose)\n      void (*loop_dump_aux) PARAMS((const struct loop *, FILE *, int));\n      int verbose;\n {\n-  int i, j;\n+  int i;\n   int num_loops;\n \n   num_loops = loops->num;\n   if (! num_loops || ! file)\n     return;\n \n-  fprintf (file, \";; %d loops found, %d levels\\n\", num_loops, loops->levels);\n+  fprintf (file, \";; %d loops found, %d levels\\n\",\n+\t   num_loops, loops->levels);\n+\n   for (i = 0; i < num_loops; i++)\n     {\n-      struct loop *loop = &loops->array[i];\n+      struct loop *loop = loops->parray[i];\n \n-      flow_loop_dump (loop, file, loop_dump_aux, verbose);\n-      if (loop->shared)\n-\tfor (j = 0; j < i; j++)\n-\t  {\n-\t    struct loop *oloop = &loops->array[j];\n+      if (!loop)\n+\tcontinue;\n \n-\t    if (loop->header == oloop->header)\n-\t      {\n-\t\tint disjoint;\n-\t\tint smaller;\n-\n-\t\tsmaller = loop->num_nodes < oloop->num_nodes;\n-\n-\t\t/* If the union of LOOP and OLOOP is different than\n-\t\t   the larger of LOOP and OLOOP then LOOP and OLOOP\n-\t\t   must be disjoint.  */\n-\t\tdisjoint = ! flow_loop_nested_p (smaller ? loop : oloop,\n-\t\t\t\t\t\t smaller ? oloop : loop);\n-\t\tfprintf (file,\n-\t\t\t \";; loop header %d shared by loops %d, %d %s\\n\",\n-\t\t\t loop->header->index, i, j,\n-\t\t\t disjoint ? \"disjoint\" : \"nested\");\n-\t      }\n-\t  }\n+      flow_loop_dump (loop, file, loop_dump_aux, verbose);\n     }\n \n   if (verbose)\n     flow_loops_cfg_dump (loops, file);\n }\n \n+/* Free data allocated for LOOP.  */\n+static void\n+flow_loop_free (loop)\n+     struct loop *loop;\n+{\n+  if (loop->pre_header_edges)\n+    free (loop->pre_header_edges);\n+  if (loop->entry_edges)\n+    free (loop->entry_edges);\n+  if (loop->exit_edges)\n+    free (loop->exit_edges);\n+  if (loop->pred)\n+    free (loop->pred);\n+  free (loop);\n+}\n+\n /* Free all the memory allocated for LOOPS.  */\n \n void\n flow_loops_free (loops)\n      struct loops *loops;\n {\n-  if (loops->array)\n+  if (loops->parray)\n     {\n       int i;\n \n@@ -212,180 +212,163 @@ flow_loops_free (loops)\n       /* Free the loop descriptors.  */\n       for (i = 0; i < loops->num; i++)\n \t{\n-\t  struct loop *loop = &loops->array[i];\n-\n-\t  if (loop->pre_header_edges)\n-\t    free (loop->pre_header_edges);\n-\t  if (loop->nodes)\n-\t    sbitmap_free (loop->nodes);\n-\t  if (loop->entry_edges)\n-\t    free (loop->entry_edges);\n-\t  if (loop->exit_edges)\n-\t    free (loop->exit_edges);\n-\t  if (loop->exits_doms)\n-\t    sbitmap_free (loop->exits_doms);\n+\t  struct loop *loop = loops->parray[i];\n+\n+\t  if (!loop)\n+\t    continue;\n+\n+\t  flow_loop_free (loop);\n \t}\n \n-      free (loops->array);\n-      loops->array = NULL;\n+      free (loops->parray);\n+      loops->parray = NULL;\n \n       if (loops->cfg.dom)\n \tsbitmap_vector_free (loops->cfg.dom);\n \n       if (loops->cfg.dfs_order)\n \tfree (loops->cfg.dfs_order);\n+      if (loops->cfg.rc_order)\n+\tfree (loops->cfg.rc_order);\n \n-      if (loops->shared_headers)\n-\tsbitmap_free (loops->shared_headers);\n     }\n }\n \n-/* Find the entry edges into the loop with header HEADER and nodes\n-   NODES and store in ENTRY_EDGES array.  Return the number of entry\n-   edges from the loop.  */\n+/* Find the entry edges into the LOOP.  */\n \n-static int\n-flow_loop_entry_edges_find (header, nodes, entry_edges)\n-     basic_block header;\n-     const sbitmap nodes;\n-     edge **entry_edges;\n+static void \n+flow_loop_entry_edges_find (loop)\n+     struct loop *loop;\n {\n   edge e;\n   int num_entries;\n \n-  *entry_edges = NULL;\n-\n   num_entries = 0;\n-  for (e = header->pred; e; e = e->pred_next)\n+  for (e = loop->header->pred; e; e = e->pred_next)\n     {\n-      basic_block src = e->src;\n-\n-      if (src == ENTRY_BLOCK_PTR || ! TEST_BIT (nodes, src->index))\n+      if (flow_loop_outside_edge_p (loop, e))\n \tnum_entries++;\n     }\n \n   if (! num_entries)\n     abort ();\n \n-  *entry_edges = (edge *) xmalloc (num_entries * sizeof (edge));\n+  loop->entry_edges = (edge *) xmalloc (num_entries * sizeof (edge *));\n \n   num_entries = 0;\n-  for (e = header->pred; e; e = e->pred_next)\n+  for (e = loop->header->pred; e; e = e->pred_next)\n     {\n-      basic_block src = e->src;\n-\n-      if (src == ENTRY_BLOCK_PTR || ! TEST_BIT (nodes, src->index))\n-\t(*entry_edges)[num_entries++] = e;\n+      if (flow_loop_outside_edge_p (loop, e))\n+\tloop->entry_edges[num_entries++] = e;\n     }\n \n-  return num_entries;\n+  loop->num_entries = num_entries;\n }\n \n-/* Find the exit edges from the loop using the bitmap of loop nodes\n-   NODES and store in EXIT_EDGES array.  Return the number of\n-   exit edges from the loop.  */\n+/* Find the exit edges from the LOOP.  */\n \n-static int\n-flow_loop_exit_edges_find (nodes, exit_edges)\n-     const sbitmap nodes;\n-     edge **exit_edges;\n+static void\n+flow_loop_exit_edges_find (loop)\n+     struct loop *loop;\n {\n   edge e;\n-  int node;\n-  int num_exits;\n+  basic_block node, *bbs;\n+  int num_exits, i;\n \n-  *exit_edges = NULL;\n+  loop->exit_edges = NULL;\n+  loop->num_exits = 0;\n \n   /* Check all nodes within the loop to see if there are any\n      successors not in the loop.  Note that a node may have multiple\n-     exiting edges ?????  A node can have one jumping edge and one fallthru\n-     edge so only one of these can exit the loop.  */\n+     exiting edges.  */\n   num_exits = 0;\n-  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, node, {\n-    for (e = BASIC_BLOCK (node)->succ; e; e = e->succ_next)\n-      {\n-\tbasic_block dest = e->dest;\n+  bbs = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      node = bbs[i];\n+      for (e = node->succ; e; e = e->succ_next)\n+\t{\n+\t  basic_block dest = e->dest;\n \n-\tif (dest == EXIT_BLOCK_PTR || ! TEST_BIT (nodes, dest->index))\n+\t  if (!flow_bb_inside_loop_p (loop, dest))\n \t    num_exits++;\n-      }\n-  });\n+\t}\n+    }\n \n   if (! num_exits)\n-    return 0;\n+    {\n+      free (bbs);\n+      return;\n+    }\n \n-  *exit_edges = (edge *) xmalloc (num_exits * sizeof (edge));\n+  loop->exit_edges = (edge *) xmalloc (num_exits * sizeof (edge *));\n \n   /* Store all exiting edges into an array.  */\n   num_exits = 0;\n-  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, node, {\n-    for (e = BASIC_BLOCK (node)->succ; e; e = e->succ_next)\n-      {\n-\tbasic_block dest = e->dest;\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      node = bbs[i];\n+      for (e = node->succ; e; e = e->succ_next)\n+\t{\n+\t  basic_block dest = e->dest;\n \n-\tif (dest == EXIT_BLOCK_PTR || ! TEST_BIT (nodes, dest->index))\n-\t  (*exit_edges)[num_exits++] = e;\n+\t  if (!flow_bb_inside_loop_p (loop, dest))\n+\t    loop->exit_edges[num_exits++] = e;\n       }\n-  });\n-\n-  return num_exits;\n+    }\n+  free (bbs);\n+  loop->num_exits = num_exits;\n }\n \n-/* Find the nodes contained within the loop with header HEADER and\n-   latch LATCH and store in NODES.  Return the number of nodes within\n-   the loop.  */\n+/* Find the nodes contained within the LOOP with header HEADER.\n+   Return the number of nodes within the loop.  */\n \n static int\n-flow_loop_nodes_find (header, latch, nodes)\n+flow_loop_nodes_find (header, loop)\n      basic_block header;\n-     basic_block latch;\n-     sbitmap nodes;\n+     struct loop *loop;\n {\n   basic_block *stack;\n   int sp;\n-  int num_nodes = 0;\n-\n-  stack = (basic_block *) xmalloc (n_basic_blocks * sizeof (basic_block));\n-  sp = 0;\n+  int num_nodes = 1;\n+  int findex, lindex;\n \n-  /* Start with only the loop header in the set of loop nodes.  */\n-  sbitmap_zero (nodes);\n-  SET_BIT (nodes, header->index);\n-  num_nodes++;\n-  header->loop_depth++;\n+  header->loop_father = loop;\n+  header->loop_depth = loop->depth;\n+  findex = lindex = header->index;\n \n-  /* Push the loop latch on to the stack.  */\n-  if (! TEST_BIT (nodes, latch->index))\n+  if (loop->latch->loop_father != loop)\n     {\n-      SET_BIT (nodes, latch->index);\n-      latch->loop_depth++;\n+      stack = (basic_block *) xmalloc (n_basic_blocks * sizeof (basic_block));\n+      sp = 0;\n       num_nodes++;\n-      stack[sp++] = latch;\n-    }\n-\n-  while (sp)\n-    {\n-      basic_block node;\n-      edge e;\n-\n-      node = stack[--sp];\n-      for (e = node->pred; e; e = e->pred_next)\n+      stack[sp++] = loop->latch;\n+      loop->latch->loop_father = loop;\n+      loop->latch->loop_depth = loop->depth;\n+ \n+      while (sp)\n \t{\n-\t  basic_block ancestor = e->src;\n+\t  basic_block node;\n+\t  edge e;\n \n-\t  /* If each ancestor not marked as part of loop, add to set of\n-\t     loop nodes and push on to stack.  */\n-\t  if (ancestor != ENTRY_BLOCK_PTR\n-\t      && ! TEST_BIT (nodes, ancestor->index))\n+\t  node = stack[--sp];\n+      \n+\t  for (e = node->pred; e; e = e->pred_next)\n \t    {\n-\t      SET_BIT (nodes, ancestor->index);\n-\t      ancestor->loop_depth++;\n-\t      num_nodes++;\n-\t      stack[sp++] = ancestor;\n+\t      basic_block ancestor = e->src;\n+\n+\t      if (ancestor != ENTRY_BLOCK_PTR\n+\t\t  && ancestor->loop_father != loop)\n+\t\t{\n+\t\t  ancestor->loop_father = loop;\n+\t\t  ancestor->loop_depth = loop->depth;\n+\t\t  num_nodes++;\n+\t\t  stack[sp++] = ancestor;\n+\t\t}\n \t    }\n \t}\n+      free (stack);\n     }\n-  free (stack);\n   return num_nodes;\n }\n \n@@ -462,68 +445,55 @@ flow_loop_pre_header_find (header, dom)\n   return pre_header;\n }\n \n-/* Add LOOP to the loop hierarchy tree where PREVLOOP was the loop\n-   previously added.  The insertion algorithm assumes that the loops\n-   are added in the order found by a depth first search of the CFG.  */\n+/* Add LOOP to the loop hierarchy tree where FATHER is father of the\n+   added loop.  */\n \n-static void\n-flow_loop_tree_node_add (prevloop, loop)\n-     struct loop *prevloop;\n+void\n+flow_loop_tree_node_add (father, loop)\n+     struct loop *father;\n      struct loop *loop;\n {\n-\n-  if (flow_loop_nested_p (prevloop, loop))\n-    {\n-      prevloop->inner = loop;\n-      loop->outer = prevloop;\n-      return;\n-    }\n-\n-  for (; prevloop->outer; prevloop = prevloop->outer)\n-    if (flow_loop_nested_p (prevloop->outer, loop))\n-      {\n-\tprevloop->next = loop;\n-\tloop->outer = prevloop->outer;\n-\treturn;\n-      }\n-\n-  prevloop->next = loop;\n-  loop->outer = NULL;\n+  loop->next = father->inner;\n+  father->inner = loop;\n+  loop->outer = father;\n+\n+  loop->depth = father->depth + 1;\n+  loop->pred = xmalloc (sizeof (struct loop *) * loop->depth);\n+  memcpy (loop->pred, father->pred, sizeof (struct loop *) * father->depth);\n+  loop->pred[father->depth] = father;\n }\n \n-/* Build the loop hierarchy tree for LOOPS.  */\n+/* Remove LOOP from the loop hierarchy tree.  */\n \n-static void\n-flow_loops_tree_build (loops)\n-     struct loops *loops;\n+void\n+flow_loop_tree_node_remove (loop)\n+     struct loop *loop;\n {\n-  int i;\n-  int num_loops;\n+  struct loop *prev, *father;\n \n-  num_loops = loops->num;\n-  if (! num_loops)\n-    return;\n+  father = loop->outer;\n+  loop->outer = NULL;\n \n-  /* Root the loop hierarchy tree with the first loop found.\n-     Since we used a depth first search this should be the\n-     outermost loop.  */\n-  loops->tree_root = &loops->array[0];\n-  loops->tree_root->outer = loops->tree_root->inner\n-    = loops->tree_root->next = NULL;\n+  /* Remove loop from the list of sons.  */\n+  if (father->inner == loop)\n+    father->inner = loop->next;\n+  else\n+    {\n+      for (prev = father->inner; prev->next != loop; prev = prev->next);\n+      prev->next = loop->next;\n+    }\n \n-  /* Add the remaining loops to the tree.  */\n-  for (i = 1; i < num_loops; i++)\n-    flow_loop_tree_node_add (&loops->array[i - 1], &loops->array[i]);\n+  loop->depth = -1;\n+  free (loop->pred);\n+  loop->pred = NULL;\n }\n \n /* Helper function to compute loop nesting depth and enclosed loop level\n-   for the natural loop specified by LOOP at the loop depth DEPTH.\n-   Returns the loop level.  */\n+   for the natural loop specified by LOOP.  Returns the loop level.  */\n \n static int\n-flow_loop_level_compute (loop, depth)\n+flow_loop_level_compute (loop)\n      struct loop *loop;\n-     int depth;\n {\n   struct loop *inner;\n   int level = 1;\n@@ -538,13 +508,13 @@ flow_loop_level_compute (loop, depth)\n      itself).  */\n   for (inner = loop->inner; inner; inner = inner->next)\n     {\n-      int ilevel = flow_loop_level_compute (inner, depth + 1) + 1;\n+      int ilevel = flow_loop_level_compute (inner) + 1;\n \n-      level = MAX (ilevel, level);\n+      if (ilevel > level)\n+\tlevel = ilevel;\n     }\n \n   loop->level = level;\n-  loop->depth = depth;\n   return level;\n }\n \n@@ -556,18 +526,7 @@ static int\n flow_loops_level_compute (loops)\n      struct loops *loops;\n {\n-  int levels = 0;\n-  struct loop *loop;\n-  int level;\n-\n-  /* Traverse all the outer level loops.  */\n-  for (loop = loops->tree_root; loop; loop = loop->next)\n-    {\n-      level = flow_loop_level_compute (loop, 1);\n-      levels = MAX (levels, level);\n-    }\n-\n-  return levels;\n+  return flow_loop_level_compute (loops->tree_root);\n }\n \n /* Scan a single natural loop specified by LOOP collecting information\n@@ -579,37 +538,18 @@ flow_loop_scan (loops, loop, flags)\n      struct loop *loop;\n      int flags;\n {\n-  /* Determine prerequisites.  */\n-  if ((flags & LOOP_EXITS_DOMS) && ! loop->exit_edges)\n-    flags |= LOOP_EXIT_EDGES;\n-\n   if (flags & LOOP_ENTRY_EDGES)\n-    /* Find edges which enter the loop header.  Note that the entry edges\n-       should only enter the header of a natural loop.  */\n-    loop->num_entries = flow_loop_entry_edges_find (loop->header, loop->nodes,\n-\t\t\t\t\t\t    &loop->entry_edges);\n+    {\n+      /* Find edges which enter the loop header.\n+\t Note that the entry edges should only\n+\t enter the header of a natural loop.  */\n+      flow_loop_entry_edges_find (loop);\n+    }\n \n   if (flags & LOOP_EXIT_EDGES)\n-    /* Find edges which exit the loop.  */\n-    loop->num_exits\n-      = flow_loop_exit_edges_find (loop->nodes, &loop->exit_edges);\n-\n-  if (flags & LOOP_EXITS_DOMS)\n     {\n-      int j;\n-\n-      /* Determine which loop nodes dominate all the exits\n-\t of the loop.  */\n-      loop->exits_doms = sbitmap_alloc (last_basic_block);\n-      sbitmap_copy (loop->exits_doms, loop->nodes);\n-      for (j = 0; j < loop->num_exits; j++)\n-\tsbitmap_a_and_b (loop->exits_doms, loop->exits_doms,\n-\t\t\t loops->cfg.dom[loop->exit_edges[j]->src->index]);\n-\n-      /* The header of a natural loop must dominate\n-\t all exits.  */\n-      if (! TEST_BIT (loop->exits_doms, loop->header->index))\n-\tabort ();\n+      /* Find edges which exit the loop.  */\n+      flow_loop_exit_edges_find (loop);\n     }\n \n   if (flags & LOOP_PRE_HEADER)\n@@ -626,6 +566,190 @@ flow_loop_scan (loops, loop, flags)\n   return 1;\n }\n \n+#define HEADER_BLOCK(B) (* (int *) (B)->aux)\n+#define LATCH_EDGE(E) (*(int *) (E)->aux)\n+\n+/* Redirect edge and update latch and header info.  */\n+static void\n+redirect_edge_with_latch_update (e, to)\n+     edge e;\n+     basic_block to;\n+{\n+  basic_block jump;\n+\n+  jump = redirect_edge_and_branch_force (e, to);\n+  if (jump)\n+    {\n+      alloc_aux_for_block (jump, sizeof (int));\n+      HEADER_BLOCK (jump) = 0;\n+      alloc_aux_for_edge (jump->pred, sizeof (int));\n+      LATCH_EDGE (jump->succ) = LATCH_EDGE (e);\n+      LATCH_EDGE (jump->pred) = 0;\n+    }\n+}\n+\n+/* Split BB into entry part and rest; if REDIRECT_LATCH, redirect edges\n+   marked as latch into entry part, analogically for REDIRECT_NONLATCH.\n+   In both of these cases, ignore edge EXCEPT.  If CONN_LATCH, set edge\n+   between created entry part and BB as latch one.  Return created entry\n+   part.  */\n+\n+static basic_block\n+make_forwarder_block (bb, redirect_latch, redirect_nonlatch, except,\n+\t\t      conn_latch)\n+     basic_block bb;\n+     int redirect_latch;\n+     int redirect_nonlatch;\n+     edge except;\n+     int conn_latch;\n+{\n+  edge e, next_e, fallthru;\n+  basic_block dummy;\n+  rtx insn;\n+\n+  insn = PREV_INSN (first_insn_after_basic_block_note (bb));\n+\n+  fallthru = split_block (bb, insn);\n+  dummy = fallthru->src;\n+  bb = fallthru->dest;\n+\n+  bb->aux = xmalloc (sizeof (int));\n+  HEADER_BLOCK (dummy) = 0;\n+  HEADER_BLOCK (bb) = 1;\n+\n+  /* Redirect back edges we want to keep. */\n+  for (e = dummy->pred; e; e = next_e)\n+    {\n+      next_e = e->pred_next;\n+      if (e == except\n+\t  || !((redirect_latch && LATCH_EDGE (e))\n+\t       || (redirect_nonlatch && !LATCH_EDGE (e))))\n+\t{\n+\t  dummy->frequency -= EDGE_FREQUENCY (e);\n+\t  dummy->count -= e->count;\n+\t  if (dummy->frequency < 0)\n+\t    dummy->frequency = 0;\n+\t  if (dummy->count < 0)\n+\t    dummy->count = 0;\n+\t  redirect_edge_with_latch_update (e, bb);\n+\t}\n+    }\n+\n+  alloc_aux_for_edge (fallthru, sizeof (int));\n+  LATCH_EDGE (fallthru) = conn_latch;\n+\n+  return dummy;\n+}\n+\n+/* Takes care of merging natural loops with shared headers.  */\n+static void\n+canonicalize_loop_headers ()\n+{\n+  sbitmap *dom;\n+  basic_block header;\n+  edge e;\n+  \n+  /* Compute the dominators.  */\n+  dom = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n+  calculate_dominance_info (NULL, dom, CDI_DOMINATORS);\n+\n+  alloc_aux_for_blocks (sizeof (int));\n+  alloc_aux_for_edges (sizeof (int));\n+\n+  /* Split blocks so that each loop has only single latch.  */\n+  FOR_EACH_BB (header)\n+    {\n+      int num_latches = 0;\n+      int have_abnormal_edge = 0;\n+\n+      for (e = header->pred; e; e = e->pred_next)\n+\t{\n+\t  basic_block latch = e->src;\n+\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    have_abnormal_edge = 1;\n+\n+\t  if (latch != ENTRY_BLOCK_PTR\n+\t      && TEST_BIT (dom[latch->index], header->index))\n+\t    {\n+\t      num_latches++;\n+\t      LATCH_EDGE (e) = 1;\n+\t    }\n+\t}\n+      if (have_abnormal_edge)\n+\tHEADER_BLOCK (header) = 0;\n+      else\n+\tHEADER_BLOCK (header) = num_latches;\n+    }\n+\n+  if (HEADER_BLOCK (ENTRY_BLOCK_PTR->succ->dest))\n+    {\n+      basic_block bb;\n+\n+      /* We could not redirect edges freely here. On the other hand,\n+\t we can simply split the edge from entry block.  */\n+      bb = split_edge (ENTRY_BLOCK_PTR->succ);\n+ \n+      alloc_aux_for_edge (bb->succ, sizeof (int));\n+      LATCH_EDGE (bb->succ) = 0;\n+      alloc_aux_for_block (bb, sizeof (int));\n+      HEADER_BLOCK (bb) = 0;\n+    }\n+\n+  FOR_EACH_BB (header)\n+    {\n+      int num_latch;\n+      int want_join_latch;\n+      int max_freq, is_heavy;\n+      edge heavy;\n+\n+      if (!HEADER_BLOCK (header))\n+\tcontinue;\n+\n+      num_latch = HEADER_BLOCK (header);\n+\n+      want_join_latch = (num_latch > 1);\n+\n+      if (!want_join_latch)\n+\tcontinue;\n+\n+      /* Find a heavy edge.  */\n+      is_heavy = 1;\n+      heavy = NULL;\n+      max_freq = 0;\n+      for (e = header->pred; e; e = e->pred_next)\n+\tif (LATCH_EDGE (e) &&\n+\t    EDGE_FREQUENCY (e) > max_freq)\n+\t  max_freq = EDGE_FREQUENCY (e);\n+      for (e = header->pred; e; e = e->pred_next)\n+\tif (LATCH_EDGE (e) &&\n+\t    EDGE_FREQUENCY (e) >= max_freq / HEAVY_EDGE_RATIO)\n+\t  {\n+\t    if (heavy)\n+\t      {\n+\t\tis_heavy = 0;\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      heavy = e;\n+\t  }\n+\n+      if (is_heavy)\n+\t{\n+\t  basic_block new_header =\n+\t    make_forwarder_block (header, true, true, heavy, 0);\n+\t  if (num_latch > 2)\n+\t    make_forwarder_block (new_header, true, false, NULL, 1);\n+\t}\n+      else\n+\tmake_forwarder_block (header, true, false, NULL, 1);\n+    }\n+\n+  free_aux_for_blocks ();\n+  free_aux_for_edges ();\n+  sbitmap_vector_free (dom);\n+}\n+\n /* Find all the natural loops in the function and save in LOOPS structure and\n    recalculate loop_depth information in basic block structures.  FLAGS\n    controls which loop information is collected.  Return the number of natural\n@@ -662,32 +786,81 @@ flow_loops_find (loops, flags)\n   dfs_order = NULL;\n   rc_order = NULL;\n \n+  /* Join loops with shared headers.  */\n+  canonicalize_loop_headers ();\n+\n   /* Compute the dominators.  */\n-  dom = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n+  loops->cfg.dom = dom = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n   calculate_dominance_info (NULL, dom, CDI_DOMINATORS);\n \n-  /* Count the number of loop edges (back edges).  This should be the\n+  /* Count the number of loop headers.  This should be the\n      same as the number of natural loops.  */\n+  headers = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (headers);\n+\n   num_loops = 0;\n   FOR_EACH_BB (header)\n     {\n+      int more_latches = 0;\n+     \n       header->loop_depth = 0;\n \n       for (e = header->pred; e; e = e->pred_next)\n \t{\n \t  basic_block latch = e->src;\n \n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    {\n+\t      if (more_latches)\n+\t\t{\n+\t\t  RESET_BIT (headers, header->index);\n+\t\t  num_loops--;\n+\t\t}\n+\t      break;\n+\t    }\n+\n \t  /* Look for back edges where a predecessor is dominated\n \t     by this block.  A natural loop has a single entry\n \t     node (header) that dominates all the nodes in the\n \t     loop.  It also has single back edge to the header\n-\t     from a latch node.  Note that multiple natural loops\n-\t     may share the same header.  */\n-\t  if (latch != ENTRY_BLOCK_PTR && TEST_BIT (dom[latch->index], header->index))\n-\t    num_loops++;\n+\t     from a latch node.  */\n+\t  if (latch != ENTRY_BLOCK_PTR && TEST_BIT (dom[latch->index],\n+\t\t\t\t\t\t    header->index))\n+\t    {\n+\t      /* Shared headers should be eliminated by now.  */\n+\t      if (more_latches)\n+\t\tabort ();\n+\t      more_latches = 1;\n+\t      SET_BIT (headers, header->index);\n+\t      num_loops++;\n+\t    }\n \t}\n     }\n \n+  /* Allocate loop structures.  */\n+  loops->parray = (struct loop **) xcalloc (num_loops + 1, sizeof (struct loop *));\n+\n+  /* Dummy loop containing whole function.  */\n+  loops->parray[0] = xcalloc (1, sizeof (struct loop));\n+  loops->parray[0]->next = NULL;\n+  loops->parray[0]->inner = NULL;\n+  loops->parray[0]->outer = NULL;\n+  loops->parray[0]->depth = 0;\n+  loops->parray[0]->pred = NULL;\n+  loops->parray[0]->num_nodes = n_basic_blocks + 2;\n+  loops->parray[0]->latch = EXIT_BLOCK_PTR;\n+  loops->parray[0]->header = ENTRY_BLOCK_PTR;\n+  ENTRY_BLOCK_PTR->loop_father = loops->parray[0];\n+  EXIT_BLOCK_PTR->loop_father = loops->parray[0];\n+\n+  loops->tree_root = loops->parray[0];\n+\n+  /* Find and record information about all the natural loops\n+     in the CFG.  */\n+  loops->num = 1;\n+  FOR_EACH_BB (bb)\n+    bb->loop_father = loops->tree_root;\n+\n   if (num_loops)\n     {\n       /* Compute depth first search order of the CFG so that outer\n@@ -701,110 +874,65 @@ flow_loops_find (loops, flags)\n       loops->cfg.dfs_order = dfs_order;\n       loops->cfg.rc_order = rc_order;\n \n-      /* Allocate loop structures.  */\n-      loops->array\n-\t= (struct loop *) xcalloc (num_loops, sizeof (struct loop));\n-\n-      headers = sbitmap_alloc (last_basic_block);\n-      sbitmap_zero (headers);\n+      num_loops = 1;\n \n-      loops->shared_headers = sbitmap_alloc (last_basic_block);\n-      sbitmap_zero (loops->shared_headers);\n-\n-      /* Find and record information about all the natural loops\n-\t in the CFG.  */\n-      num_loops = 0;\n-      for (b = n_basic_blocks - 1; b >= 0; b--)\n+      for (b = 0; b < n_basic_blocks; b++)\n \t{\n-\t  basic_block latch;\n+\t  struct loop *loop;\n \n \t  /* Search the nodes of the CFG in reverse completion order\n \t     so that we can find outer loops first.  */\n-\t  latch = BASIC_BLOCK (rc_order[b]);\n+\t  if (!TEST_BIT (headers, rc_order[b]))\n+\t    continue;\n+\n+\t  header = BASIC_BLOCK (rc_order[b]);\n+\t  \n+\t  loop = loops->parray[num_loops] = xcalloc (1, sizeof (struct loop));\n \n-\t  /* Look for all the possible headers for this latch block.  */\n-\t  for (e = latch->succ; e; e = e->succ_next)\n+\t  loop->header = header;\n+\t  loop->num = num_loops;\n+\t  num_loops++;\n+\n+\t  /* Look for the latch for this header block.  */\n+\t  for (e = header->pred; e; e = e->pred_next)\n \t    {\n-\t      basic_block header = e->dest;\n-\n-\t      /* Look for forward edges where this block is dominated by\n-\t\t a successor of this block.  A natural loop has a single\n-\t\t entry node (header) that dominates all the nodes in the\n-\t\t loop.  It also has single back edge to the header from a\n-\t\t latch node.  Note that multiple natural loops may share\n-\t\t the same header.  */\n-\t      if (header != EXIT_BLOCK_PTR\n+\t      basic_block latch = e->src;\n+\n+\t      if (latch != ENTRY_BLOCK_PTR\n \t\t  && TEST_BIT (dom[latch->index], header->index))\n \t\t{\n-\t\t  struct loop *loop;\n-\n-\t\t  loop = loops->array + num_loops;\n-\n-\t\t  loop->header = header;\n \t\t  loop->latch = latch;\n-\t\t  loop->num = num_loops;\n-\n-\t\t  num_loops++;\n+\t\t  break;\n \t\t}\n \t    }\n-\t}\n-\n-      for (i = 0; i < num_loops; i++)\n-\t{\n-\t  struct loop *loop = &loops->array[i];\n-\n-\t  /* Keep track of blocks that are loop headers so\n-\t     that we can tell which loops should be merged.  */\n-\t  if (TEST_BIT (headers, loop->header->index))\n-\t    SET_BIT (loops->shared_headers, loop->header->index);\n-\t  SET_BIT (headers, loop->header->index);\n-\n-\t  /* Find nodes contained within the loop.  */\n-\t  loop->nodes = sbitmap_alloc (last_basic_block);\n-\t  loop->num_nodes\n-\t    = flow_loop_nodes_find (loop->header, loop->latch, loop->nodes);\n-\n-\t  /* Compute first and last blocks within the loop.\n-\t     These are often the same as the loop header and\n-\t     loop latch respectively, but this is not always\n-\t     the case.  */\n-\n-\t  FOR_EACH_BB (bb)\n-\t    if (TEST_BIT (loop->nodes, bb->index))\n-\t      break;\n-\t  loop->first = bb;\n-\n-\t  FOR_EACH_BB_REVERSE (bb)\n-\t    if (TEST_BIT (loop->nodes, bb->index))\n-\t      break;\n-\t  loop->last = bb;\n \n-\t  flow_loop_scan (loops, loop, flags);\n+\t  flow_loop_tree_node_add (header->loop_father, loop);\n+\t  loop->num_nodes = flow_loop_nodes_find (loop->header, loop);\n \t}\n \n-      /* Natural loops with shared headers may either be disjoint or\n-\t nested.  Disjoint loops with shared headers cannot be inner\n-\t loops and should be merged.  For now just mark loops that share\n-\t headers.  */\n-      for (i = 0; i < num_loops; i++)\n-\tif (TEST_BIT (loops->shared_headers, loops->array[i].header->index))\n-\t  loops->array[i].shared = 1;\n-\n       sbitmap_free (headers);\n-    }\n-  else\n-    sbitmap_vector_free (dom);\n \n-  loops->num = num_loops;\n+      /* Assign the loop nesting depth and enclosed loop level for each\n+\t loop.  */\n+      loops->levels = flow_loops_level_compute (loops);\n \n-  /* Build the loop hierarchy tree.  */\n-  flow_loops_tree_build (loops);\n+      /* Scan the loops.  */\n+      for (i = 1; i < num_loops; i++)\n+\tflow_loop_scan (loops, loops->parray[i], flags);\n \n-  /* Assign the loop nesting depth and enclosed loop level for each\n-     loop.  */\n-  loops->levels = flow_loops_level_compute (loops);\n+      loops->num = num_loops;\n+    }\n+  else\n+    {\n+      loops->cfg.dom = NULL;\n+      sbitmap_vector_free (dom);\n+    }\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+  verify_loop_structure (loops, 0);\n+#endif\n \n-  return num_loops;\n+  return loops->num;\n }\n \n /* Update the information regarding the loops in the CFG\n@@ -817,22 +945,259 @@ flow_loops_update (loops, flags)\n {\n   /* One day we may want to update the current loop data.  For now\n      throw away the old stuff and rebuild what we need.  */\n-  if (loops->array)\n+  if (loops->parray)\n     flow_loops_free (loops);\n \n   return flow_loops_find (loops, flags);\n }\n \n+/* Return non-zero if basic block BB belongs to LOOP.  */\n+bool\n+flow_bb_inside_loop_p (loop, bb)\n+     const struct loop *loop;\n+     const basic_block bb;\n+{\n+  struct loop *source_loop;\n+\n+  if (bb == ENTRY_BLOCK_PTR || bb == EXIT_BLOCK_PTR)\n+    return 0;\n+\n+  source_loop = bb->loop_father;\n+  return loop == source_loop || flow_loop_nested_p (loop, source_loop);\n+}\n+\n /* Return non-zero if edge E enters header of LOOP from outside of LOOP.  */\n \n-int\n+bool\n flow_loop_outside_edge_p (loop, e)\n      const struct loop *loop;\n      edge e;\n {\n   if (e->dest != loop->header)\n     abort ();\n+  return !flow_bb_inside_loop_p (loop, e->src);\n+}\n+\n+/* Enumeration predicate for get_loop_body.  */\n+static bool\n+glb_enum_p (bb, glb_header)\n+     basic_block bb;\n+     void *glb_header;\n+{\n+  return bb != (basic_block) glb_header;\n+}\n+\n+/* Gets basic blocks of a loop.  */\n+basic_block *\n+get_loop_body (loop)\n+     const struct loop *loop;\n+{\n+  basic_block *tovisit, bb;\n+  int tv = 0;\n+\n+  if (!loop->num_nodes)\n+    abort ();\n+\n+  tovisit = xcalloc (loop->num_nodes, sizeof (basic_block));\n+  tovisit[tv++] = loop->header;\n+\n+  if (loop->latch == EXIT_BLOCK_PTR)\n+    {\n+      /* There may be blocks unreachable from EXIT_BLOCK.  */\n+      if (loop->num_nodes != n_basic_blocks + 2)\n+\tabort ();\n+      FOR_EACH_BB (bb)\n+\ttovisit[tv++] = bb;\n+      tovisit[tv++] = EXIT_BLOCK_PTR;\n+    }\n+  else if (loop->latch != loop->header)\n+    {\n+      tv = dfs_enumerate_from (loop->latch, 1, glb_enum_p,\n+\t\t\t       tovisit + 1, loop->num_nodes - 1,\n+\t\t\t       loop->header) + 1;\n+    }\n+\n+  if (tv != loop->num_nodes)\n+    abort ();\n+  return tovisit;\n+}\n+\n+/* Adds basic block BB to LOOP.  */\n+void\n+add_bb_to_loop (bb, loop)\n+     basic_block bb;\n+     struct loop *loop;\n+ {\n+   int i;\n+ \n+   bb->loop_father = loop;\n+   bb->loop_depth = loop->depth;\n+   loop->num_nodes++;\n+   for (i = 0; i < loop->depth; i++)\n+     loop->pred[i]->num_nodes++;\n+ }\n+\n+/* Remove basic block BB from loops.  */\n+void\n+remove_bb_from_loops (bb)\n+     basic_block bb;\n+ {\n+   int i;\n+   struct loop *loop = bb->loop_father;\n+\n+   loop->num_nodes--;\n+   for (i = 0; i < loop->depth; i++)\n+     loop->pred[i]->num_nodes--;\n+   bb->loop_father = NULL;\n+   bb->loop_depth = 0;\n+ }\n+\n+/* Finds nearest common ancestor in loop tree for given loops.  */\n+struct loop *\n+find_common_loop (loop_s, loop_d)\n+    struct loop *loop_s;\n+    struct loop *loop_d;\n+{\n+  if (!loop_s) return loop_d;\n+  if (!loop_d) return loop_s;\n+  \n+  if (loop_s->depth < loop_d->depth)\n+    loop_d = loop_d->pred[loop_s->depth];\n+  else if (loop_s->depth > loop_d->depth)\n+    loop_s = loop_s->pred[loop_d->depth];\n+\n+  while (loop_s != loop_d)\n+    {\n+      loop_s = loop_s->outer;\n+      loop_d = loop_d->outer;\n+    }\n+  return loop_s;\n+}\n+\n+/* Checks that LOOPS are allright:\n+     -- sizes of loops are allright\n+     -- results of get_loop_body really belong to the loop\n+     -- loop header have just single entry edge and single latch edge\n+     -- loop latches have only single successor that is header of their loop\n+  */\n+void\n+verify_loop_structure (loops, flags)\n+     struct loops *loops;\n+     int flags;\n+{\n+  int *sizes, i, j;\n+  basic_block *bbs, bb;\n+  struct loop *loop;\n+  int err = 0;\n+\n+  /* Check sizes.  */\n+  sizes = xcalloc (loops->num, sizeof (int));\n+  sizes[0] = 2;\n+\n+  FOR_EACH_BB (bb)\n+    for (loop = bb->loop_father; loop; loop = loop->outer)\n+      sizes[loop->num]++;\n+\n+  for (i = 0; i < loops->num; i++)\n+    {\n+      if (!loops->parray[i])\n+        continue;\n+\n+      if (loops->parray[i]->num_nodes != sizes[i])\n+\t{\n+\t  error (\"Size of loop %d should be %d, not %d.\",\n+\t\t   i, sizes[i], loops->parray[i]->num_nodes);\n+\t  err = 1;\n+\t}\n+    }\n+\n+  free (sizes);\n+\n+  /* Check get_loop_body.  */\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      loop = loops->parray[i];\n+      if (!loop)\n+\tcontinue;\n+      bbs = get_loop_body (loop);\n+\n+      for (j = 0; j < loop->num_nodes; j++)\n+\tif (!flow_bb_inside_loop_p (loop, bbs[j]))\n+\t  {\n+\t    error (\"Bb %d do not belong to loop %d.\",\n+\t\t    bbs[j]->index, i);\n+\t    err = 1;\n+\t  }\n+      free (bbs);\n+    }\n+\n+  /* Check headers and latches.  */\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      loop = loops->parray[i];\n+      if (!loop)\n+\tcontinue;\n+\n+      if ((flags & VLS_EXPECT_PREHEADERS)\n+\t  && (!loop->header->pred->pred_next\n+\t      || loop->header->pred->pred_next->pred_next))\n+\t{\n+\t  error (\"Loop %d's header does not have exactly 2 entries.\", i);\n+\t  err = 1;\n+\t}\n+      if (flags & VLS_EXPECT_SIMPLE_LATCHES)\n+\t{\n+\t  if (!loop->latch->succ\n+\t      || loop->latch->succ->succ_next)\n+\t    {\n+\t      error (\"Loop %d's latch does not have exactly 1 successor.\", i);\n+\t      err = 1;\n+\t    }\n+\t  if (loop->latch->succ->dest != loop->header)\n+\t    {\n+\t      error (\"Loop %d's latch does not have header as successor.\", i);\n+\t      err = 1;\n+\t    }\n+\t  if (loop->latch->loop_father != loop)\n+\t    {\n+\t      error (\"Loop %d's latch does not belong directly to it.\", i);\n+\t      err = 1;\n+\t    }\n+\t}\n+      if (loop->header->loop_father != loop)\n+\t{\n+\t  error (\"Loop %d's header does not belong directly to it.\", i);\n+\t  err = 1;\n+\t}\n+    }\n+\n+  if (err)\n+    abort ();\n+}\n+\n+/* Returns latch edge of LOOP.  */\n+edge\n+loop_latch_edge (loop)\n+     struct loop *loop;\n+{\n+  edge e;\n+\n+  for (e = loop->header->pred; e->src != loop->latch; e = e->pred_next)\n+    continue;\n \n-  return (e->src == ENTRY_BLOCK_PTR)\n-    || ! TEST_BIT (loop->nodes, e->src->index);\n+  return e;\n }\n+\n+/* Returns preheader edge of LOOP.  */\n+edge\n+loop_preheader_edge (loop)\n+     struct loop *loop;\n+{\n+  edge e;\n+\n+  for (e = loop->header->pred; e->src == loop->latch; e = e->pred_next)\n+    continue;\n+\n+  return e;\n+}\n+"}, {"sha": "c00c86409f3147bef98067298b5cd580801055ae", "filename": "gcc/predict.c", "status": "modified", "additions": 52, "deletions": 66, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecfd709c24bcc376504af4317552e7e492c6702/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=2ecfd709c24bcc376504af4317552e7e492c6702", "patch": "@@ -70,7 +70,7 @@ static void combine_predictions_for_insn PARAMS ((rtx, basic_block));\n static void dump_prediction\t\t PARAMS ((enum br_predictor, int,\n \t\t\t\t\t\t  basic_block, int));\n static void estimate_loops_at_level\t PARAMS ((struct loop *loop));\n-static void propagate_freq\t\t PARAMS ((basic_block));\n+static void propagate_freq\t\t PARAMS ((struct loop *));\n static void estimate_bb_frequencies\t PARAMS ((struct loops *));\n static void counts_to_freqs\t\t PARAMS ((void));\n static void process_note_predictions\t PARAMS ((basic_block, int *, int *,\n@@ -419,19 +419,23 @@ estimate_probability (loops_info)\n \n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n-  for (i = 0; i < loops_info->num; i++)\n+  for (i = 1; i < loops_info->num; i++)\n     {\n+      basic_block bb, *bbs;\n+      int j;\n       int exits;\n-      struct loop *loop = &loops_info->array[i];\n+      struct loop *loop = loops_info->parray[i];\n \n       flow_loop_scan (loops_info, loop, LOOP_EXIT_EDGES);\n       exits = loop->num_exits;\n \n-      FOR_BB_BETWEEN (bb, loop->first, loop->last->next_bb, next_bb)\n-\tif (TEST_BIT (loop->nodes, bb->index))\n-\t  {\n-\t    int header_found = 0;\n-\t    edge e;\n+      bbs = get_loop_body (loop);\n+      for (j = 0; j < loop->num_nodes; j++)\n+\t{\n+\t  int header_found = 0;\n+\t  edge e;\n+\n+\t  bb = bbs[j];\n \n \t  /* Bypass loop heuristics on continue statement.  These\n \t     statements construct loops via \"non-loop\" constructs\n@@ -440,28 +444,28 @@ estimate_probability (loops_info)\n \t  if (predicted_by_p (bb, PRED_CONTINUE))\n \t    continue;\n \n-\t    /* Loop branch heuristics - predict an edge back to a\n-\t       loop's head as taken.  */\n-\t    for (e = bb->succ; e; e = e->succ_next)\n-\t      if (e->dest == loop->header\n-\t\t  && e->src == loop->latch)\n-\t\t{\n-\t\t  header_found = 1;\n-\t\t  predict_edge_def (e, PRED_LOOP_BRANCH, TAKEN);\n-\t\t}\n+\t  /* Loop branch heuristics - predict an edge back to a\n+\t     loop's head as taken.  */\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    if (e->dest == loop->header\n+\t\t&& e->src == loop->latch)\n+\t      {\n+\t\theader_found = 1;\n+\t\tpredict_edge_def (e, PRED_LOOP_BRANCH, TAKEN);\n+\t      }\n \n-\t    /* Loop exit heuristics - predict an edge exiting the loop if the\n-\t       conditinal has no loop header successors as not taken.  */\n-\t    if (!header_found)\n-\t      for (e = bb->succ; e; e = e->succ_next)\n-\t\tif (e->dest->index < 0\n-\t\t    || !TEST_BIT (loop->nodes, e->dest->index))\n-\t\t  predict_edge\n-\t\t    (e, PRED_LOOP_EXIT,\n-\t\t     (REG_BR_PROB_BASE\n-\t\t      - predictor_info [(int) PRED_LOOP_EXIT].hitrate)\n-\t\t     / exits);\n-\t  }\n+\t  /* Loop exit heuristics - predict an edge exiting the loop if the\n+\t     conditinal has no loop header successors as not taken.  */\n+\t  if (!header_found)\n+\t    for (e = bb->succ; e; e = e->succ_next)\n+\t      if (e->dest->index < 0\n+\t\t  || !flow_bb_inside_loop_p (loop, e->dest))\n+\t\tpredict_edge\n+\t\t  (e, PRED_LOOP_EXIT,\n+\t\t   (REG_BR_PROB_BASE\n+\t\t    - predictor_info [(int) PRED_LOOP_EXIT].hitrate)\n+\t\t   / exits);\n+\t}\n     }\n \n   /* Attempt to predict conditional jumps using a number of heuristics.  */\n@@ -896,12 +900,13 @@ typedef struct edge_info_def\n #define EDGE_INFO(E)\t((edge_info) (E)->aux)\n \n /* Helper function for estimate_bb_frequencies.\n-   Propagate the frequencies for loops headed by HEAD.  */\n+   Propagate the frequencies for LOOP.  */\n \n static void\n-propagate_freq (head)\n-     basic_block head;\n+propagate_freq (loop)\n+     struct loop *loop;\n {\n+  basic_block head = loop->header;\n   basic_block bb;\n   basic_block last;\n   edge e;\n@@ -1028,41 +1033,28 @@ static void\n estimate_loops_at_level (first_loop)\n      struct loop *first_loop;\n {\n-  struct loop *l, *loop = first_loop;\n+  struct loop *loop;\n \n   for (loop = first_loop; loop; loop = loop->next)\n     {\n-      int n;\n       edge e;\n+      basic_block *bbs;\n+      int i;\n \n       estimate_loops_at_level (loop->inner);\n-\n-      /* Find current loop back edge and mark it.  */\n-      for (e = loop->latch->succ; e->dest != loop->header; e = e->succ_next)\n-\t;\n-\n-      EDGE_INFO (e)->back_edge = 1;\n-\n-      /* In case the loop header is shared, ensure that it is the last\n-\t one sharing the same header, so we avoid redundant work.  */\n-      if (loop->shared)\n+      \n+      if (loop->latch->succ)  /* Do not do this for dummy function loop.  */\n \t{\n-\t  for (l = loop->next; l; l = l->next)\n-\t    if (l->header == loop->header)\n-\t      break;\n-\n-\t  if (l)\n-\t    continue;\n-\t}\n-\n-      /* Now merge all nodes of all loops with given header as not visited.  */\n-      for (l = loop->shared ? first_loop : loop; l != loop->next; l = l->next)\n-\tif (loop->header == l->header)\n-\t  EXECUTE_IF_SET_IN_SBITMAP (l->nodes, 0, n,\n-\t\t\t\t     BLOCK_INFO (BASIC_BLOCK (n))->tovisit = 1\n-\t\t\t\t     );\n-\n-      propagate_freq (loop->header);\n+\t  /* Find current loop back edge and mark it.  */\n+\t  e = loop_latch_edge (loop);\n+\t  EDGE_INFO (e)->back_edge = 1;\n+       }\n+\n+      bbs = get_loop_body (loop);\n+      for (i = 0; i < loop->num_nodes; i++)\n+\tBLOCK_INFO (bbs[i])->tovisit = 1;\n+      free (bbs);\n+      propagate_freq (loop);\n     }\n }\n \n@@ -1202,12 +1194,6 @@ estimate_bb_frequencies (loops)\n          to outermost to examine probabilities for back edges.  */\n       estimate_loops_at_level (loops->tree_root);\n \n-      /* Now fake loop around whole function to finalize probabilities.  */\n-      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-\tBLOCK_INFO (bb)->tovisit = 1;\n-\n-      propagate_freq (ENTRY_BLOCK_PTR);\n-\n       memcpy (&freq_max, &real_zero, sizeof (real_zero));\n       FOR_EACH_BB (bb)\n \tif (REAL_VALUES_LESS"}]}