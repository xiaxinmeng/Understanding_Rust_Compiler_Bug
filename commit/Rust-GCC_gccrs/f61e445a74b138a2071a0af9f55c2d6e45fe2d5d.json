{"sha": "f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYxZTQ0NWE3NGIxMzhhMjA3MWEwYWY5ZjU1YzJkNmU0NWZlMmQ1ZA==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2012-10-30T00:02:55Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2012-10-30T00:02:55Z"}, "message": "This patch implements the unification of the *bitmap interfaces as discussed.\n\nEssentially, we rename ebitmap and sbitmap functions to use the same names\nas the bitmap functions.  This rename works because we can now overload\non the bitmap type.  Some macros now become inline functions to enable\nthat overloading.\n\nThe sbitmap non-bool returning bitwise operations have been merged with\nthe bool versions.  Sometimes this merge involved modifying the non-bool\nversion to compute the bool value, and sometimes modifying bool version to\nadd additional work from the non-bool version.  The redundant routines have\nbeen removed.\n\nThe allocation functions have not been renamed, because we often do not\nhave an argument on which to overload.  The cardinality functions have not\nbeen renamed, because they have different parameters, and are thus not\ninterchangable.  The iteration functions have not been renamed, because\nthey are functionally different.\n\nTested on x86_64, contrib/config-list.mk testing passed.\n\n\nIndex: gcc/ChangeLog\n\n2012-10-29  Lawrence Crowl  <crowl@google.com>\n\n\t* sbitmap.h (sbitmap_copy): Rename bitmap_copy.\n\t(sbitmap_copy_n): Rename bitmap_copy_n.\n\t(sbitmap_equal): Rename bitmap_equal_p.\n\t(sbitmap_empty_p): Rename bitmap_empty_p.\n\t(sbitmap_range_empty_p): Rename bitmap_range_empty_p.\n\t(sbitmap_zero): Rename bitmap_clear.\n\t(sbitmap_ones): Rename bitmap_ones.\n\t(sbitmap_vector_zero): Rename bitmap_vector_clear.\n\t(sbitmap_vector_ones): Rename bitmap_vector_ones.\n\t(sbitmap_not): Rename bitmap_not.\n\t(sbitmap_a_and_b_cg): Commented out.\n\t(sbitmap_a_and_b): Rename bitmap_and.  Add bool return.\n\t(sbitmap_difference): Rename bitmap_and_compl.\n\t(sbitmap_a_or_b_cg): Commented out.\n\t(sbitmap_a_or_b): Rename bitmap_xor.  Add bool return.\n\t(sbitmap_a_xor_b_cg): Commented out.\n\t(sbitmap_a_xor_b): Rename bitmap_xor.  Add bool return.\n\t(sbitmap_a_and_b_or_c_cg): Rename bitmap_and_or.\n\t(sbitmap_a_and_b_or_c): Commented out.\n\t(sbitmap_a_or_b_and_c_cg): Rename bitmap_or_and.\n\t(sbitmap_a_or_b_and_c): Commented out.\n\t(sbitmap_union_of_diff_cg): Rename bitmap_ior_and_compl.\n\t(sbitmap_union_of_diff): Commented out.\n\t(dump_sbitmap): Rename dump_bitmap.\n\t(dump_sbitmap_file): Rename dump_bitmap_file.\n\t(debug_sbitmap): Rename debug_bitmap.\n\t(dump_sbitmap_vector): Rename dump_bitmap_vector.\n\t(sbitmap_first_set_bit): Rename bitmap_first_set_bit.\n\t(sbitmap_last_set_bit): Rename bitmap_last_set_bit.\n\t(sbitmap_a_subset_b_p): Rename bitmap_subset_p.\n\t(sbitmap_any_common_bits): Rename bitmap_intersect_p.\n\t(#define sbitmap_free): Reimplement as inline function.\n\t(#define sbitmap_vector_free): Reimplement as inline function.\n\t* bitmap.h (#define bitmap_zero): Remove as redundant.\n\t(#define bitmap_empty_p): Reimplement as inline function.\n\t(#define dump_bitmap): Reimplement as inline function.\n\nFrom-SVN: r192969", "tree": {"sha": "1ab800d2373b19aaee52a26a91b2c67b2657101e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ab800d2373b19aaee52a26a91b2c67b2657101e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/comments", "author": null, "committer": null, "parents": [{"sha": "880661a48b6e2f3f4b3c05860d3c9737b2a1dcc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880661a48b6e2f3f4b3c05860d3c9737b2a1dcc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/880661a48b6e2f3f4b3c05860d3c9737b2a1dcc8"}], "stats": {"total": 1168, "additions": 562, "deletions": 606}, "files": [{"sha": "4ad17e712bd788ab8afe43b97bea2af5861d65a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1,3 +1,42 @@\n+2012-10-29  Lawrence Crowl  <crowl@google.com>\n+\n+\t* sbitmap.h (sbitmap_copy): Rename bitmap_copy.\n+\t(sbitmap_copy_n): Rename bitmap_copy_n.\n+\t(sbitmap_equal): Rename bitmap_equal_p.\n+\t(sbitmap_empty_p): Rename bitmap_empty_p.\n+\t(sbitmap_range_empty_p): Rename bitmap_range_empty_p.\n+\t(sbitmap_zero): Rename bitmap_clear.\n+\t(sbitmap_ones): Rename bitmap_ones.\n+\t(sbitmap_vector_zero): Rename bitmap_vector_clear.\n+\t(sbitmap_vector_ones): Rename bitmap_vector_ones.\n+\t(sbitmap_not): Rename bitmap_not.\n+\t(sbitmap_a_and_b_cg): Commented out.\n+\t(sbitmap_a_and_b): Rename bitmap_and.  Add bool return.\n+\t(sbitmap_difference): Rename bitmap_and_compl.\n+\t(sbitmap_a_or_b_cg): Commented out.\n+\t(sbitmap_a_or_b): Rename bitmap_xor.  Add bool return.\n+\t(sbitmap_a_xor_b_cg): Commented out.\n+\t(sbitmap_a_xor_b): Rename bitmap_xor.  Add bool return.\n+\t(sbitmap_a_and_b_or_c_cg): Rename bitmap_and_or.\n+\t(sbitmap_a_and_b_or_c): Commented out.\n+\t(sbitmap_a_or_b_and_c_cg): Rename bitmap_or_and.\n+\t(sbitmap_a_or_b_and_c): Commented out.\n+\t(sbitmap_union_of_diff_cg): Rename bitmap_ior_and_compl.\n+\t(sbitmap_union_of_diff): Commented out.\n+\t(dump_sbitmap): Rename dump_bitmap.\n+\t(dump_sbitmap_file): Rename dump_bitmap_file.\n+\t(debug_sbitmap): Rename debug_bitmap.\n+\t(dump_sbitmap_vector): Rename dump_bitmap_vector.\n+\t(sbitmap_first_set_bit): Rename bitmap_first_set_bit.\n+\t(sbitmap_last_set_bit): Rename bitmap_last_set_bit.\n+\t(sbitmap_a_subset_b_p): Rename bitmap_subset_p.\n+\t(sbitmap_any_common_bits): Rename bitmap_intersect_p.\n+\t(#define sbitmap_free): Reimplement as inline function.\n+\t(#define sbitmap_vector_free): Reimplement as inline function.\n+\t* bitmap.h (#define bitmap_zero): Remove as redundant.\n+\t(#define bitmap_empty_p): Reimplement as inline function.\n+\t(#define dump_bitmap): Reimplement as inline function.\n+\n 2012-10-29  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR c++/54930"}, {"sha": "af482eecc660e1e3d8af3f135f053d70ee329d8d", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -2869,7 +2869,7 @@ init_alias_analysis (void)\n       memset (new_reg_base_value, 0, maxreg * sizeof (rtx));\n \n       /* Wipe the reg_seen array clean.  */\n-      sbitmap_zero (reg_seen);\n+      bitmap_clear (reg_seen);\n \n       /* Mark all hard registers which may contain an address.\n \t The stack, frame and argument pointers may contain an address."}, {"sha": "7ed5d745d1e329def9f70c061144be0868bfcb7a", "filename": "gcc/bitmap.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -211,7 +211,10 @@ extern bool bitmap_intersect_p (const_bitmap, const_bitmap);\n extern bool bitmap_intersect_compl_p (const_bitmap, const_bitmap);\n \n /* True if MAP is an empty bitmap.  */\n-#define bitmap_empty_p(MAP) (!(MAP)->first)\n+inline bool bitmap_empty_p (const_bitmap map)\n+{\n+  return !map->first;\n+}\n \n /* True if the bitmap has only a single bit set.  */\n extern bool bitmap_single_bit_set_p (const_bitmap);\n@@ -288,8 +291,11 @@ extern bitmap bitmap_gc_alloc_stat (ALONE_MEM_STAT_DECL);\n extern void bitmap_obstack_free (bitmap);\n \n /* A few compatibility/functions macros for compatibility with sbitmaps */\n-#define dump_bitmap(file, bitmap) bitmap_print (file, bitmap, \"\", \"\\n\")\n-#define bitmap_zero(a) bitmap_clear (a)\n+inline void dump_bitmap (FILE *file, const_bitmap map)\n+{\n+  bitmap_print (file, map, \"\", \"\\n\");\n+}\n+\n extern unsigned bitmap_first_set_bit (const_bitmap);\n extern unsigned bitmap_last_set_bit (const_bitmap);\n "}, {"sha": "2aeb1c0f023d5b123e0ba899d1206dff0f991269", "filename": "gcc/bt-load.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -436,7 +436,7 @@ note_btr_set (rtx dest, const_rtx set ATTRIBUTE_UNUSED, void *data)\n \tnote_other_use_this_block (regno, info->users_this_bb);\n \tSET_HARD_REG_BIT (info->btrs_written_in_block, regno);\n \tSET_HARD_REG_BIT (info->btrs_live_in_block, regno);\n-\tsbitmap_difference (info->bb_gen, info->bb_gen,\n+\tbitmap_and_compl (info->bb_gen, info->bb_gen,\n \t\t\t    info->btr_defset[regno - first_btr]);\n       }\n }\n@@ -457,7 +457,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n   btr_def_group all_btr_def_groups = NULL;\n   defs_uses_info info;\n \n-  sbitmap_vector_zero (bb_gen, last_basic_block);\n+  bitmap_vector_clear (bb_gen, last_basic_block);\n   for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n@@ -497,7 +497,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t\t  def_array[insn_uid] = def;\n \t\t  SET_HARD_REG_BIT (info.btrs_written_in_block, regno);\n \t\t  SET_HARD_REG_BIT (info.btrs_live_in_block, regno);\n-\t\t  sbitmap_difference (bb_gen[i], bb_gen[i],\n+\t\t  bitmap_and_compl (bb_gen[i], bb_gen[i],\n \t\t\t\t      btr_defset[regno - first_btr]);\n \t\t  SET_BIT (bb_gen[i], insn_uid);\n \t\t  def->next_this_bb = defs_this_bb;\n@@ -519,7 +519,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t\t      user->other_use_this_block = 1;\n \t\t  IOR_HARD_REG_SET (info.btrs_written_in_block, all_btrs);\n \t\t  IOR_HARD_REG_SET (info.btrs_live_in_block, all_btrs);\n-\t\t  sbitmap_zero (info.bb_gen);\n+\t\t  bitmap_clear (info.bb_gen);\n \t\t}\n \t      else\n \t\t{\n@@ -618,13 +618,13 @@ compute_kill (sbitmap *bb_kill, sbitmap *btr_defset,\n \n   /* For each basic block, form the set BB_KILL - the set\n      of definitions that the block kills.  */\n-  sbitmap_vector_zero (bb_kill, last_basic_block);\n+  bitmap_vector_clear (bb_kill, last_basic_block);\n   for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n     {\n       for (regno = first_btr; regno <= last_btr; regno++)\n \tif (TEST_HARD_REG_BIT (all_btrs, regno)\n \t    && TEST_HARD_REG_BIT (btrs_written[i], regno))\n-\t  sbitmap_a_or_b (bb_kill[i], bb_kill[i],\n+\t  bitmap_ior (bb_kill[i], bb_kill[i],\n \t\t\t  btr_defset[regno - first_btr]);\n     }\n }\n@@ -643,7 +643,7 @@ compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n   sbitmap bb_in = sbitmap_alloc (max_uid);\n \n   for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n-    sbitmap_copy (bb_out[i], bb_gen[i]);\n+    bitmap_copy (bb_out[i], bb_gen[i]);\n \n   changed = 1;\n   while (changed)\n@@ -652,7 +652,7 @@ compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n       for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n \t{\n \t  sbitmap_union_of_preds (bb_in, bb_out, BASIC_BLOCK (i));\n-\t  changed |= sbitmap_union_of_diff_cg (bb_out[i], bb_gen[i],\n+\t  changed |= bitmap_ior_and_compl (bb_out[i], bb_gen[i],\n \t\t\t\t\t       bb_in, bb_kill[i]);\n \t}\n     }\n@@ -689,7 +689,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t{\n \t\t  /* Remove all reaching defs of regno except\n \t\t     for this one.  */\n-\t\t  sbitmap_difference (reaching_defs, reaching_defs,\n+\t\t  bitmap_and_compl (reaching_defs, reaching_defs,\n \t\t\t\t      btr_defset[def->btr - first_btr]);\n \t\t  SET_BIT(reaching_defs, insn_uid);\n \t\t}\n@@ -702,20 +702,20 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t  sbitmap_iterator sbi;\n \n \t\t  if (user->use)\n-\t\t    sbitmap_a_and_b (\n+\t\t    bitmap_and (\n \t\t      reaching_defs_of_reg,\n \t\t      reaching_defs,\n \t\t      btr_defset[REGNO (user->use) - first_btr]);\n \t\t  else\n \t\t    {\n \t\t      int reg;\n \n-\t\t      sbitmap_zero (reaching_defs_of_reg);\n+\t\t      bitmap_clear (reaching_defs_of_reg);\n \t\t      for (reg = first_btr; reg <= last_btr; reg++)\n \t\t\tif (TEST_HARD_REG_BIT (all_btrs, reg)\n \t\t\t    && refers_to_regno_p (reg, reg + 1, user->insn,\n \t\t\t\t\t\t  NULL))\n-\t\t\t  sbitmap_a_or_b_and_c (reaching_defs_of_reg,\n+\t\t\t  bitmap_or_and (reaching_defs_of_reg,\n \t\t\t    reaching_defs_of_reg,\n \t\t\t    reaching_defs,\n \t\t\t    btr_defset[reg - first_btr]);\n@@ -763,7 +763,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t  for (regno = first_btr; regno <= last_btr; regno++)\n \t\t    if (TEST_HARD_REG_BIT (all_btrs, regno)\n \t\t\t&& TEST_HARD_REG_BIT (call_used_reg_set, regno))\n-\t\t      sbitmap_difference (reaching_defs, reaching_defs,\n+\t\t      bitmap_and_compl (reaching_defs, reaching_defs,\n \t\t\t\t\t  btr_defset[regno - first_btr]);\n \t\t}\n \t    }\n@@ -785,7 +785,7 @@ build_btr_def_use_webs (fibheap_t all_btr_defs)\n   sbitmap *bb_kill;\n   sbitmap *bb_out;\n \n-  sbitmap_vector_zero (btr_defset, (last_btr - first_btr) + 1);\n+  bitmap_vector_clear (btr_defset, (last_btr - first_btr) + 1);\n \n   compute_defs_uses_and_gen (all_btr_defs, def_array, use_array, btr_defset,\n \t\t\t     bb_gen, btrs_written);"}, {"sha": "fb520c6906cadd75aeb6a9e5783ef08946382761", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1822,7 +1822,7 @@ mem_overlaps_already_clobbered_arg_p (rtx addr, unsigned HOST_WIDE_INT size)\n   HOST_WIDE_INT i;\n   rtx val;\n \n-  if (sbitmap_empty_p (stored_args_map))\n+  if (bitmap_empty_p (stored_args_map))\n     return false;\n   val = internal_arg_pointer_based_exp (addr, true);\n   if (val == NULL_RTX)\n@@ -2749,7 +2749,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t    = plus_constant (Pmode, argblock, -crtl->args.pretend_args_size);\n #endif\n \t  stored_args_map = sbitmap_alloc (args_size.constant);\n-\t  sbitmap_zero (stored_args_map);\n+\t  bitmap_clear (stored_args_map);\n \t}\n \n       /* If we have no actual push instructions, or shouldn't use them,"}, {"sha": "58c763f845457f52fcef6d13680ef8973cd70442", "filename": "gcc/cfganal.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -84,7 +84,7 @@ mark_dfs_back_edges (void)\n   visited = sbitmap_alloc (last_basic_block);\n \n   /* None of the nodes in the CFG have been visited yet.  */\n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n \n   /* Push the first edge on to the stack.  */\n   stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n@@ -501,7 +501,7 @@ post_order_compute (int *post_order, bool include_entry_exit,\n   visited = sbitmap_alloc (last_basic_block);\n \n   /* None of the nodes in the CFG have been visited yet.  */\n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n \n   /* Push the first edge on to the stack.  */\n   stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n@@ -597,7 +597,7 @@ static basic_block\n dfs_find_deadend (basic_block bb)\n {\n   sbitmap visited = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n \n   for (;;)\n     {\n@@ -654,7 +654,7 @@ inverted_post_order_compute (int *post_order)\n   visited = sbitmap_alloc (last_basic_block);\n \n   /* None of the nodes in the CFG have been visited yet.  */\n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n \n   /* Put all blocks that have no successor into the initial work list.  */\n   FOR_ALL_BB (bb)\n@@ -803,7 +803,7 @@ pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order,\n   visited = sbitmap_alloc (last_basic_block);\n \n   /* None of the nodes in the CFG have been visited yet.  */\n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n \n   /* Push the first edge on to the stack.  */\n   stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n@@ -916,7 +916,7 @@ flow_dfs_compute_reverse_init (depth_first_search_ds data)\n   data->visited_blocks = sbitmap_alloc (last_basic_block);\n \n   /* None of the nodes in the CFG have been visited yet.  */\n-  sbitmap_zero (data->visited_blocks);\n+  bitmap_clear (data->visited_blocks);\n \n   return;\n }\n@@ -1006,7 +1006,7 @@ dfs_enumerate_from (basic_block bb, int reverse,\n     {\n \n       visited = sbitmap_alloc (size);\n-      sbitmap_zero (visited);\n+      bitmap_clear (visited);\n       v_size = size;\n     }\n   else if (v_size < size)\n@@ -1208,12 +1208,12 @@ sbitmap_intersection_of_succs (sbitmap dst, sbitmap *src,\n       if (e->dest == EXIT_BLOCK_PTR)\n \tcontinue;\n \n-      sbitmap_copy (dst, src[e->dest->index]);\n+      bitmap_copy (dst, src[e->dest->index]);\n       break;\n     }\n \n   if (e == 0)\n-    sbitmap_ones (dst);\n+    bitmap_ones (dst);\n   else\n     for (++ix; ix < EDGE_COUNT (b->succs); ix++)\n       {\n@@ -1250,12 +1250,12 @@ sbitmap_intersection_of_preds (sbitmap dst, sbitmap *src,\n       if (e->src == ENTRY_BLOCK_PTR)\n \tcontinue;\n \n-      sbitmap_copy (dst, src[e->src->index]);\n+      bitmap_copy (dst, src[e->src->index]);\n       break;\n     }\n \n   if (e == 0)\n-    sbitmap_ones (dst);\n+    bitmap_ones (dst);\n   else\n     for (++ix; ix < EDGE_COUNT (b->preds); ix++)\n       {\n@@ -1292,12 +1292,12 @@ sbitmap_union_of_succs (sbitmap dst, sbitmap *src,\n       if (e->dest == EXIT_BLOCK_PTR)\n \tcontinue;\n \n-      sbitmap_copy (dst, src[e->dest->index]);\n+      bitmap_copy (dst, src[e->dest->index]);\n       break;\n     }\n \n   if (ix == EDGE_COUNT (b->succs))\n-    sbitmap_zero (dst);\n+    bitmap_clear (dst);\n   else\n     for (ix++; ix < EDGE_COUNT (b->succs); ix++)\n       {\n@@ -1334,12 +1334,12 @@ sbitmap_union_of_preds (sbitmap dst, sbitmap *src,\n       if (e->src== ENTRY_BLOCK_PTR)\n \tcontinue;\n \n-      sbitmap_copy (dst, src[e->src->index]);\n+      bitmap_copy (dst, src[e->src->index]);\n       break;\n     }\n \n   if (ix == EDGE_COUNT (b->preds))\n-    sbitmap_zero (dst);\n+    bitmap_clear (dst);\n   else\n     for (ix++; ix < EDGE_COUNT (b->preds); ix++)\n       {"}, {"sha": "09dad6fa467657de818e7d0792cc64676b927a3b", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -236,7 +236,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n       /* If we have an edge cache, cache edges going out of BB.  */\n       if (edge_cache)\n \t{\n-\t  sbitmap_zero (edge_cache);\n+\t  bitmap_clear (edge_cache);\n \t  if (update_p)\n \t    {\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -385,7 +385,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n     }\n \n   if (edge_cache)\n-    sbitmap_vector_free (edge_cache);\n+    sbitmap_free (edge_cache);\n }\n \f\n static void"}, {"sha": "5c06c1f2eff0062a2e85bb97c82409249d1d4ec0", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -4581,7 +4581,7 @@ gimple_expand_cfg (void)\n     }\n \n   blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_ones (blocks);\n+  bitmap_ones (blocks);\n   find_many_sub_basic_blocks (blocks);\n   sbitmap_free (blocks);\n   purge_all_dead_edges ();"}, {"sha": "83ac28d5713c6cfd1dbda9d155ddbb0cb6c2daaf", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -393,7 +393,7 @@ flow_loops_find (struct loops *loops)\n   /* Count the number of loop headers.  This should be the\n      same as the number of natural loops.  */\n   headers = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (headers);\n+  bitmap_clear (headers);\n \n   num_loops = 0;\n   FOR_EACH_BB (header)\n@@ -1351,7 +1351,7 @@ verify_loop_structure (void)\n \t  }\n       free (bbs);\n     }\n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n   FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n       bbs = get_loop_body (loop);"}, {"sha": "713a2ef5da7de165ee0e8f78cce01a28f177600d", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -190,7 +190,7 @@ fix_bb_placements (basic_block from,\n     return;\n \n   in_queue = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (in_queue);\n+  bitmap_clear (in_queue);\n   SET_BIT (in_queue, from->index);\n   /* Prevent us from going out of the base_loop.  */\n   SET_BIT (in_queue, base_loop->header->index);\n@@ -327,7 +327,7 @@ remove_path (edge e)\n   n_bord_bbs = 0;\n   bord_bbs = XNEWVEC (basic_block, n_basic_blocks);\n   seen = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (seen);\n+  bitmap_clear (seen);\n \n   /* Find \"border\" hexes -- i.e. those with predecessor in removed path.  */\n   for (i = 0; i < nrem; i++)\n@@ -365,7 +365,7 @@ remove_path (edge e)\n   free (rem_bbs);\n \n   /* Find blocks whose dominators may be affected.  */\n-  sbitmap_zero (seen);\n+  bitmap_clear (seen);\n   for (i = 0; i < n_bord_bbs; i++)\n     {\n       basic_block ldom;\n@@ -594,7 +594,7 @@ update_dominators_in_loop (struct loop *loop)\n   unsigned i;\n \n   seen = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (seen);\n+  bitmap_clear (seen);\n   body = get_loop_body (loop);\n \n   for (i = 0; i < loop->num_nodes; i++)"}, {"sha": "5eec5e05f4be4f04c12a953dc9b674a4d36dbad4", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -3725,7 +3725,7 @@ break_superblocks (void)\n   basic_block bb;\n \n   superblocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (superblocks);\n+  bitmap_clear (superblocks);\n \n   FOR_EACH_BB (bb)\n     if (bb->flags & BB_SUPERBLOCK)"}, {"sha": "14c64d44cbe23cc1c37e9614867276dd5a2b8f1a", "filename": "gcc/config/epiphany/resolve-sw-modes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -63,7 +63,7 @@ resolve_sw_modes (void)\n \n   todo = VEC_alloc (basic_block, heap, last_basic_block);\n   pushed = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (pushed);\n+  bitmap_clear (pushed);\n   if (!finalize_fp_sets)\n     {\n       df_note_add_problem ();"}, {"sha": "7fbf3a73ad225c979ddab7b5a61649ef7ad1f99a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -401,10 +401,10 @@ move_or_delete_vzeroupper (void)\n   visited = sbitmap_alloc (last_basic_block);\n   in_worklist = sbitmap_alloc (last_basic_block);\n   in_pending = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (in_worklist);\n+  bitmap_clear (in_worklist);\n \n   /* Don't check outgoing edges of entry point.  */\n-  sbitmap_ones (in_pending);\n+  bitmap_ones (in_pending);\n   FOR_EACH_BB (bb)\n     if (BLOCK_INFO (bb)->processed)\n       RESET_BIT (in_pending, bb->index);\n@@ -426,7 +426,7 @@ move_or_delete_vzeroupper (void)\n       in_pending = in_worklist;\n       in_worklist = sbitmap_swap;\n \n-      sbitmap_zero (visited);\n+      bitmap_clear (visited);\n \n       cfun->machine->rescan_vzeroupper_p = 0;\n \n@@ -24783,7 +24783,7 @@ core2i7_first_cycle_multipass_issue (void *_data, char *ready_try, int n_ready,\n \t\t\t\t\t       n_ready, 0);\n       data->ready_try_change_size = n_ready;\n     }\n-  sbitmap_zero (data->ready_try_change);\n+  bitmap_clear (data->ready_try_change);\n \n   /* Filter out insns from ready_try that the core will not be able to issue\n      on current cycle due to decoder.  */\n@@ -24802,7 +24802,7 @@ core2i7_first_cycle_multipass_backtrack (const void *_data,\n   unsigned int i = 0;\n   sbitmap_iterator sbi;\n \n-  gcc_assert (sbitmap_last_set_bit (data->ready_try_change) < n_ready);\n+  gcc_assert (bitmap_last_set_bit (data->ready_try_change) < n_ready);\n   EXECUTE_IF_SET_IN_SBITMAP (data->ready_try_change, 0, i, sbi)\n     {\n       ready_try[i] = 0;"}, {"sha": "cc90e06b0674a4fa15eda9cf960c9fb02e94f5cc", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -14828,7 +14828,7 @@ r10k_insert_cache_barriers (void)\n   /* Bit X of PROTECTED_BBS is set if the last operation in basic block\n      X is protected by a cache barrier.  */\n   protected_bbs = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (protected_bbs);\n+  bitmap_clear (protected_bbs);\n \n   /* Iterate over the basic blocks in reverse post-order.  */\n   rev_post_order = XNEWVEC (int, last_basic_block);"}, {"sha": "720cc0299b9b76f5408b6bbd854653ff09e92258", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -2454,7 +2454,7 @@ spu_machine_dependent_reorg (void)\n     }\n \n   blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (blocks);\n+  bitmap_clear (blocks);\n \n   in_spu_reorg = 1;\n   compute_bb_for_insn ();\n@@ -2625,7 +2625,7 @@ spu_machine_dependent_reorg (void)\n     }\n   free (spu_bb_info);\n \n-  if (!sbitmap_empty_p (blocks))\n+  if (!bitmap_empty_p (blocks))\n     find_many_sub_basic_blocks (blocks);\n \n   /* We have to schedule to make sure alignment is ok. */"}, {"sha": "e90a13ca8781f313417d9796975aab37f8407fbd", "filename": "gcc/cprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -600,8 +600,8 @@ compute_local_properties (sbitmap *kill, sbitmap *comp,\n   unsigned int i;\n \n   /* Initialize the bitmaps that were passed in.  */\n-  sbitmap_vector_zero (kill, last_basic_block);\n-  sbitmap_vector_zero (comp, last_basic_block);\n+  bitmap_vector_clear (kill, last_basic_block);\n+  bitmap_vector_clear (comp, last_basic_block);\n \n   for (i = 0; i < table->size; i++)\n     {"}, {"sha": "c7a75eae45447aff8a8b4951756fb109e6c692ff", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -6546,7 +6546,7 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n \n   /* Set up the table of already visited basic blocks.  */\n   cse_visited_basic_blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (cse_visited_basic_blocks);\n+  bitmap_clear (cse_visited_basic_blocks);\n \n   /* Loop over basic blocks in reverse completion order (RPO),\n      excluding the ENTRY and EXIT blocks.  */"}, {"sha": "4c088a48fa497c646d5a3b912d4419d1f58d51cb", "filename": "gcc/dce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -724,7 +724,7 @@ init_dce (bool fast)\n     can_alter_cfg = true;\n \n   marked = sbitmap_alloc (get_max_uid () + 1);\n-  sbitmap_zero (marked);\n+  bitmap_clear (marked);\n }\n \n \n@@ -1082,7 +1082,7 @@ fast_dce (bool word_level)\n \t  /* So something was deleted that requires a redo.  Do it on\n \t     the cheap.  */\n \t  delete_unmarked_insns ();\n-\t  sbitmap_zero (marked);\n+\t  bitmap_clear (marked);\n \t  bitmap_clear (processed);\n \t  bitmap_clear (redo_out);\n "}, {"sha": "8fcb98263bbc34c430d00f627c3fdd897e94484b", "filename": "gcc/ddg.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -660,9 +660,9 @@ create_ddg (basic_block bb, int closing_branch_deps)\n \n       g->nodes[i].cuid = i;\n       g->nodes[i].successors = sbitmap_alloc (num_nodes);\n-      sbitmap_zero (g->nodes[i].successors);\n+      bitmap_clear (g->nodes[i].successors);\n       g->nodes[i].predecessors = sbitmap_alloc (num_nodes);\n-      sbitmap_zero (g->nodes[i].predecessors);\n+      bitmap_clear (g->nodes[i].predecessors);\n       g->nodes[i].first_note = (first_note ? first_note : insn);\n       g->nodes[i++].insn = insn;\n       first_note = NULL_RTX;\n@@ -890,7 +890,7 @@ create_scc (ddg_ptr g, sbitmap nodes)\n   scc->backarcs = NULL;\n   scc->num_backarcs = 0;\n   scc->nodes = sbitmap_alloc (g->num_nodes);\n-  sbitmap_copy (scc->nodes, nodes);\n+  bitmap_copy (scc->nodes, nodes);\n \n   /* Mark the backarcs that belong to this SCC.  */\n   EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, u, sbi)\n@@ -980,11 +980,11 @@ find_successors (sbitmap succ, ddg_ptr g, sbitmap ops)\n   EXECUTE_IF_SET_IN_SBITMAP (ops, 0, i, sbi)\n     {\n       const sbitmap node_succ = NODE_SUCCESSORS (&g->nodes[i]);\n-      sbitmap_a_or_b (succ, succ, node_succ);\n+      bitmap_ior (succ, succ, node_succ);\n     };\n \n   /* We want those that are not in ops.  */\n-  sbitmap_difference (succ, succ, ops);\n+  bitmap_and_compl (succ, succ, ops);\n }\n \n /* Given a set OPS of nodes in the DDG, find the set of their predecessors\n@@ -999,11 +999,11 @@ find_predecessors (sbitmap preds, ddg_ptr g, sbitmap ops)\n   EXECUTE_IF_SET_IN_SBITMAP (ops, 0, i, sbi)\n     {\n       const sbitmap node_preds = NODE_PREDECESSORS (&g->nodes[i]);\n-      sbitmap_a_or_b (preds, preds, node_preds);\n+      bitmap_ior (preds, preds, node_preds);\n     };\n \n   /* We want those that are not in ops.  */\n-  sbitmap_difference (preds, preds, ops);\n+  bitmap_and_compl (preds, preds, ops);\n }\n \n \n@@ -1035,14 +1035,14 @@ check_sccs (ddg_all_sccs_ptr sccs, int num_nodes)\n   int i = 0;\n   sbitmap tmp = sbitmap_alloc (num_nodes);\n \n-  sbitmap_zero (tmp);\n+  bitmap_clear (tmp);\n   for (i = 0; i < sccs->num_sccs; i++)\n     {\n-      gcc_assert (!sbitmap_empty_p (sccs->sccs[i]->nodes));\n+      gcc_assert (!bitmap_empty_p (sccs->sccs[i]->nodes));\n       /* Verify that every node in sccs is in exactly one strongly\n          connected component.  */\n-      gcc_assert (!sbitmap_any_common_bits (tmp, sccs->sccs[i]->nodes));\n-      sbitmap_a_or_b (tmp, tmp, sccs->sccs[i]->nodes);\n+      gcc_assert (!bitmap_intersect_p (tmp, sccs->sccs[i]->nodes));\n+      bitmap_ior (tmp, tmp, sccs->sccs[i]->nodes);\n     }\n   sbitmap_free (tmp);\n }\n@@ -1076,9 +1076,9 @@ create_ddg_all_sccs (ddg_ptr g)\n       if (backarc->aux.count == IN_SCC)\n \tcontinue;\n \n-      sbitmap_zero (scc_nodes);\n-      sbitmap_zero (from);\n-      sbitmap_zero (to);\n+      bitmap_clear (scc_nodes);\n+      bitmap_clear (from);\n+      bitmap_clear (to);\n       SET_BIT (from, dest->cuid);\n       SET_BIT (to, src->cuid);\n \n@@ -1132,15 +1132,15 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n   sbitmap reach_to = sbitmap_alloc (num_nodes);\n   sbitmap tmp = sbitmap_alloc (num_nodes);\n \n-  sbitmap_copy (reachable_from, from);\n-  sbitmap_copy (tmp, from);\n+  bitmap_copy (reachable_from, from);\n+  bitmap_copy (tmp, from);\n \n   change = 1;\n   while (change)\n     {\n       change = 0;\n-      sbitmap_copy (workset, tmp);\n-      sbitmap_zero (tmp);\n+      bitmap_copy (workset, tmp);\n+      bitmap_clear (tmp);\n       EXECUTE_IF_SET_IN_SBITMAP (workset, 0, u, sbi)\n \t{\n \t  ddg_edge_ptr e;\n@@ -1161,15 +1161,15 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n \t}\n     }\n \n-  sbitmap_copy (reach_to, to);\n-  sbitmap_copy (tmp, to);\n+  bitmap_copy (reach_to, to);\n+  bitmap_copy (tmp, to);\n \n   change = 1;\n   while (change)\n     {\n       change = 0;\n-      sbitmap_copy (workset, tmp);\n-      sbitmap_zero (tmp);\n+      bitmap_copy (workset, tmp);\n+      bitmap_clear (tmp);\n       EXECUTE_IF_SET_IN_SBITMAP (workset, 0, u, sbi)\n \t{\n \t  ddg_edge_ptr e;\n@@ -1190,7 +1190,7 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n \t}\n     }\n \n-  answer = sbitmap_a_and_b_cg (result, reachable_from, reach_to);\n+  answer = bitmap_and (result, reachable_from, reach_to);\n   sbitmap_free (workset);\n   sbitmap_free (reachable_from);\n   sbitmap_free (reach_to);\n@@ -1247,16 +1247,16 @@ longest_simple_path (struct ddg * g, int src, int dest, sbitmap nodes)\n     g->nodes[i].aux.count = -1;\n   g->nodes[src].aux.count = 0;\n \n-  sbitmap_zero (tmp);\n+  bitmap_clear (tmp);\n   SET_BIT (tmp, src);\n \n   while (change)\n     {\n       sbitmap_iterator sbi;\n \n       change = 0;\n-      sbitmap_copy (workset, tmp);\n-      sbitmap_zero (tmp);\n+      bitmap_copy (workset, tmp);\n+      bitmap_clear (tmp);\n       EXECUTE_IF_SET_IN_SBITMAP (workset, 0, u, sbi)\n \t{\n \t  ddg_node_ptr u_node = &g->nodes[u];"}, {"sha": "2ac11e42e5855e7d296f7acaaeaab917166a83f9", "filename": "gcc/df-core.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1080,7 +1080,7 @@ df_worklist_dataflow (struct dataflow *dataflow,\n     bbindex_to_postorder[i] = last_basic_block;\n \n   /* Initialize the considered map.  */\n-  sbitmap_zero (considered);\n+  bitmap_clear (considered);\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_consider, 0, index, bi)\n     {\n       SET_BIT (considered, index);"}, {"sha": "6e8c39687151db2ea881a3486b7572a5e5585558", "filename": "gcc/domwalk.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -145,7 +145,7 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n   basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks * 2);\n   int sp = 0;\n   sbitmap visited = sbitmap_alloc (last_basic_block + 1);\n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n   SET_BIT (visited, ENTRY_BLOCK_PTR->index);\n \n   while (true)"}, {"sha": "a987f3cc38fb7cbff81a3242cc20d9e38993a977", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -3384,7 +3384,7 @@ dse_step3 (bool for_spills)\n   bitmap all_ones = NULL;\n   unsigned int i;\n \n-  sbitmap_ones (unreachable_blocks);\n+  bitmap_ones (unreachable_blocks);\n \n   FOR_ALL_BB (bb)\n     {"}, {"sha": "7c7d58b96dc86c961cff533bb11377ba67fb7aa5", "filename": "gcc/ebitmap.c", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Febitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Febitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -79,7 +79,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Find the last set bit in ebitmap MAP.  */\n \n int\n-ebitmap_last_set_bit (ebitmap map)\n+bitmap_last_set_bit (ebitmap map)\n {\n   unsigned int i = 0;\n   ebitmap_iterator ebi;\n@@ -183,10 +183,10 @@ ebitmap_array_clear (ebitmap map)\n /* Clear ebitmap MAP.  */\n \n void\n-ebitmap_clear (ebitmap map)\n+bitmap_clear (ebitmap map)\n {\n   ebitmap_array_clear (map);\n-  sbitmap_zero (map->wordmask);\n+  bitmap_clear (map->wordmask);\n   map->wordmask = sbitmap_resize (map->wordmask, 1, 0);\n   map->numwords = 0;\n   map->cache = NULL;\n@@ -203,7 +203,7 @@ ebitmap_alloc (unsigned int size)\n     size = EBITMAP_ELT_BITS;\n   ebitmap_array_init (ret, (size + EBITMAP_ELT_BITS - 1) / EBITMAP_ELT_BITS);\n   ret->wordmask = sbitmap_alloc_with_popcount (size);\n-  sbitmap_zero (ret->wordmask);\n+  bitmap_clear (ret->wordmask);\n   ret->numwords = 0;\n   ret->cache = NULL;\n   ret->cacheindex = 0;\n@@ -214,7 +214,7 @@ ebitmap_alloc (unsigned int size)\n /* Clear BIT from ebitmap MAP.  */\n \n void\n-ebitmap_clear_bit (ebitmap map, unsigned int bit)\n+bitmap_clear_bit (ebitmap map, unsigned int bit)\n {\n   unsigned int wordindex = bit / EBITMAP_ELT_BITS;\n   unsigned int eltwordindex = 0;\n@@ -269,7 +269,7 @@ ebitmap_clear_bit (ebitmap map, unsigned int bit)\n /* Set BIT in ebitmap MAP.  */\n \n void\n-ebitmap_set_bit (ebitmap map, unsigned int bit)\n+bitmap_set_bit (ebitmap map, unsigned int bit)\n {\n   unsigned int wordindex = bit / EBITMAP_ELT_BITS;\n   unsigned int eltwordindex;\n@@ -325,7 +325,7 @@ ebitmap_set_bit (ebitmap map, unsigned int bit)\n /* Return true if MAP contains BIT.  */\n \n bool\n-ebitmap_bit_p (ebitmap map, unsigned int bit)\n+bitmap_bit_p (ebitmap map, unsigned int bit)\n {\n   unsigned int wordindex = bit / EBITMAP_ELT_BITS;\n   unsigned int bitindex= bit % EBITMAP_ELT_BITS;\n@@ -355,12 +355,12 @@ ebitmap_bit_p (ebitmap map, unsigned int bit)\n /* Copy ebitmap SRC to DST.  */\n \n void\n-ebitmap_copy (ebitmap dst, ebitmap src)\n+bitmap_copy (ebitmap dst, ebitmap src)\n {\n   /* Blow away any existing wordmask, and copy the new one.  */\n   sbitmap_free (dst->wordmask);\n   dst->wordmask = sbitmap_alloc_with_popcount (src->wordmask->n_bits);\n-  sbitmap_copy (dst->wordmask, src->wordmask);\n+  bitmap_copy (dst->wordmask, src->wordmask);\n \n   /* Make sure our destination array is big enough, and then copy the\n      actual words.  */\n@@ -374,14 +374,14 @@ ebitmap_copy (ebitmap dst, ebitmap src)\n /* Dump ebitmap BMAP to FILE.  */\n \n void\n-dump_ebitmap (FILE *file, ebitmap bmap)\n+dump_bitmap (FILE *file, ebitmap bmap)\n {\n   unsigned int pos;\n   unsigned int i;\n   int res;\n   unsigned int size;\n \n-  res = sbitmap_last_set_bit (bmap->wordmask);\n+  res = bitmap_last_set_bit (bmap->wordmask);\n   if (res == -1)\n     size = 0;\n   else\n@@ -390,7 +390,7 @@ dump_ebitmap (FILE *file, ebitmap bmap)\n   fprintf (file, \"n_words = %d, set = {\", bmap->numwords);\n \n   for (pos = 30, i = 0; i < size; i++)\n-    if (ebitmap_bit_p (bmap, i))\n+    if (bitmap_bit_p (bmap, i))\n       {\n \tif (pos > 70)\n \t  {\n@@ -407,15 +407,15 @@ dump_ebitmap (FILE *file, ebitmap bmap)\n /* Dump ebitmap BMAP to stderr.  */\n \n DEBUG_FUNCTION void\n-debug_ebitmap (ebitmap bmap)\n+debug_bitmap (ebitmap bmap)\n {\n-  dump_ebitmap (stderr, bmap);\n+  dump_bitmap (stderr, bmap);\n }\n \n /* Perform the operation DST &= SRC.  */\n \n void\n-ebitmap_and_into (ebitmap dst, ebitmap src)\n+bitmap_and_into (ebitmap dst, ebitmap src)\n {\n   sbitmap_iterator sbi;\n   unsigned int i;\n@@ -430,13 +430,13 @@ ebitmap_and_into (ebitmap dst, ebitmap src)\n   /* Short circuit the empty bitmap cases.  */\n   if (src->numwords == 0 || dst->numwords == 0)\n     {\n-      ebitmap_clear (dst);\n+      bitmap_clear (dst);\n       return;\n     }\n \n   /* AND the masks, then walk the words that may actually appear in\n      the result, AND'ing them.  */\n-  sbitmap_a_and_b (dst->wordmask, dst->wordmask, src->wordmask);\n+  bitmap_and (dst->wordmask, dst->wordmask, src->wordmask);\n \n   EXECUTE_IF_SET_IN_SBITMAP (dst->wordmask, 0, i, sbi)\n     {\n@@ -469,7 +469,7 @@ ebitmap_and_into (ebitmap dst, ebitmap src)\n /* Perform the operation DST = SRC1 & SRC2.  */\n \n void\n-ebitmap_and (ebitmap dst, ebitmap src1, ebitmap src2)\n+bitmap_and (ebitmap dst, ebitmap src1, ebitmap src2)\n {\n   sbitmap_iterator sbi;\n   unsigned int i;\n@@ -480,15 +480,15 @@ ebitmap_and (ebitmap dst, ebitmap src1, ebitmap src2)\n   dst->cache = NULL;\n   if (src1->numwords == 0 || src2->numwords == 0)\n     {\n-      ebitmap_clear (dst);\n+      bitmap_clear (dst);\n       return;\n     }\n \n   dst->wordmask\n     = sbitmap_resize (dst->wordmask,\n \t\t      MIN (src1->wordmask->n_bits, src2->wordmask->n_bits),\n \t\t      0);\n-  sbitmap_a_and_b (dst->wordmask, src1->wordmask, src2->wordmask);\n+  bitmap_and (dst->wordmask, src1->wordmask, src2->wordmask);\n \n   EXECUTE_IF_SET_IN_SBITMAP (dst->wordmask, 0, i, sbi)\n     {\n@@ -524,8 +524,8 @@ ebitmap_and (ebitmap dst, ebitmap src1, ebitmap src2)\n       gcc_assert (dst->elts[i] != 0);\n \n     EXECUTE_IF_SET_IN_EBITMAP (src1, 0, i, ebi)\n-      if (ebitmap_bit_p (src2, i))\n-\tgcc_assert (ebitmap_bit_p (dst, i));\n+      if (bitmap_bit_p (src2, i))\n+\tgcc_assert (bitmap_bit_p (dst, i));\n \n     for (i = 0; i <  dst->numwords; i++)\n       gcc_assert (dst->elts[i] != 0);\n@@ -542,7 +542,7 @@ ebitmap_and (ebitmap dst, ebitmap src1, ebitmap src2)\n    changed.  */\n \n bool\n-ebitmap_ior_into (ebitmap dst, ebitmap src)\n+bitmap_ior_into (ebitmap dst, ebitmap src)\n {\n   unsigned int dstsize = dst->wordmask->n_bits;\n   unsigned int srcsize = src->wordmask->n_bits;\n@@ -557,7 +557,7 @@ ebitmap_ior_into (ebitmap dst, ebitmap src)\n   unsigned int newarraysize;\n #ifdef EBITMAP_DEBUGGING\n   ebitmap dstcopy = ebitmap_alloc (1);\n-  ebitmap_copy (dstcopy, dst);\n+  bitmap_copy (dstcopy, dst);\n #endif\n \n   dst->cache = NULL;\n@@ -566,7 +566,7 @@ ebitmap_ior_into (ebitmap dst, ebitmap src)\n \n   if (dst->numwords == 0 && src->numwords != 0)\n     {\n-      ebitmap_copy (dst, src);\n+      bitmap_copy (dst, src);\n       return true;\n     }\n   else if (src->numwords == 0)\n@@ -575,24 +575,24 @@ ebitmap_ior_into (ebitmap dst, ebitmap src)\n   /* We can do without the temp mask if it's faster, but it would mean\n      touching more words in the actual dense vector.  */\n   tempmask = sbitmap_alloc (MAX (srcsize, dstsize));\n-  sbitmap_zero (tempmask);\n+  bitmap_clear (tempmask);\n   if (srcsize == dstsize)\n     {\n-      sbitmap_a_or_b (tempmask, dst->wordmask, src->wordmask);\n+      bitmap_ior (tempmask, dst->wordmask, src->wordmask);\n     }\n   else\n     {\n       dst->wordmask = sbitmap_resize (dst->wordmask, MAX (srcsize, dstsize),\n \t\t\t\t      0);\n       if (srcsize >= dstsize)\n \t{\n-\t  sbitmap_copy_n (tempmask, dst->wordmask, dst->wordmask->size);\n-\t  sbitmap_a_or_b (tempmask, tempmask, src->wordmask);\n+\t  bitmap_copy_n (tempmask, dst->wordmask, dst->wordmask->size);\n+\t  bitmap_ior (tempmask, tempmask, src->wordmask);\n \t}\n       else\n \t{\n-\t  sbitmap_copy_n (tempmask, src->wordmask, src->wordmask->size);\n-\t  sbitmap_a_or_b (tempmask, tempmask, dst->wordmask);\n+\t  bitmap_copy_n (tempmask, src->wordmask, src->wordmask->size);\n+\t  bitmap_ior (tempmask, tempmask, dst->wordmask);\n \t}\n     }\n   newarraysize = src->numwords + dst->numwords;\n@@ -649,12 +649,12 @@ ebitmap_ior_into (ebitmap dst, ebitmap src)\n       gcc_assert (dst->elts[i] != 0);\n \n     EXECUTE_IF_SET_IN_EBITMAP (src, 0, i, ebi)\n-      gcc_assert (ebitmap_bit_p (dst, i));\n+      gcc_assert (bitmap_bit_p (dst, i));\n     EXECUTE_IF_SET_IN_EBITMAP (dstcopy, 0, i, ebi)\n-      gcc_assert (ebitmap_bit_p (dst, i));\n+      gcc_assert (bitmap_bit_p (dst, i));\n \n     sbitmap_verify_popcount (dst->wordmask);\n-    gcc_assert (changed == !ebitmap_equal_p (dst, dstcopy));\n+    gcc_assert (changed == !bitmap_equal_p (dst, dstcopy));\n     gcc_assert (sbitmap_popcount (dst->wordmask,\n \t\t\t\t  dst->wordmask->n_bits) == dst->numwords);\n   }\n@@ -666,7 +666,7 @@ ebitmap_ior_into (ebitmap dst, ebitmap src)\n    in DST has changed.  */\n \n bool\n-ebitmap_ior (ebitmap dst, ebitmap src1, ebitmap src2)\n+bitmap_ior (ebitmap dst, ebitmap src1, ebitmap src2)\n {\n   unsigned int src1size = src1->wordmask->n_bits;\n   unsigned int src2size = src2->wordmask->n_bits;\n@@ -681,27 +681,27 @@ ebitmap_ior (ebitmap dst, ebitmap src1, ebitmap src2)\n   unsigned int newarraysize;\n #ifdef EBITMAP_DEBUGGING\n   ebitmap dstcopy = ebitmap_alloc (1);\n-  ebitmap_copy (dstcopy, dst);\n+  bitmap_copy (dstcopy, dst);\n #endif\n \n   dst->cache = NULL;\n   tempmask = sbitmap_alloc_with_popcount (MAX (src1size, src2size));\n-  sbitmap_zero (tempmask);\n+  bitmap_clear (tempmask);\n   if (src1size == src2size)\n     {\n-      sbitmap_a_or_b (tempmask, src1->wordmask, src2->wordmask);\n+      bitmap_ior (tempmask, src1->wordmask, src2->wordmask);\n     }\n   else\n     {\n       if (src1size >= src2size)\n \t{\n-\t  sbitmap_copy_n (tempmask, src2->wordmask, src2->wordmask->size);\n-\t  sbitmap_a_or_b (tempmask, tempmask, src1->wordmask);\n+\t  bitmap_copy_n (tempmask, src2->wordmask, src2->wordmask->size);\n+\t  bitmap_ior (tempmask, tempmask, src1->wordmask);\n \t}\n       else\n \t{\n-\t  sbitmap_copy_n (tempmask, src1->wordmask, src1->wordmask->size);\n-\t  sbitmap_a_or_b (tempmask, tempmask, src2->wordmask);\n+\t  bitmap_copy_n (tempmask, src1->wordmask, src1->wordmask->size);\n+\t  bitmap_ior (tempmask, tempmask, src2->wordmask);\n \t}\n     }\n   newarraysize = src1->numwords + src2->numwords;\n@@ -768,13 +768,13 @@ ebitmap_ior (ebitmap dst, ebitmap src1, ebitmap src2)\n       gcc_assert (dst->elts[i] != 0);\n \n     EXECUTE_IF_SET_IN_EBITMAP (src1, 0, i, ebi)\n-      gcc_assert (ebitmap_bit_p (dst, i));\n+      gcc_assert (bitmap_bit_p (dst, i));\n \n     EXECUTE_IF_SET_IN_EBITMAP (src2, 0, i, ebi)\n-      gcc_assert (ebitmap_bit_p (dst, i));\n+      gcc_assert (bitmap_bit_p (dst, i));\n   }\n   sbitmap_verify_popcount (dst->wordmask);\n-  gcc_assert (changed == !ebitmap_equal_p (dst, dstcopy));\n+  gcc_assert (changed == !bitmap_equal_p (dst, dstcopy));\n   gcc_assert (sbitmap_popcount (dst->wordmask,\n \t\t\t\tdst->wordmask->n_bits) == dst->numwords);\n #endif\n@@ -786,7 +786,7 @@ ebitmap_ior (ebitmap dst, ebitmap src1, ebitmap src2)\n    has changed.  */\n \n bool\n-ebitmap_and_compl_into (ebitmap dst, ebitmap src)\n+bitmap_and_compl_into (ebitmap dst, ebitmap src)\n {\n   bool changed = false;\n   unsigned int i;\n@@ -795,7 +795,7 @@ ebitmap_and_compl_into (ebitmap dst, ebitmap src)\n   sbitmap_iterator sbi;\n #ifdef EBITMAP_DEBUGGING\n   ebitmap dstcopy = ebitmap_alloc (1);\n-  ebitmap_copy (dstcopy, dst);\n+  bitmap_copy (dstcopy, dst);\n #endif\n \n   gcc_assert (dst != src);\n@@ -840,8 +840,8 @@ ebitmap_and_compl_into (ebitmap dst, ebitmap src)\n \n     EXECUTE_IF_SET_IN_EBITMAP (dstcopy, 0, i, ebi)\n       {\n-\tif (!ebitmap_bit_p (src, i))\n-\t  gcc_assert (ebitmap_bit_p (dst, i));\n+\tif (!bitmap_bit_p (src, i))\n+\t  gcc_assert (bitmap_bit_p (dst, i));\n       }\n \n     for (i = 0; i <  dst->numwords; i++)\n@@ -850,7 +850,7 @@ ebitmap_and_compl_into (ebitmap dst, ebitmap src)\n     gcc_assert (sbitmap_popcount (dst->wordmask,\n \t\t\t\t  dst->wordmask->n_bits) == neweltindex);\n     sbitmap_verify_popcount (dst->wordmask);\n-    gcc_assert (changed == !ebitmap_equal_p (dst, dstcopy));\n+    gcc_assert (changed == !bitmap_equal_p (dst, dstcopy));\n     gcc_assert (sbitmap_popcount (dst->wordmask,\n \t\t\t\t  dst->wordmask->n_bits) == dst->numwords);\n   }\n@@ -865,7 +865,7 @@ ebitmap_and_compl_into (ebitmap dst, ebitmap src)\n    in DST has changed.  */\n \n bool\n-ebitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n+bitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n {\n   unsigned int src1size = src1->wordmask->n_bits;\n   sbitmap_iterator sbi;\n@@ -880,8 +880,8 @@ ebitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n   /* XXX: Optimize like the into version.  */\n   dst->cache = NULL;\n   tempmask = sbitmap_alloc_with_popcount (src1size);\n-  sbitmap_zero (tempmask);\n-  sbitmap_copy (tempmask, src1->wordmask);\n+  bitmap_clear (tempmask);\n+  bitmap_copy (tempmask, src1->wordmask);\n \n   newarraysize = src1->numwords;\n   newarray = XNEWVEC (EBITMAP_ELT_TYPE, newarraysize);\n@@ -945,8 +945,8 @@ ebitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n \n     EXECUTE_IF_SET_IN_EBITMAP (src1, 0, i, ebi)\n       {\n-\tif (!ebitmap_bit_p (src2, i))\n-\t  gcc_assert (ebitmap_bit_p (dst, i));\n+\tif (!bitmap_bit_p (src2, i))\n+\t  gcc_assert (bitmap_bit_p (dst, i));\n       }\n   for (i = 0; i <  dst->numwords; i++)\n     gcc_assert (dst->elts[i] != 0);\n@@ -962,30 +962,30 @@ ebitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n /* Perform the operation DST = A | (B & ~C).  */\n \n bool\n-ebitmap_ior_and_compl (ebitmap dst, ebitmap a, ebitmap b, ebitmap c)\n+bitmap_ior_and_compl (ebitmap dst, ebitmap a, ebitmap b, ebitmap c)\n {\n   bool changed;\n   ebitmap temp = ebitmap_alloc (1);\n #ifdef EBITMAP_DEBUGGING\n   ebitmap dstcopy = ebitmap_alloc (1);\n-  ebitmap_copy (dstcopy, dst);\n+  bitmap_copy (dstcopy, dst);\n #endif\n \n   dst->cache = NULL;\n-  ebitmap_and_compl (temp, b, c);\n-  changed = ebitmap_ior (dst, a, temp);\n+  bitmap_and_compl (temp, b, c);\n+  changed = bitmap_ior (dst, a, temp);\n #ifdef EBITMAP_DEBUGGING\n   {\n     ebitmap_iterator ebi;\n     unsigned int i;\n \n     EXECUTE_IF_SET_IN_EBITMAP (a, 0, i, ebi)\n-      gcc_assert (ebitmap_bit_p (dst, i));\n+      gcc_assert (bitmap_bit_p (dst, i));\n \n     EXECUTE_IF_SET_IN_EBITMAP (b, 0, i, ebi)\n-      if (!ebitmap_bit_p (c, i))\n-\tgcc_assert (ebitmap_bit_p (dst, i));\n-    gcc_assert (changed == !ebitmap_equal_p (dst, dstcopy));\n+      if (!bitmap_bit_p (c, i))\n+\tgcc_assert (bitmap_bit_p (dst, i));\n+    gcc_assert (changed == !bitmap_equal_p (dst, dstcopy));\n   }\n #endif\n   ebitmap_free (temp);\n@@ -996,21 +996,21 @@ ebitmap_ior_and_compl (ebitmap dst, ebitmap a, ebitmap b, ebitmap c)\n /* Return true if ebitmap DST is equal to ebitmap SRC.  */\n \n bool\n-ebitmap_equal_p (ebitmap dst, ebitmap src)\n+bitmap_equal_p (ebitmap dst, ebitmap src)\n {\n   unsigned int which = MIN (dst->wordmask->size, src->wordmask->size);\n \n   if (dst->numwords != src->numwords)\n     return false;\n \n-  /* sbitmap_equal compares up to the size of the first argument, so\n+  /* bitmap_equal_p compares up to the size of the first argument, so\n      if the two sbitmaps are not equally sized, we need to pass the\n      smaller one as the first argument, or it will crash.  */\n   if (which == dst->wordmask->size\n-      && !sbitmap_equal (dst->wordmask, src->wordmask))\n+      && !bitmap_equal_p (dst->wordmask, src->wordmask))\n     return false;\n   else if (which == src->wordmask->size\n-\t   && !sbitmap_equal (src->wordmask, dst->wordmask))\n+\t   && !bitmap_equal_p (src->wordmask, dst->wordmask))\n     return false;\n \n   return memcmp (dst->elts, src->elts,"}, {"sha": "a755312a025f376a787233d25062487cd31d409e", "filename": "gcc/ebitmap.h", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Febitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Febitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.h?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -37,34 +37,38 @@ typedef struct ebitmap_def\n } *ebitmap;\n \n \n-#define ebitmap_empty_p(MAP) ((MAP)->numwords == 0)\n+inline bool bitmap_empty_p (ebitmap map)\n+{\n+  return map->numwords == 0;\n+}\n+\n #define ebitmap_free(MAP)  (free((MAP)->elts), \\\n \t\t\t    sbitmap_free ((MAP)->wordmask),\t\\\n \t\t\t    free((MAP)))\n \n-extern void ebitmap_set_bit (ebitmap, unsigned int);\n-extern void ebitmap_clear_bit (ebitmap, unsigned int);\n-extern bool ebitmap_bit_p (ebitmap, unsigned int);\n-extern void dump_ebitmap (FILE *, ebitmap);\n-extern void dump_ebitmap_file (FILE *, ebitmap);\n-extern void dump_ebitmap_vector (FILE *, const char *, const char *, ebitmap *,\n-\t\t\t\t int);\n+extern void bitmap_set_bit (ebitmap, unsigned int);\n+extern void bitmap_clear_bit (ebitmap, unsigned int);\n+extern bool bitmap_bit_p (ebitmap, unsigned int);\n+extern void dump_bitmap (FILE *, ebitmap);\n+extern void dump_bitmap_file (FILE *, ebitmap);\n+extern void dump_bitmap_vector (FILE *, const char *, const char *, ebitmap *,\n+\t\t\t\tint);\n extern ebitmap ebitmap_alloc (unsigned int);\n extern ebitmap *ebitmap_vector_alloc (unsigned int, unsigned int);\n-extern void ebitmap_copy (ebitmap, ebitmap);\n-extern void ebitmap_and (ebitmap, ebitmap, ebitmap);\n-extern void ebitmap_and_into (ebitmap, ebitmap);\n-extern bool ebitmap_and_compl (ebitmap, ebitmap, ebitmap);\n-extern bool ebitmap_and_compl_into (ebitmap, ebitmap);\n-extern bool ebitmap_ior_into (ebitmap, ebitmap);\n-extern bool ebitmap_ior (ebitmap, ebitmap, ebitmap);\n-extern bool ebitmap_ior_and_compl (ebitmap, ebitmap, ebitmap, ebitmap);\n-extern bool ebitmap_ior_and_compl_into (ebitmap, ebitmap, ebitmap);\n-extern bool ebitmap_equal_p (ebitmap, ebitmap);\n-extern void ebitmap_clear (ebitmap);\n-extern int ebitmap_last_set_bit (ebitmap);\n-extern void debug_ebitmap (ebitmap);\n-extern unsigned long ebitmap_popcount(ebitmap, unsigned long);\n+extern void bitmap_copy (ebitmap, ebitmap);\n+extern void bitmap_and (ebitmap, ebitmap, ebitmap);\n+extern void bitmap_and_into (ebitmap, ebitmap);\n+extern bool bitmap_and_compl (ebitmap, ebitmap, ebitmap);\n+extern bool bitmap_and_compl_into (ebitmap, ebitmap);\n+extern bool bitmap_ior_into (ebitmap, ebitmap);\n+extern bool bitmap_ior (ebitmap, ebitmap, ebitmap);\n+extern bool bitmap_ior_and_compl (ebitmap, ebitmap, ebitmap, ebitmap);\n+extern bool bitmap_ior_and_compl_into (ebitmap, ebitmap, ebitmap);\n+extern bool bitmap_equal_p (ebitmap, ebitmap);\n+extern void bitmap_clear (ebitmap);\n+extern int bitmap_last_set_bit (ebitmap);\n+extern void debug_bitmap (ebitmap);\n+extern unsigned long bitmap_popcount(ebitmap, unsigned long);\n \n /* The iterator for ebitmap.  */\n typedef struct {"}, {"sha": "7e18c19ec14558e1869709067185a8fa32b25cc3", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -610,7 +610,7 @@ eh_region_outermost (struct function *ifun, eh_region region_a,\n   gcc_assert (ifun->eh->region_tree);\n \n   b_outer = sbitmap_alloc (VEC_length (eh_region, ifun->eh->region_array));\n-  sbitmap_zero (b_outer);\n+  bitmap_clear (b_outer);\n \n   do\n     {"}, {"sha": "8a3904b7aae3b0ed16b358ab7363cd2b03881d49", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -6489,7 +6489,7 @@ thread_prologue_and_epilogue_insns (void)\n \n       /* Look for basic blocks within the prologue insns.  */\n       blocks = sbitmap_alloc (last_basic_block);\n-      sbitmap_zero (blocks);\n+      bitmap_clear (blocks);\n       SET_BIT (blocks, entry_edge->dest->index);\n       SET_BIT (blocks, orig_entry_edge->dest->index);\n       find_many_sub_basic_blocks (blocks);"}, {"sha": "6d0a47ef3132033a40a169c83eb8c7392a9050c6", "filename": "gcc/gcse.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -658,13 +658,13 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n   /* Initialize any bitmaps that were passed in.  */\n   if (transp)\n     {\n-      sbitmap_vector_ones (transp, last_basic_block);\n+      bitmap_vector_ones (transp, last_basic_block);\n     }\n \n   if (comp)\n-    sbitmap_vector_zero (comp, last_basic_block);\n+    bitmap_vector_clear (comp, last_basic_block);\n   if (antloc)\n-    sbitmap_vector_zero (antloc, last_basic_block);\n+    bitmap_vector_clear (antloc, last_basic_block);\n \n   for (i = 0; i < table->size; i++)\n     {\n@@ -1823,7 +1823,7 @@ prune_expressions (bool pre_p)\n   basic_block bb;\n \n   prune_exprs = sbitmap_alloc (expr_hash_table.n_elems);\n-  sbitmap_zero (prune_exprs);\n+  bitmap_clear (prune_exprs);\n   for (ui = 0; ui < expr_hash_table.size; ui++)\n     {\n       for (expr = expr_hash_table.table[ui]; expr; expr = expr->next_same_hash)\n@@ -1886,9 +1886,9 @@ prune_expressions (bool pre_p)\n \tif ((e->flags & EDGE_ABNORMAL)\n \t    && (pre_p || CALL_P (BB_END (e->src))))\n \t  {\n-\t    sbitmap_difference (antloc[bb->index],\n+\t    bitmap_and_compl (antloc[bb->index],\n \t\t\t\tantloc[bb->index], prune_exprs);\n-\t    sbitmap_difference (transp[bb->index],\n+\t    bitmap_and_compl (transp[bb->index],\n \t\t\t\ttransp[bb->index], prune_exprs);\n \t    break;\n \t  }\n@@ -1924,7 +1924,7 @@ prune_insertions_deletions (int n_elems)\n      the number of deletions achieved.  We will prune these out of the\n      insertion/deletion sets.  */\n   prune_exprs = sbitmap_alloc (n_elems);\n-  sbitmap_zero (prune_exprs);\n+  bitmap_clear (prune_exprs);\n \n   /* Iterate over the edges counting the number of times each expression\n      needs to be inserted.  */\n@@ -1976,7 +1976,7 @@ compute_pre_data (void)\n \n   compute_local_properties (transp, comp, antloc, &expr_hash_table);\n   prune_expressions (true);\n-  sbitmap_vector_zero (ae_kill, last_basic_block);\n+  bitmap_vector_clear (ae_kill, last_basic_block);\n \n   /* Compute ae_kill for each basic block using:\n \n@@ -1985,8 +1985,8 @@ compute_pre_data (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      sbitmap_a_or_b (ae_kill[bb->index], transp[bb->index], comp[bb->index]);\n-      sbitmap_not (ae_kill[bb->index], ae_kill[bb->index]);\n+      bitmap_ior (ae_kill[bb->index], transp[bb->index], comp[bb->index]);\n+      bitmap_not (ae_kill[bb->index], ae_kill[bb->index]);\n     }\n \n   edge_list = pre_edge_lcm (expr_hash_table.n_elems, transp, comp, antloc,\n@@ -2235,7 +2235,7 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n   set_size = pre_insert_map[0]->size;\n   num_edges = NUM_EDGES (edge_list);\n   inserted = sbitmap_vector_alloc (num_edges, expr_hash_table.n_elems);\n-  sbitmap_vector_zero (inserted, num_edges);\n+  bitmap_vector_clear (inserted, num_edges);\n \n   for (e = 0; e < num_edges; e++)\n     {\n@@ -2786,8 +2786,8 @@ compute_code_hoist_vbeinout (void)\n   int changed, passes;\n   basic_block bb;\n \n-  sbitmap_vector_zero (hoist_vbeout, last_basic_block);\n-  sbitmap_vector_zero (hoist_vbein, last_basic_block);\n+  bitmap_vector_clear (hoist_vbeout, last_basic_block);\n+  bitmap_vector_clear (hoist_vbein, last_basic_block);\n \n   passes = 0;\n   changed = 1;\n@@ -2807,11 +2807,11 @@ compute_code_hoist_vbeinout (void)\n \n \t      /* Include expressions in VBEout that are calculated\n \t\t in BB and available at its end.  */\n-\t      sbitmap_a_or_b (hoist_vbeout[bb->index],\n+\t      bitmap_ior (hoist_vbeout[bb->index],\n \t\t\t      hoist_vbeout[bb->index], comp[bb->index]);\n \t    }\n \n-\t  changed |= sbitmap_a_or_b_and_c_cg (hoist_vbein[bb->index],\n+\t  changed |= bitmap_or_and (hoist_vbein[bb->index],\n \t\t\t\t\t      antloc[bb->index],\n \t\t\t\t\t      hoist_vbeout[bb->index],\n \t\t\t\t\t      transp[bb->index]);\n@@ -2827,9 +2827,9 @@ compute_code_hoist_vbeinout (void)\n       FOR_EACH_BB (bb)\n         {\n \t  fprintf (dump_file, \"vbein (%d): \", bb->index);\n-\t  dump_sbitmap_file (dump_file, hoist_vbein[bb->index]);\n+\t  dump_bitmap_file (dump_file, hoist_vbein[bb->index]);\n \t  fprintf (dump_file, \"vbeout(%d): \", bb->index);\n-\t  dump_sbitmap_file (dump_file, hoist_vbeout[bb->index]);\n+\t  dump_bitmap_file (dump_file, hoist_vbeout[bb->index]);\n \t}\n     }\n }\n@@ -2911,7 +2911,7 @@ should_hoist_expr_to_dom (basic_block expr_bb, struct expr *expr,\n     {\n       visited_allocated_locally = 1;\n       visited = sbitmap_alloc (last_basic_block);\n-      sbitmap_zero (visited);\n+      bitmap_clear (visited);\n     }\n \n   FOR_EACH_EDGE (pred, ei, bb->preds)"}, {"sha": "228be811a757ae671c390be7c7da89d0cd155bd0", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -405,7 +405,7 @@ build_scop_bbs (scop_p scop)\n   sbitmap visited = sbitmap_alloc (last_basic_block);\n   sese region = SCOP_REGION (scop);\n \n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n   build_scop_bbs_1 (scop, visited, SESE_ENTRY_BB (region));\n   sbitmap_free (visited);\n }"}, {"sha": "41fd07637bfc2ff0fd7645254506de8ee38f4d75", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1465,8 +1465,8 @@ remove_some_program_points_and_update_live_ranges (void)\n   \n   born = sbitmap_alloc (ira_max_point);\n   dead = sbitmap_alloc (ira_max_point);\n-  sbitmap_zero (born);\n-  sbitmap_zero (dead);\n+  bitmap_clear (born);\n+  bitmap_clear (dead);\n   FOR_EACH_OBJECT (obj, oi)\n     for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n       {\n@@ -1476,7 +1476,7 @@ remove_some_program_points_and_update_live_ranges (void)\n       }\n \n   born_or_dead = sbitmap_alloc (ira_max_point);\n-  sbitmap_a_or_b (born_or_dead, born, dead);\n+  bitmap_ior (born_or_dead, born, dead);\n   map = (int *) ira_allocate (sizeof (int) * ira_max_point);\n   n = -1;\n   prev_born_p = prev_dead_p = false;"}, {"sha": "aeef5c4b9244ad3b551114a00d10e85e80c245f9", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -3492,9 +3492,9 @@ init_live_subregs (bool init_value, sbitmap *live_subregs,\n   /* If the entire reg was live before blasting into subregs, we need\n      to init all of the subregs to ones else init to 0.  */\n   if (init_value)\n-    sbitmap_ones (live_subregs[allocnum]);\n+    bitmap_ones (live_subregs[allocnum]);\n   else\n-    sbitmap_zero (live_subregs[allocnum]);\n+    bitmap_clear (live_subregs[allocnum]);\n \n   bitmap_set_bit (live_subregs_used, allocnum);\n }\n@@ -3624,7 +3624,7 @@ build_insn_chain (void)\n \t\t\t\tstart++;\n \t\t\t      }\n \n-\t\t\t    if (sbitmap_empty_p (live_subregs[regno]))\n+\t\t\t    if (bitmap_empty_p (live_subregs[regno]))\n \t\t\t      {\n \t\t\t\tbitmap_clear_bit (live_subregs_used, regno);\n \t\t\t\tbitmap_clear_bit (live_relevant_regs, regno);"}, {"sha": "2a2b48f7edcae18bfd64626147e1b57f9a7889d7", "filename": "gcc/lcm.c", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -106,7 +106,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n \n   /* We want a maximal solution, so make an optimistic initialization of\n      ANTIN.  */\n-  sbitmap_vector_ones (antin, last_basic_block);\n+  bitmap_vector_ones (antin, last_basic_block);\n \n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of ANTIN above.  */\n@@ -139,7 +139,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n \t/* Do not clear the aux field for blocks which are predecessors of\n \t   the EXIT block.  That way we never add then to the worklist\n \t   again.  */\n-\tsbitmap_zero (antout[bb->index]);\n+\tbitmap_clear (antout[bb->index]);\n       else\n \t{\n \t  /* Clear the aux field of this block so that it can be added to\n@@ -148,7 +148,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n \t  sbitmap_intersection_of_succs (antout[bb->index], antin, bb);\n \t}\n \n-      if (sbitmap_a_or_b_and_c_cg (antin[bb->index], antloc[bb->index],\n+      if (bitmap_or_and (antin[bb->index], antloc[bb->index],\n \t\t\t\t   transp[bb->index], antout[bb->index]))\n \t/* If the in state of this block changed, then we need\n \t   to add the predecessors of this block to the worklist\n@@ -190,17 +190,17 @@ compute_earliest (struct edge_list *edge_list, int n_exprs, sbitmap *antin,\n       pred = INDEX_EDGE_PRED_BB (edge_list, x);\n       succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n       if (pred == ENTRY_BLOCK_PTR)\n-\tsbitmap_copy (earliest[x], antin[succ->index]);\n+\tbitmap_copy (earliest[x], antin[succ->index]);\n       else\n \t{\n \t  if (succ == EXIT_BLOCK_PTR)\n-\t    sbitmap_zero (earliest[x]);\n+\t    bitmap_clear (earliest[x]);\n \t  else\n \t    {\n-\t      sbitmap_difference (difference, antin[succ->index],\n+\t      bitmap_and_compl (difference, antin[succ->index],\n \t\t\t\t  avout[pred->index]);\n-\t      sbitmap_not (temp_bitmap, antout[pred->index]);\n-\t      sbitmap_a_and_b_or_c (earliest[x], difference,\n+\t      bitmap_not (temp_bitmap, antout[pred->index]);\n+\t      bitmap_and_or (earliest[x], difference,\n \t\t\t\t    kill[pred->index], temp_bitmap);\n \t    }\n \t}\n@@ -271,14 +271,14 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n      example the expression is ANTLOC in a block within the loop) then\n      this algorithm will detect it when we process the block at the head\n      of the optimistic edge.  That will requeue the affected blocks.  */\n-  sbitmap_vector_ones (later, num_edges);\n+  bitmap_vector_ones (later, num_edges);\n \n   /* Note that even though we want an optimistic setting of LATER, we\n      do not want to be overly optimistic.  Consider an outgoing edge from\n      the entry block.  That edge should always have a LATER value the\n      same as EARLIEST for that edge.  */\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    sbitmap_copy (later[(size_t) e->aux], earliest[(size_t) e->aux]);\n+    bitmap_copy (later[(size_t) e->aux], earliest[(size_t) e->aux]);\n \n   /* Add all the blocks to the worklist.  This prevents an early exit from\n      the loop given our optimistic initialization of LATER above.  */\n@@ -305,14 +305,14 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n \tqout = worklist;\n \n       /* Compute the intersection of LATERIN for each incoming edge to B.  */\n-      sbitmap_ones (laterin[bb->index]);\n+      bitmap_ones (laterin[bb->index]);\n       FOR_EACH_EDGE (e, ei, bb->preds)\n-\tsbitmap_a_and_b (laterin[bb->index], laterin[bb->index],\n+\tbitmap_and (laterin[bb->index], laterin[bb->index],\n \t\t\t later[(size_t)e->aux]);\n \n       /* Calculate LATER for all outgoing edges.  */\n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (sbitmap_union_of_diff_cg (later[(size_t) e->aux],\n+\tif (bitmap_ior_and_compl (later[(size_t) e->aux],\n \t\t\t\t      earliest[(size_t) e->aux],\n \t\t\t\t      laterin[e->src->index],\n \t\t\t\t      antloc[e->src->index])\n@@ -331,9 +331,9 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n   /* Computation of insertion and deletion points requires computing LATERIN\n      for the EXIT block.  We allocated an extra entry in the LATERIN array\n      for just this purpose.  */\n-  sbitmap_ones (laterin[last_basic_block]);\n+  bitmap_ones (laterin[last_basic_block]);\n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n-    sbitmap_a_and_b (laterin[last_basic_block],\n+    bitmap_and (laterin[last_basic_block],\n \t\t     laterin[last_basic_block],\n \t\t     later[(size_t) e->aux]);\n \n@@ -352,17 +352,17 @@ compute_insert_delete (struct edge_list *edge_list, sbitmap *antloc,\n   basic_block bb;\n \n   FOR_EACH_BB (bb)\n-    sbitmap_difference (del[bb->index], antloc[bb->index],\n+    bitmap_and_compl (del[bb->index], antloc[bb->index],\n \t\t\tlaterin[bb->index]);\n \n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n     {\n       basic_block b = INDEX_EDGE_SUCC_BB (edge_list, x);\n \n       if (b == EXIT_BLOCK_PTR)\n-\tsbitmap_difference (insert[x], later[x], laterin[last_basic_block]);\n+\tbitmap_and_compl (insert[x], later[x], laterin[last_basic_block]);\n       else\n-\tsbitmap_difference (insert[x], later[x], laterin[b->index]);\n+\tbitmap_and_compl (insert[x], later[x], laterin[b->index]);\n     }\n }\n \n@@ -390,10 +390,10 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n       fprintf (dump_file, \"Edge List:\\n\");\n       verify_edge_list (dump_file, edge_list);\n       print_edge_list (dump_file, edge_list);\n-      dump_sbitmap_vector (dump_file, \"transp\", \"\", transp, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"antloc\", \"\", antloc, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"avloc\", \"\", avloc, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"kill\", \"\", kill, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"transp\", \"\", transp, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"antloc\", \"\", antloc, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"avloc\", \"\", avloc, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"kill\", \"\", kill, last_basic_block);\n     }\n #endif\n \n@@ -411,8 +411,8 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n     {\n-      dump_sbitmap_vector (dump_file, \"antin\", \"\", antin, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"antout\", \"\", antout, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"antin\", \"\", antin, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"antout\", \"\", antout, last_basic_block);\n     }\n #endif\n \n@@ -422,7 +422,7 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n \n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n-    dump_sbitmap_vector (dump_file, \"earliest\", \"\", earliest, num_edges);\n+    dump_bitmap_vector (dump_file, \"earliest\", \"\", earliest, num_edges);\n #endif\n \n   sbitmap_vector_free (antout);\n@@ -438,17 +438,17 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n     {\n-      dump_sbitmap_vector (dump_file, \"laterin\", \"\", laterin, last_basic_block + 1);\n-      dump_sbitmap_vector (dump_file, \"later\", \"\", later, num_edges);\n+      dump_bitmap_vector (dump_file, \"laterin\", \"\", laterin, last_basic_block + 1);\n+      dump_bitmap_vector (dump_file, \"later\", \"\", later, num_edges);\n     }\n #endif\n \n   sbitmap_vector_free (earliest);\n \n   *insert = sbitmap_vector_alloc (num_edges, n_exprs);\n   *del = sbitmap_vector_alloc (last_basic_block, n_exprs);\n-  sbitmap_vector_zero (*insert, num_edges);\n-  sbitmap_vector_zero (*del, last_basic_block);\n+  bitmap_vector_clear (*insert, num_edges);\n+  bitmap_vector_clear (*del, last_basic_block);\n   compute_insert_delete (edge_list, antloc, later, laterin, *insert, *del);\n \n   sbitmap_vector_free (laterin);\n@@ -457,8 +457,8 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n     {\n-      dump_sbitmap_vector (dump_file, \"pre_insert_map\", \"\", *insert, num_edges);\n-      dump_sbitmap_vector (dump_file, \"pre_delete_map\", \"\", *del,\n+      dump_bitmap_vector (dump_file, \"pre_insert_map\", \"\", *insert, num_edges);\n+      dump_bitmap_vector (dump_file, \"pre_delete_map\", \"\", *del,\n \t\t\t   last_basic_block);\n     }\n #endif\n@@ -485,7 +485,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n     XNEWVEC (basic_block, n_basic_blocks - NUM_FIXED_BLOCKS);\n \n   /* We want a maximal solution.  */\n-  sbitmap_vector_ones (avout, last_basic_block);\n+  bitmap_vector_ones (avout, last_basic_block);\n \n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of AVOUT above.  */\n@@ -520,7 +520,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n       if (bb->aux == ENTRY_BLOCK_PTR)\n \t/* Do not clear the aux field for blocks which are successors of the\n \t   ENTRY block.  That way we never add then to the worklist again.  */\n-\tsbitmap_zero (avin[bb->index]);\n+\tbitmap_clear (avin[bb->index]);\n       else\n \t{\n \t  /* Clear the aux field of this block so that it can be added to\n@@ -529,7 +529,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n \t  sbitmap_intersection_of_preds (avin[bb->index], avout, bb);\n \t}\n \n-      if (sbitmap_union_of_diff_cg (avout[bb->index], avloc[bb->index],\n+      if (bitmap_ior_and_compl (avout[bb->index], avloc[bb->index],\n \t\t\t\t    avin[bb->index], kill[bb->index]))\n \t/* If the out state of this block changed, then we need\n \t   to add the successors of this block to the worklist\n@@ -572,17 +572,17 @@ compute_farthest (struct edge_list *edge_list, int n_exprs,\n       pred = INDEX_EDGE_PRED_BB (edge_list, x);\n       succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n       if (succ == EXIT_BLOCK_PTR)\n-\tsbitmap_copy (farthest[x], st_avout[pred->index]);\n+\tbitmap_copy (farthest[x], st_avout[pred->index]);\n       else\n \t{\n \t  if (pred == ENTRY_BLOCK_PTR)\n-\t    sbitmap_zero (farthest[x]);\n+\t    bitmap_clear (farthest[x]);\n \t  else\n \t    {\n-\t      sbitmap_difference (difference, st_avout[pred->index],\n+\t      bitmap_and_compl (difference, st_avout[pred->index],\n \t\t\t\t  st_antin[succ->index]);\n-\t      sbitmap_not (temp_bitmap, st_avin[succ->index]);\n-\t      sbitmap_a_and_b_or_c (farthest[x], difference,\n+\t      bitmap_not (temp_bitmap, st_avin[succ->index]);\n+\t      bitmap_and_or (farthest[x], difference,\n \t\t\t\t    kill[succ->index], temp_bitmap);\n \t    }\n \t}\n@@ -619,14 +619,14 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n     INDEX_EDGE (edge_list, i)->aux = (void *) (size_t) i;\n \n   /* We want a maximal solution.  */\n-  sbitmap_vector_ones (nearer, num_edges);\n+  bitmap_vector_ones (nearer, num_edges);\n \n   /* Note that even though we want an optimistic setting of NEARER, we\n      do not want to be overly optimistic.  Consider an incoming edge to\n      the exit block.  That edge should always have a NEARER value the\n      same as FARTHEST for that edge.  */\n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n-    sbitmap_copy (nearer[(size_t)e->aux], farthest[(size_t)e->aux]);\n+    bitmap_copy (nearer[(size_t)e->aux], farthest[(size_t)e->aux]);\n \n   /* Add all the blocks to the worklist.  This prevents an early exit\n      from the loop given our optimistic initialization of NEARER.  */\n@@ -644,14 +644,14 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n       bb->aux = NULL;\n \n       /* Compute the intersection of NEARER for each outgoing edge from B.  */\n-      sbitmap_ones (nearerout[bb->index]);\n+      bitmap_ones (nearerout[bb->index]);\n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tsbitmap_a_and_b (nearerout[bb->index], nearerout[bb->index],\n+\tbitmap_and (nearerout[bb->index], nearerout[bb->index],\n \t\t\t nearer[(size_t) e->aux]);\n \n       /* Calculate NEARER for all incoming edges.  */\n       FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (sbitmap_union_of_diff_cg (nearer[(size_t) e->aux],\n+\tif (bitmap_ior_and_compl (nearer[(size_t) e->aux],\n \t\t\t\t      farthest[(size_t) e->aux],\n \t\t\t\t      nearerout[e->dest->index],\n \t\t\t\t      st_avloc[e->dest->index])\n@@ -667,9 +667,9 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n   /* Computation of insertion and deletion points requires computing NEAREROUT\n      for the ENTRY block.  We allocated an extra entry in the NEAREROUT array\n      for just this purpose.  */\n-  sbitmap_ones (nearerout[last_basic_block]);\n+  bitmap_ones (nearerout[last_basic_block]);\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    sbitmap_a_and_b (nearerout[last_basic_block],\n+    bitmap_and (nearerout[last_basic_block],\n \t\t     nearerout[last_basic_block],\n \t\t     nearer[(size_t) e->aux]);\n \n@@ -688,16 +688,16 @@ compute_rev_insert_delete (struct edge_list *edge_list, sbitmap *st_avloc,\n   basic_block bb;\n \n   FOR_EACH_BB (bb)\n-    sbitmap_difference (del[bb->index], st_avloc[bb->index],\n+    bitmap_and_compl (del[bb->index], st_avloc[bb->index],\n \t\t\tnearerout[bb->index]);\n \n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n     {\n       basic_block b = INDEX_EDGE_PRED_BB (edge_list, x);\n       if (b == ENTRY_BLOCK_PTR)\n-\tsbitmap_difference (insert[x], nearer[x], nearerout[last_basic_block]);\n+\tbitmap_and_compl (insert[x], nearer[x], nearerout[last_basic_block]);\n       else\n-\tsbitmap_difference (insert[x], nearer[x], nearerout[b->index]);\n+\tbitmap_and_compl (insert[x], nearer[x], nearerout[b->index]);\n     }\n }\n \n@@ -722,8 +722,8 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n \n   st_antin = sbitmap_vector_alloc (last_basic_block, n_exprs);\n   st_antout = sbitmap_vector_alloc (last_basic_block, n_exprs);\n-  sbitmap_vector_zero (st_antin, last_basic_block);\n-  sbitmap_vector_zero (st_antout, last_basic_block);\n+  bitmap_vector_clear (st_antin, last_basic_block);\n+  bitmap_vector_clear (st_antout, last_basic_block);\n   compute_antinout_edge (st_antloc, transp, st_antin, st_antout);\n \n   /* Compute global anticipatability.  */\n@@ -737,20 +737,20 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n       fprintf (dump_file, \"Edge List:\\n\");\n       verify_edge_list (dump_file, edge_list);\n       print_edge_list (dump_file, edge_list);\n-      dump_sbitmap_vector (dump_file, \"transp\", \"\", transp, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"st_avloc\", \"\", st_avloc, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"st_antin\", \"\", st_antin, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"st_antout\", \"\", st_antout, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"st_kill\", \"\", kill, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"transp\", \"\", transp, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_avloc\", \"\", st_avloc, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_antin\", \"\", st_antin, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_antout\", \"\", st_antout, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_kill\", \"\", kill, last_basic_block);\n     }\n #endif\n \n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n     {\n-      dump_sbitmap_vector (dump_file, \"st_avout\", \"\", st_avout, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"st_avin\", \"\", st_avin, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_avout\", \"\", st_avout, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_avin\", \"\", st_avin, last_basic_block);\n     }\n #endif\n \n@@ -761,7 +761,7 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n \n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n-    dump_sbitmap_vector (dump_file, \"farthest\", \"\", farthest, num_edges);\n+    dump_bitmap_vector (dump_file, \"farthest\", \"\", farthest, num_edges);\n #endif\n \n   sbitmap_vector_free (st_antin);\n@@ -779,9 +779,9 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n     {\n-      dump_sbitmap_vector (dump_file, \"nearerout\", \"\", nearerout,\n+      dump_bitmap_vector (dump_file, \"nearerout\", \"\", nearerout,\n \t\t\t   last_basic_block + 1);\n-      dump_sbitmap_vector (dump_file, \"nearer\", \"\", nearer, num_edges);\n+      dump_bitmap_vector (dump_file, \"nearer\", \"\", nearer, num_edges);\n     }\n #endif\n \n@@ -798,8 +798,8 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n #ifdef LCM_DEBUG_INFO\n   if (dump_file)\n     {\n-      dump_sbitmap_vector (dump_file, \"pre_insert_map\", \"\", *insert, num_edges);\n-      dump_sbitmap_vector (dump_file, \"pre_delete_map\", \"\", *del,\n+      dump_bitmap_vector (dump_file, \"pre_insert_map\", \"\", *insert, num_edges);\n+      dump_bitmap_vector (dump_file, \"pre_delete_map\", \"\", *del,\n \t\t\t   last_basic_block);\n     }\n #endif"}, {"sha": "9506b3d6bbe62cb17ec94a3d9bc89c052b7c1fad", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -465,7 +465,7 @@ peel_loop_completely (struct loop *loop)\n       bool ok;\n \n       wont_exit = sbitmap_alloc (npeel + 1);\n-      sbitmap_ones (wont_exit);\n+      bitmap_ones (wont_exit);\n       RESET_BIT (wont_exit, 0);\n       if (desc->noloop_assumptions)\n \tRESET_BIT (wont_exit, 1);\n@@ -655,7 +655,7 @@ unroll_loop_constant_iterations (struct loop *loop)\n   exit_mod = niter % (max_unroll + 1);\n \n   wont_exit = sbitmap_alloc (max_unroll + 1);\n-  sbitmap_ones (wont_exit);\n+  bitmap_ones (wont_exit);\n \n   remove_edges = NULL;\n   if (flag_split_ivs_in_unroller\n@@ -1066,7 +1066,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n      here; the only exception is when we have extra zero check and the number\n      of iterations is reliable.  Also record the place of (possible) extra\n      zero check.  */\n-  sbitmap_zero (wont_exit);\n+  bitmap_clear (wont_exit);\n   if (extra_zero_check\n       && !desc->noloop_assumptions)\n     SET_BIT (wont_exit, 1);\n@@ -1083,7 +1083,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   for (i = 0; i < n_peel; i++)\n     {\n       /* Peel the copy.  */\n-      sbitmap_zero (wont_exit);\n+      bitmap_clear (wont_exit);\n       if (i != n_peel - 1 || !last_may_exit)\n \tSET_BIT (wont_exit, 1);\n       ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n@@ -1139,7 +1139,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \n   /* And unroll loop.  */\n \n-  sbitmap_ones (wont_exit);\n+  bitmap_ones (wont_exit);\n   RESET_BIT (wont_exit, may_exit_copy);\n   opt_info_start_duplication (opt_info);\n \n@@ -1340,7 +1340,7 @@ peel_loop_simple (struct loop *loop)\n     opt_info = analyze_insns_in_loop (loop);\n \n   wont_exit = sbitmap_alloc (npeel + 1);\n-  sbitmap_zero (wont_exit);\n+  bitmap_clear (wont_exit);\n \n   opt_info_start_duplication (opt_info);\n \n@@ -1498,7 +1498,7 @@ unroll_loop_stupid (struct loop *loop)\n \n \n   wont_exit = sbitmap_alloc (nunroll + 1);\n-  sbitmap_zero (wont_exit);\n+  bitmap_clear (wont_exit);\n   opt_info_start_duplication (opt_info);\n \n   ok = duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),"}, {"sha": "06c0b577a0297301ea77f7fa7ccf8f94e909fb46", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1485,7 +1485,7 @@ decompose_multiword_subregs (bool decompose_copies)\n       propagate_pseudo_copies ();\n \n       sub_blocks = sbitmap_alloc (last_basic_block);\n-      sbitmap_zero (sub_blocks);\n+      bitmap_clear (sub_blocks);\n \n       EXECUTE_IF_SET_IN_BITMAP (decomposable_context, 0, regno, iter)\n \tdecompose_register (regno);"}, {"sha": "501e205ffd5d692e7ef7c520678eb1f4132d98a2", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -772,8 +772,8 @@ remove_some_program_points_and_update_live_ranges (void)\n \n   born = sbitmap_alloc (lra_live_max_point);\n   dead = sbitmap_alloc (lra_live_max_point);\n-  sbitmap_zero (born);\n-  sbitmap_zero (dead);\n+  bitmap_clear (born);\n+  bitmap_clear (dead);\n   max_regno = max_reg_num ();\n   for (i = FIRST_PSEUDO_REGISTER; i < (unsigned) max_regno; i++)\n     {\n@@ -785,7 +785,7 @@ remove_some_program_points_and_update_live_ranges (void)\n \t}\n     }\n   born_or_dead = sbitmap_alloc (lra_live_max_point);\n-  sbitmap_a_or_b (born_or_dead, born, dead);\n+  bitmap_ior (born_or_dead, born, dead);\n   map = XCNEWVEC (int, lra_live_max_point);\n   n = -1;\n   prev_born_p = prev_dead_p = false;"}, {"sha": "c1cc64e8fede5c7a1e6dcfed33db4e88d2f2508b", "filename": "gcc/lra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -2259,7 +2259,7 @@ lra (FILE *f)\n   df_set_flags (DF_NO_INSN_RESCAN);\n   lra_constraint_insn_stack = VEC_alloc (rtx, heap, get_max_uid ());\n   lra_constraint_insn_stack_bitmap = sbitmap_alloc (get_max_uid ());\n-  sbitmap_zero (lra_constraint_insn_stack_bitmap);\n+  bitmap_clear (lra_constraint_insn_stack_bitmap);\n   lra_live_ranges_init ();\n   lra_constraints_init ();\n   lra_curr_reload_num = 0;\n@@ -2355,7 +2355,7 @@ lra (FILE *f)\n     {\n       sbitmap blocks;\n       blocks = sbitmap_alloc (last_basic_block);\n-      sbitmap_ones (blocks);\n+      bitmap_ones (blocks);\n       find_many_sub_basic_blocks (blocks);\n       sbitmap_free (blocks);\n     }"}, {"sha": "61afdc8783543b9c9e0b67680602830c5924b91b", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -482,7 +482,7 @@ optimize_mode_switching (void)\n   transp = sbitmap_vector_alloc (last_basic_block, n_entities);\n   comp = sbitmap_vector_alloc (last_basic_block, n_entities);\n \n-  sbitmap_vector_ones (transp, last_basic_block);\n+  bitmap_vector_ones (transp, last_basic_block);\n \n   for (j = n_entities - 1; j >= 0; j--)\n     {\n@@ -591,8 +591,8 @@ optimize_mode_switching (void)\n       sbitmap *insert;\n \n       /* Set the anticipatable and computing arrays.  */\n-      sbitmap_vector_zero (antic, last_basic_block);\n-      sbitmap_vector_zero (comp, last_basic_block);\n+      bitmap_vector_clear (antic, last_basic_block);\n+      bitmap_vector_clear (comp, last_basic_block);\n       for (j = n_entities - 1; j >= 0; j--)\n \t{\n \t  int m = current_mode[j] = MODE_PRIORITY_TO_MODE (entity_map[j], i);\n@@ -612,7 +612,7 @@ optimize_mode_switching (void)\n \t placement mode switches to modes with priority I.  */\n \n       FOR_EACH_BB (bb)\n-\tsbitmap_not (kill[bb->index], transp[bb->index]);\n+\tbitmap_not (kill[bb->index], transp[bb->index]);\n       edge_list = pre_edge_lcm (n_entities, transp, comp, antic,\n \t\t\t\tkill, &insert, &del);\n "}, {"sha": "88ac28d5907c175558d042ad2d5b985203d9a0a3", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -643,7 +643,7 @@ schedule_reg_move (partial_schedule_ptr ps, int i_reg_move,\n       fprintf (dump_file, \"%11d %11d %5s %s\\n\", start, end, \"\", \"(max, min)\");\n     }\n \n-  sbitmap_zero (must_follow);\n+  bitmap_clear (must_follow);\n   SET_BIT (must_follow, move->def);\n \n   start = MAX (start, end - (ii - 1));\n@@ -767,7 +767,7 @@ schedule_reg_moves (partial_schedule_ptr ps)\n \t  move->new_reg = gen_reg_rtx (GET_MODE (prev_reg));\n \t  move->num_consecutive_stages = distances[0] && distances[1] ? 2 : 1;\n \t  move->insn = gen_move_insn (move->new_reg, copy_rtx (prev_reg));\n-\t  sbitmap_zero (move->uses);\n+\t  bitmap_clear (move->uses);\n \n \t  prev_reg = move->new_reg;\n \t}\n@@ -982,7 +982,7 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n       goto clear;\n     }\n \n-  sbitmap_ones (sched_nodes);\n+  bitmap_ones (sched_nodes);\n \n   /* Calculate the new placement of the branch.  It should be in row\n      ii-1 and fall into it's scheduling window.  */\n@@ -1880,10 +1880,10 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n   int count_succs;\n \n   /* 1. compute sched window for u (start, end, step).  */\n-  sbitmap_zero (psp);\n-  sbitmap_zero (pss);\n-  psp_not_empty = sbitmap_a_and_b_cg (psp, u_node_preds, sched_nodes);\n-  pss_not_empty = sbitmap_a_and_b_cg (pss, u_node_succs, sched_nodes);\n+  bitmap_clear (psp);\n+  bitmap_clear (pss);\n+  psp_not_empty = bitmap_and (psp, u_node_preds, sched_nodes);\n+  pss_not_empty = bitmap_and (pss, u_node_succs, sched_nodes);\n \n   /* We first compute a forward range (start <= end), then decide whether\n      to reverse it.  */\n@@ -2050,8 +2050,8 @@ calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n   first_cycle_in_window = (step == 1) ? start : end - step;\n   last_cycle_in_window = (step == 1) ? end - step : start;\n \n-  sbitmap_zero (must_precede);\n-  sbitmap_zero (must_follow);\n+  bitmap_clear (must_precede);\n+  bitmap_clear (must_follow);\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nmust_precede: \");\n@@ -2159,16 +2159,16 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n \n   partial_schedule_ptr ps = create_partial_schedule (ii, g, DFA_HISTORY);\n \n-  sbitmap_ones (tobe_scheduled);\n-  sbitmap_zero (sched_nodes);\n+  bitmap_ones (tobe_scheduled);\n+  bitmap_clear (sched_nodes);\n \n   while (flush_and_start_over && (ii < maxii))\n     {\n \n       if (dump_file)\n \tfprintf (dump_file, \"Starting with ii=%d\\n\", ii);\n       flush_and_start_over = false;\n-      sbitmap_zero (sched_nodes);\n+      bitmap_clear (sched_nodes);\n \n       for (i = 0; i < num_nodes; i++)\n \t{\n@@ -2264,7 +2264,7 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n       ps = NULL;\n     }\n   else\n-    gcc_assert (sbitmap_equal (tobe_scheduled, sched_nodes));\n+    gcc_assert (bitmap_equal_p (tobe_scheduled, sched_nodes));\n \n   sbitmap_free (sched_nodes);\n   sbitmap_free (must_precede);\n@@ -2482,7 +2482,7 @@ check_nodes_order (int *node_order, int num_nodes)\n   int i;\n   sbitmap tmp = sbitmap_alloc (num_nodes);\n \n-  sbitmap_zero (tmp);\n+  bitmap_clear (tmp);\n \n   if (dump_file)\n     fprintf (dump_file, \"SMS final nodes order: \\n\");\n@@ -2550,8 +2550,8 @@ order_nodes_of_sccs (ddg_all_sccs_ptr all_sccs, int * node_order)\n   sbitmap tmp = sbitmap_alloc (num_nodes);\n   sbitmap ones = sbitmap_alloc (num_nodes);\n \n-  sbitmap_zero (prev_sccs);\n-  sbitmap_ones (ones);\n+  bitmap_clear (prev_sccs);\n+  bitmap_ones (ones);\n \n   /* Perform the node ordering starting from the SCC with the highest recMII.\n      For each SCC order the nodes according to their ASAP/ALAP/HEIGHT etc.  */\n@@ -2561,14 +2561,14 @@ order_nodes_of_sccs (ddg_all_sccs_ptr all_sccs, int * node_order)\n \n       /* Add nodes on paths from previous SCCs to the current SCC.  */\n       find_nodes_on_paths (on_path, g, prev_sccs, scc->nodes);\n-      sbitmap_a_or_b (tmp, scc->nodes, on_path);\n+      bitmap_ior (tmp, scc->nodes, on_path);\n \n       /* Add nodes on paths from the current SCC to previous SCCs.  */\n       find_nodes_on_paths (on_path, g, scc->nodes, prev_sccs);\n-      sbitmap_a_or_b (tmp, tmp, on_path);\n+      bitmap_ior (tmp, tmp, on_path);\n \n       /* Remove nodes of previous SCCs from current extended SCC.  */\n-      sbitmap_difference (tmp, tmp, prev_sccs);\n+      bitmap_and_compl (tmp, tmp, prev_sccs);\n \n       pos = order_nodes_in_scc (g, prev_sccs, tmp, node_order, pos);\n       /* Above call to order_nodes_in_scc updated prev_sccs |= tmp.  */\n@@ -2578,7 +2578,7 @@ order_nodes_of_sccs (ddg_all_sccs_ptr all_sccs, int * node_order)\n      to order_nodes_in_scc handles a single connected component.  */\n   while (pos < g->num_nodes)\n     {\n-      sbitmap_difference (tmp, ones, prev_sccs);\n+      bitmap_and_compl (tmp, ones, prev_sccs);\n       pos = order_nodes_in_scc (g, prev_sccs, tmp, node_order, pos);\n     }\n   sbitmap_free (prev_sccs);\n@@ -2751,35 +2751,35 @@ order_nodes_in_scc (ddg_ptr g, sbitmap nodes_ordered, sbitmap scc,\n   sbitmap predecessors = sbitmap_alloc (num_nodes);\n   sbitmap successors = sbitmap_alloc (num_nodes);\n \n-  sbitmap_zero (predecessors);\n+  bitmap_clear (predecessors);\n   find_predecessors (predecessors, g, nodes_ordered);\n \n-  sbitmap_zero (successors);\n+  bitmap_clear (successors);\n   find_successors (successors, g, nodes_ordered);\n \n-  sbitmap_zero (tmp);\n-  if (sbitmap_a_and_b_cg (tmp, predecessors, scc))\n+  bitmap_clear (tmp);\n+  if (bitmap_and (tmp, predecessors, scc))\n     {\n-      sbitmap_copy (workset, tmp);\n+      bitmap_copy (workset, tmp);\n       dir = BOTTOMUP;\n     }\n-  else if (sbitmap_a_and_b_cg (tmp, successors, scc))\n+  else if (bitmap_and (tmp, successors, scc))\n     {\n-      sbitmap_copy (workset, tmp);\n+      bitmap_copy (workset, tmp);\n       dir = TOPDOWN;\n     }\n   else\n     {\n       int u;\n \n-      sbitmap_zero (workset);\n+      bitmap_clear (workset);\n       if ((u = find_max_asap (g, scc)) >= 0)\n \tSET_BIT (workset, u);\n       dir = BOTTOMUP;\n     }\n \n-  sbitmap_zero (zero_bitmap);\n-  while (!sbitmap_equal (workset, zero_bitmap))\n+  bitmap_clear (zero_bitmap);\n+  while (!bitmap_equal_p (workset, zero_bitmap))\n     {\n       int v;\n       ddg_node_ptr v_node;\n@@ -2788,45 +2788,45 @@ order_nodes_in_scc (ddg_ptr g, sbitmap nodes_ordered, sbitmap scc,\n \n       if (dir == TOPDOWN)\n \t{\n-\t  while (!sbitmap_equal (workset, zero_bitmap))\n+\t  while (!bitmap_equal_p (workset, zero_bitmap))\n \t    {\n \t      v = find_max_hv_min_mob (g, workset);\n \t      v_node = &g->nodes[v];\n \t      node_order[pos++] = v;\n \t      v_node_succs = NODE_SUCCESSORS (v_node);\n-\t      sbitmap_a_and_b (tmp, v_node_succs, scc);\n+\t      bitmap_and (tmp, v_node_succs, scc);\n \n \t      /* Don't consider the already ordered successors again.  */\n-\t      sbitmap_difference (tmp, tmp, nodes_ordered);\n-\t      sbitmap_a_or_b (workset, workset, tmp);\n+\t      bitmap_and_compl (tmp, tmp, nodes_ordered);\n+\t      bitmap_ior (workset, workset, tmp);\n \t      RESET_BIT (workset, v);\n \t      SET_BIT (nodes_ordered, v);\n \t    }\n \t  dir = BOTTOMUP;\n-\t  sbitmap_zero (predecessors);\n+\t  bitmap_clear (predecessors);\n \t  find_predecessors (predecessors, g, nodes_ordered);\n-\t  sbitmap_a_and_b (workset, predecessors, scc);\n+\t  bitmap_and (workset, predecessors, scc);\n \t}\n       else\n \t{\n-\t  while (!sbitmap_equal (workset, zero_bitmap))\n+\t  while (!bitmap_equal_p (workset, zero_bitmap))\n \t    {\n \t      v = find_max_dv_min_mob (g, workset);\n \t      v_node = &g->nodes[v];\n \t      node_order[pos++] = v;\n \t      v_node_preds = NODE_PREDECESSORS (v_node);\n-\t      sbitmap_a_and_b (tmp, v_node_preds, scc);\n+\t      bitmap_and (tmp, v_node_preds, scc);\n \n \t      /* Don't consider the already ordered predecessors again.  */\n-\t      sbitmap_difference (tmp, tmp, nodes_ordered);\n-\t      sbitmap_a_or_b (workset, workset, tmp);\n+\t      bitmap_and_compl (tmp, tmp, nodes_ordered);\n+\t      bitmap_ior (workset, workset, tmp);\n \t      RESET_BIT (workset, v);\n \t      SET_BIT (nodes_ordered, v);\n \t    }\n \t  dir = TOPDOWN;\n-\t  sbitmap_zero (successors);\n+\t  bitmap_clear (successors);\n \t  find_successors (successors, g, nodes_ordered);\n-\t  sbitmap_a_and_b (workset, successors, scc);\n+\t  bitmap_and (workset, successors, scc);\n \t}\n     }\n   sbitmap_free (tmp);"}, {"sha": "4186183ee54227ce8e5cc2b646d50c308d6ef6db", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -2874,7 +2874,7 @@ split_all_insns (void)\n   basic_block bb;\n \n   blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (blocks);\n+  bitmap_clear (blocks);\n   changed = false;\n \n   FOR_EACH_BB_REVERSE (bb)"}, {"sha": "c2fc79dbfdb4966085e160fff85906aaf88edcff", "filename": "gcc/regcprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1045,7 +1045,7 @@ copyprop_hardreg_forward (void)\n   all_vd = XNEWVEC (struct value_data, last_basic_block);\n \n   visited = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     debug_insn_changes_pool"}, {"sha": "03bd72477953d5ef25b4d63655e4563f4fbc644f", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1302,7 +1302,7 @@ reload (rtx first, int global)\n     {\n       sbitmap blocks;\n       blocks = sbitmap_alloc (last_basic_block);\n-      sbitmap_ones (blocks);\n+      bitmap_ones (blocks);\n       find_many_sub_basic_blocks (blocks);\n       sbitmap_free (blocks);\n     }"}, {"sha": "737b0cd7fa78e1676d38581984b35f6c625e7644", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 48, "deletions": 140, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -238,7 +238,7 @@ sbitmap_vector_alloc (unsigned int n_vecs, unsigned int n_elms)\n /* Copy sbitmap SRC to DST.  */\n \n void\n-sbitmap_copy (sbitmap dst, const_sbitmap src)\n+bitmap_copy (sbitmap dst, const_sbitmap src)\n {\n   memcpy (dst->elms, src->elms, sizeof (SBITMAP_ELT_TYPE) * dst->size);\n   if (dst->popcount)\n@@ -248,7 +248,7 @@ sbitmap_copy (sbitmap dst, const_sbitmap src)\n /* Copy the first N elements of sbitmap SRC to DST.  */\n \n void\n-sbitmap_copy_n (sbitmap dst, const_sbitmap src, unsigned int n)\n+bitmap_copy_n (sbitmap dst, const_sbitmap src, unsigned int n)\n {\n   memcpy (dst->elms, src->elms, sizeof (SBITMAP_ELT_TYPE) * n);\n   if (dst->popcount)\n@@ -257,15 +257,15 @@ sbitmap_copy_n (sbitmap dst, const_sbitmap src, unsigned int n)\n \n /* Determine if a == b.  */\n int\n-sbitmap_equal (const_sbitmap a, const_sbitmap b)\n+bitmap_equal_p (const_sbitmap a, const_sbitmap b)\n {\n   return !memcmp (a->elms, b->elms, sizeof (SBITMAP_ELT_TYPE) * a->size);\n }\n \n /* Return true if the bitmap is empty.  */\n \n bool\n-sbitmap_empty_p (const_sbitmap bmap)\n+bitmap_empty_p (const_sbitmap bmap)\n {\n   unsigned int i;\n   for (i=0; i<bmap->size; i++)\n@@ -279,7 +279,7 @@ sbitmap_empty_p (const_sbitmap bmap)\n    START.  */\n \n bool\n-sbitmap_range_empty_p (const_sbitmap bmap, unsigned int start, unsigned int n)\n+bitmap_range_empty_p (const_sbitmap bmap, unsigned int start, unsigned int n)\n {\n   unsigned int i = start / SBITMAP_ELT_BITS;\n   SBITMAP_ELT_TYPE elm;\n@@ -329,7 +329,7 @@ sbitmap_range_empty_p (const_sbitmap bmap, unsigned int start, unsigned int n)\n /* Zero all elements in a bitmap.  */\n \n void\n-sbitmap_zero (sbitmap bmap)\n+bitmap_clear (sbitmap bmap)\n {\n   memset (bmap->elms, 0, SBITMAP_SIZE_BYTES (bmap));\n   if (bmap->popcount)\n@@ -339,7 +339,7 @@ sbitmap_zero (sbitmap bmap)\n /* Set all elements in a bitmap to ones.  */\n \n void\n-sbitmap_ones (sbitmap bmap)\n+bitmap_ones (sbitmap bmap)\n {\n   unsigned int last_bit;\n \n@@ -361,31 +361,31 @@ sbitmap_ones (sbitmap bmap)\n /* Zero a vector of N_VECS bitmaps.  */\n \n void\n-sbitmap_vector_zero (sbitmap *bmap, unsigned int n_vecs)\n+bitmap_vector_clear (sbitmap *bmap, unsigned int n_vecs)\n {\n   unsigned int i;\n \n   for (i = 0; i < n_vecs; i++)\n-    sbitmap_zero (bmap[i]);\n+    bitmap_clear (bmap[i]);\n }\n \n /* Set a vector of N_VECS bitmaps to ones.  */\n \n void\n-sbitmap_vector_ones (sbitmap *bmap, unsigned int n_vecs)\n+bitmap_vector_ones (sbitmap *bmap, unsigned int n_vecs)\n {\n   unsigned int i;\n \n   for (i = 0; i < n_vecs; i++)\n-    sbitmap_ones (bmap[i]);\n+    bitmap_ones (bmap[i]);\n }\n \n /* Set DST to be A union (B - C).\n    DST = A | (B & ~C).\n    Returns true if any change is made.  */\n \n bool\n-sbitmap_union_of_diff_cg (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sbitmap c)\n+bitmap_ior_and_compl (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sbitmap c)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -406,26 +406,10 @@ sbitmap_union_of_diff_cg (sbitmap dst, const_sbitmap a, const_sbitmap b, const_s\n   return changed != 0;\n }\n \n-void\n-sbitmap_union_of_diff (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sbitmap c)\n-{\n-  unsigned int i, n = dst->size;\n-  sbitmap_ptr dstp = dst->elms;\n-  const_sbitmap_ptr ap = a->elms;\n-  const_sbitmap_ptr bp = b->elms;\n-  const_sbitmap_ptr cp = c->elms;\n-\n-  gcc_assert (!dst->popcount && !a->popcount\n-\t      && !b->popcount && !c->popcount);\n-\n-  for (i = 0; i < n; i++)\n-    *dstp++ = *ap++ | (*bp++ & ~*cp++);\n-}\n-\n /* Set bitmap DST to the bitwise negation of the bitmap SRC.  */\n \n void\n-sbitmap_not (sbitmap dst, const_sbitmap src)\n+bitmap_not (sbitmap dst, const_sbitmap src)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -437,7 +421,7 @@ sbitmap_not (sbitmap dst, const_sbitmap src)\n   for (i = 0; i < n; i++)\n     *dstp++ = ~*srcp++;\n \n-  /* Zero all bits past n_bits, by ANDing dst with sbitmap_ones.  */\n+  /* Zero all bits past n_bits, by ANDing dst with bitmap_ones.  */\n   last_bit = src->n_bits % SBITMAP_ELT_BITS;\n   if (last_bit)\n     dst->elms[n-1] = dst->elms[n-1]\n@@ -448,7 +432,7 @@ sbitmap_not (sbitmap dst, const_sbitmap src)\n    in A and the bits in B. i.e. dst = a & (~b).  */\n \n void\n-sbitmap_difference (sbitmap dst, const_sbitmap a, const_sbitmap b)\n+bitmap_and_compl (sbitmap dst, const_sbitmap a, const_sbitmap b)\n {\n   unsigned int i, dst_size = dst->size;\n   unsigned int min_size = dst->size;\n@@ -477,7 +461,7 @@ sbitmap_difference (sbitmap dst, const_sbitmap a, const_sbitmap b)\n    Return false otherwise.  */\n \n bool\n-sbitmap_any_common_bits (const_sbitmap a, const_sbitmap b)\n+bitmap_intersect_p (const_sbitmap a, const_sbitmap b)\n {\n   const_sbitmap_ptr ap = a->elms;\n   const_sbitmap_ptr bp = b->elms;\n@@ -495,35 +479,15 @@ sbitmap_any_common_bits (const_sbitmap a, const_sbitmap b)\n    Return nonzero if any change is made.  */\n \n bool\n-sbitmap_a_and_b_cg (sbitmap dst, const_sbitmap a, const_sbitmap b)\n-{\n-  unsigned int i, n = dst->size;\n-  sbitmap_ptr dstp = dst->elms;\n-  const_sbitmap_ptr ap = a->elms;\n-  const_sbitmap_ptr bp = b->elms;\n-  SBITMAP_ELT_TYPE changed = 0;\n-\n-  gcc_assert (!dst->popcount);\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      const SBITMAP_ELT_TYPE tmp = *ap++ & *bp++;\n-      changed |= *dstp ^ tmp;\n-      *dstp++ = tmp;\n-    }\n-\n-  return changed != 0;\n-}\n-\n-void\n-sbitmap_a_and_b (sbitmap dst, const_sbitmap a, const_sbitmap b)\n+bitmap_and (sbitmap dst, const_sbitmap a, const_sbitmap b)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n   const_sbitmap_ptr ap = a->elms;\n   const_sbitmap_ptr bp = b->elms;\n   bool has_popcount = dst->popcount != NULL;\n   unsigned char *popcountp = dst->popcount;\n+  bool anychange = false;\n \n   for (i = 0; i < n; i++)\n     {\n@@ -532,7 +496,10 @@ sbitmap_a_and_b (sbitmap dst, const_sbitmap a, const_sbitmap b)\n \t{\n \t  bool wordchanged = (*dstp ^ tmp) != 0;\n \t  if (wordchanged)\n-\t    *popcountp = do_popcount (tmp);\n+\t    {\n+\t      *popcountp = do_popcount (tmp);\n+\t      anychange = true;\n+\t    }\n \t  popcountp++;\n \t}\n       *dstp++ = tmp;\n@@ -541,41 +508,22 @@ sbitmap_a_and_b (sbitmap dst, const_sbitmap a, const_sbitmap b)\n   if (has_popcount)\n     sbitmap_verify_popcount (dst);\n #endif\n+  return anychange;\n }\n \n /* Set DST to be (A xor B)).\n    Return nonzero if any change is made.  */\n \n bool\n-sbitmap_a_xor_b_cg (sbitmap dst, const_sbitmap a, const_sbitmap b)\n-{\n-  unsigned int i, n = dst->size;\n-  sbitmap_ptr dstp = dst->elms;\n-  const_sbitmap_ptr ap = a->elms;\n-  const_sbitmap_ptr bp = b->elms;\n-  SBITMAP_ELT_TYPE changed = 0;\n-\n-  gcc_assert (!dst->popcount);\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      const SBITMAP_ELT_TYPE tmp = *ap++ ^ *bp++;\n-      changed |= *dstp ^ tmp;\n-      *dstp++ = tmp;\n-    }\n-\n-  return changed != 0;\n-}\n-\n-void\n-sbitmap_a_xor_b (sbitmap dst, const_sbitmap a, const_sbitmap b)\n+bitmap_xor (sbitmap dst, const_sbitmap a, const_sbitmap b)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n   const_sbitmap_ptr ap = a->elms;\n   const_sbitmap_ptr bp = b->elms;\n   bool has_popcount = dst->popcount != NULL;\n   unsigned char *popcountp = dst->popcount;\n+  bool anychange = false;\n \n   for (i = 0; i < n; i++)\n     {\n@@ -584,7 +532,10 @@ sbitmap_a_xor_b (sbitmap dst, const_sbitmap a, const_sbitmap b)\n \t{\n \t  bool wordchanged = (*dstp ^ tmp) != 0;\n \t  if (wordchanged)\n-\t    *popcountp = do_popcount (tmp);\n+\t    {\n+\t      *popcountp = do_popcount (tmp);\n+\t      anychange = true;\n+\t    }\n \t  popcountp++;\n \t}\n       *dstp++ = tmp;\n@@ -593,41 +544,22 @@ sbitmap_a_xor_b (sbitmap dst, const_sbitmap a, const_sbitmap b)\n   if (has_popcount)\n     sbitmap_verify_popcount (dst);\n #endif\n+  return anychange;\n }\n \n /* Set DST to be (A or B)).\n    Return nonzero if any change is made.  */\n \n bool\n-sbitmap_a_or_b_cg (sbitmap dst, const_sbitmap a, const_sbitmap b)\n-{\n-  unsigned int i, n = dst->size;\n-  sbitmap_ptr dstp = dst->elms;\n-  const_sbitmap_ptr ap = a->elms;\n-  const_sbitmap_ptr bp = b->elms;\n-  SBITMAP_ELT_TYPE changed = 0;\n-\n-  gcc_assert (!dst->popcount);\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      const SBITMAP_ELT_TYPE tmp = *ap++ | *bp++;\n-      changed |= *dstp ^ tmp;\n-      *dstp++ = tmp;\n-    }\n-\n-  return changed != 0;\n-}\n-\n-void\n-sbitmap_a_or_b (sbitmap dst, const_sbitmap a, const_sbitmap b)\n+bitmap_ior (sbitmap dst, const_sbitmap a, const_sbitmap b)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n   const_sbitmap_ptr ap = a->elms;\n   const_sbitmap_ptr bp = b->elms;\n   bool has_popcount = dst->popcount != NULL;\n   unsigned char *popcountp = dst->popcount;\n+  bool anychange = false;\n \n   for (i = 0; i < n; i++)\n     {\n@@ -636,7 +568,10 @@ sbitmap_a_or_b (sbitmap dst, const_sbitmap a, const_sbitmap b)\n \t{\n \t  bool wordchanged = (*dstp ^ tmp) != 0;\n \t  if (wordchanged)\n-\t    *popcountp = do_popcount (tmp);\n+\t    {\n+\t      *popcountp = do_popcount (tmp);\n+\t      anychange = true;\n+\t    }\n \t  popcountp++;\n \t}\n       *dstp++ = tmp;\n@@ -645,12 +580,13 @@ sbitmap_a_or_b (sbitmap dst, const_sbitmap a, const_sbitmap b)\n   if (has_popcount)\n     sbitmap_verify_popcount (dst);\n #endif\n+  return anychange;\n }\n \n /* Return nonzero if A is a subset of B.  */\n \n bool\n-sbitmap_a_subset_b_p (const_sbitmap a, const_sbitmap b)\n+bitmap_subset_p (const_sbitmap a, const_sbitmap b)\n {\n   unsigned int i, n = a->size;\n   const_sbitmap_ptr ap, bp;\n@@ -666,7 +602,7 @@ sbitmap_a_subset_b_p (const_sbitmap a, const_sbitmap b)\n    Return nonzero if any change is made.  */\n \n bool\n-sbitmap_a_or_b_and_c_cg (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sbitmap c)\n+bitmap_or_and (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sbitmap c)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -687,26 +623,11 @@ sbitmap_a_or_b_and_c_cg (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sb\n   return changed != 0;\n }\n \n-void\n-sbitmap_a_or_b_and_c (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sbitmap c)\n-{\n-  unsigned int i, n = dst->size;\n-  sbitmap_ptr dstp = dst->elms;\n-  const_sbitmap_ptr ap = a->elms;\n-  const_sbitmap_ptr bp = b->elms;\n-  const_sbitmap_ptr cp = c->elms;\n-\n-  gcc_assert (!dst->popcount);\n-\n-  for (i = 0; i < n; i++)\n-    *dstp++ = *ap++ | (*bp++ & *cp++);\n-}\n-\n /* Set DST to be (A and (B or C)).\n    Return nonzero if any change is made.  */\n \n bool\n-sbitmap_a_and_b_or_c_cg (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sbitmap c)\n+bitmap_and_or (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sbitmap c)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -727,23 +648,10 @@ sbitmap_a_and_b_or_c_cg (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sb\n   return changed != 0;\n }\n \n-void\n-sbitmap_a_and_b_or_c (sbitmap dst, const_sbitmap a, const_sbitmap b, const_sbitmap c)\n-{\n-  unsigned int i, n = dst->size;\n-  sbitmap_ptr dstp = dst->elms;\n-  const_sbitmap_ptr ap = a->elms;\n-  const_sbitmap_ptr bp = b->elms;\n-  const_sbitmap_ptr cp = c->elms;\n-\n-  for (i = 0; i < n; i++)\n-    *dstp++ = *ap++ & (*bp++ | *cp++);\n-}\n-\n /* Return number of first bit set in the bitmap, -1 if none.  */\n \n int\n-sbitmap_first_set_bit (const_sbitmap bmap)\n+bitmap_first_set_bit (const_sbitmap bmap)\n {\n   unsigned int n = 0;\n   sbitmap_iterator sbi;\n@@ -756,7 +664,7 @@ sbitmap_first_set_bit (const_sbitmap bmap)\n /* Return number of last bit set in the bitmap, -1 if none.  */\n \n int\n-sbitmap_last_set_bit (const_sbitmap bmap)\n+bitmap_last_set_bit (const_sbitmap bmap)\n {\n   int i;\n   const SBITMAP_ELT_TYPE *const ptr = bmap->elms;\n@@ -786,7 +694,7 @@ sbitmap_last_set_bit (const_sbitmap bmap)\n }\n \n void\n-dump_sbitmap (FILE *file, const_sbitmap bmap)\n+dump_bitmap (FILE *file, const_sbitmap bmap)\n {\n   unsigned int i, n, j;\n   unsigned int set_size = bmap->size;\n@@ -807,7 +715,7 @@ dump_sbitmap (FILE *file, const_sbitmap bmap)\n }\n \n void\n-dump_sbitmap_file (FILE *file, const_sbitmap bmap)\n+dump_bitmap_file (FILE *file, const_sbitmap bmap)\n {\n   unsigned int i, pos;\n \n@@ -830,13 +738,13 @@ dump_sbitmap_file (FILE *file, const_sbitmap bmap)\n }\n \n DEBUG_FUNCTION void\n-debug_sbitmap (const_sbitmap bmap)\n+debug_bitmap (const_sbitmap bmap)\n {\n-  dump_sbitmap_file (stderr, bmap);\n+  dump_bitmap_file (stderr, bmap);\n }\n \n void\n-dump_sbitmap_vector (FILE *file, const char *title, const char *subtitle,\n+dump_bitmap_vector (FILE *file, const char *title, const char *subtitle,\n \t\t     sbitmap *bmaps, int n_maps)\n {\n   int i;\n@@ -845,7 +753,7 @@ dump_sbitmap_vector (FILE *file, const char *title, const char *subtitle,\n   for (i = 0; i < n_maps; i++)\n     {\n       fprintf (file, \"%s %d\\n\", subtitle, i);\n-      dump_sbitmap (file, bmaps[i]);\n+      dump_bitmap (file, bmaps[i]);\n     }\n \n   fprintf (file, \"\\n\");"}, {"sha": "f7fa7706d0a6bb73e0d7adbc0f185c339752ce6b", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 49, "deletions": 50, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -41,24 +41,24 @@ along with GCC; see the file COPYING3.  If not see\n    Most other operations on this set representation are O(U) where U is\n    the size of the set universe:\n \n-     * clear\t\t\t: sbitmap_zero\n+     * clear\t\t\t: bitmap_clear\n      * cardinality\t\t: sbitmap_popcount\n-     * choose_one\t\t: sbitmap_first_set_bit /\n-\t\t\t\t  sbitmap_last_set_bit\n+     * choose_one\t\t: bitmap_first_set_bit /\n+\t\t\t\t  bitmap_last_set_bit\n      * forall\t\t\t: EXECUTE_IF_SET_IN_SBITMAP\n-     * set_copy\t\t\t: sbitmap_copy / sbitmap_copy_n\n-     * set_intersection\t\t: sbitmap_a_and_b\n-     * set_union\t\t: sbitmap_a_or_b\n-     * set_difference\t\t: sbitmap_difference\n+     * set_copy\t\t\t: bitmap_copy / bitmap_copy_n\n+     * set_intersection\t\t: bitmap_and\n+     * set_union\t\t: bitmap_ior\n+     * set_difference\t\t: bitmap_and_compl\n      * set_disjuction\t\t: (not implemented)\n-     * set_compare\t\t: sbitmap_equal\n+     * set_compare\t\t: bitmap_equal_p\n \n    Some operations on 3 sets that occur frequently in in data flow problems\n    are also implemented:\n \n-      * A | (B & C)\t\t: sbitmap_a_or_b_and_c\n-      * A | (B & ~C)\t\t: sbitmap_union_of_diff\n-      * A & (B | C)\t\t: sbitmap_a_and_b_or_c\n+      * A | (B & C)\t\t: bitmap_or_and\n+      * A | (B & ~C)\t\t: bitmap_ior_and_compl\n+      * A & (B | C)\t\t: bitmap_and_or\n \n    Most of the set functions have two variants: One that returns non-zero\n    if members were added or removed from the target set, and one that just\n@@ -265,54 +265,53 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n-#define sbitmap_free(MAP)\t\t(free((MAP)->popcount), free((MAP)))\n-#define sbitmap_vector_free(VEC)\tfree(VEC)\n+inline void sbitmap_free (sbitmap map)\n+{\n+  free (map->popcount);\n+  free (map);\n+}\n \n-extern void dump_sbitmap (FILE *, const_sbitmap);\n-extern void dump_sbitmap_file (FILE *, const_sbitmap);\n-extern void dump_sbitmap_vector (FILE *, const char *, const char *, sbitmap *,\n+inline void sbitmap_vector_free (sbitmap * vec)\n+{\n+  free (vec);\n+}\n+\n+extern void dump_bitmap (FILE *, const_sbitmap);\n+extern void dump_bitmap_file (FILE *, const_sbitmap);\n+extern void dump_bitmap_vector (FILE *, const char *, const char *, sbitmap *,\n \t\t\t\t int);\n extern sbitmap sbitmap_alloc (unsigned int);\n extern sbitmap sbitmap_alloc_with_popcount (unsigned int);\n extern sbitmap *sbitmap_vector_alloc (unsigned int, unsigned int);\n extern sbitmap sbitmap_resize (sbitmap, unsigned int, int);\n-extern void sbitmap_copy (sbitmap, const_sbitmap);\n-extern void sbitmap_copy_n (sbitmap, const_sbitmap, unsigned int);\n-extern int sbitmap_equal (const_sbitmap, const_sbitmap);\n-extern bool sbitmap_empty_p (const_sbitmap);\n-extern bool sbitmap_range_empty_p (const_sbitmap, unsigned int, unsigned int);\n-extern void sbitmap_zero (sbitmap);\n-extern void sbitmap_ones (sbitmap);\n-extern void sbitmap_vector_zero (sbitmap *, unsigned int);\n-extern void sbitmap_vector_ones (sbitmap *, unsigned int);\n-\n-extern void sbitmap_union_of_diff (sbitmap, const_sbitmap,\n-\t\t\t\t   const_sbitmap, const_sbitmap);\n-extern bool sbitmap_union_of_diff_cg (sbitmap, const_sbitmap,\n+extern void bitmap_copy (sbitmap, const_sbitmap);\n+extern void bitmap_copy_n (sbitmap, const_sbitmap, unsigned int);\n+extern int bitmap_equal_p (const_sbitmap, const_sbitmap);\n+extern bool bitmap_empty_p (const_sbitmap);\n+extern bool bitmap_range_empty_p (const_sbitmap, unsigned int, unsigned int);\n+extern void bitmap_clear (sbitmap);\n+extern void bitmap_ones (sbitmap);\n+extern void bitmap_vector_clear (sbitmap *, unsigned int);\n+extern void bitmap_vector_ones (sbitmap *, unsigned int);\n+\n+extern bool bitmap_ior_and_compl (sbitmap, const_sbitmap,\n \t\t\t\t      const_sbitmap, const_sbitmap);\n-extern void sbitmap_difference (sbitmap, const_sbitmap, const_sbitmap);\n-extern void sbitmap_not (sbitmap, const_sbitmap);\n-extern void sbitmap_a_or_b_and_c (sbitmap, const_sbitmap,\n-\t\t\t\t  const_sbitmap, const_sbitmap);\n-extern bool sbitmap_a_or_b_and_c_cg (sbitmap, const_sbitmap,\n+extern void bitmap_and_compl (sbitmap, const_sbitmap, const_sbitmap);\n+extern void bitmap_not (sbitmap, const_sbitmap);\n+extern bool bitmap_or_and (sbitmap, const_sbitmap,\n \t\t\t\t     const_sbitmap, const_sbitmap);\n-extern void sbitmap_a_and_b_or_c (sbitmap, const_sbitmap,\n-\t\t\t\t  const_sbitmap, const_sbitmap);\n-extern bool sbitmap_a_and_b_or_c_cg (sbitmap, const_sbitmap,\n+extern bool bitmap_and_or (sbitmap, const_sbitmap,\n \t\t\t\t     const_sbitmap, const_sbitmap);\n-extern bool sbitmap_any_common_bits (const_sbitmap, const_sbitmap);\n-extern void sbitmap_a_and_b (sbitmap, const_sbitmap, const_sbitmap);\n-extern bool sbitmap_a_and_b_cg (sbitmap, const_sbitmap, const_sbitmap);\n-extern void sbitmap_a_or_b (sbitmap, const_sbitmap, const_sbitmap);\n-extern bool sbitmap_a_or_b_cg (sbitmap, const_sbitmap, const_sbitmap);\n-extern void sbitmap_a_xor_b (sbitmap, const_sbitmap, const_sbitmap);\n-extern bool sbitmap_a_xor_b_cg (sbitmap, const_sbitmap, const_sbitmap);\n-extern bool sbitmap_a_subset_b_p (const_sbitmap, const_sbitmap);\n-\n-extern int sbitmap_first_set_bit (const_sbitmap);\n-extern int sbitmap_last_set_bit (const_sbitmap);\n-\n-extern void debug_sbitmap (const_sbitmap);\n+extern bool bitmap_intersect_p (const_sbitmap, const_sbitmap);\n+extern bool bitmap_and (sbitmap, const_sbitmap, const_sbitmap);\n+extern bool bitmap_ior (sbitmap, const_sbitmap, const_sbitmap);\n+extern bool bitmap_xor (sbitmap, const_sbitmap, const_sbitmap);\n+extern bool bitmap_subset_p (const_sbitmap, const_sbitmap);\n+\n+extern int bitmap_first_set_bit (const_sbitmap);\n+extern int bitmap_last_set_bit (const_sbitmap);\n+\n+extern void debug_bitmap (const_sbitmap);\n extern sbitmap sbitmap_realloc (sbitmap, unsigned int);\n extern unsigned long sbitmap_popcount (const_sbitmap, unsigned long);\n extern void sbitmap_verify_popcount (const_sbitmap);"}, {"sha": "a0e62b6cc4b56b223ddb58864696f3f6446045d9", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -644,16 +644,16 @@ haifa_find_rgns (void)\n   stack = XNEWVEC (edge_iterator, n_edges);\n \n   inner = sbitmap_alloc (last_basic_block);\n-  sbitmap_ones (inner);\n+  bitmap_ones (inner);\n \n   header = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (header);\n+  bitmap_clear (header);\n \n   in_queue = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (in_queue);\n+  bitmap_clear (in_queue);\n \n   in_stack = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (in_stack);\n+  bitmap_clear (in_stack);\n \n   for (i = 0; i < last_basic_block; i++)\n     max_hdr[i] = -1;\n@@ -798,7 +798,7 @@ haifa_find_rgns (void)\n         {\n           degree1 = XNEWVEC (int, last_basic_block);\n           extended_rgn_header = sbitmap_alloc (last_basic_block);\n-          sbitmap_zero (extended_rgn_header);\n+          bitmap_clear (extended_rgn_header);\n \t}\n \n       /* Find blocks which are inner loop headers.  We still have non-reducible\n@@ -1035,7 +1035,7 @@ haifa_find_rgns (void)\n         {\n           free (degree1);\n \n-          sbitmap_a_or_b (header, header, extended_rgn_header);\n+          bitmap_ior (header, header, extended_rgn_header);\n           sbitmap_free (extended_rgn_header);\n \n           extend_rgns (degree, &idx, header, max_hdr);\n@@ -1416,7 +1416,7 @@ compute_dom_prob_ps (int bb)\n   prob[bb] = 0;\n \n   /* Initialize dom[bb] to '111..1'.  */\n-  sbitmap_ones (dom[bb]);\n+  bitmap_ones (dom[bb]);\n \n   FOR_EACH_EDGE (in_edge, in_ei, BASIC_BLOCK (BB_TO_BLOCK (bb))->preds)\n     {\n@@ -1428,13 +1428,13 @@ compute_dom_prob_ps (int bb)\n \tcontinue;\n \n       pred_bb = BLOCK_TO_BB (in_edge->src->index);\n-      sbitmap_a_and_b (dom[bb], dom[bb], dom[pred_bb]);\n-      sbitmap_a_or_b (ancestor_edges[bb],\n+      bitmap_and (dom[bb], dom[bb], dom[pred_bb]);\n+      bitmap_ior (ancestor_edges[bb],\n \t\t      ancestor_edges[bb], ancestor_edges[pred_bb]);\n \n       SET_BIT (ancestor_edges[bb], EDGE_TO_BIT (in_edge));\n \n-      sbitmap_a_or_b (pot_split[bb], pot_split[bb], pot_split[pred_bb]);\n+      bitmap_ior (pot_split[bb], pot_split[bb], pot_split[pred_bb]);\n \n       FOR_EACH_EDGE (out_edge, out_ei, in_edge->src->succs)\n \tSET_BIT (pot_split[bb], EDGE_TO_BIT (out_edge));\n@@ -1443,7 +1443,7 @@ compute_dom_prob_ps (int bb)\n     }\n \n   SET_BIT (dom[bb], bb);\n-  sbitmap_difference (pot_split[bb], pot_split[bb], ancestor_edges[bb]);\n+  bitmap_and_compl (pot_split[bb], pot_split[bb], ancestor_edges[bb]);\n \n   if (sched_verbose >= 2)\n     fprintf (sched_dump, \";;  bb_prob(%d, %d) = %3d\\n\", bb, BB_TO_BLOCK (bb),\n@@ -1459,9 +1459,9 @@ static void\n split_edges (int bb_src, int bb_trg, edgelst *bl)\n {\n   sbitmap src = sbitmap_alloc (SBITMAP_SIZE (pot_split[bb_src]));\n-  sbitmap_copy (src, pot_split[bb_src]);\n+  bitmap_copy (src, pot_split[bb_src]);\n \n-  sbitmap_difference (src, src, pot_split[bb_trg]);\n+  bitmap_and_compl (src, src, pot_split[bb_trg]);\n   extract_edgelst (src, bl);\n   sbitmap_free (src);\n }\n@@ -1542,7 +1542,7 @@ compute_trg_info (int trg)\n \t     overrunning the end of the bblst_table.  */\n \n \t  update_idx = 0;\n-\t  sbitmap_zero (visited);\n+\t  bitmap_clear (visited);\n \t  for (j = 0; j < el.nr_members; j++)\n \t    {\n \t      block = el.first_member[j]->src;\n@@ -3177,7 +3177,7 @@ sched_rgn_compute_dependencies (int rgn)\n \n       /* Initialize bitmap used in add_branch_dependences.  */\n       insn_referenced = sbitmap_alloc (sched_max_luid);\n-      sbitmap_zero (insn_referenced);\n+      bitmap_clear (insn_referenced);\n \n       /* Compute backward dependencies.  */\n       for (bb = 0; bb < current_nr_blocks; bb++)\n@@ -3217,7 +3217,7 @@ sched_rgn_local_init (int rgn)\n       prob = XNEWVEC (int, current_nr_blocks);\n \n       dom = sbitmap_vector_alloc (current_nr_blocks, current_nr_blocks);\n-      sbitmap_vector_zero (dom, current_nr_blocks);\n+      bitmap_vector_clear (dom, current_nr_blocks);\n \n       /* Use ->aux to implement EDGE_TO_BIT mapping.  */\n       rgn_nr_edges = 0;\n@@ -3241,9 +3241,9 @@ sched_rgn_local_init (int rgn)\n \n       /* Split edges.  */\n       pot_split = sbitmap_vector_alloc (current_nr_blocks, rgn_nr_edges);\n-      sbitmap_vector_zero (pot_split, current_nr_blocks);\n+      bitmap_vector_clear (pot_split, current_nr_blocks);\n       ancestor_edges = sbitmap_vector_alloc (current_nr_blocks, rgn_nr_edges);\n-      sbitmap_vector_zero (ancestor_edges, current_nr_blocks);\n+      bitmap_vector_clear (ancestor_edges, current_nr_blocks);\n \n       /* Compute probabilities, dominators, split_edges.  */\n       for (bb = 0; bb < current_nr_blocks; bb++)"}, {"sha": "01fc2c4253754ff129258511f027119663fac092", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -6094,7 +6094,7 @@ sel_init_pipelining (void)\n   current_loop_nest = NULL;\n \n   bbs_in_loop_rgns = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (bbs_in_loop_rgns);\n+  bitmap_clear (bbs_in_loop_rgns);\n \n   recompute_rev_top_order ();\n }"}, {"sha": "f51e8b94371fbaf8d114840ce1436b783f4577dc", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -6775,7 +6775,7 @@ init_seqno (bitmap blocks_to_reschedule, basic_block from)\n \n   if (blocks_to_reschedule)\n     {\n-      sbitmap_ones (visited_bbs);\n+      bitmap_ones (visited_bbs);\n       EXECUTE_IF_SET_IN_BITMAP (blocks_to_reschedule, 0, bbi, bi)\n         {\n \t  gcc_assert (BLOCK_TO_BB (bbi) < current_nr_blocks);\n@@ -6784,7 +6784,7 @@ init_seqno (bitmap blocks_to_reschedule, basic_block from)\n     }\n   else\n     {\n-      sbitmap_zero (visited_bbs);\n+      bitmap_clear (visited_bbs);\n       from = EBB_FIRST_BB (0);\n     }\n "}, {"sha": "f6712f49bc35668c04a102b7dd1e00da230b47d7", "filename": "gcc/store-motion.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -849,7 +849,7 @@ remove_reachable_equiv_notes (basic_block bb, struct st_expr *smexpr)\n   sp = 0;\n   ei = ei_start (bb->succs);\n \n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n \n   act = (EDGE_COUNT (ei_container (ei)) > 0 ? EDGE_I (ei_container (ei), 0) : NULL);\n   while (1)\n@@ -1014,10 +1014,10 @@ build_store_vectors (void)\n   /* Build the gen_vector. This is any store in the table which is not killed\n      by aliasing later in its block.  */\n   st_avloc = sbitmap_vector_alloc (last_basic_block, num_stores);\n-  sbitmap_vector_zero (st_avloc, last_basic_block);\n+  bitmap_vector_clear (st_avloc, last_basic_block);\n \n   st_antloc = sbitmap_vector_alloc (last_basic_block, num_stores);\n-  sbitmap_vector_zero (st_antloc, last_basic_block);\n+  bitmap_vector_clear (st_antloc, last_basic_block);\n \n   for (ptr = first_st_expr (); ptr != NULL; ptr = next_st_expr (ptr))\n     {\n@@ -1050,10 +1050,10 @@ build_store_vectors (void)\n     }\n \n   st_kill = sbitmap_vector_alloc (last_basic_block, num_stores);\n-  sbitmap_vector_zero (st_kill, last_basic_block);\n+  bitmap_vector_clear (st_kill, last_basic_block);\n \n   st_transp = sbitmap_vector_alloc (last_basic_block, num_stores);\n-  sbitmap_vector_zero (st_transp, last_basic_block);\n+  bitmap_vector_clear (st_transp, last_basic_block);\n   regs_set_in_block = XNEWVEC (int, max_gcse_regno);\n \n   FOR_EACH_BB (bb)\n@@ -1092,10 +1092,10 @@ build_store_vectors (void)\n \n   if (dump_file)\n     {\n-      dump_sbitmap_vector (dump_file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"st_kill\", \"\", st_kill, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"st_transp\", \"\", st_transp, last_basic_block);\n-      dump_sbitmap_vector (dump_file, \"st_avloc\", \"\", st_avloc, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_kill\", \"\", st_kill, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_transp\", \"\", st_transp, last_basic_block);\n+      dump_bitmap_vector (dump_file, \"st_avloc\", \"\", st_avloc, last_basic_block);\n     }\n }\n "}, {"sha": "98132e0d0c39f246b7da22014f2fd96251cfb645", "filename": "gcc/testsuite/gcc.dg/sms-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-4.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1,4 +1,4 @@\n-/* Inspired from sbitmap_a_or_b_and_c_cg function in sbitmap.c.  */\n+/* Inspired from bitmap_or_and function in sbitmap.c.  */\n /* { dg-do run } */\n /* { dg-options \"-O2 -fmodulo-sched -fmodulo-sched-allow-regmoves -fdump-rtl-sms\" } */\n /* { dg-options \"-O2 -fmodulo-sched -fmodulo-sched-allow-regmoves -fdump-rtl-sms --param sms-min-sc=1\" { target powerpc*-*-* } } */"}, {"sha": "cbd5aacf55a65b3101f114ee6713802e4369e1f5", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -238,7 +238,7 @@ tail_duplicate (void)\n   /* Create an oversized sbitmap to reduce the chance that we need to\n      resize it.  */\n   bb_seen = sbitmap_alloc (last_basic_block * 2);\n-  sbitmap_zero (bb_seen);\n+  bitmap_clear (bb_seen);\n   initialize_original_copy_tables ();\n \n   if (profile_info && flag_branch_probabilities)"}, {"sha": "9042f068835c33e9f759cb1cc17cc9781168113e", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -3525,8 +3525,8 @@ remove_unreachable_handlers (void)\n   r_reachable = sbitmap_alloc (VEC_length (eh_region, cfun->eh->region_array));\n   lp_reachable\n     = sbitmap_alloc (VEC_length (eh_landing_pad, cfun->eh->lp_array));\n-  sbitmap_zero (r_reachable);\n-  sbitmap_zero (lp_reachable);\n+  bitmap_clear (r_reachable);\n+  bitmap_clear (lp_reachable);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -3571,9 +3571,9 @@ remove_unreachable_handlers (void)\n       fprintf (dump_file, \"Before removal of unreachable regions:\\n\");\n       dump_eh_tree (dump_file, cfun);\n       fprintf (dump_file, \"Reachable regions: \");\n-      dump_sbitmap_file (dump_file, r_reachable);\n+      dump_bitmap_file (dump_file, r_reachable);\n       fprintf (dump_file, \"Reachable landing pads: \");\n-      dump_sbitmap_file (dump_file, lp_reachable);\n+      dump_bitmap_file (dump_file, lp_reachable);\n     }\n \n   for (r_nr = 1;\n@@ -3645,7 +3645,7 @@ remove_unreachable_handlers_no_lp (void)\n   basic_block bb;\n \n   r_reachable = sbitmap_alloc (VEC_length (eh_region, cfun->eh->region_array));\n-  sbitmap_zero (r_reachable);\n+  bitmap_clear (r_reachable);\n \n   FOR_EACH_BB (bb)\n     {"}, {"sha": "b3e887b258f8394708d5f784135ad1e602c0a1c7", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -2347,7 +2347,7 @@ rewrite_into_ssa (void)\n      mark_def_sites will add to this set those blocks that the renamer\n      should process.  */\n   interesting_blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (interesting_blocks);\n+  bitmap_clear (interesting_blocks);\n \n   /* Initialize dominance frontier.  */\n   dfs = XNEWVEC (bitmap_head, last_basic_block);\n@@ -2729,7 +2729,7 @@ dump_update_ssa (FILE *file)\n   if (!need_ssa_update_p (cfun))\n     return;\n \n-  if (new_ssa_names && sbitmap_first_set_bit (new_ssa_names) >= 0)\n+  if (new_ssa_names && bitmap_first_set_bit (new_ssa_names) >= 0)\n     {\n       sbitmap_iterator sbi;\n \n@@ -2779,10 +2779,10 @@ init_update_ssa (struct function *fn)\n      add_new_name_mapping are typically done after creating new SSA\n      names, so we'll need to reallocate these arrays.  */\n   old_ssa_names = sbitmap_alloc (num_ssa_names + NAME_SETS_GROWTH_FACTOR);\n-  sbitmap_zero (old_ssa_names);\n+  bitmap_clear (old_ssa_names);\n \n   new_ssa_names = sbitmap_alloc (num_ssa_names + NAME_SETS_GROWTH_FACTOR);\n-  sbitmap_zero (new_ssa_names);\n+  bitmap_clear (new_ssa_names);\n \n   bitmap_obstack_initialize (&update_ssa_obstack);\n \n@@ -3133,8 +3133,8 @@ update_ssa (unsigned update_flags)\n       /* If we only need to update virtuals, remove all the mappings for\n \t real names before proceeding.  The caller is responsible for\n \t having dealt with the name mappings before calling update_ssa.  */\n-      sbitmap_zero (old_ssa_names);\n-      sbitmap_zero (new_ssa_names);\n+      bitmap_clear (old_ssa_names);\n+      bitmap_clear (new_ssa_names);\n     }\n \n   gcc_assert (update_ssa_initialized_fn == cfun);\n@@ -3152,14 +3152,14 @@ update_ssa (unsigned update_flags)\n   /* If there are names defined in the replacement table, prepare\n      definition and use sites for all the names in NEW_SSA_NAMES and\n      OLD_SSA_NAMES.  */\n-  if (sbitmap_first_set_bit (new_ssa_names) >= 0)\n+  if (bitmap_first_set_bit (new_ssa_names) >= 0)\n     {\n       prepare_names_to_update (insert_phi_p);\n \n       /* If all the names in NEW_SSA_NAMES had been marked for\n \t removal, and there are no symbols to rename, then there's\n \t nothing else to do.  */\n-      if (sbitmap_first_set_bit (new_ssa_names) < 0\n+      if (bitmap_first_set_bit (new_ssa_names) < 0\n \t  && !cfun->gimple_df->ssa_renaming_needed)\n \tgoto done;\n     }\n@@ -3230,7 +3230,7 @@ update_ssa (unsigned update_flags)\n \tbitmap_initialize (&dfs[bb->index], &bitmap_default_obstack);\n       compute_dominance_frontiers (dfs);\n \n-      if (sbitmap_first_set_bit (old_ssa_names) >= 0)\n+      if (bitmap_first_set_bit (old_ssa_names) >= 0)\n \t{\n \t  sbitmap_iterator sbi;\n \n@@ -3240,7 +3240,7 @@ update_ssa (unsigned update_flags)\n \t     gain any new members).  Copy OLD_SSA_NAMES to a temporary\n \t     for traversal.  */\n \t  sbitmap tmp = sbitmap_alloc (SBITMAP_SIZE (old_ssa_names));\n-\t  sbitmap_copy (tmp, old_ssa_names);\n+\t  bitmap_copy (tmp, old_ssa_names);\n \t  EXECUTE_IF_SET_IN_SBITMAP (tmp, 0, i, sbi)\n \t    insert_updated_phi_nodes_for (ssa_name (i), dfs, blocks_to_update,\n \t                                  update_flags);\n@@ -3273,7 +3273,7 @@ update_ssa (unsigned update_flags)\n \n   /* Now start the renaming process at START_BB.  */\n   interesting_blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (interesting_blocks);\n+  bitmap_clear (interesting_blocks);\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_update, 0, i, bi)\n     SET_BIT (interesting_blocks, i);\n "}, {"sha": "5c8e43edb745fe6a3dbdba8d891e3ac46c510ac7", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -670,7 +670,7 @@ eliminate_phi (edge e, elim_graph g)\n     {\n       int part;\n \n-      sbitmap_zero (g->visited);\n+      bitmap_clear (g->visited);\n       VEC_truncate (int, g->stack, 0);\n \n       FOR_EACH_VEC_ELT (int, g->nodes, x, part)\n@@ -679,7 +679,7 @@ eliminate_phi (edge e, elim_graph g)\n \t    elim_forward (g, part);\n \t}\n \n-      sbitmap_zero (g->visited);\n+      bitmap_clear (g->visited);\n       while (VEC_length (int, g->stack) > 0)\n \t{\n \t  x = VEC_pop (int, g->stack);"}, {"sha": "0a98d52edc92d14378b2fdc6659303c0efcc0d3f", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1489,13 +1489,13 @@ tree_dce_init (bool aggressive)\n \tcontrol_dependence_map[i] = BITMAP_ALLOC (NULL);\n \n       last_stmt_necessary = sbitmap_alloc (last_basic_block);\n-      sbitmap_zero (last_stmt_necessary);\n+      bitmap_clear (last_stmt_necessary);\n       bb_contains_live_stmts = sbitmap_alloc (last_basic_block);\n-      sbitmap_zero (bb_contains_live_stmts);\n+      bitmap_clear (bb_contains_live_stmts);\n     }\n \n   processed = sbitmap_alloc (num_ssa_names + 1);\n-  sbitmap_zero (processed);\n+  bitmap_clear (processed);\n \n   worklist = VEC_alloc (gimple, heap, 64);\n   cfg_altered = false;\n@@ -1566,7 +1566,7 @@ perform_tree_ssa_dce (bool aggressive)\n       timevar_pop (TV_CONTROL_DEPENDENCES);\n \n       visited_control_parents = sbitmap_alloc (last_basic_block);\n-      sbitmap_zero (visited_control_parents);\n+      bitmap_clear (visited_control_parents);\n \n       mark_dfs_back_edges ();\n     }"}, {"sha": "19eca425775fd00af9c94dda05b14e70c1a09df3", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -815,7 +815,7 @@ tree_ssa_dominator_optimize (void)\n \t}\n \n       gimple_purge_all_dead_eh_edges (need_eh_cleanup);\n-      bitmap_zero (need_eh_cleanup);\n+      bitmap_clear (need_eh_cleanup);\n     }\n \n   statistics_counter_event (cfun, \"Redundant expressions eliminated\","}, {"sha": "d6b8fbda6649050bcc8e2b1becbcb287aeb1cfaf", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1008,7 +1008,7 @@ live_worklist (tree_live_info_p live)\n   sbitmap visited = sbitmap_alloc (last_basic_block + 1);\n   bitmap tmp = BITMAP_ALLOC (&liveness_bitmap_obstack);\n \n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n \n   /* Visit all the blocks in reverse order and propagate live on entry values\n      into the predecessors blocks.  */"}, {"sha": "3d39cb6d44395116115ad66f54b0190269ebfd1d", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -308,7 +308,7 @@ live_merge_and_clear (tree_live_info_p live, int p1, int p2)\n {\n   gcc_checking_assert (&live->livein[p1] && &live->livein[p2]);\n   bitmap_ior_into (&live->livein[p1], &live->livein[p2]);\n-  bitmap_zero (&live->livein[p2]);\n+  bitmap_clear (&live->livein[p2]);\n }\n \n "}, {"sha": "178e2eeb78357018480813f665a9d0d21d5df472", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -2578,7 +2578,7 @@ tree_ssa_lim_initialize (void)\n \n   bitmap_obstack_initialize (&lim_bitmap_obstack);\n \n-  sbitmap_zero (contains_call);\n+  bitmap_clear (contains_call);\n   FOR_EACH_BB (bb)\n     {\n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))"}, {"sha": "6cf6c6de95aefa561bc120342678bf8225f90cc3", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -520,7 +520,7 @@ try_unroll_loop_completely (struct loop *loop,\n \n       initialize_original_copy_tables ();\n       wont_exit = sbitmap_alloc (n_unroll + 1);\n-      sbitmap_ones (wont_exit);\n+      bitmap_ones (wont_exit);\n       RESET_BIT (wont_exit, 0);\n \n       if (!gimple_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),"}, {"sha": "9bca5e35e2444d78cce28ec269bf2487610e40d4", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -3076,7 +3076,7 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode,\n       HOST_WIDE_INT i;\n \n       valid_mult = sbitmap_alloc (2 * MAX_RATIO + 1);\n-      sbitmap_zero (valid_mult);\n+      bitmap_clear (valid_mult);\n       addr = gen_rtx_fmt_ee (MULT, address_mode, reg1, NULL_RTX);\n       for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n \t{"}, {"sha": "2b723cac972bc7f8f76353d4b70406c0f8ba2e5d", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1172,7 +1172,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   /* Unroll the loop and remove the exits in all iterations except for the\n      last one.  */\n   wont_exit = sbitmap_alloc (factor);\n-  sbitmap_ones (wont_exit);\n+  bitmap_ones (wont_exit);\n   RESET_BIT (wont_exit, factor - 1);\n \n   ok = gimple_duplicate_loop_to_header_edge"}, {"sha": "5864d68689ab538b634e35a7f993dd04aede4c7a", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -482,7 +482,7 @@ blocks_in_phiopt_order (void)\n #define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index))\n #define VISITED_P(BB) (TEST_BIT (visited, (BB)->index))\n \n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n \n   MARK_VISITED (ENTRY_BLOCK_PTR);\n   FOR_EACH_BB (x)"}, {"sha": "7f9ab8bfb6c4faa23ce1f3352104d4f9cffe5972", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -2457,7 +2457,7 @@ compute_antic (void)\n   /* If any predecessor edges are abnormal, we punt, so antic_in is empty.\n      We pre-build the map of blocks with incoming abnormal edges here.  */\n   has_abnormal_preds = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (has_abnormal_preds);\n+  bitmap_clear (has_abnormal_preds);\n \n   FOR_ALL_BB (block)\n     {\n@@ -2486,7 +2486,7 @@ compute_antic (void)\n   BB_VISITED (EXIT_BLOCK_PTR) = 1;\n \n   changed_blocks = sbitmap_alloc (last_basic_block + 1);\n-  sbitmap_ones (changed_blocks);\n+  bitmap_ones (changed_blocks);\n   while (changed)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2516,7 +2516,7 @@ compute_antic (void)\n \n   if (do_partial_partial)\n     {\n-      sbitmap_ones (changed_blocks);\n+      bitmap_ones (changed_blocks);\n       mark_dfs_back_edges ();\n       num_iterations = 0;\n       changed = true;"}, {"sha": "380cda397878d1a5e2692b1721c9dcc7a855dee2", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -487,10 +487,10 @@ ssa_prop_init (void)\n   varying_ssa_edges = VEC_alloc (gimple, gc, 20);\n \n   executable_blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (executable_blocks);\n+  bitmap_clear (executable_blocks);\n \n   bb_in_list = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (bb_in_list);\n+  bitmap_clear (bb_in_list);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_immediate_uses (dump_file);"}, {"sha": "b54ca39d75482732f2b81beed85548185ddca29b", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1282,7 +1282,7 @@ undistribute_ops_list (enum tree_code opcode,\n \n   /* Build a list of candidates to process.  */\n   candidates = sbitmap_alloc (length);\n-  sbitmap_zero (candidates);\n+  bitmap_clear (candidates);\n   nr_candidates = 0;\n   FOR_EACH_VEC_ELT (operand_entry_t, *ops, i, oe1)\n     {\n@@ -1315,7 +1315,7 @@ undistribute_ops_list (enum tree_code opcode,\n       fprintf (dump_file, \"searching for un-distribute opportunities \");\n       print_generic_expr (dump_file,\n \tVEC_index (operand_entry_t, *ops,\n-\t\t   sbitmap_first_set_bit (candidates))->op, 0);\n+\t\t   bitmap_first_set_bit (candidates))->op, 0);\n       fprintf (dump_file, \" %d\\n\", nr_candidates);\n     }\n \n@@ -1387,7 +1387,7 @@ undistribute_ops_list (enum tree_code opcode,\n \n       /* Now collect the operands in the outer chain that contain\n          the common operand in their inner chain.  */\n-      sbitmap_zero (candidates2);\n+      bitmap_clear (candidates2);\n       nr_candidates2 = 0;\n       EXECUTE_IF_SET_IN_SBITMAP (candidates, 0, i, sbi0)\n \t{\n@@ -1421,7 +1421,7 @@ undistribute_ops_list (enum tree_code opcode,\n \t{\n \t  operand_entry_t oe1, oe2;\n \t  gimple prod;\n-\t  int first = sbitmap_first_set_bit (candidates2);\n+\t  int first = bitmap_first_set_bit (candidates2);\n \n \t  /* Build the new addition chain.  */\n \t  oe1 = VEC_index (operand_entry_t, *ops, first);"}, {"sha": "8bfceb6ce878c37fbeed6884e30a1e6a411e5acc", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1203,7 +1203,7 @@ build_pred_graph (void)\n   graph->eq_rep = XNEWVEC (int, graph->size);\n   graph->direct_nodes = sbitmap_alloc (graph->size);\n   graph->address_taken = BITMAP_ALLOC (&predbitmap_obstack);\n-  sbitmap_zero (graph->direct_nodes);\n+  bitmap_clear (graph->direct_nodes);\n \n   for (j = 0; j < FIRST_REF_NODE; j++)\n     {\n@@ -1533,7 +1533,7 @@ init_topo_info (void)\n   size_t size = graph->size;\n   struct topo_info *ti = XNEW (struct topo_info);\n   ti->visited = sbitmap_alloc (size);\n-  sbitmap_zero (ti->visited);\n+  bitmap_clear (ti->visited);\n   ti->topo_order = VEC_alloc (unsigned, heap, 1);\n   return ti;\n }\n@@ -1811,9 +1811,9 @@ init_scc_info (size_t size)\n \n   si->current_index = 0;\n   si->visited = sbitmap_alloc (size);\n-  sbitmap_zero (si->visited);\n+  bitmap_clear (si->visited);\n   si->deleted = sbitmap_alloc (size);\n-  sbitmap_zero (si->deleted);\n+  bitmap_clear (si->deleted);\n   si->node_mapping = XNEWVEC (unsigned int, size);\n   si->dfs = XCNEWVEC (unsigned int, size);\n \n@@ -2166,7 +2166,7 @@ perform_var_substitution (constraint_graph_t graph)\n     if (!TEST_BIT (si->visited, si->node_mapping[i]))\n       condense_visit (graph, si, si->node_mapping[i]);\n \n-  sbitmap_zero (si->visited);\n+  bitmap_clear (si->visited);\n   /* Actually the label the nodes for pointer equivalences  */\n   for (i = 0; i < FIRST_REF_NODE; i++)\n     if (!TEST_BIT (si->visited, si->node_mapping[i]))"}, {"sha": "fca2e8e368f4ceff80c2b67d57f36843cd5bcb46", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -60,7 +60,7 @@ reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n     return false;\n \n   visited = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (visited);\n+  bitmap_clear (visited);\n   ret = true;\n \n   FOR_EACH_EDGE (e, ei, va_arg_bb->preds)"}, {"sha": "4f1966d5fff055b70ef8afe8d0ab184ea34e5d4d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -1289,7 +1289,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n           /* Check that the loads in the first sequence are different and there\n              are no gaps between them.  */\n           load_index = sbitmap_alloc (group_size);\n-          sbitmap_zero (load_index);\n+          bitmap_clear (load_index);\n           for (k = 0; k < group_size; k++)\n             {\n               first_group_load_index = VEC_index (int, load_permutation, k);\n@@ -1407,7 +1407,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n \n   supported = true;\n   load_index = sbitmap_alloc (group_size);\n-  sbitmap_zero (load_index);\n+  bitmap_clear (load_index);\n   for (j = 0; j < group_size; j++)\n     {\n       for (i = j * group_size, k = 0;"}, {"sha": "6547ed6235aa5e0c956d99e90777d7cdce40684d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -5661,15 +5661,15 @@ find_assert_locations (void)\n       if (!live[rpo[i]])\n \t{\n \t  live[rpo[i]] = sbitmap_alloc (num_ssa_names);\n-\t  sbitmap_zero (live[rpo[i]]);\n+\t  bitmap_clear (live[rpo[i]]);\n \t}\n \n       /* Process BB and update the live information with uses in\n          this block.  */\n       need_asserts |= find_assert_locations_1 (bb, live[rpo[i]]);\n \n       /* Merge liveness into the predecessor blocks and free it.  */\n-      if (!sbitmap_empty_p (live[rpo[i]]))\n+      if (!bitmap_empty_p (live[rpo[i]]))\n \t{\n \t  int pred_rpo = i;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -5681,9 +5681,9 @@ find_assert_locations (void)\n \t      if (!live[pred])\n \t\t{\n \t\t  live[pred] = sbitmap_alloc (num_ssa_names);\n-\t\t  sbitmap_zero (live[pred]);\n+\t\t  bitmap_clear (live[pred]);\n \t\t}\n-\t      sbitmap_a_or_b (live[pred], live[pred], live[rpo[i]]);\n+\t      bitmap_ior (live[pred], live[pred], live[rpo[i]]);\n \n \t      if (bb_rpo[pred] < pred_rpo)\n \t\tpred_rpo = bb_rpo[pred];"}, {"sha": "d5ab1d1e554d7238bdb3f78af4a835dedd358117", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61e445a74b138a2071a0af9f55c2d6e45fe2d5d/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=f61e445a74b138a2071a0af9f55c2d6e45fe2d5d", "patch": "@@ -6748,11 +6748,11 @@ vt_find_locations (void)\n   visited = sbitmap_alloc (last_basic_block);\n   in_worklist = sbitmap_alloc (last_basic_block);\n   in_pending = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (in_worklist);\n+  bitmap_clear (in_worklist);\n \n   FOR_EACH_BB (bb)\n     fibheap_insert (pending, bb_order[bb->index], bb);\n-  sbitmap_ones (in_pending);\n+  bitmap_ones (in_pending);\n \n   while (success && !fibheap_empty (pending))\n     {\n@@ -6763,7 +6763,7 @@ vt_find_locations (void)\n       in_pending = in_worklist;\n       in_worklist = sbitmap_swap;\n \n-      sbitmap_zero (visited);\n+      bitmap_clear (visited);\n \n       while (!fibheap_empty (worklist))\n \t{"}]}