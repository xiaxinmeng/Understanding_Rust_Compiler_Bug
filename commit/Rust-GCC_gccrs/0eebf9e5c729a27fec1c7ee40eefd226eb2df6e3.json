{"sha": "0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVlYmY5ZTVjNzI5YTI3ZmVjMWM3ZWU0MGVlZmQyMjZlYjJkZjZlMw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-04-19T02:29:14Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-04-19T02:29:14Z"}, "message": "Initial revision\n\nFrom-SVN: r33241", "tree": {"sha": "a34c7855d6892575054cbbe5a56f9671dc1c2e5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a34c7855d6892575054cbbe5a56f9671dc1c2e5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3/comments", "author": null, "committer": null, "parents": [{"sha": "48a840d9102deba764852463142b5118442908c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48a840d9102deba764852463142b5118442908c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48a840d9102deba764852463142b5118442908c7"}], "stats": {"total": 488, "additions": 488, "deletions": 0}, "files": [{"sha": "6abeda8a611a9479a0eadae6cf01f7888abd3867", "filename": "boehm-gc/dbg_mlc.h", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3/boehm-gc%2Fdbg_mlc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3/boehm-gc%2Fdbg_mlc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.h?ref=0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3", "patch": "@@ -0,0 +1,102 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+/*\n+ * This is mostly an internal header file.  Typical clients should\n+ * not use it.  Clients that define their own object kinds with\n+ * debugging allocators will probably want to include this, however.\n+ * No attempt is made to keep the namespace clean.  This should not be\n+ * included from header filrd that are frequently included by clients.\n+ */\n+\n+#ifndef _DBG_MLC_H\n+\n+#define _DBG_MLC_H\n+\n+# define I_HIDE_POINTERS\n+# include \"gc_priv.h\"\n+# ifdef KEEP_BACK_PTRS\n+#   include \"backptr.h\"\n+# endif\n+\n+# define START_FLAG ((word)0xfedcedcb)\n+# define END_FLAG ((word)0xbcdecdef)\n+\t/* Stored both one past the end of user object, and one before\t*/\n+\t/* the end of the object as seen by the allocator.\t\t*/\n+\n+\n+/* Object header */\n+typedef struct {\n+#   ifdef KEEP_BACK_PTRS\n+\tptr_t oh_back_ptr;\n+#\tdefine MARKED_FOR_FINALIZATION (ptr_t)(-1)\n+\t    /* Object was marked because it is finalizable.\t*/\n+#\tdefine MARKED_FROM_REGISTER (ptr_t)(-2)\n+\t    /* Object was marked from a rgister.  Hence the\t*/\n+\t    /* source of the reference doesn't have an address.\t*/\n+#\tifdef ALIGN_DOUBLE\n+\t  word oh_dummy;\n+#\tendif\n+#   endif\n+    char * oh_string;\t\t/* object descriptor string\t*/\n+    word oh_int;\t\t/* object descriptor integers\t*/\n+#   ifdef NEED_CALLINFO\n+      struct callinfo oh_ci[NFRAMES];\n+#   endif\n+    word oh_sz;\t\t\t/* Original malloc arg.\t\t*/\n+    word oh_sf;\t\t\t/* start flag */\n+} oh;\n+/* The size of the above structure is assumed not to dealign things,\t*/\n+/* and to be a multiple of the word length.\t\t\t\t*/\n+\n+#define DEBUG_BYTES (sizeof (oh) + sizeof (word))\n+#define USR_PTR_FROM_BASE(p) ((ptr_t)(p) + sizeof(oh))\n+\n+/* There is no reason to ever add a byte at the end explicitly, since we */\n+/* already add a guard word.\t\t\t\t\t\t */\n+#undef ROUNDED_UP_WORDS\n+#define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1) - 1)\n+\n+#ifdef SAVE_CALL_CHAIN\n+#   define ADD_CALL_CHAIN(base, ra) GC_save_callers(((oh *)(base)) -> oh_ci)\n+#   define PRINT_CALL_CHAIN(base) GC_print_callers(((oh *)(base)) -> oh_ci)\n+#else\n+# ifdef GC_ADD_CALLER\n+#   define ADD_CALL_CHAIN(base, ra) ((oh *)(base)) -> oh_ci[0].ci_pc = (ra)\n+#   define PRINT_CALL_CHAIN(base) GC_print_callers(((oh *)(base)) -> oh_ci)\n+# else\n+#   define ADD_CALL_CHAIN(base, ra)\n+#   define PRINT_CALL_CHAIN(base)\n+# endif\n+#endif\n+\n+# ifdef GC_ADD_CALLER\n+#   define OPT_RA ra,\n+# else\n+#   define OPT_RA\n+# endif\n+\n+\n+/* Check whether object with base pointer p has debugging info\t*/ \n+/* p is assumed to point to a legitimate object in our part\t*/\n+/* of the heap.\t\t\t\t\t\t\t*/\n+GC_bool GC_has_debug_info(/* p */);\n+\n+/* Store debugging info into p.  Return displaced pointer. */\n+/* Assumes we don't hold allocation lock.\t\t   */\n+ptr_t GC_store_debug_info(/* p, sz, string, integer */);\n+\n+#endif /* _DBG_MLC_H */"}, {"sha": "ba51cbe498fa1556554fe18a81a87b579f1e3bf6", "filename": "boehm-gc/gcj_mlc.c", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3/boehm-gc%2Fgcj_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3/boehm-gc%2Fgcj_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcj_mlc.c?ref=0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3", "patch": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ */\n+/* Boehm, July 31, 1995 5:02 pm PDT */\n+\n+#ifdef GC_GCJ_SUPPORT\n+\n+/*\n+ * This is an allocator interface tuned for gcj (the GNU/Cygnus static\n+ * java compiler).\n+ *\n+ * Each allocated object has a pointer in its first word to a vtable,\n+ * which for our purposes is simply a structure describing the type of\n+ * the object.\n+ * This descriptor structur contains a GC marking descriptor at offset\n+ * MARK_DESCR_OFFSET.\n+ *\n+ * It is hoped that this interface may also be useful for other systems,\n+ * possibly with some tuning of the constants.  But the immediate goal\n+ * is to get better gcj performance.\n+ *\n+ * We assume:\n+ *  1) We have an ANSI conforming C compiler.\n+ *  2) Counting on explicit initialization of this interface is OK.\n+ *  3) FASTLOCK is not a significant win.\n+ */\n+\n+#include \"gc_priv.h\"\n+#include \"gc_mark.h\"\n+#include \"include/gc_gcj.h\"\n+#include \"dbg_mlc.h\"\n+\n+GC_bool GC_gcj_malloc_initialized = FALSE;\n+\n+int GC_gcj_kind;\t/* Object kind for objects with descriptors     */\n+\t\t\t/* in \"vtable\".\t\t\t\t\t*/\n+int GC_gcj_debug_kind;\t/* The kind of objects that is always marked \t*/\n+\t\t\t/* with a mark proc call.\t\t\t*/\n+\n+ptr_t * GC_gcjobjfreelist;\n+ptr_t * GC_gcjdebugobjfreelist;\n+\n+void * GC_default_oom_action(void) { return 0; }\n+\n+void * (*GC_oom_action)(void) = GC_default_oom_action;\n+\n+/* Caller does not hold allocation lock. */\n+void GC_init_gcj_malloc(int mp_index, void * /* really mark_proc */mp)\n+{\n+    register int i;\n+    DCL_LOCK_STATE;\n+\n+    GC_init();\t/* In case it's not already done.\t*/\n+    DISABLE_SIGNALS();\n+    LOCK();\n+    if (GC_gcj_malloc_initialized) {\n+      UNLOCK();\n+      ENABLE_SIGNALS();\n+      return;\n+    }\n+    GC_gcj_malloc_initialized = TRUE;\n+    GC_mark_procs[mp_index] = (mark_proc)mp;\n+    if (mp_index >= GC_n_mark_procs) ABORT(\"GC_init_gcj_malloc: bad index\");\n+    /* Set up object kind gcj-style indirect descriptor. */\n+      GC_gcjobjfreelist = (ptr_t *)\n+          GC_generic_malloc_inner((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n+      if (GC_gcjobjfreelist == 0) ABORT(\"Couldn't allocate GC_gcjobjfreelist\");\n+      BZERO(GC_gcjobjfreelist, (MAXOBJSZ+1)*sizeof(ptr_t));\n+      GC_gcj_kind = GC_n_kinds++;\n+      GC_obj_kinds[GC_gcj_kind].ok_freelist = GC_gcjobjfreelist;\n+      GC_obj_kinds[GC_gcj_kind].ok_reclaim_list = 0;\n+      GC_obj_kinds[GC_gcj_kind].ok_descriptor =\n+    \t(((word)(-MARK_DESCR_OFFSET - INDIR_PER_OBJ_BIAS)) | DS_PER_OBJECT);\n+      GC_obj_kinds[GC_gcj_kind].ok_relocate_descr = FALSE;\n+      GC_obj_kinds[GC_gcj_kind].ok_init = TRUE;\n+    /* Set up object kind for objects that require mark proc call.\t*/\n+      GC_gcjdebugobjfreelist = (ptr_t *)\n+          GC_generic_malloc_inner((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n+      if (GC_gcjdebugobjfreelist == 0)\n+\t  ABORT(\"Couldn't allocate GC_gcjdebugobjfreelist\");\n+      BZERO(GC_gcjdebugobjfreelist, (MAXOBJSZ+1)*sizeof(ptr_t));\n+      GC_gcj_debug_kind = GC_n_kinds++;\n+      GC_obj_kinds[GC_gcj_debug_kind].ok_freelist = GC_gcjdebugobjfreelist;\n+      GC_obj_kinds[GC_gcj_debug_kind].ok_reclaim_list = 0;\n+      GC_obj_kinds[GC_gcj_debug_kind].ok_descriptor =\n+    \tMAKE_PROC(mp_index, 1 /* allocated with debug info */);\n+      GC_obj_kinds[GC_gcj_debug_kind].ok_relocate_descr = FALSE;\n+      GC_obj_kinds[GC_gcj_debug_kind].ok_init = TRUE;\n+    UNLOCK();\n+    ENABLE_SIGNALS();\n+}\n+\n+ptr_t GC_clear_stack();\n+\n+#define GENERAL_MALLOC(lb,k) \\\n+    (GC_PTR)GC_clear_stack(GC_generic_malloc_inner((word)lb, k))\n+    \n+#define GENERAL_MALLOC_IOP(lb,k) \\\n+    (GC_PTR)GC_clear_stack(GC_generic_malloc_inner_ignore_off_page(lb, k))\n+\n+/* Allocate an object, clear it, and store the pointer to the\t*/\n+/* type structure (vtable in gcj).\t\t\t\t*/\n+/* This adds a byte at the end of the object if GC_malloc would.*/\n+void * GC_gcj_malloc(size_t lb, void * ptr_to_struct_containing_descr)\n+{\n+register ptr_t op;\n+register ptr_t * opp;\n+register word lw;\n+DCL_LOCK_STATE;\n+\n+    if( SMALL_OBJ(lb) ) {\n+#       ifdef MERGE_SIZES\n+\t  lw = GC_size_map[lb];\n+#\telse\n+\t  lw = ALIGNED_WORDS(lb);\n+#       endif\n+\topp = &(GC_gcjobjfreelist[lw]);\n+\tLOCK();\n+        if( (op = *opp) == 0 ) {\n+            op = (ptr_t)GENERAL_MALLOC((word)lb, GC_gcj_kind);\n+\t    if (0 == op) {\n+\t\tUNLOCK();\n+\t\treturn(GC_oom_action());\n+\t    }\n+#\t    ifdef MERGE_SIZES\n+\t\tlw = GC_size_map[lb];\t/* May have been uninitialized.\t*/\n+#\t    endif\n+        } else {\n+            *opp = obj_link(op);\n+            GC_words_allocd += lw;\n+            FASTUNLOCK();\n+        }\n+\t*(void **)op = ptr_to_struct_containing_descr;\n+\tUNLOCK();\n+    } else {\n+\tLOCK();\n+\top = (ptr_t)GENERAL_MALLOC((word)lb, GC_gcj_kind);\n+\tif (0 == op) {\n+\t    UNLOCK();\n+\t    return(GC_oom_action());\n+\t}\n+\t*(void **)op = ptr_to_struct_containing_descr;\n+\tUNLOCK();\n+    }\n+    return((GC_PTR) op);\n+}\n+\n+/* Similar to GC_gcj_malloc, but add debug info.  This is allocated\t*/\n+/* with GC_gcj_debug_kind.\t\t\t\t\t\t*/\n+GC_PTR GC_debug_gcj_malloc(size_t lb, void * ptr_to_struct_containing_descr,\n+\t\t\t   GC_EXTRA_PARAMS)\n+{\n+    GC_PTR result;\n+\n+    /* We clone the code from GC_debug_gcj_malloc, so that we \t*/\n+    /* dont end up with extra frames on the stack, which could\t*/\n+    /* confuse the backtrace.\t\t\t\t\t*/\n+    LOCK();\n+    result = GC_generic_malloc_inner(lb + DEBUG_BYTES, GC_gcj_debug_kind);\n+    if (result == 0) {\n+\tUNLOCK();\n+        GC_err_printf2(\"GC_debug_gcj_malloc(%ld, 0x%lx) returning NIL (\",\n+        \t       (unsigned long) lb,\n+\t\t       (unsigned long) ptr_to_struct_containing_descr);\n+        GC_err_puts(s);\n+        GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n+        return(GC_oom_action());\n+    }\n+    *((void **)((ptr_t)result + sizeof(oh))) = ptr_to_struct_containing_descr;\n+    UNLOCK();\n+    if (!GC_debugging_started) {\n+    \tGC_start_debugging();\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info(result, (word)lb, s, (word)i));\n+}\n+\n+/* Similar to GC_gcj_malloc, but the size is in words, and we don't\t*/\n+/* adjust it.  The size is assumed to be such that it can be \t*/\n+/* allocated as a small object.\t\t\t\t\t*/\n+void * GC_gcj_fast_malloc(size_t lw, void * ptr_to_struct_containing_descr)\n+{\n+ptr_t op;\n+ptr_t * opp;\n+DCL_LOCK_STATE;\n+\n+    opp = &(GC_gcjobjfreelist[lw]);\n+    LOCK();\n+    if( (op = *opp) == 0 ) {\n+        op = (ptr_t)GC_clear_stack(\n+\t\tGC_generic_malloc_words_small_inner(lw, GC_gcj_kind));\n+\tif (0 == op) {\n+\t    UNLOCK();\n+\t    return(GC_oom_action());\n+\t}\n+    } else {\n+        *opp = obj_link(op);\n+        GC_words_allocd += lw;\n+    }\n+    *(void **)op = ptr_to_struct_containing_descr;\n+    UNLOCK();\n+    return((GC_PTR) op);\n+}\n+\n+/* And a debugging version of the above:\t*/\n+void * GC_debug_gcj_fast_malloc(size_t lw,\n+\t\t\t\tvoid * ptr_to_struct_containing_descr,\n+\t\t\t\tGC_EXTRA_PARAMS)\n+{\n+    GC_PTR result;\n+    size_t lb = WORDS_TO_BYTES(lw);\n+\n+    /* We clone the code from GC_debug_gcj_malloc, so that we \t*/\n+    /* dont end up with extra frames on the stack, which could\t*/\n+    /* confuse the backtrace.\t\t\t\t\t*/\n+    LOCK();\n+    result = GC_generic_malloc_inner(lb + DEBUG_BYTES, GC_gcj_debug_kind);\n+    if (result == 0) {\n+\tUNLOCK();\n+        GC_err_printf2(\"GC_debug_gcj_fast_malloc(%ld, 0x%lx) returning NIL (\",\n+        \t       (unsigned long) lw,\n+\t\t       (unsigned long) ptr_to_struct_containing_descr);\n+        GC_err_puts(s);\n+        GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n+        return(GC_oom_action());\n+    }\n+    *((void **)((ptr_t)result + sizeof(oh))) = ptr_to_struct_containing_descr;\n+    UNLOCK();\n+    if (!GC_debugging_started) {\n+    \tGC_start_debugging();\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info(result, (word)lb, s, (word)i));\n+}\n+\n+void * GC_gcj_malloc_ignore_off_page(size_t lb,\n+\t\t\t\t     void * ptr_to_struct_containing_descr) \n+{\n+register ptr_t op;\n+register ptr_t * opp;\n+register word lw;\n+DCL_LOCK_STATE;\n+\n+    if( SMALL_OBJ(lb) ) {\n+#       ifdef MERGE_SIZES\n+\t  lw = GC_size_map[lb];\n+#\telse\n+\t  lw = ALIGNED_WORDS(lb);\n+#       endif\n+\topp = &(GC_gcjobjfreelist[lw]);\n+\tLOCK();\n+        if( (op = *opp) == 0 ) {\n+            op = (ptr_t)GENERAL_MALLOC_IOP(lb, GC_gcj_kind);\n+#\t    ifdef MERGE_SIZES\n+\t\tlw = GC_size_map[lb];\t/* May have been uninitialized.\t*/\n+#\t    endif\n+        } else {\n+            *opp = obj_link(op);\n+            GC_words_allocd += lw;\n+            FASTUNLOCK();\n+        }\n+\t*(void **)op = ptr_to_struct_containing_descr;\n+\tUNLOCK();\n+    } else {\n+        op = (ptr_t)GENERAL_MALLOC_IOP(lb, GC_gcj_kind);\n+        if (0 != op) {\n+          *(void **)op = ptr_to_struct_containing_descr;\n+\t}\n+        UNLOCK();\n+    }\n+    return((GC_PTR) op);\n+}\n+\n+#endif  /* GC_GCJ_SUPPORT */"}, {"sha": "1dede5154b69edc82bcfcdc811ec4c23c7df6539", "filename": "boehm-gc/include/gc_gcj.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3/boehm-gc%2Finclude%2Fgc_gcj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3/boehm-gc%2Finclude%2Fgc_gcj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_gcj.h?ref=0eebf9e5c729a27fec1c7ee40eefd226eb2df6e3", "patch": "@@ -0,0 +1,101 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+ * Copyright 1996-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright 1999 by Hewlett-Packard Company.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+/* This file assumes the collector has been compiled with GC_GCJ_SUPPORT */\n+/* and that an ANSI C compiler is available.\t\t\t\t */\n+\n+/*\n+ * We allocate objects whose first word contains a pointer to a struct\n+ * describing the object type.  This struct contains a garbage collector mark\n+ * descriptor at offset MARK_DESCR_OFFSET.  Alternatively, the objects\n+ * may be marked by the mark procedure passed to GC_init_gcj_malloc.\n+ */\n+\n+#ifndef MARK_DESCR_OFFSET\n+#  define MARK_DESCR_OFFSET\tsizeof(word)\n+#endif\n+\t/* Gcj keeps GC descriptor as second word of vtable.\tThis\t*/\n+\t/* probably needs to be adjusted for other clients.\t\t*/\n+\t/* We currently assume that this offset is such that:\t\t*/\n+\t/*\t- all objects of this kind are large enough to have\t*/\n+\t/*\t  a value at that offset, and\t\t\t\t*/\n+\t/* \t- it is not zero.\t\t\t\t\t*/\n+\t/* These assumptions allow objects on the free list to be \t*/\n+\t/* marked normally.\t\t\t\t\t\t*/\n+\n+#ifndef _GC_H\n+#   include \"gc.h\"\n+#endif\n+\n+/* The following allocators signal an out of memory condition with\t*/\n+/* return GC_oom_action();\t\t\t\t\t\t*/\n+/* The default GC_oom_action returns 0.\t\t\t\t\t*/\n+/* This functionality is currently restricted to the gcj allocators.\t*/\n+/* We may want to extend it to the others.\t\t\t\t*/\n+\n+extern void * (*GC_oom_action)(void);\n+\n+/* The following function must be called before the gcj allocators\t*/\n+/* can be invoked.\t\t\t\t\t\t\t*/\n+/* mp_index and mp are the index and mark_proc (see gc_mark.h)\t\t*/\n+/* respectively for the allocated objects.  Mark_proc will be \t\t*/\n+/* used to build the descriptor for objects allocated through the\t*/\n+/* debugging interface.  The mark_proc will be invoked on all such \t*/\n+/* objects with an \"environment\" value of 1.  The client may chose\t*/\n+/* to use the same mark_proc for some of its generated mark descriptors.*/\n+/* In that case, it should use a different \"environment\" value to\t*/\n+/* detect the presence or absence of the debug header.\t\t\t*/\n+\n+/* the debugging interface.\t\t\t\t\t\t*/\n+/* Mp is really of type mark_proc, as defined in gc_mark.h.  We don't \t*/\n+/* want to include that here for namespace pollution reasons.\t\t*/\n+extern void GC_init_gcj_malloc(int mp_index, void * /* really mark_proc */mp);\n+\n+/* Allocate an object, clear it, and store the pointer to the\t*/\n+/* type structure (vtable in gcj).\t\t\t\t*/\n+/* This adds a byte at the end of the object if GC_malloc would.*/\n+extern void * GC_gcj_malloc(size_t lb, void * ptr_to_struct_containing_descr);\n+/* The debug versions allocate such that the specified mark_proc\t*/\n+/* is always invoked.\t\t\t\t\t\t\t*/\n+extern void * GC_debug_gcj_malloc(size_t lb,\n+\t\t\t\t  void * ptr_to_struct_containing_descr,\n+\t\t\t\t  GC_EXTRA_PARAMS);\n+\n+/* Similar to the above, but the size is in words, and we don't\t*/\n+/* adjust it.  The size is assumed to be such that it can be \t*/\n+/* allocated as a small object.\t\t\t\t\t*/\n+extern void * GC_gcj_fast_malloc(size_t lw,\n+\t\t\t\t void * ptr_to_struct_containing_descr);\n+extern void * GC_debug_gcj_fast_malloc(size_t lw,\n+\t\t\t\t void * ptr_to_struct_containing_descr,\n+\t\t\t\t GC_EXTRA_PARAMS);\n+\n+/* Similar to GC_gcj_malloc, but assumes that a pointer to near the\t*/\n+/* beginning of the resulting object is always maintained.\t\t*/\n+extern void * GC_gcj_malloc_ignore_off_page(size_t lb,\n+\t\t\t\tvoid * ptr_to_struct_containing_descr);\n+\n+# ifdef GC_DEBUG\n+#   define GC_GCJ_MALLOC(s,d) GC_debug_gcj_malloc(s,d,GC_EXTRAS)\n+#   define GC_GCJ_FAST_MALLOC(s,d) GC_debug_gcj_fast_malloc(s,d,GC_EXTRAS)\n+#   define GC_GCJ_MALLOC_IGNORE_OFF_PAGE(s,d) GC_gcj_debug_malloc(s,d,GC_EXTRAS)\n+# else\n+#   define GC_GCJ_MALLOC(s,d) GC_gcj_malloc(s,d)\n+#   define GC_GCJ_FAST_MALLOC(s,d) GC_gcj_fast_malloc(s,d)\n+#   define GC_GCJ_MALLOC_IGNORE_OFF_PAGE(s,d) \\\n+\tGC_gcj_debug_malloc_ignore_off_page(s,d)\n+# endif\n+"}]}