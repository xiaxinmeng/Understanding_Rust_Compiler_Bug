{"sha": "795d70d7e6e107b3cde213fb78484b19c9a3a671", "node_id": "C_kwDOANBUbNoAKDc5NWQ3MGQ3ZTZlMTA3YjNjZGUyMTNmYjc4NDg0YjE5YzlhM2E2NzE", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-16T13:45:52Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-16T14:06:27Z"}, "message": "Support parsing LangItems on traits\n\nLang items are attributes that mark traits for specific behaviour with\ncompiler support kind of like builtin's/intrinsics.\n\nThis change adds parsing support for some of the arithmetic operator\noverloads. The string names always correspond to the trait-item function\nname too.", "tree": {"sha": "dc2a5e6ead63bbd081414adeca8d273913433123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc2a5e6ead63bbd081414adeca8d273913433123"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/795d70d7e6e107b3cde213fb78484b19c9a3a671", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/795d70d7e6e107b3cde213fb78484b19c9a3a671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/795d70d7e6e107b3cde213fb78484b19c9a3a671", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/795d70d7e6e107b3cde213fb78484b19c9a3a671/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df3e0ec232b878fb1f2228e5f6ef6ec0874d1665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3e0ec232b878fb1f2228e5f6ef6ec0874d1665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3e0ec232b878fb1f2228e5f6ef6ec0874d1665"}], "stats": {"total": 185, "additions": 181, "deletions": 4}, "files": [{"sha": "54591ce9fffe7dc873dd2f9cc9f2327e873581ac", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/795d70d7e6e107b3cde213fb78484b19c9a3a671/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/795d70d7e6e107b3cde213fb78484b19c9a3a671/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=795d70d7e6e107b3cde213fb78484b19c9a3a671", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-tyty-visitor.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-trait-ref.h\"\n+#include \"rust-expr.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -206,6 +207,31 @@ class TraitResolver : public TypeCheckBase\n     // loop of trying to resolve traits as required by the types\n     tref->on_resolved ();\n \n+    // does this have any lang-item attributes?\n+    for (auto &attr : trait_reference->get_outer_attrs ())\n+      {\n+\tbool is_lang_item = attr.get_path ().as_string ().compare (\"lang\") == 0\n+\t\t\t    && attr.has_attr_input ()\n+\t\t\t    && attr.get_attr_input ().get_attr_input_type ()\n+\t\t\t\t == AST::AttrInput::AttrInputType::LITERAL;\n+\tif (is_lang_item)\n+\t  {\n+\t    auto &literal\n+\t      = static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n+\t    const auto &lang_item_type_str\n+\t      = literal.get_literal ().as_string ();\n+\t    auto lang_item_type\n+\t      = Analysis::RustLangItem::Parse (lang_item_type_str);\n+\t    if (lang_item_type == Analysis::RustLangItem::ItemType::UNKNOWN)\n+\t      {\n+\t\trust_error_at (attr.get_locus (), \"unknown lang item\");\n+\t\treturn tref;\n+\t      }\n+\t    mappings->insert_lang_item (\n+\t      lang_item_type, trait_reference->get_mappings ().get_defid ());\n+\t  }\n+      }\n+\n     return tref;\n   }\n "}, {"sha": "09a7b362ced4b5f662c6c29168ed160429b26055", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 155, "deletions": 4, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/795d70d7e6e107b3cde213fb78484b19c9a3a671/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/795d70d7e6e107b3cde213fb78484b19c9a3a671/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=795d70d7e6e107b3cde213fb78484b19c9a3a671", "patch": "@@ -23,13 +23,143 @@\n #include \"rust-location.h\"\n #include \"rust-mapping-common.h\"\n #include \"rust-canonical-path.h\"\n-\n #include \"rust-ast-full-decls.h\"\n #include \"rust-hir-full-decls.h\"\n+#include \"operator.h\"\n \n namespace Rust {\n namespace Analysis {\n \n+// https://github.com/rust-lang/rust/blob/master/library/core/src/ops/arith.rs\n+class RustLangItem\n+{\n+public:\n+  enum ItemType\n+  {\n+    ADD,\n+    SUBTRACT,\n+    MULTIPLY,\n+    DIVIDE,\n+    REMAINDER,\n+    NEGATION,\n+    ADD_ASSIGN,\n+    SUB_ASSIGN,\n+    MUL_ASSIGN,\n+    DIV_ASSIGN,\n+    REM_ASSIGN,\n+\n+    UNKNOWN,\n+  };\n+\n+  static ItemType Parse (const std::string &item)\n+  {\n+    if (item.compare (\"add\") == 0)\n+      {\n+\treturn ItemType::ADD;\n+      }\n+    else if (item.compare (\"sub\") == 0)\n+      {\n+\treturn ItemType::SUBTRACT;\n+      }\n+    else if (item.compare (\"mul\") == 0)\n+      {\n+\treturn ItemType::MULTIPLY;\n+      }\n+    else if (item.compare (\"div\") == 0)\n+      {\n+\treturn ItemType::DIVIDE;\n+      }\n+    else if (item.compare (\"rem\") == 0)\n+      {\n+\treturn ItemType::REMAINDER;\n+      }\n+    else if (item.compare (\"neg\") == 0)\n+      {\n+\treturn ItemType::NEGATION;\n+      }\n+    else if (item.compare (\"add_assign\") == 0)\n+      {\n+\treturn ItemType::ADD_ASSIGN;\n+      }\n+    else if (item.compare (\"sub_assign\") == 0)\n+      {\n+\treturn ItemType::SUB_ASSIGN;\n+      }\n+    else if (item.compare (\"mul_assign\") == 0)\n+      {\n+\treturn ItemType::MUL_ASSIGN;\n+      }\n+    else if (item.compare (\"div_assign\") == 0)\n+      {\n+\treturn ItemType::DIV_ASSIGN;\n+      }\n+    else if (item.compare (\"rem_assign\") == 0)\n+      {\n+\treturn ItemType::REM_ASSIGN;\n+      }\n+\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static std::string ToString (ItemType type)\n+  {\n+    switch (type)\n+      {\n+      case ADD:\n+\treturn \"add\";\n+      case SUBTRACT:\n+\treturn \"sub\";\n+      case MULTIPLY:\n+\treturn \"mul\";\n+      case DIVIDE:\n+\treturn \"div\";\n+      case REMAINDER:\n+\treturn \"rem\";\n+      case NEGATION:\n+\treturn \"neg\";\n+      case ADD_ASSIGN:\n+\treturn \"add_assign\";\n+      case SUB_ASSIGN:\n+\treturn \"sub_assign\";\n+      case MUL_ASSIGN:\n+\treturn \"mul_assign\";\n+      case DIV_ASSIGN:\n+\treturn \"div_assign\";\n+      case REM_ASSIGN:\n+\treturn \"rem_assign\";\n+\n+      case UNKNOWN:\n+\tbreak;\n+      }\n+    return \"<UNKNOWN>\";\n+  }\n+\n+  static ItemType OperatorToLangItem (ArithmeticOrLogicalOperator op)\n+  {\n+    switch (op)\n+      {\n+      case ArithmeticOrLogicalOperator::ADD:\n+\treturn ItemType::ADD;\n+      case ArithmeticOrLogicalOperator::SUBTRACT:\n+\treturn ItemType::SUBTRACT;\n+      case ArithmeticOrLogicalOperator::MULTIPLY:\n+\treturn ItemType::MULTIPLY;\n+      case ArithmeticOrLogicalOperator::DIVIDE:\n+\treturn ItemType::DIVIDE;\n+      case ArithmeticOrLogicalOperator::MODULUS:\n+\treturn ItemType::REMAINDER;\n+\n+      case ArithmeticOrLogicalOperator::BITWISE_AND:\n+      case ArithmeticOrLogicalOperator::BITWISE_OR:\n+      case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+      case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+      case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+\treturn ItemType::UNKNOWN;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+};\n+\n class NodeMapping\n {\n public:\n@@ -237,9 +367,9 @@ class Mappings\n     const Resolver::CanonicalPath *p = nullptr;\n     if (lookup_canonical_path (crate, id, &p))\n       {\n-\t// if we have already stored a canonical path this is ok so long as this\n-\t// new path is equal or is smaller that the existing one but in that\n-\t// case we ignore it.\n+\t// if we have already stored a canonical path this is ok so long as\n+\t// this new path is equal or is smaller that the existing one but in\n+\t// that case we ignore it.\n \tif (p->is_equal (path))\n \t  return;\n \telse\n@@ -267,6 +397,24 @@ class Mappings\n     return true;\n   }\n \n+  void insert_lang_item (RustLangItem::ItemType item_type, DefId id)\n+  {\n+    auto it = lang_item_mappings.find (item_type);\n+    rust_assert (it == lang_item_mappings.end ());\n+\n+    lang_item_mappings[item_type] = id;\n+  }\n+\n+  bool lookup_lang_item (RustLangItem::ItemType item_type, DefId *id)\n+  {\n+    auto it = lang_item_mappings.find (item_type);\n+    if (it == lang_item_mappings.end ())\n+      return false;\n+\n+    *id = it->second;\n+    return true;\n+  }\n+\n private:\n   Mappings ();\n \n@@ -304,6 +452,9 @@ class Mappings\n     hirGenericParamMappings;\n   std::map<HirId, HIR::Trait *> hirTraitItemsToTraitMappings;\n \n+  // this maps the lang=<item_type> to DefId mappings\n+  std::map<RustLangItem::ItemType, DefId> lang_item_mappings;\n+\n   // canonical paths\n   std::map<CrateNum, std::map<NodeId, const Resolver::CanonicalPath> > paths;\n "}]}