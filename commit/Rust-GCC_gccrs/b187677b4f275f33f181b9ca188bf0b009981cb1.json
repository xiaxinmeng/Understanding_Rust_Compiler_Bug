{"sha": "b187677b4f275f33f181b9ca188bf0b009981cb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE4NzY3N2I0ZjI3NWYzM2YxODFiOWNhMTg4YmYwYjAwOTk4MWNiMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:43:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:43:44Z"}, "message": "[AArch64] Rewrite aarch64_simd_valid_immediate\n\nThis patch reworks aarch64_simd_valid_immediate so that\nit's easier to add SVE support.  The main changes are:\n\n- make simd_immediate_info easier to construct\n- replace the while (1) { ... break; } blocks with checks that use\n  the full 64-bit value of the constant\n- treat floating-point modes as integers if they aren't valid\n  as floating-point values\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-protos.h (aarch64_output_simd_mov_immediate):\n\tRemove the mode argument.\n\t(aarch64_simd_valid_immediate): Remove the mode and inverse\n\targuments.\n\t* config/aarch64/iterators.md (bitsize): New iterator.\n\t* config/aarch64/aarch64-simd.md (*aarch64_simd_mov<mode>, and<mode>3)\n\t(ior<mode>3): Update calls to aarch64_output_simd_mov_immediate.\n\t* config/aarch64/constraints.md (Do, Db, Dn): Update calls to\n\taarch64_simd_valid_immediate.\n\t* config/aarch64/predicates.md (aarch64_reg_or_orr_imm): Likewise.\n\t(aarch64_reg_or_bic_imm): Likewise.\n\t* config/aarch64/aarch64.c (simd_immediate_info): Replace mvn\n\twith an insn_type enum and msl with a modifier_type enum.\n\tReplace element_width with a scalar_mode.  Change the shift\n\tto unsigned int.  Add constructors for scalar_float_mode and\n\tscalar_int_mode elements.\n\t(aarch64_vect_float_const_representable_p): Delete.\n\t(aarch64_can_const_movi_rtx_p)\n\t(aarch64_simd_scalar_immediate_valid_for_move)\n\t(aarch64_simd_make_constant): Update call to\n\taarch64_simd_valid_immediate.\n\t(aarch64_advsimd_valid_immediate_hs): New function.\n\t(aarch64_advsimd_valid_immediate): Likewise.\n\t(aarch64_simd_valid_immediate): Remove mode and inverse\n\targuments.  Rewrite to use the above.  Use const_vec_duplicate_p\n\tto detect duplicated constants and use aarch64_float_const_zero_rtx_p\n\tand aarch64_float_const_representable_p on the result.\n\t(aarch64_output_simd_mov_immediate): Remove mode argument.\n\tUpdate call to aarch64_simd_valid_immediate and use of\n\tsimd_immediate_info.\n\t(aarch64_output_scalar_simd_mov_immediate): Update call\n\taccordingly.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/vect-movi.c (movi_float_lsl24): New function.\n\t(main): Call it.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256205", "tree": {"sha": "5f11d157fb8fd6973bf7e30940077af925690bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f11d157fb8fd6973bf7e30940077af925690bec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b187677b4f275f33f181b9ca188bf0b009981cb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b187677b4f275f33f181b9ca188bf0b009981cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b187677b4f275f33f181b9ca188bf0b009981cb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b187677b4f275f33f181b9ca188bf0b009981cb1/comments", "author": null, "committer": null, "parents": [{"sha": "c6561a1af68d6439cedde6dc79d19eda9981a4be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6561a1af68d6439cedde6dc79d19eda9981a4be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6561a1af68d6439cedde6dc79d19eda9981a4be"}], "stats": {"total": 489, "additions": 285, "deletions": 204}, "files": [{"sha": "9437ae9fd6c35b1088eaf736a8c2e3c399d37f62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b187677b4f275f33f181b9ca188bf0b009981cb1", "patch": "@@ -1,3 +1,40 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_output_simd_mov_immediate):\n+\tRemove the mode argument.\n+\t(aarch64_simd_valid_immediate): Remove the mode and inverse\n+\targuments.\n+\t* config/aarch64/iterators.md (bitsize): New iterator.\n+\t* config/aarch64/aarch64-simd.md (*aarch64_simd_mov<mode>, and<mode>3)\n+\t(ior<mode>3): Update calls to aarch64_output_simd_mov_immediate.\n+\t* config/aarch64/constraints.md (Do, Db, Dn): Update calls to\n+\taarch64_simd_valid_immediate.\n+\t* config/aarch64/predicates.md (aarch64_reg_or_orr_imm): Likewise.\n+\t(aarch64_reg_or_bic_imm): Likewise.\n+\t* config/aarch64/aarch64.c (simd_immediate_info): Replace mvn\n+\twith an insn_type enum and msl with a modifier_type enum.\n+\tReplace element_width with a scalar_mode.  Change the shift\n+\tto unsigned int.  Add constructors for scalar_float_mode and\n+\tscalar_int_mode elements.\n+\t(aarch64_vect_float_const_representable_p): Delete.\n+\t(aarch64_can_const_movi_rtx_p)\n+\t(aarch64_simd_scalar_immediate_valid_for_move)\n+\t(aarch64_simd_make_constant): Update call to\n+\taarch64_simd_valid_immediate.\n+\t(aarch64_advsimd_valid_immediate_hs): New function.\n+\t(aarch64_advsimd_valid_immediate): Likewise.\n+\t(aarch64_simd_valid_immediate): Remove mode and inverse\n+\targuments.  Rewrite to use the above.  Use const_vec_duplicate_p\n+\tto detect duplicated constants and use aarch64_float_const_zero_rtx_p\n+\tand aarch64_float_const_representable_p on the result.\n+\t(aarch64_output_simd_mov_immediate): Remove mode argument.\n+\tUpdate call to aarch64_simd_valid_immediate and use of\n+\tsimd_immediate_info.\n+\t(aarch64_output_scalar_simd_mov_immediate): Update call\n+\taccordingly.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "7df3aae4353f6f9e71f5d554c1c935881a958d28", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=b187677b4f275f33f181b9ca188bf0b009981cb1", "patch": "@@ -368,7 +368,7 @@ bool aarch64_mov_operand_p (rtx, machine_mode);\n rtx aarch64_reverse_mask (machine_mode, unsigned int);\n bool aarch64_offset_7bit_signed_scaled_p (machine_mode, HOST_WIDE_INT);\n char *aarch64_output_scalar_simd_mov_immediate (rtx, scalar_int_mode);\n-char *aarch64_output_simd_mov_immediate (rtx, machine_mode, unsigned,\n+char *aarch64_output_simd_mov_immediate (rtx, unsigned,\n \t\t\tenum simd_immediate_check w = AARCH64_CHECK_MOV);\n bool aarch64_pad_reg_upward (machine_mode, const_tree, bool);\n bool aarch64_regno_ok_for_base_p (int, bool);\n@@ -379,8 +379,7 @@ bool aarch64_simd_check_vect_par_cnst_half (rtx op, machine_mode mode,\n bool aarch64_simd_imm_zero_p (rtx, machine_mode);\n bool aarch64_simd_scalar_immediate_valid_for_move (rtx, scalar_int_mode);\n bool aarch64_simd_shift_imm_p (rtx, machine_mode, bool);\n-bool aarch64_simd_valid_immediate (rtx, machine_mode, bool,\n-\t\t\tstruct simd_immediate_info *,\n+bool aarch64_simd_valid_immediate (rtx, struct simd_immediate_info *,\n \t\t\tenum simd_immediate_check w = AARCH64_CHECK_MOV);\n bool aarch64_split_dimode_const_store (rtx, rtx);\n bool aarch64_symbolic_address_p (rtx);"}, {"sha": "5a85f82880e0f190f52a74d77c01d0207ed7d000", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=b187677b4f275f33f181b9ca188bf0b009981cb1", "patch": "@@ -120,8 +120,7 @@\n      case 5: return \"fmov\\t%d0, %1\";\n      case 6: return \"mov\\t%0, %1\";\n      case 7:\n-\treturn aarch64_output_simd_mov_immediate (operands[1],\n-\t\t\t\t\t\t  <MODE>mode, 64);\n+\treturn aarch64_output_simd_mov_immediate (operands[1], 64);\n      default: gcc_unreachable ();\n      }\n }\n@@ -154,7 +153,7 @@\n     case 6:\n \treturn \"#\";\n     case 7:\n-\treturn aarch64_output_simd_mov_immediate (operands[1], <MODE>mode, 128);\n+\treturn aarch64_output_simd_mov_immediate (operands[1], 128);\n     default:\n \tgcc_unreachable ();\n     }\n@@ -647,8 +646,8 @@\n       case 0:\n \treturn \"and\\t%0.<Vbtype>, %1.<Vbtype>, %2.<Vbtype>\";\n       case 1:\n-\treturn aarch64_output_simd_mov_immediate (operands[2],\n-\t   <MODE>mode, GET_MODE_BITSIZE (<MODE>mode), AARCH64_CHECK_BIC);\n+\treturn aarch64_output_simd_mov_immediate (operands[2], <bitsize>,\n+\t\t\t\t\t\t  AARCH64_CHECK_BIC);\n       default:\n \tgcc_unreachable ();\n       }\n@@ -668,8 +667,8 @@\n       case 0:\n \treturn \"orr\\t%0.<Vbtype>, %1.<Vbtype>, %2.<Vbtype>\";\n       case 1:\n-\treturn aarch64_output_simd_mov_immediate (operands[2],\n-\t\t<MODE>mode, GET_MODE_BITSIZE (<MODE>mode), AARCH64_CHECK_ORR);\n+\treturn aarch64_output_simd_mov_immediate (operands[2], <bitsize>,\n+\t\t\t\t\t\t  AARCH64_CHECK_ORR);\n       default:\n \tgcc_unreachable ();\n       }"}, {"sha": "a1896058c6d305af1b7cea8b7fb5d9a815b31cb5", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 203, "deletions": 184, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b187677b4f275f33f181b9ca188bf0b009981cb1", "patch": "@@ -117,15 +117,53 @@ struct aarch64_address_info {\n   enum aarch64_symbol_type symbol_type;\n };\n \n+/* Information about a legitimate vector immediate operand.  */\n struct simd_immediate_info\n {\n+  enum insn_type { MOV, MVN };\n+  enum modifier_type { LSL, MSL };\n+\n+  simd_immediate_info () {}\n+  simd_immediate_info (scalar_float_mode, rtx);\n+  simd_immediate_info (scalar_int_mode, unsigned HOST_WIDE_INT,\n+\t\t       insn_type = MOV, modifier_type = LSL,\n+\t\t       unsigned int = 0);\n+\n+  /* The mode of the elements.  */\n+  scalar_mode elt_mode;\n+\n+  /* The value of each element.  */\n   rtx value;\n-  int shift;\n-  int element_width;\n-  bool mvn;\n-  bool msl;\n+\n+  /* The instruction to use to move the immediate into a vector.  */\n+  insn_type insn;\n+\n+  /* The kind of shift modifier to use, and the number of bits to shift.\n+     This is (LSL, 0) if no shift is needed.  */\n+  modifier_type modifier;\n+  unsigned int shift;\n };\n \n+/* Construct a floating-point immediate in which each element has mode\n+   ELT_MODE_IN and value VALUE_IN.  */\n+inline simd_immediate_info\n+::simd_immediate_info (scalar_float_mode elt_mode_in, rtx value_in)\n+  : elt_mode (elt_mode_in), value (value_in), insn (MOV),\n+    modifier (LSL), shift (0)\n+{}\n+\n+/* Construct an integer immediate in which each element has mode ELT_MODE_IN\n+   and value VALUE_IN.  The other parameters are as for the structure\n+   fields.  */\n+inline simd_immediate_info\n+::simd_immediate_info (scalar_int_mode elt_mode_in,\n+\t\t       unsigned HOST_WIDE_INT value_in,\n+\t\t       insn_type insn_in, modifier_type modifier_in,\n+\t\t       unsigned int shift_in)\n+  : elt_mode (elt_mode_in), value (gen_int_mode (value_in, elt_mode_in)),\n+    insn (insn_in), modifier (modifier_in), shift (shift_in)\n+{}\n+\n /* The current code model.  */\n enum aarch64_code_model aarch64_cmodel;\n \n@@ -4873,7 +4911,7 @@ aarch64_can_const_movi_rtx_p (rtx x, machine_mode mode)\n   vmode = aarch64_simd_container_mode (imode, width);\n   rtx v_op = aarch64_simd_gen_const_vector_dup (vmode, ival);\n \n-  return aarch64_simd_valid_immediate (v_op, vmode, false, NULL);\n+  return aarch64_simd_valid_immediate (v_op, NULL);\n }\n \n \n@@ -11493,200 +11531,185 @@ sizetochar (int size)\n     }\n }\n \n-/* Return true iff x is a uniform vector of floating-point\n-   constants, and the constant can be represented in\n-   quarter-precision form.  Note, as aarch64_float_const_representable\n-   rejects both +0.0 and -0.0, we will also reject +0.0 and -0.0.  */\n+/* Return true if replicating VAL32 is a valid 2-byte or 4-byte immediate\n+   for the Advanced SIMD operation described by WHICH and INSN.  If INFO\n+   is nonnull, use it to describe valid immediates.  */\n static bool\n-aarch64_vect_float_const_representable_p (rtx x)\n-{\n-  rtx elt;\n-  return (GET_MODE_CLASS (GET_MODE (x)) == MODE_VECTOR_FLOAT\n-\t  && const_vec_duplicate_p (x, &elt)\n-\t  && aarch64_float_const_representable_p (elt));\n-}\n-\n-/* Return true for valid and false for invalid.  */\n-bool\n-aarch64_simd_valid_immediate (rtx op, machine_mode mode, bool inverse,\n-\t\t\t      struct simd_immediate_info *info,\n-\t\t\t      enum simd_immediate_check which)\n-{\n-#define CHECK(STRIDE, ELSIZE, CLASS, TEST, SHIFT, NEG)\t\\\n-  matches = 1;\t\t\t\t\t\t\\\n-  for (i = 0; i < idx; i += (STRIDE))\t\t\t\\\n-    if (!(TEST))\t\t\t\t\t\\\n-      matches = 0;\t\t\t\t\t\\\n-  if (matches)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      immtype = (CLASS);\t\t\t\t\\\n-      elsize = (ELSIZE);\t\t\t\t\\\n-      eshift = (SHIFT);\t\t\t\t\t\\\n-      emvn = (NEG);\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\\\n-    }\n-\n-  unsigned int i, elsize = 0, idx = 0, n_elts = CONST_VECTOR_NUNITS (op);\n-  unsigned int innersize = GET_MODE_UNIT_SIZE (mode);\n-  unsigned char bytes[16];\n-  int immtype = -1, matches;\n-  unsigned int invmask = inverse ? 0xff : 0;\n-  int eshift, emvn;\n-\n-  if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n-    {\n-      if (! (aarch64_simd_imm_zero_p (op, mode)\n-\t     || aarch64_vect_float_const_representable_p (op)))\n-\treturn false;\n+aarch64_advsimd_valid_immediate_hs (unsigned int val32,\n+\t\t\t\t    simd_immediate_info *info,\n+\t\t\t\t    enum simd_immediate_check which,\n+\t\t\t\t    simd_immediate_info::insn_type insn)\n+{\n+  /* Try a 4-byte immediate with LSL.  */\n+  for (unsigned int shift = 0; shift < 32; shift += 8)\n+    if ((val32 & (0xff << shift)) == val32)\n+      {\n+\tif (info)\n+\t  *info = simd_immediate_info (SImode, val32 >> shift, insn,\n+\t\t\t\t       simd_immediate_info::LSL, shift);\n+\treturn true;\n+      }\n \n-      if (info)\n+  /* Try a 2-byte immediate with LSL.  */\n+  unsigned int imm16 = val32 & 0xffff;\n+  if (imm16 == (val32 >> 16))\n+    for (unsigned int shift = 0; shift < 16; shift += 8)\n+      if ((imm16 & (0xff << shift)) == imm16)\n \t{\n-\t  rtx elt = CONST_VECTOR_ELT (op, 0);\n-\t  scalar_float_mode elt_mode\n-\t    = as_a <scalar_float_mode> (GET_MODE (elt));\n-\n-\t  info->value = elt;\n-\t  info->element_width = GET_MODE_BITSIZE (elt_mode);\n-\t  info->mvn = false;\n-\t  info->shift = 0;\n+\t  if (info)\n+\t    *info = simd_immediate_info (HImode, imm16 >> shift, insn,\n+\t\t\t\t\t simd_immediate_info::LSL, shift);\n+\t  return true;\n \t}\n \n-      return true;\n-    }\n+  /* Try a 4-byte immediate with MSL, except for cases that MVN\n+     can handle.  */\n+  if (which == AARCH64_CHECK_MOV)\n+    for (unsigned int shift = 8; shift < 24; shift += 8)\n+      {\n+\tunsigned int low = (1 << shift) - 1;\n+\tif (((val32 & (0xff << shift)) | low) == val32)\n+\t  {\n+\t    if (info)\n+\t      *info = simd_immediate_info (SImode, val32 >> shift, insn,\n+\t\t\t\t\t   simd_immediate_info::MSL, shift);\n+\t    return true;\n+\t  }\n+      }\n \n-  /* Splat vector constant out into a byte vector.  */\n-  for (i = 0; i < n_elts; i++)\n+  return false;\n+}\n+\n+/* Return true if replicating VAL64 is a valid immediate for the\n+   Advanced SIMD operation described by WHICH.  If INFO is nonnull,\n+   use it to describe valid immediates.  */\n+static bool\n+aarch64_advsimd_valid_immediate (unsigned HOST_WIDE_INT val64,\n+\t\t\t\t simd_immediate_info *info,\n+\t\t\t\t enum simd_immediate_check which)\n+{\n+  unsigned int val32 = val64 & 0xffffffff;\n+  unsigned int val16 = val64 & 0xffff;\n+  unsigned int val8 = val64 & 0xff;\n+\n+  if (val32 == (val64 >> 32))\n     {\n-      /* The vector is provided in gcc endian-neutral fashion.  For aarch64_be,\n-         it must be laid out in the vector register in reverse order.  */\n-      rtx el = CONST_VECTOR_ELT (op, BYTES_BIG_ENDIAN ? (n_elts - 1 - i) : i);\n-      unsigned HOST_WIDE_INT elpart;\n+      if ((which & AARCH64_CHECK_ORR) != 0\n+\t  && aarch64_advsimd_valid_immediate_hs (val32, info, which,\n+\t\t\t\t\t\t simd_immediate_info::MOV))\n+\treturn true;\n \n-      gcc_assert (CONST_INT_P (el));\n-      elpart = INTVAL (el);\n+      if ((which & AARCH64_CHECK_BIC) != 0\n+\t  && aarch64_advsimd_valid_immediate_hs (~val32, info, which,\n+\t\t\t\t\t\t simd_immediate_info::MVN))\n+\treturn true;\n \n-      for (unsigned int byte = 0; byte < innersize; byte++)\n+      /* Try using a replicated byte.  */\n+      if (which == AARCH64_CHECK_MOV\n+\t  && val16 == (val32 >> 16)\n+\t  && val8 == (val16 >> 8))\n \t{\n-\t  bytes[idx++] = (elpart & 0xff) ^ invmask;\n-\t  elpart >>= BITS_PER_UNIT;\n+\t  if (info)\n+\t    *info = simd_immediate_info (QImode, val8);\n+\t  return true;\n \t}\n-\n     }\n \n-  /* Sanity check.  */\n-  gcc_assert (idx == GET_MODE_SIZE (mode));\n-\n-  do\n+  /* Try using a bit-to-bytemask.  */\n+  if (which == AARCH64_CHECK_MOV)\n     {\n-      if (which & AARCH64_CHECK_ORR)\n+      unsigned int i;\n+      for (i = 0; i < 64; i += 8)\n \t{\n-\t  CHECK (4, 32, 0, bytes[i] == bytes[0] && bytes[i + 1] == 0\n-\t\t && bytes[i + 2] == 0 && bytes[i + 3] == 0, 0, 0);\n-\n-\t  CHECK (4, 32, 1, bytes[i] == 0 && bytes[i + 1] == bytes[1]\n-\t\t && bytes[i + 2] == 0 && bytes[i + 3] == 0, 8, 0);\n-\n-\t  CHECK (4, 32, 2, bytes[i] == 0 && bytes[i + 1] == 0\n-\t\t && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0, 16, 0);\n-\n-\t  CHECK (4, 32, 3, bytes[i] == 0 && bytes[i + 1] == 0\n-\t\t && bytes[i + 2] == 0 && bytes[i + 3] == bytes[3], 24, 0);\n-\n-\t  CHECK (2, 16, 4, bytes[i] == bytes[0] && bytes[i + 1] == 0, 0, 0);\n-\n-\t  CHECK (2, 16, 5, bytes[i] == 0 && bytes[i + 1] == bytes[1], 8, 0);\n-\t}\n-\n-      if (which & AARCH64_CHECK_BIC)\n-\t{\n-\t  CHECK (4, 32, 6, bytes[i] == bytes[0] && bytes[i + 1] == 0xff\n-\t\t && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff, 0, 1);\n-\n-\t  CHECK (4, 32, 7, bytes[i] == 0xff && bytes[i + 1] == bytes[1]\n-\t\t && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff, 8, 1);\n-\n-\t  CHECK (4, 32, 8, bytes[i] == 0xff && bytes[i + 1] == 0xff\n-\t\t && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0xff, 16, 1);\n-\n-\t  CHECK (4, 32, 9, bytes[i] == 0xff && bytes[i + 1] == 0xff\n-\t\t && bytes[i + 2] == 0xff && bytes[i + 3] == bytes[3], 24, 1);\n-\n-\t  CHECK (2, 16, 10, bytes[i] == bytes[0] && bytes[i + 1] == 0xff, 0, 1);\n-\n-\t  CHECK (2, 16, 11, bytes[i] == 0xff && bytes[i + 1] == bytes[1], 8, 1);\n+\t  unsigned char byte = (val64 >> i) & 0xff;\n+\t  if (byte != 0 && byte != 0xff)\n+\t    break;\n \t}\n-\n-      /* Shifting ones / 8-bit / 64-bit variants only checked\n-\t for 'ALL' (MOVI/MVNI).  */\n-      if (which == AARCH64_CHECK_MOV)\n+      if (i == 64)\n \t{\n-\t  CHECK (4, 32, 12, bytes[i] == 0xff && bytes[i + 1] == bytes[1]\n-\t\t && bytes[i + 2] == 0 && bytes[i + 3] == 0, 8, 0);\n-\n-\t  CHECK (4, 32, 13, bytes[i] == 0 && bytes[i + 1] == bytes[1]\n-\t\t && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff, 8, 1);\n-\n-\t  CHECK (4, 32, 14, bytes[i] == 0xff && bytes[i + 1] == 0xff\n-\t\t && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0, 16, 0);\n-\n-\t  CHECK (4, 32, 15, bytes[i] == 0 && bytes[i + 1] == 0\n-\t\t && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0xff, 16, 1);\n-\n-\t  CHECK (1, 8, 16, bytes[i] == bytes[0], 0, 0);\n-\n-\t  CHECK (1, 64, 17, (bytes[i] == 0 || bytes[i] == 0xff)\n-\t\t && bytes[i] == bytes[(i + 8) % idx], 0, 0);\n+\t  if (info)\n+\t    *info = simd_immediate_info (DImode, val64);\n+\t  return true;\n \t}\n     }\n-  while (0);\n+  return false;\n+}\n \n-  if (immtype == -1)\n+/* Return true if OP is a valid SIMD immediate for the operation\n+   described by WHICH.  If INFO is nonnull, use it to describe valid\n+   immediates.  */\n+bool\n+aarch64_simd_valid_immediate (rtx op, simd_immediate_info *info,\n+\t\t\t      enum simd_immediate_check which)\n+{\n+  rtx elt = NULL;\n+  unsigned int n_elts;\n+  if (const_vec_duplicate_p (op, &elt))\n+    n_elts = 1;\n+  else if (GET_CODE (op) == CONST_VECTOR)\n+    n_elts = CONST_VECTOR_NUNITS (op);\n+  else\n     return false;\n \n-  if (info)\n+  machine_mode mode = GET_MODE (op);\n+  scalar_mode elt_mode = GET_MODE_INNER (mode);\n+  scalar_float_mode elt_float_mode;\n+  if (elt\n+      && is_a <scalar_float_mode> (elt_mode, &elt_float_mode)\n+      && (aarch64_float_const_zero_rtx_p (elt)\n+\t  || aarch64_float_const_representable_p (elt)))\n     {\n-      info->element_width = elsize;\n-      info->mvn = emvn != 0;\n-      info->shift = eshift;\n-\n-      unsigned HOST_WIDE_INT imm = 0;\n+      if (info)\n+\t*info = simd_immediate_info (elt_float_mode, elt);\n+      return true;\n+    }\n \n-      if (immtype >= 12 && immtype <= 15)\n-\tinfo->msl = true;\n+  unsigned int elt_size = GET_MODE_SIZE (elt_mode);\n+  if (elt_size > 8)\n+    return false;\n \n-      /* Un-invert bytes of recognized vector, if necessary.  */\n-      if (invmask != 0)\n-        for (i = 0; i < idx; i++)\n-          bytes[i] ^= invmask;\n+  scalar_int_mode elt_int_mode = int_mode_for_mode (elt_mode).require ();\n \n-      if (immtype == 17)\n-        {\n-          /* FIXME: Broken on 32-bit H_W_I hosts.  */\n-          gcc_assert (sizeof (HOST_WIDE_INT) == 8);\n+  /* Expand the vector constant out into a byte vector, with the least\n+     significant byte of the register first.  */\n+  auto_vec<unsigned char, 16> bytes;\n+  bytes.reserve (n_elts * elt_size);\n+  for (unsigned int i = 0; i < n_elts; i++)\n+    {\n+      if (!elt || n_elts != 1)\n+\t/* The vector is provided in gcc endian-neutral fashion.\n+\t   For aarch64_be, it must be laid out in the vector register\n+\t   in reverse order.  */\n+\telt = CONST_VECTOR_ELT (op, BYTES_BIG_ENDIAN ? (n_elts - 1 - i) : i);\n \n-          for (i = 0; i < 8; i++)\n-            imm |= (unsigned HOST_WIDE_INT) (bytes[i] ? 0xff : 0)\n-\t      << (i * BITS_PER_UNIT);\n+      if (elt_mode != elt_int_mode)\n+\telt = gen_lowpart (elt_int_mode, elt);\n \n+      if (!CONST_INT_P (elt))\n+\treturn false;\n \n-\t  info->value = GEN_INT (imm);\n-\t}\n-      else\n+      unsigned HOST_WIDE_INT elt_val = INTVAL (elt);\n+      for (unsigned int byte = 0; byte < elt_size; byte++)\n \t{\n-\t  for (i = 0; i < elsize / BITS_PER_UNIT; i++)\n-\t    imm |= (unsigned HOST_WIDE_INT) bytes[i] << (i * BITS_PER_UNIT);\n-\n-\t  /* Construct 'abcdefgh' because the assembler cannot handle\n-\t     generic constants.\t */\n-\t  if (info->mvn)\n-\t    imm = ~imm;\n-\t  imm = (imm >> info->shift) & 0xff;\n-\t  info->value = GEN_INT (imm);\n+\t  bytes.quick_push (elt_val & 0xff);\n+\t  elt_val >>= BITS_PER_UNIT;\n \t}\n     }\n \n-  return true;\n-#undef CHECK\n+  /* The immediate must repeat every eight bytes.  */\n+  unsigned int nbytes = bytes.length ();\n+  for (unsigned i = 8; i < nbytes; ++i)\n+    if (bytes[i] != bytes[i - 8])\n+      return false;\n+\n+  /* Get the repeating 8-byte value as an integer.  No endian correction\n+     is needed here because bytes is already in lsb-first order.  */\n+  unsigned HOST_WIDE_INT val64 = 0;\n+  for (unsigned int i = 0; i < 8; i++)\n+    val64 |= ((unsigned HOST_WIDE_INT) bytes[i % nbytes]\n+\t      << (i * BITS_PER_UNIT));\n+\n+  return aarch64_advsimd_valid_immediate (val64, info, which);\n }\n \n /* Check of immediate shift constants are within range.  */\n@@ -11758,7 +11781,7 @@ aarch64_simd_scalar_immediate_valid_for_move (rtx op, scalar_int_mode mode)\n \n   vmode = aarch64_preferred_simd_mode (mode);\n   rtx op_v = aarch64_simd_gen_const_vector_dup (vmode, INTVAL (op));\n-  return aarch64_simd_valid_immediate (op_v, vmode, false, NULL);\n+  return aarch64_simd_valid_immediate (op_v, NULL);\n }\n \n /* Construct and return a PARALLEL RTX vector with elements numbering the\n@@ -12006,7 +12029,7 @@ aarch64_simd_make_constant (rtx vals)\n     gcc_unreachable ();\n \n   if (const_vec != NULL_RTX\n-      && aarch64_simd_valid_immediate (const_vec, mode, false, NULL))\n+      && aarch64_simd_valid_immediate (const_vec, NULL))\n     /* Load using MOVI/MVNI.  */\n     return const_vec;\n   else if ((const_dup = aarch64_simd_dup_constant (vals)) != NULL_RTX)\n@@ -13086,9 +13109,7 @@ aarch64_float_const_representable_p (rtx x)\n    immediate with a CONST_VECTOR of MODE and WIDTH.  WHICH selects whether to\n    output MOVI/MVNI, ORR or BIC immediate.  */\n char*\n-aarch64_output_simd_mov_immediate (rtx const_vector,\n-\t\t\t\t   machine_mode mode,\n-\t\t\t\t   unsigned width,\n+aarch64_output_simd_mov_immediate (rtx const_vector, unsigned width,\n \t\t\t\t   enum simd_immediate_check which)\n {\n   bool is_valid;\n@@ -13098,23 +13119,21 @@ aarch64_output_simd_mov_immediate (rtx const_vector,\n   unsigned int lane_count = 0;\n   char element_char;\n \n-  struct simd_immediate_info info = { NULL_RTX, 0, 0, false, false };\n+  struct simd_immediate_info info;\n \n   /* This will return true to show const_vector is legal for use as either\n      a AdvSIMD MOVI instruction (or, implicitly, MVNI), ORR or BIC immediate.\n      It will also update INFO to show how the immediate should be generated.\n      WHICH selects whether to check for MOVI/MVNI, ORR or BIC.  */\n-  is_valid = aarch64_simd_valid_immediate (const_vector, mode, false,\n-\t\t\t\t\t   &info, which);\n+  is_valid = aarch64_simd_valid_immediate (const_vector, &info, which);\n   gcc_assert (is_valid);\n \n-  element_char = sizetochar (info.element_width);\n-  lane_count = width / info.element_width;\n+  element_char = sizetochar (GET_MODE_BITSIZE (info.elt_mode));\n+  lane_count = width / GET_MODE_BITSIZE (info.elt_mode);\n \n-  mode = GET_MODE_INNER (mode);\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+  if (GET_MODE_CLASS (info.elt_mode) == MODE_FLOAT)\n     {\n-      gcc_assert (info.shift == 0 && ! info.mvn);\n+      gcc_assert (info.shift == 0 && info.insn == simd_immediate_info::MOV);\n       /* For FP zero change it to a CONST_INT 0 and use the integer SIMD\n \t move immediate path.  */\n       if (aarch64_float_const_zero_rtx_p (info.value))\n@@ -13125,7 +13144,7 @@ aarch64_output_simd_mov_immediate (rtx const_vector,\n \t  char float_buf[buf_size] = {'\\0'};\n \t  real_to_decimal_for_mode (float_buf,\n \t\t\t\t    CONST_DOUBLE_REAL_VALUE (info.value),\n-\t\t\t\t    buf_size, buf_size, 1, mode);\n+\t\t\t\t    buf_size, buf_size, 1, info.elt_mode);\n \n \t  if (lane_count == 1)\n \t    snprintf (templ, sizeof (templ), \"fmov\\t%%d0, %s\", float_buf);\n@@ -13140,8 +13159,8 @@ aarch64_output_simd_mov_immediate (rtx const_vector,\n \n   if (which == AARCH64_CHECK_MOV)\n     {\n-      mnemonic = info.mvn ? \"mvni\" : \"movi\";\n-      shift_op = info.msl ? \"msl\" : \"lsl\";\n+      mnemonic = info.insn == simd_immediate_info::MVN ? \"mvni\" : \"movi\";\n+      shift_op = info.modifier == simd_immediate_info::MSL ? \"msl\" : \"lsl\";\n       if (lane_count == 1)\n \tsnprintf (templ, sizeof (templ), \"%s\\t%%d0, \" HOST_WIDE_INT_PRINT_HEX,\n \t\t  mnemonic, UINTVAL (info.value));\n@@ -13157,7 +13176,7 @@ aarch64_output_simd_mov_immediate (rtx const_vector,\n   else\n     {\n       /* For AARCH64_CHECK_BIC and AARCH64_CHECK_ORR.  */\n-      mnemonic = info.mvn ? \"bic\" : \"orr\";\n+      mnemonic = info.insn == simd_immediate_info::MVN ? \"bic\" : \"orr\";\n       if (info.shift)\n \tsnprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, #\"\n \t\t  HOST_WIDE_INT_PRINT_DEC \", %s #%d\", mnemonic, lane_count,\n@@ -13191,7 +13210,7 @@ aarch64_output_scalar_simd_mov_immediate (rtx immediate, scalar_int_mode mode)\n \n   vmode = aarch64_simd_container_mode (mode, width);\n   rtx v_op = aarch64_simd_gen_const_vector_dup (vmode, INTVAL (immediate));\n-  return aarch64_output_simd_mov_immediate (v_op, vmode, width);\n+  return aarch64_output_simd_mov_immediate (v_op, width);\n }\n \n /* Split operands into moves from op[1] + op[2] into op[0].  */"}, {"sha": "3ca7ec7c975d5190a165bc51b17471ebcde4ff34", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=b187677b4f275f33f181b9ca188bf0b009981cb1", "patch": "@@ -210,22 +210,21 @@\n   \"@internal\n    A constraint that matches vector of immediates for orr.\"\n  (and (match_code \"const_vector\")\n-      (match_test \"aarch64_simd_valid_immediate (op, mode, false,\n-\t\t\t\t\t\t NULL, AARCH64_CHECK_ORR)\")))\n+      (match_test \"aarch64_simd_valid_immediate (op, NULL,\n+\t\t\t\t\t\t AARCH64_CHECK_ORR)\")))\n \n (define_constraint \"Db\"\n   \"@internal\n    A constraint that matches vector of immediates for bic.\"\n  (and (match_code \"const_vector\")\n-      (match_test \"aarch64_simd_valid_immediate (op, mode, false,\n-\t\t\t\t\t\t NULL, AARCH64_CHECK_BIC)\")))\n+      (match_test \"aarch64_simd_valid_immediate (op, NULL,\n+\t\t\t\t\t\t AARCH64_CHECK_BIC)\")))\n \n (define_constraint \"Dn\"\n   \"@internal\n  A constraint that matches vector of immediates.\"\n  (and (match_code \"const_vector\")\n-      (match_test \"aarch64_simd_valid_immediate (op, GET_MODE (op),\n-\t\t\t\t\t\t false, NULL)\")))\n+      (match_test \"aarch64_simd_valid_immediate (op, NULL)\")))\n \n (define_constraint \"Dh\"\n   \"@internal"}, {"sha": "b5e9f37629fe2b5ed17093be780e973ec0ac8670", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=b187677b4f275f33f181b9ca188bf0b009981cb1", "patch": "@@ -461,6 +461,13 @@\n \t\t\t  (V1DF \"1\") (V2DF \"2\")\n \t\t\t  (DI \"1\") (DF \"1\")])\n \n+;; Map a mode to the number of bits in it, if the size of the mode\n+;; is constant.\n+(define_mode_attr bitsize [(V8QI \"64\") (V16QI \"128\")\n+\t\t\t   (V4HI \"64\") (V8HI \"128\")\n+\t\t\t   (V2SI \"64\") (V4SI \"128\")\n+\t\t\t\t       (V2DI \"128\")])\n+\n ;; Map a floating point or integer mode to the appropriate register name prefix\n (define_mode_attr s [(HF \"h\") (SF \"s\") (DF \"d\") (SI \"s\") (DI \"d\")])\n "}, {"sha": "10259c03ad865e65cdbbc63f6d68bb8a5d7bcdc5", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=b187677b4f275f33f181b9ca188bf0b009981cb1", "patch": "@@ -72,14 +72,14 @@\n (define_predicate \"aarch64_reg_or_orr_imm\"\n    (ior (match_operand 0 \"register_operand\")\n \t(and (match_code \"const_vector\")\n-\t     (match_test \"aarch64_simd_valid_immediate (op, mode, false,\n-\t\t\t\t\t\tNULL, AARCH64_CHECK_ORR)\"))))\n+\t     (match_test \"aarch64_simd_valid_immediate (op, NULL,\n+\t\t\t\t\t\t\tAARCH64_CHECK_ORR)\"))))\n \n (define_predicate \"aarch64_reg_or_bic_imm\"\n    (ior (match_operand 0 \"register_operand\")\n \t(and (match_code \"const_vector\")\n-\t     (match_test \"aarch64_simd_valid_immediate (op, mode, false,\n-\t\t\t\t\t\tNULL, AARCH64_CHECK_BIC)\"))))\n+\t     (match_test \"aarch64_simd_valid_immediate (op, NULL,\n+\t\t\t\t\t\t\tAARCH64_CHECK_BIC)\"))))\n \n (define_predicate \"aarch64_fp_compare_operand\"\n   (ior (match_operand 0 \"register_operand\")"}, {"sha": "2003706744e7e70a5e524d261eae3b9ccde16519", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b187677b4f275f33f181b9ca188bf0b009981cb1", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.target/aarch64/vect-movi.c (movi_float_lsl24): New function.\n+\t(main): Call it.\n+\n 2018-01-03  Jeff Law  <law@redhat.com>\n \n \tPR target/83641"}, {"sha": "311d3dafaec73e76591abc96df50827e5bd6b94c", "filename": "gcc/testsuite/gcc.target/aarch64/vect-movi.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-movi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b187677b4f275f33f181b9ca188bf0b009981cb1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-movi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-movi.c?ref=b187677b4f275f33f181b9ca188bf0b009981cb1", "patch": "@@ -45,10 +45,21 @@ mvni_msl16 (int *__restrict a)\n     a[i] = 0xff540000;\n }\n \n+static void\n+movi_float_lsl24 (float * a)\n+{\n+  int i;\n+\n+  /* { dg-final { scan-assembler {\\tmovi\\tv[0-9]+\\.[42]s, 0x43, lsl 24\\n} } } */\n+  for (i = 0; i < N; i++)\n+    a[i] = 128.0;\n+}\n+\n int\n main (void)\n {\n   int a[N] = { 0 };\n+  float b[N] = { 0 };\n   int i;\n \n #define CHECK_ARRAY(a, val)\t\\\n@@ -68,6 +79,9 @@ main (void)\n   mvni_msl16 (a);\n   CHECK_ARRAY (a, 0xff540000);\n \n+  movi_float_lsl24 (b);\n+  CHECK_ARRAY (b, 128.0);\n+\n   return 0;\n }\n "}]}