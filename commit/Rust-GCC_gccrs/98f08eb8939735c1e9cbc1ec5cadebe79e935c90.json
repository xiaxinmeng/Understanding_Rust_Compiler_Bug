{"sha": "98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThmMDhlYjg5Mzk3MzVjMWU5Y2JjMWVjNWNhZGViZTc5ZTkzNWM5MA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-11-21T02:50:02Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-11-21T02:50:02Z"}, "message": "c-parser.c (c_parser_has_attribute_expression): New function.\n\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (c_parser_has_attribute_expression): New function.\n\t(c_parser_attribute): New function.\n\t(c_parser_attributes): Move code into c_parser_attribute.\n\t(c_parser_unary_expression): Handle RID_HAS_ATTRIBUTE_EXPRESSION.\n\ngcc/c-family/ChangeLog:\n\n\t* c-attribs.c (type_for_vector_size): New function.\n\t(type_valid_for_vector_size): Same.\n\t(handle_vector_size_attribute): Move code to the functions above\n\tand call them.\n\t(validate_attribute, has_attribute): New functions.\n\t* c-common.h (has_attribute): Declare.\n\t(rid): Add RID_HAS_ATTRIBUTE_EXPRESSION.\n\t* c-common.c (c_common_resword): Same.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (cp_check_const_attributes): Declare.\n\t* decl2.c (cp_check_const_attributes): Declare extern.\n\t* parser.c (cp_parser_has_attribute_expression): New function.\n\t(cp_parser_unary_expression): Handle RID_HAS_ATTRIBUTE_EXPRESSION.\n\t(cp_parser_gnu_attribute_list): Add argument.\n\ngcc/ChangeLog:\n\n\t* doc/extend.texi (Other Builtins): Add __builtin_has_attribute.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/builtin-has-attribute-2.c: New test.\n\t* c-c++-common/builtin-has-attribute-3.c: New test.\n\t* c-c++-common/builtin-has-attribute-4.c: New test.\n\t* c-c++-common/builtin-has-attribute.c: New test.\n\t* gcc.dg/builtin-has-attribute.c: New test.\n\t* gcc/testsuite/gcc.target/i386/builtin-has-attribute.c: New test.\n\nFrom-SVN: r266335", "tree": {"sha": "9fb2084c7e170349abee1d8f950047936556b98a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fb2084c7e170349abee1d8f950047936556b98a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "48d1f31d1b7131e8f809ede8256e4f1eb6c5c3ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48d1f31d1b7131e8f809ede8256e4f1eb6c5c3ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48d1f31d1b7131e8f809ede8256e4f1eb6c5c3ae"}], "stats": {"total": 1522, "additions": 1426, "deletions": 96}, "files": [{"sha": "229e1b0e1670961b96511388d092864731e1d062", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -1,3 +1,7 @@\n+2018-11-20  Martin Sebor  <msebor@redhat.com>\n+\n+\t* doc/extend.texi (Other Builtins): Add __builtin_has_attribute.\n+\n 2018-11-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/84044"}, {"sha": "6d60cf02ed5aba57d33c2d3f5f9fc4965caa2fdf", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -1,3 +1,14 @@\n+2018-11-20  Martin Sebor  <msebor@redhat.com>\n+\n+\t* c-attribs.c (type_for_vector_size): New function.\n+\t(type_valid_for_vector_size): Same.\n+\t(handle_vector_size_attribute): Move code to the functions above\n+\tand call them.\n+\t(validate_attribute, has_attribute): New functions.\n+\t* c-common.h (has_attribute): Declare.\n+\t(rid): Add RID_HAS_ATTRIBUTE_EXPRESSION.\n+\t* c-common.c (c_common_resword): Same.\n+\n 2018-11-16  Jason Merrill  <jason@redhat.com>\n \n \t* c-lex.c (c_common_has_attribute): Handle likely/unlikely."}, {"sha": "373381df68e63b27ce4ba8416e20a775381a0f2a", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -4176,7 +4176,7 @@ has_attribute (location_t atloc, tree t, tree attr, tree (*convert)(tree))\n \t      if (expr && DECL_P (expr))\n \t\tfound_match = TREE_READONLY (expr);\n \t    }\n-\t  else if (!strcmp (\"const\", namestr))\n+\t  else if (!strcmp (\"pure\", namestr))\n \t    {\n \t      if (expr && DECL_P (expr))\n \t\tfound_match = DECL_PURE_P (expr);"}, {"sha": "9d51815532d961fb9c472c319ae3fe329ebc85c3", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -376,6 +376,7 @@ const struct c_common_resword c_common_reswords[] =\n     RID_BUILTIN_CALL_WITH_STATIC_CHAIN, D_CONLY },\n   { \"__builtin_choose_expr\", RID_CHOOSE_EXPR, D_CONLY },\n   { \"__builtin_complex\", RID_BUILTIN_COMPLEX, D_CONLY },\n+  { \"__builtin_has_attribute\", RID_BUILTIN_HAS_ATTRIBUTE, 0 },\n   { \"__builtin_launder\", RID_BUILTIN_LAUNDER, D_CXXONLY },\n   { \"__builtin_shuffle\", RID_BUILTIN_SHUFFLE, 0 },\n   { \"__builtin_tgmath\", RID_BUILTIN_TGMATH, D_CONLY },"}, {"sha": "4187343c0b3f7d6f7b3237ac6f610a3a143c2bcf", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -103,6 +103,7 @@ enum rid\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_CHOOSE_EXPR,\n   RID_TYPES_COMPATIBLE_P,      RID_BUILTIN_COMPLEX,\t     RID_BUILTIN_SHUFFLE,\n   RID_BUILTIN_TGMATH,\n+  RID_BUILTIN_HAS_ATTRIBUTE,\n   RID_DFLOAT32, RID_DFLOAT64, RID_DFLOAT128,\n \n   /* TS 18661-3 keywords, in the same sequence as the TI_* values.  */\n@@ -1355,6 +1356,7 @@ extern void maybe_suggest_missing_token_insertion (rich_location *richloc,\n \t\t\t\t\t\t   enum cpp_ttype token_type,\n \t\t\t\t\t\t   location_t prev_token_loc);\n extern tree braced_list_to_string (tree, tree);\n+extern bool has_attribute (location_t, tree, tree, tree (*)(tree));\n \n #if CHECKING_P\n namespace selftest {"}, {"sha": "0b73df94db11939ea876d63d34bf82b7b3af74d4", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -1,3 +1,10 @@\n+2018-11-20  Martin Sebor  <msebor@redhat.com>\n+\n+\t* c-parser.c (c_parser_has_attribute_expression): New function.\n+\t(c_parser_attribute): New function.\n+\t(c_parser_attributes): Move code into c_parser_attribute.\n+\t(c_parser_unary_expression): Handle RID_HAS_ATTRIBUTE_EXPRESSION.\n+\n 2018-11-15  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/83656"}, {"sha": "afc40710e83a2aecd5a3323aa9d254ae843427f8", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 251, "deletions": 89, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -1445,6 +1445,8 @@ static vec<tree, va_gc> *c_parser_expr_list (c_parser *, bool, bool,\n \t\t\t\t\t     vec<tree, va_gc> **, location_t *,\n \t\t\t\t\t     tree *, vec<location_t> *,\n \t\t\t\t\t     unsigned int * = NULL);\n+static struct c_expr c_parser_has_attribute_expression (c_parser *);\n+\n static void c_parser_oacc_declare (c_parser *);\n static void c_parser_oacc_enter_exit_data (c_parser *, bool);\n static void c_parser_oacc_update (c_parser *);\n@@ -4313,7 +4315,126 @@ c_parser_attribute_any_word (c_parser *parser)\n    type), a reserved word storage class specifier, type specifier or\n    type qualifier.  ??? This still leaves out most reserved keywords\n    (following the old parser), shouldn't we include them, and why not\n-   allow identifiers declared as types to start the arguments?  */\n+   allow identifiers declared as types to start the arguments?\n+   When EXPECT_COMMA is true, expect the attribute to be preceded\n+   by a comma and fail if it isn't.\n+   When EMPTY_OK is true, allow and consume any number of consecutive\n+   commas with no attributes in between.  */\n+\n+static tree\n+c_parser_attribute (c_parser *parser, tree attrs,\n+\t\t    bool expect_comma = false, bool empty_ok = true)\n+{\n+  bool comma_first = c_parser_next_token_is (parser, CPP_COMMA);\n+  if (!comma_first\n+      && !c_parser_next_token_is (parser, CPP_NAME)\n+      && !c_parser_next_token_is (parser, CPP_KEYWORD))\n+    return NULL_TREE;\n+\n+  while (c_parser_next_token_is (parser, CPP_COMMA))\n+    {\n+      c_parser_consume_token (parser);\n+      if (!empty_ok)\n+\treturn attrs;\n+    }\n+\n+  tree attr_name = c_parser_attribute_any_word (parser);\n+  if (attr_name == NULL_TREE)\n+    return NULL_TREE;\n+\n+  attr_name = canonicalize_attr_name (attr_name);\n+  c_parser_consume_token (parser);\n+\n+  tree attr;\n+  if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n+    {\n+      if (expect_comma && !comma_first)\n+\t{\n+\t  /* A comma is missing between the last attribute on the chain\n+\t     and this one.  */\n+\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t     \"expected %<)%>\");\n+\t  return error_mark_node;\n+\t}\n+      attr = build_tree_list (attr_name, NULL_TREE);\n+      /* Add this attribute to the list.  */\n+      attrs = chainon (attrs, attr);\n+      return attrs;\n+    }\n+  c_parser_consume_token (parser);\n+\n+  vec<tree, va_gc> *expr_list;\n+  tree attr_args;\n+  /* Parse the attribute contents.  If they start with an\n+     identifier which is followed by a comma or close\n+     parenthesis, then the arguments start with that\n+     identifier; otherwise they are an expression list.\n+     In objective-c the identifier may be a classname.  */\n+  if (c_parser_next_token_is (parser, CPP_NAME)\n+      && (c_parser_peek_token (parser)->id_kind == C_ID_ID\n+\t  || (c_dialect_objc ()\n+\t      && c_parser_peek_token (parser)->id_kind\n+\t      == C_ID_CLASSNAME))\n+      && ((c_parser_peek_2nd_token (parser)->type == CPP_COMMA)\n+\t  || (c_parser_peek_2nd_token (parser)->type\n+\t      == CPP_CLOSE_PAREN))\n+      && (attribute_takes_identifier_p (attr_name)\n+\t  || (c_dialect_objc ()\n+\t      && c_parser_peek_token (parser)->id_kind\n+\t      == C_ID_CLASSNAME)))\n+    {\n+      tree arg1 = c_parser_peek_token (parser)->value;\n+      c_parser_consume_token (parser);\n+      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+\tattr_args = build_tree_list (NULL_TREE, arg1);\n+      else\n+\t{\n+\t  tree tree_list;\n+\t  c_parser_consume_token (parser);\n+\t  expr_list = c_parser_expr_list (parser, false, true,\n+\t\t\t\t\t  NULL, NULL, NULL, NULL);\n+\t  tree_list = build_tree_list_vec (expr_list);\n+\t  attr_args = tree_cons (NULL_TREE, arg1, tree_list);\n+\t  release_tree_vector (expr_list);\n+\t}\n+    }\n+  else\n+    {\n+      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+\tattr_args = NULL_TREE;\n+      else\n+\t{\n+\t  expr_list = c_parser_expr_list (parser, false, true,\n+\t\t\t\t\t  NULL, NULL, NULL, NULL);\n+\t  attr_args = build_tree_list_vec (expr_list);\n+\t  release_tree_vector (expr_list);\n+\t}\n+    }\n+\n+  attr = build_tree_list (attr_name, attr_args);\n+  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+    c_parser_consume_token (parser);\n+  else\n+    {\n+      parser->lex_untranslated_string = false;\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t \"expected %<)%>\");\n+      return error_mark_node;\n+    }\n+\n+  if (expect_comma && !comma_first)\n+    {\n+      /* A comma is missing between the last attribute on the chain\n+\t and this one.  */\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t \"expected %<)%>\");\n+      return error_mark_node;\n+    }\n+\n+  /* Add this attribute to the list.  */\n+  attrs = chainon (attrs, attr);\n+  return attrs;\n+}\n \n static tree\n c_parser_attributes (c_parser *parser)\n@@ -4338,97 +4459,19 @@ c_parser_attributes (c_parser *parser)\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t  return attrs;\n \t}\n-      /* Parse the attribute list.  */\n-      while (c_parser_next_token_is (parser, CPP_COMMA)\n-\t     || c_parser_next_token_is (parser, CPP_NAME)\n-\t     || c_parser_next_token_is (parser, CPP_KEYWORD))\n+      /* Parse the attribute list.  Require a comma between successive\n+\t (possibly empty) attributes.  */\n+      for (bool expect_comma = false; ; expect_comma = true)\n \t{\n-\t  tree attr, attr_name, attr_args;\n-\t  vec<tree, va_gc> *expr_list;\n-\t  if (c_parser_next_token_is (parser, CPP_COMMA))\n-\t    {\n-\t      c_parser_consume_token (parser);\n-\t      continue;\n-\t    }\n-\n-\t  attr_name = c_parser_attribute_any_word (parser);\n-\t  if (attr_name == NULL)\n+\t  /* Parse a single attribute.  */\n+\t  tree attr = c_parser_attribute (parser, attrs, expect_comma);\n+\t  if (attr == error_mark_node)\n+\t    return attrs;\n+\t  if (!attr)\n \t    break;\n-\t  attr_name = canonicalize_attr_name (attr_name);\n-\t  c_parser_consume_token (parser);\n-\t  if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n-\t    {\n-\t      attr = build_tree_list (attr_name, NULL_TREE);\n-\t      /* Add this attribute to the list.  */\n-\t      attrs = chainon (attrs, attr);\n-\t      /* If the next token isn't a comma, we're done.  */\n-\t      if (!c_parser_next_token_is (parser, CPP_COMMA))\n-\t\tbreak;\n-\t      continue;\n-\t    }\n-\t  c_parser_consume_token (parser);\n-\t  /* Parse the attribute contents.  If they start with an\n-\t     identifier which is followed by a comma or close\n-\t     parenthesis, then the arguments start with that\n-\t     identifier; otherwise they are an expression list.  \n-\t     In objective-c the identifier may be a classname.  */\n-\t  if (c_parser_next_token_is (parser, CPP_NAME)\n-\t      && (c_parser_peek_token (parser)->id_kind == C_ID_ID\n-\t\t  || (c_dialect_objc ()\n-\t\t      && c_parser_peek_token (parser)->id_kind\n-\t\t\t == C_ID_CLASSNAME))\n-\t      && ((c_parser_peek_2nd_token (parser)->type == CPP_COMMA)\n-\t\t  || (c_parser_peek_2nd_token (parser)->type\n-\t\t      == CPP_CLOSE_PAREN))\n-\t      && (attribute_takes_identifier_p (attr_name)\n-\t\t  || (c_dialect_objc ()\n-\t\t      && c_parser_peek_token (parser)->id_kind\n-\t\t\t == C_ID_CLASSNAME)))\n-\t    {\n-\t      tree arg1 = c_parser_peek_token (parser)->value;\n-\t      c_parser_consume_token (parser);\n-\t      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-\t\tattr_args = build_tree_list (NULL_TREE, arg1);\n-\t      else\n-\t\t{\n-\t\t  tree tree_list;\n-\t\t  c_parser_consume_token (parser);\n-\t\t  expr_list = c_parser_expr_list (parser, false, true,\n-\t\t\t\t\t\t  NULL, NULL, NULL, NULL);\n-\t\t  tree_list = build_tree_list_vec (expr_list);\n-\t\t  attr_args = tree_cons (NULL_TREE, arg1, tree_list);\n-\t\t  release_tree_vector (expr_list);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-\t\tattr_args = NULL_TREE;\n-\t      else\n-\t\t{\n-\t\t  expr_list = c_parser_expr_list (parser, false, true,\n-\t\t\t\t\t\t  NULL, NULL, NULL, NULL);\n-\t\t  attr_args = build_tree_list_vec (expr_list);\n-\t\t  release_tree_vector (expr_list);\n-\t\t}\n-\t    }\n+\t  attrs = attr;\n+      }\n \n-\t  attr = build_tree_list (attr_name, attr_args);\n-\t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-\t    c_parser_consume_token (parser);\n-\t  else\n-\t    {\n-\t      parser->lex_untranslated_string = false;\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t\t \"expected %<)%>\");\n-\t      return attrs;\n-\t    }\n-\t  /* Add this attribute to the list.  */\n-\t  attrs = chainon (attrs, attr);\n-\t  /* If the next token isn't a comma, we're done.  */\n-\t  if (!c_parser_next_token_is (parser, CPP_COMMA))\n-\t    break;\n-\t}\n       /* Look for the two `)' tokens.  */\n       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \tc_parser_consume_token (parser);\n@@ -7263,6 +7306,8 @@ c_parser_unary_expression (c_parser *parser)\n \t  return c_parser_sizeof_expression (parser);\n \tcase RID_ALIGNOF:\n \t  return c_parser_alignof_expression (parser);\n+\tcase RID_BUILTIN_HAS_ATTRIBUTE:\n+\t  return c_parser_has_attribute_expression (parser);\n \tcase RID_EXTENSION:\n \t  c_parser_consume_token (parser);\n \t  ext = disable_extension_diagnostics ();\n@@ -7462,6 +7507,123 @@ c_parser_alignof_expression (c_parser *parser)\n     }\n }\n \n+/* Parse the __builtin_has_attribute ([expr|type], attribute-spec)\n+   expression.  */\n+\n+static struct c_expr\n+c_parser_has_attribute_expression (c_parser *parser)\n+{\n+  gcc_assert (c_parser_next_token_is_keyword (parser,\n+\t\t\t\t\t      RID_BUILTIN_HAS_ATTRIBUTE));\n+  c_parser_consume_token (parser);\n+\n+  c_inhibit_evaluation_warnings++;\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    {\n+      c_inhibit_evaluation_warnings--;\n+      in_typeof--;\n+\n+      struct c_expr result;\n+      result.set_error ();\n+      result.original_code = ERROR_MARK;\n+      result.original_type = NULL;\n+      return result;\n+    }\n+\n+  /* Treat the type argument the same way as in typeof for the purposes\n+     of warnings.  FIXME: Generalize this so the warning refers to\n+     __builtin_has_attribute rather than typeof.  */\n+  in_typeof++;\n+\n+  /* The first operand: one of DECL, EXPR, or TYPE.  */\n+  tree oper = NULL_TREE;\n+  if (c_parser_next_tokens_start_typename (parser, cla_prefer_id))\n+    {\n+      struct c_type_name *tname = c_parser_type_name (parser);\n+      in_typeof--;\n+      if (tname)\n+\t{\n+\t  oper = groktypename (tname, NULL, NULL);\n+\t  pop_maybe_used (variably_modified_type_p (oper, NULL_TREE));\n+\t}\n+    }\n+  else\n+    {\n+      struct c_expr cexpr = c_parser_expr_no_commas (parser, NULL);\n+      c_inhibit_evaluation_warnings--;\n+      in_typeof--;\n+      if (cexpr.value != error_mark_node)\n+\t{\n+\t  mark_exp_read (cexpr.value);\n+\t  oper = cexpr.value;\n+\t  tree etype = TREE_TYPE (oper);\n+\t  bool was_vm = variably_modified_type_p (etype, NULL_TREE);\n+\t  /* This is returned with the type so that when the type is\n+\t     evaluated, this can be evaluated.  */\n+\t  if (was_vm)\n+\t    oper = c_fully_fold (oper, false, NULL);\n+\t  pop_maybe_used (was_vm);\n+\t}\n+    }\n+\n+  struct c_expr result;\n+  result.original_code = ERROR_MARK;\n+  result.original_type = NULL;\n+\n+  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n+    {\n+      /* Consume the closing parenthesis if that's the next token\n+\t in the likely case the built-in was invoked with fewer\n+\t than two arguments.  */\n+      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+\tc_parser_consume_token (parser);\n+      c_inhibit_evaluation_warnings--;\n+      result.set_error ();\n+      return result;\n+    }\n+\n+  parser->lex_untranslated_string = true;\n+\n+  location_t atloc = c_parser_peek_token (parser)->location;\n+  /* Parse a single attribute.  Require no leading comma and do not\n+     allow empty attributes.  */\n+  tree attr = c_parser_attribute (parser, NULL_TREE, false, false);\n+\n+  parser->lex_untranslated_string = false;\n+\n+  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+    c_parser_consume_token (parser);\n+  else\n+    {\n+      c_parser_error (parser, \"expected identifier\");\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n+\n+      result.set_error ();\n+      return result;\n+    }\n+\n+  if (!attr)\n+    {\n+      error_at (atloc, \"expected identifier\");\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t \"expected %<)%>\");\n+      result.set_error ();\n+      return result;\n+    }\n+\n+  result.original_code = INTEGER_CST;\n+  result.original_type = boolean_type_node;\n+\n+  if (has_attribute (atloc, oper, attr, default_conversion))\n+    result.value = boolean_true_node;\n+  else\n+    result.value =  boolean_false_node;\n+\n+  return result;\n+}\n+\n /* Helper function to read arguments of builtins which are interfaces\n    for the middle-end nodes like COMPLEX_EXPR, VEC_PERM_EXPR and\n    others.  The name of the builtin is passed using BNAME parameter."}, {"sha": "a8e054442d6cc5fe1fe01207ac34765520087ef1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -1,3 +1,11 @@\n+2018-11-20  Martin Sebor  <msebor@redhat.com>\n+\n+\t* cp-tree.h (cp_check_const_attributes): Declare.\n+\t* decl2.c (cp_check_const_attributes): Declare extern.\n+\t* parser.c (cp_parser_has_attribute_expression): New function.\n+\t(cp_parser_unary_expression): Handle RID_HAS_ATTRIBUTE_EXPRESSION.\n+\t(cp_parser_gnu_attribute_list): Add argument.\n+\n 2018-11-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/88110"}, {"sha": "111a123bb34c50af51a92d3d82621307492c62b1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -6491,6 +6491,7 @@ extern int parm_index                           (tree);\n extern tree vtv_start_verification_constructor_init_function (void);\n extern tree vtv_finish_verification_constructor_init_function (tree);\n extern bool cp_omp_mappable_type\t\t(tree);\n+extern void cp_check_const_attributes (tree);\n \n /* in error.c */\n extern const char *type_as_string\t\t(tree, int);"}, {"sha": "ffc0d0d6ec4b7d9fdc5990b6ce478218e66886ac", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -1368,7 +1368,7 @@ cp_reconstruct_complex_type (tree type, tree bottom)\n /* Replaces any constexpr expression that may be into the attributes\n    arguments with their reduced value.  */\n \n-static void\n+void\n cp_check_const_attributes (tree attributes)\n {\n   if (attributes == error_mark_node)"}, {"sha": "0617f5636cdadd46bccd755755707f1f3e2eb679", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 125, "deletions": 5, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -2048,6 +2048,8 @@ static cp_expr cp_parser_unary_expression\n   (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false, bool = false);\n static enum tree_code cp_parser_unary_operator\n   (cp_token *);\n+static tree cp_parser_has_attribute_expression\n+  (cp_parser *);\n static tree cp_parser_new_expression\n   (cp_parser *);\n static vec<tree, va_gc> *cp_parser_new_placement\n@@ -2381,7 +2383,7 @@ static tree cp_parser_attributes_opt\n static tree cp_parser_gnu_attributes_opt\n   (cp_parser *);\n static tree cp_parser_gnu_attribute_list\n-  (cp_parser *);\n+  (cp_parser *, bool = false);\n static tree cp_parser_std_attribute\n   (cp_parser *, tree);\n static tree cp_parser_std_attribute_spec\n@@ -8110,6 +8112,9 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t    return ret_expr;\n \t  }\n \n+\tcase RID_BUILTIN_HAS_ATTRIBUTE:\n+\t  return cp_parser_has_attribute_expression (parser);\n+\n \tcase RID_NEW:\n \t  return cp_parser_new_expression (parser);\n \n@@ -8407,6 +8412,121 @@ cp_parser_unary_operator (cp_token* token)\n     }\n }\n \n+/* Parse a __builtin_has_attribute([expr|type], attribute-spec) expression.\n+   Returns a representation of the expression.  */\n+\n+static tree\n+cp_parser_has_attribute_expression (cp_parser *parser)\n+{\n+  location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  /* Consume the __builtin_has_attribute token.  */\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return error_mark_node;\n+\n+  /* Types cannot be defined in a `sizeof' expression.  Save away the\n+     old message.  */\n+  const char *saved_message = parser->type_definition_forbidden_message;\n+  /* And create the new one.  */\n+  const int kwd = RID_BUILTIN_HAS_ATTRIBUTE;\n+  char *tmp = concat (\"types may not be defined in %<\",\n+\t\t      IDENTIFIER_POINTER (ridpointers[kwd]),\n+\t\t      \"%> expressions\", NULL);\n+  parser->type_definition_forbidden_message = tmp;\n+\n+  /* The restrictions on constant-expressions do not apply inside\n+     sizeof expressions.  */\n+  bool saved_integral_constant_expression_p\n+    = parser->integral_constant_expression_p;\n+  bool saved_non_integral_constant_expression_p\n+    = parser->non_integral_constant_expression_p;\n+  parser->integral_constant_expression_p = false;\n+\n+  /* Do not actually evaluate the expression.  */\n+  ++cp_unevaluated_operand;\n+  ++c_inhibit_evaluation_warnings;\n+\n+  tree oper = NULL_TREE;\n+\n+  /* We can't be sure yet whether we're looking at a type-id or an\n+     expression.  */\n+  cp_parser_parse_tentatively (parser);\n+\n+  bool saved_in_type_id_in_expr_p = parser->in_type_id_in_expr_p;\n+  parser->in_type_id_in_expr_p = true;\n+  /* Look for the type-id.  */\n+  oper = cp_parser_type_id (parser);\n+  parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n+\n+  cp_parser_parse_definitely (parser);\n+\n+  /* If the type-id production did not work out, then we must be\n+     looking at the unary-expression production.  */\n+  if (!oper || oper == error_mark_node)\n+    oper = cp_parser_unary_expression (parser);\n+\n+  /* Go back to evaluating expressions.  */\n+  --cp_unevaluated_operand;\n+  --c_inhibit_evaluation_warnings;\n+\n+  /* Free the message we created.  */\n+  free (tmp);\n+  /* And restore the old one.  */\n+  parser->type_definition_forbidden_message = saved_message;\n+  parser->integral_constant_expression_p\n+    = saved_integral_constant_expression_p;\n+  parser->non_integral_constant_expression_p\n+    = saved_non_integral_constant_expression_p;\n+\n+  /* Consume the comma if it's there.  */\n+  if (!cp_parser_require (parser, CPP_COMMA, RT_COMMA))\n+    {\n+      cp_parser_skip_to_closing_parenthesis (parser, false, false,\n+\t\t\t\t\t     /*consume_paren=*/true);\n+      return error_mark_node;\n+    }\n+\n+  /* Parse the attribute specification.  */\n+  bool ret = false;\n+  location_t atloc = cp_lexer_peek_token (parser->lexer)->location;\n+  if (tree attr = cp_parser_gnu_attribute_list (parser, /*exactly_one=*/true))\n+    {\n+      if (oper != error_mark_node)\n+\t{\n+\t  /* Fold constant expressions used in attributes first.  */\n+\t  cp_check_const_attributes (attr);\n+\n+\t  /* Finally, see if OPER has been declared with ATTR.  */\n+\t  ret = has_attribute (atloc, oper, attr, default_conversion);\n+\t}\n+\n+      parens.require_close (parser);\n+    }\n+  else\n+    {\n+      error_at (atloc, \"expected identifier\");\n+      cp_parser_skip_to_closing_parenthesis (parser, true, false, true);\n+    }\n+\n+  /* Construct a location e.g. :\n+     __builtin_has_attribute (oper, attr)\n+     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+     with start == caret at the start of the built-in token,\n+     and with the endpoint at the final closing paren.  */\n+  location_t finish_loc\n+    = cp_lexer_previous_token (parser->lexer)->location;\n+  location_t compound_loc\n+    = make_location (start_loc, start_loc, finish_loc);\n+\n+  cp_expr ret_expr (ret ? boolean_true_node : boolean_false_node);\n+  ret_expr.set_location (compound_loc);\n+  ret_expr = ret_expr.maybe_add_location_wrapper ();\n+  return ret_expr;\n+}\n+\n /* Parse a new-expression.\n \n    new-expression:\n@@ -25376,7 +25496,7 @@ cp_parser_gnu_attributes_opt (cp_parser* parser)\n    the arguments, if any.  */\n \n static tree\n-cp_parser_gnu_attribute_list (cp_parser* parser)\n+cp_parser_gnu_attribute_list (cp_parser* parser, bool exactly_one /* = false */)\n {\n   tree attribute_list = NULL_TREE;\n   bool save_translate_strings_p = parser->translate_strings_p;\n@@ -25443,9 +25563,9 @@ cp_parser_gnu_attribute_list (cp_parser* parser)\n \n \t  token = cp_lexer_peek_token (parser->lexer);\n \t}\n-      /* Now, look for more attributes.  If the next token isn't a\n-\t `,', we're done.  */\n-      if (token->type != CPP_COMMA)\n+      /* Unless EXACTLY_ONE is set look for more attributes.\n+\t If the next token isn't a `,', we're done.  */\n+      if (exactly_one || token->type != CPP_COMMA)\n \tbreak;\n \n       /* Consume the comma and keep going.  */"}, {"sha": "858b2d15440922fd4c6abf3521d71c2d6871421f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -11140,6 +11140,7 @@ is called and the @var{flag} argument passed to it.\n @findex __builtin_call_with_static_chain\n @findex __builtin_extend_pointer\n @findex __builtin_fpclassify\n+@findex __builtin_has_attribute\n @findex __builtin_isfinite\n @findex __builtin_isnormal\n @findex __builtin_isgreater\n@@ -11797,6 +11798,46 @@ check its compatibility with @var{size}.\n \n @end deftypefn\n \n+@deftypefn {Built-in Function} bool __builtin_has_attribute (@var{type-or-expression}, @var{attribute})\n+The @code{__builtin_has_attribute} function evaluates to an integer constant\n+expression equal to @code{true} if the symbol or type referenced by\n+the @var{type-or-expression} argument has been declared with\n+the @var{attribute} referenced by the second argument.  Neither argument\n+is evaluated.  The @var{type-or-expression} argument is subject to the same\n+restrictions as the argument to @code{typeof} (@pxref{Typeof}).  The\n+@var{attribute} argument is an attribute name optionally followed by\n+a comma-separated list of arguments enclosed in parentheses.  Both forms\n+of attribute names---with and without double leading and trailing\n+underscores---are recognized.  See @xref{Attribute Syntax} for details.\n+When no attribute arguments are specified for an attribute that expects\n+one or more arguments the function returns @code{true} if\n+@var{type-or-expression} has been declared with the attribute regardless\n+of the attribute argument values.  Arguments provided for an attribute\n+that expects some are validated and matched up to the provided number.\n+The function returns @code{true} if all provided arguments match.  For\n+example, the first call to the function below evaluates to @code{true}\n+because @code{x} is declared with the @code{aligned} attribute but\n+the second call evaluates to @code{false} because @code{x} is declared\n+@code{aligned (8)} and not @code{aligned (4)}.\n+\n+@smallexample\n+__attribute__ ((aligned (8))) int x;\n+_Static_assert (__builtin_has_attribute (x, aligned), \"aligned\");\n+_Static_assert (!__builtin_has_attribute (x, aligned (4)), \"aligned (4)\");\n+@end smallexample\n+\n+Due to a limitation the @code{__builtin_has_attribute} function returns\n+@code{false} for the @code{mode} attribute even if the type or variable\n+referenced by the @var{type-or-expression} argument was declared with one.\n+The function is also not supported with labels, and in C with enumerators.\n+\n+Note that unlike the @code{__has_attribute} preprocessor operator which\n+is suitable for use in @code{#if} preprocessing directives\n+@code{__builtin_has_attribute} is an intrinsic function that is not\n+recognized in such contexts.\n+\n+@end deftypefn\n+\n @deftypefn {Built-in Function} @var{type} __builtin_speculation_safe_value (@var{type} val, @var{type} failval)\n \n This built-in function can be used to help mitigate against unsafe"}, {"sha": "43831fcfbb43f5ea4f450ac1dcda639b281ce517", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -1,3 +1,12 @@\n+2018-11-20  Martin Sebor  <msebor@redhat.com>\n+\n+\t* c-c++-common/builtin-has-attribute-2.c: New test.\n+\t* c-c++-common/builtin-has-attribute-3.c: New test.\n+\t* c-c++-common/builtin-has-attribute-4.c: New test.\n+\t* c-c++-common/builtin-has-attribute.c: New test.\n+\t* gcc.dg/builtin-has-attribute.c: New test.\n+\t* gcc/testsuite/gcc.target/i386/builtin-has-attribute.c: New test.\n+\n 2018-11-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/84044"}, {"sha": "0f692ffe44481717c7413d366d21352a95ad31bf", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-2.c", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-2.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -0,0 +1,206 @@\n+/* Verify __builtin_has_attribute return value for types.\n+   { dg-do compile }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" }\n+   { dg-options \"-Wall -Wno-narrowing -Wno-unused-local-typedefs -ftrack-macro-expansion=0\" { target c++ } }  */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+#define A(expect, sym, attr)\t\t\t\t\t\t\\\n+  typedef int Assert [1 - 2 * !(__builtin_has_attribute (sym, attr) == expect)]\n+\n+struct ATTR (packed) Packed { char c; int i; };\n+\n+void fvoid (void);\n+struct Packed fpacked (void);\n+\n+union OrdinaryUnion { void *p; int i; };\n+union ATTR (transparent_union) TransparentUnion { void *p; int i; };\n+\n+/* Exercise __builtin_has_attribute with the first argument that\n+   is a type.  */\n+\n+void test_type (int n)\n+{\n+  /* Verify both forms of the attribute spelling.  Unlike the attribute\n+     keyword that can be spelled three ways (with either leading or\n+     trailing underscores, or with both), attribute names can only be\n+     spelled two ways.  */\n+  A (0, int, aligned);\n+  A (0, int, __aligned__);\n+\n+  A (0, int, aligned (1));\n+  A (0, int, aligned (2));\n+  A (0, int[1], aligned);\n+  A (0, int[1], aligned (2));\n+  A (0, int[n], aligned);\n+  A (0, int[n], aligned (4));\n+\n+  /* Again, verify both forms of the attribute spelling.  */\n+  A (1, ATTR (aligned) char, aligned);\n+  A (1, ATTR (aligned (2)) short, aligned);\n+  A (1, ATTR (aligned (4)) int, __aligned__);\n+\n+  A (0, int ATTR (aligned (4)), aligned (2));\n+  A (0, int ATTR (aligned (2)), aligned (4));\n+  /* GCC retains both attributes in the */\n+  A (0, int ATTR (aligned (2), aligned (4)), aligned (2));\n+  A (1, int ATTR (aligned (2), aligned (4)), aligned (4));\n+  /* The following fails due to bug 87524.\n+     A (1, int ATTR (aligned (4), aligned (2))), aligned (4)); */\n+  A (0, int ATTR (aligned (4), aligned (2)), aligned (8));\n+\n+  A (1, int ATTR (aligned (8)), aligned (1 + 7));\n+\n+  enum { eight = 8 };\n+  A (1, int ATTR (aligned (8)), aligned (eight));\n+  A (1, int ATTR (aligned (eight)), aligned (1 + 7));\n+\n+  struct NotPacked { char c; int i; };\n+  A (0, struct NotPacked, packed);\n+  A (1, struct Packed, packed);\n+\n+  /* Exercise types returned from a function.  */\n+  A (0, fvoid (), packed);\n+  A (1, fpacked (), packed);\n+\n+  struct ATTR (aligned (2), packed) Aligned2Packed { char c; int i; };\n+  A (1, struct Aligned2Packed, aligned);\n+  A (1, struct Aligned2Packed, aligned (2));\n+  A (0, struct Aligned2Packed, aligned (4));\n+  A (1, struct Aligned2Packed, packed);\n+\n+  A (0, int, may_alias);\n+  A (1, ATTR (may_alias) int, may_alias);\n+\n+  A (0, char, warn_if_not_aligned (1));\n+  A (0, char, warn_if_not_aligned (2));\n+\n+  A (1, ATTR (warn_if_not_aligned (2)) char, warn_if_not_aligned);\n+  A (0, ATTR (warn_if_not_aligned (2)) char, warn_if_not_aligned (1));\n+  A (1, ATTR (warn_if_not_aligned (2)) char, warn_if_not_aligned (2));\n+  A (0, ATTR (warn_if_not_aligned (2)) char, warn_if_not_aligned (4));\n+\n+  A (0, union OrdinaryUnion, transparent_union);\n+\n+  A (1, union TransparentUnion, transparent_union);\n+  A (1, const union TransparentUnion, transparent_union);\n+}\n+\n+/* Exercise __builtin_has_attribute with the first argument that\n+   is a typedef.  */\n+\n+void test_typedef (int n)\n+{\n+  typedef char A1[1];\n+  A (0, A1, aligned);\n+  A (0, A1, aligned (1));\n+  A (0, A1, aligned (2));\n+\n+  typedef char An[n];\n+  A (0, An, aligned);\n+  A (0, An, aligned (1));\n+  A (0, An, aligned (2));\n+\n+  typedef ATTR (aligned (8)) short AI8;\n+  A (1, AI8, aligned);\n+  A (0, AI8, aligned (4));\n+  A (1, AI8, aligned (8));\n+  A (0, AI8, aligned (16));\n+\n+  A (1, const AI8, aligned);\n+  A (1, const volatile AI8, aligned);\n+\n+  typedef ATTR (aligned (2), aligned (8), aligned (16)) int AI16;\n+  A (1, AI16, aligned);\n+  A (0, AI16, aligned (1));\n+  A (0, AI16, aligned (2));\n+  A (0, AI16, aligned (4));\n+  A (0, AI16, aligned (8));\n+  A (1, AI16, aligned (16));\n+  A (0, AI16, aligned (32));\n+\n+  typedef const AI16 CAI16;\n+  A (1, CAI16, aligned);\n+  A (0, CAI16, aligned (1));\n+  A (1, CAI16, aligned (16));\n+\n+  typedef int I;\n+  A (0, I, may_alias);\n+  A (0, AI8, may_alias);\n+\n+  typedef ATTR (may_alias) int MAI;\n+  A (1, MAI, may_alias);\n+\n+  typedef ATTR (aligned (4), may_alias) char A4MAC;\n+  A (0, A4MAC, aligned (0));\n+  A (0, A4MAC, aligned (1));\n+  A (0, A4MAC, aligned (2));\n+  A (1, A4MAC, aligned (4));\n+  A (0, A4MAC, aligned (8));\n+  A (1, A4MAC, may_alias);\n+\n+  typedef ATTR (may_alias, aligned (8)) char A8MAC;\n+  A (1, A8MAC, aligned);\n+  A (0, A8MAC, aligned (0));\n+  A (0, A8MAC, aligned (1));\n+  A (0, A8MAC, aligned (2));\n+  A (0, A8MAC, aligned (4));\n+  A (1, A8MAC, aligned (8));\n+  A (0, A8MAC, aligned (16));\n+  A (1, A8MAC, may_alias);\n+\n+  typedef ATTR (may_alias) const AI8 CMAI8;\n+  A (1, CMAI8, aligned);\n+  A (1, CMAI8, may_alias);\n+  A (0, CMAI8, aligned (4));\n+  A (1, CMAI8, aligned (8));\n+\n+  typedef void Fnull (void*, void*, void*);\n+  A (0, Fnull, nonnull);\n+  A (0, Fnull, nonnull (1));\n+  A (0, Fnull, nonnull (2));\n+  A (0, Fnull, nonnull (3));\n+\n+  typedef ATTR (nonnull) Fnull Fnonnull;\n+  A (1, Fnonnull, nonnull);\n+  A (1, Fnonnull, nonnull (1));\n+  A (1, Fnonnull, nonnull (2));\n+  A (1, Fnonnull, nonnull (3));\n+\n+  typedef ATTR (nonnull (2)) void Fnonnull_2 (void*, void*, void*);\n+  A (0, Fnonnull_2, nonnull);\n+  A (0, Fnonnull_2, nonnull (1));\n+  A (1, Fnonnull_2, nonnull (2));\n+  A (0, Fnonnull_2, nonnull (3));\n+\n+  typedef ATTR (nonnull (1), nonnull (2), nonnull (3))\n+    void Fnonnull_1_2_3 (void*, void*, void*);\n+\n+  /* The following fails because  the built-in doesn't recognize that\n+     a single nonnull with no arguments is the same as one nonnull for\n+     each function parameter.  Disable the testing for now.\n+     A (1, Fnonnull_1_2_3, nonnull);\n+  */\n+  A (1, Fnonnull_1_2_3, nonnull (1));\n+  A (1, Fnonnull_1_2_3, nonnull (2));\n+  A (1, Fnonnull_1_2_3, nonnull (3));\n+\n+  typedef void Freturns (void);\n+  A (0, Fnull, noreturn);\n+  A (0, Freturns, noreturn);\n+\n+  typedef ATTR (warn_if_not_aligned (8)) char CWA8;\n+  A (0, CWA8, warn_if_not_aligned (2));\n+  A (0, CWA8, warn_if_not_aligned (4));\n+  A (1, CWA8, warn_if_not_aligned (8));\n+  A (0, CWA8, warn_if_not_aligned (16));\n+\n+  typedef union OrdinaryUnion OrdUnion;\n+  A (0, OrdUnion, transparent_union);\n+\n+  /* The attribute is ignored on typedefs but GCC fails to diagnose\n+     it (see bug ).  */\n+  typedef union ATTR (transparent_union)\n+    OrdinaryUnion TransUnion;   /* { dg-warning \"\\\\\\[-Wattributes\" \"pr87578\" { xfail { ! { c++ } } } } */\n+  A (0, TransUnion, transparent_union);\n+}"}, {"sha": "237dc72fb9fdeaceae56ba978446fe8ed5f29bb2", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-3.c", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-3.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -0,0 +1,314 @@\n+/* Verify __builtin_has_attribute return value for functions.\n+   { dg-do compile }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" }\n+   { dg-options \"-Wall -Wno-narrowing -Wno-unused-local-typedefs -ftrack-macro-expansion=0\" { target c++ } }  */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+void fnone (void);\n+\n+ATTR (aligned) void faligned (void);\n+ATTR (aligned (1)) void faligned_1 (void);\n+ATTR (aligned (2)) void faligned_2 (void);\n+ATTR (aligned (4)) void faligned_4 (void);\n+ATTR (aligned (8)) void faligned_8 (void);\n+\n+ATTR (alloc_size (1)) void* falloc_size_1 (int, int);\n+ATTR (alloc_size (2)) void* falloc_size_2 (int, int);\n+ATTR (alloc_size (2, 4)) void* falloc_size_2_4 (int, int, int, int);\n+\n+ATTR (alloc_align (1)) void* falloc_align_1 (int, int);\n+ATTR (alloc_align (2)) void* falloc_align_2 (int, int);\n+ATTR (alloc_align (1), alloc_size (2)) void* falloc_align_1_size_2 (int, int);\n+ATTR (alloc_align (2), alloc_size (1)) void* falloc_align_2_size_1 (int, int);\n+\n+#if __cplusplus\n+extern \"C\"\n+#endif\n+ATTR (noreturn) void fnoreturn (void) { __builtin_abort (); }\n+\n+ATTR (alias (\"fnoreturn\")) void falias (void);\n+\n+#define A(expect, sym, attr)\t\t\t\t\t\t\\\n+  typedef int Assert [1 - 2 * !(__builtin_has_attribute (sym, attr) == expect)]\n+\n+void test_aligned (void)\n+{\n+  A (0, fnone, aligned);\n+  A (0, fnone, aligned (0));\n+  A (0, fnone, aligned (1));\n+  A (0, fnone, aligned (2));\n+  A (0, fnone, aligned (4));\n+  A (0, fnone, aligned (8));\n+  A (0, fnone, aligned (16));\n+\n+  A (1, faligned, aligned);\n+  A (0, faligned, aligned (0));\n+  A (0, faligned, aligned (1));\n+  A (0, faligned, aligned (2));\n+\n+  A (1, faligned_1, aligned);\n+  A (0, faligned_1, aligned (0));\n+  A (1, faligned_1, aligned (1));\n+  A (0, faligned_1, aligned (2));\n+  A (0, faligned_1, aligned (4));\n+\n+  A (1, faligned_2, aligned);\n+  A (0, faligned_2, aligned (0));\n+  A (0, faligned_2, aligned (1));\n+  A (1, faligned_2, aligned (2));\n+  A (0, faligned_2, aligned (4));\n+}\n+\n+\n+void test_alloc_align (void)\n+{\n+  A (0, fnone, alloc_align);\n+  A (0, falloc_size_1, alloc_align);\n+  A (1, falloc_align_1, alloc_align);\n+  A (1, falloc_align_2, alloc_align);\n+\n+  A (0, fnone, alloc_align (1));        /* { dg-warning \"\\\\\\[-Wattributes\" } */\n+  A (0, falloc_size_1, alloc_align (1));\n+  A (1, falloc_align_1, alloc_align (1));\n+  A (0, falloc_align_2, alloc_align (1));\n+  A (1, falloc_align_2, alloc_align (2));\n+}\n+\n+\n+void test_alloc_size_malloc (void)\n+{\n+  A (0, fnone, alloc_size);\n+  A (0, fnone, alloc_size (1));         /* { dg-warning \"\\\\\\[-Wattributes\" } */\n+  A (0, fnone, alloc_size (2));         /* { dg-warning \"\\\\\\[-Wattributes\" } */\n+  A (0, falloc_align_1, alloc_size (1));\n+  A (0, falloc_align_2, alloc_size (1));\n+  A (1, falloc_size_1, alloc_size (1));\n+  A (0, falloc_size_1, alloc_size (2));\n+  A (0, falloc_size_2, alloc_size (1));\n+  A (1, falloc_size_2, alloc_size (2));\n+\n+  A (1, falloc_size_2_4, alloc_size);\n+  /* It would probably make more sense to have the built-in return\n+     true only when both alloc_size arguments match, not just one\n+     or the other.  */\n+  A (0, falloc_size_2_4, alloc_size (1));\n+  A (1, falloc_size_2_4, alloc_size (2));\n+  A (0, falloc_size_2_4, alloc_size (3));\n+  A (1, falloc_size_2_4, alloc_size (4));\n+  A (1, falloc_size_2_4, alloc_size (2, 4));\n+\n+  extern ATTR (alloc_size (3))\n+    void* fmalloc_size_3 (int, int, int);\n+\n+  A (1, fmalloc_size_3, alloc_size);\n+  A (0, fmalloc_size_3, alloc_size (1));\n+  A (0, fmalloc_size_3, alloc_size (2));\n+  A (1, fmalloc_size_3, alloc_size (3));\n+  A (0, fmalloc_size_3, malloc);\n+\n+  extern ATTR (malloc)\n+    void* fmalloc_size_3 (int, int, int);\n+\n+  A (1, fmalloc_size_3, alloc_size (3));\n+  A (1, fmalloc_size_3, malloc);\n+}\n+\n+\n+void test_alias (void)\n+{\n+  A (0, fnoreturn, alias);\n+  A (1, falias, alias);\n+  A (1, falias, alias (\"fnoreturn\"));\n+  A (0, falias, alias (\"falias\"));\n+  A (0, falias, alias (\"fnone\"));\n+}\n+\n+\n+void test_cold_hot (void)\n+{\n+  extern ATTR (cold) void fcold (void);\n+  extern ATTR (hot) void fhot (void);\n+\n+  A (0, fnone, cold);\n+  A (0, fnone, hot);\n+\n+  A (1, fcold, cold);\n+  A (0, fcold, hot);\n+\n+  A (0, fhot, cold);\n+  A (1, fhot, hot);\n+}\n+\n+\n+void test_const_leaf_pure (void)\n+{\n+  extern ATTR (const) int fconst (void);\n+  extern ATTR (leaf) int fleaf (void);\n+  extern ATTR (pure) int fpure (void);\n+\n+  A (0, fnone, const);\n+  A (0, fnone, leaf);\n+  A (0, fnone, pure);\n+\n+  A (1, fconst, const);\n+  A (0, fconst, leaf);\n+  A (0, fconst, pure);\n+\n+  A (0, fleaf, const);\n+  A (1, fleaf, leaf);\n+  A (0, fleaf, pure);\n+\n+  A (0, fpure, const);\n+  A (0, fpure, leaf);\n+  A (1, fpure, pure);\n+\n+  extern ATTR (const, leaf) int fconst_leaf (void);\n+\n+  A (1, fconst_leaf, const);\n+  A (1, fconst_leaf, leaf);\n+\n+  extern ATTR (leaf, const) int fleaf_const (void);\n+\n+  A (1, fleaf_const, const);\n+  A (1, fleaf_const, leaf);\n+}\n+\n+\n+void test_ctor_dtor (void)\n+{\n+  extern ATTR (constructor) void fctor (void);\n+  extern ATTR (destructor) void fdtor (void);\n+  extern ATTR (constructor, destructor) void fctor_dtor (void);\n+\n+  A (0, fnone, constructor);\n+  A (0, fnone, destructor);\n+\n+  A (1, fctor, constructor);\n+  A (1, fdtor, destructor);\n+\n+  extern ATTR (constructor) void fctor_dtor (void);\n+  extern ATTR (destructor) void fctor_dtor (void);\n+  extern ATTR (constructor, destructor) void fctor_dtor (void);\n+\n+  A (1, fctor_dtor, constructor);\n+  A (1, fctor_dtor, destructor);\n+\n+  extern ATTR (constructor (123)) void fctor_123 (void);\n+  A (1, fctor_123, constructor);\n+  A (0, fctor_123, destructor);\n+  A (1, fctor_123, constructor (123));\n+  A (0, fctor_123, constructor (124));\n+\n+  extern ATTR (destructor (234)) void fctor_123 (void);\n+  A (1, fctor_123, constructor (123));\n+  A (1, fctor_123, destructor);\n+  A (1, fctor_123, destructor (234));\n+  A (0, fctor_123, destructor (235));\n+}\n+\n+\n+void test_externally_visible (void)\n+{\n+  extern void fexternally_visible (void);\n+\n+  A (0, fexternally_visible, externally_visible);\n+\n+  extern ATTR (externally_visible) void fexternally_visible (void);\n+\n+  A (1, fexternally_visible, externally_visible);\n+}\n+\n+\n+void test_flatten (void)\n+{\n+  extern void fflatten (void);\n+\n+  A (0, fflatten, flatten);\n+\n+  extern ATTR (flatten) void fflatten (void);\n+\n+  A (1, fflatten, flatten);\n+\n+  extern void fflatten (void);\n+\n+  A (1, fflatten, flatten);\n+}\n+\n+\n+ATTR (format (printf, 2, 4)) void\n+fformat_printf_2_3 (int, const char*, int, ...);\n+\n+void test_format (void)\n+{\n+  A (0, fnone, format);\n+  A (0, fnone, format (printf));\n+  A (0, fnone, format (printf, 2));\n+}\n+\n+\n+inline void finline (void) { }\n+inline ATTR (always_inline) void falways_inline (void) { }\n+inline ATTR (always_inline, gnu_inline) void falways_gnu_inline (void) { }\n+ATTR (noinline) void fnoinline () { }\n+\n+void test_inline (void)\n+{\n+  A (0, fnone, always_inline);\n+  A (0, fnone, gnu_inline);\n+  A (0, fnone, noinline);\n+\n+  A (0, finline, always_inline);\n+  A (0, finline, gnu_inline);\n+  A (0, finline, noinline);\n+\n+  A (1, falways_inline, always_inline);\n+  A (0, falways_inline, gnu_inline);\n+  A (0, falways_inline, noinline);\n+\n+  A (1, falways_gnu_inline, always_inline);\n+  A (1, falways_gnu_inline, gnu_inline);\n+  A (0, falways_gnu_inline, noinline);\n+\n+  A (0, fnoinline, always_inline);\n+  A (0, fnoinline, gnu_inline);\n+  A (1, fnoinline, noinline);\n+}\n+\n+\n+ATTR (no_instrument_function) void fno_instrument (void);\n+\n+ATTR (visibility (\"default\")) void fdefault (void);\n+ATTR (visibility (\"hidden\")) void fhidden (void);\n+ATTR (visibility (\"internal\")) void finternal (void);\n+ATTR (visibility (\"protected\")) void fprotected (void);\n+\n+void test_visibility (void)\n+{\n+  A (0, fnone, visibility (\"default\"));\n+  A (0, fnone, visibility (\"hidden\"));\n+  A (0, fnone, visibility (\"internal\"));\n+  A (0, fnone, visibility (\"protected\"));\n+\n+  A (1, fdefault, visibility (\"default\"));\n+  A (0, fdefault, visibility (\"hidden\"));\n+  A (0, fdefault, visibility (\"internal\"));\n+  A (0, fdefault, visibility (\"protected\"));\n+\n+  A (0, fhidden, visibility (\"default\"));\n+  A (1, fhidden, visibility (\"hidden\"));\n+  A (0, fhidden, visibility (\"internal\"));\n+  A (0, fhidden, visibility (\"protected\"));\n+\n+  A (0, finternal, visibility (\"default\"));\n+  A (0, finternal, visibility (\"hidden\"));\n+  A (1, finternal, visibility (\"internal\"));\n+  A (0, finternal, visibility (\"protected\"));\n+\n+  A (0, fprotected, visibility (\"default\"));\n+  A (0, fprotected, visibility (\"hidden\"));\n+  A (0, fprotected, visibility (\"internal\"));\n+  A (1, fprotected, visibility (\"protected\"));\n+}\n+\n+/* { dg-prune-output \"specifies less restrictive attribute\" } */"}, {"sha": "14bdd3f3e0850c870721995ba0db38a88da607ef", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-4.c", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-4.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -0,0 +1,285 @@\n+/* Verify __builtin_has_attribute return value for variables.\n+   { dg-do compile }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" }\n+   { dg-options \"-Wall -Wno-narrowing -Wno-unused -ftrack-macro-expansion=0\" { target c++ } }  */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+#define A(expect, sym, attr)\t\t\t\t\t\t\\\n+  typedef int Assert [1 - 2 * !(__builtin_has_attribute (sym, attr) == expect)]\n+\n+int vnone;\n+\n+ATTR (aligned) char valigned;\n+ATTR (aligned (1)) char valigned_1;\n+ATTR (aligned (2)) char valigned_2;\n+ATTR (aligned (4)) char valigned_4;\n+ATTR (aligned (8)) char valigned_8;\n+\n+void test_aligned (void)\n+{\n+  A (0, vnone, aligned);\n+  A (0, vnone, aligned (0));\n+  A (0, vnone, aligned (1));\n+  A (0, vnone, aligned (2));\n+  A (0, vnone, aligned (4));\n+  A (0, vnone, aligned (8));\n+  A (0, vnone, aligned (16));\n+\n+  A (1, valigned, aligned);\n+  A (0, valigned, aligned (0));\n+  A (0, valigned, aligned (1));\n+  A (0, valigned, aligned (2));\n+\n+  A (1, valigned_1, aligned);\n+  A (0, valigned_1, aligned (0));\n+  A (1, valigned_1, aligned (1));\n+  A (0, valigned_1, aligned (2));\n+  A (0, valigned_1, aligned (4));\n+\n+  A (1, valigned_2, aligned);\n+  A (0, valigned_2, aligned (0));\n+  A (0, valigned_2, aligned (1));\n+  A (1, valigned_2, aligned (2));\n+  A (0, valigned_2, aligned (4));\n+}\n+\n+\n+int vtarget;\n+extern ATTR (alias (\"vtarget\")) int valias;\n+\n+void test_alias (void)\n+{\n+  A (0, vnone, alias);\n+  A (1, valias, alias);\n+  A (1, valias, alias (\"vtarget\"));\n+  A (0, valias, alias (\"vnone\"));\n+}\n+\n+\n+void test_cleanup (void)\n+{\n+  extern void fpv (void*);\n+  extern void fcleanup (void*);\n+\n+  int var;\n+  ATTR (cleanup (fcleanup)) int var_cleanup;\n+  A (0, var, cleanup);\n+  A (1, var_cleanup, cleanup);\n+  A (1, var_cleanup, cleanup (fcleanup));\n+  A (0, var_cleanup, cleanup (fpv));\n+}\n+\n+\n+ATTR (common) int vcommon;\n+ATTR (nocommon) int vnocommon;\n+\n+void test_common (void)\n+{\n+  A (0, vnone, common);\n+  A (0, vnone, nocommon);\n+\n+  A (1, vcommon, common);\n+  A (0, vcommon, nocommon);\n+\n+  A (0, vnocommon, common);\n+  A (1, vnocommon, nocommon);\n+}\n+\n+\n+void test_externally_visible (void)\n+{\n+  extern int vexternally_visible;\n+\n+  A (0, vexternally_visible, externally_visible);\n+\n+  extern ATTR (externally_visible) int vexternally_visible;\n+\n+  A (1, vexternally_visible, externally_visible);\n+}\n+\n+\n+int test_mode (void)\n+{\n+  ATTR (mode (byte)) int i8;\n+  return __builtin_has_attribute (i8, mode);   /* { dg-warning \".mode. attribute not supported in .__builtin_has_attribute.\" } */\n+}\n+\n+\n+void test_nonstring (void)\n+{\n+  char arr[1];\n+  char* ptr = arr;\n+\n+  ATTR (nonstring) char arr_nonstring[1];\n+  ATTR (nonstring) char *ptr_nonstring =  arr_nonstring;\n+\n+  A (0, arr, nonstring);\n+  A (0, ptr, nonstring);\n+\n+  A (1, arr_nonstring, nonstring);\n+  A (1, ptr_nonstring, nonstring);\n+}\n+\n+struct PackedMember\n+{\n+  char c;\n+  short s;\n+  int i;\n+  ATTR (packed) int a[2];\n+} gpak[2];\n+\n+void test_packed (struct PackedMember *p)\n+{\n+  int vunpacked;\n+  ATTR (packed) int vpacked;   /* { dg-warning \".packed. attribute ignored\" } */\n+\n+  A (0, vunpacked, packed);\n+  A (0, vpacked, packed);\n+\n+  int arr_unpacked[2];\n+  ATTR (packed) int arr_packed[2];   /* { dg-warning \".packed. attribute ignored\" } */\n+\n+  A (0, arr_unpacked, packed);\n+  A (0, arr_packed, packed);\n+  A (0, arr_unpacked[0], packed);\n+  A (0, arr_packed[0], packed);\n+\n+  A (0, gpak, packed);\n+  A (0, gpak[0], packed);\n+  A (0, *gpak, packed);\n+  A (0, gpak[0].c, packed);\n+  A (0, gpak[1].s, packed);\n+  A (1, gpak->a, packed);\n+  A (1, (*gpak).a[0], packed);\n+\n+  /* The following fails because in C it's represented as\n+       INDIRECT_REF (POINTER_PLUS (NOP_EXPR (ADDR_EXPR (gpak)), ...))\n+     with no reference to the member.  Avoid testing it.\n+  A (1, *gpak[9].a, packed);  */\n+\n+  A (0, p->c, packed);\n+  A (0, p->s, packed);\n+  A (1, p->a, packed);\n+  A (1, p->a[0], packed);\n+  /* Similar to the comment above.\n+   A (1, *p->a, packed);  */\n+}\n+\n+\n+ATTR (section (\"sectA\")) int var_sectA;\n+ATTR (section (\"sectB\")) int var_sectB;\n+\n+void test_section (void)\n+{\n+  int var = 0;\n+  A (0, var, section);\n+  A (0, var, section (\"sectA\"));\n+\n+  A (1, var_sectA, section);\n+  A (1, var_sectA, section (\"sectA\"));\n+  A (0, var_sectA, section (\"sectB\"));\n+\n+  A (1, var_sectB, section);\n+  A (0, var_sectB, section (\"sectA\"));\n+  A (1, var_sectB, section (\"sectB\"));\n+}\n+\n+\n+void test_vector_size (void)\n+{\n+  char c;\n+  extern int arrx[];\n+  extern int arr1[1];\n+\n+  A (0, c, vector_size);\n+  A (0, c, vector_size (1));\n+  A (0, arrx, vector_size);\n+  A (0, arrx, vector_size (4));\n+  A (0, arr1, vector_size);\n+  A (0, arr1, vector_size (8));\n+\n+  ATTR (vector_size (4)) char cv4;\n+  ATTR (vector_size (16)) int iv16;\n+\n+  A (1, cv4, vector_size);\n+  A (0, cv4, vector_size (1));\n+  A (0, cv4, vector_size (2));\n+  A (1, cv4, vector_size (4));\n+  A (0, cv4, vector_size (8));\n+\n+  A (1, iv16, vector_size);\n+  A (0, iv16, vector_size (1));\n+  A (0, iv16, vector_size (8));\n+  A (1, iv16, vector_size (16));\n+  A (0, iv16, vector_size (32));\n+\n+  ATTR (vector_size (8)) float afv8[4];\n+  A (1, afv8, vector_size);\n+  A (0, afv8, vector_size (1));\n+  A (0, afv8, vector_size (2));\n+  A (0, afv8, vector_size (4));\n+  A (1, afv8, vector_size (8));\n+  A (0, afv8, vector_size (16));\n+}\n+\n+\n+ATTR (visibility (\"default\")) int vdefault;\n+ATTR (visibility (\"hidden\")) int vhidden;\n+ATTR (visibility (\"internal\")) int vinternal;\n+ATTR (visibility (\"protected\")) int vprotected;\n+\n+void test_visibility (void)\n+{\n+  A (0, vnone, visibility (\"default\"));\n+  A (0, vnone, visibility (\"hidden\"));\n+  A (0, vnone, visibility (\"internal\"));\n+  A (0, vnone, visibility (\"protected\"));\n+\n+  A (1, vdefault, visibility (\"default\"));\n+  A (0, vdefault, visibility (\"hidden\"));\n+  A (0, vdefault, visibility (\"internal\"));\n+  A (0, vdefault, visibility (\"protected\"));\n+\n+  A (0, vhidden, visibility (\"default\"));\n+  A (1, vhidden, visibility (\"hidden\"));\n+  A (0, vhidden, visibility (\"internal\"));\n+  A (0, vhidden, visibility (\"protected\"));\n+\n+  A (0, vinternal, visibility (\"default\"));\n+  A (0, vinternal, visibility (\"hidden\"));\n+  A (1, vinternal, visibility (\"internal\"));\n+  A (0, vinternal, visibility (\"protected\"));\n+\n+  A (0, vprotected, visibility (\"default\"));\n+  A (0, vprotected, visibility (\"hidden\"));\n+  A (0, vprotected, visibility (\"internal\"));\n+  A (1, vprotected, visibility (\"protected\"));\n+}\n+\n+\n+int var_init_strong = 123;\n+int var_uninit_strong;\n+static int var_extern_strong;\n+static int var_static_strong;\n+\n+ATTR (weak) int var_init_weak = 234;\n+ATTR (weak) int var_uninit_weak;\n+\n+void test_weak (void)\n+{\n+  int var_local = 0;\n+  static int var_static_local = 0;\n+\n+  A (0, var_init_strong, weak);\n+  A (0, var_uninit_strong, weak);\n+  A (0, var_extern_strong, weak);\n+  A (0, var_static_strong, weak);\n+  A (0, var_local, weak);\n+  A (0, var_static_local, weak);\n+\n+  A (1, var_init_weak, weak);\n+  A (1, var_uninit_weak, weak);\n+}\n+\n+/* { dg-prune-output \"specifies less restrictive attribute\" } */"}, {"sha": "67c792f37df2f3845951fb8d2c5caf5d7e3ab3e6", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -0,0 +1,60 @@\n+/* Verify __builtin_has_attribute error handling.\n+   { dg-do compile }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" }  */\n+\n+#define ATTR(list) __attribute__ (list)\n+\n+void fnone (void);\n+\n+ATTR ((aligned)) void faligned (void);\n+ATTR ((aligned (8))) void faligned_8 (void);\n+\n+#define has_attr(x, attr)   __builtin_has_attribute (x, attr)\n+\n+#define A(expect, sym, attr)\t\t\t\t\t\t\\\n+  typedef int Assert [1 - 2 * !(has_attr (sym, attr) == expect)]\n+\n+\n+int b;\n+\n+/* Exercise syntactically invalid arguments.  */\n+\n+void test_bad_arguments (void)\n+{\n+  b = __builtin_has_attribute ();            /* { dg-error \"expected \\(primary-\\)?expression|expected .,.\" } */\n+  b = __builtin_has_attribute (1);           /* { dg-error \"expected .,.\" } */\n+  b = __builtin_has_attribute (void);        /* { dg-error \"expected .,.\" } */\n+  b = __builtin_has_attribute (foo);         /* { dg-error \".foo. \\(undeclared|was not declared\\)\" } */\n+  /* { dg-error \"expected .,.\" \"missing comma\" { target *-*-* } .-1 } */\n+\n+  /* Verify the implementationm doesn't ICE.  */\n+  b = __builtin_has_attribute (foobar, aligned);  /* { dg-error \".foobar. \\(undeclared|was not declared\\)\" } */\n+\n+  b = __builtin_has_attribute (1, 2, 3);     /* { dg-error \"expected identifier\" } */\n+  b = __builtin_has_attribute (int, 1 + 2);  /* { dg-error \"expected identifier\" } */\n+  b = __builtin_has_attribute (2, \"aligned\"); /* { dg-error \"expected identifier\" } */\n+}\n+\n+/* Exercise syntactically valid arguments applied in invalid ways.  */\n+\n+void test_invalid_arguments (void)\n+{\n+  b = has_attr (fnone, align);        /* { dg-error \"unknown attribute .align.\" } */\n+  b = has_attr (b, aligned__);        /* { dg-error \"unknown attribute .aligned__.\" } */\n+  b = has_attr (fnone, aligned (3));  /* { dg-error \"alignment .3. is not a positive power of 2\" } */\n+\n+  /* Verify the out-of-bounds arguments are diagnosed and the result\n+     of the built-in is false.  */\n+  A (0, fnone, alloc_size (1));       /* { dg-warning \"\\\\\\[-Wattributes]\" } */\n+  A (0, fnone, alloc_size (2));       /* { dg-warning \"\\\\\\[-Wattributes]\" } */\n+\n+  A (0, int, alloc_size (1));         /* { dg-warning \".alloc_size. attribute only applies to function types\" } */\n+\n+  int i = 1;\n+  A (0, i, alloc_size (1));           /* { dg-warning \".alloc_size. attribute only applies to function types\" } */\n+\n+  A (0, faligned_8, aligned (i));     /* { dg-error \"alignment is not an integer constant\" } */\n+\n+  typedef ATTR ((aligned (2))) char CA2;\n+  b = has_attr (CA2[2], aligned);     /* { dg-error \"alignment of array elements is greater than element size\" } */\n+}"}, {"sha": "8c11cf82abe8f34901068aefaa1d98e81601f047", "filename": "gcc/testsuite/gcc.dg/builtin-has-attribute.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-has-attribute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-has-attribute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-has-attribute.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -0,0 +1,45 @@\n+/* Verify that defining a type in __builtin_has_attribute triggers\n+   the expected -Wc++-compat warning and evaluates as expected.\n+   Also verify that the expression in __builtin_has_attribute is\n+   not evaluated.\n+\n+  { dg-do run }\n+  { dg-options \"-O2 -Wall -Wc++-compat\" }  */\n+\n+#define ATTR(list) __attribute__ (list)\n+\n+#define A(expect, sym, attr)\t\t\t\t\t\t\\\n+  typedef int Assert [1 - 2 * !(__builtin_has_attribute (sym, attr) == expect)]\n+\n+int nfails;\n+\n+#define assert(expr)\t\t\t\t\t\t\\\n+  ((expr)\t\t\t\t\t\t\t\\\n+   ? (void)0\t\t\t\t\t\t\t\\\n+   : (__builtin_printf (\"Assertion failed on line %i: %s\\n\",\t\\\n+\t\t\t__LINE__, #expr),\t\t\t\\\n+      ++nfails))\n+\n+A (0, struct A { int i; }, aligned);   /* { dg-warning \"expression is invalid in C\\\\\\+\\\\\\+\" } */\n+A (1, struct ATTR ((aligned)) B { int i; }, aligned);   /* { dg-warning \"expression is invalid in C\\\\\\+\\\\\\+\" } */\n+\n+\n+int f (void)\n+{\n+  __builtin_abort ();\n+}\n+\n+int n = 1;\n+\n+int main (void)\n+{\n+  assert (0 == __builtin_has_attribute (int[n++], aligned));\n+  assert (1 == __builtin_has_attribute (ATTR ((aligned)) int[n++], aligned));\n+  assert (1 == __builtin_has_attribute (ATTR ((aligned)) int[f ()], aligned));\n+  assert (1 == 1);\n+\n+  if (nfails)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "2de1ba3a7f96ef2259d2b269ddf5bd2f8b7e6d36", "filename": "gcc/testsuite/gcc.target/i386/builtin-has-attribute.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbuiltin-has-attribute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f08eb8939735c1e9cbc1ec5cadebe79e935c90/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbuiltin-has-attribute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbuiltin-has-attribute.c?ref=98f08eb8939735c1e9cbc1ec5cadebe79e935c90", "patch": "@@ -0,0 +1,54 @@\n+/* Verify __builtin_has_attribute return value for i386 function attributes.\n+   { dg-do compile }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" }\n+   { dg-options \"-Wall -Wno-narrowing -Wno-unused -ftrack-macro-expansion=0\" { target c++ } }  */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+#define A(expect, sym, attr)\t\t\t\t\t\t\\\n+  typedef int Assert [1 - 2 * !(__builtin_has_attribute (sym, attr) == expect)]\n+\n+void fnone (void);\n+\n+\n+ATTR (interrupt) void finterrupt (void*);\n+ATTR (interrupt, naked) void fnaked_interrupt (void*);\n+\n+A (0, fnone, interrupt);\n+A (1, finterrupt, interrupt);\n+A (1, fnaked_interrupt, interrupt);\n+A (1, fnaked_interrupt, naked);\n+\n+\n+ATTR (naked) void fnaked (void);\n+\n+A (0, fnone, naked);\n+A (1, fnaked, naked);\n+\n+\n+ATTR (no_caller_saved_registers) void fnsr (int);\n+\n+A (0, fnone, no_caller_saved_registers);\n+A (1, fnsr, no_caller_saved_registers);\n+\n+\n+ATTR (target (\"abm\")) void ftarget_abm (void);\n+ATTR (target (\"mmx\")) void ftarget_mmx (void);\n+ATTR (target (\"mmx\"), target (\"sse\")) void ftarget_mmx_sse (void);\n+\n+A (0, fnone, target);\n+A (0, fnone, target (\"abm\"));\n+A (0, fnone, target (\"mmx\"));\n+\n+A (1, ftarget_abm, target);\n+A (0, ftarget_abm, target (\"no-abm\"));\n+A (1, ftarget_abm, target (\"abm\"));\n+\n+A (1, ftarget_mmx, target);\n+A (0, ftarget_mmx, target (\"no-mmx\"));\n+A (1, ftarget_mmx, target (\"mmx\"));\n+\n+A (1, ftarget_mmx_sse, target);\n+A (0, ftarget_mmx_sse, target (\"no-mmx\"));\n+A (1, ftarget_mmx_sse, target (\"mmx\"));\n+A (1, ftarget_mmx_sse, target (\"sse\"));"}]}