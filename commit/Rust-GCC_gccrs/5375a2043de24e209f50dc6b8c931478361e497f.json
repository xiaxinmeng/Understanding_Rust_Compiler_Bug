{"sha": "5375a2043de24e209f50dc6b8c931478361e497f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM3NWEyMDQzZGUyNGUyMDlmNTBkYzZiOGM5MzE0NzgzNjFlNDk3Zg==", "commit": {"author": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-04-12T15:12:59Z"}, "committer": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-04-12T15:12:59Z"}, "message": "(objc_write_reference) added\n\nFrom-SVN: r4089", "tree": {"sha": "510f54b87ff4e0854c532df78c421ba0d48bc621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/510f54b87ff4e0854c532df78c421ba0d48bc621"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5375a2043de24e209f50dc6b8c931478361e497f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5375a2043de24e209f50dc6b8c931478361e497f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5375a2043de24e209f50dc6b8c931478361e497f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5375a2043de24e209f50dc6b8c931478361e497f/comments", "author": null, "committer": null, "parents": [{"sha": "305f8c5bafed302aebd3e9f68bfb1685478c6a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305f8c5bafed302aebd3e9f68bfb1685478c6a86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/305f8c5bafed302aebd3e9f68bfb1685478c6a86"}], "stats": {"total": 141, "additions": 121, "deletions": 20}, "files": [{"sha": "486ff7ee530285da855e08886fc6ee37d0d5944d", "filename": "gcc/objc/archive.c", "status": "modified", "additions": 121, "deletions": 20, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5375a2043de24e209f50dc6b8c931478361e497f/gcc%2Fobjc%2Farchive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5375a2043de24e209f50dc6b8c931478361e497f/gcc%2Fobjc%2Farchive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Farchive.c?ref=5375a2043de24e209f50dc6b8c931478361e497f", "patch": "@@ -59,6 +59,9 @@ objc_write_class (struct objc_typed_stream* stream,\n static const char*\n __objc_skip_type (const char* type);\n \n+static void __objc_finish_write_root_object(struct objc_typed_stream*);\n+static void __objc_finish_read_root_object(struct objc_typed_stream*);\n+\n static __inline__ int\n __objc_code_unsigned_char (unsigned char* buf, unsigned char val)\n {\n@@ -313,11 +316,39 @@ __objc_write_object (struct objc_typed_stream* stream, id object)\n     return objc_write_use_common(stream, 0);\n }\n \n+int \n+objc_write_object_reference (struct objc_typed_stream* stream, id object)\n+{\n+  unsigned int key;\n+  if ((key = (unsigned int)hash_value_for_key (stream->object_table, object)))\n+    return objc_write_use_common (stream, key);\n+\n+  __objc_write_extension (stream, _BX_OBJREF);\n+  return objc_write_unsigned_int (stream, (unsigned int)object);\n+}\n+\n+int \n+objc_write_root_object (struct objc_typed_stream* stream, id object)\n+{\n+  int len;\n+  if (stream->writing_root_p)\n+    __objc_fatal (\"objc_write_root_object called recursively\")\n+  else\n+    {\n+      stream->writing_root_p = 1;\n+      __objc_write_extension (stream, _BX_OBJROOT);\n+      if((len = objc_write_object (stream, object)))\n+\t__objc_finish_write_root_object(stream);\n+      stream->writing_root_p = 0;\n+    }\n+  return len;\n+}\n+\n int \n objc_write_object (struct objc_typed_stream* stream, id object)\n {\n   unsigned int key;\n-  if ((key = (unsigned int)hash_value_for_key (stream->stream_table, object)))\n+  if ((key = (unsigned int)hash_value_for_key (stream->object_table, object)))\n     return objc_write_use_common (stream, key);\n \n   else if (object == nil)\n@@ -326,7 +357,7 @@ objc_write_object (struct objc_typed_stream* stream, id object)\n   else\n     {\n       int length;\n-      hash_add (&stream->stream_table, (void*)key=(unsigned int)object, object);\n+      hash_add (&stream->object_table, (void*)key=(unsigned int)object, object);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn __objc_write_object (stream, object);\n       return length;\n@@ -336,14 +367,10 @@ objc_write_object (struct objc_typed_stream* stream, id object)\n __inline__ int\n __objc_write_class (struct objc_typed_stream* stream, struct objc_class* class)\n {\n-  unsigned char buf = '\\0';\n-  SEL write_sel = sel_get_uid (\"write:\");\n   __objc_write_extension (stream, _BX_CLASS);\n   objc_write_string_atomic(stream, (char*)class->name,\n \t\t\t   strlen(class->name));\n   objc_write_unsigned_int (stream, CLS_GETNUMBER(class));\n-  (*objc_msg_lookup(class, write_sel))(class, write_sel, stream);\n-  return (*stream->write)(stream->physical, &buf, 1);\n }\n \n \n@@ -645,7 +672,7 @@ objc_read_object (struct objc_typed_stream* stream, id* object)\n \n \t  /* register? */\n \t  if (key)\n-\t    hash_add (&stream->stream_table, (void*)key, *object);\n+\t    hash_add (&stream->object_table, (void*)key, *object);\n \n \t  /* send -read: */\n \t  if (__objc_responds_to (*object, read_sel))\n@@ -662,7 +689,23 @@ objc_read_object (struct objc_typed_stream* stream, id* object)\n \t  if (key)\n \t    __objc_fatal(\"cannot register use upcode...\");\n \t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n-\t  (*object) = hash_value_for_key (stream->stream_table, (void*)key);\n+\t  (*object) = hash_value_for_key (stream->object_table, (void*)key);\n+\t}\n+\n+      else if (buf[0] == (_B_EXT | _BX_OBJREF))\t/* a forward reference */\n+\t{\n+\t  struct objc_list* other;\n+\t  len = objc_read_unsigned_int (stream, &key);\n+\t  other = (struct objc_list*)hash_value_for_key (stream->object_refs, (void*)key);\n+\t  hash_add (&stream->object_refs, (void*)key, (void*)list_cons(object, other));\n+\t}\n+\n+      else if (buf[0] == (_B_EXT | _BX_OBJROOT)) /* a root object */\n+\t{\n+\t  if (key)\n+\t    __objc_fatal(\"cannot register root object...\");\n+\t  len = objc_read_object (stream, object);\n+\t  __objc_finish_read_root_object (stream);\n \t}\n \n       else\n@@ -678,7 +721,6 @@ objc_read_class (struct objc_typed_stream* stream, Class** class)\n   int len;\n   if ((len = (*stream->read)(stream->physical, buf, 1)))\n     {\n-      SEL read_sel = sel_get_uid (\"read:\");\n       unsigned int key = 0;\n \n       if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n@@ -701,16 +743,8 @@ objc_read_class (struct objc_typed_stream* stream, Class** class)\n \t  if (key)\n \t    hash_add (&stream->stream_table, (void*)key, *class);\n \n-\t  /* call +read: */\n-\t  (*objc_msg_lookup(*class, read_sel))(*class, read_sel, stream);\n-\n \t  objc_read_unsigned_int(stream, &version);\n \t  hash_add (&stream->class_table, (*class)->name, (void*)version);\n-\n-\t  /* check null-byte */\n-\t  len = (*stream->read)(stream->physical, buf, 1);\n-\t  if (buf[0] != '\\0')\n-\t    __objc_fatal(\"expected null-byte, got opcode %c\", buf[0]);\n \t}\n \n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n@@ -1280,6 +1314,58 @@ __objc_write_typed_stream_signature (TypedStream* stream)\n   (*stream->write)(stream->physical, buffer, strlen(buffer)+1);\n }\n \n+static void __objc_finish_write_root_object(struct objc_typed_stream* stream)\n+{\n+  hash_delete (stream->object_table);\n+  stream->object_table = hash_new(64,\n+\t\t\t\t  (hash_func_type)hash_ptr,\n+\t\t\t\t  (compare_func_type)compare_ptrs);\n+}\n+\n+static void __objc_finish_read_root_object(struct objc_typed_stream* stream)\n+{\n+  node_ptr node;\n+  SEL awake_sel = sel_get_uid (\"awake:\");\n+\n+  /* resolve object forward references */\n+  for (node = hash_next (stream->object_refs, NULL); node;\n+       node = hash_next (stream->object_refs, node))\n+    {\n+      struct objc_list* reflist = node->value;\n+      const void* key = node->key;\n+      id object = hash_value_for_key (stream->object_table, key);\n+      while(reflist)\n+\t{\n+\t  *((id*)reflist->head) = object;\n+\t  reflist = reflist->tail;\n+\t}\n+      list_free (node->value);\n+    }\n+\n+  /* empty object reference table */\n+  hash_delete (stream->object_refs);\n+  stream->object_refs = hash_new(8, (hash_func_type)hash_ptr,\n+\t\t\t\t (compare_func_type)compare_ptrs);\n+  \n+  /* call -awake for all objects read  */\n+  if (awake_sel)\n+    {\n+      for (node = hash_next (stream->object_table, NULL); node;\n+\t   node = hash_next (stream->object_table, node))\n+\t{\n+\t  id object = node->value;\n+\t  if (__objc_responds_to (object, awake_sel))\n+\t    (*objc_msg_lookup(object, awake_sel))(object, awake_sel, stream);\n+\t}\n+    }\n+\n+  /* empty object table */\n+  hash_delete (stream->object_table);\n+  stream->object_table = hash_new(64,\n+\t\t\t\t  (hash_func_type)hash_ptr,\n+\t\t\t\t  (compare_func_type)compare_ptrs);\n+}\n+\n /*\n ** Open the stream PHYSICAL in MODE\n */\n@@ -1296,19 +1382,26 @@ objc_open_typed_stream (FILE* physical, int mode)\n   s->stream_table = hash_new(64,\n \t\t\t     (hash_func_type)hash_ptr,\n \t\t\t     (compare_func_type)compare_ptrs);\n+  s->object_table = hash_new(64,\n+\t\t\t     (hash_func_type)hash_ptr,\n+\t\t\t     (compare_func_type)compare_ptrs);\n   s->eof = (objc_typed_eof_func)__objc_feof;\n   s->flush = (objc_typed_flush_func)fflush;\n+  s->writing_root_p = 0;\n   if (mode == OBJC_READONLY)\n     {\n       s->class_table = hash_new(8, (hash_func_type)hash_string,\n \t\t\t\t(compare_func_type)compare_strings);\n+      s->object_refs = hash_new(8, (hash_func_type)hash_ptr,\n+\t\t\t\t(compare_func_type)compare_ptrs);\n       s->read = (objc_typed_read_func)__objc_fread;\n       s->write = (objc_typed_write_func)__objc_no_write;\n       __objc_read_typed_stream_signature (s);\n     }\n   else if (mode == OBJC_WRITEONLY)\n     {\n       s->class_table = 0;\n+      s->object_refs = 0;\n       s->read = (objc_typed_read_func)__objc_no_read;\n       s->write = (objc_typed_write_func)__objc_fwrite;\n       __objc_write_typed_stream_signature (s);\n@@ -1356,11 +1449,19 @@ objc_open_typed_stream_for_file (const char* file_name, int mode)\n void\n objc_close_typed_stream (TypedStream* stream)\n {\n+  if (stream->mode == OBJC_READONLY)\n+    {\n+      __objc_finish_read_root_object (stream); /* Just in case... */\n+      hash_delete (stream->class_table);\n+      hash_delete (stream->object_refs);\n+    }\n+\n+  hash_delete (stream->stream_table);\n+  hash_delete (stream->object_table);\n+\n   if (stream->type == (OBJC_MANAGED_STREAM | OBJC_FILE_STREAM))\n     fclose ((FILE*)stream->physical);\n-  hash_delete (stream->stream_table);\n-  if (stream->mode == OBJC_READONLY)\n-    hash_delete (stream->class_table);\n+\n   free (stream);\n }\n "}]}