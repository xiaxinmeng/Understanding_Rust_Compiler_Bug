{"sha": "d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg0ZmZjMGE1NmQ4NGEwMjkyOWZhNjdkMmVkYjUyZDRiODFmYWIzNw==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2015-12-14T16:46:54Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2015-12-14T16:46:54Z"}, "message": "libgomp.h (gomp_device_state): New enum.\n\nlibgomp/\n\t* libgomp.h (gomp_device_state): New enum.\n\t(struct gomp_device_descr): Replace is_initialized with state.\n\t(gomp_fini_device): Remove declaration.\n\t* oacc-host.c (host_dispatch): Use state instead of is_initialized.\n\t* oacc-init.c (acc_init_1): Use state instead of is_initialized.\n\t(acc_shutdown_1): Likewise.  Inline gomp_fini_device.\n\t(acc_set_device_type): Use state instead of is_initialized.\n\t(acc_set_device_num): Likewise.\n\t* target.c (resolve_device): Use state instead of is_initialized.\n\tDo not initialize finalized device.\n\t(gomp_map_vars): Do nothing if device is finalized.\n\t(gomp_unmap_vars): Likewise.\n\t(gomp_update): Likewise.\n\t(GOMP_offload_register_ver): Use state instead of is_initialized.\n\t(GOMP_offload_unregister_ver): Likewise.\n\t(gomp_init_device): Likewise.\n\t(gomp_unload_device): Likewise.\n\t(gomp_fini_device): Remove.\n\t(gomp_get_target_fn_addr): Do nothing if device is finalized.\n\t(GOMP_target): Go to host fallback if device is finalized.\n\t(GOMP_target_ext): Likewise.\n\t(gomp_exit_data): Do nothing if device is finalized.\n\t(gomp_target_task_fn): Go to host fallback if device is finalized.\n\t(gomp_target_fini): New static function.\n\t(gomp_target_init): Use state instead of is_initialized.\n\tCall gomp_target_fini at exit.\nliboffloadmic/\n\t* plugin/libgomp-plugin-intelmic.cpp (unregister_main_image): Remove.\n\t(register_main_image): Do not call unregister_main_image at exit.\n\t(GOMP_OFFLOAD_fini_device): Allow for OpenMP.  Unregister main image.\n\nFrom-SVN: r231623", "tree": {"sha": "942a44d60d4c5cc795b051eb83959cabdbc8fe20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/942a44d60d4c5cc795b051eb83959cabdbc8fe20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/comments", "author": null, "committer": null, "parents": [{"sha": "755cd5a907454199a9bff3d6f9f4baa4b298289d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/755cd5a907454199a9bff3d6f9f4baa4b298289d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/755cd5a907454199a9bff3d6f9f4baa4b298289d"}], "stats": {"total": 181, "additions": 132, "deletions": 49}, "files": [{"sha": "87459270a5e159f598099692e0ad4052b64903f2", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "patch": "@@ -1,3 +1,32 @@\n+2015-12-14  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* libgomp.h (gomp_device_state): New enum.\n+\t(struct gomp_device_descr): Replace is_initialized with state.\n+\t(gomp_fini_device): Remove declaration.\n+\t* oacc-host.c (host_dispatch): Use state instead of is_initialized.\n+\t* oacc-init.c (acc_init_1): Use state instead of is_initialized.\n+\t(acc_shutdown_1): Likewise.  Inline gomp_fini_device.\n+\t(acc_set_device_type): Use state instead of is_initialized.\n+\t(acc_set_device_num): Likewise.\n+\t* target.c (resolve_device): Use state instead of is_initialized.\n+\tDo not initialize finalized device.\n+\t(gomp_map_vars): Do nothing if device is finalized.\n+\t(gomp_unmap_vars): Likewise.\n+\t(gomp_update): Likewise.\n+\t(GOMP_offload_register_ver): Use state instead of is_initialized.\n+\t(GOMP_offload_unregister_ver): Likewise.\n+\t(gomp_init_device): Likewise.\n+\t(gomp_unload_device): Likewise.\n+\t(gomp_fini_device): Remove.\n+\t(gomp_get_target_fn_addr): Do nothing if device is finalized.\n+\t(GOMP_target): Go to host fallback if device is finalized.\n+\t(GOMP_target_ext): Likewise.\n+\t(gomp_exit_data): Do nothing if device is finalized.\n+\t(gomp_target_task_fn): Go to host fallback if device is finalized.\n+\t(gomp_target_fini): New static function.\n+\t(gomp_target_init): Use state instead of is_initialized.\n+\tCall gomp_target_fini at exit.\n+\n 2015-12-09  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/68716"}, {"sha": "9d9949ff16a1f58479da3ad2333ca0c8e1c6cdcd", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "patch": "@@ -888,6 +888,14 @@ typedef struct acc_dispatch_t\n   } cuda;\n } acc_dispatch_t;\n \n+/* Various state of the accelerator device.  */\n+enum gomp_device_state\n+{\n+  GOMP_DEVICE_UNINITIALIZED,\n+  GOMP_DEVICE_INITIALIZED,\n+  GOMP_DEVICE_FINALIZED\n+};\n+\n /* This structure describes accelerator device.\n    It contains name of the corresponding libgomp plugin, function handlers for\n    interaction with the device, ID-number of the device, and information about\n@@ -933,8 +941,10 @@ struct gomp_device_descr\n   /* Mutex for the mutable data.  */\n   gomp_mutex_t lock;\n \n-  /* Set to true when device is initialized.  */\n-  bool is_initialized;\n+  /* Current state of the device.  OpenACC allows to move from INITIALIZED state\n+     back to UNINITIALIZED state.  OpenMP allows only to move from INITIALIZED\n+     to FINALIZED state (at program shutdown).  */\n+  enum gomp_device_state state;\n \n   /* OpenACC-specific data and functions.  */\n   /* This is mutable because of its mutable data_environ and target_data\n@@ -962,7 +972,6 @@ extern void gomp_copy_from_async (struct target_mem_desc *);\n extern void gomp_unmap_vars (struct target_mem_desc *, bool);\n extern void gomp_init_device (struct gomp_device_descr *);\n extern void gomp_free_memmap (struct splay_tree_s *);\n-extern void gomp_fini_device (struct gomp_device_descr *);\n extern void gomp_unload_device (struct gomp_device_descr *);\n \n /* work.c */"}, {"sha": "d289b38941d3e2de736d45575bb45f2140b38a02", "filename": "libgomp/oacc-host.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "patch": "@@ -222,7 +222,7 @@ static struct gomp_device_descr host_dispatch =\n \n     .mem_map = { NULL },\n     /* .lock initilized in goacc_host_init.  */\n-    .is_initialized = false,\n+    .state = GOMP_DEVICE_UNINITIALIZED,\n \n     .openacc = {\n       .data_environ = NULL,"}, {"sha": "c4f7b6742fdb7f1b3043e299facc10cb1c178cbd", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "patch": "@@ -225,7 +225,7 @@ acc_init_1 (acc_device_t d)\n   acc_dev = &base_dev[goacc_device_num];\n \n   gomp_mutex_lock (&acc_dev->lock);\n-  if (acc_dev->is_initialized)\n+  if (acc_dev->state == GOMP_DEVICE_INITIALIZED)\n     {\n       gomp_mutex_unlock (&acc_dev->lock);\n       gomp_fatal (\"device already active\");\n@@ -306,10 +306,11 @@ acc_shutdown_1 (acc_device_t d)\n     {\n       struct gomp_device_descr *acc_dev = &base_dev[i];\n       gomp_mutex_lock (&acc_dev->lock);\n-      if (acc_dev->is_initialized)\n+      if (acc_dev->state == GOMP_DEVICE_INITIALIZED)\n         {\n \t  devices_active = true;\n-\t  gomp_fini_device (acc_dev);\n+\t  acc_dev->fini_device_func (acc_dev->target_id);\n+\t  acc_dev->state = GOMP_DEVICE_UNINITIALIZED;\n \t}\n       gomp_mutex_unlock (&acc_dev->lock);\n     }\n@@ -506,7 +507,7 @@ acc_set_device_type (acc_device_t d)\n   acc_dev = &base_dev[goacc_device_num];\n \n   gomp_mutex_lock (&acc_dev->lock);\n-  if (!acc_dev->is_initialized)\n+  if (acc_dev->state == GOMP_DEVICE_UNINITIALIZED)\n     gomp_init_device (acc_dev);\n   gomp_mutex_unlock (&acc_dev->lock);\n \n@@ -608,7 +609,7 @@ acc_set_device_num (int ord, acc_device_t d)\n       acc_dev = &base_dev[ord];\n \n       gomp_mutex_lock (&acc_dev->lock);\n-      if (!acc_dev->is_initialized)\n+      if (acc_dev->state == GOMP_DEVICE_UNINITIALIZED)\n         gomp_init_device (acc_dev);\n       gomp_mutex_unlock (&acc_dev->lock);\n "}, {"sha": "932b1761f4e4feeb91797fe16ab34e8ed1066c2b", "filename": "libgomp/target.c", "status": "modified", "additions": 75, "deletions": 26, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "patch": "@@ -118,8 +118,13 @@ resolve_device (int device_id)\n     return NULL;\n \n   gomp_mutex_lock (&devices[device_id].lock);\n-  if (!devices[device_id].is_initialized)\n+  if (devices[device_id].state == GOMP_DEVICE_UNINITIALIZED)\n     gomp_init_device (&devices[device_id]);\n+  else if (devices[device_id].state == GOMP_DEVICE_FINALIZED)\n+    {\n+      gomp_mutex_unlock (&devices[device_id].lock);\n+      return NULL;\n+    }\n   gomp_mutex_unlock (&devices[device_id].lock);\n \n   return &devices[device_id];\n@@ -356,6 +361,12 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n     }\n \n   gomp_mutex_lock (&devicep->lock);\n+  if (devicep->state == GOMP_DEVICE_FINALIZED)\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      free (tgt);\n+      return NULL;\n+    }\n \n   for (i = 0; i < mapnum; i++)\n     {\n@@ -834,6 +845,13 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n     }\n \n   gomp_mutex_lock (&devicep->lock);\n+  if (devicep->state == GOMP_DEVICE_FINALIZED)\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      free (tgt->array);\n+      free (tgt);\n+      return;\n+    }\n \n   size_t i;\n   for (i = 0; i < tgt->list_count; i++)\n@@ -896,6 +914,12 @@ gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n     return;\n \n   gomp_mutex_lock (&devicep->lock);\n+  if (devicep->state == GOMP_DEVICE_FINALIZED)\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      return;\n+    }\n+\n   for (i = 0; i < mapnum; i++)\n     if (sizes[i])\n       {\n@@ -1106,7 +1130,8 @@ GOMP_offload_register_ver (unsigned version, const void *host_table,\n     {\n       struct gomp_device_descr *devicep = &devices[i];\n       gomp_mutex_lock (&devicep->lock);\n-      if (devicep->type == target_type && devicep->is_initialized)\n+      if (devicep->type == target_type\n+\t  && devicep->state == GOMP_DEVICE_INITIALIZED)\n \tgomp_load_image_to_device (devicep, version,\n \t\t\t\t   host_table, target_data, true);\n       gomp_mutex_unlock (&devicep->lock);\n@@ -1150,7 +1175,8 @@ GOMP_offload_unregister_ver (unsigned version, const void *host_table,\n     {\n       struct gomp_device_descr *devicep = &devices[i];\n       gomp_mutex_lock (&devicep->lock);\n-      if (devicep->type == target_type && devicep->is_initialized)\n+      if (devicep->type == target_type\n+\t  && devicep->state == GOMP_DEVICE_INITIALIZED)\n \tgomp_unload_image_from_device (devicep, version,\n \t\t\t\t       host_table, target_data);\n       gomp_mutex_unlock (&devicep->lock);\n@@ -1193,13 +1219,13 @@ gomp_init_device (struct gomp_device_descr *devicep)\n \t\t\t\t   false);\n     }\n \n-  devicep->is_initialized = true;\n+  devicep->state = GOMP_DEVICE_INITIALIZED;\n }\n \n attribute_hidden void\n gomp_unload_device (struct gomp_device_descr *devicep)\n {\n-  if (devicep->is_initialized)\n+  if (devicep->state == GOMP_DEVICE_INITIALIZED)\n     {\n       unsigned i;\n       \n@@ -1231,18 +1257,6 @@ gomp_free_memmap (struct splay_tree_s *mem_map)\n     }\n }\n \n-/* This function de-initializes the target device, specified by DEVICEP.\n-   DEVICEP must be locked on entry, and remains locked on return.  */\n-\n-attribute_hidden void\n-gomp_fini_device (struct gomp_device_descr *devicep)\n-{\n-  if (devicep->is_initialized)\n-    devicep->fini_device_func (devicep->target_id);\n-\n-  devicep->is_initialized = false;\n-}\n-\n /* Host fallback for GOMP_target{,_ext} routines.  */\n \n static void\n@@ -1310,6 +1324,12 @@ gomp_get_target_fn_addr (struct gomp_device_descr *devicep,\n   else\n     {\n       gomp_mutex_lock (&devicep->lock);\n+      if (devicep->state == GOMP_DEVICE_FINALIZED)\n+\t{\n+\t  gomp_mutex_unlock (&devicep->lock);\n+\t  return NULL;\n+\t}\n+\n       struct splay_tree_key_s k;\n       k.host_start = (uintptr_t) host_fn;\n       k.host_end = k.host_start + 1;\n@@ -1339,12 +1359,12 @@ GOMP_target (int device, void (*fn) (void *), const void *unused,\n {\n   struct gomp_device_descr *devicep = resolve_device (device);\n \n+  void *fn_addr;\n   if (devicep == NULL\n-      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n+      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n+      || !(fn_addr = gomp_get_target_fn_addr (devicep, fn)))\n     return gomp_target_fallback (fn, hostaddrs);\n \n-  void *fn_addr = gomp_get_target_fn_addr (devicep, fn);\n-\n   struct target_mem_desc *tgt_vars\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, false,\n \t\t     GOMP_MAP_VARS_TARGET);\n@@ -1430,15 +1450,15 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n \tgomp_task_maybe_wait_for_dependencies (depend);\n     }\n \n+  void *fn_addr;\n   if (devicep == NULL\n-      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n+      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n+      || !(fn_addr = gomp_get_target_fn_addr (devicep, fn)))\n     {\n       gomp_target_fallback_firstprivate (fn, mapnum, hostaddrs, sizes, kinds);\n       return;\n     }\n \n-  void *fn_addr = gomp_get_target_fn_addr (devicep, fn);\n-\n   struct target_mem_desc *tgt_vars\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, true,\n \t\t     GOMP_MAP_VARS_TARGET);\n@@ -1593,6 +1613,12 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n   const int typemask = 0xff;\n   size_t i;\n   gomp_mutex_lock (&devicep->lock);\n+  if (devicep->state == GOMP_DEVICE_FINALIZED)\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      return;\n+    }\n+\n   for (i = 0; i < mapnum; i++)\n     {\n       struct splay_tree_key_s cur_node;\n@@ -1729,8 +1755,10 @@ gomp_target_task_fn (void *data)\n \n   if (ttask->fn != NULL)\n     {\n+      void *fn_addr;\n       if (devicep == NULL\n-\t  || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n+\t  || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n+\t  || !(fn_addr = gomp_get_target_fn_addr (devicep, ttask->fn)))\n \t{\n \t  ttask->state = GOMP_TARGET_TASK_FALLBACK;\n \t  gomp_target_fallback_firstprivate (ttask->fn, ttask->mapnum,\n@@ -1745,7 +1773,6 @@ gomp_target_task_fn (void *data)\n \t  return false;\n \t}\n \n-      void *fn_addr = gomp_get_target_fn_addr (devicep, ttask->fn);\n       ttask->tgt\n \t= gomp_map_vars (devicep, ttask->mapnum, ttask->hostaddrs, NULL,\n \t\t\t ttask->sizes, ttask->kinds, true,\n@@ -2282,6 +2309,25 @@ gomp_load_plugin_for_device (struct gomp_device_descr *device,\n   return 0;\n }\n \n+/* This function finalizes all initialized devices.  */\n+\n+static void\n+gomp_target_fini (void)\n+{\n+  int i;\n+  for (i = 0; i < num_devices; i++)\n+    {\n+      struct gomp_device_descr *devicep = &devices[i];\n+      gomp_mutex_lock (&devicep->lock);\n+      if (devicep->state == GOMP_DEVICE_INITIALIZED)\n+\t{\n+\t  devicep->fini_device_func (devicep->target_id);\n+\t  devicep->state = GOMP_DEVICE_FINALIZED;\n+\t}\n+      gomp_mutex_unlock (&devicep->lock);\n+    }\n+}\n+\n /* This function initializes the runtime needed for offloading.\n    It parses the list of offload targets and tries to load the plugins for\n    these targets.  On return, the variables NUM_DEVICES and NUM_DEVICES_OPENMP\n@@ -2341,7 +2387,7 @@ gomp_target_init (void)\n \t\t/* current_device.capabilities has already been set.  */\n \t\tcurrent_device.type = current_device.get_type_func ();\n \t\tcurrent_device.mem_map.root = NULL;\n-\t\tcurrent_device.is_initialized = false;\n+\t\tcurrent_device.state = GOMP_DEVICE_UNINITIALIZED;\n \t\tcurrent_device.openacc.data_environ = NULL;\n \t\tfor (i = 0; i < new_num_devices; i++)\n \t\t  {\n@@ -2387,6 +2433,9 @@ gomp_target_init (void)\n       if (devices[i].capabilities & GOMP_OFFLOAD_CAP_OPENACC_200)\n \tgoacc_register (&devices[i]);\n     }\n+\n+  if (atexit (gomp_target_fini) != 0)\n+    gomp_fatal (\"atexit failed\");\n }\n \n #else /* PLUGIN_SUPPORT */"}, {"sha": "c6fd49fbf70e3d957a584fe524d2eb24fb2f14c2", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "patch": "@@ -1,3 +1,9 @@\n+2015-12-14  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* plugin/libgomp-plugin-intelmic.cpp (unregister_main_image): Remove.\n+\t(register_main_image): Do not call unregister_main_image at exit.\n+\t(GOMP_OFFLOAD_fini_device): Allow for OpenMP.  Unregister main image.\n+\n 2015-11-19  Ilya Verbin  <ilya.verbin@intel.com>\n \n \t* plugin/libgomp-plugin-intelmic.cpp (struct TargetImageDesc): New."}, {"sha": "68f7b2c898b1522b4c1affb11d2647d0ecb86004", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84ffc0a56d84a02929fa67d2edb52d4b81fab37/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=d84ffc0a56d84a02929fa67d2edb52d4b81fab37", "patch": "@@ -230,12 +230,6 @@ offload (const char *file, uint64_t line, int device, const char *name,\n     }\n }\n \n-static void\n-unregister_main_image ()\n-{\n-  __offload_unregister_image (&main_target_image);\n-}\n-\n static void\n register_main_image ()\n {\n@@ -246,12 +240,6 @@ register_main_image ()\n   /* liboffloadmic will call GOMP_PLUGIN_target_task_completion when\n      asynchronous task on target is completed.  */\n   __offload_register_task_callback (GOMP_PLUGIN_target_task_completion);\n-\n-  if (atexit (unregister_main_image) != 0)\n-    {\n-      fprintf (stderr, \"%s: atexit failed\\n\", __FILE__);\n-      exit (1);\n-    }\n }\n \n /* liboffloadmic loads and runs offload_target_main on all available devices\n@@ -269,8 +257,9 @@ extern \"C\" void\n GOMP_OFFLOAD_fini_device (int device)\n {\n   TRACE (\"(device = %d)\", device);\n-  /* Unreachable for GOMP_OFFLOAD_CAP_OPENMP_400.  */\n-  abort ();\n+\n+  /* liboffloadmic will finalize target processes on all available devices.  */\n+  __offload_unregister_image (&main_target_image);\n }\n \n static void"}]}