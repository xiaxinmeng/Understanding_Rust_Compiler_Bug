{"sha": "3517d3a0870e7081d4ded0fa4cc590c602713a8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUxN2QzYTA4NzBlNzA4MWQ0ZGVkMGZhNGNjNTkwYzYwMjcxM2E4Yw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-10-06T15:34:26Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-10-06T15:34:26Z"}, "message": "re PR middle-end/37535 (gcc/libgcc2.c:404: internal compiler error: Floating point exception)\n\n2008-10-06  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR middle-end/37535\n\n\t* ira-lives.c (mark_reg_live, mark_reg_dead): New functions.\n\t(mark_ref_live, mark_ref_dead): Use them.\n\t(def_conflicts_with_inputs_p): Remove.\n\t(mark_early_clobbers): New function.\n\t(process_bb_node_lives): Call preprocess_constraints and\n\tmark_early_clobbers.\n\n\t* doc/rtx.texi (clobber): Change how RA deals with clobbers.\n\nFrom-SVN: r140906", "tree": {"sha": "6208c8b2d1a94f1fa3c249de54b5c7b56339df26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6208c8b2d1a94f1fa3c249de54b5c7b56339df26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3517d3a0870e7081d4ded0fa4cc590c602713a8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3517d3a0870e7081d4ded0fa4cc590c602713a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3517d3a0870e7081d4ded0fa4cc590c602713a8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3517d3a0870e7081d4ded0fa4cc590c602713a8c/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e84319a3ffa34ad21ba267ec06d2dfc6fa180bc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e84319a3ffa34ad21ba267ec06d2dfc6fa180bc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e84319a3ffa34ad21ba267ec06d2dfc6fa180bc7"}], "stats": {"total": 163, "additions": 122, "deletions": 41}, "files": [{"sha": "a873fd66cbff760feadba040e566b5a6568e108c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3517d3a0870e7081d4ded0fa4cc590c602713a8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3517d3a0870e7081d4ded0fa4cc590c602713a8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3517d3a0870e7081d4ded0fa4cc590c602713a8c", "patch": "@@ -1,3 +1,16 @@\n+2008-10-06  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR middle-end/37535\n+\n+\t* ira-lives.c (mark_reg_live, mark_reg_dead): New functions.\n+\t(mark_ref_live, mark_ref_dead): Use them.\n+\t(def_conflicts_with_inputs_p): Remove.\n+\t(mark_early_clobbers): New function.\n+\t(process_bb_node_lives): Call preprocess_constraints and\n+\tmark_early_clobbers.\n+\n+\t* doc/rtx.texi (clobber): Change how RA deals with clobbers.\n+\n 2008-10-06  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \t* config/i386/mingw32.h (REAL_LIBGCC_SPEC): Add thread cleanup"}, {"sha": "a12de2152bba1235dc23572b482a1915eb15eaa8", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3517d3a0870e7081d4ded0fa4cc590c602713a8c/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3517d3a0870e7081d4ded0fa4cc590c602713a8c/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=3517d3a0870e7081d4ded0fa4cc590c602713a8c", "patch": "@@ -2930,9 +2930,11 @@ constituent instructions might not.\n When a @code{clobber} expression for a register appears inside a\n @code{parallel} with other side effects, the register allocator\n guarantees that the register is unoccupied both before and after that\n-insn.  However, the reload phase may allocate a register used for one of\n-the inputs unless the @samp{&} constraint is specified for the selected\n-alternative (@pxref{Modifiers}).  You can clobber either a specific hard\n+insn if it is a hard register clobber or the @samp{&} constraint\n+is specified for at least one alternative (@pxref{Modifiers}) of the\n+clobber.  However, the reload phase may allocate a register used for\n+one of the inputs unless the @samp{&} constraint is specified for the\n+selected alternative.  You can clobber either a specific hard\n register, a pseudo register, or a @code{scratch} expression; in the\n latter two cases, GCC will allocate a hard register that is available\n there for use as a temporary."}, {"sha": "c1b2bdd6548e4724aae8bda64b87628ffceceefd", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 104, "deletions": 38, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3517d3a0870e7081d4ded0fa4cc590c602713a8c/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3517d3a0870e7081d4ded0fa4cc590c602713a8c/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=3517d3a0870e7081d4ded0fa4cc590c602713a8c", "patch": "@@ -209,20 +209,15 @@ clear_allocno_live (ira_allocno_t a)\n   sparseset_clear_bit (allocnos_live, ALLOCNO_NUM (a));\n }\n \n-/* Mark the register referenced by use or def REF as live\n-   Store a 1 in hard_regs_live or allocnos_live for this register or\n-   the corresponding allocno, record how many consecutive hardware\n-   registers it actually needs.  */\n-\n+/* Mark the register REG as live.  Store a 1 in hard_regs_live or\n+   allocnos_live for this register or the corresponding allocno,\n+   record how many consecutive hardware registers it actually\n+   needs.  */\n static void\n-mark_ref_live (struct df_ref *ref)\n+mark_reg_live (rtx reg)\n {\n-  rtx reg;\n   int regno;\n \n-  reg = DF_REF_REG (ref);\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n   gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n \n@@ -269,32 +264,25 @@ mark_ref_live (struct df_ref *ref)\n     }\n }\n \n-/* Return true if the definition described by DEF conflicts with the\n-   instruction's inputs.  */\n-static bool\n-def_conflicts_with_inputs_p (struct df_ref *def)\n+/* Mark the register referenced by use or def REF as live.  */\n+static void\n+mark_ref_live (struct df_ref *ref)\n {\n-  /* Conservatively assume that the condition is true for all clobbers.  */\n-  return DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER);\n+  rtx reg;\n+\n+  reg = DF_REF_REG (ref);\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  mark_reg_live (reg);\n }\n \n-/* Mark the register referenced by definition DEF as dead, if the\n-   definition is a total one.  Store a 0 in hard_regs_live or\n+/* Mark the register REG as dead.  Store a 0 in hard_regs_live or\n    allocnos_live for the register.  */\n static void\n-mark_ref_dead (struct df_ref *def)\n+mark_reg_dead (rtx reg)\n {\n-  unsigned int i;\n-  rtx reg;\n   int regno;\n \n-  if (DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL)\n-      || DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n-    return;\n-\n-  reg = DF_REF_REG (def);\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n   gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n \n@@ -312,6 +300,7 @@ mark_ref_dead (struct df_ref *def)\n     }\n   else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n+      unsigned int i;\n       int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n       enum reg_class cover_class;\n \n@@ -343,6 +332,80 @@ mark_ref_dead (struct df_ref *def)\n     }\n }\n \n+/* Mark the register referenced by definition DEF as dead, if the\n+   definition is a total one.  */\n+static void\n+mark_ref_dead (struct df_ref *def)\n+{\n+  rtx reg;\n+\n+  if (DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL)\n+      || DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n+    return;\n+\n+  reg = DF_REF_REG (def);\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  mark_reg_dead (reg);\n+}\n+\n+/* Mark early clobber registers of the current INSN as live (if\n+   LIVE_P) or dead.  Return true if there are such registers.  */\n+static bool\n+mark_early_clobbers (rtx insn, bool live_p)\n+{\n+  int alt;\n+  int def;\n+  struct df_ref **def_rec;\n+  bool set_p = false;\n+\n+  for (def = 0; def < recog_data.n_operands; def++)\n+    {\n+      rtx dreg = recog_data.operand[def];\n+      \n+      if (GET_CODE (dreg) == SUBREG)\n+\tdreg = SUBREG_REG (dreg);\n+      if (! REG_P (dreg))\n+\tcontinue;\n+\n+      for (alt = 0; alt < recog_data.n_alternatives; alt++)\n+\tif ((recog_op_alt[def][alt].earlyclobber)\n+\t    && (recog_op_alt[def][alt].cl != NO_REGS))\n+\t  break;\n+\n+      if (alt >= recog_data.n_alternatives)\n+\tcontinue;\n+\n+      if (live_p)\n+\tmark_reg_live (dreg);\n+      else\n+\tmark_reg_dead (dreg);\n+      set_p = true;\n+    }\n+\n+  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+    if (DF_REF_FLAGS_IS_SET (*def_rec, DF_REF_MUST_CLOBBER))\n+      {\n+\trtx dreg = DF_REF_REG (*def_rec);\n+\t\n+\tif (GET_CODE (dreg) == SUBREG)\n+\t  dreg = SUBREG_REG (dreg);\n+\tif (! REG_P (dreg) || REGNO (dreg) >= FIRST_PSEUDO_REGISTER)\n+\t  continue;\n+\n+\t/* Hard register clobbers are believed to be early clobber\n+\t   because there is no way to say that non-operand hard\n+\t   register clobbers are not early ones.  */ \n+\tif (live_p)\n+\t  mark_ref_live (*def_rec);\n+\telse\n+\t  mark_ref_dead (*def_rec);\n+\tset_p = true;\n+      }\n+\n+  return set_p;\n+}\n+\n /* Checks that CONSTRAINTS permits to use only one hard register.  If\n    it is so, the function returns the class of the hard register.\n    Otherwise it returns NO_REGS.  */\n@@ -580,6 +643,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n   bitmap_iterator bi;\n   bitmap reg_live_out;\n   unsigned int px;\n+  bool set_p;\n \n   bb = loop_tree_node->bb;\n   if (bb != NULL)\n@@ -698,6 +762,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t      }\n \t  \n \t  extract_insn (insn);\n+\t  preprocess_constraints ();\n \t  process_single_reg_class_operands (false, freq);\n \t  \n \t  /* See which defined values die here.  */\n@@ -733,19 +798,20 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n \t    mark_ref_live (*use_rec);\n \n-\t  /* If any defined values conflict with the inputs, mark those\n-\t     defined values as live.  */\n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    if (def_conflicts_with_inputs_p (*def_rec))\n-\t      mark_ref_live (*def_rec);\n+\t  set_p = mark_early_clobbers (insn, true);\n \n \t  process_single_reg_class_operands (true, freq);\n \t  \n-\t  /* See which of the defined values we marked as live are dead\n-\t     before the instruction.  */\n-\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t    if (def_conflicts_with_inputs_p (*def_rec))\n-\t      mark_ref_dead (*def_rec);\n+\t  if (set_p)\n+\t    {\n+\t      mark_early_clobbers (insn, false);\n+\n+\t      /* Mark each used value as live again.  For example, a\n+\t\t hard register can be in clobber and in an insn\n+\t\t input.  */\n+\t      for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t\tmark_ref_live (*use_rec);\n+\t    }\n \n \t  curr_point++;\n \t}"}]}