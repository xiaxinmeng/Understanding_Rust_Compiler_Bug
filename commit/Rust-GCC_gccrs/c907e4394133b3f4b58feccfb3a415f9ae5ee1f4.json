{"sha": "c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkwN2U0Mzk0MTMzYjNmNGI1OGZlY2NmYjNhNDE1ZjlhZTVlZTFmNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-01-05T05:40:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-01-19T00:40:06Z"}, "message": "compiler: read embedcfg files, parse go:embed directives\n\nThis change reads go:embed directives and attaches them to variables.\nWe still don't do anything with the directives.\n\nThis change also reads the file passed in the -fgo-embedcfg option.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/281533", "tree": {"sha": "a2a082a30790441b19730f20339b73312cf719f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2a082a30790441b19730f20339b73312cf719f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef1f8ee67d41689ddd3b6babf8fab6b4dec60c10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1f8ee67d41689ddd3b6babf8fab6b4dec60c10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef1f8ee67d41689ddd3b6babf8fab6b4dec60c10"}], "stats": {"total": 267, "additions": 234, "deletions": 33}, "files": [{"sha": "fb4ec30913e6151cc3410a19ec4a1e87b8b4e724", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "patch": "@@ -1,4 +1,4 @@\n-22ce16e28220d446c4557f47129024e3561f3d77\n+9e78cef2b689aa586dbf677fb47ea3f08f197b91\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "7ee867462120f197cbeb85354aea6987ca0b68d0", "filename": "gcc/go/gofrontend/embed.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fembed.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fembed.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fembed.cc?ref=c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "patch": "@@ -626,3 +626,18 @@ Embedcfg_reader::error(const char* msg)\n \t\t\"%<-fgo-embedcfg%>: %s: %s\",\n \t\tthis->filename_, msg);\n }\n+\n+// Return whether the current file imports \"embed\".\n+\n+bool\n+Gogo::is_embed_imported() const\n+{\n+  Packages::const_iterator p = this->packages_.find(\"embed\");\n+  if (p == this->packages_.end())\n+    return false;\n+\n+  // We track current file imports in the package aliases, where a\n+  // typical import will just list the package name in aliases.  So\n+  // the package has been imported if there is at least one alias.\n+  return !p->second->aliases().empty();\n+}"}, {"sha": "404cb124549619f3b540beff3897fa8195be0490", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "patch": "@@ -40,6 +40,8 @@ go_create_gogo(const struct go_create_gogo_args* args)\n     ::gogo->set_compiling_runtime(args->compiling_runtime);\n   if (args->c_header != NULL)\n     ::gogo->set_c_header(args->c_header);\n+  if (args->embedcfg != NULL)\n+    ::gogo->read_embedcfg(args->embedcfg);\n   ::gogo->set_debug_escape_level(args->debug_escape_level);\n   if (args->debug_escape_hash != NULL)\n     ::gogo->set_debug_escape_hash(args->debug_escape_hash);"}, {"sha": "4c795a2b49527d2819c6a514b557e7a6133ef478", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "patch": "@@ -7456,8 +7456,8 @@ Variable::Variable(Type* type, Expression* init, bool is_global,\n \t\t   bool is_parameter, bool is_receiver,\n \t\t   Location location)\n   : type_(type), init_(init), preinit_(NULL), location_(location),\n-    backend_(NULL), is_global_(is_global), is_parameter_(is_parameter),\n-    is_closure_(false), is_receiver_(is_receiver),\n+    embeds_(NULL), backend_(NULL), is_global_(is_global),\n+    is_parameter_(is_parameter), is_closure_(false), is_receiver_(is_receiver),\n     is_varargs_parameter_(false), is_global_sink_(false), is_used_(false),\n     is_address_taken_(false), is_non_escaping_address_taken_(false),\n     seen_(false), init_is_lowered_(false), init_is_flattened_(false),"}, {"sha": "891ef697ffe433c138f8859a53c5818f7ab266f7", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "patch": "@@ -397,6 +397,10 @@ class Gogo\n   void\n   read_embedcfg(const char* filename);\n \n+  // Return whether the current file imports \"embed\".\n+  bool\n+  is_embed_imported() const;\n+\n   // Return whether to check for division by zero in binary operations.\n   bool\n   check_divide_by_zero() const\n@@ -2276,6 +2280,16 @@ class Variable\n     this->is_referenced_by_inline_ = true;\n   }\n \n+  // Attach any go:embed comments for this variable.\n+  void\n+  set_embeds(std::vector<std::string>* embeds)\n+  {\n+    go_assert(this->is_global_\n+\t      && this->init_ == NULL\n+\t      && this->preinit_ == NULL);\n+    this->embeds_ = embeds;\n+  }\n+\n   // Return the top-level declaration for this variable.\n   Statement*\n   toplevel_decl()\n@@ -2346,6 +2360,8 @@ class Variable\n   Block* preinit_;\n   // Location of variable definition.\n   Location location_;\n+  // Any associated go:embed comments.\n+  std::vector<std::string>* embeds_;\n   // Backend representation.\n   Bvariable* backend_;\n   // Whether this is a global variable."}, {"sha": "dd66c0209a46e520d6874d0dac1d9649b6bcafe3", "filename": "gcc/go/gofrontend/lex.cc", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "patch": "@@ -2035,6 +2035,8 @@ Lex::skip_cpp_comment()\n \t  (*this->linknames_)[go_name] = Linkname(ext_name, is_exported, loc);\n \t}\n     }\n+  else if (verb == \"go:embed\")\n+    this->gather_embed(ps, pend);\n   else if (verb == \"go:nointerface\")\n     {\n       // For field tracking analysis: a //go:nointerface comment means\n@@ -2111,6 +2113,98 @@ Lex::skip_cpp_comment()\n     }\n }\n \n+// Read a go:embed directive.  This is a series of space-separated\n+// patterns.  Each pattern may be a quoted or backquoted string.\n+\n+void\n+Lex::gather_embed(const char *p, const char *pend)\n+{\n+  while (true)\n+    {\n+      // Skip spaces to find the start of the next pattern.  We do a\n+      // fast skip of space and tab, but we also permit and skip\n+      // Unicode space characters.\n+      while (p < pend && (*p == ' ' || *p == '\\t'))\n+\t++p;\n+      if (p >= pend)\n+\tbreak;\n+      unsigned int c;\n+      bool issued_error;\n+      const char *pnext = this->advance_one_utf8_char(p, &c, &issued_error);\n+      if (issued_error)\n+\treturn;\n+      if (Lex::is_unicode_space(c))\n+\t{\n+\t  p = pnext;\n+\t  continue;\n+\t}\n+\n+      // Here P points to the start of the next pattern, PNEXT points\n+      // to the second character in the pattern, and C is the first\n+      // character in that pattern (the character to which P points).\n+\n+      if (c == '\"' || c == '`')\n+\t{\n+\t  Location loc = this->location();\n+\t  const unsigned char quote = c;\n+\t  std::string value;\n+\t  p = pnext;\n+\t  while (p < pend && *p != quote)\n+\t    {\n+\t      bool is_character;\n+\t      if (quote == '\"')\n+\t\tp = this->advance_one_char(p, false, &c, &is_character);\n+\t      else\n+\t\t{\n+\t\t  p = this->advance_one_utf8_char(p, &c, &issued_error);\n+\t\t  if (issued_error)\n+\t\t    return;\n+\t\t  // \"Carriage return characters ('\\r') inside raw string\n+\t\t  // literals are discarded from the raw string value.\"\n+\t\t  if (c == '\\r')\n+\t\t    continue;\n+\t\t  is_character = true;\n+\t\t}\n+\t      Lex::append_char(c, is_character, &value, loc);\n+\t    }\n+\t  if (p >= pend)\n+\t    {\n+\t      // Note that within a go:embed directive we do not\n+\t      // permit raw strings to cross multiple lines.\n+\t      go_error_at(loc, \"unterminated string\");\n+\t      return;\n+\t    }\n+\t  this->embeds_.push_back(value);\n+\t  ++p;\n+\t}\n+      else\n+\t{\n+\t  const char *start = p;\n+\t  p = pnext;\n+\t  while (p < pend)\n+\t    {\n+\t      c = *p;\n+\t      if (c == ' ' || c == '\\t')\n+\t\tbreak;\n+\t      if (c > ' ' && c <= 0x7f)\n+\t\t{\n+\t\t  // ASCII non-space character.\n+\t\t  ++p;\n+\t\t  continue;\n+\t\t}\n+\t      pnext = this->advance_one_utf8_char(p, &c, &issued_error);\n+\t      if (issued_error)\n+\t\treturn;\n+\t      if (Lex::is_unicode_space(c))\n+\t\tbreak;\n+\t      p = pnext;\n+\t    }\n+\n+\t  this->embeds_.push_back(std::string(start, p - start));\n+\t}\n+    }\n+}\n+\n // The Unicode tables use this struct.\n \n struct Unicode_range"}, {"sha": "75c8429b68f0b01d66ac69e35f5a6412ec0d4690", "filename": "gcc/go/gofrontend/lex.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.h?ref=c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "patch": "@@ -405,6 +405,21 @@ class Lex\n     return ret;\n   }\n \n+  // Return whether there are any current go:embed patterns.\n+  bool\n+  has_embeds() const\n+  { return !this->embeds_.empty(); }\n+\n+  // If there are any go:embed patterns seen so far, store them in\n+  // *EMBEDS and clear the saved set.  *EMBEDS must be an empty\n+  // vector.\n+  void\n+  get_and_clear_embeds(std::vector<std::string>* embeds)\n+  {\n+    go_assert(embeds->empty());\n+    std::swap(*embeds, this->embeds_);\n+  }\n+\n   // Return whether the identifier NAME should be exported.  NAME is a\n   // mangled name which includes only ASCII characters.\n   static bool\n@@ -536,6 +551,9 @@ class Lex\n   void\n   skip_cpp_comment();\n \n+  void\n+  gather_embed(const char*, const char*);\n+\n   // The input file name.\n   const char* input_file_name_;\n   // The input file.\n@@ -561,6 +579,8 @@ class Lex\n   std::string extern_;\n   // The list of //go:linkname comments, if any.\n   Linknames* linknames_;\n+  // The list of //go:embed patterns, if any.\n+  std::vector<std::string> embeds_;\n };\n \n #endif // !defined(GO_LEX_H)"}, {"sha": "fd81a85c87f83c7833327a2f6bff1dc6d0a75a9d", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 76, "deletions": 23, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "patch": "@@ -1315,12 +1315,36 @@ Parse::declaration()\n     go_warning_at(token->location(), 0,\n \t\t  \"ignoring magic comment before non-function\");\n \n+  std::vector<std::string>* embeds = NULL;\n+  if (this->lex_->has_embeds())\n+    {\n+      embeds = new(std::vector<std::string>);\n+      this->lex_->get_and_clear_embeds(embeds);\n+\n+      if (!this->gogo_->is_embed_imported())\n+\t{\n+\t  go_error_at(token->location(),\n+\t\t      \"invalid go:embed: missing import %<embed%>\");\n+\t  delete embeds;\n+\t  embeds = NULL;\n+\t}\n+      if (!token->is_keyword(KEYWORD_VAR))\n+\t{\n+\t  go_error_at(token->location(), \"misplaced go:embed directive\");\n+\t  if (embeds != NULL)\n+\t    {\n+\t      delete embeds;\n+\t      embeds = NULL;\n+\t    }\n+\t}\n+    }\n+\n   if (token->is_keyword(KEYWORD_CONST))\n     this->const_decl();\n   else if (token->is_keyword(KEYWORD_TYPE))\n     this->type_decl(pragmas);\n   else if (token->is_keyword(KEYWORD_VAR))\n-    this->var_decl();\n+    this->var_decl(embeds);\n   else if (token->is_keyword(KEYWORD_FUNC))\n     this->function_decl(pragmas);\n   else\n@@ -1343,8 +1367,8 @@ Parse::declaration_may_start_here()\n // Decl<P> = P | \"(\" [ List<P> ] \")\" .\n \n void\n-Parse::decl(void (Parse::*pfn)(void*, unsigned int), void* varg,\n-\t    unsigned int pragmas)\n+Parse::decl(void (Parse::*pfn)(unsigned int, std::vector<std::string>*),\n+\t    unsigned int pragmas, std::vector<std::string>* embeds)\n {\n   if (this->peek_token()->is_eof())\n     {\n@@ -1354,15 +1378,18 @@ Parse::decl(void (Parse::*pfn)(void*, unsigned int), void* varg,\n     }\n \n   if (!this->peek_token()->is_op(OPERATOR_LPAREN))\n-    (this->*pfn)(varg, pragmas);\n+    (this->*pfn)(pragmas, embeds);\n   else\n     {\n       if (pragmas != 0)\n \tgo_warning_at(this->location(), 0,\n \t\t      \"ignoring magic %<//go:...%> comment before group\");\n+      if (embeds != NULL)\n+\tgo_error_at(this->location(),\n+\t\t    \"ignoring %<//go:embed%> comment before group\");\n       if (!this->advance_token()->is_op(OPERATOR_RPAREN))\n \t{\n-\t  this->list(pfn, varg, true);\n+\t  this->list(pfn, true);\n \t  if (!this->peek_token()->is_op(OPERATOR_RPAREN))\n \t    {\n \t      go_error_at(this->location(), \"missing %<)%>\");\n@@ -1383,10 +1410,10 @@ Parse::decl(void (Parse::*pfn)(void*, unsigned int), void* varg,\n // might follow.  This is either a '}' or a ')'.\n \n void\n-Parse::list(void (Parse::*pfn)(void*, unsigned int), void* varg,\n+Parse::list(void (Parse::*pfn)(unsigned int, std::vector<std::string>*),\n \t    bool follow_is_paren)\n {\n-  (this->*pfn)(varg, 0);\n+  (this->*pfn)(0, NULL);\n   Operator follow = follow_is_paren ? OPERATOR_RPAREN : OPERATOR_RCURLY;\n   while (this->peek_token()->is_op(OPERATOR_SEMICOLON)\n \t || this->peek_token()->is_op(OPERATOR_COMMA))\n@@ -1395,7 +1422,7 @@ Parse::list(void (Parse::*pfn)(void*, unsigned int), void* varg,\n \tgo_error_at(this->location(), \"unexpected comma\");\n       if (this->advance_token()->is_op(follow))\n \tbreak;\n-      (this->*pfn)(varg, 0);\n+      (this->*pfn)(0, NULL);\n     }\n }\n \n@@ -1522,13 +1549,13 @@ Parse::type_decl(unsigned int pragmas)\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_TYPE));\n   this->advance_token();\n-  this->decl(&Parse::type_spec, NULL, pragmas);\n+  this->decl(&Parse::type_spec, pragmas, NULL);\n }\n \n // TypeSpec = identifier [\"=\"] Type .\n \n void\n-Parse::type_spec(void*, unsigned int pragmas)\n+Parse::type_spec(unsigned int pragmas, std::vector<std::string>*)\n {\n   const Token* token = this->peek_token();\n   if (!token->is_identifier())\n@@ -1622,27 +1649,42 @@ Parse::type_spec(void*, unsigned int pragmas)\n // VarDecl = \"var\" Decl<VarSpec> .\n \n void\n-Parse::var_decl()\n+Parse::var_decl(std::vector<std::string>* embeds)\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_VAR));\n   this->advance_token();\n-  this->decl(&Parse::var_spec, NULL, 0);\n+  this->decl(&Parse::var_spec, 0, embeds);\n }\n \n // VarSpec = IdentifierList\n //             ( CompleteType [ \"=\" ExpressionList ] | \"=\" ExpressionList ) .\n \n void\n-Parse::var_spec(void*, unsigned int pragmas)\n+Parse::var_spec(unsigned int pragmas, std::vector<std::string>* embeds)\n {\n+  Location loc = this->location();\n+\n   if (pragmas != 0)\n-    go_warning_at(this->location(), 0,\n-\t\t  \"ignoring magic %<//go:...%> comment before var\");\n+    go_warning_at(loc, 0, \"ignoring magic %<//go:...%> comment before var\");\n \n   // Get the variable names.\n   Typed_identifier_list til;\n   this->identifier_list(&til);\n \n+  if (embeds != NULL)\n+    {\n+      if (!this->gogo_->in_global_scope())\n+\t{\n+\t  go_error_at(loc, \"go:embed only permitted at package scope\");\n+\t  embeds = NULL;\n+\t}\n+      if (til.size() > 1)\n+\t{\n+\t  go_error_at(loc, \"go:embed cannot apply to multiple vars\");\n+\t  embeds = NULL;\n+\t}\n+    }\n+\n   Location location = this->location();\n \n   Type* type = NULL;\n@@ -1670,7 +1712,13 @@ Parse::var_spec(void*, unsigned int pragmas)\n       init = this->expression_list(NULL, false, true);\n     }\n \n-  this->init_vars(&til, type, init, false, location);\n+  if (embeds != NULL && init != NULL)\n+    {\n+      go_error_at(loc, \"go:embed cannot apply to var with initializer\");\n+      embeds = NULL;\n+    }\n+\n+  this->init_vars(&til, type, init, false, embeds, location);\n \n   if (init != NULL)\n     delete init;\n@@ -1683,11 +1731,12 @@ Parse::var_spec(void*, unsigned int pragmas)\n void\n Parse::init_vars(const Typed_identifier_list* til, Type* type,\n \t\t Expression_list* init, bool is_coloneq,\n-\t\t Location location)\n+\t\t std::vector<std::string>* embeds, Location location)\n {\n   // Check for an initialization which can yield multiple values.\n   if (init != NULL && init->size() == 1 && til->size() > 1)\n     {\n+      go_assert(embeds == NULL);\n       if (this->init_vars_from_call(til, type, *init->begin(), is_coloneq,\n \t\t\t\t    location))\n \treturn;\n@@ -1729,8 +1778,12 @@ Parse::init_vars(const Typed_identifier_list* til, Type* type,\n     {\n       if (init != NULL)\n \tgo_assert(pexpr != init->end());\n-      this->init_var(*p, type, init == NULL ? NULL : *pexpr, is_coloneq,\n-\t\t     false, &any_new, vars, vals);\n+      Named_object* no = this->init_var(*p, type,\n+\t\t\t\t\tinit == NULL ? NULL : *pexpr,\n+\t\t\t\t\tis_coloneq, false, &any_new,\n+\t\t\t\t\tvars, vals);\n+      if (embeds != NULL && no->is_variable())\n+\tno->var_value()->set_embeds(embeds);\n       if (init != NULL)\n \t++pexpr;\n     }\n@@ -2270,7 +2323,7 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n \t}\n     }\n \n-  this->init_vars(&til, NULL, init, true, location);\n+  this->init_vars(&til, NULL, init, true, NULL, location);\n }\n \n // FunctionDecl = \"func\" identifier Signature [ Block ] .\n@@ -5317,7 +5370,7 @@ Parse::for_stat(Label* label)\n \t{\n \t  go_error_at(this->location(),\n                       \"var declaration not allowed in for initializer\");\n-\t  this->var_decl();\n+\t  this->var_decl(NULL);\n \t}\n \n       if (token->is_op(OPERATOR_SEMICOLON))\n@@ -5762,13 +5815,13 @@ Parse::import_decl()\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_IMPORT));\n   this->advance_token();\n-  this->decl(&Parse::import_spec, NULL, 0);\n+  this->decl(&Parse::import_spec, 0, NULL);\n }\n \n // ImportSpec = [ \".\" | PackageName ] PackageFileName .\n \n void\n-Parse::import_spec(void*, unsigned int pragmas)\n+Parse::import_spec(unsigned int pragmas, std::vector<std::string>*)\n {\n   if (pragmas != 0)\n     go_warning_at(this->location(), 0,"}, {"sha": "2c3c505ffa98dab2c777b69e1c3412fb99470847", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c907e4394133b3f4b58feccfb3a415f9ae5ee1f4/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=c907e4394133b3f4b58feccfb3a415f9ae5ee1f4", "patch": "@@ -181,16 +181,17 @@ class Parse\n   void method_spec(Typed_identifier_list*);\n   void declaration();\n   bool declaration_may_start_here();\n-  void decl(void (Parse::*)(void*, unsigned int), void*, unsigned int pragmas);\n-  void list(void (Parse::*)(void*, unsigned int), void*, bool);\n+  void decl(void (Parse::*)(unsigned int, std::vector<std::string>*),\n+\t    unsigned int pragmas, std::vector<std::string>* embeds);\n+  void list(void (Parse::*)(unsigned int, std::vector<std::string>*), bool);\n   void const_decl();\n   void const_spec(int, Type**, Expression_list**);\n   void type_decl(unsigned int pragmas);\n-  void type_spec(void*, unsigned int pragmas);\n-  void var_decl();\n-  void var_spec(void*, unsigned int pragmas);\n+  void type_spec(unsigned int pragmas, std::vector<std::string>*);\n+  void var_decl(std::vector<std::string>* embeds);\n+  void var_spec(unsigned int pragmas, std::vector<std::string>*);\n   void init_vars(const Typed_identifier_list*, Type*, Expression_list*,\n-\t\t bool is_coloneq, Location);\n+\t\t bool is_coloneq, std::vector<std::string>*, Location);\n   bool init_vars_from_call(const Typed_identifier_list*, Type*, Expression*,\n \t\t\t   bool is_coloneq, Location);\n   bool init_vars_from_map(const Typed_identifier_list*, Type*, Expression*,\n@@ -277,7 +278,7 @@ class Parse\n   void goto_stat();\n   void package_clause();\n   void import_decl();\n-  void import_spec(void*, unsigned int pragmas);\n+  void import_spec(unsigned int pragmas, std::vector<std::string>*);\n \n   // Skip past an error looking for a semicolon or OP.  Return true if\n   // all is well, false if we found EOF."}]}