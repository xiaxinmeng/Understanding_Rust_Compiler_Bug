{"sha": "5dd9a9d0c9294455077ba6401701fd3566dcf07c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRkOWE5ZDBjOTI5NDQ1NTA3N2JhNjQwMTcwMWZkMzU2NmRjZjA3Yw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-01-04T17:40:59Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-01-04T17:40:59Z"}, "message": "C FE: implement fix-it hint for -Wmissing-braces\n\ngcc/c/ChangeLog:\n\t* c-parser.c (c_parser_declaration_or_fndef): Create a\n\trich_location at init_loc and parse it to start_init.\n\t(last_init_list_comma): New global.\n\t(c_parser_braced_init): Update last_init_list_comma when parsing\n\tcommas.  Pass it to pop_init_level.  Pass location of closing\n\tbrace to pop_init_level.\n\t(c_parser_postfix_expression_after_paren_type): Create a\n\trich_location at type_loc and parse it to start_init.\n\t(c_parser_omp_declare_reduction): Likewise for loc.\n\t* c-tree.h (start_init): Add rich_location * param.\n\t(pop_init_level): Add location_t param.\n\t* c-typeck.c (struct initializer_stack): Add field\n\t\"missing_brace_richloc\".\n\t(start_init): Add richloc param, use it to initialize\n\tthe stack node's missing_brace_richloc.\n\t(last_init_list_comma): New decl.\n\t(finish_implicit_inits): Pass last_init_list_comma to\n\tpop_init_level.\n\t(push_init_level): When finding missing open braces, add fix-it\n\thints to the richloc.\n\t(pop_init_level): Add \"insert_before\" param and pass it\n\twhen calling pop_init_level.  Add fixits about missing\n\tclose braces to any richloc.  Use the richloc for the\n\t-Wmissing-braces warning.\n\t(set_designator): Pass last_init_list_comma to pop_init_level.\n\t(process_init_element): Likewise.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/Wmissing-braces-fixits.c: New test case.\n\nFrom-SVN: r244061", "tree": {"sha": "881a273cbb54d8222e066d9f714a5334e21e14fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/881a273cbb54d8222e066d9f714a5334e21e14fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dd9a9d0c9294455077ba6401701fd3566dcf07c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd9a9d0c9294455077ba6401701fd3566dcf07c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dd9a9d0c9294455077ba6401701fd3566dcf07c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd9a9d0c9294455077ba6401701fd3566dcf07c/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d0a0bfd9394f303ac9ada8803c72ad846bbab990", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0a0bfd9394f303ac9ada8803c72ad846bbab990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0a0bfd9394f303ac9ada8803c72ad846bbab990"}], "stats": {"total": 319, "additions": 297, "deletions": 22}, "files": [{"sha": "6f8cf00a1da1a3202523c9e1c394ad8623e577a7", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=5dd9a9d0c9294455077ba6401701fd3566dcf07c", "patch": "@@ -1,3 +1,32 @@\n+2017-01-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-parser.c (c_parser_declaration_or_fndef): Create a\n+\trich_location at init_loc and parse it to start_init.\n+\t(last_init_list_comma): New global.\n+\t(c_parser_braced_init): Update last_init_list_comma when parsing\n+\tcommas.  Pass it to pop_init_level.  Pass location of closing\n+\tbrace to pop_init_level.\n+\t(c_parser_postfix_expression_after_paren_type): Create a\n+\trich_location at type_loc and parse it to start_init.\n+\t(c_parser_omp_declare_reduction): Likewise for loc.\n+\t* c-tree.h (start_init): Add rich_location * param.\n+\t(pop_init_level): Add location_t param.\n+\t* c-typeck.c (struct initializer_stack): Add field\n+\t\"missing_brace_richloc\".\n+\t(start_init): Add richloc param, use it to initialize\n+\tthe stack node's missing_brace_richloc.\n+\t(last_init_list_comma): New decl.\n+\t(finish_implicit_inits): Pass last_init_list_comma to\n+\tpop_init_level.\n+\t(push_init_level): When finding missing open braces, add fix-it\n+\thints to the richloc.\n+\t(pop_init_level): Add \"insert_before\" param and pass it\n+\twhen calling pop_init_level.  Add fixits about missing\n+\tclose braces to any richloc.  Use the richloc for the\n+\t-Wmissing-braces warning.\n+\t(set_designator): Pass last_init_list_comma to pop_init_level.\n+\t(process_init_element): Likewise.\n+\n 2017-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "c7679c2644a1004beffb43978337c1c51b77c855", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=5dd9a9d0c9294455077ba6401701fd3566dcf07c", "patch": "@@ -1847,8 +1847,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      c_parser_consume_token (parser);\n \t      if (auto_type_p)\n \t\t{\n-\t\t  start_init (NULL_TREE, asm_name, global_bindings_p ());\n \t\t  init_loc = c_parser_peek_token (parser)->location;\n+\t\t  rich_location richloc (line_table, init_loc);\n+\t\t  start_init (NULL_TREE, asm_name, global_bindings_p (), &richloc);\n \t\t  init = c_parser_expr_no_commas (parser, NULL);\n \t\t  if (TREE_CODE (init.value) == COMPONENT_REF\n \t\t      && DECL_C_BIT_FIELD (TREE_OPERAND (init.value, 1)))\n@@ -1904,8 +1905,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t      || !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n \t\t    c_finish_omp_declare_simd (parser, d, NULL_TREE,\n \t\t\t\t\t       omp_declare_simd_clauses);\n-\t\t  start_init (d, asm_name, global_bindings_p ());\n \t\t  init_loc = c_parser_peek_token (parser)->location;\n+\t\t  rich_location richloc (line_table, init_loc);\n+\t\t  start_init (d, asm_name, global_bindings_p (), &richloc);\n \t\t  init = c_parser_initializer (parser);\n \t\t  finish_init ();\n \t\t}\n@@ -4325,6 +4327,11 @@ c_parser_initializer (c_parser *parser)\n     }\n }\n \n+/* The location of the last comma within the current initializer list,\n+   or UNKNOWN_LOCATION if not within one.  */\n+\n+location_t last_init_list_comma;\n+\n /* Parse a braced initializer list.  TYPE is the type specified for a\n    compound literal, and NULL_TREE for other initializers and for\n    nested braced lists.  NESTED_P is true for nested braced lists,\n@@ -4362,7 +4369,10 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p,\n \t  if (parser->error)\n \t    break;\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n-\t    c_parser_consume_token (parser);\n+\t    {\n+\t      last_init_list_comma = c_parser_peek_token (parser)->location;\n+\t      c_parser_consume_token (parser);\n+\t    }\n \t  else\n \t    break;\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n@@ -4376,13 +4386,13 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p,\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n       c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, \"expected %<}%>\");\n-      pop_init_level (brace_loc, 0, &braced_init_obstack);\n+      pop_init_level (brace_loc, 0, &braced_init_obstack, last_init_list_comma);\n       obstack_free (&braced_init_obstack, NULL);\n       return ret;\n     }\n   location_t close_loc = next_tok->location;\n   c_parser_consume_token (parser);\n-  ret = pop_init_level (brace_loc, 0, &braced_init_obstack);\n+  ret = pop_init_level (brace_loc, 0, &braced_init_obstack, close_loc);\n   obstack_free (&braced_init_obstack, NULL);\n   set_c_expr_source_range (&ret, brace_loc, close_loc);\n   return ret;\n@@ -8218,7 +8228,8 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n   tree type_expr = NULL_TREE;\n   bool type_expr_const = true;\n   check_compound_literal_type (type_loc, type_name);\n-  start_init (NULL_TREE, NULL, 0);\n+  rich_location richloc (line_table, type_loc);\n+  start_init (NULL_TREE, NULL, 0, &richloc);\n   type = groktypename (type_name, &type_expr, &type_expr_const);\n   start_loc = c_parser_peek_token (parser)->location;\n   if (type != error_mark_node && C_TYPE_VARIABLE_SIZE (type))\n@@ -17140,8 +17151,9 @@ c_parser_omp_declare_reduction (c_parser *parser, enum pragma_context context)\n \t      else\n \t\t{\n \t\t  tree st = push_stmt_list ();\n-\t\t  start_init (omp_priv, NULL_TREE, 0);\n \t\t  location_t loc = c_parser_peek_token (parser)->location;\n+\t\t  rich_location richloc (line_table, loc);\n+\t\t  start_init (omp_priv, NULL_TREE, 0, &richloc);\n \t\t  struct c_expr init = c_parser_initializer (parser);\n \t\t  finish_init ();\n \t\t  finish_decl (omp_priv, loc, init.value,"}, {"sha": "ae01450f90ea90ef9a5e9e808e3eabfd432c8faa", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=5dd9a9d0c9294455077ba6401701fd3566dcf07c", "patch": "@@ -642,12 +642,13 @@ extern tree c_cast_expr (location_t, struct c_type_name *, tree);\n extern tree build_c_cast (location_t, tree, tree);\n extern void store_init_value (location_t, tree, tree, tree);\n extern void maybe_warn_string_init (location_t, tree, struct c_expr);\n-extern void start_init (tree, tree, int);\n+extern void start_init (tree, tree, int, rich_location *);\n extern void finish_init (void);\n extern void really_start_incremental_init (tree);\n extern void finish_implicit_inits (location_t, struct obstack *);\n extern void push_init_level (location_t, int, struct obstack *);\n-extern struct c_expr pop_init_level (location_t, int, struct obstack *);\n+extern struct c_expr pop_init_level (location_t, int, struct obstack *,\n+\t\t\t\t     location_t);\n extern void set_init_index (location_t, tree, tree, struct obstack *);\n extern void set_init_label (location_t, tree, location_t, struct obstack *);\n extern void process_init_element (location_t, struct c_expr, bool,"}, {"sha": "63e0dc6b29898105794aa1bd24e2c985e137a0cb", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=5dd9a9d0c9294455077ba6401701fd3566dcf07c", "patch": "@@ -7494,14 +7494,16 @@ struct initializer_stack\n   char top_level;\n   char require_constant_value;\n   char require_constant_elements;\n+  rich_location *missing_brace_richloc;\n };\n \n static struct initializer_stack *initializer_stack;\n \f\n /* Prepare to parse and output the initializer for variable DECL.  */\n \n void\n-start_init (tree decl, tree asmspec_tree ATTRIBUTE_UNUSED, int top_level)\n+start_init (tree decl, tree asmspec_tree ATTRIBUTE_UNUSED, int top_level,\n+\t    rich_location *richloc)\n {\n   const char *locus;\n   struct initializer_stack *p = XNEW (struct initializer_stack);\n@@ -7517,6 +7519,7 @@ start_init (tree decl, tree asmspec_tree ATTRIBUTE_UNUSED, int top_level)\n   p->spelling_size = spelling_size;\n   p->top_level = constructor_top_level;\n   p->next = initializer_stack;\n+  p->missing_brace_richloc = richloc;\n   initializer_stack = p;\n \n   constructor_decl = decl;\n@@ -7701,6 +7704,8 @@ really_start_incremental_init (tree type)\n     }\n }\n \f\n+extern location_t last_init_list_comma;\n+\n /* Called when we see an open brace for a nested initializer.  Finish\n    off any pending levels with implicit braces.  */\n void\n@@ -7711,14 +7716,16 @@ finish_implicit_inits (location_t loc, struct obstack *braced_init_obstack)\n       if (RECORD_OR_UNION_TYPE_P (constructor_type)\n \t  && constructor_fields == 0)\n \tprocess_init_element (input_location,\n-\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack,\n+\t\t\t\t\t      last_init_list_comma),\n \t\t\t      true, braced_init_obstack);\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE\n \t       && constructor_max_index\n \t       && tree_int_cst_lt (constructor_max_index,\n \t\t\t\t   constructor_index))\n \tprocess_init_element (input_location,\n-\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack,\n+\t\t\t\t\t      last_init_list_comma),\n \t\t\t      true, braced_init_obstack);\n       else\n \tbreak;\n@@ -7837,7 +7844,12 @@ push_init_level (location_t loc, int implicit,\n     }\n \n   if (implicit == 1)\n-    found_missing_braces = 1;\n+    {\n+      found_missing_braces = 1;\n+      if (initializer_stack->missing_brace_richloc)\n+\tinitializer_stack->missing_brace_richloc->add_fixit_insert_before\n+\t  (loc, \"{\");\n+    }\n \n   if (RECORD_OR_UNION_TYPE_P (constructor_type))\n     {\n@@ -7915,7 +7927,8 @@ push_init_level (location_t loc, int implicit,\n \n struct c_expr\n pop_init_level (location_t loc, int implicit,\n-\t\tstruct obstack *braced_init_obstack)\n+\t\tstruct obstack *braced_init_obstack,\n+\t\tlocation_t insert_before)\n {\n   struct constructor_stack *p;\n   struct c_expr ret;\n@@ -7929,10 +7942,15 @@ pop_init_level (location_t loc, int implicit,\n \t pop any inner levels that didn't have explicit braces.  */\n       while (constructor_stack->implicit)\n \tprocess_init_element (input_location,\n-\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack,\n+\t\t\t\t\t      insert_before),\n \t\t\t      true, braced_init_obstack);\n       gcc_assert (!constructor_range_stack);\n     }\n+  else\n+    if (initializer_stack->missing_brace_richloc)\n+      initializer_stack->missing_brace_richloc->add_fixit_insert_before\n+\t(insert_before, \"}\");\n \n   /* Now output all pending elements.  */\n   constructor_incremental = 1;\n@@ -7989,8 +8007,12 @@ pop_init_level (location_t loc, int implicit,\n   /* Warn when some structs are initialized with direct aggregation.  */\n   if (!implicit && found_missing_braces && warn_missing_braces\n       && !constructor_zeroinit)\n-    warning_init (loc, OPT_Wmissing_braces,\n-\t\t  \"missing braces around initializer\");\n+    {\n+      gcc_assert (initializer_stack->missing_brace_richloc);\n+      warning_at_rich_loc (initializer_stack->missing_brace_richloc,\n+\t\t\t   OPT_Wmissing_braces,\n+\t\t\t   \"missing braces around initializer\");\n+    }\n \n   /* Warn when some struct elements are implicitly initialized to zero.  */\n   if (warn_missing_field_initializers\n@@ -8129,7 +8151,8 @@ set_designator (location_t loc, int array,\n \t braces.  */\n       while (constructor_stack->implicit)\n \tprocess_init_element (input_location,\n-\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack,\n+\t\t\t\t\t      last_init_list_comma),\n \t\t\t      true, braced_init_obstack);\n       constructor_designated = 1;\n       return 0;\n@@ -9198,15 +9221,17 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n       if (RECORD_OR_UNION_TYPE_P (constructor_type)\n \t  && constructor_fields == 0)\n \tprocess_init_element (loc,\n-\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack,\n+\t\t\t\t\t      last_init_list_comma),\n \t\t\t      true, braced_init_obstack);\n       else if ((TREE_CODE (constructor_type) == ARRAY_TYPE\n \t\t|| VECTOR_TYPE_P (constructor_type))\n \t       && constructor_max_index\n \t       && tree_int_cst_lt (constructor_max_index,\n \t\t\t\t   constructor_index))\n \tprocess_init_element (loc,\n-\t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n+\t\t\t      pop_init_level (loc, 1, braced_init_obstack,\n+\t\t\t\t\t      last_init_list_comma),\n \t\t\t      true, braced_init_obstack);\n       else\n \tbreak;\n@@ -9539,7 +9564,8 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t      gcc_assert (constructor_stack->implicit);\n \t      process_init_element (loc,\n \t\t\t\t    pop_init_level (loc, 1,\n-\t\t\t\t\t\t    braced_init_obstack),\n+\t\t\t\t\t\t    braced_init_obstack,\n+\t\t\t\t\t\t    last_init_list_comma),\n \t\t\t\t    true, braced_init_obstack);\n \t    }\n \t  for (p = range_stack;\n@@ -9549,7 +9575,8 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n \t      gcc_assert (constructor_stack->implicit);\n \t      process_init_element (loc,\n \t\t\t\t    pop_init_level (loc, 1,\n-\t\t\t\t\t\t    braced_init_obstack),\n+\t\t\t\t\t\t    braced_init_obstack,\n+\t\t\t\t\t\t    last_init_list_comma),\n \t\t\t\t    true, braced_init_obstack);\n \t    }\n "}, {"sha": "8ad30173c77ac49d5be5adc8efe79e975e46216f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5dd9a9d0c9294455077ba6401701fd3566dcf07c", "patch": "@@ -1,3 +1,7 @@\n+2017-01-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/Wmissing-braces-fixits.c: New test case.\n+\n 2017-01-04  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/66735"}, {"sha": "37998d04adf55554a708dbb84b80026f5827da0b", "filename": "gcc/testsuite/gcc.dg/Wmissing-braces-fixits.c", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-braces-fixits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd9a9d0c9294455077ba6401701fd3566dcf07c/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-braces-fixits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-braces-fixits.c?ref=5dd9a9d0c9294455077ba6401701fd3566dcf07c", "patch": "@@ -0,0 +1,202 @@\n+/* { dg-options \"-Wmissing-braces -fdiagnostics-show-caret\" } */\n+\n+struct sf2 { int i; int j; };\n+struct sf3 { int i; int j; int k; };\n+struct sa2 { int arr[2]; };\n+struct sa3 { int arr[3]; };\n+\n+int arr_12[12] = \\\n+  { 0, 1, 2, 3, 4, 5,\n+    6, 7, 8, 9, 10, 11};\n+\n+int arr_12_1[12][1] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {} {} {} {} {} {}\n+     6, 7, 8, 9, 10, 11};\n+     {} {} {} {} { } { }\n+     { dg-end-multiline-output \"\" } */\n+\n+int arr_1_12[1][12] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {\n+     6, 7, 8, 9, 10, 11};\n+                       }\n+     { dg-end-multiline-output \"\" } */\n+\n+int arr_2_6[2][6] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {               }\n+     6, 7, 8, 9, 10, 11};\n+     {                 }\n+     { dg-end-multiline-output \"\" } */\n+\n+int arr_2_2_3[2][2][3] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {\n+     {      } {      }\n+                     }\n+     6, 7, 8, 9, 10, 11};\n+     {\n+     {      } {        }\n+                       }\n+     { dg-end-multiline-output \"\" } */\n+\n+int arr_2_3_2[2][3][2] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {\n+     {   } {   } {   }\n+                     }\n+     6, 7, 8, 9, 10, 11};\n+     {\n+     {   } {   } {     }\n+                       }\n+     { dg-end-multiline-output \"\" } */\n+\n+int arr_6_2[6][2] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {   } {   } {   }\n+     6, 7, 8, 9, 10, 11};\n+     {   } {   } {     }\n+     { dg-end-multiline-output \"\" } */\n+\n+int arr_3_2_2[3][2][2] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {\n+     {   } {   }\n+               } {\n+                 {   }\n+     6, 7, 8, 9, 10, 11};\n+     {   }\n+         } {\n+           {   } {     }\n+                       }\n+     { dg-end-multiline-output \"\" } */\n+\n+int arr_3_4[3][4] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {         } {\n+     6, 7, 8, 9, 10, 11};\n+         } {           }\n+     { dg-end-multiline-output \"\" } */\n+\n+int arr_4_3[4][3] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {      } {      }\n+     6, 7, 8, 9, 10, 11};\n+     {      } {        }\n+     { dg-end-multiline-output \"\" } */\n+\n+int arr_2_1_6[2][1][6] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {\n+     {               }\n+                     }\n+     6, 7, 8, 9, 10, 11};\n+     {\n+     {                 }\n+                       }\n+     { dg-end-multiline-output \"\" } */\n+\n+struct sf2 arr_6_sf2[6] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {   } {   } {   }\n+     6, 7, 8, 9, 10, 11};\n+     {   } {   } {     }\n+     { dg-end-multiline-output \"\" } */\n+\n+struct sf3 arr_4_sf3[4] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {      } {      }\n+     6, 7, 8, 9, 10, 11};\n+     {      } {        }\n+     { dg-end-multiline-output \"\" } */\n+\n+struct sa2 arr_6_sa2[6] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {\n+     {   }\n+         } {\n+           {   }\n+               } {\n+                 {   }\n+                     }\n+     6, 7, 8, 9, 10, 11};\n+     {\n+     {   }\n+         } {\n+           {   }\n+               } {\n+                 {     }\n+                       }\n+     { dg-end-multiline-output \"\" } */\n+\n+struct sa3 arr_4_sa3[4] = \\\n+  { 0, 1, 2, 3, 4, 5, /* { dg-warning \"missing braces around initializer\" } */\n+    6, 7, 8, 9, 10, 11};\n+  /* { dg-begin-multiline-output \"\" }\n+   { 0, 1, 2, 3, 4, 5,\n+   ^\n+     {\n+     {      }\n+            } {\n+              {      }\n+                     }\n+     6, 7, 8, 9, 10, 11};\n+     {\n+     {      }\n+            } {\n+              {        }\n+                       }\n+     { dg-end-multiline-output \"\" } */"}]}