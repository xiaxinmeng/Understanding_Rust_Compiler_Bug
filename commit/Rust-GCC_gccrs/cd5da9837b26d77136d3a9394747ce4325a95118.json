{"sha": "cd5da9837b26d77136d3a9394747ce4325a95118", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q1ZGE5ODM3YjI2ZDc3MTM2ZDNhOTM5NDc0N2NlNDMyNWE5NTExOA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-11-15T22:18:54Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-11-15T22:18:54Z"}, "message": "PR c/83656 - missing -Wbuiltin-declaration-mismatch on declaration without prototype\n\ngcc/c/ChangeLog:\n\n\tPR c/83656\n\t* c-decl.c (header_for_builtin_fn): Declare.\n\t(diagnose_mismatched_decls): Diagnose declarations of built-in\n\tfunctions without a prototype.\n\t* c-typeck.c (maybe_warn_builtin_no_proto_arg): New function.\n\t(convert_argument): Same.\n\t(convert_arguments): Factor code out into convert_argument.\n\tDetect mismatches between built-in formal arguments in calls\n\tto built-in without prototype.\n\t(build_conditional_expr): Same.\n\t(type_or_builtin_type): New function.\n\t(convert_for_assignment): Add argument.  Conditionally issue\n\twarnings instead of errors for mismatches.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/83656\n\t* gcc.dg/20021006-1.c\n\t* gcc.dg/Wbuiltin-declaration-mismatch.c: New test.\n\t* gcc.dg/Wbuiltin-declaration-mismatch-2.c: New test.\n\t* gcc.dg/Wbuiltin-declaration-mismatch-3.c: New test.\n\t* gcc.dg/Wbuiltin-declaration-mismatch-4.c: New test.\n\t* gcc.dg/Walloca-16.c: Adjust.\n\t* gcc.dg/Wrestrict-4.c: Adjust.\n\t* gcc.dg/Wrestrict-5.c: Adjust.\n\t* gcc.dg/atomic/stdatomic-generic.c: Adjust.\n\t* gcc.dg/atomic/stdatomic-lockfree.c: Adjust.\n\t* gcc.dg/initpri1.c: Adjust.\n\t* gcc.dg/pr15698-1.c: Adjust.\n\t* gcc.dg/pr69156.c: Adjust.\n\t* gcc.dg/pr83463.c: Adjust.\n\t* gcc.dg/redecl-4.c: Adjust.\n\t* gcc.dg/tls/thr-init-2.c: Adjust.\n\t* gcc.dg/torture/pr55890-2.c: Adjust.\n\t* gcc.dg/torture/pr55890-3.c: Adjust.\n\t* gcc.dg/torture/pr67741.c: Adjust.\n\t* gcc.dg/torture/stackalign/sibcall-1.c: Adjust.\n\t* gcc.dg/torture/tls/thr-init-1.c: Adjust.\n\t* gcc.dg/tree-ssa/builtins-folding-gimple-ub.c: Adjust.\n\nFrom-SVN: r266194", "tree": {"sha": "9a3374d29ebe69ec33462c7e9550317679a7a341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a3374d29ebe69ec33462c7e9550317679a7a341"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd5da9837b26d77136d3a9394747ce4325a95118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5da9837b26d77136d3a9394747ce4325a95118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5da9837b26d77136d3a9394747ce4325a95118", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5da9837b26d77136d3a9394747ce4325a95118/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a4030effa436cc4c6a537e633b0b0338b2b3ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a4030effa436cc4c6a537e633b0b0338b2b3ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a4030effa436cc4c6a537e633b0b0338b2b3ad4"}], "stats": {"total": 1201, "additions": 937, "deletions": 264}, "files": [{"sha": "706839cd1cb3940dc473059ecce611f0ef0e4742", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -1,3 +1,19 @@\n+2018-11-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/83656\n+\t* c-decl.c (header_for_builtin_fn): Declare.\n+\t(diagnose_mismatched_decls): Diagnose declarations of built-in\n+\tfunctions without a prototype.\n+\t* c-typeck.c (maybe_warn_builtin_no_proto_arg): New function.\n+\t(convert_argument): Same.\n+\t(convert_arguments): Factor code out into convert_argument.\n+\tDetect mismatches between built-in formal arguments in calls\n+\tto built-in without prototype.\n+\t(build_conditional_expr): Same.\n+\t(type_or_builtin_type): New function.\n+\t(convert_for_assignment): Add argument.  Conditionally issue\n+\twarnings instead of errors for mismatches.\n+\n 2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-decl.c: Replace \"source_location\" with \"location_t\"."}, {"sha": "cdd10ab7c55dfa1d8063858784970ead42b2b2ae", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -604,6 +604,7 @@ static tree grokparms (struct c_arg_info *, bool);\n static void layout_array_type (tree);\n static void warn_defaults_to (location_t, int, const char *, ...)\n     ATTRIBUTE_GCC_DIAG(3,4);\n+static const char *header_for_builtin_fn (enum built_in_function);\n \f\n /* T is a statement.  Add it to the statement-tree.  This is the\n    C/ObjC version--C++ has a slightly different version of this\n@@ -1887,12 +1888,25 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    *oldtypep = oldtype = trytype;\n \t  else\n \t    {\n+\t      const char *header\n+\t\t= header_for_builtin_fn (DECL_FUNCTION_CODE (olddecl));\n+\t      location_t loc = DECL_SOURCE_LOCATION (newdecl);\n+\t      if (warning_at (loc, OPT_Wbuiltin_declaration_mismatch,\n+\t\t\t      \"conflicting types for built-in function %q+D; \"\n+\t\t\t      \"expected %qT\",\n+\t\t\t      newdecl, oldtype)\n+\t\t  && header)\n+\t\t{\n+\t\t  /* Suggest the right header to include as the preferred\n+\t\t     solution rather than the spelling of the declaration.  */\n+\t\t  rich_location richloc (line_table, loc);\n+\t\t  maybe_add_include_fixit (&richloc, header, true);\n+\t\t  inform (&richloc,\n+\t\t\t  \"%qD is declared in header %qs\", olddecl, header);\n+\t\t}\n \t      /* If types don't match for a built-in, throw away the\n \t\t built-in.  No point in calling locate_old_decl here, it\n \t\t won't print anything.  */\n-\t      warning (OPT_Wbuiltin_declaration_mismatch,\n-\t\t       \"conflicting types for built-in function %q+D\",\n-\t\t       newdecl);\n \t      return false;\n \t    }\n \t}\n@@ -2026,15 +2040,33 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t can't validate the argument list) the built-in definition is\n \t overridden, but optionally warn this was a bad choice of name.  */\n       if (fndecl_built_in_p (olddecl)\n-\t  && !C_DECL_DECLARED_BUILTIN (olddecl)\n-\t  && (!TREE_PUBLIC (newdecl)\n-\t      || (DECL_INITIAL (newdecl)\n-\t\t  && !prototype_p (TREE_TYPE (newdecl)))))\n+\t  && !C_DECL_DECLARED_BUILTIN (olddecl))\n \t{\n-\t  warning (OPT_Wshadow, \"declaration of %q+D shadows \"\n-\t\t   \"a built-in function\", newdecl);\n-\t  /* Discard the old built-in function.  */\n-\t  return false;\n+\t  if (!TREE_PUBLIC (newdecl)\n+\t      || (DECL_INITIAL (newdecl)\n+\t\t  && !prototype_p (TREE_TYPE (newdecl))))\n+\t    {\n+\t      warning_at (DECL_SOURCE_LOCATION (newdecl),\n+\t\t\t  OPT_Wshadow, \"declaration of %qD shadows \"\n+\t\t\t  \"a built-in function\", newdecl);\n+\t      /* Discard the old built-in function.  */\n+\t      return false;\n+\t    }\n+\n+\t  if (!prototype_p (TREE_TYPE (newdecl)))\n+\t    {\n+\t      /* Set for built-ins that take no arguments.  */\n+\t      bool func_void_args = false;\n+\t      if (tree at = TYPE_ARG_TYPES (oldtype))\n+\t\tfunc_void_args = VOID_TYPE_P (TREE_VALUE (at));\n+\n+\t      if (extra_warnings && !func_void_args)\n+\t\twarning_at (DECL_SOURCE_LOCATION (newdecl),\n+\t\t\t    OPT_Wbuiltin_declaration_mismatch,\n+\t\t\t    \"declaration of built-in function %qD without \"\n+\t\t\t    \"a prototype; expected %qT\",\n+\t\t\t    newdecl, TREE_TYPE (olddecl));\n+\t    }\n \t}\n \n       if (DECL_INITIAL (newdecl))"}, {"sha": "bdfcb53c9fd60000f7c0a32d4433e47b4ef59470", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 485, "deletions": 239, "changes": 724, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -97,7 +97,8 @@ static int convert_arguments (location_t, vec<location_t>, tree,\n \t\t\t      tree);\n static tree pointer_diff (location_t, tree, tree, tree *);\n static tree convert_for_assignment (location_t, location_t, tree, tree, tree,\n-\t\t\t\t    enum impl_conv, bool, tree, tree, int);\n+\t\t\t\t    enum impl_conv, bool, tree, tree, int,\n+\t\t\t\t    int = 0);\n static tree valid_compound_expr_initializer (tree, tree);\n static void push_string (const char *);\n static void push_member_name (tree);\n@@ -3183,6 +3184,188 @@ c_build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n   return build_function_call_vec (loc, arg_loc, function, params, origtypes);\n }\n \f\n+/* Helper for convert_arguments called to convert the VALue of argument\n+   number ARGNUM from ORIGTYPE to the corresponding parameter number\n+   PARMNUL and TYPE.  */\n+\n+static tree\n+convert_argument (location_t ploc, tree function, tree fundecl,\n+\t\t  tree type, tree origtype, tree val, bool npc,\n+\t\t  tree rname, int parmnum, int argnum,\n+\t\t  bool excess_precision, int warnopt)\n+{\n+  tree valtype = TREE_TYPE (val);\n+\n+  tree parmval;\n+\n+  /* Formal parm type is specified by a function prototype.  */\n+\n+  if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n+    {\n+      error_at (ploc, \"type of formal parameter %d is incomplete\",\n+\t\tparmnum + 1);\n+      parmval = val;\n+    }\n+  else\n+    {\n+      /* Optionally warn about conversions that differ from the default\n+\t conversions.  */\n+      if (warn_traditional_conversion || warn_traditional)\n+\t{\n+\t  unsigned int formal_prec = TYPE_PRECISION (type);\n+\n+\t  if (INTEGRAL_TYPE_P (type)\n+\t      && TREE_CODE (valtype) == REAL_TYPE)\n+\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\"passing argument %d of %qE as integer rather \"\n+\t\t\t\"than floating due to prototype\",\n+\t\t\targnum, rname);\n+\t  if (INTEGRAL_TYPE_P (type)\n+\t      && TREE_CODE (valtype) == COMPLEX_TYPE)\n+\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\"passing argument %d of %qE as integer rather \"\n+\t\t\t\"than complex due to prototype\",\n+\t\t\targnum, rname);\n+\t  else if (TREE_CODE (type) == COMPLEX_TYPE\n+\t\t   && TREE_CODE (valtype) == REAL_TYPE)\n+\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\"passing argument %d of %qE as complex rather \"\n+\t\t\t\"than floating due to prototype\",\n+\t\t\targnum, rname);\n+\t  else if (TREE_CODE (type) == REAL_TYPE\n+\t\t   && INTEGRAL_TYPE_P (valtype))\n+\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\"passing argument %d of %qE as floating rather \"\n+\t\t\t\"than integer due to prototype\",\n+\t\t\targnum, rname);\n+\t  else if (TREE_CODE (type) == COMPLEX_TYPE\n+\t\t   && INTEGRAL_TYPE_P (valtype))\n+\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\"passing argument %d of %qE as complex rather \"\n+\t\t\t\"than integer due to prototype\",\n+\t\t\targnum, rname);\n+\t  else if (TREE_CODE (type) == REAL_TYPE\n+\t\t   && TREE_CODE (valtype) == COMPLEX_TYPE)\n+\t    warning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t\"passing argument %d of %qE as floating rather \"\n+\t\t\t\"than complex due to prototype\",\n+\t\t\targnum, rname);\n+\t  /* ??? At some point, messages should be written about\n+\t     conversions between complex types, but that's too messy\n+\t     to do now.  */\n+\t  else if (TREE_CODE (type) == REAL_TYPE\n+\t\t   && TREE_CODE (valtype) == REAL_TYPE)\n+\t    {\n+\t      /* Warn if any argument is passed as `float',\n+\t\t since without a prototype it would be `double'.  */\n+\t      if (formal_prec == TYPE_PRECISION (float_type_node)\n+\t\t  && type != dfloat32_type_node)\n+\t\twarning_at (ploc, 0,\n+\t\t\t    \"passing argument %d of %qE as %<float%> \"\n+\t\t\t    \"rather than %<double%> due to prototype\",\n+\t\t\t    argnum, rname);\n+\n+\t      /* Warn if mismatch between argument and prototype\n+\t\t for decimal float types.  Warn of conversions with\n+\t\t binary float types and of precision narrowing due to\n+\t\t prototype.  */\n+\t      else if (type != valtype\n+\t\t       && (type == dfloat32_type_node\n+\t\t\t   || type == dfloat64_type_node\n+\t\t\t   || type == dfloat128_type_node\n+\t\t\t   || valtype == dfloat32_type_node\n+\t\t\t   || valtype == dfloat64_type_node\n+\t\t\t   || valtype == dfloat128_type_node)\n+\t\t       && (formal_prec\n+\t\t\t   <= TYPE_PRECISION (valtype)\n+\t\t\t   || (type == dfloat128_type_node\n+\t\t\t       && (valtype\n+\t\t\t\t   != dfloat64_type_node\n+\t\t\t\t   && (valtype\n+\t\t\t\t       != dfloat32_type_node)))\n+\t\t\t   || (type == dfloat64_type_node\n+\t\t\t       && (valtype\n+\t\t\t\t   != dfloat32_type_node))))\n+\t\twarning_at (ploc, 0,\n+\t\t\t    \"passing argument %d of %qE as %qT \"\n+\t\t\t    \"rather than %qT due to prototype\",\n+\t\t\t    argnum, rname, type, valtype);\n+\n+\t    }\n+\t  /* Detect integer changing in width or signedness.\n+\t     These warnings are only activated with\n+\t     -Wtraditional-conversion, not with -Wtraditional.  */\n+\t  else if (warn_traditional_conversion\n+\t\t   && INTEGRAL_TYPE_P (type)\n+\t\t   && INTEGRAL_TYPE_P (valtype))\n+\t    {\n+\t      tree would_have_been = default_conversion (val);\n+\t      tree type1 = TREE_TYPE (would_have_been);\n+\n+\t      if (val == error_mark_node)\n+\t\t/* VAL could have been of incomplete type.  */;\n+\t      else if (TREE_CODE (type) == ENUMERAL_TYPE\n+\t\t       && (TYPE_MAIN_VARIANT (type)\n+\t\t\t   == TYPE_MAIN_VARIANT (valtype)))\n+\t\t/* No warning if function asks for enum\n+\t\t   and the actual arg is that enum type.  */\n+\t\t;\n+\t      else if (formal_prec != TYPE_PRECISION (type1))\n+\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t    \"passing argument %d of %qE \"\n+\t\t\t    \"with different width due to prototype\",\n+\t\t\t    argnum, rname);\n+\t      else if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (type1))\n+\t\t;\n+\t      /* Don't complain if the formal parameter type\n+\t\t is an enum, because we can't tell now whether\n+\t\t the value was an enum--even the same enum.  */\n+\t      else if (TREE_CODE (type) == ENUMERAL_TYPE)\n+\t\t;\n+\t      else if (TREE_CODE (val) == INTEGER_CST\n+\t\t       && int_fits_type_p (val, type))\n+\t\t/* Change in signedness doesn't matter\n+\t\t   if a constant value is unaffected.  */\n+\t\t;\n+\t      /* If the value is extended from a narrower\n+\t\t unsigned type, it doesn't matter whether we\n+\t\t pass it as signed or unsigned; the value\n+\t\t certainly is the same either way.  */\n+\t      else if (TYPE_PRECISION (valtype) < TYPE_PRECISION (type)\n+\t\t       && TYPE_UNSIGNED (valtype))\n+\t\t;\n+\t      else if (TYPE_UNSIGNED (type))\n+\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t    \"passing argument %d of %qE \"\n+\t\t\t    \"as unsigned due to prototype\",\n+\t\t\t    argnum, rname);\n+\t      else\n+\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t\t    \"passing argument %d of %qE \"\n+\t\t\t    \"as signed due to prototype\",\n+\t\t\t    argnum, rname);\n+\t    }\n+\t}\n+\n+      /* Possibly restore an EXCESS_PRECISION_EXPR for the\n+\t sake of better warnings from convert_and_check.  */\n+      if (excess_precision)\n+\tval = build1 (EXCESS_PRECISION_EXPR, valtype, val);\n+\n+      parmval = convert_for_assignment (ploc, ploc, type,\n+\t\t\t\t\tval, origtype, ic_argpass,\n+\t\t\t\t\tnpc, fundecl, function,\n+\t\t\t\t\tparmnum + 1, warnopt);\n+\n+      if (targetm.calls.promote_prototypes (fundecl ? TREE_TYPE (fundecl) : 0)\n+\t  && INTEGRAL_TYPE_P (type)\n+\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n+\tparmval = default_conversion (parmval);\n+    }\n+\n+  return parmval;\n+}\n+\n /* Convert the argument expressions in the vector VALUES\n    to the types in the list TYPELIST.\n \n@@ -3209,7 +3392,6 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t\t   vec<tree, va_gc> *values, vec<tree, va_gc> *origtypes,\n \t\t   tree function, tree fundecl)\n {\n-  tree typetail, val;\n   unsigned int parmnum;\n   bool error_args = false;\n   const bool type_generic = fundecl\n@@ -3227,50 +3409,69 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n   /* Handle an ObjC selector specially for diagnostics.  */\n   selector = objc_message_selector ();\n \n+  /* For a call to a built-in function declared without a prototype,\n+     set to the built-in function's argument list.  */\n+  tree builtin_typelist = NULL_TREE;\n+\n   /* For type-generic built-in functions, determine whether excess\n      precision should be removed (classification) or not\n      (comparison).  */\n-  if (type_generic\n+  if (fundecl\n       && fndecl_built_in_p (fundecl, BUILT_IN_NORMAL))\n     {\n-      switch (DECL_FUNCTION_CODE (fundecl))\n+      built_in_function code = DECL_FUNCTION_CODE (fundecl);\n+      if (C_DECL_BUILTIN_PROTOTYPE (fundecl))\n \t{\n-\tcase BUILT_IN_ISFINITE:\n-\tcase BUILT_IN_ISINF:\n-\tcase BUILT_IN_ISINF_SIGN:\n-\tcase BUILT_IN_ISNAN:\n-\tcase BUILT_IN_ISNORMAL:\n-\tcase BUILT_IN_FPCLASSIFY:\n-\t  type_generic_remove_excess_precision = true;\n-\t  break;\n+\t  if (tree bdecl = builtin_decl_implicit (code))\n+\t    builtin_typelist = TYPE_ARG_TYPES (TREE_TYPE (bdecl));\n+\t}\n \n-\tcase BUILT_IN_ADD_OVERFLOW_P:\n-\tcase BUILT_IN_SUB_OVERFLOW_P:\n-\tcase BUILT_IN_MUL_OVERFLOW_P:\n-\t  /* The last argument of these type-generic builtins\n-\t     should not be promoted.  */\n-\t  type_generic_overflow_p = true;\n-\t  break;\n+      /* For type-generic built-in functions, determine whether excess\n+\t precision should be removed (classification) or not\n+\t (comparison).  */\n+      if (type_generic)\n+\tswitch (code)\n+\t  {\n+\t  case BUILT_IN_ISFINITE:\n+\t  case BUILT_IN_ISINF:\n+\t  case BUILT_IN_ISINF_SIGN:\n+\t  case BUILT_IN_ISNAN:\n+\t  case BUILT_IN_ISNORMAL:\n+\t  case BUILT_IN_FPCLASSIFY:\n+\t    type_generic_remove_excess_precision = true;\n+\t    break;\n \n-\tdefault:\n-\t  break;\n-\t}\n+\t  case BUILT_IN_ADD_OVERFLOW_P:\n+\t  case BUILT_IN_SUB_OVERFLOW_P:\n+\t  case BUILT_IN_MUL_OVERFLOW_P:\n+\t    /* The last argument of these type-generic builtins\n+\t       should not be promoted.  */\n+\t    type_generic_overflow_p = true;\n+\t    break;\n+\n+\t  default:\n+\t    break;\n+\t  }\n     }\n \n   /* Scan the given expressions and types, producing individual\n      converted arguments.  */\n \n-  for (typetail = typelist, parmnum = 0;\n+  tree typetail, builtin_typetail, val;\n+  for (typetail = typelist,\n+\t builtin_typetail = builtin_typelist,\n+\t parmnum = 0;\n        values && values->iterate (parmnum, &val);\n        ++parmnum)\n     {\n-      tree type = typetail ? TREE_VALUE (typetail) : 0;\n+      tree type = typetail ? TREE_VALUE (typetail) : NULL_TREE;\n+      tree builtin_type = (builtin_typetail\n+\t\t\t   ? TREE_VALUE (builtin_typetail) : NULL_TREE);\n       tree valtype = TREE_TYPE (val);\n       tree rname = function;\n       int argnum = parmnum + 1;\n       const char *invalid_func_diag;\n       bool excess_precision = false;\n-      bool npc;\n       tree parmval;\n       /* Some __atomic_* builtins have additional hidden argument at\n \t position 0.  */\n@@ -3289,13 +3490,25 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t  return error_args ? -1 : (int) parmnum;\n \t}\n \n+      if (builtin_type == void_type_node)\n+\t{\n+\t  warning_at (loc, OPT_Wbuiltin_declaration_mismatch,\n+\t\t      \"too many arguments to built-in function %qE \"\n+\t\t      \"expecting %d\",\n+\t\t      function, parmnum);\n+\n+\t  inform_declaration (fundecl);\n+\t  builtin_typetail = NULL_TREE;\n+\t}\n+\n       if (selector && argnum > 2)\n \t{\n \t  rname = selector;\n \t  argnum -= 2;\n \t}\n \n-      npc = null_pointer_constant_p (val);\n+      /* Determine if VAL is a null pointer constant before folding it.  */\n+      bool npc = null_pointer_constant_p (val);\n \n       /* If there is excess precision and a prototype, convert once to\n \t the required type rather than converting via the semantic\n@@ -3340,172 +3553,10 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \n       if (type != NULL_TREE)\n \t{\n-\t  /* Formal parm type is specified by a function prototype.  */\n-\n-\t  if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n-\t    {\n-\t      error_at (ploc, \"type of formal parameter %d is incomplete\",\n-\t\t\tparmnum + 1);\n-\t      parmval = val;\n-\t    }\n-\t  else\n-\t    {\n-\t      tree origtype;\n-\n-\t      /* Optionally warn about conversions that\n-\t\t differ from the default conversions.  */\n-\t      if (warn_traditional_conversion || warn_traditional)\n-\t\t{\n-\t\t  unsigned int formal_prec = TYPE_PRECISION (type);\n-\n-\t\t  if (INTEGRAL_TYPE_P (type)\n-\t\t      && TREE_CODE (valtype) == REAL_TYPE)\n-\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\t\"passing argument %d of %qE as integer rather \"\n-\t\t\t\t\"than floating due to prototype\",\n-\t\t\t\targnum, rname);\n-\t\t  if (INTEGRAL_TYPE_P (type)\n-\t\t      && TREE_CODE (valtype) == COMPLEX_TYPE)\n-\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\t\"passing argument %d of %qE as integer rather \"\n-\t\t\t\t\"than complex due to prototype\",\n-\t\t\t\targnum, rname);\n-\t\t  else if (TREE_CODE (type) == COMPLEX_TYPE\n-\t\t\t   && TREE_CODE (valtype) == REAL_TYPE)\n-\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\t\"passing argument %d of %qE as complex rather \"\n-\t\t\t\t\"than floating due to prototype\",\n-\t\t\t\targnum, rname);\n-\t\t  else if (TREE_CODE (type) == REAL_TYPE\n-\t\t\t   && INTEGRAL_TYPE_P (valtype))\n-\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\t\"passing argument %d of %qE as floating rather \"\n-\t\t\t\t\"than integer due to prototype\",\n-\t\t\t\targnum, rname);\n-\t\t  else if (TREE_CODE (type) == COMPLEX_TYPE\n-\t\t\t   && INTEGRAL_TYPE_P (valtype))\n-\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\t\"passing argument %d of %qE as complex rather \"\n-\t\t\t\t\"than integer due to prototype\",\n-\t\t\t\targnum, rname);\n-\t\t  else if (TREE_CODE (type) == REAL_TYPE\n-\t\t\t   && TREE_CODE (valtype) == COMPLEX_TYPE)\n-\t\t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\t\"passing argument %d of %qE as floating rather \"\n-\t\t\t\t\"than complex due to prototype\",\n-\t\t\t\targnum, rname);\n-\t\t  /* ??? At some point, messages should be written about\n-\t\t     conversions between complex types, but that's too messy\n-\t\t     to do now.  */\n-\t\t  else if (TREE_CODE (type) == REAL_TYPE\n-\t\t\t   && TREE_CODE (valtype) == REAL_TYPE)\n-\t\t    {\n-\t\t      /* Warn if any argument is passed as `float',\n-\t\t\t since without a prototype it would be `double'.  */\n-\t\t      if (formal_prec == TYPE_PRECISION (float_type_node)\n-\t\t\t  && type != dfloat32_type_node)\n-\t\t\twarning_at (ploc, 0,\n-\t\t\t\t    \"passing argument %d of %qE as %<float%> \"\n-\t\t\t\t    \"rather than %<double%> due to prototype\",\n-\t\t\t\t    argnum, rname);\n-\n-\t\t      /* Warn if mismatch between argument and prototype\n-\t\t\t for decimal float types.  Warn of conversions with\n-\t\t\t binary float types and of precision narrowing due to\n-\t\t\t prototype. */\n- \t\t      else if (type != valtype\n-\t\t\t       && (type == dfloat32_type_node\n-\t\t\t\t   || type == dfloat64_type_node\n-\t\t\t\t   || type == dfloat128_type_node\n-\t\t\t\t   || valtype == dfloat32_type_node\n-\t\t\t\t   || valtype == dfloat64_type_node\n-\t\t\t\t   || valtype == dfloat128_type_node)\n-\t\t\t       && (formal_prec\n-\t\t\t\t   <= TYPE_PRECISION (valtype)\n-\t\t\t\t   || (type == dfloat128_type_node\n-\t\t\t\t       && (valtype\n-\t\t\t\t\t   != dfloat64_type_node\n-\t\t\t\t\t   && (valtype\n-\t\t\t\t\t       != dfloat32_type_node)))\n-\t\t\t\t   || (type == dfloat64_type_node\n-\t\t\t\t       && (valtype\n-\t\t\t\t\t   != dfloat32_type_node))))\n-\t\t\twarning_at (ploc, 0,\n-\t\t\t\t    \"passing argument %d of %qE as %qT \"\n-\t\t\t\t    \"rather than %qT due to prototype\",\n-\t\t\t\t    argnum, rname, type, valtype);\n-\n-\t\t    }\n-\t\t  /* Detect integer changing in width or signedness.\n-\t\t     These warnings are only activated with\n-\t\t     -Wtraditional-conversion, not with -Wtraditional.  */\n-\t\t  else if (warn_traditional_conversion\n-\t\t\t   && INTEGRAL_TYPE_P (type)\n-\t\t\t   && INTEGRAL_TYPE_P (valtype))\n-\t\t    {\n-\t\t      tree would_have_been = default_conversion (val);\n-\t\t      tree type1 = TREE_TYPE (would_have_been);\n-\n-\t\t      if (val == error_mark_node)\n-\t\t\t/* VAL could have been of incomplete type.  */;\n-\t\t      else if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t\t\t       && (TYPE_MAIN_VARIANT (type)\n-\t\t\t\t   == TYPE_MAIN_VARIANT (valtype)))\n-\t\t\t/* No warning if function asks for enum\n-\t\t\t   and the actual arg is that enum type.  */\n-\t\t\t;\n-\t\t      else if (formal_prec != TYPE_PRECISION (type1))\n-\t\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\t    \"passing argument %d of %qE \"\n-\t\t\t\t    \"with different width due to prototype\",\n-\t\t\t\t    argnum, rname);\n-\t\t      else if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (type1))\n-\t\t\t;\n-\t\t      /* Don't complain if the formal parameter type\n-\t\t\t is an enum, because we can't tell now whether\n-\t\t\t the value was an enum--even the same enum.  */\n-\t\t      else if (TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t\t;\n-\t\t      else if (TREE_CODE (val) == INTEGER_CST\n-\t\t\t       && int_fits_type_p (val, type))\n-\t\t\t/* Change in signedness doesn't matter\n-\t\t\t   if a constant value is unaffected.  */\n-\t\t\t;\n-\t\t      /* If the value is extended from a narrower\n-\t\t\t unsigned type, it doesn't matter whether we\n-\t\t\t pass it as signed or unsigned; the value\n-\t\t\t certainly is the same either way.  */\n-\t\t      else if (TYPE_PRECISION (valtype) < TYPE_PRECISION (type)\n-\t\t\t       && TYPE_UNSIGNED (valtype))\n-\t\t\t;\n-\t\t      else if (TYPE_UNSIGNED (type))\n-\t\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\t    \"passing argument %d of %qE \"\n-\t\t\t\t    \"as unsigned due to prototype\",\n-\t\t\t\t    argnum, rname);\n-\t\t      else\n-\t\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\t    \"passing argument %d of %qE \"\n-\t\t\t\t    \"as signed due to prototype\",\n-\t\t\t\t    argnum, rname);\n-\t\t    }\n-\t\t}\n-\n-\t      /* Possibly restore an EXCESS_PRECISION_EXPR for the\n-\t\t sake of better warnings from convert_and_check.  */\n-\t      if (excess_precision)\n-\t\tval = build1 (EXCESS_PRECISION_EXPR, valtype, val);\n-\t      origtype = (!origtypes) ? NULL_TREE : (*origtypes)[parmnum];\n-\t      parmval = convert_for_assignment (loc, ploc, type,\n-\t\t\t\t\t\tval, origtype, ic_argpass,\n-\t\t\t\t\t\tnpc, fundecl, function,\n-\t\t\t\t\t\tparmnum + 1);\n-\n-\t      if (targetm.calls.promote_prototypes (fundecl ? TREE_TYPE (fundecl) : 0)\n-\t\t  && INTEGRAL_TYPE_P (type)\n-\t\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n-\t\tparmval = default_conversion (parmval);\n-\t    }\n+\t  tree origtype = (!origtypes) ? NULL_TREE : (*origtypes)[parmnum];\n+\t  parmval = convert_argument (ploc, function, fundecl, type, origtype,\n+\t\t\t\t      val, npc, rname, parmnum, argnum,\n+\t\t\t\t      excess_precision, 0);\n \t}\n       else if (promote_float_arg)\n         {\n@@ -3547,8 +3598,24 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n       if (parmval == error_mark_node)\n \terror_args = true;\n \n+      if (!type && builtin_type && TREE_CODE (builtin_type) != VOID_TYPE)\n+\t{\n+\t  /* For a call to a built-in function declared without a prototype,\n+\t     perform the conversions from the argument to the expected type\n+\t     but issue warnings rather than errors for any mismatches.\n+\t     Ignore the converted argument and use the PARMVAL obtained\n+\t     above by applying default conversions instead.  */\n+\t  tree origtype = (!origtypes) ? NULL_TREE : (*origtypes)[parmnum];\n+\t  convert_argument (ploc, function, fundecl, builtin_type, origtype,\n+\t\t\t    val, npc, rname, parmnum, argnum, excess_precision,\n+\t\t\t    OPT_Wbuiltin_declaration_mismatch);\n+\t}\n+\n       if (typetail)\n \ttypetail = TREE_CHAIN (typetail);\n+\n+      if (builtin_typetail)\n+\tbuiltin_typetail = TREE_CHAIN (builtin_typetail);\n     }\n \n   gcc_assert (parmnum == vec_safe_length (values));\n@@ -3560,6 +3627,18 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n       return -1;\n     }\n \n+  if (builtin_typetail && TREE_VALUE (builtin_typetail) != void_type_node)\n+    {\n+      unsigned nargs = parmnum;\n+      for (tree t = builtin_typetail; t; t = TREE_CHAIN (t))\n+\t++nargs;\n+\n+      warning_at (loc, OPT_Wbuiltin_declaration_mismatch,\n+\t\t  \"too few arguments to built-in function %qE expecting %u\",\n+\t\t  function, nargs - 1);\n+      inform_declaration (fundecl);\n+    }\n+\n   return error_args ? -1 : (int) parmnum;\n }\n \f\n@@ -4922,6 +5001,40 @@ ep_convert_and_check (location_t loc, tree type, tree expr,\n   return convert (type, expr);\n }\n \n+/* If EXPR refers to a built-in declared without a prototype returns\n+   the actual type of the built-in and, if non-null, set *BLTIN to\n+   a pointer to the built-in.  Otherwise return the type of EXPR\n+   and clear *BLTIN if non-null.  */\n+\n+static tree\n+type_or_builtin_type (tree expr, tree *bltin = NULL)\n+{\n+  tree dummy;\n+  if (!bltin)\n+    bltin = &dummy;\n+\n+  *bltin = NULL_TREE;\n+\n+  tree type = TREE_TYPE (expr);\n+  if (TREE_CODE (expr) != ADDR_EXPR)\n+    return type;\n+\n+  tree oper = TREE_OPERAND (expr, 0);\n+  if (!DECL_P (oper)\n+      || TREE_CODE (oper) != FUNCTION_DECL\n+      || !fndecl_built_in_p (oper, BUILT_IN_NORMAL))\n+    return type;\n+\n+  built_in_function code = DECL_FUNCTION_CODE (oper);\n+  if (!C_DECL_BUILTIN_PROTOTYPE (oper))\n+    return type;\n+\n+  if ((*bltin = builtin_decl_implicit (code)))\n+    type = build_pointer_type (TREE_TYPE (*bltin));\n+\n+  return type;\n+}\n+\n /* Build and return a conditional expression IFEXP ? OP1 : OP2.  If\n    IFEXP_BCP then the condition is a call to __builtin_constant_p, and\n    if folded to an integer constant then the unselected half may\n@@ -4966,9 +5079,11 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n       || TREE_CODE (TREE_TYPE (op2)) == ERROR_MARK)\n     return error_mark_node;\n \n-  type1 = TREE_TYPE (op1);\n+  tree bltin1 = NULL_TREE;\n+  tree bltin2 = NULL_TREE;\n+  type1 = type_or_builtin_type (op1, &bltin1);\n   code1 = TREE_CODE (type1);\n-  type2 = TREE_TYPE (op2);\n+  type2 = type_or_builtin_type (op2, &bltin2);\n   code2 = TREE_CODE (type2);\n \n   if (code1 == POINTER_TYPE && reject_gcc_builtin (op1))\n@@ -5206,9 +5321,14 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n       else\n \t{\n \t  int qual = ENCODE_QUAL_ADDR_SPACE (as_common);\n-\n-\t  pedwarn (colon_loc, 0,\n-\t\t   \"pointer type mismatch in conditional expression\");\n+\t  if (bltin1 && bltin2)\n+\t    warning_at (colon_loc, OPT_Wincompatible_pointer_types,\n+\t\t\t\"pointer type mismatch between %qT and %qT \"\n+\t\t\t\"of %qD and %qD in conditional expression\",\n+\t\t\ttype1, type2, bltin1, bltin2);\n+\t  else\n+\t    pedwarn (colon_loc, 0,\n+\t\t     \"pointer type mismatch in conditional expression\");\n \t  result_type = build_pointer_type\n \t\t\t  (build_qualified_type (void_type_node, qual));\n \t}\n@@ -6322,6 +6442,46 @@ inform_for_arg (tree fundecl, location_t ploc, int parmnum,\n \t  expected_type, actual_type);\n }\n \n+/* Issue a warning when an argument of ARGTYPE is passed to a built-in\n+   function FUNDECL declared without prototype to parameter PARMNUM of\n+   PARMTYPE when ARGTYPE does not promote to PARMTYPE.  */\n+\n+static void\n+maybe_warn_builtin_no_proto_arg (location_t loc, tree fundecl, int parmnum,\n+\t\t\t\t tree parmtype, tree argtype)\n+{\n+  tree_code parmcode = TREE_CODE (parmtype);\n+  tree_code argcode = TREE_CODE (argtype);\n+  tree promoted = c_type_promotes_to (argtype);\n+\n+  /* Avoid warning for enum arguments that promote to an integer type\n+     of the same size/mode.  */\n+  if (parmcode == INTEGER_TYPE\n+      && argcode == ENUMERAL_TYPE\n+      && TYPE_MODE (parmtype) == TYPE_MODE (argtype))\n+    return;\n+\n+  if (parmcode == argcode\n+      && TYPE_MAIN_VARIANT (parmtype) == TYPE_MAIN_VARIANT (promoted))\n+    return;\n+\n+  /* This diagnoses even signed/unsigned mismatches.  Those might be\n+     safe in many cases but GCC may emit suboptimal code for them so\n+     warning on those cases drives efficiency improvements.  */\n+  if (warning_at (loc, OPT_Wbuiltin_declaration_mismatch,\n+\t\t  TYPE_MAIN_VARIANT (promoted) == argtype\n+\t\t  ? G_(\"%qD argument %d type is %qT where %qT is expected \"\n+\t\t       \"in a call to built-in function declared without \"\n+\t\t       \"prototype\")\n+\t\t  : G_(\"%qD argument %d promotes to %qT where %qT is expected \"\n+\t\t       \"in a call to built-in function declared without \"\n+\t\t       \"prototype\"),\n+\t\t  fundecl, parmnum, promoted, parmtype))\n+    inform (DECL_SOURCE_LOCATION (fundecl),\n+\t    \"built-in %qD declared here\",\n+\t    fundecl);\n+}\n+\n /* Convert value RHS to type TYPE as preparation for an assignment to\n    an lvalue of type TYPE.  If ORIGTYPE is not NULL_TREE, it is the\n    original type of RHS; this differs from TREE_TYPE (RHS) for enum\n@@ -6346,13 +6506,16 @@ inform_for_arg (tree fundecl, location_t ploc, int parmnum,\n \t    ^\n \n    FUNCTION is a tree for the function being called.\n-   PARMNUM is the number of the argument, for printing in error messages.  */\n+   PARMNUM is the number of the argument, for printing in error messages.\n+   WARNOPT may be set to a warning option to issue the corresponding warning\n+   rather than an error for invalid conversions.  Used for calls to built-in\n+   functions declared without a prototype.  */\n \n static tree\n convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t\ttree rhs, tree origtype, enum impl_conv errtype,\n \t\t\tbool null_pointer_constant, tree fundecl,\n-\t\t\ttree function, int parmnum)\n+\t\t\ttree function, int parmnum, int warnopt /* = 0 */)\n {\n   enum tree_code codel = TREE_CODE (type);\n   tree orig_rhs = rhs;\n@@ -6550,7 +6713,11 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t an unprototyped function, it is compile-time undefined;\n \t making it a constraint in that case was rejected in\n \t DR#252.  */\n-      error_at (location, \"void value not ignored as it ought to be\");\n+      const char msg[] = \"void value not ignored as it ought to be\";\n+      if (warnopt)\n+\twarning_at (location, warnopt, msg);\n+      else\n+\terror_at (location, msg);\n       return error_mark_node;\n     }\n   rhs = require_complete_type (location, rhs);\n@@ -6566,7 +6733,11 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n     {\n       if (!lvalue_p (rhs))\n \t{\n-\t  error_at (location, \"cannot pass rvalue to reference parameter\");\n+\t  const char msg[] = \"cannot pass rvalue to reference parameter\";\n+\t  if (warnopt)\n+\t    warning_at (location, warnopt, msg);\n+\t  else\n+\t    error_at (location, msg);\n \t  return error_mark_node;\n \t}\n       if (!c_mark_addressable (rhs))\n@@ -6578,7 +6749,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t\t\t    build_pointer_type (TREE_TYPE (type)),\n \t\t\t\t    rhs, origtype, errtype,\n \t\t\t\t    null_pointer_constant, fundecl, function,\n-\t\t\t\t    parmnum);\n+\t\t\t\t    parmnum, warnopt);\n       if (rhs == error_mark_node)\n \treturn error_mark_node;\n \n@@ -6600,15 +6771,18 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t       || coder == ENUMERAL_TYPE || coder == COMPLEX_TYPE\n \t       || coder == BOOLEAN_TYPE))\n     {\n-      tree ret;\n+      if (warnopt && errtype == ic_argpass)\n+\tmaybe_warn_builtin_no_proto_arg (expr_loc, fundecl, parmnum, type,\n+\t\t\t\t\t rhstype);\n+\n       bool save = in_late_binary_op;\n       if (codel == BOOLEAN_TYPE || codel == COMPLEX_TYPE\n \t  || (coder == REAL_TYPE\n \t      && (codel == INTEGER_TYPE || codel == ENUMERAL_TYPE)\n \t      && sanitize_flags_p (SANITIZE_FLOAT_CAST)))\n \tin_late_binary_op = true;\n-      ret = convert_and_check (expr_loc != UNKNOWN_LOCATION\n-\t\t\t       ? expr_loc : location, type, orig_rhs);\n+      tree ret = convert_and_check (expr_loc != UNKNOWN_LOCATION\n+\t\t\t\t    ? expr_loc : location, type, orig_rhs);\n       in_late_binary_op = save;\n       return ret;\n     }\n@@ -6742,6 +6916,12 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n   else if ((codel == POINTER_TYPE || codel == REFERENCE_TYPE)\n \t   && (coder == codel))\n     {\n+      /* If RHS refers to a built-in declared without a prototype\n+\t BLTIN is the declaration of the built-in with a prototype\n+\t and RHSTYPE is set to the actual type of the built-in.  */\n+      tree bltin;\n+      rhstype = type_or_builtin_type (rhs, &bltin);\n+\n       tree ttl = TREE_TYPE (type);\n       tree ttr = TREE_TYPE (rhstype);\n       tree mvl = ttl;\n@@ -6805,21 +6985,45 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t  switch (errtype)\n \t    {\n \t    case ic_argpass:\n-\t      error_at (expr_loc, \"passing argument %d of %qE from pointer to \"\n-\t\t\t\"non-enclosed address space\", parmnum, rname);\n+\t      {\n+\t\tconst char msg[] = G_(\"passing argument %d of %qE from \"\n+\t\t\t\t      \"pointer to non-enclosed address space\");\n+\t\tif (warnopt)\n+\t\t  warning_at (expr_loc, warnopt, msg, parmnum, rname);\n+\t\telse\n+\t\t  error_at (expr_loc, msg, parmnum, rname);\n \t      break;\n+\t      }\n \t    case ic_assign:\n-\t      error_at (location, \"assignment from pointer to \"\n-\t\t\t\"non-enclosed address space\");\n-\t      break;\n+\t      {\n+\t\tconst char msg[] = G_(\"assignment from pointer to \"\n+\t\t\t\t      \"non-enclosed address space\");\n+\t\tif (warnopt)\n+\t\t  warning_at (location, warnopt, msg);\n+\t\telse\n+\t\t  error_at (location, msg);\n+\t\tbreak;\n+\t      }\n \t    case ic_init:\n-\t      error_at (location, \"initialization from pointer to \"\n-\t\t\t\"non-enclosed address space\");\n-\t      break;\n+\t      {\n+\t\tconst char msg[] = G_(\"initialization from pointer to \"\n+\t\t\t\t      \"non-enclosed address space\");\n+\t\tif (warnopt)\n+\t\t  warning_at (location, warnopt, msg);\n+\t\telse\n+\t\t  error_at (location, msg);\n+\t\tbreak;\n+\t      }\n \t    case ic_return:\n-\t      error_at (location, \"return from pointer to \"\n-\t\t\t\"non-enclosed address space\");\n-\t      break;\n+\t      {\n+\t\tconst char msg[] = G_(\"return from pointer to \"\n+\t\t\t\t      \"non-enclosed address space\");\n+\t\tif (warnopt)\n+\t\t  warning_at (location, warnopt, msg);\n+\t\telse\n+\t\t  error_at (location, msg);\n+\t\tbreak;\n+\t      }\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -7017,19 +7221,38 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t      }\n \t      break;\n \t    case ic_assign:\n-\t      pedwarn (location, OPT_Wincompatible_pointer_types,\n-\t\t       \"assignment to %qT from incompatible pointer type %qT\",\n-\t\t       type, rhstype);\n+\t      if (bltin)\n+\t\tpedwarn (location, OPT_Wincompatible_pointer_types,\n+\t\t\t \"assignment to %qT from pointer to \"\n+\t\t\t \"%qD with incompatible type %qT\",\n+\t\t\t type, bltin, rhstype);\n+\t      else\n+\t\tpedwarn (location, OPT_Wincompatible_pointer_types,\n+\t\t\t \"assignment to %qT from incompatible pointer type %qT\",\n+\t\t\t type, rhstype);\n \t      break;\n \t    case ic_init:\n-\t      pedwarn_init (location, OPT_Wincompatible_pointer_types,\n-\t\t\t    \"initialization of %qT from incompatible pointer \"\n-\t\t\t    \"type %qT\", type, rhstype);\n+\t      if (bltin)\n+\t\tpedwarn_init (location, OPT_Wincompatible_pointer_types,\n+\t\t\t      \"initialization of %qT from pointer to \"\n+\t\t\t      \"%qD with incompatible type %qT\",\n+\t\t\t      type, bltin, rhstype);\n+\t      else\n+\t\tpedwarn_init (location, OPT_Wincompatible_pointer_types,\n+\t\t\t      \"initialization of %qT from incompatible \"\n+\t\t\t      \"pointer type %qT\",\n+\t\t\t      type, rhstype);\n \t      break;\n \t    case ic_return:\n-\t      pedwarn (location, OPT_Wincompatible_pointer_types,\n-\t\t       \"returning %qT from a function with incompatible \"\n-\t\t       \"return type %qT\", rhstype, type);\n+\t      if (bltin)\n+\t\tpedwarn (location, OPT_Wincompatible_pointer_types,\n+\t\t\t \"returning pointer to %qD of type %qT from \"\n+\t\t\t \"a function with incompatible type %qT\",\n+\t\t\t bltin, rhstype, type);\n+\t      else\n+\t\tpedwarn (location, OPT_Wincompatible_pointer_types,\n+\t\t\t \"returning %qT from a function with incompatible \"\n+\t\t\t \"return type %qT\", rhstype, type);\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n@@ -7042,7 +7265,11 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n     {\n       /* ??? This should not be an error when inlining calls to\n \t unprototyped functions.  */\n-      error_at (location, \"invalid use of non-lvalue array\");\n+      const char msg[] = \"invalid use of non-lvalue array\";\n+      if (warnopt)\n+\twarning_at (location, warnopt, msg);\n+      else\n+\terror_at (location, msg);\n       return error_mark_node;\n     }\n   else if (codel == POINTER_TYPE && coder == INTEGER_TYPE)\n@@ -7138,25 +7365,44 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \tauto_diagnostic_group d;\n \trange_label_for_type_mismatch rhs_label (rhstype, type);\n \tgcc_rich_location richloc (expr_loc, &rhs_label);\n-\terror_at (&richloc, \"incompatible type for argument %d of %qE\", parmnum,\n-\t\t  rname);\n+\tconst char msg[] = G_(\"incompatible type for argument %d of %qE\");\n+\tif (warnopt)\n+\t  warning_at (expr_loc, warnopt, msg, parmnum, rname);\n+\telse\n+\t  error_at (&richloc, msg, parmnum, rname);\n \tinform_for_arg (fundecl, expr_loc, parmnum, type, rhstype);\n       }\n       break;\n     case ic_assign:\n-      error_at (location, \"incompatible types when assigning to type %qT from \"\n-\t\t\"type %qT\", type, rhstype);\n-      break;\n+      {\n+\tconst char msg[]\n+\t  = G_(\"incompatible types when assigning to type %qT from type %qT\");\n+\tif (warnopt)\n+\t  warning_at (expr_loc, 0, msg, type, rhstype);\n+\telse\n+\t  error_at (expr_loc, msg, type, rhstype);\n+\tbreak;\n+      }\n     case ic_init:\n-      error_at (location,\n-\t\t\"incompatible types when initializing type %qT using type %qT\",\n-\t\ttype, rhstype);\n-      break;\n+      {\n+\tconst char msg[]\n+\t  = G_(\"incompatible types when initializing type %qT using type %qT\");\n+\tif (warnopt)\n+\t  warning_at (location, 0, msg, type, rhstype);\n+\telse\n+\t  error_at (location, msg, type, rhstype);\n+\tbreak;\n+      }\n     case ic_return:\n-      error_at (location,\n-\t\t\"incompatible types when returning type %qT but %qT was \"\n-\t\t\"expected\", rhstype, type);\n-      break;\n+      {\n+\tconst char msg[]\n+\t  = G_(\"incompatible types when returning type %qT but %qT was expected\");\n+\tif (warnopt)\n+\t  warning_at (location, 0, msg, rhstype, type);\n+\telse\n+\t  error_at (location, msg, rhstype, type);\n+\tbreak;\n+      }\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "1bf250146887e94d7ec63d1effdc5cb84fe911b8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -7063,9 +7063,26 @@ attributes.\n @item -Wno-builtin-declaration-mismatch\n @opindex Wno-builtin-declaration-mismatch\n @opindex Wbuiltin-declaration-mismatch\n-Warn if a built-in function is declared with the wrong signature or \n-as non-function.\n-This warning is enabled by default.\n+Warn if a built-in function is declared with an incompatible signature\n+or as a non-function, or when a built-in function declared with a type\n+that does not include a prototype is called with arguments whose promoted\n+types do not match those expected by the function.  When @option{-Wextra}\n+is specified, also warn when a built-in function that takes arguments is\n+declared without a prototype.  The @option{-Wno-builtin-declaration-mismatch}\n+warning is enabled by default.  To avoid the warning include the appropriate\n+header to bring the prototypes of built-in functions into scope.\n+\n+For example, the call to @code{memset} below is diagnosed by the warning\n+because the function expects a value of type @code{size_t} as its argument\n+but the type of @code{32} is @code{int}.  With @option{-Wextra},\n+the declaration of the function is diagnosed as well.\n+@smallexample\n+extern void* memset ();\n+void f (void *d)\n+@{\n+  memset (d, '\\0', 32);\n+@}\n+@end smallexample\n \n @item -Wno-builtin-macro-redefined\n @opindex Wno-builtin-macro-redefined"}, {"sha": "c2ec7861c122c72dc25e9467f2037bbcb79b57ed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -1,3 +1,29 @@\n+2018-11-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/83656\n+\t* gcc.dg/20021006-1.c\n+\t* gcc.dg/Wbuiltin-declaration-mismatch.c: New test.\n+\t* gcc.dg/Wbuiltin-declaration-mismatch-2.c: New test.\n+\t* gcc.dg/Wbuiltin-declaration-mismatch-3.c: New test.\n+\t* gcc.dg/Wbuiltin-declaration-mismatch-4.c: New test.\n+\t* gcc.dg/Walloca-16.c: Adjust.\n+\t* gcc.dg/Wrestrict-4.c: Adjust.\n+\t* gcc.dg/Wrestrict-5.c: Adjust.\n+\t* gcc.dg/atomic/stdatomic-generic.c: Adjust.\n+\t* gcc.dg/atomic/stdatomic-lockfree.c: Adjust.\n+\t* gcc.dg/initpri1.c: Adjust.\n+\t* gcc.dg/pr15698-1.c: Adjust.\n+\t* gcc.dg/pr69156.c: Adjust.\n+\t* gcc.dg/pr83463.c: Adjust.\n+\t* gcc.dg/redecl-4.c: Adjust.\n+\t* gcc.dg/tls/thr-init-2.c: Adjust.\n+\t* gcc.dg/torture/pr55890-2.c: Adjust.\n+\t* gcc.dg/torture/pr55890-3.c: Adjust.\n+\t* gcc.dg/torture/pr67741.c: Adjust.\n+\t* gcc.dg/torture/stackalign/sibcall-1.c: Adjust.\n+\t* gcc.dg/torture/tls/thr-init-1.c: Adjust.\n+\t* gcc.dg/tree-ssa/builtins-folding-gimple-ub.c: Adjust.\n+\n 2018-11-15  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/86246"}, {"sha": "92df2c57f6ef953b6505ad386d8fc7e730568081", "filename": "gcc/testsuite/gcc.dg/20021006-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2F20021006-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2F20021006-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20021006-1.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -2,7 +2,7 @@\n    This testcase was miscompiled on x86-64 due to wrong access to the struct\n    members.  */\n \n-extern void abort();\n+extern void abort(void);\n \n struct A {\n   long x;"}, {"sha": "7e16caacbf2dfc41db789575fdfc5b08ff21b11c", "filename": "gcc/testsuite/gcc.dg/Walloca-16.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-16.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -5,3 +5,5 @@\n \n void *alloca ();\n __typeof__(alloca ()) a () { return alloca (); }\n+\n+/* { dg-prune-output \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */"}, {"sha": "9d75cd8669cf47b5662ccb60004d35cdc3237d1c", "filename": "gcc/testsuite/gcc.dg/Wbuiltin-declaration-mismatch-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-2.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -0,0 +1,25 @@\n+/* PR c/83656 - missing -Wbuiltin-declaration-mismatch on declaration\n+   without prototype\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wextra\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+/* Verify that ordinary library built-ins are not diagnosed with -Wextra\n+   when they take no arguments (except in cases of return type mismatches).\n+   This is in anticipation that C may some day adopt the same syntax as\n+   C++ for declaring functions that take no arguments.  */\n+\n+void abort ();\n+\n+/* Verify that ordinary library built-ins are diagnosed with -Wextra\n+   when they take arguments.  */\n+\n+void* memcpy ();    /* { dg-warning \"declaration of built-in function .memcpy. without a prototype; expected .void \\\\\\*\\\\\\(void \\\\\\*, const void \\\\\\*, \\(long \\)*unsigned int\\\\\\).\" } */\n+void* memset ();    /* { dg-warning \"declaration of built-in function .memset. without a prototype; expected .void \\\\\\*\\\\\\(void \\\\\\*, int, *\\(long \\)*unsigned int\\\\\\).\" } */\n+size_t strlen ();   /* { dg-warning \"declaration of built-in function .strlen. without a prototype; expected .\\(long \\)*unsigned int\\\\\\(const char \\\\\\*\\\\\\).\" } */\n+\n+/* Variadic built-ins are diagnosed even without -Wextra (they are,\n+   in fact, diagnosed by default).  */\n+int printf ();      /* { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */\n+int sprintf ();     /* { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */"}, {"sha": "f2ec32595461e5fb9266693e8dbe50574d766e3a", "filename": "gcc/testsuite/gcc.dg/Wbuiltin-declaration-mismatch-3.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-3.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -0,0 +1,116 @@\n+/* PR c/83656 - missing -Wbuiltin-declaration-mismatch on declaration\n+   without prototype\n+   { dg-do compile }\n+   { dg-options \"-Wbuiltin-declaration-mismatch\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+/* Built-ins declared without a prototype are not diagnosed by default\n+   (without -Wextra) except when their return type doesn't match.  */\n+int abort ();       /* { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */\n+\n+/* Built-ins declared without a prototype are not diagnosed without -Wextra.  */\n+void exit ();\n+void* memcpy ();\n+void* memset ();\n+\n+\n+void test_call_abort (void)\n+{\n+  /* Verify that a valid call to abort() is not diagnosed.  */\n+  abort ();\n+\n+  /* Unfortunately, the incompatible declaration above makes GCC \"forget\"\n+     that abort() is a built-in and so the invalid calls below aren't\n+     diagnosed.  The only saving grace is that the invalid declaration\n+     that differs in the return type is diagnosed by default. */\n+  abort (1);        /* { dg-warning \"too many arguments to built-in function .abort. expecting 0\" \"pr?????\" { xfail *-*-* } } */\n+\n+  abort (1, 2);     /* { dg-warning \"too many arguments\" \"pr?????\" { xfail *-*-* } } */\n+}\n+\n+\n+void test_call_exit (void)\n+{\n+  /* Verify that valid calls to exit are not diagnosed.  */\n+  exit ('\\0');\n+  exit (0);\n+\n+  /* Also verify calls to the built-in.  */\n+  __builtin_exit ('\\0');\n+  __builtin_exit (0);\n+  __builtin_exit (0.0);\n+\n+  exit ();          /* { dg-warning \"too few arguments to built-in function 'exit' expecting 1\" } */\n+\n+  exit (1, 2);      /* { dg-warning \"too many arguments\" } */\n+\n+  /* Verify that passing incompatible arguments triggers a warning.  */\n+  exit (\"\");        /* { dg-warning \"\\\\\\[-Wint-conversion]\" } */\n+\n+  struct S { int i; } s = { 0 };\n+  exit (s);         /* { dg-warning \"incompatible type for argument 1\" } */\n+}\n+\n+\n+void test_call_memcpy (void *p, const void *q, size_t n)\n+{\n+  memcpy (p, q, n);\n+\n+  memcpy ();        /* { dg-warning \"too few arguments to built-in function 'memcpy' expecting 3\" } */\n+\n+  memcpy (p);       /* { dg-warning \"too few arguments to built-in function 'memcpy' expecting 3\" } */\n+\n+  memcpy (p, q);     /* { dg-warning \"too few arguments to built-in function 'memcpy' expecting 3\" } */\n+\n+  memcpy (q, p, n); /* { dg-warning \"\\\\\\[-Wdiscarded-qualifiers]\" } */\n+\n+  memcpy (p, n, q); /* { dg-warning \"\\\\\\[-Wint-conversion]\" } */\n+\n+  memcpy (p, q, n, 0); /* { dg-warning \"too many arguments to built-in function 'memcpy' expecting 3\" } */\n+}\n+\n+\n+typedef void* (memcpy_t)(void*, const void*, size_t);\n+typedef void* (memset_t)(void*, int, size_t);\n+\n+void test_init (void)\n+{\n+  /* Verify that initialization of a pointer by the address of a built-in\n+     function of a matching type declared without a prototype doesn't\n+     trigger a warning...  */\n+  memset_t *pmemset = memset;\n+\n+  /* ...but initialization by the address of an incompatible built-in\n+     does even without -Wextra.  */\n+  memcpy_t *pmemcpy = memset;           /* { dg-warning \"\\\\\\[-Wincompatible-pointer-types]\" } */\n+}\n+\n+\n+void test_assign (void)\n+{\n+  /* Same as above but for assignment.  */\n+  memset_t *pmemset;\n+  pmemset = memset;\n+\n+  memcpy_t *pmemcpy;\n+  pmemcpy = memset;                     /* { dg-warning \"\\\\\\[-Wincompatible-pointer-types]\" } */\n+}\n+\n+\n+/* Verify that passing built-ins declared without a prototype to\n+   functions that expect a pointer to a function of a specific type\n+   is diagnosed.  Ditto for return statements.  */\n+\n+void take_memcpy (memcpy_t*);\n+void take_any (int, ...);\n+\n+memset_t* pass_args (int i)\n+{\n+  take_memcpy (memcpy);\n+  take_memcpy (memset);                 /* { dg-warning \"\\\\\\[-Wincompatible-pointer-types]\" } */\n+\n+  take_any (0, i ? memcpy : memset);    /* { dg-warning \"\\\\\\[-Wincompatible-pointer-types]\" } */\n+\n+  return memcpy;                        /* { dg-warning \"\\\\\\[-Wincompatible-pointer-types]\" } */\n+}"}, {"sha": "3c82e9d7a055902062b124e739e583374ed9d411", "filename": "gcc/testsuite/gcc.dg/Wbuiltin-declaration-mismatch-4.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-4.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -0,0 +1,152 @@\n+/* PR c/83656 - missing -Wbuiltin-declaration-mismatch on declaration\n+   without prototype\n+   { dg-do compile }\n+   { dg-options \"-Wbuiltin-declaration-mismatch\" } */\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+char c;\n+signed char sc;\n+unsigned char uc;\n+short si;\n+unsigned short usi;\n+int i;\n+unsigned ui;\n+long li;\n+unsigned long uli;\n+\n+size_t szi;\n+typedef size_t SizeType;\n+SizeType szti;\n+\n+ptrdiff_t diffi;\n+\n+enum E { e0 } e;\n+\n+float f;\n+double d;\n+long double ld;\n+\n+\n+/* Verify warnings for undefined calls to built-ins expecting integer\n+   arguments.  */\n+\n+int abs ();         /* { dg-message \"built-in .abs. declared here\" } */\n+\n+void test_integer_conversion_abs (void)\n+{\n+  i = abs (c);\n+  i = abs (sc);\n+  i = abs (uc);\n+\n+  i = abs (si);\n+  i = abs (usi);\n+\n+  i = abs (i);\n+  i = abs (ui);     /* { dg-warning \".abs. argument 1 type is .unsigned int. where .int. is expected in a call to built-in function declared without prototype\" } */\n+\n+  /* Verify that the same call as above but to the built-in doesn't\n+     trigger a warning.  */\n+  i = __builtin_abs (ui);\n+\n+  i = abs (li);     /* { dg-warning \".abs. argument 1 type is .long int. where .int. is expected in a call to built-in function declared without prototype\" } */\n+  i = abs (uli);    /* { dg-warning \".abs. argument 1 type is .long unsigned int. where .int. is expected in a call to built-in function declared without prototype\" } */\n+\n+  i = abs (e0);\n+  i = abs (e);\n+\n+  i = abs (-1.0);   /* { dg-warning \".abs. argument 1 type is .double. where .int. is expected in a call to built-in function declared without prototype\" } */\n+  i = abs (f);      /* { dg-warning \".abs. argument 1 promotes to .double. where .int. is expected in a call to built-in function declared without prototype\" } */\n+  i = abs (ld);     /* { dg-warning \".abs. argument 1 type is .long double. where .int. is expected in a call to built-in function declared without prototype\" } */\n+\n+  /* Verify that the same call as above but to the built-in doesn't\n+     trigger a warning.  */\n+  i = __builtin_abs (ld);\n+}\n+\n+\n+extern void* memset ();\n+\n+void test_integer_conversion_memset (void *d)\n+{\n+  memset (d, 0, sizeof (int));\n+  memset (d, '\\0', szi);\n+  memset (d, i, szti);\n+\n+  /* Passing a ptrdiff_t where size_t is expected may not be unsafe\n+     but because GCC may emits suboptimal code for such calls warning\n+     for them helps improve efficiency.  */\n+  memset (d, 0, diffi);       /* { dg-warning \".memset. argument 3 promotes to .ptrdiff_t. {aka .long int.} where .long unsigned int. is expected\" } */\n+\n+  memset (d, 0, 2.0);         /* { dg-warning \".memset. argument 3 type is .double. where 'long unsigned int' is expected\" } */\n+\n+  /* Verify that the same call as above but to the built-in doesn't\n+     trigger a warning.  */\n+  __builtin_memset (d, 0.0, 4.0);\n+}\n+\n+\n+/* Verify warnings for undefined calls to built-ins expecting floating\n+   arguments.  */\n+\n+double fabs ();           /* { dg-message \"built-in .fabs. declared here\" } */\n+\n+/* Expect a warning for fabsf below because even a float argument promotes\n+   to double.  Unfortunately, invalid calls to fabsf() are not diagnosed.  */\n+float fabsf ();           /* { dg-warning \"conflicting types for built-in function .fabsf.; expected .float\\\\\\(float\\\\\\).\" } */\n+long double fabsl ();     /* { dg-message \"built-in .fabsl. declared here\" } */\n+\n+void test_real_conversion_fabs (void)\n+{\n+  d = fabs (c);     /* { dg-warning \".fabs. argument 1 promotes to .int. where .double. is expected in a call to built-in function declared without prototype\" } */\n+\n+  d = fabs (i);     /* { dg-warning \".fabs. argument 1 type is .int. where .double. is expected in a call to built-in function declared without prototype\" } */\n+\n+  d = fabs (li);    /* { dg-warning \".fabs. argument 1 type is .long int. where .double. is expected in a call to built-in function declared without prototype\" } */\n+\n+  /* In C, the type of an enumeration constant is int.  */\n+  d = fabs (e0);    /* { dg-warning \".fabs. argument 1 type is .int. where .double. is expected in a call to built-in function declared without prototype\" } */\n+\n+  d = fabs (e);     /* { dg-warning \".fabs. argument 1 type is .enum E. where .double. is expected in a call to built-in function declared without prototype\" } */\n+\n+  /* No warning here since float is promoted to double.  */\n+  d = fabs (f);\n+\n+  d = fabs (ld);    /* { dg-warning \".fabs. argument 1 type is .long double. where .double. is expected in a call to built-in function declared without prototype\" } */\n+\n+  d = fabsf (c);    /* { dg-warning \".fabsf. argument 1 promotes to .int. where .float. is expected in a call to built-in function declared without prototype\" \"pr87890\" { xfail *-*-* } } */\n+\n+  d = fabsl (c);    /* { dg-warning \".fabsl. argument 1 promotes to .int. where .long double. is expected in a call to built-in function declared without prototype\" } */\n+\n+  d = fabsl (f);    /* { dg-warning \".fabsl. argument 1 promotes to .double. where .long double. is expected in a call to built-in function declared without prototype\" } */\n+\n+  /* Verify that the same call as above but to the built-in doesn't\n+     trigger a warning.  */\n+  d = __builtin_fabsl (f);\n+}\n+\n+/* Verify warnings for calls to a two-argument real function.  */\n+\n+double pow ();      /* { dg-message \"built-in .pow. declared here\" } */\n+\n+void test_real_conversion_pow (void)\n+{\n+  d = pow (2.0, 2.0);\n+  d = pow (d, 3.0);\n+  d = pow (d, d);\n+\n+  d = pow (2, 3.0); /* { dg-warning \".pow. argument 1 type is .int. where .double. is expected in a call to built-in function declared without prototype\" } */\n+  d = pow (3.0, 2); /* { dg-warning \".pow. argument 2 type is .int. where .double. is expected in a call to built-in function declared without prototype\" } */\n+}\n+\n+\n+/* Verify warnings for calls that discard qualifiers.  */\n+\n+extern void* memcpy ();\n+\n+void test_qual_conversion_memcpy (void *d, const void *s)\n+{\n+  memcpy (d, s, sizeof (int));\n+  memcpy (s, d, sizeof (int));    /* { dg-warning \"passing argument 1 of .memcpy. discards 'const' qualifier from pointer target type\" } */\n+}"}, {"sha": "ed66fd3626b9874e19cc933e1dc4a5a19803dcbe", "filename": "gcc/testsuite/gcc.dg/Wbuiltin-declaration-mismatch.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -0,0 +1,23 @@\n+/* PR c/83656 - missing -Wbuiltin-declaration-mismatch on declaration\n+   without prototype\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+/* Verify that ordinary library built-ins are not diagnosed with -Wall\n+   (or by default) whether or not they take arguments (even though they\n+   should be).  */\n+\n+void abort ();\n+void* memcpy ();\n+void* memset ();\n+size_t strlen ();\n+\n+/* Verify mismatches in return types are diagnosed.  */\n+int exit ();        /* { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */\n+\n+/* Variadic built-ins are diagnosed with -Wall (they are, in fact,\n+   diagnosed by default).  */\n+int printf ();      /* { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */\n+int sprintf ();     /* { dg-warning \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */"}, {"sha": "a95960e751a23d9f5d158ff210b668e184971e22", "filename": "gcc/testsuite/gcc.dg/Wrestrict-4.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-4.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -109,3 +109,5 @@ void* test_strncpy_2 (char *d, const char *s)\n {\n   return strncpy (d, s);\n }\n+\n+/* { dg-prune-output \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */"}, {"sha": "90babfd8205d3f11b9af6942765e5edaa14dc678", "filename": "gcc/testsuite/gcc.dg/Wrestrict-5.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-5.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -42,3 +42,6 @@ void test_strncpy_nowarn (char *d)\n {\n   strncpy (d + 1, d + 3, \"\");\n }\n+\n+/* { dg-prune-output \"\\\\\\[-Wbuiltin-declaration-mismatch]\" }\n+   { dg-prune-output \"\\\\\\[-Wint-conversion]\" } */"}, {"sha": "96582b4a3865fdf493f4a8bb5729bb8ba6032b18", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-generic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-generic.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -4,7 +4,7 @@\n \n #include <stdatomic.h>\n \n-extern void abort ();\n+extern void abort (void);\n extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n \n typedef struct test {"}, {"sha": "c6d06a55a8885bc7ccdc8fc4600f8c65acb45760", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-lockfree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-lockfree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-lockfree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-lockfree.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -5,7 +5,7 @@\n #include <stdatomic.h>\n #include <stdint.h>\n \n-extern void abort ();\n+extern void abort (void);\n \n _Atomic _Bool aba;\n atomic_bool abt;"}, {"sha": "b6afd7690de5e7306c1138f0fdc7d87e98a1bc18", "filename": "gcc/testsuite/gcc.dg/initpri1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Finitpri1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Finitpri1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Finitpri1.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run { target init_priority } } */\n \n-extern void abort ();\n+extern void abort (void);\n \n int i;\n int j;"}, {"sha": "cbe613c4fd6858f247285a9dacde31d4ff114aed", "filename": "gcc/testsuite/gcc.dg/pr15698-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15698-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15698-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15698-1.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -21,3 +21,5 @@ char *rindex(a, b)\n {\n   return 0;\n }\n+\n+/* { dg-prune-output \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */"}, {"sha": "522ac00be46468bca934ac603e9b248ebd7eb8c3", "filename": "gcc/testsuite/gcc.dg/pr69156.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69156.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69156.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69156.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -5,6 +5,6 @@\n _Bool\n foo ()\n {\n-  _Bool (*f) () = __builtin_abs;\t/* { dg-warning \"initialization of '_Bool \\\\(\\\\*\\\\)\\\\(\\\\)' from incompatible pointer type\" } */\n+  _Bool (*f) () = __builtin_abs;\t/* { dg-warning \"initialization of '_Bool \\\\(\\\\*\\\\)\\\\(\\\\)' from pointer to .__builtin_abs. with incompatible type .int \\\\\\(\\\\\\*\\\\\\).\" } */\n   return f (0);\n }"}, {"sha": "9142d273e7cb66400b05f2c09a42b75fa39317e1", "filename": "gcc/testsuite/gcc.dg/pr83463.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83463.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83463.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83463.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -16,3 +16,5 @@ p ()\n {\n   m (p + (long) a);\n }\n+\n+/* { dg-prune-output \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */"}, {"sha": "8f124886da87cb9c6dcc76d1aae51791ba9921dd", "filename": "gcc/testsuite/gcc.dg/redecl-4.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-4.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -27,3 +27,6 @@ f (void)\n \n /* Should still diagnose incompatible prototype for strcmp.  */\n int strcmp (void); /* { dg-error \"conflict\" } */\n+\n+/* { dg-prune-output \"\\\\\\[-Wbuiltin-declaration-mismatch]\" }\n+   { dg-prune-output \"\\\\\\[-Wint-conversion]\" } */"}, {"sha": "a54038970572fc1d0a9f1613d525e8c382cd4f8d", "filename": "gcc/testsuite/gcc.dg/tls/thr-init-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-init-2.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -2,7 +2,7 @@\n /* { dg-require-effective-target tls_runtime } */\n /* { dg-add-options tls } */\n \n-extern void abort() ;\n+extern void abort (void);\n \n static __thread int fstat ;\n static __thread int fstat = 1;"}, {"sha": "391f970e9feb1889422e0c28062c0ff9667c7f04", "filename": "gcc/testsuite/gcc.dg/torture/pr55890-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55890-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55890-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55890-2.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -3,3 +3,5 @@\n \r\n extern void *memcpy();\r\n int main() { memcpy(); }\r\n+\r\n+/* { dg-prune-output \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */\r"}, {"sha": "c284c12ecc322650d9b03c8a6d4ab69d068ca44c", "filename": "gcc/testsuite/gcc.dg/torture/pr55890-3.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55890-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55890-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55890-3.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -8,3 +8,5 @@ bar ()\n {\n   return memmove ();\n }\n+\n+/* { dg-prune-output \"\\\\\\[-Wbuiltin-declaration-mismatch]\" } */"}, {"sha": "c0019d04a86bb7fd7f0a6f2e3023e3ddfb8620ca", "filename": "gcc/testsuite/gcc.dg/torture/pr67741.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr67741.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr67741.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr67741.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -9,5 +9,6 @@ float cabsf(fc)\n {\n   struct doublecomplex dc ;\n   dc.real=fc.real; dc.imag=fc.imag;\n-  return (float) cabs(dc);\n+  return (float) cabs(dc);   /* { dg-warning \"incompatible type for argument 1 of .cabs.\" } */\n }\n+"}, {"sha": "179fad85cd19acd0c7f4318228410ecb94154b3b", "filename": "gcc/testsuite/gcc.dg/torture/pr71816.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71816.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71816.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71816.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-prune-output \"conflicting types for built-in\" } */\n+/* { dg-prune-output \"\\\\\\[-Wbuiltin-declaration-mismatch\" } */\n \n void *ext2fs_resize_mem_p;\n struct ext2_icount_el {"}, {"sha": "c4992df66ea0c635ba163bef17829adfe83760f4", "filename": "gcc/testsuite/gcc.dg/torture/stackalign/sibcall-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fsibcall-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fsibcall-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fsibcall-1.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run } */\n \n extern int ok (int);\n-extern void exit ();\n+extern void exit (int);\n static int gen_x86_64_shrd (int);\n static int\n gen_x86_64_shrd(int a __attribute__ ((__unused__)))"}, {"sha": "3ae2e2928b55194d04059680da47b8d28d0a8abf", "filename": "gcc/testsuite/gcc.dg/torture/tls/thr-init-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Fthr-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Fthr-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Fthr-init-1.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -3,7 +3,7 @@\n /* { dg-add-options tls } */\n \n extern int printf (char *,...);\n-extern void abort() ;\n+extern void abort(void) ;\n \n int test_code(int b)\n {"}, {"sha": "0912b687e13f104755f1a56386cca68bd6cd0882", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtins-folding-gimple-ub.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltins-folding-gimple-ub.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5da9837b26d77136d3a9394747ce4325a95118/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltins-folding-gimple-ub.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltins-folding-gimple-ub.c?ref=cd5da9837b26d77136d3a9394747ce4325a95118", "patch": "@@ -31,4 +31,5 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin_memchr\" 2 \"optimized\" } } */\n+/* { dg-prune-output \"-Wbuiltin-declaration-mismatch\" }\n+   { dg-final { scan-tree-dump-times \"__builtin_memchr\" 2 \"optimized\" } } */"}]}