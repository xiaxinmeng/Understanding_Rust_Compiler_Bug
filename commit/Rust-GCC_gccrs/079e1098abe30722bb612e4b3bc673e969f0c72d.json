{"sha": "079e1098abe30722bb612e4b3bc673e969f0c72d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc5ZTEwOThhYmUzMDcyMmJiNjEyZTRiM2JjNjczZTk2OWYwYzcyZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-28T15:43:58Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-28T15:43:58Z"}, "message": "cp-tree.h (build_enumerator): Take the enumeration type as a paramter.\n\n\t* cp-tree.h (build_enumerator): Take the enumeration type as a\n\tparamter.\n\t* decl.c (finish_enum): Don't set the TREE_TYPE for the\n\tenumeration constant values if we're processing_template_decls.\n\tDon't set the type for the CONST_DECLs either; that's done in\n\tbuild_enumerator. (\n\t(build_enumerator): Take the enumeration type as a\n\tparamter.\n\t* lex.c (do_identifier): Don't resolve enumeration constants while\n\tprocessing template declarations, even if they happen to be\n\tTEMPLATE_PARM_INDEXs.\n\t* parse.y (current_enum_type): New variable.\n\t(primary): Don't allow statement-expression in local classes just\n\tas we don't in global classes.\n\t(structsp): Use current_enum_type.\n\t(enum_list): Likewise.\n\t* pt.c (tsubst_enum): Don't check for NOP_EXPRs introduced by\n\tfinish_enum; they no longer occur.\n\nFrom-SVN: r22060", "tree": {"sha": "01906c60f2f79be105f47fb3279d31cbf6f01a9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01906c60f2f79be105f47fb3279d31cbf6f01a9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/079e1098abe30722bb612e4b3bc673e969f0c72d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079e1098abe30722bb612e4b3bc673e969f0c72d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079e1098abe30722bb612e4b3bc673e969f0c72d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079e1098abe30722bb612e4b3bc673e969f0c72d/comments", "author": null, "committer": null, "parents": [{"sha": "ec8b2a13642c7b6b75f6a949776076f1c1c879c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8b2a13642c7b6b75f6a949776076f1c1c879c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8b2a13642c7b6b75f6a949776076f1c1c879c6"}], "stats": {"total": 157, "additions": 96, "deletions": 61}, "files": [{"sha": "4cfc4c63f99e70170076d7f84aa8d5a6f6246046", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=079e1098abe30722bb612e4b3bc673e969f0c72d", "patch": "@@ -1,5 +1,24 @@\n 1998-08-28  Mark Mitchell  <mark@markmitchell.com>\n \n+\t* cp-tree.h (build_enumerator): Take the enumeration type as a\n+\tparamter. \n+\t* decl.c (finish_enum): Don't set the TREE_TYPE for the\n+\tenumeration constant values if we're processing_template_decls.\n+\tDon't set the type for the CONST_DECLs either; that's done in\n+\tbuild_enumerator. (\n+\t(build_enumerator): Take the enumeration type as a\n+\tparamter. \n+\t* lex.c (do_identifier): Don't resolve enumeration constants while\n+\tprocessing template declarations, even if they happen to be\n+\tTEMPLATE_PARM_INDEXs. \n+\t* parse.y (current_enum_type): New variable.\n+\t(primary): Don't allow statement-expression in local classes just\n+\tas we don't in global classes.\n+\t(structsp): Use current_enum_type.\n+\t(enum_list): Likewise.\n+\t* pt.c (tsubst_enum): Don't check for NOP_EXPRs introduced by\n+\tfinish_enum; they no longer occur.\n+\t\n \t* cp-tree.h (finish_base_specifier): New function.\n \t* parse.y (base_class): Use it.\n \t* semantics.c (finish_base_specifier): Define it."}, {"sha": "f7ce4f2714eb44367ffbfc2173a9338724b685ef", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=079e1098abe30722bb612e4b3bc673e969f0c72d", "patch": "@@ -2536,7 +2536,7 @@ extern tree xref_tag_from_type\t\t\tPROTO((tree, tree, int));\n extern void xref_basetypes\t\t\tPROTO((tree, tree, tree, tree));\n extern tree start_enum\t\t\t\tPROTO((tree));\n extern tree finish_enum\t\t\t\tPROTO((tree));\n-extern tree build_enumerator\t\t\tPROTO((tree, tree));\n+extern tree build_enumerator\t\t\tPROTO((tree, tree, tree));\n extern tree grok_enum_decls\t\t\tPROTO((tree));\n extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n extern void expand_start_early_try_stmts\tPROTO((void));"}, {"sha": "2d4fb1345674e753d17b1d3a9b5ccf257275b83a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=079e1098abe30722bb612e4b3bc673e969f0c72d", "patch": "@@ -11883,34 +11883,32 @@ finish_enum (enumtype)\n \t     constant.  */\n \t  decl = TREE_VALUE (pair);\n \n-\t  /* The type of the CONST_DECL is the type of the enumeration,\n-\t     not an INTEGER_TYPE.  */\n-\t  TREE_TYPE (decl) = enumtype;\n-\n \t  /* The DECL_INITIAL will be NULL if we are processing a\n \t     template declaration and this enumeration constant had no\n \t     explicit initializer.  */\n \t  value = DECL_INITIAL (decl);\n-\t  if (value)\n-\t    {\n-\t      /* Set the TREE_TYPE for the VALUE as well.  When\n-\t\t processing a template, however, we might have a\n-\t\t TEMPLATE_PARM_INDEX, and we should not change the\n-\t\t type of such a thing.  */\n-\t      if (TREE_CODE (value) == TEMPLATE_PARM_INDEX)\n-\t\tDECL_INITIAL (decl) = value \n-\t\t  = build1 (NOP_EXPR, enumtype, value);\n+\t  if (value && !processing_template_decl)\n+\t    {\n+\t      /* Set the TREE_TYPE for the VALUE as well.  That's so\n+\t\t that when we call decl_constant_value we get an\n+\t\t entity of the right type (but with the constant\n+\t\t value).  Since we shouldn't ever call\n+\t\t decl_constant_value on a template type, there's no\n+\t\t reason to do that when processing_template_decl.\n+\t\t And, if the expression is something like a\n+\t\t TEMPLATE_PARM_INDEX or a CAST_EXPR doing so will\n+\t\t wreak havoc on the intended type of the expression.  \n+\n+\t         Of course, there's also no point in trying to compute\n+\t\t minimum or maximum values if we're in a template.  */\n \t      TREE_TYPE (value) = enumtype;\n \n-\t      if (!processing_template_decl)\n-\t\t{\n-\t\t  if (!minnode)\n-\t\t    minnode = maxnode = value;\n-\t\t  else if (tree_int_cst_lt (maxnode, value))\n-\t\t    maxnode = value;\n-\t\t  else if (tree_int_cst_lt (value, minnode))\n-\t\t    minnode = value;\n-\t\t}\n+\t      if (!minnode)\n+\t\tminnode = maxnode = value;\n+\t      else if (tree_int_cst_lt (maxnode, value))\n+\t\tmaxnode = value;\n+\t      else if (tree_int_cst_lt (value, minnode))\n+\t\tminnode = value;\n \t    }\n \n \t  /* In the list we're building up, we want the enumeration\n@@ -11985,14 +11983,15 @@ finish_enum (enumtype)\n   return enumtype;\n }\n \n-/* Build and install a CONST_DECL for one value of the\n-   current enumeration type (one that was begun with start_enum).\n-   Return a tree-list containing the name and its value.\n+/* Build and install a CONST_DECL for an enumeration constant of the\n+   enumeration type TYPE whose NAME and VALUE (if any) are provided.\n    Assignment of sequential values by default is handled here.  */\n \n tree\n-build_enumerator (name, value)\n-     tree name, value;\n+build_enumerator (name, value, type)\n+     tree name;\n+     tree value;\n+     tree type;\n {\n   tree decl, result;\n   tree context;\n@@ -12038,8 +12037,9 @@ build_enumerator (name, value)\n #endif\n    }\n \n- /* We have to always copy here; not all INTEGER_CSTs are unshared,\n-    and there's no wedding ring. Look at size_int()...*/\n+ /* We always have to copy here; not all INTEGER_CSTs are unshared.\n+    Even in other cases, we will later (in finish_enum) be setting the\n+    type of VALUE.  */\n  if (value != NULL_TREE)\n    value = copy_node (value);\n \n@@ -12048,11 +12048,11 @@ build_enumerator (name, value)\n  context = current_scope ();\n  if (context && context == current_class_type)\n    /* This enum declaration is local to the class.  */\n-   decl = build_lang_field_decl (CONST_DECL, name, integer_type_node);\n+   decl = build_lang_field_decl (CONST_DECL, name, type);\n  else\n    /* It's a global enum, or it's local to a function.  (Note local to\n       a function could mean local to a class method.  */\n-   decl = build_decl (CONST_DECL, name, integer_type_node);\n+   decl = build_decl (CONST_DECL, name, type);\n \n  DECL_CONTEXT (decl) = FROB_CONTEXT (context);\n  DECL_INITIAL (decl) = value;"}, {"sha": "915b660337910efecc30125fed275883bd18ffa6", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=079e1098abe30722bb612e4b3bc673e969f0c72d", "patch": "@@ -2984,8 +2984,12 @@ do_identifier (token, parsing, args)\n \t    cp_error (\"enum `%D' is private\", id);\n \t  /* protected is OK, since it's an enum of `this'.  */\n \t}\n-      if (! processing_template_decl\n-\t  || (DECL_INITIAL (id)\n+      if (!processing_template_decl\n+\t  /* Don't resolve enumeration constants while processing\n+\t     template declarations, unless they're for global\n+\t     enumerations and therefore cannot involve template\n+\t     parameters.  */\n+\t  || (!DECL_CONTEXT (id)\n \t      && TREE_CODE (DECL_INITIAL (id)) == TEMPLATE_PARM_INDEX))\n \tid = DECL_INITIAL (id);\n     }"}, {"sha": "6c66a55717a88fcd2a6e8ca2ce9b8a51a12333c8", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=079e1098abe30722bb612e4b3bc673e969f0c72d", "patch": "@@ -290,9 +290,13 @@ static tree current_declspecs;\n    a declspec list have been updated.  */\n static tree prefix_attributes;\n \n-/* When defining an aggregate, this is the most recent one being defined.  */\n+/* When defining an aggregate, this is the kind of the most recent one\n+   being defined.  (For example, this might be class_type_node.)  */\n static tree current_aggr;\n \n+/* When defining an enumeration, this is the type of the enumeration.  */\n+static tree current_enum_type;\n+\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n@@ -1373,7 +1377,8 @@ primary:\n \t| '(' error ')'\n \t\t{ $$ = error_mark_node; }\n \t| '('\n-\t\t{ if (current_function_decl == 0)\n+\t\t{ tree scope = current_scope ();\n+\t\t  if (!scope || TREE_CODE (scope) != FUNCTION_DECL)\n \t\t    {\n \t\t      error (\"braced-group within expression allowed only inside a function\");\n \t\t      YYERROR;\n@@ -2058,26 +2063,30 @@ pending_defargs:\n structsp:\n \t  ENUM identifier '{'\n \t\t{ $<itype>3 = suspend_momentary ();\n-\t\t  $<ttype>$ = start_enum ($2); }\n+\t\t  $<ttype>$ = current_enum_type;\n+\t\t  current_enum_type = start_enum ($2); }\n \t  enumlist maybecomma_warn '}'\n-\t\t{ TYPE_VALUES ($<ttype>4) = $5;\n-\t\t  $$.t = finish_enum ($<ttype>4);\n+\t\t{ TYPE_VALUES (current_enum_type) = $5;\n+\t\t  $$.t = finish_enum (current_enum_type);\n \t\t  $$.new_type_flag = 1;\n+\t\t  current_enum_type = $<ttype>4;\n \t\t  resume_momentary ((int) $<itype>3);\n-\t\t  check_for_missing_semicolon ($<ttype>4); }\n+\t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM identifier '{' '}'\n \t\t{ $$.t = finish_enum (start_enum ($2));\n \t\t  $$.new_type_flag = 1;\n \t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM '{'\n \t\t{ $<itype>2 = suspend_momentary ();\n-\t\t  $<ttype>$ = start_enum (make_anon_name ()); }\n+\t\t  $<ttype>$ = current_enum_type;\n+\t\t  current_enum_type = start_enum (make_anon_name ()); }\n \t  enumlist maybecomma_warn '}'\n-                { TYPE_VALUES ($<ttype>3) = $4;\n-\t\t  $$.t = finish_enum ($<ttype>3);\n+                { TYPE_VALUES (current_enum_type) = $4;\n+\t\t  $$.t = finish_enum (current_enum_type);\n+\t\t  $$.new_type_flag = 1;\n+\t\t  current_enum_type = $<ttype>4;\n \t\t  resume_momentary ((int) $<itype>1);\n-\t\t  check_for_missing_semicolon ($<ttype>3);\n-\t\t  $$.new_type_flag = 1; }\n+\t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM '{' '}'\n \t\t{ $$.t = finish_enum (start_enum (make_anon_name()));\n \t\t  $$.new_type_flag = 1;\n@@ -2585,9 +2594,9 @@ enumlist:\n \n enumerator:\n \t  identifier\n-\t\t{ $$ = build_enumerator ($$, NULL_TREE); }\n+\t\t{ $$ = build_enumerator ($$, NULL_TREE, current_enum_type); }\n \t| identifier '=' expr_no_commas\n-\t\t{ $$ = build_enumerator ($$, $3); }\n+\t\t{ $$ = build_enumerator ($$, $3, current_enum_type); }\n \t;\n \n /* ANSI new-type-id (5.3.4) */"}, {"sha": "d86eea8f53ebb988cfb6270de912522e38e25363", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=079e1098abe30722bb612e4b3bc673e969f0c72d", "patch": "@@ -8210,20 +8210,11 @@ tsubst_enum (tag, newtag, args)\n \n   for (e = TYPE_VALUES (tag); e; e = TREE_CHAIN (e))\n     {\n-      tree value;\n-      tree elt;\n-\n-      value = TREE_VALUE (e);\n-      if (value)\n-\t{\n-\t  if (TREE_CODE (value) == NOP_EXPR)\n-\t    /* This is the special case where the value is really a\n-\t       TEMPLATE_PARM_INDEX.  See finish_enum.  */\n-\t    value = TREE_OPERAND (value, 0);\n-\t  value = tsubst_expr (value, args, NULL_TREE);\n-\t}\n-\n-      elt = build_enumerator (TREE_PURPOSE (e), value);\n+      tree elt\n+\t= build_enumerator (TREE_PURPOSE (e), \n+\t\t\t    tsubst_expr (TREE_VALUE (e), args,\n+\t\t\t\t\t NULL_TREE),\n+\t\t\t    newtag); \n \n       /* We save the enumerators we have built so far in the\n \t TYPE_VALUES so that if the enumeration constants for"}, {"sha": "713c11c33d5ab2f8619c4cf0f356ef949c366ef0", "filename": "gcc/testsuite/g++.old-deja/g++.pt/enum10.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079e1098abe30722bb612e4b3bc673e969f0c72d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fenum10.C?ref=079e1098abe30722bb612e4b3bc673e969f0c72d", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+\n+template <class T> \n+struct S {\n+  enum E { a = (int) T::b };\n+};\n+\n+struct S2 {\n+  enum E2 { b };\n+};\n+\n+template class S<S2>;"}]}