{"sha": "ecb75b7ab94b7d2515e65815df40c69bb8720471", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNiNzViN2FiOTRiN2QyNTE1ZTY1ODE1ZGY0MGM2OWJiODcyMDQ3MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@cygnus.com", "date": "1998-06-11T11:51:52Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-06-11T11:51:52Z"}, "message": "For regmove if we could not improve code by changing the source to the destination, copy the source to the destination directly\n\nFrom-SVN: r20427", "tree": {"sha": "614f48702fe3b1201670055c1fd940453de3416c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/614f48702fe3b1201670055c1fd940453de3416c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecb75b7ab94b7d2515e65815df40c69bb8720471", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb75b7ab94b7d2515e65815df40c69bb8720471", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecb75b7ab94b7d2515e65815df40c69bb8720471", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb75b7ab94b7d2515e65815df40c69bb8720471/comments", "author": null, "committer": null, "parents": [{"sha": "8e34149da2a7a293b4bb553b6a79f3abe0a0cfce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e34149da2a7a293b4bb553b6a79f3abe0a0cfce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e34149da2a7a293b4bb553b6a79f3abe0a0cfce"}], "stats": {"total": 176, "additions": 163, "deletions": 13}, "files": [{"sha": "79f0a7e8bbf0ab7bdc2a8077b5dd66dd7580392b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb75b7ab94b7d2515e65815df40c69bb8720471/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb75b7ab94b7d2515e65815df40c69bb8720471/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ecb75b7ab94b7d2515e65815df40c69bb8720471", "patch": "@@ -1,3 +1,13 @@\n+Thu Jun 11 14:50:02 1998  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* regmove.c (regmove_optimize): If we can't replace the\n+\tdestination in an insn that sets the source, generate an explicit\n+\tmove of the source to the destination.\n+\t(copy_src_to_dest): New function.\n+\t(toplevel): Include basic-block.h\n+\n+\t* Makefile.in (regmove.o): Add basic-block.h dependencies.\n+\n Thu Jun 11 10:30:09 1998  Dave Brolley  <brolley@cygnus.com>\n \n \t* toplev.c (lang_options): Add missing options (nostdinc, idirafter)."}, {"sha": "8f6cbb728551fbabb7d13af15febd7d0d631da01", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb75b7ab94b7d2515e65815df40c69bb8720471/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb75b7ab94b7d2515e65815df40c69bb8720471/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ecb75b7ab94b7d2515e65815df40c69bb8720471", "patch": "@@ -1461,7 +1461,7 @@ alias.o : alias.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h regs.h \\\n    insn-codes.h\n regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n    insn-codes.h recog.h output.h reload.h regs.h hard-reg-set.h flags.h \\\n-   expr.h insn-flags.h\n+   expr.h insn-flags.h $(BASIC_BLOCK_H)\n $(SCHED_PREFIX)sched.o : $(SCHED_PREFIX)sched.c $(CONFIG_H) system.h $(RTL_H) \\\n    $(BASIC_BLOCK_H) regs.h hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n    toplev.h"}, {"sha": "43116268ccd452e374a1d62b190b4920993775c7", "filename": "gcc/regmove.c", "status": "modified", "additions": 152, "deletions": 12, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb75b7ab94b7d2515e65815df40c69bb8720471/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb75b7ab94b7d2515e65815df40c69bb8720471/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=ecb75b7ab94b7d2515e65815df40c69bb8720471", "patch": "@@ -43,11 +43,14 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"flags.h\"\n #include \"expr.h\"\n #include \"insn-flags.h\"\n+#include \"basic-block.h\"\n \n static int optimize_reg_copy_1\tPROTO((rtx, rtx, rtx));\n static void optimize_reg_copy_2\tPROTO((rtx, rtx, rtx));\n static void optimize_reg_copy_3\tPROTO((rtx, rtx, rtx));\n static rtx gen_add3_insn\tPROTO((rtx, rtx, rtx));\n+static void copy_src_to_dest\tPROTO((rtx, rtx, rtx, int));\n+static int *regmove_bb_head;\n \n struct match {\n   int with[MAX_RECOG_OPERANDS];\n@@ -528,6 +531,98 @@ optimize_reg_copy_3 (insn, dest, src)\n   validate_replace_rtx (src, src_reg, insn);\n }\n \n+\f\n+/* If we were not able to update the users of src to use dest directly, try\n+   instead moving the value to dest directly before the operation.  */\n+\n+void\n+copy_src_to_dest (insn, src, dest, loop_depth)\n+     rtx insn;\n+     rtx src;\n+     rtx dest;\n+{\n+  rtx seq;\n+  rtx link;\n+  rtx next;\n+  rtx set;\n+  rtx move_insn;\n+  rtx *p_insn_notes;\n+  rtx *p_move_notes;\n+  int i;\n+  int src_regno;\n+  int dest_regno;\n+  int bb;\n+  int insn_uid;\n+  int move_uid;\n+\n+  if (GET_CODE (src) == REG && GET_CODE (dest) == REG\n+      && (set = single_set (insn)) != NULL_RTX\n+      && !reg_mentioned_p (dest, SET_SRC (set))\n+      && validate_replace_rtx (src, dest, insn))\n+    {\n+      /* Generate the src->dest move.  */\n+      start_sequence ();\n+      emit_move_insn (dest, src);\n+      seq = gen_sequence ();\n+      end_sequence ();\n+      emit_insn_before (seq, insn);\n+      move_insn = PREV_INSN (insn);\n+      p_move_notes = &REG_NOTES (move_insn);\n+      p_insn_notes = &REG_NOTES (insn);\n+\n+      /* Move any notes mentioning src to the move instruction */\n+      for (link = REG_NOTES (insn); link != NULL_RTX; link = next)\n+\t{\n+\t  next = XEXP (link, 1);\n+\t  if (XEXP (link, 0) == src)\n+\t    {\n+\t      *p_move_notes = link;\n+\t      p_move_notes = &XEXP (link, 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      *p_insn_notes = link;\n+\t      p_insn_notes = &XEXP (link, 1);\n+\t    }\n+\t}\n+\n+      *p_move_notes = NULL_RTX;\n+      *p_insn_notes = NULL_RTX;\n+\n+      /* Is the insn the head of a basic block?  If so extend it */\n+      insn_uid = INSN_UID (insn);\n+      move_uid = INSN_UID (move_insn);\n+      bb = regmove_bb_head[insn_uid];\n+      if (bb >= 0)\n+\t{\n+\t  basic_block_head[bb] = move_insn;\n+\t  regmove_bb_head[insn_uid] = -1;\n+\t}\n+\n+      /* Update the various register tables.  */\n+      dest_regno = REGNO (dest);\n+      REG_N_SETS (dest_regno) += loop_depth;\n+      REG_N_REFS (dest_regno) += loop_depth;\n+      REG_LIVE_LENGTH (dest_regno)++;\n+      if (REGNO_FIRST_UID (dest_regno) == insn_uid)\n+\tREGNO_FIRST_UID (dest_regno) = move_uid;\n+\n+      src_regno = REGNO (src);\n+      if (! find_reg_note (move_insn, REG_DEAD, src))\n+\tREG_LIVE_LENGTH (src_regno)++;\n+\n+      if (REGNO_FIRST_UID (src_regno) == insn_uid)\n+\tREGNO_FIRST_UID (src_regno) = move_uid;\n+\n+      if (REGNO_LAST_UID (src_regno) == insn_uid)\n+\tREGNO_LAST_UID (src_regno) = move_uid;\n+\n+      if (REGNO_LAST_NOTE_UID (src_regno) == insn_uid)\n+\tREGNO_LAST_NOTE_UID (src_regno) = move_uid;\n+    }\n+}\n+\n+\f\n /* Return whether REG is set in only one location, and is set to a\n    constant, but is set in a different basic block from INSN (an\n    instructions which uses REG).  In this case REG is equivalent to a\n@@ -750,10 +845,16 @@ regmove_optimize (f, nregs, regmove_dump_file)\n   struct match match;\n   int pass;\n   int maxregnum = max_reg_num (), i;\n+  rtx copy_src, copy_dst;\n \n   regno_src_regno = (int *)alloca (sizeof *regno_src_regno * maxregnum);\n   for (i = maxregnum; --i >= 0; ) regno_src_regno[i] = -1;\n \n+  regmove_bb_head = (int *)alloca (sizeof (int) * (get_max_uid () + 1));\n+  for (i = get_max_uid (); --i >= 0; ) regmove_bb_head[i] = -1;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    regmove_bb_head[INSN_UID (basic_block_head[i])] = i;\n+\n   /* A forward/backward pass.  Replace output operands with input operands.  */\n \n   loop_depth = 1;\n@@ -936,6 +1037,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t{\n \t  int insn_code_number = find_matches (insn, &match);\n \t  int operand_number, match_number;\n+\t  int success = 0;\n \t  \n \t  if (insn_code_number < 0)\n \t    continue;\n@@ -946,13 +1048,14 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t     operand.  If safe, then replace the source operand with the\n \t     dest operand in both instructions.  */\n \n+\t  copy_src = NULL_RTX;\n+\t  copy_dst = NULL_RTX;\n \t  for (operand_number = 0;\n \t       operand_number < insn_n_operands[insn_code_number];\n \t       operand_number++)\n \t    {\n \t      rtx set, p, src, dst;\n \t      rtx src_note, dst_note;\n-\t      int success = 0;\n \t      int num_calls = 0;\n \t      enum reg_class src_class, dst_class;\n \t      int length;\n@@ -1016,27 +1119,58 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t      || CLASS_LIKELY_SPILLED_P (src_class))\n \t\t  && (! reg_class_subset_p (dst_class, src_class)\n \t\t      || CLASS_LIKELY_SPILLED_P (dst_class)))\n-\t\tcontinue;\n-\t  \n-\t      if (! (src_note = find_reg_note (insn, REG_DEAD, src)))\n-\t\tcontinue;\n+\t\t{\n+\t\t  if (!copy_src)\n+\t\t    {\n+\t\t      copy_src = src;\n+\t\t      copy_dst = dst;\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n \n \t      /* Can not modify an earlier insn to set dst if this insn\n \t\t uses an old value in the source.  */\n \t      if (reg_overlap_mentioned_p (dst, SET_SRC (set)))\n-\t\tcontinue;\n+\t\t{\n+\t\t  if (!copy_src)\n+\t\t    {\n+\t\t      copy_src = src;\n+\t\t      copy_dst = dst;\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (! (src_note = find_reg_note (insn, REG_DEAD, src)))\n+\t\t{\n+\t\t  if (!copy_src)\n+\t\t    {\n+\t\t      copy_src = src;\n+\t\t      copy_dst = dst;\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n \n-\t      if (regmove_dump_file)\n-\t\tfprintf (regmove_dump_file,\n-\t\t\t \"Could fix operand %d of insn %d matching operand %d.\\n\",\n-\t\t\t operand_number, INSN_UID (insn), match_number);\n \n \t      /* If src is set once in a different basic block,\n \t\t and is set equal to a constant, then do not use\n \t\t it for this optimization, as this would make it\n \t\t no longer equivalent to a constant.  */\n-\t      if (reg_is_remote_constant_p (src, insn, f))\n-\t\tcontinue;\n+\n+              if (reg_is_remote_constant_p (src, insn, f))\n+\t\t{\n+\t\t  if (!copy_src)\n+\t\t    {\n+\t\t      copy_src = src;\n+\t\t      copy_dst = dst;\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n+\n+\n+\t      if (regmove_dump_file)\n+\t\tfprintf (regmove_dump_file,\n+\t\t\t \"Could fix operand %d of insn %d matching operand %d.\\n\",\n+\t\t\t operand_number, INSN_UID (insn), match_number);\n \n \t      /* Scan backward to find the first instruction that uses\n \t\t the input operand.  If the operand is set here, then\n@@ -1173,6 +1307,12 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t  break;\n \t\t}\n \t    }\n+\n+\t  /* If we weren't able to replace any of the alternatives, try an\n+\t     alternative appoach of copying the source to the destination.  */\n+\t  if (!success && copy_src != NULL_RTX)\n+\t    copy_src_to_dest (insn, copy_src, copy_dst, loop_depth);\n+\n \t}\n     }\n #endif /* REGISTER_CONSTRAINTS */"}]}