{"sha": "8b119bb67de0c95e25150b8a280878af67cb3eb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIxMTliYjY3ZGUwYzk1ZTI1MTUwYjhhMjgwODc4YWY2N2NiM2ViNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-19T17:02:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-19T17:02:57Z"}, "message": "mn10300: Cleanup secondary reloads\n\nHandles output reloads for QI/HImode properly; previously we were\nonly handing input reloads properly.\n\nHandles reloads involving the stack pointer better; note that the\nAM33 allows copying SP to DATA_REGS as well as ADDRESS and EXTENDED.\n\nFrom-SVN: r169005", "tree": {"sha": "4f7c0a2912485b76df2116017beedc648533166f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f7c0a2912485b76df2116017beedc648533166f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b119bb67de0c95e25150b8a280878af67cb3eb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b119bb67de0c95e25150b8a280878af67cb3eb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b119bb67de0c95e25150b8a280878af67cb3eb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b119bb67de0c95e25150b8a280878af67cb3eb6/comments", "author": null, "committer": null, "parents": [{"sha": "b1efde2a0bef10502751bbb5f9caf96370424805", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1efde2a0bef10502751bbb5f9caf96370424805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1efde2a0bef10502751bbb5f9caf96370424805"}], "stats": {"total": 196, "additions": 114, "deletions": 82}, "files": [{"sha": "06b439efcdb30ba93d50411ea2bcf4d2d9de08cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b119bb67de0c95e25150b8a280878af67cb3eb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b119bb67de0c95e25150b8a280878af67cb3eb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b119bb67de0c95e25150b8a280878af67cb3eb6", "patch": "@@ -1,5 +1,17 @@\n 2011-01-19  Richard Henderson  <rth@redhat.com>\n \n+\t* config/mn10300/mn10300.c (mn10300_preferred_reload_class): Allow\n+\tDATA_REGS for AM33 stack-pointer destination.\n+\t(mn10300_preferred_output_reload_class): Likewise.\n+\t(mn10300_secondary_reload): Rearrange mn10300_secondary_reload_class\n+\tinto a form appropriate for ...\n+\t(TARGET_SECONDARY_RELOAD): New.\n+\t* config/mn10300/mn10300.h (SECONDARY_RELOAD_CLASS): Remove.\n+\t* config/mn10300/mn10300-protos.h: Update.\n+\t* config/mn10300/mn10300.md (reload_plus_sp_const): Rename from\n+\treload_insi; use the \"A\" constraint for the scratch; handle AM33\n+\tmoves of sp to non-address registers.\n+\n \t* config/mn10300/mn10300.md (*am33_movqi, *mn10300_movqi): Merge into\n \t(*movqi_internal): ... here.\n \t(*am33_movhi, *mn10300_movhi): Merge into..."}, {"sha": "37968ff5cc9dd370ecb14063f74487709e960cee", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b119bb67de0c95e25150b8a280878af67cb3eb6/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b119bb67de0c95e25150b8a280878af67cb3eb6/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=8b119bb67de0c95e25150b8a280878af67cb3eb6", "patch": "@@ -35,7 +35,6 @@ extern Cstar mn10300_output_cmp (rtx, rtx);\n extern void  mn10300_print_operand (FILE *, rtx, int);\n extern void  mn10300_print_operand_address (FILE *, rtx);\n extern void  mn10300_print_reg_list (FILE *, int);\n-extern Rclas mn10300_secondary_reload_class (Rclas, Mmode, rtx);\n extern Mmode mn10300_select_cc_mode (rtx);\n extern int   mn10300_store_multiple_operation (rtx, Mmode);\n extern int   mn10300_symbolic_operand (rtx, Mmode);"}, {"sha": "29cf3373a60a856b507bd027a2827587e41da32f", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 67, "deletions": 53, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b119bb67de0c95e25150b8a280878af67cb3eb6/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b119bb67de0c95e25150b8a280878af67cb3eb6/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=8b119bb67de0c95e25150b8a280878af67cb3eb6", "patch": "@@ -1327,7 +1327,7 @@ static reg_class_t\n mn10300_preferred_reload_class (rtx x, reg_class_t rclass)\n {\n   if (x == stack_pointer_rtx && rclass != SP_REGS)\n-     return ADDRESS_OR_EXTENDED_REGS;\n+    return (TARGET_AM33 ? GENERAL_REGS : ADDRESS_REGS);\n   else if (MEM_P (x)\n \t   || (REG_P (x) \n \t       && !HARD_REGISTER_P (x))\n@@ -1345,72 +1345,83 @@ static reg_class_t\n mn10300_preferred_output_reload_class (rtx x, reg_class_t rclass)\n {\n   if (x == stack_pointer_rtx && rclass != SP_REGS)\n-    return ADDRESS_OR_EXTENDED_REGS;\n-\n+    return (TARGET_AM33 ? GENERAL_REGS : ADDRESS_REGS);\n   return rclass;\n }\n \n-/* What (if any) secondary registers are needed to move IN with mode\n-   MODE into a register in register class RCLASS.\n-\n-   We might be able to simplify this.  */\n+/* Implement TARGET_SECONDARY_RELOAD.  */\n \n-enum reg_class\n-mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n-\t\t\t\trtx in)\n+static reg_class_t\n+mn10300_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n+\t\t\t  enum machine_mode mode, secondary_reload_info *sri)\n {\n-  rtx inner = in;\n-\n-  /* Strip off any SUBREG expressions from IN.  Basically we want\n-     to know if IN is a pseudo or (subreg (pseudo)) as those can\n-     turn into MEMs during reload.  */\n-  while (GET_CODE (inner) == SUBREG)\n-    inner = SUBREG_REG (inner);\n-\n-  /* Memory loads less than a full word wide can't have an\n-     address or stack pointer destination.  They must use\n-     a data register as an intermediate register.  */\n-  if ((MEM_P (in)\n-       || (REG_P (inner)\n-\t   && REGNO (inner) >= FIRST_PSEUDO_REGISTER))\n-      && (mode == QImode || mode == HImode)\n-      && (rclass == ADDRESS_REGS || rclass == SP_REGS\n-\t  || rclass == SP_OR_ADDRESS_REGS))\n+  enum reg_class rclass = (enum reg_class) rclass_i;\n+  enum reg_class xclass = NO_REGS;\n+  unsigned int xregno = INVALID_REGNUM;\n+\n+  if (REG_P (x))\n     {\n-      if (TARGET_AM33)\n-\treturn DATA_OR_EXTENDED_REGS;\n-      return DATA_REGS;\n+      xregno = REGNO (x);\n+      if (xregno >= FIRST_PSEUDO_REGISTER)\n+\txregno = true_regnum (x);\n+      if (xregno != INVALID_REGNUM)\n+\txclass = REGNO_REG_CLASS (xregno);\n+    }\n+\n+  if (!TARGET_AM33)\n+    {\n+      /* Memory load/stores less than a full word wide can't have an\n+         address or stack pointer destination.  They must use a data\n+         register as an intermediate register.  */\n+      if (rclass != DATA_REGS\n+\t  && (mode == QImode || mode == HImode)\n+\t  && xclass == NO_REGS)\n+\treturn DATA_REGS;\n+\n+      /* We can only move SP to/from an address register.  */\n+      if (in_p\n+\t  && rclass == SP_REGS\n+\t  && xclass != ADDRESS_REGS)\n+\treturn ADDRESS_REGS;\n+      if (!in_p\n+\t  && xclass == SP_REGS\n+\t  && rclass != ADDRESS_REGS\n+\t  && rclass != SP_OR_ADDRESS_REGS)\n+\treturn ADDRESS_REGS;\n     }\n \n-  /* We can't directly load sp + const_int into a data register;\n-     we must use an address register as an intermediate.  */\n-  if (rclass != SP_REGS\n-      && rclass != ADDRESS_REGS\n+  /* We can't directly load sp + const_int into a register;\n+     we must use an address register as an scratch.  */\n+  if (in_p\n+      && rclass != SP_REGS\n       && rclass != SP_OR_ADDRESS_REGS\n       && rclass != SP_OR_EXTENDED_REGS\n-      && rclass != ADDRESS_OR_EXTENDED_REGS\n       && rclass != SP_OR_ADDRESS_OR_EXTENDED_REGS\n-      && (in == stack_pointer_rtx\n-\t  || (GET_CODE (in) == PLUS\n-\t      && (XEXP (in, 0) == stack_pointer_rtx\n-\t\t  || XEXP (in, 1) == stack_pointer_rtx))))\n-    return ADDRESS_REGS;\n+      && GET_CODE (x) == PLUS\n+      && (XEXP (x, 0) == stack_pointer_rtx\n+\t  || XEXP (x, 1) == stack_pointer_rtx))\n+    {\n+      sri->icode = CODE_FOR_reload_plus_sp_const;\n+      return NO_REGS;\n+    }\n \n+  /* We can't load/store an FP register from a constant address.  */\n   if (TARGET_AM33_2\n-      && rclass == FP_REGS)\n+      && (rclass == FP_REGS || xclass == FP_REGS)\n+      && (xclass == NO_REGS || rclass == NO_REGS))\n     {\n-      /* We can't load directly into an FP register from a\t\n-\t constant address.  */\n-      if (MEM_P (in)\n-\t  && CONSTANT_ADDRESS_P (XEXP (in, 0)))\n-\treturn DATA_OR_EXTENDED_REGS;\n+      rtx addr = NULL;\n+\n+      if (xregno >= FIRST_PSEUDO_REGISTER && xregno != INVALID_REGNUM)\n+\t{\n+\t  addr = reg_equiv_mem [xregno];\n+\t  if (addr)\n+\t    addr = XEXP (addr, 0);\n+\t}\n+      else if (MEM_P (x))\n+\taddr = XEXP (x, 0);\n \n-      /* Handle case were a pseudo may not get a hard register\n-\t but has an equivalent memory location defined.  */\n-      if (REG_P (inner)\n-\t  && REGNO (inner) >= FIRST_PSEUDO_REGISTER\n-\t  && reg_equiv_mem [REGNO (inner)]\n-\t  && CONSTANT_ADDRESS_P (XEXP (reg_equiv_mem [REGNO (inner)], 0)))\n+      if (addr && CONSTANT_ADDRESS_P (addr))\n \treturn DATA_OR_EXTENDED_REGS;\n     }\n \n@@ -2802,7 +2813,10 @@ mn10300_md_asm_clobbers (tree outputs ATTRIBUTE_UNUSED,\n #undef  TARGET_PREFERRED_RELOAD_CLASS\n #define TARGET_PREFERRED_RELOAD_CLASS mn10300_preferred_reload_class\n #undef  TARGET_PREFERRED_OUTPUT_RELOAD_CLASS\n-#define TARGET_PREFERRED_OUTPUT_RELOAD_CLASS mn10300_preferred_output_reload_class\n+#define TARGET_PREFERRED_OUTPUT_RELOAD_CLASS \\\n+  mn10300_preferred_output_reload_class\n+#undef  TARGET_SECONDARY_RELOAD\n+#define TARGET_SECONDARY_RELOAD  mn10300_secondary_reload\n \n #undef  TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT mn10300_trampoline_init"}, {"sha": "1ed13b9b181b1d2c46900e7ef5cfdc696b96da23", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b119bb67de0c95e25150b8a280878af67cb3eb6/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b119bb67de0c95e25150b8a280878af67cb3eb6/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=8b119bb67de0c95e25150b8a280878af67cb3eb6", "patch": "@@ -416,9 +416,6 @@ enum reg_class\n #define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n   (!TARGET_AM33 && (MODE == QImode || MODE == HImode) ? DATA_REGS : CLASS)\n \n-#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  mn10300_secondary_reload_class(CLASS,MODE,IN)\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n "}, {"sha": "7dd33676cf0f8fcf235e3934657f341414ac6b70", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b119bb67de0c95e25150b8a280878af67cb3eb6/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b119bb67de0c95e25150b8a280878af67cb3eb6/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=8b119bb67de0c95e25150b8a280878af67cb3eb6", "patch": "@@ -285,42 +285,52 @@\n ;; We use this to handle addition of two values when one operand is the\n ;; stack pointer and the other is a memory reference of some kind.  Reload\n ;; does not handle them correctly without this expander.\n-(define_expand \"reload_insi\"\n-  [(set (match_operand:SI     0 \"register_operand\" \"=a\")\n+(define_expand \"reload_plus_sp_const\"\n+  [(set (match_operand:SI     0 \"register_operand\" \"=r\")\n \t(match_operand:SI     1 \"impossible_plus_operand\" \"\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))]\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&A\"))]\n   \"\"\n   \"\n {\n-  gcc_assert (REGNO (operands[0]) != REGNO (operands[2]));\n+  rtx dest, scratch, other;\n \n-  if (XEXP (operands[1], 0) == stack_pointer_rtx)\n+  dest = operands[0];\n+  scratch = operands[2];\n+\n+  other = XEXP (operands[1], 1);\n+  if (other == stack_pointer_rtx)\n+    other = XEXP (operands[1], 0);\n+\n+  if (true_regnum (other) == true_regnum (dest))\n     {\n-      if (GET_CODE (XEXP (operands[1], 1)) == SUBREG\n-\t  && (GET_MODE_SIZE (GET_MODE (XEXP (operands[1], 1)))\n-\t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (operands[1], 1))))))\n-\temit_move_insn (operands[2],\n-\t\t\tgen_rtx_ZERO_EXTEND\n-\t\t\t(GET_MODE (XEXP (operands[1], 1)),\n-\t\t\t SUBREG_REG (XEXP (operands[1], 1))));\n-      else\n-\temit_move_insn (operands[2], XEXP (operands[1], 1));\n-      emit_move_insn (operands[0], XEXP (operands[1], 0));\n+      gcc_assert (true_regnum (scratch) != true_regnum (dest));\n+      emit_move_insn (scratch, stack_pointer_rtx);\n+      emit_insn (gen_addsi3 (dest, dest, scratch));\n+    }\n+  else if (TARGET_AM33 || REGNO_REG_CLASS (true_regnum (dest)) == ADDRESS_REGS)\n+    {\n+      emit_move_insn (dest, stack_pointer_rtx);\n+      if (other == stack_pointer_rtx)\n+        emit_insn (gen_addsi3 (dest, dest, dest));\n+      else if (other != const0_rtx)\n+        emit_insn (gen_addsi3 (dest, dest, other));\n     }\n   else\n     {\n-      if (GET_CODE (XEXP (operands[1], 0)) == SUBREG\n-\t  && (GET_MODE_SIZE (GET_MODE (XEXP (operands[1], 0)))\n-\t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (operands[1], 0))))))\n-\temit_move_insn (operands[2],\n-\t\t\tgen_rtx_ZERO_EXTEND\n-\t\t\t(GET_MODE (XEXP (operands[1], 0)),\n-\t\t\t SUBREG_REG (XEXP (operands[1], 0))));\n+      emit_move_insn (scratch, stack_pointer_rtx);\n+      if (other == stack_pointer_rtx)\n+\t{\n+\t  emit_move_insn (dest, scratch);\n+          emit_insn (gen_addsi3 (dest, dest, dest));\n+\t}\n+      else if (other != const0_rtx)\n+\t{\n+\t  emit_move_insn (dest, other);\n+          emit_insn (gen_addsi3 (dest, dest, scratch));\n+\t}\n       else\n-\temit_move_insn (operands[2], XEXP (operands[1], 0));\n-      emit_move_insn (operands[0], XEXP (operands[1], 1));\n+\temit_move_insn (dest, scratch);\n     }\n-  emit_insn (gen_addsi3 (operands[0], operands[0], operands[2]));\n   DONE;\n }\")\n "}]}