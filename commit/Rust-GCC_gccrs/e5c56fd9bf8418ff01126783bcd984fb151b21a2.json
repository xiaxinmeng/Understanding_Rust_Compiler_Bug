{"sha": "e5c56fd9bf8418ff01126783bcd984fb151b21a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVjNTZmZDliZjg0MThmZjAxMTI2NzgzYmNkOTg0ZmIxNTFiMjFhMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-05-17T21:21:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-05-17T21:21:21Z"}, "message": "integrate.c (copy_rtx_and_substitute): Use simplify_gen_subreg.\n\n\t* integrate.c (copy_rtx_and_substitute): Use simplify_gen_subreg.\n\t(simplify_subreg): Handle complex types represented as CONCAT.\n\n\t* recog.c (validate_replace_rtx_1): Properly canonicalize expression\n\t* rtl.h (swap_commutative_operands_p): Declare.\n\t* rtlanal.c (swap_commutative_operands_p): New.\n\t(operand_preference): New static function.\n\n\t* combine.c (combine_simplify_rtx): Use swap_commutative_operands_p.\n\t(gen_binary): Likewise.\n\t* optabs.c (emit_cmp_and_jump_insns, emit_conditional_move): Likewise.\n\t* simplify-rtx.c (simplify_gen_binary,\n\tsimplify_gen_relational): Likewise.\n\nFrom-SVN: r42224", "tree": {"sha": "6be18b336d723f66b33f5327a8908ec4da42a48e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6be18b336d723f66b33f5327a8908ec4da42a48e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5c56fd9bf8418ff01126783bcd984fb151b21a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c56fd9bf8418ff01126783bcd984fb151b21a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c56fd9bf8418ff01126783bcd984fb151b21a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c56fd9bf8418ff01126783bcd984fb151b21a2/comments", "author": null, "committer": null, "parents": [{"sha": "949c5d62571446e982b85c6190af0a172d645356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/949c5d62571446e982b85c6190af0a172d645356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/949c5d62571446e982b85c6190af0a172d645356"}], "stats": {"total": 161, "additions": 94, "deletions": 67}, "files": [{"sha": "1bd75c2f1b4951befd7aafffb443ecb1443dc89e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5c56fd9bf8418ff01126783bcd984fb151b21a2", "patch": "@@ -1,3 +1,19 @@\n+Thu May 17 23:19:46 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* integrate.c (copy_rtx_and_substitute): Use simplify_gen_subreg.\n+\t(simplify_subreg): Handle complex types represented as CONCAT.\n+\n+\t* recog.c (validate_replace_rtx_1): Properly canonicalize expression\n+\t* rtl.h (swap_commutative_operands_p): Declare.\n+\t* rtlanal.c (swap_commutative_operands_p): New.\n+\t(operand_preference): New static function.\n+\n+\t* combine.c (combine_simplify_rtx): Use swap_commutative_operands_p.\n+\t(gen_binary): Likewise.\n+\t* optabs.c (emit_cmp_and_jump_insns, emit_conditional_move): Likewise.\n+\t* simplify-rtx.c (simplify_gen_binary,\n+\tsimplify_gen_relational): Likewise.\n+\n Thu May 17 20:43:36 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* cse.c (fold_rtx): Use simplify_subreg."}, {"sha": "ceb6dc77b763315c246a651ae7c04abd158b593f", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e5c56fd9bf8418ff01126783bcd984fb151b21a2", "patch": "@@ -3514,12 +3514,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n   /* If this is a commutative operation, put a constant last and a complex\n      expression first.  We don't need to do this for comparisons here.  */\n   if (GET_RTX_CLASS (code) == 'c'\n-      && ((CONSTANT_P (XEXP (x, 0)) && GET_CODE (XEXP (x, 1)) != CONST_INT)\n-\t  || (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == 'o'\n-\t      && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) != 'o')\n-\t  || (GET_CODE (XEXP (x, 0)) == SUBREG\n-\t      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 0)))) == 'o'\n-\t      && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) != 'o')))\n+      && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n     {\n       temp = XEXP (x, 0);\n       SUBST (XEXP (x, 0), XEXP (x, 1));\n@@ -9818,12 +9813,7 @@ gen_binary (code, mode, op0, op1)\n \n   /* Put complex operands first and constants second.  */\n   if (GET_RTX_CLASS (code) == 'c'\n-      && ((CONSTANT_P (op0) && GET_CODE (op1) != CONST_INT)\n-\t  || (GET_RTX_CLASS (GET_CODE (op0)) == 'o'\n-\t      && GET_RTX_CLASS (GET_CODE (op1)) != 'o')\n-\t  || (GET_CODE (op0) == SUBREG\n-\t      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (op0))) == 'o'\n-\t      && GET_RTX_CLASS (GET_CODE (op1)) != 'o')))\n+      && swap_commutative_operands_p (op0, op1))\n     return gen_rtx_fmt_ee (code, mode, op1, op0);\n \n   /* If we are turning off bits already known off in OP0, we need not do"}, {"sha": "e1e26df102272a4c2670224ead1318cb5555b2a3", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e5c56fd9bf8418ff01126783bcd984fb151b21a2", "patch": "@@ -1308,10 +1308,6 @@ int\n subreg_lowpart_p (x)\n      rtx x;\n {\n-  unsigned int offset = 0;\n-  int difference = (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n-\t\t    - GET_MODE_SIZE (GET_MODE (x)));\n-\n   if (GET_CODE (x) != SUBREG)\n     return 1;\n   else if (GET_MODE (SUBREG_REG (x)) == VOIDmode)"}, {"sha": "29acaf2939f1a781393935d16399ef2343fe2bb1", "filename": "gcc/integrate.c", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=e5c56fd9bf8418ff01126783bcd984fb151b21a2", "patch": "@@ -1902,35 +1902,9 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \n     case SUBREG:\n       copy = copy_rtx_and_substitute (SUBREG_REG (orig), map, for_lhs);\n-      /* SUBREG is ordinary, but don't make nested SUBREGs.  */\n-      if (GET_CODE (copy) == SUBREG)\n-\t{\n-\t  int final_offset = SUBREG_BYTE (orig) + SUBREG_BYTE (copy);\n-\n-\t  /* When working with SUBREGs the rule is that the byte\n-\t     offset must be a multiple of the SUBREG's mode.  */\n-\t  final_offset = (final_offset / GET_MODE_SIZE (GET_MODE (orig)));\n-\t  final_offset = (final_offset * GET_MODE_SIZE (GET_MODE (orig)));\n-\t  return gen_rtx_SUBREG (GET_MODE (orig), SUBREG_REG (copy),\n-\t\t\t\t final_offset);\n-\t}\n-      else if (GET_CODE (copy) == CONCAT)\n-\t{\n-\t  rtx retval = subreg_realpart_p (orig) ? XEXP (copy, 0) : XEXP (copy, 1);\n-\t  int final_offset;\n-\n-\t  if (GET_MODE (retval) == GET_MODE (orig))\n-\t    return retval;\n-\t  \n-\t  final_offset = SUBREG_BYTE (orig) %\n-\t  \t\t GET_MODE_UNIT_SIZE (GET_MODE (SUBREG_REG (orig)));\n-\t  final_offset = (final_offset / GET_MODE_SIZE (GET_MODE (orig)));\n-\t  final_offset = (final_offset * GET_MODE_SIZE (GET_MODE (orig)));\n-\t  return gen_rtx_SUBREG (GET_MODE (orig), retval, final_offset);\n-\t}\n-      else\n-\treturn gen_rtx_SUBREG (GET_MODE (orig), copy,\n-\t\t\t       SUBREG_BYTE (orig));\n+      return simplify_gen_subreg (GET_MODE (orig), copy,\n+\t\t\t\t  GET_MODE (SUBREG_REG (orig)),\n+\t\t\t\t  SUBREG_BYTE (orig));\n \n     case ADDRESSOF:\n       copy = gen_rtx_ADDRESSOF (mode,"}, {"sha": "a2a42c636b162aadc44abe38cd3da370d1b40de9", "filename": "gcc/optabs.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e5c56fd9bf8418ff01126783bcd984fb151b21a2", "patch": "@@ -3290,8 +3290,7 @@ emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, label)\n   rtx op0;\n   rtx op1;\n \t  \n-  if ((CONSTANT_P (x) && ! CONSTANT_P (y))\n-      || (GET_CODE (x) == CONST_INT && GET_CODE (y) != CONST_INT))\n+  if (swap_commutative_operands_p (x, y))\n     {\n       /* Swap operands and condition to ensure canonical RTL.  */\n       op0 = y;\n@@ -3609,12 +3608,12 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n {\n   rtx tem, subtarget, comparison, insn;\n   enum insn_code icode;\n+  enum rtx_code reversed;\n \n   /* If one operand is constant, make it the second one.  Only do this\n      if the other operand is not constant as well.  */\n \n-  if ((CONSTANT_P (op0) && ! CONSTANT_P (op1))\n-      || (GET_CODE (op0) == CONST_INT && GET_CODE (op1) != CONST_INT))\n+  if (swap_commutative_operands_p (op0, op1))\n     {\n       tem = op0;\n       op0 = op1;\n@@ -3633,16 +3632,14 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n   if (cmode == VOIDmode)\n     cmode = GET_MODE (op0);\n \n-  if (((CONSTANT_P (op2) && ! CONSTANT_P (op3))\n-       || (GET_CODE (op2) == CONST_INT && GET_CODE (op3) != CONST_INT))\n-      && (GET_MODE_CLASS (GET_MODE (op1)) != MODE_FLOAT\n-\t  || TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT \n-\t  || flag_unsafe_math_optimizations))\n+  if (swap_commutative_operands_p (op2, op3)\n+      && ((reversed = reversed_comparison_code_parts (code, op0, op1, NULL))\n+          != UNKNOWN))\n     {\n       tem = op2;\n       op2 = op3;\n       op3 = tem;\n-      code = reverse_condition (code);\n+      code = reversed;\n     }\n \n   if (mode == VOIDmode)"}, {"sha": "44c61ef863ea67055e342d7b494b736856a45e2d", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e5c56fd9bf8418ff01126783bcd984fb151b21a2", "patch": "@@ -1370,6 +1370,7 @@ extern int reg_used_between_p\t\tPARAMS ((rtx, rtx, rtx));\n extern int reg_referenced_between_p\tPARAMS ((rtx, rtx, rtx));\n extern int reg_set_between_p\t\tPARAMS ((rtx, rtx, rtx));\n extern int regs_set_between_p\t\tPARAMS ((rtx, rtx, rtx));\n+extern int swap_commutative_operands_p\tPARAMS ((rtx, rtx));\n extern int modified_between_p\t\tPARAMS ((rtx, rtx, rtx));\n extern int no_labels_between_p\t\tPARAMS ((rtx, rtx));\n extern int no_jumps_between_p\t\tPARAMS ((rtx, rtx));"}, {"sha": "af0f81fc81732cdd2ba2071fdaf6b5aa5be773c7", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e5c56fd9bf8418ff01126783bcd984fb151b21a2", "patch": "@@ -30,6 +30,7 @@ Boston, MA 02111-1307, USA.  */\n static void set_of_1\t\tPARAMS ((rtx, rtx, void *));\n static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n static int computed_jump_p_1\tPARAMS ((rtx));\n+static int operand_preference\tPARAMS ((rtx));\n \n /* Bit flags that specify the machine subtype we are compiling for.\n    Bits are tested using macros TARGET_... defined in the tm.h file\n@@ -2533,6 +2534,52 @@ regno_use_in (regno, x)\n   return NULL_RTX;\n }\n \n+/* Return a value indicating whether OP, an operand of a commutative\n+   operation, is preferred as the first or second operand.  The higher\n+   the value, the stronger the preference for being the first operand.\n+   We use negative values to indicate a preference for the first operand\n+   and positive values for the second operand.  */\n+\n+static int\n+operand_preference (op)\n+     rtx op;\n+{\n+  /* Constants always come the second operand.  Prefer \"nice\" constants.  */\n+  if (GET_CODE (op) == CONST_INT)\n+    return -4;\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    return -3;\n+  if (CONSTANT_P (op))\n+    return -2;\n+\n+  /* SUBREGs of objects should come second.  */\n+  if (GET_CODE (op) == SUBREG\n+      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (op))) == 'o')\n+    return -1;\n+\n+  /* If only one operand is a `neg', `not',\n+    `mult', `plus', or `minus' expression, it will be the first\n+    operand.  */\n+  if (GET_CODE (op) == NEG || GET_CODE (op) == NOT\n+      || GET_CODE (op) == MULT || GET_CODE (op) == PLUS\n+      || GET_CODE (op) == MINUS)\n+    return 2;\n+\n+  /* Complex expressions should be the first.  */\n+  if (GET_RTX_CLASS (GET_CODE (op)) == 'o')\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return 1 iff it is neccesary to swap operands of commutative operation\n+   in order to canonicalize expression.  */\n+\n+int\n+swap_commutative_operands_p (x, y)\n+     rtx x, y;\n+{\n+  return operand_preference (x) < operand_preference (y);\n+}\n \n /* Return 1 if X is an autoincrement side effect and the register is\n    not the stack pointer.  */"}, {"sha": "e586b015413379e04dddbe26c929b9fffd575460", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c56fd9bf8418ff01126783bcd984fb151b21a2/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=e5c56fd9bf8418ff01126783bcd984fb151b21a2", "patch": "@@ -113,12 +113,7 @@ simplify_gen_binary (code, mode, op0, op1)\n \n   /* Put complex operands first and constants second if commutative.  */\n   if (GET_RTX_CLASS (code) == 'c'\n-      && ((CONSTANT_P (op0) && GET_CODE (op1) != CONST_INT)\n-\t  || (GET_RTX_CLASS (GET_CODE (op0)) == 'o'\n-\t      && GET_RTX_CLASS (GET_CODE (op1)) != 'o')\n-\t  || (GET_CODE (op0) == SUBREG\n-\t      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (op0))) == 'o'\n-\t      && GET_RTX_CLASS (GET_CODE (op1)) != 'o')))\n+      && swap_commutative_operands_p (op0, op1))\n     tem = op0, op0 = op1, op1 = tem;\n \n   /* If this simplifies, do it.  */\n@@ -194,12 +189,7 @@ simplify_gen_relational (code, mode, cmp_mode, op0, op1)\n     return tem;\n \n   /* Put complex operands first and constants second.  */\n-  if ((CONSTANT_P (op0) && GET_CODE (op1) != CONST_INT)\n-      || (GET_RTX_CLASS (GET_CODE (op0)) == 'o'\n-\t  && GET_RTX_CLASS (GET_CODE (op1)) != 'o')\n-      || (GET_CODE (op0) == SUBREG\n-\t  && GET_RTX_CLASS (GET_CODE (SUBREG_REG (op0))) == 'o'\n-\t  && GET_RTX_CLASS (GET_CODE (op1)) != 'o'))\n+  if (swap_commutative_operands_p (op0, op1))\n     tem = op0, op0 = op1, op1 = tem, code = swap_condition (code);\n \n   return gen_rtx_fmt_ee (code, mode, op0, op1);\n@@ -2212,6 +2202,9 @@ simplify_subreg (outermode, op, innermode, byte)\n       || byte >= GET_MODE_SIZE (innermode))\n     abort ();\n \n+  if (outermode == innermode && !byte)\n+    return op;\n+\n   /* Attempt to simplify constant to non-SUBREG expression.  */\n   if (CONSTANT_P (op))\n     {\n@@ -2388,6 +2381,19 @@ simplify_subreg (outermode, op, innermode, byte)\n       MEM_COPY_ATTRIBUTES (new, op);\n       return new;\n     }\n+\n+  /* Handle complex values represented as CONCAT\n+     of real and imaginary part.  */\n+  if (GET_CODE (op) == CONCAT)\n+    {\n+      int is_realpart = byte < GET_MODE_UNIT_SIZE (innermode) / 2;\n+      rtx part = is_realpart ? XEXP (op, 0) : XEXP (op, 1);\n+      unsigned int final_offset;\n+\n+      final_offset = SUBREG_BYTE (op) % (GET_MODE_UNIT_SIZE (innermode) / 2);\n+      return simplify_subreg (outermode, part, GET_MODE (part), final_offset);\n+    }\n+\n   return NULL_RTX;\n }\n /* Make a SUBREG operation or equivalent if it folds.  */"}]}