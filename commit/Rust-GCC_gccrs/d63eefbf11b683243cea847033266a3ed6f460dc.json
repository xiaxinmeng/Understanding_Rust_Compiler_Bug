{"sha": "d63eefbf11b683243cea847033266a3ed6f460dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYzZWVmYmYxMWI2ODMyNDNjZWE4NDcwMzMyNjZhM2VkNmY0NjBkYw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-20T23:59:26Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-20T23:59:26Z"}, "message": "cppmacro.c (paste_tokens): Rename from paste_payloads.\n\n        * cppmacro.c (paste_tokens): Rename from paste_payloads.\n        Change token type after pasting spellings.\n        (paste_all_tokens): Use it.\n\nFrom-SVN: r37596", "tree": {"sha": "a425596f26f500fe84874b6ee0055ed816a85eb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a425596f26f500fe84874b6ee0055ed816a85eb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d63eefbf11b683243cea847033266a3ed6f460dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d63eefbf11b683243cea847033266a3ed6f460dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d63eefbf11b683243cea847033266a3ed6f460dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d63eefbf11b683243cea847033266a3ed6f460dc/comments", "author": null, "committer": null, "parents": [{"sha": "1535cc88f20ca7b9c872879fe42c24a8f4222cc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1535cc88f20ca7b9c872879fe42c24a8f4222cc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1535cc88f20ca7b9c872879fe42c24a8f4222cc3"}], "stats": {"total": 166, "additions": 92, "deletions": 74}, "files": [{"sha": "1feb9606cbca98d41edda8e91e0a8cb08de1db6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63eefbf11b683243cea847033266a3ed6f460dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63eefbf11b683243cea847033266a3ed6f460dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d63eefbf11b683243cea847033266a3ed6f460dc", "patch": "@@ -1,3 +1,11 @@\n+2000-11-20  Neil Booth  <neilb@earthling.net>\n+\n+\t* cppmacro.c (paste_tokens): Rename from paste_payloads.\n+\tChange token type after pasting spellings.\n+\t(paste_all_tokens): Use it.\n+\t* gcc.dg/cpp/paste2.c: Update test.\n+\t* objc/execute/paste.m: New test.\n+\n 2000-11-20  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf.h (FMT_CODE): Adjust argument order; fix mapping to"}, {"sha": "c5ec6de49d90ddd3e609c47f3bf2b1c412ae8e03", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 84, "deletions": 74, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63eefbf11b683243cea847033266a3ed6f460dc/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63eefbf11b683243cea847033266a3ed6f460dc/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=d63eefbf11b683243cea847033266a3ed6f460dc", "patch": "@@ -75,8 +75,7 @@ static void make_string_token PARAMS ((cpp_pool *, cpp_token *,\n static void make_number_token PARAMS ((cpp_reader *, cpp_token *, int));\n static void stringify_arg PARAMS ((cpp_reader *, macro_arg *));\n static void paste_all_tokens PARAMS ((cpp_reader *, cpp_token *));\n-static void paste_payloads PARAMS ((cpp_reader *, cpp_token *,\n-\t\t\t\t    const cpp_token *));\n+static int paste_tokens PARAMS ((cpp_reader *, cpp_token *, cpp_token *));\n static int funlike_invocation_p PARAMS ((cpp_reader *, const cpp_hashnode *,\n \t\t\t\t\t  struct toklist *));\n static void replace_args PARAMS ((cpp_reader *, cpp_macro *, macro_arg *,\n@@ -260,40 +259,6 @@ unlock_pools (pfile)\n   _cpp_unlock_pool (&pfile->argument_pool);\n }\n \n-static void\n-paste_payloads (pfile, lhs, rhs)\n-     cpp_reader *pfile;\n-     cpp_token *lhs;\n-     const cpp_token *rhs;\n-{\n-  unsigned int total_len = cpp_token_len (lhs) + cpp_token_len (rhs);\n-  unsigned char *result, *end;\n-  cpp_pool *pool;\n-\n-  pool = lhs->type == CPP_NAME ? &pfile->ident_pool: pfile->string_pool;\n-  result = _cpp_pool_alloc (pool, total_len + 1);\n-\n-  /* Paste the spellings and null terminate.  */\n-  end = cpp_spell_token (pfile, rhs, cpp_spell_token (pfile, lhs, result));\n-  *end = '\\0';\n-  total_len = end - result;\n-\n-  if (lhs->type == CPP_NAME)\n-    {\n-      lhs->val.node = cpp_lookup (pfile, result, total_len);\n-      if (lhs->val.node->flags & NODE_OPERATOR)\n-\t{\n-\t  lhs->flags |= NAMED_OP;\n-\t  lhs->type = lhs->val.node->value.operator;\n-\t}\n-    }\n-  else\n-    {\n-      lhs->val.str.text = result;\n-      lhs->val.str.len = total_len;\n-    }\n-}\n-\n /* Adds backslashes before all backslashes and double quotes appearing\n    in strings.  Non-printable characters are converted to octal.  */\n static U_CHAR *\n@@ -398,64 +363,109 @@ stringify_arg (pfile, arg)\n   arg->stringified->val.str.len = total_len;\n }\n \n+/* Try to paste two tokens.  On success, the LHS becomes the pasted\n+   token, and 0 is returned.  For failure, we update the flags of the\n+   RHS appropriately and return non-zero.  */\n+static int\n+paste_tokens (pfile, lhs, rhs)\n+     cpp_reader *pfile;\n+     cpp_token *lhs, *rhs;\n+{\n+  unsigned char flags;\n+  int digraph = 0;\n+  enum cpp_ttype type;\n+\n+  type = cpp_can_paste (pfile, lhs, rhs, &digraph);\n+  \n+  if (type == CPP_EOF)\n+    {\n+      if (CPP_OPTION (pfile, warn_paste))\n+\tcpp_warning (pfile,\n+\t \"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\",\n+\t\t     cpp_token_as_text (pfile, lhs),\n+\t\t     cpp_token_as_text (pfile, rhs));\n+\n+      /* The standard states that behaviour is undefined.  By the\n+\t principle of least surpise, we step back before the RHS, and\n+\t mark it to prevent macro expansion.  Tests in the testsuite\n+\t rely on clearing PREV_WHITE here, though you could argue we\n+\t should actually set it.  */\n+      rhs->flags &= ~PREV_WHITE;\n+      rhs->flags |= NO_EXPAND;\n+      return 1;\n+    }\n+\n+  flags = lhs->flags & ~DIGRAPH;\n+  if (digraph)\n+    flags |= DIGRAPH;\n+\n+  /* Identifiers and numbers need spellings to be pasted.  */\n+  if (type == CPP_NAME || type == CPP_NUMBER)\n+    {\n+      unsigned int total_len = cpp_token_len (lhs) + cpp_token_len (rhs);\n+      unsigned char *result, *end;\n+      cpp_pool *pool;\n+\n+      pool = type == CPP_NAME ? &pfile->ident_pool: pfile->string_pool;\n+      result = _cpp_pool_alloc (pool, total_len + 1);\n+\n+      /* Paste the spellings and null terminate.  */\n+      end = cpp_spell_token (pfile, rhs, cpp_spell_token (pfile, lhs, result));\n+      *end = '\\0';\n+      total_len = end - result;\n+\n+      if (type == CPP_NAME)\n+\t{\n+\t  lhs->val.node = cpp_lookup (pfile, result, total_len);\n+\t  if (lhs->val.node->flags & NODE_OPERATOR)\n+\t    {\n+\t      flags |= NAMED_OP;\n+\t      lhs->type = lhs->val.node->value.operator;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  lhs->val.str.text = result;\n+\t  lhs->val.str.len = total_len;\n+\t}\n+    }\n+  else if (type == CPP_WCHAR || type == CPP_WSTRING)\n+    lhs->val.str = rhs->val.str;\n+\n+  /* Set type and flags after pasting spellings.  */\n+  lhs->type = type;\n+  lhs->flags = flags;\n+\n+  return 0;\n+}\n+\n /* Handles an arbitrarily long sequence of ## operators.  This\n    implementation is left-associative, non-recursive, and finishes a\n-   paste before handling succeeding ones.  If the paste fails, the\n-   right hand side of the ## operator is placed in the then-current\n-   context's lookahead buffer, with the effect that it appears in the\n-   output stream normally.  */\n+   paste before handling succeeding ones.  If the paste fails, we back\n+   up a token to just after the ## operator, with the effect that it\n+   appears in the output stream normally.  */\n static void\n paste_all_tokens (pfile, lhs)\n      cpp_reader *pfile;\n      cpp_token *lhs;\n {\n-  unsigned char orig_flags = lhs->flags;\n   cpp_token *rhs;\n+  unsigned char orig_flags = lhs->flags;\n \n   do\n     {\n-      int digraph = 0;\n-      enum cpp_ttype type;\n-\n       /* Take the token directly from the current context.  We can do\n \t this, because we are in the replacement list of either an\n \t object-like macro, or a function-like macro with arguments\n \t inserted.  In either case, the constraints to #define\n-\t guarantee we have at least one more token (empty arguments\n-\t become placemarkers).  */\n+\t guarantee we have at least one more token.  */\n       rhs = pfile->context->list.first++;\n-\n-      type = cpp_can_paste (pfile, lhs, rhs, &digraph);\n-      if (type == CPP_EOF)\n+      if (paste_tokens (pfile, lhs, rhs))\n \t{\n-\t  if (CPP_OPTION (pfile, warn_paste))\n-\t    cpp_warning (pfile,\n-\t \"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\",\n-\t\t\t cpp_token_as_text (pfile, lhs),\n-\t\t\t cpp_token_as_text (pfile, rhs));\n-\n-\t  /* The standard states that behaviour is undefined.  By the\n-\t     principle of least surpise, we step back before the RHS,\n-\t     and mark it to prevent macro expansion.  Tests in the\n-\t     testsuite rely on clearing PREV_WHITE here, though you\n-\t     could argue we should actually set it.  */\n-\t  rhs->flags &= ~PREV_WHITE;\n-\t  rhs->flags |= NO_EXPAND;\n-\n-\t  /* Step back so we read the RHS in next.  */\n+\t  /* We failed.  Step back so we read the RHS in next.  */\n \t  pfile->context->list.first--;\n \t  break;\n \t}\n-\n-      lhs->type = type;\n-      lhs->flags &= ~DIGRAPH;\n-      if (digraph)\n-\tlhs->flags |= DIGRAPH;\n-\n-      if (type == CPP_NAME || type == CPP_NUMBER)\n-\tpaste_payloads (pfile, lhs, rhs);\n-      else if (type == CPP_WCHAR || type == CPP_WSTRING)\n-\tlhs->val.str = rhs->val.str;\n     }\n   while (rhs->flags & PASTE_LEFT);\n "}]}