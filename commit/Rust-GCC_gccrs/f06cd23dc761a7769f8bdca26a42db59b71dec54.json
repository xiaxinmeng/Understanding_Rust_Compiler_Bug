{"sha": "f06cd23dc761a7769f8bdca26a42db59b71dec54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA2Y2QyM2RjNzYxYTc3NjlmOGJkY2EyNmE0MmRiNTliNzFkZWM1NA==", "commit": {"author": {"name": "Zhenqiang Chen", "email": "zhenqiang.chen@linaro.org", "date": "2014-11-17T06:03:07Z"}, "committer": {"name": "Zhenqiang Chen", "email": "zqchen@gcc.gnu.org", "date": "2014-11-17T06:03:07Z"}, "message": "Makefile.in: Add ccmp.o.\n\n2014-11-17  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n\n\t* Makefile.in: Add ccmp.o.\n\t* ccmp.c: New file.\n\t* ccmp.h: New file.\n\t* expr.c: include \"ccmp.h\"\n\t(expand_cond_expr_using_cmove): Handle VOIDmode.\n\t(expand_expr_real_1): Try to expand ccmp.\n\nFrom-SVN: r217641", "tree": {"sha": "6cfdb458bba92a9545deccf6b36dbf8290c4cc36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cfdb458bba92a9545deccf6b36dbf8290c4cc36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f06cd23dc761a7769f8bdca26a42db59b71dec54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f06cd23dc761a7769f8bdca26a42db59b71dec54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f06cd23dc761a7769f8bdca26a42db59b71dec54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f06cd23dc761a7769f8bdca26a42db59b71dec54/comments", "author": null, "committer": null, "parents": [{"sha": "2d52a3a19d16f75e57f5278d722e227d29ba4d03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d52a3a19d16f75e57f5278d722e227d29ba4d03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d52a3a19d16f75e57f5278d722e227d29ba4d03"}], "stats": {"total": 355, "additions": 354, "deletions": 1}, "files": [{"sha": "c5da3318e8cc8a79aee0deafe6a1ced284a44fda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06cd23dc761a7769f8bdca26a42db59b71dec54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06cd23dc761a7769f8bdca26a42db59b71dec54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f06cd23dc761a7769f8bdca26a42db59b71dec54", "patch": "@@ -1,3 +1,12 @@\n+2014-11-17  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n+\n+\t* Makefile.in: Add ccmp.o.\n+\t* ccmp.c: New file.\n+\t* ccmp.h: New file.\n+\t* expr.c: include \"ccmp.h\"\n+\t(expand_cond_expr_using_cmove): Handle VOIDmode.\n+\t(expand_expr_real_1): Try to expand ccmp.\n+\n 2014-11-17  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n \n \t* cfgexpand.c (expand_gimple_cond): Check ccmp."}, {"sha": "49f94e751b3d31be6068f3cb933d7398a10455c2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06cd23dc761a7769f8bdca26a42db59b71dec54/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06cd23dc761a7769f8bdca26a42db59b71dec54/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f06cd23dc761a7769f8bdca26a42db59b71dec54", "patch": "@@ -1174,6 +1174,7 @@ OBJS = \\\n \tbuiltins.o \\\n \tcaller-save.o \\\n \tcalls.o \\\n+\tccmp.o \\\n \tcfg.o \\\n \tcfganal.o \\\n \tcfgbuild.o \\"}, {"sha": "9c239e2b5a84613be025f11ea5defe54b353e1fd", "filename": "gcc/ccmp.c", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06cd23dc761a7769f8bdca26a42db59b71dec54/gcc%2Fccmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06cd23dc761a7769f8bdca26a42db59b71dec54/gcc%2Fccmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.c?ref=f06cd23dc761a7769f8bdca26a42db59b71dec54", "patch": "@@ -0,0 +1,306 @@\n+/* Conditional compare related functions\n+   Copyright (C) 2014-2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"stor-layout.h\"\n+#include \"regs.h\"\n+#include \"expr.h\"\n+#include \"insn-codes.h\"\n+#include \"optabs.h\"\n+#include \"tree-iterator.h\"\n+#include \"predict.h\"\n+#include \"dominance.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"gimple-ssa.h\"\n+#include \"tree-ssanames.h\"\n+#include \"target.h\"\n+#include \"common/common-target.h\"\n+#include \"df.h\"\n+#include \"tree-ssa-live.h\"\n+#include \"tree-outof-ssa.h\"\n+#include \"cfgexpand.h\"\n+#include \"tree-phinodes.h\"\n+#include \"ssa-iterators.h\"\n+#include \"expmed.h\"\n+#include \"ccmp.h\"\n+\n+/* The following functions expand conditional compare (CCMP) instructions.\n+   Here is a short description about the over all algorithm:\n+     * ccmp_candidate_p is used to identify the CCMP candidate\n+\n+     * expand_ccmp_expr is the main entry, which calls expand_ccmp_expr_1\n+       to expand CCMP.\n+\n+     * expand_ccmp_expr_1 uses a recursive algorithm to expand CCMP.\n+       It calls two target hooks gen_ccmp_first and gen_ccmp_next to generate\n+       CCMP instructions.\n+\t - gen_ccmp_first expands the first compare in CCMP.\n+\t - gen_ccmp_next expands the following compares.\n+\n+     * If the final result is not used in a COND_EXPR (checked by function\n+       used_in_cond_stmt_p), it calls cstorecc4 pattern to store the CC to a\n+       general register.  */\n+\n+/* Check whether G is a potential conditional compare candidate.  */\n+static bool\n+ccmp_candidate_p (gimple g)\n+{\n+  tree rhs = gimple_assign_rhs_to_tree (g);\n+  tree lhs, op0, op1;\n+  gimple gs0, gs1;\n+  enum tree_code tcode, tcode0, tcode1;\n+  tcode = TREE_CODE (rhs);\n+\n+  if (tcode != BIT_AND_EXPR && tcode != BIT_IOR_EXPR)\n+    return false;\n+\n+  lhs = gimple_assign_lhs (g);\n+  op0 = TREE_OPERAND (rhs, 0);\n+  op1 = TREE_OPERAND (rhs, 1);\n+\n+  if ((TREE_CODE (op0) != SSA_NAME) || (TREE_CODE (op1) != SSA_NAME)\n+      || !has_single_use (lhs))\n+    return false;\n+\n+  gs0 = get_gimple_for_ssa_name (op0);\n+  gs1 = get_gimple_for_ssa_name (op1);\n+  if (!gs0 || !gs1 || !is_gimple_assign (gs0) || !is_gimple_assign (gs1)\n+      /* g, gs0 and gs1 must be in the same basic block, since current stage\n+\t is out-of-ssa.  We can not guarantee the correctness when forwording\n+\t the gs0 and gs1 into g whithout DATAFLOW analysis.  */\n+      || gimple_bb (gs0) != gimple_bb (gs1)\n+      || gimple_bb (gs0) != gimple_bb (g))\n+    return false;\n+\n+  if (!(INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (gs0)))\n+       || POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (gs0))))\n+      || !(INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (gs1)))\n+\t   || POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (gs1)))))\n+    return false;\n+\n+  tcode0 = gimple_assign_rhs_code (gs0);\n+  tcode1 = gimple_assign_rhs_code (gs1);\n+  if (TREE_CODE_CLASS (tcode0) == tcc_comparison\n+      && TREE_CODE_CLASS (tcode1) == tcc_comparison)\n+    return true;\n+  if (TREE_CODE_CLASS (tcode0) == tcc_comparison\n+      && ccmp_candidate_p (gs1))\n+    return true;\n+  else if (TREE_CODE_CLASS (tcode1) == tcc_comparison\n+\t   && ccmp_candidate_p (gs0))\n+    return true;\n+  /* We skip ccmp_candidate_p (gs1) && ccmp_candidate_p (gs0) since\n+     there is no way to set the CC flag.  */\n+  return false;\n+}\n+\n+/* Check whether EXP is used in a GIMPLE_COND statement or not.  */\n+static bool\n+used_in_cond_stmt_p (tree exp)\n+{\n+  bool expand_cond = false;\n+  imm_use_iterator ui;\n+  gimple use_stmt;\n+  FOR_EACH_IMM_USE_STMT (use_stmt, ui, exp)\n+    if (gimple_code (use_stmt) == GIMPLE_COND)\n+      {\n+\ttree op1 = gimple_cond_rhs (use_stmt);\n+\tif (integer_zerop (op1))\n+\t  expand_cond = true;\n+\tBREAK_FROM_IMM_USE_STMT (ui);\n+      }\n+    else if (gimple_code (use_stmt) == GIMPLE_ASSIGN\n+\t     && gimple_expr_code (use_stmt) == COND_EXPR)\n+      {\n+\tif (gimple_assign_rhs1 (use_stmt) == exp)\n+\t  expand_cond = true;\n+      }\n+\n+  return expand_cond;\n+}\n+\n+/* Expand conditional compare gimple G.  A typical CCMP sequence is like:\n+\n+     CC0 = CMP (a, b);\n+     CC1 = CCMP (NE (CC0, 0), CMP (e, f));\n+     ...\n+     CCn = CCMP (NE (CCn-1, 0), CMP (...));\n+\n+   hook gen_ccmp_first is used to expand the first compare.\n+   hook gen_ccmp_next is used to expand the following CCMP.  */\n+static rtx\n+expand_ccmp_expr_1 (gimple g)\n+{\n+  tree exp = gimple_assign_rhs_to_tree (g);\n+  enum tree_code code = TREE_CODE (exp);\n+  gimple gs0 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 0));\n+  gimple gs1 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 1));\n+  rtx tmp;\n+  enum tree_code code0 = gimple_assign_rhs_code (gs0);\n+  enum tree_code code1 = gimple_assign_rhs_code (gs1);\n+\n+  gcc_assert (code == BIT_AND_EXPR || code == BIT_IOR_EXPR);\n+  gcc_assert (gs0 && gs1 && is_gimple_assign (gs0) && is_gimple_assign (gs1));\n+\n+  if (TREE_CODE_CLASS (code0) == tcc_comparison)\n+    {\n+      if (TREE_CODE_CLASS (code1) == tcc_comparison)\n+\t{\n+\t  int unsignedp0, unsignedp1;\n+\t  enum rtx_code rcode0, rcode1;\n+\t  rtx op0, op1, op2, op3, tmp;\n+\n+\t  unsignedp0 = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs0)));\n+\t  rcode0 = get_rtx_code (code0, unsignedp0);\n+\t  unsignedp1 = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs1)));\n+\t  rcode1 = get_rtx_code (code1, unsignedp1);\n+\n+\t  expand_operands (gimple_assign_rhs1 (gs0),\n+\t\t\t   gimple_assign_rhs2 (gs0),\n+\t\t\t   NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\n+\t  /* Since the operands of GS1 might clobber CC reg, we expand the\n+\t     operands of GS1 before GEN_CCMP_FIRST.  */\n+\t  expand_operands (gimple_assign_rhs1 (gs1),\n+\t\t\t   gimple_assign_rhs2 (gs1),\n+\t\t\t   NULL_RTX, &op2, &op3, EXPAND_NORMAL);\n+\t  tmp = targetm.gen_ccmp_first (rcode0, op0, op1);\n+\t  if (!tmp)\n+\t    return NULL_RTX;\n+\n+\t  return targetm.gen_ccmp_next (tmp, rcode1, op2, op3,\n+\t\t\t\t\tget_rtx_code (code, 0));\n+\t}\n+      else\n+\t{\n+  \t  rtx op0, op1;\n+\t  enum rtx_code rcode;\n+\t  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs0)));\n+\n+\t  rcode = get_rtx_code (gimple_assign_rhs_code (gs0), unsignedp);\n+\n+\t  /* Hoist the preparation operations above the entire\n+\t     conditional compare sequence.  */\n+\t  expand_operands (gimple_assign_rhs1 (gs0),\n+\t\t\t   gimple_assign_rhs2 (gs0),\n+\t\t\t   NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\n+\t  gcc_assert (code1 == BIT_AND_EXPR || code1 == BIT_IOR_EXPR);\n+\n+\t  /* Note: We swap the order to make the recursive function work.  */\n+\t  tmp = expand_ccmp_expr_1 (gs1);\n+\t  if (tmp)\n+\t    return targetm.gen_ccmp_next (tmp, rcode, op0, op1,\n+\t\t\t\t\t  get_rtx_code (code, 0));\n+\t}\n+    }\n+  else\n+    {\n+      gcc_assert (gimple_assign_rhs_code (gs0) == BIT_AND_EXPR\n+                  || gimple_assign_rhs_code (gs0) == BIT_IOR_EXPR);\n+\n+      if (TREE_CODE_CLASS (gimple_assign_rhs_code (gs1)) == tcc_comparison)\n+\t{\n+  \t  rtx op0, op1;\n+\t  enum rtx_code rcode;\n+\t  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs1)));\n+\n+\t  rcode = get_rtx_code (gimple_assign_rhs_code (gs1), unsignedp);\n+\n+\t  /* Hoist the preparation operations above the entire\n+\t     conditional compare sequence.  */\n+\t  expand_operands (gimple_assign_rhs1 (gs1),\n+\t\t\t   gimple_assign_rhs2 (gs1),\n+\t\t\t   NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\t  tmp = expand_ccmp_expr_1 (gs0);\n+\t  if (tmp)\n+\t    return targetm.gen_ccmp_next (tmp, rcode, op0, op1,\n+\t\t\t\t\t  get_rtx_code (code, 0));\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (gimple_assign_rhs_code (gs1) == BIT_AND_EXPR\n+\t\t      || gimple_assign_rhs_code (gs1) == BIT_IOR_EXPR);\n+\t}\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+/* Main entry to expand conditional compare statement G. \n+   Return NULL_RTX if G is not a legal candidate or expand fail.\n+   Otherwise return the target.  */\n+rtx\n+expand_ccmp_expr (gimple g)\n+{\n+  rtx_insn *last;\n+  rtx tmp;\n+\n+  if (!ccmp_candidate_p (g))\n+    return NULL_RTX;\n+\n+  last = get_last_insn ();\n+  tmp = expand_ccmp_expr_1 (g);\n+\n+  if (tmp)\n+    {\n+      enum insn_code icode;\n+      enum machine_mode cc_mode = CCmode;\n+\n+      tree lhs = gimple_assign_lhs (g);\n+      /* TMP should be CC.  If it is used in a GIMPLE_COND, just return it.\n+\t Note: Target needs to define \"cbranchcc4\".  */\n+      if (used_in_cond_stmt_p (lhs))\n+\treturn tmp;\n+\n+#ifdef SELECT_CC_MODE\n+      cc_mode = SELECT_CC_MODE (NE, tmp, const0_rtx);\n+#endif\n+      /* If TMP is not used in a GIMPLE_COND, store it with a csctorecc4_optab.\n+\t Note: Target needs to define \"cstorecc4\".  */\n+      icode = optab_handler (cstore_optab, cc_mode);\n+      if (icode != CODE_FOR_nothing)\n+\t{\n+\t  tree lhs = gimple_assign_lhs (g);\n+\t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+\t  rtx target = gen_reg_rtx (mode);\n+\t  tmp = emit_cstore (target, icode, NE, cc_mode, cc_mode,\n+\t\t\t     0, tmp, const0_rtx, 1, mode);\n+\t  if (tmp)\n+\t    return tmp;\n+\t}\n+    }\n+  /* Clean up.  */\n+  delete_insns_since (last);\n+  return NULL_RTX;\n+}\n+"}, {"sha": "6144dbbb35d18b33f7299eb08ebb0dad5be1190e", "filename": "gcc/ccmp.h", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06cd23dc761a7769f8bdca26a42db59b71dec54/gcc%2Fccmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06cd23dc761a7769f8bdca26a42db59b71dec54/gcc%2Fccmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.h?ref=f06cd23dc761a7769f8bdca26a42db59b71dec54", "patch": "@@ -0,0 +1,25 @@\n+/* Conditional comapre related functions.\n+   Copyright (C) 2014-2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CCMP_H\n+#define GCC_CCMP_H\n+\n+extern rtx expand_ccmp_expr (gimple);\n+\n+#endif  /* GCC_CCMP_H  */"}, {"sha": "093f544a993ef9c0f79a8f5d4675bfe6c283c706", "filename": "gcc/expr.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f06cd23dc761a7769f8bdca26a42db59b71dec54/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f06cd23dc761a7769f8bdca26a42db59b71dec54/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f06cd23dc761a7769f8bdca26a42db59b71dec54", "patch": "@@ -81,6 +81,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"tree-chkp.h\"\n #include \"rtl-chkp.h\"\n+#include \"ccmp.h\"\n \n #ifndef STACK_PUSH_CODE\n #ifdef STACK_GROWS_DOWNWARD\n@@ -8062,7 +8063,9 @@ expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,\n       op00 = expand_normal (treeop0);\n       op01 = const0_rtx;\n       comparison_code = NE;\n-      comparison_mode = TYPE_MODE (TREE_TYPE (treeop0));\n+      comparison_mode = GET_MODE (op00);\n+      if (comparison_mode == VOIDmode)\n+\tcomparison_mode = TYPE_MODE (TREE_TYPE (treeop0));\n     }\n \n   if (GET_MODE (op1) != mode)\n@@ -9504,6 +9507,15 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t      /* Fallthru */\n \t    case GIMPLE_BINARY_RHS:\n \t      ops.op1 = gimple_assign_rhs2 (g);\n+\n+\t      /* Try to expand conditonal compare.  */\n+\t      if (targetm.gen_ccmp_first)\n+\t\t{\n+\t\t  gcc_checking_assert (targetm.gen_ccmp_next != NULL);\n+\t\t  r = expand_ccmp_expr (g);\n+\t\t  if (r)\n+\t\t    break;\n+\t\t}\n \t      /* Fallthru */\n \t    case GIMPLE_UNARY_RHS:\n \t      ops.op0 = gimple_assign_rhs1 (g);"}]}