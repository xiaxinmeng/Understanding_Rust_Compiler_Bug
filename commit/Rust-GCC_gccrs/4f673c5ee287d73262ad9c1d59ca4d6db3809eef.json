{"sha": "4f673c5ee287d73262ad9c1d59ca4d6db3809eef", "node_id": "C_kwDOANBUbNoAKDRmNjczYzVlZTI4N2Q3MzI2MmFkOWMxZDU5Y2E0ZDZkYjM4MDllZWY", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2023-01-09T23:29:11Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2023-01-26T19:10:16Z"}, "message": "RISC-V: Fix bugs of supporting AVL=REG (single-real-def) in VSETVL PASS\n\ngcc/ChangeLog:\n\n\t* config/riscv/riscv-vsetvl.cc (same_bb_and_before_p): Remove it.\n\t(real_insn_and_same_bb_p): New function.\n\t(same_bb_and_after_or_equal_p): Remove it.\n\t(before_p): New function.\n\t(reg_killed_by_bb_p): Ditto.\n\t(has_vsetvl_killed_avl_p): Ditto.\n\t(get_vl): Move location so that we can call it.\n\t(anticipatable_occurrence_p): Fix issue of AVL=REG support.\n\t(available_occurrence_p): Ditto.\n\t(dominate_probability_p): Remove it.\n\t(can_backward_propagate_p): Remove it.\n\t(get_all_nonphi_defs): New function.\n\t(get_all_predecessors): Ditto.\n\t(any_insn_in_bb_p): Ditto.\n\t(insert_vsetvl): Adjust AVL REG.\n\t(source_equal_p): New function.\n\t(extract_single_source): Ditto.\n\t(avl_info::single_source_equal_p): Ditto.\n\t(avl_info::operator==): Adjust for AVL=REG.\n\t(vl_vtype_info::same_avl_p): Ditto.\n\t(vector_insn_info::set_demand_info): Remove it.\n\t(vector_insn_info::compatible_p): Adjust for AVL=REG.\n\t(vector_insn_info::compatible_avl_p): New function.\n\t(vector_insn_info::merge): Adjust AVL=REG.\n\t(vector_insn_info::dump): Ditto.\n\t(pass_vsetvl::merge_successors): Remove it.\n\t(enum fusion_type): New enum.\n\t(pass_vsetvl::get_backward_fusion_type): New function.\n\t(pass_vsetvl::backward_demand_fusion): Adjust for AVL=REG.\n\t(pass_vsetvl::forward_demand_fusion): Ditto.\n\t(pass_vsetvl::demand_fusion): Ditto.\n\t(pass_vsetvl::prune_expressions): Ditto.\n\t(pass_vsetvl::compute_local_properties): Ditto.\n\t(pass_vsetvl::cleanup_vsetvls): Ditto.\n\t(pass_vsetvl::commit_vsetvls): Ditto.\n\t(pass_vsetvl::init): Ditto.\n\t* config/riscv/riscv-vsetvl.h (enum fusion_type): New enum.\n\t(enum merge_type): New enum.", "tree": {"sha": "addc9f7a143c3e2ad178de7a962613899bd4ee18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/addc9f7a143c3e2ad178de7a962613899bd4ee18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f673c5ee287d73262ad9c1d59ca4d6db3809eef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f673c5ee287d73262ad9c1d59ca4d6db3809eef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f673c5ee287d73262ad9c1d59ca4d6db3809eef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f673c5ee287d73262ad9c1d59ca4d6db3809eef/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acc10c793127d5683b19158fd89fd0d4f4fc9db0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acc10c793127d5683b19158fd89fd0d4f4fc9db0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acc10c793127d5683b19158fd89fd0d4f4fc9db0"}], "stats": {"total": 994, "additions": 709, "deletions": 285}, "files": [{"sha": "e4bc3d2b35364162a227db9793992fd919c173ae", "filename": "gcc/config/riscv/riscv-vsetvl.cc", "status": "modified", "additions": 647, "deletions": 279, "changes": 926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f673c5ee287d73262ad9c1d59ca4d6db3809eef/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f673c5ee287d73262ad9c1d59ca4d6db3809eef/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc?ref=4f673c5ee287d73262ad9c1d59ca4d6db3809eef", "patch": "@@ -178,110 +178,180 @@ vsetvl_insn_p (rtx_insn *rinsn)\n \t || INSN_CODE (rinsn) == CODE_FOR_vsetvlsi);\n }\n \n-/* Return true if INSN1 comes befeore INSN2 in the same block.  */\n static bool\n-same_bb_and_before_p (const insn_info *insn1, const insn_info *insn2)\n+real_insn_and_same_bb_p (const insn_info *insn, const bb_info *bb)\n {\n-  return ((insn1->bb ()->index () == insn2->bb ()->index ())\n-\t && (*insn1 < *insn2));\n+  return insn != nullptr && insn->is_real () && insn->bb () == bb;\n }\n \n-/* Return true if INSN1 comes after or equal INSN2 in the same block.  */\n static bool\n-same_bb_and_after_or_equal_p (const insn_info *insn1, const insn_info *insn2)\n+before_p (const insn_info *insn1, const insn_info *insn2)\n {\n-  return ((insn1->bb ()->index () == insn2->bb ()->index ())\n-\t && (*insn1 >= *insn2));\n+  return insn1->compare_with (insn2) == -1;\n+}\n+\n+static bool\n+reg_killed_by_bb_p (const bb_info *bb, rtx x)\n+{\n+  if (!x || vlmax_avl_p (x))\n+    return false;\n+  for (const insn_info *insn : bb->real_nondebug_insns ())\n+    if (find_access (insn->defs (), REGNO (x)))\n+      return true;\n+  return false;\n+}\n+\n+static bool\n+has_vsetvl_killed_avl_p (const bb_info *bb, const vector_insn_info &info)\n+{\n+  if (info.dirty_with_killed_avl_p ())\n+    {\n+      rtx avl = info.get_avl ();\n+      for (const insn_info *insn : bb->reverse_real_nondebug_insns ())\n+\t{\n+\t  def_info *def = find_access (insn->defs (), REGNO (avl));\n+\t  if (def)\n+\t    {\n+\t      set_info *set = safe_dyn_cast<set_info *> (def);\n+\t      if (!set)\n+\t\treturn false;\n+\n+\t      rtx new_avl = gen_rtx_REG (GET_MODE (avl), REGNO (avl));\n+\t      gcc_assert (new_avl != avl);\n+\t      if (!info.compatible_avl_p (avl_info (new_avl, set)))\n+\t\treturn false;\n+\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Helper function to get VL operand.  */\n+static rtx\n+get_vl (rtx_insn *rinsn)\n+{\n+  if (has_vl_op (rinsn))\n+    {\n+      extract_insn_cached (rinsn);\n+      return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n+    }\n+  return SET_DEST (XVECEXP (PATTERN (rinsn), 0, 0));\n }\n \n /* An \"anticipatable occurrence\" is one that is the first occurrence in the\n    basic block, the operands are not modified in the basic block prior\n    to the occurrence and the output is not used between the start of\n-   the block and the occurrence.  */\n+   the block and the occurrence.\n+\n+   For VSETVL instruction, we have these following formats:\n+     1. vsetvl zero, rs1.\n+     2. vsetvl zero, imm.\n+     3. vsetvl rd, rs1.\n+\n+   So base on these circumstances, a DEM is considered as a local anticipatable\n+   occurrence should satisfy these following conditions:\n+\n+     1). rs1 (avl) are not modified in the basic block prior to the VSETVL.\n+     2). rd (vl) are not modified in the basic block prior to the VSETVL.\n+     3). rd (vl) is not used between the start of the block and the occurrence.\n+\n+   Note: We don't need to check VL/VTYPE here since DEM is UNKNOWN if VL/VTYPE\n+\t is modified prior to the occurrence. This case is already considered as\n+\t a non-local anticipatable occurrence.\n+*/\n static bool\n-anticipatable_occurrence_p (const insn_info *insn, const vector_insn_info dem)\n+anticipatable_occurrence_p (const bb_info *bb, const vector_insn_info dem)\n {\n+  insn_info *insn = dem.get_insn ();\n   /* The only possible operand we care of VSETVL is AVL.  */\n   if (dem.has_avl_reg ())\n     {\n-      /* The operands should not be modified in the basic block prior\n-\t to the occurrence.  */\n+      /* rs1 (avl) are not modified in the basic block prior to the VSETVL.  */\n       if (!vlmax_avl_p (dem.get_avl ()))\n \t{\n \t  set_info *set\n \t    = find_access (insn->uses (), REGNO (dem.get_avl ()))->def ();\n \t  /* If it's undefined, it's not anticipatable conservatively.  */\n \t  if (!set)\n \t    return false;\n-\t  if (same_bb_and_before_p (set->insn (), insn))\n+\t  if (real_insn_and_same_bb_p (set->insn (), bb)\n+\t      && before_p (set->insn (), insn))\n \t    return false;\n \t}\n     }\n \n-  /* The output should not be used between the start of the block\n-     and the occurrence.  */\n+  /* rd (vl) is not used between the start of the block and the occurrence.  */\n   if (vsetvl_insn_p (insn->rtl ()))\n     {\n-      rtx dest = SET_DEST (XVECEXP (PATTERN (insn->rtl ()), 0, 0));\n-      for (insn_info *i = insn->prev_nondebug_insn (); i != nullptr;\n-\t   i = i->prev_nondebug_insn ())\n-\tif (find_access (i->uses (), REGNO (dest)))\n-\t  return false;\n+      rtx dest = get_vl (insn->rtl ());\n+      for (insn_info *i = insn->prev_nondebug_insn ();\n+\t   real_insn_and_same_bb_p (i, bb); i = i->prev_nondebug_insn ())\n+\t{\n+\t  /* rd (vl) is not used between the start of the block and the\n+\t   * occurrence.  */\n+\t  if (find_access (i->uses (), REGNO (dest)))\n+\t    return false;\n+\t  /* rd (vl) are not modified in the basic block prior to the VSETVL. */\n+\t  if (find_access (i->defs (), REGNO (dest)))\n+\t    return false;\n+\t}\n     }\n \n   return true;\n }\n \n /* An \"available occurrence\" is one that is the last occurrence in the\n    basic block and the operands are not modified by following statements in\n-   the basic block [including this insn].  */\n+   the basic block [including this insn].\n+\n+   For VSETVL instruction, we have these following formats:\n+     1. vsetvl zero, rs1.\n+     2. vsetvl zero, imm.\n+     3. vsetvl rd, rs1.\n+\n+   So base on these circumstances, a DEM is considered as a local available\n+   occurrence should satisfy these following conditions:\n+\n+     1). rs1 (avl) are not modified by following statements in\n+\t the basic block.\n+     2). rd (vl) are not modified by following statements in\n+\t the basic block.\n+\n+   Note: We don't need to check VL/VTYPE here since DEM is UNKNOWN if VL/VTYPE\n+\t is modified prior to the occurrence. This case is already considered as\n+\t a non-local available occurrence.\n+*/\n static bool\n-available_occurrence_p (const insn_info *insn, const vector_insn_info dem)\n+available_occurrence_p (const bb_info *bb, const vector_insn_info dem)\n {\n+  insn_info *insn = dem.get_insn ();\n   /* The only possible operand we care of VSETVL is AVL.  */\n   if (dem.has_avl_reg ())\n     {\n-      /* The operands should not be modified in the basic block prior\n-\t to the occurrence.\n-\t e.g.\n-\t    bb:\n-\t      vsetvl hr3, hr2, ...\n-\t      ...\n-\t      vadd ... (vl=hr3)\n-      */\n       if (!vlmax_avl_p (dem.get_avl ()))\n \t{\n-\t  set_info *set\n-\t    = find_access (insn->uses (), REGNO (dem.get_avl ()))->def ();\n-\t  /* If it's undefined, it's not available conservatively.  */\n-\t  if (!set)\n-\t    return false;\n-\t  if (same_bb_and_after_or_equal_p (set->insn (), insn))\n-\t    return false;\n+\t  rtx dest = NULL_RTX;\n+\t  if (vsetvl_insn_p (insn->rtl ()))\n+\t    dest = get_vl (insn->rtl ());\n+\t  for (const insn_info *i = insn; real_insn_and_same_bb_p (i, bb);\n+\t       i = i->next_nondebug_insn ())\n+\t    {\n+\t      /* rs1 (avl) are not modified by following statements in\n+\t\t the basic block.  */\n+\t      if (find_access (i->defs (), REGNO (dem.get_avl ())))\n+\t\treturn false;\n+\t      /* rd (vl) are not modified by following statements in\n+\t\t the basic block.  */\n+\t      if (dest && find_access (i->defs (), REGNO (dest)))\n+\t\treturn false;\n+\t    }\n \t}\n     }\n   return true;\n }\n \n-/* Return true if the branch probability is dominate.  */\n-static bool\n-dominate_probability_p (edge e)\n-{\n-  /* TODO: We simpily pick dominate probability >= 50%.\n-     However, it isn't always optimal. Consider cases\n-     like this:\n-       bb 0: 80% succs: bb 2, bb 3, bb 4, bb 5.\n-       bb 1: 20%\n-\n-     Assume bb 1, bb 2, bb 3, bb 4, bb 5 are different\n-     one another, and bb 2, bb 3, bb 4, bb 5 are incompatible.\n-\n-     ??? Maybe backward propagate bb 1 is better ???\n-     May need to support an accurate and reliable COST model\n-     in the future.  */\n-  return e->probability >= profile_probability::even ();\n-}\n-\n /* Return true if the block is worthwhile backward propagation.  */\n static bool\n backward_propagate_worthwhile_p (const basic_block cfg_bb,\n@@ -348,18 +418,6 @@ backward_propagate_worthwhile_p (const basic_block cfg_bb,\n   return true;\n }\n \n-/* Helper function to get VL operand.  */\n-static rtx\n-get_vl (rtx_insn *rinsn)\n-{\n-  if (has_vl_op (rinsn))\n-    {\n-      extract_insn_cached (rinsn);\n-      return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n-    }\n-  return SET_DEST (XVECEXP (PATTERN (rinsn), 0, 0));\n-}\n-\n /* Helper function to get AVL operand.  */\n static rtx\n get_avl (rtx_insn *rinsn)\n@@ -375,101 +433,79 @@ get_avl (rtx_insn *rinsn)\n   return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n }\n \n-static bool\n-can_backward_propagate_p (const function_info *ssa, const basic_block cfg_bb,\n-\t\t\t  const vector_insn_info prop)\n+/* Recursively find all real define instructions if it is a real instruction. */\n+static hash_set<insn_info *>\n+get_all_nonphi_defs (phi_info *phi)\n {\n-  insn_info *insn = prop.get_insn ();\n-\n-  /* TODO: We don't backward propagate the explict VSETVL here\n-     since we will change vsetvl and vsetvlmax intrinsics into\n-     no side effects which can be optimized into optimal location\n-     by GCC internal passes. We only need to support these backward\n-     propagation if vsetvl intrinsics have side effects.  */\n-  if (vsetvl_insn_p (insn->rtl ()))\n-    return false;\n+  hash_set<insn_info *> insns;\n+  auto_vec<phi_info *> work_list;\n+  hash_set<phi_info *> visited_list;\n+  if (!phi)\n+    return insns;\n+  work_list.safe_push (phi);\n \n-  gcc_assert (has_vtype_op (insn->rtl ()));\n-  rtx reg = NULL_RTX;\n-\n-  /* Case 1: Don't need VL. Just let it backward propagate.  */\n-  if (!has_vl_op (insn->rtl ()))\n-    return true;\n-  else\n+  while (!work_list.is_empty ())\n     {\n-      /* Case 2: CONST_INT AVL, we don't need to check def.  */\n-      if (prop.has_avl_imm ())\n-\treturn true;\n-      else\n+      phi_info *phi = work_list.pop ();\n+      visited_list.add (phi);\n+      for (use_info *use : phi->inputs ())\n \t{\n-\t  /* Case 3: REG AVL, we need to check the distance of def to make\n-\t     sure we won't backward propagate over the def.  */\n-\t  gcc_assert (prop.has_avl_reg ());\n-\t  if (vlmax_avl_p (prop.get_avl ()))\n-\t    /* Check VL operand for vsetvl vl,zero.  */\n-\t    reg = get_vl (insn->rtl ());\n-\t  else\n-\t    /* Check AVL operand for vsetvl zero,avl.  */\n-\t    reg = get_avl (insn->rtl ());\n-\t}\n-    }\n-\n-  def_info *def = find_access (insn->uses (), REGNO (reg))->def ();\n-\n-  /* If the definition is in the current block, we can't propagate it\n-     across blocks.  */\n-  if (def->bb ()->cfg_bb ()->index == insn->bb ()->cfg_bb ()->index)\n-    {\n-      set_info *set = safe_dyn_cast<set_info *> (def);\n-\n-      /* True if it is a degenerate PHI that can be backward propagated.  */\n-      auto valid_degenerate_phi_p = [&] () {\n-\tif (!set)\n-\t  return false;\n-\n-\tphi_info *phi = safe_dyn_cast<phi_info *> (set);\n-\tif (!phi)\n-\t  return false;\n-\n-\tbasic_block iter_bb;\n-\tset_info *ultimate_def = look_through_degenerate_phi (set);\n-\tconst basic_block ultimate_bb = ultimate_def->bb ()->cfg_bb ();\n-\tFOR_BB_BETWEEN (iter_bb, ultimate_bb, def->bb ()->cfg_bb (), next_bb)\n-\t  {\n-\t    if (!iter_bb)\n-\t      break;\n-\t    if (iter_bb->index == cfg_bb->index)\n-\t      return true;\n-\t  }\n-\n-\treturn false;\n-      };\n+\t  def_info *def = use->def ();\n+\t  if (!def)\n+\t    {\n+\t      /* if def is null, treat undefined */\n+\t      insns.empty ();\n+\t      return insns;\n+\t    }\n \n-      if (valid_degenerate_phi_p ())\n-\treturn true;\n+\t  gcc_assert (!def->insn ()->is_debug_insn ());\n \n-      /* TODO: Support non-degenerate PHI backward propagation later.  */\n-      return false;\n+\t  if (!def->insn ()->is_phi ())\n+\t    insns.add (def->insn ());\n+\t  if (def->insn ()->is_phi ())\n+\t    {\n+\t      phi_info *new_phi = as_a<phi_info *> (def);\n+\t      if (!visited_list.contains (new_phi))\n+\t\twork_list.safe_push (new_phi);\n+\t    }\n+\t}\n     }\n+  return insns;\n+}\n \n-  /* If the definition block is the current block that we iterate, we\n-     can backward propagate it since we will insert or change VL/VTYPE\n-     info at the end of the current block we iterate.  */\n-  if (def->bb ()->cfg_bb ()->index == cfg_bb->index)\n-    return true;\n+/* Recursively find all predecessor blocks for cfg_bb. */\n+static hash_set<basic_block>\n+get_all_predecessors (basic_block cfg_bb)\n+{\n+  hash_set<basic_block> blocks;\n+  auto_vec<basic_block> work_list;\n+  hash_set<basic_block> visited_list;\n+  work_list.safe_push (cfg_bb);\n \n-  /* Make sure we don't backward propagate the VL/VTYPE info over the\n-     definition blocks.  */\n-  bool visited_p = false;\n-  for (const bb_info *bb : ssa->reverse_bbs ())\n+  while (!work_list.is_empty ())\n     {\n-      if (bb->cfg_bb ()->index == cfg_bb->index && visited_p)\n-\treturn false;\n-      if (bb->cfg_bb ()->index == def->bb ()->cfg_bb ()->index)\n-\tvisited_p = true;\n+      basic_block new_cfg_bb = work_list.pop ();\n+      visited_list.add (new_cfg_bb);\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, new_cfg_bb->preds)\n+\t{\n+\t  if (!visited_list.contains (e->src))\n+\t    work_list.safe_push (e->src);\n+\t  blocks.add (e->src);\n+\t}\n     }\n+  return blocks;\n+}\n \n-  return true;\n+/* Return true if there is an INSN in insns staying in the block BB.  */\n+static bool\n+any_insn_in_bb_p (hash_set<insn_info *> insns, const bb_info *bb)\n+{\n+  for (const insn_info *insn : insns)\n+    if (insn->bb ()->index () == bb->index ())\n+      return true;\n+  return false;\n }\n \n /* Helper function to get SEW operand. We always have SEW value for\n@@ -618,7 +654,7 @@ insert_vsetvl (enum emit_type emit_type, rtx_insn *rinsn,\n   /* Use X0, X0 form if the AVL is the same and the SEW+LMUL gives the same\n      VLMAX.  */\n   if (prev_info.valid_or_dirty_p () && !prev_info.unknown_p ()\n-      && info.same_avl_p (prev_info) && info.same_vlmax_p (prev_info))\n+      && info.compatible_avl_p (prev_info) && info.same_vlmax_p (prev_info))\n     {\n       emit_vsetvl_insn (VSETVL_VTYPE_CHANGE_ONLY, emit_type, info, NULL_RTX,\n \t\t\trinsn);\n@@ -904,6 +940,54 @@ change_vsetvl_insn (const insn_info *insn, const vector_insn_info &info)\n   change_insn (rinsn, new_pat);\n }\n \n+static bool\n+source_equal_p (rtx_insn *rinsn1, rtx_insn *rinsn2)\n+{\n+  if (!rinsn1 || !rinsn2)\n+    return false;\n+  rtx note1 = find_reg_equal_equiv_note (rinsn1);\n+  rtx note2 = find_reg_equal_equiv_note (rinsn2);\n+  rtx single_set1 = single_set (rinsn1);\n+  rtx single_set2 = single_set (rinsn2);\n+\n+  if (note1 && note2 && rtx_equal_p (note1, note2))\n+    return true;\n+  if (single_set1 && single_set2\n+      && rtx_equal_p (SET_SRC (single_set1), SET_SRC (single_set2)))\n+    return true;\n+  return false;\n+}\n+\n+/* Helper function to get single same real RTL source.\n+   return NULL if it is not a single real RTL source.  */\n+static rtx_insn *\n+extract_single_source (set_info *set)\n+{\n+  if (!set)\n+    return nullptr;\n+  if (set->insn ()->is_real ())\n+    return set->insn ()->rtl ();\n+  if (!set->insn ()->is_phi ())\n+    return nullptr;\n+  phi_info *phi = safe_dyn_cast<phi_info *> (set);\n+  hash_set<insn_info *> insns = get_all_nonphi_defs (phi);\n+\n+  insn_info *first_insn = (*insns.begin ());\n+  if (first_insn->is_artificial ())\n+    return nullptr;\n+  for (const insn_info *insn : insns)\n+    {\n+      /* If there is a head or end insn, we conservative return\n+\t NULL so that VSETVL PASS will insert vsetvl directly.  */\n+      if (insn->is_artificial ())\n+\treturn nullptr;\n+      if (!source_equal_p (insn->rtl (), first_insn->rtl ()))\n+\treturn nullptr;\n+    }\n+\n+  return (*insns.begin ())->rtl ();\n+}\n+\n avl_info::avl_info (const avl_info &other)\n {\n   m_value = other.get_value ();\n@@ -914,6 +998,16 @@ avl_info::avl_info (rtx value_in, set_info *source_in)\n   : m_value (value_in), m_source (source_in)\n {}\n \n+bool\n+avl_info::single_source_equal_p (const avl_info &other) const\n+{\n+  set_info *set1 = m_source;\n+  set_info *set2 = other.get_source ();\n+  rtx_insn *rinsn1 = extract_single_source (set1);\n+  rtx_insn *rinsn2 = extract_single_source (set2);\n+  return source_equal_p (rinsn1, rinsn2);\n+}\n+\n avl_info &\n avl_info::operator= (const avl_info &other)\n {\n@@ -946,8 +1040,21 @@ avl_info::operator== (const avl_info &other) const\n   if (vlmax_avl_p (m_value))\n     return vlmax_avl_p (other.get_value ());\n \n-  /* TODO: So far we only support VLMAX (AVL=zero) comparison,\n-     we will support non-VLMAX AVL in the future.  */\n+  /* If Pseudo REGNO are same, it's safe to consider they are same.  */\n+  if (ORIGINAL_REGNO (m_value) == ORIGINAL_REGNO (other.get_value ()))\n+    return true;\n+\n+  /* If any source is undef value, we think they are not equal.  */\n+  if (!m_source || !other.get_source ())\n+    return false;\n+\n+  /* If both sources are single source (defined by a single real RTL)\n+     and their definitions are same.  */\n+  if (single_source_equal_p (other))\n+    return true;\n+\n+  /* TODO: Support avl defined by PHI which includes multiple different insn\n+   * later.  */\n   return false;\n }\n \n@@ -994,7 +1101,7 @@ vl_vtype_info::has_non_zero_avl () const\n bool\n vl_vtype_info::same_avl_p (const vl_vtype_info &other) const\n {\n-  return get_avl_info () == other.get_avl_info ();\n+  return get_avl () == other.get_avl ();\n }\n \n bool\n@@ -1177,19 +1284,6 @@ vector_insn_info::parse_insn (insn_info *insn)\n     m_demands[DEMAND_MASK_POLICY] = true;\n }\n \n-void\n-vector_insn_info::set_demand_info (const vector_insn_info &other)\n-{\n-  set_sew (other.get_sew ());\n-  set_vlmul (other.get_vlmul ());\n-  set_ratio (other.get_ratio ());\n-  set_ta (other.get_ta ());\n-  set_ma (other.get_ma ());\n-  set_avl_info (other.get_avl_info ());\n-  for (size_t i = 0; i < NUM_DEMAND; i++)\n-    m_demands[i] = other.demand_p ((enum demand_type) i);\n-}\n-\n void\n vector_insn_info::demand_vl_vtype ()\n {\n@@ -1236,7 +1330,7 @@ vector_insn_info::compatible_p (const vector_insn_info &other) const\n     return false;\n \n   if (demand_p (DEMAND_AVL) && other.demand_p (DEMAND_AVL))\n-    return m_avl == other.get_avl_info ();\n+    return compatible_avl_p (other);\n \n   return true;\n }\n@@ -1251,6 +1345,15 @@ vector_insn_info::compatible_avl_p (const vl_vtype_info &other) const\n   return get_avl_info () == other.get_avl_info ();\n }\n \n+bool\n+vector_insn_info::compatible_avl_p (const avl_info &other) const\n+{\n+  gcc_assert (valid_or_dirty_p () && \"Can't compare invalid vl_vtype_info\");\n+  gcc_assert (!unknown_p () && \"Can't compare AVL in unknown state\");\n+  gcc_assert (demand_p (DEMAND_AVL) && \"Can't compare AVL undemand state\");\n+  return get_avl_info () == other;\n+}\n+\n bool\n vector_insn_info::compatible_vtype_p (const vl_vtype_info &other) const\n {\n@@ -1294,28 +1397,38 @@ vector_insn_info::compatible_p (const vl_vtype_info &curr_info) const\n \n vector_insn_info\n vector_insn_info::merge (const vector_insn_info &merge_info,\n-\t\t\t bool across_bb_p = false) const\n+\t\t\t enum merge_type type = LOCAL_MERGE) const\n {\n   gcc_assert (this->compatible_p (merge_info)\n \t      && \"Can't merge incompatible demanded infos\");\n \n   vector_insn_info new_info;\n   new_info.demand_vl_vtype ();\n \n-  if (dirty_p ())\n+  if (type == LOCAL_MERGE)\n     {\n-      gcc_assert (across_bb_p);\n-      if (demand_p (DEMAND_AVL))\n-\tnew_info.set_insn (get_insn ());\n-      else\n-\tnew_info.set_insn (merge_info.get_insn ());\n+      /* For local backward data flow, we always update INSN && AVL as the\n+\t latest INSN and AVL so that we can keep track status of each INSN.*/\n+      new_info.set_insn (merge_info.get_insn ());\n+      if (merge_info.demand_p (DEMAND_AVL))\n+\tnew_info.set_avl_info (merge_info.get_avl_info ());\n+      else if (demand_p (DEMAND_AVL))\n+\tnew_info.set_avl_info (get_avl_info ());\n     }\n   else\n     {\n-      if (across_bb_p)\n-\tnew_info.set_insn (get_insn ());\n-      else\n-\tnew_info.set_insn (merge_info.get_insn ());\n+      /* For global data flow, we should keep original INSN and AVL if they\n+\t valid since we should keep the life information of each block.\n+\n+\t For example:\n+\t   bb 0 -> bb 1.\n+\t We should keep INSN && AVL of bb 1 since we will eventually emit\n+\t vsetvl instruction according to INSN and AVL of bb 1.  */\n+      new_info.set_insn (get_insn ());\n+      if (demand_p (DEMAND_AVL))\n+\tnew_info.set_avl_info (get_avl_info ());\n+      else if (merge_info.demand_p (DEMAND_AVL))\n+\tnew_info.set_avl_info (merge_info.get_avl_info ());\n     }\n \n   if (!demand_p (DEMAND_AVL) && !merge_info.demand_p (DEMAND_AVL))\n@@ -1332,11 +1445,6 @@ vector_insn_info::merge (const vector_insn_info &merge_info,\n       && !merge_info.demand_p (DEMAND_MASK_POLICY))\n     new_info.undemand (DEMAND_MASK_POLICY);\n \n-  if (merge_info.demand_p (DEMAND_AVL))\n-    new_info.set_avl_info (merge_info.get_avl_info ());\n-  else if (demand_p (DEMAND_AVL))\n-    new_info.set_avl_info (get_avl_info ());\n-\n   if (merge_info.demand_p (DEMAND_SEW))\n     new_info.set_sew (merge_info.get_sew ());\n   else if (demand_p (DEMAND_SEW))\n@@ -1404,6 +1512,8 @@ vector_insn_info::dump (FILE *file) const\n     fprintf (file, \"UNKNOWN,\");\n   else if (empty_p ())\n     fprintf (file, \"EMPTY,\");\n+  else if (dirty_with_killed_avl_p ())\n+    fprintf (file, \"DIRTY_WITH_KILLED_AVL,\");\n   else\n     fprintf (file, \"DIRTY,\");\n \n@@ -1749,7 +1859,8 @@ class pass_vsetvl : public rtl_opt_pass\n   void emit_local_forward_vsetvls (const bb_info *);\n \n   /* Phase 3.  */\n-  bool merge_successors (const basic_block, const basic_block);\n+  enum fusion_type get_backward_fusion_type (const bb_info *,\n+\t\t\t\t\t     const vector_insn_info &);\n   bool backward_demand_fusion (void);\n   bool forward_demand_fusion (void);\n   void demand_fusion (void);\n@@ -1926,52 +2037,175 @@ pass_vsetvl::emit_local_forward_vsetvls (const bb_info *bb)\n   block_info.reaching_out = curr_info;\n }\n \n-/* Merge all successors of Father except child node.  */\n-bool\n-pass_vsetvl::merge_successors (const basic_block father,\n-\t\t\t       const basic_block child)\n+enum fusion_type\n+pass_vsetvl::get_backward_fusion_type (const bb_info *bb,\n+\t\t\t\t       const vector_insn_info &prop)\n {\n-  edge e;\n-  edge_iterator ei;\n-  auto &father_info = m_vector_manager->vector_block_infos[father->index];\n-  gcc_assert (father_info.local_dem.dirty_p ()\n-\t      || father_info.local_dem.empty_p ());\n-  gcc_assert (father_info.reaching_out.dirty_p ()\n-\t      || father_info.reaching_out.empty_p ());\n+  insn_info *insn = prop.get_insn ();\n \n-  bool changed_p = false;\n-  FOR_EACH_EDGE (e, ei, father->succs)\n+  /* TODO: We don't backward propagate the explict VSETVL here\n+     since we will change vsetvl and vsetvlmax intrinsics into\n+     no side effects which can be optimized into optimal location\n+     by GCC internal passes. We only need to support these backward\n+     propagation if vsetvl intrinsics have side effects.  */\n+  if (vsetvl_insn_p (insn->rtl ()))\n+    return INVALID_FUSION;\n+\n+  gcc_assert (has_vtype_op (insn->rtl ()));\n+  rtx reg = NULL_RTX;\n+\n+  /* Case 1: Don't need VL. Just let it backward propagate.  */\n+  if (!has_vl_op (insn->rtl ()))\n+    return VALID_AVL_FUSION;\n+  else\n     {\n-      const basic_block succ = e->dest;\n-      if (succ->index == child->index)\n-\tcontinue;\n+      /* Case 2: CONST_INT AVL, we don't need to check def.  */\n+      if (prop.has_avl_imm ())\n+\treturn VALID_AVL_FUSION;\n+      else\n+\t{\n+\t  /* Case 3: REG AVL, we need to check the distance of def to make\n+\t     sure we won't backward propagate over the def.  */\n+\t  gcc_assert (prop.has_avl_reg ());\n+\t  if (vlmax_avl_p (prop.get_avl ()))\n+\t    /* Check VL operand for vsetvl vl,zero.  */\n+\t    reg = get_vl (insn->rtl ());\n+\t  else\n+\t    /* Check AVL operand for vsetvl zero,avl.  */\n+\t    reg = get_avl (insn->rtl ());\n+\t}\n+    }\n \n-      const auto succ_info\n-\t= m_vector_manager->vector_block_infos[succ->index].local_dem;\n+  gcc_assert (reg);\n+  def_info *def = find_access (insn->uses (), REGNO (reg))->def ();\n+  if (def->insn ()->is_phi ())\n+    {\n+      hash_set<insn_info *> insns\n+\t= get_all_nonphi_defs (as_a<phi_info *> (def));\n+      if (any_insn_in_bb_p (insns, insn->bb ()))\n+\treturn INVALID_FUSION;\n+    }\n+  else\n+    {\n+      if (def->insn ()->bb () == insn->bb ())\n+\treturn INVALID_FUSION;\n+    }\n \n-      if (!succ_info.valid_p ())\n-\tcontinue;\n+  rtx new_reg = gen_rtx_REG (GET_MODE (reg), REGNO (reg));\n+  gcc_assert (new_reg != reg);\n+  const avl_info info = avl_info (new_reg, safe_dyn_cast<set_info *> (def));\n+  if (prop.dirty_with_killed_avl_p ())\n+    {\n+      unsigned int bb_index;\n+      sbitmap_iterator sbi;\n+      sbitmap bitdata = m_vector_manager->vector_avout[bb->index ()];\n+      bool has_valid_avl = false;\n+      EXECUTE_IF_SET_IN_BITMAP (bitdata, 0, bb_index, sbi)\n+      {\n+\tconst vector_insn_info *expr = m_vector_manager->vector_exprs[bb_index];\n+\tif (expr->compatible_avl_p (info))\n+\t  {\n+\t    has_valid_avl = true;\n+\t    break;\n+\t  }\n+      }\n+      if (!has_valid_avl)\n+\treturn INVALID_FUSION;\n+    }\n \n-      vector_insn_info new_info;\n-      if (father_info.reaching_out.dirty_p ())\n+  if (reg_killed_by_bb_p (bb, reg))\n+    {\n+      unsigned int bb_index;\n+      sbitmap_iterator sbi;\n+      sbitmap bitdata = m_vector_manager->vector_avin[bb->index ()];\n+      hash_set<basic_block> blocks = get_all_predecessors (bb->cfg_bb ());\n+      for (const auto block : blocks)\n+\tif (block == insn->bb ()->cfg_bb ())\n+\t  return INVALID_FUSION;\n+      if (bitmap_empty_p (bitdata))\n \t{\n-\t  if (!father_info.reaching_out.compatible_p (succ_info))\n-\t    continue;\n-\n-\t  new_info = succ_info.merge (father_info.reaching_out, true);\n+\t  /* void f (int8_t *restrict in, int8_t *restrict out, int n, int m,\n+\t\t    unsigned cond, size_t vl)\n+\t  {\n+\t    vbool64_t mask = *(vbool64_t *) (in + 1000000);\n+\n+\t    vl = 101;\n+\t    if (cond > 0)\n+\t      {\n+\t      vint8mf8_t v = __riscv_vle8_v_i8mf8 (in, vl);\n+\t      __riscv_vse8_v_i8mf8 (out, v, vl);\n+\t      }\n+\t    else\n+\t      {\n+\t      out[100] = out[100] + 300;\n+\t      }\n+\n+\t    for (size_t i = 0; i < n; i++)\n+\t      {\n+\t      vfloat32mf2_t v = __riscv_vle32_v_f32mf2 ((in + i + 200), vl);\n+\t      __riscv_vse32_v_f32mf2 ((out + i + 200), v, vl);\n+\n+\t      vfloat32mf2_t v2\n+\t\t= __riscv_vle32_v_f32mf2_tumu (mask, v, (in + i + 300), vl);\n+\t      __riscv_vse32_v_f32mf2_m (mask, (out + i + 300), v2, vl);\n+\t      }\n+\t  }  */\n+\t  for (const auto block : blocks)\n+\t    {\n+\t      if (block == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t\tcontinue;\n+\t      sbitmap avout = m_vector_manager->vector_avout[block->index];\n+\t      EXECUTE_IF_SET_IN_BITMAP (avout, 0, bb_index, sbi)\n+\t      {\n+\t\tconst vector_insn_info *expr\n+\t\t  = m_vector_manager->vector_exprs[bb_index];\n+\t\tif (expr->compatible_avl_p (info))\n+\t\t  return KILLED_AVL_FUSION;\n+\t      }\n+\t    }\n+\t  return INVALID_FUSION;\n \t}\n       else\n-\tnew_info = succ_info;\n+\t{\n+\t  /* void f (int8_t * restrict in, int8_t * restrict out, int n, int\n+\t      m, unsigned cond, size_t vl)\n+\t      {\n+\t\tvbool64_t mask = *(vbool64_t *) (in + 1000000);\n \n-      new_info.set_dirty ();\n-      rtx new_pat = gen_vsetvl_pat (new_info.get_insn ()->rtl (), new_info);\n+\t\tvl = 101;\n+\t\tif (cond > 0)\n+\t\t  {\n+\t\t  vint8mf8_t v = __riscv_vle8_v_i8mf8 (in, vl);\n+\t\t  __riscv_vse8_v_i8mf8 (out, v, vl);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t  vint8mf8_t v = __riscv_vle8_v_i8mf8 (in + 1000, vl);\n+\t\t  __riscv_vse8_v_i8mf8 (out + 1000, v, vl);\n+\t\t  }\n+\n+\t\tfor (size_t i = 0; i < n; i++)\n+\t\t  {\n+\t\t  vfloat32mf2_t v = __riscv_vle32_v_f32mf2 ((in + i + 200), vl);\n+\t\t  __riscv_vse32_v_f32mf2 ((out + i + 200), v, vl);\n \n-      father_info.local_dem = new_info;\n-      father_info.reaching_out = new_info;\n-      changed_p = true;\n+\t\t  vfloat32mf2_t v2\n+\t\t    = __riscv_vle32_v_f32mf2_tumu (mask, v, (in + i + 300), vl);\n+\t\t  __riscv_vse32_v_f32mf2_m (mask, (out + i + 300), v2, vl);\n+\t\t  }\n+\t  }  */\n+\t  EXECUTE_IF_SET_IN_BITMAP (bitdata, 0, bb_index, sbi)\n+\t  {\n+\t    const vector_insn_info *expr\n+\t      = m_vector_manager->vector_exprs[bb_index];\n+\t    if (expr->compatible_avl_p (info))\n+\t      return KILLED_AVL_FUSION;\n+\t  }\n+\t}\n+      return INVALID_FUSION;\n     }\n \n-  return changed_p;\n+  return prop.dirty_with_killed_avl_p () ? KILLED_AVL_FUSION : VALID_AVL_FUSION;\n }\n \n /* Compute global backward demanded info.  */\n@@ -2036,20 +2270,16 @@ pass_vsetvl::backward_demand_fusion (void)\n \t    continue;\n \t  else if (block_info.reaching_out.empty_p ())\n \t    {\n-\t      if (!can_backward_propagate_p (crtl->ssa, e->src, prop))\n+\t      enum fusion_type type\n+\t\t= get_backward_fusion_type (crtl->ssa->bb (e->src), prop);\n+\t      if (type == INVALID_FUSION)\n \t\tcontinue;\n \n-\t      if (dominate_probability_p (e))\n-\t\t{\n-\t\t  rtx new_pat = gen_vsetvl_pat (prop.get_insn ()->rtl (), prop);\n-\n-\t\t  block_info.reaching_out = prop;\n-\t\t  block_info.reaching_out.set_dirty ();\n-\t\t  block_info.local_dem = block_info.reaching_out;\n-\t\t  changed_p = true;\n-\t\t}\n-\n-\t      changed_p |= merge_successors (e->src, cfg_bb);\n+\t      block_info.reaching_out = prop;\n+\t      block_info.reaching_out.set_dirty (type);\n+\t      block_info.local_dem = block_info.reaching_out;\n+\t      block_info.probability = curr_block_info.probability;\n+\t      changed_p = true;\n \t    }\n \t  else if (block_info.reaching_out.dirty_p ())\n \t    {\n@@ -2060,19 +2290,22 @@ pass_vsetvl::backward_demand_fusion (void)\n \t\t{\n \t\t  if (block_info.reaching_out >= prop)\n \t\t    continue;\n-\t\t  new_info = block_info.reaching_out.merge (prop, true);\n+\t\t  block_info.probability += curr_block_info.probability;\n+\t\t  new_info = block_info.reaching_out.merge (prop, GLOBAL_MERGE);\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (dominate_probability_p (e))\n-\t\t    new_info = prop;\n+\t\t  if (curr_block_info.probability > block_info.probability)\n+\t\t    {\n+\t\t      new_info = prop;\n+\t\t      block_info.probability = curr_block_info.probability;\n+\t\t    }\n \t\t  else\n \t\t    continue;\n \t\t}\n \n-\t      rtx new_pat\n-\t\t= gen_vsetvl_pat (new_info.get_insn ()->rtl (), new_info);\n-\t      new_info.set_dirty ();\n+\t      new_info.set_dirty (\n+\t\tblock_info.reaching_out.dirty_with_killed_avl_p ());\n \t      block_info.local_dem = new_info;\n \t      block_info.reaching_out = new_info;\n \t      changed_p = true;\n@@ -2090,7 +2323,10 @@ pass_vsetvl::backward_demand_fusion (void)\n \t      vector_insn_info be_merged = block_info.reaching_out;\n \t      if (block_info.local_dem == block_info.reaching_out)\n \t\tbe_merged = block_info.local_dem;\n-\t      vector_insn_info new_info = be_merged.merge (prop, true);\n+\t      vector_insn_info new_info = be_merged.merge (prop, GLOBAL_MERGE);\n+\n+\t      if (curr_block_info.probability > block_info.probability)\n+\t\tblock_info.probability = curr_block_info.probability;\n \n \t      change_vsetvl_insn (new_info.get_insn (), new_info);\n \t      if (block_info.local_dem == block_info.reaching_out)\n@@ -2160,27 +2396,33 @@ pass_vsetvl::forward_demand_fusion (void)\n \t  /* If there is nothing to propagate, just skip it.  */\n \t  if (!local_dem.valid_or_dirty_p ())\n \t    continue;\n+\t  if (local_dem >= prop)\n+\t    continue;\n+\t  if (!local_dem.compatible_p (prop))\n+\t    continue;\n \n-\t  if (prop > local_dem)\n+\t  vector_insn_info new_info = local_dem.merge (prop, GLOBAL_MERGE);\n+\t  new_info.set_insn (local_dem.get_insn ());\n+\t  if (local_dem.dirty_p ())\n \t    {\n-\t      if (local_dem.dirty_p ())\n-\t\t{\n-\t\t  gcc_assert (local_dem == reaching_out);\n-\t\t  rtx dirty_pat\n-\t\t    = gen_vsetvl_pat (prop.get_insn ()->rtl (), prop);\n-\t\t  local_dem = prop;\n-\t\t  local_dem.set_dirty ();\n-\t\t  reaching_out = local_dem;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (reaching_out == local_dem)\n-\t\t    reaching_out.set_demand_info (prop);\n-\t\t  local_dem.set_demand_info (prop);\n-\t\t  change_vsetvl_insn (local_dem.get_insn (), prop);\n-\t\t}\n-\t      changed_p = true;\n+\t      gcc_assert (local_dem == reaching_out);\n+\t      local_dem = new_info;\n+\t      local_dem.set_dirty (local_dem.dirty_with_killed_avl_p ());\n+\t      reaching_out = local_dem;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (reaching_out == local_dem)\n+\t\treaching_out = new_info;\n+\t      local_dem = new_info;\n+\t      change_vsetvl_insn (local_dem.get_insn (), new_info);\n \t    }\n+\t  auto &prob\n+\t    = m_vector_manager->vector_block_infos[e->dest->index].probability;\n+\t  auto &curr_prob\n+\t    = m_vector_manager->vector_block_infos[cfg_bb->index].probability;\n+\t  prob = curr_prob * e->probability;\n+\t  changed_p = true;\n \t}\n     }\n   return changed_p;\n@@ -2193,8 +2435,51 @@ pass_vsetvl::demand_fusion (void)\n   while (changed_p)\n     {\n       changed_p = false;\n+      prune_expressions ();\n+      m_vector_manager->create_bitmap_vectors ();\n+      compute_local_properties ();\n+      /* To optimize the case like this:\n+\t void f2 (int8_t * restrict in, int8_t * restrict out, int n, int cond)\n+\t   {\n+\t     size_t vl = 101;\n+\n+\t     for (size_t i = 0; i < n; i++)\n+\t       {\n+\t\t vint8mf8_t v = __riscv_vle8_v_i8mf8 (in + i + 300, vl);\n+\t\t __riscv_vse8_v_i8mf8 (out + i + 300, v, vl);\n+\t       }\n+\n+\t     for (size_t i = 0; i < n; i++)\n+\t       {\n+\t\t vint8mf8_t v = __riscv_vle8_v_i8mf8 (in + i, vl);\n+\t\t __riscv_vse8_v_i8mf8 (out + i, v, vl);\n+\n+\t\t vint8mf8_t v2 = __riscv_vle8_v_i8mf8_tu (v, in + i + 100, vl);\n+\t\t __riscv_vse8_v_i8mf8 (out + i + 100, v2, vl);\n+\t       }\n+\t   }\n+\n+\t  bb 0: li a5, 101 (killed avl)\n+\t  ...\n+\t  bb 1: vsetvli zero, a5, ta\n+\t  ...\n+\t  bb 2: li a5, 101 (killed avl)\n+\t  ...\n+\t  bb 3: vsetvli zero, a3, tu\n+\n+\tWe want to fuse VSEVLI instructions on bb 1 and bb 3. However, there is\n+\tan AVL kill instruction in bb 2 that we can't backward fuse bb 3 or\n+\tforward bb 1 arbitrarily. We need available information of each block to\n+\thelp for such cases.  */\n+      compute_available (m_vector_manager->vector_comp,\n+\t\t\t m_vector_manager->vector_kill,\n+\t\t\t m_vector_manager->vector_avout,\n+\t\t\t m_vector_manager->vector_avin);\n       changed_p |= backward_demand_fusion ();\n       changed_p |= forward_demand_fusion ();\n+      m_vector_manager->free_bitmap_vectors ();\n+      if (!m_vector_manager->vector_exprs.is_empty ())\n+\tm_vector_manager->vector_exprs.release ();\n     }\n \n   if (dump_file)\n@@ -2238,6 +2523,21 @@ pass_vsetvl::prune_expressions (void)\n     }\n }\n \n+/* Compute the local properties of each recorded expression.\n+\n+   Local properties are those that are defined by the block, irrespective of\n+   other blocks.\n+\n+   An expression is transparent in a block if its operands are not modified\n+   in the block.\n+\n+   An expression is computed (locally available) in a block if it is computed\n+   at least once and expression would contain the same value if the\n+   computation was moved to the end of the block.\n+\n+   An expression is locally anticipatable in a block if it is computed at\n+   least once and expression would contain the same value if the computation\n+   was moved to the beginning of the block.  */\n void\n pass_vsetvl::compute_local_properties (void)\n {\n@@ -2260,41 +2560,85 @@ pass_vsetvl::compute_local_properties (void)\n \tthe block and the occurrence.  */\n \n   basic_block cfg_bb;\n-  FOR_EACH_BB_FN (cfg_bb, cfun)\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n     {\n-      int curr_bb_idx = cfg_bb->index;\n+      unsigned int curr_bb_idx = bb->index ();\n       const auto local_dem\n \t= m_vector_manager->vector_block_infos[curr_bb_idx].local_dem;\n       const auto reaching_out\n \t= m_vector_manager->vector_block_infos[curr_bb_idx].reaching_out;\n \n-      if (!local_dem.empty_p ())\n+      /* Compute transparent.  */\n+      for (size_t i = 0; i < m_vector_manager->vector_exprs.length (); i++)\n \t{\n-\t  for (size_t i = 0; i < m_vector_manager->vector_exprs.length (); i++)\n+\t  const vector_insn_info *expr = m_vector_manager->vector_exprs[i];\n+\t  if (local_dem.real_dirty_p () || local_dem.valid_p ()\n+\t      || local_dem.unknown_p ()\n+\t      || has_vsetvl_killed_avl_p (bb, local_dem))\n \t    bitmap_clear_bit (m_vector_manager->vector_transp[curr_bb_idx], i);\n+\t  /* FIXME: Here we set the block as non-transparent (killed) if there\n+\t     is an instruction killed the value of AVL according to the\n+\t     definition of Local transparent. This is true for such following\n+\t     case:\n+\n+\t\tbb 0 (Loop label):\n+\t\t  vsetvl zero, a5, e8, mf8\n+\t\tbb 1:\n+\t\t  def a5\n+\t\tbb 2:\n+\t\t  branch bb 0 (Loop label).\n+\n+\t     In this case, we known there is a loop bb 0->bb 1->bb 2. According\n+\t     to LCM definition, it is correct when we set vsetvl zero, a5, e8,\n+\t     mf8 as non-transparent (killed) so that LCM will not hoist outside\n+\t     the bb 0.\n+\n+\t     However, such conservative configuration will forbid optimization\n+\t     on some unlucky case. For example:\n+\n+\t\tbb 0:\n+\t\t  li a5, 101\n+\t\tbb 1:\n+\t\t  vsetvl zero, a5, e8, mf8\n+\t\tbb 2:\n+\t\t  li a5, 101\n+\t\tbb 3:\n+\t\t  vsetvl zero, a5, e8, mf8.\n+\t     So we also relax def a5 as transparent to gain more optimizations\n+\t     as long as the all real def insn of avl do not come from this\n+\t     block. This configuration may be still missing some optimization\n+\t     opportunities.  */\n+\t  if (reg_killed_by_bb_p (bb, expr->get_avl ()))\n+\t    {\n+\t      hash_set<insn_info *> insns = get_all_nonphi_defs (\n+\t\tsafe_dyn_cast<phi_info *> (expr->get_avl_source ()));\n+\t      if (any_insn_in_bb_p (insns, bb))\n+\t\tbitmap_clear_bit (m_vector_manager->vector_transp[curr_bb_idx],\n+\t\t\t\t  i);\n+\t    }\n \t}\n \n-      if (local_dem.valid_or_dirty_p ())\n-\t{\n-\t  const insn_info *header_insn = local_dem.get_insn ();\n-\t  size_t header_index = m_vector_manager->get_expr_id (local_dem);\n-\t  if (anticipatable_occurrence_p (header_insn, local_dem))\n-\t    bitmap_set_bit (m_vector_manager->vector_antic[curr_bb_idx],\n-\t\t\t    header_index);\n-\t}\n+      /* Compute anticipatable occurrences.  */\n+      if (local_dem.valid_p () || local_dem.real_dirty_p ())\n+\tif (anticipatable_occurrence_p (bb, local_dem))\n+\t  bitmap_set_bit (m_vector_manager->vector_antic[curr_bb_idx],\n+\t\t\t  m_vector_manager->get_expr_id (local_dem));\n \n+      /* Compute available occurrences.  */\n       if (reaching_out.valid_or_dirty_p ())\n \t{\n-\t  const insn_info *footer_insn = reaching_out.get_insn ();\n-\t  size_t footer_index = m_vector_manager->get_expr_id (reaching_out);\n-\t  if (available_occurrence_p (footer_insn, reaching_out))\n-\t    bitmap_set_bit (m_vector_manager->vector_comp[curr_bb_idx],\n-\t\t\t    footer_index);\n \t  auto_vec<size_t> available_list\n \t    = m_vector_manager->get_all_available_exprs (reaching_out);\n \t  for (size_t i = 0; i < available_list.length (); i++)\n-\t    bitmap_set_bit (m_vector_manager->vector_comp[curr_bb_idx],\n-\t\t\t    available_list[i]);\n+\t    {\n+\t      const vector_insn_info *expr\n+\t\t= m_vector_manager->vector_exprs[available_list[i]];\n+\t      if (reaching_out.real_dirty_p ()\n+\t\t  || has_vsetvl_killed_avl_p (bb, reaching_out)\n+\t\t  || available_occurrence_p (bb, *expr))\n+\t\tbitmap_set_bit (m_vector_manager->vector_comp[curr_bb_idx],\n+\t\t\t\tavailable_list[i]);\n+\t    }\n \t}\n     }\n \n@@ -2427,8 +2771,11 @@ pass_vsetvl::cleanup_vsetvls ()\n \t\tinfo.set_unknown ();\n \t      else\n \t\t{\n-\t\t  insn_info *insn\n-\t\t    = m_vector_manager->vector_exprs[i]->get_insn ();\n+\t\t  const auto dem\n+\t\t    = m_vector_manager->vector_block_infos[cfg_bb->index]\n+\t\t\t.local_dem;\n+\t\t  gcc_assert (dem == *m_vector_manager->vector_exprs[i]);\n+\t\t  insn_info *insn = dem.get_insn ();\n \t\t  gcc_assert (insn && insn->rtl ());\n \t\t  rtx_insn *rinsn;\n \t\t  if (vector_config_insn_p (insn->rtl ()))\n@@ -2488,14 +2835,34 @@ pass_vsetvl::commit_vsetvls (void)\n \t}\n     }\n \n-  basic_block cfg_bb;\n-  FOR_EACH_BB_FN (cfg_bb, cfun)\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n     {\n+      basic_block cfg_bb = bb->cfg_bb ();\n       const auto reaching_out\n \t= m_vector_manager->vector_block_infos[cfg_bb->index].reaching_out;\n       if (!reaching_out.dirty_p ())\n \tcontinue;\n \n+      if (reaching_out.dirty_with_killed_avl_p ())\n+\t{\n+\t  if (!has_vsetvl_killed_avl_p (bb, reaching_out))\n+\t    continue;\n+\n+\t  unsigned int bb_index;\n+\t  sbitmap_iterator sbi;\n+\t  sbitmap avin = m_vector_manager->vector_avin[cfg_bb->index];\n+\t  bool available_p = false;\n+\t  EXECUTE_IF_SET_IN_BITMAP (avin, 0, bb_index, sbi)\n+\t  {\n+\t    if (*m_vector_manager->vector_exprs[bb_index] >= reaching_out)\n+\t      {\n+\t\tavailable_p = true;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t  if (available_p)\n+\t    continue;\n+\t}\n \n       rtx new_pat;\n       if (can_refine_vsetvl_p (cfg_bb, reaching_out.get_ratio ()))\n@@ -2604,6 +2971,7 @@ pass_vsetvl::init (void)\n     }\n \n   m_vector_manager = new vector_infos_manager ();\n+  compute_probabilities ();\n \n   if (dump_file)\n     {"}, {"sha": "fbde7bd58e5fc80546070a37680ccfe3952d23c2", "filename": "gcc/config/riscv/riscv-vsetvl.h", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f673c5ee287d73262ad9c1d59ca4d6db3809eef/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f673c5ee287d73262ad9c1d59ca4d6db3809eef/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h?ref=4f673c5ee287d73262ad9c1d59ca4d6db3809eef", "patch": "@@ -52,6 +52,19 @@ enum demand_type\n   NUM_DEMAND\n };\n \n+enum fusion_type\n+{\n+  INVALID_FUSION,\n+  VALID_AVL_FUSION,\n+  KILLED_AVL_FUSION\n+};\n+\n+enum merge_type\n+{\n+  LOCAL_MERGE,\n+  GLOBAL_MERGE\n+};\n+\n /* AVL info for RVV instruction. Most RVV instructions have AVL operand in\n    implicit dependency. The AVL comparison between 2 RVV instructions is\n    very important since it affects our decision whether we should insert\n@@ -129,6 +142,7 @@ class avl_info\n   avl_info (rtx, rtl_ssa::set_info *);\n   rtx get_value () const { return m_value; }\n   rtl_ssa::set_info *get_source () const { return m_source; }\n+  bool single_source_equal_p (const avl_info &) const;\n   avl_info &operator= (const avl_info &);\n   bool operator== (const avl_info &) const;\n   bool operator!= (const avl_info &) const;\n@@ -174,6 +188,7 @@ struct vl_vtype_info\n \n   rtx get_avl () const { return m_avl.get_value (); }\n   const avl_info &get_avl_info () const { return m_avl; }\n+  rtl_ssa::set_info *get_avl_source () const { return m_avl.get_source (); }\n   void set_avl_info (const avl_info &avl) { m_avl = avl; }\n   uint8_t get_sew () const { return m_sew; }\n   riscv_vector::vlmul_type get_vlmul () const { return m_vlmul; }\n@@ -199,7 +214,25 @@ class vector_insn_info : public vl_vtype_info\n     /* The block is polluted as containing VSETVL instruction during dem\n        backward propagation to gain better LCM optimization even though\n        such VSETVL instruction is not really emit yet during this time.  */\n-    DIRTY\n+    DIRTY,\n+    /* The block is polluted with killed AVL.\n+       We will backward propagate such case:\n+\t bb 0: def a5, 55 (empty).\n+\t ...\n+\t bb 1: vsetvli zero, a5.\n+\t ...\n+\t bb 2: empty.\n+\t ...\n+\t bb 3: def a3, 55 (empty).\n+\t ...\n+\t bb 4: vsetvli zero, a3.\n+\n+       To elide vsetvli in bb 4, we need to backward pollute bb 3 and bb 2\n+       as DIRTY block as long as there is a block def AVL which has the same\n+       source with AVL in bb 4. Such polluted block, we call it as\n+       DIRTY_WITH_KILLED_AVL\n+    */\n+    DIRTY_WITH_KILLED_AVL\n   };\n \n   enum state_type m_state;\n@@ -247,10 +280,19 @@ class vector_insn_info : public vl_vtype_info\n   bool valid_p () const { return m_state == VALID; }\n   bool unknown_p () const { return m_state == UNKNOWN; }\n   bool empty_p () const { return m_state == EMPTY; }\n-  bool dirty_p () const { return m_state == DIRTY; }\n+  bool dirty_p () const\n+  {\n+    return m_state == DIRTY || m_state == DIRTY_WITH_KILLED_AVL;\n+  }\n+  bool dirty_with_killed_avl_p () const\n+  {\n+    return m_state == DIRTY_WITH_KILLED_AVL;\n+  }\n+  bool real_dirty_p () const { return m_state == DIRTY; }\n   bool valid_or_dirty_p () const\n   {\n-    return m_state == VALID || m_state == DIRTY;\n+    return m_state == VALID || m_state == DIRTY\n+\t   || m_state == DIRTY_WITH_KILLED_AVL;\n   }\n \n   static vector_insn_info get_unknown ()\n@@ -263,9 +305,22 @@ class vector_insn_info : public vl_vtype_info\n   void set_valid () { m_state = VALID; }\n   void set_unknown () { m_state = UNKNOWN; }\n   void set_empty () { m_state = EMPTY; }\n-  void set_dirty () { m_state = DIRTY; }\n+  void set_dirty (enum fusion_type type)\n+  {\n+    gcc_assert (type == VALID_AVL_FUSION || type == KILLED_AVL_FUSION);\n+    if (type == VALID_AVL_FUSION)\n+      m_state = DIRTY;\n+    else\n+      m_state = DIRTY_WITH_KILLED_AVL;\n+  }\n+  void set_dirty (bool dirty_with_killed_avl_p)\n+  {\n+    if (dirty_with_killed_avl_p)\n+      m_state = DIRTY_WITH_KILLED_AVL;\n+    else\n+      m_state = DIRTY;\n+  }\n   void set_insn (rtl_ssa::insn_info *insn) { m_insn = insn; }\n-  void set_demand_info (const vector_insn_info &);\n \n   bool demand_p (enum demand_type type) const { return m_demands[type]; }\n   void demand (enum demand_type type) { m_demands[type] = true; }\n@@ -274,9 +329,10 @@ class vector_insn_info : public vl_vtype_info\n \n   bool compatible_p (const vector_insn_info &) const;\n   bool compatible_avl_p (const vl_vtype_info &) const;\n+  bool compatible_avl_p (const avl_info &) const;\n   bool compatible_vtype_p (const vl_vtype_info &) const;\n   bool compatible_p (const vl_vtype_info &) const;\n-  vector_insn_info merge (const vector_insn_info &, bool) const;\n+  vector_insn_info merge (const vector_insn_info &, enum merge_type) const;\n \n   rtl_ssa::insn_info *get_insn () const { return m_insn; }\n "}]}