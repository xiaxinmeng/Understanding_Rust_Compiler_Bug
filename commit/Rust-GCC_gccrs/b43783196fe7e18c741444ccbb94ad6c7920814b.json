{"sha": "b43783196fe7e18c741444ccbb94ad6c7920814b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQzNzgzMTk2ZmU3ZTE4Yzc0MTQ0NGNjYmI5NGFkNmM3OTIwODE0Yg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2002-08-27T20:01:17Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2002-08-27T20:01:17Z"}, "message": "config.gcc: Add v850e-*-* target.\n\n2002-08-27  Nick Clifton  <nickc@redhat.com>\n            Catherine Moore  <clm@redhat.com>\n            Jim Wilson  <wilson@cygnus.com>\n        * config.gcc: Add v850e-*-* target.\n        Add --with-cpu= support for v850.\n        * config/v850/lib1funcs.asm: Add v850e callt functions.\n        * config/v850/v850.h: Add support for v850e target.\n        * config/v850/v850.c: Add functions to support v850e target.\n        * config/v850/v850-protos.h: Add prototypes for new functions in v850.c.\n        * config/v850/v850.md: Add patterns for v850e instructions.\n        * doc/invoke.texi: Document new v850e command line switches.\n\nCo-Authored-By: Catherine Moore <clm@redhat.com>\nCo-Authored-By: Jim Wilson <wilson@cygnus.com>\n\nFrom-SVN: r56612", "tree": {"sha": "d148f5263f503200520b6fcaef7e6203042e25a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d148f5263f503200520b6fcaef7e6203042e25a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b43783196fe7e18c741444ccbb94ad6c7920814b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b43783196fe7e18c741444ccbb94ad6c7920814b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b43783196fe7e18c741444ccbb94ad6c7920814b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b43783196fe7e18c741444ccbb94ad6c7920814b/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "361d6b42857605b1177f501bc9ad571371159aed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/361d6b42857605b1177f501bc9ad571371159aed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/361d6b42857605b1177f501bc9ad571371159aed"}], "stats": {"total": 1812, "additions": 1748, "deletions": 64}, "files": [{"sha": "ec6d938aad808f9c98f67cf5ce04f67e2d0e8fcb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b43783196fe7e18c741444ccbb94ad6c7920814b", "patch": "@@ -1,3 +1,16 @@\n+2002-08-27  Nick Clifton  <nickc@redhat.com>\n+            Catherine Moore  <clm@redhat.com>\n+            Jim Wilson  <wilson@cygnus.com>\n+\n+        * config.gcc: Add v850e-*-* target.\n+        Add --with-cpu= support for v850.\n+        * config/v850/lib1funcs.asm: Add v850e callt functions.\n+        * config/v850/v850.h: Add support for v850e target.\n+        * config/v850/v850.c: Add functions to support v850e target.\n+        * config/v850/v850-protos.h: Add prototypes for new functions in v850.c.\n+        * config/v850/v850.md: Add patterns for v850e instructions.\n+        * doc/invoke.texi: Document new v850e command line switches.\n+\n Tue Aug 27 18:30:47 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \t\t\t  Aldy Hernandez <aldyh at redhat dot com>\n "}, {"sha": "145d2cf0064f97a652326fcd2cc6d80d099e955a", "filename": "gcc/config.gcc", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b43783196fe7e18c741444ccbb94ad6c7920814b", "patch": "@@ -2643,6 +2643,21 @@ v850-*-rtems*)\n \tc_target_objs=\"v850-c.o\"\n \tcxx_target_objs=\"v850-c.o\"\n \t;;\n+v850e-*-*)\n+\ttarget_cpu_default=\"TARGET_CPU_v850e\"\n+\ttm_file=\"dbxelf.h elfos.h svr4.h v850/v850.h\"\n+\ttm_p_file=v850/v850-protos.h\n+\ttmake_file=v850/t-v850\n+\tmd_file=v850/v850.md\n+\tout_file=v850/v850.c\n+\tif test x$stabs = xyes\n+\tthen\n+\t\ttm_file=\"${tm_file} dbx.h\"\n+\tfi\n+\tuse_collect2=no\n+\tc_target_objs=\"v850-c.o\"\n+\tcxx_target_objs=\"v850-c.o\"\n+\t;;\n v850-*-*)\n \ttarget_cpu_default=\"TARGET_CPU_generic\"\n \ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n@@ -2952,6 +2967,22 @@ sparc*-*-*)\n \t\t\t;;\n \tesac\n \t;;\n+v850*-*-*)\n+\tcase \"x$with_cpu\" in\n+\t\tx)\n+\t\t\t;;\n+\t\tv850e)\n+\t\t\ttarget_cpu_default2=\"TARGET_CPU_$with_cpu\"\n+\t\t\t;;\n+\t\t*)\n+\t\t\tif test x$pass2done = xyes\n+\t\t\tthen\n+\t\t\t\techo \"Unknown cpu used with --with-cpu=$with_cpu\" 1>&2\n+\t\t\t\texit 1\n+\t\t\tfi\n+\t\t\t;;\n+\tesac\n+\t;;\n esac\n \n if test \"$target_cpu_default2\" != \"\""}, {"sha": "fb241d4bea2d5e6e972910d2d41b0b198f6d00c0", "filename": "gcc/config/v850/lib1funcs.asm", "status": "modified", "additions": 378, "deletions": 3, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Flib1funcs.asm?ref=b43783196fe7e18c741444ccbb94ad6c7920814b", "patch": "@@ -1,5 +1,5 @@\n /* libgcc routines for NEC V850.\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1114,7 +1114,7 @@ __return_r29_r31:\n \t.type\t__save_r31,@function\n \t/* Allocate space and save register 31 on the stack */\n \t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r29_r31,r10 */\n+\t/* Called via:\tjalr __save_r31,r10 */\n __save_r31:\n \taddi\t-20,sp,sp\n \tst.w\tr31,16[sp]\n@@ -1130,7 +1130,7 @@ __return_r31:\n \tld.w\t16[sp],r31\n \taddi\t20,sp,sp\n \tjmp\t[r31]\n-\t.size\t__return_r29_r31,.-__return_r29_r31\n+        .size   __return_r31,.-__return_r31\n #endif /* L_save_31c */\n \n #ifdef L_save_varargs\n@@ -1267,3 +1267,378 @@ __restore_all_interrupt:\n \tjmp\t[r10]\n \t.size\t__restore_all_interrupt,.-__restore_all_interrupt\n #endif /* L_save_all_interrupt */\n+\n+\t\n+#if defined __v850e__\n+#ifdef\tL_callt_save_r2_r29\n+\t/* Put these functions into the call table area.  */\n+\t.call_table_text\n+\t\n+\t/* Allocate space and save registers 2, 20 .. 29 on the stack.  */\n+\t/* Called via:\tcallt ctoff(__callt_save_r2_r29).  */\n+\t.align\t2\n+.L_save_r2_r29:\n+\tadd\t-4, sp\n+\tst.w\tr2, 0[sp]\n+\tprepare {r20 - r29}, 0\n+\tctret\n+\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tcallt ctoff(__callt_return_r2_r29).  */\n+\t.align\t2\n+.L_return_r2_r29:\n+\tdispose 0, {r20-r29}\n+\tld.w    0[sp], r2\n+\tadd\t4, sp\n+\tjmp     [r31]\n+\n+\t/* Place the offsets of the start of these routines into the call table.  */\n+\t.call_table_data\n+\n+\t.global\t__callt_save_r2_r29\n+\t.type\t__callt_save_r2_r29,@function\n+__callt_save_r2_r29:\t.short ctoff(.L_save_r2_r29)\n+\t\n+\t.global\t__callt_return_r2_r29\n+\t.type\t__callt_return_r2_r29,@function\n+__callt_return_r2_r29:\t.short ctoff(.L_return_r2_r29)\n+\t\n+#endif /* L_callt_save_r2_r29 */\n+\n+#ifdef\tL_callt_save_r2_r31\n+\t/* Put these functions into the call table area.  */\n+\t.call_table_text\n+\t\n+\t/* Allocate space and save registers 2 and 20 .. 29, 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tcallt ctoff(__callt_save_r2_r31).  */\n+\t.align\t2\n+.L_save_r2_r31:\n+\tadd\t-4, sp\n+\tst.w\tr2, 0[sp]\n+\tprepare {r20 - r29, r31}, 4\n+\tctret\n+\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tcallt ctoff(__callt_return_r2_r31).  */\n+\t.align\t2\n+.L_return_r2_r31:\n+\tdispose 4, {r20 - r29, r31}\n+\tld.w    0[sp], r2\n+\taddi\t4, sp, sp\n+\tjmp     [r31]\n+\n+\t/* Place the offsets of the start of these routines into the call table.  */\n+\t.call_table_data\n+\n+\t.global\t__callt_save_r2_r31\n+\t.type\t__callt_save_r2_r31,@function\n+__callt_save_r2_r31:\t.short ctoff(.L_save_r2_r31)\n+\t\n+\t.global\t__callt_return_r2_r31\n+\t.type\t__callt_return_r2_r31,@function\n+__callt_return_r2_r31:\t.short ctoff(.L_return_r2_r31)\n+\t\n+#endif /* L_callt_save_r2_r31 */\n+\n+\n+#ifdef L_callt_save_r6_r9\n+\t/* Put these functions into the call table area.  */\n+\t.call_table_text\n+\t\n+\t/* Save registers r6 - r9 onto the stack in the space reserved for them.\n+\t   Use by variable argument functions. \n+\t   Called via:\tcallt ctoff(__callt_save_r6_r9).  */\n+\t.align\t2\n+.L_save_r6_r9:\n+\tmov\tep,r1\n+\tmov\tsp,ep\n+\tsst.w\tr6,0[ep]\n+\tsst.w\tr7,4[ep]\n+\tsst.w\tr8,8[ep]\n+\tsst.w\tr9,12[ep]\n+\tmov\tr1,ep\n+\tctret\n+\n+\t/* Place the offsets of the start of this routines into the call table.  */\n+\t.call_table_data\n+\n+\t.global\t__callt_save_r6_r9\n+\t.type\t__callt_save_r6_r9,@function\n+__callt_save_r6_r9:\t.short ctoff(.L_save_r6_r9)\n+#endif /* L_callt_save_r6_r9 */\n+\n+\t\n+#ifdef\tL_callt_save_interrupt\n+\t/* Put this functions into the call table area */\n+\t.call_table_text\n+\t\n+\t/* Save registers r1, ep, gp, r10 on stack and load up with expected values.  */\n+\t/* Called via:\tcallt ctoff(__callt_save_interrupt).  */\n+\t.align\t2\n+.L_save_interrupt:\n+        /* SP has already been moved before callt ctoff(_save_interrupt).  */\n+        /* addi -24, sp, sp  */\n+        st.w    ep,  0[sp]\n+        st.w    gp,  4[sp]\n+        st.w    r1,  8[sp]\n+        /* R10 has alread been saved bofore callt ctoff(_save_interrupt).  */\n+        /* st.w    r10, 12[sp]  */\n+\tmov\thilo(__ep),ep\n+\tmov\thilo(__gp),gp\n+\tctret\n+\n+        /* Place the offsets of the start of the routine into the call table.  */\n+        .call_table_data\n+        .global __callt_save_interrupt\n+        .type   __callt_save_interrupt,@function\n+__callt_save_interrupt: .short ctoff(.L_save_interrupt)\n+\n+        .call_table_text\n+\n+\t/* Restore saved registers, deallocate stack and return from the interrupt.  */\n+        /* Called via:  callt ctoff(__callt_restore_itnerrupt).   */\n+\t.text\n+\t.align\t2\n+\t.globl\t__return_interrupt\n+\t.type\t__return_interrupt,@function\n+.L_return_interrupt:\n+        ld.w    20[sp], r1\n+        ldsr    r1,     ctpsw\n+        ld.w    16[sp], r1\n+        ldsr    r1,     ctpc\n+        ld.w    12[sp], r10\n+        ld.w     8[sp], r1\n+        ld.w     4[sp], gp\n+        ld.w     0[sp], ep\n+        addi    24, sp, sp\n+        reti\n+\n+\t/* Place the offsets of the start of the routine into the call table.  */\n+\t.call_table_data\n+\n+        .global __callt_return_interrupt\n+        .type   __callt_return_interrupt,@function\n+__callt_return_interrupt:       .short ctoff(.L_return_interrupt)\n+\t\n+#endif /* L_callt_save_interrupt */\n+\n+#ifdef L_callt_save_all_interrupt\n+\t/* Put this functions into the call table area.  */\n+\t.call_table_text\n+\t\n+\t/* Save all registers except for those saved in __save_interrupt.  */\n+\t/* Allocate enough stack for all of the registers & 16 bytes of space.  */\n+\t/* Called via:\tcallt ctoff(__callt_save_all_interrupt).  */\n+\t.align\t2\n+.L_save_all_interrupt:\n+\taddi\t-60, sp, sp\n+\tmov\tep,  r1\n+\tmov\tsp,  ep\n+\tsst.w\tr2,  56[ep]\n+\tsst.w\tr5,  52[ep]\n+\tsst.w\tr6,  48[ep]\n+\tsst.w\tr7,  44[ep]\n+\tsst.w\tr8,  40[ep]\n+\tsst.w\tr9,  36[ep]\n+\tsst.w\tr11, 32[ep]\n+\tsst.w\tr12, 28[ep]\n+\tsst.w\tr13, 24[ep]\n+\tsst.w\tr14, 20[ep]\n+\tsst.w\tr15, 16[ep]\n+\tsst.w\tr16, 12[ep]\n+\tsst.w\tr17, 8[ep]\n+\tsst.w\tr18, 4[ep]\n+\tsst.w\tr19, 0[ep]\n+\tmov\tr1,  ep\n+\n+\tprepare {r20 - r29, r31}, 4\n+\tctret\t\n+\n+\t/* Restore all registers saved in __save_all_interrupt.  */\n+\t/* & deallocate the stack space.  */\n+\t/* Called via:\tcallt ctoff(__callt_restore_all_interrupt).  */\n+\t.align 2\n+.L_restore_all_interrupt:\n+\tdispose 4, {r20 - r29, r31}\n+\t\n+\tmov\tep, r1\n+\tmov\tsp, ep\n+\tsld.w\t0 [ep], r19\n+\tsld.w\t4 [ep], r18\n+\tsld.w\t8 [ep], r17\n+\tsld.w\t12[ep], r16\n+\tsld.w\t16[ep], r15\n+\tsld.w\t20[ep], r14\n+\tsld.w\t24[ep], r13\n+\tsld.w\t28[ep], r12\n+\tsld.w\t32[ep], r11\n+\tsld.w\t36[ep], r9\n+\tsld.w\t40[ep], r8\n+\tsld.w\t44[ep], r7\n+\tsld.w\t48[ep], r6\n+\tsld.w\t52[ep], r5\n+\tsld.w\t56[ep], r2\n+\tmov\tr1, ep\n+\taddi\t60, sp, sp\n+\tctret\n+\n+\t/* Place the offsets of the start of these routines into the call table.  */\n+\t.call_table_data\n+\n+\t.global\t__callt_save_all_interrupt\n+\t.type\t__callt_save_all_interrupt,@function\n+__callt_save_all_interrupt:\t.short ctoff(.L_save_all_interrupt)\n+\t\n+\t.global\t__callt_restore_all_interrupt\n+\t.type\t__callt_restore_all_interrupt,@function\n+__callt_restore_all_interrupt:\t.short ctoff(.L_restore_all_interrupt)\n+\t\n+#endif /* L_callt_save_all_interrupt */\n+\n+\n+#define MAKE_CALLT_FUNCS( START )\t\t\t\t\t\t\\\n+\t.call_table_text\t\t\t\t\t\t\t;\\\n+\t.align\t2\t\t\t\t\t\t\t\t;\\\n+\t/* Allocate space and save registers START .. r29 on the stack.  */\t;\\\n+\t/* Called via:\tcallt ctoff(__callt_save_START_r29).  */\t\t;\\\n+.L_save_##START##_r29:\t\t\t\t\t\t\t\t;\\\n+\tprepare { START - r29 }, 0\t\t\t\t\t\t;\\\n+\tctret\t\t\t\t\t\t\t\t\t;\\\n+\t\t\t\t\t\t\t\t\t\t;\\\n+\t/* Restore saved registers, deallocate stack and return.  */\t\t;\\\n+\t/* Called via:\tcallt ctoff(__return_START_r29) */\t\t\t;\\\n+\t.align\t2\t\t\t\t\t\t\t\t;\\\n+.L_return_##START##_r29:\t\t\t\t\t\t\t;\\\n+\tdispose 0, { START - r29 }, r31\t\t\t\t\t\t;\\\n+\t\t\t\t\t\t\t\t\t\t;\\\n+\t/* Place the offsets of the start of these funcs into the call table. */;\\\n+\t.call_table_data\t\t\t\t\t\t\t;\\\n+\t\t\t\t\t\t\t\t\t\t;\\\n+\t.global\t__callt_save_##START##_r29\t\t\t\t\t;\\\n+\t.type\t__callt_save_##START##_r29,@function\t\t\t\t;\\\n+__callt_save_##START##_r29:\t.short ctoff(.L_save_##START##_r29 )\t\t;\\\n+\t\t\t\t\t\t\t\t\t\t;\\\n+\t.global\t__callt_return_##START##_r29\t\t\t\t\t;\\\n+\t.type\t__callt_return_##START##_r29,@function\t\t\t\t;\\\n+__callt_return_##START##_r29:\t.short ctoff(.L_return_##START##_r29 )\t\n+\n+\n+#define MAKE_CALLT_CFUNCS( START )\t\t\t\t\t\t\\\n+\t.call_table_text\t\t\t\t\t\t\t;\\\n+\t.align\t2\t\t\t\t\t\t\t\t;\\\n+\t/* Allocate space and save registers START .. r31 on the stack.  */\t;\\\n+\t/* Called via:\tcallt ctoff(__callt_save_START_r31c).  */\t\t;\\\n+.L_save_##START##_r31c:\t\t\t\t\t\t\t\t;\\\n+\tprepare { START - r29, r31}, 4\t\t\t\t\t\t;\\\n+\tctret\t\t\t\t\t\t\t\t\t;\\\n+\t\t\t\t\t\t\t\t\t\t;\\\n+\t/* Restore saved registers, deallocate stack and return.  */\t\t;\\\n+\t/* Called via:\tcallt ctoff(__return_START_r31c).  */\t\t\t;\\\n+\t.align\t2\t\t\t\t\t\t\t\t;\\\n+.L_return_##START##_r31c:\t\t\t\t\t\t\t;\\\n+\tdispose 4, { START - r29, r31}, r31\t\t\t\t\t;\\\n+\t\t\t\t\t\t\t\t\t\t;\\\n+\t/* Place the offsets of the start of these funcs into the call table. */;\\\n+\t.call_table_data\t\t\t\t\t\t\t;\\\n+\t\t\t\t\t\t\t\t\t\t;\\\n+\t.global\t__callt_save_##START##_r31c\t\t\t\t\t;\\\n+\t.type\t__callt_save_##START##_r31c,@function\t\t\t\t;\\\n+__callt_save_##START##_r31c:    .short ctoff(.L_save_##START##_r31c )\t\t;\\\n+\t\t\t\t\t\t\t\t\t\t;\\\n+\t.global\t__callt_return_##START##_r31c\t\t\t\t\t;\\\n+\t.type\t__callt_return_##START##_r31c,@function\t\t\t\t;\\\n+__callt_return_##START##_r31c:  .short ctoff(.L_return_##START##_r31c )\t\n+\n+\t\n+#ifdef\tL_callt_save_20\n+\tMAKE_CALLT_FUNCS (r20)\n+#endif\n+#ifdef\tL_callt_save_21\n+\tMAKE_CALLT_FUNCS (r21)\n+#endif\n+#ifdef\tL_callt_save_22\n+\tMAKE_CALLT_FUNCS (r22)\n+#endif\n+#ifdef\tL_callt_save_23\n+\tMAKE_CALLT_FUNCS (r23)\n+#endif\n+#ifdef\tL_callt_save_24\n+\tMAKE_CALLT_FUNCS (r24)\n+#endif\n+#ifdef\tL_callt_save_25\n+\tMAKE_CALLT_FUNCS (r25)\n+#endif\n+#ifdef\tL_callt_save_26\n+\tMAKE_CALLT_FUNCS (r26)\n+#endif\n+#ifdef\tL_callt_save_27\n+\tMAKE_CALLT_FUNCS (r27)\n+#endif\n+#ifdef\tL_callt_save_28\n+\tMAKE_CALLT_FUNCS (r28)\n+#endif\n+#ifdef\tL_callt_save_29\n+\tMAKE_CALLT_FUNCS (r29)\n+#endif\n+\n+#ifdef\tL_callt_save_20c\n+\tMAKE_CALLT_CFUNCS (r20)\n+#endif\n+#ifdef\tL_callt_save_21c\n+\tMAKE_CALLT_CFUNCS (r21)\n+#endif\n+#ifdef\tL_callt_save_22c\n+\tMAKE_CALLT_CFUNCS (r22)\n+#endif\n+#ifdef\tL_callt_save_23c\n+\tMAKE_CALLT_CFUNCS (r23)\n+#endif\n+#ifdef\tL_callt_save_24c\n+\tMAKE_CALLT_CFUNCS (r24)\n+#endif\n+#ifdef\tL_callt_save_25c\n+\tMAKE_CALLT_CFUNCS (r25)\n+#endif\n+#ifdef\tL_callt_save_26c\n+\tMAKE_CALLT_CFUNCS (r26)\n+#endif\n+#ifdef\tL_callt_save_27c\n+\tMAKE_CALLT_CFUNCS (r27)\n+#endif\n+#ifdef\tL_callt_save_28c\n+\tMAKE_CALLT_CFUNCS (r28)\n+#endif\n+#ifdef\tL_callt_save_29c\n+\tMAKE_CALLT_CFUNCS (r29)\n+#endif\n+\n+\t\n+#ifdef\tL_callt_save_31c\n+\t.call_table_text\n+\t.align\t2\n+\t/* Allocate space and save register r31 on the stack.  */\n+\t/* Called via:\tcallt ctoff(__callt_save_r31c).  */\n+.L_callt_save_r31c:\n+\tprepare {r31}, 4\n+\tctret\n+\n+\t/* Restore saved registers, deallocate stack and return.  */\n+\t/* Called via:\tcallt ctoff(__return_r31c).  */\n+\t.align\t2\n+.L_callt_return_r31c:\n+\tdispose 4, {r31}, r31\n+\t\n+\t/* Place the offsets of the start of these funcs into the call table.  */\n+\t.call_table_data\n+\n+\t.global\t__callt_save_r31c\n+\t.type\t__callt_save_r31c,@function\n+__callt_save_r31c:\t.short ctoff(.L_callt_save_r31c)\n+\n+\t.global\t__callt_return_r31c\n+\t.type\t__callt_return_r31c,@function\n+__callt_return_r31c:\t.short ctoff(.L_callt_return_r31c)\t\t\n+#endif\n+\n+#endif /* __v850e__ */"}, {"sha": "2030dc30d3e08c16f9b05647d5e5ad8aafa5f85e", "filename": "gcc/config/v850/t-v850", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Ft-v850", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Ft-v850", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Ft-v850?ref=b43783196fe7e18c741444ccbb94ad6c7920814b", "patch": "@@ -29,7 +29,34 @@ LIB1ASMFUNCS\t= _mulsi3 \\\n \t\t  _save_31c \\\n \t\t  _save_varargs \\\n \t\t  _save_interrupt \\\n-\t\t  _save_all_interrupt\n+\t\t  _save_all_interrupt \\\n+                  _callt_save_20 \\\n+\t\t  _callt_save_21 \\\n+\t\t  _callt_save_22 \\\n+\t\t  _callt_save_23 \\\n+\t\t  _callt_save_24 \\\n+\t\t  _callt_save_25 \\\n+\t\t  _callt_save_26 \\\n+\t\t  _callt_save_27 \\\n+\t\t  _callt_save_28 \\\n+\t\t  _callt_save_29 \\\n+\t\t  _callt_save_20c \\\n+\t\t  _callt_save_21c \\\n+\t\t  _callt_save_22c \\\n+\t\t  _callt_save_23c \\\n+\t\t  _callt_save_24c \\\n+\t\t  _callt_save_25c \\\n+\t\t  _callt_save_26c \\\n+\t\t  _callt_save_27c \\\n+\t\t  _callt_save_28c \\\n+\t\t  _callt_save_29c \\\n+\t\t  _callt_save_31c \\\n+\t\t  _callt_save_varargs \\\n+\t\t  _callt_save_interrupt \\\n+\t\t  _callt_save_all_interrupt \\\n+\t\t  _callt_save_r2_r29 \\\n+\t\t  _callt_save_r2_r31 \\\n+\t\t  _callt_save_r6_r9\n \n # We want fine grained libraries, so use the new code to build the\n # floating point emulation libraries.\n@@ -50,6 +77,8 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n TCFLAGS = -Wa,-mwarn-signed-overflow -Wa,-mwarn-unsigned-overflow\n+# Create non-target specific versions of the libraries\n+TCFLAGS += -mno-app-regs -msmall-sld -mv850 -D__v850e__ -Wa,-mv850any\n \n v850-c.o: $(srcdir)/config/v850/v850-c.c $(RTL_H) $(TREE_H) $(CONFIG_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<"}, {"sha": "ed0a565eefbea99268cb244cee626de7a97c18e4", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=b43783196fe7e18c741444ccbb94ad6c7920814b", "patch": "@@ -53,6 +53,10 @@ extern void   notice_update_cc              PARAMS ((rtx, rtx));\n extern char * construct_save_jarl           PARAMS ((rtx));\n extern char * construct_restore_jr          PARAMS ((rtx));\n #ifdef HAVE_MACHINE_MODES\n+extern char * construct_dispose_instruction PARAMS ((rtx));\n+extern char * construct_prepare_instruction PARAMS ((rtx));\n+extern int    pattern_is_ok_for_prepare     PARAMS ((rtx, Mmode));\n+extern int    pattern_is_ok_for_dispose     PARAMS ((rtx, Mmode));\n extern int    ep_memory_operand             PARAMS ((rtx, Mmode, int));\n extern int    reg_or_0_operand              PARAMS ((rtx, Mmode));\n extern int    reg_or_int5_operand           PARAMS ((rtx, Mmode));"}, {"sha": "3190839e8eb5c5bc2ba2f0d32ccf95cc32c52774", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 535, "deletions": 20, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=b43783196fe7e18c741444ccbb94ad6c7920814b", "patch": "@@ -142,6 +142,13 @@ override_options ()\n \t    }\n \t}\n     }\n+\n+  /* Make sure that the US_BIT_SET mask has been correctly initialised.  */\n+  if ((target_flags & MASK_US_MASK_SET) == 0)\n+    {\n+      target_flags |= MASK_US_MASK_SET;\n+      target_flags &= ~MASK_US_BIT_SET;\n+    }\n }\n \n \f\n@@ -176,6 +183,9 @@ function_arg (cum, mode, type, named)\n   else\n     size = GET_MODE_SIZE (mode);\n \n+  if (size < 1)\n+    return 0;\n+\n   if (type)\n     align = TYPE_ALIGN (type) / BITS_PER_UNIT;\n   else\n@@ -696,6 +706,38 @@ print_operand_address (file, addr)\n     }\n }\n \n+/* When assemble_integer is used to emit the offsets for a switch\n+   table it can encounter (TRUNCATE:HI (MINUS:SI (LABEL_REF:SI) (LABEL_REF:SI))).\n+   output_addr_const will normally barf at this, but it is OK to omit\n+   the truncate and just emit the difference of the two labels.  The\n+   .hword directive will automatically handle the truncation for us.\n+   \n+   Returns 1 if rtx was handled, 0 otherwise.  */\n+\n+int\n+v850_output_addr_const_extra (file, x)\n+     FILE * file;\n+     rtx x;\n+{\n+  if (GET_CODE (x) != TRUNCATE)\n+    return 0;\n+\n+  x = XEXP (x, 0);\n+\n+  /* We must also handle the case where the switch table was passed a\n+     constant value and so has been collapsed.  In this case the first\n+     label will have been deleted.  In such a case it is OK to emit\n+     nothing, since the table will not be used.\n+     (cf gcc.c-torture/compile/990801-1.c).  */\n+  if (GET_CODE (x) == MINUS\n+      && GET_CODE (XEXP (x, 0)) == LABEL_REF\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == CODE_LABEL\n+      && INSN_DELETED_P (XEXP (XEXP (x, 0), 0)))\n+    return 1;\n+\n+  output_addr_const (file, x);\n+  return 1;\n+}\n \f\n /* Return appropriate code to load up a 1, 2, or 4 integer/floating\n    point value.  */\n@@ -716,16 +758,19 @@ output_move_single (operands)\n \t{\n \t  HOST_WIDE_INT value = INTVAL (src);\n \n-\t  if (CONST_OK_FOR_J (value))\t\t/* signed 5 bit immediate */\n+\t  if (CONST_OK_FOR_J (value))\t\t/* Signed 5 bit immediate.  */\n \t    return \"mov %1,%0\";\n \n-\t  else if (CONST_OK_FOR_K (value))\t/* signed 16 bit immediate */\n+\t  else if (CONST_OK_FOR_K (value))\t/* Signed 16 bit immediate.  */\n \t    return \"movea lo(%1),%.,%0\";\n \n-\t  else if (CONST_OK_FOR_L (value))\t/* upper 16 bits were set */\n+\t  else if (CONST_OK_FOR_L (value))\t/* Upper 16 bits were set.  */\n \t    return \"movhi hi(%1),%.,%0\";\n \n-\t  else\t\t\t\t\t/* random constant */\n+\t  /* A random constant.  */\n+\t  else if (TARGET_V850E)\n+\t      return \"mov %1,%0\";\n+\t  else\n \t    return \"movhi hi(%1),%.,%0\\n\\tmovea lo(%1),%0,%0\";\n \t}\n \n@@ -734,16 +779,21 @@ output_move_single (operands)\n \t  HOST_WIDE_INT high, low;\n \n \t  const_double_split (src, &high, &low);\n-\t  if (CONST_OK_FOR_J (high))\t\t/* signed 5 bit immediate */\n+\n+\t  if (CONST_OK_FOR_J (high))\t\t/* Signed 5 bit immediate.  */\n \t    return \"mov %F1,%0\";\n \n-\t  else if (CONST_OK_FOR_K (high))\t/* signed 16 bit immediate */\n+\t  else if (CONST_OK_FOR_K (high))\t/* Signed 16 bit immediate.  */\n \t    return \"movea lo(%F1),%.,%0\";\n \n-\t  else if (CONST_OK_FOR_L (high))\t/* upper 16 bits were set */\n+\t  else if (CONST_OK_FOR_L (high))\t/* Upper 16 bits were set.  */\n \t    return \"movhi hi(%F1),%.,%0\";\n \n-\t  else\t\t\t\t\t/* random constant */\n+\t  /* A random constant.  */\n+\t  else if (TARGET_V850E)\n+\t      return \"mov %F1,%0\";\n+\n+\t  else\n \t    return \"movhi hi(%F1),%.,%0\\n\\tmovea lo(%F1),%0,%0\";\n \t}\n \n@@ -757,7 +807,10 @@ output_move_single (operands)\n \t       || GET_CODE (src) == SYMBOL_REF\n \t       || GET_CODE (src) == CONST)\n \t{\n-\t  return \"movhi hi(%1),%.,%0\\n\\tmovea lo(%1),%0,%0\";\n+\t  if (TARGET_V850E)\n+\t    return \"mov hilo(%1),%0\";\n+\t  else\n+\t    return \"movhi hi(%1),%.,%0\\n\\tmovea lo(%1),%0,%0\";\n \t}\n \n       else if (GET_CODE (src) == HIGH)\n@@ -881,11 +934,25 @@ ep_memory_offset (mode, unsignedp)\n   switch (mode)\n     {\n     case QImode:\n-      max_offset = (1 << 7);\n+      if (TARGET_SMALL_SLD)\n+\tmax_offset = (1 << 4);\n+      else if (TARGET_V850E \n+\t       && (   (  unsignedp && ! TARGET_US_BIT_SET)\n+\t\t   || (! unsignedp &&   TARGET_US_BIT_SET)))\n+\tmax_offset = (1 << 4);\n+      else\n+\tmax_offset = (1 << 7);\n       break;\n \n     case HImode:\n-      max_offset = (1 << 8);\n+      if (TARGET_SMALL_SLD)\n+\tmax_offset = (1 << 5);\n+      else if (TARGET_V850E\n+\t       && (   (  unsignedp && ! TARGET_US_BIT_SET)\n+\t\t   || (! unsignedp &&   TARGET_US_BIT_SET)))\n+\tmax_offset = (1 << 5);\n+      else\n+\tmax_offset = (1 << 8);\n       break;\n \n     case SImode:\n@@ -985,6 +1052,32 @@ reg_or_int5_operand (op, mode)\n     return register_operand (op, mode);\n }\n \n+/* Return true if OP is either a register or a signed nine bit integer.  */\n+\n+int\n+reg_or_int9_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return CONST_OK_FOR_O (INTVAL (op));\n+\n+  return register_operand (op, mode);\n+}\n+\n+/* Return true if OP is either a register or a const integer.  */\n+\n+int\n+reg_or_const_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return TRUE;\n+\n+  return register_operand (op, mode);\n+}\n+\n /* Return true if OP is a valid call operand.  */\n \n int\n@@ -1129,6 +1222,16 @@ Saved %d bytes (%d uses of register %s) in function %s, starting as insn %d, end\n \t      else if (GET_CODE (SET_SRC (pattern)) == MEM)\n \t\tp_mem = &SET_SRC (pattern);\n \n+\t      else if (GET_CODE (SET_SRC (pattern)) == SIGN_EXTEND\n+\t\t       && GET_CODE (XEXP (SET_SRC (pattern), 0)) == MEM)\n+\t\tp_mem = &XEXP (SET_SRC (pattern), 0);\n+\n+\t      else if (GET_CODE (SET_SRC (pattern)) == ZERO_EXTEND\n+\t\t       && GET_CODE (XEXP (SET_SRC (pattern), 0)) == MEM)\n+\t\t{\n+\t\t  p_mem = &XEXP (SET_SRC (pattern), 0);\n+\t\t  unsignedp = TRUE;\n+\t\t}\n \t      else\n \t\tp_mem = (rtx *)0;\n \n@@ -1278,6 +1381,16 @@ void v850_reorg (start_insn)\n \t      else if (GET_CODE (src) == MEM)\n \t\tmem = src;\n \n+\t      else if (GET_CODE (src) == SIGN_EXTEND\n+\t\t       && GET_CODE (XEXP (src, 0)) == MEM)\n+\t\tmem = XEXP (src, 0);\n+\n+\t      else if (GET_CODE (src) == ZERO_EXTEND\n+\t\t       && GET_CODE (XEXP (src, 0)) == MEM)\n+\t\t{\n+\t\t  mem = XEXP (src, 0);\n+\t\t  unsignedp = TRUE;\n+\t\t}\n \t      else\n \t\tmem = NULL_RTX;\n \n@@ -1531,8 +1644,11 @@ expand_prologue ()\n   /* Save/setup global registers for interrupt functions right now.  */\n   if (interrupt_handler)\n     {\n+      if (TARGET_V850E && ! TARGET_DISABLE_CALLT)\n+\temit_insn (gen_callt_save_interrupt ());\n+      else\n \temit_insn (gen_save_interrupt ());\n-      \n+\n       actual_fsize -= INTERRUPT_FIXED_SAVE_SIZE;\n       \n       if (((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n@@ -1544,7 +1660,10 @@ expand_prologue ()\n     {\n       if (TARGET_PROLOG_FUNCTION)\n \t{\n-\t  emit_insn (gen_save_r6_r9 ());\n+\t  if (TARGET_V850E && ! TARGET_DISABLE_CALLT)\n+\t    emit_insn (gen_save_r6_r9_v850e ());\n+\t  else\n+\t    emit_insn (gen_save_r6_r9 ());\n \t}\n       else\n \t{\n@@ -1656,7 +1775,10 @@ Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n       /* Special case interrupt functions that save all registers for a call.  */\n       if (interrupt_handler && ((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n \t{\n-\t  emit_insn (gen_save_all_interrupt ());\n+\t  if (TARGET_V850E && ! TARGET_DISABLE_CALLT)\n+\t    emit_insn (gen_callt_save_all_interrupt ());\n+\t  else\n+\t    emit_insn (gen_save_all_interrupt ());\n \t}\n       else\n \t{\n@@ -1888,7 +2010,10 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \t for a call.  */\n       if (interrupt_handler && ((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n \t{\n-\t  emit_insn (gen_restore_all_interrupt ());\n+\t  if (TARGET_V850E && ! TARGET_DISABLE_CALLT)\n+\t    emit_insn (gen_callt_restore_all_interrupt ());\n+\t  else\n+\t    emit_insn (gen_restore_all_interrupt ());\n \t}\n       else\n \t{\n@@ -1926,7 +2051,12 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \n       /* And return or use reti for interrupt handlers.  */\n       if (interrupt_handler)\n-\temit_jump_insn (gen_restore_interrupt ());\n+        {\n+          if (TARGET_V850E && ! TARGET_DISABLE_CALLT)\n+            emit_insn (gen_callt_return_interrupt ());\n+          else\n+            emit_jump_insn (gen_return_interrupt ());\n+\t }\n       else if (actual_fsize)\n \temit_jump_insn (gen_return_internal ());\n       else\n@@ -2233,10 +2363,9 @@ register_is_ok_for_epilogue (op, mode)\n      rtx op;\n      enum machine_mode ATTRIBUTE_UNUSED mode;\n {\n-  /* The save/restore routines can only cope with registers 2, and 20 - 31 */\n-  return (GET_CODE (op) == REG)\n-\t  && (((REGNO (op) >= 20) && REGNO (op) <= 31)\n-\t      || REGNO (op) == 2);\n+  /* The save/restore routines can only cope with registers 20 - 31.  */\n+  return ((GET_CODE (op) == REG)\n+          && (((REGNO (op) >= 20) && REGNO (op) <= 31)));\n }\n \n /* Return non-zero if the given RTX is suitable for collapsing into\n@@ -2817,6 +2946,392 @@ v850_insert_attributes (decl, attr_ptr)\n \t}\n     }\n }\n+\n+/* Return non-zero if the given RTX is suitable\n+   for collapsing into a DISPOSE instruction.  */\n+\n+int\n+pattern_is_ok_for_dispose (op, mode)\n+  rtx \t\t\top;\n+  enum machine_mode\tmode ATTRIBUTE_UNUSED;\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+  \n+  /* If there are no registers to restore then\n+     the dispose instruction is not suitable.  */\n+  if (count <= 2)\n+    return 0;\n+\n+  /* The pattern matching has already established that we are performing a\n+     function epilogue and that we are popping at least one register.  We must\n+     now check the remaining entries in the vector to make sure that they are\n+     also register pops.  There is no good reason why there should ever be\n+     anything else in this vector, but being paranoid always helps...\n+\n+     The test below performs the C equivalent of this machine description\n+     pattern match:\n+\n+        (set (match_operand:SI n \"register_is_ok_for_epilogue\" \"r\")\n+\t  (mem:SI (plus:SI (reg:SI 3)\n+\t    (match_operand:SI n \"immediate_operand\" \"i\"))))\n+     */\n+\n+  for (i = 3; i < count; i++)\n+    {\n+      rtx vector_element = XVECEXP (op, 0, i);\n+      rtx dest;\n+      rtx src;\n+      rtx plus;\n+      \n+      if (GET_CODE (vector_element) != SET)\n+\treturn 0;\n+      \n+      dest = SET_DEST (vector_element);\n+      src  = SET_SRC (vector_element);\n+\n+      if (   GET_CODE (dest) != REG\n+\t  || GET_MODE (dest) != SImode\n+\t  || ! register_is_ok_for_epilogue (dest, SImode)\n+\t  || GET_CODE (src) != MEM\n+\t  || GET_MODE (src) != SImode)\n+\treturn 0;\n+\n+      plus = XEXP (src, 0);\n+\n+      if (   GET_CODE (plus) != PLUS\n+\t  || GET_CODE (XEXP (plus, 0)) != REG\n+\t  || GET_MODE (XEXP (plus, 0)) != SImode\n+\t  || REGNO    (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n+\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Construct a DISPOSE instruction that is the equivalent of\n+   the given RTX.  We have already verified that this should\n+   be possible.  */\n+\n+char *\n+construct_dispose_instruction (op)\n+     rtx op;\n+{\n+  int                count = XVECLEN (op, 0);\n+  int                stack_bytes;\n+  unsigned long int  mask;\n+  int\t\t     i;\n+  static char        buff[ 100 ]; /* XXX */\n+  int                use_callt = 0;\n+  \n+  if (count <= 2)\n+    {\n+      error (\"Bogus DISPOSE construction: %d\\n\", count);\n+      return NULL;\n+    }\n+\n+  /* Work out how many bytes to pop off the\n+     stack before retrieving registers.  */\n+  if (GET_CODE (XVECEXP (op, 0, 1)) != SET)\n+    abort ();\n+  if (GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) != PLUS)\n+    abort ();\n+  if (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1)) != CONST_INT)\n+    abort ();\n+    \n+  stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1));\n+\n+  /* Each pop will remove 4 bytes from the stack... */\n+  stack_bytes -= (count - 2) * 4;\n+\n+  /* Make sure that the amount we are popping\n+     will fit into the DISPOSE instruction.  */\n+  if (stack_bytes > 128)\n+    {\n+      error (\"Too much stack space to dispose of: %d\", stack_bytes);\n+      return NULL;\n+    }\n+\n+  /* Now compute the bit mask of registers to push.  */\n+  mask = 0;\n+\n+  for (i = 2; i < count; i++)\n+    {\n+      rtx vector_element = XVECEXP (op, 0, i);\n+      \n+      if (GET_CODE (vector_element) != SET)\n+\tabort ();\n+      if (GET_CODE (SET_DEST (vector_element)) != REG)\n+\tabort ();\n+      if (! register_is_ok_for_epilogue (SET_DEST (vector_element), SImode))\n+\tabort ();\n+\n+      if (REGNO (SET_DEST (vector_element)) == 2)\n+\tuse_callt = 1;\n+      else\n+        mask |= 1 << REGNO (SET_DEST (vector_element));\n+    }\n+\n+  if (! TARGET_DISABLE_CALLT\n+      && (use_callt || stack_bytes == 0 || stack_bytes == 16))\n+    {\n+      if (use_callt)\n+\t{\n+\t  sprintf (buff, \"callt ctoff(__callt_return_r2_r%d)\", (mask & (1 << 31)) ? 31 : 29);\n+\t  return buff;\n+\t}\n+      else\n+\t{\n+\t  for (i = 20; i < 32; i++)\n+\t    if (mask & (1 << i))\n+\t      break;\n+\t  \n+\t  if (i == 31)\n+\t    sprintf (buff, \"callt ctoff(__callt_return_r31c)\");\n+\t  else\n+\t    sprintf (buff, \"callt ctoff(__callt_return_r%d_r%d%s)\",\n+\t\t     i, (mask & (1 << 31)) ? 31 : 29, stack_bytes ? \"c\" : \"\");\n+\t}\n+    }\n+  else\n+    {\n+      static char        regs [100]; /* XXX */\n+      int                done_one;\n+      \n+      /* Generate the DISPOSE instruction.  Note we could just issue the\n+\t bit mask as a number as the assembler can cope with this, but for\n+\t the sake of our readers we turn it into a textual description.  */\n+      regs[0] = 0;\n+      done_one = 0;\n+      \n+      for (i = 20; i < 32; i++)\n+\t{\n+\t  if (mask & (1 << i))\n+\t    {\n+\t      int first;\n+\t      \n+\t      if (done_one)\n+\t\tstrcat (regs, \", \");\n+\t      else\n+\t\tdone_one = 1;\n+\t      \n+\t      first = i;\n+\t      strcat (regs, reg_names[ first ]);\n+\t      \n+\t      for (i++; i < 32; i++)\n+\t\tif ((mask & (1 << i)) == 0)\n+\t\t  break;\n+\t      \n+\t      if (i > first + 1)\n+\t\t{\n+\t\t  strcat (regs, \" - \");\n+\t\t  strcat (regs, reg_names[ i - 1 ] );\n+\t\t}\n+\t    }\n+\t}\n+      \n+      sprintf (buff, \"dispose %d {%s}, r31\", stack_bytes / 4, regs);\n+    }\n+  \n+  return buff;\n+}\n+\n+/* Return non-zero if the given RTX is suitable\n+   for collapsing into a PREPARE instruction.  */\n+\n+int\n+pattern_is_ok_for_prepare (op, mode)\n+     rtx\t\top;\n+     enum machine_mode\tmode ATTRIBUTE_UNUSED;\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+  \n+  /* If there are no registers to restore then the prepare instruction\n+     is not suitable.  */\n+  if (count <= 1)\n+    return 0;\n+\n+  /* The pattern matching has already established that we are adjusting the\n+     stack and pushing at least one register.  We must now check that the\n+     remaining entries in the vector to make sure that they are also register\n+     pushes.\n+\n+     The test below performs the C equivalent of this machine description\n+     pattern match:\n+\n+     (set (mem:SI (plus:SI (reg:SI 3)\n+       (match_operand:SI 2 \"immediate_operand\" \"i\")))\n+         (match_operand:SI 3 \"register_is_ok_for_epilogue\" \"r\"))\n+\n+     */\n+\n+  for (i = 2; i < count; i++)\n+    {\n+      rtx vector_element = XVECEXP (op, 0, i);\n+      rtx dest;\n+      rtx src;\n+      rtx plus;\n+      \n+      if (GET_CODE (vector_element) != SET)\n+\treturn 0;\n+      \n+      dest = SET_DEST (vector_element);\n+      src  = SET_SRC (vector_element);\n+\n+      if (   GET_CODE (dest) != MEM\n+\t  || GET_MODE (dest) != SImode\n+\t  || GET_CODE (src) != REG\n+\t  || GET_MODE (src) != SImode\n+\t  || ! register_is_ok_for_epilogue (src, SImode)\n+\t     )\n+\treturn 0;\n+\n+      plus = XEXP (dest, 0);\n+\n+      if (   GET_CODE (plus) != PLUS\n+\t  || GET_CODE (XEXP (plus, 0)) != REG\n+\t  || GET_MODE (XEXP (plus, 0)) != SImode\n+\t  || REGNO    (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n+\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n+\treturn 0;\n+\n+      /* If the register is being pushed somewhere other than the stack\n+\t space just aquired by the first operand then abandon this quest.\n+\t Note: the test is <= becuase both values are negative.\t */\n+      if (INTVAL (XEXP (plus, 1))\n+\t  <= INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)))\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Construct a PREPARE instruction that is the equivalent of\n+   the given RTL.  We have already verified that this should\n+   be possible.  */\n+\n+char *\n+construct_prepare_instruction (op)\n+     rtx op;\n+{\n+  int                count = XVECLEN (op, 0);\n+  int                stack_bytes;\n+  unsigned long int  mask;\n+  int\t\t     i;\n+  static char        buff[ 100 ]; /* XXX */\n+  int\t\t     use_callt = 0;\n+  \n+  if (count <= 1)\n+    {\n+      error (\"Bogus PREPEARE construction: %d\\n\", count);\n+      return NULL;\n+    }\n+\n+  /* Work out how many bytes to push onto\n+     the stack after storing the registers.  */\n+  if (GET_CODE (XVECEXP (op, 0, 0)) != SET)\n+    abort ();\n+  if (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != PLUS)\n+    abort ();\n+  if (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)) != CONST_INT)\n+    abort ();\n+    \n+  stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1));\n+\n+  /* Each push will put 4 bytes from the stack.  */\n+  stack_bytes += (count - 1) * 4;\n+\n+  /* Make sure that the amount we are popping\n+     will fit into the DISPOSE instruction.  */\n+  if (stack_bytes < -128)\n+    {\n+      error (\"Too much stack space to prepare: %d\", stack_bytes);\n+      return NULL;\n+    }\n+\n+  /* Now compute the bit mask of registers to push.  */\n+  mask = 0;\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx vector_element = XVECEXP (op, 0, i);\n+      \n+      if (GET_CODE (vector_element) != SET)\n+\tabort ();\n+      if (GET_CODE (SET_SRC (vector_element)) != REG)\n+\tabort ();\n+      if (! register_is_ok_for_epilogue (SET_SRC (vector_element), SImode))\n+\tabort ();\n+\n+      if (REGNO (SET_SRC (vector_element)) == 2)\n+\tuse_callt = 1;\n+      else\n+\tmask |= 1 << REGNO (SET_SRC (vector_element));\n+    }\n+\n+  if ((! TARGET_DISABLE_CALLT)\n+      && (use_callt || stack_bytes == 0 || stack_bytes == -16))\n+    {\n+      if (use_callt)\n+\t{\n+\t  sprintf (buff, \"callt ctoff(__callt_save_r2_r%d)\", (mask & (1 << 31)) ? 31 : 29 );\n+\t  return buff;\n+\t}\n+      \n+      for (i = 20; i < 32; i++)\n+\tif (mask & (1 << i))\n+\t  break;\n+\n+      if (i == 31)\n+\tsprintf (buff, \"callt ctoff(__callt_save_r31c)\");\n+      else\n+\tsprintf (buff, \"callt ctoff(__callt_save_r%d_r%d%s)\",\n+\t\t i, (mask & (1 << 31)) ? 31 : 29, stack_bytes ? \"c\" : \"\");\n+    }\n+  else\n+    {\n+      static char        regs [100]; /* XXX */\n+      int                done_one;\n+\n+      \n+      /* Generate the PREPARE instruction.  Note we could just issue the\n+\t bit mask as a number as the assembler can cope with this, but for\n+\t the sake of our readers we turn it into a textual description.  */      \n+      regs[0] = 0;\n+      done_one = 0;\n+      \n+      for (i = 20; i < 32; i++)\n+\t{\n+\t  if (mask & (1 << i))\n+\t    {\n+\t      int first;\n+\t      \n+\t      if (done_one)\n+\t\tstrcat (regs, \", \");\n+\t      else\n+\t\tdone_one = 1;\n+\t      \n+\t      first = i;\n+\t      strcat (regs, reg_names[ first ]);\n+\t      \n+\t      for (i++; i < 32; i++)\n+\t\tif ((mask & (1 << i)) == 0)\n+\t\t  break;\n+\t      \n+\t      if (i > first + 1)\n+\t\t{\n+\t\t  strcat (regs, \" - \");\n+\t\t  strcat (regs, reg_names[ i - 1 ] );\n+\t\t}\n+\t    }\n+\t}\n+      \t \n+      sprintf (buff, \"prepare {%s}, %d\", regs, (- stack_bytes) / 4);\n+    }\n+  \n+  return buff;\n+}\n \f\n /* Implement `va_arg'.  */\n "}, {"sha": "4d89c982f93887b127b51befd087150791b00ca9", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 77, "deletions": 21, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=b43783196fe7e18c741444ccbb94ad6c7920814b", "patch": "@@ -31,8 +31,8 @@ Boston, MA 02111-1307, USA.  */\n #undef STARTFILE_SPEC\n #undef ASM_SPEC\n \n-\n #define TARGET_CPU_generic \t1\n+#define TARGET_CPU_v850e   \t2\n \n #ifndef TARGET_CPU_DEFAULT\n #define TARGET_CPU_DEFAULT\tTARGET_CPU_generic\n@@ -43,9 +43,22 @@ Boston, MA 02111-1307, USA.  */\n #define SUBTARGET_CPP_SPEC \t\"%{!mv*:-D__v850__}\"\n #define TARGET_VERSION \t\tfprintf (stderr, \" (NEC V850)\");\n \n+/* Choose which processor will be the default.\n+   We must pass a -mv850xx option to the assembler if no explicit -mv* option\n+   is given, because the assembler's processor default may not be correct.  */\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_v850e\n+#undef  MASK_DEFAULT\n+#define MASK_DEFAULT            MASK_V850E\n+#undef  SUBTARGET_ASM_SPEC\n+#define SUBTARGET_ASM_SPEC \t\"%{!mv*:-mv850e}\"\n+#undef  SUBTARGET_CPP_SPEC\n+#define SUBTARGET_CPP_SPEC \t\"%{!mv*:-D__v850e__}\"\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION \t\tfprintf (stderr, \" (NEC V850E)\");\n+#endif\n \n #define ASM_SPEC \"%{mv*:-mv%*}\"\n-#define CPP_SPEC\t\t\"%{mv850ea:-D__v850ea__} %{mv850e:-D__v850e__} %{mv850:-D__v850__} %(subtarget_cpp_spec)\"\n+#define CPP_SPEC\t\t\"%{mv850e:-D__v850e__} %{mv850:-D__v850__} %(subtarget_cpp_spec)\"\n \n #define EXTRA_SPECS \\\n  { \"subtarget_asm_spec\", SUBTARGET_ASM_SPEC }, \\\n@@ -67,8 +80,15 @@ extern int target_flags;\n \n #define MASK_CPU                0x00000030\n #define MASK_V850               0x00000010\n+#define MASK_V850E              0x00000020\n+#define MASK_SMALL_SLD          0x00000040\n \n #define MASK_BIG_SWITCH\t\t0x00000100\n+#define MASK_NO_APP_REGS        0x00000200\n+#define MASK_DISABLE_CALLT      0x00000400\n+\n+#define MASK_US_BIT_SET         0x00001000\n+#define MASK_US_MASK_SET        0x00002000\n \n /* Macros used in the machine description to test the flags.  */\n \n@@ -107,8 +127,23 @@ extern int target_flags;\n /* Whether to emit 2 byte per entry or 4 byte per entry switch tables.  */\n #define TARGET_BIG_SWITCH (target_flags & MASK_BIG_SWITCH)\n \n-/* General debug flag */\n-#define TARGET_DEBUG (target_flags & MASK_DEBUG)\n+/* General debug flag.  */\n+#define TARGET_DEBUG \t\t(target_flags & MASK_DEBUG)\n+#define TARGET_V850E   \t\t((target_flags & MASK_V850E) == MASK_V850E)\n+\n+#define TARGET_US_BIT_SET\t(target_flags & MASK_US_BIT_SET)\n+\n+/* Whether to assume that the SLD.B and SLD.H instructions only have small\n+   displacement fields, thus allowing the generated code to run on any of\n+   the V850 range of processors.  */\n+#define TARGET_SMALL_SLD \t(target_flags & MASK_SMALL_SLD)\n+\n+/* True if callt will not be used for function prolog & epilog.  */\n+#define TARGET_DISABLE_CALLT \t(target_flags & MASK_DISABLE_CALLT)\n+\n+/* False if r2 and r5 can be used by the compiler.  True if r2\n+   and r5 are to be fixed registers (for compatibility with GHS).  */\n+#define TARGET_NO_APP_REGS  \t(target_flags & MASK_NO_APP_REGS)\n \n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n@@ -134,6 +169,19 @@ extern int target_flags;\n    { \"v850\",\t\t \t MASK_V850,\t\t\t\t\\\n                                 N_(\"Compile for the v850 processor\") },\t\\\n    { \"v850\",\t\t \t -(MASK_V850 ^ MASK_CPU), \"\" },\t\t\\\n+   { \"v850e\",\t\t\t MASK_V850E, N_(\"Compile for v850e processor\") }, \\\n+   { \"v850e\",\t\t        -(MASK_V850E ^ MASK_CPU), \"\" }, /* Make sure that the other bits are cleared.  */ \\\n+   { \"small-sld\",\t\t MASK_SMALL_SLD, N_(\"Enable the use of the short load instructions\") },\t\\\n+   { \"no-small-sld\",\t\t-MASK_SMALL_SLD, \"\" },\t\t\t\\\n+   { \"disable-callt\",            MASK_DISABLE_CALLT, \t\t\t\\\n+       \t\t\t\tN_(\"Do not use the callt instruction\") },   \\\n+   { \"no-disable-callt\",        -MASK_DISABLE_CALLT, \"\" },             \t\\\n+   { \"US-bit-set\",\t\t (MASK_US_BIT_SET | MASK_US_MASK_SET), \"\" },\t\\\n+   { \"no-US-bit-set\",\t\t-MASK_US_BIT_SET, \"\" },\t\t\t\\\n+   { \"no-US-bit-set\",\t\t MASK_US_MASK_SET, \"\" },\t\t\\\n+   { \"app-regs\",                -MASK_NO_APP_REGS, \"\"  },               \\\n+   { \"no-app-regs\",              MASK_NO_APP_REGS, \t\t\t\\\n+       \t\t\t\tN_(\"Do not use registers r2 and r5\") }, \\\n    { \"big-switch\",\t\t MASK_BIG_SWITCH, \t\t\t\\\n        \t\t\t\tN_(\"Use 4 byte entries in switch tables\") },\\\n    { \"\",\t\t\t MASK_DEFAULT, \"\"}}\n@@ -327,6 +375,17 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n    0,  1,  3,  4,  5, 30, 32, 33\t/* fixed registers */\t\t\\\n }\n \n+/* If TARGET_NO_APP_REGS is not defined then add r2 and r5 to\n+   the pool of fixed registers. See PR 14505. */\n+#define CONDITIONAL_REGISTER_USAGE  \\\n+{                                                       \\\n+  if (TARGET_NO_APP_REGS)                               \\\n+    {                                                   \\\n+     fixed_regs[2] = 1;  call_used_regs[2] = 1;         \\\n+     fixed_regs[5] = 1;  call_used_regs[5] = 1;         \\\n+    }                                                   \\\n+}\n+\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n \n@@ -457,11 +516,11 @@ enum reg_class\n #define CONST_OK_FOR_M(VALUE) ((unsigned)(VALUE) < 0x10000)\n /* 5 bit unsigned immediate in shift instructions */\n #define CONST_OK_FOR_N(VALUE) ((unsigned) (VALUE) <= 31)\n+/* 9 bit signed immediate for word multiply instruction.  */\n+#define CONST_OK_FOR_O(VALUE) ((unsigned) (VALUE) + 0x100 < 0x200)\n \n-#define CONST_OK_FOR_O(VALUE) 0\n #define CONST_OK_FOR_P(VALUE) 0\n \n-\n #define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n   ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n    (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n@@ -851,7 +910,7 @@ extern int current_function_anonymous_args;\n  ((C) == 'Q'   ? ep_memory_operand (OP, GET_MODE (OP), 0)\t\t\t\\\n   : (C) == 'R' ? special_symbolref_operand (OP, VOIDmode)\t\t\\\n   : (C) == 'S' ? (GET_CODE (OP) == SYMBOL_REF && ! ZDA_NAME_P (XSTR (OP, 0))) \\\n-  : (C) == 'T' ? 0\t\t\t\t\t\t\t\\\n+  : (C) == 'T' ? ep_memory_operand(OP,GET_MODE(OP),TRUE)\t\t\t\\\n   : (C) == 'U' ? ((GET_CODE (OP) == SYMBOL_REF && ZDA_NAME_P (XSTR (OP, 0))) \\\n \t\t  || (GET_CODE (OP) == CONST\t\t\t\t\\\n \t\t      && GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n@@ -1136,17 +1195,9 @@ zbss_section ()\t\t\t\t\t\t\t\t\\\n #undef  USER_LABEL_PREFIX\n #define USER_LABEL_PREFIX \"_\"\n \n-/* When assemble_integer is used to emit the offsets for a switch\n-   table it can encounter (TRUNCATE:HI (MINUS:SI (LABEL_REF:SI) (LABEL_REF:SI))).\n-   output_addr_const will normally barf at this, but it is OK to omit\n-   the truncate and just emit the difference of the two labels.  The\n-   .hword directive will automatically handle the truncation for us.  */\n-\n-#define OUTPUT_ADDR_CONST_EXTRA(FILE, X, FAIL)\t\t\\\n-  if (GET_CODE (x) == TRUNCATE)\t\t\t\t\\\n-    output_addr_const (FILE, XEXP (X, 0));\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    goto FAIL;\n+#define OUTPUT_ADDR_CONST_EXTRA(FILE, X, FAIL)  \\\n+  if (! v850_output_addr_const_extra (FILE, X)) \\\n+     goto FAIL\n \n /* This says how to output the assembler to define a global\n    uninitialized but not common symbol.  */\n@@ -1243,10 +1294,12 @@ zbss_section ()\t\t\t\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-  fprintf (FILE, \"\\t%s .L%d-.L%d\\n\",\t\t\t\t\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n+  fprintf (FILE, \"\\t%s %s.L%d-.L%d%s\\n\",\t\t\t\t\\\n \t   (TARGET_BIG_SWITCH ? \".long\" : \".short\"),\t\t\t\\\n-\t   VALUE, REL)\n+\t   (! TARGET_BIG_SWITCH && TARGET_V850E ? \"(\" : \"\"),\t\t\\\n+\t   VALUE, REL,\t\t\t\t\t\t\t\\\n+\t   (! TARGET_BIG_SWITCH && TARGET_V850E ? \")>>1\" : \"\"))\n \n #define ASM_OUTPUT_ALIGN(FILE, LOG)\t\\\n   if ((LOG) != 0)\t\t\t\\\n@@ -1426,6 +1479,9 @@ extern union tree_node * GHS_current_section_names [(int) COUNT_OF_GHS_SECTION_K\n { \"pattern_is_ok_for_prologue\",\t{ PARALLEL }},\t\t\t\t\\\n { \"pattern_is_ok_for_epilogue\",\t{ PARALLEL }},\t\t\t\t\\\n { \"register_is_ok_for_epilogue\",{ REG }},\t\t\t\t\\\n+{ \"pattern_is_ok_for_dispose\",\t{ PARALLEL }},\t\t\t\t\\\n+{ \"pattern_is_ok_for_prepare\",\t{ PARALLEL }},\t\t\t\t\\\n+{ \"register_is_ok_for_dispose\",\t{ REG }},\t\t\t\t\\\n { \"not_power_of_two_operand\",\t{ CONST_INT }},\n   \n #endif /* ! GCC_V850_H */"}, {"sha": "75d8662fdc9cc1c8e85b4b83755401b5c52cd974", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 649, "deletions": 19, "changes": 668, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=b43783196fe7e18c741444ccbb94ad6c7920814b", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for NEC V850\n-;; Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+;; Copyright (C) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n ;; Contributed by Jeff Law (law@cygnus.com).\n \n ;; This file is part of GNU CC.\n@@ -153,6 +153,7 @@\n      must be done with HIGH & LO_SUM patterns.  */\n   if (CONSTANT_P (operands[1])\n       && GET_CODE (operands[1]) != HIGH\n+      && ! TARGET_V850E\n       && !special_symbolref_operand (operands[1], VOIDmode)\n       && !(GET_CODE (operands[1]) == CONST_INT\n \t   && (CONST_OK_FOR_J (INTVAL (operands[1]))\n@@ -174,6 +175,24 @@\n     }\n }\")\n \n+;; This is the same as the following pattern, except that it includes\n+;; support for arbitrary 32 bit immediates.\n+\n+;; ??? This always loads addresses using hilo.  If the only use of this address\n+;; was in a load/store, then we would get smaller code if we only loaded the\n+;; upper part with hi, and then put the lower part in the load/store insn.\n+\n+(define_insn \"*movsi_internal_v850e\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,r,Q,r,r,m,m,r\")\n+\t(match_operand:SI 1 \"general_operand\" \"Jr,K,L,Q,Ir,m,R,r,I,i\"))]\n+  \"TARGET_V850E\n+   && (register_operand (operands[0], SImode)\n+       || reg_or_0_operand (operands[1], SImode))\"\n+  \"* return output_move_single (operands);\"\n+  [(set_attr \"length\" \"2,4,4,2,2,4,4,4,4,6\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n+   (set_attr \"type\" \"other,other,other,load,other,load,other,other,other,other\")])\n+\n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,r,Q,r,r,m,m\")\n \t(match_operand:SI 1 \"movsi_source_operand\" \"Jr,K,L,Q,Ir,m,R,r,I\"))]\n@@ -377,6 +396,94 @@\n    (set_attr \"cc\" \"none_0hit,none_0hit\")\n    (set_attr \"type\" \"mult\")])\n \n+;; ??? The scheduling info is probably wrong.\n+\n+;; ??? This instruction can also generate the 32 bit highpart, but using it\n+;; may increase code size counter to the desired result.\n+\n+;; ??? This instructions can also give a DImode result.\n+\n+;; ??? There is unsigned version, but it matters only for the DImode/highpart\n+;; results.\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t ;; %redact changeone /reg_or_int9/ 'register' unless nec-no-copyright\n+\t\t (match_operand:SI 2 \"reg_or_int9_operand\" \"rO\")))]\n+  \"TARGET_V850E\"\n+  \"mul %2,%1,%.\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"mult\")])\n+\n+;; ----------------------------------------------------------------------\n+;; DIVIDE INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; ??? These insns do set the Z/N condition codes, except that they are based\n+;; on only one of the two results, so it doesn't seem to make sense to use\n+;; them.\n+\n+;; ??? The scheduling info is probably wrong.\n+\n+(define_insn \"divmodsi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=r\")\n+\t(mod:SI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"TARGET_V850E\"\n+  \"div %2,%0,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"other\")])\n+\t\n+(define_insn \"udivmodsi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=r\")\n+\t(umod:SI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"TARGET_V850E\"\n+  \"divu %2,%0,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"other\")])\n+\t\n+;; ??? There is a 2 byte instruction for generating only the quotient.\n+;; However, it isn't clear how to compute the length field correctly.\n+\n+(define_insn \"divmodhi4\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(div:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:HI 2 \"register_operand\" \"r\")))\n+   (set (match_operand:HI 3 \"register_operand\" \"=r\")\n+\t(mod:HI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"TARGET_V850E\"\n+  \"divh %2,%0,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"other\")])\n+\n+;; Half-words are sign-extended by default, so we must zero extend to a word\n+;; here before doing the divide.\n+\n+(define_insn \"udivmodhi4\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(udiv:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"r\")))\n+   (set (match_operand:HI 3 \"register_operand\" \"=r\")\n+\t(umod:HI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"TARGET_V850E\"\n+  \"zxh %0 ; divhu %2,%0,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"other\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; AND INSTRUCTIONS\n@@ -734,6 +841,245 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")])\n \n+;; ----------------------------------------------------------------------\n+;; CONDITIONAL MOVE INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; Instructions using cc0 aren't allowed to have input reloads, so we must\n+;; hide the fact that this instruction uses cc0.  We do so by including the\n+;; compare instruction inside it.\n+\n+;; ??? This is very ugly.  The right way to do this is to modify cmpsi so\n+;; that it doesn't emit RTL, and then modify the bcc/scc patterns so that\n+;; they emit RTL for the compare instruction.  Unfortunately, this requires\n+;; lots of changes that will be hard to sanitise.  So for now, cmpsi still\n+;; emits RTL, and I get the compare operands here from the previous insn.\n+\n+(define_expand \"movsicc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(if_then_else:SI\n+\t (match_operator 1 \"comparison_operator\"\n+\t\t\t [(match_dup 4) (match_dup 5)])\n+         ;; %redact changeone /const/ 'int5' unless nec-no-copyright\n+\t (match_operand:SI 2 \"reg_or_const_operand\" \"rJ\")\n+         ;; %redact changeone /const/ '0' unless nec-no-copyright\n+\t (match_operand:SI 3 \"reg_or_const_operand\" \"rI\")))]\n+  \"TARGET_V850E\"\n+  \"\n+{\n+  rtx insn = get_last_insn_anywhere ();\n+\n+  if (   (GET_CODE (operands[2]) == CONST_INT\n+       && GET_CODE (operands[3]) == CONST_INT))\n+    {\n+      int o2 = INTVAL (operands[2]);\n+      int o3 = INTVAL (operands[3]);\n+\n+      if (o2 == 1 && o3 == 0)\n+\tFAIL;   /* setf */\n+      if (o3 == 1 && o2 == 0)\n+\tFAIL;   /* setf */\n+      if (o2 == 0 && (o3 < -16 || o3 > 15) && exact_log2 (o3) >= 0)\n+\tFAIL;   /* setf + shift */\n+      if (o3 == 0 && (o2 < -16 || o2 > 15) && exact_log2 (o2) >=0)\n+\tFAIL;   /* setf + shift */\n+      if (o2 != 0)\n+\toperands[2] = copy_to_mode_reg (SImode, operands[2]);\n+      if (o3 !=0 )\n+\toperands[3] = copy_to_mode_reg (SImode, operands[3]);\n+    }\n+  else\n+    {\n+      if (GET_CODE (operands[2]) != REG)\n+\toperands[2] = copy_to_mode_reg (SImode,operands[2]);\n+      if (GET_CODE (operands[3]) != REG)\n+\toperands[3] = copy_to_mode_reg (SImode, operands[3]);\n+    }\n+  if (GET_CODE (insn) == INSN\n+      && GET_CODE (PATTERN (insn)) == SET\n+      && SET_DEST (PATTERN (insn)) == cc0_rtx)\n+    {\n+      rtx src = SET_SRC (PATTERN (insn));\n+\n+      if (GET_CODE (src) == COMPARE)\n+\t{\n+\t  operands[4] = XEXP (src, 0);\n+\t  operands[5] = XEXP (src, 1);\n+\t}\n+      else if (GET_CODE (src) == REG\n+               || GET_CODE (src) == SUBREG)\n+\t{\n+\t  operands[4] = src;\n+\t  operands[5] = const0_rtx;\n+\t}\n+      else\n+\tabort ();\n+    }\n+  else\n+    abort ();\n+}\")\n+\n+;; ??? Clobbering the condition codes is overkill.\n+\n+;; ??? We sometimes emit an unnecessary compare instruction because the\n+;; condition codes may have already been set by an earlier instruction,\n+;; but we have no code here to avoid the compare if it is unnecessary.\n+\n+(define_insn \"*movsicc_normal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(if_then_else:SI\n+\t (match_operator 1 \"comparison_operator\"\n+\t\t\t [(match_operand:SI 4 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 5 \"reg_or_int5_operand\" \"rJ\")])\n+\t (match_operand:SI 2 \"reg_or_int5_operand\" \"rJ\")\n+\t (match_operand:SI 3 \"reg_or_0_operand\" \"rI\")))]\n+  \"TARGET_V850E\"\n+  \"cmp %5,%4 ; cmov %c1,%2,%z3,%0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*movsicc_reversed\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(if_then_else:SI\n+\t (match_operator 1 \"comparison_operator\"\n+\t\t\t [(match_operand:SI 4 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 5 \"reg_or_int5_operand\" \"rJ\")])\n+\t (match_operand:SI 2 \"reg_or_0_operand\" \"rI\")\n+\t (match_operand:SI 3 \"reg_or_int5_operand\" \"rJ\")))]\n+  \"TARGET_V850E\"\n+  \"cmp %5,%4 ; cmov %C1,%3,%z2,%0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*movsicc_tst1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(if_then_else:SI\n+\t (match_operator 1 \"comparison_operator\"\n+\t\t\t [(zero_extract:SI\n+\t\t\t   (match_operand:QI 2 \"memory_operand\" \"m\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand 3 \"const_int_operand\" \"n\"))\n+\t\t\t  (const_int 0)])\n+\t (match_operand:SI 4 \"reg_or_int5_operand\" \"rJ\")\n+\t (match_operand:SI 5 \"reg_or_0_operand\" \"rI\")))]\n+  \"TARGET_V850E\"\n+  \"tst1 %3,%2 ; cmov %c1,%4,%z5,%0\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*movsicc_tst1_reversed\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(if_then_else:SI\n+\t (match_operator 1 \"comparison_operator\"\n+\t\t\t [(zero_extract:SI\n+\t\t\t   (match_operand:QI 2 \"memory_operand\" \"m\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand 3 \"const_int_operand\" \"n\"))\n+\t\t\t  (const_int 0)])\n+\t (match_operand:SI 4 \"reg_or_0_operand\" \"rI\")\n+\t (match_operand:SI 5 \"reg_or_int5_operand\" \"rJ\")))]\n+  \"TARGET_V850E\"\n+  \"tst1 %3,%2 ; cmov %C1,%5,%z4,%0\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; Matching for sasf requires combining 4 instructions, so we provide a\n+;; dummy pattern to match the first 3, which will always be turned into the\n+;; second pattern by subsequent combining.  As above, we must include the\n+;; comparison to avoid input reloads in an insn using cc0.\n+\n+(define_insn \"*sasf_1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ior:SI (match_operator 1 \"comparison_operator\" [(cc0) (const_int 0)])\n+\t\t(ashift:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t\t   (const_int 1))))]\n+  \"TARGET_V850E\"\n+  \"* abort ();\")\n+\n+(define_insn \"*sasf_2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI\n+\t (match_operator 1 \"comparison_operator\"\n+\t\t\t [(match_operand:SI 3 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 4 \"reg_or_int5_operand\" \"rJ\")])\n+\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t    (const_int 1))))]\n+  \"TARGET_V850E\"\n+  \"cmp %4,%3 ; sasf %c1,%0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(if_then_else:SI\n+\t (match_operator 1 \"comparison_operator\"\n+\t\t\t [(match_operand:SI 4 \"register_operand\" \"\")\n+\t\t\t  (match_operand:SI 5 \"reg_or_int5_operand\" \"\")])\n+\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t (match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"TARGET_V850E\n+   && ((INTVAL (operands[2]) ^ INTVAL (operands[3])) == 1)\n+   && ((INTVAL (operands[2]) + INTVAL (operands[3])) != 1)\n+   && (GET_CODE (operands[5]) == CONST_INT\n+      || REGNO (operands[0]) != REGNO (operands[5]))\n+   && REGNO (operands[0]) != REGNO (operands[4])\"\n+  [(set (match_dup 0) (match_dup 6))\n+   (set (match_dup 0)\n+\t(ior:SI (match_op_dup 7 [(match_dup 4) (match_dup 5)])\n+\t\t(ashift:SI (match_dup 0) (const_int 1))))]\n+  \"\n+{\n+  operands[6] = GEN_INT (INTVAL (operands[2]) >> 1);\n+  if (INTVAL (operands[2]) & 0x1)\n+    operands[7] = operands[1];\n+  else\n+    operands[7] = gen_rtx (reverse_condition (GET_CODE (operands[1])),\n+\t\t\t   GET_MODE (operands[1]), XEXP (operands[1], 0),\n+\t\t\t   XEXP (operands[1], 1));\n+}\")\n+;; ---------------------------------------------------------------------\n+;; BYTE SWAP INSTRUCTIONS\n+;; ---------------------------------------------------------------------\n+\n+(define_expand \"rotlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(rotate:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"TARGET_V850E\"\n+  \"\n+{\n+  if (INTVAL (operands[2]) != 8)\n+    FAIL;\n+}\")\n+\n+(define_insn \"*rotlhi3_8\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(rotate:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t   (const_int 8)))]\n+  \"TARGET_V850E\"\n+  \"bsh %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"\")))]\n+  \"TARGET_V850E\"\n+  \"\n+{\n+  if (INTVAL (operands[2]) != 16)\n+    FAIL;\n+}\")\n+\n+(define_insn \"*rotlsi3_16\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (const_int 16)))]\n+  \"TARGET_V850E\"\n+  \"hsw %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; JUMP INSTRUCTIONS\n@@ -921,6 +1267,20 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none\")])\n \n+(define_insn \"switch\"\n+  [(set (pc)\n+\t(plus:SI\n+\t (sign_extend:SI\n+\t  (mem:HI\n+\t   (plus:SI (ashift:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t       (const_int 1))\n+\t\t    (label_ref (match_operand 1 \"\" \"\")))))\n+\t (label_ref (match_dup 1))))]\n+  \"TARGET_V850E\"\n+  \"switch %0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n (define_expand \"casesi\"\n   [(match_operand:SI 0 \"register_operand\" \"\")\n    (match_operand:SI 1 \"register_operand\" \"\")\n@@ -940,6 +1300,12 @@\n   /* Branch to the default label if out of range of the table.  */\n   emit_jump_insn (gen_bgtu (operands[4]));\n \n+  if (! TARGET_BIG_SWITCH && TARGET_V850E)\n+    {\n+      emit_jump_insn (gen_switch (reg, operands[3]));\n+      DONE;\n+    }\n+\n   /* Shift index for the table array access.  */\n   emit_insn (gen_ashlsi3 (reg, reg, GEN_INT (TARGET_BIG_SWITCH ? 2 : 1)));\n   /* Load the table address into a pseudo.  */\n@@ -1084,6 +1450,18 @@\n ;; EXTEND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \"0,r,T,m\")))]\n+  \"TARGET_V850E\"\n+  \"@\n+   zxh %0\n+   andi 65535,%1,%0\n+   sld.hu %1,%0\n+   ld.hu %1,%0\"\n+  [(set_attr \"length\" \"2,4,2,4\")\n+   (set_attr \"cc\" \"none_0hit,set_znv,none_0hit,none_0hit\")])\n \n (define_insn \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1094,6 +1472,18 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set_znv\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"0,r,T,m\")))]\n+  \"TARGET_V850E\"\n+  \"@\n+   zxb %0\n+   andi 255,%1,%0\n+   sld.bu %1,%0\n+   ld.bu %1,%0\"\n+  [(set_attr \"length\" \"2,4,2,4\")\n+   (set_attr \"cc\" \"none_0hit,set_znv,none_0hit,none_0hit\")])\n \n (define_insn \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1106,6 +1496,18 @@\n \n ;;- sign extension instructions\n \n+;; ??? The extendhisi2 pattern should not emit shifts for v850e?\n+\n+(define_insn \"*extendhisi_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0,Q,m\")))]\n+  \"TARGET_V850E\"\n+  \"@\n+   sxh %0\n+   sld.h %1,%0\n+   ld.h %1,%0\"\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit\")])\n \n ;; ??? This is missing a sign extend from memory pattern to match the ld.h\n ;; instruction.\n@@ -1124,6 +1526,18 @@\n   operands[2] = gen_reg_rtx (SImode);\n }\")\n \n+;; ??? The extendqisi2 pattern should not emit shifts for v850e?\n+\n+(define_insn \"*extendqisi_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0,Q,m\")))]\n+  \"TARGET_V850E\"\n+  \"@\n+   sxb %0\n+   sld.b %1,%0\n+   ld.b %1,%0\"\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit\")])\n \n ;; ??? This is missing a sign extend from memory pattern to match the ld.b\n ;; instruction.\n@@ -1229,6 +1643,21 @@\n ;; RTXs.  These RTXs will then be turned into a suitable call to a worker\n ;; function.\n \n+;;\n+;; Actually, convert the RTXs into a PREPARE instruction.\n+;;\n+(define_insn \"\"\n+ [(match_parallel 0 \"pattern_is_ok_for_prepare\"\n+   [(set (reg:SI 3)\n+\t (plus:SI (reg:SI 3) (match_operand:SI 1 \"immediate_operand\" \"i\")))\n+    (set (mem:SI (plus:SI (reg:SI 3)\n+\t\t\t  (match_operand:SI 2 \"immediate_operand\" \"i\")))\n+\t (match_operand:SI 3 \"register_is_ok_for_epilogue\" \"r\"))])]\n+ \"TARGET_PROLOG_FUNCTION && TARGET_V850E\"\n+ \"* return construct_prepare_instruction (operands[0]);\n+ \"\n+ [(set_attr \"length\" \"4\")\n+  (set_attr \"cc\"     \"none\")])\n \n (define_insn \"\"\n  [(match_parallel 0 \"pattern_is_ok_for_prologue\"\n@@ -1245,6 +1674,23 @@\n \t\t\t\t     (const_string \"4\")))\n   (set_attr \"cc\"     \"clobber\")])\n \n+;;\n+;; Actually, turn the RTXs into a DISPOSE instruction.\n+;;\n+(define_insn \"\"\n+ [(match_parallel 0 \"pattern_is_ok_for_dispose\"\n+   [(return)\n+    (set (reg:SI 3)\n+\t (plus:SI (reg:SI 3) (match_operand:SI 1 \"immediate_operand\" \"i\")))\n+    (set (match_operand:SI 2 \"register_is_ok_for_epilogue\" \"=r\")\n+\t (mem:SI (plus:SI (reg:SI 3)\n+\t\t\t  (match_operand:SI 3 \"immediate_operand\" \"i\"))))])]\n+ \"TARGET_PROLOG_FUNCTION && TARGET_V850E\"\n+ \"* return construct_dispose_instruction (operands[0]);\n+ \"\n+ [(set_attr \"length\" \"4\")\n+  (set_attr \"cc\"     \"none\")])\n+\n ;; This pattern will match a return RTX followed by any number of pop RTXs\n ;; and possible a stack adjustment as well.  These RTXs will be turned into\n ;; a suitable call to a worker function.\n@@ -1266,60 +1712,244 @@\n   (set_attr \"cc\"     \"clobber\")])\n \n ;; Initialize an interrupt function.  Do not depend on TARGET_PROLOG_FUNCTION.\n+(define_insn \"callt_save_interrupt\"\n+  [(unspec_volatile [(const_int 0)] 2)]\n+    \"TARGET_V850E && !TARGET_DISABLE_CALLT\"\n+    ;; The CALLT instruction stores the next address of CALLT to CTPC register\n+    ;; without saving its previous value.  So if the interrupt handler\n+    ;; or its caller could possibily execute the CALLT insn, save_interrupt \n+    ;; MUST NOT be called via CALLT.\n+    \"*\n+{\n+  output_asm_insn (\\\"addi -24,   sp, sp\\\", operands);\n+  output_asm_insn (\\\"st.w r10,   12[sp]\\\", operands);\n+  output_asm_insn (\\\"stsr ctpc,  r10\\\",    operands);\n+  output_asm_insn (\\\"st.w r10,   16[sp]\\\", operands);\n+  output_asm_insn (\\\"stsr ctpsw, r10\\\",    operands);\n+  output_asm_insn (\\\"st.w r10,   20[sp]\\\", operands);\n+  output_asm_insn (\\\"callt ctoff(__callt_save_interrupt)\\\", operands);\n+  return \\\"\\\";\n+}\"\n+   [(set_attr \"length\" \"26\")\n+    (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"callt_return_interrupt\"\n+  [(unspec_volatile [(const_int 0)] 3)]\n+  \"TARGET_V850E && !TARGET_DISABLE_CALLT\"\n+  \"callt ctoff(__callt_return_interrupt)\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n (define_insn \"save_interrupt\"\n   [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -16)))\n-   (set (mem:SI (reg:SI 3)) (reg:SI 30))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 10))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 4))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 1))]\n-  \"TARGET_V850 && ! TARGET_LONG_CALLS\"\n-  \"add -16, sp ; st.w r10, 12[sp] ; jarl __save_interrupt, r10\"\n-  [(set_attr \"length\" \"12\")\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 30))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 4))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int  -8))) (reg:SI 1))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int  -4))) (reg:SI 10))]\n+  \"\"\n+  \"*\n+{\n+  if (TARGET_PROLOG_FUNCTION && !TARGET_LONG_CALLS)\n+    return \\\"add -16,sp\\;st.w r10,12[sp]\\;jarl __save_interrupt,r10\\\";\n+  else\n+    {\n+      output_asm_insn (\\\"add   -16, sp\\\", operands);\n+      output_asm_insn (\\\"st.w  r10, 12[sp]\\\", operands);\n+      output_asm_insn (\\\"st.w  ep, 0[sp]\\\", operands);\n+      output_asm_insn (\\\"st.w  gp, 4[sp]\\\", operands);\n+      output_asm_insn (\\\"st.w  r1, 8[sp]\\\", operands);\n+      output_asm_insn (\\\"movhi hi(__ep), r0, ep\\\", operands);\n+      output_asm_insn (\\\"movea lo(__ep), ep, ep\\\", operands);\n+      output_asm_insn (\\\"movhi hi(__gp), r0, gp\\\", operands);\n+      output_asm_insn (\\\"movea lo(__gp), gp, gp\\\", operands);\n+      return \\\"\\\";\n+    }\n+}\"\n+  [(set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\") (const_int 0))\n+                       (const_int 10)\n+                       (const_int 34)))\n    (set_attr \"cc\" \"clobber\")])\n-\n+  \n ;; Restore r1, r4, r10, and return from the interrupt\n-(define_insn \"restore_interrupt\"\n+(define_insn \"return_interrupt\"\n   [(return)\n-   (set (reg:SI 3) (plus:SI (reg:SI 3) (const_int 16)))\n-   (set (reg:SI 30) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n-   (set (reg:SI 10) (mem:SI (plus:SI (reg:SI 3) (const_int 8))))\n-   (set (reg:SI 4)  (mem:SI (plus:SI (reg:SI 3) (const_int 4))))\n-   (set (reg:SI 1)  (mem:SI (reg:SI 3)))]\n+   (set (reg:SI 3)  (plus:SI (reg:SI 3) (const_int 16)))\n+   (set (reg:SI 10) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n+   (set (reg:SI 1)  (mem:SI (plus:SI (reg:SI 3) (const_int  8))))\n+   (set (reg:SI 4)  (mem:SI (plus:SI (reg:SI 3) (const_int  4))))\n+   (set (reg:SI 30) (mem:SI (reg:SI 3)))]\n   \"\"\n-  \"jr __return_interrupt\"\n-  [(set_attr \"length\" \"4\")\n+  \"*\n+{\n+  if (TARGET_PROLOG_FUNCTION && !TARGET_LONG_CALLS)\n+    return \\\"jr __return_interrupt\\\";\n+  else \n+    {\n+      output_asm_insn (\\\"ld.w 0[sp],  ep\\\",   operands);\n+      output_asm_insn (\\\"ld.w 4[sp],  gp\\\",   operands);\n+      output_asm_insn (\\\"ld.w 8[sp],  r1\\\",   operands);\n+      output_asm_insn (\\\"ld.w 12[sp], r10\\\", operands);\n+      output_asm_insn (\\\"addi 16, sp, sp\\\",   operands);\n+      output_asm_insn (\\\"reti\\\",            operands);\n+      return \\\"\\\";\n+    }\n+}\"\n+  [(set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\") (const_int 0))\n+                       (const_int 4)\n+                       (const_int 24)))\n    (set_attr \"cc\" \"clobber\")])\n \n-\n ;; Save all registers except for the registers saved in save_interrupt when\n ;; an interrupt function makes a call.\n ;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n ;; all of memory.  This blocks insns from being moved across this point.\n ;; This is needed because the rest of the compiler is not ready to handle\n ;; insns this complicated.\n \n+(define_insn \"callt_save_all_interrupt\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"TARGET_V850E && !TARGET_DISABLE_CALLT\"\n+  \"callt ctoff(__callt_save_all_interrupt)\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n (define_insn \"save_all_interrupt\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"*\n+{\n+  if (TARGET_PROLOG_FUNCTION && !TARGET_LONG_CALLS)\n+    return \\\"jarl __save_all_interrupt,r10\\\";\n+\n+  output_asm_insn (\\\"addi -120, sp, sp\\\", operands);\n+  output_asm_insn (\\\"mov ep, r1\\\", operands);\n+  output_asm_insn (\\\"mov sp, ep\\\", operands);\n+  output_asm_insn (\\\"sst.w r31, 116[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r2,  112[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w gp,  108[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r6,  104[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r7,  100[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r8,   96[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r9,   92[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r11,  88[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r12,  84[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r13,  80[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r14,  76[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r15,  72[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r16,  68[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r17,  64[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r18,  60[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r19,  56[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r20,  52[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r21,  48[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r22,  44[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r23,  40[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r24,  36[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r25,  32[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r26,  28[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r27,  24[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r28,  20[ep]\\\", operands);\n+  output_asm_insn (\\\"sst.w r29,  16[ep]\\\", operands);\n+  output_asm_insn (\\\"mov   r1,   ep\\\", operands);\n+  return \\\"\\\";\n+}\"\n+  [(set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\") (const_int 0))\n+                       (const_int 4)\n+                       (const_int 62)\n+\t))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"_save_all_interrupt\"\n   [(unspec_volatile [(const_int 0)] 0)]\n   \"TARGET_V850 && ! TARGET_LONG_CALLS\"\n   \"jarl __save_all_interrupt,r10\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n \n-\n ;; Restore all registers saved when an interrupt function makes a call.\n ;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n ;; all of memory.  This blocks insns from being moved across this point.\n ;; This is needed because the rest of the compiler is not ready to handle\n ;; insns this complicated.\n \n+(define_insn \"callt_restore_all_interrupt\"\n+  [(unspec_volatile [(const_int 0)] 1)]\n+  \"TARGET_V850E && !TARGET_DISABLE_CALLT\"\n+  \"callt ctoff(__callt_restore_all_interrupt)\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n (define_insn \"restore_all_interrupt\"\n+  [(unspec_volatile [(const_int 0)] 1)]\n+  \"\"\n+  \"*\n+{\n+  if (TARGET_PROLOG_FUNCTION && !TARGET_LONG_CALLS)\n+    return \\\"jarl __restore_all_interrupt,r10\\\";\n+  else\n+    {\n+      output_asm_insn (\\\"mov   ep,      r1\\\", operands);\n+      output_asm_insn (\\\"mov   sp,      ep\\\", operands);\n+      output_asm_insn (\\\"sld.w 116[ep], r31\\\", operands);\n+      output_asm_insn (\\\"sld.w 112[ep], r2\\\", operands);\n+      output_asm_insn (\\\"sld.w 108[ep], gp\\\", operands);\n+      output_asm_insn (\\\"sld.w 104[ep], r6\\\", operands);\n+      output_asm_insn (\\\"sld.w 100[ep], r7\\\", operands);\n+      output_asm_insn (\\\"sld.w 96[ep],  r8\\\", operands);\n+      output_asm_insn (\\\"sld.w 92[ep],  r9\\\", operands);\n+      output_asm_insn (\\\"sld.w 88[ep],  r11\\\", operands);\n+      output_asm_insn (\\\"sld.w 84[ep],  r12\\\", operands);\n+      output_asm_insn (\\\"sld.w 80[ep],  r13\\\", operands);\n+      output_asm_insn (\\\"sld.w 76[ep],  r14\\\", operands);\n+      output_asm_insn (\\\"sld.w 72[ep],  r15\\\", operands);\n+      output_asm_insn (\\\"sld.w 68[ep],  r16\\\", operands);\n+      output_asm_insn (\\\"sld.w 64[ep],  r17\\\", operands);\n+      output_asm_insn (\\\"sld.w 60[ep],  r18\\\", operands);\n+      output_asm_insn (\\\"sld.w 56[ep],  r19\\\", operands);\n+      output_asm_insn (\\\"sld.w 52[ep],  r20\\\", operands);\n+      output_asm_insn (\\\"sld.w 48[ep],  r21\\\", operands);\n+      output_asm_insn (\\\"sld.w 44[ep],  r22\\\", operands);\n+      output_asm_insn (\\\"sld.w 40[ep],  r23\\\", operands);\n+      output_asm_insn (\\\"sld.w 36[ep],  r24\\\", operands);\n+      output_asm_insn (\\\"sld.w 32[ep],  r25\\\", operands);\n+      output_asm_insn (\\\"sld.w 28[ep],  r26\\\", operands);\n+      output_asm_insn (\\\"sld.w 24[ep],  r27\\\", operands);\n+      output_asm_insn (\\\"sld.w 20[ep],  r28\\\", operands);\n+      output_asm_insn (\\\"sld.w 16[ep],  r29\\\", operands);\n+      output_asm_insn (\\\"mov   r1,      ep\\\", operands);\n+      output_asm_insn (\\\"addi  120, sp, sp\\\", operands);\n+      return \\\"\\\";\n+    }\n+}\"\n+  [(set (attr \"length\")\n+        (if_then_else (ne (symbol_ref \"TARGET_LONG_CALLS\") (const_int 0))\n+                       (const_int 4)\n+                       (const_int 62)\n+\t))\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"_restore_all_interrupt\"\n   [(unspec_volatile [(const_int 0)] 1)]\n   \"TARGET_V850 && ! TARGET_LONG_CALLS\"\n   \"jarl __restore_all_interrupt,r10\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n \n ;; Save r6-r9 for a variable argument function\n+(define_insn \"save_r6_r9_v850e\"\n+  [(set (mem:SI (reg:SI 3)) (reg:SI 6))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int 4))) (reg:SI 7))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int 8))) (reg:SI 8))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int 12))) (reg:SI 9))\n+  ]\n+  \"TARGET_PROLOG_FUNCTION && TARGET_V850E && !TARGET_DISABLE_CALLT\"\n+  \"callt ctoff(__callt_save_r6_r9)\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n (define_insn \"save_r6_r9\"\n   [(set (mem:SI (reg:SI 3)) (reg:SI 6))\n    (set (mem:SI (plus:SI (reg:SI 3) (const_int 4))) (reg:SI 7))"}, {"sha": "1ce61bd451d98a03f3c5ebef8a0541c9aaa98100", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b43783196fe7e18c741444ccbb94ad6c7920814b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b43783196fe7e18c741444ccbb94ad6c7920814b", "patch": "@@ -577,6 +577,9 @@ in the following sections.\n -mlong-calls  -mno-long-calls  -mep  -mno-ep @gol\n -mprolog-function  -mno-prolog-function  -mspace @gol\n -mtda=@var{n}  -msda=@var{n}  -mzda=@var{n} @gol\n+-mapp-regs -mno-app-regs @gol\n+-mdisable-callt -mno-disable-callt @gol\n+-mv850e @gol\n -mv850  -mbig-switch}\n \n @emph{NS32K Options}\n@@ -8682,6 +8685,34 @@ Specify that the target processor is the V850.\n Generate code suitable for big switch tables.  Use this option only if\n the assembler/linker complain about out of range branches within a switch\n table.\n+\n+@item -mapp-regs\n+@opindex -mapp-regs\n+This option will cause r2 and r5 to be used in the code generated by\n+the compiler.  This setting is the default.\n+\n+@item -mno-app-regs\n+@opindex -mno-app-regs\n+This option will cause r2 and r5 to be treated as fixed registers.\n+  \n+@item -mv850e\n+@opindex -mv850e\n+Specify that the target processor is the V850E.  The preprocessor\n+constant @samp{__v850e__} will be defined if this option is used.\n+\n+If neither @option{-mv850} nor @option{-mv850e} are defined\n+then a default target processor will be chosen and the relevant\n+@samp{__v850*__} preprocessor constant will be defined.\n+\n+The preprocessor constants @samp{__v850} and @samp{__v851__} are always\n+defined, regardless of which processor variant is the target.\n+\n+@item -mdisable-callt\n+@opindex -mdisable-callt\n+This option will suppress generation of the CALLT instruction for the\n+v850e flavors of the v850 architecture.  The default is\n+@option{-mno-disable-callt} which allows the CALLT instruction to be used.\n+\n @end table\n \n @node ARC Options"}]}