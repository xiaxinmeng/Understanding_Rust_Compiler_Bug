{"sha": "45e8e706e295e7770d02c6d9c9798f4bab7ab524", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVlOGU3MDZlMjk1ZTc3NzBkMDJjNmQ5Yzk3OThmNGJhYjdhYjUyNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:11:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:11:09Z"}, "message": "[22/77] Replace !VECTOR_MODE_P with is_a <scalar_int_mode>\n\nThis patch replaces some checks of !VECTOR_MODE_P with checks\nof is_a <scalar_int_mode>, in cases where the scalar integer\nmodes were the only useful alternatives left.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* simplify-rtx.c (simplify_binary_operation_1): Use\n\tis_a <scalar_int_mode> instead of !VECTOR_MODE_P.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251474", "tree": {"sha": "8256b3298d2ebf7cfbd2d266df5c50ba59a69e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8256b3298d2ebf7cfbd2d266df5c50ba59a69e24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45e8e706e295e7770d02c6d9c9798f4bab7ab524", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e8e706e295e7770d02c6d9c9798f4bab7ab524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45e8e706e295e7770d02c6d9c9798f4bab7ab524", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e8e706e295e7770d02c6d9c9798f4bab7ab524/comments", "author": null, "committer": null, "parents": [{"sha": "b0567726a311d3f2fcec5b62380675231cd610c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0567726a311d3f2fcec5b62380675231cd610c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0567726a311d3f2fcec5b62380675231cd610c9"}], "stats": {"total": 26, "additions": 15, "deletions": 11}, "files": [{"sha": "f12544024d70fb57caed581177ea841335822f20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45e8e706e295e7770d02c6d9c9798f4bab7ab524/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45e8e706e295e7770d02c6d9c9798f4bab7ab524/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45e8e706e295e7770d02c6d9c9798f4bab7ab524", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* simplify-rtx.c (simplify_binary_operation_1): Use\n+\tis_a <scalar_int_mode> instead of !VECTOR_MODE_P.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "bf8abdb6578e92b833f5442642d338f6debd85e3", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45e8e706e295e7770d02c6d9c9798f4bab7ab524/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45e8e706e295e7770d02c6d9c9798f4bab7ab524/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=45e8e706e295e7770d02c6d9c9798f4bab7ab524", "patch": "@@ -2138,7 +2138,7 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n   rtx tem, reversed, opleft, opright;\n   HOST_WIDE_INT val;\n   unsigned int width = GET_MODE_PRECISION (mode);\n-  scalar_int_mode int_mode;\n+  scalar_int_mode int_mode, inner_mode;\n \n   /* Even if we can't compute a constant result,\n      there are some cases worth simplifying.  */\n@@ -3374,27 +3374,24 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t (subreg:M1 ([a|l]shiftrt:M2 (reg:M2) (const_int <c1 + c2>))\n \t\t    <low_part>).  */\n       if ((code == ASHIFTRT || code == LSHIFTRT)\n-\t  && !VECTOR_MODE_P (mode)\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n \t  && SUBREG_P (op0)\n \t  && CONST_INT_P (op1)\n \t  && GET_CODE (SUBREG_REG (op0)) == LSHIFTRT\n-\t  && !VECTOR_MODE_P (GET_MODE (SUBREG_REG (op0)))\n+\t  && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (op0)),\n+\t\t\t\t     &inner_mode)\n \t  && CONST_INT_P (XEXP (SUBREG_REG (op0), 1))\n-\t  && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n-\t      > GET_MODE_BITSIZE (mode))\n+\t  && GET_MODE_BITSIZE (inner_mode) > GET_MODE_BITSIZE (int_mode)\n \t  && (INTVAL (XEXP (SUBREG_REG (op0), 1))\n-\t      == (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n-\t\t  - GET_MODE_BITSIZE (mode)))\n+\t      == GET_MODE_BITSIZE (inner_mode) - GET_MODE_BITSIZE (int_mode))\n \t  && subreg_lowpart_p (op0))\n \t{\n \t  rtx tmp = GEN_INT (INTVAL (XEXP (SUBREG_REG (op0), 1))\n \t\t\t     + INTVAL (op1));\n-\t  machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n-\t  tmp = simplify_gen_binary (code,\n-\t\t\t\t     GET_MODE (SUBREG_REG (op0)),\n+\t  tmp = simplify_gen_binary (code, inner_mode,\n \t\t\t\t     XEXP (SUBREG_REG (op0), 0),\n \t\t\t\t     tmp);\n-\t  return lowpart_subreg (mode, tmp, inner_mode);\n+\t  return lowpart_subreg (int_mode, tmp, inner_mode);\n \t}\n \n       if (SHIFT_COUNT_TRUNCATED && CONST_INT_P (op1))"}]}