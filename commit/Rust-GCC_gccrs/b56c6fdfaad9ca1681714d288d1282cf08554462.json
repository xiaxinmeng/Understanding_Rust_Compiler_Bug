{"sha": "b56c6fdfaad9ca1681714d288d1282cf08554462", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU2YzZmZGZhYWQ5Y2ExNjgxNzE0ZDI4OGQxMjgyY2YwODU1NDQ2Mg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-02T09:13:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-02T09:13:20Z"}, "message": "Merge #601\n\n601: union support for hir type checking and gcc backend r=dkm a=dkm\n\nFrom Mark Wielaard : https://gcc.gnu.org/pipermail/gcc-rust/2021-August/000107.html\r\n\r\n> \r\n> Treat a union as a Struct variant like a tuple struct.  Add an\r\n> iterator and get_identifier functions to the AST Union class.  Same\r\n> for the HIR Union class, plus a get_generics_params method. Add a new\r\n> ADTKind enum and adt_kind field to the ADTType to select the\r\n> underlying abstract data type (struct struct, tuple struct or union,\r\n> with enum as possible future variant).\r\n> \r\n> An union constructor can have only one field. Add an union_index field\r\n> to StructExprStruct which is set during type checking in the\r\n> TypeCheckStructExpr HIR StructExprStructFields visitor.\r\n> \r\n> For the Gcc_backend class rename fill_in_struct to fill_in_fields and\r\n> use it from a new union_type method. Handle union_index in\r\n> constructor_expression (so only one field is initialized).\r\n\r\nFixes #157 \n\nCo-authored-by: Mark Wielaard <mark@klomp.org>", "tree": {"sha": "d815a7d24660b24da5fcf7d05b5f2b3e8de99ae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d815a7d24660b24da5fcf7d05b5f2b3e8de99ae1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b56c6fdfaad9ca1681714d288d1282cf08554462", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhB7cwCRBK7hj4Ov3rIwAApbYIAEQmOWwy+lQuB1Nr51poCowF\nlens05thQ9V9XeMcFj+GmTP7VHf7K4nOWFRDi6xC1zeTasIALcT8zqL1biIDmYnd\nVR1zRfy3XLE5XjFcKIUW1VmX44NxJK8zrrtC6E0h2XFIwoyLYn2NoCc9bWwBNTVn\nmK4+MAxmWCw2yn+LICkz2JmJV5kiw44OGe6tvliECkGem0zOje7uJz83oBck7guP\n4Bqf9CaMnbS3t1OFPu882a1AlQWnzEyMbO4tjNWNC/gC3a2TuwNmtH7qQcjQX9iQ\nvAr5ecVJfNIhRANvgkRLp3/hUnhPsV0mP+KM6NNa7qeGxXZZ8pdLRm4BIh8d6Eo=\n=Cmsw\n-----END PGP SIGNATURE-----\n", "payload": "tree d815a7d24660b24da5fcf7d05b5f2b3e8de99ae1\nparent 06a65591eb09fbec25e4ee38c1cf751b416af5bf\nparent 389fd74a3f3e9422a965263b6961b51295c55976\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1627895600 +0000\ncommitter GitHub <noreply@github.com> 1627895600 +0000\n\nMerge #601\n\n601: union support for hir type checking and gcc backend r=dkm a=dkm\n\nFrom Mark Wielaard : https://gcc.gnu.org/pipermail/gcc-rust/2021-August/000107.html\r\n\r\n> \r\n> Treat a union as a Struct variant like a tuple struct.  Add an\r\n> iterator and get_identifier functions to the AST Union class.  Same\r\n> for the HIR Union class, plus a get_generics_params method. Add a new\r\n> ADTKind enum and adt_kind field to the ADTType to select the\r\n> underlying abstract data type (struct struct, tuple struct or union,\r\n> with enum as possible future variant).\r\n> \r\n> An union constructor can have only one field. Add an union_index field\r\n> to StructExprStruct which is set during type checking in the\r\n> TypeCheckStructExpr HIR StructExprStructFields visitor.\r\n> \r\n> For the Gcc_backend class rename fill_in_struct to fill_in_fields and\r\n> use it from a new union_type method. Handle union_index in\r\n> constructor_expression (so only one field is initialized).\r\n\r\nFixes #157 \n\nCo-authored-by: Mark Wielaard <mark@klomp.org>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b56c6fdfaad9ca1681714d288d1282cf08554462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b56c6fdfaad9ca1681714d288d1282cf08554462", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b56c6fdfaad9ca1681714d288d1282cf08554462/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06a65591eb09fbec25e4ee38c1cf751b416af5bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a65591eb09fbec25e4ee38c1cf751b416af5bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06a65591eb09fbec25e4ee38c1cf751b416af5bf"}, {"sha": "389fd74a3f3e9422a965263b6961b51295c55976", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/389fd74a3f3e9422a965263b6961b51295c55976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/389fd74a3f3e9422a965263b6961b51295c55976"}], "stats": {"total": 584, "additions": 529, "deletions": 55}, "files": [{"sha": "5605b0bb79c15c1c4ecbdd704489fd750e1a69b2", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -2489,6 +2489,15 @@ class Union : public VisItem\n   std::vector<StructField> &get_variants () { return variants; }\n   const std::vector<StructField> &get_variants () const { return variants; }\n \n+  void iterate (std::function<bool (StructField &)> cb)\n+  {\n+    for (auto &variant : variants)\n+      {\n+\tif (!cb (variant))\n+\t  return;\n+      }\n+  }\n+\n   std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n   {\n     return generic_params;\n@@ -2505,6 +2514,8 @@ class Union : public VisItem\n     return where_clause;\n   }\n \n+  Identifier get_identifier () const { return union_name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "8007c2fa00d237520395d60ff3387157bbec0dc2", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -417,9 +417,13 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \tfields.push_back (std::move (f));\n       }\n \n-    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n+    Btype *type_record;\n+    if (type.is_union ())\n+      type_record = ctx->get_backend ()->union_type (fields);\n+    else\n+      type_record = ctx->get_backend ()->struct_type (fields);\n     Btype *named_struct\n-      = ctx->get_backend ()->named_type (type.get_name (), struct_type_record,\n+      = ctx->get_backend ()->named_type (type.get_name (), type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n \t\t\t\t\t   type.get_ty_ref ()));\n "}, {"sha": "46582954895f016c14fe5cbaf9ecd049c42d6224", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -80,7 +80,7 @@ class CompileExpr : public HIRCompileBase\n       }\n \n     translated\n-      = ctx->get_backend ()->constructor_expression (tuple_type, vals,\n+      = ctx->get_backend ()->constructor_expression (tuple_type, vals, -1,\n \t\t\t\t\t\t     expr.get_locus ());\n   }\n \n@@ -595,6 +595,7 @@ class CompileExpr : public HIRCompileBase\n \n     translated\n       = ctx->get_backend ()->constructor_expression (type, vals,\n+\t\t\t\t\t\t     struct_expr.union_index,\n \t\t\t\t\t\t     struct_expr.get_locus ());\n   }\n "}, {"sha": "aa9aa2d90ab9143da655daeb5fca125b22682637", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -79,7 +79,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n       });\n \n       translated\n-\t= ctx->get_backend ()->constructor_expression (type, vals,\n+\t= ctx->get_backend ()->constructor_expression (type, vals, -1,\n \t\t\t\t\t\t       expr.get_locus ());\n     }\n   else"}, {"sha": "f168c7d3e888e32431fe23c71450c8d056a8b91a", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -193,6 +193,57 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t       struct_decl.get_locus ());\n   }\n \n+  void visit (AST::Union &union_decl) override\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (union_decl.has_generics ())\n+      {\n+\tgeneric_params\n+\t  = lower_generic_params (union_decl.get_generic_params ());\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    std::vector<HIR::StructField> variants;\n+    union_decl.iterate ([&] (AST::StructField &variant) mutable -> bool {\n+      HIR::Visibility vis = HIR::Visibility::create_public ();\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (variant.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, variant.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      HIR::StructField translated_variant (mapping, variant.get_field_name (),\n+\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t   vis, variant.get_locus (),\n+\t\t\t\t\t   variant.get_outer_attrs ());\n+      variants.push_back (std::move (translated_variant));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, union_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::Union (mapping, union_decl.get_identifier (), vis,\n+\t\t\tstd::move (generic_params), std::move (where_clause),\n+\t\t\tstd::move (variants), union_decl.get_outer_attrs (),\n+\t\t\tunion_decl.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       union_decl.get_locus ());\n+  }\n+\n   void visit (AST::StaticItem &var) override\n   {\n     HIR::Visibility vis = HIR::Visibility::create_public ();"}, {"sha": "2e97ca63a133dddddc01989897671e7c31ceb4be", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -215,6 +215,59 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t       struct_decl.get_locus ());\n   }\n \n+  void visit (AST::Union &union_decl) override\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (union_decl.has_generics ())\n+      {\n+\tgeneric_params\n+\t  = lower_generic_params (union_decl.get_generic_params ());\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    std::vector<HIR::StructField> variants;\n+    union_decl.iterate ([&] (AST::StructField &variant) mutable -> bool {\n+      HIR::Visibility vis = HIR::Visibility::create_public ();\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (variant.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, variant.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      // FIXME\n+      // AST::StructField is missing Location info\n+      Location variant_locus;\n+      HIR::StructField translated_variant (mapping, variant.get_field_name (),\n+\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t   vis, variant_locus,\n+\t\t\t\t\t   variant.get_outer_attrs ());\n+      variants.push_back (std::move (translated_variant));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, union_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::Union (mapping, union_decl.get_identifier (), vis,\n+\t\t\tstd::move (generic_params), std::move (where_clause),\n+\t\t\tstd::move (variants), union_decl.get_outer_attrs (),\n+\t\t\tunion_decl.get_locus ());\n+\n+    mappings->insert_hir_stmt (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       union_decl.get_locus ());\n+  }\n+\n   void visit (AST::EmptyStmt &empty) override\n   {\n     auto crate_num = mappings->get_current_crate ();"}, {"sha": "8d815c5adc6f23dac94cecd44414e550bc358a2a", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -1449,6 +1449,10 @@ class StructExprStructFields : public StructExprStruct\n   // FIXME make unique_ptr\n   StructBase *struct_base;\n \n+  // For unions there is just one field, the index\n+  // is set when type checking\n+  int union_index = -1;\n+\n   std::string as_string () const override;\n \n   bool has_struct_base () const { return struct_base != nullptr; }\n@@ -1467,7 +1471,8 @@ class StructExprStructFields : public StructExprStruct\n \n   // copy constructor with vector clone\n   StructExprStructFields (StructExprStructFields const &other)\n-    : StructExprStruct (other), struct_base (other.struct_base)\n+    : StructExprStruct (other), struct_base (other.struct_base),\n+      union_index (other.union_index)\n   {\n     fields.reserve (other.fields.size ());\n     for (const auto &e : other.fields)\n@@ -1479,6 +1484,7 @@ class StructExprStructFields : public StructExprStruct\n   {\n     StructExprStruct::operator= (other);\n     struct_base = other.struct_base;\n+    union_index = other.union_index;\n \n     fields.reserve (other.fields.size ());\n     for (const auto &e : other.fields)"}, {"sha": "182fe87a6b945c3e847fe13225e6b286fff06f7e", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -1989,10 +1989,26 @@ class Union : public VisItem\n   Union (Union &&other) = default;\n   Union &operator= (Union &&other) = default;\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+\n+  Identifier get_identifier () const { return union_name; }\n+\n   Location get_locus () const { return locus; }\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  void iterate (std::function<bool (StructField &)> cb)\n+  {\n+    for (auto &variant : variants)\n+      {\n+\tif (!cb (variant))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "c67121d72f9e0f48afbc41dfb6dcc72eb9495154", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -260,6 +260,28 @@ class ResolveItem : public ResolverBase\n     resolver->get_type_scope ().pop ();\n   }\n \n+  void visit (AST::Union &union_decl) override\n+  {\n+    NodeId scope_node_id = union_decl.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (union_decl.has_generics ())\n+      {\n+\tfor (auto &generic : union_decl.get_generic_params ())\n+\t  {\n+\t    ResolveGenericParam::go (generic.get (), union_decl.get_node_id ());\n+\t  }\n+      }\n+\n+    union_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       union_decl.get_node_id ());\n+      return true;\n+    });\n+\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n   void visit (AST::StaticItem &var) override\n   {\n     ResolveType::go (var.get_type ().get (), var.get_node_id ());"}, {"sha": "b6044327b2751589f29b638141c154bdba99f3e1", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -131,6 +131,38 @@ class ResolveStmt : public ResolverBase\n     resolver->get_type_scope ().pop ();\n   }\n \n+  void visit (AST::Union &union_decl) override\n+  {\n+    auto path = CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t\tunion_decl.get_identifier ());\n+    resolver->get_type_scope ().insert (\n+      path, union_decl.get_node_id (), union_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (union_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    NodeId scope_node_id = union_decl.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (union_decl.has_generics ())\n+      {\n+\tfor (auto &generic : union_decl.get_generic_params ())\n+\t  {\n+\t    ResolveGenericParam::go (generic.get (), union_decl.get_node_id ());\n+\t  }\n+      }\n+\n+    union_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       union_decl.get_node_id ());\n+      return true;\n+    });\n+\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n   void visit (AST::Function &function) override\n   {\n     auto path = ResolveFunctionItemToCanonicalPath::resolve (function);"}, {"sha": "57a0534de484d170dfd42e9214c1265a29b68058", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -81,6 +81,20 @@ class ResolveTopLevel : public ResolverBase\n       });\n   }\n \n+  void visit (AST::Union &union_decl) override\n+  {\n+    auto path\n+      = prefix.append (CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t\t       union_decl.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, union_decl.get_node_id (), union_decl.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (union_decl.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+  }\n+\n   void visit (AST::StaticItem &var) override\n   {\n     auto path = prefix.append ("}, {"sha": "4635796e953f2f030b1e661706ce0628cc0575ea", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -178,6 +178,9 @@ class Backend\n   // Get a struct type.\n   virtual Btype *struct_type (const std::vector<Btyped_identifier> &fields) = 0;\n \n+  // Get a union type.\n+  virtual Btype *union_type (const std::vector<Btyped_identifier> &fields) = 0;\n+\n   // Get an array type.\n   virtual Btype *array_type (Btype *element_type, Bexpression *length) = 0;\n \n@@ -424,7 +427,7 @@ class Backend\n   // corresponding fields in BTYPE.\n   virtual Bexpression *\n   constructor_expression (Btype *btype, const std::vector<Bexpression *> &vals,\n-\t\t\t  Location)\n+\t\t\t  int, Location)\n     = 0;\n \n   // Return an expression that constructs an array of BTYPE with INDEXES and"}, {"sha": "3e47a7cba7a2d1e311083e5cc8b5eb7485d5fb92", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 70, "deletions": 21, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -265,6 +265,8 @@ class Gcc_backend : public Backend\n \n   Btype *struct_type (const std::vector<Btyped_identifier> &);\n \n+  Btype *union_type (const std::vector<Btyped_identifier> &);\n+\n   Btype *array_type (Btype *, Bexpression *);\n \n   Btype *placeholder_pointer_type (const std::string &, Location, bool);\n@@ -377,7 +379,7 @@ class Gcc_backend : public Backend\n \t\t\t\t\tLocation);\n \n   Bexpression *constructor_expression (Btype *,\n-\t\t\t\t       const std::vector<Bexpression *> &,\n+\t\t\t\t       const std::vector<Bexpression *> &, int,\n \t\t\t\t       Location);\n \n   Bexpression *array_constructor_expression (Btype *,\n@@ -531,7 +533,7 @@ class Gcc_backend : public Backend\n \n   Bfunction *make_function (tree t) { return new Bfunction (t); }\n \n-  Btype *fill_in_struct (Btype *, const std::vector<Btyped_identifier> &);\n+  Btype *fill_in_fields (Btype *, const std::vector<Btyped_identifier> &);\n \n   Btype *fill_in_array (Btype *, Btype *, Bexpression *);\n \n@@ -1145,14 +1147,23 @@ Gcc_backend::function_ptr_type (Btype *result_type,\n Btype *\n Gcc_backend::struct_type (const std::vector<Btyped_identifier> &fields)\n {\n-  return this->fill_in_struct (this->make_type (make_node (RECORD_TYPE)),\n+  return this->fill_in_fields (this->make_type (make_node (RECORD_TYPE)),\n+\t\t\t       fields);\n+}\n+\n+// Make a union type.\n+\n+Btype *\n+Gcc_backend::union_type (const std::vector<Btyped_identifier> &fields)\n+{\n+  return this->fill_in_fields (this->make_type (make_node (UNION_TYPE)),\n \t\t\t       fields);\n }\n \n-// Fill in the fields of a struct type.\n+// Fill in the fields of a struct or union type.\n \n Btype *\n-Gcc_backend::fill_in_struct (Btype *fill,\n+Gcc_backend::fill_in_fields (Btype *fill,\n \t\t\t     const std::vector<Btyped_identifier> &fields)\n {\n   tree fill_tree = fill->get_tree ();\n@@ -1311,7 +1322,7 @@ Gcc_backend::set_placeholder_struct_type (\n {\n   tree t = placeholder->get_tree ();\n   gcc_assert (TREE_CODE (t) == RECORD_TYPE && TYPE_FIELDS (t) == NULL_TREE);\n-  Btype *r = this->fill_in_struct (placeholder, fields);\n+  Btype *r = this->fill_in_fields (placeholder, fields);\n \n   if (TYPE_NAME (t) != NULL_TREE)\n     {\n@@ -1321,7 +1332,7 @@ Gcc_backend::set_placeholder_struct_type (\n       DECL_ORIGINAL_TYPE (TYPE_NAME (t)) = copy;\n       TYPE_SIZE (copy) = NULL_TREE;\n       Btype *bc = this->make_type (copy);\n-      this->fill_in_struct (bc, fields);\n+      this->fill_in_fields (bc, fields);\n       delete bc;\n     }\n \n@@ -1758,7 +1769,8 @@ Gcc_backend::struct_field_expression (Bexpression *bstruct, size_t index,\n   if (struct_tree == error_mark_node\n       || TREE_TYPE (struct_tree) == error_mark_node)\n     return this->error_expression ();\n-  gcc_assert (TREE_CODE (TREE_TYPE (struct_tree)) == RECORD_TYPE);\n+  gcc_assert (TREE_CODE (TREE_TYPE (struct_tree)) == RECORD_TYPE\n+\t      || TREE_CODE (TREE_TYPE (struct_tree)) == UNION_TYPE);\n   tree field = TYPE_FIELDS (TREE_TYPE (struct_tree));\n   if (field == NULL_TREE)\n     {\n@@ -2041,7 +2053,7 @@ Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, Bexpression *left,\n Bexpression *\n Gcc_backend::constructor_expression (Btype *btype,\n \t\t\t\t     const std::vector<Bexpression *> &vals,\n-\t\t\t\t     Location location)\n+\t\t\t\t     int union_index, Location location)\n {\n   tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n@@ -2053,11 +2065,15 @@ Gcc_backend::constructor_expression (Btype *btype,\n   tree sink = NULL_TREE;\n   bool is_constant = true;\n   tree field = TYPE_FIELDS (type_tree);\n-  for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n-       p != vals.end (); ++p, field = DECL_CHAIN (field))\n+  if (union_index != -1)\n     {\n-      gcc_assert (field != NULL_TREE);\n-      tree val = (*p)->get_tree ();\n+      gcc_assert (TREE_CODE (type_tree) == UNION_TYPE);\n+      tree val = vals.front ()->get_tree ();\n+      for (int i = 0; i < union_index; i++)\n+\t{\n+\t  gcc_assert (field != NULL_TREE);\n+\t  field = DECL_CHAIN (field);\n+\t}\n       if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n \t  || TREE_TYPE (val) == error_mark_node)\n \treturn this->error_expression ();\n@@ -2070,17 +2086,49 @@ Gcc_backend::constructor_expression (Btype *btype,\n \t  // would have been added as a map element for its\n \t  // side-effects and construct an empty map.\n \t  append_to_statement_list (val, &sink);\n-\t  continue;\n \t}\n+      else\n+\t{\n+\t  constructor_elt empty = {NULL, NULL};\n+\t  constructor_elt *elt = init->quick_push (empty);\n+\t  elt->index = field;\n+\t  elt->value = this->convert_tree (TREE_TYPE (field), val, location);\n+\t  if (!TREE_CONSTANT (elt->value))\n+\t    is_constant = false;\n+\t}\n+    }\n+  else\n+    {\n+      gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n+      for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n+\t   p != vals.end (); ++p, field = DECL_CHAIN (field))\n+\t{\n+\t  gcc_assert (field != NULL_TREE);\n+\t  tree val = (*p)->get_tree ();\n+\t  if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n+\t      || TREE_TYPE (val) == error_mark_node)\n+\t    return this->error_expression ();\n \n-      constructor_elt empty = {NULL, NULL};\n-      constructor_elt *elt = init->quick_push (empty);\n-      elt->index = field;\n-      elt->value = this->convert_tree (TREE_TYPE (field), val, location);\n-      if (!TREE_CONSTANT (elt->value))\n-\tis_constant = false;\n+\t  if (int_size_in_bytes (TREE_TYPE (field)) == 0)\n+\t    {\n+\t      // GIMPLE cannot represent indices of zero-sized types so\n+\t      // trying to construct a map with zero-sized keys might lead\n+\t      // to errors.  Instead, we evaluate each expression that\n+\t      // would have been added as a map element for its\n+\t      // side-effects and construct an empty map.\n+\t      append_to_statement_list (val, &sink);\n+\t      continue;\n+\t    }\n+\n+\t  constructor_elt empty = {NULL, NULL};\n+\t  constructor_elt *elt = init->quick_push (empty);\n+\t  elt->index = field;\n+\t  elt->value = this->convert_tree (TREE_TYPE (field), val, location);\n+\t  if (!TREE_CONSTANT (elt->value))\n+\t    is_constant = false;\n+\t}\n+      gcc_assert (field == NULL_TREE);\n     }\n-  gcc_assert (field == NULL_TREE);\n   tree ret = build_constructor (type_tree, init);\n   if (is_constant)\n     TREE_CONSTANT (ret) = 1;\n@@ -2781,6 +2829,7 @@ Gcc_backend::convert_tree (tree type_tree, tree expr_tree, Location location)\n       || SCALAR_FLOAT_TYPE_P (type_tree) || COMPLEX_FLOAT_TYPE_P (type_tree))\n     return fold_convert_loc (location.gcc_location (), type_tree, expr_tree);\n   else if (TREE_CODE (type_tree) == RECORD_TYPE\n+\t   || TREE_CODE (type_tree) == UNION_TYPE\n \t   || TREE_CODE (type_tree) == ARRAY_TYPE)\n     {\n       gcc_assert (int_size_in_bytes (type_tree)"}, {"sha": "77cbc0628efd414ab948a818b753894d2b90f066", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -159,7 +159,8 @@ class TypeCheckStmt : public TypeCheckBase\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (), true,\n+\t\t\t   struct_decl.get_identifier (),\n+\t\t\t   TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n \t\t\t   std::move (fields), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n@@ -209,13 +210,66 @@ class TypeCheckStmt : public TypeCheckBase\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (), false,\n+\t\t\t   struct_decl.get_identifier (),\n+\t\t\t   TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n \t\t\t   std::move (fields), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n     infered = type;\n   }\n \n+  void visit (HIR::Union &union_decl) override\n+  {\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    if (union_decl.has_generics ())\n+      {\n+\tfor (auto &generic_param : union_decl.get_generic_params ())\n+\t  {\n+\t    switch (generic_param.get ()->get_kind ())\n+\t      {\n+\t      case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t// Skipping Lifetime completely until better handling.\n+\t\tbreak;\n+\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  auto param_type\n+\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\t  context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t\tparam_type);\n+\n+\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t    param_type));\n+\t\t}\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    std::vector<TyTy::StructFieldType *> variants;\n+    union_decl.iterate ([&] (HIR::StructField &variant) mutable -> bool {\n+      TyTy::BaseType *variant_type\n+\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_variant\n+\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t     variant.get_field_name (), variant_type);\n+      variants.push_back (ty_variant);\n+      context->insert_type (variant.get_mappings (),\n+\t\t\t    ty_variant->get_field_type ());\n+      return true;\n+    });\n+\n+    TyTy::BaseType *type\n+      = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n+\t\t\t   mappings->get_next_hir_id (),\n+\t\t\t   union_decl.get_identifier (),\n+\t\t\t   TyTy::ADTType::ADTKind::UNION, std::move (variants),\n+\t\t\t   std::move (substitutions));\n+\n+    context->insert_type (union_decl.get_mappings (), type);\n+    infered = type;\n+  }\n+\n   void visit (HIR::Function &function) override\n   {\n     std::vector<TyTy::SubstitutionParamMapping> substitutions;"}, {"sha": "5b9757f6519020ae644a3fb8976d453e1afddce8", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -94,7 +94,8 @@ class TypeCheckTopLevel : public TypeCheckBase\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (), true,\n+\t\t\t   struct_decl.get_identifier (),\n+\t\t\t   TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n \t\t\t   std::move (fields), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n@@ -143,12 +144,64 @@ class TypeCheckTopLevel : public TypeCheckBase\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (), false,\n+\t\t\t   struct_decl.get_identifier (),\n+\t\t\t   TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n \t\t\t   std::move (fields), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n   }\n \n+  void visit (HIR::Union &union_decl) override\n+  {\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    if (union_decl.has_generics ())\n+      {\n+\tfor (auto &generic_param : union_decl.get_generic_params ())\n+\t  {\n+\t    switch (generic_param.get ()->get_kind ())\n+\t      {\n+\t      case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t// Skipping Lifetime completely until better handling.\n+\t\tbreak;\n+\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  auto param_type\n+\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\t  context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t\tparam_type);\n+\n+\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t    param_type));\n+\t\t}\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    std::vector<TyTy::StructFieldType *> variants;\n+    union_decl.iterate ([&] (HIR::StructField &variant) mutable -> bool {\n+      TyTy::BaseType *variant_type\n+\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_variant\n+\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t     variant.get_field_name (), variant_type);\n+      variants.push_back (ty_variant);\n+      context->insert_type (variant.get_mappings (),\n+\t\t\t    ty_variant->get_field_type ());\n+      return true;\n+    });\n+\n+    TyTy::BaseType *type\n+      = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n+\t\t\t   mappings->get_next_hir_id (),\n+\t\t\t   union_decl.get_identifier (),\n+\t\t\t   TyTy::ADTType::ADTKind::UNION, std::move (variants),\n+\t\t\t   std::move (substitutions));\n+\n+    context->insert_type (union_decl.get_mappings (), type);\n+  }\n+\n   void visit (HIR::StaticItem &var) override\n   {\n     TyTy::BaseType *type = TypeCheckType::Resolve (var.get_type ());"}, {"sha": "66adfcb51310f612242f1f37ae0172d9cf439193", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -180,7 +180,17 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n   // check the arguments are all assigned and fix up the ordering\n   if (fields_assigned.size () != struct_path_resolved->num_fields ())\n     {\n-      if (!struct_expr.has_struct_base ())\n+      if (struct_def->is_union ())\n+\t{\n+\t  if (fields_assigned.size () != 1 || struct_expr.has_struct_base ())\n+\t    {\n+\t      rust_error_at (\n+\t\tstruct_expr.get_locus (),\n+\t\t\"union must have exactly one field variant assigned\");\n+\t      return;\n+\t    }\n+\t}\n+      else if (!struct_expr.has_struct_base ())\n \t{\n \t  rust_error_at (struct_expr.get_locus (),\n \t\t\t \"constructor is missing fields\");\n@@ -236,23 +246,40 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n \t}\n     }\n \n-  // everything is ok, now we need to ensure all field values are ordered\n-  // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n-  // assigned field in the constructor is in the same order as the field in\n-  // the type\n-\n-  std::vector<std::unique_ptr<HIR::StructExprField> > expr_fields\n-    = struct_expr.get_fields_as_owner ();\n-  for (auto &f : expr_fields)\n-    f.release ();\n-\n-  std::vector<std::unique_ptr<HIR::StructExprField> > ordered_fields;\n-  for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n+  if (struct_def->is_union ())\n+    {\n+      // There is exactly one field in this constructor, we need to\n+      // figure out the field index to make sure we initialize the\n+      // right union field.\n+      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n+\t{\n+\t  if (adtFieldIndexToField[i])\n+\t    {\n+\t      struct_expr.union_index = i;\n+\t      break;\n+\t    }\n+\t}\n+      rust_assert (struct_expr.union_index != -1);\n+    }\n+  else\n     {\n-      ordered_fields.push_back (\n-\tstd::unique_ptr<HIR::StructExprField> (adtFieldIndexToField[i]));\n+      // everything is ok, now we need to ensure all field values are ordered\n+      // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n+      // assigned field in the constructor is in the same order as the field in\n+      // the type\n+      std::vector<std::unique_ptr<HIR::StructExprField> > expr_fields\n+\t= struct_expr.get_fields_as_owner ();\n+      for (auto &f : expr_fields)\n+\tf.release ();\n+\n+      std::vector<std::unique_ptr<HIR::StructExprField> > ordered_fields;\n+      for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n+\t{\n+\t  ordered_fields.push_back (\n+\t    std::unique_ptr<HIR::StructExprField> (adtFieldIndexToField[i]));\n+\t}\n+      struct_expr.set_fields_as_owner (std::move (ordered_fields));\n     }\n-  struct_expr.set_fields_as_owner (std::move (ordered_fields));\n \n   resolved = struct_def;\n }"}, {"sha": "cc2e3c01110aa39d81e9829158d1cb46172150a6", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -48,6 +48,12 @@ class TypeResolverDump : public TypeCheckBase\n \t    + \"\\n\";\n   }\n \n+  void visit (HIR::Union &union_decl) override\n+  {\n+    dump\n+      += indent () + \"union \" + type_string (union_decl.get_mappings ()) + \"\\n\";\n+  }\n+\n   void visit (HIR::ImplBlock &impl_block) override\n   {\n     dump += indent () + \"impl \""}, {"sha": "6bac7647ec6e6151589e2c26466de01f0df7f490", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -537,7 +537,7 @@ ADTType::clone ()\n   for (auto &f : fields)\n     cloned_fields.push_back ((StructFieldType *) f->clone ());\n \n-  return new ADTType (get_ref (), get_ty_ref (), identifier, get_is_tuple (),\n+  return new ADTType (get_ref (), get_ty_ref (), identifier, get_adt_kind (),\n \t\t      cloned_fields, clone_substs (), used_arguments,\n \t\t      get_combined_refs ());\n }\n@@ -1999,7 +1999,7 @@ PlaceholderType::clone ()\n void\n TypeCheckCallExpr::visit (ADTType &type)\n {\n-  if (!type.get_is_tuple ())\n+  if (!type.is_tuple_struct ())\n     {\n       rust_error_at (\n \tcall.get_locus (),"}, {"sha": "46110e4a9a757f2b7cd5ea9d2912dee883de084c", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -855,29 +855,39 @@ class SubstitutionRef\n class ADTType : public BaseType, public SubstitutionRef\n {\n public:\n-  ADTType (HirId ref, std::string identifier, bool is_tuple,\n+  enum ADTKind\n+  {\n+    STRUCT_STRUCT,\n+    TUPLE_STRUCT,\n+    UNION,\n+    // ENUM ?\n+  };\n+\n+  ADTType (HirId ref, std::string identifier, ADTKind adt_kind,\n \t   std::vector<StructFieldType *> fields,\n \t   std::vector<SubstitutionParamMapping> subst_refs,\n \t   SubstitutionArgumentMappings generic_arguments\n \t   = SubstitutionArgumentMappings::error (),\n \t   std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::ADT, refs),\n       SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n-      identifier (identifier), fields (fields), is_tuple (is_tuple)\n+      identifier (identifier), fields (fields), adt_kind (adt_kind)\n   {}\n \n-  ADTType (HirId ref, HirId ty_ref, std::string identifier, bool is_tuple,\n+  ADTType (HirId ref, HirId ty_ref, std::string identifier, ADTKind adt_kind,\n \t   std::vector<StructFieldType *> fields,\n \t   std::vector<SubstitutionParamMapping> subst_refs,\n \t   SubstitutionArgumentMappings generic_arguments\n \t   = SubstitutionArgumentMappings::error (),\n \t   std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::ADT, refs),\n       SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n-      identifier (identifier), fields (fields), is_tuple (is_tuple)\n+      identifier (identifier), fields (fields), adt_kind (adt_kind)\n   {}\n \n-  bool get_is_tuple () { return is_tuple; }\n+  ADTKind get_adt_kind () { return adt_kind; }\n+  bool is_tuple_struct () { return adt_kind == TUPLE_STRUCT; }\n+  bool is_union () { return adt_kind == UNION; }\n \n   bool is_unit () const override { return this->fields.empty (); }\n \n@@ -964,7 +974,7 @@ class ADTType : public BaseType, public SubstitutionRef\n private:\n   std::string identifier;\n   std::vector<StructFieldType *> fields;\n-  bool is_tuple;\n+  ADTType::ADTKind adt_kind;\n };\n \n class FnType : public BaseType, public SubstitutionRef"}, {"sha": "393e59115a78135a0545c39154921f1d75ef122a", "filename": "gcc/testsuite/rust/compile/torture/union.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Funion.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Funion.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Funion.rs?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile }\n+// { dg-options \"-w\" }\n+\n+union U\n+{\n+  f1: u8\n+}\n+\n+union V\n+{\n+  f1: u8,\n+  f2: u16,\n+  f3: i32,\n+}\n+\n+struct S\n+{\n+  f1: U,\n+  f2: V\n+}\n+\n+fn main ()\n+{\n+  let u = U { f1: 16 };\n+  let v = V { f2: 365 };\n+  let s = S { f1: u, f2: v };\n+  let _v125 = unsafe\n+    { let mut uv: u64;\n+      uv = s.f1.f1 as u64;\n+      uv += s.f2.f1 as u64;\n+      uv += s.f2.f2 as u64;\n+      uv -= s.f2.f3 as u64;\n+      uv\n+    };\n+}"}, {"sha": "9feb145a692189b46203bc4138a9d0dcc1086e75", "filename": "gcc/testsuite/rust/compile/torture/union_union.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Funion_union.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56c6fdfaad9ca1681714d288d1282cf08554462/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Funion_union.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Funion_union.rs?ref=b56c6fdfaad9ca1681714d288d1282cf08554462", "patch": "@@ -0,0 +1,27 @@\n+union union\n+{\n+  union: u32,\n+  inion: i32,\n+  u8ion: u8,\n+  i64on: i64,\n+  u64on: u64\n+}\n+\n+pub fn main ()\n+{\n+  let union = union { union: 2 };\n+  let inion = union { inion: -2 };\n+  let mut mnion = union { inion: -16 };\n+  let m1 = unsafe { mnion.union };\n+  unsafe { mnion.union = union.union };\n+  let m2 = unsafe { mnion.inion };\n+  let u1 = unsafe { union.union };\n+  let i1 = unsafe { union.inion };\n+  let u2 = unsafe { inion.union };\n+  let i2 = unsafe { inion.inion };\n+  let _r1 = u2 - u1 - m1;\n+  let _r2 = i1 + i2 + m2;\n+  let _u8 = unsafe { union.u8ion };\n+  let _i64 = unsafe { union.i64on };\n+  let _u64 = unsafe { union.u64on };\n+}"}]}