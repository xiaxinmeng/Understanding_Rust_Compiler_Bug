{"sha": "a5695aa2c93dec00bfeb7eed1ff6d62858699ba7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU2OTVhYTJjOTNkZWMwMGJmZWI3ZWVkMWZmNmQ2Mjg1ODY5OWJhNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-03-25T16:58:48Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-03-25T16:58:48Z"}, "message": "utils.c (add_parallel_type): Take a TYPE instead of a DECL and adjust.\n\n\t* gcc-interface/utils.c (add_parallel_type): Take a TYPE instead of a\n\tDECL and adjust.  Move around.\n\t(has_parallel_type): New predicate.\n\t(rest_of_record_type_compilation): Return early if the type already\n\thas a parallel type.\n\t* gcc-interface/gigi.h (add_parallel_type): Adjust.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust for above changes.\n\nFrom-SVN: r185779", "tree": {"sha": "536edf3d5f2df8ca541b5757200960e4953e5522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/536edf3d5f2df8ca541b5757200960e4953e5522"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7/comments", "author": null, "committer": null, "parents": [{"sha": "fb88e1dd28570359af09327bb65ac8de5fcc9fe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb88e1dd28570359af09327bb65ac8de5fcc9fe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb88e1dd28570359af09327bb65ac8de5fcc9fe8"}], "stats": {"total": 71, "additions": 47, "deletions": 24}, "files": [{"sha": "efd34461532b724b2158063b0c2249cb17707d65", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a5695aa2c93dec00bfeb7eed1ff6d62858699ba7", "patch": "@@ -1,3 +1,13 @@\n+2012-03-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (add_parallel_type): Take a TYPE instead of a\n+\tDECL and adjust.  Move around.\n+\t(has_parallel_type): New predicate.\n+\t(rest_of_record_type_compilation): Return early if the type already\n+\thas a parallel type.\n+\t* gcc-interface/gigi.h (add_parallel_type): Adjust.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust for above changes.\n+\n 2012-03-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (finish_record_type): Return early for padded"}, {"sha": "2139fbd6fdb996c760585476c10d76d22b66a0e5", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=a5695aa2c93dec00bfeb7eed1ff6d62858699ba7", "patch": "@@ -1779,7 +1779,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       if (debug_info_p\n \t  && Is_Packed_Array_Type (gnat_entity)\n \t  && present_gnu_tree (Original_Array_Type (gnat_entity)))\n-\tadd_parallel_type (TYPE_STUB_DECL (gnu_type),\n+\tadd_parallel_type (gnu_type,\n \t\t\t   gnat_to_gnu_type\n \t\t\t   (Original_Array_Type (gnat_entity)));\n \n@@ -1854,7 +1854,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      /* Make the original array type a parallel type.  */\n \t      if (present_gnu_tree (Original_Array_Type (gnat_entity)))\n-\t\tadd_parallel_type (TYPE_STUB_DECL (gnu_type),\n+\t\tadd_parallel_type (gnu_type,\n \t\t\t\t   gnat_to_gnu_type\n \t\t\t\t   (Original_Array_Type (gnat_entity)));\n \n@@ -2637,7 +2637,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t}\n \n \t      finish_record_type (gnu_bound_rec, gnu_field_list, 0, true);\n-\t      add_parallel_type (TYPE_STUB_DECL (gnu_type), gnu_bound_rec);\n+\t      add_parallel_type (gnu_type, gnu_bound_rec);\n \t    }\n \n \t  /* If this is a packed array type, make the original array type a\n@@ -2647,15 +2647,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      if (Is_Packed_Array_Type (gnat_entity)\n \t\t  && present_gnu_tree (Original_Array_Type (gnat_entity)))\n-\t\tadd_parallel_type (TYPE_STUB_DECL (gnu_type),\n+\t\tadd_parallel_type (gnu_type,\n \t\t\t\t   gnat_to_gnu_type\n \t\t\t\t   (Original_Array_Type (gnat_entity)));\n \t      else\n \t\t{\n \t\t  tree gnu_base_decl\n \t\t    = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE, 0);\n \t\t  if (!DECL_ARTIFICIAL (gnu_base_decl))\n-\t\t    add_parallel_type (TYPE_STUB_DECL (gnu_type),\n+\t\t    add_parallel_type (gnu_type,\n \t\t\t\t       TREE_TYPE (TREE_TYPE (gnu_base_decl)));\n \t\t}\n \t    }\n@@ -3529,8 +3529,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t\t\t 0, 0),\n \t\t\t\t      0, true);\n \n-\t\t  add_parallel_type (TYPE_STUB_DECL (gnu_type),\n-\t\t\t\t     gnu_subtype_marker);\n+\t\t  add_parallel_type (gnu_type, gnu_subtype_marker);\n \n \t\t  if (definition\n \t\t      && TREE_CODE (gnu_size_unit) != INTEGER_CST\n@@ -6643,7 +6642,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t\t\t     0, 0),\n \t\t\t  0, true);\n \n-      add_parallel_type (TYPE_STUB_DECL (record), marker);\n+      add_parallel_type (record, marker);\n \n       if (definition && size && TREE_CODE (size) != INTEGER_CST)\n \tTYPE_SIZE_UNIT (marker)"}, {"sha": "c507615fbfd94ada4588f9bc730c0c0f9daed9b1", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=a5695aa2c93dec00bfeb7eed1ff6d62858699ba7", "patch": "@@ -560,8 +560,8 @@ extern void finish_record_type (tree record_type, tree field_list,\n    a parallel type is to be attached to the record type.  */\n extern void rest_of_record_type_compilation (tree record_type);\n \n-/* Append PARALLEL_TYPE on the chain of parallel types for decl.  */\n-extern void add_parallel_type (tree decl, tree parallel_type);\n+/* Append PARALLEL_TYPE on the chain of parallel types for TYPE.  */\n+extern void add_parallel_type (tree type, tree parallel_type);\n \n /* Return a FUNCTION_TYPE node.  RETURN_TYPE is the type returned by the\n    subprogram.  If it is VOID_TYPE, then we are dealing with a procedure,"}, {"sha": "1460a43ea94c8af0bf5710e1fc439c6bcfc631f0", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5695aa2c93dec00bfeb7eed1ff6d62858699ba7/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=a5695aa2c93dec00bfeb7eed1ff6d62858699ba7", "patch": "@@ -855,6 +855,29 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n     rest_of_record_type_compilation (record_type);\n }\n \n+/* Append PARALLEL_TYPE on the chain of parallel types of TYPE.  */\n+\n+void\n+add_parallel_type (tree type, tree parallel_type)\n+{\n+  tree decl = TYPE_STUB_DECL (type);\n+\n+  while (DECL_PARALLEL_TYPE (decl))\n+    decl = TYPE_STUB_DECL (DECL_PARALLEL_TYPE (decl));\n+\n+  SET_DECL_PARALLEL_TYPE (decl, parallel_type);\n+}\n+\n+/* Return true if TYPE has a parallel type.  */\n+\n+static bool\n+has_parallel_type (tree type)\n+{\n+  tree decl = TYPE_STUB_DECL (type);\n+\n+  return DECL_PARALLEL_TYPE (decl) != NULL_TREE;\n+}\n+\n /* Wrap up compilation of RECORD_TYPE, i.e. output all the debug information\n    associated with it.  It need not be invoked directly in most cases since\n    finish_record_type takes care of doing so, but this can be necessary if\n@@ -871,6 +894,10 @@ rest_of_record_type_compilation (tree record_type)\n   if (TYPE_IS_PADDING_P (record_type))\n     return;\n \n+  /* If the type already has a parallel type (XVS type), then we're done.  */\n+  if (has_parallel_type (record_type))\n+    return;\n+\n   for (field = TYPE_FIELDS (record_type); field; field = DECL_CHAIN (field))\n     {\n       /* We need to make an XVE/XVU record if any field has variable size,\n@@ -1054,23 +1081,10 @@ rest_of_record_type_compilation (tree record_type)\n \n       TYPE_FIELDS (new_record_type) = nreverse (TYPE_FIELDS (new_record_type));\n \n-      add_parallel_type (TYPE_STUB_DECL (record_type), new_record_type);\n+      add_parallel_type (record_type, new_record_type);\n     }\n }\n \n-/* Append PARALLEL_TYPE on the chain of parallel types for decl.  */\n-\n-void\n-add_parallel_type (tree decl, tree parallel_type)\n-{\n-  tree d = decl;\n-\n-  while (DECL_PARALLEL_TYPE (d))\n-    d = TYPE_STUB_DECL (DECL_PARALLEL_TYPE (d));\n-\n-  SET_DECL_PARALLEL_TYPE (d, parallel_type);\n-}\n-\n /* Utility function of above to merge LAST_SIZE, the previous size of a record\n    with FIRST_BIT and SIZE that describe a field.  SPECIAL is true if this\n    represents a QUAL_UNION_TYPE in which case we must look for COND_EXPRs and"}]}