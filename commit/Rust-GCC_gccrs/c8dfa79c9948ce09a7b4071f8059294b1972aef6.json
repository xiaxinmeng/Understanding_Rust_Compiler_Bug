{"sha": "c8dfa79c9948ce09a7b4071f8059294b1972aef6", "node_id": "C_kwDOANBUbNoAKGM4ZGZhNzljOTk0OGNlMDlhN2I0MDcxZjgwNTkyOTRiMTk3MmFlZjY", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-09-27T08:43:32Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-09-27T08:50:18Z"}, "message": "d: Merge upstream dmd d579c467c1, phobos 88aa69b14.\n\nD front-end changes:\n\n    - Throwing from contracts of `nothrow' functions has been\n      deprecated, as this breaks the guarantees of `nothrow'.\n    - Added language support for initializing the interior pointer of\n      associative arrays using `new' keyword.\n\nPhobos changes:\n\n    - The std.digest.digest module has been removed.\n    - The std.xml module has been removed.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd d579c467c1.\n\t* decl.cc (layout_struct_initializer): Update for new front-end\n\tinterface.\n\t* expr.cc (ExprVisitor::visit (AssignExp *)): Remove lowering of array\n\tassignments.\n\t(ExprVisitor::visit (NewExp *)): Add new lowering of new'ing\n\tassociative arrays to an _aaNew() library call.\n\t* runtime.def (ARRAYSETASSIGN): Remove.\n\t(AANEW): Define.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime d579c467c1.\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Remove\n\trt/arrayassign.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* src/MERGE: Merge upstream phobos 88aa69b14.\n\t* src/Makefile.am (PHOBOS_DSOURCES): Remove std/digest/digest.d,\n\tstd/xml.d.\n\t* src/Makefile.in: Regenerate.", "tree": {"sha": "cb93655417a5475c6baac88691fc92621b3fa7ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb93655417a5475c6baac88691fc92621b3fa7ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8dfa79c9948ce09a7b4071f8059294b1972aef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8dfa79c9948ce09a7b4071f8059294b1972aef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8dfa79c9948ce09a7b4071f8059294b1972aef6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8dfa79c9948ce09a7b4071f8059294b1972aef6/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2"}], "stats": {"total": 8586, "additions": 3282, "deletions": 5304}, "files": [{"sha": "dcfca648e4413cdb310ec363f2dd49783b7e8a0a", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2335,7 +2335,7 @@ layout_struct_initializer (StructDeclaration *sd)\n {\n   StructLiteralExp *sle = StructLiteralExp::create (sd->loc, sd, NULL);\n \n-  if (!sd->fill (sd->loc, sle->elements, true))\n+  if (!sd->fill (sd->loc, *sle->elements, true))\n     gcc_unreachable ();\n \n   sle->type = sd->type;"}, {"sha": "a4c46f3306ede57b9563edfe93b88cb6026ed42b", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,4 +1,4 @@\n-817610b16d0f0f469b9fbb28c000956fb910c43f\n+4219ba670ce9ff92f3e874f0f048f2c28134c008\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "edca17fbad1edf3b0218d3d1878457db79452412", "filename": "gcc/d/dmd/aggregate.d", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Faggregate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Faggregate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -355,23 +355,22 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n      *      false if any errors occur.\n      *      Otherwise, returns true and the missing arguments will be pushed in elements[].\n      */\n-    final bool fill(const ref Loc loc, Expressions* elements, bool ctorinit)\n+    final bool fill(const ref Loc loc, ref Expressions elements, bool ctorinit)\n     {\n         //printf(\"AggregateDeclaration::fill() %s\\n\", toChars());\n         assert(sizeok == Sizeok.done);\n-        assert(elements);\n         const nfields = nonHiddenFields();\n         bool errors = false;\n \n         size_t dim = elements.dim;\n         elements.setDim(nfields);\n         foreach (size_t i; dim .. nfields)\n-            (*elements)[i] = null;\n+            elements[i] = null;\n \n         // Fill in missing any elements with default initializers\n         foreach (i; 0 .. nfields)\n         {\n-            if ((*elements)[i])\n+            if (elements[i])\n                 continue;\n \n             auto vd = fields[i];\n@@ -389,7 +388,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n                 if (!vd.isOverlappedWith(v2))\n                     continue;\n \n-                if ((*elements)[j])\n+                if (elements[j])\n                 {\n                     vx = null;\n                     break;\n@@ -489,10 +488,10 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n                     else\n                         e = telem.defaultInitLiteral(loc);\n                 }\n-                (*elements)[fieldi] = e;\n+                elements[fieldi] = e;\n             }\n         }\n-        foreach (e; *elements)\n+        foreach (e; elements)\n         {\n             if (e && e.op == EXP.error)\n                 return false;"}, {"sha": "f0909e3dc02aaf0ffbe8fc67cdade7d3b4e6f39a", "filename": "gcc/d/dmd/aggregate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Faggregate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Faggregate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.h?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -125,7 +125,7 @@ class AggregateDeclaration : public ScopeDsymbol\n     bool determineSize(const Loc &loc);\n     virtual void finalizeSize() = 0;\n     uinteger_t size(const Loc &loc) override final;\n-    bool fill(const Loc &loc, Expressions *elements, bool ctorinit);\n+    bool fill(const Loc &loc, Expressions &elements, bool ctorinit);\n     Type *getType() override final;\n     bool isDeprecated() const override final; // is aggregate deprecated?\n     void setDeprecated();"}, {"sha": "3b73771ef22f4875cc638e455547b1a19753443f", "filename": "gcc/d/dmd/apply.d", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fapply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fapply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fapply.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -16,6 +16,7 @@ import dmd.dsymbol;\n import dmd.dsymbolsem;\n import dmd.dtemplate;\n import dmd.expression;\n+import dmd.root.array;\n import dmd.visitor;\n \n bool walkPostorder(Expression e, StoppableVisitor v)\n@@ -86,12 +87,10 @@ public:\n         return stop;\n     }\n \n-    bool doCond(Expressions* e)\n+    extern(D) bool doCond(Expression[] e)\n     {\n-        if (!e)\n-            return false;\n-        for (size_t i = 0; i < e.dim && !stop; i++)\n-            doCond((*e)[i]);\n+        for (size_t i = 0; i < e.length && !stop; i++)\n+            doCond(e[i]);\n         return stop;\n     }\n \n@@ -110,13 +109,13 @@ public:\n     override void visit(NewExp e)\n     {\n         //printf(\"NewExp::apply(): %s\\n\", toChars());\n-        doCond(e.thisexp) || doCond(e.arguments) || applyTo(e);\n+        doCond(e.thisexp) || doCond(e.arguments.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(NewAnonClassExp e)\n     {\n         //printf(\"NewAnonClassExp::apply(): %s\\n\", toChars());\n-        doCond(e.thisexp) || doCond(e.arguments) || applyTo(e);\n+        doCond(e.thisexp) || doCond(e.arguments.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(TypeidExp e)\n@@ -143,13 +142,13 @@ public:\n     override void visit(CallExp e)\n     {\n         //printf(\"CallExp::apply(apply_fp_t fp, void *param): %s\\n\", toChars());\n-        doCond(e.e1) || doCond(e.arguments) || applyTo(e);\n+        doCond(e.e1) || doCond(e.arguments.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(ArrayExp e)\n     {\n         //printf(\"ArrayExp::apply(apply_fp_t fp, void *param): %s\\n\", toChars());\n-        doCond(e.e1) || doCond(e.arguments) || applyTo(e);\n+        doCond(e.e1) || doCond(e.arguments.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(SliceExp e)\n@@ -159,12 +158,12 @@ public:\n \n     override void visit(ArrayLiteralExp e)\n     {\n-        doCond(e.basis) || doCond(e.elements) || applyTo(e);\n+        doCond(e.basis) || doCond(e.elements.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(AssocArrayLiteralExp e)\n     {\n-        doCond(e.keys) || doCond(e.values) || applyTo(e);\n+        doCond(e.keys.peekSlice()) || doCond(e.values.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(StructLiteralExp e)\n@@ -173,13 +172,13 @@ public:\n             return;\n         int old = e.stageflags;\n         e.stageflags |= stageApply;\n-        doCond(e.elements) || applyTo(e);\n+        doCond(e.elements.peekSlice()) || applyTo(e);\n         e.stageflags = old;\n     }\n \n     override void visit(TupleExp e)\n     {\n-        doCond(e.e0) || doCond(e.exps) || applyTo(e);\n+        doCond(e.e0) || doCond(e.exps.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(CondExp e)"}, {"sha": "f07a6f44d2b681439119447d25222d76427d657d", "filename": "gcc/d/dmd/arrayop.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Farrayop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Farrayop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -129,8 +129,7 @@ Expression arrayOp(BinExp e, Scope* sc)\n         return arrayOpInvalidError(e);\n \n     auto tiargs = new Objects();\n-    auto args = new Expressions();\n-    buildArrayOp(sc, e, tiargs, args);\n+    auto args = buildArrayOp(sc, e, tiargs);\n \n     import dmd.dtemplate : TemplateDeclaration;\n     __gshared TemplateDeclaration arrayOp;\n@@ -184,7 +183,7 @@ Expression arrayOp(BinAssignExp e, Scope* sc)\n  * using reverse polish notation (RPN) to encode order of operations.\n  * Encode operations as string arguments, using a \"u\" prefix for unary operations.\n  */\n-private void buildArrayOp(Scope* sc, Expression e, Objects* tiargs, Expressions* args)\n+private Expressions* buildArrayOp(Scope* sc, Expression e, Objects* tiargs)\n {\n     extern (C++) final class BuildArrayOpVisitor : Visitor\n     {\n@@ -194,11 +193,11 @@ private void buildArrayOp(Scope* sc, Expression e, Objects* tiargs, Expressions*\n         Expressions* args;\n \n     public:\n-        extern (D) this(Scope* sc, Objects* tiargs, Expressions* args)\n+        extern (D) this(Scope* sc, Objects* tiargs)\n         {\n             this.sc = sc;\n             this.tiargs = tiargs;\n-            this.args = args;\n+            this.args = new Expressions();\n         }\n \n         override void visit(Expression e)\n@@ -252,8 +251,9 @@ private void buildArrayOp(Scope* sc, Expression e, Objects* tiargs, Expressions*\n         }\n     }\n \n-    scope v = new BuildArrayOpVisitor(sc, tiargs, args);\n+    scope v = new BuildArrayOpVisitor(sc, tiargs);\n     e.accept(v);\n+    return v.args;\n }\n \n /***********************************************"}, {"sha": "3472d1ce478928d0bc274c7b8aea2d6e0b76da18", "filename": "gcc/d/dmd/attrib.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1431,7 +1431,7 @@ extern (C++) final class UserAttributeDeclaration : AttribDeclaration\n         if (auto sc = _scope)\n         {\n             _scope = null;\n-            arrayExpressionSemantic(atts, sc);\n+            arrayExpressionSemantic(atts.peekSlice(), sc);\n         }\n         auto exps = new Expressions();\n         if (userAttribDecl && userAttribDecl !is this)\n@@ -1554,7 +1554,7 @@ int foreachUda(Dsymbol sym, Scope* sc, int delegate(Expression) dg)\n         return 0;\n \n     auto udas = sym.userAttribDecl.getAttributes();\n-    arrayExpressionSemantic(udas, sc, true);\n+    arrayExpressionSemantic(udas.peekSlice(), sc, true);\n \n     return udas.each!((uda) {\n         if (!uda.isTupleExp())"}, {"sha": "09e38331137ed2670cfb1c7cd692a37f66018253", "filename": "gcc/d/dmd/canthrow.d", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fcanthrow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fcanthrow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -111,13 +111,9 @@ extern (C++) /* CT */ BE canThrow(Expression e, FuncDeclaration func, bool mustN\n                     auto ts = tbNext.baseElemOf().isTypeStruct();\n                     if (ts)\n                     {\n-                        import dmd.id : Id;\n-\n                         auto sd = ts.sym;\n                         const id = ce.f.ident;\n-                        if (sd.postblit &&\n-                            (id == Id._d_arrayctor || id == Id._d_arraysetctor ||\n-                            id == Id._d_arrayassign_l || id == Id._d_arrayassign_r))\n+                        if (sd.postblit && isArrayConstructionOrAssign(id))\n                         {\n                             checkFuncThrows(ce, sd.postblit);\n                             return;"}, {"sha": "8204961fd2941eb9529aca38287007c9f43f3746", "filename": "gcc/d/dmd/chkformat.d", "status": "modified", "additions": 173, "deletions": 427, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fchkformat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fchkformat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fchkformat.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1079,386 +1079,210 @@ Format parseGenericFormatSpecifier(scope const char[] format,\n     return specifier; // success\n }\n \n-unittest\n+@(\"parseGenericFormatSpecifier\") unittest\n {\n-    /* parseGenericFormatSpecifier\n-     */\n-\n     char genSpecifier;\n     size_t idx;\n \n-    assert(parseGenericFormatSpecifier(\"hhd\", idx, genSpecifier) == Format.hhd);\n-    assert(genSpecifier == 'd');\n-\n-    idx = 0;\n-    assert(parseGenericFormatSpecifier(\"hn\", idx, genSpecifier) == Format.hn);\n-    assert(genSpecifier == 'n');\n-\n-    idx = 0;\n-    assert(parseGenericFormatSpecifier(\"ji\", idx, genSpecifier) == Format.jd);\n-    assert(genSpecifier == 'i');\n+    void testG(string fmtStr, Format expectedFormat, char expectedGenSpecifier)\n+    {\n+        idx = 0;\n+        assert(parseGenericFormatSpecifier(fmtStr, idx, genSpecifier) == expectedFormat);\n+        assert(genSpecifier == expectedGenSpecifier);\n+    }\n \n-    idx = 0;\n-    assert(parseGenericFormatSpecifier(\"lu\", idx, genSpecifier) == Format.lu);\n-    assert(genSpecifier == 'u');\n+    testG(\"hhd\", Format.hhd, 'd');\n+    testG(\"hn\", Format.hn, 'n');\n+    testG(\"ji\", Format.jd, 'i');\n+    testG(\"lu\", Format.lu, 'u');\n \n     idx = 0;\n     assert(parseGenericFormatSpecifier(\"k\", idx, genSpecifier) == Format.error);\n+}\n \n-    /* parsePrintfFormatSpecifier\n-     */\n-\n-     bool widthStar;\n-     bool precisionStar;\n-\n-     // one for each Format\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%d\", idx, widthStar, precisionStar) == Format.d);\n-     assert(idx == 2);\n-     assert(!widthStar && !precisionStar);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%ld\", idx, widthStar, precisionStar) == Format.ld);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%lld\", idx, widthStar, precisionStar) == Format.lld);\n-     assert(idx == 4);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%jd\", idx, widthStar, precisionStar) == Format.jd);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%zd\", idx, widthStar, precisionStar) == Format.zd);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%td\", idx, widthStar, precisionStar) == Format.td);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%g\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%Lg\", idx, widthStar, precisionStar) == Format.Lg);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%p\", idx, widthStar, precisionStar) == Format.p);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%n\", idx, widthStar, precisionStar) == Format.n);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%ln\", idx, widthStar, precisionStar) == Format.ln);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%lln\", idx, widthStar, precisionStar) == Format.lln);\n-     assert(idx == 4);\n+@(\"parsePrintfFormatSpecifier\") unittest\n+{\n+    bool useGNUExts = false;\n \n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%hn\", idx, widthStar, precisionStar) == Format.hn);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%hhn\", idx, widthStar, precisionStar) == Format.hhn);\n-     assert(idx == 4);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%jn\", idx, widthStar, precisionStar) == Format.jn);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%zn\", idx, widthStar, precisionStar) == Format.zn);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%tn\", idx, widthStar, precisionStar) == Format.tn);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%c\", idx, widthStar, precisionStar) == Format.c);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%lc\", idx, widthStar, precisionStar) == Format.lc);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%s\", idx, widthStar, precisionStar) == Format.s);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%ls\", idx, widthStar, precisionStar) == Format.ls);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%%\", idx, widthStar, precisionStar) == Format.percent);\n-     assert(idx == 2);\n-\n-     // Synonyms\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%i\", idx, widthStar, precisionStar) == Format.d);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%u\", idx, widthStar, precisionStar) == Format.u);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%o\", idx, widthStar, precisionStar) == Format.u);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%x\", idx, widthStar, precisionStar) == Format.u);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%X\", idx, widthStar, precisionStar) == Format.u);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%f\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%F\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%G\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%a\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%La\", idx, widthStar, precisionStar) == Format.Lg);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%A\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%lg\", idx, widthStar, precisionStar) == Format.lg);\n-     assert(idx == 3);\n-\n-     // width, precision\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%*d\", idx, widthStar, precisionStar) == Format.d);\n-     assert(idx == 3);\n-     assert(widthStar && !precisionStar);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%.*d\", idx, widthStar, precisionStar) == Format.d);\n-     assert(idx == 4);\n-     assert(!widthStar && precisionStar);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%*.*d\", idx, widthStar, precisionStar) == Format.d);\n-     assert(idx == 5);\n-     assert(widthStar && precisionStar);\n-\n-     // Too short formats\n-     {\n-         foreach (s; [\"%\", \"%-\", \"%+\", \"% \", \"%#\", \"%0\", \"%*\", \"%1\", \"%19\", \"%.\", \"%.*\", \"%.1\", \"%.12\",\n-                      \"%j\", \"%z\", \"%t\", \"%l\", \"%h\", \"%ll\", \"%hh\"])\n-         {\n-             idx = 0;\n-             assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar) == Format.error);\n-             assert(idx == s.length);\n-         }\n-     }\n-\n-     // Undefined format combinations\n-     {\n-         foreach (s; [\"%#d\", \"%llg\", \"%jg\", \"%zg\", \"%tg\", \"%hg\", \"%hhg\",\n-                      \"%#c\", \"%0c\", \"%jc\", \"%zc\", \"%tc\", \"%Lc\", \"%hc\", \"%hhc\", \"%llc\",\n-                      \"%#s\", \"%0s\", \"%js\", \"%zs\", \"%ts\", \"%Ls\", \"%hs\", \"%hhs\", \"%lls\",\n-                      \"%jp\", \"%zp\", \"%tp\", \"%Lp\", \"%hp\", \"%lp\", \"%hhp\", \"%llp\",\n-                      \"%-n\", \"%+n\", \"% n\", \"%#n\", \"%0n\", \"%*n\", \"%1n\", \"%19n\", \"%.n\", \"%.*n\", \"%.1n\", \"%.12n\", \"%Ln\", \"%K\"])\n-         {\n-             idx = 0;\n-             assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar) == Format.error);\n-             assert(idx == s.length);\n-         }\n-     }\n-\n-    /* parseScanfFormatSpecifier\n-     */\n+    size_t idx = 0;\n+    bool widthStar;\n+    bool precisionStar;\n \n-    bool asterisk;\n+    void testP(string fmtStr, Format expectedFormat, size_t expectedIdx)\n+    {\n+        idx = 0;\n+        assert(parsePrintfFormatSpecifier(fmtStr, idx, widthStar, precisionStar, useGNUExts) == expectedFormat);\n+        assert(idx == expectedIdx);\n+    }\n \n     // one for each Format\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%d\", idx, asterisk) == Format.d);\n-    assert(idx == 2);\n-    assert(!asterisk);\n+    testP(\"%d\", Format.d, 2);\n+    assert(!widthStar && !precisionStar);\n+\n+    testP(\"%ld\", Format.ld, 3);\n+    testP(\"%lld\", Format.lld, 4);\n+    testP(\"%jd\", Format.jd, 3);\n+    testP(\"%zd\", Format.zd, 3);\n+    testP(\"%td\", Format.td, 3);\n+    testP(\"%g\", Format.g, 2);\n+    testP(\"%Lg\", Format.Lg, 3);\n+    testP(\"%p\", Format.p, 2);\n+    testP(\"%n\", Format.n, 2);\n+    testP(\"%ln\", Format.ln, 3);\n+    testP(\"%lln\", Format.lln, 4);\n+    testP(\"%hn\", Format.hn, 3);\n+    testP(\"%hhn\", Format.hhn, 4);\n+    testP(\"%jn\", Format.jn, 3);\n+    testP(\"%zn\", Format.zn, 3);\n+    testP(\"%tn\", Format.tn, 3);\n+    testP(\"%c\", Format.c, 2);\n+    testP(\"%lc\", Format.lc, 3);\n+    testP(\"%s\", Format.s, 2);\n+    testP(\"%ls\", Format.ls, 3);\n+    testP(\"%%\", Format.percent, 2);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%hhd\", idx, asterisk) == Format.hhd);\n-    assert(idx == 4);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%hd\", idx, asterisk) == Format.hd);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%ld\", idx, asterisk) == Format.ld);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%lld\", idx, asterisk) == Format.lld);\n-    assert(idx == 4);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%jd\", idx, asterisk) == Format.jd);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%zd\", idx, asterisk) == Format.zd);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%td\", idx, asterisk,) == Format.td);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%u\", idx, asterisk) == Format.u);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%hhu\", idx, asterisk,) == Format.hhu);\n-    assert(idx == 4);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%hu\", idx, asterisk) == Format.hu);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%lu\", idx, asterisk) == Format.lu);\n-    assert(idx == 3);\n+    // Synonyms\n+    testP(\"%i\", Format.d, 2);\n+    testP(\"%u\", Format.u, 2);\n+    testP(\"%o\", Format.u, 2);\n+    testP(\"%x\", Format.u, 2);\n+    testP(\"%X\", Format.u, 2);\n+    testP(\"%f\", Format.g, 2);\n+    testP(\"%F\", Format.g, 2);\n+    testP(\"%G\", Format.g, 2);\n+    testP(\"%a\", Format.g, 2);\n+    testP(\"%La\", Format.Lg, 3);\n+    testP(\"%A\", Format.g, 2);\n+    testP(\"%lg\", Format.lg, 3);\n+\n+    // width, precision\n+    testP(\"%*d\", Format.d, 3);\n+    assert(widthStar && !precisionStar);\n+\n+    testP(\"%.*d\", Format.d, 4);\n+    assert(!widthStar && precisionStar);\n+\n+    testP(\"%*.*d\", Format.d, 5);\n+    assert(widthStar && precisionStar);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%llu\", idx, asterisk) == Format.llu);\n-    assert(idx == 4);\n+    // Too short formats\n+    foreach (s; [\"%\", \"%-\", \"%+\", \"% \", \"%#\", \"%0\", \"%*\", \"%1\", \"%19\", \"%.\", \"%.*\", \"%.1\", \"%.12\",\n+                    \"%j\", \"%z\", \"%t\", \"%l\", \"%h\", \"%ll\", \"%hh\"])\n+    {\n+        testP(s, Format.error, s.length);\n+    }\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%ju\", idx, asterisk) == Format.ju);\n-    assert(idx == 3);\n+    // Undefined format combinations\n+    foreach (s; [\"%#d\", \"%llg\", \"%jg\", \"%zg\", \"%tg\", \"%hg\", \"%hhg\",\n+                    \"%#c\", \"%0c\", \"%jc\", \"%zc\", \"%tc\", \"%Lc\", \"%hc\", \"%hhc\", \"%llc\",\n+                    \"%#s\", \"%0s\", \"%js\", \"%zs\", \"%ts\", \"%Ls\", \"%hs\", \"%hhs\", \"%lls\",\n+                    \"%jp\", \"%zp\", \"%tp\", \"%Lp\", \"%hp\", \"%lp\", \"%hhp\", \"%llp\",\n+                    \"%-n\", \"%+n\", \"% n\", \"%#n\", \"%0n\", \"%*n\", \"%1n\", \"%19n\", \"%.n\", \"%.*n\", \"%.1n\", \"%.12n\", \"%Ln\", \"%K\"])\n+    {\n+        testP(s, Format.error, s.length);\n+    }\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%g\", idx, asterisk) == Format.g);\n-    assert(idx == 2);\n+    testP(\"%C\", Format.lc, 2);\n+    testP(\"%S\", Format.ls, 2);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%lg\", idx, asterisk) == Format.lg);\n-    assert(idx == 3);\n+    // GNU extensions: explicitly toggle ISO/GNU flag.\n+    foreach (s; [\"%jm\", \"%zm\", \"%tm\", \"%Lm\", \"%hm\", \"%hhm\", \"%lm\", \"%llm\",\n+                    \"%#m\", \"%+m\", \"%-m\", \"% m\", \"%0m\"])\n+    {\n+        useGNUExts = false;\n+        testP(s, Format.error, s.length);\n+        useGNUExts = true;\n+        testP(s, Format.error, s.length);\n+    }\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%Lg\", idx, asterisk) == Format.Lg);\n-    assert(idx == 3);\n+    foreach (s; [\"%m\", \"%md\", \"%mz\", \"%mc\", \"%mm\", \"%msyz\", \"%ml\", \"%mlz\", \"%mlc\", \"%mlm\"])\n+    {\n+        // valid cases, all parsed as `%m`\n+        // GNU printf()\n+        useGNUExts = true;\n+        testP(s, Format.GNU_m, 2);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%p\", idx, asterisk) == Format.p);\n-    assert(idx == 2);\n+        // ISO printf()\n+        useGNUExts = false;\n+        testP(s, Format.error, 2);\n+    }\n+}\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%s\", idx, asterisk) == Format.s);\n-    assert(idx == 2);\n+@(\"parseScanfFormatSpecifier\") unittest\n+{\n+    size_t idx;\n+    bool asterisk;\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%ls\", idx, asterisk,) == Format.ls);\n-    assert(idx == 3);\n+    void testS(string fmtStr, Format expectedFormat, size_t expectedIdx)\n+    {\n+        idx = 0;\n+        assert(parseScanfFormatSpecifier(fmtStr, idx, asterisk) == expectedFormat);\n+        assert(idx == expectedIdx);\n+    }\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%%\", idx, asterisk) == Format.percent);\n-    assert(idx == 2);\n+    // one for each Format\n+    testS(\"%d\", Format.d, 2);\n+    testS(\"%hhd\", Format.hhd, 4);\n+    testS(\"%hd\", Format.hd, 3);\n+    testS(\"%ld\", Format.ld, 3);\n+    testS(\"%lld\", Format.lld, 4);\n+    testS(\"%jd\", Format.jd, 3);\n+    testS(\"%zd\", Format.zd, 3);\n+    testS(\"%td\", Format.td, 3);\n+    testS(\"%u\", Format.u, 2);\n+    testS(\"%hhu\", Format.hhu, 4);\n+    testS(\"%hu\", Format.hu, 3);\n+    testS(\"%lu\", Format.lu, 3);\n+    testS(\"%llu\", Format.llu, 4);\n+    testS(\"%ju\", Format.ju, 3);\n+    testS(\"%g\", Format.g, 2);\n+    testS(\"%lg\", Format.lg, 3);\n+    testS(\"%Lg\", Format.Lg, 3);\n+    testS(\"%p\", Format.p, 2);\n+    testS(\"%s\", Format.s, 2);\n+    testS(\"%ls\", Format.ls, 3);\n+    testS(\"%%\", Format.percent, 2);\n \n     // Synonyms\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%i\", idx, asterisk) == Format.d);\n-    assert(idx == 2);\n+    testS(\"%i\", Format.d, 2);\n+    testS(\"%n\", Format.n, 2);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%n\", idx, asterisk) == Format.n);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%o\", idx, asterisk) == Format.u);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%x\", idx, asterisk) == Format.u);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%f\", idx, asterisk) == Format.g);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%e\", idx, asterisk) == Format.g);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%a\", idx, asterisk) == Format.g);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%c\", idx, asterisk) == Format.c);\n-    assert(idx == 2);\n+    testS(\"%o\", Format.u, 2);\n+    testS(\"%x\", Format.u, 2);\n+    testS(\"%f\", Format.g, 2);\n+    testS(\"%e\", Format.g, 2);\n+    testS(\"%a\", Format.g, 2);\n+    testS(\"%c\", Format.c, 2);\n \n     // asterisk\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%*d\", idx, asterisk) == Format.d);\n-    assert(idx == 3);\n+    testS(\"%*d\", Format.d, 3);\n     assert(asterisk);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%9ld\", idx, asterisk) == Format.ld);\n-    assert(idx == 4);\n+    testS(\"%9ld\", Format.ld, 4);\n     assert(!asterisk);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%*25984hhd\", idx, asterisk) == Format.hhd);\n-    assert(idx == 10);\n+    testS(\"%*25984hhd\", Format.hhd, 10);\n     assert(asterisk);\n \n     // scansets\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%[a-zA-Z]\", idx, asterisk) == Format.s);\n-    assert(idx == 9);\n+    testS(\"%[a-zA-Z]\", Format.s, 9);\n     assert(!asterisk);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%*25l[a-z]\", idx, asterisk) == Format.ls);\n-    assert(idx == 10);\n+    testS(\"%*25l[a-z]\", Format.ls, 10);\n     assert(asterisk);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%[]]\", idx, asterisk) == Format.s);\n-    assert(idx == 4);\n+    testS(\"%[]]\", Format.s, 4);\n     assert(!asterisk);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%[^]]\", idx, asterisk) == Format.s);\n-    assert(idx == 5);\n+    testS(\"%[^]]\", Format.s, 5);\n     assert(!asterisk);\n \n     // Too short formats\n     foreach (s; [\"%\", \"% \", \"%#\", \"%0\", \"%*\", \"%1\", \"%19\",\n                  \"%j\", \"%z\", \"%t\", \"%l\", \"%h\", \"%ll\", \"%hh\", \"%K\"])\n     {\n-        idx = 0;\n-        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n-        assert(idx == s.length);\n+\n+        testS(s, Format.error, s.length);\n     }\n \n \n@@ -1468,18 +1292,16 @@ unittest\n                  \"%jp\", \"%zp\", \"%tp\", \"%Lp\", \"%hp\", \"%lp\", \"%hhp\", \"%llp\",\n                  \"%-\", \"%+\", \"%#\", \"%0\", \"%.\", \"%Ln\"])\n     {\n-        idx = 0;\n-        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n-        assert(idx == s.length);\n+\n+        testS(s, Format.error, s.length);\n \n     }\n \n     // Invalid scansets\n     foreach (s; [\"%[]\", \"%[^\", \"%[^]\", \"%[s\", \"%[0-9lld\", \"%[\", \"%l[^]\"])\n     {\n-        idx = 0;\n-        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n-        assert(idx == s.length);\n+\n+        testS(s, Format.error, s.length);\n     }\n \n     // Posix extensions\n@@ -1488,95 +1310,19 @@ unittest\n                  \"%LC\", \"%lC\", \"%llC\", \"%jC\", \"%tC\", \"%hC\", \"%hhC\", \"%zC\",\n                  \"%LS\", \"%lS\", \"%llS\", \"%jS\", \"%tS\", \"%hS\", \"%hhS\", \"%zS\"])\n     {\n-        idx = 0;\n-        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n-        assert(idx == s.length);\n-    }\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%mc\", idx, asterisk) == Format.POSIX_ms);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%ms\", idx, asterisk) == Format.POSIX_ms);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%m[0-9]\", idx, asterisk) == Format.POSIX_ms);\n-    assert(idx == 7);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%mlc\", idx, asterisk) == Format.POSIX_mls);\n-    assert(idx == 4);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%mls\", idx, asterisk) == Format.POSIX_mls);\n-    assert(idx == 4);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%ml[^0-9]\", idx, asterisk) == Format.POSIX_mls);\n-    assert(idx == 9);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%mC\", idx, asterisk) == Format.POSIX_mls);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%mS\", idx, asterisk) == Format.POSIX_mls);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parsePrintfFormatSpecifier(\"%C\", idx, widthStar, precisionStar) == Format.lc);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%C\", idx, asterisk) == Format.lc);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parsePrintfFormatSpecifier(\"%S\", idx, widthStar, precisionStar) == Format.ls);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%S\", idx, asterisk) == Format.ls);\n-    assert(idx == 2);\n-\n-    // GNU extensions: explicitly toggle ISO/GNU flag.\n-    // ISO printf()\n-    bool useGNUExts = false;\n-    {\n-        foreach (s; [\"%jm\", \"%zm\", \"%tm\", \"%Lm\", \"%hm\", \"%hhm\", \"%lm\", \"%llm\",\n-                     \"%#m\", \"%+m\", \"%-m\", \"% m\", \"%0m\"])\n-        {\n-            idx = 0;\n-            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.error);\n-            assert(idx == s.length);\n-        }\n-        foreach (s; [\"%m\", \"%md\", \"%mz\", \"%mc\", \"%mm\", \"%msyz\", \"%ml\", \"%mlz\", \"%mlc\", \"%mlm\"])\n-        {\n-            idx = 0;\n-            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.error);\n-            assert(idx == 2);\n-        }\n+        testS(s, Format.error, s.length);\n     }\n \n-    // GNU printf()\n-    useGNUExts = true;\n-    {\n-        foreach (s; [\"%jm\", \"%zm\", \"%tm\", \"%Lm\", \"%hm\", \"%hhm\", \"%lm\", \"%llm\",\n-                     \"%#m\", \"%+m\", \"%-m\", \"% m\", \"%0m\"])\n-        {\n-            idx = 0;\n-            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.error);\n-            assert(idx == s.length);\n-        }\n-\n-        // valid cases, all parsed as `%m`\n-        foreach (s; [\"%m\", \"%md\", \"%mz\", \"%mc\", \"%mm\", \"%msyz\", \"%ml\", \"%mlz\", \"%mlc\", \"%mlm\"])\n-        {\n-            idx = 0;\n-            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.GNU_m);\n-            assert(idx == 2);\n-        }\n-    }\n+    testS(\"%mc\", Format.POSIX_ms, 3);\n+    testS(\"%ms\", Format.POSIX_ms, 3);\n+    testS(\"%m[0-9]\", Format.POSIX_ms, 7);\n+    testS(\"%mlc\", Format.POSIX_mls, 4);\n+    testS(\"%mls\", Format.POSIX_mls, 4);\n+    testS(\"%ml[^0-9]\", Format.POSIX_mls, 9);\n+    testS(\"%mC\", Format.POSIX_mls, 3);\n+    testS(\"%mS\", Format.POSIX_mls, 3);\n+\n+    testS(\"%C\", Format.lc, 2);\n+    testS(\"%S\", Format.ls, 2);\n }"}, {"sha": "ba7d590b5530209d7ae9c37c60b866fb5cee9b34", "filename": "gcc/d/dmd/clone.d", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fclone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fclone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -105,8 +105,7 @@ FuncDeclaration hasIdentityOpAssign(AggregateDeclaration ad, Scope* sc)\n         scope er = new NullExp(ad.loc, ad.type);    // dummy rvalue\n         scope el = new IdentifierExp(ad.loc, Id.p); // dummy lvalue\n         el.type = ad.type;\n-        Expressions a;\n-        a.setDim(1);\n+        auto a = Expressions(1);\n         const errors = global.startGagging(); // Do not report errors, even if the template opAssign fbody makes it.\n         sc = sc.push();\n         sc.tinst = null;\n@@ -465,8 +464,7 @@ private FuncDeclaration hasIdentityOpEquals(AggregateDeclaration ad, Scope* sc)\n          */\n         scope er = new NullExp(ad.loc, null); // dummy rvalue\n         scope el = new IdentifierExp(ad.loc, Id.p); // dummy lvalue\n-        Expressions a;\n-        a.setDim(1);\n+        auto a = Expressions(1);\n \n         bool hasIt(Type tthis)\n         {"}, {"sha": "2c5a4f0e76ddb91049f56c8bf17199f1d9d51f43", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1886,15 +1886,6 @@ final class CParser(AST) : Parser!AST\n             }\n             if (s !is null)\n             {\n-                s = applySpecifier(s, specifier);\n-                if (level == LVL.local)\n-                {\n-                    // Wrap the declaration in `extern (C) { declaration }`\n-                    // Necessary for function pointers, but harmless to apply to all.\n-                    auto decls = new AST.Dsymbols(1);\n-                    (*decls)[0] = s;\n-                    s = new AST.LinkDeclaration(s.loc, linkage, decls);\n-                }\n                 // Saw `asm(\"name\")` in the function, type, or variable definition.\n                 // This is equivalent to `pragma(mangle, \"name\")` in D\n                 if (asmName)\n@@ -1917,6 +1908,15 @@ final class CParser(AST) : Parser!AST\n                         p.mangleOverride = str;\n                     }\n                 }\n+                s = applySpecifier(s, specifier);\n+                if (level == LVL.local)\n+                {\n+                    // Wrap the declaration in `extern (C) { declaration }`\n+                    // Necessary for function pointers, but harmless to apply to all.\n+                    auto decls = new AST.Dsymbols(1);\n+                    (*decls)[0] = s;\n+                    s = new AST.LinkDeclaration(s.loc, linkage, decls);\n+                }\n                 symbols.push(s);\n             }\n             first = false;\n@@ -2603,7 +2603,6 @@ final class CParser(AST) : Parser!AST\n     {\n         //printf(\"cparseDeclarator(%d, %p)\\n\", declarator, t);\n         AST.Types constTypes; // all the Types that will need `const` applied to them\n-        constTypes.setDim(0);\n \n         AST.Type parseDecl(AST.Type t)\n         {"}, {"sha": "8ab3873aa33fbd60cd1f1badc5f5a2b1bf689080", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2979,10 +2979,10 @@ Lagain:\n             return Lret(t);\n \n         if (t1n.ty == Tvoid) // pointers to void are always compatible\n-            return Lret(t2);\n+            return Lret(t1);\n \n         if (t2n.ty == Tvoid)\n-            return Lret(t);\n+            return Lret(t2);\n \n         if (t1.implicitConvTo(t2))\n             return convert(e1, t2);"}, {"sha": "5bce6b0060bbc9e5b8736a0f4d325ffd452aa711", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -210,7 +210,7 @@ class OverDeclaration final : public Declaration\n     Dsymbol *aliassym;\n \n     const char *kind() const override;\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     bool overloadInsert(Dsymbol *s) override;\n \n     Dsymbol *toAlias() override;\n@@ -625,7 +625,7 @@ class FuncDeclaration : public Declaration\n     FuncDeclaration *syntaxCopy(Dsymbol *) override;\n     bool functionSemantic();\n     bool functionSemantic3();\n-    bool equals(const RootObject *o) const override final;\n+    bool equals(const RootObject * const o) const override final;\n \n     int overrides(FuncDeclaration *fd);\n     int findVtblIndex(Dsymbols *vtbl, int dim);"}, {"sha": "705acd1c98f2aa232d165f0d390167f36e19edb9", "filename": "gcc/d/dmd/dimport.d", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdimport.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdimport.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdimport.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -265,11 +265,16 @@ extern (C++) final class Import : Dsymbol\n             scopesym.addAccessiblePackage(p, visibility);\n             foreach (id; packages[1 .. $]) // [b, c]\n             {\n-                p = cast(Package) p.symtab.lookup(id);\n+                auto sym = p.symtab.lookup(id);\n                 // https://issues.dlang.org/show_bug.cgi?id=17991\n                 // An import of truly empty file/package can happen\n                 // https://issues.dlang.org/show_bug.cgi?id=20151\n                 // Package in the path conflicts with a module name\n+                if (sym is null)\n+                    break;\n+                // https://issues.dlang.org/show_bug.cgi?id=23327\n+                // Package conflicts with symbol of the same name\n+                p = sym.isPackage();\n                 if (p is null)\n                     break;\n                 scopesym.addAccessiblePackage(p, visibility);"}, {"sha": "a95d9dee88dc89134c4fbd292b8c533ec2450097", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2830,7 +2830,7 @@ public:\n                         (*exps)[i] = ex;\n                     }\n                 }\n-                sd.fill(e.loc, exps, false);\n+                sd.fill(e.loc, *exps, false);\n \n                 auto se = ctfeEmplaceExp!StructLiteralExp(e.loc, sd, exps, e.newtype);\n                 se.origin = se;\n@@ -4778,12 +4778,6 @@ public:\n             // If `_d_HookTraceImpl` is found, resolve the underlying hook and replace `e` and `fd` with it.\n             removeHookTraceImpl(e, fd);\n \n-            bool isArrayConstructionOrAssign(FuncDeclaration fd)\n-            {\n-                return fd.ident == Id._d_arrayctor || fd.ident == Id._d_arraysetctor ||\n-                fd.ident == Id._d_arrayassign_l || fd.ident == Id._d_arrayassign_r;\n-            }\n-\n             if (fd.ident == Id.__ArrayPostblit || fd.ident == Id.__ArrayDtor)\n             {\n                 assert(e.arguments.dim == 1);\n@@ -4837,11 +4831,11 @@ public:\n                 result = interpretRegion(ae, istate);\n                 return;\n             }\n-            else if (isArrayConstructionOrAssign(fd))\n+            else if (isArrayConstructionOrAssign(fd.ident))\n             {\n                 // In expressionsem.d, the following lowerings were performed:\n                 // * `T[x] ea = eb;` to `_d_array{,set}ctor(ea[], eb[]);`.\n-                // * `ea = eb` (ea and eb are arrays) to `_d_arrayassign_{l,r}(ea[], eb[])`.\n+                // * `ea = eb` to `_d_array{,setassign,assign_l,assign_r}(ea[], eb)`.\n                 // The following code will rewrite them back to `ea = eb` and\n                 // then interpret that expression.\n "}, {"sha": "be0cbccc7c6551b4fc890178933dfc81e797b35b", "filename": "gcc/d/dmd/dmangle.d", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -833,6 +833,23 @@ public:\n                 printf(\"  parent = %s %s\", s.parent.kind(), s.parent.toChars());\n             printf(\"\\n\");\n         }\n+        if (s.parent && s.ident)\n+        {\n+            if (auto m = s.parent.isModule())\n+            {\n+                if (m.filetype == FileType.c)\n+                {\n+                    /* C types at global level get mangled into the __C global namespace\n+                     * to get the same mangling regardless of which module it\n+                     * is declared in. This works because types are the same if the mangling\n+                     * is the same.\n+                     */\n+                    mangleIdentifier(Id.ImportC, s); // parent\n+                    mangleIdentifier(s.ident, s);\n+                    return;\n+                }\n+            }\n+        }\n         mangleParent(s);\n         if (s.ident)\n             mangleIdentifier(s.ident, s);"}, {"sha": "e1d589769fe47eb33d05ae35bc44e321289399fb", "filename": "gcc/d/dmd/doc.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdoc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdoc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3294,7 +3294,7 @@ private struct MarkdownLink\n      * Params:\n      *  buf   = an OutBuffer containing the DDoc\n      *  i     = the index within `buf` that points to the first character of the URL.\n-     *          If this function succeeds `i` will point just after the the end of the URL.\n+     *          If this function succeeds `i` will point just after the end of the URL.\n      * Returns: whether a URL was found and parsed\n      */\n     private bool parseHref(ref OutBuffer buf, ref size_t i)\n@@ -3362,7 +3362,7 @@ private struct MarkdownLink\n      * Params:\n      *  buf   = an OutBuffer containing the DDoc\n      *  i     = the index within `buf` that points to the first character of the title.\n-     *          If this function succeeds `i` will point just after the the end of the title.\n+     *          If this function succeeds `i` will point just after the end of the title.\n      * Returns: whether a title was found and parsed\n      */\n     private bool parseTitle(ref OutBuffer buf, ref size_t i)"}, {"sha": "7e2d02f06bf3ac063a360e8e72c001f75877bbf9", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1544,6 +1544,12 @@ public:\n \n                         if (flags & IgnoreAmbiguous) // if return NULL on ambiguity\n                             return null;\n+\n+                        /* If two imports from C import files, pick first one, as C has global name space\n+                         */\n+                        if (s.isCsymbol() && s2.isCsymbol())\n+                            continue;\n+\n                         if (!(flags & IgnoreErrors))\n                             ScopeDsymbol.multiplyDefined(loc, s, s2);\n                         break;"}, {"sha": "acf0004eb80e7525206192b2d8fd517085b820c8", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -189,7 +189,7 @@ class Dsymbol : public ASTNode\n     virtual const char *toPrettyCharsHelper(); // helper to print fully qualified (template) arguments\n     Loc getLoc();\n     const char *locToChars();\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     bool isAnonymous() const;\n     void error(const Loc &loc, const char *format, ...);\n     void error(const char *format, ...);"}, {"sha": "701f06aadeed3fbae9d7281152f12fb47025730a", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -58,6 +58,7 @@ import dmd.nspace;\n import dmd.objc;\n import dmd.opover;\n import dmd.parse;\n+import dmd.root.array;\n import dmd.root.filename;\n import dmd.common.outbuffer;\n import dmd.root.rmem;\n@@ -983,7 +984,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 // possibilities.\n                 if (fd && !(dsym.storage_class & (STC.manifest | STC.static_ | STC.gshared | STC.extern_)) && !dsym._init.isVoidInitializer())\n                 {\n-                    //printf(\"fd = '%s', var = '%s'\\n\", fd.toChars(), toChars());\n+                    //printf(\"fd = '%s', var = '%s'\\n\", fd.toChars(), dsym.toChars());\n                     if (!ei)\n                     {\n                         ArrayInitializer ai = dsym._init.isArrayInitializer();\n@@ -1014,24 +1015,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         dsym._init = dsym._init.initializerSemantic(sc, dsym.type, INITinterpret);\n                     }\n \n-                    Expression exp = ei.exp;\n-                    Expression e1 = new VarExp(dsym.loc, dsym);\n-                    if (isBlit)\n-                        exp = new BlitExp(dsym.loc, e1, exp);\n-                    else\n-                        exp = new ConstructExp(dsym.loc, e1, exp);\n-                    dsym.canassign++;\n-                    exp = exp.expressionSemantic(sc);\n-                    dsym.canassign--;\n-                    exp = exp.optimize(WANTvalue);\n-                    if (exp.op == EXP.error)\n-                    {\n-                        dsym._init = new ErrorInitializer();\n-                        ei = null;\n-                    }\n-                    else\n-                        ei.exp = exp;\n-\n                     if (ei && dsym.isScope())\n                     {\n                         Expression ex = ei.exp.lastComma();\n@@ -1054,6 +1037,24 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                                 f.tookAddressOf--;\n                         }\n                     }\n+\n+                    Expression exp = ei.exp;\n+                    Expression e1 = new VarExp(dsym.loc, dsym);\n+                    if (isBlit)\n+                        exp = new BlitExp(dsym.loc, e1, exp);\n+                    else\n+                        exp = new ConstructExp(dsym.loc, e1, exp);\n+                    dsym.canassign++;\n+                    exp = exp.expressionSemantic(sc);\n+                    dsym.canassign--;\n+                    exp = exp.optimize(WANTvalue);\n+                    if (exp.op == EXP.error)\n+                    {\n+                        dsym._init = new ErrorInitializer();\n+                        ei = null;\n+                    }\n+                    else\n+                        ei.exp = exp;\n                 }\n                 else\n                 {\n@@ -1956,7 +1957,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         //printf(\"UserAttributeDeclaration::semantic() %p\\n\", this);\n         if (uad.decl && !uad._scope)\n             uad.Dsymbol.setScope(sc); // for function local symbols\n-        arrayExpressionSemantic(uad.atts, sc, true);\n+        arrayExpressionSemantic(uad.atts.peekSlice(), sc, true);\n         return attribSemantic(uad);\n     }\n \n@@ -4182,6 +4183,13 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             dd.errors = true;\n             return;\n         }\n+\n+        if (ad.isClassDeclaration() && ad.classKind == ClassKind.d)\n+        {\n+            // Class destructors are implicitly `scope`\n+            dd.storage_class |= STC.scope_;\n+        }\n+\n         if (dd.ident == Id.dtor && dd.semanticRun < PASS.semantic)\n             ad.userDtors.push(dd);\n         if (!dd.type)"}, {"sha": "13efc1cba3fee29d842c25659a4fdad5ea7a2e2f", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1327,7 +1327,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         Loc instLoc = ti.loc;\n         Objects* tiargs = ti.tiargs;\n-        auto dedargs = new Objects();\n+        auto dedargs = new Objects(parameters.dim);\n         Objects* dedtypes = &ti.tdtypes; // for T:T*, the dedargs is the T*, dedtypes is the T\n \n         version (none)\n@@ -1346,7 +1346,6 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         assert(_scope);\n \n-        dedargs.setDim(parameters.dim);\n         dedargs.zero();\n \n         dedtypes.setDim(parameters.dim);\n@@ -1511,7 +1510,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n             }\n         }\n \n-        if (toParent().isModule() || (_scope.stc & STC.static_))\n+        if (toParent().isModule())\n             tthis = null;\n         if (tthis)\n         {\n@@ -1534,7 +1533,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n             }\n \n             // Match attributes of tthis against attributes of fd\n-            if (fd.type && !fd.isCtorDeclaration())\n+            if (fd.type && !fd.isCtorDeclaration() && !(_scope.stc & STC.static_))\n             {\n                 StorageClass stc = _scope.stc | fd.storage_class2;\n                 // Propagate parent storage class, https://issues.dlang.org/show_bug.cgi?id=5504\n@@ -2716,14 +2715,27 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n         if (mfa == MATCH.nomatch)\n             return 0;\n \n-        if (mfa > m.last) goto LfIsBetter;\n-        if (mfa < m.last) goto LlastIsBetter;\n+        int firstIsBetter()\n+        {\n+            td_best = null;\n+            ti_best = null;\n+            ta_last = MATCH.exact;\n+            m.last = mfa;\n+            m.lastf = fd;\n+            tthis_best = tthis_fd;\n+            ov_index = 0;\n+            m.count = 1;\n+            return 0;\n+        }\n+\n+        if (mfa > m.last) return firstIsBetter();\n+        if (mfa < m.last) return 0;\n \n         /* See if one of the matches overrides the other.\n          */\n         assert(m.lastf);\n-        if (m.lastf.overrides(fd)) goto LlastIsBetter;\n-        if (fd.overrides(m.lastf)) goto LfIsBetter;\n+        if (m.lastf.overrides(fd)) return 0;\n+        if (fd.overrides(m.lastf)) return firstIsBetter();\n \n         /* Try to disambiguate using template-style partial ordering rules.\n          * In essence, if f() and g() are ambiguous, if f() can call g(),\n@@ -2734,8 +2746,8 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             MATCH c1 = fd.leastAsSpecialized(m.lastf);\n             MATCH c2 = m.lastf.leastAsSpecialized(fd);\n             //printf(\"c1 = %d, c2 = %d\\n\", c1, c2);\n-            if (c1 > c2) goto LfIsBetter;\n-            if (c1 < c2) goto LlastIsBetter;\n+            if (c1 > c2) return firstIsBetter();\n+            if (c1 < c2) return 0;\n         }\n \n         /* The 'overrides' check above does covariant checking only\n@@ -2756,12 +2768,12 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             {\n                 if (firstCovariant != Covariant.yes && firstCovariant != Covariant.no)\n                 {\n-                    goto LlastIsBetter;\n+                    return 0;\n                 }\n             }\n             else if (firstCovariant == Covariant.yes || firstCovariant == Covariant.no)\n             {\n-                goto LfIsBetter;\n+                return firstIsBetter();\n             }\n         }\n \n@@ -2780,37 +2792,22 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             fd._linkage == m.lastf._linkage)\n         {\n             if (fd.fbody && !m.lastf.fbody)\n-                goto LfIsBetter;\n+                return firstIsBetter();\n             if (!fd.fbody)\n-                goto LlastIsBetter;\n+                return 0;\n         }\n \n         // https://issues.dlang.org/show_bug.cgi?id=14450\n         // Prefer exact qualified constructor for the creating object type\n         if (isCtorCall && tf.mod != m.lastf.type.mod)\n         {\n-            if (tthis.mod == tf.mod) goto LfIsBetter;\n-            if (tthis.mod == m.lastf.type.mod) goto LlastIsBetter;\n+            if (tthis.mod == tf.mod) return firstIsBetter();\n+            if (tthis.mod == m.lastf.type.mod) return 0;\n         }\n \n         m.nextf = fd;\n         m.count++;\n         return 0;\n-\n-    LlastIsBetter:\n-        return 0;\n-\n-    LfIsBetter:\n-        td_best = null;\n-        ti_best = null;\n-        ta_last = MATCH.exact;\n-        m.last = mfa;\n-        m.lastf = fd;\n-        tthis_best = tthis_fd;\n-        ov_index = 0;\n-        m.count = 1;\n-        return 0;\n-\n     }\n \n     int applyTemplate(TemplateDeclaration td)\n@@ -3844,10 +3841,20 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                         tp = (*parameters)[i];\n                     else\n                     {\n+                        Loc loc;\n+                        // The \"type\" (it hasn't been resolved yet) of the function parameter\n+                        // does not have a location but the parameter it is related to does,\n+                        // so we use that for the resolution (better error message).\n+                        if (inferStart < parameters.dim)\n+                        {\n+                            TemplateParameter loctp = (*parameters)[inferStart];\n+                            loc = loctp.loc;\n+                        }\n+\n                         Expression e;\n                         Type tx;\n                         Dsymbol s;\n-                        taa.index.resolve(Loc.initial, sc, e, tx, s);\n+                        taa.index.resolve(loc, sc, e, tx, s);\n                         edim = s ? getValue(s) : getValue(e);\n                     }\n                 }"}, {"sha": "7ba0a96aa0a350d5dff511235fc36d6bff434e11", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1423,10 +1423,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n                  *   auto dg = () return { return &x; }\n                  * Because dg.ptr points to x, this is returning dt.ptr+offset\n                  */\n-                if (global.params.useDIP1000 == FeatureState.enabled)\n-                {\n-                    sc.func.storage_class |= STC.return_ | STC.returninferred;\n-                }\n+                sc.func.storage_class |= STC.return_ | STC.returninferred;\n             }\n         }\n "}, {"sha": "42b4dd45c09cca40188a26fdac00c23f5c7f4550", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -7197,6 +7197,26 @@ extern(D) Modifiable checkModifiable(Expression exp, Scope* sc, ModifyFlags flag\n     }\n }\n \n+/**\n+ * Verify if the given identifier is any of\n+ * _d_array{ctor,setctor,setassign,assign_l, assign_r}.\n+ *\n+ * Params:\n+ *  id = the identifier to verify\n+ *\n+ * Returns:\n+ *  `true` if the identifier corresponds to a construction of assignement\n+ *  runtime hook, `false` otherwise.\n+ */\n+bool isArrayConstructionOrAssign(const Identifier id)\n+{\n+    import dmd.id : Id;\n+\n+    return id == Id._d_arrayctor || id == Id._d_arraysetctor ||\n+        id == Id._d_arrayassign_l || id == Id._d_arrayassign_r ||\n+        id == Id._d_arraysetassign;\n+}\n+\n /******************************\n  * Provide efficient way to implement isUnaExp(), isBinExp(), isBinAssignExp()\n  */"}, {"sha": "c9e3978710687037ff4e471f27b878a35485ae58", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -250,7 +250,7 @@ class IntegerExp final : public Expression\n \n     static IntegerExp *create(const Loc &loc, dinteger_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, dinteger_t value, Type *type);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     dinteger_t toInteger() override;\n     real_t toReal() override;\n     real_t toImaginary() override;\n@@ -280,7 +280,7 @@ class RealExp final : public Expression\n \n     static RealExp *create(const Loc &loc, real_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, real_t value, Type *type);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     dinteger_t toInteger() override;\n     uinteger_t toUInteger() override;\n     real_t toReal() override;\n@@ -297,7 +297,7 @@ class ComplexExp final : public Expression\n \n     static ComplexExp *create(const Loc &loc, complex_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, complex_t value, Type *type);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     dinteger_t toInteger() override;\n     uinteger_t toUInteger() override;\n     real_t toReal() override;\n@@ -358,7 +358,7 @@ class SuperExp final : public ThisExp\n class NullExp final : public Expression\n {\n public:\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     Optional<bool> toBool() override;\n     StringExp *toStringExp() override;\n     void accept(Visitor *v) override { v->visit(this); }\n@@ -377,7 +377,7 @@ class StringExp final : public Expression\n     static StringExp *create(const Loc &loc, const char *s);\n     static StringExp *create(const Loc &loc, const void *s, d_size_t len);\n     static void emplace(UnionExp *pue, const Loc &loc, const char *s);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     char32_t getCodeUnit(d_size_t i) const;\n     void setCodeUnit(d_size_t i, char32_t c);\n     StringExp *toStringExp() override;\n@@ -408,7 +408,7 @@ class TupleExp final : public Expression\n \n     static TupleExp *create(const Loc &loc, Expressions *exps);\n     TupleExp *syntaxCopy() override;\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n \n     void accept(Visitor *v) override { v->visit(this); }\n };\n@@ -423,7 +423,7 @@ class ArrayLiteralExp final : public Expression\n     static ArrayLiteralExp *create(const Loc &loc, Expressions *elements);\n     static void emplace(UnionExp *pue, const Loc &loc, Expressions *elements);\n     ArrayLiteralExp *syntaxCopy() override;\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     Expression *getElement(d_size_t i); // use opIndex instead\n     Expression *opIndex(d_size_t i);\n     Optional<bool> toBool() override;\n@@ -439,7 +439,7 @@ class AssocArrayLiteralExp final : public Expression\n     Expressions *values;\n     OwnedBy ownedByCtfe;\n \n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     AssocArrayLiteralExp *syntaxCopy() override;\n     Optional<bool> toBool() override;\n \n@@ -477,7 +477,7 @@ class StructLiteralExp final : public Expression\n     OwnedBy ownedByCtfe;\n \n     static StructLiteralExp *create(const Loc &loc, StructDeclaration *sd, void *elements, Type *stype = NULL);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     StructLiteralExp *syntaxCopy() override;\n     Expression *getField(Type *type, unsigned offset);\n     int getFieldIndex(Type *type, unsigned offset);\n@@ -583,7 +583,7 @@ class VarExp final : public SymbolExp\n public:\n     bool delegateWasExtracted;\n     static VarExp *create(const Loc &loc, Declaration *var, bool hasOverloads = true);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     bool isLvalue() override;\n     Expression *toLvalue(Scope *sc, Expression *e) override;\n     Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n@@ -612,7 +612,7 @@ class FuncExp final : public Expression\n     TemplateDeclaration *td;\n     TOK tok;\n \n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     FuncExp *syntaxCopy() override;\n     const char *toChars() const override;\n     bool checkType() override;"}, {"sha": "8a4a13ce1335461a69244707a638d65eba7625be", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -62,6 +62,7 @@ import dmd.opover;\n import dmd.optimize;\n import dmd.parse;\n import dmd.printast;\n+import dmd.root.array;\n import dmd.root.ctfloat;\n import dmd.root.file;\n import dmd.root.filename;\n@@ -336,22 +337,18 @@ Expression resolveOpDollar(Scope* sc, ArrayExp ae, IntervalExp ie, Expression* p\n /******************************\n  * Perform semantic() on an array of Expressions.\n  */\n-bool arrayExpressionSemantic(Expressions* exps, Scope* sc, bool preserveErrors = false)\n+extern(D) bool arrayExpressionSemantic(\n+    Expression[] exps, Scope* sc, bool preserveErrors = false)\n {\n     bool err = false;\n-    if (exps)\n+    foreach (ref e; exps)\n     {\n-        foreach (ref e; *exps)\n-        {\n-            if (e)\n-            {\n-                auto e2 = e.expressionSemantic(sc);\n-                if (e2.op == EXP.error)\n-                    err = true;\n-                if (preserveErrors || e2.op != EXP.error)\n-                    e = e2;\n-            }\n-        }\n+        if (e is null) continue;\n+        auto e2 = e.expressionSemantic(sc);\n+        if (e2.op == EXP.error)\n+            err = true;\n+        if (preserveErrors || e2.op != EXP.error)\n+            e = e2;\n     }\n     return err;\n }\n@@ -443,7 +440,7 @@ private Expression searchUFCS(Scope* sc, UnaExp ue, Identifier ident)\n     }\n \n     if (!s)\n-        return ue.e1.type.getProperty(sc, loc, ident, 0);\n+        return ue.e1.type.getProperty(sc, loc, ident, 0, ue.e1);\n \n     FuncDeclaration f = s.isFuncDeclaration();\n     if (f)\n@@ -550,7 +547,7 @@ private Expression resolveUFCS(Scope* sc, CallExp ce)\n                     if (!global.endGagging(errors))\n                         return e;\n \n-                    if (arrayExpressionSemantic(originalArguments, sc))\n+                    if (arrayExpressionSemantic(originalArguments.peekSlice(), sc))\n                         return ErrorExp.get();\n \n                     /* fall down to UFCS */\n@@ -3111,7 +3108,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         if (e.basis)\n             e.basis = e.basis.expressionSemantic(sc);\n-        if (arrayExpressionSemantic(e.elements, sc) || (e.basis && e.basis.op == EXP.error))\n+        if (arrayExpressionSemantic(e.elements.peekSlice(), sc) || (e.basis && e.basis.op == EXP.error))\n             return setError();\n \n         expandTuples(e.elements);\n@@ -3154,8 +3151,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n \n         // Run semantic() on each element\n-        bool err_keys = arrayExpressionSemantic(e.keys, sc);\n-        bool err_vals = arrayExpressionSemantic(e.values, sc);\n+        bool err_keys = arrayExpressionSemantic(e.keys.peekSlice(), sc);\n+        bool err_vals = arrayExpressionSemantic(e.values.peekSlice(), sc);\n         if (err_keys || err_vals)\n             return setError();\n \n@@ -3201,7 +3198,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return setError();\n \n         // run semantic() on each element\n-        if (arrayExpressionSemantic(e.elements, sc))\n+        if (arrayExpressionSemantic(e.elements.peekSlice(), sc))\n             return setError();\n \n         expandTuples(e.elements);\n@@ -3213,7 +3210,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         /* Fill out remainder of elements[] with default initializers for fields[]\n          */\n-        if (!e.sd.fill(e.loc, e.elements, false))\n+        if (!e.sd.fill(e.loc, *e.elements, false))\n         {\n             /* An error in the initializer needs to be recorded as an error\n              * in the enclosing function or template, since the initializer\n@@ -3524,7 +3521,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         exp.newtype = exp.type; // in case type gets cast to something else\n         Type tb = exp.type.toBasetype();\n         //printf(\"tb: %s, deco = %s\\n\", tb.toChars(), tb.deco);\n-        if (arrayExpressionSemantic(exp.arguments, sc))\n+        if (arrayExpressionSemantic(exp.arguments.peekSlice(), sc))\n         {\n             return setError();\n         }\n@@ -3672,7 +3669,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 }\n             }\n \n-            if (cd.disableNew)\n+            if (cd.disableNew && !exp.onstack)\n             {\n                 exp.error(\"cannot allocate `class %s` with `new` because it is annotated with `@disable new()`\",\n                           originalNewtype.toChars());\n@@ -3807,7 +3804,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 if (!sd.fit(exp.loc, sc, exp.arguments, tb))\n                     return setError();\n \n-                if (!sd.fill(exp.loc, exp.arguments, false))\n+                if (!sd.fill(exp.loc, *exp.arguments, false))\n                     return setError();\n \n                 if (checkFrameAccess(exp.loc, sc, sd, exp.arguments ? exp.arguments.dim : 0))\n@@ -4259,7 +4256,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n         if (FuncExp fe = exp.e1.isFuncExp())\n         {\n-            if (arrayExpressionSemantic(exp.arguments, sc) || preFunctionParameters(sc, exp.arguments))\n+            if (arrayExpressionSemantic(exp.arguments.peekSlice(), sc) ||\n+                preFunctionParameters(sc, exp.arguments))\n                 return setError();\n \n             // Run e1 semantic even if arguments have any errors\n@@ -4497,7 +4495,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             result = exp.e1;\n             return;\n         }\n-        if (arrayExpressionSemantic(exp.arguments, sc) || preFunctionParameters(sc, exp.arguments))\n+        if (arrayExpressionSemantic(exp.arguments.peekSlice(), sc) ||\n+            preFunctionParameters(sc, exp.arguments))\n             return setError();\n \n         // Check for call operator overload\n@@ -4543,7 +4542,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                         goto Lx;\n \n                     auto sle = new StructLiteralExp(exp.loc, sd, null, exp.e1.type);\n-                    if (!sd.fill(exp.loc, sle.elements, true))\n+                    if (!sd.fill(exp.loc, *sle.elements, true))\n                         return setError();\n                     if (checkFrameAccess(exp.loc, sc, sd, sle.elements.dim))\n                         return setError();\n@@ -4614,7 +4613,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             {\n                 Expression e;\n \n-                // Make sure to use the the enum type itself rather than its\n+                // Make sure to use the enum type itself rather than its\n                 // base type\n                 // https://issues.dlang.org/show_bug.cgi?id=16346\n                 if (exp.e1.type.ty == Tenum)\n@@ -8661,7 +8660,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (sd.isNested())\n         {\n             auto sle = new StructLiteralExp(loc, sd, null, t);\n-            if (!sd.fill(loc, sle.elements, true))\n+            if (!sd.fill(loc, *sle.elements, true))\n                 return ErrorExp.get();\n             if (checkFrameAccess(loc, sc, sd, sle.elements.dim))\n                 return ErrorExp.get();\n@@ -9991,38 +9990,41 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n     }\n \n     /***************************************\n-     * Lower AssignExp to `_d_arrayassign_{l,r}` if needed.\n+     * Lower AssignExp to `_d_array{setassign,assign_l,assign_r}` if needed.\n      *\n      * Params:\n      *      ae = the AssignExp to be lowered\n      *      fromCommaExp = indicates whether `ae` is part of a CommaExp or not,\n      *                     so no unnecessary temporay variable is created.\n      * Returns:\n-     *      a CommaExp contiaining call a to `_d_arrayassign_{l,r}` if needed or\n-     *      `ae` otherwise\n+     *      a CommaExp contiaining call a to `_d_array{setassign,assign_l,assign_r}`\n+     *      if needed or `ae` otherwise\n      */\n     private Expression lowerArrayAssign(AssignExp ae, bool fromCommaExp = false)\n     {\n         Type t1b = ae.e1.type.toBasetype();\n         if (t1b.ty != Tsarray && t1b.ty != Tarray)\n             return ae;\n \n-        const isArrayAssign =\n-            (ae.e1.isSliceExp || ae.e1.type.ty == Tsarray) &&\n+        const isArrayAssign = (ae.e1.isSliceExp() || ae.e1.type.ty == Tsarray) &&\n             (ae.e2.type.ty == Tsarray || ae.e2.type.ty == Tarray) &&\n-            (ae.e1.type.nextOf && ae.e2.type.nextOf && ae.e1.type.nextOf.mutableOf.equals(ae.e2.type.nextOf.mutableOf));\n+            (ae.e1.type.nextOf() && ae.e2.type.nextOf() && ae.e1.type.nextOf.mutableOf.equals(ae.e2.type.nextOf.mutableOf()));\n \n-        if (!isArrayAssign)\n+        const isArraySetAssign = (ae.e1.isSliceExp() || ae.e1.type.ty == Tsarray) &&\n+            (ae.e1.type.nextOf() && ae.e2.type.implicitConvTo(ae.e1.type.nextOf()));\n+\n+        if (!isArrayAssign && !isArraySetAssign)\n             return ae;\n \n         const ts = t1b.nextOf().baseElemOf().isTypeStruct();\n         if (!ts || (!ts.sym.postblit && !ts.sym.dtor))\n             return ae;\n \n         Expression res;\n-        auto func = ae.e2.isLvalue || ae.e2.isSliceExp ? Id._d_arrayassign_l : Id._d_arrayassign_r;\n+        Identifier func = isArraySetAssign ? Id._d_arraysetassign :\n+            ae.e2.isLvalue() || ae.e2.isSliceExp() ? Id._d_arrayassign_l : Id._d_arrayassign_r;\n \n-        // Lower to `.object._d_arrayassign_l{r}(e1, e2)``\n+        // Lower to `.object._d_array{setassign,assign_l,assign_r}(e1, e2)``\n         Expression id = new IdentifierExp(ae.loc, Id.empty);\n         id = new DotIdExp(ae.loc, id, Id.object);\n         id = new DotIdExp(ae.loc, id, func);\n@@ -10032,10 +10034,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             .expressionSemantic(sc));\n \n         Expression eValue2, value2 = ae.e2;\n-        if (ae.e2.isLvalue)\n-            value2 = new CastExp(ae.loc, ae.e2, ae.e2.type.nextOf.arrayOf)\n+        if (isArrayAssign && value2.isLvalue())\n+            value2 = new CastExp(ae.loc, ae.e2, ae.e2.type.nextOf.arrayOf())\n                 .expressionSemantic(sc);\n-        else if (!fromCommaExp)\n+        else if (!fromCommaExp &&\n+            (isArrayAssign || (isArraySetAssign && !value2.isLvalue())))\n         {\n             // Rvalues from CommaExps were introduced in `visit(AssignExp)`\n             // and are temporary variables themselves. Rvalues from trivial\n@@ -10044,15 +10047,20 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             // `__assigntmp` will be destroyed together with the array `ae.e1`.\n             // When `ae.e2` is a variadic arg array, it is also `scope`, so\n             // `__assigntmp` may also be scope.\n-            auto vd = copyToTemp(STC.rvalue | STC.nodtor | STC.scope_, \"__assigntmp\", ae.e2);\n+            StorageClass stc = STC.nodtor;\n+            if (isArrayAssign)\n+                stc |= STC.rvalue | STC.scope_;\n+\n+            auto vd = copyToTemp(stc, \"__assigntmp\", ae.e2);\n             eValue2 = new DeclarationExp(vd.loc, vd).expressionSemantic(sc);\n             value2 = new VarExp(vd.loc, vd).expressionSemantic(sc);\n         }\n         arguments.push(value2);\n \n         Expression ce = new CallExp(ae.loc, id, arguments);\n         res = Expression.combine(eValue2, ce).expressionSemantic(sc);\n-        res = Expression.combine(res, ae.e1).expressionSemantic(sc);\n+        if (isArrayAssign)\n+            res = Expression.combine(res, ae.e1).expressionSemantic(sc);\n \n         if (global.params.verbose)\n             message(\"lowered   %s =>\\n          %s\", ae.toChars(), res.toChars());"}, {"sha": "bcae282f09fcb71bbfb3c93040f2aa569273df8b", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3216,11 +3216,12 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n         }\n     }\n \n-    if (tiargs && arrayObjectIsError(tiargs) ||\n-        fargs && arrayObjectIsError(cast(Objects*)fargs))\n-    {\n+    if (tiargs && arrayObjectIsError(tiargs))\n         return null;\n-    }\n+    if (fargs !is null)\n+        foreach (arg; *fargs)\n+            if (isError(arg))\n+                return null;\n \n     MatchAccumulator m;\n     functionResolve(m, s, loc, sc, tiargs, tthis, fargs, null);\n@@ -3758,9 +3759,9 @@ extern (C++) final class FuncLiteralDeclaration : FuncDeclaration\n     // backend\n     bool deferToObj;\n \n-    extern (D) this(const ref Loc loc, const ref Loc endloc, Type type, TOK tok, ForeachStatement fes, Identifier id = null)\n+    extern (D) this(const ref Loc loc, const ref Loc endloc, Type type, TOK tok, ForeachStatement fes, Identifier id = null, StorageClass storage_class = STC.undefined_)\n     {\n-        super(loc, endloc, null, STC.undefined_, type);\n+        super(loc, endloc, null, storage_class, type);\n         this.ident = id ? id : Id.empty;\n         this.tok = tok;\n         this.fes = fes;\n@@ -3774,7 +3775,7 @@ extern (C++) final class FuncLiteralDeclaration : FuncDeclaration\n     {\n         //printf(\"FuncLiteralDeclaration::syntaxCopy('%s')\\n\", toChars());\n         assert(!s);\n-        auto f = new FuncLiteralDeclaration(loc, endloc, type.syntaxCopy(), tok, fes, ident);\n+        auto f = new FuncLiteralDeclaration(loc, endloc, type.syntaxCopy(), tok, fes, ident, storage_class & STC.auto_);\n         f.treq = treq; // don't need to copy\n         FuncDeclaration.syntaxCopy(f);\n         return f;\n@@ -3833,9 +3834,7 @@ extern (C++) final class FuncLiteralDeclaration : FuncDeclaration\n             {\n                 Expression exp = s.exp;\n                 if (exp && !exp.type.equals(tret))\n-                {\n-                    s.exp = exp.castTo(sc, tret);\n-                }\n+                    s.exp = exp.implicitCastTo(sc, tret);\n             }\n         }\n "}, {"sha": "7a840ffa585546cff398837b147ea8b7c0d33adc", "filename": "gcc/d/dmd/iasmgcc.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasmgcc.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -84,13 +84,10 @@ int parseExtAsmOperands(Parser)(Parser p, GccAsmStatement s)\n \n             case TOK.string_:\n                 constraint = p.parsePrimaryExp();\n-                // @@@DEPRECATED_2.101@@@\n-                // Old parser allowed omitting parentheses around the expression.\n-                // Deprecated in 2.091. Can be made permanent error after 2.100\n                 if (p.token.value != TOK.leftParenthesis)\n                 {\n                     arg = p.parseAssignExp();\n-                    deprecation(arg.loc, \"`%s` must be surrounded by parentheses\", arg.toChars());\n+                    error(arg.loc, \"`%s` must be surrounded by parentheses\", arg.toChars());\n                 }\n                 else\n                 {\n@@ -527,6 +524,9 @@ unittest\n         // Found ',' when expecting ':'\n         q{ asm { \"\", \"\";\n         } },\n+\n+        // https://issues.dlang.org/show_bug.cgi?id=20593\n+        q{ asm { \"instruction\" : : \"operand\" 123; } },\n     ];\n \n     foreach (test; passAsmTests)"}, {"sha": "48ca7665eaef365602a5a67dd6ff1f50c231ed84", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -319,6 +319,7 @@ immutable Msgtable[] msgtable =\n     { \"_aaApply2\" },\n     { \"_d_arrayctor\" },\n     { \"_d_arraysetctor\" },\n+    { \"_d_arraysetassign\" },\n     { \"_d_arrayassign_l\" },\n     { \"_d_arrayassign_r\" },\n \n@@ -511,6 +512,7 @@ immutable Msgtable[] msgtable =\n     { \"wchar_t\" },\n \n     // for C compiler\n+    { \"ImportC\", \"__C\" },\n     { \"__tag\" },\n     { \"dllimport\" },\n     { \"dllexport\" },"}, {"sha": "523b5b820d759b53df147cf90ddd632901dc15be", "filename": "gcc/d/dmd/init.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Finit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Finit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -167,6 +167,7 @@ extern (C++) final class ArrayInitializer : Initializer\n     uint dim;               // length of array being initialized\n     Type type;              // type that array will be used to initialize\n     bool sem;               // true if semantic() is run\n+    bool isCarray;          // C array semantics\n \n     extern (D) this(const ref Loc loc)\n     {"}, {"sha": "977157f5c41434764501edd70f7c4b983ad6bf34", "filename": "gcc/d/dmd/init.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Finit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Finit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.h?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -78,6 +78,7 @@ class ArrayInitializer final : public Initializer\n     unsigned dim;       // length of array being initialized\n     Type *type;         // type that array will be used to initialize\n     bool sem;           // true if semantic() is run\n+    bool isCarray;      // C array semantics\n \n     bool isAssociativeArray() const;\n     Expression *toAssocArrayLiteral();"}, {"sha": "ef39f594d88b5d7e28480d515a7f5ede64a9c002", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 325, "deletions": 228, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -225,7 +225,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 assert(sc);\n                 auto tm = vd.type.addMod(t.mod);\n                 auto iz = i.value[j].initializerSemantic(sc, tm, needInterpret);\n-                auto ex = iz.initializerToExpression();\n+                auto ex = iz.initializerToExpression(null, (sc.flags & SCOPE.Cfile) != 0);\n                 if (ex.op == EXP.error)\n                 {\n                     errors = true;\n@@ -243,7 +243,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n \n             // Make a StructLiteralExp out of elements[]\n             auto sle = new StructLiteralExp(i.loc, sd, elements, t);\n-            if (!sd.fill(i.loc, elements, false))\n+            if (!sd.fill(i.loc, *elements, false))\n                 return err();\n             sle.type = t;\n             auto ie = new ExpInitializer(i.loc, sle);\n@@ -272,7 +272,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         uint length;\n         const(uint) amax = 0x80000000;\n         bool errors = false;\n-        //printf(\"ArrayInitializer::semantic(%s)\\n\", t.toChars());\n+        //printf(\"ArrayInitializer::semantic(%s), ai: %s %p\\n\", t.toChars(), i.toChars(), i);\n         if (i.sem) // if semantic() already run\n         {\n             return i;\n@@ -374,11 +374,22 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         }\n         if (auto tsa = t.isTypeSArray())\n         {\n-            uinteger_t edim = tsa.dim.toInteger();\n-            if (i.dim > edim && !(tsa.isIncomplete() && (sc.flags & SCOPE.Cfile)))\n+            if (sc.flags & SCOPE.Cfile && tsa.isIncomplete())\n             {\n-                error(i.loc, \"array initializer has %u elements, but array length is %llu\", i.dim, edim);\n-                return err();\n+                // Change to array of known length\n+                auto tn = tsa.next.toBasetype();\n+                tsa = new TypeSArray(tn, new IntegerExp(Loc.initial, i.dim, Type.tsize_t));\n+                tx = tsa;      // rewrite caller's type\n+                i.type = tsa;  // remember for later passes\n+            }\n+            else\n+            {\n+                uinteger_t edim = tsa.dim.toInteger();\n+                if (i.dim > edim)\n+                {\n+                    error(i.loc, \"array initializer has %u elements, but array length is %llu\", i.dim, edim);\n+                    return err();\n+                }\n             }\n         }\n         if (errors)\n@@ -394,6 +405,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             error(i.loc, \"array dimension %llu exceeds max of %llu\", ulong(i.dim), ulong(amax / sz));\n             return err();\n         }\n+        //printf(\"returns ai: %s\\n\", i.toChars());\n         return i;\n     }\n \n@@ -661,295 +673,380 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n \n     Initializer visitC(CInitializer ci)\n     {\n-        if (ci.sem) // if semantic() already run\n-            return ci;\n         //printf(\"CInitializer::semantic() (%s) %s\\n\", t.toChars(), ci.toChars());\n-        ci.sem = true;\n+        /* Rewrite CInitializer into ExpInitializer, ArrayInitializer, or StructInitializer\n+         */\n         t = t.toBasetype();\n-        ci.type = t;    // later passes will need this\n-\n-        auto dil = ci.initializerList[];\n-        size_t i = 0;   // index into dil[]\n-        const uint amax = 0x8000_0000;\n-        bool errors;\n \n         /* If `{ expression }` return the expression initializer\n          */\n         ExpInitializer isBraceExpression()\n         {\n+            auto dil = ci.initializerList[];\n             return (dil.length == 1 && !dil[0].designatorList)\n                     ? dil[0].initializer.isExpInitializer()\n                     : null;\n         }\n \n-        /* Convert struct initializer into ExpInitializer\n+        /********************************\n          */\n-        Initializer structs(TypeStruct ts)\n+        bool overlaps(VarDeclaration field, VarDeclaration[] fields, StructInitializer si)\n         {\n-            //printf(\"structs %s\\n\", ts.toChars());\n+            foreach (fld; fields)\n+            {\n+                if (field.isOverlappedWith(fld))\n+                {\n+                    // look for initializer corresponding with fld\n+                    foreach (i, ident; si.field[])\n+                    {\n+                        if (ident == fld.ident && si.value[i])\n+                            return true;   // already an initializer for `field`\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /* Run semantic on ExpInitializer, see if it represents entire struct ts\n+         */\n+        bool representsStruct(ExpInitializer ei, TypeStruct ts)\n+        {\n+            if (needInterpret)\n+                sc = sc.startCTFE();\n+            ei.exp = ei.exp.expressionSemantic(sc);\n+            ei.exp = resolveProperties(sc, ei.exp);\n+            if (needInterpret)\n+                sc = sc.endCTFE();\n+            return ei.exp.implicitConvTo(ts) != MATCH.nomatch; // initializer represents the entire struct\n+        }\n+\n+        /* If { } are omitted from substructs, use recursion to reconstruct where\n+         * brackets go\n+         * Params:\n+         *  ts = substruct to initialize\n+         *  index = index into ci.initializer, updated\n+         * Returns: struct initializer for this substruct\n+         */\n+        Initializer subStruct()(TypeStruct ts, ref size_t index)\n+        {\n+            //printf(\"subStruct(ts: %s, index %d)\\n\", ts.toChars(), cast(int)index);\n+\n+            auto si = new StructInitializer(ci.loc);\n             StructDeclaration sd = ts.sym;\n             sd.size(ci.loc);\n             if (sd.sizeok != Sizeok.done)\n             {\n-                errors = true;\n+                index = ci.initializerList.length;\n                 return err();\n             }\n-            const nfields = sd.nonHiddenFields();\n-            auto elements = new Expressions(nfields);\n-            auto elems = (*elements)[];\n-            foreach (ref elem; elems)\n-                elem = null;\n+            const nfields = sd.fields.length;\n \n-          FieldLoop:\n-            for (size_t fieldi = 0; fieldi < nfields; ++fieldi)\n+            foreach (fieldi; 0 .. nfields)\n             {\n-                if (i == dil.length)\n-                    break;\n-\n-                auto di = dil[i];\n-                if (di.designatorList)\n+                if (index >= ci.initializerList.length)\n+                    break;          // ran out of initializers\n+                auto di = ci.initializerList[index];\n+                if (di.designatorList && fieldi != 0)\n+                    break;          // back to top level\n+                else\n                 {\n-                    error(ci.loc, \"C designator-list not supported yet\");\n-                    errors = true;\n-                    break;\n+                    VarDeclaration field;\n+                    while (1)   // skip field if it overlaps with previously seen fields\n+                    {\n+                        field = sd.fields[fieldi];\n+                        ++fieldi;\n+                        if (!overlaps(field, sd.fields[], si))\n+                            break;\n+                        if (fieldi == nfields)\n+                            break;\n+                    }\n+                    auto tn = field.type.toBasetype();\n+                    auto tnsa = tn.isTypeSArray();\n+                    auto tns = tn.isTypeStruct();\n+                    auto ix = di.initializer;\n+                    if (tnsa && ix.isExpInitializer())\n+                    {\n+                        ExpInitializer ei = ix.isExpInitializer();\n+                        if (ei.exp.isStringExp() && tnsa.nextOf().isintegral())\n+                        {\n+                            si.addInit(field.ident, ei);\n+                            ++index;\n+                        }\n+                        else\n+                            si.addInit(field.ident, subArray(tnsa, index)); // fwd ref of subArray is why subStruct is a template\n+                    }\n+                    else if (tns && ix.isExpInitializer())\n+                    {\n+                        /* Disambiguate between an exp representing the entire\n+                         * struct, and an exp representing the first field of the struct\n+                         */\n+                        if (representsStruct(ix.isExpInitializer(), tns)) // initializer represents the entire struct\n+                        {\n+                            si.addInit(field.ident, initializerSemantic(ix, sc, tn, needInterpret));\n+                            ++index;\n+                        }\n+                        else                                // field initializers for struct\n+                            si.addInit(field.ident, subStruct(tns, index)); // the first field\n+                    }\n+                    else\n+                    {\n+                        si.addInit(field.ident, ix);\n+                        ++index;\n+                    }\n                 }\n+            }\n+            //printf(\"subStruct() returns ai: %s, index: %d\\n\", si.toChars(), cast(int)index);\n+            return si;\n+        }\n \n-                VarDeclaration vd = sd.fields[fieldi];\n+        /* If { } are omitted from subarrays, use recursion to reconstruct where\n+         * brackets go\n+         * Params:\n+         *  tsa = subarray to initialize\n+         *  index = index into ci.initializer, updated\n+         * Returns: array initializer for this subarray\n+         */\n+        Initializer subArray(TypeSArray tsa, ref size_t index)\n+        {\n+            //printf(\"array(tsa: %s, index %d)\\n\", tsa.toChars(), cast(int)index);\n+            if (tsa.isIncomplete())\n+            {\n+                // C11 6.2.5-20 \"element type shall be complete whenever the array type is specified\"\n+                assert(0); // should have been detected by parser\n+            }\n \n-                // Check for overlapping initializations (can happen with unions)\n-                foreach (k, v2; sd.fields[0 .. nfields])\n+            auto tnsa = tsa.nextOf().toBasetype().isTypeSArray();\n+\n+            auto ai = new ArrayInitializer(ci.loc);\n+            ai.isCarray = true;\n+\n+            foreach (n; 0 .. cast(size_t)tsa.dim.toInteger())\n+            {\n+                if (index >= ci.initializerList.length)\n+                    break;          // ran out of initializers\n+                auto di = ci.initializerList[index];\n+                if (di.designatorList)\n+                    break;          // back to top level\n+                else if (tnsa && di.initializer.isExpInitializer())\n                 {\n-                    if (vd.isOverlappedWith(v2) && elems[k])\n+                    ExpInitializer ei = di.initializer.isExpInitializer();\n+                    if (ei.exp.isStringExp() && tnsa.nextOf().isintegral())\n                     {\n-                        continue FieldLoop;     // skip it\n+                        ai.addInit(null, ei);\n+                        ++index;\n                     }\n+                    else\n+                        ai.addInit(null, subArray(tnsa, index));\n                 }\n-\n-                ++i;\n-\n-                // Convert initializer to Expression `ex`\n-                assert(sc);\n-                auto tm = vd.type.addMod(ts.mod);\n-                auto iz = di.initializer.initializerSemantic(sc, tm, needInterpret);\n-                auto ex = iz.initializerToExpression(null, true);\n-                if (ex.op == EXP.error)\n+                else\n                 {\n-                    errors = true;\n-                    continue;\n+                    ai.addInit(null, di.initializer);\n+                    ++index;\n                 }\n-\n-                elems[fieldi] = ex;\n             }\n-            if (errors)\n-                return err();\n-\n-            // Make a StructLiteralExp out of elements[]\n-            Type tx = ts;\n-            auto sle = new StructLiteralExp(ci.loc, sd, elements, tx);\n-            if (!sd.fill(ci.loc, elements, false))\n-                return err();\n-            sle.type = tx;\n-            auto ie = new ExpInitializer(ci.loc, sle);\n-            return ie.initializerSemantic(sc, tx, needInterpret);\n+            //printf(\"array() returns ai: %s, index: %d\\n\", ai.toChars(), cast(int)index);\n+            return ai;\n         }\n \n         if (auto ts = t.isTypeStruct())\n         {\n-            auto ei = structs(ts);\n-            if (errors)\n-                return err();\n-            if (i < dil.length)\n+            auto si = new StructInitializer(ci.loc);\n+            StructDeclaration sd = ts.sym;\n+            sd.size(ci.loc);            // run semantic() on sd to get fields\n+            if (sd.sizeok != Sizeok.done)\n             {\n-                error(ci.loc, \"%d extra initializer(s) for `struct %s`\", cast(int)(dil.length - i), ts.toChars());\n                 return err();\n             }\n-            return ei;\n-        }\n+            const nfields = sd.fields.length;\n \n-        auto tsa = t.isTypeSArray();\n-        if (!tsa)\n-        {\n-            /* Not an array. See if it is `{ exp }` which can be\n-             * converted to an ExpInitializer\n-             */\n-            if (ExpInitializer ei = isBraceExpression())\n-            {\n-                return ei.initializerSemantic(sc, t, needInterpret);\n-            }\n-\n-            error(ci.loc, \"C non-array initializer (%s) %s not supported yet\", t.toChars(), ci.toChars());\n-            return err();\n-        }\n+            size_t fieldi = 0;\n \n-        /* If it's an array of integral being initialized by `{ string }`\n-         * replace with `string`\n-         */\n-        auto tn = t.nextOf();\n-        if (tn.isintegral())\n-        {\n-            if (ExpInitializer ei = isBraceExpression())\n+            for (size_t index = 0; index < ci.initializerList.length; )\n             {\n-                if (ei.exp.isStringExp())\n-                    return ei.initializerSemantic(sc, t, needInterpret);\n+                auto di = ci.initializerList[index];\n+                auto dlist = di.designatorList;\n+                if (dlist)\n+                {\n+                    const length = (*dlist).length;\n+                    if (length == 0 || !(*dlist)[0].ident)\n+                    {\n+                        error(ci.loc, \"`.identifier` expected for C struct field initializer `%s`\", ci.toChars());\n+                        return err();\n+                    }\n+                    if (length > 1)\n+                    {\n+                        error(ci.loc, \"only 1 designator currently allowed for C struct field initializer `%s`\", ci.toChars());\n+                        return err();\n+                    }\n+                    auto id = (*dlist)[0].ident;\n+                    foreach (k, f; sd.fields[])         // linear search for now\n+                    {\n+                        if (f.ident == id)\n+                        {\n+                            fieldi = k;\n+                            si.addInit(id, di.initializer);\n+                            ++fieldi;\n+                            ++index;\n+                            break;\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    if (fieldi == nfields)\n+                        break;\n+                    VarDeclaration field;\n+                    while (1)   // skip field if it overlaps with previously seen fields\n+                    {\n+                        field = sd.fields[fieldi];\n+                        ++fieldi;\n+                        if (!overlaps(field, sd.fields[], si))\n+                            break;\n+                        if (fieldi == nfields)\n+                            break;\n+                    }\n+                    auto tn = field.type.toBasetype();\n+                    auto tnsa = tn.isTypeSArray();\n+                    auto tns = tn.isTypeStruct();\n+                    auto ix = di.initializer;\n+                    if (tnsa && ix.isExpInitializer())\n+                    {\n+                        ExpInitializer ei = ix.isExpInitializer();\n+                        if (ei.exp.isStringExp() && tnsa.nextOf().isintegral())\n+                        {\n+                            si.addInit(field.ident, ei);\n+                            ++index;\n+                        }\n+                        else\n+                            si.addInit(field.ident, subArray(tnsa, index));\n+                    }\n+                    else if (tns && ix.isExpInitializer())\n+                    {\n+                        /* Disambiguate between an exp representing the entire\n+                         * struct, and an exp representing the first field of the struct\n+                         */\n+                        if (representsStruct(ix.isExpInitializer(), tns)) // initializer represents the entire struct\n+                        {\n+                            si.addInit(field.ident, initializerSemantic(ix, sc, tn, needInterpret));\n+                            ++index;\n+                        }\n+                        else                                // field initializers for struct\n+                            si.addInit(field.ident, subStruct(tns, index)); // the first field\n+                    }\n+                    else\n+                    {\n+                        si.addInit(field.ident, di.initializer);\n+                        ++index;\n+                    }\n+                }\n             }\n+            return initializerSemantic(si, sc, t, needInterpret);\n         }\n-\n-        /* Support recursion to handle un-braced array initializers\n-         * Params:\n-         *    t = element type\n-         *    dim = max number of elements\n-         *    simple = true if array of simple elements\n-         * Returns:\n-         *    # of elements in array\n-         */\n-        size_t array(Type t, size_t dim, ref bool simple)\n+        else if (auto ta = t.isTypeSArray())\n         {\n-            //printf(\" type %s i %d dim %d dil.length = %d\\n\", t.toChars(), cast(int)i, cast(int)dim, cast(int)dil.length);\n-            auto tn = t.nextOf().toBasetype();\n-            auto tnsa = tn.isTypeSArray();\n-            if (tnsa && tnsa.isIncomplete())\n-            {\n-                // C11 6.2.5-20 \"element type shall be complete whenever the array type is specified\"\n-                error(ci.loc, \"incomplete element type `%s` not allowed\", tnsa.toChars());\n-                errors = true;\n-                return 1;\n-            }\n-            if (i == dil.length)\n-                return 0;\n-            size_t n;\n-            const nelems = tnsa ? cast(size_t)tnsa.dim.toInteger() : 0;\n+            auto tn = t.nextOf().toBasetype();  // element type of array\n \n-            /* Run initializerSemantic on a single element.\n+            /* If it's an array of integral being initialized by `{ string }`\n+             * replace with `string`\n              */\n-            Initializer elem(Initializer ie)\n+            if (tn.isintegral())\n             {\n-                ++i;\n-                auto tnx = tn; // in case initializerSemantic tries to change it\n-                ie = ie.initializerSemantic(sc, tnx, needInterpret);\n-                if (ie.isErrorInitializer())\n-                    errors = true;\n-                assert(tnx == tn); // sub-types should not be modified\n-                return ie;\n+                if (ExpInitializer ei = isBraceExpression())\n+                {\n+                    if (ei.exp.isStringExp())\n+                        return ei.initializerSemantic(sc, t, needInterpret);\n+                }\n             }\n \n-            foreach (j; 0 .. dim)\n+            auto tnsa = tn.isTypeSArray();      // array of array\n+            auto tns = tn.isTypeStruct();       // array of struct\n+\n+            auto ai = new ArrayInitializer(ci.loc);\n+            ai.isCarray = true;\n+            for (size_t index = 0; index < ci.initializerList.length; )\n             {\n-                auto di = dil[i];\n-                if (di.designatorList)\n-                {\n-                    error(ci.loc, \"C designator-list not supported yet\");\n-                    errors = true;\n-                    break;\n-                }\n-                if (tnsa && di.initializer.isExpInitializer())\n+                auto di = ci.initializerList[index];\n+                if (auto dlist = di.designatorList)\n                 {\n-                    // no braces enclosing array initializer, so recurse\n-                    array(tnsa, nelems, simple);\n-                }\n-                else if (auto tns = tn.isTypeStruct())\n-                {\n-                    if (auto ei = di.initializer.isExpInitializer())\n+                    const length = (*dlist).length;\n+                    if (length == 0 || !(*dlist)[0].exp)\n+                    {\n+                        error(ci.loc, \"`[ constant-expression ]` expected for C array element initializer `%s`\", ci.toChars());\n+                        return err();\n+                    }\n+                    if (length > 1)\n+                    {\n+                        error(ci.loc, \"only 1 designator currently allowed for C array element initializer `%s`\", ci.toChars());\n+                        return err();\n+                    }\n+                    //printf(\"tn: %s, di.initializer: %s\\n\", tn.toChars(), di.initializer.toChars());\n+                    auto ix = di.initializer;\n+                    if (tnsa && ix.isExpInitializer())\n+                    {\n+                        // Wrap initializer in [ ]\n+                        auto ain = new ArrayInitializer(ci.loc);\n+                        ain.addInit(null, di.initializer);\n+                        ix = ain;\n+                        ai.addInit((*dlist)[0].exp, initializerSemantic(ix, sc, tn, needInterpret));\n+                        ++index;\n+                    }\n+                    else if (tns && ix.isExpInitializer())\n                     {\n-                        // no braces enclosing struct initializer\n-\n                         /* Disambiguate between an exp representing the entire\n                          * struct, and an exp representing the first field of the struct\n-                        */\n-                        if (needInterpret)\n-                            sc = sc.startCTFE();\n-                        ei.exp = ei.exp.expressionSemantic(sc);\n-                        ei.exp = resolveProperties(sc, ei.exp);\n-                        if (needInterpret)\n-                            sc = sc.endCTFE();\n-                        if (ei.exp.implicitConvTo(tn))\n-                            di.initializer = elem(di.initializer); // the whole struct\n-                        else\n+                         */\n+                        if (representsStruct(ix.isExpInitializer(), tns)) // initializer represents the entire struct\n                         {\n-                            simple = false;\n-                            dil[n].initializer = structs(tns); // the first field\n+                            ai.addInit((*dlist)[0].exp, initializerSemantic(ix, sc, tn, needInterpret));\n+                            ++index;\n                         }\n+                        else                                // field initializers for struct\n+                            ai.addInit((*dlist)[0].exp, subStruct(tns, index)); // the first field\n+                    }\n+                    else\n+                    {\n+                        ai.addInit((*dlist)[0].exp, initializerSemantic(ix, sc, tn, needInterpret));\n+                        ++index;\n+                    }\n+                }\n+                else if (tnsa && di.initializer.isExpInitializer())\n+                {\n+                    ExpInitializer ei = di.initializer.isExpInitializer();\n+                    if (ei.exp.isStringExp() && tnsa.nextOf().isintegral())\n+                    {\n+                        ai.addInit(null, ei);\n+                        ++index;\n                     }\n                     else\n-                        dil[n].initializer = elem(di.initializer);\n+                        ai.addInit(null, subArray(tnsa, index));\n+                }\n+                else if (tns && di.initializer.isExpInitializer())\n+                {\n+                    /* Disambiguate between an exp representing the entire\n+                     * struct, and an exp representing the first field of the struct\n+                     */\n+                    if (representsStruct(di.initializer.isExpInitializer(), tns)) // initializer represents the entire struct\n+                    {\n+                        ai.addInit(null, initializerSemantic(di.initializer, sc, tn, needInterpret));\n+                        ++index;\n+                    }\n+                    else                                // field initializers for struct\n+                        ai.addInit(null, subStruct(tns, index)); // the first field\n                 }\n                 else\n                 {\n-                    di.initializer = elem(di.initializer);\n+                    ai.addInit(null, initializerSemantic(di.initializer, sc, tn, needInterpret));\n+                    ++index;\n                 }\n-                ++n;\n-                if (i == dil.length)\n-                    break;\n-            }\n-            //printf(\" n: %d i: %d\\n\", cast(int)n, cast(int)i);\n-            return n;\n-        }\n-\n-        size_t dim = tsa.isIncomplete() ? dil.length : cast(size_t)tsa.dim.toInteger();\n-        bool simple = true;\n-        auto newdim = array(t, dim, simple);\n-\n-        if (errors)\n-            return err();\n-\n-        if (tsa.isIncomplete()) // array of unknown length\n-        {\n-            // Change to array of known length\n-            tsa = new TypeSArray(tn, new IntegerExp(Loc.initial, newdim, Type.tsize_t));\n-            tx = tsa;       // rewrite caller's type\n-            ci.type = tsa;  // remember for later passes\n-        }\n-        const uinteger_t edim = tsa.dim.toInteger();\n-        if (i < dil.length)\n-        {\n-            error(ci.loc, \"%d extra initializer(s) for static array length of %d\", cast(int)(dil.length - i), cast(int)edim);\n-            return err();\n-        }\n-\n-        const sz = tn.size(); // element size\n-        if (sz == SIZE_INVALID)\n-            return err();\n-        bool overflow;\n-        const max = mulu(edim, sz, overflow);\n-        if (overflow || max >= amax)\n-        {\n-            error(ci.loc, \"array dimension %llu exceeds max of %llu\", ulong(edim), ulong(amax / sz));\n-            return err();\n-        }\n-\n-        /* If an array of simple elements, replace with an ArrayInitializer\n-         */\n-        auto tnb = tn.toBasetype();\n-        if (!tnb.isTypeSArray() && (!tnb.isTypeStruct() || simple))\n-        {\n-            auto ai = new ArrayInitializer(ci.loc);\n-            ai.dim = cast(uint) dil.length;\n-            ai.index.setDim(dil.length);\n-            ai.value.setDim(dil.length);\n-            foreach (const j; 0 .. dil.length)\n-            {\n-                ai.index[j] = null;\n-                ai.value[j] = dil[j].initializer;\n             }\n-            auto ty = tx;\n-            return ai.initializerSemantic(sc, ty, needInterpret);\n+            return initializerSemantic(ai, sc, tx, needInterpret);\n         }\n-\n-        if (newdim < ci.initializerList.length && tnb.isTypeStruct())\n+        else if (ExpInitializer ei = isBraceExpression())\n+            return visitExp(ei);\n+        else\n         {\n-            // https://issues.dlang.org/show_bug.cgi?id=22375\n-            // initializerList can be bigger than the number of actual elements\n-            // to initialize for array of structs because it is not required\n-            // for values to have proper bracing.\n-            // i.e: These are all valid initializers for `struct{int a,b;}[3]`:\n-            //      {1,2,3,4}, {{1,2},3,4}, {1,2,{3,4}}, {{1,2},{3,4}}\n-            // In all examples above, the new length of the initializer list\n-            // has been shortened from four elements to two. This is important,\n-            // because `dil` is written back to directly, making the lowered\n-            // initializer `{{1,2},{3,4}}` and not `{{1,2},{3,4},3,4}`.\n-            ci.initializerList.length = newdim;\n+            assert(0);\n         }\n-\n-        return ci;\n     }\n \n     final switch (init.kind)"}, {"sha": "1de89d4d6b60e0d0ee25fc45aa4ae3f0a955f5dd", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2582,8 +2582,13 @@ class Lexer\n         {\n             /* C11 6.4.4.2 doesn't actually care if it is not representable if it is not hex\n              */\n-            const char* suffix = (result == TOK.float32Literal || result == TOK.imaginary32Literal) ? \"f\" : \"\";\n-            error(scanloc, \"number `%s%s` is not representable\", sbufptr, suffix);\n+            const char* suffix = result == TOK.float32Literal ? \"f\" : result == TOK.float80Literal ? \"L\" : \"\";\n+            const char* type = [TOK.float32Literal: \"`float`\".ptr,\n+                                TOK.float64Literal: \"`double`\".ptr,\n+                                TOK.float80Literal: \"`real` for the current target\".ptr][result];\n+            error(scanloc, \"number `%s%s` is not representable as a %s\", sbufptr, suffix, type);\n+            const char* extra = result == TOK.float64Literal ? \"`real` literals can be written using the `L` suffix. \" : \"\";\n+            errorSupplemental(scanloc, \"%shttps://dlang.org/spec/lex.html#floatliteral\", extra);\n         }\n         debug\n         {"}, {"sha": "341ce361f3cc7f8fce709233c67c8c9aee69a7ae", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -37,7 +37,7 @@ class Package : public ScopeDsymbol\n \n     const char *kind() const override;\n \n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n \n     Package *isPackage() override final { return this; }\n "}, {"sha": "1240f5a8a9d40dd489cd16a5e754abe2e18f4743", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 349, "deletions": 300, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -936,7 +936,7 @@ extern (C++) abstract class Type : ASTNode\n         else\n         {\n             // If `typeSemantic` succeeded, there may have been deprecations that\n-            // were gagged due the the `startGagging` above.  Run again to display\n+            // were gagged due the `startGagging` above.  Run again to display\n             // those deprecations.  https://issues.dlang.org/show_bug.cgi?id=19107\n             if (global.gaggedWarnings > 0)\n                 typeSemantic(tcopy, loc, sc);\n@@ -4656,7 +4656,7 @@ extern (C++) final class TypeFunction : TypeNext\n                 // suppress early exit if an error message is wanted,\n                 // so we can check any matching args are valid\n                 if (!pMessage)\n-                    goto Nomatch;\n+                    return MATCH.nomatch;\n             }\n             // too many args; no match\n             match = MATCH.convert; // match ... with a \"conversion\" match level\n@@ -4669,7 +4669,7 @@ extern (C++) final class TypeFunction : TypeNext\n             buf.printf(\"too few arguments, expected `%d`, got `%d`\", cast(int)nparams, cast(int)nargs);\n             if (pMessage)\n                 *pMessage = buf.extractChars();\n-            goto Nomatch;\n+            return MATCH.nomatch;\n         }\n \n         foreach (u, p; parameterList)\n@@ -4710,226 +4710,16 @@ extern (C++) final class TypeFunction : TypeNext\n             MATCH m;\n \n             assert(p);\n-            if (u >= nargs)\n-            {\n-                if (p.defaultArg)\n-                    continue;\n-                // try typesafe variadics\n-                goto L1;\n-            }\n+\n+            // One or more arguments remain\n+            if (u < nargs)\n             {\n                 Expression arg = args[u];\n                 assert(arg);\n-                //printf(\"arg: %s, type: %s\\n\", arg.toChars(), arg.type.toChars());\n-\n-                Type targ = arg.type;\n-                Type tprm = wildmatch ? p.type.substWildTo(wildmatch) : p.type;\n-\n-                if (p.isLazy() && tprm.ty == Tvoid && targ.ty != Tvoid)\n-                    m = MATCH.convert;\n-                else\n-                {\n-                    //printf(\"%s of type %s implicitConvTo %s\\n\", arg.toChars(), targ.toChars(), tprm.toChars());\n-                    if (flag)\n-                    {\n-                        // for partial ordering, value is an irrelevant mockup, just look at the type\n-                        m = targ.implicitConvTo(tprm);\n-                    }\n-                    else\n-                    {\n-                        const isRef = p.isReference();\n-\n-                        StructDeclaration argStruct, prmStruct;\n-\n-                        // first look for a copy constructor\n-                        if (arg.isLvalue() && !isRef && targ.ty == Tstruct && tprm.ty == Tstruct)\n-                        {\n-                            // if the argument and the parameter are of the same unqualified struct type\n-                            argStruct = (cast(TypeStruct)targ).sym;\n-                            prmStruct = (cast(TypeStruct)tprm).sym;\n-                        }\n-\n-                        // check if the copy constructor may be called to copy the argument\n-                        if (argStruct && argStruct == prmStruct && argStruct.hasCopyCtor)\n-                        {\n-                            /* this is done by seeing if a call to the copy constructor can be made:\n-                             *\n-                             * typeof(tprm) __copytmp;\n-                             * copytmp.__copyCtor(arg);\n-                             */\n-                            auto tmp = new VarDeclaration(arg.loc, tprm, Identifier.generateId(\"__copytmp\"), null);\n-                            tmp.storage_class = STC.rvalue | STC.temp | STC.ctfe;\n-                            tmp.dsymbolSemantic(sc);\n-                            Expression ve = new VarExp(arg.loc, tmp);\n-                            Expression e = new DotIdExp(arg.loc, ve, Id.ctor);\n-                            e = new CallExp(arg.loc, e, arg);\n-                            //printf(\"e = %s\\n\", e.toChars());\n-                            if(.trySemantic(e, sc))\n-                                m = MATCH.exact;\n-                            else\n-                            {\n-                                if (pMessage)\n-                                {\n-                                    /* https://issues.dlang.org/show_bug.cgi?id=22202\n-                                     *\n-                                     * If a function was deduced by semantic on the CallExp,\n-                                     * it means that resolveFuncCall completed succesfully.\n-                                     * Therefore, there exists a callable copy constructor,\n-                                     * however, it cannot be called because scope constraints\n-                                     * such as purity, safety or nogc.\n-                                     */\n-                                    OutBuffer buf;\n-                                    auto callExp = e.isCallExp();\n-                                    if (auto f = callExp.f)\n-                                    {\n-                                        char[] s;\n-                                        if (!f.isPure && sc.func.setImpure())\n-                                            s ~= \"pure \";\n-                                        if (!f.isSafe() && !f.isTrusted() && sc.setUnsafe())\n-                                            s ~= \"@safe \";\n-                                        if (!f.isNogc && sc.func.setGC())\n-                                            s ~= \"nogc \";\n-                                        if (s)\n-                                        {\n-                                            s[$-1] = '\\0';\n-                                            buf.printf(\"`%s` copy constructor cannot be called from a `%s` context\", f.type.toChars(), s.ptr);\n-                                        }\n-                                        else if (f.isGenerated() && f.isDisabled())\n-                                        {\n-                                            /* https://issues.dlang.org/show_bug.cgi?id=23097\n-                                             * Compiler generated copy constructor failed.\n-                                             */\n-                                            buf.printf(\"generating a copy constructor for `struct %s` failed, therefore instances of it are uncopyable\",\n-                                                       argStruct.toChars());\n-                                        }\n-                                        else\n-                                        {\n-                                            /* Although a copy constructor may exist, no suitable match was found.\n-                                             * i.e: `inout` constructor creates `const` object, not mutable.\n-                                             * Fallback to using the original generic error before bugzilla 22202.\n-                                             */\n-                                            goto Lnocpctor;\n-                                        }\n-                                    }\n-                                    else\n-                                    {\n-                                    Lnocpctor:\n-                                        buf.printf(\"`struct %s` does not define a copy constructor for `%s` to `%s` copies\",\n-                                               argStruct.toChars(), targ.toChars(), tprm.toChars());\n-                                    }\n-\n-                                    *pMessage = buf.extractChars();\n-                                }\n-                                m = MATCH.nomatch;\n-                                goto Nomatch;\n-                            }\n-                        }\n-                        else\n-                        {\n-                            import dmd.dcast : cimplicitConvTo;\n-                            m = (sc && sc.flags & SCOPE.Cfile) ? arg.cimplicitConvTo(tprm) : arg.implicitConvTo(tprm);\n-                        }\n-                    }\n-                    //printf(\"match %d\\n\", m);\n-                }\n-\n-                // Non-lvalues do not match ref or out parameters\n-                if (p.isReference())\n-                {\n-                    // https://issues.dlang.org/show_bug.cgi?id=13783\n-                    // Don't use toBasetype() to handle enum types.\n-                    Type ta = targ;\n-                    Type tp = tprm;\n-                    //printf(\"fparam[%d] ta = %s, tp = %s\\n\", u, ta.toChars(), tp.toChars());\n-\n-                    if (m && !arg.isLvalue())\n-                    {\n-                        if (p.storageClass & STC.out_)\n-                        {\n-                            if (pMessage) *pMessage = getParamError(arg, p);\n-                            goto Nomatch;\n-                        }\n-\n-                        if (arg.op == EXP.string_ && tp.ty == Tsarray)\n-                        {\n-                            if (ta.ty != Tsarray)\n-                            {\n-                                Type tn = tp.nextOf().castMod(ta.nextOf().mod);\n-                                dinteger_t dim = (cast(StringExp)arg).len;\n-                                ta = tn.sarrayOf(dim);\n-                            }\n-                        }\n-                        else if (arg.op == EXP.slice && tp.ty == Tsarray)\n-                        {\n-                            // Allow conversion from T[lwr .. upr] to ref T[upr-lwr]\n-                            if (ta.ty != Tsarray)\n-                            {\n-                                Type tn = ta.nextOf();\n-                                dinteger_t dim = (cast(TypeSArray)tp).dim.toUInteger();\n-                                ta = tn.sarrayOf(dim);\n-                            }\n-                        }\n-                        else if ((p.storageClass & STC.in_) && global.params.previewIn)\n-                        {\n-                            // Allow converting a literal to an `in` which is `ref`\n-                            if (arg.op == EXP.arrayLiteral && tp.ty == Tsarray)\n-                            {\n-                                Type tn = tp.nextOf();\n-                                dinteger_t dim = (cast(TypeSArray)tp).dim.toUInteger();\n-                                ta = tn.sarrayOf(dim);\n-                            }\n-\n-                            // Need to make this a rvalue through a temporary\n-                            m = MATCH.convert;\n-                        }\n-                        else if (global.params.rvalueRefParam != FeatureState.enabled ||\n-                                 p.storageClass & STC.out_ ||\n-                                 !arg.type.isCopyable())  // can't copy to temp for ref parameter\n-                        {\n-                            if (pMessage) *pMessage = getParamError(arg, p);\n-                            goto Nomatch;\n-                        }\n-                        else\n-                        {\n-                            /* in functionParameters() we'll convert this\n-                             * rvalue into a temporary\n-                             */\n-                            m = MATCH.convert;\n-                        }\n-                    }\n-\n-                    /* If the match is not already perfect or if the arg\n-                       is not a lvalue then try the `alias this` chain\n-                       see  https://issues.dlang.org/show_bug.cgi?id=15674\n-                       and https://issues.dlang.org/show_bug.cgi?id=21905\n-                    */\n-                    if (ta != tp || !arg.isLvalue())\n-                    {\n-                        Type firsttab = ta.toBasetype();\n-                        while (1)\n-                        {\n-                            Type tab = ta.toBasetype();\n-                            Type tat = tab.aliasthisOf();\n-                            if (!tat || !tat.implicitConvTo(tprm))\n-                                break;\n-                            if (tat == tab || tat == firsttab)\n-                                break;\n-                            ta = tat;\n-                        }\n-                    }\n-\n-                    /* A ref variable should work like a head-const reference.\n-                     * e.g. disallows:\n-                     *  ref T      <- an lvalue of const(T) argument\n-                     *  ref T[dim] <- an lvalue of const(T[dim]) argument\n-                     */\n-                    if (!ta.constConv(tp))\n-                    {\n-                        if (pMessage) *pMessage = getParamError(arg, p);\n-                        goto Nomatch;\n-                    }\n-                }\n+                m = argumentMatchParameter(this, p, arg, wildmatch, flag, sc, pMessage);\n             }\n+            else if (p.defaultArg)\n+                continue;\n \n             /* prefer matching the element type rather than the array\n              * type when more arguments are present with T[]...\n@@ -4943,100 +4733,33 @@ extern (C++) final class TypeFunction : TypeNext\n             L1:\n                 if (parameterList.varargs == VarArg.typesafe && u + 1 == nparams) // if last varargs param\n                 {\n-                    Type tb = p.type.toBasetype();\n-                    TypeSArray tsa;\n-                    dinteger_t sz;\n-\n-                    switch (tb.ty)\n-                    {\n-                    case Tsarray:\n-                        tsa = cast(TypeSArray)tb;\n-                        sz = tsa.dim.toInteger();\n-                        if (sz != nargs - u)\n-                        {\n-                            if (pMessage)\n-                                // Windows (Vista) OutBuffer.vprintf issue? 2nd argument always zero\n-                                //*pMessage = getMatchError(\"expected %d variadic argument(s), not %d\", sz, nargs - u);\n-                            if (!global.gag || global.params.showGaggedErrors)\n-                            {\n-                                OutBuffer buf;\n-                                buf.printf(\"expected %llu variadic argument(s)\", sz);\n-                                buf.printf(\", not %zu\", nargs - u);\n-                                *pMessage = buf.extractChars();\n-                            }\n-                            goto Nomatch;\n-                        }\n-                        goto case Tarray;\n-                    case Tarray:\n-                        {\n-                            TypeArray ta = cast(TypeArray)tb;\n-                            foreach (arg; args[u .. nargs])\n-                            {\n-                                assert(arg);\n-\n-                                /* If lazy array of delegates,\n-                                 * convert arg(s) to delegate(s)\n-                                 */\n-                                Type tret = p.isLazyArray();\n-                                if (tret)\n-                                {\n-                                    if (ta.next.equals(arg.type))\n-                                        m = MATCH.exact;\n-                                    else if (tret.toBasetype().ty == Tvoid)\n-                                        m = MATCH.convert;\n-                                    else\n-                                    {\n-                                        m = arg.implicitConvTo(tret);\n-                                        if (m == MATCH.nomatch)\n-                                            m = arg.implicitConvTo(ta.next);\n-                                    }\n-                                }\n-                                else\n-                                    m = arg.implicitConvTo(ta.next);\n-\n-                                if (m == MATCH.nomatch)\n-                                {\n-                                    if (pMessage) *pMessage = getParamError(arg, p);\n-                                    goto Nomatch;\n-                                }\n-                                if (m < match)\n-                                    match = m;\n-                            }\n-                            goto Ldone;\n-                        }\n-                    case Tclass:\n-                        // Should see if there's a constructor match?\n-                        // Or just leave it ambiguous?\n-                        goto Ldone;\n-\n-                    default:\n-                        break;\n-                    }\n+                    auto trailingArgs = args[u .. $];\n+                    if (auto vmatch = matchTypeSafeVarArgs(this, p, trailingArgs, pMessage))\n+                        return vmatch < match ? vmatch : match;\n+                    // Error message was already generated in `matchTypeSafeVarArgs`\n+                    return MATCH.nomatch;\n                 }\n-                if (pMessage && u < nargs)\n-                    *pMessage = getParamError(args[u], p);\n-                else if (pMessage)\n+                if (pMessage && u >= nargs)\n                     *pMessage = getMatchError(\"missing argument for parameter #%d: `%s`\",\n                         u + 1, parameterToChars(p, this, false));\n-                goto Nomatch;\n+                // If an error happened previously, `pMessage` was already filled\n+                else if (pMessage && !*pMessage)\n+                    *pMessage = getParamError(args[u], p);\n+\n+                return MATCH.nomatch;\n             }\n             if (m < match)\n                 match = m; // pick worst match\n         }\n \n-    Ldone:\n         if (pMessage && !parameterList.varargs && nargs > nparams)\n         {\n             // all parameters had a match, but there are surplus args\n             *pMessage = getMatchError(\"expected %d argument(s), not %d\", nparams, nargs);\n-            goto Nomatch;\n+            return MATCH.nomatch;\n         }\n         //printf(\"match = %d\\n\", match);\n         return match;\n-\n-    Nomatch:\n-        //printf(\"no match\\n\");\n-        return MATCH.nomatch;\n     }\n \n     /+\n@@ -6194,6 +5917,11 @@ extern (C++) final class TypeClass : Type\n         if (t && t.ty == Tclass)\n         {\n             ClassDeclaration cd = (cast(TypeClass)t).sym;\n+            if (cd.semanticRun < PASS.semanticdone && !cd.isBaseInfoComplete())\n+                cd.dsymbolSemantic(null);\n+            if (sym.semanticRun < PASS.semanticdone && !sym.isBaseInfoComplete())\n+                sym.dsymbolSemantic(null);\n+\n             if (sym.isBaseOf(cd, poffset))\n                 return true;\n         }\n@@ -6355,10 +6083,9 @@ extern (C++) final class TypeTuple : Type\n     extern (D) this(Expressions* exps)\n     {\n         super(Ttuple);\n-        auto arguments = new Parameters();\n+        auto arguments = new Parameters(exps ? exps.dim : 0);\n         if (exps)\n         {\n-            arguments.setDim(exps.dim);\n             for (size_t i = 0; i < exps.dim; i++)\n             {\n                 Expression e = (*exps)[i];\n@@ -7330,3 +7057,325 @@ const(char)* toChars(ScopeRef sr) pure nothrow @nogc @safe\n         return names[sr];\n     }\n }\n+\n+/**\n+ * Used by `callMatch` to check if the copy constructor may be called to\n+ * copy the argument\n+ *\n+ * This is done by seeing if a call to the copy constructor can be made:\n+ * ```\n+ * typeof(tprm) __copytmp;\n+ * copytmp.__copyCtor(arg);\n+ * ```\n+ */\n+private extern(D) bool isCopyConstructorCallable (StructDeclaration argStruct,\n+    Expression arg, Type tprm, Scope* sc, const(char)** pMessage)\n+{\n+    auto tmp = new VarDeclaration(arg.loc, tprm, Identifier.generateId(\"__copytmp\"), null);\n+    tmp.storage_class = STC.rvalue | STC.temp | STC.ctfe;\n+    tmp.dsymbolSemantic(sc);\n+    Expression ve = new VarExp(arg.loc, tmp);\n+    Expression e = new DotIdExp(arg.loc, ve, Id.ctor);\n+    e = new CallExp(arg.loc, e, arg);\n+    //printf(\"e = %s\\n\", e.toChars());\n+    if (.trySemantic(e, sc))\n+        return true;\n+\n+    if (pMessage)\n+    {\n+        /* https://issues.dlang.org/show_bug.cgi?id=22202\n+         *\n+         * If a function was deduced by semantic on the CallExp,\n+         * it means that resolveFuncCall completed succesfully.\n+         * Therefore, there exists a callable copy constructor,\n+         * however, it cannot be called because scope constraints\n+         * such as purity, safety or nogc.\n+         */\n+        OutBuffer buf;\n+        auto callExp = e.isCallExp();\n+        if (auto f = callExp.f)\n+        {\n+            char[] s;\n+            if (!f.isPure && sc.func.setImpure())\n+                s ~= \"pure \";\n+            if (!f.isSafe() && !f.isTrusted() && sc.setUnsafe())\n+                s ~= \"@safe \";\n+            if (!f.isNogc && sc.func.setGC())\n+                s ~= \"nogc \";\n+            if (s)\n+            {\n+                s[$-1] = '\\0';\n+                buf.printf(\"`%s` copy constructor cannot be called from a `%s` context\", f.type.toChars(), s.ptr);\n+            }\n+            else if (f.isGenerated() && f.isDisabled())\n+            {\n+                /* https://issues.dlang.org/show_bug.cgi?id=23097\n+                 * Compiler generated copy constructor failed.\n+                 */\n+                buf.printf(\"generating a copy constructor for `struct %s` failed, therefore instances of it are uncopyable\",\n+                           argStruct.toChars());\n+            }\n+            else\n+            {\n+                /* Although a copy constructor may exist, no suitable match was found.\n+                 * i.e: `inout` constructor creates `const` object, not mutable.\n+                 * Fallback to using the original generic error before bugzilla 22202.\n+                 */\n+                goto Lnocpctor;\n+            }\n+        }\n+        else\n+        {\n+        Lnocpctor:\n+            buf.printf(\"`struct %s` does not define a copy constructor for `%s` to `%s` copies\",\n+                       argStruct.toChars(), arg.type.toChars(), tprm.toChars());\n+        }\n+\n+        *pMessage = buf.extractChars();\n+    }\n+    return false;\n+}\n+\n+/**\n+ * Match a single parameter to an argument.\n+ *\n+ * This function is called by `TypeFunction.callMatch` while iterating over\n+ * the list of parameter. Here we check if `arg` is a match for `p`,\n+ * which is mostly about checking if `arg.type` converts to `p`'s type\n+ * and some check about value reference.\n+ *\n+ * Params:\n+ *   tf = The `TypeFunction`, only used for error reporting\n+ *   p = The parameter of `tf` being matched\n+ *   arg = Argument being passed (bound) to `p`\n+ *   wildmatch = Wild (`inout`) matching level, derived from the full argument list\n+ *   flag = A non-zero value means we're doing a partial ordering check\n+ *          (no value semantic check)\n+ *   sc = Scope we are in\n+ *   pMessage = A buffer to write the error in, or `null`\n+ *\n+ * Returns: Whether `trailingArgs` match `p`.\n+ */\n+private extern(D) MATCH argumentMatchParameter (TypeFunction tf, Parameter p,\n+    Expression arg, ubyte wildmatch, int flag, Scope* sc, const(char)** pMessage)\n+{\n+    //printf(\"arg: %s, type: %s\\n\", arg.toChars(), arg.type.toChars());\n+    MATCH m;\n+    Type targ = arg.type;\n+    Type tprm = wildmatch ? p.type.substWildTo(wildmatch) : p.type;\n+\n+    if (p.isLazy() && tprm.ty == Tvoid && targ.ty != Tvoid)\n+        m = MATCH.convert;\n+    else if (flag)\n+    {\n+        // for partial ordering, value is an irrelevant mockup, just look at the type\n+        m = targ.implicitConvTo(tprm);\n+    }\n+    else\n+    {\n+        const isRef = p.isReference();\n+        StructDeclaration argStruct, prmStruct;\n+\n+        // first look for a copy constructor\n+        if (arg.isLvalue() && !isRef && targ.ty == Tstruct && tprm.ty == Tstruct)\n+        {\n+            // if the argument and the parameter are of the same unqualified struct type\n+            argStruct = (cast(TypeStruct)targ).sym;\n+            prmStruct = (cast(TypeStruct)tprm).sym;\n+        }\n+\n+        // check if the copy constructor may be called to copy the argument\n+        if (argStruct && argStruct == prmStruct && argStruct.hasCopyCtor)\n+        {\n+            if (!isCopyConstructorCallable(argStruct, arg, tprm, sc, pMessage))\n+                return MATCH.nomatch;\n+            m = MATCH.exact;\n+        }\n+        else\n+        {\n+            import dmd.dcast : cimplicitConvTo;\n+            m = (sc && sc.flags & SCOPE.Cfile) ? arg.cimplicitConvTo(tprm) : arg.implicitConvTo(tprm);\n+        }\n+    }\n+\n+    // Non-lvalues do not match ref or out parameters\n+    if (p.isReference())\n+    {\n+        // https://issues.dlang.org/show_bug.cgi?id=13783\n+        // Don't use toBasetype() to handle enum types.\n+        Type ta = targ;\n+        Type tp = tprm;\n+        //printf(\"fparam[%d] ta = %s, tp = %s\\n\", u, ta.toChars(), tp.toChars());\n+\n+        if (m && !arg.isLvalue())\n+        {\n+            if (p.storageClass & STC.out_)\n+            {\n+                if (pMessage) *pMessage = tf.getParamError(arg, p);\n+                return MATCH.nomatch;\n+            }\n+\n+            if (arg.op == EXP.string_ && tp.ty == Tsarray)\n+            {\n+                if (ta.ty != Tsarray)\n+                {\n+                    Type tn = tp.nextOf().castMod(ta.nextOf().mod);\n+                    dinteger_t dim = (cast(StringExp)arg).len;\n+                    ta = tn.sarrayOf(dim);\n+                }\n+            }\n+            else if (arg.op == EXP.slice && tp.ty == Tsarray)\n+            {\n+                // Allow conversion from T[lwr .. upr] to ref T[upr-lwr]\n+                if (ta.ty != Tsarray)\n+                {\n+                    Type tn = ta.nextOf();\n+                    dinteger_t dim = (cast(TypeSArray)tp).dim.toUInteger();\n+                    ta = tn.sarrayOf(dim);\n+                }\n+            }\n+            else if ((p.storageClass & STC.in_) && global.params.previewIn)\n+            {\n+                // Allow converting a literal to an `in` which is `ref`\n+                if (arg.op == EXP.arrayLiteral && tp.ty == Tsarray)\n+                {\n+                    Type tn = tp.nextOf();\n+                    dinteger_t dim = (cast(TypeSArray)tp).dim.toUInteger();\n+                    ta = tn.sarrayOf(dim);\n+                }\n+\n+                // Need to make this a rvalue through a temporary\n+                m = MATCH.convert;\n+            }\n+            else if (global.params.rvalueRefParam != FeatureState.enabled ||\n+                     p.storageClass & STC.out_ ||\n+                     !arg.type.isCopyable())  // can't copy to temp for ref parameter\n+            {\n+                if (pMessage) *pMessage = tf.getParamError(arg, p);\n+                return MATCH.nomatch;\n+            }\n+            else\n+            {\n+                /* in functionParameters() we'll convert this\n+                 * rvalue into a temporary\n+                 */\n+                m = MATCH.convert;\n+            }\n+        }\n+\n+        /* If the match is not already perfect or if the arg\n+           is not a lvalue then try the `alias this` chain\n+           see  https://issues.dlang.org/show_bug.cgi?id=15674\n+           and https://issues.dlang.org/show_bug.cgi?id=21905\n+        */\n+        if (ta != tp || !arg.isLvalue())\n+        {\n+            Type firsttab = ta.toBasetype();\n+            while (1)\n+            {\n+                Type tab = ta.toBasetype();\n+                Type tat = tab.aliasthisOf();\n+                if (!tat || !tat.implicitConvTo(tprm))\n+                    break;\n+                if (tat == tab || tat == firsttab)\n+                    break;\n+                ta = tat;\n+            }\n+        }\n+\n+        /* A ref variable should work like a head-const reference.\n+         * e.g. disallows:\n+         *  ref T      <- an lvalue of const(T) argument\n+         *  ref T[dim] <- an lvalue of const(T[dim]) argument\n+         */\n+        if (!ta.constConv(tp))\n+        {\n+            if (pMessage) *pMessage = tf.getParamError(arg, p);\n+            return MATCH.nomatch;\n+        }\n+    }\n+    return m;\n+}\n+\n+/**\n+ * Match the remaining arguments `trailingArgs` with parameter `p`.\n+ *\n+ * Assume we already checked that `p` is the last parameter of `tf`,\n+ * and we want to know whether the arguments would match `p`.\n+ *\n+ * Params:\n+ *   tf = The `TypeFunction`, only used for error reporting\n+ *   p = The last parameter of `tf` which is variadic\n+ *   trailingArgs = The remaining arguments that should match `p`\n+ *   pMessage = A buffer to write the error in, or `null`\n+ *\n+ * Returns: Whether `trailingArgs` match `p`.\n+ */\n+private extern(D) MATCH matchTypeSafeVarArgs(TypeFunction tf, Parameter p,\n+    Expression[] trailingArgs, const(char)** pMessage)\n+{\n+    Type tb = p.type.toBasetype();\n+\n+    switch (tb.ty)\n+    {\n+    case Tsarray:\n+        TypeSArray tsa = cast(TypeSArray)tb;\n+        dinteger_t sz = tsa.dim.toInteger();\n+        if (sz != trailingArgs.length)\n+        {\n+            if (pMessage)\n+                *pMessage = tf.getMatchError(\"expected %llu variadic argument(s), not %zu\",\n+                    sz, trailingArgs.length);\n+            return MATCH.nomatch;\n+        }\n+        goto case Tarray;\n+    case Tarray:\n+    {\n+        MATCH match = MATCH.exact;\n+        TypeArray ta = cast(TypeArray)tb;\n+        foreach (arg; trailingArgs)\n+        {\n+            MATCH m;\n+            assert(arg);\n+\n+            /* If lazy array of delegates,\n+             * convert arg(s) to delegate(s)\n+             */\n+            Type tret = p.isLazyArray();\n+            if (tret)\n+            {\n+                if (ta.next.equals(arg.type))\n+                    m = MATCH.exact;\n+                else if (tret.toBasetype().ty == Tvoid)\n+                    m = MATCH.convert;\n+                else\n+                {\n+                    m = arg.implicitConvTo(tret);\n+                    if (m == MATCH.nomatch)\n+                        m = arg.implicitConvTo(ta.next);\n+                }\n+            }\n+            else\n+                m = arg.implicitConvTo(ta.next);\n+\n+            if (m == MATCH.nomatch)\n+            {\n+                if (pMessage) *pMessage = tf.getParamError(arg, p);\n+                return MATCH.nomatch;\n+            }\n+            if (m < match)\n+                match = m;\n+        }\n+        return match;\n+    }\n+    case Tclass:\n+        // We leave it up to the actual constructor call to do the matching.\n+        return MATCH.exact;\n+\n+    default:\n+        // We can have things as `foo(int[int] wat...)` but they only match\n+        // with an associative array proper.\n+        if (pMessage && trailingArgs.length) *pMessage = tf.getParamError(trailingArgs[0], p);\n+        return MATCH.nomatch;\n+    }\n+}"}, {"sha": "2b9c94cf7f2f0ed63b5d0f98388faed2605a4ce2", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -221,7 +221,7 @@ class Type : public ASTNode\n     virtual const char *kind();\n     Type *copy() const;\n     virtual Type *syntaxCopy();\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     bool equivalent(Type *t);\n     // kludge for template.isType()\n     DYNCAST dyncast() const override final { return DYNCAST_TYPE; }\n@@ -877,7 +877,7 @@ class TypeTuple final : public Type\n     static TypeTuple *create(Type *t1, Type *t2);\n     const char *kind() override;\n     TypeTuple *syntaxCopy() override;\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     void accept(Visitor *v) override { v->visit(this); }\n };\n "}, {"sha": "ca99b8bdc36e617910a39d82ac271da08806f85c", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1247,13 +1247,10 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 args2[0] = e.e2;\n                 expandTuples(&args2);\n                 MatchAccumulator m;\n-                if (s)\n+                functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, &args2);\n+                if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                 {\n-                    functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, &args2);\n-                    if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n-                    {\n-                        return ErrorExp.get();\n-                    }\n+                    return ErrorExp.get();\n                 }\n                 if (m.count > 1)\n                 {"}, {"sha": "ed85a5de96aad0a07f995a01a90ba0b9fb9ad87e", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 71, "deletions": 31, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2756,7 +2756,6 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n     {\n         auto parameters = new AST.Parameters();\n         VarArg varargs = VarArg.none;\n-        int hasdefault = 0;\n         StorageClass varargsStc;\n \n         // Attributes allowed for ...\n@@ -2921,40 +2920,30 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                         //if ((storageClass & STC.scope_) && (storageClass & (STC.ref_ | STC.out_)))\n                             //error(\"scope cannot be ref or out\");\n \n-                        if (tpl && token.value == TOK.identifier)\n+                        const tv = peekNext();\n+                        if (tpl && token.value == TOK.identifier &&\n+                            (tv == TOK.comma || tv == TOK.rightParenthesis || tv == TOK.dotDotDot))\n                         {\n-                            const tv = peekNext();\n-                            if (tv == TOK.comma || tv == TOK.rightParenthesis || tv == TOK.dotDotDot)\n-                            {\n-                                Identifier id = Identifier.generateId(\"__T\");\n-                                const loc = token.loc;\n-                                at = new AST.TypeIdentifier(loc, id);\n-                                if (!*tpl)\n-                                    *tpl = new AST.TemplateParameters();\n-                                AST.TemplateParameter tp = new AST.TemplateTypeParameter(loc, id, null, null);\n-                                (*tpl).push(tp);\n-\n-                                ai = token.ident;\n-                                nextToken();\n-                            }\n-                            else goto _else;\n+                            Identifier id = Identifier.generateId(\"__T\");\n+                            const loc = token.loc;\n+                            at = new AST.TypeIdentifier(loc, id);\n+                            if (!*tpl)\n+                                *tpl = new AST.TemplateParameters();\n+                            AST.TemplateParameter tp = new AST.TemplateTypeParameter(loc, id, null, null);\n+                            (*tpl).push(tp);\n+\n+                            ai = token.ident;\n+                            nextToken();\n                         }\n                         else\n                         {\n-                        _else:\n                             at = parseType(&ai);\n                         }\n                         ae = null;\n                         if (token.value == TOK.assign) // = defaultArg\n                         {\n                             nextToken();\n                             ae = parseDefaultInitExp();\n-                            hasdefault = 1;\n-                        }\n-                        else\n-                        {\n-                            if (hasdefault)\n-                                error(\"default argument expected for `%s`\", ai ? ai.toChars() : at.toChars());\n                         }\n                         auto param = new AST.Parameter(storageClass | STC.parameter, at, ai, ae, null);\n                         if (udas)\n@@ -4484,7 +4473,6 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n \n             const loc = token.loc;\n             Identifier ident;\n-\n             auto t = parseDeclarator(ts, alt, &ident, &tpl, storage_class, &disable, &udas);\n             assert(t);\n             if (!tfirst)\n@@ -4868,6 +4856,10 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     token.value == TOK.identifier && peekNext() == TOK.goesTo ||\n                     token.value == TOK.ref_ && peekNext() == TOK.leftParenthesis &&\n                         skipAttributes(peekPastParen(peek(&token)), &tk) &&\n+                        (tk.value == TOK.goesTo || tk.value == TOK.leftCurly) ||\n+                    token.value == TOK.auto_ && peekNext() == TOK.ref_ &&\n+                        peekNext2() == TOK.leftParenthesis &&\n+                        skipAttributes(peekPastParen(peek(peek(&token))), &tk) &&\n                         (tk.value == TOK.goesTo || tk.value == TOK.leftCurly)\n                    )\n                 {\n@@ -4879,6 +4871,8 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     // identifier => expression\n                     // ref (parameters) { statements... }\n                     // ref (parameters) => expression\n+                    // auto ref (parameters) { statements... }\n+                    // auto ref (parameters) => expression\n \n                     s = parseFunctionLiteral();\n \n@@ -5006,7 +5000,20 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         case TOK.delegate_:\n             save = token.value;\n             nextToken();\n-            if (token.value == TOK.ref_)\n+            if (token.value == TOK.auto_)\n+            {\n+                nextToken();\n+                if (token.value == TOK.ref_)\n+                {\n+                    // function auto ref (parameters) { statements... }\n+                    // delegate auto ref (parameters) { statements... }\n+                    stc = STC.auto_ | STC.ref_;\n+                    nextToken();\n+                }\n+                else\n+                    error(\"`auto` can only be used as part of `auto ref` for function literal return values\");\n+            }\n+            else if (token.value == TOK.ref_)\n             {\n                 // function ref (parameters) { statements... }\n                 // delegate ref (parameters) { statements... }\n@@ -5034,6 +5041,20 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             }\n             goto case TOK.leftParenthesis;\n \n+        case TOK.auto_:\n+            {\n+                nextToken();\n+                if (token.value == TOK.ref_)\n+                {\n+                    // auto ref (parameters) => expression\n+                    // auto ref (parameters) { statements... }\n+                    stc = STC.auto_ | STC.ref_;\n+                    nextToken();\n+                }\n+                else\n+                    error(\"`auto` can only be used as part of `auto ref` for function literal return values\");\n+                goto case TOK.leftParenthesis;\n+            }\n         case TOK.ref_:\n             {\n                 // ref (parameters) => expression\n@@ -5086,7 +5107,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n \n         auto tf = new AST.TypeFunction(parameterList, tret, linkage, stc);\n         tf = cast(AST.TypeFunction)tf.addSTC(stc);\n-        auto fd = new AST.FuncLiteralDeclaration(loc, Loc.initial, tf, save, null);\n+        auto fd = new AST.FuncLiteralDeclaration(loc, Loc.initial, tf, save, null, null, stc & STC.auto_);\n \n         if (token.value == TOK.goesTo)\n         {\n@@ -5209,7 +5230,9 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             }\n             else\n             {\n-                f.frequires.push(parseStatement(ParseStatementFlags.curly | ParseStatementFlags.scope_));\n+                auto ret = parseStatement(ParseStatementFlags.curly | ParseStatementFlags.scope_);\n+                assert(ret);\n+                f.frequires.push(ret);\n                 requireDo = true;\n             }\n             goto L1;\n@@ -6550,7 +6573,7 @@ LagainStc:\n                 nextToken();\n             if (token.value == TOK.semicolon)\n                 nextToken();\n-            s = null;\n+            s = new AST.ErrorStatement;\n             break;\n         }\n         if (pEndloc)\n@@ -8394,6 +8417,22 @@ LagainStc:\n             e = parseNewExp(null);\n             break;\n \n+        case TOK.auto_:\n+            {\n+                if (peekNext() == TOK.ref_ && peekNext2() == TOK.leftParenthesis)\n+                {\n+                    Token* tk = peekPastParen(peek(peek(&token)));\n+                    if (skipAttributes(tk, &tk) && (tk.value == TOK.goesTo || tk.value == TOK.leftCurly))\n+                    {\n+                        // auto ref (arguments) => expression\n+                        // auto ref (arguments) { statements... }\n+                        goto case_delegate;\n+                    }\n+                }\n+                nextToken();\n+                error(\"found `%s` when expecting `ref` and function literal following `auto`\", token.toChars());\n+                goto Lerr;\n+            }\n         case TOK.ref_:\n             {\n                 if (peekNext() == TOK.leftParenthesis)\n@@ -8630,7 +8669,7 @@ LagainStc:\n                     if (token.value != TOK.identifier)\n                     {\n                         error(\"identifier expected following `(type)`.\");\n-                        return null;\n+                        return AST.ErrorExp.get();\n                     }\n                     e = new AST.DotIdExp(loc, new AST.TypeExp(loc, t), token.ident);\n                     nextToken();\n@@ -8749,7 +8788,8 @@ LagainStc:\n                                     if (peekNext() != TOK.identifier && peekNext() != TOK.new_)\n                                     {\n                                         error(\"identifier or new keyword expected following `(...)`.\");\n-                                        return null;\n+                                        nextToken();\n+                                        return AST.ErrorExp.get();\n                                     }\n                                     e = new AST.TypeExp(loc, t);\n                                     e.parens = true;"}, {"sha": "b735dd98728ffcd5273755d8f0d3d924b9696294", "filename": "gcc/d/dmd/root/object.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Froot%2Fobject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Froot%2Fobject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fobject.h?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -39,7 +39,7 @@ class RootObject\n public:\n     RootObject() { }\n \n-    virtual bool equals(const RootObject *o) const;\n+    virtual bool equals(const RootObject * const o) const;\n \n     /**\n      * Pretty-print an Object. Useful for debugging the old-fashioned way."}, {"sha": "d2f9c0ab04b0b7e45c908fe60c781cfd31c32c2d", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -167,11 +167,18 @@ private extern(C++) final class Semantic3Visitor : Visitor\n \n         sc = sc.push(tmix.argsym);\n         sc = sc.push(tmix);\n+\n+        uint olderrors = global.errors;\n+\n         for (size_t i = 0; i < tmix.members.dim; i++)\n         {\n             Dsymbol s = (*tmix.members)[i];\n             s.semantic3(sc);\n         }\n+\n+        if (global.errors != olderrors)\n+            errorSupplemental(tmix.loc, \"parent scope from here: `mixin %s`\", tmix.toChars());\n+\n         sc = sc.pop();\n         sc.pop();\n     }\n@@ -969,6 +976,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n             /* Do the semantic analysis on the [in] preconditions and\n              * [out] postconditions.\n              */\n+            immutable bool isnothrow = f.isnothrow && !(funcdecl.flags & FUNCFLAG.nothrowInprocess);\n             if (freq)\n             {\n                 /* frequire is composed of the [in] contracts\n@@ -980,10 +988,22 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                 sc2.flags = (sc2.flags & ~SCOPE.contract) | SCOPE.require;\n \n                 // BUG: need to error if accessing out parameters\n-                // BUG: need to disallow returns and throws\n+                // BUG: need to disallow returns\n                 // BUG: verify that all in and ref parameters are read\n                 freq = freq.statementSemantic(sc2);\n-                freq.blockExit(funcdecl, false);\n+\n+                // @@@DEPRECATED_2.111@@@ - pass `isnothrow` instead of `false` to print a more detailed error msg`\n+                const blockExit = freq.blockExit(funcdecl, false);\n+                if (blockExit & BE.throw_)\n+                {\n+                    if (isnothrow)\n+                        // @@@DEPRECATED_2.111@@@\n+                        // Deprecated in 2.101, can be made an error in 2.111\n+                        deprecation(funcdecl.loc, \"`%s`: `in` contract may throw but function is marked as `nothrow`\",\n+                            funcdecl.toPrettyChars());\n+                    else if (funcdecl.flags & FUNCFLAG.nothrowInprocess)\n+                        f.isnothrow = false;\n+                }\n \n                 funcdecl.flags &= ~FUNCFLAG.noEH;\n \n@@ -992,6 +1012,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                 if (global.params.useIn == CHECKENABLE.off)\n                     freq = null;\n             }\n+\n             if (fens)\n             {\n                 /* fensure is composed of the [out] contracts\n@@ -1017,7 +1038,19 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     funcdecl.buildResultVar(scout, f.next);\n \n                 fens = fens.statementSemantic(sc2);\n-                fens.blockExit(funcdecl, false);\n+\n+                // @@@DEPRECATED_2.111@@@ - pass `isnothrow` instead of `false` to print a more detailed error msg`\n+                const blockExit = fens.blockExit(funcdecl, false);\n+                if (blockExit & BE.throw_)\n+                {\n+                    if (isnothrow)\n+                        // @@@DEPRECATED_2.111@@@\n+                        // Deprecated in 2.101, can be made an error in 2.111\n+                        deprecation(funcdecl.loc, \"`%s`: `out` contract may throw but function is marked as `nothrow`\",\n+                            funcdecl.toPrettyChars());\n+                    else if (funcdecl.flags & FUNCFLAG.nothrowInprocess)\n+                        f.isnothrow = false;\n+                }\n \n                 funcdecl.flags &= ~FUNCFLAG.noEH;\n \n@@ -1144,7 +1177,6 @@ private extern(C++) final class Semantic3Visitor : Visitor\n \n                             s = s.statementSemantic(sc2);\n \n-                            immutable bool isnothrow = f.isnothrow && !(funcdecl.flags & FUNCFLAG.nothrowInprocess);\n                             const blockexit = s.blockExit(funcdecl, isnothrow);\n                             if (blockexit & BE.throw_)\n                             {"}, {"sha": "0d7240f4ef44a11c3388eeb4ff767ae17bffcb38", "filename": "gcc/d/dmd/transitivevisitor.d", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -28,6 +28,7 @@ extern(C++) class ParseTimeTransitiveVisitor(AST) : PermissiveVisitor!AST\n  */\n package mixin template ParseVisitMethods(AST)\n {\n+    import dmd.root.array;\n \n //   Statement Nodes\n //===========================================================\n@@ -46,7 +47,7 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.CompileStatement s)\n     {\n         //printf(\"Visiting CompileStatement\\n\");\n-        visitArgs(s.exps);\n+        visitArgs(s.exps.peekSlice());\n     }\n \n     override void visit(AST.CompoundStatement s)\n@@ -181,11 +182,9 @@ package mixin template ParseVisitMethods(AST)\n             s.elsebody.accept(this);\n     }\n \n-    void visitArgs(AST.Expressions* expressions, AST.Expression basis = null)\n+    private extern(D) void visitArgs(AST.Expression[] expressions, AST.Expression basis = null)\n     {\n-        if (!expressions || !expressions.dim)\n-            return;\n-        foreach (el; *expressions)\n+        foreach (el; expressions)\n         {\n             if (!el)\n                 el = basis;\n@@ -197,8 +196,7 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.PragmaStatement s)\n     {\n         //printf(\"Visiting PragmaStatement\\n\");\n-        if (s.args && s.args.dim)\n-            visitArgs(s.args);\n+        visitArgs(s.args.peekSlice());\n         if (s._body)\n             s._body.accept(this);\n     }\n@@ -346,19 +344,14 @@ package mixin template ParseVisitMethods(AST)\n             foreach (p; *td.origParameters)\n                 p.accept(this);\n         }\n-        visitParameters(t.parameterList.parameters);\n+        visitParameters(t.parameterList.parameters.peekSlice());\n     }\n \n-    void visitParameters(AST.Parameters* parameters)\n+    private extern(D) final void visitParameters(AST.Parameter[] parameters)\n     {\n-        if (parameters)\n+        foreach (i; 0 .. parameters.length)\n         {\n-            size_t dim = AST.Parameter.dim(parameters);\n-            foreach(i; 0..dim)\n-            {\n-                AST.Parameter fparam = AST.Parameter.getNth(parameters, i);\n-                fparam.accept(this);\n-            }\n+            parameters[i].accept(this);\n         }\n     }\n \n@@ -469,7 +462,7 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.TypeTuple t)\n     {\n         //printf(\"Visiting TypeTuple\\n\");\n-        visitParameters(t.arguments);\n+        visitParameters(t.arguments.peekSlice());\n     }\n \n     override void visit(AST.TypeSlice t)\n@@ -487,7 +480,7 @@ package mixin template ParseVisitMethods(AST)\n \n     override void visit(AST.TypeMixin t)\n     {\n-        visitArgs(t.exps);\n+        visitArgs(t.exps.peekSlice());\n     }\n \n //      Miscellaneous\n@@ -571,33 +564,30 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.PragmaDeclaration d)\n     {\n         //printf(\"Visiting PragmaDeclaration\\n\");\n-        if (d.args && d.args.dim)\n-            visitArgs(d.args);\n+        visitArgs(d.args.peekSlice());\n         visitAttribDeclaration(cast(AST.AttribDeclaration)d);\n     }\n \n     override void visit(AST.ConditionalDeclaration d)\n     {\n         //printf(\"Visiting ConditionalDeclaration\\n\");\n         d.condition.accept(this);\n-        if (d.decl)\n-            foreach (de; *d.decl)\n-                de.accept(this);\n-        if (d.elsedecl)\n-            foreach (de; *d.elsedecl)\n-                de.accept(this);\n+        foreach (de; d.decl.peekSlice())\n+            de.accept(this);\n+        foreach (de; d.elsedecl.peekSlice())\n+            de.accept(this);\n     }\n \n     override void visit(AST.CompileDeclaration d)\n     {\n         //printf(\"Visiting compileDeclaration\\n\");\n-        visitArgs(d.exps);\n+        visitArgs(d.exps.peekSlice());\n     }\n \n     override void visit(AST.UserAttributeDeclaration d)\n     {\n         //printf(\"Visiting UserAttributeDeclaration\\n\");\n-        visitArgs(d.atts);\n+        visitArgs(d.atts.peekSlice());\n         visitAttribDeclaration(cast(AST.AttribDeclaration)d);\n     }\n \n@@ -791,6 +781,15 @@ package mixin template ParseVisitMethods(AST)\n             s.accept(this);\n     }\n \n+    override void visit(AST.UnionDeclaration d)\n+    {\n+        //printf(\"Visiting UnionDeclaration\\n\");\n+        if (!d.members)\n+            return;\n+        foreach (s; *d.members)\n+            s.accept(this);\n+    }\n+\n     override void visit(AST.ClassDeclaration d)\n     {\n         //printf(\"Visiting ClassDeclaration\\n\");\n@@ -840,7 +839,7 @@ package mixin template ParseVisitMethods(AST)\n         auto tf = f.type.isTypeFunction();\n         if (!f.inferRetType && tf.next)\n             visitType(tf.next);\n-        visitParameters(tf.parameterList.parameters);\n+        visitParameters(tf.parameterList.parameters.peekSlice());\n         AST.CompoundStatement cs = f.fbody.isCompoundStatement();\n         AST.Statement s = !cs ? f.fbody : null;\n         AST.ReturnStatement rs = s ? s.isReturnStatement() : null;\n@@ -946,7 +945,7 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.ArrayLiteralExp e)\n     {\n         //printf(\"Visiting ArrayLiteralExp\\n\");\n-        visitArgs(e.elements, e.basis);\n+        visitArgs(e.elements.peekSlice(), e.basis);\n     }\n \n     override void visit(AST.AssocArrayLiteralExp e)\n@@ -978,17 +977,15 @@ package mixin template ParseVisitMethods(AST)\n         if (e.thisexp)\n             e.thisexp.accept(this);\n         visitType(e.newtype);\n-        if (e.arguments && e.arguments.dim)\n-            visitArgs(e.arguments);\n+        visitArgs(e.arguments.peekSlice());\n     }\n \n     override void visit(AST.NewAnonClassExp e)\n     {\n         //printf(\"Visiting NewAnonClassExp\\n\");\n         if (e.thisexp)\n             e.thisexp.accept(this);\n-        if (e.arguments && e.arguments.dim)\n-            visitArgs(e.arguments);\n+        visitArgs(e.arguments.peekSlice());\n         if (e.cd)\n             e.cd.accept(this);\n     }\n@@ -998,7 +995,7 @@ package mixin template ParseVisitMethods(AST)\n         //printf(\"Visiting TupleExp\\n\");\n         if (e.e0)\n             e.e0.accept(this);\n-        visitArgs(e.exps);\n+        visitArgs(e.exps.peekSlice());\n     }\n \n     override void visit(AST.FuncExp e)\n@@ -1056,7 +1053,7 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.MixinExp e)\n     {\n         //printf(\"Visiting MixinExp\\n\");\n-        visitArgs(e.exps);\n+        visitArgs(e.exps.peekSlice());\n     }\n \n     override void visit(AST.ImportExp e)\n@@ -1090,7 +1087,7 @@ package mixin template ParseVisitMethods(AST)\n     {\n         //printf(\"Visiting CallExp\\n\");\n         e.e1.accept(this);\n-        visitArgs(e.arguments);\n+        visitArgs(e.arguments.peekSlice());\n     }\n \n     override void visit(AST.PtrExp e)\n@@ -1124,7 +1121,7 @@ package mixin template ParseVisitMethods(AST)\n     {\n         //printf(\"Visiting ArrayExp\\n\");\n         e.e1.accept(this);\n-        visitArgs(e.arguments);\n+        visitArgs(e.arguments.peekSlice());\n     }\n \n     override void visit(AST.PostExp e)"}, {"sha": "0ef77052ec8e8a6231a50069736682801b4c4af3", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1388,6 +1388,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             // extended index), as we need to run semantic when `oidx` changes.\n             size_t tupleOrigIdx = size_t.max;\n             size_t tupleExtIdx = size_t.max;\n+            bool hasDefault;\n             foreach (oidx, oparam, eidx, eparam; tf.parameterList)\n             {\n                 // oparam (original param) will always have the default arg\n@@ -1396,6 +1397,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 // position to get the offset in it later on.\n                 if (oparam.defaultArg)\n                 {\n+                    hasDefault = true;\n                     // Get the obvious case out of the way\n                     if (oparam is eparam)\n                         errors |= !defaultArgSemantic(eparam, argsc);\n@@ -1422,6 +1424,11 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                             eparam.defaultArg = (*te.exps)[eidx - tupleExtIdx];\n                     }\n                 }\n+                else if (hasDefault)\n+                {\n+                    .error(loc, \"default argument expected for `%s`\", oparam.toChars());\n+                    errors = true;\n+                }\n \n                 // We need to know the default argument to resolve `auto ref`,\n                 // hence why this has to take place as the very last step.\n@@ -2089,10 +2096,12 @@ extern (C++) Type merge(Type type)\n  *  loc = the location where the property is encountered\n  *  ident = the identifier of the property\n  *  flag = if flag & 1, don't report \"not a property\" error and just return NULL.\n+ *  src = expression for type `t` or null.\n  * Returns:\n  *      expression representing the property, or null if not a property and (flag & 1)\n  */\n-Expression getProperty(Type t, Scope* scope_, const ref Loc loc, Identifier ident, int flag)\n+Expression getProperty(Type t, Scope* scope_, const ref Loc loc, Identifier ident, int flag,\n+    Expression src = null)\n {\n     Expression visitType(Type mt)\n     {\n@@ -2169,7 +2178,10 @@ Expression getProperty(Type t, Scope* scope_, const ref Loc loc, Identifier iden\n                         error(loc, \"no property `%s` for type `%s`, perhaps `import %.*s;` is needed?\", ident.toChars(), mt.toChars(), cast(int)n.length, n.ptr);\n                 else\n                 {\n-                    error(loc, \"no property `%s` for type `%s`\", ident.toChars(), mt.toPrettyChars(true));\n+                    if (src)\n+                        error(loc, \"no property `%s` for `%s` of type `%s`\", ident.toChars(), src.toChars(), mt.toPrettyChars(true));\n+                    else\n+                        error(loc, \"no property `%s` for type `%s`\", ident.toChars(), mt.toPrettyChars(true));\n                     if (auto dsym = mt.toDsymbol(scope_))\n                         if (auto sym = dsym.isAggregateDeclaration())\n                         {\n@@ -4457,7 +4469,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n \n \n /************************\n- * Get the the default initialization expression for a type.\n+ * Get the default initialization expression for a type.\n  * Params:\n  *  mt = the type for which the init expression is returned\n  *  loc = the location where the expression needs to be evaluated"}, {"sha": "fa5ec90a2bccb194035c509f9ddb302ec417dc07", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -908,21 +908,12 @@ class ExprVisitor : public Visitor\n \n \t    if ((postblit || destructor) && e->op != EXP::blit)\n \t      {\n-\t\t/* Need to call postblit/destructor as part of assignment.\n-\t\t   Construction has already been handled by the front-end.  */\n-\t\tgcc_assert (e->op != EXP::construct);\n-\n-\t\t/* So we can call postblits on const/immutable objects.  */\n-\t\tType *tm = etype->unSharedOf ()->mutableOf ();\n-\t\ttree ti = build_typeinfo (e, tm);\n-\n-\t\t/* Generate: _d_arraysetassign (t1.ptr, &t2, t1.length, ti);  */\n-\t\tresult = build_libcall (LIBCALL_ARRAYSETASSIGN, Type::tvoid, 4,\n-\t\t\t\t\td_array_ptr (t1),\n-\t\t\t\t\tbuild_address (t2),\n-\t\t\t\t\td_array_length (t1), ti);\n+\t\t/* This case should have been rewritten to `_d_arraysetassign`\n+\t\t   in the semantic phase.  */\n+\t\tgcc_unreachable ();\n \t      }\n-\t    else if (integer_zerop (t2))\n+\n+\t    if (integer_zerop (t2))\n \t      {\n \t\ttree size = size_mult_expr (d_array_length (t1),\n \t\t\t\t\t    size_int (etype->size ()));\n@@ -2473,6 +2464,20 @@ class ExprVisitor : public Visitor\n \tif (e->argprefix)\n \t  result = compound_expr (build_expr (e->argprefix), result);\n       }\n+    else if (tb->ty == TY::Taarray)\n+      {\n+\t/* Allocating memory for a new associative array.  */\n+\ttree arg = build_typeinfo (e, e->newtype);\n+\ttree mem = build_libcall (LIBCALL_AANEW, Type::tvoidptr, 1, arg);\n+\n+\t/* Return an associative array pointed to by MEM.  */\n+\ttree aatype = build_ctype (tb);\n+\tvec <constructor_elt, va_gc> *ce = NULL;\n+\tCONSTRUCTOR_APPEND_ELT (ce, TYPE_FIELDS (aatype), mem);\n+\n+\tresult = build_nop (build_ctype (e->type),\n+\t\t\t    build_constructor (aatype, ce));\n+      }\n     else\n       gcc_unreachable ();\n "}, {"sha": "f576bef4e59d99ba232fab446c91b12862dfd66f", "filename": "gcc/d/runtime.def", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Fd%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.def?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -115,10 +115,6 @@ DEF_D_RUNTIME (ALLOCMEMORY, \"_d_allocmemory\", RT(VOIDPTR), P1(SIZE_T),\n DEF_D_RUNTIME (ARRAYCOPY, \"_d_arraycopy\", RT(ARRAY_VOID),\n \t       P3(SIZE_T, ARRAY_VOID, ARRAY_VOID), 0)\n \n-/* Used for array assignments from a single element.  */\n-DEF_D_RUNTIME (ARRAYSETASSIGN, \"_d_arraysetassign\", RT(VOIDPTR),\n-\t       P4(VOIDPTR, VOIDPTR, SIZE_T, CONST_TYPEINFO), 0)\n-\n /* Used for concatenating two or more arrays together.  Then `n' variant is\n    for when there is more than two arrays to handle.  */\n DEF_D_RUNTIME (ARRAYCATT, \"_d_arraycatT\", RT(ARRAY_BYTE),\n@@ -140,6 +136,7 @@ DEF_D_RUNTIME (ARRAYAPPENDWD, \"_d_arrayappendwd\", RT(ARRAY_VOID),\n /* Used for allocating a new associative array.  */\n DEF_D_RUNTIME (ASSOCARRAYLITERALTX, \"_d_assocarrayliteralTX\", RT(VOIDPTR),\n \t       P3(CONST_TYPEINFO, ARRAY_VOID, ARRAY_VOID), 0)\n+DEF_D_RUNTIME (AANEW, \"_aaNew\", RT(VOIDPTR), P1(CONST_TYPEINFO), 0)\n \n /* Used for value equality of two associative arrays.  */\n DEF_D_RUNTIME (AAEQUAL, \"_aaEqual\", RT(INT),"}, {"sha": "abe956c80948bcea2b18759d9dee507a9acfda1d", "filename": "gcc/testsuite/gdc.test/compilable/commontype.d", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcommontype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcommontype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcommontype.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -151,19 +151,19 @@ static assert(Error!( uint*, int* ));\n static assert(is( X!( int function(), int function() ) == int function() ));\n \n // void pointer\n-static assert(is( X!( void*, int* ) == int* ));\n-static assert(is( X!( int*, void* ) == int* ));\n-static assert(is( X!( const(int)*, void* ) == const(int)* ));\n-static assert(is( X!( const(int*), void* ) == const(int*) ));\n-static assert(is( X!( int*, const(void)* ) == int* )); // `const`\n-static assert(is( X!( int*, const(void*) ) == int* )); // `const`\n-static assert(is( X!( int*, shared(void*) ) == int* )); // should fail\n-static assert(is( X!( int*, shared(void)* ) == int* )); // should fail\n+static assert(is( X!( void*, int* ) == void* ));\n+static assert(is( X!( int*, void* ) == void* ));\n+static assert(is( X!( const(int)*, void* ) == void* ));\n+static assert(is( X!( const(int*), void* ) == void* ));\n+static assert(is( X!( int*, const(void)* ) == const(void)* )); // `const`\n+static assert(is( X!( int*, const(void*) ) == const(void*) )); // `const`\n+static assert(is( X!( int*, shared(void*) ) == shared(void*) )); // should fail\n+static assert(is( X!( int*, shared(void)* ) == shared(void)* )); // should fail\n \n static assert(Error!( int**, void** )); // should work\n \n-static assert(is( X!( void*, int function() ) == int function() ));\n-static assert(is( X!( immutable(void*), int function() ) == int function() )); // `const`\n+static assert(is( X!( void*, int function() ) == void* ));\n+static assert(is( X!( immutable(void*), int function() ) == immutable(void*) )); // `const`\n \n // implicit conversion\n static assert(is( X!( int*, const(int*) ) == const(int*) ));"}, {"sha": "c8ff97644c3a89baaa54d88108cd129b4d485947", "filename": "gcc/testsuite/gdc.test/compilable/imports/cimports2a.i", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2a.i", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2a.i", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2a.i?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,4 @@\n+extern int xx;\n+\n+typedef struct Foo *FooRef;\n+FooRef make_foo(void);"}, {"sha": "03b22b2a216313514edb65b21983d928e0a2a89f", "filename": "gcc/testsuite/gdc.test/compilable/imports/cimports2b.i", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2b.i", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2b.i", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2b.i?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,4 @@\n+extern int xx;\n+\n+typedef struct Foo *FooRef;\n+void free_foo(FooRef foo);"}, {"sha": "de9b95705e1af65fc085a1deb2b71cdc87ecf96f", "filename": "gcc/testsuite/gdc.test/compilable/imports/format23327.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,7 @@\n+module imports.format23327;\n+\n+import imports.format23327.write;\n+\n+immutable(string) format23327() { }\n+\n+import imports.format23327.internal.write;"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gdc.test/compilable/imports/format23327/write.d", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327%2Fwrite.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327%2Fwrite.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327%2Fwrite.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6"}, {"sha": "2ea125f5d3be8320f0dc82d355cf5904e5a55e72", "filename": "gcc/testsuite/gdc.test/compilable/segfaultgolf.d", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fsegfaultgolf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fsegfaultgolf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fsegfaultgolf.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,50 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23351\n+enum strings =\n+[\n+\"a[(b).\",\n+\"[(a)(b).\",\n+\"a(={@.()(\",\n+\"a[b,[(c).\",\n+\"a[b#([(c).\",\n+\"[a@b[(c).\",\n+\"[((a).\",\n+\"[a)b[(c).\",\n+\"a[b)[(c).\",\n+\"a(b[(c).\",\n+\"a[b()c[(d).\",\n+\"a[(b[(c).\",\n+\"a(b[(c).\",\n+\"[(@@a b[(c).\",\n+\"a[(!b)c[(d).\",\n+\"[(^a)b[(c).\",\n+\"a(b[(c).\",\n+\"~[a.b[(c).\",\n+\"[a).[(b c d(e[(f).\",\n+\"[((a).\",\n+\"[a}b[(c).\",\n+\"a[b[c..(d).\",\n+\"[1a.[(b).\",\n+\"a[({in){,\",\n+\"a[^in(b[c=])S....,\",\n+\"a[({in[({)){,\"\n+];\n+template KidNamedFinger(T)\n+{\n+\n+}\n+void dummy()\n+{\n+    static foreach(str; strings)\n+    {\n+        /*\n+            The above strings are all gibberish, they should\n+            fail to parse but not segfault the compiler.\n+        */\n+        {\n+            enum exp = __traits(compiles, mixin(str));\n+            static assert(!exp);\n+            enum t = __traits(compiles, KidNamedFinger!(mixin(str)));\n+            static assert(!t);\n+        }\n+    }\n+}"}, {"sha": "0236f2da29b50ba2181d148f47f4252d98d9a70c", "filename": "gcc/testsuite/gdc.test/compilable/statictemplatethis.d", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstatictemplatethis.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstatictemplatethis.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstatictemplatethis.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,45 @@\n+mixin template Constructors(){\n+    this(){ }\n+    this()immutable{ }\n+    this()shared{ }\n+}\n+\n+class A {\n+public:\n+    static T getInstance(this T)() {\n+        return new T();\n+    }\n+private:\n+    mixin Constructors;\n+}\n+\n+class B : A {\n+private:\n+    mixin Constructors;\n+}\n+\n+void f(){\n+    auto a = (new A).getInstance;\n+    auto b = (new B).getInstance;\n+    static assert(is(typeof(a) == A));\n+    static assert(is(typeof(b) == B));\n+\n+    auto ca = (new immutable A).getInstance;\n+    auto sb = (new shared B).getInstance;\n+    static assert(is(typeof(ca) == immutable A));\n+    static assert(is(typeof(sb) == shared B));\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=10488\n+version(none)\n+void g(){\n+    auto a = A.getInstance();\n+    auto b = B.getInstance();\n+    static assert(is(typeof(a)==A));\n+    static assert(is(typeof(b)==B));\n+\n+    auto ai = (immutable(A)).getInstance();\n+    auto bs = (shared(B)).getInstance();\n+    static assert(is(typeof(ai)==immutable(A)));\n+    static assert(is(typeof(bs)==shared(B)));\n+}"}, {"sha": "881eb1b9dd7d99c174a8eaf8a2721d0e3a6df643", "filename": "gcc/testsuite/gdc.test/compilable/test13123.d", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13123.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13123.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13123.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,38 @@\n+auto inferNothrow()\n+in\n+{\n+}\n+out\n+{\n+}\n+do\n+{\n+    return 1;\n+}\n+\n+auto dontInferNothrowIn()\n+in\n+{\n+    throw new Exception(null);\n+}\n+do\n+{\n+    return 1;\n+}\n+\n+auto dontInferNothrowOut()\n+out\n+{\n+    throw new Exception(null);\n+}\n+do\n+{\n+    return 1;\n+}\n+\n+enum isNothrow(Attr...) = (Attr.length >= 1)\n+    && (Attr[0] == \"nothrow\" || isNothrow!(Attr[1 .. $]));\n+\n+static assert(isNothrow!(__traits(getFunctionAttributes, inferNothrow)));\n+static assert(!isNothrow!(__traits(getFunctionAttributes, dontInferNothrowIn)));\n+static assert(!isNothrow!(__traits(getFunctionAttributes, dontInferNothrowOut)));"}, {"sha": "20838dc973b76fb796ff80acbfdde57eb77afc7d", "filename": "gcc/testsuite/gdc.test/compilable/test21243.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21243.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21243.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21243.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,21 @@\n+// Parsing - expressions\n+auto a = auto ref (int x) => x;\n+auto b = auto ref (int x) { return x; };\n+auto c = function auto ref (int x) { return x; };\n+auto d = delegate auto ref (int x) { return x; };\n+\n+// Parsing - aliases\n+alias e = auto ref (int x) => x;\n+alias f = auto ref (int x) { return x; };\n+alias g = function auto ref (int x) { return x; };\n+alias h = delegate auto ref (int x) { return x; };\n+\n+// Semantic\n+void test()\n+{\n+    alias fun(alias x) = auto ref () => x;\n+    int n = 123;\n+    auto _ = fun!123();\n+    static assert(!__traits(compiles, &fun!123())); // rvalue\n+    fun!n() = 456; // lvalue\n+}"}, {"sha": "64ebc55644c7723ca2b9a92ca6d586fb63214b9a", "filename": "gcc/testsuite/gdc.test/compilable/test21956.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21956.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21956.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21956.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,16 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21956\n+\n+noreturn[noreturn] nrnr;\n+\n+void gun()\n+{\n+    foreach (a; nrnr){}\n+}\n+\n+int main()\n+{\n+    noreturn[] empty;\n+    int val;\n+    foreach(el; empty) val++;\n+    return val;\n+}"}, {"sha": "cc6e3bb2d073fe2fe40e22005b5040d741628ca2", "filename": "gcc/testsuite/gdc.test/compilable/test22674.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22674.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22674.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22674.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,10 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22674\n+// EXTRA_FILES: imports/cimports2a.i imports/cimports2b.i\n+\n+import imports.cimports2a;\n+import imports.cimports2b;\n+\n+void do_foo(){\n+    FooRef f = make_foo(); // use_foo.d(5)\n+    free_foo(f);           // use_foo.d(6)\n+}"}, {"sha": "6b16132d518fa1b4df3ca1e8e48f3371574bae29", "filename": "gcc/testsuite/gdc.test/compilable/test23173.d", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23173.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23173.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23173.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,6 @@\n+// REQUIRED_ARGS: -o-\n+// https://issues.dlang.org/show_bug.cgi?id=23173\n+\n+mixin(\"long l = \", long.min, \";\");\n+static assert(mixin(long.min) == long.min);\n+static assert(is(typeof(mixin(long.min)) == long));"}, {"sha": "1e8e91b779531c32c8820809f5e5e85c4f7dfd97", "filename": "gcc/testsuite/gdc.test/compilable/test23258.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23258.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23258.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23258.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,21 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23258\n+\n+struct SumType(Types...)\n+{\n+    this(Types[0])\n+    {\n+    }\n+    this(Types[1])\n+    {\n+    }\n+}\n+\n+alias A2 = SumType!(C1[], C2[]);\n+\n+class C1\n+{\n+}\n+\n+class C2\n+{\n+}"}, {"sha": "81b51f65aec6bd3bd8c885b6e95e52a0383cbaf1", "filename": "gcc/testsuite/gdc.test/compilable/test23306.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23306.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23306.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23306.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,7 @@\n+class A {\n+        @disable new();\n+}\n+\n+void main() {\n+        scope A a = new A();\n+}"}, {"sha": "bbb6346a9ff76cc47b38453c1698291d0365495f", "filename": "gcc/testsuite/gdc.test/compilable/test23327.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23327.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23327.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23327.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,3 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23327\n+// EXTRA_FILES: imports/format23327.d imports/format23327/write.d\n+import imports.format23327;"}, {"sha": "79826a0e132a5226a671ca9cd7953f92f359a694", "filename": "gcc/testsuite/gdc.test/compilable/vararg.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvararg.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvararg.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvararg.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,20 @@\n+void main ()\n+{\n+    variance([1.0, 2, 3]);\n+}\n+\n+alias meanType(T) = T;\n+\n+template variance(bool stable = true)\n+{\n+    void variance(Range)(Range r, bool isPopulation = false)\n+    {\n+        .variance!(double, stable)(r, isPopulation);\n+    }\n+}\n+\n+template variance(F, bool stable = true)\n+{\n+    void variance(Range)(Range r, bool isPopulation = false) {}\n+    void variance(scope const F[] ar...) {}\n+}"}, {"sha": "84d0ad4696b64355a81b005185a04503f81a09ae", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag10169.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10169.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10169.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10169.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2,7 +2,7 @@\n EXTRA_FILES: imports/a10169.d\n TEST_OUTPUT:\n ---\n-fail_compilation/diag10169.d(12): Error: no property `x` for type `imports.a10169.B`\n+fail_compilation/diag10169.d(12): Error: no property `x` for `B(0)` of type `imports.a10169.B`\n ---\n */\n import imports.a10169;"}, {"sha": "80c7f5e56ea289357f2d5e5cbc9c5970d052e8c2", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag10783.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10783.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10783.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10783.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag10783.d(14): Error: no property `type` for type `diag10783.Event`\n+fail_compilation/diag10783.d(14): Error: no property `type` for `event` of type `diag10783.Event`\n fail_compilation/diag10783.d(14): Error: undefined identifier `En`\n ---\n */"}, {"sha": "9b5761f7a575943e658408a915d1c27a74aaa62e", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag13528.d", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13528.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13528.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13528.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,10 +1,12 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag13528.d(13): Error: value of `this` is not known at compile time\n-fail_compilation/diag13528.d(13):        while evaluating `pragma(msg, __traits(getMember, A, \"foo\"))`\n+fail_compilation/diag13528.d(6): Error: value of `this` is not known at compile time\n+fail_compilation/diag13528.d(6):        while evaluating `pragma(msg, __traits(getMember, A, \"foo\"))`\n+fail_compilation/diag13528.d(12):        parent scope from here: `mixin MyTemplate!()`\n ---\n */\n+#line 1\n \n mixin template MyTemplate()\n {"}, {"sha": "fa7c6114ad60a4f99daef91608217017f8ad5b3c", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag14145.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14145.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14145.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14145.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag14145.d(15): Error: no property `i` for type `diag14145.main.Capture!(i)`\n+fail_compilation/diag14145.d(15): Error: no property `i` for `_` of type `diag14145.main.Capture!(i)`\n fail_compilation/diag14145.d(15):        potentially malformed `opDispatch`. Use an explicit instantiation to get a better error message\n fail_compilation/diag14145.d(34): Error: expression `*this.ptr` of type `shared(int)` is not implicitly convertible to return type `ref int`\n fail_compilation/diag14145.d(16): Error: template instance `diag14145.main.Capture!(i).Capture.opDispatch!\"i\"` error instantiating"}, {"sha": "e4cb2a7603a5687974d6abbff99ae69664101642", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag15713.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag15713.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag15713.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag15713.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag15713.d(19): Error: no property `widthSign` for type `diag15713.WrData.Data`\n+fail_compilation/diag15713.d(19): Error: no property `widthSign` for `this` of type `diag15713.WrData.Data`\n fail_compilation/diag15713.d(39): Error: template instance `diag15713.conwritefImpl!(\"parse-int\", \"width\", \"\\n\", Data(null))` error instantiating\n fail_compilation/diag15713.d(44):        instantiated from here: `conwritefImpl!(\"main\", \"\\n\", Data(null))`\n fail_compilation/diag15713.d(49):        instantiated from here: `fdwritef!()`"}, {"sha": "586cbb0fce85662420ac44a15c1272d04c645ad8", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag23355.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag23355.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag23355.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag23355.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,16 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/diag23355.d(1): Error: undefined identifier `n`\n+fail_compilation/diag23355.d(4): Error: none of the overloads of template `diag23355.ffi1` are callable using argument types `!()(int[4])`\n+fail_compilation/diag23355.d(1):        Candidate is: `ffi1(T)(T[n] s)`\n+fail_compilation/diag23355.d(2): Error: undefined identifier `n`\n+fail_compilation/diag23355.d(4): Error: none of the overloads of template `diag23355.ffi2` are callable using argument types `!()(int[4])`\n+fail_compilation/diag23355.d(2):        Candidate is: `ffi2()(T[n] s)`\n+---\n+*/\n+#line 1\n+void ffi1(T)(T[n] s) { }\n+void ffi2()(T[n] s) { }\n+\n+void main() { int[4] x; ffi1(x); ffi2(x); }"}, {"sha": "c4cbc721d860f7f199bf85fcc22660f8b7ee215f", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag3438.d", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,4 +1,3 @@\n-// REQUIRED_ARGS: -de\n /*\n TEST_OUTPUT:\n ---\n@@ -8,6 +7,7 @@ fail_compilation/diag3438.d(20): Error: constructor `diag3438.F5.this` is marked\n fail_compilation/diag3438.d(20):        Use `@disable this();` if you want to disable default initialization.\n fail_compilation/diag3438.d(21): Error: constructor `diag3438.F6.this` is marked `@disable`, so it cannot have default arguments for all parameters.\n fail_compilation/diag3438.d(21):        Use `@disable this();` if you want to disable default initialization.\n+fail_compilation/diag3438.d(24): Error: default argument expected for `y`\n ---\n */\n \n@@ -19,3 +19,6 @@ struct F3 { this(...) { } } // ok\n struct F4 { this(int[] x...) { } }  // ok\n struct F5 { @disable this(int x = 1); }\n struct F6 { @disable this(int x = 1) { } }\n+\n+// Make sure the deprecation doesn't interfere w/ the check for default arguments\n+struct S { this(int x = 1, int y) { } }"}, {"sha": "46a197d2a24958006077e13aaa77882b975f4956", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag3438b.d", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438b.d?ref=be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2", "patch": "@@ -1,9 +0,0 @@\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/diag3438b.d(9): Error: default argument expected for `y`\n----\n-*/\n-\n-// Make sure the deprecation doesn't interfere w/ the check for default arguments\n-struct S { this(int x = 1, int y) { } }"}, {"sha": "7cf3023aedbdf163f05f9760bf379074a131e137", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8894.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8894.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8894.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8894.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,10 +1,10 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag8894.d(16): Error: no property `x` for type `diag8894.Foo`\n-fail_compilation/diag8894.d(17): Error: no property `y` for type `diag8894.Foo`\n-fail_compilation/diag8894.d(18): Error: no property `x` for type `diag8894.Foo`\n-fail_compilation/diag8894.d(19): Error: no property `x` for type `diag8894.Foo`\n+fail_compilation/diag8894.d(16): Error: no property `x` for `f` of type `diag8894.Foo`\n+fail_compilation/diag8894.d(17): Error: no property `y` for `f` of type `diag8894.Foo`\n+fail_compilation/diag8894.d(18): Error: no property `x` for `f` of type `diag8894.Foo`\n+fail_compilation/diag8894.d(19): Error: no property `x` for `f` of type `diag8894.Foo`\n ---\n */\n "}, {"sha": "324d21733af0686acee0455ac92aae256261731d", "filename": "gcc/testsuite/gdc.test/fail_compilation/dip22a.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip22a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip22a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip22a.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2,11 +2,11 @@\n EXTRA_FILES: imports/dip22a.d\n TEST_OUTPUT:\n ---\n-fail_compilation/dip22a.d(16): Error: no property `bar` for type `imports.dip22a.Klass`\n-fail_compilation/dip22a.d(17): Error: no property `bar` for type `imports.dip22a.Struct`\n+fail_compilation/dip22a.d(16): Error: no property `bar` for `new Klass` of type `imports.dip22a.Klass`\n+fail_compilation/dip22a.d(17): Error: no property `bar` for `Struct()` of type `imports.dip22a.Struct`\n fail_compilation/dip22a.d(18): Error: undefined identifier `bar` in module `imports.dip22a`\n-fail_compilation/dip22a.d(19): Error: no property `bar` for type `void`\n-fail_compilation/dip22a.d(20): Error: no property `bar` for type `int`\n+fail_compilation/dip22a.d(19): Error: no property `bar` for `Template!int` of type `void`\n+fail_compilation/dip22a.d(20): Error: no property `bar` for `12` of type `int`\n ---\n */\n import imports.dip22a;"}, {"sha": "92e07342d49b008e23111763c4b7dbd2ab63201e", "filename": "gcc/testsuite/gdc.test/fail_compilation/e15876_1.d", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_1.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,14 +1,15 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/e15876_1.d(15): Error: valid scope identifiers are `exit`, `failure`, or `success`, not `x`\n-fail_compilation/e15876_1.d(16): Error: found `End of File` when expecting `)`\n-fail_compilation/e15876_1.d(16): Error: found `End of File` instead of statement\n-fail_compilation/e15876_1.d(16): Error: found `End of File` when expecting `}` following compound statement\n-fail_compilation/e15876_1.d(16): Error: found `End of File` when expecting `]`\n-fail_compilation/e15876_1.d(16): Error: no identifier for declarator `o[()\n+fail_compilation/e15876_1.d(16): Error: valid scope identifiers are `exit`, `failure`, or `success`, not `x`\n+fail_compilation/e15876_1.d(17): Error: found `End of File` when expecting `)`\n+fail_compilation/e15876_1.d(17): Error: found `End of File` instead of statement\n+fail_compilation/e15876_1.d(17): Error: found `End of File` when expecting `}` following compound statement\n+fail_compilation/e15876_1.d(17): Error: found `End of File` when expecting `]`\n+fail_compilation/e15876_1.d(17): Error: no identifier for declarator `o[()\n {\n-scope(exit) }\n+scope(exit) __error__\n+}\n ]`\n ---\n */"}, {"sha": "fe7d546f51b7b6a9ae2fbb7ee87bcadb50b4f011", "filename": "gcc/testsuite/gdc.test/fail_compilation/e15876_3.d", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_3.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,25 +1,27 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/e15876_3.d(25): Error: unexpected `(` in declarator\n-fail_compilation/e15876_3.d(25): Error: basic type expected, not `=`\n-fail_compilation/e15876_3.d(26): Error: found `End of File` when expecting `(`\n-fail_compilation/e15876_3.d(26): Error: found `End of File` instead of statement\n-fail_compilation/e15876_3.d(26): Error: expression expected, not `End of File`\n-fail_compilation/e15876_3.d(26): Error: found `End of File` when expecting `;` following `for` condition\n-fail_compilation/e15876_3.d(26): Error: expression expected, not `End of File`\n-fail_compilation/e15876_3.d(26): Error: found `End of File` when expecting `)`\n-fail_compilation/e15876_3.d(26): Error: found `End of File` instead of statement\n-fail_compilation/e15876_3.d(26): Error: found `End of File` when expecting `}` following compound statement\n-fail_compilation/e15876_3.d(26): Error: found `End of File` when expecting `)`\n-fail_compilation/e15876_3.d(26): Error: no identifier for declarator `d(_error_ = ()\n+fail_compilation/e15876_3.d(27): Error: unexpected `(` in declarator\n+fail_compilation/e15876_3.d(27): Error: basic type expected, not `=`\n+fail_compilation/e15876_3.d(28): Error: found `End of File` when expecting `(`\n+fail_compilation/e15876_3.d(28): Error: found `End of File` instead of statement\n+fail_compilation/e15876_3.d(28): Error: expression expected, not `End of File`\n+fail_compilation/e15876_3.d(28): Error: found `End of File` when expecting `;` following `for` condition\n+fail_compilation/e15876_3.d(28): Error: expression expected, not `End of File`\n+fail_compilation/e15876_3.d(28): Error: found `End of File` when expecting `)`\n+fail_compilation/e15876_3.d(28): Error: found `End of File` instead of statement\n+fail_compilation/e15876_3.d(28): Error: found `End of File` when expecting `}` following compound statement\n+fail_compilation/e15876_3.d(28): Error: found `End of File` when expecting `)`\n+fail_compilation/e15876_3.d(28): Error: no identifier for declarator `d(_error_ = ()\n {\n-for (; 0; 0)\n+for (__error__\n+ 0; 0)\n {\n+__error__\n }\n }\n )`\n-fail_compilation/e15876_3.d(26): Error: semicolon expected following function declaration\n+fail_compilation/e15876_3.d(28): Error: semicolon expected following function declaration\n ---\n */\n d(={for"}, {"sha": "f4bd407b9c0eb84a61bff04dfd1c6b3779ca02a0", "filename": "gcc/testsuite/gdc.test/fail_compilation/e15876_4.d", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_4.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_4.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_4.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,20 +1,22 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/e15876_4.d(23): Error: found `)` when expecting `(`\n-fail_compilation/e15876_4.d(24): Error: found `End of File` when expecting `(`\n-fail_compilation/e15876_4.d(24): Error: found `End of File` instead of statement\n-fail_compilation/e15876_4.d(24): Error: expression expected, not `End of File`\n-fail_compilation/e15876_4.d(24): Error: found `End of File` when expecting `;` following `for` condition\n-fail_compilation/e15876_4.d(24): Error: expression expected, not `End of File`\n-fail_compilation/e15876_4.d(24): Error: found `End of File` when expecting `)`\n-fail_compilation/e15876_4.d(24): Error: found `End of File` instead of statement\n-fail_compilation/e15876_4.d(24): Error: found `End of File` when expecting `}` following compound statement\n-fail_compilation/e15876_4.d(24): Error: found `End of File` when expecting `)`\n-fail_compilation/e15876_4.d(24): Error: no identifier for declarator `typeof(()\n+fail_compilation/e15876_4.d(25): Error: found `)` when expecting `(`\n+fail_compilation/e15876_4.d(26): Error: found `End of File` when expecting `(`\n+fail_compilation/e15876_4.d(26): Error: found `End of File` instead of statement\n+fail_compilation/e15876_4.d(26): Error: expression expected, not `End of File`\n+fail_compilation/e15876_4.d(26): Error: found `End of File` when expecting `;` following `for` condition\n+fail_compilation/e15876_4.d(26): Error: expression expected, not `End of File`\n+fail_compilation/e15876_4.d(26): Error: found `End of File` when expecting `)`\n+fail_compilation/e15876_4.d(26): Error: found `End of File` instead of statement\n+fail_compilation/e15876_4.d(26): Error: found `End of File` when expecting `}` following compound statement\n+fail_compilation/e15876_4.d(26): Error: found `End of File` when expecting `)`\n+fail_compilation/e15876_4.d(26): Error: no identifier for declarator `typeof(()\n {\n-for (; 0; 0)\n+for (__error__\n+ 0; 0)\n {\n+__error__\n }\n }\n )`"}, {"sha": "cfda8f4d9ad00a3fd1b653bc2ba079c9575cb074", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail10968.d", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,27 +1,28 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail10968.d(42): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(42): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(43): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(43): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(44): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(44): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(44): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.arrayassign._d_arrayassign_l!(SA[], SA)._d_arrayassign_l`\n-fail_compilation/fail10968.d(47): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(47): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(44): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.arrayassign._d_arraysetassign!(SA[], SA)._d_arraysetassign`\n+fail_compilation/fail10968.d(45): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(45): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(45): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.arrayassign._d_arrayassign_l!(SA[], SA)._d_arrayassign_l`\n fail_compilation/fail10968.d(48): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(48): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(48): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arraysetctor!(SA[], SA)._d_arraysetctor`\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(49): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(49): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(49): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arrayctor!(SA[], SA)._d_arrayctor`\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(49): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arraysetctor!(SA[], SA)._d_arraysetctor`\n+fail_compilation/fail10968.d(50): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(50): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(50): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arrayctor!(SA[], SA)._d_arrayctor`\n ---\n */\n \n@@ -52,12 +53,12 @@ void bar() pure @safe\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail10968.d(75): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(76): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(77): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n-fail_compilation/fail10968.d(80): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n+fail_compilation/fail10968.d(78): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(81): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(82): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n+fail_compilation/fail10968.d(83): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n ---\n */\n "}, {"sha": "8d5af747ce15406fb80a89cb25f81569ce8ea9ba", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail121.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail121.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail121.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail121.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3,8 +3,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail121.d(23): Error: no property `typeinfo` for type `fail121.myobject`\n-fail_compilation/fail121.d(23): Error: no property `typeinfo` for type `int`\n+fail_compilation/fail121.d(23): Error: no property `typeinfo` for `list[1]` of type `fail121.myobject`\n+fail_compilation/fail121.d(23): Error: no property `typeinfo` for `i` of type `int`\n ---\n */\n "}, {"sha": "7784cba67be5efce30c37268e19a69d6a4c774f1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail13123.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail13123.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail13123.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail13123.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,21 @@\n+// REQUIRED_ARGS: -de\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail13123.d(10): Deprecation: `fail13123.test`: `in` contract may throw but function is marked as `nothrow`\n+fail_compilation/fail13123.d(10): Deprecation: `fail13123.test`: `out` contract may throw but function is marked as `nothrow`\n+---\n+*/\n+\n+void test() nothrow\n+in\n+{\n+    throw new Exception(null);\n+}\n+out\n+{\n+    throw new Exception(null);\n+}\n+do\n+{\n+}"}, {"sha": "39e7cb9eb7377b43e6f301380ceb679b7db2b283", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17646.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17646.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17646.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17646.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -4,9 +4,8 @@ EXTRA_FILES: imports/fail17646.d\n TEST_OUTPUT:\n ---\n fail_compilation/imports/fail17646.d(10): Error: found `}` instead of statement\n-fail_compilation/imports/fail17646.d(7): Error: function `imports.fail17646.allTestData!\"\".allTestData` has no `return` statement, but is expected to return a value of type `const(TestData)[]`\n-fail_compilation/fail17646.d(16): Error: template instance `imports.fail17646.allTestData!\"\"` error instantiating\n-fail_compilation/fail17646.d(19):        instantiated from here: `runTests!\"\"`\n+fail_compilation/fail17646.d(11): Error: function `fail17646.runTests!\"\".runTests` has no `return` statement, but is expected to return a value of type `int`\n+fail_compilation/fail17646.d(18): Error: template instance `fail17646.runTests!\"\"` error instantiating\n ---\n */\n int runTests(Modules...)()"}, {"sha": "0fb56d315e97ae7f8da6f41e0ce0b76b2288834b", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18892.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18892.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18892.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18892.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,8 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail18892.d(20): Error: no property `foo` for type `fail18892.MT`\n-fail_compilation/fail18892.d(21): Error: no property `foo` for type `fail18892.MT`\n+fail_compilation/fail18892.d(20): Error: no property `foo` for `a` of type `fail18892.MT`\n+fail_compilation/fail18892.d(21): Error: no property `foo` for `MT` of type `fail18892.MT`\n ---\n */\n "}, {"sha": "a8156fe7d1efc7347457f29df1c443ae25144d14", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18970.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18970.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18970.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18970.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,9 +1,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail18970.d(24): Error: no property `y` for type `fail18970.S`\n+fail_compilation/fail18970.d(24): Error: no property `y` for `S()` of type `fail18970.S`\n fail_compilation/fail18970.d(24):        potentially malformed `opDispatch`. Use an explicit instantiation to get a better error message\n-fail_compilation/fail18970.d(31): Error: no property `yyy` for type `fail18970.S2`\n+fail_compilation/fail18970.d(31): Error: no property `yyy` for `this` of type `fail18970.S2`\n fail_compilation/fail18970.d(31):        potentially malformed `opDispatch`. Use an explicit instantiation to get a better error message\n ---\n */"}, {"sha": "04e36f623ff79be2ab4879c8d4f8790cdaf05575", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18979.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18979.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18979.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18979.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2,7 +2,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail18979.d(13): Error: no property `__ctor` for type `imports.imp18979.Foo`\n+fail_compilation/fail18979.d(13): Error: no property `__ctor` for `Foo()` of type `imports.imp18979.Foo`\n ----\n */\n "}, {"sha": "40fafcdc1ae0e823f4bb72b7ae93418c4a0a5320", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19103.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19103.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19103.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19103.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,8 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail19103.d(12): Error: no property `puts` for type `fail19103.C`\n-fail_compilation/fail19103.d(14): Error: no property `puts` for type `fail19103.S1`\n+fail_compilation/fail19103.d(12): Error: no property `puts` for `new C` of type `fail19103.C`\n+fail_compilation/fail19103.d(14): Error: no property `puts` for `s1` of type `fail19103.S1`\n fail_compilation/fail19103.d(16): Error: no property `puts` for type `S2`, did you mean `core.stdc.stdio.puts`?\n ---\n */"}, {"sha": "0076091b8a1cacb07099fa538b23c0f833086f76", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19687.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19687.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19687.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19687.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail19687.d(17): Error: no property `nonexisting` for type `string`\n+fail_compilation/fail19687.d(17): Error: no property `nonexisting` for `\"\"` of type `string`\n ---\n */\n "}, {"sha": "c880923ae407d3be405238e82e3dce2518a954c2", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19913.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19913.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19913.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19913.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail19913.d(11): Error: no property `b` for type `int`\n+fail_compilation/fail19913.d(11): Error: no property `b` for `a` of type `int`\n fail_compilation/fail19913.d(11): Error: mixin `fail19913.S.b!()` is not defined\n ---\n */"}, {"sha": "25df235e9cb6ca29fabcc48cf111dc0030dce76a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail21243.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21243.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21243.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21243.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,19 @@\n+/+ TEST_OUTPUT:\n+---\n+fail_compilation/fail21243.d(16): Error: found `(` when expecting `ref` and function literal following `auto`\n+fail_compilation/fail21243.d(16): Error: semicolon expected following auto declaration, not `int`\n+fail_compilation/fail21243.d(16): Error: semicolon needed to end declaration of `x` instead of `)`\n+fail_compilation/fail21243.d(16): Error: declaration expected, not `)`\n+fail_compilation/fail21243.d(17): Error: `auto` can only be used as part of `auto ref` for function literal return values\n+fail_compilation/fail21243.d(18): Error: basic type expected, not `(`\n+fail_compilation/fail21243.d(18): Error: function declaration without return type. (Note that constructors are always named `this`)\n+fail_compilation/fail21243.d(18): Deprecation: storage class `auto` has no effect in type aliases\n+fail_compilation/fail21243.d(18): Error: semicolon expected to close `alias` declaration\n+fail_compilation/fail21243.d(18): Error: declaration expected, not `=>`\n+fail_compilation/fail21243.d(19): Error: `auto` can only be used as part of `auto ref` for function literal return values\n+---\n++/\n+auto a = auto (int x) => x;\n+auto b = function auto (int x) { return x; };\n+alias c = auto (int x) => x;\n+alias d = function auto (int x) { return x; };"}, {"sha": "5c5c11b719535cbcfe00c0762d7008c6811b0f9f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail23109.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23109.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23109.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23109.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -4,8 +4,8 @@ EXTRA_FILES: imports/test23109a.d imports/test23109b.d imports/test23109c.d\n EXTRA_SOURCES: extra-files/test23109/object.d\n TEST_OUTPUT:\n ---\n-Error: no property `getHash` for type `object.TypeInfo_Const`\n-Error: no property `getHash` for type `object.TypeInfo_Const`\n+Error: no property `getHash` for `typeid(const(Ensure[]))` of type `object.TypeInfo_Const`\n+Error: no property `getHash` for `typeid(const(Ensure[1]))` of type `object.TypeInfo_Const`\n fail_compilation/imports/test23109a.d(10): Error: template instance `imports.test23109a.Array!(Ensure)` error instantiating\n ---\n */"}, {"sha": "2d56e0969c28be579bdd9edea202961ddd89332a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail7372.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7372.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7372.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7372.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,13 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/imports/fail7372.d(7): Error: undefined identifier `X`\n+fail_compilation/fail7372.d(4):        parent scope from here: `mixin Issue7372!()`\n+---\n+*/\n+#line 1\n+import imports.fail7372;\n+interface I {}\n+class C : I {\n+    mixin Issue7372!();\n+}"}, {"sha": "c44b289cceca5d7a1f90c2d464cf30e6ef25ba17", "filename": "gcc/testsuite/gdc.test/fail_compilation/faildottypeinfo.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffaildottypeinfo.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffaildottypeinfo.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffaildottypeinfo.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/faildottypeinfo.d(11): Error: no property `typeinfo` for type `int`\n+fail_compilation/faildottypeinfo.d(11): Error: no property `typeinfo` for `0` of type `int`\n fail_compilation/faildottypeinfo.d(12): Error: no property `typeinfo` for type `object.Object`\n ---\n */"}, {"sha": "ff0d26be6737f67d2856cbcbabbe315fc97a6fdf", "filename": "gcc/testsuite/gdc.test/fail_compilation/failoffset.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailoffset.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailoffset.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailoffset.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/failoffset.d(12): Error: no property `offset` for type `int`\n+fail_compilation/failoffset.d(12): Error: no property `offset` for `b` of type `int`\n fail_compilation/failoffset.d(12):        while evaluating: `static assert(b.offset == 4)`\n ---\n */"}, {"sha": "d21ee47dec749fd590185ae7b64ecc2c19d4ba04", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice10938.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10938.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10938.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10938.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice10938.d(13): Error: no property `opts` for type `ice10938.C`\n+fail_compilation/ice10938.d(13): Error: no property `opts` for `this` of type `ice10938.C`\n fail_compilation/ice10938.d(13):        potentially malformed `opDispatch`. Use an explicit instantiation to get a better error message\n ---\n */"}, {"sha": "dbe386e97e996d1f129fe2893c574c87db7f4ff1", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice12174.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12174.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12174.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12174.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice12174.d(12): Error: no property `sum` for type `int[]`\n+fail_compilation/ice12174.d(12): Error: no property `sum` for `[1, 2, 3]` of type `int[]`\n fail_compilation/ice12174.d(20): Error: CTFE failed because of previous errors in `this`\n fail_compilation/ice12174.d(13):        called from here: `filter([1, 2, 3])`\n ---"}, {"sha": "b26fe4cda046f740de7c1417d28ac8dd1dcb13e5", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice15855.d", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice15855.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice15855.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice15855.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2,19 +2,21 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice15855.d(25): Error: found `End of File` when expecting `(`\n-fail_compilation/ice15855.d(25): Error: found `End of File` instead of statement\n-fail_compilation/ice15855.d(25): Error: expression expected, not `End of File`\n-fail_compilation/ice15855.d(25): Error: found `End of File` when expecting `;` following `for` condition\n-fail_compilation/ice15855.d(25): Error: expression expected, not `End of File`\n-fail_compilation/ice15855.d(25): Error: found `End of File` when expecting `)`\n-fail_compilation/ice15855.d(25): Error: found `End of File` instead of statement\n-fail_compilation/ice15855.d(25): Error: found `End of File` when expecting `}` following compound statement\n-fail_compilation/ice15855.d(25): Error: found `End of File` when expecting `]`\n-fail_compilation/ice15855.d(25): Error: no identifier for declarator `a[()\n+fail_compilation/ice15855.d(27): Error: found `End of File` when expecting `(`\n+fail_compilation/ice15855.d(27): Error: found `End of File` instead of statement\n+fail_compilation/ice15855.d(27): Error: expression expected, not `End of File`\n+fail_compilation/ice15855.d(27): Error: found `End of File` when expecting `;` following `for` condition\n+fail_compilation/ice15855.d(27): Error: expression expected, not `End of File`\n+fail_compilation/ice15855.d(27): Error: found `End of File` when expecting `)`\n+fail_compilation/ice15855.d(27): Error: found `End of File` instead of statement\n+fail_compilation/ice15855.d(27): Error: found `End of File` when expecting `}` following compound statement\n+fail_compilation/ice15855.d(27): Error: found `End of File` when expecting `]`\n+fail_compilation/ice15855.d(27): Error: no identifier for declarator `a[()\n {\n-for (; 0; 0)\n+for (__error__\n+ 0; 0)\n {\n+__error__\n }\n }\n ]`"}, {"sha": "796dd3dcc9decdb2f70635523633cd8ff93ba065", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice18469.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice18469.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice18469.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice18469.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice18469.d(10): Error: no property `opCall` for type `void`\n+fail_compilation/ice18469.d(10): Error: no property `opCall` for `this.~this()` of type `void`\n ---\n */\n class Bar"}, {"sha": "6d60fc43c1b2724d13c706201c2da13c0435bca5", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice19755.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice19755.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice19755.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice19755.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,6 +1,6 @@\n /* TEST_OUTPUT:\n ---\n-fail_compilation/ice19755.d(11): Error: no property `x` for type `ice19755.Thunk!int*`\n+fail_compilation/ice19755.d(11): Error: no property `x` for `self` of type `ice19755.Thunk!int*`\n fail_compilation/ice19755.d(16): Error: template instance `ice19755.Thunk!int` error instantiating\n ---\n */"}, {"sha": "f71c7367c700c5e5d4be936f9e79ba152d31b54b", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/fail7372.d", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail7372.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail7372.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail7372.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,9 @@\n+module imports.fail7372;\n+import imports.imp1;\n+mixin template Issue7372()\n+{\n+    public void f()\n+    {\n+        int foo = X;\n+    }\n+}"}, {"sha": "11fddf069d6df4457b88ce4bbcdd713c505ade64", "filename": "gcc/testsuite/gdc.test/fail_compilation/misc_parser_err_cov1.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc_parser_err_cov1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc_parser_err_cov1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc_parser_err_cov1.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -22,7 +22,6 @@ fail_compilation/misc_parser_err_cov1.d(39): Error: expression expected, not `;`\n fail_compilation/misc_parser_err_cov1.d(40): Error: semicolon expected following auto declaration, not `auto`\n fail_compilation/misc_parser_err_cov1.d(40): Error: identifier or `new` expected following `.`, not `+`\n fail_compilation/misc_parser_err_cov1.d(41): Error: identifier or new keyword expected following `(...)`.\n-fail_compilation/misc_parser_err_cov1.d(41): Error: found `.` when expecting `;` following statement\n fail_compilation/misc_parser_err_cov1.d(41): Error: expression expected, not `;`\n fail_compilation/misc_parser_err_cov1.d(42): Error: found `}` when expecting `;` following statement\n fail_compilation/misc_parser_err_cov1.d(43): Error: found `End of File` when expecting `}` following compound statement"}, {"sha": "db8bf5968ddc70c57ff2b859e29d9f54d12d2e88", "filename": "gcc/testsuite/gdc.test/fail_compilation/mixinprop.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixinprop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixinprop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixinprop.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,13 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/mixinprop.d(12): Error: no property `x` for `mixin Foo!() F;\n+` of type `void`\n+---\n+*/\n+mixin template Foo() { }\n+\n+void main()\n+{\n+    mixin Foo F;\n+    F.x;\n+}"}, {"sha": "594b5d35e758bd184f4b5c7ddb44f9327c0d0d10", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15785.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15785.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15785.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15785.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2,7 +2,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/test15785.d(16): Error: no property `foo` for type `imports.test15785.Base`\n+fail_compilation/test15785.d(16): Error: no property `foo` for `super` of type `imports.test15785.Base`\n fail_compilation/test15785.d(17): Error: undefined identifier `bar`\n ---\n */"}, {"sha": "db554cb9e15a1610bdbcd8a65bff1b6836bb7304", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15897.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15897.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15897.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15897.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3,7 +3,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/test15897.d(19): Error: no property `create` for type `imports.test15897.Cat`\n+fail_compilation/test15897.d(19): Error: no property `create` for `cat` of type `imports.test15897.Cat`\n ---\n */\n module test15897;"}, {"sha": "bdaae94a6ca3ae273fbd65865cc8953cee974bdf", "filename": "gcc/testsuite/gdc.test/fail_compilation/test16188.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16188.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16188.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16188.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,7 +1,7 @@\n /* REQUIRED_ARGS: -preview=bitfields\n  * TEST_OUTPUT:\n ---\n-fail_compilation/test16188.d(101): Error: no property `name` for type `test16188.Where`\n+fail_compilation/test16188.d(101): Error: no property `name` for `Where()` of type `test16188.Where`\n fail_compilation/test16188.d(101):        potentially malformed `opDispatch`. Use an explicit instantiation to get a better error message\n ---\n  */"}, {"sha": "f523337037af5267c8e2b3223182ae191d8214ea", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17380spec.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17380spec.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17380spec.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17380spec.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n (spec:1) fail_compilation/test17380spec.d(14): Error: cannot resolve identifier `ThisTypeDoesNotExistAndCrashesTheCompiler`\n-(spec:1) fail_compilation/test17380spec.d(14): Error: no property `ThisTypeDoesNotExistAndCrashesTheCompiler` for type `test17380spec.Uint128`\n+(spec:1) fail_compilation/test17380spec.d(14): Error: no property `ThisTypeDoesNotExistAndCrashesTheCompiler` for `this.opCast()` of type `test17380spec.Uint128`\n fail_compilation/test17380spec.d(14): Error: undefined identifier `ThisTypeDoesNotExistAndCrashesTheCompiler`\n ---\n  */"}, {"sha": "302eb3da31a132ae18cc521f0587bcacb89871b2", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21096.d", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21096.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21096.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21096.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3,10 +3,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/test21096.d(13): Error: identifier or new keyword expected following `(...)`.\n-fail_compilation/test21096.d(13): Error: found `.` when expecting `]`\n-fail_compilation/test21096.d(13): Error: no identifier for declarator `char`\n-fail_compilation/test21096.d(13): Error: declaration expected, not `]`\n+fail_compilation/test21096.d(11): Error: identifier or new keyword expected following `(...)`.\n+fail_compilation/test21096.d(11): Error: no identifier for declarator `char[(__error)]`\n ---\n */\n "}, {"sha": "caf0f4adff4a5c2f01e91f3b5b5eec2b179c40c6", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22680.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22680.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22680.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22680.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,17 @@\n+/* REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/test22680.d(104): Error: scope variable `this` assigned to non-scope `c`\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22680\n+\n+#line 100\n+\n+C c;\n+class C {\n+    ~this() @safe {\n+\t    c = this;\n+    }\n+}"}, {"sha": "94e79d5896a858e11eed102c1cf7c5f5a602ea6d", "filename": "gcc/testsuite/gdc.test/runnable/newaa.d", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnewaa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnewaa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnewaa.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,23 @@\n+void main()\n+{\n+    alias AA = int[string];\n+    // aa is not ref\n+    static void test(AA aa)\n+    {\n+        aa[\"\"] = 0;\n+    }\n+    auto aa = new AA();\n+    auto ab = new int[string];\n+    auto ac = new typeof(aa);\n+    test(aa);\n+    test(ab);\n+    test(ac);\n+    assert(aa.length);\n+    assert(ab.length);\n+    assert(ac.length);\n+\n+    int[string] a = new int[string];\n+    auto b = a;\n+    a[\"seven\"] = 7;\n+    assert(b[\"seven\"] == 7);\n+}"}, {"sha": "7872aa76dfe2571767dbea51022a33e2da609c7f", "filename": "gcc/testsuite/gdc.test/runnable/test23234.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23234.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23234.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23234.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -0,0 +1,22 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23234\n+\n+class Bar\n+{\n+}\n+\n+class Foo\n+{\n+    Bar get() { return new Bar; }\n+    alias get this;\n+}\n+\n+void main()\n+{\n+    auto foo = new Foo;\n+    void test(Bar delegate() dg)\n+    {\n+        assert(dg() !is null);\n+    }\n+\n+    test(() => foo);\n+}"}, {"sha": "586aea80ccef258b2891116bfc0c6a5da9f8095d", "filename": "gcc/testsuite/gdc.test/runnable/testassign.d", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestassign.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -230,6 +230,21 @@ void test5()\n     static assert(!__traits(compiles, s.err += 1));\n }\n \n+void test6()\n+{\n+    int dtors;\n+    struct S6\n+    {\n+        @disable this(this);\n+        ~this() { dtors++; }\n+    }\n+\n+    S6[2] arr;\n+    arr = S6();\n+\n+    assert(dtors == 2);\n+}\n+\n /***************************************************/\n // https://issues.dlang.org/show_bug.cgi?id=4424\n \n@@ -1192,6 +1207,7 @@ int main()\n     test3();\n     test4();\n     test5();\n+    test6();\n     test4424();\n     test6174a();\n     test6174b();"}, {"sha": "a4c46f3306ede57b9563edfe93b88cb6026ed42b", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,4 +1,4 @@\n-817610b16d0f0f469b9fbb28c000956fb910c43f\n+4219ba670ce9ff92f3e874f0f048f2c28134c008\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "45749d7ef103b1a4b60d6a2bfc40e20fafb88d7b", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -211,11 +211,11 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tgcc/sections/package.d gcc/sections/pecoff.d gcc/simd.d \\\n \tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n \tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n-\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n-\trt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d rt/deh.d \\\n-\trt/dmain2.d rt/ehalloc.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n-\trt/minfo.d rt/monitor_.d rt/profilegc.d rt/sections.d rt/tlsgc.d \\\n-\trt/util/typeinfo.d rt/util/utility.d\n+\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arraycat.d rt/cast_.d \\\n+\trt/config.d rt/critical_.d rt/deh.d rt/dmain2.d rt/ehalloc.d \\\n+\trt/invariant.d rt/lifetime.d rt/memory.d rt/minfo.d rt/monitor_.d \\\n+\trt/profilegc.d rt/sections.d rt/tlsgc.d rt/util/typeinfo.d \\\n+\trt/util/utility.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/allocator.d core/stdcpp/array.d \\\n \tcore/stdcpp/exception.d core/stdcpp/memory.d core/stdcpp/new_.d \\"}, {"sha": "e86721fb3feeaecf5db75b434c7de7c9d02d2c2f", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -242,11 +242,11 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tgcc/unwind/arm_common.lo gcc/unwind/c6x.lo \\\n \tgcc/unwind/generic.lo gcc/unwind/package.lo gcc/unwind/pe.lo \\\n \tobject.lo rt/aApply.lo rt/aApplyR.lo rt/aaA.lo rt/adi.lo \\\n-\trt/arrayassign.lo rt/arraycat.lo rt/cast_.lo rt/config.lo \\\n-\trt/critical_.lo rt/deh.lo rt/dmain2.lo rt/ehalloc.lo \\\n-\trt/invariant.lo rt/lifetime.lo rt/memory.lo rt/minfo.lo \\\n-\trt/monitor_.lo rt/profilegc.lo rt/sections.lo rt/tlsgc.lo \\\n-\trt/util/typeinfo.lo rt/util/utility.lo\n+\trt/arraycat.lo rt/cast_.lo rt/config.lo rt/critical_.lo \\\n+\trt/deh.lo rt/dmain2.lo rt/ehalloc.lo rt/invariant.lo \\\n+\trt/lifetime.lo rt/memory.lo rt/minfo.lo rt/monitor_.lo \\\n+\trt/profilegc.lo rt/sections.lo rt/tlsgc.lo rt/util/typeinfo.lo \\\n+\trt/util/utility.lo\n am__objects_2 = core/stdc/libgdruntime_la-errno_.lo\n am__objects_3 = core/sys/elf/package.lo\n am__objects_4 = core/stdcpp/allocator.lo core/stdcpp/array.lo \\\n@@ -880,11 +880,11 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tgcc/sections/package.d gcc/sections/pecoff.d gcc/simd.d \\\n \tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n \tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n-\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n-\trt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d rt/deh.d \\\n-\trt/dmain2.d rt/ehalloc.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n-\trt/minfo.d rt/monitor_.d rt/profilegc.d rt/sections.d rt/tlsgc.d \\\n-\trt/util/typeinfo.d rt/util/utility.d\n+\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arraycat.d rt/cast_.d \\\n+\trt/config.d rt/critical_.d rt/deh.d rt/dmain2.d rt/ehalloc.d \\\n+\trt/invariant.d rt/lifetime.d rt/memory.d rt/minfo.d rt/monitor_.d \\\n+\trt/profilegc.d rt/sections.d rt/tlsgc.d rt/util/typeinfo.d \\\n+\trt/util/utility.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/allocator.d core/stdcpp/array.d \\\n \tcore/stdcpp/exception.d core/stdcpp/memory.d core/stdcpp/new_.d \\\n@@ -1364,7 +1364,6 @@ rt/aApply.lo: rt/$(am__dirstamp)\n rt/aApplyR.lo: rt/$(am__dirstamp)\n rt/aaA.lo: rt/$(am__dirstamp)\n rt/adi.lo: rt/$(am__dirstamp)\n-rt/arrayassign.lo: rt/$(am__dirstamp)\n rt/arraycat.lo: rt/$(am__dirstamp)\n rt/cast_.lo: rt/$(am__dirstamp)\n rt/config.lo: rt/$(am__dirstamp)"}, {"sha": "1c49035890471e6cbe3d0aa6a58e39fb5bf1c09a", "filename": "libphobos/libdruntime/__builtins.di", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2F__builtins.di", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2F__builtins.di", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2F__builtins.di?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -15,7 +15,7 @@ module __builtins;\n /* gcc relies on internal __builtin_xxxx functions and templates to\n  * accomplish <stdarg.h>. D does the same thing with templates in core.stdc.stdarg.\n  * Here, we redirect the gcc builtin declarations to the equivalent\n- * ones in core.stdc.stdarg, thereby avoiding having to hardware them\n+ * ones in core.stdc.stdarg, thereby avoiding having to hardwire them\n  * into the D compiler.\n  */\n "}, {"sha": "c2d40322961d338b8328def9c5e42a17d5dac61b", "filename": "libphobos/libdruntime/core/demangle.d", "status": "modified", "additions": 185, "deletions": 65, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -82,7 +82,7 @@ pure @safe:\n \n     static class ParseException : Exception\n     {\n-        @safe pure nothrow this( string msg )\n+        this(string msg) @safe pure nothrow\n         {\n             super( msg );\n         }\n@@ -91,14 +91,14 @@ pure @safe:\n \n     static class OverflowException : Exception\n     {\n-        @safe pure nothrow this( string msg )\n+        this(string msg) @safe pure nothrow\n         {\n             super( msg );\n         }\n     }\n \n \n-    static void error( string msg = \"Invalid symbol\" ) @trusted /* exception only used in module */\n+    static noreturn error( string msg = \"Invalid symbol\" ) @trusted /* exception only used in module */\n     {\n         pragma(inline, false); // tame dmd inliner\n \n@@ -110,7 +110,7 @@ pure @safe:\n     }\n \n \n-    static void overflow( string msg = \"Buffer overflow\" ) @trusted /* exception only used in module */\n+    static noreturn overflow( string msg = \"Buffer overflow\" ) @trusted /* exception only used in module */\n     {\n         pragma(inline, false); // tame dmd inliner\n \n@@ -156,7 +156,6 @@ pure @safe:\n         if (val >= '0' && val <= '9')\n             return cast(ubyte)(val - '0');\n         error();\n-        return 0;\n     }\n \n \n@@ -253,23 +252,22 @@ pure @safe:\n             put(\", \");\n     }\n \n-    char[] put(char c) return scope\n+    void put(char c) return scope\n     {\n         char[1] val = c;\n-        return put(val[]);\n+        put(val[]);\n     }\n \n-    char[] put( scope const(char)[] val ) return scope\n+    void put(scope const(char)[] val) return scope\n     {\n         pragma(inline, false); // tame dmd inliner\n \n-        if ( val.length )\n-        {\n-            if ( !contains( dst[0 .. len], val ) )\n-                return append( val );\n-            return shift( val );\n-        }\n-        return null;\n+        if (!val.length) return;\n+\n+        if (!contains(dst[0 .. len], val))\n+            append(val);\n+        else\n+            shift(val);\n     }\n \n \n@@ -948,18 +946,19 @@ pure @safe:\n             return dst[beg .. len];\n         case 'D': // TypeDelegate (D TypeFunction)\n             popFront();\n-            auto modbeg = len;\n-            parseModifier();\n-            auto modend = len;\n+            auto modifiers = parseModifier();\n             if ( front == 'Q' )\n                 parseBackrefType( () => parseTypeFunction( name, IsDelegate.yes ) );\n             else\n                 parseTypeFunction( name, IsDelegate.yes );\n-            if (modend > modbeg)\n+            if (modifiers)\n             {\n-                // move modifiers behind the function arguments\n-                shift(dst[modend-1 .. modend]); // trailing space\n-                shift(dst[modbeg .. modend-1]);\n+                // write modifiers behind the function arguments\n+                while (auto str = typeCtors.toStringConsume(modifiers))\n+                {\n+                    put(' ');\n+                    put(str);\n+                }\n             }\n             return dst[beg .. len];\n         case 'n': // TypeNone (n)\n@@ -1009,7 +1008,6 @@ pure @safe:\n                 }\n             }\n             error();\n-            return null;\n         }\n     }\n \n@@ -1110,71 +1108,72 @@ pure @safe:\n         }\n     }\n \n-    void parseModifier()\n+    /// Returns: Flags of `TypeCtor`\n+    ushort parseModifier()\n     {\n+        TypeCtor res = TypeCtor.None;\n         switch ( front )\n         {\n         case 'y':\n             popFront();\n-            put( \"immutable \" );\n-            break;\n+            return TypeCtor.Immutable;\n         case 'O':\n             popFront();\n-            put( \"shared \" );\n-            if ( front == 'x' )\n+            res |= TypeCtor.Shared;\n+            if (front == 'x')\n                 goto case 'x';\n-            if ( front == 'N' )\n+            if (front == 'N')\n                 goto case 'N';\n-            break;\n+            return TypeCtor.Shared;\n         case 'N':\n-            if ( peek( 1 ) != 'g' )\n-                break;\n+            if (peek( 1 ) != 'g')\n+                return res;\n             popFront();\n             popFront();\n-            put( \"inout \" );\n+            res |= TypeCtor.InOut;\n             if ( front == 'x' )\n                 goto case 'x';\n-            break;\n+            return res;\n         case 'x':\n             popFront();\n-            put( \"const \" );\n-            break;\n-        default: break;\n+            res |= TypeCtor.Const;\n+            return res;\n+        default: return TypeCtor.None;\n         }\n     }\n \n-    void parseFuncAttr()\n+    ushort parseFuncAttr()\n     {\n         // FuncAttrs\n-        breakFuncAttrs:\n+        ushort result;\n         while ('N' == front)\n         {\n             popFront();\n             switch ( front )\n             {\n             case 'a': // FuncAttrPure\n                 popFront();\n-                put( \"pure \" );\n+                result |= FuncAttributes.Pure;\n                 continue;\n             case 'b': // FuncAttrNoThrow\n                 popFront();\n-                put( \"nothrow \" );\n+                result |= FuncAttributes.Nothrow;\n                 continue;\n             case 'c': // FuncAttrRef\n                 popFront();\n-                put( \"ref \" );\n+                result |= FuncAttributes.Ref;\n                 continue;\n             case 'd': // FuncAttrProperty\n                 popFront();\n-                put( \"@property \" );\n+                result |= FuncAttributes.Property;\n                 continue;\n             case 'e': // FuncAttrTrusted\n                 popFront();\n-                put( \"@trusted \" );\n+                result |= FuncAttributes.Trusted;\n                 continue;\n             case 'f': // FuncAttrSafe\n                 popFront();\n-                put( \"@safe \" );\n+                result |= FuncAttributes.Safe;\n                 continue;\n             case 'g':\n             case 'h':\n@@ -1188,27 +1187,42 @@ pure @safe:\n                 //       if we see these, then we know we're really in\n                 //       the parameter list.  Rewind and break.\n                 pos--;\n-                break breakFuncAttrs;\n+                return result;\n             case 'i': // FuncAttrNogc\n                 popFront();\n-                put( \"@nogc \" );\n+                result |= FuncAttributes.NoGC;\n                 continue;\n             case 'j': // FuncAttrReturn\n                 popFront();\n-                put( \"return \" );\n+                if (this.peek(0) == 'N' && this.peek(1) == 'l')\n+                {\n+                    result |= FuncAttributes.ReturnScope;\n+                    popFront();\n+                    popFront();\n+                } else {\n+                    result |= FuncAttributes.Return;\n+                }\n                 continue;\n             case 'l': // FuncAttrScope\n                 popFront();\n-                put( \"scope \" );\n+                if (this.peek(0) == 'N' && this.peek(1) == 'j')\n+                {\n+                    result |= FuncAttributes.ScopeReturn;\n+                    popFront();\n+                    popFront();\n+                } else {\n+                    result |= FuncAttributes.Scope;\n+                }\n                 continue;\n             case 'm': // FuncAttrLive\n                 popFront();\n-                put( \"@live \" );\n+                result |= FuncAttributes.Live;\n                 continue;\n             default:\n                 error();\n             }\n         }\n+        return result;\n     }\n \n     void parseFuncArguments() scope\n@@ -1346,19 +1360,20 @@ pure @safe:\n         auto beg = len;\n \n         parseCallConvention();\n-        auto attrbeg = len;\n-        parseFuncAttr();\n+        auto attributes = parseFuncAttr();\n \n         auto argbeg = len;\n         put( '(' );\n         parseFuncArguments();\n         put( ')' );\n-        if (attrbeg < argbeg)\n+        if (attributes)\n         {\n-            // move function attributes behind arguments\n-            shift( dst[argbeg - 1 .. argbeg] ); // trailing space\n-            shift( dst[attrbeg .. argbeg - 1] ); // attributes\n-            argbeg = attrbeg;\n+            // write function attributes behind arguments\n+            while (auto str = funcAttrs.toStringConsume(attributes))\n+            {\n+                put(' ');\n+                put(str);\n+            }\n         }\n         auto retbeg = len;\n         parseType();\n@@ -1900,21 +1915,26 @@ pure @safe:\n             {\n                 // do not emit \"needs this\"\n                 popFront();\n-                parseModifier();\n+                auto modifiers = parseModifier();\n+                while (auto str = typeCtors.toStringConsume(modifiers))\n+                {\n+                    put(str);\n+                    put(' ');\n+                }\n             }\n             if ( isCallConvention( front ) )\n             {\n                 // we don't want calling convention and attributes in the qualified name\n                 parseCallConvention();\n-                parseFuncAttr();\n-                if ( keepAttr )\n-                {\n+                auto attributes = parseFuncAttr();\n+                if (keepAttr) {\n+                    while (auto str = funcAttrs.toStringConsume(attributes))\n+                    {\n+                        put(str);\n+                        put(' ');\n+                    }\n                     attr = dst[prevlen .. len];\n                 }\n-                else\n-                {\n-                    len = prevlen;\n-                }\n \n                 put( '(' );\n                 parseFuncArguments();\n@@ -2637,6 +2657,12 @@ else\n         [\"_D4test4rrs1FNkMJPiZv\", \"void test.rrs1(return scope out int*)\"],\n         [\"_D4test4rrs1FNkMKPiZv\", \"void test.rrs1(return scope ref int*)\"],\n         [\"_D4test4rrs1FNkMPiZv\",  \"void test.rrs1(return scope int*)\"],\n+\n+        // `scope` and `return` combinations\n+        [\"_D3foo3Foo3barMNgFNjNlNfZNgPv\", \"inout return scope @safe inout(void*) foo.Foo.bar()\"],\n+        [\"_D3foo3FooQiMNgFNlNfZv\",        \"inout scope @safe void foo.Foo.foo()\"],\n+        [\"_D3foo3Foo4foorMNgFNjNfZv\",     \"inout return @safe void foo.Foo.foor()\"],\n+        [\"_D3foo3Foo3rabMNgFNlNjNfZv\",    \"inout scope return @safe void foo.Foo.rab()\"],\n     ];\n \n \n@@ -2720,7 +2746,12 @@ unittest\n }\n \n /*\n+ * Expand an OMF, DMD-generated compressed identifier into its full form\n  *\n+ * This function only has a visible effect for OMF binaries (Win32),\n+ * as compression is otherwise not used.\n+ *\n+ * See_Also: `compiler/src/dmd/backend/compress.d`\n  */\n string decodeDmdString( const(char)[] ln, ref size_t p ) nothrow pure @safe\n {\n@@ -2781,3 +2812,92 @@ extern (C) private\n         errno = err;\n     }\n }\n+\n+private struct ManglingFlagInfo\n+{\n+    /// The flag value to use\n+    ushort flag;\n+\n+    /// Human-readable representation\n+    string value;\n+}\n+\n+private enum TypeCtor : ushort {\n+    None      = 0,\n+    //// 'x'\n+    Const     = (1 << 1),\n+    /// 'y'\n+    Immutable = (1 << 2),\n+    /// 'O'\n+    Shared    = (1 << 3),\n+    ///\n+    InOut     = (1 << 4),\n+}\n+\n+private immutable ManglingFlagInfo[] typeCtors = [\n+    ManglingFlagInfo(TypeCtor.Immutable, \"immutable\"),\n+    ManglingFlagInfo(TypeCtor.Shared,    \"shared\"),\n+    ManglingFlagInfo(TypeCtor.InOut,     \"inout\"),\n+    ManglingFlagInfo(TypeCtor.Const,     \"const\"),\n+];\n+\n+private enum FuncAttributes : ushort {\n+    None      = 0,\n+    //// 'a'\n+    Pure     = (1 << 1),\n+    //// 'b'\n+    Nothrow  = (1 << 2),\n+    //// 'c'\n+    Ref      = (1 << 3),\n+    //// 'd'\n+    Property = (1 << 4),\n+    //// 'e'\n+    Trusted  = (1 << 5),\n+    //// 'f'\n+    Safe     = (1 << 6),\n+    //// 'i'\n+    NoGC     = (1 << 7),\n+    //// 'j'\n+    Return   = (1 << 8),\n+    //// 'l'\n+    Scope    = (1 << 9),\n+    //// 'm'\n+    Live     = (1 << 10),\n+\n+    /// Their order matter\n+    ReturnScope   = (1 << 11),\n+    ScopeReturn   = (1 << 12),\n+}\n+\n+// The order in which we process is the same as in compiler/dmd/src/dmangle.d\n+private immutable ManglingFlagInfo[] funcAttrs = [\n+    ManglingFlagInfo(FuncAttributes.Pure,     \"pure\"),\n+    ManglingFlagInfo(FuncAttributes.Nothrow,  \"nothrow\"),\n+    ManglingFlagInfo(FuncAttributes.Ref,      \"ref\"),\n+    ManglingFlagInfo(FuncAttributes.Property, \"@property\"),\n+    ManglingFlagInfo(FuncAttributes.NoGC,     \"@nogc\"),\n+\n+    ManglingFlagInfo(FuncAttributes.ReturnScope, \"return scope\"),\n+    ManglingFlagInfo(FuncAttributes.ScopeReturn, \"scope return\"),\n+\n+    ManglingFlagInfo(FuncAttributes.Return,   \"return\"),\n+    ManglingFlagInfo(FuncAttributes.Scope,    \"scope\"),\n+\n+    ManglingFlagInfo(FuncAttributes.Live,     \"@live\"),\n+    ManglingFlagInfo(FuncAttributes.Trusted,  \"@trusted\"),\n+    ManglingFlagInfo(FuncAttributes.Safe,     \"@safe\"),\n+];\n+\n+private string toStringConsume (immutable ManglingFlagInfo[] infos, ref ushort base)\n+    @safe pure nothrow @nogc\n+{\n+    foreach (const ref info; infos)\n+    {\n+        if ((base & info.flag) == info.flag)\n+        {\n+            base &= ~info.flag;\n+            return info.value;\n+        }\n+    }\n+    return null;\n+}"}, {"sha": "6e3c1fdc3effd8389190f68ed13d13cfe2c31a2f", "filename": "libphobos/libdruntime/core/internal/array/arrayassign.d", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Farrayassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Farrayassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Farrayassign.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -302,3 +302,151 @@ Tarr _d_arrayassign_r(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @tru\n     assert(!didThrow);\n     assert(counter == 0);\n }\n+\n+/**\n+ * Sets all elements of an array to a single value. Takes into account postblits,\n+ * copy constructors and destructors. For Plain Old Data elements,`rt/memset.d`\n+ * is used.\n+ *\n+ * ---\n+ * struct S\n+ * {\n+ *     ~this() {} // destructor, so not Plain Old Data\n+ * }\n+ *\n+ * void main()\n+ * {\n+ *   S[3] arr;\n+ *   S value;\n+ *\n+ *   arr = value;\n+ *   // Generates:\n+ *   // _d_arraysetassign(arr[], value), arr;\n+ * }\n+ * ---\n+ *\n+ * Params:\n+ *     to = destination array\n+ *     value = the element to set\n+ * Returns:\n+ *     `to`\n+ */\n+Tarr _d_arraysetassign(Tarr : T[], T)(return scope Tarr to, scope ref T value) @trusted\n+{\n+    import core.internal.traits : Unqual;\n+    import core.lifetime : copyEmplace;\n+    import core.stdc.string : memcpy;\n+\n+    enum elemSize = T.sizeof;\n+    void[elemSize] tmp = void;\n+\n+    foreach (ref dst; to)\n+    {\n+        memcpy(&tmp, cast(void*) &dst, elemSize);\n+        // Use `memcpy` if `T` has a `@disable`d postblit.\n+        static if (__traits(isCopyable, T))\n+            copyEmplace(value, dst);\n+        else\n+            memcpy(cast(void*) &value, cast(void*) &dst, elemSize);\n+        auto elem = cast(Unqual!T*) &tmp;\n+        destroy(*elem);\n+    }\n+\n+    return to;\n+}\n+\n+// postblit and destructor\n+@safe unittest\n+{\n+    string ops;\n+    struct S\n+    {\n+        int val;\n+        this(this) { ops ~= \"=\"; }\n+        ~this() { ops ~= \"~\"; }\n+    }\n+\n+    S[4] arr;\n+    S s = S(1234);\n+    _d_arraysetassign(arr[], s);\n+    assert(ops == \"=~=~=~=~\");\n+    assert(arr == [S(1234), S(1234), S(1234), S(1234)]);\n+}\n+\n+// copy constructor\n+@safe unittest\n+{\n+    string ops;\n+    struct S\n+    {\n+        int val;\n+        this(const scope ref S rhs)\n+        {\n+            val = rhs.val;\n+            ops ~= \"=\";\n+        }\n+        ~this() { ops ~= \"~\"; }\n+    }\n+\n+    S[4] arr;\n+    S s = S(1234);\n+    _d_arraysetassign(arr[], s);\n+    assert(ops == \"=~=~=~=~\");\n+    assert(arr == [S(1234), S(1234), S(1234), S(1234)]);\n+}\n+\n+// throwing and `nothrow`\n+@safe nothrow unittest\n+{\n+    // Test that throwing works\n+    bool didThrow;\n+    int counter;\n+    struct Throw\n+    {\n+        int val;\n+        this(this)\n+        {\n+            counter++;\n+            if (counter == 2)\n+                throw new Exception(\"Oh no.\");\n+        }\n+    }\n+\n+    try\n+    {\n+        Throw[4] a;\n+        Throw b = Throw(1);\n+        _d_arraysetassign(a[], b);\n+    }\n+    catch (Exception)\n+    {\n+        didThrow = true;\n+    }\n+    assert(didThrow);\n+    assert(counter == 2);\n+\n+    // Test that `nothrow` works\n+    didThrow = false;\n+    counter = 0;\n+    struct NoThrow\n+    {\n+        int val;\n+        this(this) { counter++; }\n+    }\n+\n+    try\n+    {\n+        NoThrow[4] a;\n+        NoThrow b = NoThrow(1);\n+        _d_arraysetassign(a[], b);\n+        foreach (ref e; a)\n+            assert(e == NoThrow(1));\n+    }\n+    catch (Exception)\n+    {\n+        didThrow = true;\n+    }\n+    assert(!didThrow);\n+    // The array `a` is destroyed when the `try` block ends.\n+    assert(counter == 4);\n+}"}, {"sha": "dbad0e6064f22e38dcb72db84ec2c4c63f635fa1", "filename": "libphobos/libdruntime/core/internal/dassert.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -518,7 +518,7 @@ private auto assumeFakeAttributes(T)(T t) @trusted\n }\n \n /// Wrapper for `miniFormat` which assumes that the implementation is `@safe`, `@nogc`, ...\n-/// s.t. it does not violate the constraints of the the function containing the `assert`.\n+/// s.t. it does not violate the constraints of the function containing the `assert`.\n private string miniFormatFakeAttributes(T)(const scope ref T t)\n {\n     alias miniT = miniFormat!T;"}, {"sha": "9808b9947f5de3034fe8f8465b9fece73bd4d60d", "filename": "libphobos/libdruntime/core/internal/utf.d", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futf.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -567,17 +567,22 @@ ubyte codeLength(C)(dchar c)\n \n /***********************************\n Checks to see if string is well formed or not. $(D S) can be an array\n- of $(D char), $(D wchar), or $(D dchar). Throws a $(D UtfException)\n- if it is not. Use to check all untrusted input for correctness.\n+ of $(D char), $(D wchar), or $(D dchar). Returns $(D false) if it is not.\n+ Use to check all untrusted input for correctness.\n  */\n-@safe pure\n-void validate(S)(const scope S s)\n+@safe pure nothrow\n+bool isValidString(S)(const scope S s)\n {\n     auto len = s.length;\n     for (size_t i = 0; i < len; )\n     {\n-        decode(s, i);\n+        try\n+            decode(s, i);\n+        catch (Exception e)\n+            return false;\n     }\n+\n+    return true;\n }\n \n /* =================== Conversion to UTF8 ======================= */\n@@ -626,7 +631,7 @@ char[] toUTF8(return scope char[] buf, dchar c)\n string toUTF8(return scope string s)\n     in\n     {\n-        validate(s);\n+        assert(isValidString(s));\n     }\n     do\n     {\n@@ -787,7 +792,7 @@ wptr toUTF16z(const scope char[] s)\n wstring toUTF16(return scope wstring s)\n     in\n     {\n-        validate(s);\n+        assert(isValidString(s));\n     }\n     do\n     {\n@@ -867,7 +872,7 @@ dstring toUTF32(const scope wchar[] s)\n dstring toUTF32(return scope dstring s)\n     in\n     {\n-        validate(s);\n+        assert(isValidString(s));\n     }\n     do\n     {"}, {"sha": "c2b343a08475dfec4e8c9dc6e9e6ae9b018da135", "filename": "libphobos/libdruntime/core/simd.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsimd.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsimd.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsimd.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -704,7 +704,7 @@ version (D_SIMD)\n                 // store `v` to location pointed to by `d`\n                 storeUnaligned(cast(T*)d, v);\n \n-                // check that the the data was stored correctly\n+                // check that the data was stored correctly\n                 foreach (j; 0..T.sizeof)\n                 {\n                     assert(ptrToV[j] == d[j]);"}, {"sha": "5242ba9d4e21d10858a6dbd826688f3060f045b5", "filename": "libphobos/libdruntime/core/stdc/fenv.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ffenv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ffenv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ffenv.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -483,7 +483,7 @@ else version (CRuntime_UClibc)\n \n         alias fexcept_t = ushort;\n     }\n-    else version (MIPS32)\n+    else version (MIPS_Any)\n     {\n         struct fenv_t\n         {"}, {"sha": "2666c952992568c0915d8f1e44eebd89b3753db3", "filename": "libphobos/libdruntime/core/stdc/math.d", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -106,21 +106,14 @@ else version (CRuntime_Bionic)\n }\n else version (CRuntime_UClibc)\n {\n-    version (X86)\n-    {\n-        ///\n-        enum int FP_ILOGB0        = int.min;\n-        ///\n-        enum int FP_ILOGBNAN      = int.min;\n-    }\n-    else version (X86_64)\n+    version (X86_Any)\n     {\n         ///\n         enum int FP_ILOGB0        = int.min;\n         ///\n         enum int FP_ILOGBNAN      = int.min;\n     }\n-    else version (MIPS32)\n+    else version (MIPS_Any)\n     {\n         ///\n         enum int FP_ILOGB0        = -int.max;"}, {"sha": "7713eea97858d7a77933001b90b9d533e4794b6c", "filename": "libphobos/libdruntime/core/sys/darwin/mach/loader.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Floader.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Floader.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Floader.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1803,7 +1803,7 @@ version (CoreDdoc)\n      * image. The isub_image field is an index into the sub-images\n      * (sub-frameworks and sub-umbrellas list) that made up the two-level image\n      * that the undefined symbol was found in when it was built by the static\n-     * link editor. If isub-image is 0 the the symbol is expected to be defined\n+     * link editor. If isub-image is 0 the symbol is expected to be defined\n      * in library and not in the sub-images. If isub-image is non-zero it is an\n      * index into the array of sub-images for the umbrella with the first index\n      * in the sub-images being 1. The array of sub-images is the ordered list of"}, {"sha": "89dc019cc8f2a82fdb2671bc1f5d95d71a441549", "filename": "libphobos/libdruntime/core/sys/linux/fcntl.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ffcntl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ffcntl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ffcntl.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -42,7 +42,7 @@ These cmd values will set locks that conflict with process-associated\n record  locks, but are \"owned\" by the open file description, not the\n process. This means that they are inherited across fork() like BSD (flock)\n locks, and they are only released automatically when the last reference to\n-the the open file against which they were acquired is put.\n+the open file against which they were acquired is put.\n \n */\n enum"}, {"sha": "04a8e8bb8668481656abec8b331b4f5df7cb5304", "filename": "libphobos/libdruntime/core/sys/posix/dlfcn.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -377,7 +377,7 @@ else version (CRuntime_Musl)\n }\n else version (CRuntime_UClibc)\n {\n-    version (X86_64)\n+    version (X86_Any)\n     {\n         enum RTLD_LAZY              = 0x0001;\n         enum RTLD_NOW               = 0x0002;\n@@ -387,7 +387,7 @@ else version (CRuntime_UClibc)\n         enum RTLD_LOCAL             = 0;\n         enum RTLD_NODELETE          = 0x01000;\n     }\n-    else version (MIPS32)\n+    else version (MIPS_Any)\n     {\n         enum RTLD_LAZY              = 0x0001;\n         enum RTLD_NOW               = 0x0002;"}, {"sha": "7085fc4dfa54f99a73f6a139fc269af811e55b98", "filename": "libphobos/libdruntime/core/sys/posix/mqueue.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fmqueue.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fmqueue.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fmqueue.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -147,7 +147,7 @@ int mq_notify (mqd_t mqdes, const(sigevent)* notification);\n \n \n /**\n- * Receive the oldest message with the highest priority the the message queue\n+ * Receive the oldest message with the highest priority the message queue\n  *\n  * Params:\n  *   mqdes      = Message queue descriptor.\n@@ -164,7 +164,7 @@ ssize_t mq_receive (mqd_t mqdes, char* msg_ptr, size_t msg_len, uint* msg_prio);\n \n \n /**\n- * Receive the oldest message with the highest priority the the message queue,\n+ * Receive the oldest message with the highest priority the message queue,\n  * wait up to a certain timeout.\n  *\n  * Params:"}, {"sha": "5a15d82d2ee85bf356de6cd137778cf5161376c3", "filename": "libphobos/libdruntime/core/sys/posix/setjmp.d", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsetjmp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsetjmp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsetjmp.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -370,6 +370,22 @@ else version (CRuntime_UClibc)\n                 double[6] __fpregs;\n         }\n     }\n+    else version (MIPS64)\n+    {\n+        struct __jmp_buf\n+        {\n+            long __pc;\n+            long __sp;\n+            long[8] __regs;\n+            long __fp;\n+            long __gp;\n+            int __fpc_csr;\n+            version (MIPS_N64)\n+                double[8] __fpregs;\n+            else\n+                double[6] __fpregs;\n+        }\n+    }\n     else\n         static assert(0, \"unimplemented\");\n "}, {"sha": "df96a3d33715a3c59704cfcd9f4e63e13e30b4ba", "filename": "libphobos/libdruntime/core/sys/posix/stdlib.d", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdlib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdlib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdlib.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -95,44 +95,44 @@ int posix_memalign(void**, size_t, size_t);\n \n version (CRuntime_Glibc)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (FreeBSD)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (NetBSD)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (OpenBSD)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (DragonFlyBSD)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (Solaris)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (Darwin)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (CRuntime_Bionic)\n {\n     // Added since Lollipop\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (CRuntime_Musl)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (CRuntime_UClibc)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n \n //"}, {"sha": "3e515c4c68e35485dc24268a7745f4a6f1ec24b7", "filename": "libphobos/libdruntime/core/sys/posix/sys/types.d", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ftypes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ftypes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ftypes.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1140,6 +1140,18 @@ else version (CRuntime_UClibc)\n         enum __SIZEOF_PTHREAD_BARRIER_T     = 20;\n         enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;\n      }\n+     else version (MIPS64)\n+     {\n+        enum __SIZEOF_PTHREAD_ATTR_T        = 56;\n+        enum __SIZEOF_PTHREAD_MUTEX_T       = 40;\n+        enum __SIZEOF_PTHREAD_MUTEXATTR_T   = 4;\n+        enum __SIZEOF_PTHREAD_COND_T        = 48;\n+        enum __SIZEOF_PTHREAD_CONDATTR_T    = 4;\n+        enum __SIZEOF_PTHREAD_RWLOCK_T      = 56;\n+        enum __SIZEOF_PTHREAD_RWLOCKATTR_T  = 8;\n+        enum __SIZEOF_PTHREAD_BARRIER_T     = 32;\n+        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;\n+     }\n      else version (ARM)\n      {\n         enum __SIZEOF_PTHREAD_ATTR_T = 36;"}, {"sha": "798208597b145303a13be932150941c9c88dad09", "filename": "libphobos/libdruntime/core/sys/windows/stacktrace.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstacktrace.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstacktrace.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstacktrace.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -288,7 +288,8 @@ private:\n         auto res = formatStackFrame(pc);\n         res ~= \" in \";\n         const(char)[] tempSymName = symName[0 .. strlen(symName)];\n-        //Deal with dmd mangling of long names\n+        // Deal with dmd mangling of long names for OMF 32 bits builds\n+        // Note that `target.d` only defines `CRuntime_DigitalMars` for OMF builds\n         version (CRuntime_DigitalMars)\n         {\n             size_t decodeIndex = 0;"}, {"sha": "ea163a0958aea573cc985f78b60172feffb485f9", "filename": "libphobos/libdruntime/core/time.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Ftime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fcore%2Ftime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Ftime.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3362,7 +3362,7 @@ struct TickDuration\n         $(D gettimeofday) (the decision is made when $(D TickDuration) is\n         compiled), which unfortunately, is not monotonic, but if\n         $(D mach_absolute_time) and $(D clock_gettime) aren't available, then\n-        $(D gettimeofday) is the the best that there is.\n+        $(D gettimeofday) is the best that there is.\n \n         $(RED Warning):\n             On some systems, the monotonic clock may stop counting when"}, {"sha": "83351f26038c913ee307afa4b34a71fdaff99d0a", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2700,7 +2700,7 @@ class Exception : Throwable\n      * Creates a new instance of Exception. The nextInChain parameter is used\n      * internally and should always be $(D null) when passed by user code.\n      * This constructor does not automatically throw the newly-created\n-     * Exception; the $(D throw) statement should be used for that purpose.\n+     * Exception; the $(D throw) expression should be used for that purpose.\n      */\n     @nogc @safe pure nothrow this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable nextInChain = null)\n     {\n@@ -4617,6 +4617,7 @@ public import core.internal.array.construction : _d_arrayctor;\n public import core.internal.array.construction : _d_arraysetctor;\n public import core.internal.array.arrayassign : _d_arrayassign_l;\n public import core.internal.array.arrayassign : _d_arrayassign_r;\n+public import core.internal.array.arrayassign : _d_arraysetassign;\n public import core.internal.array.capacity: _d_arraysetlengthTImpl;\n \n public import core.internal.dassert: _d_assert_fail;"}, {"sha": "c9e2b15025f7f07f97d036629790ecae0020adb3", "filename": "libphobos/libdruntime/rt/arrayassign.d", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2/libphobos%2Flibdruntime%2Frt%2Farrayassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2/libphobos%2Flibdruntime%2Frt%2Farrayassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Farrayassign.d?ref=be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2", "patch": "@@ -1,60 +0,0 @@\n-/**\n- * Implementation of array assignment support routines.\n- *\n- *\n- * Copyright: Copyright Digital Mars 2010 - 2016.\n- * License:   Distributed under the\n- *            $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n- * Authors:   Walter Bright, Kenji Hara\n- * Source:    $(DRUNTIMESRC rt/_arrayassign.d)\n- */\n-\n-module rt.arrayassign;\n-\n-private\n-{\n-    import core.internal.util.array;\n-    import core.stdc.string;\n-    import core.stdc.stdlib;\n-    debug(PRINTF) import core.stdc.stdio;\n-}\n-\n-/**\n-Set all elements of an array to a single value.\n-\n----\n-p[0 .. count] = value;\n----\n-\n-Takes into account postblits and destructors, for Plain Old Data elements,\n-`rt/memset.d` is used.\n-\n-Params:\n-    p = pointer to start of array\n-    value = bytes of the element to set. Size is derived from `ti`.\n-    count = amount of array elements to set\n-    ti = type info of the array element type / `value`\n-Returns: `p`\n-*/\n-extern (C) void* _d_arraysetassign(void* p, void* value, int count, TypeInfo ti)\n-{\n-    void* pstart = p;\n-\n-    auto element_size = ti.tsize;\n-\n-    // Need a temporary buffer tmp[] big enough to hold one element\n-    immutable maxAllocaSize = 512;\n-    void *ptmp = (element_size > maxAllocaSize) ? malloc(element_size) : alloca(element_size);\n-\n-    foreach (i; 0 .. count)\n-    {\n-        memcpy(ptmp, p, element_size);\n-        memcpy(p, value, element_size);\n-        ti.postblit(p);\n-        ti.destroy(ptmp);\n-        p += element_size;\n-    }\n-    if (element_size > maxAllocaSize)\n-        free(ptmp);\n-    return pstart;\n-}"}, {"sha": "f2515c3c6776264f893ef71e6aa0e91994bad061", "filename": "libphobos/libdruntime/rt/lifetime.d", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Flifetime.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1229,61 +1229,6 @@ debug(PRINTF)\n     }\n }\n \n-/**\n- *\n- */\n-extern (C) void _d_delarray_t(void[]* p, const TypeInfo_Struct ti) @weak\n-{\n-    if (p)\n-    {\n-        auto bic = __getBlkInfo(p.ptr);\n-        auto info = bic ? *bic : GC.query(p.ptr);\n-\n-        if (info.base && (info.attr & BlkAttr.APPENDABLE))\n-        {\n-            if (ti) // ti non-null only if ti is a struct with dtor\n-            {\n-                void* start = __arrayStart(info);\n-                size_t length = __arrayAllocLength(info, ti);\n-                finalize_array(start, length, ti);\n-            }\n-\n-            // if p is in the cache, clear it there as well\n-            if (bic)\n-                bic.base = null;\n-\n-            GC.free(info.base);\n-            *p = null;\n-        }\n-    }\n-}\n-\n-deprecated unittest\n-{\n-    __gshared size_t countDtor = 0;\n-    struct S\n-    {\n-        int x;\n-        ~this() { countDtor++; }\n-    }\n-    // destroy large array with x.ptr not base address of allocation\n-    auto x = new S[10000];\n-    void* p = x.ptr;\n-    assert(GC.addrOf(p) != null);\n-    _d_delarray_t(cast(void[]*)&x, typeid(typeof(x[0]))); // delete x;\n-    assert(GC.addrOf(p) == null);\n-    assert(countDtor == 10000);\n-\n-    // destroy full array even if only slice passed\n-    auto y = new S[400];\n-    auto z = y[200 .. 300];\n-    p = z.ptr;\n-    assert(GC.addrOf(p) != null);\n-    _d_delarray_t(cast(void[]*)&z, typeid(typeof(z[0]))); // delete z;\n-    assert(GC.addrOf(p) == null);\n-    assert(countDtor == 10000 + 400);\n-}\n-\n /**\n  *\n  */\n@@ -2754,11 +2699,6 @@ deprecated unittest\n         }\n     }\n \n-    dtorCount = 0;\n-    S1[] arr1 = new S1[7];\n-    _d_delarray_t(cast(void[]*)&arr1, typeid(typeof(arr1[0]))); // delete arr1;\n-    assert(dtorCount == 7);\n-\n     dtorCount = 0;\n     S1* s2 = new S1;\n     GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);"}, {"sha": "4d6382617dfc54b1da2c0d2fb9344bcf94be58e8", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1,4 +1,4 @@\n-b578dfad94770574d7e522557a77276c35943daa\n+88aa69b14f8a28255a0ac7626f6509a13cfdb67a\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "655c02eb5d4cbfbcb7f265b80e468351d4c5031c", "filename": "libphobos/src/Makefile.am", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.am?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -97,9 +97,9 @@ PHOBOS_DSOURCES = etc/c/curl.d etc/c/zlib.d std/algorithm/comparison.d \\\n \tstd/datetime/interval.d std/datetime/package.d \\\n \tstd/datetime/stopwatch.d std/datetime/systime.d \\\n \tstd/datetime/timezone.d std/demangle.d std/digest/crc.d \\\n-\tstd/digest/digest.d std/digest/hmac.d std/digest/md.d \\\n-\tstd/digest/murmurhash.d std/digest/package.d std/digest/ripemd.d \\\n-\tstd/digest/sha.d std/encoding.d std/exception.d \\\n+\tstd/digest/hmac.d std/digest/md.d std/digest/murmurhash.d \\\n+\tstd/digest/package.d std/digest/ripemd.d std/digest/sha.d \\\n+\tstd/encoding.d std/exception.d \\\n \tstd/experimental/allocator/building_blocks/affix_allocator.d \\\n \tstd/experimental/allocator/building_blocks/aligned_block_list.d \\\n \tstd/experimental/allocator/building_blocks/allocator_list.d \\\n@@ -156,6 +156,6 @@ PHOBOS_DSOURCES = etc/c/curl.d etc/c/zlib.d std/algorithm/comparison.d \\\n \tstd/stdio.d std/string.d std/sumtype.d std/system.d std/traits.d \\\n \tstd/typecons.d std/typetuple.d std/uni/package.d std/uri.d std/utf.d \\\n \tstd/uuid.d std/variant.d std/windows/charset.d std/windows/registry.d \\\n-\tstd/windows/syserror.d std/xml.d std/zip.d std/zlib.d\n+\tstd/windows/syserror.d std/zip.d std/zlib.d\n \n endif"}, {"sha": "a6229587e7b370f81e6f337809332d6c6fca7b59", "filename": "libphobos/src/Makefile.in", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.in?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -179,7 +179,6 @@ am__dirstamp = $(am__leading_dot)dirstamp\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/datetime/timezone.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/demangle.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/crc.lo \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/digest.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/hmac.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/md.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/murmurhash.lo \\\n@@ -291,8 +290,7 @@ am__dirstamp = $(am__leading_dot)dirstamp\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/windows/charset.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/windows/registry.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/windows/syserror.lo \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/xml.lo std/zip.lo \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/zlib.lo\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/zip.lo std/zlib.lo\n am__objects_2 = $(am__objects_1)\n am__objects_3 = $(am__objects_2)\n am_libgphobos_la_OBJECTS = $(am__objects_3)\n@@ -562,9 +560,9 @@ libgphobos_la_LINK = $(LIBTOOL) --tag=D $(libgphobos_la_LIBTOOLFLAGS) \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/datetime/interval.d std/datetime/package.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/datetime/stopwatch.d std/datetime/systime.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/datetime/timezone.d std/demangle.d std/digest/crc.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/digest.d std/digest/hmac.d std/digest/md.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/murmurhash.d std/digest/package.d std/digest/ripemd.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/sha.d std/encoding.d std/exception.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/hmac.d std/digest/md.d std/digest/murmurhash.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/package.d std/digest/ripemd.d std/digest/sha.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/encoding.d std/exception.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/allocator/building_blocks/affix_allocator.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/allocator/building_blocks/aligned_block_list.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/experimental/allocator/building_blocks/allocator_list.d \\\n@@ -621,7 +619,7 @@ libgphobos_la_LINK = $(LIBTOOL) --tag=D $(libgphobos_la_LIBTOOLFLAGS) \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/stdio.d std/string.d std/sumtype.d std/system.d std/traits.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/typecons.d std/typetuple.d std/uni/package.d std/uri.d std/utf.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/uuid.d std/variant.d std/windows/charset.d std/windows/registry.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/windows/syserror.d std/xml.d std/zip.d std/zlib.d\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/windows/syserror.d std/zip.d std/zlib.d\n \n \n # Source file definitions. Boring stuff, auto-generated with\n@@ -754,7 +752,6 @@ std/digest/$(am__dirstamp):\n \t@$(MKDIR_P) std/digest\n \t@: > std/digest/$(am__dirstamp)\n std/digest/crc.lo: std/digest/$(am__dirstamp)\n-std/digest/digest.lo: std/digest/$(am__dirstamp)\n std/digest/hmac.lo: std/digest/$(am__dirstamp)\n std/digest/md.lo: std/digest/$(am__dirstamp)\n std/digest/murmurhash.lo: std/digest/$(am__dirstamp)\n@@ -964,7 +961,6 @@ std/windows/$(am__dirstamp):\n std/windows/charset.lo: std/windows/$(am__dirstamp)\n std/windows/registry.lo: std/windows/$(am__dirstamp)\n std/windows/syserror.lo: std/windows/$(am__dirstamp)\n-std/xml.lo: std/$(am__dirstamp)\n std/zip.lo: std/$(am__dirstamp)\n std/zlib.lo: std/$(am__dirstamp)\n "}, {"sha": "481222596702c791059fb90b3bdbdbc6793d06f0", "filename": "libphobos/src/index.dd", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Findex.dd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Findex.dd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Findex.dd?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -70,10 +70,6 @@ $(BOOKTABLE ,\n         $(TDNW $(MREF std,json))\n         $(TD Read/write data in JSON format.)\n     )\n-    $(TR\n-        $(TDNW $(MREF std,xml))\n-        $(TD Read/write data in XML format.)\n-    )\n     $(TR\n         $(TDNW $(MREF std,zip))\n         $(TD Read/write data in the ZIP archive format.)"}, {"sha": "5ecb4f601a51e9573597da3c440f804deb43a35d", "filename": "libphobos/src/std/algorithm/comparison.d", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fcomparison.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fcomparison.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fcomparison.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -577,14 +577,24 @@ Returns:\n     and `T3` are different.\n */\n T1 clamp(T1, T2, T3)(T1 val, T2 lower, T3 upper)\n-if (is(typeof(val.lessThan(lower) ? lower : val.greaterThan(upper) ? upper : val) : T1))\n+if (is(typeof(val.lessThan(lower) ? lower : val.greaterThan(upper) ? upper : val))\n+    && (is(T2 : T1) && is(T3 : T1)))\n+// cannot use :\n+// `if (is(typeof(val.lessThan(lower) ? lower : val.greaterThan(upper) ? upper : val) : T1))\n+// because of https://issues.dlang.org/show_bug.cgi?id=16235.\n+// Once that is fixed, we can simply use the ternary in both the template constraint\n+// and the template body\n in\n {\n     assert(!lower.greaterThan(upper), \"Lower can't be greater than upper.\");\n }\n do\n {\n-    return val.lessThan(lower) ? lower : val.greaterThan(upper) ? upper : val;\n+    if (val.lessThan(lower))\n+        return lower;\n+    else if (val.greaterThan(upper))\n+        return upper;\n+    return val;\n }\n \n ///\n@@ -637,6 +647,12 @@ do\n     assert(x.clamp(lo, hi).y == 42);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=23268\n+@safe pure nothrow @nogc unittest\n+{\n+    static assert(__traits(compiles, clamp(short.init, short.init, cast(const) short.init)));\n+}\n+\n // cmp\n /**********************************\n Performs a lexicographical comparison on two"}, {"sha": "39eff0d4a2b82a76e42f2acfb6745debcb1b071b", "filename": "libphobos/src/std/algorithm/iteration.d", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -771,6 +771,23 @@ private struct MapResult(alias fun, Range)\n     assert(dd.length == 4);\n }\n \n+// Verify fix for: https://issues.dlang.org/show_bug.cgi?id=16034\n+@safe unittest\n+{\n+    struct One\n+    {\n+        int entry = 1;\n+        @disable this(this);\n+    }\n+\n+    One[] ones = [One(), One()];\n+\n+    import std.algorithm.comparison : equal;\n+\n+    assert(ones.map!`a.entry + 1`.equal([2, 2]));\n+}\n+\n+\n @safe unittest\n {\n     import std.algorithm.comparison : equal;"}, {"sha": "15f7ca99e66ead2ae8cb5b8234c073075eadfbb6", "filename": "libphobos/src/std/algorithm/searching.d", "status": "modified", "additions": 71, "deletions": 5, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -5002,7 +5002,7 @@ If set to `OpenRight.yes`, then the interval is open to the right\n (last element is not included).\n \n Otherwise if set to `OpenRight.no`, then the interval is closed to the right\n-(last element included).\n+including the entire sentinel.\n  */\n alias OpenRight = Flag!\"openRight\";\n \n@@ -5052,6 +5052,7 @@ if (isInputRange!Range)\n     static if (!is(Sentinel == void))\n         private Sentinel _sentinel;\n     private OpenRight _openRight;\n+    private bool _matchStarted;\n     private bool _done;\n \n     static if (!is(Sentinel == void))\n@@ -5063,7 +5064,19 @@ if (isInputRange!Range)\n             _input = input;\n             _sentinel = sentinel;\n             _openRight = openRight;\n-            _done = _input.empty || openRight && predSatisfied();\n+            static if (isInputRange!Sentinel)\n+            {\n+                _matchStarted = predSatisfied();\n+                _done = _input.empty || _sentinel.empty || openRight && _matchStarted;\n+                if (_matchStarted && !_done && !openRight)\n+                {\n+                    _sentinel.popFront;\n+                }\n+            }\n+            else\n+            {\n+                _done = _input.empty || openRight && predSatisfied();\n+            }\n         }\n         private this(Range input, Sentinel sentinel, OpenRight openRight,\n             bool done)\n@@ -5118,9 +5131,32 @@ if (isInputRange!Range)\n         assert(!empty, \"Can not popFront of an empty Until\");\n         if (!_openRight)\n         {\n-            _done = predSatisfied();\n-            _input.popFront();\n-            _done = _done || _input.empty;\n+            static if (isInputRange!Sentinel)\n+            {\n+                _input.popFront();\n+                _done = _input.empty || _sentinel.empty;\n+                if (!_done)\n+                {\n+                    if (_matchStarted)\n+                    {\n+                        _sentinel.popFront;\n+                    }\n+                    else\n+                    {\n+                        _matchStarted = predSatisfied();\n+                        if (_matchStarted)\n+                        {\n+                            _sentinel.popFront;\n+                        }\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                _done = predSatisfied();\n+                _input.popFront();\n+                _done = _done || _input.empty;\n+            }\n         }\n         else\n         {\n@@ -5212,3 +5248,33 @@ pure @safe unittest\n         assert(equal(r.save, \"foo\"));\n     }\n }\n+// https://issues.dlang.org/show_bug.cgi?id=14543\n+pure @safe unittest\n+{\n+    import std.algorithm.comparison : equal;\n+    import std.uni : toUpper;\n+    assert(\"one two three\".until(\"two\").equal(\"one \"));\n+    assert(\"one two three\".until(\"two\", OpenRight.no).equal(\"one two\"));\n+\n+    assert(\"one two three\".until(\"two\", No.openRight).equal(\"one two\"));\n+    assert(\"one two three\".until(\"two\", Yes.openRight).equal(\"one \"));\n+\n+    assert(\"one two three\".until('t', Yes.openRight).equal(\"one \"));\n+    assert(\"one two three\".until(\"\", Yes.openRight).equal(\"\"));\n+    assert(\"one two three\".until(\"\", No.openRight).equal(\"\"));\n+\n+    assert(\"one two three\".until(\"three\", No.openRight).equal(\"one two three\"));\n+    assert(\"one two three\".until(\"three\", Yes.openRight).equal(\"one two \"));\n+\n+    assert(\"one two three\".until(\"one\", No.openRight).equal(\"one\"));\n+    assert(\"one two three\".until(\"one\", Yes.openRight).equal(\"\"));\n+\n+    assert(\"one two three\".until(\"o\", No.openRight).equal(\"o\"));\n+    assert(\"one two three\".until(\"o\", Yes.openRight).equal(\"\"));\n+\n+    assert(\"one two three\".until(\"\", No.openRight).equal(\"\"));\n+    assert(\"one two three\".until(\"\", Yes.openRight).equal(\"\"));\n+\n+    assert(\"one two three\".until!((a,b)=>a.toUpper == b)(\"TWO\", No.openRight).equal(\"one two\"));\n+}\n+"}, {"sha": "4fc7ee9ac4ca7926b0c95159f1be332d06520d6d", "filename": "libphobos/src/std/algorithm/sorting.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1642,9 +1642,9 @@ private void multiSortImpl(Range, SwapStrategy ss, funs...)(Range r)\n }\n \n // https://issues.dlang.org/show_bug.cgi?id=16413 - @system comparison function\n-@safe unittest\n+@system unittest\n {\n-    bool lt(int a, int b) { return a < b; } static @system\n+    static @system bool lt(int a, int b) { return a < b; }\n     auto a = [2, 1];\n     a.multiSort!(lt, lt);\n     assert(a == [1, 2]);"}, {"sha": "4ea5bd72433731a7f0356c2a9139f1c7d00852d9", "filename": "libphobos/src/std/compiler.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fcompiler.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fcompiler.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcompiler.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -28,7 +28,7 @@ immutable\n         gnu = 2,         /// GNU D Compiler (GDC)\n         llvm = 3,        /// LLVM D Compiler (LDC)\n         dotNET = 4,      /// D.NET\n-        sdc = 5,         /// Stupid D Compiler (SDC)\n+        sdc = 5,         /// Snazzy D Compiler (SDC)\n     }\n \n     /// Which vendor produced this compiler."}, {"sha": "bc53236b9b71be818bf01de6960b2ed3eac9b423", "filename": "libphobos/src/std/concurrency.d", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fconcurrency.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fconcurrency.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconcurrency.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -257,9 +257,12 @@ private\n \n     @property ref ThreadInfo thisInfo() nothrow\n     {\n-        if (scheduler is null)\n+        import core.atomic : atomicLoad;\n+\n+        auto localScheduler = atomicLoad(scheduler);\n+        if (localScheduler is null)\n             return ThreadInfo.thisInfo;\n-        return scheduler.thisInfo;\n+        return localScheduler.thisInfo;\n     }\n }\n "}, {"sha": "ecc459969254b7b2089c410f290888241a41d739", "filename": "libphobos/src/std/container/array.d", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fcontainer%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fcontainer%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcontainer%2Farray.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -412,9 +412,9 @@ if (!is(immutable T == immutable bool))\n                     .destroy(e);\n \n             static if (hasIndirections!T)\n-                GC.removeRange(_payload.ptr);\n+                GC.removeRange(cast(void*) _payload.ptr);\n \n-            free(_payload.ptr);\n+            free(cast(void*) _payload.ptr);\n         }\n \n         this(this) @disable;\n@@ -489,14 +489,14 @@ if (!is(immutable T == immutable bool))\n                 auto newPayload = newPayloadPtr[0 .. oldLength];\n \n                 // copy old data over to new array\n-                memcpy(newPayload.ptr, _payload.ptr, T.sizeof * oldLength);\n+                memcpy(cast(void*) newPayload.ptr, cast(void*) _payload.ptr, T.sizeof * oldLength);\n                 // Zero out unused capacity to prevent gc from seeing false pointers\n-                memset(newPayload.ptr + oldLength,\n+                memset( cast(void*) (newPayload.ptr + oldLength),\n                         0,\n                         (elements - oldLength) * T.sizeof);\n-                GC.addRange(newPayload.ptr, sz);\n-                GC.removeRange(_payload.ptr);\n-                free(_payload.ptr);\n+                GC.addRange(cast(void*) newPayload.ptr, sz);\n+                GC.removeRange(cast(void*) _payload.ptr);\n+                free(cast(void*) _payload.ptr);\n                 _payload = newPayload;\n             }\n             else\n@@ -611,12 +611,17 @@ if (!is(immutable T == immutable bool))\n         return opEquals(rhs);\n     }\n \n+    // fix https://issues.dlang.org/show_bug.cgi?23140\n+    private alias Unshared(T) = T;\n+    private alias Unshared(T: shared U, U) = U;\n+\n     /// ditto\n     bool opEquals(ref const Array rhs) const\n     {\n         if (empty) return rhs.empty;\n         if (rhs.empty) return false;\n-        return _data._payload == rhs._data._payload;\n+\n+        return cast(Unshared!(T)[]) _data._payload ==  cast(Unshared!(T)[]) rhs._data._payload;\n     }\n \n     /**\n@@ -1740,6 +1745,16 @@ if (!is(immutable T == immutable bool))\n     assertThrown!AssertError(array.length = 5);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=23140\n+@system unittest\n+{\n+    shared class C\n+    {\n+    }\n+\n+    Array!C ac;\n+    ac = Array!C([new C]);\n+}\n ////////////////////////////////////////////////////////////////////////////////\n // Array!bool\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "11e3883e5ee408203f3fccf00a06dea021f386d8", "filename": "libphobos/src/std/container/dlist.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fdlist.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fdlist.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fdlist.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -111,7 +111,7 @@ private struct DRange\n         static assert(is(ElementType!DRange == BaseNode*));\n     }\n \n-nothrow @safe pure:\n+nothrow @safe @nogc pure:\n     private BaseNode* _first;\n     private BaseNode* _last;\n "}, {"sha": "0f660658920273d7ce05dd3370b9ef3ffa3bb38f", "filename": "libphobos/src/std/conv.d", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fconv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fconv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconv.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -4894,7 +4894,7 @@ if (isOctalLiteral(num))\n template octal(alias decimalInteger)\n if (is(typeof(decimalInteger)) && isIntegral!(typeof(decimalInteger)))\n {\n-    enum octal = octal!(typeof(decimalInteger))(to!string(decimalInteger));\n+    enum octal = convertToOctal(decimalInteger);\n }\n \n ///\n@@ -4910,6 +4910,19 @@ if (is(typeof(decimalInteger)) && isIntegral!(typeof(decimalInteger)))\n     auto d = octal!\"0001_200_000\";\n }\n \n+/*************************************\n+ * Convert a decimal integer to an octal integer with the same digits.\n+ * Params:\n+ *    i = integer to convert\n+ * Returns:\n+ *    octal integer with the same type and same digits\n+ */\n+private T convertToOctal(T)(T i)\n+{\n+    assert((i % 10) < 8);\n+    return i ? convertToOctal(i / 10) * 8 + i % 10 : 0;\n+}\n+\n /*\n     Takes a string, num, which is an octal literal, and returns its\n     value, in the type T specified."}, {"sha": "eedc0ea79c90c76765d0b7083fdda5c8789993b9", "filename": "libphobos/src/std/datetime/stopwatch.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fstopwatch.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fstopwatch.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fstopwatch.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -234,7 +234,7 @@ public:\n \n \n     /++\n-       Peek at the amount of time that the the StopWatch has been running.\n+       Peek at the amount of time that the StopWatch has been running.\n \n        This does not include any time during which the StopWatch was stopped but\n        does include $(I all) of the time that it was running and not just the"}, {"sha": "b23891808f5d70b319404c389c2060c815096a0a", "filename": "libphobos/src/std/datetime/timezone.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fdatetime%2Ftimezone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fdatetime%2Ftimezone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Ftimezone.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3397,8 +3397,7 @@ struct TZConversions\n TZConversions parseTZConversions(string windowsZonesXMLText) @safe pure\n {\n     // This is a bit hacky, since it doesn't properly read XML, but it avoids\n-    // needing to pull in std.xml (which we're theoretically replacing at some\n-    // point anyway).\n+    // needing to pull in an xml parsing module.\n     import std.algorithm.iteration : uniq;\n     import std.algorithm.searching : find;\n     import std.algorithm.sorting : sort;"}, {"sha": "b7922bb03da84cc14621c3ced47071c543afb4d5", "filename": "libphobos/src/std/digest/crc.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fdigest%2Fcrc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fdigest%2Fcrc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdigest%2Fcrc.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -555,7 +555,7 @@ ubyte[8] crc64ECMAOf(T...)(T data)\n }\n \n /**\n- * This is a convenience alias for $(REF digest, std,digest,digest) using the\n+ * This is a convenience alias for $(REF digest, std,digest) using the\n  * CRC64-ISO implementation.\n  *\n  * Params:\n@@ -611,7 +611,7 @@ alias CRC32Digest = WrapperDigest!CRC32;\n  * OOP API CRC64-ECMA implementation.\n  * See `std.digest` for differences between template and OOP API.\n  *\n- * This is an alias for $(D $(REF WrapperDigest, std,digest,digest)!CRC64ECMA),\n+ * This is an alias for $(D $(REF WrapperDigest, std,digest)!CRC64ECMA),\n  * see there for more information.\n  */\n alias CRC64ECMADigest = WrapperDigest!CRC64ECMA;\n@@ -620,15 +620,15 @@ alias CRC64ECMADigest = WrapperDigest!CRC64ECMA;\n  * OOP API CRC64-ISO implementation.\n  * See `std.digest` for differences between template and OOP API.\n  *\n- * This is an alias for $(D $(REF WrapperDigest, std,digest,digest)!CRC64ISO),\n+ * This is an alias for $(D $(REF WrapperDigest, std,digest)!CRC64ISO),\n  * see there for more information.\n  */\n alias CRC64ISODigest = WrapperDigest!CRC64ISO;\n \n ///\n @safe unittest\n {\n-    //Simple example, hashing a string using Digest.digest helper function\n+    //Simple example, hashing a string using CRC32Digest.digest helper function\n     auto crc = new CRC32Digest();\n     ubyte[] hash = crc.digest(\"abc\");\n     //Let's get a hash string"}, {"sha": "01fdbd75e4bf181e2f56eed3e409ec9d73b763b0", "filename": "libphobos/src/std/digest/digest.d", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2/libphobos%2Fsrc%2Fstd%2Fdigest%2Fdigest.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2/libphobos%2Fsrc%2Fstd%2Fdigest%2Fdigest.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdigest%2Fdigest.d?ref=be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2", "patch": "@@ -1,3 +0,0 @@\n-// @@@DEPRECATED_2.101@@@\n-deprecated(\"import std.digest instead of std.digest.digest. std.digest.digest will be removed in 2.101\")\n-module std.digest.digest;"}, {"sha": "d0d0b7cb27cf744bef188ae30c02d2448e6a2f72", "filename": "libphobos/src/std/experimental/allocator/building_blocks/affix_allocator.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Faffix_allocator.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Faffix_allocator.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Faffix_allocator.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -521,9 +521,9 @@ version (StdUnittest)\n \n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n \n-    auto a = AffixAllocator!(Region!(), uint)(Region!()(new ubyte[1024 * 64]));\n+    auto a = AffixAllocator!(BorrowedRegion!(), uint)(BorrowedRegion!()(new ubyte[1024 * 64]));\n     auto b = a.allocate(42);\n     assert(b.length == 42);\n     // Test that expand infers from parent"}, {"sha": "99768bc318e56d3ac564dc7e7dc4193d80886652", "filename": "libphobos/src/std/experimental/allocator/building_blocks/aligned_block_list.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Faligned_block_list.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Faligned_block_list.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Faligned_block_list.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -526,7 +526,7 @@ shared struct SharedAlignedBlockList(Allocator, ParentAllocator, ulong theAlignm\n ///\n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : SharedRegion;\n+    import std.experimental.allocator.building_blocks.region : SharedBorrowedRegion;\n     import std.experimental.allocator.building_blocks.ascending_page_allocator : SharedAscendingPageAllocator;\n     import std.experimental.allocator.building_blocks.null_allocator : NullAllocator;\n     import core.thread : ThreadGroup;\n@@ -536,11 +536,11 @@ shared struct SharedAlignedBlockList(Allocator, ParentAllocator, ulong theAlignm\n     enum maxIter = 10;\n \n     /*\n-    In this example we use 'SharedAlignedBlockList' together with 'SharedRegion',\n-    in order to create a fast, thread-safe allocator.\n+    In this example we use 'SharedAlignedBlockList' together with\n+    'SharedBorrowedRegion', in order to create a fast, thread-safe allocator.\n     */\n     alias SuperAllocator = SharedAlignedBlockList!(\n-            SharedRegion!(NullAllocator, 1),\n+            SharedBorrowedRegion!(1),\n             SharedAscendingPageAllocator,\n             4096);\n \n@@ -597,7 +597,7 @@ version (StdUnittest)\n     SpinLock lock = SpinLock(SpinLock.Contention.brief);\n \n     alias SuperAllocator = SharedAlignedBlockList!(\n-            SharedRegion!(NullAllocator, 1),\n+            SharedBorrowedRegion!(1),\n             SharedAscendingPageAllocator,\n             1 << 16);\n     void[][totalAllocs] buf;"}, {"sha": "ca83785914eb777b4d7155c282e1c981557a6c3d", "filename": "libphobos/src/std/experimental/allocator/building_blocks/allocator_list.d", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fallocator_list.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fallocator_list.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fallocator_list.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -679,8 +679,8 @@ version (Posix) @system unittest\n {\n     // Create an allocator based upon 4MB regions, fetched from the GC heap.\n     import std.algorithm.comparison : max;\n-    import std.experimental.allocator.building_blocks.region : Region;\n-    AllocatorList!((n) => Region!()(new ubyte[max(n, 1024 * 4096)])) a;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n+    AllocatorList!((n) => BorrowedRegion!()(new ubyte[max(n, 1024 * 4096)])) a;\n     auto b1 = a.alignedAllocate(1024 * 8192, 1024);\n     assert(b1 !is null); // still works due to overdimensioning\n     assert(b1.length == 1024 * 8192);\n@@ -707,8 +707,8 @@ version (Posix) @system unittest\n \n     // Create an allocator based upon 4MB regions, fetched from the GC heap.\n     import std.algorithm.comparison : max;\n-    import std.experimental.allocator.building_blocks.region : Region;\n-    AllocatorList!((n) => Region!()(new ubyte[max(n, 1024 * 4096)])) a;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n+    AllocatorList!((n) => BorrowedRegion!()(new ubyte[max(n, 1024 * 4096)])) a;\n     auto b1 = a.alignedAllocate(0, 1);\n     assert(b1 is null);\n \n@@ -728,8 +728,8 @@ version (Posix) @system unittest\n \n     // Create an allocator based upon 4MB regions, fetched from the GC heap.\n     import std.algorithm.comparison : max;\n-    import std.experimental.allocator.building_blocks.region : Region;\n-    AllocatorList!((n) => Region!()(new ubyte[max(n, 1024 * 4096)])) a;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n+    AllocatorList!((n) => BorrowedRegion!()(new ubyte[max(n, 1024 * 4096)])) a;\n     auto b0 = a.alignedAllocate(1, 1024);\n     assert(b0.length == 1);\n     assert(b0.ptr.alignedAt(1024));\n@@ -765,8 +765,8 @@ version (Posix) @system unittest\n {\n     // Create an allocator based upon 4MB regions, fetched from the GC heap.\n     import std.algorithm.comparison : max;\n-    import std.experimental.allocator.building_blocks.region : Region;\n-    AllocatorList!((n) => Region!()(new ubyte[max(n, 1024 * 4096)])) a;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n+    AllocatorList!((n) => BorrowedRegion!()(new ubyte[max(n, 1024 * 4096)])) a;\n     auto b1 = a.allocate(1024 * 8192);\n     assert(b1 !is null); // still works due to overdimensioning\n     b1 = a.allocate(1024 * 10);\n@@ -779,10 +779,10 @@ version (Posix) @system unittest\n @system unittest\n {\n     import std.algorithm.comparison : max;\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n     import std.experimental.allocator.mallocator : Mallocator;\n     import std.typecons : Ternary;\n-    AllocatorList!((n) => Region!()(new ubyte[max(n, 1024 * 4096)]), Mallocator) a;\n+    AllocatorList!((n) => BorrowedRegion!()(new ubyte[max(n, 1024 * 4096)]), Mallocator) a;\n     auto b1 = a.allocate(1024 * 8192);\n     assert(b1 !is null);\n     b1 = a.allocate(1024 * 10);"}, {"sha": "3990418c3cfb4aa9350dd9c19a40803cfae6e3f4", "filename": "libphobos/src/std/experimental/allocator/building_blocks/fallback_allocator.d", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Ffallback_allocator.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Ffallback_allocator.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Ffallback_allocator.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -342,12 +342,12 @@ struct FallbackAllocator(Primary, Fallback)\n \n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n     import std.typecons : Ternary;\n \n-    auto a = FallbackAllocator!(Region!(), Region!())(\n-                Region!()(new ubyte[4096 * 1024]),\n-                Region!()(new ubyte[4096 * 1024]));\n+    auto a = FallbackAllocator!(BorrowedRegion!(), BorrowedRegion!())(\n+                BorrowedRegion!()(new ubyte[4096 * 1024]),\n+                BorrowedRegion!()(new ubyte[4096 * 1024]));\n \n     auto b = a.alignedAllocate(42, 8);\n     assert(b.length == 42);\n@@ -506,11 +506,11 @@ version (StdUnittest)\n \n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n     import std.typecons : Ternary;\n \n-    alias A = FallbackAllocator!(Region!(), Region!());\n-    auto a = A(Region!()(new ubyte[16_384]), Region!()(new ubyte[16_384]));\n+    alias A = FallbackAllocator!(BorrowedRegion!(), BorrowedRegion!());\n+    auto a = A(BorrowedRegion!()(new ubyte[16_384]), BorrowedRegion!()(new ubyte[16_384]));\n \n     auto b = a.allocate(42);\n     assert(b.length == 42);"}, {"sha": "d2b32099226b5dfda657949efb6c5828b2283074", "filename": "libphobos/src/std/experimental/allocator/building_blocks/free_list.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Ffree_list.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Ffree_list.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Ffree_list.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -486,9 +486,9 @@ struct FreeList(ParentAllocator,\n // Test that deallocateAll infers from parent\n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n \n-    auto fl = FreeList!(Region!(), 0, 16)(Region!()(new ubyte[1024 * 64]));\n+    auto fl = FreeList!(BorrowedRegion!(), 0, 16)(BorrowedRegion!()(new ubyte[1024 * 64]));\n     auto b = fl.allocate(42);\n     assert(b.length == 42);\n     assert((() pure nothrow @safe @nogc => fl.expand(b, 48))());"}, {"sha": "fe59e2650a168f509233a19dad57f302cf2aca92", "filename": "libphobos/src/std/experimental/allocator/building_blocks/free_tree.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Ffree_tree.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Ffree_tree.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Ffree_tree.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -502,9 +502,9 @@ version (StdUnittest)\n \n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n \n-    auto a = FreeTree!(Region!())(Region!()(new ubyte[1024 * 64]));\n+    auto a = FreeTree!(BorrowedRegion!())(BorrowedRegion!()(new ubyte[1024 * 64]));\n     auto b = a.allocate(42);\n     assert(b.length == 42);\n     assert((() pure nothrow @safe @nogc => a.expand(b, 22))());"}, {"sha": "3334a86fd849c9b51ee44a32ae2c4e4d04090b22", "filename": "libphobos/src/std/experimental/allocator/building_blocks/quantizer.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fquantizer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fquantizer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fquantizer.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -315,14 +315,14 @@ version (StdUnittest)\n version (StdUnittest)\n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n     import std.typecons : Ternary;\n \n-    alias MyAlloc = Quantizer!(Region!(),\n+    alias MyAlloc = Quantizer!(BorrowedRegion!(),\n         (size_t n) => n.roundUpToMultipleOf(64));\n-    testAllocator!(() => MyAlloc(Region!()(new ubyte[1024 * 64])));\n+    testAllocator!(() => MyAlloc(BorrowedRegion!()(new ubyte[1024 * 64])));\n \n-    auto a = MyAlloc(Region!()(new ubyte[1024 * 64]));\n+    auto a = MyAlloc(BorrowedRegion!()(new ubyte[1024 * 64]));\n     // Check that empty inherits from parent\n     assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.yes);\n     auto b = a.allocate(42);"}, {"sha": "8c397849f4327a74aef4335d5634e7270bb95024", "filename": "libphobos/src/std/experimental/allocator/building_blocks/region.d", "status": "modified", "additions": 713, "deletions": 398, "changes": 1111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fregion.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fregion.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fregion.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -29,16 +29,15 @@ the store and the limits. One allocation entails rounding up the allocation\n size for alignment purposes, bumping the current pointer, and comparing it\n against the limit.\n \n-If `ParentAllocator` is different from $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator), `Region`\n-deallocates the chunk of memory during destruction.\n+`Region` deallocates the chunk of memory during destruction.\n \n The `minAlign` parameter establishes alignment. If $(D minAlign > 1), the\n sizes of all allocation requests are rounded up to a multiple of `minAlign`.\n Applications aiming at maximum speed may want to choose $(D minAlign = 1) and\n control alignment externally.\n \n */\n-struct Region(ParentAllocator = NullAllocator,\n+struct Region(ParentAllocator,\n     uint minAlign = platformAlignment,\n     Flag!\"growDownwards\" growDownwards = No.growDownwards)\n {\n@@ -63,50 +62,42 @@ struct Region(ParentAllocator = NullAllocator,\n         alias parent = ParentAllocator.instance;\n     }\n \n-    private void* _current, _begin, _end;\n+    private BorrowedRegion!(minAlign, growDownwards) _impl;\n \n     private void* roundedBegin() const pure nothrow @trusted @nogc\n     {\n-        return cast(void*) roundUpToAlignment(cast(size_t) _begin, alignment);\n+        return _impl.roundedBegin;\n     }\n \n     private void* roundedEnd() const pure nothrow @trusted @nogc\n     {\n-        return cast(void*) roundDownToAlignment(cast(size_t) _end, alignment);\n+        return _impl.roundedEnd;\n     }\n     /**\n     Constructs a region backed by a user-provided store.\n-    Assumes the memory was allocated with `ParentAllocator`\n-    (if different from $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator)).\n+    Assumes the memory was allocated with `ParentAllocator`.\n \n     Params:\n-        store = User-provided store backing up the region. If $(D\n-        ParentAllocator) is different from $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator), memory is assumed to\n-        have been allocated with `ParentAllocator`.\n-        n = Bytes to allocate using `ParentAllocator`. This constructor is only\n-        defined If `ParentAllocator` is different from $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator). If\n-        `parent.allocate(n)` returns `null`, the region will be initialized\n-        as empty (correctly initialized but unable to allocate).\n+        store = User-provided store backing up the region. Assumed to have been\n+        allocated with `ParentAllocator`.\n+        n = Bytes to allocate using `ParentAllocator`. If `parent.allocate(n)`\n+        returns `null`, the region will be initialized as empty (correctly\n+        initialized but unable to allocate).\n         */\n     this(ubyte[] store) pure nothrow @nogc\n     {\n-        _begin = store.ptr;\n-        _end = store.ptr + store.length;\n-        static if (growDownwards)\n-            _current = roundedEnd();\n-        else\n-            _current = roundedBegin();\n+        _impl = store;\n     }\n \n     /// Ditto\n-    static if (!is(ParentAllocator == NullAllocator) && !stateSize!ParentAllocator)\n+    static if (!stateSize!ParentAllocator)\n     this(size_t n)\n     {\n         this(cast(ubyte[]) (parent.allocate(n.roundUpToAlignment(alignment))));\n     }\n \n     /// Ditto\n-    static if (!is(ParentAllocator == NullAllocator) && stateSize!ParentAllocator)\n+    static if (stateSize!ParentAllocator)\n     this(ParentAllocator parent, size_t n)\n     {\n         this.parent = parent;\n@@ -119,23 +110,21 @@ struct Region(ParentAllocator = NullAllocator,\n     */\n \n     /**\n-    If `ParentAllocator` is not $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator) and defines `deallocate`,\n-    the region defines a destructor that uses `ParentAllocator.deallocate` to free the\n-    memory chunk.\n+    If `ParentAllocator` defines `deallocate`, the region defines a destructor\n+    that uses `ParentAllocator.deallocate` to free the memory chunk.\n     */\n-    static if (!is(ParentAllocator == NullAllocator)\n-        && hasMember!(ParentAllocator, \"deallocate\"))\n+    static if (hasMember!(ParentAllocator, \"deallocate\"))\n     ~this()\n     {\n-        parent.deallocate(_begin[0 .. _end - _begin]);\n+        with (_impl) parent.deallocate(_begin[0 .. _end - _begin]);\n     }\n \n     /**\n     Rounds the given size to a multiple of the `alignment`\n     */\n     size_t goodAllocSize(size_t n) const pure nothrow @safe @nogc\n     {\n-        return n.roundUpToAlignment(alignment);\n+        return _impl.goodAllocSize(n);\n     }\n \n     /**\n@@ -156,24 +145,7 @@ struct Region(ParentAllocator = NullAllocator,\n     */\n     void[] allocate(size_t n) pure nothrow @trusted @nogc\n     {\n-        const rounded = goodAllocSize(n);\n-        if (n == 0 || rounded < n || available < rounded) return null;\n-\n-        static if (growDownwards)\n-        {\n-            assert(available >= rounded);\n-            auto result = (_current - rounded)[0 .. n];\n-            assert(result.ptr >= _begin);\n-            _current = result.ptr;\n-            assert(owns(result) == Ternary.yes);\n-        }\n-        else\n-        {\n-            auto result = _current[0 .. n];\n-            _current += rounded;\n-        }\n-\n-        return result;\n+        return _impl.allocate(n);\n     }\n \n     /**\n@@ -188,57 +160,13 @@ struct Region(ParentAllocator = NullAllocator,\n     */\n     void[] alignedAllocate(size_t n, uint a) pure nothrow @trusted @nogc\n     {\n-        import std.math.traits : isPowerOf2;\n-        assert(a.isPowerOf2);\n-\n-        const rounded = goodAllocSize(n);\n-        if (n == 0 || rounded < n || available < rounded) return null;\n-\n-        static if (growDownwards)\n-        {\n-            auto tmpCurrent = _current - rounded;\n-            auto result = tmpCurrent.alignDownTo(a);\n-            if (result <= tmpCurrent && result >= _begin)\n-            {\n-                _current = result;\n-                return cast(void[]) result[0 .. n];\n-            }\n-        }\n-        else\n-        {\n-            // Just bump the pointer to the next good allocation\n-            auto newCurrent = _current.alignUpTo(a);\n-            if (newCurrent < _current || newCurrent > _end)\n-                return null;\n-\n-            auto save = _current;\n-            _current = newCurrent;\n-            auto result = allocate(n);\n-            if (result.ptr)\n-            {\n-                assert(result.length == n);\n-                return result;\n-            }\n-            // Failed, rollback\n-            _current = save;\n-        }\n-        return null;\n+        return _impl.alignedAllocate(n, a);\n     }\n \n     /// Allocates and returns all memory available to this region.\n     void[] allocateAll() pure nothrow @trusted @nogc\n     {\n-        static if (growDownwards)\n-        {\n-            auto result = _begin[0 .. available];\n-            _current = _begin;\n-        }\n-        else\n-        {\n-            auto result = _current[0 .. available];\n-            _current = _end;\n-        }\n-        return result;\n+        return _impl.allocateAll;\n     }\n \n     /**\n@@ -249,25 +177,7 @@ struct Region(ParentAllocator = NullAllocator,\n     static if (growDownwards == No.growDownwards)\n     bool expand(ref void[] b, size_t delta) pure nothrow @safe @nogc\n     {\n-        assert(owns(b) == Ternary.yes || b is null);\n-        assert((() @trusted => b.ptr + b.length <= _current)() || b is null);\n-        if (b is null || delta == 0) return delta == 0;\n-        auto newLength = b.length + delta;\n-        if ((() @trusted => _current < b.ptr + b.length + alignment)())\n-        {\n-            immutable currentGoodSize = this.goodAllocSize(b.length);\n-            immutable newGoodSize = this.goodAllocSize(newLength);\n-            immutable goodDelta = newGoodSize - currentGoodSize;\n-            // This was the last allocation! Allocate some more and we're done.\n-            if (goodDelta == 0\n-                || (() @trusted => allocate(goodDelta).length == goodDelta)())\n-            {\n-                b = (() @trusted => b.ptr[0 .. newLength])();\n-                assert((() @trusted => _current < b.ptr + b.length + alignment)());\n-                return true;\n-            }\n-        }\n-        return false;\n+        return _impl.expand(b, delta);\n     }\n \n     /**\n@@ -281,26 +191,7 @@ struct Region(ParentAllocator = NullAllocator,\n     */\n     bool deallocate(void[] b) pure nothrow @nogc\n     {\n-        assert(owns(b) == Ternary.yes || b.ptr is null);\n-        auto rounded = goodAllocSize(b.length);\n-        static if (growDownwards)\n-        {\n-            if (b.ptr == _current)\n-            {\n-                _current += rounded;\n-                return true;\n-            }\n-        }\n-        else\n-        {\n-            if (b.ptr + rounded == _current)\n-            {\n-                assert(b.ptr !is null || _current is null);\n-                _current = b.ptr;\n-                return true;\n-            }\n-        }\n-        return false;\n+        return _impl.deallocate(b);\n     }\n \n     /**\n@@ -309,15 +200,7 @@ struct Region(ParentAllocator = NullAllocator,\n     */\n     bool deallocateAll() pure nothrow @nogc\n     {\n-        static if (growDownwards)\n-        {\n-            _current = roundedEnd();\n-        }\n-        else\n-        {\n-            _current = roundedBegin();\n-        }\n-        return true;\n+        return _impl.deallocateAll;\n     }\n \n     /**\n@@ -332,7 +215,7 @@ struct Region(ParentAllocator = NullAllocator,\n     */\n     Ternary owns(const void[] b) const pure nothrow @trusted @nogc\n     {\n-        return Ternary(b && (&b[0] >= _begin) && (&b[0] + b.length <= _end));\n+        return _impl.owns(b);\n     }\n \n     /**\n@@ -341,23 +224,13 @@ struct Region(ParentAllocator = NullAllocator,\n     */\n     Ternary empty() const pure nothrow @safe @nogc\n     {\n-        static if (growDownwards)\n-            return Ternary(_current == roundedEnd());\n-        else\n-            return Ternary(_current == roundedBegin());\n+        return _impl.empty;\n     }\n \n     /// Nonstandard property that returns bytes available for allocation.\n     size_t available() const @safe pure nothrow @nogc\n     {\n-        static if (growDownwards)\n-        {\n-            return _current - _begin;\n-        }\n-        else\n-        {\n-            return _end - _current;\n-        }\n+        return _impl.available;\n     }\n }\n \n@@ -414,17 +287,6 @@ struct Region(ParentAllocator = NullAllocator,\n     testAlloc(sharedReg);\n }\n \n-@system nothrow @nogc unittest\n-{\n-    import std.experimental.allocator.mallocator : AlignedMallocator;\n-    import std.typecons : Ternary;\n-\n-    ubyte[] buf = cast(ubyte[]) AlignedMallocator.instance.alignedAllocate(64, 64);\n-    auto reg = Region!(NullAllocator, 64, Yes.growDownwards)(buf);\n-    assert(reg.alignedAllocate(10, 32).length == 10);\n-    assert(!reg.available);\n-}\n-\n @system nothrow @nogc unittest\n {\n     // test 'this(ubyte[] store)' constructed regions properly clean up\n@@ -491,107 +353,428 @@ version (StdUnittest)\n }\n \n /**\n+A `BorrowedRegion` allocates directly from a user-provided block of memory.\n \n-`InSituRegion` is a convenient region that carries its storage within itself\n-(in the form of a statically-sized array).\n-\n-The first template argument is the size of the region and the second is the\n-needed alignment. Depending on the alignment requested and platform details,\n-the actual available storage may be smaller than the compile-time parameter. To\n-make sure that at least `n` bytes are available in the region, use\n-$(D InSituRegion!(n + a - 1, a)).\n-\n-Given that the most frequent use of `InSituRegion` is as a stack allocator, it\n-allocates starting at the end on systems where stack grows downwards, such that\n-hot memory is used first.\n+Unlike a `Region`, a `BorrowedRegion` does not own the memory it allocates from\n+and will not deallocate that memory upon destruction. Instead, it is the user's\n+responsibility to ensure that the memory is properly disposed of.\n \n+In all other respects, a `BorrowedRegion` behaves exactly like a `Region`.\n */\n-struct InSituRegion(size_t size, size_t minAlign = platformAlignment)\n+struct BorrowedRegion(uint minAlign = platformAlignment,\n+    Flag!\"growDownwards\" growDownwards = No.growDownwards)\n {\n-    import std.algorithm.comparison : max;\n-    import std.conv : to;\n-    import std.traits : hasMember;\n-    import std.typecons : Ternary;\n-\n     static assert(minAlign.isGoodStaticAlignment);\n-    static assert(size >= minAlign);\n \n-    version (X86) enum growDownwards = Yes.growDownwards;\n-    else version (X86_64) enum growDownwards = Yes.growDownwards;\n-    else version (ARM) enum growDownwards = Yes.growDownwards;\n-    else version (AArch64) enum growDownwards = Yes.growDownwards;\n-    else version (HPPA) enum growDownwards = No.growDownwards;\n-    else version (PPC) enum growDownwards = Yes.growDownwards;\n-    else version (PPC64) enum growDownwards = Yes.growDownwards;\n-    else version (RISCV32) enum growDownwards = Yes.growDownwards;\n-    else version (RISCV64) enum growDownwards = Yes.growDownwards;\n-    else version (MIPS32) enum growDownwards = Yes.growDownwards;\n-    else version (MIPS64) enum growDownwards = Yes.growDownwards;\n-    else version (SPARC) enum growDownwards = Yes.growDownwards;\n-    else version (SPARC64) enum growDownwards = Yes.growDownwards;\n-    else version (SystemZ) enum growDownwards = Yes.growDownwards;\n-    else static assert(0, \"Dunno how the stack grows on this architecture.\");\n+    import std.typecons : Ternary;\n \n-    @disable this(this);\n+    // state\n+    private void* _current, _begin, _end;\n \n-    // state {\n-    private Region!(NullAllocator, minAlign, growDownwards) _impl;\n-    union\n+    private void* roundedBegin() const pure nothrow @trusted @nogc\n     {\n-        private ubyte[size] _store = void;\n-        private double _forAlignmentOnly1;\n+        return cast(void*) roundUpToAlignment(cast(size_t) _begin, alignment);\n+    }\n+\n+    private void* roundedEnd() const pure nothrow @trusted @nogc\n+    {\n+        return cast(void*) roundDownToAlignment(cast(size_t) _end, alignment);\n     }\n-    // }\n \n     /**\n-    An alias for `minAlign`, which must be a valid alignment (nonzero power\n-    of 2). The start of the region and all allocation requests will be rounded\n-    up to a multiple of the alignment.\n+    Constructs a region backed by a user-provided store.\n \n-    ----\n-    InSituRegion!(4096) a1;\n-    assert(a1.alignment == platformAlignment);\n-    InSituRegion!(4096, 64) a2;\n-    assert(a2.alignment == 64);\n-    ----\n+    Params:\n+        store = User-provided store backing up the region.\n     */\n-    alias alignment = minAlign;\n-\n-    private void lazyInit()\n+    this(ubyte[] store) pure nothrow @nogc\n     {\n-        assert(!_impl._current);\n-        _impl = typeof(_impl)(_store);\n-        assert(_impl._current.alignedAt(alignment));\n+        _begin = store.ptr;\n+        _end = store.ptr + store.length;\n+        static if (growDownwards)\n+            _current = roundedEnd();\n+        else\n+            _current = roundedBegin();\n     }\n \n+    /*\n+    TODO: The postblit of `BorrowedRegion` should be disabled because such objects\n+    should not be copied around naively.\n+    */\n+\n     /**\n-    Allocates `bytes` and returns them, or `null` if the region cannot\n-    accommodate the request. For efficiency reasons, if $(D bytes == 0) the\n-    function returns an empty non-null slice.\n+    Rounds the given size to a multiple of the `alignment`\n     */\n-    void[] allocate(size_t n)\n+    size_t goodAllocSize(size_t n) const pure nothrow @safe @nogc\n     {\n-        // Fast path\n-    entry:\n-        auto result = _impl.allocate(n);\n-        if (result.length == n) return result;\n-        // Slow path\n-        if (_impl._current) return null; // no more room\n-        lazyInit;\n-        assert(_impl._current);\n-        goto entry;\n+        return n.roundUpToAlignment(alignment);\n     }\n \n     /**\n-    As above, but the memory allocated is aligned at `a` bytes.\n+    Alignment offered.\n     */\n-    void[] alignedAllocate(size_t n, uint a)\n-    {\n-        // Fast path\n-    entry:\n-        auto result = _impl.alignedAllocate(n, a);\n-        if (result.length == n) return result;\n-        // Slow path\n+    alias alignment = minAlign;\n+\n+    /**\n+    Allocates `n` bytes of memory. The shortest path involves an alignment\n+    adjustment (if $(D alignment > 1)), an increment, and a comparison.\n+\n+    Params:\n+        n = number of bytes to allocate\n+\n+    Returns:\n+        A properly-aligned buffer of size `n` or `null` if request could not\n+        be satisfied.\n+    */\n+    void[] allocate(size_t n) pure nothrow @trusted @nogc\n+    {\n+        const rounded = goodAllocSize(n);\n+        if (n == 0 || rounded < n || available < rounded) return null;\n+\n+        static if (growDownwards)\n+        {\n+            assert(available >= rounded);\n+            auto result = (_current - rounded)[0 .. n];\n+            assert(result.ptr >= _begin);\n+            _current = result.ptr;\n+            assert(owns(result) == Ternary.yes);\n+        }\n+        else\n+        {\n+            auto result = _current[0 .. n];\n+            _current += rounded;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+    Allocates `n` bytes of memory aligned at alignment `a`.\n+\n+    Params:\n+        n = number of bytes to allocate\n+        a = alignment for the allocated block\n+\n+    Returns:\n+        Either a suitable block of `n` bytes aligned at `a`, or `null`.\n+    */\n+    void[] alignedAllocate(size_t n, uint a) pure nothrow @trusted @nogc\n+    {\n+        import std.math.traits : isPowerOf2;\n+        assert(a.isPowerOf2);\n+\n+        const rounded = goodAllocSize(n);\n+        if (n == 0 || rounded < n || available < rounded) return null;\n+\n+        static if (growDownwards)\n+        {\n+            auto tmpCurrent = _current - rounded;\n+            auto result = tmpCurrent.alignDownTo(a);\n+            if (result <= tmpCurrent && result >= _begin)\n+            {\n+                _current = result;\n+                return cast(void[]) result[0 .. n];\n+            }\n+        }\n+        else\n+        {\n+            // Just bump the pointer to the next good allocation\n+            auto newCurrent = _current.alignUpTo(a);\n+            if (newCurrent < _current || newCurrent > _end)\n+                return null;\n+\n+            auto save = _current;\n+            _current = newCurrent;\n+            auto result = allocate(n);\n+            if (result.ptr)\n+            {\n+                assert(result.length == n);\n+                return result;\n+            }\n+            // Failed, rollback\n+            _current = save;\n+        }\n+        return null;\n+    }\n+\n+    /// Allocates and returns all memory available to this region.\n+    void[] allocateAll() pure nothrow @trusted @nogc\n+    {\n+        static if (growDownwards)\n+        {\n+            auto result = _begin[0 .. available];\n+            _current = _begin;\n+        }\n+        else\n+        {\n+            auto result = _current[0 .. available];\n+            _current = _end;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+    Expands an allocated block in place. Expansion will succeed only if the\n+    block is the last allocated. Defined only if `growDownwards` is\n+    `No.growDownwards`.\n+    */\n+    static if (growDownwards == No.growDownwards)\n+    bool expand(ref void[] b, size_t delta) pure nothrow @safe @nogc\n+    {\n+        assert(owns(b) == Ternary.yes || b is null);\n+        assert((() @trusted => b.ptr + b.length <= _current)() || b is null);\n+        if (b is null || delta == 0) return delta == 0;\n+        auto newLength = b.length + delta;\n+        if ((() @trusted => _current < b.ptr + b.length + alignment)())\n+        {\n+            immutable currentGoodSize = this.goodAllocSize(b.length);\n+            immutable newGoodSize = this.goodAllocSize(newLength);\n+            immutable goodDelta = newGoodSize - currentGoodSize;\n+            // This was the last allocation! Allocate some more and we're done.\n+            if (goodDelta == 0\n+                || (() @trusted => allocate(goodDelta).length == goodDelta)())\n+            {\n+                b = (() @trusted => b.ptr[0 .. newLength])();\n+                assert((() @trusted => _current < b.ptr + b.length + alignment)());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+    Deallocates `b`. This works only if `b` was obtained as the last call\n+    to `allocate`; otherwise (i.e. another allocation has occurred since) it\n+    does nothing.\n+\n+    Params:\n+        b = Block previously obtained by a call to `allocate` against this\n+        allocator (`null` is allowed).\n+    */\n+    bool deallocate(void[] b) pure nothrow @nogc\n+    {\n+        assert(owns(b) == Ternary.yes || b.ptr is null);\n+        auto rounded = goodAllocSize(b.length);\n+        static if (growDownwards)\n+        {\n+            if (b.ptr == _current)\n+            {\n+                _current += rounded;\n+                return true;\n+            }\n+        }\n+        else\n+        {\n+            if (b.ptr + rounded == _current)\n+            {\n+                assert(b.ptr !is null || _current is null);\n+                _current = b.ptr;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+    Deallocates all memory allocated by this region, which can be subsequently\n+    reused for new allocations.\n+    */\n+    bool deallocateAll() pure nothrow @nogc\n+    {\n+        static if (growDownwards)\n+        {\n+            _current = roundedEnd();\n+        }\n+        else\n+        {\n+            _current = roundedBegin();\n+        }\n+        return true;\n+    }\n+\n+    /**\n+    Queries whether `b` has been allocated with this region.\n+\n+    Params:\n+        b = Arbitrary block of memory (`null` is allowed; `owns(null)` returns\n+        `false`).\n+\n+    Returns:\n+        `true` if `b` has been allocated with this region, `false` otherwise.\n+    */\n+    Ternary owns(const void[] b) const pure nothrow @trusted @nogc\n+    {\n+        return Ternary(b && (&b[0] >= _begin) && (&b[0] + b.length <= _end));\n+    }\n+\n+    /**\n+    Returns `Ternary.yes` if no memory has been allocated in this region,\n+    `Ternary.no` otherwise. (Never returns `Ternary.unknown`.)\n+    */\n+    Ternary empty() const pure nothrow @safe @nogc\n+    {\n+        static if (growDownwards)\n+            return Ternary(_current == roundedEnd());\n+        else\n+            return Ternary(_current == roundedBegin());\n+    }\n+\n+    /// Nonstandard property that returns bytes available for allocation.\n+    size_t available() const @safe pure nothrow @nogc\n+    {\n+        static if (growDownwards)\n+        {\n+            return _current - _begin;\n+        }\n+        else\n+        {\n+            return _end - _current;\n+        }\n+    }\n+}\n+\n+///\n+@system nothrow @nogc unittest\n+{\n+    import std.typecons : Ternary;\n+\n+    ubyte[1024] store;\n+    auto myRegion = BorrowedRegion!(1)(store[]);\n+\n+    assert(myRegion.empty == Ternary.yes);\n+    assert(myRegion.available == store.length);\n+\n+    void[] b = myRegion.allocate(101);\n+\n+    assert(b.length == 101);\n+    assert(myRegion.empty == Ternary.no);\n+    assert(myRegion.owns(b) == Ternary.yes);\n+    assert(myRegion.available == store.length - b.length);\n+\n+    void[] b2 = myRegion.allocate(256);\n+\n+    // Can only free the most recent allocation\n+    assert(myRegion.deallocate(b) == false);\n+    assert(myRegion.deallocate(b2) == true);\n+\n+    myRegion.deallocateAll();\n+\n+    assert(myRegion.empty == Ternary.yes);\n+}\n+\n+@system nothrow @nogc unittest\n+{\n+    import std.experimental.allocator.mallocator : AlignedMallocator;\n+    import std.typecons : Ternary;\n+\n+    ubyte[] buf = cast(ubyte[]) AlignedMallocator.instance.alignedAllocate(64, 64);\n+    auto reg = BorrowedRegion!(64, Yes.growDownwards)(buf);\n+    assert(reg.alignedAllocate(10, 32).length == 10);\n+    assert(!reg.available);\n+}\n+\n+/**\n+\n+`InSituRegion` is a convenient region that carries its storage within itself\n+(in the form of a statically-sized array).\n+\n+The first template argument is the size of the region and the second is the\n+needed alignment. Depending on the alignment requested and platform details,\n+the actual available storage may be smaller than the compile-time parameter. To\n+make sure that at least `n` bytes are available in the region, use\n+$(D InSituRegion!(n + a - 1, a)).\n+\n+Given that the most frequent use of `InSituRegion` is as a stack allocator, it\n+allocates starting at the end on systems where stack grows downwards, such that\n+hot memory is used first.\n+\n+*/\n+struct InSituRegion(size_t size, size_t minAlign = platformAlignment)\n+{\n+    import std.algorithm.comparison : max;\n+    import std.conv : to;\n+    import std.traits : hasMember;\n+    import std.typecons : Ternary;\n+\n+    static assert(minAlign.isGoodStaticAlignment);\n+    static assert(size >= minAlign);\n+\n+    version (X86) enum growDownwards = Yes.growDownwards;\n+    else version (X86_64) enum growDownwards = Yes.growDownwards;\n+    else version (ARM) enum growDownwards = Yes.growDownwards;\n+    else version (AArch64) enum growDownwards = Yes.growDownwards;\n+    else version (HPPA) enum growDownwards = No.growDownwards;\n+    else version (PPC) enum growDownwards = Yes.growDownwards;\n+    else version (PPC64) enum growDownwards = Yes.growDownwards;\n+    else version (RISCV32) enum growDownwards = Yes.growDownwards;\n+    else version (RISCV64) enum growDownwards = Yes.growDownwards;\n+    else version (MIPS32) enum growDownwards = Yes.growDownwards;\n+    else version (MIPS64) enum growDownwards = Yes.growDownwards;\n+    else version (SPARC) enum growDownwards = Yes.growDownwards;\n+    else version (SPARC64) enum growDownwards = Yes.growDownwards;\n+    else version (SystemZ) enum growDownwards = Yes.growDownwards;\n+    else static assert(0, \"Dunno how the stack grows on this architecture.\");\n+\n+    @disable this(this);\n+\n+    // state {\n+    private BorrowedRegion!(minAlign, growDownwards) _impl;\n+    union\n+    {\n+        private ubyte[size] _store = void;\n+        private double _forAlignmentOnly1;\n+    }\n+    // }\n+\n+    /**\n+    An alias for `minAlign`, which must be a valid alignment (nonzero power\n+    of 2). The start of the region and all allocation requests will be rounded\n+    up to a multiple of the alignment.\n+\n+    ----\n+    InSituRegion!(4096) a1;\n+    assert(a1.alignment == platformAlignment);\n+    InSituRegion!(4096, 64) a2;\n+    assert(a2.alignment == 64);\n+    ----\n+    */\n+    alias alignment = minAlign;\n+\n+    private void lazyInit()\n+    {\n+        assert(!_impl._current);\n+        _impl = typeof(_impl)(_store);\n+        assert(_impl._current.alignedAt(alignment));\n+    }\n+\n+    /**\n+    Allocates `bytes` and returns them, or `null` if the region cannot\n+    accommodate the request. For efficiency reasons, if $(D bytes == 0) the\n+    function returns an empty non-null slice.\n+    */\n+    void[] allocate(size_t n)\n+    {\n+        // Fast path\n+    entry:\n+        auto result = _impl.allocate(n);\n+        if (result.length == n) return result;\n+        // Slow path\n+        if (_impl._current) return null; // no more room\n+        lazyInit;\n+        assert(_impl._current);\n+        goto entry;\n+    }\n+\n+    /**\n+    As above, but the memory allocated is aligned at `a` bytes.\n+    */\n+    void[] alignedAllocate(size_t n, uint a)\n+    {\n+        // Fast path\n+    entry:\n+        auto result = _impl.alignedAllocate(n, a);\n+        if (result.length == n) return result;\n+        // Slow path\n         if (_impl._current) return null; // no more room\n         lazyInit;\n         assert(_impl._current);\n@@ -992,7 +1175,7 @@ version (Posix) @system nothrow @nogc unittest\n The threadsafe version of the `Region` allocator.\n Allocations and deallocations are lock-free based using $(REF cas, core,atomic).\n */\n-shared struct SharedRegion(ParentAllocator = NullAllocator,\n+shared struct SharedRegion(ParentAllocator,\n     uint minAlign = platformAlignment,\n     Flag!\"growDownwards\" growDownwards = No.growDownwards)\n {\n@@ -1016,45 +1199,36 @@ shared struct SharedRegion(ParentAllocator = NullAllocator,\n     {\n         alias parent = ParentAllocator.instance;\n     }\n-    private shared void* _current, _begin, _end;\n+    private shared SharedBorrowedRegion!(minAlign, growDownwards) _impl;\n \n     private void* roundedBegin() const pure nothrow @trusted @nogc\n     {\n-        return cast(void*) roundUpToAlignment(cast(size_t) _begin, alignment);\n+        return _impl.roundedBegin;\n     }\n \n     private void* roundedEnd() const pure nothrow @trusted @nogc\n     {\n-        return cast(void*) roundDownToAlignment(cast(size_t) _end, alignment);\n+        return _impl.roundedEnd;\n     }\n \n \n     /**\n     Constructs a region backed by a user-provided store.\n-    Assumes the memory was allocated with `ParentAllocator`\n-    (if different from $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator)).\n+    Assumes the memory was allocated with `ParentAllocator`.\n \n     Params:\n-        store = User-provided store backing up the region. If `ParentAllocator`\n-        is different from $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator), memory is assumed to\n-        have been allocated with `ParentAllocator`.\n-        n = Bytes to allocate using `ParentAllocator`. This constructor is only\n-        defined If `ParentAllocator` is different from $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator). If\n-        `parent.allocate(n)` returns `null`, the region will be initialized\n-        as empty (correctly initialized but unable to allocate).\n+        store = User-provided store backing up the region. Assumed to have been\n+        allocated with `ParentAllocator`.\n+        n = Bytes to allocate using `ParentAllocator`. If `parent.allocate(n)`\n+        returns `null`, the region will be initialized as empty (correctly\n+        initialized but unable to allocate).\n     */\n     this(ubyte[] store) pure nothrow @nogc\n     {\n-        _begin = cast(typeof(_begin)) store.ptr;\n-        _end = cast(typeof(_end)) (store.ptr + store.length);\n-        static if (growDownwards)\n-            _current = cast(typeof(_current)) roundedEnd();\n-        else\n-            _current = cast(typeof(_current)) roundedBegin();\n+        _impl = store;\n     }\n \n     /// Ditto\n-    static if (!is(ParentAllocator == NullAllocator))\n     this(size_t n)\n     {\n         this(cast(ubyte[]) (parent.allocate(n.roundUpToAlignment(alignment))));\n@@ -1065,7 +1239,7 @@ shared struct SharedRegion(ParentAllocator = NullAllocator,\n     */\n     size_t goodAllocSize(size_t n) const pure nothrow @safe @nogc\n     {\n-        return n.roundUpToAlignment(alignment);\n+        return _impl.goodAllocSize(n);\n     }\n \n     /**\n@@ -1086,38 +1260,7 @@ shared struct SharedRegion(ParentAllocator = NullAllocator,\n     */\n     void[] allocate(size_t n) pure nothrow @trusted @nogc\n     {\n-        import core.atomic : cas, atomicLoad;\n-\n-        if (n == 0) return null;\n-        const rounded = goodAllocSize(n);\n-\n-        shared void* localCurrent, localNewCurrent;\n-        static if (growDownwards)\n-        {\n-            do\n-            {\n-                localCurrent = atomicLoad(_current);\n-                localNewCurrent = localCurrent - rounded;\n-                if (localNewCurrent > localCurrent || localNewCurrent < _begin)\n-                    return null;\n-            } while (!cas(&_current, localCurrent, localNewCurrent));\n-\n-            return cast(void[]) localNewCurrent[0 .. n];\n-        }\n-        else\n-        {\n-            do\n-            {\n-                localCurrent = atomicLoad(_current);\n-                localNewCurrent = localCurrent + rounded;\n-                if (localNewCurrent < localCurrent || localNewCurrent > _end)\n-                    return null;\n-            } while (!cas(&_current, localCurrent, localNewCurrent));\n-\n-            return cast(void[]) localCurrent[0 .. n];\n-        }\n-\n-        assert(0, \"Unexpected error in SharedRegion.allocate\");\n+        return _impl.allocate(n);\n     }\n \n     /**\n@@ -1131,97 +1274,30 @@ shared struct SharedRegion(ParentAllocator = NullAllocator,\n     */\n     bool deallocate(void[] b) pure nothrow @nogc\n     {\n-        import core.atomic : cas, atomicLoad;\n-\n-        const rounded = goodAllocSize(b.length);\n-        shared void* localCurrent, localNewCurrent;\n-\n-        // The cas is done only once, because only the last allocation can be reverted\n-        localCurrent = atomicLoad(_current);\n-        static if (growDownwards)\n-        {\n-            localNewCurrent = localCurrent + rounded;\n-            if (b.ptr == localCurrent)\n-                return cas(&_current, localCurrent, localNewCurrent);\n-        }\n-        else\n-        {\n-            localNewCurrent = localCurrent - rounded;\n-            if (b.ptr == localNewCurrent)\n-                return cas(&_current, localCurrent, localNewCurrent);\n-        }\n-\n-        return false;\n-    }\n-\n-    /**\n-    Deallocates all memory allocated by this region, which can be subsequently\n-    reused for new allocations.\n-    */\n-    bool deallocateAll() pure nothrow @nogc\n-    {\n-        import core.atomic : atomicStore;\n-        static if (growDownwards)\n-        {\n-            atomicStore(_current, cast(shared(void*)) roundedEnd());\n-        }\n-        else\n-        {\n-            atomicStore(_current, cast(shared(void*)) roundedBegin());\n-        }\n-        return true;\n+        return _impl.deallocate(b);\n     }\n \n-    /**\n-    Allocates `n` bytes of memory aligned at alignment `a`.\n-    Params:\n-        n = number of bytes to allocate\n-        a = alignment for the allocated block\n-\n-    Returns:\n-        Either a suitable block of `n` bytes aligned at `a`, or `null`.\n-    */\n-    void[] alignedAllocate(size_t n, uint a) pure nothrow @trusted @nogc\n-    {\n-        import core.atomic : cas, atomicLoad;\n-        import std.math.traits : isPowerOf2;\n-\n-        assert(a.isPowerOf2);\n-        if (n == 0) return null;\n-\n-        const rounded = goodAllocSize(n);\n-        shared void* localCurrent, localNewCurrent;\n-\n-        static if (growDownwards)\n-        {\n-            do\n-            {\n-                localCurrent = atomicLoad(_current);\n-                auto alignedCurrent = cast(void*)(localCurrent - rounded);\n-                localNewCurrent = cast(shared(void*)) alignedCurrent.alignDownTo(a);\n-                if (alignedCurrent > localCurrent || localNewCurrent > alignedCurrent ||\n-                    localNewCurrent < _begin)\n-                    return null;\n-            } while (!cas(&_current, localCurrent, localNewCurrent));\n-\n-            return cast(void[]) localNewCurrent[0 .. n];\n-        }\n-        else\n-        {\n-            do\n-            {\n-                localCurrent = atomicLoad(_current);\n-                auto alignedCurrent = alignUpTo(cast(void*) localCurrent, a);\n-                localNewCurrent = cast(shared(void*)) (alignedCurrent + rounded);\n-                if (alignedCurrent < localCurrent || localNewCurrent < alignedCurrent ||\n-                    localNewCurrent > _end)\n-                    return null;\n-            } while (!cas(&_current, localCurrent, localNewCurrent));\n-\n-            return cast(void[]) (localNewCurrent - rounded)[0 .. n];\n-        }\n+    /**\n+    Deallocates all memory allocated by this region, which can be subsequently\n+    reused for new allocations.\n+    */\n+    bool deallocateAll() pure nothrow @nogc\n+    {\n+        return _impl.deallocateAll;\n+    }\n+\n+    /**\n+    Allocates `n` bytes of memory aligned at alignment `a`.\n+    Params:\n+        n = number of bytes to allocate\n+        a = alignment for the allocated block\n \n-        assert(0, \"Unexpected error in SharedRegion.alignedAllocate\");\n+    Returns:\n+        Either a suitable block of `n` bytes aligned at `a`, or `null`.\n+    */\n+    void[] alignedAllocate(size_t n, uint a) pure nothrow @trusted @nogc\n+    {\n+        return _impl.alignedAllocate(n, a);\n     }\n \n     /**\n@@ -1236,7 +1312,7 @@ shared struct SharedRegion(ParentAllocator = NullAllocator,\n     */\n     Ternary owns(const void[] b) const pure nothrow @trusted @nogc\n     {\n-        return Ternary(b && (&b[0] >= _begin) && (&b[0] + b.length <= _end));\n+        return _impl.owns(b);\n     }\n \n     /**\n@@ -1245,25 +1321,17 @@ shared struct SharedRegion(ParentAllocator = NullAllocator,\n     */\n     Ternary empty() const pure nothrow @safe @nogc\n     {\n-        import core.atomic : atomicLoad;\n-\n-        auto localCurrent = atomicLoad(_current);\n-        static if (growDownwards)\n-            return Ternary(localCurrent == roundedEnd());\n-        else\n-            return Ternary(localCurrent == roundedBegin());\n+        return _impl.empty;\n     }\n \n     /**\n-    If `ParentAllocator` is not $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator) and defines `deallocate`,\n-    the region defines a destructor that uses `ParentAllocator.deallocate` to free the\n-    memory chunk.\n+    If `ParentAllocator` defines `deallocate`, the region defines a destructor\n+    that uses `ParentAllocator.deallocate` to free the memory chunk.\n     */\n-    static if (!is(ParentAllocator == NullAllocator)\n-        && hasMember!(ParentAllocator, \"deallocate\"))\n+    static if (hasMember!(ParentAllocator, \"deallocate\"))\n     ~this()\n     {\n-        parent.deallocate(cast(void[]) _begin[0 .. _end - _begin]);\n+        with (_impl) parent.deallocate(cast(void[]) _begin[0 .. _end - _begin]);\n     }\n }\n \n@@ -1397,3 +1465,250 @@ shared struct SharedRegion(ParentAllocator = NullAllocator,\n     testAlloc(a1, true);\n     testAlloc(a2, false);\n }\n+\n+/**\n+A `SharedBorrowedRegion` allocates directly from a user-provided block of memory.\n+\n+Unlike a `SharedRegion`, a `SharedBorrowedRegion` does not own the memory it\n+allocates from and will not deallocate that memory upon destruction. Instead,\n+it is the user's responsibility to ensure that the memory is properly disposed\n+of.\n+\n+In all other respects, a `SharedBorrowedRegion` behaves exactly like a `SharedRegion`.\n+*/\n+shared struct SharedBorrowedRegion(uint minAlign = platformAlignment,\n+    Flag!\"growDownwards\" growDownwards = No.growDownwards)\n+{\n+    static assert(minAlign.isGoodStaticAlignment);\n+\n+    import std.typecons : Ternary;\n+\n+    // state\n+    private void* _current, _begin, _end;\n+\n+    private void* roundedBegin() shared const pure nothrow @trusted @nogc\n+    {\n+        return cast(void*) roundUpToAlignment(cast(size_t) _begin, alignment);\n+    }\n+\n+    private void* roundedEnd() shared const pure nothrow @trusted @nogc\n+    {\n+        return cast(void*) roundDownToAlignment(cast(size_t) _end, alignment);\n+    }\n+\n+    /**\n+    Constructs a region backed by a user-provided store.\n+\n+    Params:\n+        store = User-provided store backing up the region. Must not be aliased.\n+    */\n+    this(ubyte[] store) shared pure nothrow @nogc\n+    {\n+        _begin = cast(typeof(_begin)) store.ptr;\n+        _end = cast(typeof(_end)) (store.ptr + store.length);\n+        static if (growDownwards)\n+            _current = cast(typeof(_current)) roundedEnd();\n+        else\n+            _current = cast(typeof(_current)) roundedBegin();\n+    }\n+\n+    /*\n+    TODO: The postblit of `SharedBorrowedRegion` should be disabled because\n+    such objects should not be copied around naively.\n+    */\n+\n+    /**\n+    Rounds the given size to a multiple of the `alignment`\n+    */\n+    size_t goodAllocSize(size_t n) shared const pure nothrow @safe @nogc\n+    {\n+        return n.roundUpToAlignment(alignment);\n+    }\n+\n+    /**\n+    Alignment offered.\n+    */\n+    alias alignment = minAlign;\n+\n+    /**\n+    Allocates `n` bytes of memory. The allocation is served by atomically incrementing\n+    a pointer which keeps track of the current used space.\n+\n+    Params:\n+        n = number of bytes to allocate\n+\n+    Returns:\n+        A properly-aligned buffer of size `n`, or `null` if request could not\n+        be satisfied.\n+    */\n+    void[] allocate(size_t n) shared pure nothrow @trusted @nogc\n+    {\n+        import core.atomic : cas, atomicLoad;\n+\n+        if (n == 0) return null;\n+        const rounded = goodAllocSize(n);\n+\n+        shared void* localCurrent, localNewCurrent;\n+        static if (growDownwards)\n+        {\n+            do\n+            {\n+                localCurrent = atomicLoad(_current);\n+                localNewCurrent = localCurrent - rounded;\n+                if (localNewCurrent > localCurrent || localNewCurrent < _begin)\n+                    return null;\n+            } while (!cas(&_current, localCurrent, localNewCurrent));\n+\n+            return cast(void[]) localNewCurrent[0 .. n];\n+        }\n+        else\n+        {\n+            do\n+            {\n+                localCurrent = atomicLoad(_current);\n+                localNewCurrent = localCurrent + rounded;\n+                if (localNewCurrent < localCurrent || localNewCurrent > _end)\n+                    return null;\n+            } while (!cas(&_current, localCurrent, localNewCurrent));\n+\n+            return cast(void[]) localCurrent[0 .. n];\n+        }\n+\n+        assert(0, \"Unexpected error in SharedBorrowedRegion.allocate\");\n+    }\n+\n+    /**\n+    Allocates `n` bytes of memory aligned at alignment `a`.\n+\n+    Params:\n+        n = number of bytes to allocate\n+        a = alignment for the allocated block\n+\n+    Returns:\n+        Either a suitable block of `n` bytes aligned at `a`, or `null`.\n+    */\n+    void[] alignedAllocate(size_t n, uint a) shared pure nothrow @trusted @nogc\n+    {\n+        import core.atomic : cas, atomicLoad;\n+        import std.math.traits : isPowerOf2;\n+\n+        assert(a.isPowerOf2);\n+        if (n == 0) return null;\n+\n+        const rounded = goodAllocSize(n);\n+        shared void* localCurrent, localNewCurrent;\n+\n+        static if (growDownwards)\n+        {\n+            do\n+            {\n+                localCurrent = atomicLoad(_current);\n+                auto alignedCurrent = cast(void*)(localCurrent - rounded);\n+                localNewCurrent = cast(shared(void*)) alignedCurrent.alignDownTo(a);\n+                if (alignedCurrent > localCurrent || localNewCurrent > alignedCurrent ||\n+                    localNewCurrent < _begin)\n+                    return null;\n+            } while (!cas(&_current, localCurrent, localNewCurrent));\n+\n+            return cast(void[]) localNewCurrent[0 .. n];\n+        }\n+        else\n+        {\n+            do\n+            {\n+                localCurrent = atomicLoad(_current);\n+                auto alignedCurrent = alignUpTo(cast(void*) localCurrent, a);\n+                localNewCurrent = cast(shared(void*)) (alignedCurrent + rounded);\n+                if (alignedCurrent < localCurrent || localNewCurrent < alignedCurrent ||\n+                    localNewCurrent > _end)\n+                    return null;\n+            } while (!cas(&_current, localCurrent, localNewCurrent));\n+\n+            return cast(void[]) (localNewCurrent - rounded)[0 .. n];\n+        }\n+\n+        assert(0, \"Unexpected error in SharedBorrowedRegion.alignedAllocate\");\n+    }\n+\n+    /**\n+    Deallocates `b`. This works only if `b` was obtained as the last call\n+    to `allocate`; otherwise (i.e. another allocation has occurred since) it\n+    does nothing.\n+\n+    Params:\n+        b = Block previously obtained by a call to `allocate` against this\n+        allocator (`null` is allowed).\n+    */\n+    bool deallocate(void[] b) shared pure nothrow @nogc\n+    {\n+        import core.atomic : cas, atomicLoad;\n+\n+        const rounded = goodAllocSize(b.length);\n+        shared void* localCurrent, localNewCurrent;\n+\n+        // The cas is done only once, because only the last allocation can be reverted\n+        localCurrent = atomicLoad(_current);\n+        static if (growDownwards)\n+        {\n+            localNewCurrent = localCurrent + rounded;\n+            if (b.ptr == localCurrent)\n+                return cas(&_current, localCurrent, localNewCurrent);\n+        }\n+        else\n+        {\n+            localNewCurrent = localCurrent - rounded;\n+            if (b.ptr == localNewCurrent)\n+                return cas(&_current, localCurrent, localNewCurrent);\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+    Deallocates all memory allocated by this region, which can be subsequently\n+    reused for new allocations.\n+    */\n+    bool deallocateAll() shared pure nothrow @nogc\n+    {\n+        import core.atomic : atomicStore;\n+        static if (growDownwards)\n+        {\n+            atomicStore(_current, cast(shared(void*)) roundedEnd());\n+        }\n+        else\n+        {\n+            atomicStore(_current, cast(shared(void*)) roundedBegin());\n+        }\n+        return true;\n+    }\n+\n+    /**\n+    Queries whether `b` has been allocated with this region.\n+\n+    Params:\n+        b = Arbitrary block of memory (`null` is allowed; `owns(null)` returns\n+        `false`).\n+\n+    Returns:\n+        `true` if `b` has been allocated with this region, `false` otherwise.\n+    */\n+    Ternary owns(const void[] b) shared const pure nothrow @trusted @nogc\n+    {\n+        return Ternary(b && (&b[0] >= _begin) && (&b[0] + b.length <= _end));\n+    }\n+\n+    /**\n+    Returns `Ternary.yes` if no memory has been allocated in this region,\n+    `Ternary.no` otherwise. (Never returns `Ternary.unknown`.)\n+    */\n+    Ternary empty() shared const pure nothrow @safe @nogc\n+    {\n+        import core.atomic : atomicLoad;\n+\n+        auto localCurrent = atomicLoad(_current);\n+        static if (growDownwards)\n+            return Ternary(localCurrent == roundedEnd());\n+        else\n+            return Ternary(localCurrent == roundedBegin());\n+    }\n+}"}, {"sha": "96859b0762f90e882abce3e62fcb9c9e98e768cc", "filename": "libphobos/src/std/experimental/allocator/building_blocks/scoped_allocator.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fscoped_allocator.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fscoped_allocator.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fscoped_allocator.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -259,10 +259,10 @@ version (StdUnittest)\n // Test that deallocateAll infers from parent\n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n \n-    ScopedAllocator!(Region!()) a;\n-    a.parent.parent = Region!()(new ubyte[1024 * 64]);\n+    ScopedAllocator!(BorrowedRegion!()) a;\n+    a.parent.parent = BorrowedRegion!()(new ubyte[1024 * 64]);\n     auto b = a.allocate(42);\n     assert(b.length == 42);\n     assert((() pure nothrow @safe @nogc => a.expand(b, 22))());"}, {"sha": "ff089bddc13f79a66efc8ba9fb2b67be5f106bab", "filename": "libphobos/src/std/experimental/allocator/building_blocks/segregator.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fsegregator.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fsegregator.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fsegregator.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -503,12 +503,12 @@ if (Args.length > 3)\n \n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n     import std.typecons : Ternary;\n \n-    auto a = Segregator!(10_240, Region!(), Region!())(\n-                Region!()(new ubyte[4096 * 1024]),\n-                Region!()(new ubyte[4096 * 1024]));\n+    auto a = Segregator!(10_240, BorrowedRegion!(), BorrowedRegion!())(\n+                BorrowedRegion!()(new ubyte[4096 * 1024]),\n+                BorrowedRegion!()(new ubyte[4096 * 1024]));\n \n     assert((() nothrow @safe @nogc => a.empty)() == Ternary.yes);\n     auto b = a.alignedAllocate(42, 8);"}, {"sha": "3770af10ceb33e97be8cef3a11206475df56cfe9", "filename": "libphobos/src/std/experimental/allocator/building_blocks/stats_collector.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fstats_collector.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fstats_collector.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fbuilding_blocks%2Fstats_collector.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -845,9 +845,9 @@ public:\n \n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n \n-    auto a = StatsCollector!(Region!(), Options.all, Options.all)(Region!()(new ubyte[1024 * 64]));\n+    auto a = StatsCollector!(BorrowedRegion!(), Options.all, Options.all)(BorrowedRegion!()(new ubyte[1024 * 64]));\n     auto b = a.allocate(42);\n     assert(b.length == 42);\n     // Test that reallocate infers from parent\n@@ -859,9 +859,9 @@ public:\n \n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n \n-    auto a = StatsCollector!(Region!(), Options.all)(Region!()(new ubyte[1024 * 64]));\n+    auto a = StatsCollector!(BorrowedRegion!(), Options.all)(BorrowedRegion!()(new ubyte[1024 * 64]));\n     auto b = a.alignedAllocate(42, 128);\n     assert(b.length == 42);\n     assert(b.ptr.alignedAt(128));"}, {"sha": "217792676b509de91cce7b59e061b4849c2ad6c7", "filename": "libphobos/src/std/experimental/allocator/package.d", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fpackage.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -547,24 +547,24 @@ nothrow:\n \n @system unittest\n {\n-    import std.experimental.allocator.building_blocks.region : Region;\n+    import std.experimental.allocator.building_blocks.region : BorrowedRegion;\n     import std.conv : emplace;\n \n-    auto reg = Region!()(new ubyte[1024]);\n-    auto state = reg.allocate(stateSize!(CAllocatorImpl!(Region!(), Yes.indirect)));\n-    auto regObj = emplace!(CAllocatorImpl!(Region!(), Yes.indirect))(state, &reg);\n+    auto reg = BorrowedRegion!()(new ubyte[1024]);\n+    auto state = reg.allocate(stateSize!(CAllocatorImpl!(BorrowedRegion!(), Yes.indirect)));\n+    auto regObj = emplace!(CAllocatorImpl!(BorrowedRegion!(), Yes.indirect))(state, &reg);\n \n     auto rcalloc = RCIAllocator(regObj);\n     auto b = rcalloc.allocate(10);\n     assert(b.length == 10);\n \n     // The reference counting is zero based\n-    assert((cast(CAllocatorImpl!(Region!(), Yes.indirect))(rcalloc._alloc)).rc == 1);\n+    assert((cast(CAllocatorImpl!(BorrowedRegion!(), Yes.indirect))(rcalloc._alloc)).rc == 1);\n     {\n         auto rca2 = rcalloc;\n-        assert((cast(CAllocatorImpl!(Region!(), Yes.indirect))(rcalloc._alloc)).rc == 2);\n+        assert((cast(CAllocatorImpl!(BorrowedRegion!(), Yes.indirect))(rcalloc._alloc)).rc == 2);\n     }\n-    assert((cast(CAllocatorImpl!(Region!(), Yes.indirect))(rcalloc._alloc)).rc == 1);\n+    assert((cast(CAllocatorImpl!(BorrowedRegion!(), Yes.indirect))(rcalloc._alloc)).rc == 1);\n }\n \n @system unittest"}, {"sha": "8957089de89b6c910bffe6b0b7da75f25074827e", "filename": "libphobos/src/std/file.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffile.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3714,7 +3714,7 @@ assert(!de2.isFile);\n         @property bool isSymlink() scope;\n \n         /++\n-            Returns the size of the the file represented by this `DirEntry`\n+            Returns the size of the file represented by this `DirEntry`\n             in bytes.\n           +/\n         @property ulong size() scope;"}, {"sha": "d83f0281e594d8f3572eb5958e7c06542eb31d8f", "filename": "libphobos/src/std/format/package.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -550,7 +550,7 @@ License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors: $(HTTP walterbright.com, Walter Bright), $(HTTP erdani.com,\n Andrei Alexandrescu), and Kenji Hara\n \n-Source: $(PHOBOSSRC std/format.d)\n+Source: $(PHOBOSSRC std/format/package.d)\n  */\n module std.format;\n "}, {"sha": "703ecb1e6b35e2416dd746874d9c8a0215753582", "filename": "libphobos/src/std/internal/math/gammafunction.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fgammafunction.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fgammafunction.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fgammafunction.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -631,7 +631,7 @@ enum real BETA_BIGINV = 1.084202172485504434007e-19L;\n  * betaIncomplete(a, b, x) = &Gamma;(a+b)/(&Gamma;(a) &Gamma;(b)) *\n  * $(INTEGRATE 0, x) $(POWER t, a-1)$(POWER (1-t),b-1) dt\n  *\n- * and is the same as the the cumulative distribution function.\n+ * and is the same as the cumulative distribution function.\n  *\n  * The domain of definition is 0 <= x <= 1.  In this\n  * implementation a and b are restricted to positive values."}, {"sha": "846f6ee214ab4e6d07e529c4b5d2566f12f66bca", "filename": "libphobos/src/std/logger/core.d", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Flogger%2Fcore.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Flogger%2Fcore.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Flogger%2Fcore.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -704,7 +704,7 @@ abstract class Logger\n     /** This template provides the log functions for the `Logger` `class`\n     with the `LogLevel` encoded in the function name.\n \n-    For further information see the the two functions defined inside of this\n+    For further information see the two functions defined inside of this\n     template.\n \n     The aliases following this template create the public names of these log\n@@ -1446,7 +1446,7 @@ that the returned reference is only a current snapshot and in the following\n code, you must make sure no other thread reassigns to it between reading and\n writing `sharedLog`.\n \n-`sharedLog` is only thread-safe if the the used `Logger` is thread-safe.\n+`sharedLog` is only thread-safe if the used `Logger` is thread-safe.\n The default `Logger` is thread-safe.\n -------------\n if (sharedLog !is myLogger)\n@@ -1559,10 +1559,21 @@ class StdForwardLogger : Logger\n         }\n     }\n \n+    auto oldSharedLog = sharedLog;\n+\n     sharedLog = new shared RaceLogger;\n-    scope(exit) { sharedLog = null; }\n-    () @trusted { new Thread(() { log(\"foo\"); }).start(); }();\n+    scope(exit)\n+    {\n+        sharedLog = oldSharedLog;\n+    }\n+    Thread toWaitFor;\n+    () @trusted { toWaitFor = new Thread(() { log(\"foo\"); }).start(); }();\n     log(\"bar\");\n+\n+    () @trusted\n+    {\n+        toWaitFor.join();\n+    }();\n }\n \n /** This `LogLevel` is unqiue to every thread.\n@@ -1897,7 +1908,7 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n         assertThrown!Throwable(logf(LogLevel.fatal, msg, \"Yet\"));\n     } ();\n     lineNumber = __LINE__ - 2;\n-    assert(l.msg == msg.format(\"Yet\"));\n+    assert(l.msg == msg.format(\"Yet\"), l.msg);\n     assert(l.line == lineNumber);\n     assert(l.logLevel == LogLevel.all);\n "}, {"sha": "23182790be7e60dd71d4d19f9f5f7806ad8f761f", "filename": "libphobos/src/std/net/curl.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fnet%2Fcurl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fnet%2Fcurl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fnet%2Fcurl.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1973,7 +1973,7 @@ private mixin template Protocol()\n     }\n \n     /**\n-     * The network interface to use in form of the the IP of the interface.\n+     * The network interface to use in form of the IP of the interface.\n      *\n      * Example:\n      * ----\n@@ -2706,7 +2706,7 @@ struct HTTP\n         @property void dnsTimeout(Duration d);\n \n         /**\n-         * The network interface to use in form of the the IP of the interface.\n+         * The network interface to use in form of the IP of the interface.\n          *\n          * Example:\n          * ----\n@@ -3486,7 +3486,7 @@ struct FTP\n         @property void dnsTimeout(Duration d);\n \n         /**\n-         * The network interface to use in form of the the IP of the interface.\n+         * The network interface to use in form of the IP of the interface.\n          *\n          * Example:\n          * ----\n@@ -3912,7 +3912,7 @@ struct SMTP\n         @property void dnsTimeout(Duration d);\n \n         /**\n-         * The network interface to use in form of the the IP of the interface.\n+         * The network interface to use in form of the IP of the interface.\n          *\n          * Example:\n          * ----"}, {"sha": "df7ac39b4e445e64b0c49e3f6be9c4d4750f13ea", "filename": "libphobos/src/std/numeric.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fnumeric.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fnumeric.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fnumeric.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -1124,8 +1124,8 @@ public:\n  *\n  * References: \"On Enclosing Simple Roots of Nonlinear Equations\",\n  * G. Alefeld, F.A. Potra, Yixun Shi, Mathematics of Computation 61,\n- * pp733-744 (1993).  Fortran code available from $(HTTP\n- * www.netlib.org,www.netlib.org) as algorithm TOMS478.\n+ * pp733-744 (1993).  Fortran code available from\n+ * $(HTTP www.netlib.org,www.netlib.org) as algorithm TOMS478.\n  *\n  */\n T findRoot(T, DF, DT)(scope DF f, const T a, const T b,"}, {"sha": "4b5a7efe07f2e742eeda26ac52de1915c01af8d2", "filename": "libphobos/src/std/path.d", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fpath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fpath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fpath.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3357,8 +3357,10 @@ in\n {\n     // Verify that pattern[] is valid\n     import std.algorithm.searching : balancedParens;\n-    assert(balancedParens(pattern, '[', ']', 0));\n-    assert(balancedParens(pattern, '{', '}', 0));\n+    import std.utf : byUTF;\n+\n+    assert(balancedParens(pattern.byUTF!C, '[', ']', 0));\n+    assert(balancedParens(pattern.byUTF!C, '{', '}', 0));\n }\n do\n {\n@@ -3959,7 +3961,7 @@ string expandTilde(string inputPath) @safe nothrow\n     version (Posix)\n     {\n         import core.exception : onOutOfMemoryError;\n-        import core.stdc.errno : errno, ERANGE;\n+        import core.stdc.errno : errno, EBADF, ENOENT, EPERM, ERANGE, ESRCH;\n         import core.stdc.stdlib : malloc, free, realloc;\n \n         /*  Joins a path from a C string to the remainder of path.\n@@ -4065,7 +4067,7 @@ string expandTilde(string inputPath) @safe nothrow\n                 char[] extra_memory;\n \n                 passwd result;\n-                while (1)\n+                loop: while (1)\n                 {\n                     extra_memory.length += extra_memory_size;\n \n@@ -4088,10 +4090,23 @@ string expandTilde(string inputPath) @safe nothrow\n                         break;\n                     }\n \n-                    if (errno != ERANGE &&\n+                    switch (errno)\n+                    {\n+                        case ERANGE:\n                         // On BSD and OSX, errno can be left at 0 instead of set to ERANGE\n-                        errno != 0)\n-                        onOutOfMemoryError();\n+                        case 0:\n+                            break;\n+\n+                        case ENOENT:\n+                        case ESRCH:\n+                        case EBADF:\n+                        case EPERM:\n+                            // The given name or uid was not found.\n+                            break loop;\n+\n+                        default:\n+                            onOutOfMemoryError();\n+                    }\n \n                     // extra_memory isn't large enough\n                     import core.checkedint : mulu;"}, {"sha": "cdab401a1f28447fe8a4fc840802373f44e66412", "filename": "libphobos/src/std/range/primitives.d", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Frange%2Fprimitives.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Frange%2Fprimitives.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Frange%2Fprimitives.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -172,7 +172,7 @@ Returns:\n enum bool isInputRange(R) =\n     is(typeof(R.init) == R)\n     && is(ReturnType!((R r) => r.empty) == bool)\n-    && is(typeof((return ref R r) => r.front))\n+    && (is(typeof((return ref R r) => r.front)) || is(typeof(ref (return ref R r) => r.front)))\n     && !is(ReturnType!((R r) => r.front) == void)\n     && is(typeof((R r) => r.popFront));\n \n@@ -227,6 +227,17 @@ enum bool isInputRange(R) =\n     }\n     static assert(!isInputRange!VoidFront);\n }\n+// https://issues.dlang.org/show_bug.cgi?id=16034\n+@safe unittest\n+{\n+    struct One\n+    {\n+        int entry = 1;\n+        @disable this(this);\n+    }\n+\n+    assert(isInputRange!(One[]));\n+}\n \n @safe unittest\n {"}, {"sha": "fb2c2d4225300a52d3eac860f3231821a467fb29", "filename": "libphobos/src/std/socket.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fsocket.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fsocket.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fsocket.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -2942,7 +2942,7 @@ public:\n      * Calling `shutdown` before `close` is recommended\n      * for connection-oriented sockets.\n      */\n-    void close() @trusted nothrow @nogc\n+    void close() scope @trusted nothrow @nogc\n     {\n         _close(sock);\n         sock = socket_t.init;\n@@ -3641,7 +3641,7 @@ class UdpSocket: Socket\n             {\n                 checkAttributes!q{nothrow @nogc @trusted};\n             }\n-            nothrow @nogc @trusted void close()\n+            nothrow @nogc @trusted scope void close()\n             {\n                 checkAttributes!q{nothrow @nogc @trusted};\n             }"}, {"sha": "cd1a356eda10fa3b1418872f0c3637101562bdba", "filename": "libphobos/src/std/stdio.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fstdio.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -85,8 +85,7 @@ else version (CRuntime_Musl)\n }\n else version (CRuntime_UClibc)\n {\n-    // uClibc supports GCC IO\n-    version = GCC_IO;\n+    version = GENERIC_IO;\n }\n else version (OSX)\n {\n@@ -589,7 +588,7 @@ Throws: `ErrnoException` if the file could not be opened.\n         detach();\n     }\n \n-    this(this) @safe nothrow\n+    this(this) @safe pure nothrow @nogc\n     {\n         if (!_p) return;\n         assert(atomicLoad(_p.refs));"}, {"sha": "ee2d73a1233428336d0608e72615b5026030ecc5", "filename": "libphobos/src/std/sumtype.d", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fsumtype.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -753,23 +753,6 @@ public:\n         }\n     }\n \n-    invariant\n-    {\n-        this.match!((ref value) {\n-            static if (is(typeof(value) == class))\n-            {\n-                if (value !is null)\n-                {\n-                    assert(value);\n-                }\n-            }\n-            else static if (is(typeof(value) == struct))\n-            {\n-                assert(&value);\n-            }\n-        });\n-    }\n-\n     // Workaround for https://issues.dlang.org/show_bug.cgi?id=21400\n     version (StdDdoc)\n     {\n@@ -1330,36 +1313,6 @@ version (D_BetterC) {} else\n     }));\n }\n \n-// Types with invariants\n-// Disabled in BetterC due to use of exceptions\n-version (D_BetterC) {} else\n-version (D_Invariants)\n-@system unittest\n-{\n-    import std.exception : assertThrown;\n-    import core.exception : AssertError;\n-\n-    struct S\n-    {\n-        int i;\n-        invariant { assert(i >= 0); }\n-    }\n-\n-    class C\n-    {\n-        int i;\n-        invariant { assert(i >= 0); }\n-    }\n-\n-    SumType!S x;\n-    x.match!((ref v) { v.i = -1; });\n-    assertThrown!AssertError(assert(&x));\n-\n-    SumType!C y = new C();\n-    y.match!((ref v) { v.i = -1; });\n-    assertThrown!AssertError(assert(&y));\n-}\n-\n // Calls value postblit on self-assignment\n @safe unittest\n {"}, {"sha": "094628b559cf656501b4dbcf1a7238dc75df9fc3", "filename": "libphobos/src/std/typecons.d", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftypecons.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3793,8 +3793,28 @@ Params:\n                 sink.formatValue(_value, fmt);\n             }\n         }\n+\n+        void toString()(scope void delegate(const(char)[]) sink, scope const ref FormatSpec!char fmt) const\n+        {\n+            if (isNull)\n+            {\n+                sink.formatValue(\"Nullable.null\", fmt);\n+            }\n+            else\n+            {\n+                sink.formatValue(_value, fmt);\n+            }\n+        }\n     }\n \n+@system unittest\n+{\n+    import std.conv : to;\n+\n+    const Nullable!(ulong, 0) x = 1;\n+    assert(x.to!string == \"1\");\n+}\n+\n /**\n Check if `this` is in the null state.\n \n@@ -4320,8 +4340,28 @@ Params:\n                 sink.formatValue(*_value, fmt);\n             }\n         }\n+\n+        void toString()(scope void delegate(const(char)[]) sink, scope const ref FormatSpec!char fmt) const\n+        {\n+            if (isNull)\n+            {\n+                sink.formatValue(\"Nullable.null\", fmt);\n+            }\n+            else\n+            {\n+                sink.formatValue(*_value, fmt);\n+            }\n+        }\n     }\n \n+@system unittest\n+{\n+    import std.conv : to;\n+\n+    const NullableRef!(ulong) x = new ulong(1);\n+    assert(x.to!string == \"1\");\n+}\n+\n /**\n Binds the internal state to `value`.\n "}, {"sha": "8a032aaa514740560c9c94009d5253e8c9cb9dbb", "filename": "libphobos/src/std/uni/package.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -426,7 +426,7 @@ $(TR $(TD Building blocks) $(TD\n     $(SECTION Construction of lookup tables)\n     $(P The Unicode standard describes a set of algorithms that\n         depend on having the ability to quickly look up various properties\n-        of a code point. Given the the codespace of about 1 million $(CODEPOINTS),\n+        of a code point. Given the codespace of about 1 million $(CODEPOINTS),\n         it is not a trivial task to provide a space-efficient solution for\n         the multitude of properties.\n     )"}, {"sha": "8d94e121ff2170246e08c5441eeae7973c81f950", "filename": "libphobos/src/std/utf.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8dfa79c9948ce09a7b4071f8059294b1972aef6/libphobos%2Fsrc%2Fstd%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Futf.d?ref=c8dfa79c9948ce09a7b4071f8059294b1972aef6", "patch": "@@ -3571,7 +3571,7 @@ enum dchar replacementDchar = '\\uFFFD';\n  *      of characters (including strings) or a type that implicitly converts to a string type.\n  * Returns:\n  *      If `r` is not an auto-decodable string (i.e. a narrow string or a\n- *      user-defined type that implicits converts to a string type), then `r`\n+ *      user-defined type that implicitly converts to a string type), then `r`\n  *      is returned.\n  *\n  *      Otherwise, `r` is converted to its corresponding string type (if it's"}, {"sha": "fdfdc3f70abfa45cea510ed8ca5605cb06982ad4", "filename": "libphobos/src/std/xml.d", "status": "removed", "additions": 0, "deletions": 3113, "changes": 3113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2/libphobos%2Fsrc%2Fstd%2Fxml.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2/libphobos%2Fsrc%2Fstd%2Fxml.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fxml.d?ref=be4a6551ed37c1e7dbdfb9400fc2e2b5d40c5be2"}]}