{"sha": "675d607041a286e80da64c0de803ee2ff9669e64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc1ZDYwNzA0MWEyODZlODBkYTY0YzBkZTgwM2VlMmZmOTY2OWU2NA==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-04-06T09:18:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:18:09Z"}, "message": "checks.ads, checks.adb (Selected_Range_Checks): No range check is required for a conversion between two...\n\n2007-04-06  Thomas Quinot  <quinot@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* checks.ads, checks.adb (Selected_Range_Checks): No range check is\n\trequired for a conversion between two access-to-unconstrained-array\n\ttypes.\n\t(Expr_Known_Valid): Validity checks do not apply to discriminants, but\n\tto discriminant constraints on discriminant objects. This rule must\n\tapply as well to discriminants of protected types in private components.\n\t(Null_Exclusion_Static_Checks): If No_Initialization is set on an\n\tobject of a null-excluding access type then don't require the\n\tthe object declaration to have an expression and don't emit a\n\trun-time check.\n\nFrom-SVN: r123554", "tree": {"sha": "de49bf424086aff1103408245a1df50cff482b5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de49bf424086aff1103408245a1df50cff482b5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/675d607041a286e80da64c0de803ee2ff9669e64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/675d607041a286e80da64c0de803ee2ff9669e64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/675d607041a286e80da64c0de803ee2ff9669e64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/675d607041a286e80da64c0de803ee2ff9669e64/comments", "author": null, "committer": null, "parents": [{"sha": "4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cd52f5eab66c5cb3fb60f535f2cff73864a6d5f"}], "stats": {"total": 775, "additions": 389, "deletions": 386}, "files": [{"sha": "53c534d9ad27e3f146c547433e9559cb7a50df9c", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 382, "deletions": 385, "changes": 767, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675d607041a286e80da64c0de803ee2ff9669e64/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675d607041a286e80da64c0de803ee2ff9669e64/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=675d607041a286e80da64c0de803ee2ff9669e64", "patch": "@@ -820,11 +820,10 @@ package body Checks is\n       Set_Analyzed (Opnd, True);\n       Set_Right_Opnd (Opnod, Opnd);\n \n-      --  The type of the operation changes to the base type of the check\n-      --  type, and we reset the overflow check indication, since clearly\n-      --  no overflow is possible now that we are using a double length\n-      --  type. We also set the Analyzed flag to avoid a recursive attempt\n-      --  to expand the node.\n+      --  The type of the operation changes to the base type of the check type,\n+      --  and we reset the overflow check indication, since clearly no overflow\n+      --  is possible now that we are using a double length type. We also set\n+      --  the Analyzed flag to avoid a recursive attempt to expand the node.\n \n       Set_Etype             (Opnod, Base_Type (Ctyp));\n       Set_Do_Overflow_Check (Opnod, False);\n@@ -836,8 +835,8 @@ package body Checks is\n       Analyze (Opnd);\n       Set_Etype (Opnd, Typ);\n \n-      --  In the discrete type case, we directly generate the range check\n-      --  for the outer operand. This range check will implement the required\n+      --  In the discrete type case, we directly generate the range check for\n+      --  the outer operand. This range check will implement the required\n       --  overflow check.\n \n       if Is_Discrete_Type (Typ) then\n@@ -863,16 +862,16 @@ package body Checks is\n    -- Apply_Array_Size_Check --\n    ----------------------------\n \n-   --  The situation is as follows. In GNAT 3 (GCC 2.x), the size in bits\n-   --  is computed in 32 bits without an overflow check. That's a real\n-   --  problem for Ada. So what we do in GNAT 3 is to approximate the\n-   --  size of an array by manually multiplying the element size by the\n-   --  number of elements, and comparing that against the allowed limits.\n+   --  The situation is as follows. In GNAT 3 (GCC 2.x), the size in bits is\n+   --  computed in 32 bits without an overflow check. That's a real problem for\n+   --  Ada. So what we do in GNAT 3 is to approximate the size of an array by\n+   --  manually multiplying the element size by the number of elements, and\n+   --  comparing that against the allowed limits.\n \n-   --  In GNAT 5, the size in byte is still computed in 32 bits without\n-   --  an overflow check in the dynamic case, but the size in bits is\n-   --  computed in 64 bits. We assume that's good enough, and we do not\n-   --  bother to generate any front end test.\n+   --  In GNAT 5, the size in byte is still computed in 32 bits without an\n+   --  overflow check in the dynamic case, but the size in bits is computed in\n+   --  64 bits. We assume that's good enough, and we do not bother to generate\n+   --  any front end test.\n \n    procedure Apply_Array_Size_Check (N : Node_Id; Typ : Entity_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n@@ -893,8 +892,8 @@ package body Checks is\n       --  Set false if any index subtye bound is non-static\n \n       Umark : constant Uintp.Save_Mark := Uintp.Mark;\n-      --  We can throw away all the Uint computations here, since they are\n-      --  done only to generate boolean test results.\n+      --  We can throw away all the Uint computations here, since they are done\n+      --  only to generate boolean test results.\n \n       Check_Siz : Uint;\n       --  Size to check against\n@@ -929,7 +928,6 @@ package body Checks is\n                declare\n                   F : constant Node_Id :=\n                         First (Pragma_Argument_Associations (Decl));\n-\n                begin\n                   return\n                     Present (F)\n@@ -953,9 +951,11 @@ package body Checks is\n    --  Start of processing for Apply_Array_Size_Check\n \n    begin\n-      --  Do size check on local arrays. We only need this in the GCC 2\n-      --  case, since in GCC 3, we expect the back end to properly handle\n-      --  things. This routine can be removed when we baseline GNAT 3.\n+      --  Do size check on local arrays. We only need this in the GCC 2 case,\n+      --  since in GCC 3, we expect the back end to properly handle things.\n+      --  This routine can be removed when we baseline GNAT 3.\n+\n+      --  Shouldn't we remove GCC 2 crud at this stage ???\n \n       if Opt.GCC_Version >= 3 then\n          return;\n@@ -981,10 +981,10 @@ package body Checks is\n          return;\n       end if;\n \n-      --  Look head for pragma interface/import or address clause applying\n-      --  to this entity. If found, we suppress the check entirely. For now\n-      --  we only look ahead 20 declarations to stop this becoming too slow\n-      --  Note that eventually this whole routine gets moved to gigi.\n+      --  Look head for pragma interface/import or address clause applying to\n+      --  this entity. If found, we suppress the check entirely. For now we\n+      --  only look ahead 20 declarations to stop this becoming too slow Note\n+      --  that eventually this whole routine gets moved to gigi.\n \n       Decl := N;\n       for Ctr in 1 .. 20 loop\n@@ -996,10 +996,10 @@ package body Checks is\n          end if;\n       end loop;\n \n-      --  First step is to calculate the maximum number of elements. For\n-      --  this calculation, we use the actual size of the subtype if it is\n-      --  static, and if a bound of a subtype is non-static, we go to the\n-      --  bound of the base type.\n+      --  First step is to calculate the maximum number of elements. For this\n+      --  calculation, we use the actual size of the subtype if it is static,\n+      --  and if a bound of a subtype is non-static, we go to the bound of the\n+      --  base type.\n \n       Siz := Uint_1;\n       Indx := First_Index (Typ);\n@@ -1008,8 +1008,8 @@ package body Checks is\n          Lo := Type_Low_Bound (Xtyp);\n          Hi := Type_High_Bound (Xtyp);\n \n-         --  If any bound raises constraint error, we will never get this\n-         --  far, so there is no need to generate any kind of check.\n+         --  If any bound raises constraint error, we will never get this far,\n+         --  so there is no need to generate any kind of check.\n \n          if Raises_Constraint_Error (Lo)\n            or else\n@@ -1049,8 +1049,8 @@ package body Checks is\n          Check_Siz := Uint_2 ** 31;\n       end if;\n \n-      --  If we have all static bounds and Siz is too large, then we know\n-      --  we know we have a storage error right now, so generate message\n+      --  If we have all static bounds and Siz is too large, then we know we\n+      --  have a storage error right now, so generate message\n \n       if Static and then Siz >= Check_Siz then\n          Insert_Action (N,\n@@ -1061,8 +1061,8 @@ package body Checks is\n          return;\n       end if;\n \n-      --  Case of component size known at compile time. If the array\n-      --  size is definitely in range, then we do not need a check.\n+      --  Case of component size known at compile time. If the array size is\n+      --  definitely in range, then we do not need a check.\n \n       if Known_Esize (Ctyp)\n         and then Siz * Esize (Ctyp) < Check_Siz\n@@ -1073,9 +1073,9 @@ package body Checks is\n \n       --  Here if a dynamic check is required\n \n-      --  What we do is to build an expression for the size of the array,\n-      --  which is computed as the 'Size of the array component, times\n-      --  the size of each dimension.\n+      --  What we do is to build an expression for the size of the array, which\n+      --  is computed as the 'Size of the array component, times the size of\n+      --  each dimension.\n \n       Uintp.Release (Umark);\n \n@@ -1266,15 +1266,15 @@ package body Checks is\n          return;\n       end if;\n \n-      --  No discriminant checks necessary for an access when expression\n-      --  is statically Null. This is not only an optimization, this is\n-      --  fundamental because otherwise discriminant checks may be generated\n-      --  in init procs for types containing an access to a not-yet-frozen\n-      --  record, causing a deadly forward reference.\n+      --  No discriminant checks necessary for an access when expression is\n+      --  statically Null. This is not only an optimization, it is fundamental\n+      --  because otherwise discriminant checks may be generated in init procs\n+      --  for types containing an access to a not-yet-frozen record, causing a\n+      --  deadly forward reference.\n \n-      --  Also, if the expression is of an access type whose designated\n-      --  type is incomplete, then the access value must be null and\n-      --  we suppress the check.\n+      --  Also, if the expression is of an access type whose designated type is\n+      --  incomplete, then the access value must be null and we suppress the\n+      --  check.\n \n       if Nkind (N) = N_Null then\n          return;\n@@ -1311,9 +1311,9 @@ package body Checks is\n          T_Typ := Get_Actual_Subtype (Lhs);\n       end if;\n \n-      --  Nothing to do if the type is unconstrained (this is the case\n-      --  where the actual subtype in the RM sense of N is unconstrained\n-      --  and no check is required).\n+      --  Nothing to do if the type is unconstrained (this is the case where\n+      --  the actual subtype in the RM sense of N is unconstrained and no check\n+      --  is required).\n \n       if not Is_Constrained (T_Typ) then\n          return;\n@@ -1333,9 +1333,9 @@ package body Checks is\n          return;\n       end if;\n \n-      --  Suppress checks if the subtypes are the same.\n-      --  the check must be preserved in an assignment to a formal, because\n-      --  the constraint is given by the actual.\n+      --  Suppress checks if the subtypes are the same. the check must be\n+      --  preserved in an assignment to a formal, because the constraint is\n+      --  given by the actual.\n \n       if Nkind (Original_Node (N)) /= N_Allocator\n         and then (No (Lhs)\n@@ -1349,9 +1349,9 @@ package body Checks is\n             return;\n          end if;\n \n-      --  We can also eliminate checks on allocators with a subtype mark\n-      --  that coincides with the context type. The context type may be a\n-      --  subtype without a constraint (common case, a generic actual).\n+      --  We can also eliminate checks on allocators with a subtype mark that\n+      --  coincides with the context type. The context type may be a subtype\n+      --  without a constraint (common case, a generic actual).\n \n       elsif Nkind (Original_Node (N)) = N_Allocator\n         and then Is_Entity_Name (Expression (Original_Node (N)))\n@@ -1373,9 +1373,9 @@ package body Checks is\n          end;\n       end if;\n \n-      --  See if we have a case where the types are both constrained, and\n-      --  all the constraints are constants. In this case, we can do the\n-      --  check successfully at compile time.\n+      --  See if we have a case where the types are both constrained, and all\n+      --  the constraints are constants. In this case, we can do the check\n+      --  successfully at compile time.\n \n       --  We skip this check for the case where the node is a rewritten`\n       --  allocator, because it already carries the context subtype, and\n@@ -1393,10 +1393,10 @@ package body Checks is\n \n          begin\n             --  S_Typ may not have discriminants in the case where it is a\n-            --  private type completed by a default discriminated type. In\n-            --  that case, we need to get the constraints from the\n-            --  underlying_type. If the underlying type is unconstrained (i.e.\n-            --  has no default discriminants) no check is needed.\n+            --  private type completed by a default discriminated type. In that\n+            --  case, we need to get the constraints from the underlying_type.\n+            --  If the underlying type is unconstrained (i.e. has no default\n+            --  discriminants) no check is needed.\n \n             if Has_Discriminants (S_Typ) then\n                Discr := First_Discriminant (S_Typ);\n@@ -1578,15 +1578,15 @@ package body Checks is\n    -- Apply_Float_Conversion_Check --\n    ----------------------------------\n \n-   --  Let F and I be the source and target types of the conversion.\n-   --  The Ada standard specifies that a floating-point value X is rounded\n-   --  to the nearest integer, with halfway cases being rounded away from\n-   --  zero. The rounded value of X is checked against I'Range.\n+   --  Let F and I be the source and target types of the conversion. The RM\n+   --  specifies that a floating-point value X is rounded to the nearest\n+   --  integer, with halfway cases being rounded away from zero. The rounded\n+   --  value of X is checked against I'Range.\n+\n+   --  The catch in the above paragraph is that there is no good way to know\n+   --  whether the round-to-integer operation resulted in overflow. A remedy is\n+   --  to perform a range check in the floating-point domain instead, however:\n \n-   --  The catch in the above paragraph is that there is no good way\n-   --  to know whether the round-to-integer operation resulted in\n-   --  overflow. A remedy is to perform a range check in the floating-point\n-   --  domain instead, however:\n    --      (1)  The bounds may not be known at compile time\n    --      (2)  The check must take into account possible rounding.\n    --      (3)  The range of type I may not be exactly representable in F.\n@@ -1595,6 +1595,7 @@ package body Checks is\n    --      (5)  X may be a NaN, which will fail any comparison\n \n    --  The following steps take care of these issues converting X:\n+\n    --      (1) If either I'First or I'Last is not known at compile time, use\n    --          I'Base instead of I in the next three steps and perform a\n    --          regular range check against I'Range after conversion.\n@@ -1613,36 +1614,40 @@ package body Checks is\n      (Ck_Node    : Node_Id;\n       Target_Typ : Entity_Id)\n    is\n-      LB          : constant Node_Id := Type_Low_Bound (Target_Typ);\n-      HB          : constant Node_Id := Type_High_Bound (Target_Typ);\n+      LB          : constant Node_Id    := Type_Low_Bound (Target_Typ);\n+      HB          : constant Node_Id    := Type_High_Bound (Target_Typ);\n       Loc         : constant Source_Ptr := Sloc (Ck_Node);\n       Expr_Type   : constant Entity_Id  := Base_Type (Etype (Ck_Node));\n-      Target_Base : constant Entity_Id  := Implementation_Base_Type\n-                                             (Target_Typ);\n+      Target_Base : constant Entity_Id  :=\n+                      Implementation_Base_Type (Target_Typ);\n+\n       Max_Bound   : constant Uint := UI_Expon\n                                        (Machine_Radix (Expr_Type),\n                                         Machine_Mantissa (Expr_Type) - 1) - 1;\n       --  Largest bound, so bound plus or minus half is a machine number of F\n \n-      Ifirst,\n-      Ilast     : Uint;         --  Bounds of integer type\n-      Lo, Hi    : Ureal;        --  Bounds to check in floating-point domain\n-      Lo_OK,\n-      Hi_OK     : Boolean;      --  True iff Lo resp. Hi belongs to I'Range\n+      Ifirst, Ilast : Uint;\n+      --  Bounds of integer type\n+\n+      Lo, Hi : Ureal;\n+      --  Bounds to check in floating-point domain\n \n-      Lo_Chk,\n-      Hi_Chk    : Node_Id;      --  Expressions that are False iff check fails\n+      Lo_OK, Hi_OK : Boolean;\n+      --  True iff Lo resp. Hi belongs to I'Range\n \n-      Reason    : RT_Exception_Code;\n+      Lo_Chk, Hi_Chk : Node_Id;\n+      --  Expressions that are False iff check fails\n+\n+      Reason : RT_Exception_Code;\n \n    begin\n       if not Compile_Time_Known_Value (LB)\n           or not Compile_Time_Known_Value (HB)\n       then\n          declare\n-            --  First check that the value falls in the range of the base\n-            --  type, to prevent overflow during conversion and then\n-            --  perform a regular range check against the (dynamic) bounds.\n+            --  First check that the value falls in the range of the base type,\n+            --  to prevent overflow during conversion and then perform a\n+            --  regular range check against the (dynamic) bounds.\n \n             Par : constant Node_Id := Parent (Ck_Node);\n \n@@ -1734,9 +1739,9 @@ package body Checks is\n                      Right_Opnd => Make_Real_Literal (Loc, Hi));\n       end if;\n \n-      --  If the bounds of the target type are the same as those of the\n-      --  base type, the check is an overflow check as a range check is\n-      --  not performed in these cases.\n+      --  If the bounds of the target type are the same as those of the base\n+      --  type, the check is an overflow check as a range check is not\n+      --  performed in these cases.\n \n       if Expr_Value (Type_Low_Bound (Target_Base)) = Ifirst\n         and then Expr_Value (Type_High_Bound (Target_Base)) = Ilast\n@@ -1786,8 +1791,8 @@ package body Checks is\n    -- Apply_Scalar_Range_Check --\n    ------------------------------\n \n-   --  Note that Apply_Scalar_Range_Check never turns the Do_Range_Check\n-   --  flag off if it is already set on.\n+   --  Note that Apply_Scalar_Range_Check never turns the Do_Range_Check flag\n+   --  off if it is already set on.\n \n    procedure Apply_Scalar_Range_Check\n      (Expr       : Node_Id;\n@@ -1810,8 +1815,8 @@ package body Checks is\n       --  range of the subscript, since we don't know the actual subtype.\n \n       Int_Real : Boolean;\n-      --  Set to True if Expr should be regarded as a real value\n-      --  even though the type of Expr might be discrete.\n+      --  Set to True if Expr should be regarded as a real value even though\n+      --  the type of Expr might be discrete.\n \n       procedure Bad_Value;\n       --  Procedure called if value is determined to be out of range\n@@ -1834,10 +1839,10 @@ package body Checks is\n       if Inside_A_Generic then\n          return;\n \n-      --  Return if check obviously not needed. Note that we do not check\n-      --  for the expander being inactive, since this routine does not\n-      --  insert any code, but it does generate useful warnings sometimes,\n-      --  which we would like even if we are in semantics only mode.\n+      --  Return if check obviously not needed. Note that we do not check for\n+      --  the expander being inactive, since this routine does not insert any\n+      --  code, but it does generate useful warnings sometimes, which we would\n+      --  like even if we are in semantics only mode.\n \n       elsif Target_Typ = Any_Type\n         or else not Is_Scalar_Type (Target_Typ)\n@@ -1901,8 +1906,8 @@ package body Checks is\n             then\n                return;\n \n-            --  If Expr is part of an assignment statement, then check\n-            --  left side of assignment if it is an entity name.\n+            --  If Expr is part of an assignment statement, then check left\n+            --  side of assignment if it is an entity name.\n \n             elsif Nkind (Parnt) = N_Assignment_Statement\n               and then Is_Entity_Name (Name (Parnt))\n@@ -1945,9 +1950,9 @@ package body Checks is\n       Is_Unconstrained_Subscr_Ref :=\n         Is_Subscr_Ref and then not Is_Constrained (Arr_Typ);\n \n-      --  Always do a range check if the source type includes infinities\n-      --  and the target type does not include infinities. We do not do\n-      --  this if range checks are killed.\n+      --  Always do a range check if the source type includes infinities and\n+      --  the target type does not include infinities. We do not do this if\n+      --  range checks are killed.\n \n       if Is_Floating_Point_Type (S_Typ)\n         and then Has_Infinities (S_Typ)\n@@ -1956,16 +1961,15 @@ package body Checks is\n          Enable_Range_Check (Expr);\n       end if;\n \n-      --  Return if we know expression is definitely in the range of\n-      --  the target type as determined by Determine_Range. Right now\n-      --  we only do this for discrete types, and not fixed-point or\n-      --  floating-point types.\n+      --  Return if we know expression is definitely in the range of the target\n+      --  type as determined by Determine_Range. Right now we only do this for\n+      --  discrete types, and not fixed-point or floating-point types.\n \n       --  The additional less-precise tests below catch these cases\n \n-      --  Note: skip this if we are given a source_typ, since the point\n-      --  of supplying a Source_Typ is to stop us looking at the expression.\n-      --  could sharpen this test to be out parameters only ???\n+      --  Note: skip this if we are given a source_typ, since the point of\n+      --  supplying a Source_Typ is to stop us looking at the expression.\n+      --  We could sharpen this test to be out parameters only ???\n \n       if Is_Discrete_Type (Target_Typ)\n         and then Is_Discrete_Type (Etype (Expr))\n@@ -2047,9 +2051,9 @@ package body Checks is\n          Bad_Value;\n          return;\n \n-      --  In the floating-point case, we only do range checks if the\n-      --  type is constrained. We definitely do NOT want range checks\n-      --  for unconstrained types, since we want to have infinities\n+      --  In the floating-point case, we only do range checks if the type is\n+      --  constrained. We definitely do NOT want range checks for unconstrained\n+      --  types, since we want to have infinities\n \n       elsif Is_Floating_Point_Type (S_Typ) then\n          if Is_Constrained (S_Typ) then\n@@ -2114,9 +2118,8 @@ package body Checks is\n             end if;\n          end if;\n \n-         --  If the item is a conditional raise of constraint error,\n-         --  then have a look at what check is being performed and\n-         --  ???\n+         --  If the item is a conditional raise of constraint error, then have\n+         --  a look at what check is being performed and ???\n \n          if Nkind (R_Cno) = N_Raise_Constraint_Error\n            and then Present (Condition (R_Cno))\n@@ -2207,9 +2210,8 @@ package body Checks is\n          R_Cno := R_Result (J);\n          exit when No (R_Cno);\n \n-         --  If the item is a conditional raise of constraint error,\n-         --  then have a look at what check is being performed and\n-         --  ???\n+         --  If the item is a conditional raise of constraint error, then have\n+         --  a look at what check is being performed and ???\n \n          if Nkind (R_Cno) = N_Raise_Constraint_Error\n            and then Present (Condition (R_Cno))\n@@ -2229,10 +2231,10 @@ package body Checks is\n             if Is_Entity_Name (Cond)\n               and then Entity (Cond) = Standard_True\n             then\n-               --  Since an N_Range is technically not an expression, we\n-               --  have to set one of the bounds to C_E and then just flag\n-               --  the N_Range. The warning message will point to the\n-               --  lower bound and complain about a range, which seems OK.\n+               --  Since an N_Range is technically not an expression, we have\n+               --  to set one of the bounds to C_E and then just flag the\n+               --  N_Range. The warning message will point to the lower bound\n+               --  and complain about a range, which seems OK.\n \n                if Nkind (Ck_Node) = N_Range then\n                   Apply_Compile_Time_Constraint_Error\n@@ -2294,10 +2296,10 @@ package body Checks is\n       Sub := First (Expressions (Expr));\n       while Present (Sub) loop\n \n-         --  Check one subscript. Note that we do not worry about\n-         --  enumeration type with holes, since we will convert the\n-         --  value to a Pos value for the subscript, and that convert\n-         --  will do the necessary validity check.\n+         --  Check one subscript. Note that we do not worry about enumeration\n+         --  type with holes, since we will convert the value to a Pos value\n+         --  for the subscript, and that convert will do the necessary validity\n+         --  check.\n \n          Ensure_Valid (Sub, Holes_OK => True);\n \n@@ -2327,18 +2329,18 @@ package body Checks is\n       elsif Serious_Errors_Detected > 0 then\n          return;\n \n-      --  Scalar type conversions of the form Target_Type (Expr) require\n-      --  a range check if we cannot be sure that Expr is in the base type\n-      --  of Target_Typ and also that Expr is in the range of Target_Typ.\n-      --  These are not quite the same condition from an implementation\n-      --  point of view, but clearly the second includes the first.\n+      --  Scalar type conversions of the form Target_Type (Expr) require a\n+      --  range check if we cannot be sure that Expr is in the base type of\n+      --  Target_Typ and also that Expr is in the range of Target_Typ. These\n+      --  are not quite the same condition from an implementation point of\n+      --  view, but clearly the second includes the first.\n \n       elsif Is_Scalar_Type (Target_Type) then\n          declare\n             Conv_OK  : constant Boolean := Conversion_OK (N);\n-            --  If the Conversion_OK flag on the type conversion is set\n-            --  and no floating point type is involved in the type conversion\n-            --  then fixed point values must be read as integral values.\n+            --  If the Conversion_OK flag on the type conversion is set and no\n+            --  floating point type is involved in the type conversion then\n+            --  fixed point values must be read as integral values.\n \n             Float_To_Int : constant Boolean :=\n                              Is_Floating_Point_Type (Expr_Type)\n@@ -2391,7 +2393,6 @@ package body Checks is\n \n          begin\n             Constraint := First_Elmt (Stored_Constraint (Target_Type));\n-\n             while Present (Constraint) loop\n                Discr_Value := Node (Constraint);\n \n@@ -2404,10 +2405,10 @@ package body Checks is\n                     and then Scope (Discr) = Base_Type (Expr_Type)\n                   then\n                      --  Parent is constrained by new discriminant. Obtain\n-                     --  Value of original discriminant in expression. If\n-                     --  the new discriminant has been used to constrain more\n-                     --  than one of the stored discriminants, this will\n-                     --  provide the required consistency check.\n+                     --  Value of original discriminant in expression. If the\n+                     --  new discriminant has been used to constrain more than\n+                     --  one of the stored discriminants, this will provide the\n+                     --  required consistency check.\n \n                      Append_Elmt (\n                         Make_Selected_Component (Loc,\n@@ -2424,8 +2425,8 @@ package body Checks is\n                      return;\n                   end if;\n \n-               --  Derived type definition has an explicit value for\n-               --  this stored discriminant.\n+               --  Derived type definition has an explicit value for this\n+               --  stored discriminant.\n \n                else\n                   Append_Elmt\n@@ -2450,10 +2451,10 @@ package body Checks is\n                 Reason    => CE_Discriminant_Check_Failed));\n          end;\n \n-      --  For arrays, conversions are applied during expansion, to take\n-      --  into accounts changes of representation.  The checks become range\n-      --  checks on the base type or length checks on the subtype, depending\n-      --  on whether the target type is unconstrained or constrained.\n+      --  For arrays, conversions are applied during expansion, to take into\n+      --  accounts changes of representation. The checks become range checks on\n+      --  the base type or length checks on the subtype, depending on whether\n+      --  the target type is unconstrained or constrained.\n \n       else\n          null;\n@@ -2499,11 +2500,11 @@ package body Checks is\n       then\n          Set_Etype (N, Base_Type (Typ));\n \n-      --  Otherwise, replace the attribute node with a type conversion\n-      --  node whose expression is the attribute, retyped to universal\n-      --  integer, and whose subtype mark is the target type. The call\n-      --  to analyze this conversion will set range and overflow checks\n-      --  as required for proper detection of an out of range value.\n+      --  Otherwise, replace the attribute node with a type conversion node\n+      --  whose expression is the attribute, retyped to universal integer, and\n+      --  whose subtype mark is the target type. The call to analyze this\n+      --  conversion will set range and overflow checks as required for proper\n+      --  detection of an out of range value.\n \n       else\n          Set_Etype    (N, Universal_Integer);\n@@ -2545,10 +2546,10 @@ package body Checks is\n          Assoc : Node_Id;\n \n       begin\n-         --  The aggregate has been normalized with named associations. We\n-         --  use the Chars field to locate the discriminant to take into\n-         --  account discriminants in derived types, which carry the same\n-         --  name as those in the parent.\n+         --  The aggregate has been normalized with named associations. We use\n+         --  the Chars field to locate the discriminant to take into account\n+         --  discriminants in derived types, which carry the same name as those\n+         --  in the parent.\n \n          Assoc := First (Component_Associations (N));\n          while Present (Assoc) loop\n@@ -2755,10 +2756,10 @@ package body Checks is\n       if Range_Checks_Suppressed (Etype (Expr)) then\n          return;\n \n-      --  Only do this check for expressions that come from source. We\n-      --  assume that expander generated assignments explicitly include\n-      --  any necessary checks. Note that this is not just an optimization,\n-      --  it avoids infinite recursions!\n+      --  Only do this check for expressions that come from source. We assume\n+      --  that expander generated assignments explicitly include any necessary\n+      --  checks. Note that this is not just an optimization, it avoids\n+      --  infinite recursions!\n \n       elsif not Comes_From_Source (Expr) then\n          return;\n@@ -2774,8 +2775,8 @@ package body Checks is\n       elsif Nkind (Expr) = N_Indexed_Component then\n          Apply_Subscript_Validity_Checks (Expr);\n \n-         --  Prefix may itself be or contain an indexed component, and\n-         --  these subscripts need checking as well\n+         --  Prefix may itself be or contain an indexed component, and these\n+         --  subscripts need checking as well.\n \n          Check_Valid_Lvalue_Subscripts (Prefix (Expr));\n       end if;\n@@ -2840,7 +2841,7 @@ package body Checks is\n               (\"null-exclusion must be applied to an access type\",\n                Error_Node);\n \n-         --  Enforce legality rule 3.10 (14/1): A null exclusion can only\n+         --  Enforce legality rule RM 3.10(14/1): A null exclusion can only\n          --  be applied to a [sub]type that does not exclude null already.\n \n          elsif Can_Never_Be_Null (Typ)\n@@ -2860,10 +2861,11 @@ package body Checks is\n \n       if K = N_Object_Declaration\n         and then No (Expression (N))\n+        and then not No_Initialization (N)\n       then\n-         --  Add a an expression that assignates null. This node is needed\n-         --  by Apply_Compile_Time_Constraint_Error, that will replace this\n-         --  node by a Constraint_Error node.\n+         --  Add an expression that assigns null. This node is needed by\n+         --  Apply_Compile_Time_Constraint_Error, which will replace this with\n+         --  a Constraint_Error node.\n \n          Set_Expression (N, Make_Null (Sloc (N)));\n          Set_Etype (Expression (N), Etype (Defining_Identifier (N)));\n@@ -2922,15 +2924,15 @@ package body Checks is\n    begin\n       Saved_Checks_TOS := Saved_Checks_TOS + 1;\n \n-      --  If stack overflows, kill all checks, that way we know to\n-      --  simply reset the number of saved checks to zero on return.\n-      --  This should never occur in practice.\n+      --  If stack overflows, kill all checks, that way we know to simply reset\n+      --  the number of saved checks to zero on return. This should never occur\n+      --  in practice.\n \n       if Saved_Checks_TOS > Saved_Checks_Stack'Last then\n          Kill_All_Checks;\n \n-      --  In the normal case, we just make a new stack entry saving\n-      --  the current number of saved checks for a later restore.\n+      --  In the normal case, we just make a new stack entry saving the current\n+      --  number of saved checks for a later restore.\n \n       else\n          Saved_Checks_Stack (Saved_Checks_TOS) := Num_Saved_Checks;\n@@ -2950,15 +2952,15 @@ package body Checks is\n    begin\n       pragma Assert (Saved_Checks_TOS > 0);\n \n-      --  If the saved checks stack overflowed, then we killed all\n-      --  checks, so setting the number of saved checks back to\n-      --  zero is correct. This should never occur in practice.\n+      --  If the saved checks stack overflowed, then we killed all checks, so\n+      --  setting the number of saved checks back to zero is correct. This\n+      --  should never occur in practice.\n \n       if Saved_Checks_TOS > Saved_Checks_Stack'Last then\n          Num_Saved_Checks := 0;\n \n-      --  In the normal case, restore the number of saved checks\n-      --  from the top stack entry.\n+      --  In the normal case, restore the number of saved checks from the top\n+      --  stack entry.\n \n       else\n          Num_Saved_Checks := Saved_Checks_Stack (Saved_Checks_TOS);\n@@ -2982,13 +2984,13 @@ package body Checks is\n    Determine_Range_Cache_N  : array (Cache_Index) of Node_Id;\n    Determine_Range_Cache_Lo : array (Cache_Index) of Uint;\n    Determine_Range_Cache_Hi : array (Cache_Index) of Uint;\n-   --  The above arrays are used to implement a small direct cache\n-   --  for Determine_Range calls. Because of the way Determine_Range\n-   --  recursively traces subexpressions, and because overflow checking\n-   --  calls the routine on the way up the tree, a quadratic behavior\n-   --  can otherwise be encountered in large expressions. The cache\n-   --  entry for node N is stored in the (N mod Cache_Size) entry, and\n-   --  can be validated by checking the actual node value stored there.\n+   --  The above arrays are used to implement a small direct cache for\n+   --  Determine_Range calls. Because of the way Determine_Range recursively\n+   --  traces subexpressions, and because overflow checking calls the routine\n+   --  on the way up the tree, a quadratic behavior can otherwise be\n+   --  encountered in large expressions. The cache entry for node N is stored\n+   --  in the (N mod Cache_Size) entry, and can be validated by checking the\n+   --  actual node value stored there.\n \n    procedure Determine_Range\n      (N  : Node_Id;\n@@ -3053,8 +3055,8 @@ package body Checks is\n       Lor := No_Uint;\n       Hir := No_Uint;\n \n-      --  If the type is not discrete, or is undefined, then we can't\n-      --  do anything about determining the range.\n+      --  If the type is not discrete, or is undefined, then we can't do\n+      --  anything about determining the range.\n \n       if No (Typ) or else not Is_Discrete_Type (Typ)\n         or else Error_Posted (N)\n@@ -3067,8 +3069,8 @@ package body Checks is\n \n       OK := True;\n \n-      --  If value is compile time known, then the possible range is the\n-      --  one value that we know this expression definitely has!\n+      --  If value is compile time known, then the possible range is the one\n+      --  value that we know this expression definitely has!\n \n       if Compile_Time_Known_Value (N) then\n          Lo := Expr_Value (N);\n@@ -3086,16 +3088,16 @@ package body Checks is\n          return;\n       end if;\n \n-      --  Otherwise, start by finding the bounds of the type of the\n-      --  expression, the value cannot be outside this range (if it\n-      --  is, then we have an overflow situation, which is a separate\n-      --  check, we are talking here only about the expression value).\n+      --  Otherwise, start by finding the bounds of the type of the expression,\n+      --  the value cannot be outside this range (if it is, then we have an\n+      --  overflow situation, which is a separate check, we are talking here\n+      --  only about the expression value).\n \n-      --  We use the actual bound unless it is dynamic, in which case\n-      --  use the corresponding base type bound if possible. If we can't\n-      --  get a bound then we figure we can't determine the range (a\n-      --  peculiar case, that perhaps cannot happen, but there is no\n-      --  point in bombing in this optimization circuit.\n+      --  We use the actual bound unless it is dynamic, in which case use the\n+      --  corresponding base type bound if possible. If we can't get a bound\n+      --  then we figure we can't determine the range (a peculiar case, that\n+      --  perhaps cannot happen, but there is no point in bombing in this\n+      --  optimization circuit.\n \n       --  First the low bound\n \n@@ -3129,16 +3131,16 @@ package body Checks is\n          return;\n       end if;\n \n-      --  If we have a static subtype, then that may have a tighter bound\n-      --  so use the upper bound of the subtype instead in this case.\n+      --  If we have a static subtype, then that may have a tighter bound so\n+      --  use the upper bound of the subtype instead in this case.\n \n       if Compile_Time_Known_Value (Bound) then\n          Hi := Expr_Value (Bound);\n       end if;\n \n-      --  We may be able to refine this value in certain situations. If\n-      --  refinement is possible, then Lor and Hir are set to possibly\n-      --  tighter bounds, and OK1 is set to True.\n+      --  We may be able to refine this value in certain situations. If any\n+      --  refinement is possible, then Lor and Hir are set to possibly tighter\n+      --  bounds, and OK1 is set to True.\n \n       case Nkind (N) is\n \n@@ -3166,9 +3168,9 @@ package body Checks is\n                Hir := Hi_Left + Hi_Right;\n             end if;\n \n-         --  Division is tricky. The only case we consider is where the\n-         --  right operand is a positive constant, and in this case we\n-         --  simply divide the bounds of the left operand\n+         --  Division is tricky. The only case we consider is where the right\n+         --  operand is a positive constant, and in this case we simply divide\n+         --  the bounds of the left operand\n \n          when N_Op_Divide =>\n             if OK_Operands then\n@@ -3183,17 +3185,17 @@ package body Checks is\n                end if;\n             end if;\n \n-         --  For binary subtraction, get range of each operand and do\n-         --  the worst case subtraction to get the result range.\n+         --  For binary subtraction, get range of each operand and do the worst\n+         --  case subtraction to get the result range.\n \n          when N_Op_Subtract =>\n             if OK_Operands then\n                Lor := Lo_Left - Hi_Right;\n                Hir := Hi_Left - Lo_Right;\n             end if;\n \n-         --  For MOD, if right operand is a positive constant, then\n-         --  result must be in the allowable range of mod results.\n+         --  For MOD, if right operand is a positive constant, then result must\n+         --  be in the allowable range of mod results.\n \n          when N_Op_Mod =>\n             if OK_Operands then\n@@ -3214,8 +3216,8 @@ package body Checks is\n                end if;\n             end if;\n \n-         --  For REM, if right operand is a positive constant, then\n-         --  result must be in the allowable range of mod results.\n+         --  For REM, if right operand is a positive constant, then result must\n+         --  be in the allowable range of mod results.\n \n          when N_Op_Rem =>\n             if OK_Operands then\n@@ -3340,8 +3342,8 @@ package body Checks is\n \n             end case;\n \n-         --  For type conversion from one discrete type to another, we\n-         --  can refine the range using the converted value.\n+         --  For type conversion from one discrete type to another, we can\n+         --  refine the range using the converted value.\n \n          when N_Type_Conversion =>\n             Determine_Range (Expression (N), OK1, Lor, Hir);\n@@ -3499,10 +3501,10 @@ package body Checks is\n          pg (N);\n       end if;\n \n-      --  Nothing to do if the range of the result is known OK. We skip\n-      --  this for conversions, since the caller already did the check,\n-      --  and in any case the condition for deleting the check for a\n-      --  type conversion is different in any case.\n+      --  Nothing to do if the range of the result is known OK. We skip this\n+      --  for conversions, since the caller already did the check, and in any\n+      --  case the condition for deleting the check for a type conversion is\n+      --  different in any case.\n \n       if Nkind (N) /= N_Type_Conversion then\n          Determine_Range (N, OK, Lo, Hi);\n@@ -3536,12 +3538,12 @@ package body Checks is\n          end if;\n       end if;\n \n-      --  If not in optimizing mode, set flag and we are done. We are also\n-      --  done (and just set the flag) if the type is not a discrete type,\n-      --  since it is not worth the effort to eliminate checks for other\n-      --  than discrete types. In addition, we take this same path if we\n-      --  have stored the maximum number of checks possible already (a\n-      --  very unlikely situation, but we do not want to blow up!)\n+      --  If not in optimizing mode, set flag and we are done. We are also done\n+      --  (and just set the flag) if the type is not a discrete type, since it\n+      --  is not worth the effort to eliminate checks for other than discrete\n+      --  types. In addition, we take this same path if we have stored the\n+      --  maximum number of checks possible already (a very unlikely situation,\n+      --  but we do not want to blow up!)\n \n       if Optimization_Level = 0\n         or else not Is_Discrete_Type (Etype (N))\n@@ -3616,10 +3618,10 @@ package body Checks is\n          w (\"  Target_Type = Empty\");\n       end if;\n \n-   --  If we get an exception, then something went wrong, probably because\n-   --  of an error in the structure of the tree due to an incorrect program.\n-   --  Or it may be a bug in the optimization circuit. In either case the\n-   --  safest thing is simply to set the check flag unconditionally.\n+   --  If we get an exception, then something went wrong, probably because of\n+   --  an error in the structure of the tree due to an incorrect program. Or it\n+   --  may be a bug in the optimization circuit. In either case the safest\n+   --  thing is simply to set the check flag unconditionally.\n \n    exception\n       when others =>\n@@ -3645,9 +3647,8 @@ package body Checks is\n       P    : Node_Id;\n \n    begin\n-      --  Return if unchecked type conversion with range check killed.\n-      --  In this case we never set the flag (that's what Kill_Range_Check\n-      --  is all about!)\n+      --  Return if unchecked type conversion with range check killed. In this\n+      --  case we never set the flag (that's what Kill_Range_Check is about!)\n \n       if Nkind (N) = N_Unchecked_Type_Conversion\n         and then Kill_Range_Check (N)\n@@ -3699,12 +3700,12 @@ package body Checks is\n          pg (N);\n       end if;\n \n-      --  If not in optimizing mode, set flag and we are done. We are also\n-      --  done (and just set the flag) if the type is not a discrete type,\n-      --  since it is not worth the effort to eliminate checks for other\n-      --  than discrete types. In addition, we take this same path if we\n-      --  have stored the maximum number of checks possible already (a\n-      --  very unlikely situation, but we do not want to blow up!)\n+      --  If not in optimizing mode, set flag and we are done. We are also done\n+      --  (and just set the flag) if the type is not a discrete type, since it\n+      --  is not worth the effort to eliminate checks for other than discrete\n+      --  types. In addition, we take this same path if we have stored the\n+      --  maximum number of checks possible already (a very unlikely situation,\n+      --  but we do not want to blow up!)\n \n       if Optimization_Level = 0\n         or else No (Etype (N))\n@@ -3746,17 +3747,17 @@ package body Checks is\n                Atyp := Designated_Type (Atyp);\n \n                --  If the prefix is an access to an unconstrained array,\n-               --  perform check unconditionally: it depends on the bounds\n-               --  of an object and we cannot currently recognize whether\n-               --  the test may be redundant.\n+               --  perform check unconditionally: it depends on the bounds of\n+               --  an object and we cannot currently recognize whether the test\n+               --  may be redundant.\n \n                if not Is_Constrained (Atyp) then\n                   Set_Do_Range_Check (N, True);\n                   return;\n                end if;\n \n-            --  Ditto if the prefix is an explicit dereference whose\n-            --  designated type is unconstrained.\n+            --  Ditto if the prefix is an explicit dereference whose designated\n+            --  type is unconstrained.\n \n             elsif Nkind (Prefix (P)) = N_Explicit_Dereference\n               and then not Is_Constrained (Atyp)\n@@ -3855,10 +3856,10 @@ package body Checks is\n          pg (Ttyp);\n       end if;\n \n-   --  If we get an exception, then something went wrong, probably because\n-   --  of an error in the structure of the tree due to an incorrect program.\n-   --  Or it may be a bug in the optimization circuit. In either case the\n-   --  safest thing is simply to set the check flag unconditionally.\n+   --  If we get an exception, then something went wrong, probably because of\n+   --  an error in the structure of the tree due to an incorrect program. Or\n+   --  it may be a bug in the optimization circuit. In either case the safest\n+   --  thing is simply to set the check flag unconditionally.\n \n    exception\n       when others =>\n@@ -3889,9 +3890,9 @@ package body Checks is\n       elsif Range_Or_Validity_Checks_Suppressed (Expr) then\n          return;\n \n-      --  No check required if expression is from the expander, we assume\n-      --  the expander will generate whatever checks are needed. Note that\n-      --  this is not just an optimization, it avoids infinite recursions!\n+      --  No check required if expression is from the expander, we assume the\n+      --  expander will generate whatever checks are needed. Note that this is\n+      --  not just an optimization, it avoids infinite recursions!\n \n       --  Unchecked conversions must be checked, unless they are initialized\n       --  scalar values, as in a component assignment in an init proc.\n@@ -3910,8 +3911,8 @@ package body Checks is\n       elsif Expr_Known_Valid (Expr) then\n          return;\n \n-      --  Ignore case of enumeration with holes where the flag is set not\n-      --  to worry about holes, since no special validity check is needed\n+      --  Ignore case of enumeration with holes where the flag is set not to\n+      --  worry about holes, since no special validity check is needed\n \n       elsif Is_Enumeration_Type (Typ)\n         and then Has_Non_Standard_Rep (Typ)\n@@ -3979,10 +3980,10 @@ package body Checks is\n                   P := Parent (N);\n                end if;\n \n-               --  Only need to worry if we are argument of a procedure\n-               --  call since functions don't have out parameters. If this\n-               --  is an indirect or dispatching call, get signature from\n-               --  the subprogram type.\n+               --  Only need to worry if we are argument of a procedure call\n+               --  since functions don't have out parameters. If this is an\n+               --  indirect or dispatching call, get signature from the\n+               --  subprogram type.\n \n                if Nkind (P) = N_Procedure_Call_Statement then\n                   L := Parameter_Associations (P);\n@@ -3994,18 +3995,17 @@ package body Checks is\n                      E := Etype (Name (P));\n                   end if;\n \n-                  --  Only need to worry if there are indeed actuals, and\n-                  --  if this could be a procedure call, otherwise we cannot\n-                  --  get a match (either we are not an argument, or the\n-                  --  mode of the formal is not OUT). This test also filters\n-                  --  out the generic case.\n+                  --  Only need to worry if there are indeed actuals, and if\n+                  --  this could be a procedure call, otherwise we cannot get a\n+                  --  match (either we are not an argument, or the mode of the\n+                  --  formal is not OUT). This test also filters out the\n+                  --  generic case.\n \n                   if Is_Non_Empty_List (L)\n                     and then Is_Subprogram (E)\n                   then\n-                     --  This is the loop through parameters, looking to\n-                     --  see if there is an OUT parameter for which we are\n-                     --  the argument.\n+                     --  This is the loop through parameters, looking for an\n+                     --  OUT parameter for which we are the argument.\n \n                      F := First_Formal (E);\n                      A := First (L);\n@@ -4036,14 +4036,13 @@ package body Checks is\n       Typ : constant Entity_Id := Etype (Expr);\n \n    begin\n-      --  Non-scalar types are always considered valid, since they never\n-      --  give rise to the issues of erroneous or bounded error behavior\n-      --  that are the concern. In formal reference manual terms the\n-      --  notion of validity only applies to scalar types. Note that\n-      --  even when packed arrays are represented using modular types,\n-      --  they are still arrays semantically, so they are also always\n-      --  valid (in particular, the unused bits can be random rubbish\n-      --  without affecting the validity of the array value).\n+      --  Non-scalar types are always considered valid, since they never give\n+      --  rise to the issues of erroneous or bounded error behavior that are\n+      --  the concern. In formal reference manual terms the notion of validity\n+      --  only applies to scalar types. Note that even when packed arrays are\n+      --  represented using modular types, they are still arrays semantically,\n+      --  so they are also always valid (in particular, the unused bits can be\n+      --  random rubbish without affecting the validity of the array value).\n \n       if not Is_Scalar_Type (Typ) or else Is_Packed_Array_Type (Typ) then\n          return True;\n@@ -4061,8 +4060,8 @@ package body Checks is\n       then\n          return True;\n \n-      --  If the expression is the value of an object that is known to\n-      --  be valid, then clearly the expression value itself is valid.\n+      --  If the expression is the value of an object that is known to be\n+      --  valid, then clearly the expression value itself is valid.\n \n       elsif Is_Entity_Name (Expr)\n         and then Is_Known_Valid (Entity (Expr))\n@@ -4073,17 +4072,18 @@ package body Checks is\n       --  of a discriminant gets checked when the object is built. Within the\n       --  record, we consider it valid, and it is important to do so, since\n       --  otherwise we can try to generate bogus validity checks which\n-      --  reference discriminants out of scope.\n+      --  reference discriminants out of scope. Discriminants of concurrent\n+      --  types are excluded for the same reason.\n \n       elsif Is_Entity_Name (Expr)\n-        and then Ekind (Entity (Expr)) = E_Discriminant\n+        and then Denotes_Discriminant (Expr, Check_Concurrent => True)\n       then\n          return True;\n \n-      --  If the type is one for which all values are known valid, then\n-      --  we are sure that the value is valid except in the slightly odd\n-      --  case where the expression is a reference to a variable whose size\n-      --  has been explicitly set to a value greater than the object size.\n+      --  If the type is one for which all values are known valid, then we are\n+      --  sure that the value is valid except in the slightly odd case where\n+      --  the expression is a reference to a variable whose size has been\n+      --  explicitly set to a value greater than the object size.\n \n       elsif Is_Known_Valid (Typ) then\n          if Is_Entity_Name (Expr)\n@@ -4131,8 +4131,8 @@ package body Checks is\n             return True;\n          end if;\n \n-      --  The result of a membership test is always valid, since it is true\n-      --  or false, there are no other possibilities.\n+      --  The result of a membership test is always valid, since it is true or\n+      --  false, there are no other possibilities.\n \n       elsif Nkind (Expr) in N_Membership_Test then\n          return True;\n@@ -4247,8 +4247,8 @@ package body Checks is\n          return;\n       end if;\n \n-      --  Come here with expression of appropriate form, check if\n-      --  entity is an appropriate one for our purposes.\n+      --  Come here with expression of appropriate form, check if entity is an\n+      --  appropriate one for our purposes.\n \n       if (Ekind (Ent) = E_Variable\n             or else\n@@ -4295,7 +4295,7 @@ package body Checks is\n    ---------------------------------\n \n    --  Note: the code for this procedure is derived from the\n-   --  emit_discriminant_check routine a-trans.c v1.659.\n+   --  Emit_Discriminant_Check Routine in trans.c.\n \n    procedure Generate_Discriminant_Check (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n@@ -4323,9 +4323,9 @@ package body Checks is\n       --  List of arguments for function call\n \n       Formal : Entity_Id;\n-      --  Keep track of the formal corresponding to the actual we build\n-      --  for each discriminant, in order to be able to perform the\n-      --  necessary type conversions.\n+      --  Keep track of the formal corresponding to the actual we build for\n+      --  each discriminant, in order to be able to perform the necessary type\n+      --  conversions.\n \n       Scomp : Node_Id;\n       --  Selected component reference for checking function argument\n@@ -4363,10 +4363,10 @@ package body Checks is\n       if Is_Tagged_Type (Scope (Orig_Comp)) then\n          Pref_Type := Scope (Orig_Comp);\n \n-      --  For an untagged derived type, use the discriminants of the\n-      --  parent which have been renamed in the derivation, possibly\n-      --  by a one-to-many discriminant constraint.\n-      --  For non-tagged type, initially get the Etype of the prefix\n+      --  For an untagged derived type, use the discriminants of the parent\n+      --  which have been renamed in the derivation, possibly by a one-to-many\n+      --  discriminant constraint. For non-tagged type, initially get the Etype\n+      --  of the prefix\n \n       else\n          if Is_Derived_Type (Pref_Type)\n@@ -4415,8 +4415,8 @@ package body Checks is\n \n          --  Manually analyze and resolve this selected component. We really\n          --  want it just as it appears above, and do not want the expander\n-         --  playing discriminal games etc with this reference. Then we\n-         --  append the argument to the list we are gathering.\n+         --  playing discriminal games etc with this reference. Then we append\n+         --  the argument to the list we are gathering.\n \n          Set_Etype (Scomp, Etype (Real_Discr));\n          Set_Analyzed (Scomp, True);\n@@ -4465,8 +4465,8 @@ package body Checks is\n          if Do_Range_Check (Sub) then\n             Set_Do_Range_Check (Sub, False);\n \n-            --  Force evaluation except for the case of a simple name of\n-            --  a non-volatile entity.\n+            --  Force evaluation except for the case of a simple name of a\n+            --  non-volatile entity.\n \n             if not Is_Entity_Name (Sub)\n               or else Treat_As_Volatile (Entity (Sub))\n@@ -4479,12 +4479,12 @@ package body Checks is\n \n             --    Base_Type(Sub) not in array'range (subscript)\n \n-            --  Note that the reason we generate the conversion to the\n-            --  base type here is that we definitely want the range check\n-            --  to take place, even if it looks like the subtype is OK.\n-            --  Optimization considerations that allow us to omit the\n-            --  check have already been taken into account in the setting\n-            --  of the Do_Range_Check flag earlier on.\n+            --  Note that the reason we generate the conversion to the base\n+            --  type here is that we definitely want the range check to take\n+            --  place, even if it looks like the subtype is OK. Optimization\n+            --  considerations that allow us to omit the check have already\n+            --  been taken into account in the setting of the Do_Range_Check\n+            --  flag earlier on.\n \n             if Ind = 1 then\n                Num := No_List;\n@@ -4527,14 +4527,14 @@ package body Checks is\n       Target_Base_Type : constant Entity_Id  := Base_Type (Target_Type);\n \n    begin\n-      --  First special case, if the source type is already within the\n-      --  range of the target type, then no check is needed (probably we\n-      --  should have stopped Do_Range_Check from being set in the first\n-      --  place, but better late than later in preventing junk code!\n+      --  First special case, if the source type is already within the range\n+      --  of the target type, then no check is needed (probably we should have\n+      --  stopped Do_Range_Check from being set in the first place, but better\n+      --  late than later in preventing junk code!\n \n-      --  We do NOT apply this if the source node is a literal, since in\n-      --  this case the literal has already been labeled as having the\n-      --  subtype of the target.\n+      --  We do NOT apply this if the source node is a literal, since in this\n+      --  case the literal has already been labeled as having the subtype of\n+      --  the target.\n \n       if In_Subrange_Of (Source_Type, Target_Type)\n         and then not\n@@ -4561,9 +4561,9 @@ package body Checks is\n          Force_Evaluation (N);\n       end if;\n \n-      --  The easiest case is when Source_Base_Type and Target_Base_Type\n-      --  are the same since in this case we can simply do a direct\n-      --  check of the value of N against the bounds of Target_Type.\n+      --  The easiest case is when Source_Base_Type and Target_Base_Type are\n+      --  the same since in this case we can simply do a direct check of the\n+      --  value of N against the bounds of Target_Type.\n \n       --    [constraint_error when N not in Target_Type]\n \n@@ -4615,20 +4615,19 @@ package body Checks is\n                            Attribute_Name => Name_Last)))),\n              Reason => Reason));\n \n-      --  Note that at this stage we now that the Target_Base_Type is\n-      --  not in the range of the Source_Base_Type (since even the\n-      --  Target_Type itself is not in this range). It could still be\n-      --  the case that the Source_Type is in range of the target base\n-      --  type, since we have not checked that case.\n+      --  Note that at this stage we now that the Target_Base_Type is not in\n+      --  the range of the Source_Base_Type (since even the Target_Type itself\n+      --  is not in this range). It could still be the case that Source_Type is\n+      --  in range of the target base type since we have not checked that case.\n \n-      --  If that is the case, we can freely convert the source to the\n-      --  target, and then test the target result against the bounds.\n+      --  If that is the case, we can freely convert the source to the target,\n+      --  and then test the target result against the bounds.\n \n       elsif In_Subrange_Of (Source_Type, Target_Base_Type) then\n \n-         --  We make a temporary to hold the value of the converted\n-         --  value (converted to the base type), and then we will\n-         --  do the test against this temporary.\n+         --  We make a temporary to hold the value of the converted value\n+         --  (converted to the base type), and then we will do the test against\n+         --  this temporary.\n \n          --     Tnn : constant Target_Base_Type := Target_Base_Type (N);\n          --     [constraint_error when Tnn not in Target_Type]\n@@ -4680,8 +4679,8 @@ package body Checks is\n             --  know that the source is not shorter than the target (otherwise\n             --  the source base type would be in the target base type range).\n \n-            --  In other words, the unsigned type is either the same size\n-            --  as the target, or it is larger. It cannot be smaller.\n+            --  In other words, the unsigned type is either the same size as\n+            --  the target, or it is larger. It cannot be smaller.\n \n             pragma Assert\n               (Esize (Source_Base_Type) >= Esize (Target_Base_Type));\n@@ -4761,27 +4760,26 @@ package body Checks is\n             pragma Assert (not Is_Unsigned_Type (Source_Base_Type)\n                              and then Is_Unsigned_Type (Target_Base_Type));\n \n-            --  If the source is signed and the target is unsigned, then\n-            --  we know that the target is not shorter than the source\n-            --  (otherwise the target base type would be in the source\n-            --  base type range).\n+            --  If the source is signed and the target is unsigned, then we\n+            --  know that the target is not shorter than the source (otherwise\n+            --  the target base type would be in the source base type range).\n \n-            --  In other words, the unsigned type is either the same size\n-            --  as the target, or it is larger. It cannot be smaller.\n+            --  In other words, the unsigned type is either the same size as\n+            --  the target, or it is larger. It cannot be smaller.\n \n-            --  Clearly we have an error if the source value is negative\n-            --  since no unsigned type can have negative values. If the\n-            --  source type is non-negative, then the check can be done\n-            --  using the target type.\n+            --  Clearly we have an error if the source value is negative since\n+            --  no unsigned type can have negative values. If the source type\n+            --  is non-negative, then the check can be done using the target\n+            --  type.\n \n             --    Tnn : constant Target_Base_Type (N) := Target_Type;\n \n             --    [constraint_error\n             --       when N < 0 or else Tnn not in Target_Type];\n \n-            --  We turn off all checks for the conversion of N to the\n-            --  target base type, since we generate the explicit check\n-            --  to ensure that the value is non-negative\n+            --  We turn off all checks for the conversion of N to the target\n+            --  base type, since we generate the explicit check to ensure that\n+            --  the value is non-negative\n \n             declare\n                Tnn : constant Entity_Id :=\n@@ -4818,9 +4816,9 @@ package body Checks is\n                    Reason => Reason)),\n                  Suppress => All_Checks);\n \n-               --  Set the Etype explicitly, because Insert_Actions may\n-               --  have placed the declaration in the freeze list for an\n-               --  enclosing construct, and thus it is not analyzed yet.\n+               --  Set the Etype explicitly, because Insert_Actions may have\n+               --  placed the declaration in the freeze list for an enclosing\n+               --  construct, and thus it is not analyzed yet.\n \n                Set_Etype (Tnn, Target_Base_Type);\n                Rewrite (N, New_Occurrence_Of (Tnn, Loc));\n@@ -4944,9 +4942,9 @@ package body Checks is\n                      (not Range_Checks_Suppressed (Suppress_Typ));\n \n    begin\n-      --  For now we just return if Checks_On is false, however this should\n-      --  be enhanced to check for an always True value in the condition\n-      --  and to generate a compilation warning???\n+      --  For now we just return if Checks_On is false, however this should be\n+      --  enhanced to check for an always True value in the condition and to\n+      --  generate a compilation warning???\n \n       if not Expander_Active or else not Checks_On then\n          return;\n@@ -5193,9 +5191,9 @@ package body Checks is\n          w (\"Kill_All_Checks\");\n       end if;\n \n-      --  We reset the number of saved checks to zero, and also modify\n-      --  all stack entries for statement ranges to indicate that the\n-      --  number of checks at each level is now zero.\n+      --  We reset the number of saved checks to zero, and also modify all\n+      --  stack entries for statement ranges to indicate that the number of\n+      --  checks at each level is now zero.\n \n       Num_Saved_Checks := 0;\n \n@@ -5621,7 +5619,6 @@ package body Checks is\n             end if;\n \n             return N;\n-\n          end if;\n       end Get_E_Length;\n \n@@ -5638,7 +5635,6 @@ package body Checks is\n                Duplicate_Subexpr_No_Checks (N, Name_Req => True),\n              Expressions => New_List (\n                Make_Integer_Literal (Loc, Indx)));\n-\n       end Get_N_Length;\n \n       -------------------\n@@ -5655,7 +5651,6 @@ package body Checks is\n            Make_Op_Ne (Loc,\n              Left_Opnd  => Get_E_Length (Typ, Indx),\n              Right_Opnd => Get_E_Length (Exptyp, Indx));\n-\n       end Length_E_Cond;\n \n       -------------------\n@@ -5672,9 +5667,12 @@ package body Checks is\n            Make_Op_Ne (Loc,\n              Left_Opnd  => Get_E_Length (Typ, Indx),\n              Right_Opnd => Get_N_Length (Expr, Indx));\n-\n       end Length_N_Cond;\n \n+      -----------------\n+      -- Same_Bounds --\n+      -----------------\n+\n       function Same_Bounds (L : Node_Id; R : Node_Id) return Boolean is\n       begin\n          return\n@@ -5807,12 +5805,11 @@ package body Checks is\n                   Ref_Node : Node_Id;\n \n                begin\n-\n-                  --  At the library level, we need to ensure that the\n-                  --  type of the object is elaborated before the check\n-                  --  itself is emitted. This is only done if the object\n-                  --  is in the current compilation unit, otherwise the\n-                  --  type is frozen and elaborated in its unit.\n+                  --  At the library level, we need to ensure that the type of\n+                  --  the object is elaborated before the check itself is\n+                  --  emitted. This is only done if the object is in the\n+                  --  current compilation unit, otherwise the type is frozen\n+                  --  and elaborated in its unit.\n \n                   if Is_Itype (Exptyp)\n                     and then\n@@ -5904,8 +5901,8 @@ package body Checks is\n             --  do not evaluate it more than once.\n \n             --  Here Ck_Node is the original expression, or more properly the\n-            --  result of applying Duplicate_Expr to the original tree,\n-            --  forcing the result to be a name.\n+            --  result of applying Duplicate_Expr to the original tree, forcing\n+            --  the result to be a name.\n \n             else\n                declare\n@@ -6080,12 +6077,14 @@ package body Checks is\n \n       begin\n          if Nkind (LB) = N_Identifier\n-           and then Ekind (Entity (LB)) = E_Discriminant then\n+           and then Ekind (Entity (LB)) = E_Discriminant\n+         then\n             LB := New_Occurrence_Of (Discriminal (Entity (LB)), Loc);\n          end if;\n \n          if Nkind (HB) = N_Identifier\n-           and then Ekind (Entity (HB)) = E_Discriminant then\n+           and then Ekind (Entity (HB)) = E_Discriminant\n+         then\n             HB := New_Occurrence_Of (Discriminal (Entity (HB)), Loc);\n          end if;\n \n@@ -6239,12 +6238,11 @@ package body Checks is\n          elsif Nkind (Bound) = N_Integer_Literal then\n             return Make_Integer_Literal (Loc, Intval (Bound));\n \n-         --  Case of a bound that has been rewritten to an\n-         --  N_Raise_Constraint_Error node because it is an out-of-range\n-         --  value. We may not call Duplicate_Subexpr on this node because\n-         --  an N_Raise_Constraint_Error is not side effect free, and we may\n-         --  not assume that we are in the proper context to remove side\n-         --  effects on it at the point of reference.\n+         --  Case of a bound rewritten to an N_Raise_Constraint_Error node\n+         --  because it is an out-of-range value. Duplicate_Subexpr cannot be\n+         --  called on this node because an N_Raise_Constraint_Error is not\n+         --  side effect free, and we may not assume that we are in the proper\n+         --  context to remove side effects on it at the point of reference.\n \n          elsif Nkind (Bound) = N_Raise_Constraint_Error then\n             return New_Copy_Tree (Bound);\n@@ -6305,7 +6303,6 @@ package body Checks is\n                Make_Op_Gt (Loc,\n                  Left_Opnd => Get_E_First_Or_Last (Exptyp, Indx, Name_Last),\n                  Right_Opnd  => Get_E_First_Or_Last (Typ, Indx, Name_Last)));\n-\n       end Range_E_Cond;\n \n       ------------------------\n@@ -6505,18 +6502,17 @@ package body Checks is\n                   HB : Node_Id := High_Bound (Ck_Node);\n \n                begin\n-\n-                  --  If either bound is a discriminant and we are within\n-                  --  the record declaration, it is a use of the discriminant\n-                  --  in a constraint of a component, and nothing can be\n-                  --  checked here. The check will be emitted within the\n-                  --  init proc. Before then, the discriminal has no real\n-                  --  meaning. Similarly, if the entity is a discriminal,\n-                  --  there is no check to perform yet.\n-\n-                  --  The same holds within a discriminated synchronized\n-                  --  type, where the discriminant may constrain a component\n-                  --  or an entry family.\n+                  --  If either bound is a discriminant and we are within the\n+                  --  record declaration, it is a use of the discriminant in a\n+                  --  constraint of a component, and nothing can be checked\n+                  --  here. The check will be emitted within the init proc.\n+                  --  Before then, the discriminal has no real meaning.\n+                  --  Similarly, if the entity is a discriminal, there is no\n+                  --  check to perform yet.\n+\n+                  --  The same holds within a discriminated synchronized type,\n+                  --  where the discriminant may constrain a component or an\n+                  --  entry family.\n \n                   if Nkind (LB) = N_Identifier\n                     and then Denotes_Discriminant (LB, True)\n@@ -6557,7 +6553,6 @@ package body Checks is\n                           Right_Opnd => Duplicate_Subexpr_No_Checks (LB)),\n                       Right_Opnd => Cond);\n                end;\n-\n             end if;\n          end;\n \n@@ -6748,21 +6743,23 @@ package body Checks is\n             end if;\n \n          else\n-            --  Generate an Action to check that the bounds of the\n-            --  source value are within the constraints imposed by the\n-            --  target type for a conversion to an unconstrained type.\n-            --  Rule is 4.6(38).\n-\n-            if Nkind (Parent (Ck_Node)) = N_Type_Conversion then\n+            --  For a conversion to an unconstrained array type, generate an\n+            --  Action to check that the bounds of the source value are within\n+            --  the constraints imposed by the target type (RM 4.6(38)). No\n+            --  check is needed for a conversion to an access to unconstrained\n+            --  array type, as 4.6(24.15/2) requires the designated subtypes\n+            --  of the two access types to statically match.\n+\n+            if Nkind (Parent (Ck_Node)) = N_Type_Conversion\n+              and then not Do_Access\n+            then\n                declare\n                   Opnd_Index : Node_Id;\n                   Targ_Index : Node_Id;\n \n                begin\n-                  Opnd_Index\n-                    := First_Index (Get_Actual_Subtype (Ck_Node));\n+                  Opnd_Index := First_Index (Get_Actual_Subtype (Ck_Node));\n                   Targ_Index := First_Index (T_Typ);\n-\n                   while Opnd_Index /= Empty loop\n                      if Nkind (Opnd_Index) = N_Range then\n                         if Is_In_Range\n@@ -6773,7 +6770,7 @@ package body Checks is\n                         then\n                            null;\n \n-                           --  If null range, no check needed\n+                        --  If null range, no check needed\n \n                         elsif\n                           Compile_Time_Known_Value (High_Bound (Opnd_Index))"}, {"sha": "84012a16a60ba83bb10d938f9c52751286ca799d", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675d607041a286e80da64c0de803ee2ff9669e64/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675d607041a286e80da64c0de803ee2ff9669e64/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=675d607041a286e80da64c0de803ee2ff9669e64", "patch": "@@ -264,6 +264,12 @@ package Checks is\n    --                this node is further examined depends on the setting of\n    --                the parameter Source_Typ, as described below.\n \n+   --    ??? Apply_Length_Check and Apply_Range_Check do not have an Expr\n+   --        formal\n+\n+   --    ??? Apply_Length_Check and Apply_Range_Check have a Ck_Node formal\n+   --        which is undocumented, is it the same as Expr?\n+\n    --    Target_Typ  The target type on which the check is to be based. For\n    --                example, if we have a scalar range check, then the check\n    --                is that we are in range of this type.\n@@ -311,7 +317,7 @@ package Checks is\n      (Ck_Node    : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id := Empty);\n-   --  For an Node of kind N_Range, constructs a range check action that tests\n+   --  For a Node of kind N_Range, constructs a range check action that tests\n    --  first that the range is not null and then that the range is contained in\n    --  the Target_Typ range.\n    --"}]}