{"sha": "f40333afeb570012ed42439cb9ce3c7aaa63b916", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQwMzMzYWZlYjU3MDAxMmVkNDI0MzljYjljZTNjN2FhYTYzYjkxNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-09-24T11:04:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-09-24T11:04:04Z"}, "message": "re PR tree-optimization/58513 (*var and MEM[(const int &)var]  (var has int* type) are not treated as the same data ref.)\n\n2013-09-24  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/58513\n\t* tree.c (reference_alias_ptr_type): Move ...\n\t* alias.c (reference_alias_ptr_type): ... here and implement\n\tin terms of the new reference_alias_ptr_type_1.\n\t(ref_all_alias_ptr_type_p): New helper.\n\t(get_deref_alias_set_1): Drop flag_strict_aliasing here,\n\tuse ref_all_alias_ptr_type_p.\n\t(get_deref_alias_set): Add flag_strict_aliasing check here.\n\t(reference_alias_ptr_type_1): New function, split out from ...\n\t(get_alias_set): ... here.\n\t(alias_ptr_types_compatible_p): New function.\n\t* alias.h (reference_alias_ptr_type): Declare.\n\t(alias_ptr_types_compatible_p): Likewise.\n\t* tree.h (reference_alias_ptr_type): Remove.\n\t* fold-const.c (operand_equal_p): Use alias_ptr_types_compatible_p\n\tto compare MEM_REF alias types.\n\n\t* g++.dg/vect/pr58513.cc: New testcase.\n\nFrom-SVN: r202865", "tree": {"sha": "648deb8197d0c5862100744de7dc74e36afb91ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/648deb8197d0c5862100744de7dc74e36afb91ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f40333afeb570012ed42439cb9ce3c7aaa63b916", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40333afeb570012ed42439cb9ce3c7aaa63b916", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40333afeb570012ed42439cb9ce3c7aaa63b916", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40333afeb570012ed42439cb9ce3c7aaa63b916/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "583e8bf5d0b400730b2dec40a6989523fc420946", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/583e8bf5d0b400730b2dec40a6989523fc420946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/583e8bf5d0b400730b2dec40a6989523fc420946"}], "stats": {"total": 235, "additions": 160, "deletions": 75}, "files": [{"sha": "72bca64b0313d82788eaef52aff295987fa6e707", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f40333afeb570012ed42439cb9ce3c7aaa63b916", "patch": "@@ -1,3 +1,22 @@\n+2013-09-24  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/58513\n+\t* tree.c (reference_alias_ptr_type): Move ...\n+\t* alias.c (reference_alias_ptr_type): ... here and implement\n+\tin terms of the new reference_alias_ptr_type_1.\n+\t(ref_all_alias_ptr_type_p): New helper.\n+\t(get_deref_alias_set_1): Drop flag_strict_aliasing here,\n+\tuse ref_all_alias_ptr_type_p.\n+\t(get_deref_alias_set): Add flag_strict_aliasing check here.\n+\t(reference_alias_ptr_type_1): New function, split out from ...\n+\t(get_alias_set): ... here.\n+\t(alias_ptr_types_compatible_p): New function.\n+\t* alias.h (reference_alias_ptr_type): Declare.\n+\t(alias_ptr_types_compatible_p): Likewise.\n+\t* tree.h (reference_alias_ptr_type): Remove.\n+\t* fold-const.c (operand_equal_p): Use alias_ptr_types_compatible_p\n+\tto compare MEM_REF alias types.\n+\n 2013-09-24  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vrp.c (vrp_finalize): Check for SSA name presence."}, {"sha": "7d28267657bdb818e5cbb64db9cabc26db0722b3", "filename": "gcc/alias.c", "status": "modified", "additions": 118, "deletions": 54, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f40333afeb570012ed42439cb9ce3c7aaa63b916", "patch": "@@ -547,27 +547,33 @@ component_uses_parent_alias_set (const_tree t)\n     }\n }\n \n+\n+/* Return whether the pointer-type T effective for aliasing may\n+   access everything and thus the reference has to be assigned\n+   alias-set zero.  */\n+\n+static bool\n+ref_all_alias_ptr_type_p (const_tree t)\n+{\n+  return (TREE_CODE (TREE_TYPE (t)) == VOID_TYPE\n+\t  || TYPE_REF_CAN_ALIAS_ALL (t));\n+}\n+\n /* Return the alias set for the memory pointed to by T, which may be\n    either a type or an expression.  Return -1 if there is nothing\n    special about dereferencing T.  */\n \n static alias_set_type\n get_deref_alias_set_1 (tree t)\n {\n-  /* If we're not doing any alias analysis, just assume everything\n-     aliases everything else.  */\n-  if (!flag_strict_aliasing)\n-    return 0;\n-\n   /* All we care about is the type.  */\n   if (! TYPE_P (t))\n     t = TREE_TYPE (t);\n \n   /* If we have an INDIRECT_REF via a void pointer, we don't\n      know anything about what that might alias.  Likewise if the\n      pointer is marked that way.  */\n-  if (TREE_CODE (TREE_TYPE (t)) == VOID_TYPE\n-      || TYPE_REF_CAN_ALIAS_ALL (t))\n+  if (ref_all_alias_ptr_type_p (t))\n     return 0;\n \n   return -1;\n@@ -579,6 +585,11 @@ get_deref_alias_set_1 (tree t)\n alias_set_type\n get_deref_alias_set (tree t)\n {\n+  /* If we're not doing any alias analysis, just assume everything\n+     aliases everything else.  */\n+  if (!flag_strict_aliasing)\n+    return 0;\n+\n   alias_set_type set = get_deref_alias_set_1 (t);\n \n   /* Fall back to the alias-set of the pointed-to type.  */\n@@ -592,6 +603,101 @@ get_deref_alias_set (tree t)\n   return set;\n }\n \n+/* Return the pointer-type relevant for TBAA purposes from the\n+   memory reference tree *T or NULL_TREE in which case *T is\n+   adjusted to point to the outermost component reference that\n+   can be used for assigning an alias set.  */\n+ \n+static tree\n+reference_alias_ptr_type_1 (tree *t)\n+{\n+  tree inner;\n+\n+  /* Get the base object of the reference.  */\n+  inner = *t;\n+  while (handled_component_p (inner))\n+    {\n+      /* If there is a VIEW_CONVERT_EXPR in the chain we cannot use\n+\t the type of any component references that wrap it to\n+\t determine the alias-set.  */\n+      if (TREE_CODE (inner) == VIEW_CONVERT_EXPR)\n+\t*t = TREE_OPERAND (inner, 0);\n+      inner = TREE_OPERAND (inner, 0);\n+    }\n+\n+  /* Handle pointer dereferences here, they can override the\n+     alias-set.  */\n+  if (INDIRECT_REF_P (inner)\n+      && ref_all_alias_ptr_type_p (TREE_TYPE (TREE_OPERAND (inner, 0))))\n+    return TREE_TYPE (TREE_OPERAND (inner, 0));\n+  else if (TREE_CODE (inner) == TARGET_MEM_REF)\n+    return TREE_TYPE (TMR_OFFSET (inner));\n+  else if (TREE_CODE (inner) == MEM_REF\n+\t   && ref_all_alias_ptr_type_p (TREE_TYPE (TREE_OPERAND (inner, 1))))\n+    return TREE_TYPE (TREE_OPERAND (inner, 1));\n+\n+  /* If the innermost reference is a MEM_REF that has a\n+     conversion embedded treat it like a VIEW_CONVERT_EXPR above,\n+     using the memory access type for determining the alias-set.  */\n+  if (TREE_CODE (inner) == MEM_REF\n+      && (TYPE_MAIN_VARIANT (TREE_TYPE (inner))\n+\t  != TYPE_MAIN_VARIANT\n+\t       (TREE_TYPE (TREE_TYPE (TREE_OPERAND (inner, 1))))))\n+    return TREE_TYPE (TREE_OPERAND (inner, 1));\n+\n+  /* Otherwise, pick up the outermost object that we could have a pointer\n+     to, processing conversions as above.  */\n+  /* ???  Ick, this is worse than quadratic!  */\n+  while (component_uses_parent_alias_set (*t))\n+    {\n+      *t = TREE_OPERAND (*t, 0);\n+      STRIP_NOPS (*t);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return the pointer-type relevant for TBAA purposes from the\n+   gimple memory reference tree T.  This is the type to be used for\n+   the offset operand of MEM_REF or TARGET_MEM_REF replacements of T\n+   and guarantees that get_alias_set will return the same alias\n+   set for T and the replacement.  */\n+\n+tree\n+reference_alias_ptr_type (tree t)\n+{\n+  tree ptype = reference_alias_ptr_type_1 (&t);\n+  /* If there is a given pointer type for aliasing purposes, return it.  */\n+  if (ptype != NULL_TREE)\n+    return ptype;\n+\n+  /* Otherwise build one from the outermost component reference we\n+     may use.  */\n+  if (TREE_CODE (t) == MEM_REF\n+      || TREE_CODE (t) == TARGET_MEM_REF)\n+    return TREE_TYPE (TREE_OPERAND (t, 1));\n+  else\n+    return build_pointer_type (TYPE_MAIN_VARIANT (TREE_TYPE (t)));\n+}\n+\n+/* Return whether the pointer-types T1 and T2 used to determine\n+   two alias sets of two references will yield the same answer\n+   from get_deref_alias_set.  */\n+\n+bool\n+alias_ptr_types_compatible_p (tree t1, tree t2)\n+{\n+  if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n+    return true;\n+\n+  if (ref_all_alias_ptr_type_p (t1)\n+      || ref_all_alias_ptr_type_p (t2))\n+    return false;\n+\n+  return (TYPE_MAIN_VARIANT (TREE_TYPE (t1))\n+\t  == TYPE_MAIN_VARIANT (TREE_TYPE (t2)));\n+}\n+\n /* Return the alias set for T, which may be either a type or an\n    expression.  Call language-specific routine for help, if needed.  */\n \n@@ -615,60 +721,18 @@ get_alias_set (tree t)\n      aren't types.  */\n   if (! TYPE_P (t))\n     {\n-      tree inner;\n-\n       /* Give the language a chance to do something with this tree\n \t before we look at it.  */\n       STRIP_NOPS (t);\n       set = lang_hooks.get_alias_set (t);\n       if (set != -1)\n \treturn set;\n \n-      /* Get the base object of the reference.  */\n-      inner = t;\n-      while (handled_component_p (inner))\n-\t{\n-\t  /* If there is a VIEW_CONVERT_EXPR in the chain we cannot use\n-\t     the type of any component references that wrap it to\n-\t     determine the alias-set.  */\n-\t  if (TREE_CODE (inner) == VIEW_CONVERT_EXPR)\n-\t    t = TREE_OPERAND (inner, 0);\n-\t  inner = TREE_OPERAND (inner, 0);\n-\t}\n-\n-      /* Handle pointer dereferences here, they can override the\n-\t alias-set.  */\n-      if (INDIRECT_REF_P (inner))\n-\t{\n-\t  set = get_deref_alias_set_1 (TREE_OPERAND (inner, 0));\n-\t  if (set != -1)\n-\t    return set;\n-\t}\n-      else if (TREE_CODE (inner) == TARGET_MEM_REF)\n-\treturn get_deref_alias_set (TMR_OFFSET (inner));\n-      else if (TREE_CODE (inner) == MEM_REF)\n-\t{\n-\t  set = get_deref_alias_set_1 (TREE_OPERAND (inner, 1));\n-\t  if (set != -1)\n-\t    return set;\n-\t}\n-\n-      /* If the innermost reference is a MEM_REF that has a\n-\t conversion embedded treat it like a VIEW_CONVERT_EXPR above,\n-\t using the memory access type for determining the alias-set.  */\n-     if (TREE_CODE (inner) == MEM_REF\n-\t && TYPE_MAIN_VARIANT (TREE_TYPE (inner))\n-\t    != TYPE_MAIN_VARIANT\n-\t       (TREE_TYPE (TREE_TYPE (TREE_OPERAND (inner, 1)))))\n-       return get_deref_alias_set (TREE_OPERAND (inner, 1));\n-\n-      /* Otherwise, pick up the outermost object that we could have a pointer\n-\t to, processing conversions as above.  */\n-      while (component_uses_parent_alias_set (t))\n-\t{\n-\t  t = TREE_OPERAND (t, 0);\n-\t  STRIP_NOPS (t);\n-\t}\n+      /* Get the alias pointer-type to use or the outermost object\n+         that we could have a pointer to.  */\n+      tree ptype = reference_alias_ptr_type_1 (&t);\n+      if (ptype != NULL)\n+\treturn get_deref_alias_set (ptype);\n \n       /* If we've already determined the alias set for a decl, just return\n \t it.  This is necessary for C++ anonymous unions, whose component"}, {"sha": "dd4b641ee8c1996b397a80001ad440838ffea533", "filename": "gcc/alias.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Falias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Falias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.h?ref=f40333afeb570012ed42439cb9ce3c7aaa63b916", "patch": "@@ -41,6 +41,8 @@ extern int alias_sets_conflict_p (alias_set_type, alias_set_type);\n extern int alias_sets_must_conflict_p (alias_set_type, alias_set_type);\n extern int objects_must_conflict_p (tree, tree);\n extern int nonoverlapping_memrefs_p (const_rtx, const_rtx, bool);\n+tree reference_alias_ptr_type (tree);\n+bool alias_ptr_types_compatible_p (tree, tree);\n \n /* This alias set can be used to force a memory to conflict with all\n    other memories, creating a barrier across which no memory reference"}, {"sha": "d435b540e001ae59be7f81b77120d5618903ecdc", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f40333afeb570012ed42439cb9ce3c7aaa63b916", "patch": "@@ -2693,8 +2693,9 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t\t       && operand_equal_p (TYPE_SIZE (TREE_TYPE (arg0)),\n \t\t\t\t\t   TYPE_SIZE (TREE_TYPE (arg1)), flags)))\n \t\t  && types_compatible_p (TREE_TYPE (arg0), TREE_TYPE (arg1))\n-\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (arg0, 1)))\n-\t\t      == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (arg1, 1))))\n+\t\t  && alias_ptr_types_compatible_p\n+\t\t       (TREE_TYPE (TREE_OPERAND (arg0, 1)),\n+\t\t\tTREE_TYPE (TREE_OPERAND (arg1, 1)))\n \t\t  && OP_SAME (0) && OP_SAME (1));\n \n \tcase ARRAY_REF:"}, {"sha": "6443e3e03887ba81eaee0c5f306a6b4db02f6d56", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f40333afeb570012ed42439cb9ce3c7aaa63b916", "patch": "@@ -1,3 +1,8 @@\n+2013-09-24  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/58513\n+\t* g++.dg/vect/pr58513.cc: New testcase.\n+\n 2013-09-24  Yvan Roux  <yvan.roux@linaro.org>\n \n \t* gcc.target/arm/atomic-comp-swap-release-acquire.c: Adjust expected"}, {"sha": "25630479e9ecf6e84b0bfd6bb5c3292129abb9d8", "filename": "gcc/testsuite/g++.dg/vect/pr58513.cc", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr58513.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr58513.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr58513.cc?ref=f40333afeb570012ed42439cb9ce3c7aaa63b916", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+// { dg-require-effective-target vect_int }\n+\n+int op (const int& x, const int& y) { return x + y; }\n+\n+void foo(int* a)\n+{\n+  for (int i = 0; i < 1000; ++i)\n+    a[i] = op(a[i], 1);\n+}\n+\n+// { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } }\n+// { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "a7b66c5ae14dec546a9f6567520e6bd3f8bdda88", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f40333afeb570012ed42439cb9ce3c7aaa63b916", "patch": "@@ -4263,24 +4263,6 @@ mem_ref_offset (const_tree t)\n   return tree_to_double_int (toff).sext (TYPE_PRECISION (TREE_TYPE (toff)));\n }\n \n-/* Return the pointer-type relevant for TBAA purposes from the\n-   gimple memory reference tree T.  This is the type to be used for\n-   the offset operand of MEM_REF or TARGET_MEM_REF replacements of T.  */\n-\n-tree\n-reference_alias_ptr_type (const_tree t)\n-{\n-  const_tree base = t;\n-  while (handled_component_p (base))\n-    base = TREE_OPERAND (base, 0);\n-  if (TREE_CODE (base) == MEM_REF)\n-    return TREE_TYPE (TREE_OPERAND (base, 1));\n-  else if (TREE_CODE (base) == TARGET_MEM_REF)\n-    return TREE_TYPE (TMR_OFFSET (base)); \n-  else\n-    return build_pointer_type (TYPE_MAIN_VARIANT (TREE_TYPE (base)));\n-}\n-\n /* Return an invariant ADDR_EXPR of type TYPE taking the address of BASE\n    offsetted by OFFSET units.  */\n "}, {"sha": "b1d168b0593c19c9add977be25635b30200effe8", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40333afeb570012ed42439cb9ce3c7aaa63b916/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f40333afeb570012ed42439cb9ce3c7aaa63b916", "patch": "@@ -4345,7 +4345,6 @@ extern tree build_simple_mem_ref_loc (location_t, tree);\n #define build_simple_mem_ref(T)\\\n \tbuild_simple_mem_ref_loc (UNKNOWN_LOCATION, T)\n extern double_int mem_ref_offset (const_tree);\n-extern tree reference_alias_ptr_type (const_tree);\n extern tree build_invariant_address (tree, tree, HOST_WIDE_INT);\n extern tree constant_boolean_node (bool, tree);\n extern tree div_if_zero_remainder (enum tree_code, const_tree, const_tree);"}]}