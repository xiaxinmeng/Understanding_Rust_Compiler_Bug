{"sha": "03456e44cfa6f5b10bf37689d497d05514dd47a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM0NTZlNDRjZmE2ZjViMTBiZjM3Njg5ZDQ5N2QwNTUxNGRkNDdhNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-22T09:11:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-22T09:11:52Z"}, "message": "[multiple changes]\n\n2009-06-22  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb (Check_Files): Close temporary files after all file names\n\thave been written into it.\n\n2009-06-22  Matthew Gingell  <gingell@adacore.com>\n\n\t* adaint.c, adaint.h, cstreams.c: Call stat64 on platforms where it is\n\tavailable.\n\n2009-06-22  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_disp.adb (Check_Direct_Call): Handle the case where the full\n\tview of the root type is visible at the point of the call.\n\n2009-06-22  Pat Rogers  <rogers@adacore.com>\n\n\t* gnat_ugn.texi: Revised a sentence to correct a minor grammar error.\n\nFrom-SVN: r148781", "tree": {"sha": "1c44cbd67cb9cf4de50113877176ec1dec6c7539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c44cbd67cb9cf4de50113877176ec1dec6c7539"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03456e44cfa6f5b10bf37689d497d05514dd47a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03456e44cfa6f5b10bf37689d497d05514dd47a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03456e44cfa6f5b10bf37689d497d05514dd47a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03456e44cfa6f5b10bf37689d497d05514dd47a4/comments", "author": null, "committer": null, "parents": [{"sha": "283268809829d27d5f54909bc3a79e8e54fc48eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/283268809829d27d5f54909bc3a79e8e54fc48eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/283268809829d27d5f54909bc3a79e8e54fc48eb"}], "stats": {"total": 282, "additions": 170, "deletions": 112}, "files": [{"sha": "bce68717b4bc24123e745abaccc9d5f2d2074445", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=03456e44cfa6f5b10bf37689d497d05514dd47a4", "patch": "@@ -1,3 +1,22 @@\n+2009-06-22  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb (Check_Files): Close temporary files after all file names\n+\thave been written into it.\n+\n+2009-06-22  Matthew Gingell  <gingell@adacore.com>\n+\n+\t* adaint.c, adaint.h, cstreams.c: Call stat64 on platforms where it is\n+\tavailable.\n+\n+2009-06-22  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_disp.adb (Check_Direct_Call): Handle the case where the full\n+\tview of the root type is visible at the point of the call.\n+\n+2009-06-22  Pat Rogers  <rogers@adacore.com>\n+\n+\t* gnat_ugn.texi: Revised a sentence to correct a minor grammar error.\n+\n 2009-06-22  Jerome Lambourg  <lambourg@adacore.com>\n \n \t* freeze.adb: Add comments."}, {"sha": "59d615bfc3be291e3add532fe4a4a2e2ab275afa", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=03456e44cfa6f5b10bf37689d497d05514dd47a4", "patch": "@@ -520,7 +520,7 @@ __gnat_try_lock (char *dir, char *file)\n {\n   char full_path[256];\n   char temp_file[256];\n-  struct stat stat_result;\n+  STRUCT_STAT stat_result;\n   int fd;\n \n   sprintf (full_path, \"%s%c%s\", dir, DIR_SEPARATOR, file);\n@@ -775,15 +775,7 @@ __gnat_fopen (char *path, char *mode, int encoding ATTRIBUTE_UNUSED)\n #elif defined (VMS)\n   return decc$fopen (path, mode);\n #else\n-\n-#if defined (__GLIBC__) || defined (sun)\n-  /* GLIBC and Solaris provides fopen64, which allows IO on files\n-     larger than 2GB on systems that support it. */\n-  return fopen64 (path, mode);\n-#else\n-  return fopen (path, mode);\n-#endif\n-\n+  return FOPEN (path, mode);\n #endif\n }\n \n@@ -1027,12 +1019,16 @@ long\n __gnat_file_length (int fd)\n {\n   int ret;\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  ret = fstat (fd, &statbuf);\n+  ret = FSTAT (fd, &statbuf);\n   if (ret || !S_ISREG (statbuf.st_mode))\n     return 0;\n \n+  /* st_size may be 32 bits, or 64 bits which is converted to long. We\n+     don't return a useful value for files larger than 2 gigabytes in\n+     either case. */\n+\n   return (statbuf.st_size);\n }\n \n@@ -1042,12 +1038,16 @@ long\n __gnat_named_file_length (char *name)\n {\n   int ret;\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n   ret = __gnat_stat (name, &statbuf);\n   if (ret || !S_ISREG (statbuf.st_mode))\n     return 0;\n \n+  /* st_size may be 32 bits, or 64 bits which is converted to long. We\n+     don't return a useful value for files larger than 2 gigabytes in\n+     either case. */\n+\n   return (statbuf.st_size);\n }\n \n@@ -1269,7 +1269,7 @@ __gnat_file_time_name (char *name)\n     }\n   return (OS_Time) ret;\n #else\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n   if (__gnat_stat (name, &statbuf) != 0) {\n      return (OS_Time)-1;\n   } else {\n@@ -1361,9 +1361,9 @@ __gnat_file_time_fd (int fd)\n   return (OS_Time) ret;\n \n #else\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  if (fstat (fd, &statbuf) != 0) {\n+  if (FSTAT (fd, &statbuf) != 0) {\n      return (OS_Time) -1;\n   } else {\n #ifdef VMS\n@@ -1651,7 +1651,7 @@ __gnat_get_libraries_from_registry (void)\n }\n \n int\n-__gnat_stat (char *name, struct stat *statbuf)\n+__gnat_stat (char *name, STRUCT_STAT *statbuf)\n {\n #ifdef __MINGW32__\n   /* Under Windows the directory name for the stat function must not be\n@@ -1683,7 +1683,7 @@ __gnat_stat (char *name, struct stat *statbuf)\n   return _tstat (wname, (struct _stat *)statbuf);\n \n #else\n-  return stat (name, statbuf);\n+  return STAT (name, statbuf);\n #endif\n }\n \n@@ -1699,7 +1699,7 @@ __gnat_file_exists (char *name)\n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n   return GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n #else\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n   return !__gnat_stat (name, &statbuf);\n #endif\n@@ -1744,7 +1744,7 @@ int\n __gnat_is_regular_file (char *name)\n {\n   int ret;\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n   ret = __gnat_stat (name, &statbuf);\n   return (!ret && S_ISREG (statbuf.st_mode));\n@@ -1754,7 +1754,7 @@ int\n __gnat_is_directory (char *name)\n {\n   int ret;\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n   ret = __gnat_stat (name, &statbuf);\n   return (!ret && S_ISDIR (statbuf.st_mode));\n@@ -1972,9 +1972,9 @@ __gnat_is_readable_file (char *name)\n #else\n   int ret;\n   int mode;\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  ret = stat (name, &statbuf);\n+  ret = STAT (name, &statbuf);\n   mode = statbuf.st_mode & S_IRUSR;\n   return (!ret && mode);\n #endif\n@@ -2004,9 +2004,9 @@ __gnat_is_writable_file (char *name)\n #else\n   int ret;\n   int mode;\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  ret = stat (name, &statbuf);\n+  ret = STAT (name, &statbuf);\n   mode = statbuf.st_mode & S_IWUSR;\n   return (!ret && mode);\n #endif\n@@ -2031,13 +2031,12 @@ __gnat_is_executable_file (char *name)\n   else\n     return GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES\n       && _tcsstr (wname, _T(\".exe\")) - wname == (int) (_tcslen (wname) - 4);\n-\n #else\n   int ret;\n   int mode;\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  ret = stat (name, &statbuf);\n+  ret = STAT (name, &statbuf);\n   mode = statbuf.st_mode & S_IXUSR;\n   return (!ret && mode);\n #endif\n@@ -2057,9 +2056,9 @@ __gnat_set_writable (char *name)\n   SetFileAttributes\n     (wname, GetFileAttributes (wname) & ~FILE_ATTRIBUTE_READONLY);\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  if (stat (name, &statbuf) == 0)\n+  if (STAT (name, &statbuf) == 0)\n     {\n       statbuf.st_mode = statbuf.st_mode | S_IWUSR;\n       chmod (name, statbuf.st_mode);\n@@ -2079,9 +2078,9 @@ __gnat_set_executable (char *name)\n     __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_EXECUTE);\n \n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  if (stat (name, &statbuf) == 0)\n+  if (STAT (name, &statbuf) == 0)\n     {\n       statbuf.st_mode = statbuf.st_mode | S_IXUSR;\n       chmod (name, statbuf.st_mode);\n@@ -2106,9 +2105,9 @@ __gnat_set_non_writable (char *name)\n   SetFileAttributes\n     (wname, GetFileAttributes (wname) | FILE_ATTRIBUTE_READONLY);\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  if (stat (name, &statbuf) == 0)\n+  if (STAT (name, &statbuf) == 0)\n     {\n       statbuf.st_mode = statbuf.st_mode & 07577;\n       chmod (name, statbuf.st_mode);\n@@ -2128,9 +2127,9 @@ __gnat_set_readable (char *name)\n     __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_READ);\n \n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  if (stat (name, &statbuf) == 0)\n+  if (STAT (name, &statbuf) == 0)\n     {\n       chmod (name, statbuf.st_mode | S_IREAD);\n     }\n@@ -2149,9 +2148,9 @@ __gnat_set_non_readable (char *name)\n     __gnat_set_OWNER_ACL (wname, DENY_ACCESS, FILE_GENERIC_READ);\n \n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  if (stat (name, &statbuf) == 0)\n+  if (STAT (name, &statbuf) == 0)\n     {\n       chmod (name, statbuf.st_mode & (~S_IREAD));\n     }\n@@ -2166,9 +2165,9 @@ __gnat_is_symbolic_link (char *name ATTRIBUTE_UNUSED)\n \n #elif defined (_AIX) || defined (__APPLE__) || defined (__unix__)\n   int ret;\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n-  ret = lstat (name, &statbuf);\n+  ret = LSTAT (name, &statbuf);\n   return (!ret && S_ISLNK (statbuf.st_mode));\n \n #else\n@@ -3435,10 +3434,10 @@ __gnat_copy_attribs (char *from, char *to, int mode)\n   return 0;\n \n #else\n-  struct stat fbuf;\n+  STRUCT_STAT fbuf;\n   struct utimbuf tbuf;\n \n-  if (stat (from, &fbuf) == -1)\n+  if (STAT (from, &fbuf) == -1)\n     {\n       return -1;\n     }"}, {"sha": "a5243f1eef44909e54218c985079119f3ffae4fc", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=03456e44cfa6f5b10bf37689d497d05514dd47a4", "patch": "@@ -43,6 +43,24 @@\n #define Encoding_8bits 1        /* Standard 8bits, CP_ACP on Windows. */\n #define Encoding_Unspecified 2  /* Based on GNAT_CODE_PAGE env variable. */\n \n+/* Large file support. It is unclear what portable mechanism we can\n+   use to determine at compile time what support the system offers for\n+   large files. For now we just list the platforms we have manually\n+   tested.  */\n+\n+#if defined (__GLIBC__) || defined (sun)  || defined (__sgi)\n+#define FOPEN fopen64\n+#define STAT stat64\n+#define FSTAT fstat64\n+#define LSTAT lstat64\n+#define STRUCT_STAT struct stat64\n+#else\n+#define FOPEN fopen\n+#define STAT stat\n+#define FSTAT fstat\n+#define STRUCT_STAT struct stat\n+#endif\n+\n typedef long OS_Time; /* Type corresponding to GNAT.OS_Lib.OS_Time */\n \n extern int    __gnat_max_path_len;\n@@ -70,7 +88,7 @@ extern int    __gnat_open_new                      (char *, int);\n extern int    __gnat_open_new_temp\t\t   (char *, int);\n extern int    __gnat_mkdir\t\t\t   (char *);\n extern int    __gnat_stat\t\t\t   (char *,\n-\t\t\t\t\t\t    struct stat *);\n+\t\t\t\t\t\t    STRUCT_STAT *);\n extern int    __gnat_unlink                        (char *);\n extern int    __gnat_rename                        (char *, char *);\n extern int    __gnat_chdir                         (char *);"}, {"sha": "2177fdc1512c2fe9dcb569e5999d728631a4647f", "filename": "gcc/ada/cstreams.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fcstreams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fcstreams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstreams.c?ref=03456e44cfa6f5b10bf37689d497d05514dd47a4", "patch": "@@ -96,7 +96,7 @@ int\n __gnat_is_regular_file_fd (int fd)\n {\n   int ret;\n-  struct stat statbuf;\n+  STRUCT_STAT statbuf;\n \n #ifdef __EMX__\n   /* Programs using screen I/O may need to reset the FPU after\n@@ -107,7 +107,7 @@ __gnat_is_regular_file_fd (int fd)\n   __gnat_init_float();\n #endif\n \n-  ret = fstat (fd, &statbuf);\n+  ret = FSTAT (fd, &statbuf);\n   return (!ret && S_ISREG (statbuf.st_mode));\n }\n "}, {"sha": "0fda13b57c59b7f167769d1e9a024e7139a29763", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=03456e44cfa6f5b10bf37689d497d05514dd47a4", "patch": "@@ -17693,8 +17693,9 @@ considered to be a class. A category consists of a library package (or\n a library generic package) that defines a tagged or an interface type,\n together with all its descendant (generic) packages that define tagged\n or interface types. For any package counted as a class,\n-its body (if any) is considered\n-together with its spec when counting the dependencies. For dependencies\n+its body and subunits (if any) are considered\n+together with its spec when counting the dependencies, and coupling\n+metrics are reported for spec units only. For dependencies\n between classes, the Ada semantic dependencies are considered.\n For coupling metrics, only dependencies on units that are considered as\n classes, are considered.\n@@ -18891,9 +18892,10 @@ units are called @emph{interface units} (@pxref{Stand-alone Ada Libraries}).\n All compilation units comprising an application, including those in a library,\n need to be elaborated in an order partially defined by Ada's semantics. GNAT\n computes the elaboration order from the @file{ALI} files and this is why they\n-constitute a mandatory part of GNAT libraries. Except in the case of\n-@emph{stand-alone libraries}, where a specific library elaboration routine is\n-produced independently of the application(s) using the library.\n+constitute a mandatory part of GNAT libraries.\n+@emph{Stand-alone libraries} are the exception to this rule because a specific\n+library elaboration routine is produced independently of the application(s)\n+using the library.\n \n @node General Ada Libraries\n @section General Ada Libraries"}, {"sha": "3f5bb6d09fbe6dee3387e8c1035e5b1b7f6ccc6d", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 42, "deletions": 55, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=03456e44cfa6f5b10bf37689d497d05514dd47a4", "patch": "@@ -330,36 +330,36 @@ procedure GNATCmd is\n          --  For gnatcheck, gnatpp and gnatmetric , create a temporary file and\n          --  put the list of sources in it.\n \n-         if The_Command = Check\n-            or else The_Command = Pretty\n-            or else The_Command = Metric\n+         if The_Command = Check  or else\n+            The_Command = Pretty or else\n+            The_Command = Metric\n          then\n             Tempdir.Create_Temp_File (FD, Temp_File_Name);\n             Last_Switches.Increment_Last;\n             Last_Switches.Table (Last_Switches.Last) :=\n               new String'(\"-files=\" & Get_Name_String (Temp_File_Name));\n-\n          end if;\n \n          declare\n-            Proj         : Project_List;\n+            Proj : Project_List;\n \n          begin\n-            --  Gnatstack needs to add the .ci file for the binder\n-            --  generated files corresponding to all of the library projects\n-            --  and main units belonging to the application.\n+            --  Gnatstack needs to add the .ci file for the binder generated\n+            --  files corresponding to all of the library projects and main\n+            --  units belonging to the application.\n \n             if The_Command = Stack then\n                Proj := Project_Tree.Projects;\n                while Proj /= null loop\n                   if Check_Project (Proj.Project, Project) then\n                      declare\n-                        Main : String_List_Id := Proj.Project.Mains;\n+                        Main : String_List_Id;\n                         File : String_Access;\n \n                      begin\n                         --  Include binder generated files for main programs\n \n+                        Main := Proj.Project.Mains;\n                         while Main /= Nil_String loop\n                            File :=\n                              new String'\n@@ -430,28 +430,23 @@ procedure GNATCmd is\n                      then\n                         Subunit := False;\n \n-                        if\n-                          Unit_Data.File_Names (Specification).Name = No_File\n-                            or else\n-                            Unit_Data.File_Names\n-                              (Specification).Path.Name = Slash\n+                        if Unit_Data.File_Names (Specification).Name = No_File\n+                          or else Unit_Data.File_Names\n+                                    (Specification).Path.Name = Slash\n                         then\n                            --  We have a body with no spec: we need to check if\n                            --  this is a subunit, because gnatls will complain\n                            --  about subunits.\n \n                            declare\n-                              Src_Ind : Source_File_Index;\n-\n+                              Src_Ind : constant Source_File_Index :=\n+                                          Sinput.P.Load_Project_File\n+                                            (Get_Name_String\n+                                              (Unit_Data.File_Names\n+                                                (Body_Part).Path.Name));\n                            begin\n-                              Src_Ind := Sinput.P.Load_Project_File\n-                                (Get_Name_String\n-                                   (Unit_Data.File_Names\n-                                      (Body_Part).Path.Name));\n-\n                               Subunit :=\n-                                Sinput.P.Source_File_Is_Subunit\n-                                  (Src_Ind);\n+                                Sinput.P.Source_File_Is_Subunit (Src_Ind);\n                            end;\n                         end if;\n \n@@ -470,7 +465,7 @@ procedure GNATCmd is\n                       and then\n                     Unit_Data.File_Names (Specification).Path.Name /= Slash\n                   then\n-                     --  We have a spec with no body; check if it is for this\n+                     --  We have a spec with no body. Check if it is for this\n                      --  project.\n \n                      if All_Projects or else\n@@ -491,39 +486,33 @@ procedure GNATCmd is\n                --  but not the subunits.\n \n                elsif The_Command = Stack then\n-                  if\n-                    Unit_Data.File_Names (Body_Part).Name /= No_File\n-                      and then\n-                    Unit_Data.File_Names (Body_Part).Path.Name /= Slash\n+                  if Unit_Data.File_Names (Body_Part).Name /= No_File\n+                    and then\n+                      Unit_Data.File_Names (Body_Part).Path.Name /= Slash\n                   then\n                      --  There is a body. Check if .ci files for this project\n                      --  must be added.\n \n-                     if\n-                       Check_Project\n+                     if Check_Project\n                          (Unit_Data.File_Names (Body_Part).Project, Project)\n                      then\n                         Subunit := False;\n \n-                        if\n-                          Unit_Data.File_Names (Specification).Name = No_File\n-                            or else\n-                            Unit_Data.File_Names\n-                              (Specification).Path.Name = Slash\n+                        if Unit_Data.File_Names (Specification).Name = No_File\n+                          or else Unit_Data.File_Names\n+                                    (Specification).Path.Name = Slash\n                         then\n                            --  We have a body with no spec: we need to check\n                            --  if this is a subunit, because .ci files are not\n                            --  generated for subunits.\n \n                            declare\n-                              Src_Ind : Source_File_Index;\n-\n+                              Src_Ind : constant Source_File_Index :=\n+                                          Sinput.P.Load_Project_File\n+                                            (Get_Name_String\n+                                              (Unit_Data.File_Names\n+                                                (Body_Part).Path.Name));\n                            begin\n-                              Src_Ind := Sinput.P.Load_Project_File\n-                                (Get_Name_String\n-                                   (Unit_Data.File_Names\n-                                      (Body_Part).Path.Name));\n-\n                               Subunit :=\n                                 Sinput.P.Source_File_Is_Subunit (Src_Ind);\n                            end;\n@@ -546,16 +535,14 @@ procedure GNATCmd is\n                         end if;\n                      end if;\n \n-                  elsif\n-                    Unit_Data.File_Names (Specification).Name /= No_File\n+                  elsif Unit_Data.File_Names (Specification).Name /= No_File\n                     and then\n-                    Unit_Data.File_Names (Specification).Path.Name /= Slash\n+                      Unit_Data.File_Names (Specification).Path.Name /= Slash\n                   then\n                      --  We have a spec with no body. Check if it is for this\n                      --  project.\n \n-                     if\n-                       Check_Project\n+                     if Check_Project\n                          (Unit_Data.File_Names (Specification).Project,\n                           Project)\n                      then\n@@ -610,17 +597,17 @@ procedure GNATCmd is\n                         end if;\n                      end if;\n                   end loop;\n-\n-                  if FD /= Invalid_FD then\n-                     Close (FD, Success);\n-\n-                     if not Success then\n-                        Osint.Fail (\"disk full\");\n-                     end if;\n-                  end if;\n                end if;\n             end loop;\n          end;\n+\n+         if FD /= Invalid_FD then\n+            Close (FD, Success);\n+\n+            if not Success then\n+               Osint.Fail (\"disk full\");\n+            end if;\n+         end if;\n       end if;\n    end Check_Files;\n "}, {"sha": "239742aa78320e61ef2dd1109580350ebbb3cd83", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03456e44cfa6f5b10bf37689d497d05514dd47a4/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=03456e44cfa6f5b10bf37689d497d05514dd47a4", "patch": "@@ -319,20 +319,53 @@ package body Sem_Disp is\n       procedure Check_Direct_Call is\n          Typ : Entity_Id := Etype (Control);\n \n+         function Is_User_Defined_Equality (Id : Entity_Id) return Boolean;\n+         --  Determine whether an entity denotes a user-defined equality\n+\n+         ------------------------------\n+         -- Is_User_Defined_Equality --\n+         ------------------------------\n+\n+         function Is_User_Defined_Equality (Id : Entity_Id) return Boolean is\n+         begin\n+            return\n+              Ekind (Id) = E_Function\n+                and then Chars (Id) = Name_Op_Eq\n+                and then Comes_From_Source (Id)\n+\n+               --  Internally generated equalities have a full type declaration\n+               --  as their parent.\n+\n+                and then Nkind (Parent (Id)) = N_Function_Specification;\n+         end Is_User_Defined_Equality;\n+\n+      --  Start of processing for Check_Direct_Call\n+\n       begin\n+         --  Predefined primitives do not receive wrappers since they are built\n+         --  from scratch for the corresponding record of synchronized types.\n+         --  Equality is in general predefined, but is excluded from the check\n+         --  when it is user-defined.\n+\n+         if Is_Predefined_Dispatching_Operation (Subp_Entity)\n+           and then not Is_User_Defined_Equality (Subp_Entity)\n+         then\n+            return;\n+         end if;\n+\n          if Is_Class_Wide_Type (Typ) then\n             Typ := Root_Type (Typ);\n          end if;\n \n-         --  Detect whether the controlling type is a private type completed\n-         --  by a task or protected type.\n+         if Is_Private_Type (Typ) and then Present (Full_View (Typ)) then\n+            Typ := Full_View (Typ);\n+         end if;\n \n-         if Is_Private_Type (Typ)\n-           and then Present (Full_View (Typ))\n-           and then Is_Concurrent_Type (Full_View (Typ))\n-           and then Present (Corresponding_Record_Type (Full_View (Typ)))\n+         if Is_Concurrent_Type (Typ)\n+              and then\n+            Present (Corresponding_Record_Type (Typ))\n          then\n-            Typ := Corresponding_Record_Type (Full_View (Typ));\n+            Typ := Corresponding_Record_Type (Typ);\n \n             --  The concurrent record's list of primitives should contain a\n             --  wrapper for the entity of the call, retrieve it."}]}