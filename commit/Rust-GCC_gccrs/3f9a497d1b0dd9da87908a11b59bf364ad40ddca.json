{"sha": "3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y5YTQ5N2QxYjBkZDlkYTg3OTA4YTExYjU5YmYzNjRhZDQwZGRjYQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-19T23:47:29Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-19T23:56:13Z"}, "message": "Extend -Warray-bounds to detect out-of-bounds accesses to array parameters.\n\ngcc/ChangeLog:\n\n\tPR middle-end/82608\n\tPR middle-end/94195\n\tPR c/50584\n\tPR middle-end/84051\n\t* gimple-array-bounds.cc (get_base_decl): New function.\n\t(get_ref_size): New function.\n\t(trailing_array): New function.\n\t(array_bounds_checker::check_array_ref): Call them.  Handle arrays\n\tdeclared in function parameters.\n\t(array_bounds_checker::check_mem_ref):  Same.  Handle references to\n\tdynamically allocated arrays.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/82608\n\tPR middle-end/94195\n\tPR c/50584\n\tPR middle-end/84051\n\t* c-c++-common/Warray-bounds.c: Adjust.\n\t* gcc.dg/Wbuiltin-declaration-mismatch-9.c: Adjust.\n\t* gcc.dg/Warray-bounds-63.c: New test.\n\t* gcc.dg/Warray-bounds-64.c: New test.\n\t* gcc.dg/Warray-bounds-65.c: New test.\n\t* gcc.dg/Warray-bounds-66.c: New test.\n\t* gcc.dg/Warray-bounds-67.c: New test.", "tree": {"sha": "f1a13f5fcd2db0e36dd3c487b47dd7198151ce56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1a13f5fcd2db0e36dd3c487b47dd7198151ce56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baad4c48a85a354d2bf1b17e5aff71203c08adea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baad4c48a85a354d2bf1b17e5aff71203c08adea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baad4c48a85a354d2bf1b17e5aff71203c08adea"}], "stats": {"total": 1024, "additions": 944, "deletions": 80}, "files": [{"sha": "b93ef7a7b7495b51c51de014f462ca573882f325", "filename": "gcc/gimple-array-bounds.cc", "status": "modified", "additions": 334, "deletions": 77, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "patch": "@@ -36,6 +36,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vr-values.h\"\n #include \"domwalk.h\"\n #include \"tree-cfg.h\"\n+#include \"attribs.h\"\n+#include \"builtins.h\"\n \n // This purposely returns a value_range, not a value_range_equiv, to\n // break the dependency on equivalences for this pass.\n@@ -46,19 +48,137 @@ array_bounds_checker::get_value_range (const_tree op)\n   return ranges->get_value_range (op);\n }\n \n+/* Try to determine the DECL that REF refers to.  Return the DECL or\n+   the expression closest to it.  Used in informational notes pointing\n+   to referenced objects or function parameters.  */\n+\n+static tree\n+get_base_decl (tree ref)\n+{\n+  tree base = get_base_address (ref);\n+  if (DECL_P (base))\n+    return base;\n+\n+  if (TREE_CODE (base) == MEM_REF)\n+    base = TREE_OPERAND (base, 0);\n+\n+  if (TREE_CODE (base) != SSA_NAME)\n+    return base;\n+\n+  do\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (base);\n+      if (gimple_assign_single_p (def))\n+\t{\n+\t  base = gimple_assign_rhs1 (def);\n+\t  if (TREE_CODE (base) != ASSERT_EXPR)\n+\t    return base;\n+\n+\t  base = TREE_OPERAND (base, 0);\n+\t  if (TREE_CODE (base) != SSA_NAME)\n+\t    return base;\n+\n+\t  continue;\n+\t}\n+\n+      if (!gimple_nop_p (def))\n+\treturn base;\n+\n+      break;\n+    } while (true);\n+\n+  tree var = SSA_NAME_VAR (base);\n+  if (TREE_CODE (var) != PARM_DECL)\n+    return base;\n+\n+  return var;\n+}\n+\n+/* Return the constant byte size of the object or type referenced by\n+   the MEM_REF ARG.  On success, set *PREF to the DECL or expression\n+   ARG refers to.  Otherwise return null.  */\n+\n+static tree\n+get_ref_size (tree arg, tree *pref)\n+{\n+  if (TREE_CODE (arg) != MEM_REF)\n+    return NULL_TREE;\n+\n+  arg = TREE_OPERAND (arg, 0);\n+  tree type = TREE_TYPE (arg);\n+  if (!POINTER_TYPE_P (type))\n+    return NULL_TREE;\n+\n+  type = TREE_TYPE (type);\n+  if (TREE_CODE (type) != ARRAY_TYPE)\n+    return NULL_TREE;\n+\n+  tree nbytes = TYPE_SIZE_UNIT (type);\n+  if (!nbytes || TREE_CODE (nbytes) != INTEGER_CST)\n+    return NULL_TREE;\n+\n+  *pref = get_base_decl (arg);\n+  return nbytes;\n+}\n+\n+/* Return true if REF is (likely) an ARRAY_REF to a trailing array member\n+   of a struct.  It refines array_at_struct_end_p by detecting a pointer\n+   to an array and an array parameter declared using the [N] syntax (as\n+   opposed to a pointer) and returning false.  Set *PREF to the decl or\n+   expression REF refers to.  */\n+\n+static bool\n+trailing_array (tree arg, tree *pref)\n+{\n+  tree ref = arg;\n+  tree base = get_base_decl (arg);\n+  while (TREE_CODE (ref) == ARRAY_REF || TREE_CODE (ref) == MEM_REF)\n+    ref = TREE_OPERAND (ref, 0);\n+\n+  if (TREE_CODE (ref) == COMPONENT_REF)\n+    {\n+      *pref = TREE_OPERAND (ref, 1);\n+      tree type = TREE_TYPE (*pref);\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  /* A multidimensional trailing array is not considered special\n+\t     no matter what its major bound is.  */\n+\t  type = TREE_TYPE (type);\n+\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t    return false;\n+\t}\n+    }\n+  else\n+    *pref = base;\n+\n+  tree basetype = TREE_TYPE (base);\n+  if (TREE_CODE (base) == PARM_DECL\n+      && POINTER_TYPE_P (basetype))\n+    {\n+      tree ptype = TREE_TYPE (basetype);\n+      if (TREE_CODE (ptype) == ARRAY_TYPE)\n+\treturn false;\n+    }\n+\n+  return array_at_struct_end_p (arg);\n+}\n+\n /* Checks one ARRAY_REF in REF, located at LOCUS. Ignores flexible\n    arrays and \"struct\" hacks. If VRP can determine that the array\n    subscript is a constant, check if it is outside valid range.  If\n    the array subscript is a RANGE, warn if it is non-overlapping with\n    valid range.  IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside\n-   a ADDR_EXPR.  Returns true if a warning has been issued.  */\n+   a ADDR_EXPR.  Return  true if a warning has been issued or if\n+   no-warning is set.  */\n \n bool\n array_bounds_checker::check_array_ref (location_t location, tree ref,\n \t\t\t\t       bool ignore_off_by_one)\n {\n   if (TREE_NO_WARNING (ref))\n-    return false;\n+    /* Return true to have the caller prevent warnings for enclosing\n+       refs.  */\n+    return true;\n \n   tree low_sub = TREE_OPERAND (ref, 1);\n   tree up_sub = low_sub;\n@@ -74,8 +194,7 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \n   if (!up_bound\n       || TREE_CODE (up_bound) != INTEGER_CST\n-      || (warn_array_bounds < 2\n-\t  && array_at_struct_end_p (ref)))\n+      || (warn_array_bounds < 2 && trailing_array (ref, &decl)))\n     {\n       /* Accesses to trailing arrays via pointers may access storage\n \t beyond the types array bounds.  For such arrays, or for flexible\n@@ -116,7 +235,14 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \t      poly_int64 off;\n \t      if (tree base = get_addr_base_and_unit_offset (arg, &off))\n \t\t{\n-\t\t  if (!compref && DECL_P (base))\n+\t\t  if (TREE_CODE (base) == MEM_REF)\n+\t\t    {\n+\t\t      /* Try to determine the size from a pointer to\n+\t\t\t an array if BASE is one.  */\n+\t\t      if (tree size = get_ref_size (base, &decl))\n+\t\t\tmaxbound = size;\n+\t\t    }\n+\t\t  else if (!compref && DECL_P (base))\n \t\t    if (tree basesize = DECL_SIZE_UNIT (base))\n \t\t      if (TREE_CODE (basesize) == INTEGER_CST)\n \t\t\t{\n@@ -217,7 +343,13 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n-      ref = decl ? decl : TREE_OPERAND (ref, 0);\n+      /* Avoid more warnings when checking more significant subscripts\n+\t of the same expression.  */\n+      ref = TREE_OPERAND (ref, 0);\n+      TREE_NO_WARNING (ref) = 1;\n+\n+      if (decl)\n+\tref = decl;\n \n       tree rec = NULL_TREE;\n       if (TREE_CODE (ref) == COMPONENT_REF)\n@@ -235,8 +367,6 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \tinform (DECL_SOURCE_LOCATION (ref), \"while referencing %qD\", ref);\n       if (rec && DECL_P (rec))\n \tinform (DECL_SOURCE_LOCATION (rec), \"defined here %qD\", rec);\n-\n-      TREE_NO_WARNING (ref) = 1;\n     }\n \n   return warned;\n@@ -266,16 +396,16 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \n   const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n \n-  /* The array or string constant bounds in bytes.  Initially set\n-     to [-MAXOBJSIZE - 1, MAXOBJSIZE]  until a tighter bound is\n+  /* The zero-based array or string constant bounds in bytes.  Initially\n+     set to [-MAXOBJSIZE - 1, MAXOBJSIZE]  until a tighter bound is\n      determined.  */\n   offset_int arrbounds[2] = { -maxobjsize - 1, maxobjsize };\n \n   /* The minimum and maximum intermediate offset.  For a reference\n      to be valid, not only does the final offset/subscript must be\n      in bounds but all intermediate offsets should be as well.\n      GCC may be able to deal gracefully with such out-of-bounds\n-     offsets so the checking is only enbaled at -Warray-bounds=2\n+     offsets so the checking is only enabled at -Warray-bounds=2\n      where it may help detect bugs in uses of the intermediate\n      offsets that could otherwise not be detectable.  */\n   offset_int ioff = wi::to_offset (fold_convert (ptrdiff_type_node, cstoff));\n@@ -284,7 +414,10 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n   /* The range of the byte offset into the reference.  */\n   offset_int offrange[2] = { 0, 0 };\n \n-  const value_range *vr = NULL;\n+  /* The statement used to allocate the array or null.  */\n+  gimple *alloc_stmt = NULL;\n+  /* For an allocation statement, the low bound of the size range.  */\n+  offset_int minbound = 0;\n \n   /* Determine the offsets and increment OFFRANGE for the bounds of each.\n      The loop computes the range of the final offset for expressions such\n@@ -294,6 +427,35 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n   for (unsigned n = 0; TREE_CODE (arg) == SSA_NAME && n < limit; ++n)\n     {\n       gimple *def = SSA_NAME_DEF_STMT (arg);\n+      if (is_gimple_call (def))\n+\t{\n+\t  /* Determine the byte size of the array from an allocation call.  */\n+\t  wide_int sizrng[2];\n+\t  if (gimple_call_alloc_size (def, sizrng))\n+\t    {\n+\t      arrbounds[0] = 0;\n+\t      arrbounds[1] = offset_int::from (sizrng[1], UNSIGNED);\n+\t      minbound = offset_int::from (sizrng[0], UNSIGNED);\n+\t      alloc_stmt = def;\n+\t    }\n+\t  break;\n+\t}\n+\n+      if (gimple_nop_p (def))\n+\t{\n+\t  /* For a function argument try to determine the byte size\n+\t     of the array from the current function declaratation\n+\t     (e.g., attribute access or related).  */\n+\t  wide_int wr[2];\n+\t  tree ref = gimple_parm_array_size (arg, wr);\n+\t  if (!ref)\n+\t    break;\n+\t  arrbounds[0] = offset_int::from (wr[0], UNSIGNED);\n+\t  arrbounds[1] = offset_int::from (wr[1], UNSIGNED);\n+\t  arg = ref;\n+\t  break;\n+\t}\n+\n       if (!is_gimple_assign (def))\n \tbreak;\n \n@@ -316,7 +478,7 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n       if (TREE_CODE (varoff) != SSA_NAME)\n \tbreak;\n \n-      vr = get_value_range (varoff);\n+      const value_range* const vr = get_value_range (varoff);\n       if (!vr || vr->undefined_p () || vr->varying_p ())\n \tbreak;\n \n@@ -366,79 +528,104 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \toffrange[1] = arrbounds[1];\n     }\n \n-  if (TREE_CODE (arg) == ADDR_EXPR)\n+  tree reftype = NULL_TREE;\n+  offset_int eltsize = -1;\n+  if (arrbounds[0] >= 0)\n+    {\n+      /* The byte size of the array has already been determined above\n+\t based on a pointer ARG.  Set ELTSIZE to the size of the type\n+\t it points to and REFTYPE to the array with the size, rounded\n+\t down as necessary.  */\n+      reftype = TREE_TYPE (TREE_TYPE (arg));\n+      if (TREE_CODE (reftype) == ARRAY_TYPE)\n+\treftype = TREE_TYPE (reftype);\n+      if (tree refsize = TYPE_SIZE_UNIT (reftype))\n+\tif (TREE_CODE (refsize) == INTEGER_CST)\n+\t  eltsize = wi::to_offset (refsize);\n+\n+      if (eltsize < 0)\n+\treturn false;\n+\n+      offset_int nelts = arrbounds[1] / eltsize;\n+      reftype = build_array_type_nelts (reftype, nelts.to_uhwi ());\n+    }\n+  else if (TREE_CODE (arg) == ADDR_EXPR)\n     {\n       arg = TREE_OPERAND (arg, 0);\n       if (TREE_CODE (arg) != STRING_CST\n \t  && TREE_CODE (arg) != PARM_DECL\n \t  && TREE_CODE (arg) != VAR_DECL)\n \treturn false;\n-    }\n-  else\n-    return false;\n \n-  /* The type of the object being referred to.  It can be an array,\n-     string literal, or a non-array type when the MEM_REF represents\n-     a reference/subscript via a pointer to an object that is not\n-     an element of an array.  Incomplete types are excluded as well\n-     because their size is not known.  */\n-  tree reftype = TREE_TYPE (arg);\n-  if (POINTER_TYPE_P (reftype)\n-      || !COMPLETE_TYPE_P (reftype)\n-      || TREE_CODE (TYPE_SIZE_UNIT (reftype)) != INTEGER_CST)\n-    return false;\n+      /* The type of the object being referred to.  It can be an array,\n+\t string literal, or a non-array type when the MEM_REF represents\n+\t a reference/subscript via a pointer to an object that is not\n+\t an element of an array.  Incomplete types are excluded as well\n+\t because their size is not known.  */\n+      reftype = TREE_TYPE (arg);\n+      if (POINTER_TYPE_P (reftype)\n+\t  || !COMPLETE_TYPE_P (reftype)\n+\t  || TREE_CODE (TYPE_SIZE_UNIT (reftype)) != INTEGER_CST)\n+\treturn false;\n \n-  /* Except in declared objects, references to trailing array members\n-     of structs and union objects are excluded because MEM_REF doesn't\n-     make it possible to identify the member where the reference\n-     originated.  */\n-  if (RECORD_OR_UNION_TYPE_P (reftype)\n-      && (!VAR_P (arg)\n-\t  || (DECL_EXTERNAL (arg) && array_at_struct_end_p (ref))))\n-    return false;\n+      /* Except in declared objects, references to trailing array members\n+\t of structs and union objects are excluded because MEM_REF doesn't\n+\t make it possible to identify the member where the reference\n+\t originated.  */\n+      if (RECORD_OR_UNION_TYPE_P (reftype)\n+\t  && (!VAR_P (arg)\n+\t      || (DECL_EXTERNAL (arg) && array_at_struct_end_p (ref))))\n+\treturn false;\n \n-  arrbounds[0] = 0;\n+      /* FIXME: Should this be 1 for Fortran?  */\n+      arrbounds[0] = 0;\n \n-  offset_int eltsize;\n-  if (TREE_CODE (reftype) == ARRAY_TYPE)\n-    {\n-      eltsize = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (reftype)));\n-      if (tree dom = TYPE_DOMAIN (reftype))\n+      if (TREE_CODE (reftype) == ARRAY_TYPE)\n \t{\n-\t  tree bnds[] = { TYPE_MIN_VALUE (dom), TYPE_MAX_VALUE (dom) };\n-\t  if (TREE_CODE (arg) == COMPONENT_REF)\n+\t  /* Set to the size of the array element (and adjust below).  */\n+\t  eltsize = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (reftype)));\n+\t  /* Use log2 of size to convert the array byte size in to its\n+\t     upper bound in elements.  */\n+\t  const offset_int eltsizelog2 = wi::floor_log2 (eltsize);\n+\t  if (tree dom = TYPE_DOMAIN (reftype))\n \t    {\n-\t      offset_int size = maxobjsize;\n-\t      if (tree fldsize = component_ref_size (arg))\n-\t\tsize = wi::to_offset (fldsize);\n-\t      arrbounds[1] = wi::lrshift (size, wi::floor_log2 (eltsize));\n+\t      tree bnds[] = { TYPE_MIN_VALUE (dom), TYPE_MAX_VALUE (dom) };\n+\t      if (TREE_CODE (arg) == COMPONENT_REF)\n+\t\t{\n+\t\t  offset_int size = maxobjsize;\n+\t\t  if (tree fldsize = component_ref_size (arg))\n+\t\t    size = wi::to_offset (fldsize);\n+\t\t  arrbounds[1] = wi::lrshift (size, eltsizelog2);\n+\t\t}\n+\t      else if (array_at_struct_end_p (arg) || !bnds[0] || !bnds[1])\n+\t\tarrbounds[1] = wi::lrshift (maxobjsize, eltsizelog2);\n+\t      else\n+\t\tarrbounds[1] = (wi::to_offset (bnds[1]) - wi::to_offset (bnds[0])\n+\t\t\t\t+ 1) * eltsize;\n \t    }\n-\t  else if (array_at_struct_end_p (arg) || !bnds[0] || !bnds[1])\n-\t    arrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));\n \t  else\n-\t    arrbounds[1] = (wi::to_offset (bnds[1]) - wi::to_offset (bnds[0])\n-\t\t\t    + 1) * eltsize;\n+\t    arrbounds[1] = wi::lrshift (maxobjsize, eltsizelog2);\n+\n+\t  /* Determine a tighter bound of the non-array element type.  */\n+\t  tree eltype = TREE_TYPE (reftype);\n+\t  while (TREE_CODE (eltype) == ARRAY_TYPE)\n+\t    eltype = TREE_TYPE (eltype);\n+\t  eltsize = wi::to_offset (TYPE_SIZE_UNIT (eltype));\n \t}\n       else\n-\tarrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));\n-\n-      /* Determine a tighter bound of the non-array element type.  */\n-      tree eltype = TREE_TYPE (reftype);\n-      while (TREE_CODE (eltype) == ARRAY_TYPE)\n-\teltype = TREE_TYPE (eltype);\n-      eltsize = wi::to_offset (TYPE_SIZE_UNIT (eltype));\n+\t{\n+\t  eltsize = 1;\n+\t  tree size = TYPE_SIZE_UNIT (reftype);\n+\t  if (VAR_P (arg))\n+\t    if (tree initsize = DECL_SIZE_UNIT (arg))\n+\t      if (tree_int_cst_lt (size, initsize))\n+\t\tsize = initsize;\n+\n+\t  arrbounds[1] = wi::to_offset (size);\n+\t}\n     }\n   else\n-    {\n-      eltsize = 1;\n-      tree size = TYPE_SIZE_UNIT (reftype);\n-      if (VAR_P (arg))\n-\tif (tree initsize = DECL_SIZE_UNIT (arg))\n-\t  if (tree_int_cst_lt (size, initsize))\n-\t    size = initsize;\n-\n-      arrbounds[1] = wi::to_offset (size);\n-    }\n+    return false;\n \n   offrange[0] += ioff;\n   offrange[1] += ioff;\n@@ -448,11 +635,25 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n      of an array) but always use the stricter bound in diagnostics. */\n   offset_int ubound = arrbounds[1];\n   if (ignore_off_by_one)\n-    ubound += 1;\n+    ubound += eltsize;\n \n-  if (arrbounds[0] == arrbounds[1]\n-      || offrange[0] >= ubound\n-      || offrange[1] < arrbounds[0])\n+  bool warned = false;\n+  /* Set if the lower bound of the subscript is out of bounds.  */\n+  const bool lboob = (arrbounds[0] == arrbounds[1]\n+\t\t      || offrange[0] >= ubound\n+\t\t      || offrange[1] < arrbounds[0]);\n+  /* Set if only the upper bound of the subscript is out of bounds.\n+     This can happen when using a bigger type to index into an array\n+     of a smaller type, as is common with unsigned char.  */\n+  tree axstype = TREE_TYPE (ref);\n+  offset_int axssize = 0;\n+  if (TREE_CODE (axstype) != UNION_TYPE)\n+    if (tree access_size = TYPE_SIZE_UNIT (axstype))\n+      if (TREE_CODE (access_size) == INTEGER_CST)\n+\taxssize = wi::to_offset (access_size);\n+\n+  const bool uboob = !lboob && offrange[0] + axssize > ubound;\n+  if (lboob || uboob)\n     {\n       /* Treat a reference to a non-array object as one to an array\n \t of a single element.  */\n@@ -471,8 +672,10 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \t  offrange[0] = offrange[0] / wi::to_offset (size);\n \t  offrange[1] = offrange[1] / wi::to_offset (size);\n \t}\n+    }\n \n-      bool warned;\n+  if (lboob)\n+    {\n       if (offrange[0] == offrange[1])\n \twarned = warning_at (location, OPT_Warray_bounds,\n \t\t\t     \"array subscript %wi is outside array bounds \"\n@@ -484,12 +687,66 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \t\t\t     \"array bounds of %qT\",\n \t\t\t     offrange[0].to_shwi (),\n \t\t\t     offrange[1].to_shwi (), reftype);\n-      if (warned && DECL_P (arg))\n+    }\n+  else if (uboob && !ignore_off_by_one)\n+    {\n+      tree backtype = reftype;\n+      if (alloc_stmt)\n+\t/* If the memory was dynamically allocated refer to it as if\n+\t   it were an untyped array of bytes.  */\n+\tbacktype = build_array_type_nelts (unsigned_char_type_node,\n+\t\t\t\t\t   arrbounds[1].to_uhwi ());\n+\n+      warned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t   \"array subscript %<%T[%wi]%> is partly \"\n+\t\t\t   \"outside array bounds of %qT\",\n+\t\t\t   axstype, offrange[0].to_shwi (), backtype);\n+    }\n+\n+  if (warned)\n+    {\n+      if (DECL_P (arg))\n \tinform (DECL_SOURCE_LOCATION (arg), \"while referencing %qD\", arg);\n+      else if (alloc_stmt)\n+\t{\n+\t  location_t loc = gimple_location (alloc_stmt);\n+\t  if (gimple_call_builtin_p (alloc_stmt, BUILT_IN_ALLOCA_WITH_ALIGN))\n+\t    {\n+\t      if (minbound == arrbounds[1])\n+\t\tinform (loc, \"referencing a variable length array \"\n+\t\t\t\"of size %wu\", minbound.to_uhwi ());\n+\t      else\n+\t\tinform (loc, \"referencing a variable length array \"\n+\t\t\t\"of size between %wu and %wu\",\n+\t\t\tminbound.to_uhwi (), arrbounds[1].to_uhwi ());\n+\t    }\n+\t  else if (tree fndecl = gimple_call_fndecl (alloc_stmt))\n+\t    {\n+\t      if (minbound == arrbounds[1])\n+\t\tinform (loc, \"referencing an object of size %wu \"\n+\t\t\t\"allocated by %qD\",\n+\t\t\tminbound.to_uhwi (), fndecl);\n+\t      else\n+\t\tinform (loc, \"referencing an object of size between \"\n+\t\t\t\"%wu and %wu allocated by %qD\",\n+\t\t\tminbound.to_uhwi (), arrbounds[1].to_uhwi (), fndecl);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree fntype = gimple_call_fntype (alloc_stmt);\n+\t      if (minbound == arrbounds[1])\n+\t\tinform (loc, \"referencing an object of size %wu \"\n+\t\t\t\"allocated by %qT\",\n+\t\t\tminbound.to_uhwi (), fntype);\n+\t      else\n+\t\tinform (loc, \"referencing an object of size between \"\n+\t\t\t\"%wu and %wu allocated by %qT\",\n+\t\t\tminbound.to_uhwi (), arrbounds[1].to_uhwi (), fntype);\n+\t    }\n+\t}\n \n-      if (warned)\n-\tTREE_NO_WARNING (ref) = 1;\n-      return warned;\n+      TREE_NO_WARNING (ref) = 1;\n+      return true;\n     }\n \n   if (warn_array_bounds < 2)"}, {"sha": "815badc0241a1927584344759f73198497e8a438", "filename": "gcc/testsuite/c-c++-common/Warray-bounds.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds.c?ref=3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "patch": "@@ -2,7 +2,7 @@\n    large index\n    { dg-do compile }\n    { dg-require-effective-target alloca }\n-   { dg-options \"-O2 -Warray-bounds -ftrack-macro-expansion=0\" }  */\n+   { dg-options \"-O2 -Warray-bounds -Wno-stringop-overread -ftrack-macro-expansion=0\" }  */\n \n #include \"../gcc.dg/range.h\"\n "}, {"sha": "0583d233c22f2efc91489b89799f346aea705eaf", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-63.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-63.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-63.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-63.c?ref=3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "patch": "@@ -0,0 +1,53 @@\n+/* PR middle-end/94195 - missing warning reading a smaller object via\n+   an lvalue of a larger type\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __INT16_TYPE__ int16_t;\n+typedef __SIZE_TYPE__  size_t;\n+\n+void* alloca (size_t);\n+\n+void sink (void*);\n+\n+\n+void byte_store_to_decl (void)\n+{\n+  struct S6 { char a[6]; } s;   // { dg-message \"referencing 's'\" }\n+\n+  char *p = (char*)&s;\n+\n+  p[0] = 0; p[1] = 1; p[2] = 2; p[3] = 3; p[4] = 4; p[5] = 5;\n+  p[6] = 6;                     // { dg-warning \"array subscript 6 is outside array bounds of 'struct S6\\\\\\[1]\" }\n+\n+  sink (&s);\n+}\n+\n+\n+void word_store_to_decl (void)\n+{\n+  struct S6 { char a[6]; } s;   // { dg-message \"referencing 's'\" }\n+\n+  char *p = (char*)&s;\n+\n+  int16_t *q = (int16_t*)(p + 1);\n+\n+  q[0] = 0; q[1] = 1;\n+  q[2] = 2;                     // { dg-warning \"array subscript 'int16_t {aka short int}\\\\\\[2]' is partly outside array bounds of 'struct S6\\\\\\[1]'\" }\n+\n+  sink (&s);\n+}\n+\n+\n+void word_store_to_alloc (void)\n+{\n+  struct S6 { char a[6]; } *p;\n+  p = alloca (sizeof *p);       // { dg-message \"referencing an object of size 6 allocated by 'alloca'\" }\n+\n+  int16_t *q = (int16_t*)((char*)p + 1);\n+\n+  q[0] = 0; q[1] = 1;\n+  q[2] = 2;                     // { dg-warning \"array subscript 'int16_t {aka short int}\\\\\\[2]' is partly outside array bounds of 'unsigned char\\\\\\[6]'\" }\n+\n+  sink (p);\n+}"}, {"sha": "88b88debff401d50e3416b655f031bee5ebbcd19", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-64.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-64.c?ref=3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "patch": "@@ -0,0 +1,60 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+\n+   Verify that out-of-bounds accesses to array arguments are diagnosed,\n+   both to ordinary array parameters with constant bounds and to array\n+   parameters declared static.  This is the converse of what PR 50584\n+   asks for.\n+\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Warray-parameter -Wno-vla-paramater\" } */\n+\n+#define NOIPA __attribute__  ((noipa))\n+\n+void sink (void*, ...);\n+\n+#define T(...) sink (0, __VA_ARGS__)\n+\n+\n+NOIPA void fca1 (char a[1])\n+{\n+  T (a[0]);\n+  T (a[1]);                   // { dg-warning \"-Warray-bounds\" }\n+}\n+\n+NOIPA void fcas1 (char a[static 1])\n+{\n+  T (a[0]);\n+  T (a[1]);                   // { dg-warning \"-Warray-bounds\" }\n+}\n+\n+NOIPA void fca2 (char a[2])\n+{\n+  T (a[0]); T (a[1]);\n+  T (a[2]);                   // { dg-warning \"-Warray-bounds\" }\n+}\n+\n+NOIPA void fcas2 (char a[static 2])\n+{\n+  T (a[0]); T (a[1]);\n+  T (a[2]);                   // { dg-warning \"-Warray-bounds\" }\n+}\n+\n+NOIPA void fca3 (char a[3])\n+{\n+  T (a[0]); T (a[1]); T (a[2]);\n+  T (a[3]);                   // { dg-warning \"-Warray-bounds\" }\n+}\n+\n+NOIPA void fcas3 (char a[static 3])\n+{\n+  T (a[0]); T (a[1]); T (a[2]);\n+  T (a[3]);                   // { dg-warning \"-Warray-bounds\" }\n+}\n+\n+\n+NOIPA void fca1_1 (char a[1][1])\n+{\n+  T (a[0][0]);\n+  T (a[0][1]);                // { dg-warning \"-Warray-bounds\" }\n+}"}, {"sha": "6bd50d0f8764db1c767ae7f97a95aa95d6ccd3de", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-65.c", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-65.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-65.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-65.c?ref=3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "patch": "@@ -0,0 +1,202 @@\n+/* PR middle-end/84051 - missing -Warray-bounds on an out-of-bounds access\n+   via an array pointer\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+void sink (void*, ...);\n+#define T(x) sink (0, x)\n+\n+void\n+test_note (int (*pia3)[3])    // { dg-message \"while referencing 'pia3'\" }\n+{\n+  int i = 0;\n+  T ((*pia3)[i++]);\n+  T ((*pia3)[i++]);\n+  T ((*pia3)[i++]);\n+  T ((*pia3)[i++]);           // { dg-warning \"array subscript 3 is (above|outside) array bounds of 'int\\\\\\[3]'\" }\n+  T ((*pia3)[i++]);           // { dg-warning \"array subscript 4 is (above|outside) array bounds of 'int\\\\\\[3]'\" }\n+\n+  {\n+    /* Regrettably, the following isn't diagnosed because it's represented\n+       the same as the possibly valid access below:\n+         MEM[(int *)a_1(D) + 36B] = 0;  */\n+    int *p0 = pia3[0];\n+    T (p0[3]);                // { dg-warning \"array subscript 3 is (above|outside) array bounds of 'int\\\\\\[3]'\" \"pr?????\" { xfail *-*-* } }\n+\n+    int *p1 = pia3[3];\n+    T (p1[0]);                // okay\n+  }\n+}\n+\n+void test_a1_cst (_Bool (*pba0)[0], char (*pca1)[1],\n+\t\t  short (*psa2)[2], int (*pia3)[3])\n+{\n+  T ((*pba0)[-1]);            // { dg-warning \"array subscript -1 is (above|outside) array bounds of '_Bool\\\\\\[0]'\" }\n+  T ((*pba0)[0]);             // { dg-warning \"array subscript 0 is (above|outside) array bounds of '_Bool\\\\\\[0]'\" }\n+  T ((*pba0)[1]);             // { dg-warning \"array subscript 1 is (above|outside) array bounds of '_Bool\\\\\\[0]'\" }\n+  T ((*pba0)[2]);             // { dg-warning \"array subscript 2 is (above|outside) array bounds of '_Bool\\\\\\[0]'\" }\n+  T ((*pba0)[12]);            // { dg-warning \"array subscript 12 is (above|outside) array bounds of '_Bool\\\\\\[0]'\" }\n+\n+  T ((*pca1)[-1]);            // { dg-warning \"array subscript -1 is (below|outside) array bounds of 'char\\\\\\[1]'\" }\n+  T ((*pca1)[0]);\n+  T ((*pca1)[1]);             // { dg-warning \"array subscript 1 is (above|outside) array bounds of 'char\\\\\\[1]'\" }\n+  T ((*pca1)[2]);             // { dg-warning \"array subscript 2 is (above|outside) array bounds of 'char\\\\\\[1]'\" }\n+  T ((*pca1)[123]);           // { dg-warning \"array subscript 123 is (above|outside) array bounds of 'char\\\\\\[1]'\" }\n+\n+  T ((*psa2)[-1]);            // { dg-warning \"array subscript -1 is (below|outside) array bounds of 'short int\\\\\\[2]'\" }\n+  T ((*psa2)[0]);\n+  T ((*psa2)[1]);\n+  T ((*psa2)[2]);             // { dg-warning \"array subscript 2 is (above|outside) array bounds of 'short int\\\\\\[2]'\" }\n+  T ((*psa2)[1234]);          // { dg-warning \"array subscript 1234 is (above|outside) array bounds of 'short int\\\\\\[2]'\" }\n+\n+  T ((*pia3)[-1]);            // { dg-warning \"array subscript -1 is (below|outside) array bounds of 'int\\\\\\[3]'\" }\n+  T ((*pia3)[0]);\n+  T ((*pia3)[1]);\n+  T ((*pia3)[2]);\n+  T ((*pia3)[3]);             // { dg-warning \"array subscript 3 is (above|outside) array bounds of 'int\\\\\\[3]'\" }\n+  T ((*pia3)[12345]);         // { dg-warning \"array subscript 12345 is (above|outside) array bounds of 'int\\\\\\[3]'\" }\n+}\n+\n+\n+void test_a2_cst (_Bool (*pba0_1)[0][1], char (*pca1_2)[1][2],\n+\t\t  short (*psa2_3)[2][3], int (*pia3_4)[3][4])\n+{\n+  T ((*pba0_1)[-1][-1]);        // { dg-warning \"array subscript -1 is (below|outside) array bounds of '_Bool\\\\\\[1]'\" }\n+  T ((*pba0_1)[-1][0]);         // { dg-warning \"array subscript -1 is (above|outside) array bounds of '_Bool\\\\\\[0]\\\\\\[1]'\" }\n+\n+  T ((*pba0_1)[0][-1]);         // { dg-warning \"array subscript -1 is (below|outside) array bounds of '_Bool\\\\\\[1]'\" }\n+  T ((*pba0_1)[0][0]);          // { dg-warning \"array subscript 0 is (above|outside) array bounds of '_Bool\\\\\\[0]\\\\\\[1]'\" }\n+  T ((*pba0_1)[0][1]);          // { dg-warning \"array subscript 1 is (above|outside) array bounds of '_Bool\\\\\\[1]'\" }\n+  T ((*pba0_1)[0][2]);          // { dg-warning \"array subscript 2 is (above|outside) array bounds of '_Bool\\\\\\[1]'\" }\n+  T ((*pba0_1)[0][12]);         // { dg-warning \"array subscript 12 is (above|outside) array bounds of '_Bool\\\\\\[1]'\" }\n+\n+  T ((*pba0_1)[1][-1]);         // { dg-warning \"array subscript -1 is (below|outside) array bounds of '_Bool\\\\\\[1]'\" }\n+  T ((*pba0_1)[1][0]);          // { dg-warning \"array subscript 1 is (above|outside) array bounds of '_Bool\\\\\\[0]\\\\\\[1]'\" }\n+  T ((*pba0_1)[1][1]);          // { dg-warning \"array subscript 1 is (above|outside) array bounds of '_Bool\\\\\\[1]'\" }\n+  T ((*pba0_1)[1][2]);          // { dg-warning \"array subscript 2 is (above|outside) array bounds of '_Bool\\\\\\[1]'\" }\n+  T ((*pba0_1)[1][12]);         // { dg-warning \"array subscript 12 is (above|outside) array bounds of '_Bool\\\\\\[1]'\" }\n+\n+\n+  T ((*pca1_2)[0][0]);\n+  T ((*pca1_2)[0][1]);\n+  T ((*pca1_2)[0][2]);          // { dg-warning \"array subscript 2 is (above|outside) array bounds of 'char\\\\\\[2]'\" }\n+\n+  T ((*pca1_2)[1][0]);          // { dg-warning \"array subscript 1 is (above|outside) array bounds of 'char\\\\\\[1]\\\\\\[2]'\" }\n+  T ((*pca1_2)[1][1]);          // { dg-warning \"array subscript 1 is (above|outside) array bounds of 'char\\\\\\[1]\\\\\\[2]'\" }\n+  T ((*pca1_2)[1][2]);          // { dg-warning \"array subscript 2 is (above|outside) array bounds of 'char\\\\\\[2]'\" }\n+\n+\n+  T ((*psa2_3)[0][0]);\n+  T ((*psa2_3)[0][1]);\n+  T ((*psa2_3)[0][2]);\n+  T ((*psa2_3)[0][3]);          // { dg-warning \"array subscript 3 is (above|outside) array bounds of 'short int\\\\\\[3]'\" }\n+\n+  T ((*psa2_3)[1][0]);\n+  T ((*psa2_3)[1][1]);\n+  T ((*psa2_3)[1][2]);\n+  T ((*psa2_3)[1][3]);          // { dg-warning \"array subscript 3 is (above|outside) array bounds of 'short int\\\\\\[3]'\" }\n+\n+  T ((*psa2_3)[2][0]);          // { dg-warning \"array subscript 2 is (above|outside) array bounds of 'short int\\\\\\[2]\\\\\\[3]'\" }\n+  T ((*psa2_3)[2][1]);          // { dg-warning \"array subscript 2 is (above|outside) array bounds of 'short int\\\\\\[2]\\\\\\[3]'\" }\n+  T ((*psa2_3)[2][2]);          // { dg-warning \"array subscript 2 is (above|outside) array bounds of 'short int\\\\\\[2]\\\\\\[3]'\" }\n+  T ((*psa2_3)[2][3]);          // { dg-warning \"array subscript 3 is (above|outside) array bounds of 'short int\\\\\\[3]'\" }\n+\n+\n+  T ((*pia3_4)[0][0]);\n+  T ((*pia3_4)[0][1]);\n+  T ((*pia3_4)[0][2]);\n+  T ((*pia3_4)[0][3]);\n+  T ((*pia3_4)[0][4]);          // { dg-warning \"array subscript 4 is (above|outside) array bounds of 'int\\\\\\[4]'\" }\n+\n+  T ((*pia3_4)[1][0]);\n+  T ((*pia3_4)[1][1]);\n+  T ((*pia3_4)[1][2]);\n+  T ((*pia3_4)[1][3]);\n+  T ((*pia3_4)[1][4]);          // { dg-warning \"array subscript 4 is (above|outside) array bounds of 'int\\\\\\[4]'\" }\n+\n+  T ((*pia3_4)[2][0]);\n+  T ((*pia3_4)[2][1]);\n+  T ((*pia3_4)[2][2]);\n+  T ((*pia3_4)[2][3]);\n+  T ((*pia3_4)[2][4]);          // { dg-warning \"array subscript 4 is (above|outside) array bounds of 'int\\\\\\[4]'\" }\n+\n+  T ((*pia3_4)[3][0]);          // { dg-warning \"array subscript 3 is (above|outside) array bounds of 'int\\\\\\[3]\\\\\\[4]'\" }\n+  T ((*pia3_4)[3][1]);          // { dg-warning \"array subscript 3 is (above|outside) array bounds of 'int\\\\\\[3]\\\\\\[4]'\" }\n+  T ((*pia3_4)[3][2]);          // { dg-warning \"array subscript 3 is (above|outside) array bounds of 'int\\\\\\[3]\\\\\\[4]'\" }\n+  T ((*pia3_4)[3][3]);          // { dg-warning \"array subscript 3 is (above|outside) array bounds of 'int\\\\\\[3]\\\\\\[4]'\" }\n+  T ((*pia3_4)[3][4]);          // { dg-warning \"array subscript 4 is (above|outside) array bounds of 'int\\\\\\[4]'\" }\n+}\n+\n+\n+typedef int IA4[4];\n+typedef IA4 IA3_4[3];\n+\n+void test_a2_var (IA3_4 *pia3_4)\n+{\n+  {\n+    IA4 *pia4 = &(*pia3_4)[0];\n+\n+    T ((*pia4)[-1]);            // { dg-warning \"array subscript -1 is (below|outside) array bounds of 'IA4'\" }\n+    T ((*pia4)[0]);\n+    T ((*pia4)[1]);\n+    T ((*pia4)[2]);\n+    T ((*pia4)[3]);\n+    T ((*pia4)[4]);             // { dg-warning \"array subscript 4 is (above|outside) array bounds of 'IA4'\" }\n+  }\n+\n+  {\n+    IA4 *pia4 = &(*pia3_4)[1];\n+\n+    T ((*pia4)[-1]);            // { dg-warning \"array subscript -1 is (below|outside) array bounds of 'IA4'\" }\n+    T ((*pia4)[0]);\n+    T ((*pia4)[1]);\n+    T ((*pia4)[2]);\n+    T ((*pia4)[3]);\n+    T ((*pia4)[4]);             // { dg-warning \"array subscript 4 is (above|outside) array bounds of 'IA4'\" }\n+  }\n+\n+  {\n+    IA4 *pia4 = &(*pia3_4)[2];\n+\n+    T ((*pia4)[-1]);            // { dg-warning \"array subscript -1 is (below|outside) array bounds of 'IA4'\" }\n+    T ((*pia4)[0]);\n+    T ((*pia4)[1]);\n+    T ((*pia4)[2]);\n+    T ((*pia4)[3]);\n+    T ((*pia4)[4]);             // { dg-warning \"array subscript 4 is (above|outside) array bounds of 'IA4'\" }\n+  }\n+\n+  {\n+    IA4 *pia4 = &(*pia3_4)[3];\n+\n+    T ((*pia4)[-1]);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    /* The following aren't diagnosed unless N itself is out of bounds\n+       because thanks to the MEM_REF they're indistinguishable from\n+       possibly valid accesses:\n+         MEM[(int[4] *)pia3_4_2(D) + 48B][N];  */\n+    T ((*pia4)[0]);             // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+    T ((*pia4)[1]);             // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+    T ((*pia4)[2]);             // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+    T ((*pia4)[3]);             // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+    T ((*pia4)[4]);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+}\n+\n+\n+struct S { IA3_4 *pia3_4; };\n+typedef struct S S5[5];\n+typedef S5 S5_7[7];\n+\n+void test_s5_7 (S5_7 *ps5_7)\n+{\n+  {\n+    S5 *ps5 = &(*ps5_7)[0];\n+    T ((*ps5)[0]);\n+    T ((*(*ps5)[0].pia3_4)[0][0]);\n+    T ((*(*ps5)[0].pia3_4)[2][3]);\n+    T ((*(*ps5)[0].pia3_4)[2][4]);    // { dg-warning \"array subscript 4 is above array bounds of 'IA4'\" }\n+\n+    T ((*(*ps5)[1].pia3_4)[2][3]);\n+    T ((*(*ps5)[5].pia3_4)[2][3]);    // { dg-warning \"array subscript 5 is above array bounds of 'S5'\" }\n+  }\n+}"}, {"sha": "d9bb2a29ca4a17eaf9c9340daf3fe7247208676a", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-66.c", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-66.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-66.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-66.c?ref=3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "patch": "@@ -0,0 +1,256 @@\n+/* PR middle-end/82608 - missing -Warray-bounds on an out-of-bounds VLA index\n+ { dg-do compile }\n+ { dg-options \"-O2 -Wall -Wno-uninitialized -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+typedef __INT16_TYPE__ int16_t;\n+\n+#define alloca(n) __builtin_alloca (n)\n+\n+void* calloc (size_t, size_t);\n+void* malloc (size_t);\n+\n+void sink (void*, ...);\n+#define sink(...) sink (0, __VA_ARGS__)\n+\n+#define T(x) (sink (x))\n+\n+__attribute__ ((alloc_size (1))) void* alloc (size_t);\n+\n+\n+void test_alloca_cst (void)\n+{\n+  {\n+    char *p = alloca (1);\n+    sink (p);\n+    T (p[0]);\n+    T (p[1]);                 // { dg-warning \"subscript 1 is outside array bounds of 'char\\\\\\[1\\\\\\]'\" }\n+  }\n+\n+  {\n+    char *p = alloca (2);\n+    sink (p);\n+    T (p[0]), T (p[1]);\n+    T (p[2]);                 // { dg-warning \"subscript 2 is outside array bounds of 'char\\\\\\[2\\\\\\]'\" }\n+  }\n+\n+  {\n+    char *p = alloca (3);\n+    sink (p);\n+    T (p[0]), T (p[1]), T (p[2]);\n+    T (p[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'char\\\\\\[3\\\\\\]'\" }\n+  }\n+}\n+\n+\n+void test_alloca_char_range (int i, unsigned n, size_t sz)\n+{\n+  {\n+    // Be sure to exercise signed as well as unsigned arguments.\n+    char *p = alloca (i);\n+    sink (p);\n+    T (p[0]), T (p[1]), T (p[12345]);\n+    T (p[-1]);                // { dg-warning \"subscript -1 is outside array bounds of 'char\\\\\\[\" }\n+  }\n+\n+  {\n+    char *p = alloca (n);\n+    sink (p);\n+    T (p[0]), T (p[1]), T (p[12345]);\n+    T (p[-1]);                // { dg-warning \"subscript -1 is outside array bounds of 'char\\\\\\[\" }\n+  }\n+\n+  {\n+    char *p = alloca (sz);\n+    sink (p);\n+    T (p[0]), T (p[1]), T (p[23456]);\n+    T (p[-1]);                // { dg-warning \"subscript -1 is outside array bounds of 'char\\\\\\[\" }\n+  }\n+\n+  {\n+    char *p = alloca (UR (0, 1));\n+    sink (p);\n+    T (p[0]);\n+    T (p[1]);                 // { dg-warning \"subscript 1 is outside array bounds of 'char\\\\\\[1\\\\\\]'\" }\n+  }\n+\n+  {\n+    char *p = alloca (UR (0, 2));\n+    sink (p);\n+    sink (p[0], p[1]);\n+    sink (p[2]);              // { dg-warning \"subscript 2 is outside array bounds of 'char\\\\\\[2\\\\\\]'\" }\n+  }\n+\n+  {\n+    char *p = alloca (UR (0, 3));\n+    sink (p);\n+    T (p[0]), T (p[1]), T (p[2]);\n+    T (p[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'char\\\\\\[3\\\\\\]'\" }\n+  }\n+\n+  {\n+    char *p = alloca (UR (1, 3));\n+    sink (p);\n+    T (p[0]), T (p[1]), T (p[2]);\n+    T (p[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'char\\\\\\[3\\\\\\]'\" }\n+  }\n+\n+  {\n+    char *p = alloca (UR (2, 3));\n+    sink (p);\n+    T (p[0]), T (p[1]), T (p[2]);\n+    T (p[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'char\\\\\\[3\\\\\\]'\" }\n+  }\n+}\n+\n+\n+void test_alloca_int16_range (unsigned n)\n+{\n+  int16_t *p;\n+  {\n+    p = alloca (n);           // { dg-message \"allocated by \" }\n+    sink (p);\n+    T (p[0]), T (p[1]), T (p[12345]);\n+    T (p[-1]);                // { dg-warning \"subscript -1 is outside array bounds of 'int16_t\\\\\\[\" }\n+  }\n+\n+  {\n+    p = alloca (UR (0, 1));   // { dg-message \"object of size between 0 and 1 allocated by '__builtin_alloca'\" }\n+    sink (p);\n+    T (p[0]);                 // { dg-warning \"subscript 'int16_t {aka short int}\\\\\\[0\\\\\\]' is partly outside array bounds of 'unsigned char\\\\\\[1]'\" }\n+    T (p[1]);                 // { dg-warning \"subscript 1 is outside array bounds of 'int16_t\\\\\\[0]'\" }\n+  }\n+\n+  {\n+    p = alloca (UR (0, 2));   // { dg-message \"object of size between 0 and 2 allocated by '__builtin_alloca'\" }\n+    sink (p);\n+    sink (p[0]);\n+    sink (p[1]);              // { dg-warning \"subscript 1 is outside array bounds of 'int16_t\\\\\\[1]'\" }\n+    sink (p[2]);              // { dg-warning \"subscript 2 is outside array bounds of 'int16_t\\\\\\[1\\\\\\]'\" }\n+  }\n+\n+  {\n+    p = alloca (UR (0, 3));   // { dg-message \"object of size between 0 and 3 allocated by '__builtin_alloca'\" }\n+    sink (p);\n+    T (p[0]);\n+    T (p[1]);                 // { dg-warning \"subscript 'int16_t {aka short int}\\\\\\[1\\\\\\]' is partly outside array bounds of 'unsigned char\\\\\\[3]'\" }\n+    T (p[2]);                 // { dg-warning \"subscript 2 is outside array bounds of 'int16_t\\\\\\[1\\\\\\]'\" }\n+    T (p[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'int16_t\\\\\\[1\\\\\\]'\" }\n+  }\n+\n+  {\n+    p = alloca (UR (1, 3));    // { dg-message \"object of size between 1 and 3 allocated by '__builtin_alloca'\" }\n+    sink (p);\n+    T (p[0]);\n+    T (p[1]);                 // { dg-warning \"subscript 'int16_t {aka short int}\\\\\\[1\\\\\\]' is partly outside array bounds of 'unsigned char\\\\\\[3]'\" }\n+    T (p[2]);                 // { dg-warning \"subscript 2 is outside array bounds of 'int16_t\\\\\\[1\\\\\\]'\" }\n+    T (p[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'int16_t\\\\\\[1\\\\\\]'\" }\n+  }\n+\n+  {\n+    p = alloca (UR (2, 3));    // { dg-message \"object of size between 2 and 3 allocated by '__builtin_alloca'\" }\n+    sink (p);\n+    T (p[0]);\n+    T (p[1]);                 // { dg-warning \"subscript 'int16_t {aka short int}\\\\\\[1\\\\\\]' is partly outside array bounds of 'unsigned char\\\\\\[3]'\" }\n+    T (p[2]);                 // { dg-warning \"subscript 2 is outside array bounds of 'int16_t\\\\\\[1\\\\\\]'\" }\n+    T (p[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'int16_t\\\\\\[1\\\\\\]'\" }\n+  }\n+\n+  {\n+    p = alloca (UR (3, 4));    // { dg-message \"object of size between 3 and 4 allocated by '__builtin_alloca'\" }\n+    sink (p);\n+    T (p[0]);\n+    T (p[1]);\n+    T (p[2]);                 // { dg-warning \"subscript 2 is outside array bounds of 'int16_t\\\\\\[2\\\\\\]'\" }\n+    T (p[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'int16_t\\\\\\[2\\\\\\]'\" }\n+  }\n+}\n+\n+\n+void test_vla_cst (void)\n+{\n+  int n = 1;\n+  {\n+    char a[n];\n+    sink (a);\n+    T (a[0]);\n+    T (a[1]);                 // { dg-warning \"subscript 1 is (above|outside) array bounds \" }\n+  }\n+\n+  {\n+    n = 2;\n+    char a[n];\n+    sink (a);\n+    T (a[0]), T (a[1]);\n+    T (a[2]);                 // { dg-warning \"subscript 2 is (above|outside) array bounds \" }\n+  }\n+\n+  {\n+    n = 3;\n+    char a[n], *p = a;\n+    sink (p);\n+    T (p[0]), T (p[1]), T (p[2]);\n+    T (p[3]);                 // { dg-warning \"subscript 3 is (above|outside) array bounds \" }\n+  }\n+}\n+\n+\n+void test_vla_char_range (int i, unsigned n, size_t sz)\n+{\n+  {\n+    char a[i];\n+    sink (a);\n+    T (a[0]), T (a[1]), T (a[12345]);\n+    T (a[-1]);                // { dg-warning \"subscript -1 is (below|outside) array bounds of 'char\\\\\\[\" }\n+  }\n+\n+  {\n+    char a[n];\n+    sink (a);\n+    T (a[0]), T (a[1]), T (a[12345]);\n+    T (a[-1]);                // { dg-warning \"subscript -1 is (below|outside) array bounds of 'char\\\\\\[\" }\n+  }\n+\n+  {\n+    char a[sz];\n+    sink (a);\n+    T (a[0]), T (a[1]), T (a[23456]);\n+    T (a[-1]);                // { dg-warning \"subscript -1 is (below|outside) array bounds of 'char\\\\\\[\" }\n+  }\n+\n+  {\n+    char a[UR (0, 1)];\n+    sink (a);\n+    T (a[0]);\n+    T (a[1]);                 // { dg-warning \"subscript 1 is outside array bounds of 'char\\\\\\[1\\\\\\]'\" \"pr82608\" { xfail *-*-* } }\n+  }\n+\n+  {\n+    char a[UR (0, 2)];\n+    sink (a);\n+    sink (a[0], a[1]);\n+    sink (a[2]);              // { dg-warning \"subscript 2 is outside array bounds of 'char\\\\\\[2\\\\\\]'\" \"pr82608\" { xfail *-*-* } }\n+  }\n+\n+  {\n+    char a[UR (0, 3)];\n+    sink (a);\n+    T (a[0]), T (a[1]), T (a[2]);\n+    T (a[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'char\\\\\\[3\\\\\\]'\" \"pr82608\" { xfail *-*-* } }\n+  }\n+\n+  {\n+    char a[UR (1, 3)];\n+    sink (a);\n+    T (a[0]), T (a[1]), T (a[2]);\n+    T (a[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'char\\\\\\[3\\\\\\]'\" \"pr82608\" { xfail *-*-* } }\n+  }\n+\n+  {\n+    char a[UR (2, 3)];\n+    sink (a);\n+    T (a[0]), T (a[1]), T (a[2]);\n+    T (a[3]);                 // { dg-warning \"subscript 3 is outside array bounds of 'char\\\\\\[3\\\\\\]'\" \"pr82608\" { xfail *-*-* } }\n+  }\n+}"}, {"sha": "a9b9ff7d2ab25c76d9396943a64c324e9418add5", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-67.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-67.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-67.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-67.c?ref=3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "patch": "@@ -0,0 +1,36 @@\n+/* Verify warnings fpr accesses to trailing one-element array members\n+   of a struct that's a member of either a struct or a union.  Both\n+   are obviously undefined but GCC relies on these hacks so the test\n+   verifies that -Warray-bounds doesn't trigger for it.\n+   { do-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+\n+typedef union tree_node *tree;\n+\n+struct tree_exp { int i; tree operands[1]; };\n+\n+union tree_node\n+{\n+  struct tree_exp exp;\n+};\n+\n+tree test_nowarn (tree t)\n+{\n+  return t->exp.operands[3];    // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+typedef struct shrub_node *shrub;\n+\n+struct shrub_exp { int i; shrub operands[1]; };\n+\n+struct shrub_node\n+{\n+  struct shrub_exp exp;\n+};\n+\n+shrub test_warn (shrub s)\n+{\n+  return s->exp.operands[3];    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr96346\" { xfail *-*-* } }\n+}"}, {"sha": "56a827ab5273e8f61954fafe98c2eed8cb0b1458", "filename": "gcc/testsuite/gcc.dg/Wbuiltin-declaration-mismatch-9.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f9a497d1b0dd9da87908a11b59bf364ad40ddca/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-9.c?ref=3f9a497d1b0dd9da87908a11b59bf364ad40ddca", "patch": "@@ -11,5 +11,5 @@ void a (void)\n \t  );\n }\n \n-/* The scanf call may also trigger:\n-   { dg-prune-output \"-Wstringop-overflow\" } */\n+/* The invalid scanf call may also trigger:\n+   { dg-prune-output \"accessing 4 bytes in a region of size 1\" } */"}]}