{"sha": "3168cb992791efed6b803d0f44a37528245b7a96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE2OGNiOTkyNzkxZWZlZDZiODAzZDBmNDRhMzc1MjgyNDViN2E5Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-02-03T03:03:43Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-02-03T03:03:43Z"}, "message": "tree.c (commutative_tree_code, [...]): New functions.\n\n\n\t* tree.c (commutative_tree_code, associative_tree_code): New\n\tfunctions.\n\t(iterative_hash_expr): Use commutative_tree_code.\n\t* tree.h (commutative_tree_code, associative_tree_code): Declare.\n\t* fold-const.c (operand_equal_p): Use commutative_tree_code\n\trather than inlining the commutativity check.\n\t(fold): Likewise.\n\nCo-Authored-By: Roger Sayle <roger@eyesopen.com>\n\nFrom-SVN: r77152", "tree": {"sha": "f84736766435151bb3235057dcf3f0fb892023ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f84736766435151bb3235057dcf3f0fb892023ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3168cb992791efed6b803d0f44a37528245b7a96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3168cb992791efed6b803d0f44a37528245b7a96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3168cb992791efed6b803d0f44a37528245b7a96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3168cb992791efed6b803d0f44a37528245b7a96/comments", "author": null, "committer": null, "parents": [{"sha": "4e0e4a4995ab0d9c2dc284d62f7c7d546e43f399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e0e4a4995ab0d9c2dc284d62f7c7d546e43f399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e0e4a4995ab0d9c2dc284d62f7c7d546e43f399"}], "stats": {"total": 78, "additions": 65, "deletions": 13}, "files": [{"sha": "a467635fd04c843a48fd6f230605d2fa91eb1792", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3168cb992791efed6b803d0f44a37528245b7a96/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3168cb992791efed6b803d0f44a37528245b7a96/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3168cb992791efed6b803d0f44a37528245b7a96", "patch": "@@ -1,3 +1,14 @@\n+2004-02-02  Jeff Law  <law@redhat.com>\n+\t    Roger Sayle  <roger@eyesopen.com>\n+\n+\t* tree.c (commutative_tree_code, associative_tree_code): New\n+\tfunctions.\n+\t(iterative_hash_expr): Use commutative_tree_code.\n+\t* tree.h (commutative_tree_code, associative_tree_code): Declare.\n+\t* fold-const.c (operand_equal_p): Use commutative_tree_code\n+\trather than inlining the commutativity check.\n+\t(fold): Likewise.\n+\n 2004-02-02  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* system.h (FUNCTION_ARG_KEEP_AS_REFERENCE): Poison."}, {"sha": "264e5f01f2862e3983fc839608ee905e22f8399e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3168cb992791efed6b803d0f44a37528245b7a96/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3168cb992791efed6b803d0f44a37528245b7a96/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3168cb992791efed6b803d0f44a37528245b7a96", "patch": "@@ -833,7 +833,6 @@ negate_mathfn_p (enum built_in_function code)\n   return false;\n }\n \n-\n /* Determine whether an expression T can be cheaply negated using\n    the function negate_expr.  */\n \n@@ -2105,12 +2104,7 @@ operand_equal_p (tree arg0, tree arg1, int only_const)\n \treturn 1;\n \n       /* For commutative ops, allow the other order.  */\n-      return ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MULT_EXPR\n-\t       || TREE_CODE (arg0) == MIN_EXPR || TREE_CODE (arg0) == MAX_EXPR\n-\t       || TREE_CODE (arg0) == BIT_IOR_EXPR\n-\t       || TREE_CODE (arg0) == BIT_XOR_EXPR\n-\t       || TREE_CODE (arg0) == BIT_AND_EXPR\n-\t       || TREE_CODE (arg0) == NE_EXPR || TREE_CODE (arg0) == EQ_EXPR)\n+      return (commutative_tree_code (TREE_CODE (arg0))\n \t      && operand_equal_p (TREE_OPERAND (arg0, 0),\n \t\t\t\t  TREE_OPERAND (arg1, 1), 0)\n \t      && operand_equal_p (TREE_OPERAND (arg0, 1),\n@@ -5299,9 +5293,7 @@ fold (tree expr)\n \n   /* If this is a commutative operation, and ARG0 is a constant, move it\n      to ARG1 to reduce the number of tests below.  */\n-  if ((code == PLUS_EXPR || code == MULT_EXPR || code == MIN_EXPR\n-       || code == MAX_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR\n-       || code == BIT_AND_EXPR)\n+  if (commutative_tree_code (code)\n       && tree_swap_operands_p (arg0, arg1, true))\n     return fold (build (code, type, arg1, arg0));\n "}, {"sha": "47ae7ba5e950f888f820b95340b7ec6236c3c115", "filename": "gcc/tree.c", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3168cb992791efed6b803d0f44a37528245b7a96/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3168cb992791efed6b803d0f44a37528245b7a96/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3168cb992791efed6b803d0f44a37528245b7a96", "patch": "@@ -3538,6 +3538,55 @@ compare_tree_int (tree t, unsigned HOST_WIDE_INT u)\n     return 1;\n }\n \n+/* Return true if CODE represents an associative tree code.  Otherwise\n+   return false.  */\n+bool\n+associative_tree_code (enum tree_code code)\n+{\n+  switch (code)\n+    {\n+    case BIT_IOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_XOR_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      return true;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* Return true if CODE represents an commutative tree code.  Otherwise\n+   return false.  */\n+bool\n+commutative_tree_code (enum tree_code code)\n+{\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+    case MULT_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case NE_EXPR:\n+    case EQ_EXPR:\n+      return true;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n /* Generate a hash value for an expression.  This can be used iteratively\n    by passing a previous result as the \"val\" argument.\n \n@@ -3595,9 +3644,7 @@ iterative_hash_expr (tree t, hashval_t val)\n \t  || code == NON_LVALUE_EXPR)\n \tval = iterative_hash_object (TREE_TYPE (t), val);\n \n-      if (code == PLUS_EXPR || code == MULT_EXPR || code == MIN_EXPR\n-\t  || code == MAX_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR\n-\t  || code == BIT_AND_EXPR || code == NE_EXPR || code == EQ_EXPR)\n+      if (commutative_tree_code (code))\n \t{\n \t  /* It's a commutative expression.  We want to hash it the same\n \t     however it appears.  We do this by first hashing both operands"}, {"sha": "a69678285ee669d48194163a4dcaf2f9af3f5869", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3168cb992791efed6b803d0f44a37528245b7a96/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3168cb992791efed6b803d0f44a37528245b7a96/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3168cb992791efed6b803d0f44a37528245b7a96", "patch": "@@ -2713,6 +2713,8 @@ extern tree get_callee_fndecl (tree);\n extern void change_decl_assembler_name (tree, tree);\n extern int type_num_arguments (tree);\n extern tree lhd_unsave_expr_now (tree);\n+extern bool associative_tree_code (enum tree_code);\n+extern bool commutative_tree_code (enum tree_code);\n \n \f\n /* In stmt.c */"}]}