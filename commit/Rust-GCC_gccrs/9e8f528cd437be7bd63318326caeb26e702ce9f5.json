{"sha": "9e8f528cd437be7bd63318326caeb26e702ce9f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU4ZjUyOGNkNDM3YmU3YmQ2MzMxODMyNmNhZWIyNmU3MDJjZTlmNQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2000-09-14T17:42:48Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2000-09-14T17:42:48Z"}, "message": "reload.c (find_reloads_address_1): Generate reloads for auto_inc pseudos that refer to the original pseudos...\n\n* reload.c (find_reloads_address_1): Generate reloads for auto_inc\npseudos that refer to the original pseudos, not only to their\nequivalent memory locations.\n\nFrom-SVN: r36413", "tree": {"sha": "b0d56ca7b3f344d846191da5b264e612479a155e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0d56ca7b3f344d846191da5b264e612479a155e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e8f528cd437be7bd63318326caeb26e702ce9f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e8f528cd437be7bd63318326caeb26e702ce9f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e8f528cd437be7bd63318326caeb26e702ce9f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e8f528cd437be7bd63318326caeb26e702ce9f5/comments", "author": null, "committer": null, "parents": [{"sha": "fe7a8445101cfadcda67b45eb1ad0322df8976ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe7a8445101cfadcda67b45eb1ad0322df8976ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe7a8445101cfadcda67b45eb1ad0322df8976ae"}], "stats": {"total": 21, "additions": 12, "deletions": 9}, "files": [{"sha": "fb8152f34b3185186c52b938dfcf3339603c4bc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e8f528cd437be7bd63318326caeb26e702ce9f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e8f528cd437be7bd63318326caeb26e702ce9f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e8f528cd437be7bd63318326caeb26e702ce9f5", "patch": "@@ -1,3 +1,9 @@\n+2000-09-14  Alexandre Oliva  <aoliva@redhat.com>, Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* reload.c (find_reloads_address_1): Generate reloads for auto_inc\n+\tpseudos that refer to the original pseudos, not only to their\n+\tequivalent memory locations.\n+\n Thu Sep 14 12:10:16 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* expr.c (expand_expr, case COMPONENT_EXPR): Copy memory attributes"}, {"sha": "3fc2bfe98cc3dfb443b6f5a77b78c4ea34ab31ed", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e8f528cd437be7bd63318326caeb26e702ce9f5/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e8f528cd437be7bd63318326caeb26e702ce9f5/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9e8f528cd437be7bd63318326caeb26e702ce9f5", "patch": "@@ -5276,21 +5276,18 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t&& ((*insn_data[icode].operand[1].predicate)\n \t\t\t    (equiv, Pmode))))\n \t\t{\n-\t\t  loc = &XEXP (x, 0);\n+\t\t  /* We use the original pseudo for loc, so that\n+\t\t     emit_reload_insns() knows which pseudo this\n+\t\t     reload refers to and updates the pseudo rtx, not\n+\t\t     its equivalent memory location, as well as the\n+\t\t     corresponding entry in reg_last_reload_reg.  */\n+\t\t  loc = &XEXP (x_orig, 0);\n \t\t  x = XEXP (x, 0);\n \t\t  reloadnum\n \t\t    = push_reload (x, x, loc, loc,\n \t\t\t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n \t\t\t\t   GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t\t   opnum, RELOAD_OTHER);\n-\n-\t\t  /* If we created a new MEM based on reg_equiv_mem[REGNO], then\n-\t\t     LOC above is part of the new MEM, not the MEM in INSN.\n-\n-\t\t     We must also replace the address of the MEM in INSN.  */\n-\t\t  if (&XEXP (x_orig, 0) != loc)\n-\t\t    push_replacement (&XEXP (x_orig, 0), reloadnum, VOIDmode);\n-\n \t\t}\n \t      else\n \t\t{"}]}