{"sha": "68e82b83349899173cd32116c387c7b56c917341", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhlODJiODMzNDk4OTkxNzNjZDMyMTE2YzM4N2M3YjU2YzkxNzM0MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-07-30T16:42:05Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-07-30T16:42:05Z"}, "message": "fold-const.c: Fix comment typos.\n\n\t* fold-const.c: Fix comment typos.\n\t* gcse.c: Likewise.\n\t* reload1.c: Likewise.\n\nFrom-SVN: r55876", "tree": {"sha": "62810ecc3fe20d29c3376905a31212e146a1d5df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62810ecc3fe20d29c3376905a31212e146a1d5df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68e82b83349899173cd32116c387c7b56c917341", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e82b83349899173cd32116c387c7b56c917341", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e82b83349899173cd32116c387c7b56c917341", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e82b83349899173cd32116c387c7b56c917341/comments", "author": null, "committer": null, "parents": [{"sha": "fe6b547a28692c1cbc81bc64aa3ed4f32a2083b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe6b547a28692c1cbc81bc64aa3ed4f32a2083b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe6b547a28692c1cbc81bc64aa3ed4f32a2083b8"}], "stats": {"total": 12, "additions": 9, "deletions": 3}, "files": [{"sha": "42ffe447367b7a78401ec8ea8a90efac8c92872a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e82b83349899173cd32116c387c7b56c917341/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e82b83349899173cd32116c387c7b56c917341/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68e82b83349899173cd32116c387c7b56c917341", "patch": "@@ -1,3 +1,9 @@\n+2002-07-30  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* fold-const.c: Fix comment typos.\n+\t* gcse.c: Likewise.\n+\t* reload1.c: Likewise.\n+\n 2002-07-29  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/rs6000.md: Disallow CCEQ compare with crnor/crnot"}, {"sha": "7751e6587018ff0fb25c54bcad17a41418942d2e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e82b83349899173cd32116c387c7b56c917341/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e82b83349899173cd32116c387c7b56c917341/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=68e82b83349899173cd32116c387c7b56c917341", "patch": "@@ -2716,7 +2716,7 @@ sign_bit_p (exp, val)\n   int width;\n   tree t;\n \n-  /* Tree EXP must have a integral type.  */\n+  /* Tree EXP must have an integral type.  */\n   t = TREE_TYPE (exp);\n   if (! INTEGRAL_TYPE_P (t))\n     return NULL_TREE;"}, {"sha": "3ad8a750366a48d522ac7005acecad5f6f7d9b8f", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e82b83349899173cd32116c387c7b56c917341/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e82b83349899173cd32116c387c7b56c917341/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=68e82b83349899173cd32116c387c7b56c917341", "patch": "@@ -5850,7 +5850,7 @@ static sbitmap *hoist_exprs;\n dominance_info dominators;\n \n /* ??? We could compute post dominators and run this algorithm in\n-   reverse to to perform tail merging, doing so would probably be\n+   reverse to perform tail merging, doing so would probably be\n    more effective than the tail merging code in jump.c.\n \n    It's unclear if tail merging could be run in parallel with"}, {"sha": "894df877046dd055dee909a80fa3ef21ef29a92e", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e82b83349899173cd32116c387c7b56c917341/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e82b83349899173cd32116c387c7b56c917341/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=68e82b83349899173cd32116c387c7b56c917341", "patch": "@@ -4321,7 +4321,7 @@ clear_reload_reg_in_use (regno, opnum, type, mode)\n       abort ();\n     }\n   /* We resolve conflicts with remaining reloads of the same type by\n-     excluding the intervals of of reload registers by them from the\n+     excluding the intervals of reload registers by them from the\n      interval of freed reload registers.  Since we only keep track of\n      one set of interval bounds, we might have to exclude somewhat\n      more than what would be necessary if we used a HARD_REG_SET here."}]}