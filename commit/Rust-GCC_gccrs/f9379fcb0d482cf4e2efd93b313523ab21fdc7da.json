{"sha": "f9379fcb0d482cf4e2efd93b313523ab21fdc7da", "node_id": "C_kwDOANBUbNoAKGY5Mzc5ZmNiMGQ0ODJjZjRlMmVmZDkzYjMxMzUyM2FiMjFmZGM3ZGE", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-12-04T23:46:17Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-12-09T16:51:47Z"}, "message": "Move bndrng from access_ref to access_data.\n\ngcc/ChangeLog:\n\n\t* gimple-ssa-warn-access.cc (check_access): Adjust to member name\n\tchange.\n\t(pass_waccess::check_strncmp): Same.\n\t* pointer-query.cc (access_ref::access_ref): Remove arguments.\n\tSimpilfy.\n\t(access_data::access_data): Define new ctors.\n\t(access_data::set_bound): Define new member function.\n\t(compute_objsize_r): Remove unnecessary code.\n\t* pointer-query.h (struct access_ref): Remove ctor arguments.\n\t(struct access_data): Declare ctor overloads.\n\t(access_data::dst_bndrng): New member.\n\t(access_data::src_bndrng): New member.", "tree": {"sha": "33fd1a4743decaacb66136ea14d34963f9136069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33fd1a4743decaacb66136ea14d34963f9136069"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9379fcb0d482cf4e2efd93b313523ab21fdc7da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9379fcb0d482cf4e2efd93b313523ab21fdc7da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9379fcb0d482cf4e2efd93b313523ab21fdc7da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9379fcb0d482cf4e2efd93b313523ab21fdc7da/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "425a39fd4effd9604af9f5f0780d209036d6e886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425a39fd4effd9604af9f5f0780d209036d6e886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/425a39fd4effd9604af9f5f0780d209036d6e886"}], "stats": {"total": 140, "additions": 79, "deletions": 61}, "files": [{"sha": "05b8d91b71dbf91bced150eebd8bc31e2bdefb3d", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9379fcb0d482cf4e2efd93b313523ab21fdc7da/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9379fcb0d482cf4e2efd93b313523ab21fdc7da/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=f9379fcb0d482cf4e2efd93b313523ab21fdc7da", "patch": "@@ -1337,10 +1337,10 @@ check_access (GimpleOrTree exp, tree dstwrite,\n   if (!dstsize)\n     dstsize = maxobjsize;\n \n-  /* Set RANGE to that of DSTWRITE if non-null, bounded by PAD->DST.BNDRNG\n+  /* Set RANGE to that of DSTWRITE if non-null, bounded by PAD->DST_BNDRNG\n      if valid.  */\n   gimple *stmt = pad ? pad->stmt : nullptr;\n-  get_size_range (rvals, dstwrite, stmt, range, pad ? pad->dst.bndrng : NULL);\n+  get_size_range (rvals, dstwrite, stmt, range, pad ? pad->dst_bndrng : NULL);\n \n   tree func = get_callee_fndecl (exp);\n   /* Read vs write access by built-ins can be determined from the const\n@@ -1432,9 +1432,9 @@ check_access (GimpleOrTree exp, tree dstwrite,\n      of an object.  */\n   if (maxread)\n     {\n-      /* Set RANGE to that of MAXREAD, bounded by PAD->SRC.BNDRNG if\n+      /* Set RANGE to that of MAXREAD, bounded by PAD->SRC_BNDRNG if\n \t PAD is nonnull and BNDRNG is valid.  */\n-      get_size_range (rvals, maxread, stmt, range, pad ? pad->src.bndrng : NULL);\n+      get_size_range (rvals, maxread, stmt, range, pad ? pad->src_bndrng : NULL);\n \n       location_t loc = get_location (exp);\n       tree size = dstsize;\n@@ -1479,12 +1479,12 @@ check_access (GimpleOrTree exp, tree dstwrite,\n       && (pad->src.offrng[1] < 0\n \t  || pad->src.offrng[0] <= pad->src.offrng[1]))\n     {\n-      /* Set RANGE to that of MAXREAD, bounded by PAD->SRC.BNDRNG if\n+      /* Set RANGE to that of MAXREAD, bounded by PAD->SRC_BNDRNG if\n \t PAD is nonnull and BNDRNG is valid.  */\n-      get_size_range (rvals, maxread, stmt, range, pad ? pad->src.bndrng : NULL);\n+      get_size_range (rvals, maxread, stmt, range, pad ? pad->src_bndrng : NULL);\n       /* Set OVERREAD for reads starting just past the end of an object.  */\n-      overread = pad->src.sizrng[1] - pad->src.offrng[0] < pad->src.bndrng[0];\n-      range[0] = wide_int_to_tree (sizetype, pad->src.bndrng[0]);\n+      overread = pad->src.sizrng[1] - pad->src.offrng[0] < pad->src_bndrng[0];\n+      range[0] = wide_int_to_tree (sizetype, pad->src_bndrng[0]);\n       slen = size_zero_node;\n     }\n \n@@ -2592,7 +2592,7 @@ pass_waccess::check_strncmp (gcall *stmt)\n   /* Determine the range of the bound first and bail if it fails; it's\n      cheaper than computing the size of the objects.  */\n   tree bndrng[2] = { NULL_TREE, NULL_TREE };\n-  get_size_range (m_ptr_qry.rvals, bound, stmt, bndrng, adata1.src.bndrng);\n+  get_size_range (m_ptr_qry.rvals, bound, stmt, bndrng, adata1.src_bndrng);\n   if (!bndrng[0] || integer_zerop (bndrng[0]))\n     return;\n "}, {"sha": "a8c9671e3baf8c182c5ab3bd9bcfc100a009e791", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9379fcb0d482cf4e2efd93b313523ab21fdc7da/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9379fcb0d482cf4e2efd93b313523ab21fdc7da/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=f9379fcb0d482cf4e2efd93b313523ab21fdc7da", "patch": "@@ -596,15 +596,9 @@ gimple_parm_array_size (tree ptr, wide_int rng[2],\n   return var;\n }\n \n-/* Given a statement STMT, set the bounds of the reference to at most\n-   as many bytes as BOUND or unknown when null, and at least one when\n-   the MINACCESS is true unless BOUND is a constant zero.  STMT is\n-   used for context to get accurate range info.  */\n-\n-access_ref::access_ref (range_query *qry /* = nullptr */,\n-\t\t\ttree bound /* = NULL_TREE */,\n-\t\t\tgimple *stmt /* = nullptr */,\n-\t\t\tbool minaccess /* = false */)\n+/* Initialize the object.  */\n+\n+access_ref::access_ref ()\n   : ref (), eval ([](tree x){ return x; }), deref (), trail1special (true),\n     base0 (true), parmarray ()\n {\n@@ -613,21 +607,6 @@ access_ref::access_ref (range_query *qry /* = nullptr */,\n   offmax[0] = offmax[1] = 0;\n   /* Invalidate.   */\n   sizrng[0] = sizrng[1] = -1;\n-\n-  /* Set the default bounds of the access and adjust below.  */\n-  bndrng[0] = minaccess ? 1 : 0;\n-  bndrng[1] = HOST_WIDE_INT_M1U;\n-\n-  /* When BOUND is nonnull and a range can be extracted from it,\n-     set the bounds of the access to reflect both it and MINACCESS.\n-     BNDRNG[0] is the size of the minimum access.  */\n-  tree rng[2];\n-  if (bound && get_size_range (qry, bound, stmt, rng, SR_ALLOW_ZERO))\n-    {\n-      bndrng[0] = wi::to_offset (rng[0]);\n-      bndrng[1] = wi::to_offset (rng[1]);\n-      bndrng[0] = bndrng[0] > 0 && minaccess ? 1 : 0;\n-    }\n }\n \n /* Return the PHI node REF refers to or null if it doesn't.  */\n@@ -1199,6 +1178,54 @@ access_ref::inform_access (access_mode mode) const\n \t    sizestr, allocfn);\n }\n \n+/* Set the access to at most MAXWRITE and MAXREAD bytes, and at least 1\n+   when MINWRITE or MINREAD, respectively, is set.  */\n+access_data::access_data (range_query *query, gimple *stmt, access_mode mode,\n+\t\t\t  tree maxwrite /* = NULL_TREE */,\n+\t\t\t  bool minwrite /* = false */,\n+\t\t\t  tree maxread /* = NULL_TREE */,\n+\t\t\t  bool minread /* = false */)\n+  : stmt (stmt), call (), dst (), src (), mode (mode)\n+{\n+  set_bound (dst_bndrng, maxwrite, minwrite, query, stmt);\n+  set_bound (src_bndrng, maxread, minread, query, stmt);\n+}\n+\n+/* Set the access to at most MAXWRITE and MAXREAD bytes, and at least 1\n+   when MINWRITE or MINREAD, respectively, is set.  */\n+access_data::access_data (range_query *query, tree expr, access_mode mode,\n+\t\t\t  tree maxwrite /* = NULL_TREE */,\n+\t\t\t  bool minwrite /* = false */,\n+\t\t\t  tree maxread /* = NULL_TREE */,\n+\t\t\t  bool minread /* = false */)\n+  : stmt (), call (expr),  dst (), src (), mode (mode)\n+{\n+  set_bound (dst_bndrng, maxwrite, minwrite, query, stmt);\n+  set_bound (src_bndrng, maxread, minread, query, stmt);\n+}\n+\n+/* Set BNDRNG to the range of BOUND for the statement STMT.  */\n+\n+void\n+access_data::set_bound (offset_int bndrng[2], tree bound, bool minaccess,\n+\t\t\trange_query *query, gimple *stmt)\n+{\n+  /* Set the default bounds of the access and adjust below.  */\n+  bndrng[0] = minaccess ? 1 : 0;\n+  bndrng[1] = HOST_WIDE_INT_M1U;\n+\n+  /* When BOUND is nonnull and a range can be extracted from it,\n+     set the bounds of the access to reflect both it and MINACCESS.\n+     BNDRNG[0] is the size of the minimum access.  */\n+  tree rng[2];\n+  if (bound && get_size_range (query, bound, stmt, rng, SR_ALLOW_ZERO))\n+    {\n+      bndrng[0] = wi::to_offset (rng[0]);\n+      bndrng[1] = wi::to_offset (rng[1]);\n+      bndrng[0] = bndrng[0] > 0 && minaccess ? 1 : 0;\n+    }\n+}\n+\n /* Set a bit for the PHI in VISITED and return true if it wasn't\n    already set.  */\n \n@@ -1948,14 +1975,8 @@ compute_objsize_r (tree ptr, gimple *stmt, int ostype, access_ref *pref,\n \t  if (const access_ref *cache_ref = qry->get_ref (ptr))\n \t    {\n \t      /* If the pointer is in the cache set *PREF to what it refers\n-\t\t to and return success.\n-\t\t FIXME: BNDRNG is determined by each access and so it doesn't\n-\t\t belong in access_ref.  Until the design is changed, keep it\n-\t\t unchanged here.  */\n-\t      const offset_int bndrng[2] = { pref->bndrng[0], pref->bndrng[1] };\n+\t\t to and return success.  */\n \t      *pref = *cache_ref;\n-\t      pref->bndrng[0] = bndrng[0];\n-\t      pref->bndrng[1] = bndrng[1];\n \t      return true;\n \t    }\n \t}"}, {"sha": "82cb81b3987758d8fc0d2f8fe66ecf9a3f4899df", "filename": "gcc/pointer-query.h", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9379fcb0d482cf4e2efd93b313523ab21fdc7da/gcc%2Fpointer-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9379fcb0d482cf4e2efd93b313523ab21fdc7da/gcc%2Fpointer-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.h?ref=f9379fcb0d482cf4e2efd93b313523ab21fdc7da", "patch": "@@ -61,8 +61,7 @@ class pointer_query;\n struct access_ref\n {\n   /* Set the bounds of the reference.  */\n-  access_ref (range_query *query = nullptr, tree = NULL_TREE,\n-\t      gimple * = nullptr, bool = false);\n+  access_ref ();\n \n   /* Return the PHI node REF refers to or null if it doesn't.  */\n   gphi *phi () const;\n@@ -129,11 +128,6 @@ struct access_ref\n   offset_int sizrng[2];\n   /* The minimum and maximum offset computed.  */\n   offset_int offmax[2];\n-  /* Range of the bound of the access: denotes that the access\n-     is at least BNDRNG[0] bytes but no more than BNDRNG[1].\n-     For string functions the size of the actual access is\n-     further constrained by the length of the string.  */\n-  offset_int bndrng[2];\n \n   /* Used to fold integer expressions when called from front ends.  */\n   tree (*eval)(tree);\n@@ -206,30 +200,33 @@ struct access_data\n {\n   /* Set the access to at most MAXWRITE and MAXREAD bytes, and\n      at least 1 when MINWRITE or MINREAD, respectively, is set.  */\n-  access_data (range_query *query, gimple *stmt, access_mode mode,\n-\t       tree maxwrite = NULL_TREE, bool minwrite = false,\n-\t       tree maxread = NULL_TREE, bool minread = false)\n-    : stmt (stmt), call (),\n-      dst (query, maxwrite, stmt, minwrite),\n-      src (query, maxread, stmt, minread),\n-      mode (mode) { }\n+  access_data (range_query *, gimple *, access_mode,\n+\t       tree = NULL_TREE, bool = false,\n+\t       tree = NULL_TREE, bool = false);\n \n   /* Set the access to at most MAXWRITE and MAXREAD bytes, and\n      at least 1 when MINWRITE or MINREAD, respectively, is set.  */\n-  access_data (range_query *query, tree expr, access_mode mode,\n-\t       tree maxwrite = NULL_TREE, bool minwrite = false,\n-\t       tree maxread = NULL_TREE, bool minread = false)\n-    : stmt (), call (expr),\n-      dst (query, maxwrite, nullptr, minwrite),\n-      src (query, maxread, nullptr, minread),\n-      mode (mode) { }\n+  access_data (range_query *, tree, access_mode,\n+\t       tree = NULL_TREE, bool = false,\n+\t       tree = NULL_TREE, bool = false);\n+\n+  /* Constructor helper.  */\n+  static void set_bound (offset_int[2], tree, bool, range_query *, gimple *);\n \n   /* Access statement.  */\n   gimple *stmt;\n   /* Built-in function call.  */\n   tree call;\n   /* Destination and source of the access.  */\n   access_ref dst, src;\n+\n+  /* Range of the bound of the access: denotes that the access is at\n+     least XXX_BNDRNG[0] bytes but no more than XXX_BNDRNG[1].  For\n+     string functions the size of the actual access is further\n+     constrained by the length of the string.  */\n+  offset_int dst_bndrng[2];\n+  offset_int src_bndrng[2];\n+\n   /* Read-only for functions like memcmp or strlen, write-only\n      for memset, read-write for memcpy or strcat.  */\n   access_mode mode;"}]}