{"sha": "a926eeedf43512b8576855c0afa51ec29662fd5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkyNmVlZWRmNDM1MTJiODU3Njg1NWMwYWZhNTFlYzI5NjYyZmQ1YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-20T12:07:08Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-20T12:11:19Z"}, "message": "preprocessor: line-map cleanups\n\nI found the linemap logic dealing with running out of column numbers\nconfusing.  There's no need for completely separate code blocks there,\nas we can rely on the masking operations working all the way down to\nzero bits.  The two binary searches for linemap lookups could do with\nmodernization of placing the var decls at their initialization point.\n(These two searches work in opposite directions, and while lower_bound\nwould work there, the caching got in the way and I decided to be\nconservative.)\n\n\tlibcpp/\n\t* line-map.c (linemap_add): Simplify column overflow calculation.\n\tAdd comment about range and column bit init.\n\t(linemap_ordinary_map_lookup): Refactor for RAII\n\t(linemap_macro_map_lookup): Likewise.", "tree": {"sha": "c331fe0c8bd9c20885686db3ac5da59b6e5202f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c331fe0c8bd9c20885686db3ac5da59b6e5202f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a926eeedf43512b8576855c0afa51ec29662fd5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a926eeedf43512b8576855c0afa51ec29662fd5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a926eeedf43512b8576855c0afa51ec29662fd5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a926eeedf43512b8576855c0afa51ec29662fd5a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4f1cbc35b1e823a0a6e58eeca61c8c6ca351875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4f1cbc35b1e823a0a6e58eeca61c8c6ca351875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4f1cbc35b1e823a0a6e58eeca61c8c6ca351875"}], "stats": {"total": 52, "additions": 21, "deletions": 31}, "files": [{"sha": "a8d52861dee45622ddea347be940c6cc96c17b4b", "filename": "libcpp/line-map.c", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a926eeedf43512b8576855c0afa51ec29662fd5a/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a926eeedf43512b8576855c0afa51ec29662fd5a/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=a926eeedf43512b8576855c0afa51ec29662fd5a", "patch": "@@ -462,17 +462,12 @@ linemap_add (line_maps *set, enum lc_reason reason,\n {\n   /* Generate a start_location above the current highest_location.\n      If possible, make the low range bits be zero.  */\n-  location_t start_location;\n-  if (set->highest_location < LINE_MAP_MAX_LOCATION_WITH_COLS)\n-    {\n-      start_location = set->highest_location + (1 << set->default_range_bits);\n-      if (set->default_range_bits)\n-\tstart_location &= ~((1 << set->default_range_bits) - 1);\n-      linemap_assert (0 == (start_location\n-\t\t\t    & ((1 << set->default_range_bits) - 1)));\n-    }\n-  else\n-    start_location = set->highest_location + 1;\n+  location_t start_location = set->highest_location + 1;\n+  unsigned range_bits = 0;\n+  if (start_location < LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    range_bits = set->default_range_bits;\n+  start_location += (1 << range_bits) - 1;\n+  start_location &=  ~((1 << range_bits) - 1);\n \n   linemap_assert (!LINEMAPS_ORDINARY_USED (set)\n \t\t  || (start_location\n@@ -537,8 +532,9 @@ linemap_add (line_maps *set, enum lc_reason reason,\n   map->to_file = to_file;\n   map->to_line = to_line;\n   LINEMAPS_ORDINARY_CACHE (set) = LINEMAPS_ORDINARY_USED (set) - 1;\n-  map->m_column_and_range_bits = 0;\n-  map->m_range_bits = 0;\n+  /* Do not store range_bits here.  That's readjusted in\n+     linemap_line_start.  */\n+  map->m_range_bits = map->m_column_and_range_bits = 0;\n   set->highest_location = start_location;\n   set->highest_line = start_location;\n   set->max_column_hint = 0;\n@@ -954,19 +950,16 @@ linemap_lookup (const line_maps *set, location_t line)\n static const line_map_ordinary *\n linemap_ordinary_map_lookup (const line_maps *set, location_t line)\n {\n-  unsigned int md, mn, mx;\n-  const line_map_ordinary *cached, *result;\n-\n   if (IS_ADHOC_LOC (line))\n     line = get_location_from_adhoc_loc (set, line);\n \n   if (set ==  NULL || line < RESERVED_LOCATION_COUNT)\n     return NULL;\n \n-  mn = LINEMAPS_ORDINARY_CACHE (set);\n-  mx = LINEMAPS_ORDINARY_USED (set);\n+  unsigned mn = LINEMAPS_ORDINARY_CACHE (set);\n+  unsigned mx = LINEMAPS_ORDINARY_USED (set);\n \n-  cached = LINEMAPS_ORDINARY_MAP_AT (set, mn);\n+  const line_map_ordinary *cached = LINEMAPS_ORDINARY_MAP_AT (set, mn);\n   /* We should get a segfault if no line_maps have been added yet.  */\n   if (line >= MAP_START_LOCATION (cached))\n     {\n@@ -981,15 +974,15 @@ linemap_ordinary_map_lookup (const line_maps *set, location_t line)\n \n   while (mx - mn > 1)\n     {\n-      md = (mn + mx) / 2;\n+      unsigned md = (mn + mx) / 2;\n       if (MAP_START_LOCATION (LINEMAPS_ORDINARY_MAP_AT (set, md)) > line)\n \tmx = md;\n       else\n \tmn = md;\n     }\n \n   LINEMAPS_ORDINARY_CACHE (set) = mn;\n-  result = LINEMAPS_ORDINARY_MAP_AT (set, mn);\n+  const line_map_ordinary *result = LINEMAPS_ORDINARY_MAP_AT (set, mn);\n   linemap_assert (line >= MAP_START_LOCATION (result));\n   return result;\n }\n@@ -1002,21 +995,18 @@ linemap_ordinary_map_lookup (const line_maps *set, location_t line)\n static const line_map_macro *\n linemap_macro_map_lookup (const line_maps *set, location_t line)\n {\n-  unsigned int md, mn, mx;\n-  const struct line_map_macro *cached, *result;\n-\n   if (IS_ADHOC_LOC (line))\n     line = get_location_from_adhoc_loc (set, line);\n \n   linemap_assert (line >= LINEMAPS_MACRO_LOWEST_LOCATION (set));\n \n-  if (set ==  NULL)\n+  if (set == NULL)\n     return NULL;\n \n-  mn = LINEMAPS_MACRO_CACHE (set);\n-  mx = LINEMAPS_MACRO_USED (set);\n-  cached = LINEMAPS_MACRO_MAP_AT (set, mn);\n-  \n+  unsigned mn = LINEMAPS_MACRO_CACHE (set);\n+  unsigned mx = LINEMAPS_MACRO_USED (set);\n+  const struct line_map_macro *cached = LINEMAPS_MACRO_MAP_AT (set, mn);\n+\n   if (line >= MAP_START_LOCATION (cached))\n     {\n       if (mn == 0 || line < MAP_START_LOCATION (&cached[-1]))\n@@ -1027,15 +1017,15 @@ linemap_macro_map_lookup (const line_maps *set, location_t line)\n \n   while (mn < mx)\n     {\n-      md = (mx + mn) / 2;\n+      unsigned md = (mx + mn) / 2;\n       if (MAP_START_LOCATION (LINEMAPS_MACRO_MAP_AT (set, md)) > line)\n \tmn = md + 1;\n       else\n \tmx = md;\n     }\n \n   LINEMAPS_MACRO_CACHE (set) = mx;\n-  result = LINEMAPS_MACRO_MAP_AT (set, LINEMAPS_MACRO_CACHE (set));\n+  const struct line_map_macro *result = LINEMAPS_MACRO_MAP_AT (set, mx);\n   linemap_assert (MAP_START_LOCATION (result) <= line);\n \n   return result;"}]}