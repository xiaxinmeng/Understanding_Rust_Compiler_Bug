{"sha": "41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFjMTRiNDVhYzYwNGViZDY5YTY3MTU0NDVjZGIxMGZjNWM1ZWMwNw==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-09T07:29:51Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-09T07:29:51Z"}, "message": "Merge branch 'master' of https://github.com/redbrain/gccrs", "tree": {"sha": "fb9e6c7e60b9024b1857c0fcf6241c118f2f67f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb9e6c7e60b9024b1857c0fcf6241c118f2f67f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "815c9e8b0734d45a6e5b5a7d50f38d4af7120a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815c9e8b0734d45a6e5b5a7d50f38d4af7120a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/815c9e8b0734d45a6e5b5a7d50f38d4af7120a8c"}, {"sha": "cef34bd730d80b4664d8633e2cc27a64c5cae246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cef34bd730d80b4664d8633e2cc27a64c5cae246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cef34bd730d80b4664d8633e2cc27a64c5cae246"}], "stats": {"total": 1810, "additions": 1708, "deletions": 102}, "files": [{"sha": "b91fbd7e0b3c0b01bdfc3b1cb1429f66eda74bba", "filename": ".github/workflows/ccpp.yml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/.github%2Fworkflows%2Fccpp.yml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/.github%2Fworkflows%2Fccpp.yml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Fworkflows%2Fccpp.yml?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -36,11 +36,12 @@ jobs:\n            mkdir -p gccrs-build;\n            cd gccrs-build;\n            ../configure \\\n-               --enable-languages=c,c++,rust \\\n+               --enable-languages=rust \\\n                --disable-bootstrap \\\n                --enable-multilib\n \n     - name: Build\n       run: |\n            cd gccrs-build; \\\n-           make\n+           make; \\\n+           make check-rust"}, {"sha": "8ef31ae1f63af101c59920ce4df9f07706fca11c", "filename": "Dockerfile", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/Dockerfile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/Dockerfile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Dockerfile?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,71 @@\n+FROM ubuntu:latest\n+\n+RUN apt-get update; \\\n+    DEBIAN_FRONTEND=\"noninteractive\" apt-get install -y --no-install-recommends \\\n+    autoconf \\\n+    automake \\\n+    bzip2\\\n+    dpkg-dev \\\n+    file \\\n+    wget \\\n+    curl \\\n+    build-essential \\\n+    imagemagick \\\n+    libbz2-dev \\\n+    libc6-dev \\\n+    libcurl4-openssl-dev \\\n+    libdb-dev \\\n+    libevent-dev \\\n+    libffi-dev \\\n+    libgdbm-dev \\\n+    libglib2.0-dev \\\n+    libgmp-dev \\\n+    libjpeg-dev \\\n+    libkrb5-dev \\\n+    liblzma-dev \\\n+    libmagickcore-dev \\\n+    libmagickwand-dev \\\n+    libmaxminddb-dev \\\n+    libncurses5-dev \\\n+    libncursesw5-dev \\\n+    libpng-dev \\\n+    libpq-dev \\\n+    libreadline-dev \\\n+    libsqlite3-dev \\\n+    libssl-dev \\\n+    libtool \\\n+    libwebp-dev \\\n+    libxml2-dev \\\n+    libxslt-dev \\\n+    libyaml-dev \\\n+    make \\\n+    patch \\\n+    unzip \\\n+    xz-utils \\\n+    zlib1g-dev \\\n+    flex \\\n+    bison\n+\n+ADD . /usr/src/gcc\n+RUN /bin/sh -c set -ex; \\\n+    cd /usr/src/gcc; \\\n+    ./contrib/download_prerequisites; \t{ rm *.tar.* || true; }; \\\n+    mkdir -p /usr/src/gcc/gcc-build; \\\n+    cd /usr/src/gcc/gcc-build; \\\n+    /usr/src/gcc/configure --disable-bootstrap --disable-multilib --enable-languages=rust; \\\n+    make -j \"$(nproc)\"; \\\n+    make install-strip; \\\n+    cd /root; \\\n+    rm -rf /usr/src/gcc\n+\n+RUN /bin/sh -c set -ex; \\\n+    echo '/usr/local/lib64' > /etc/ld.so.conf.d/local-lib64.conf; \\\n+    ldconfig -v\n+\n+RUN /bin/sh -c set -ex; \\\n+    dpkg-divert --divert /usr/bin/gcc.orig --rename /usr/bin/gcc; \\\n+    dpkg-divert --divert /usr/bin/g++.orig --rename /usr/bin/g++; \\\n+    update-alternatives --install /usr/bin/cc cc /usr/local/bin/gcc 999\n+\n+\n+CMD [\"bash\"]"}, {"sha": "edc8f2accace216d6564ca17b5e8097dfa07bd19", "filename": "Makefile.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -642,6 +642,7 @@ languages = { language=brig;\tgcc-check-target=check-brig;\n \t\t\t\tlib-check-target=check-target-libhsail-rt; };\n languages = { language=d;\tgcc-check-target=check-d;\n \t\t\t\tlib-check-target=check-target-libphobos; };\n+languages = { language=rust;\tgcc-check-target=check-rust; };\n \n // Toplevel bootstrap\n bootstrap_stage = { id=1 ; };"}, {"sha": "93c4e06d0306e8ee16db1cdfdc67a27dee0b5eb1", "filename": "Makefile.in", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -55553,6 +55553,14 @@ check-gcc-d:\n \t(cd gcc && $(MAKE) $(GCC_FLAGS_TO_PASS) check-d);\n check-d: check-gcc-d check-target-libphobos\n \n+.PHONY: check-gcc-rust check-rust\n+check-gcc-rust:\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\t(cd gcc && $(MAKE) $(GCC_FLAGS_TO_PASS) check-rust);\n+check-rust: check-gcc-rust\n+\n \n # The gcc part of install-no-fixedincludes, which relies on an intimate\n # knowledge of how a number of gcc internal targets (inter)operate.  Delegate."}, {"sha": "caa32f0bb5527e7a90f289ed0601a894694f7217", "filename": "README.md", "status": "modified", "additions": 66, "deletions": 8, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/README.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/README.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/README.md?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -1,33 +1,91 @@\n ![C/C++ CI](https://github.com/philberty/gccrs/workflows/C/C++%20CI/badge.svg)\n+![Docker Build](https://img.shields.io/docker/cloud/build/philberty/gccrs)\n+![Docker Pulls](https://img.shields.io/docker/pulls/philberty/gccrs)\n # GCC Rust\n \n-This is an implementation of rust following the gccgo style front-end.\n+This is a full alternative implementaion of the Rust language ontop of GCC.\n+Please see the accompanying reporting repository: https://github.com/Rust-GCC/Reporting for\n+status reports from Philip Herron and tast tracking overviews.\n \n-## Compilation for Development\n+## Development Enviroment\n \n Fetch dependancies for ubuntu:\n \n ```bash\n $ apt install build-essential libgmp3-dev libmpfr-dev libmpc-dev flex bison autogen gcc-multilib\n ```\n \n-Clone\n+Clone the repository\n \n ```bash\n-$ git clone https://github.com/philberty/gccrs\n+$ git clone git@github.com:Rust-GCC/gccrs.git\n ```\n \n-Dev Build\n+Compilation script. It is important to remember that GNU toolchain projects are designed to be built outside of its source directory\n+this is why a build directory is created.\n \n ```bash\n $ mkdir gccrs-build\n $ cd gccrs-build\n-$ ../gccrs/configure --prefix=$HOME/gccrs-install --disable-bootstrap --enable-multilib --enable-languages=c,c++,rust\n+$ ../gccrs/configure --prefix=$HOME/gccrs-install --disable-bootstrap --enable-multilib --enable-languages=rust\n $ make\n ```\n \n-Running the compiler itself - no need to make install\n+Running the compiler itself without make install we can simply invoke the compiler proper:\n \n ```\n-$ gdb --args ./gcc/rust1 test1.rs -frust-dump-parse -dumpbase test.rs -mtune=generic -march=x86-64 -auxbase-strip test.s -O0 -version -fdump-tree-gimple -o test.s -L/lib/x86_64-linux-gnu -L/lib/../lib64 -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib64\n+$ gdb --args ./gcc/rust1 test.rs -frust-dump-parse -Warray-bounds -dumpbase test.rs -mtune=generic -march=x86-64 -O0 -version -fdump-tree-gimple -o test.s -L/lib/x86_64-linux-gnu -L/lib/../lib64 -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib64\n ```\n+\n+Invoking the compiler driver we need to:\n+\n+```\n+$ make install\n+```\n+\n+Then invoke the compiler as expected:\n+\n+```\n+$ gccrs -g -O2 -c test.rs -o test.o\n+$ gccrs -o test test.o\n+```\n+\n+## Testsuite\n+\n+The test suite can be invoked via:\n+\n+```\n+$ make check-rust\n+```\n+\n+Test cases can be found within gcc/testsuite/rust.test please feel free to contriobute your specific\n+test cases referencing any issues on github.\n+\n+## Docker image\n+\n+There is a docker image hosted over on: \n+\n+https://hub.docker.com/repository/docker/philberty/gccrs\n+\n+Or you can build your own image:\n+\n+```\n+$ docker build . -t gccrs-dev\n+$ docker run --rm -v \"$PWD\":/usr/src/myapp -w /usr/src/myapp \\\n+    gccrs-dev:latest gccrs -g -O2 -c \\\n+    gcc/testsuite/rust.test/compilable/type_infer1.rs -o type_infer1.o\n+```\n+\n+## Contributing\n+\n+Please be aware this project is designed to be pushed upstream to GCC when we reach some milestones and this means we require\n+contribtions to have copyright assignment in place. Please see: https://gcc.gnu.org/contribute.html\n+\n+Not all contributions must be code, we would love to see new test cases or bugs and issues to be reported. Feel free to add any comments on open PRs\n+\n+## Community\n+\n+We can be found on all usual Rust channels such as Zulip but we also have our own channels:\n+\n+ * GCC Rust Zulip: https://gcc-rust.zulipchat.com/\n+ * Twitter: https://twitter.com/gcc_rust"}, {"sha": "234d51bc92c0585530c13b8dacf855591d9bdc0b", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -1,6 +1,6 @@\n # Make-lang.in -- Top level -*- makefile -*- fragment for GCC Rust frontend.\n \n-# Copyright (C) 2009-2013 Free Software Foundation, Inc.\n+# Copyright (C) 2009-2020 Free Software Foundation, Inc.\n \n # This file is part of GCC.\n \n@@ -11,7 +11,7 @@\n \n # GCC is distributed in the hope that it will be useful,\n # but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\tSee the\n # GNU General Public License for more details.\n \n # You should have received a copy of the GNU General Public License\n@@ -30,7 +30,7 @@ GCCRS_INSTALL_NAME := $(shell echo gccrs|sed '$(program_transform_name)')\n GCCRS_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gccrs|sed '$(program_transform_name)')\n \n # Define the names for selecting rust in LANGUAGES.\n-rust: gccrs$(exeext) rust1$(exeext)\n+rust: rust1$(exeext)\n \n # Tell GNU make to ignore files by these names if they exist.\n .PHONY: rust\n@@ -54,7 +54,7 @@ gccrs$(exeext): $(GCCRS_D_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a $(LIBDEPS)\n \t  $(GCCRS_D_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \\\n \t  $(EXTRA_GCC_LIBS) $(LIBS)\n \n-# List of host object files used by the rust language - files for translation from the parse tree \n+# List of host object files used by the rust language - files for translation from the parse tree\n # to GENERIC\n # The compiler proper, not driver\n GRS_OBJS = \\\n@@ -70,12 +70,12 @@ GRS_OBJS = \\\n     rust/rust-ast-full-test.o \\\n     rust/rust-session-manager.o \\\n     rust/rust-name-resolution.o \\\n-\trust/rust-type-resolution.o \\\n+    rust/rust-type-resolution.o \\\n     rust/rust-scan.o \\\n     rust/rust-compile.o \\\n     rust/rust-macro-expand.o \\\n     $(END)\n-# removed object files from here \n+# removed object files from here\n \n # All language-specific object files for Rust.\n RUST_ALL_OBJS = $(GRS_OBJS) $(RUST_TARGET_OBJS)\n@@ -89,26 +89,30 @@ rust1$(exeext): $(RUST_ALL_OBJS) attribs.o  $(BACKEND) $(LIBDEPS)\n \n # Build hooks.\n \n+lang_checks += check-rust\n+lang_checks_parallelized += check-rust\n+check_rust_parallelize = 10\n+\n # Copies its dependencies into the source directory. This generally should be used for generated files\n-# such as Bison output files which are not version-controlled, but should be included in any release \n-# tarballs. This target will be executed during a bootstrap if \u2018--enable-generated-files-in-srcdir\u2019 \n-# was specified as a configure option. \n-rust.srcextra: \n+# such as Bison output files which are not version-controlled, but should be included in any release\n+# tarballs. This target will be executed during a bootstrap if \u2018--enable-generated-files-in-srcdir\u2019\n+# was specified as a configure option.\n+rust.srcextra:\n \n rust.all.cross:\n \n # idk what this does but someone used it\n rust.start.encap: gccrs$(exeext)\n rust.rest.encap:\n \n-# Build generated man pages for the front end from Texinfo manuals (see Man Page Generation), in the \n-# build directory. This target is only called if the necessary tools are available, but should ignore \n-# errors so as not to stop the build if errors occur; man pages are optional and the tools involved \n-# may be installed in a broken way. \n+# Build generated man pages for the front end from Texinfo manuals (see Man Page Generation), in the\n+# build directory. This target is only called if the necessary tools are available, but should ignore\n+# errors so as not to stop the build if errors occur; man pages are optional and the tools involved\n+# may be installed in a broken way.\n rust.man:\n \n # Copies its dependencies into the source directory. These targets will be executed during a bootstrap\n-# if \u2018--enable-generated-files-in-srcdir\u2019 was specified as a configure option. \n+# if \u2018--enable-generated-files-in-srcdir\u2019 was specified as a configure option.\n rust.srcman:\n \n # Clean hooks.\n@@ -119,40 +123,40 @@ rust.mostlyclean:\n rust.clean: rust.mostlyclean\n \n # Builds an etags TAGS file in the language subdirectory in the source tree.\n-# TODO: add more directories if I add more \n+# TODO: add more directories if I add more\n rust.tags: force\n \tcd $(srcdir)/rust; \\\n \tetags -o TAGS.sub *.y *.l *.cc *.h ast/*.h ast/*.cc lex/*.h lex/*.cc parse/*.h parse/*.cc; \\\n \tetags --include TAGS.sub --include ../TAGS.sub\n \n # Build documentation hooks.\n \n-# Build info documentation for the front end, in the build directory. This target is only called by \n-# \u2018make bootstrap\u2019 if a suitable version of makeinfo is available, so does not need to check for this, \n-# and should fail if an error occurs. \n-rust.info: \n+# Build info documentation for the front end, in the build directory. This target is only called by\n+# \u2018make bootstrap\u2019 if a suitable version of makeinfo is available, so does not need to check for this,\n+# and should fail if an error occurs.\n+rust.info:\n \n-rust.srcinfo: \n+rust.srcinfo:\n \n-# Build DVI documentation for the front end, in the build directory. This should be done using \n-# $(TEXI2DVI), with appropriate -I arguments pointing to directories of included files. \n-rust.dvi: \n+# Build DVI documentation for the front end, in the build directory. This should be done using\n+# $(TEXI2DVI), with appropriate -I arguments pointing to directories of included files.\n+rust.dvi:\n \n-# Build PDF documentation for the front end, in the build directory. This should be done using \n-# $(TEXI2PDF), with appropriate -I arguments pointing to directories of included files. \n-rust.pdf: \n+# Build PDF documentation for the front end, in the build directory. This should be done using\n+# $(TEXI2PDF), with appropriate -I arguments pointing to directories of included files.\n+rust.pdf:\n \n-doc/rust.info: \n-doc/rust.dvi: \n-doc/rust.pdf: \n+doc/rust.info:\n+doc/rust.dvi:\n+doc/rust.pdf:\n \n-# Build HTML documentation for the front end, in the build directory. \n-rust.html: \n+# Build HTML documentation for the front end, in the build directory.\n+rust.html:\n \n # Install hooks.\n \n-# Install everything that is part of the front end, apart from the compiler executables listed in \n-# compilers in config-lang.in. \n+# Install everything that is part of the front end, apart from the compiler executables listed in\n+# compilers in config-lang.in.\n rust.install-common: installdirs\n #\t-rm -f $(DESTDIR)$(bindir)/$(GCCRS_INSTALL_NAME)$(exeext)\n #\t-rm -f $(DESTDIR)$(bindir)/$(GCCRS_TARGET_INSTALL_NAME)$(exeext)\n@@ -169,11 +173,11 @@ rust.install-common: installdirs\n \t( cd $(DESTDIR)$(bindir) && \\\n       $(LN) $(GCCRS_INSTALL_NAME)$(exeext) $(GCCRS_TARGET_INSTALL_NAME)$(exeext) ); \\\n \n-# Install headers needed for plugins. \n+# Install headers needed for plugins.\n rust.install-plugin:\n \n-# Uninstall files installed by installing the compiler. This is currently documented not to be \n-# supported, so the hook need not do anything. \n+# Uninstall files installed by installing the compiler. This is currently documented not to be\n+# supported, so the hook need not do anything.\n rust.uninstall:\n #\t-rm -rf $(DESTDIR)/$(bindir)/$(GCCRS_INSTALL_NAME)$(exeext)\n \t-rm -f gccrs$(exeext) grs1$(exeext)\n@@ -183,13 +187,13 @@ rust.uninstall:\n # No rust-specific selftests\n selftest-rust:\n \n-# Install info documentation for the front end, if it is present in the source directory. This target \n-# should have dependencies on info files that should be installed. \n-rust.install-info: \n+# Install info documentation for the front end, if it is present in the source directory. This target\n+# should have dependencies on info files that should be installed.\n+rust.install-info:\n \n-rust.install-pdf: \n+rust.install-pdf:\n \n-# Install man pages for the front end. This target should ignore errors. \n+# Install man pages for the front end. This target should ignore errors.\n rust.install-man:\n \n # Stage hooks:"}, {"sha": "f1edec822b7258dafee2a34a2a7203e5b44ca783", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 229, "deletions": 16, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -1,5 +1,6 @@\n #include \"rust-type-resolution.h\"\n #include \"rust-diagnostics.h\"\n+#include \"rust-type-visitor.h\"\n \n #define ADD_BUILTIN_TYPE(_X, _S)                                               \\\n   do                                                                           \\\n@@ -104,7 +105,13 @@ TypeResolution::typesAreCompatible (AST::Type *lhs, AST::Type *rhs,\n     }\n \n   AST::Type *val = NULL;\n-  return scope.LookupType (lhsTypeStr, &val);\n+  if (!scope.LookupType (lhsTypeStr, &val))\n+    {\n+      rust_error_at (locus, \"Unknown type: %s\", lhsTypeStr.c_str ());\n+      return false;\n+    }\n+\n+  return true;\n }\n \n bool\n@@ -395,19 +402,133 @@ TypeResolution::visit (AST::CompoundAssignmentExpr &expr)\n void\n TypeResolution::visit (AST::GroupedExpr &expr)\n {}\n-// void TypeResolution::visit(ArrayElems& elems) {}\n+\n void\n TypeResolution::visit (AST::ArrayElemsValues &elems)\n-{}\n+{\n+  // we need to generate the AST::ArrayType for this array init_expression\n+  // we can get the size via get_num_values() but we need to ensure each element\n+  // are type compatible\n+\n+  bool failed = false;\n+  AST::Type *last_inferred_type = nullptr;\n+  elems.iterate ([&] (AST::Expr *expr) mutable -> bool {\n+    size_t before;\n+    before = typeBuffer.size ();\n+    expr->accept_vis (*this);\n+    if (typeBuffer.size () <= before)\n+      {\n+\trust_error_at (expr->get_locus_slow (),\n+\t\t       \"unable to determine element type\");\n+\treturn false;\n+      }\n+\n+    AST::Type *inferedType = typeBuffer.back ();\n+    typeBuffer.pop_back ();\n+\n+    if (last_inferred_type == nullptr)\n+      last_inferred_type = inferedType;\n+    else\n+      {\n+\tif (!typesAreCompatible (last_inferred_type, inferedType,\n+\t\t\t\t expr->get_locus_slow ()))\n+\t  {\n+\t    failed = true;\n+\t    return false;\n+\t  }\n+      }\n+\n+    return true;\n+  });\n+\n+  // nothing to do when its failed\n+  if (failed)\n+    return;\n+\n+  // FIXME This will leak\n+  auto capacity\n+    = new AST::LiteralExpr (std::to_string (elems.get_num_values ()),\n+\t\t\t    AST::Literal::INT,\n+\t\t\t    Linemap::predeclared_location ());\n+  auto arrayType = new AST::ArrayType (last_inferred_type->clone_type (),\n+\t\t\t\t       std::unique_ptr<AST::Expr> (capacity),\n+\t\t\t\t       Linemap::predeclared_location ());\n+  typeBuffer.push_back (arrayType);\n+}\n+\n void\n TypeResolution::visit (AST::ArrayElemsCopied &elems)\n-{}\n+{\n+  printf (\"ArrayElemsCopied: %s\\n\", elems.as_string ().c_str ());\n+}\n+\n void\n TypeResolution::visit (AST::ArrayExpr &expr)\n-{}\n+{\n+  auto& elements = expr.get_array_elems ();\n+\n+  auto before = typeBuffer.size ();\n+  elements->accept_vis (*this);\n+  if (typeBuffer.size () <= before)\n+    {\n+      rust_error_at (expr.get_locus_slow (),\n+\t\t     \"unable to determine type for ArrayExpr\");\n+      return;\n+    }\n+\n+  expr.set_inferred_type (typeBuffer.back ());\n+}\n+\n void\n TypeResolution::visit (AST::ArrayIndexExpr &expr)\n-{}\n+{\n+  auto before = typeBuffer.size ();\n+  expr.get_array_expr ()->accept_vis (*this);\n+  if (typeBuffer.size () <= before)\n+    {\n+      rust_error_at (expr.get_locus_slow (),\n+\t\t     \"unable to determine type for array index expression\");\n+      return;\n+    }\n+  AST::Type *array_expr_type = typeBuffer.back ();\n+  typeBuffer.pop_back ();\n+\n+  before = typeBuffer.size ();\n+  expr.get_index_expr ()->accept_vis (*this);\n+  if (typeBuffer.size () <= before)\n+    {\n+      rust_error_at (expr.get_index_expr ()->get_locus_slow (),\n+\t\t     \"unable to determine type for index expression\");\n+      return;\n+    }\n+\n+  AST::Type *array_index_type = typeBuffer.back ();\n+  typeBuffer.pop_back ();\n+\n+  // check the index_type should be an i32 which should really be\n+  // more permissive\n+  AST::Type *i32 = nullptr;\n+  scope.LookupType (\"i32\", &i32);\n+  rust_assert (i32 != nullptr);\n+\n+  if (!typesAreCompatible (array_index_type, i32,\n+\t\t\t   expr.get_index_expr ()->get_locus_slow ()))\n+    {\n+      return;\n+    }\n+\n+  // the the element type from the array_expr_type and it _must_ be an array\n+  AST::ArrayType *resolved = ArrayTypeVisitor::Resolve (array_expr_type);\n+  if (resolved == nullptr)\n+    {\n+      rust_error_at (expr.get_locus_slow (),\n+\t\t     \"unable to resolve type for array expression\");\n+      return;\n+    }\n+\n+  typeBuffer.push_back (resolved->get_elem_type ().get ());\n+}\n+\n void\n TypeResolution::visit (AST::TupleExpr &expr)\n {}\n@@ -516,6 +637,10 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n \t}\n     }\n \n+  // need to correct the ordering with the respect to the struct definition and\n+  // ensure we handle missing values and give them defaults\n+  // FIXME\n+\n   // setup a path in type\n   AST::PathIdentSegment seg (expr.get_struct_name ().as_string ());\n   auto typePath = ::std::unique_ptr<AST::TypePathSegment> (\n@@ -649,9 +774,42 @@ TypeResolution::visit (AST::RangeFromToInclExpr &expr)\n void\n TypeResolution::visit (AST::RangeToInclExpr &expr)\n {}\n+\n void\n TypeResolution::visit (AST::ReturnExpr &expr)\n-{}\n+{\n+  // Ensure the type of this matches the function\n+  auto before = typeBuffer.size ();\n+  expr.get_returned_expr ()->accept_vis (*this);\n+\n+  if (typeBuffer.size () <= before)\n+    {\n+      rust_error_at (expr.get_returned_expr ()->get_locus_slow (),\n+\t\t     \"unable to determine type for return expr\");\n+      return;\n+    }\n+\n+  auto inferedType = typeBuffer.back ();\n+  typeBuffer.pop_back ();\n+\n+  // check this is compatible with the return type\n+  // this will again have issues with structs before we move to HIR\n+\n+  auto function = scope.CurrentFunction ();\n+  if (!function->has_return_type ())\n+    {\n+      rust_error_at (expr.get_locus (), \"return for void function %s\",\n+\t\t     function->as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (!typesAreCompatible (function->get_return_type ().get (), inferedType,\n+\t\t\t   expr.get_locus_slow ()))\n+    {\n+      return;\n+    }\n+}\n+\n void\n TypeResolution::visit (AST::UnsafeBlockExpr &expr)\n {}\n@@ -764,18 +922,26 @@ TypeResolution::visit (AST::Function &function)\n   // its  a marker for a void function\n   scope.InsertType (function.get_function_name (), function.get_return_type ().get ());\n   scope.InsertFunction (function.get_function_name (), &function);\n+  scope.PushFunction (&function);\n   scope.Push ();\n \n   for (auto &param : function.get_function_params ())\n     {\n       if (!isTypeInScope (param.get_type ().get (), param.get_locus ()))\n-\treturn;\n+\t{\n+\t  scope.Pop ();\n+\t  scope.PopFunction ();\n+\t  return;\n+\t}\n \n       auto before = letPatternBuffer.size ();\n       param.get_pattern ()->accept_vis (*this);\n       if (letPatternBuffer.size () <= before)\n \t{\n \t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n+\n+\t  scope.Pop ();\n+\t  scope.PopFunction ();\n \t  return;\n \t}\n \n@@ -788,7 +954,11 @@ TypeResolution::visit (AST::Function &function)\n   if (function.has_return_type ())\n     {\n       if (!isTypeInScope (function.get_return_type ().get (), function.get_locus ()))\n-\treturn;\n+\t{\n+\t  scope.Pop ();\n+\t  scope.PopFunction ();\n+\t  return;\n+\t}\n     }\n \n   // walk the expression body\n@@ -802,6 +972,7 @@ TypeResolution::visit (AST::Function &function)\n     function.locals.push_back (value);\n \n   scope.Pop ();\n+  scope.PopFunction ();\n }\n \n void\n@@ -1011,7 +1182,7 @@ TypeResolution::visit (AST::LetStmt &stmt)\n       return;\n     }\n \n-  AST::Type *inferedType = NULL;\n+  AST::Type *inferedType = nullptr;\n   if (stmt.has_init_expr ())\n     {\n       auto before = typeBuffer.size ();\n@@ -1044,13 +1215,51 @@ TypeResolution::visit (AST::LetStmt &stmt)\n \t  return;\n \t}\n     }\n-  else if (stmt.has_type () && !stmt.has_init_expr ())\n+  else if (stmt.has_type ())\n     {\n-      inferedType = stmt.get_type ().get ();\n+      auto before = typeComparisonBuffer.size ();\n+      stmt.get_type ()->accept_vis (*this);\n+      if (typeComparisonBuffer.size () <= before)\n+\t{\n+\t  rust_error_at (stmt.get_locus (), \"failed to understand type for lhs\");\n+\t  return;\n+\t}\n+      auto typeString = typeComparisonBuffer.back ();\n+      typeComparisonBuffer.pop_back ();\n+\n+      // AST::Type *val = NULL;\n+      // if (!scope.LookupType (typeString, &val))\n+      //   {\n+      //     rust_error_at (stmt.locus, \"LetStmt has unknown type: %s\",\n+      //   \t\t stmt.type->as_string ().c_str ());\n+      //     return;\n+      //   }\n+    }\n+  else if (inferedType != nullptr)\n+    {\n+      auto before = typeComparisonBuffer.size ();\n+      inferedType->accept_vis (*this);\n+      if (typeComparisonBuffer.size () <= before)\n+\t{\n+\t  rust_error_at (stmt.get_locus (), \"failed to understand type for lhs\");\n+\t  return;\n+\t}\n+      auto typeString = typeComparisonBuffer.back ();\n+      typeComparisonBuffer.pop_back ();\n+\n+      // AST::Type *val = NULL;\n+      // if (!scope.LookupType (typeString, &val))\n+      //   {\n+      //     rust_error_at (stmt.get_locus (), \"Inferred unknown type: %s\",\n+      //   \t\t inferedType->as_string ().c_str ());\n+      //     return;\n+      //   }\n+    }\n+  else\n+    {\n+      rust_fatal_error (stmt.get_locus (), \"Failed to determine any type for LetStmt\");\n+      return;\n     }\n-\n-  // TODO check we know what the type is in the scope requires the builtins to\n-  // be defined at the constructor\n \n   // ensure the decl has the type set for compilation later on\n   if (!stmt.has_type ())\n@@ -1118,9 +1327,13 @@ TypeResolution::visit (AST::RawPointerType &type)\n void\n TypeResolution::visit (AST::ReferenceType &type)\n {}\n+\n void\n TypeResolution::visit (AST::ArrayType &type)\n-{}\n+{\n+  typeComparisonBuffer.push_back (type.get_elem_type ()->as_string ());\n+}\n+\n void\n TypeResolution::visit (AST::SliceType &type)\n {}"}, {"sha": "2f61a39418110b7136431c7cb153c0cdd9db3cbf", "filename": "gcc/rust/analysis/rust-type-resolution.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -1,3 +1,20 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n #pragma once\n \n #include \"rust-resolution.h\"\n@@ -38,6 +55,12 @@ class TypeScoping\n     return functionScope.Lookup (ident, fn);\n   }\n \n+  void PushFunction (AST::Function *fn) { functionStack.push_back (fn); }\n+\n+  void PopFunction () { functionStack.pop_back (); }\n+\n+  AST::Function *CurrentFunction () { return functionStack.back (); }\n+\n   void InsertLocal (std::string ident, AST::LetStmt *let)\n   {\n     localsPerBlock.Insert (ident, let);\n@@ -74,6 +97,8 @@ class TypeScoping\n   }\n \n private:\n+  std::vector<AST::Function *> functionStack;\n+\n   Scope<AST::Function *> functionScope;\n   Scope<AST::LetStmt *> localsPerBlock;\n   Scope<AST::StructStruct *> structsPerBlock;"}, {"sha": "8cfe156782e648d50c30d2d02cbb37eb2d29c6d6", "filename": "gcc/rust/analysis/rust-type-visitor.h", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fanalysis%2Frust-type-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fanalysis%2Frust-type-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-visitor.h?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,261 @@\n+// rust-type-visitor.h -- Rust AST Visitor to AST::Type specific\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYPE_VISITOR_H\n+#define RUST_TYPE_VISITOR_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-scan.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+class BaseTypeVisitor : public AST::ASTVisitor\n+{\n+public:\n+  // visitor impl\n+  // rust-ast.h\n+  //  virtual void visit(AttrInput& attr_input);\n+  //  virtual void visit(TokenTree& token_tree);\n+  //  virtual void visit(MacroMatch& macro_match);\n+  virtual void visit (AST::Token &tok) override {}\n+  virtual void visit (AST::DelimTokenTree &delim_tok_tree) override {}\n+  virtual void visit (AST::AttrInputMetaItemContainer &input) override {}\n+  //  virtual void visit(MetaItem& meta_item) override {}\n+  //  void vsit(Stmt& stmt) override {}\n+  //  virtual void visit(Expr& expr) override {}\n+  virtual void visit (AST::IdentifierExpr &ident_expr) override {}\n+  //  virtual void visit(Pattern& pattern) override {}\n+  //  virtual void visit(Type& type) override {}\n+  //  virtual void visit(TypeParamBound& type_param_bound) override {}\n+  virtual void visit (AST::Lifetime &lifetime) override {}\n+  //  virtual void visit(GenericParam& generic_param) override {}\n+  virtual void visit (AST::LifetimeParam &lifetime_param) override {}\n+  //  virtual void visit(TraitItem& trait_item) override {}\n+  //  virtual void visit(InherentImplItem& inherent_impl_item) override {}\n+  //  virtual void visit(TraitImplItem& trait_impl_item) override {}\n+  virtual void visit (AST::MacroInvocationSemi &macro) override {}\n+\n+  // rust-path.h\n+  virtual void visit (AST::PathInExpression &path) override {}\n+  virtual void visit (AST::TypePathSegment &segment) override {}\n+  virtual void visit (AST::TypePathSegmentGeneric &segment) override {}\n+  virtual void visit (AST::TypePathSegmentFunction &segment) override {}\n+  virtual void visit (AST::TypePath &path) override {}\n+  virtual void visit (AST::QualifiedPathInExpression &path) override {}\n+  virtual void visit (AST::QualifiedPathInType &path) override {}\n+\n+  // rust-expr.h\n+  virtual void visit (AST::LiteralExpr &expr) override {}\n+  virtual void visit (AST::AttrInputLiteral &attr_input) override {}\n+  virtual void visit (AST::MetaItemLitExpr &meta_item) override {}\n+  virtual void visit (AST::MetaItemPathLit &meta_item) override {}\n+  virtual void visit (AST::BorrowExpr &expr) override {}\n+  virtual void visit (AST::DereferenceExpr &expr) override {}\n+  virtual void visit (AST::ErrorPropagationExpr &expr) override {}\n+  virtual void visit (AST::NegationExpr &expr) override {}\n+  virtual void visit (AST::ArithmeticOrLogicalExpr &expr) override {}\n+  virtual void visit (AST::ComparisonExpr &expr) override {}\n+  virtual void visit (AST::LazyBooleanExpr &expr) override {}\n+  virtual void visit (AST::TypeCastExpr &expr) override {}\n+  virtual void visit (AST::AssignmentExpr &expr) override {}\n+  virtual void visit (AST::CompoundAssignmentExpr &expr) override {}\n+  virtual void visit (AST::GroupedExpr &expr) override {}\n+  //  virtual void visit(ArrayElems& elems) override {}\n+  virtual void visit (AST::ArrayElemsValues &elems) override {}\n+  virtual void visit (AST::ArrayElemsCopied &elems) override {}\n+  virtual void visit (AST::ArrayExpr &expr) override {}\n+  virtual void visit (AST::ArrayIndexExpr &expr) override {}\n+  virtual void visit (AST::TupleExpr &expr) override {}\n+  virtual void visit (AST::TupleIndexExpr &expr) override {}\n+  virtual void visit (AST::StructExprStruct &expr) override {}\n+  //  virtual void visit(StructExprField& field) override {}\n+  virtual void visit (AST::StructExprFieldIdentifier &field) override {}\n+  virtual void visit (AST::StructExprFieldIdentifierValue &field) override {}\n+  virtual void visit (AST::StructExprFieldIndexValue &field) override {}\n+  virtual void visit (AST::StructExprStructFields &expr) override {}\n+  virtual void visit (AST::StructExprStructBase &expr) override {}\n+  virtual void visit (AST::StructExprTuple &expr) override {}\n+  virtual void visit (AST::StructExprUnit &expr) override {}\n+  //  virtual void visit(EnumExprField& field) override {}\n+  virtual void visit (AST::EnumExprFieldIdentifier &field) override {}\n+  virtual void visit (AST::EnumExprFieldIdentifierValue &field) override {}\n+  virtual void visit (AST::EnumExprFieldIndexValue &field) override {}\n+  virtual void visit (AST::EnumExprStruct &expr) override {}\n+  virtual void visit (AST::EnumExprTuple &expr) override {}\n+  virtual void visit (AST::EnumExprFieldless &expr) override {}\n+  virtual void visit (AST::CallExpr &expr) override {}\n+  virtual void visit (AST::MethodCallExpr &expr) override {}\n+  virtual void visit (AST::FieldAccessExpr &expr) override {}\n+  virtual void visit (AST::ClosureExprInner &expr) override {}\n+  virtual void visit (AST::BlockExpr &expr) override {}\n+  virtual void visit (AST::ClosureExprInnerTyped &expr) override {}\n+  virtual void visit (AST::ContinueExpr &expr) override {}\n+  virtual void visit (AST::BreakExpr &expr) override {}\n+  virtual void visit (AST::RangeFromToExpr &expr) override {}\n+  virtual void visit (AST::RangeFromExpr &expr) override {}\n+  virtual void visit (AST::RangeToExpr &expr) override {}\n+  virtual void visit (AST::RangeFullExpr &expr) override {}\n+  virtual void visit (AST::RangeFromToInclExpr &expr) override {}\n+  virtual void visit (AST::RangeToInclExpr &expr) override {}\n+  virtual void visit (AST::ReturnExpr &expr) override {}\n+  virtual void visit (AST::UnsafeBlockExpr &expr) override {}\n+  virtual void visit (AST::LoopExpr &expr) override {}\n+  virtual void visit (AST::WhileLoopExpr &expr) override {}\n+  virtual void visit (AST::WhileLetLoopExpr &expr) override {}\n+  virtual void visit (AST::ForLoopExpr &expr) override {}\n+  virtual void visit (AST::IfExpr &expr) override {}\n+  virtual void visit (AST::IfExprConseqElse &expr) override {}\n+  virtual void visit (AST::IfExprConseqIf &expr) override {}\n+  virtual void visit (AST::IfExprConseqIfLet &expr) override {}\n+  virtual void visit (AST::IfLetExpr &expr) override {}\n+  virtual void visit (AST::IfLetExprConseqElse &expr) override {}\n+  virtual void visit (AST::IfLetExprConseqIf &expr) override {}\n+  virtual void visit (AST::IfLetExprConseqIfLet &expr) override {}\n+  //  virtual void visit(MatchCase& match_case) override {}\n+  // virtual void visit (AST::MatchCaseBlockExpr &match_case) override {}\n+  // virtual void visit (AST::MatchCaseExpr &match_case) override {}\n+  virtual void visit (AST::MatchExpr &expr) override {}\n+  virtual void visit (AST::AwaitExpr &expr) override {}\n+  virtual void visit (AST::AsyncBlockExpr &expr) override {}\n+\n+  // rust-item.h\n+  virtual void visit (AST::TypeParam &param) override {}\n+  //  virtual void visit(WhereClauseItem& item) override {}\n+  virtual void visit (AST::LifetimeWhereClauseItem &item) override {}\n+  virtual void visit (AST::TypeBoundWhereClauseItem &item) override {}\n+  virtual void visit (AST::Method &method) override {}\n+  virtual void visit (AST::ModuleBodied &module) override {}\n+  virtual void visit (AST::ModuleNoBody &module) override {}\n+  virtual void visit (AST::ExternCrate &crate) override {}\n+  //  virtual void visit(UseTree& use_tree) override {}\n+  virtual void visit (AST::UseTreeGlob &use_tree) override {}\n+  virtual void visit (AST::UseTreeList &use_tree) override {}\n+  virtual void visit (AST::UseTreeRebind &use_tree) override {}\n+  virtual void visit (AST::UseDeclaration &use_decl) override {}\n+  virtual void visit (AST::Function &function) override {}\n+  virtual void visit (AST::TypeAlias &type_alias) override {}\n+  virtual void visit (AST::StructStruct &struct_item) override {}\n+  virtual void visit (AST::TupleStruct &tuple_struct) override {}\n+  virtual void visit (AST::EnumItem &item) override {}\n+  virtual void visit (AST::EnumItemTuple &item) override {}\n+  virtual void visit (AST::EnumItemStruct &item) override {}\n+  virtual void visit (AST::EnumItemDiscriminant &item) override {}\n+  virtual void visit (AST::Enum &enum_item) override {}\n+  virtual void visit (AST::Union &union_item) override {}\n+  virtual void visit (AST::ConstantItem &const_item) override {}\n+  virtual void visit (AST::StaticItem &static_item) override {}\n+  virtual void visit (AST::TraitItemFunc &item) override {}\n+  virtual void visit (AST::TraitItemMethod &item) override {}\n+  virtual void visit (AST::TraitItemConst &item) override {}\n+  virtual void visit (AST::TraitItemType &item) override {}\n+  virtual void visit (AST::Trait &trait) override {}\n+  virtual void visit (AST::InherentImpl &impl) override {}\n+  virtual void visit (AST::TraitImpl &impl) override {}\n+  //  virtual void visit(ExternalItem& item) override {}\n+  virtual void visit (AST::ExternalStaticItem &item) override {}\n+  virtual void visit (AST::ExternalFunctionItem &item) override {}\n+  virtual void visit (AST::ExternBlock &block) override {}\n+\n+  // rust-macro.h\n+  virtual void visit (AST::MacroMatchFragment &match) override {}\n+  virtual void visit (AST::MacroMatchRepetition &match) override {}\n+  virtual void visit (AST::MacroMatcher &matcher) override {}\n+  virtual void visit (AST::MacroRulesDefinition &rules_def) override {}\n+  virtual void visit (AST::MacroInvocation &macro_invoc) override {}\n+  virtual void visit (AST::MetaItemPath &meta_item) override {}\n+  virtual void visit (AST::MetaItemSeq &meta_item) override {}\n+  virtual void visit (AST::MetaWord &meta_item) override {}\n+  virtual void visit (AST::MetaNameValueStr &meta_item) override {}\n+  virtual void visit (AST::MetaListPaths &meta_item) override {}\n+  virtual void visit (AST::MetaListNameValueStr &meta_item) override {}\n+\n+  // rust-pattern.h\n+  virtual void visit (AST::LiteralPattern &pattern) override {}\n+  virtual void visit (AST::IdentifierPattern &pattern) override {}\n+  virtual void visit (AST::WildcardPattern &pattern) override {}\n+  //  virtual void visit(RangePatternBound& bound) override {}\n+  virtual void visit (AST::RangePatternBoundLiteral &bound) override {}\n+  virtual void visit (AST::RangePatternBoundPath &bound) override {}\n+  virtual void visit (AST::RangePatternBoundQualPath &bound) override {}\n+  virtual void visit (AST::RangePattern &pattern) override {}\n+  virtual void visit (AST::ReferencePattern &pattern) override {}\n+  //  virtual void visit(StructPatternField& field) override {}\n+  virtual void visit (AST::StructPatternFieldTuplePat &field) override {}\n+  virtual void visit (AST::StructPatternFieldIdentPat &field) override {}\n+  virtual void visit (AST::StructPatternFieldIdent &field) override {}\n+  virtual void visit (AST::StructPattern &pattern) override {}\n+  //  virtual void visit(TupleStructItems& tuple_items) override {}\n+  virtual void visit (AST::TupleStructItemsNoRange &tuple_items) override {}\n+  virtual void visit (AST::TupleStructItemsRange &tuple_items) override {}\n+  virtual void visit (AST::TupleStructPattern &pattern) override {}\n+  //  virtual void visit(TuplePatternItems& tuple_items) override {}\n+  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items) override {}\n+  virtual void visit (AST::TuplePatternItemsRanged &tuple_items) override {}\n+  virtual void visit (AST::TuplePattern &pattern) override {}\n+  virtual void visit (AST::GroupedPattern &pattern) override {}\n+  virtual void visit (AST::SlicePattern &pattern) override {}\n+\n+  // rust-stmt.h\n+  virtual void visit (AST::EmptyStmt &stmt) override {}\n+  virtual void visit (AST::LetStmt &stmt) override {}\n+  virtual void visit (AST::ExprStmtWithoutBlock &stmt) override {}\n+  virtual void visit (AST::ExprStmtWithBlock &stmt) override {}\n+\n+  // rust-type.h\n+  virtual void visit (AST::TraitBound &bound) override {}\n+  virtual void visit (AST::ImplTraitType &type) override {}\n+  virtual void visit (AST::TraitObjectType &type) override {}\n+  virtual void visit (AST::ParenthesisedType &type) override {}\n+  virtual void visit (AST::ImplTraitTypeOneBound &type) override {}\n+  virtual void visit (AST::TraitObjectTypeOneBound &type) override {}\n+  virtual void visit (AST::TupleType &type) override {}\n+  virtual void visit (AST::NeverType &type) override {}\n+  virtual void visit (AST::RawPointerType &type) override {}\n+  virtual void visit (AST::ReferenceType &type) override {}\n+  virtual void visit (AST::ArrayType &type) override {}\n+  virtual void visit (AST::SliceType &type) override {}\n+  virtual void visit (AST::InferredType &type) override {}\n+  virtual void visit (AST::BareFunctionType &type) override {}\n+};\n+\n+class ArrayTypeVisitor : public BaseTypeVisitor\n+{\n+public:\n+  static AST::ArrayType *Resolve (AST::Type *type)\n+  {\n+    ArrayTypeVisitor vis;\n+    type->accept_vis (vis);\n+    return vis.resolved;\n+  }\n+\n+  virtual void visit (AST::ArrayType &type) override { resolved = &type; };\n+\n+private:\n+  ArrayTypeVisitor () : resolved (nullptr) {}\n+\n+  AST::ArrayType *resolved;\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust\n+\n+#endif // RUST_TYPE_VISITOR_H"}, {"sha": "c7302fef4d7d46aa862ac66ccc6e57a8e1d18a5a", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -972,6 +972,17 @@ class ArrayElemsValues : public ArrayElems\n   const std::vector<std::unique_ptr<Expr> > &get_values () const { return values; }\n   std::vector<std::unique_ptr<Expr> > &get_values () { return values; }\n \n+  size_t get_num_values () const { return values.size (); }\n+\n+  void iterate (std::function<bool (Expr *)> cb)\n+  {\n+    for (auto it = values.begin (); it != values.end (); it++)\n+      {\n+\tif (!cb ((*it).get ()))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   ArrayElemsValues *clone_array_elems_impl () const override\n   {\n@@ -1048,6 +1059,10 @@ class ArrayExpr : public ExprWithoutBlock\n   // TODO: find another way to store this to save memory?\n   bool marked_for_strip = false;\n \n+  // this is a reference to what the inferred type is based on\n+  // this init expression\n+  Type *inferredType;\n+\n public:\n   std::string as_string () const override;\n \n@@ -1111,6 +1126,9 @@ class ArrayExpr : public ExprWithoutBlock\n     return internal_elements;\n   }\n \n+  Type *get_inferred_type () { return inferredType; }\n+  void set_inferred_type (Type *type) { inferredType = type; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "43510170e8fcc1cb47c6e29c7c902897d09f3dea", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -64,7 +64,7 @@ class ImplTraitType : public Type\n {\n   // TypeParamBounds type_param_bounds;\n   // inlined form\n-  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n \n   Location locus;\n \n@@ -78,7 +78,7 @@ class ImplTraitType : public Type\n \n public:\n   ImplTraitType (\n-    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n     Location locus)\n     : type_param_bounds (std::move (type_param_bounds)), locus (locus)\n   {}\n@@ -124,7 +124,7 @@ class TraitObjectType : public Type\n {\n   bool has_dyn;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n+  std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n \n   Location locus;\n@@ -139,7 +139,7 @@ class TraitObjectType : public Type\n \n public:\n   TraitObjectType (\n-    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n     Location locus, bool is_dyn_dispatch = false)\n     : has_dyn (is_dyn_dispatch),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n@@ -330,14 +330,14 @@ class TypePath; // definition moved to \"rust-path.h\"\n  * specific order */\n class TupleType : public TypeNoBounds\n {\n-  std::vector<std::unique_ptr<Type>> elems;\n+  std::vector<std::unique_ptr<Type> > elems;\n   Location locus;\n \n public:\n   // Returns whether the tuple type is the unit type, i.e. has no elements.\n   bool is_unit_type () const { return elems.empty (); }\n \n-  TupleType (std::vector<std::unique_ptr<Type>> elems, Location locus)\n+  TupleType (std::vector<std::unique_ptr<Type> > elems, Location locus)\n     : elems (std::move (elems)), locus (locus)\n   {}\n "}, {"sha": "dd28759e95c05b8980181a73406b8d28fca69782", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 113, "deletions": 23, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -503,19 +503,102 @@ Compilation::visit (AST::CompoundAssignmentExpr &expr)\n void\n Compilation::visit (AST::GroupedExpr &expr)\n {}\n-// void Compilation::visit(ArrayElems& elems) {}\n+\n void\n Compilation::visit (AST::ArrayElemsValues &elems)\n-{}\n+{\n+  std::vector< ::Bexpression *> elements;\n+\n+  bool failed = false;\n+  elems.iterate ([&] (AST::Expr *expr) mutable -> bool {\n+    Bexpression *value = nullptr;\n+    VISIT_POP (expr.get_locus_slow (), expr, value, exprs);\n+    if (value == nullptr)\n+      {\n+\trust_fatal_error (expr->get_locus_slow (),\n+\t\t\t  \"failed to compile value to array initialiser\");\n+\treturn false;\n+      }\n+    elements.push_back (value);\n+    return true;\n+  });\n+\n+  // nothing to do when its failed\n+  if (failed)\n+    return;\n+\n+  arrayConsStack.push_back (elements);\n+}\n+\n void\n Compilation::visit (AST::ArrayElemsCopied &elems)\n {}\n+\n void\n Compilation::visit (AST::ArrayExpr &expr)\n-{}\n+{\n+  translatedType = nullptr;\n+  expr.get_inferred_type ()->accept_vis (*this);\n+  if (translatedType == nullptr)\n+    {\n+      rust_error_at (expr.get_locus_slow (),\n+\t\t     \"failed to compile array type for ArrayExpr\");\n+      return;\n+    }\n+\n+  ::Btype *compiledType = translatedType;\n+  translatedType = nullptr;\n+\n+  auto before = arrayConsStack.size ();\n+  expr.get_internal_elements ()->accept_vis (*this);\n+  if (arrayConsStack.size () <= before)\n+    {\n+      rust_error_at (expr.get_locus_slow (),\n+\t\t     \"failed to compile the array constructor\");\n+      return;\n+    }\n+  std::vector< ::Bexpression *> initializer = arrayConsStack.back ();\n+  arrayConsStack.pop_back ();\n+\n+  std::vector<unsigned long> indexes;\n+  for (unsigned long i = 0; i < initializer.size (); ++i)\n+    indexes.push_back (i);\n+\n+  Bexpression *cons\n+    = backend->array_constructor_expression (compiledType, indexes, initializer,\n+\t\t\t\t\t     expr.get_locus_slow ());\n+  exprs.push_back (cons);\n+}\n+\n void\n Compilation::visit (AST::ArrayIndexExpr &expr)\n-{}\n+{\n+  Bexpression *arrayExpr = nullptr;\n+  VISIT_POP (expr.get_array_expr ()->get_locus_slow (), expr.get_array_expr (),\n+\t     arrayExpr, exprs);\n+  if (arrayExpr == nullptr)\n+    {\n+      rust_error_at (expr.get_locus_slow (),\n+\t\t     \"failed to compile value to array expression reference\");\n+      return;\n+    }\n+\n+  Bexpression *indexExpr = nullptr;\n+  VISIT_POP (expr.get_index_expr ()->get_locus_slow (), expr.get_index_expr (),\n+\t     indexExpr, exprs);\n+  if (indexExpr == nullptr)\n+    {\n+      rust_error_at (expr.get_locus_slow (),\n+\t\t     \"failed to compile value to array index expression\");\n+      return;\n+    }\n+\n+  Bexpression *indexExpression\n+    = backend->array_index_expression (arrayExpr, indexExpr,\n+\t\t\t\t       expr.get_locus_slow ());\n+  exprs.push_back (indexExpression);\n+}\n+\n void\n Compilation::visit (AST::TupleExpr &expr)\n {}\n@@ -533,24 +616,6 @@ Compilation::visit (AST::StructExprFieldIdentifier &field)\n void\n Compilation::visit (AST::StructExprFieldIdentifierValue &field)\n {\n-  AST::StructStruct *decl = structBuffer.back ();\n-  size_t index = 0;\n-  bool found = false;\n-  for (auto &df : decl->get_fields ())\n-    {\n-      if (field.get_field_name ().compare (df.get_field_name ()) == 0)\n-\t{\n-\t  found = true;\n-\t  break;\n-\t}\n-    }\n-  if (!found)\n-    {\n-      rust_fatal_error (field.get_value ()->get_locus_slow (),\n-\t\t\t\"failed to lookup field index\");\n-      return;\n-    }\n-\n   Bexpression *value = NULL;\n   VISIT_POP (field.get_value ()->get_locus_slow (), field.get_value ().get (), value, exprs);\n   if (value == NULL)\n@@ -1394,9 +1459,34 @@ Compilation::visit (AST::RawPointerType &type)\n void\n Compilation::visit (AST::ReferenceType &type)\n {}\n+\n void\n Compilation::visit (AST::ArrayType &type)\n-{}\n+{\n+  Btype *elementType;\n+  translatedType = nullptr;\n+  type.get_element_type ()->accept_vis (*this);\n+  if (translatedType == nullptr)\n+    {\n+      rust_error_at (type.get_locus (),\n+\t\t     \"Failed to compile element type for array\");\n+      return;\n+    }\n+  elementType = translatedType;\n+\n+  Bexpression *length = nullptr;\n+  VISIT_POP (type.get_size_expr ()->get_locus_slow (), type.get_size_expr (),\n+\t     length, exprs);\n+  if (length == nullptr)\n+    {\n+      rust_error_at (type.get_size_expr ()->get_locus_slow (),\n+\t\t     \"failed to size for array type\");\n+      return;\n+    }\n+\n+  translatedType = backend->array_type (elementType, length);\n+}\n+\n void\n Compilation::visit (AST::SliceType &type)\n {}"}, {"sha": "88c83187a0dea1bfec94c2ddc40b031ed492bd15", "filename": "gcc/rust/backend/rust-compile.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fbackend%2Frust-compile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Fbackend%2Frust-compile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.h?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -243,7 +243,8 @@ class Compilation : public AST::ASTVisitor\n   std::vector< ::Bexpression *> exprs;\n   std::vector< ::Bstatement *> stmts;\n   std::vector< ::Bvariable *> varBuffer;\n-  std::vector<AST::StructStruct*> structBuffer;\n+  std::vector<AST::StructStruct *> structBuffer;\n+  std::vector<std::vector< ::Bexpression *> > arrayConsStack;\n \n   // careful these are the vectors we pass into the GCC middle-end\n   std::vector< ::Btype *> type_decls;"}, {"sha": "a907fe41dd4e29b736ab80671bf0f4397d35ccf8", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -1,4 +1,5 @@\n-#pragma once\n+#ifndef RUST_BACKEND_H\n+#define RUST_BACKEND_H\n \n #include <gmp.h>\n #include <mpfr.h>\n@@ -759,3 +760,5 @@ class Backend\n   // section in the output object file.\n   virtual void write_export_data (const char *bytes, unsigned int size) = 0;\n };\n+\n+#endif // RUST_BACKEND_H"}, {"sha": "5da2764e98787fddb52e23d792d721edc11b48ca", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -279,6 +279,12 @@ Session::init ()\n \n   // derived values from hook\n   options.target_data.init_derived_values ();\n+\n+  // setup singleton linemap\n+  linemap = rust_get_linemap ();\n+\n+  // setup backend to GCC GIMPLE\n+  backend = rust_get_backend ();\n }\n \n /* Initialise default options. Actually called before handle_option, unlike init\n@@ -416,12 +422,10 @@ Session::parse_file (const char *filename)\n       rust_fatal_error (Location (), \"cannot open filename %s: %m\", filename);\n     }\n \n-  Backend *backend = rust_get_backend ();\n-\n   // parse file here\n   /* create lexer and parser - these are file-specific and so aren't instance\n    * variables */\n-  Lexer lex (filename, std::move (file_wrap), rust_get_linemap ());\n+  Lexer lex (filename, std::move (file_wrap), linemap);\n   Parser<Lexer> parser (std::move (lex));\n \n   // generate crate from parser"}, {"sha": "e7c9852349ed5bd6c0ac368cf48e086b3ab0c007", "filename": "gcc/testsuite/lib/rust-dg.exp", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Flib%2Frust-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Flib%2Frust-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Frust-dg.exp?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,106 @@\n+# Copyright (C) 2012-2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+load_lib gcc-dg.exp\n+\n+# Define rust callbacks for dg.exp.\n+\n+proc rust-dg-test { prog do_what extra_tool_flags } {\n+    upvar dg-do-what dg-do-what\n+\n+    # Demote link and run tests to compile-only if D runtime is missing.\n+    if ![check_effective_target_d_runtime] {\n+\tswitch $do_what {\n+\t    link -\n+\t    run {\n+\t\tset do_what compile\n+\t\tset dg-do-what compile\n+\t    }\n+\t}\n+    }\n+\n+    # Strip rust.test prefix off test names to avoid pathname failures in\n+    # some tests.\n+    set prog [dg-trim-dirname rust.test $prog]\n+\n+    set result \\\n+\t[gcc-dg-test-1 rust_target_compile $prog $do_what $extra_tool_flags]\n+\n+    set comp_output [lindex $result 0]\n+    set output_file [lindex $result 1]\n+\n+    return [list $comp_output $output_file]\n+}\n+\n+proc rust-dg-prune { system text } {\n+    return [gcc-dg-prune $system $text]\n+}\n+\n+# Utility routines.\n+\n+#\n+# Modified dg-runtest that can cycle through a list of optimization options\n+# as c-torture does.\n+#\n+\n+proc rust-dg-runtest { testcases flags default-extra-flags } {\n+    global runtests\n+\n+    foreach test $testcases {\n+\t# If we're only testing specific files and this isn't one of\n+\t# them, skip it.\n+\t\n+\tif ![runtest_file_p $runtests $test] {\n+\t    continue\n+\t}\n+\n+\t# Use TORTURE_OPTIONS to cycle through an option list.\n+\tif [torture-options-exist] then {\n+\t    global torture_with_loops\n+\t    set option_list $torture_with_loops\n+\t} else {\n+\t    set option_list { \"\" }\n+\t}\n+\n+\tset nshort [file tail [file dirname $test]]/[file tail $test]\n+\n+\tforeach flags_t $option_list {\n+\t    verbose \"Testing $nshort, $flags $flags_t\" 1\n+\t    dg-test $test \"$flags $flags_t\" ${default-extra-flags}\n+\t}\n+    }\n+}\n+\n+#\n+# rust_load -- wrapper around default rust_load to handle tests that\n+# require program arguments passed to them.\n+#\n+\n+if { [info procs rust_load] != [list] \\\n+      && [info procs prev_rust_load] == [list] } {\n+    rename rust_load prev_rust_load\n+\n+    proc rust_load { program args } {\n+\tglobal RUST_EXECUTE_ARGS\n+\tif [info exists RUST_EXECUTE_ARGS] then {\n+\t    set args [concat \"{$RUST_EXECUTE_ARGS}\"]\n+\t}\n+\t#print \"Running: $program [lindex $args 0]\"\n+\tset result [eval [list prev_rust_load $program] $args ]\n+\treturn $result\n+    }\n+}\n+"}, {"sha": "541b0520dc8aabeaca8ccf26e1e42519c7453092", "filename": "gcc/testsuite/lib/rust.exp", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Flib%2Frust.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Flib%2Frust.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Frust.exp?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,213 @@\n+# Copyright (C) 2012-2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+#\n+# rust support library routines\n+#\n+\n+load_lib prune.exp\n+load_lib gcc-defs.exp\n+load_lib timeout.exp\n+load_lib target-libpath.exp\n+\n+#\n+# RUST_UNDER_TEST is the compiler under test.\n+#\n+\n+set rust_compile_options \"\"\n+\n+\n+#\n+# rust_version -- extract and print the version number of the compiler\n+#\n+\n+proc rust_version { } {\n+    global RUST_UNDER_TEST\n+\n+    rust_init\n+\n+    # ignore any arguments after the command\n+    set compiler [lindex $RUST_UNDER_TEST 0]\n+\n+    # verify that the compiler exists\n+    if { [is_remote host] || [which $compiler] != 0 } then {\n+\tset tmp [remote_exec host \"$compiler -v\"]\n+\tset status [lindex $tmp 0]\n+\tset output [lindex $tmp 1]\n+\tregexp \" version \\[^\\n\\r\\]*\" $output version\n+\tif { $status == 0 && [info exists version] } then {\n+\t    if [is_remote host] {\n+\t\tclone_output \"$compiler $version\\n\"\n+\t    } else {\n+\t\tclone_output \"[which $compiler] $version\\n\"\n+\t    }\n+\t} else {\n+\t    clone_output \"Couldn't determine version of $output [which $compiler]\\n\"\n+\t}\n+    } else {\n+\t# compiler does not exist (this should have already been detected)\n+\twarning \"$compiler does not exist\"\n+    }\n+}\n+\n+#\n+# rust_include_flags -- include flags for the gcc tree structure\n+#\n+\n+proc rust_include_flags { paths } {\n+    global srcdir\n+    global TESTING_IN_BUILD_TREE\n+\n+    set flags \"\"\n+\n+    if { [is_remote host] || ![info exists TESTING_IN_BUILD_TREE] } {\n+\treturn \"${flags}\"\n+    }\n+\n+    set gccpath ${paths}\n+\n+    return \"$flags\"\n+}\n+\n+#\n+# rust_link_flags -- linker flags for the gcc tree structure\n+#\n+\n+proc rust_link_flags { paths } {\n+    global srcdir\n+    global ld_library_path\n+    global RUST_UNDER_TEST\n+    global shlib_ext\n+    global SHARED_OPTION\n+\n+    set gccpath ${paths}\n+    set libio_dir \"\"\n+    set flags \"\"\n+    set ld_library_path \".\"\n+    set shlib_ext [get_shlib_extension]\n+    set SHARED_OPTION \"\"\n+    verbose \"shared lib extension: $shlib_ext\"\n+\n+    set_ld_library_path_env_vars\n+\n+    return \"$flags\"\n+}\n+\n+#\n+# rust_init -- called at the start of each subdir of tests\n+#\n+\n+proc rust_init { args } {\n+    global subdir\n+    global rust_initialized\n+    global base_dir\n+    global tmpdir\n+    global libdir\n+    global gluefile wrap_flags\n+    global objdir srcdir\n+    global ALWAYS_DFLAGS\n+    global TOOL_EXECUTABLE TOOL_OPTIONS\n+    global RUST_UNDER_TEST\n+    global TESTING_IN_BUILD_TREE\n+    global TEST_ALWAYS_FLAGS\n+    global gcc_warning_prefix\n+    global gcc_error_prefix\n+\n+    # We set LC_ALL and LANG to C so that we get the same error messages as expected.\n+    setenv LC_ALL C\n+    setenv LANG C\n+\n+    if ![info exists RUST_UNDER_TEST] then {\n+\tif [info exists TOOL_EXECUTABLE] {\n+\t    set RUST_UNDER_TEST $TOOL_EXECUTABLE\n+\t} else {\n+\t    if { [is_remote host] || ! [info exists TESTING_IN_BUILD_TREE] } {\n+\t\tset RUST_UNDER_TEST [transform gccrs]\n+\t    } else {\n+\t\tset RUST_UNDER_TEST [findfile $base_dir/../../gccrs \"$base_dir/../../gccrs -B$base_dir/../../\" [findfile $base_dir/gccrs \"$base_dir/gccrs -B$base_dir/\" [transform gccrs]]]\n+\t    }\n+\t}\n+    }\n+\n+    if ![is_remote host] {\n+\tif { [which $RUST_UNDER_TEST] == 0 } then {\n+\t    perror \"RUST_UNDER_TEST ($RUST_UNDER_TEST) does not exist\"\n+\t    exit 1\n+\t}\n+    }\n+    if ![info exists tmpdir] {\n+\tset tmpdir \"/tmp\"\n+    }\n+\n+    if [info exists gluefile] {\n+\tunset gluefile\n+    }\n+\n+    rust_maybe_build_wrapper \"${tmpdir}/rust-testglue.o\"\n+\n+    set ALWAYS_RUSTFLAGS \"\"\n+\n+    # TEST_ALWAYS_FLAGS are flags that should be passed to every\n+    # compilation.  They are passed first to allow individual\n+    # tests to override them.\n+    if [info exists TEST_ALWAYS_FLAGS] {\n+\tlappend ALWAYS_DFLAGS \"additional_flags=$TEST_ALWAYS_FLAGS\"\n+    }\n+\n+    if ![is_remote host] {\n+\tif [info exists TOOL_OPTIONS] {\n+\t    lappend ALWAYS_DFLAGS \"additional_flags=[rust_include_flags [get_multilibs ${TOOL_OPTIONS}] ]\"\n+\t    lappend ALWAYS_DFLAGS \"ldflags=[rust_link_flags [get_multilibs ${TOOL_OPTIONS}] ]\"\n+\t} else {\n+\t    lappend ALWAYS_DFLAGS \"additional_flags=[rust_include_flags [get_multilibs] ]\"\n+\t    lappend ALWAYS_DFLAGS \"ldflags=[rust_link_flags [get_multilibs] ]\"\n+\t}\n+    }\n+\n+    if [info exists TOOL_OPTIONS] {\n+\tlappend ALWAYS_DFLAGS \"additional_flags=$TOOL_OPTIONS\"\n+    }\n+\n+    verbose -log \"ALWAYS_DFLAGS set to $ALWAYS_DFLAGS\"\n+\n+    set gcc_warning_prefix \"warning:\"\n+    set gcc_error_prefix \"(fatal )?error:\"\n+\n+    verbose \"rust is initialized\" 3\n+}\n+\n+#\n+# rust_target_compile -- compile a source file\n+#\n+\n+proc rust_target_compile { source dest type options } {\n+    global tmpdir\n+    global gluefile wrap_flags\n+    global ALWAYS_DFLAGS\n+    global RUST_UNDER_TEST\n+\n+    if { [target_info needs_status_wrapper] != \"\" && [info exists gluefile] } {\n+\tlappend options \"libs=${gluefile}\"\n+\tlappend options \"ldflags=${wrap_flags}\"\n+    }\n+\n+    lappend options \"timeout=[timeout_value]\"\n+    lappend options \"compiler=$RUST_UNDER_TEST\"\n+\n+    set options [concat \"$ALWAYS_DFLAGS\" $options]\n+    set options [dg-additional-files-options $options $source]\n+    return [target_compile $source $dest $type $options]\n+}"}, {"sha": "f7e66af7a266179f8bad20292b0c6908b506c70b", "filename": "gcc/testsuite/rust.test/compilable/arrays1.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays1.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let xs: [i32; 5] = [1, 2, 3, 4, 5];\n+    let xy = [6, 7, 8];\n+\n+    let a = xs[0];\n+    let b = xy[2];\n+}"}, {"sha": "2bb3a95f033ca6d73ac44e3b95b95b2ecea7cd15", "filename": "gcc/testsuite/rust.test/compilable/conditional.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fconditional.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fconditional.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fconditional.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,11 @@\n+fn main() {\n+    let mut x = 5;\n+\n+    if x == 5 {\n+        x = 1;\n+    } else if x == 3 {\n+        x = 2;\n+    } else {\n+        x = 3;\n+    }\n+}"}, {"sha": "51ed74b27c2ce98f29ddea36f90af6e1d8e56f03", "filename": "gcc/testsuite/rust.test/compilable/impl_block.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,14 @@\n+struct Foo {\n+    one: i32,\n+    two: i32,\n+}\n+\n+impl Foo {\n+    fn new(a: i32, b: i32) -> Foo {\n+        return Foo { one: a, two: b };\n+    }\n+}\n+\n+fn main() {\n+    let cake = Foo::new(3, 4);\n+}"}, {"sha": "7a564af979877aba842ccaeddd1c8cc45fa3f23a", "filename": "gcc/testsuite/rust.test/compilable/static_function.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstatic_function.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstatic_function.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstatic_function.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,7 @@\n+fn test(x: i32) -> i32 {\n+    return x + 1;\n+}\n+\n+fn main() {\n+    let call_test = test(1);\n+}"}, {"sha": "6081476cfac2da2181fb7892fa901b6c50e89fe0", "filename": "gcc/testsuite/rust.test/compilable/struct_init.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,8 @@\n+struct Foo {\n+    one: i32,\n+    two: i32,\n+}\n+\n+fn main() {\n+    let struct_test = Foo { one: 1, two: 2 };\n+}"}, {"sha": "bc4b09a6a5426a84542289027e7ebbfc05a6b848", "filename": "gcc/testsuite/rust.test/compilable/type_infer1.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer1.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,19 @@\n+struct Foo {\n+    one: i32,\n+    two: i32,\n+}\n+\n+fn test(x: i32) -> i32 {\n+    return x + 1;\n+}\n+\n+fn main() {\n+    let logical: bool = true;\n+    let an_integer = 5;\n+    let mut default_integer = 7;\n+\n+    default_integer = 1 + an_integer;\n+\n+    let call_test = test(1);\n+    let struct_test = Foo { one: 1, two: 2 };\n+}"}, {"sha": "614c67d6f3c5ac7d334d6d41a01cde25bcab6747", "filename": "gcc/testsuite/rust.test/compilable/type_infer2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer2.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,8 @@\n+fn test(x: i32) -> i32 {\n+    return x + 1;\n+}\n+\n+fn main() {\n+    let an_integer = 5;\n+    let call_test = test(an_integer + 1);\n+}"}, {"sha": "797f1ca91c921ab76cc54c428f0f85be4d9b75d2", "filename": "gcc/testsuite/rust.test/fail_compilation/arrays1.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Farrays1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Farrays1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Farrays1.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let xs: [i32; 5] = [1, 2, 3, 4, 5];\n+    let a: bool = xs[0];\n+}"}, {"sha": "9ecf322db19ec297f5fc1fdc8fb0bd200eaae395", "filename": "gcc/testsuite/rust.test/fail_compilation/arrays2.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Farrays2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Farrays2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Farrays2.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let array: [i32; 5] = [1, 2, 3];\n+}"}, {"sha": "83e16f31f967199a4dce1123c9085f31fd92a782", "filename": "gcc/testsuite/rust.test/fail_compilation/bad_type1.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fbad_type1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fbad_type1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fbad_type1.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let logical: bool = 123;\n+}"}, {"sha": "5578c279c00f4d78445fd19111332559de4ff084", "filename": "gcc/testsuite/rust.test/fail_compilation/func1.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc1.rs?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,9 @@\n+fn test(x: i32) -> bool {\n+    return x + 1;\n+}\n+\n+fn main() {\n+    let an_integer = 5;\n+\n+    let call_test = test(1);\n+}"}, {"sha": "cc324548892ccfae4c30a1f5384dfb20df0c2bec", "filename": "gcc/testsuite/rust.test/rust-test.exp", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Frust-test.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41c14b45ac604ebd69a6715445cdb10fc5c5ec07/gcc%2Ftestsuite%2Frust.test%2Frust-test.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Frust-test.exp?ref=41c14b45ac604ebd69a6715445cdb10fc5c5ec07", "patch": "@@ -0,0 +1,436 @@\n+# Copyright (C) 2012-2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Test using the DMD testsuite.\n+# Load support procs.\n+load_lib rust-dg.exp\n+\n+#\n+# Convert DMD arguments to RUST equivalent\n+#\n+\n+proc rust-convert-args { args } {\n+    set out \"\"\n+\n+    foreach arg [split [lindex $args 0] \" \"] {\n+\t# List of switches kept in ASCII collated order.\n+\tif [string match \"-D\" $arg] {\n+\t    lappend out \"-fdoc\"\n+\n+\t} elseif { [regexp -- {^-I([\\w+/-]+)} $arg pattern path] } {\n+\t    lappend out \"-I$path\"\n+\n+\t} elseif { [regexp -- {^-J([\\w+/-]+)} $arg pattern path] } {\n+\t    lappend out \"-J$path\"\n+\n+\t} elseif [string match \"-allinst\" $arg] {\n+\t    lappend out \"-fall-instantiations\"\n+\n+\t} elseif [string match \"-betterC\" $arg] {\n+\t    lappend out \"-fno-druntime\"\n+\n+\t} elseif { [string match \"-boundscheck\" $arg]\n+\t\t || [string match \"-boundscheck=on\" $arg] } {\n+\t    lappend out \"-fbounds-check\"\n+\n+\t} elseif { [string match \"-boundscheck=off\" $arg]\n+\t\t   || [string match \"-noboundscheck\" $arg] } {\n+\t    lappend out \"-fno-bounds-check\"\n+\n+\t} elseif [string match \"-boundscheck=safeonly\" $arg] {\n+\t    lappend out \"-fbounds-check=safeonly\"\n+\n+\t} elseif [string match \"-c\" $arg] {\n+\t    lappend out \"-c\"\n+\n+\t} elseif [string match \"-d\" $arg] {\n+\t    lappend out \"-Wno-deprecated\"\n+\n+\t} elseif [string match \"-de\" $arg] {\n+\t    lappend out \"-Wdeprecated\"\n+\t    lappend out \"-Werror\"\n+\n+\t} elseif [string match \"-debug\" $arg] {\n+\t    lappend out \"-fdebug\"\n+\n+\t} elseif [regexp -- {^-debug=(\\w+)} $arg pattern value] {\n+\t    lappend out \"-fdebug=$value\"\n+\n+\t} elseif [string match \"-dip1000\" $arg] {\n+\t    lappend out \"-ftransition=dip1000\"\n+\n+\t} elseif [string match \"-dip25\" $arg] {\n+\t    lappend out \"-ftransition=dip25\"\n+\n+\t} elseif [string match \"-dw\" $arg] {\n+\t    lappend out \"-Wdeprecated\"\n+\t    lappend out \"-Wno-error\"\n+\n+\t} elseif [string match \"-fPIC\" $arg] {\n+\t    lappend out \"-fPIC\"\n+\n+\t} elseif { [string match \"-g\" $arg]\n+\t\t   || [string match \"-gc\" $arg] } {\n+\t    lappend out \"-g\"\n+\n+\t} elseif [string match \"-inline\" $arg] {\n+\t    lappend out \"-finline-functions\"\n+\n+\t} elseif [string match \"-main\" $arg] {\n+\t    lappend out \"-fmain\"\n+\n+\t} elseif [regexp -- {^-mv=([\\w+=./-]+)} $arg pattern value] {\n+\t    lappend out \"-fmodule-file=$value\"\n+\n+\t} elseif [string match \"-O\" $arg] {\n+\t    lappend out \"-O2\"\n+\n+\t} elseif [string match \"-release\" $arg] {\n+\t    lappend out \"-frelease\"\n+\n+\t} elseif [regexp -- {^-transition=(\\w+)} $arg pattern value] {\n+\t    lappend out \"-ftransition=$value\"\n+\n+\t} elseif [string match \"-unittest\" $arg] {\n+\t    lappend out \"-funittest\"\n+\n+\t} elseif [string match \"-verrors=spec\" $arg] {\n+\t    lappend out \"-Wspeculative\"\n+\n+\t} elseif [regexp -- {^-verrors=(\\d+)} $arg pattern num] {\n+\t    lappend out \"-fmax-errors=$num\"\n+\n+\t} elseif [regexp -- {^-version=(\\w+)} $arg pattern value] {\n+\t    lappend out \"-fversion=$value\"\n+\n+\t} elseif [string match \"-vtls\" $arg] {\n+\t    lappend out \"-ftransition=tls\"\n+\n+\t} elseif [string match \"-w\" $arg] {\n+\t    lappend out \"-Wall\"\n+\t    lappend out \"-Werror\"\n+\n+\t} elseif [string match \"-wi\" $arg] {\n+\t    lappend out \"-Wall\"\n+\t    lappend out \"-Wno-error\"\n+\n+\t} else {\n+\t    # print \"Unhandled Argument: $arg\"\n+\t}\n+    }\n+\n+    return $out\n+}\n+\n+proc rust-copy-extra { base extra } {\n+    # Split base, folder/file.\n+    set type [file dirname $extra]\n+\n+    # print \"Filename: $base - $extra\"\n+\n+    set fdin [open $base/$extra r]\n+    fconfigure $fdin -encoding binary\n+\n+    file mkdir $type\n+    set fdout [open $extra w]\n+    fconfigure $fdout -encoding binary\n+\n+    while { [gets $fdin copy_line] >= 0 } {\n+\tset out_line $copy_line\n+\tputs $fdout $out_line\n+    }\n+\n+    close $fdin\n+    close $fdout\n+\n+    # Remove file once test is finished.\n+    upvar 2 cleanup_extra_files cleanups\n+    lappend cleanups $extra\n+\n+    return $extra\n+}\n+\n+#\n+# Translate DMD test directives to dejagnu equivalent.\n+#\n+#   COMPILE_SEPARATELY: Not handled.\n+#   EXECUTE_ARGS:\tParameters to add to the execution of the test.\n+#   COMPILED_IMPORTS:\tList of modules files that are imported by the main\n+#\t\t\tsource file that should be included in compilation.\n+#\t\t\tCurrently handled the same as EXTRA_SOURCES.\n+#   EXTRA_SOURCES:\tList of extra sources to build and link along with\n+#\t\t\tthe test.\n+#   EXTRA_FILES:\tList of extra files to copy for the test runs.\n+#   PERMUTE_ARGS:\tThe set of arguments to permute in multiple compiler\n+#\t\t\tinvocations.  An empty set means only one permutation\n+#\t\t\twith no arguments.\n+#   TEST_OUTPUT:\tThe output expected from the compilation.\n+#   POST_SCRIPT:\tNot handled.\n+#   REQUIRED_ARGS:\tArguments to add to the compiler command line.\n+#   DISABLED:\t\tNot handled.\n+#\n+\n+proc dmd2dg { base test } {\n+    global DEFAULT_DFLAGS\n+    global PERMUTE_ARGS\n+    global RUST_EXECUTE_ARGS\n+\n+    set PERMUTE_ARGS $DEFAULT_DFLAGS\n+    set RUST_EXECUTE_ARGS \"\"\n+\n+    set extra_sources \"\"\n+    set extra_files \"\"\n+\n+    # Split base, folder/file.\n+    set type [file dirname $test]\n+    set name [file tail $test]\n+\n+    print \"Filename: $base - $test\"\n+\n+    set fdin [open $base/$test r]\n+    #fconfigure $fdin -encoding binary\n+\n+    file mkdir $type\n+    set fdout [open $test w]\n+    #fconfigure $fdout -encoding binary\n+\n+    while { [gets $fdin copy_line] >= 0 } {\n+\tset out_line $copy_line\n+\n+\tif [regexp -- {COMPILE_SEPARATELY} $copy_line] {\n+\t    # COMPILE_SEPARATELY is not handled.\n+\t    regsub -- {COMPILE_SEPARATELY.*$} $copy_line \"\" out_line\n+\n+\t} elseif [regexp -- {DISABLED} $copy_line] {\n+\t    # DISABLED is not handled.\n+\t    regsub -- {DISABLED.*$} $copy_line \"\" out_line\n+\n+\t} elseif [regexp -- {POST_SCRIPT} $copy_line] {\n+\t    # POST_SCRIPT is not handled\n+\t    regsub -- {POST_SCRIPT.*$} $copy_line \"\" out_line\n+\n+\t} elseif [regexp -- {PERMUTE_ARGS\\s*:\\s*(.*)} $copy_line match args] {\n+\t    # PERMUTE_ARGS is handled by rust-do-test.\n+\t    set PERMUTE_ARGS [rust-convert-args $args]\n+\t    regsub -- {PERMUTE_ARGS.*$} $copy_line \"\" out_line\n+\n+\t} elseif [regexp -- {EXECUTE_ARGS\\s*:\\s*(.*)} $copy_line match args] {\n+\t    # EXECUTE_ARGS is handled by rust_load.\n+\t    foreach arg $args {\n+\t\tlappend RUST_EXECUTE_ARGS $arg\n+\t    }\n+\t    regsub -- {EXECUTE_ARGS.*$} $copy_line \"\" out_line\n+\n+\t} elseif [regexp -- {REQUIRED_ARGS\\s*:\\s*(.*)} $copy_line match args] {\n+\t    # Convert all listed arguments to from dmd to rust-style.\n+\t    set new_option \"{ dg-additional-options \\\"[rust-convert-args $args]\\\" }\"\n+\t    regsub -- {REQUIRED_ARGS.*$} $copy_line $new_option out_line\n+\n+\t} elseif [regexp -- {EXTRA_SOURCES\\s*:\\s*(.*)} $copy_line match sources] {\n+\t    # EXTRA_SOURCES are appended to extra_sources list\n+\t    foreach srcfile $sources {\n+\t\tlappend extra_sources $srcfile\n+\t    }\n+\t    regsub -- {EXTRA_SOURCES.*$} $copy_line \"\" out_line\n+\n+\t} elseif [regexp -- {EXTRA_CPP_SOURCES\\s*:\\s*(.*)} $copy_line match sources] {\n+\t    # EXTRA_CPP_SOURCES are appended to extra_sources list\n+\t    foreach srcfile $sources {\n+\t\t# C++ sources are found in the extra-files directory.\n+\t\tlappend extra_sources \"extra-files/$srcfile\"\n+\t    }\n+\t    regsub -- {EXTRA_CPP_SOURCES.*$} $copy_line \"\" out_line\n+\n+\t} elseif [regexp -- {EXTRA_FILES\\s*:\\s*(.*)} $copy_line match files] {\n+\t    # EXTRA_FILES are appended to extra_files list\n+\t    foreach file $files {\n+\t\tlappend extra_files $file\n+\t    }\n+\t    regsub -- {EXTRA_FILES.*$} $copy_line \"\" out_line\n+\n+\t} elseif [regexp -- {COMPILED_IMPORTS\\s*:\\s*(.*)} $copy_line match sources] {\n+\t    # COMPILED_IMPORTS are appended to extra_sources list\n+\t    foreach import $sources {\n+\t\tlappend extra_sources $import\n+\t    }\n+\t    regsub -- {COMPILED_IMPORTS.*$} $copy_line \"\" out_line\n+\n+\t}\n+\n+\tputs $fdout $out_line\n+    }\n+\n+    # Now that all extra sources and files have been collected, copy them all\n+    # to the testsuite build directory.\n+    if { [llength $extra_sources] > 0 } {\n+\tforeach srcfile $extra_sources {\n+\t    rust-copy-extra $base \"$type/$srcfile\"\n+\t}\n+\tset out_line \"// { dg-additional-sources \\\"$extra_sources\\\" }\"\n+\tputs $fdout $out_line\n+    }\n+\n+    if { [llength $extra_files] > 0 } {\n+\tforeach file $extra_files {\n+\t    rust-copy-extra $base \"$type/$file\"\n+\t}\n+\tset out_line \"// { dg-additional-files \\\"$extra_files\\\" }\"\n+\tputs $fdout $out_line\n+    }\n+\n+    # Add specific options for test type\n+\n+    # DMD's testsuite is extremely verbose, compiler messages from constructs\n+    # such as pragma(msg, ...) would otherwise cause tests to fail.\n+    set out_line \"// { dg-prune-output .* }\"\n+    puts $fdout $out_line\n+\n+    # Compilable files are successful if an output is generated.\n+    # Fail compilable are successful if an output is not generated.\n+    # Runnable must compile, link, and return 0 to be successful by default.\n+    switch $type {\n+\trunnable {\n+\t    if ![isnative] {\n+\t\tset out_line \"// { dg-final { output-exists } }\"\n+\t\tputs $fdout $out_line\n+\t    }\n+\t}\n+\n+\tcompilable {\n+\t    puts $fdout \"// { dg-final { output-exists } }\"\n+\t}\n+\n+\tfail_compilation {\n+\t    puts $fdout \"// { dg-do run { xfail *-*-* } }\"\n+\t}\n+    }\n+\n+    close $fdin\n+    close $fdout\n+\n+    return $test\n+}\n+\n+\n+proc rust-permute-options { options } {\n+    set result { }\n+    set n [expr 1<<[llength $options]]\n+    for { set i 0 } { $i<$n } { incr i } {\n+\tset option \"\"\n+\tfor { set j 0 } { $j<[llength $options] } { incr j } {\n+\t    if [expr $i & 1 << $j] {\n+\t\tappend option [lindex $options $j]\n+\t\tappend option \" \"\n+\t    }\n+\t}\n+\tlappend result $option\n+\n+    }\n+    return $result\n+}\n+\n+\n+proc rust-do-test { } {\n+    global srcdir subdir\n+    global dg-do-what-default\n+    global verbose\n+\n+    # If a testcase doesn't have special options, use these.\n+    global DEFAULT_DFLAGS\n+    if ![info exists DEFAULT_DFLAGS] then {\n+\tset DEFAULT_DFLAGS \"-g -O2\"\n+    }\n+\n+    # These are special options to use on testcase, and override DEFAULT_DFLAGS\n+    global PERMUTE_ARGS\n+\n+    # Set if an extra option should be passed to link to shared druntime.\n+    global SHARED_OPTION\n+\n+    # Additional arguments for rust_load\n+    global RUST_EXECUTE_ARGS\n+\n+    # Initialize `dg'.\n+    dg-init\n+\n+    # Allow blank linkes in output for all of rust.test.\n+    global allow_blank_lines\n+    set save_allow_blank_lines $allow_blank_lines\n+    if { !$allow_blank_lines } {\n+\tset allow_blank_lines 2\n+    }\n+\n+    # Create rust.test link so test names include that subdir.\n+    catch { file link $subdir . }\n+\n+    # Main loop.\n+\n+    # set verbose 1\n+    # set dg-final-code \"\"\n+    # Find all tests and pass to routine.\n+    foreach test [lsort [find $srcdir/$subdir *]] {\n+\tregexp -- \"(.*)/(.+)/(.+)\\.rs$\" $test match base dir name ext\n+\tset ext \"rs\"\n+\n+\t# Skip invalid test extensions\n+\tif { [lsearch \"rs\" $ext] == -1 } {\n+\t    continue\n+\t}\t\n+\n+\t# Convert to DG test.\n+\tset imports [format \"-I%s/%s\" $base $dir]\n+\tset cleanup_extra_files \"\"\n+\t# Include $subdir prefix so test names follow DejaGnu conventions.\n+\tset filename \"$subdir/[dmd2dg $base $dir/$name.$ext]\"\n+\n+\tif { $dir == \"runnable\" } {\n+\t    append PERMUTE_ARGS \" $SHARED_OPTION\"\n+\t}\n+\tset options [rust-permute-options [lsort -unique $PERMUTE_ARGS]]\n+\n+\tswitch $dir {\n+\t    compilable {\n+\t\tfor { set i 0 } { $i<[llength $options] } { incr i } {\n+\t\t    set flags [lindex $options $i]\n+\t\t    set dg-do-what-default \"compile\"\n+\t\t    rust-dg-runtest $filename $flags $imports\n+\t\t}\n+\t    }\n+\n+\t    fail_compilation {\n+\t\tfor { set i 0 } { $i<[llength $options] } { incr i } {\n+\t\t    set flags [lindex $options $i]\n+\t\t    set dg-do-what-default \"compile\"\n+\t\t    rust-dg-runtest $filename $flags $imports\n+\t\t}\n+\t    }\n+\t}\n+\n+\t# Cleanup test directory.\n+\tforeach srcfile $cleanup_extra_files {\n+\t    file delete $subdir/$srcfile\n+\t}\n+\tfile delete $filename\n+    }\n+\n+    set allow_blank_lines $save_allow_blank_lines\n+\n+    # All done.\n+    dg-finish\n+}\n+\n+rust-do-test\n+"}]}