{"sha": "9816367c7c84a6b7b533a5aee44b40fa456d28a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgxNjM2N2M3Yzg0YTZiN2I1MzNhNWFlZTQ0YjQwZmE0NTZkMjhhNw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2015-02-20T12:55:37Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2015-02-20T12:55:37Z"}, "message": "cgraph.h (clone_function_name_1): Declare.\n\n    \t* cgraph.h (clone_function_name_1): Declare.\n    \t* cgraphclones.c (clone_function_name_1): New function.\n    \t(clone_function_name): Use it.\n    \t* lto-partition.c: Include \"stringpool.h\".\n    \t(must_not_rename, maybe_rewrite_identifier,\n    \tvalidize_symbol_for_target): New static functions.\n    \t(privatize_symbol_name): Use must_not_rename.\n    \t(promote_symbol): Call validize_symbol_for_target.\n    \t(lto_promote_cross_file_statics): Likewise.\n    \t(lto_promote_statics_nonwpa): Likewise.\n\nFrom-SVN: r220855", "tree": {"sha": "b7f86a4a4bee0677428f7fbe07e9f03c662aebed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7f86a4a4bee0677428f7fbe07e9f03c662aebed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9816367c7c84a6b7b533a5aee44b40fa456d28a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9816367c7c84a6b7b533a5aee44b40fa456d28a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9816367c7c84a6b7b533a5aee44b40fa456d28a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9816367c7c84a6b7b533a5aee44b40fa456d28a7/comments", "author": null, "committer": null, "parents": [{"sha": "e4dc33272aaa7bb8660b94019627cba85740a49c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4dc33272aaa7bb8660b94019627cba85740a49c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4dc33272aaa7bb8660b94019627cba85740a49c"}], "stats": {"total": 180, "additions": 144, "deletions": 36}, "files": [{"sha": "a899997e8eb97d850da0ba98d1f126fe98814dc1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9816367c7c84a6b7b533a5aee44b40fa456d28a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9816367c7c84a6b7b533a5aee44b40fa456d28a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9816367c7c84a6b7b533a5aee44b40fa456d28a7", "patch": "@@ -1,3 +1,16 @@\n+2015-02-20  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+    \t* cgraph.h (clone_function_name_1): Declare.\n+    \t* cgraphclones.c (clone_function_name_1): New function.\n+    \t(clone_function_name): Use it.\n+    \t* lto-partition.c: Include \"stringpool.h\".\n+    \t(must_not_rename, maybe_rewrite_identifier,\n+    \tvalidize_symbol_for_target): New static functions.\n+    \t(privatize_symbol_name): Use must_not_rename.\n+    \t(promote_symbol): Call validize_symbol_for_target.\n+    \t(lto_promote_cross_file_statics): Likewise.\n+    \t(lto_promote_statics_nonwpa): Likewise.\n+\n 2015-02-20  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/64452"}, {"sha": "ec3cccda866eb31dbc95f072850f431b068fc299", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9816367c7c84a6b7b533a5aee44b40fa456d28a7/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9816367c7c84a6b7b533a5aee44b40fa456d28a7/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=9816367c7c84a6b7b533a5aee44b40fa456d28a7", "patch": "@@ -2206,6 +2206,7 @@ basic_block init_lowered_empty_function (tree, bool, gcov_type);\n \n /* In cgraphclones.c  */\n \n+tree clone_function_name_1 (const char *, const char *);\n tree clone_function_name (tree decl, const char *);\n \n void tree_function_versioning (tree, tree, vec<ipa_replace_map *, va_gc> *,"}, {"sha": "d0a5f707136e247c26cd0b63a04d3c473fd3aea1", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9816367c7c84a6b7b533a5aee44b40fa456d28a7/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9816367c7c84a6b7b533a5aee44b40fa456d28a7/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=9816367c7c84a6b7b533a5aee44b40fa456d28a7", "patch": "@@ -533,19 +533,19 @@ cgraph_node::create_clone (tree decl, gcov_type gcov_count, int freq,\n   return new_node;\n }\n \n-/* Return a new assembler name for a clone of DECL with SUFFIX.  */\n-\n static GTY(()) unsigned int clone_fn_id_num;\n \n+/* Return a new assembler name for a clone with SUFFIX of a decl named\n+   NAME.  */\n+\n tree\n-clone_function_name (tree decl, const char *suffix)\n+clone_function_name_1 (const char *name, const char *suffix)\n {\n-  tree name = DECL_ASSEMBLER_NAME (decl);\n-  size_t len = IDENTIFIER_LENGTH (name);\n+  size_t len = strlen (name);\n   char *tmp_name, *prefix;\n \n   prefix = XALLOCAVEC (char, len + strlen (suffix) + 2);\n-  memcpy (prefix, IDENTIFIER_POINTER (name), len);\n+  memcpy (prefix, name, len);\n   strcpy (prefix + len + 1, suffix);\n #ifndef NO_DOT_IN_LABEL\n   prefix[len] = '.';\n@@ -558,6 +558,16 @@ clone_function_name (tree decl, const char *suffix)\n   return get_identifier (tmp_name);\n }\n \n+/* Return a new assembler name for a clone of DECL with SUFFIX.  */\n+\n+tree\n+clone_function_name (tree decl, const char *suffix)\n+{\n+  tree name = DECL_ASSEMBLER_NAME (decl);\n+  return clone_function_name_1 (IDENTIFIER_POINTER (name), suffix);\n+}\n+\n+\n /* Create callgraph node clone with new declaration.  The actual body will\n    be copied later at compilation stage.\n "}, {"sha": "235b735a8fdb2c1b3cf527ad2d9f176ee5658cb0", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 114, "deletions": 30, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9816367c7c84a6b7b533a5aee44b40fa456d28a7/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9816367c7c84a6b7b533a5aee44b40fa456d28a7/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=9816367c7c84a6b7b533a5aee44b40fa456d28a7", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-inline.h\"\n #include \"ipa-utils.h\"\n #include \"lto-partition.h\"\n+#include \"stringpool.h\"\n \n vec<ltrans_partition> ltrans_partitions;\n \n@@ -783,39 +784,22 @@ lto_balanced_map (int n_lto_partitions)\n   free (order);\n }\n \n-/* Mangle NODE symbol name into a local name.  \n-   This is necessary to do\n-   1) if two or more static vars of same assembler name\n-      are merged into single ltrans unit.\n-   2) if prevoiusly static var was promoted hidden to avoid possible conflict\n-      with symbols defined out of the LTO world.\n-*/\n+/* Return true if we must not change the name of the NODE.  The name as\n+   extracted from the corresponding decl should be passed in NAME.  */\n \n static bool\n-privatize_symbol_name (symtab_node *node)\n+must_not_rename (symtab_node *node, const char *name)\n {\n-  tree decl = node->decl;\n-  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n-  const char *name;\n-\n-  /* If we want to privatize instrumentation clone\n-     then we need to change original function name\n-     which is used via transparent alias chain.  */\n-  if (cnode && cnode->instrumentation_clone)\n-    decl = cnode->orig_decl;\n-\n-  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\n   /* Our renaming machinery do not handle more than one change of assembler name.\n      We should not need more than one anyway.  */\n   if (node->lto_file_data\n       && lto_get_decl_name_mapping (node->lto_file_data, name) != name)\n     {\n       if (symtab->dump_file)\n \tfprintf (symtab->dump_file,\n-\t\t\"Not privatizing symbol name: %s. It privatized already.\\n\",\n-\t\tname);\n-      return false;\n+\t\t \"Not privatizing symbol name: %s. It privatized already.\\n\",\n+\t\t name);\n+      return true;\n     }\n   /* Avoid mangling of already mangled clones. \n      ???  should have a flag whether a symbol has a 'private' name already,\n@@ -825,12 +809,103 @@ privatize_symbol_name (symtab_node *node)\n     {\n       if (symtab->dump_file)\n \tfprintf (symtab->dump_file,\n-\t\t\"Not privatizing symbol name: %s. Has unique name.\\n\",\n-\t\tname);\n-      return false;\n+\t\t \"Not privatizing symbol name: %s. Has unique name.\\n\",\n+\t\t name);\n+      return true;\n     }\n+  return false;\n+}\n+\n+/* If we are an offload compiler, we may have to rewrite symbols to be\n+   valid on this target.  Return either PTR or a modified version of it.  */\n+\n+static const char *\n+maybe_rewrite_identifier (const char *ptr)\n+{\n+#if defined ACCEL_COMPILER && (defined NO_DOT_IN_LABEL || defined NO_DOLLAR_IN_LABEL)\n+#ifndef NO_DOT_IN_LABEL\n+  char valid = '.';\n+  const char reject[] = \"$\";\n+#elif !defined NO_DOLLAR_IN_LABEL\n+  char valid = '$';\n+  const char reject[] = \".\";\n+#else\n+  char valid = '_';\n+  const char reject[] = \".$\";\n+#endif\n+\n+  char *copy = NULL;\n+  const char *match = ptr;\n+  for (;;)\n+    {\n+      size_t off = strcspn (match, reject);\n+      if (match[off] == '\\0')\n+\tbreak;\n+      if (copy == NULL)\n+\t{\n+\t  copy = xstrdup (ptr);\n+\t  match = copy;\n+\t}\n+      copy[off] = valid;\n+    }\n+  return match;\n+#else\n+  return ptr;\n+#endif\n+}\n+\n+/* Ensure that the symbol in NODE is valid for the target, and if not,\n+   rewrite it.  */\n+\n+static void\n+validize_symbol_for_target (symtab_node *node)\n+{\n+  tree decl = node->decl;\n+  const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  if (must_not_rename (node, name))\n+    return;\n+\n+  const char *name2 = maybe_rewrite_identifier (name);\n+  if (name2 != name)\n+    {\n+      symtab->change_decl_assembler_name (decl, get_identifier (name2));\n+      if (node->lto_file_data)\n+\tlto_record_renamed_decl (node->lto_file_data, name,\n+\t\t\t\t IDENTIFIER_POINTER\n+\t\t\t\t (DECL_ASSEMBLER_NAME (decl)));\n+    }\n+}\n+\n+/* Mangle NODE symbol name into a local name.  \n+   This is necessary to do\n+   1) if two or more static vars of same assembler name\n+      are merged into single ltrans unit.\n+   2) if previously static var was promoted hidden to avoid possible conflict\n+      with symbols defined out of the LTO world.  */\n+\n+static bool\n+privatize_symbol_name (symtab_node *node)\n+{\n+  tree decl = node->decl;\n+  const char *name;\n+  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n+\n+  /* If we want to privatize instrumentation clone\n+     then we need to change original function name\n+     which is used via transparent alias chain.  */\n+  if (cnode && cnode->instrumentation_clone)\n+    decl = cnode->orig_decl;\n+\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  if (must_not_rename (node, name))\n+    return false;\n+\n+  name = maybe_rewrite_identifier (name);\n   symtab->change_decl_assembler_name (decl,\n-\t\t\t\t      clone_function_name (decl, \"lto_priv\"));\n+\t\t\t\t      clone_function_name_1 (name,\n+\t\t\t\t\t\t\t     \"lto_priv\"));\n   if (node->lto_file_data)\n     lto_record_renamed_decl (node->lto_file_data, name,\n \t\t\t     IDENTIFIER_POINTER\n@@ -868,7 +943,10 @@ promote_symbol (symtab_node *node)\n   if (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n       && DECL_VISIBILITY_SPECIFIED (node->decl)\n       && TREE_PUBLIC (node->decl))\n-    return;\n+    {\n+      validize_symbol_for_target (node);\n+      return;\n+    }\n \n   gcc_checking_assert (!TREE_PUBLIC (node->decl)\n \t\t       && !DECL_EXTERNAL (node->decl));\n@@ -1007,7 +1085,10 @@ lto_promote_cross_file_statics (void)\n \t      /* ... or if we do not partition it. This mean that it will\n \t\t appear in every partition refernecing it.  */\n \t      || node->get_partitioning_class () != SYMBOL_PARTITION)\n-\t    continue;\n+\t    {\n+\t      validize_symbol_for_target (node);\n+\t      continue;\n+\t    }\n \n           promote_symbol (node);\n         }\n@@ -1022,5 +1103,8 @@ lto_promote_statics_nonwpa (void)\n {\n   symtab_node *node;\n   FOR_EACH_SYMBOL (node)\n-    rename_statics (NULL, node);\n+    {\n+      rename_statics (NULL, node);\n+      validize_symbol_for_target (node);\n+    }\n }"}]}