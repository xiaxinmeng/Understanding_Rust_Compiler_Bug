{"sha": "f9f27ee563eb3741820d0fa91196900dd5621108", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlmMjdlZTU2M2ViMzc0MTgyMGQwZmE5MTE5NjkwMGRkNTYyMTEwOA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "2000-06-24T11:12:58Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-06-24T11:12:58Z"}, "message": "Vector support: rtx and mode definitions\n\nFrom-SVN: r34677", "tree": {"sha": "dac16ab34bb2645a309aa730b9bf3506da65f28b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dac16ab34bb2645a309aa730b9bf3506da65f28b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9f27ee563eb3741820d0fa91196900dd5621108", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f27ee563eb3741820d0fa91196900dd5621108", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f27ee563eb3741820d0fa91196900dd5621108", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f27ee563eb3741820d0fa91196900dd5621108/comments", "author": null, "committer": null, "parents": [{"sha": "e4e3ab5ad4749f7d157da8e34c9ffa7175dc6866", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4e3ab5ad4749f7d157da8e34c9ffa7175dc6866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4e3ab5ad4749f7d157da8e34c9ffa7175dc6866"}], "stats": {"total": 189, "additions": 186, "deletions": 3}, "files": [{"sha": "4d78128541fec2810e9572702620a27811ef3bae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f27ee563eb3741820d0fa91196900dd5621108/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f27ee563eb3741820d0fa91196900dd5621108/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9f27ee563eb3741820d0fa91196900dd5621108", "patch": "@@ -1,3 +1,18 @@\n+2000-06-24  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* rtl.texi (Vector Operations): New node.\n+\t(Arithmetic): Add ss_plus, us_plus, ss_minus, us_minus.\n+\t(Conversions): Add ss_truncate, us_truncate.\n+\t* rtl.def (VEC_MERGE, VEC_SELECT, VEC_CONCAT, VEC_REORDER,\n+\tVEC_CONST, VEC_DUPLICATE, SS_PLUS, SS_MINUS, SS_TRUNCATE,\n+\tUS_TRUNCATE): New rtx codes.\n+\t* machmode.def: Add vector modes.\n+\t* machmode.h (enum mode_class): Add MODE_VECTOR_INT and\n+\tMODE_VECTOR_FLOAT.\n+\t(INTEGER_MODE_P): Check for MODE_VECTOR_INT.\n+\t(FLOAT_MODE_P): Check for MODE_VECTOR_FLOAT.\n+\t(VECTOR_MODE_P): New.\n+\n 2000-06-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cpp.texi: Clarify #pragma GCC namespace.\t"}, {"sha": "2cd93eea38760166fcd1c8305930f3992b694b25", "filename": "gcc/machmode.def", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f27ee563eb3741820d0fa91196900dd5621108/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f27ee563eb3741820d0fa91196900dd5621108/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=f9f27ee563eb3741820d0fa91196900dd5621108", "patch": "@@ -45,6 +45,7 @@ Boston, MA 02111-1307, USA.  */\n    MODE_PARTIAL_INT - PQImode, PHImode, PSImode and PDImode\n    MODE_CC - modes used for representing the condition code in a register\n    MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT - complex number\n+   MODE_VECTOR_INT, MODE_VECTOR_FLOAT - vector\n    MODE_RANDOM - anything else\n \n    Fourth argument is the relative size of the object, in bytes.\n@@ -100,6 +101,33 @@ DEF_MACHMODE (CDImode, \"CDI\", MODE_COMPLEX_INT, 16, 8, CTImode)\n DEF_MACHMODE (CTImode, \"CTI\", MODE_COMPLEX_INT, 32, 16, COImode)\n DEF_MACHMODE (COImode, \"COI\", MODE_COMPLEX_INT, 64, 32, VOIDmode)\n \n+/* Vector modes.  */\n+/* There are no V1xx vector modes.  These are equivalent to normal non-vector\n+   modes.  */\n+DEF_MACHMODE (V2QImode, \"V2QI\", MODE_VECTOR_INT, 2, 1, VOIDmode)\n+DEF_MACHMODE (V2HImode, \"V2HI\", MODE_VECTOR_INT, 4, 2, VOIDmode)\n+DEF_MACHMODE (V2SImode, \"V2SI\", MODE_VECTOR_INT, 8, 4, VOIDmode)\n+DEF_MACHMODE (V2DImode, \"V2DI\", MODE_VECTOR_INT, 16, 8, VOIDmode)\n+\n+DEF_MACHMODE (V4QImode, \"V4QI\", MODE_VECTOR_INT, 4, 1, VOIDmode)\n+DEF_MACHMODE (V4HImode, \"V4HI\", MODE_VECTOR_INT, 8, 2, VOIDmode)\n+DEF_MACHMODE (V4SImode, \"V4SI\", MODE_VECTOR_INT, 16, 4, VOIDmode)\n+DEF_MACHMODE (V4DImode, \"V4DI\", MODE_VECTOR_INT, 32, 8, VOIDmode)\n+\n+DEF_MACHMODE (V8QImode, \"V8QI\", MODE_VECTOR_INT, 8, 1, VOIDmode)\n+DEF_MACHMODE (V8HImode, \"V8HI\", MODE_VECTOR_INT, 16, 2, VOIDmode)\n+DEF_MACHMODE (V8SImode, \"V8SI\", MODE_VECTOR_INT, 32, 4, VOIDmode)\n+DEF_MACHMODE (V8DImode, \"V8DI\", MODE_VECTOR_INT, 64, 8, VOIDmode)\n+\n+DEF_MACHMODE (V2SFmode, \"V2SF\", MODE_VECTOR_FLOAT, 8, 4, VOIDmode)\n+DEF_MACHMODE (V2DFmode, \"V2DF\", MODE_VECTOR_FLOAT, 16, 8, VOIDmode)\n+\n+DEF_MACHMODE (V4SFmode, \"V4SF\", MODE_VECTOR_FLOAT, 16, 4, VOIDmode)\n+DEF_MACHMODE (V4DFmode, \"V4DF\", MODE_VECTOR_FLOAT, 32, 8, VOIDmode)\n+\n+DEF_MACHMODE (V8SFmode, \"V8SF\", MODE_VECTOR_FLOAT, 32, 4, VOIDmode)\n+DEF_MACHMODE (V8DFmode, \"V8DF\", MODE_VECTOR_FLOAT, 64, 8, VOIDmode)\n+\n /* BLKmode is used for structures, arrays, etc.\n    that fit no more specific mode.  */\n DEF_MACHMODE (BLKmode, \"BLK\", MODE_RANDOM, 0, 0, VOIDmode)"}, {"sha": "f5a3ab9681652cc4f3871624e5b84d3d180ac475", "filename": "gcc/machmode.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f27ee563eb3741820d0fa91196900dd5621108/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f27ee563eb3741820d0fa91196900dd5621108/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=f9f27ee563eb3741820d0fa91196900dd5621108", "patch": "@@ -42,7 +42,9 @@ extern const char * const mode_name[];\n #define GET_MODE_NAME(MODE)\t\t(mode_name[(int) (MODE)])\n \n enum mode_class { MODE_RANDOM, MODE_INT, MODE_FLOAT, MODE_PARTIAL_INT, MODE_CC,\n-\t\t  MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT, MAX_MODE_CLASS};\n+\t\t  MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT,\n+\t\t  MODE_VECTOR_INT, MODE_VECTOR_FLOAT,\n+\t\t  MAX_MODE_CLASS};\n \n /* Get the general kind of object that mode MODE represents\n    (integer, floating, complex, etc.)  */\n@@ -54,18 +56,25 @@ extern const enum mode_class mode_class[];\n #define INTEGRAL_MODE_P(MODE)\t\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n    || GET_MODE_CLASS (MODE) == MODE_PARTIAL_INT \\\n-   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_INT)\n+   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_INT \\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_INT)\n \n /* Nonzero if MODE is a floating-point mode.  */\n #define FLOAT_MODE_P(MODE)\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n-   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\n+   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT \\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT)\n \n /* Nonzero if MODE is a complex mode.  */\n #define COMPLEX_MODE_P(MODE)\t\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_COMPLEX_INT\t\\\n    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\n \n+/* Nonzero if MODE is a vector mode.  */\n+#define VECTOR_MODE_P(MODE)\t\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_VECTOR_INT\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT)\n+\n /* Get the size in bytes of an object of mode MODE.  */\n \n extern const unsigned int mode_size[];"}, {"sha": "6a0b73e87ffcd4d93269dbec41c1cb79d49d5821", "filename": "gcc/rtl.def", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f27ee563eb3741820d0fa91196900dd5621108/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f27ee563eb3741820d0fa91196900dd5621108/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=f9f27ee563eb3741820d0fa91196900dd5621108", "patch": "@@ -928,6 +928,52 @@ DEF_RTL_EXPR(CONSTANT_P_RTX, \"constant_p_rtx\", \"e\", 'x')\n    tree-based optimizations once front-end conversions are complete.  */\n DEF_RTL_EXPR(CALL_PLACEHOLDER, \"call_placeholder\", \"uuuu\", 'x')\n \n+/* Describes a merge operation between two vector values.\n+   Operands 0 and 1 are the vectors to be merged, operand 2 is a bitmask\n+   that specifies where the parts of the result are taken from.  Set bits\n+   indicate operand 0, clear bits indicate operand 1.  The parts are defined\n+   by the mode of the vectors.  */\n+DEF_RTL_EXPR(VEC_MERGE, \"vec_merge\", \"eee\", 'x')\n+\n+/* Describes an operation that selects parts of a vector.\n+   Operands 0 is the source vector, operand 1 is a PARALLEL that contains\n+   a CONST_INT for each of the subparts of the result vector, giving the\n+   number of the source subpart that should be stored into it.  */\n+DEF_RTL_EXPR(VEC_SELECT, \"vec_select\", \"ee\", 'x')\n+\n+/* Describes a vector concat operation.  Operands 0 and 1 are the source\n+   vectors, the result is a vector that is as long as operands 0 and 1\n+   combined and is the concatenation of the two source vectors.  */\n+DEF_RTL_EXPR(VEC_CONCAT, \"vec_concat\", \"ee\", 'x')\n+\n+/* Describes a vector constant.  Each part of the PARALLEL that is operand 0\n+   describes a constant for one of the subparts.  */\n+DEF_RTL_EXPR(VEC_CONST, \"vec_const\", \"e\", 'x')\n+\n+/* Describes an operation that converts a small vector into a larger one by\n+   duplicating the input values.  The output vector mode must have the same\n+   submodes as the input vector mode, and the number of output parts must be\n+   an integer multiple of the number of input parts.  */\n+DEF_RTL_EXPR(VEC_DUPLICATE, \"vec_duplicate\", \"e\", 'x')\n+     \n+/* Addition with signed saturation */\n+DEF_RTL_EXPR(SS_PLUS, \"ss_plus\", \"ee\", 'c')\n+\n+/* Addition with unsigned saturation */\n+DEF_RTL_EXPR(US_PLUS, \"us_plus\", \"ee\", 'c')\n+\n+/* Operand 0 minus operand 1, with signed saturation.  */\n+DEF_RTL_EXPR(SS_MINUS, \"ss_minus\", \"ee\", '2')\n+\n+/* Operand 0 minus operand 1, with unsigned saturation.  */\n+DEF_RTL_EXPR(US_MINUS, \"us_minus\", \"ee\", '2')\n+\n+/* Signed saturating truncate.  */\n+DEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", '1')\n+\n+/* Unsigned saturating truncate.  */\n+DEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", '1')\n+\n /* The SSA phi operator. \n \n    The argument is a vector of 2N rtxes.  Element 2N+1 is a CONST_INT"}, {"sha": "0bd9f0c46690927e8aec584c4f870dc1974e681e", "filename": "gcc/rtl.texi", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f27ee563eb3741820d0fa91196900dd5621108/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f27ee563eb3741820d0fa91196900dd5621108/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=f9f27ee563eb3741820d0fa91196900dd5621108", "patch": "@@ -29,6 +29,7 @@ form uses nested parentheses to indicate the pointers in the internal form.\n * Arithmetic::        Expressions representing arithmetic on other expressions.\n * Comparisons::       Expressions representing comparison of expressions.\n * Bit Fields::        Expressions representing bitfields in memory or reg.\n+* Vector Operations:: Expressions involving vector datatypes.\n * Conversions::       Extending, truncating, floating or fixing.\n * RTL Declarations::  Declaring volatility, constancy, etc.\n * Side Effects::      Expressions for storing in registers, etc.\n@@ -1347,6 +1348,30 @@ item minus the number of bits set by the @code{high} code\n @item (minus:@var{m} @var{x} @var{y})\n Like @code{plus} but represents subtraction.\n \n+@findex ss_plus\n+@cindex RTL addition with signed saturation\n+@item (ss_plus:@var{m} @var{x} @var{y})\n+\n+Like @code{plus}, but using signed saturation in case of an overflow.\n+\n+@findex us_plus\n+@cindex RTL addition with unsigned saturation\n+@item (us_plus:@var{m} @var{x} @var{y})\n+\n+Like @code{plus}, but using unsigned saturation in case of an overflow.\n+\n+@findex ss_minus\n+@cindex RTL addition with signed saturation\n+@item (ss_minus:@var{m} @var{x} @var{y})\n+\n+Like @code{minus}, but using signed saturation in case of an overflow.\n+\n+@findex us_minus\n+@cindex RTL addition with unsigned saturation\n+@item (us_minus:@var{m} @var{x} @var{y})\n+\n+Like @code{minus}, but using unsigned saturation in case of an overflow.\n+\n @findex compare\n @cindex RTL comparison\n @item (compare:@var{m} @var{x} @var{y})\n@@ -1695,6 +1720,52 @@ bit field.  The same sequence of bits are extracted, but they\n are filled to an entire word with zeros instead of by sign-extension.\n @end table\n \n+@node Vector Operations\n+@section Vector Operations\n+@cindex vector operations\n+\n+All normal rtl expressions can be used with vector modes; they are\n+interpreted as operating on each part of the vector independently.\n+Additionally, there are a few new expressions to describe specific vector\n+operations.\n+\n+@table @code\n+@findex vec_merge\n+@item (vec_merge:@var{m} @var{vec1} @var{vec2} @var{items})\n+This describes a merge operation between two vectors.  The result is a vector\n+of mode @var{m}; its elements are selected from either @var{vec1} or\n+@var{vec2}.  Which elements are selected is described by @var{items}, which\n+is a bit mask represented by a @code{const_int}; a zero bit indicates the\n+corresponding element in the result vector is taken from @var{vec2} while\n+a set bit indicates it is taken from @var{vec1}.\n+\n+@findex vec_select\n+@item (vec_select:@var{m} @var{vec1} @var{selection})\n+This describes an operation that selects parts of a vector.  @var{vec1} is\n+the source vector, @var{selection} is a @code{parallel} that contains a\n+@code{const_int} for each of the subparts of the result vector, giving the\n+number of the source subpart that should be stored into it.\n+\n+@findex vec_concat\n+@item (vec_concat:@var{m} @var{vec1} @var{vec2})\n+Describes a vector concat operation.  The result is a concatenation of the\n+vectors @var{vec1} and @var{vec2}; its length is the sum of the lengths of\n+the two inputs.\n+\n+@findex vec_const\n+@item (vec_const:@var{m} @var{subparts})\n+This describes a constant vector.  @var{subparts} is a @code{parallel} that\n+contains a constant for each of the subparts of the vector.\n+\n+@findex vec_duplicate\n+@item (vec_duplicate:@var{m} @var{vec})\n+This operation converts a small vector into a larger one by duplicating the\n+input values.  The output vector mode must have the same submodes as the\n+input vector mode, and the number of output parts must be an integer multiple\n+of the number of input parts.\n+\n+@end table\n+\n @node Conversions\n @section Conversions\n @cindex conversions\n@@ -1747,6 +1818,20 @@ Represents the result of truncating the value @var{x}\n to machine mode @var{m}.  @var{m} must be a fixed-point mode\n and @var{x} a fixed-point value of a mode wider than @var{m}.\n \n+@findex ss_truncate\n+@item (ss_truncate:@var{m} @var{x})\n+Represents the result of truncating the value @var{x}\n+to machine mode @var{m}, using signed saturation in the case of\n+overflow.  Both @var{m} and the mode of @var{x} must be fixed-point\n+modes.\n+\n+@findex us_truncate\n+@item (us_truncate:@var{m} @var{x})\n+Represents the result of truncating the value @var{x}\n+to machine mode @var{m}, using unsigned saturation in the case of\n+overflow.  Both @var{m} and the mode of @var{x} must be fixed-point\n+modes.\n+\n @findex float_truncate\n @item (float_truncate:@var{m} @var{x})\n Represents the result of truncating the value @var{x}"}]}