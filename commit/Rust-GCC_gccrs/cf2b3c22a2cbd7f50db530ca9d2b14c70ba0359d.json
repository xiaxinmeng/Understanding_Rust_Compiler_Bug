{"sha": "cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YyYjNjMjJhMmNiZDdmNTBkYjUzMGNhOWQyYjE0YzcwYmEwMzU5ZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-09-30T19:55:45Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-09-30T19:55:45Z"}, "message": "re PR fortran/40996 ([F03] ALLOCATABLE scalars)\n\nfortran/\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* check.c (gfc_check_same_type_as): New function for checking\n\tSAME_TYPE_AS and EXTENDS_TYPE_OF.\n\t* decl.c (encapsulate_class_symbol): Set ABSTRACT attribute for class\n\tcontainer, if the contained type has it. Add an initializer for the\n\tclass container.\n\t(add_init_expr_to_sym): Handle BT_CLASS.\n\t(vindex_counter): New counter for setting vindices.\n\t(gfc_match_derived_decl): Set vindex for all derived types, not only\n\tthose which are being extended.\n\t* expr.c (gfc_check_assign_symbol): Handle NULL initialization of class\n\tpointers.\n\t* gfortran.h (gfc_isym_id): New values GFC_ISYM_SAME_TYPE_AS and\n\tGFC_ISYM_EXTENDS_TYPE_OF.\n\t(gfc_type_is_extensible): New prototype.\n\t* intrinsic.h (gfc_check_same_type_as): New prototype.\n\t* intrinsic.c (add_functions): Add SAME_TYPE_AS and EXTENDS_TYPE_OF.\n\t* primary.c (gfc_expr_attr): Handle CLASS-valued functions.\n\t* resolve.c (resolve_structure_cons): Handle BT_CLASS.\n\t(type_is_extensible): Make non-static and rename to\n\t'gfc_type_is_extensible.\n\t(resolve_select_type): Renamed type_is_extensible.\n\t(resolve_class_assign): Handle NULL pointers.\n\t(resolve_fl_variable_derived): Renamed type_is_extensible.\n\t(resolve_fl_derived): Ditto.\n\t* trans-expr.c (gfc_trans_subcomponent_assign): Handle NULL\n\tinitialization of class pointer components.\n\t(gfc_conv_structure): Handle BT_CLASS.\n\t* trans-intrinsic.c (gfc_conv_same_type_as,gfc_conv_extends_type_of):\n\tNew functions.\n\t(gfc_conv_intrinsic_function): Handle SAME_TYPE_AS and EXTENDS_TYPE_OF.\n\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* gfortran.h (type_selector, select_type_tmp): New global variables.\n\t* match.c (type_selector, select_type_tmp): New global variables,\n\tused for SELECT TYPE statements.\n\t(gfc_match_select_type): Better error handling. Remember selector.\n\t(gfc_match_type_is): Create temporary variable.\n\t* module.c (ab_attribute): New value 'AB_IS_CLASS'.\n\t(attr_bits): New string.\n\t(mio_symbol_attribute): Handle 'is_class'.\n\t* resolve.c (resolve_select_type): Insert pointer assignment statement,\n\tto assign temporary to selector.\n\t* symbol.c (gfc_get_ha_sym_tree): Replace selector by a temporary\n\tin SELECT TYPE statements.\n\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* dump-parse-tree.c (show_code_node): Renamed 'alloc_list'.\n\t* gfortran.h (gfc_code): Rename 'alloc_list'. Add member 'ts'.\n\t(gfc_expr_to_initialize): New prototype.\n\t* match.c (alloc_opt_list): Correctly check type compatibility.\n\tRenamed 'alloc_list'.\n\t(dealloc_opt_list): Renamed 'alloc_list'.\n\t* resolve.c (expr_to_initialize): Rename to 'gfc_expr_to_initialize'\n\tand make it non-static.\n\t(resolve_allocate_expr): Set vindex for CLASS variables correctly.\n\tMove initialization code to gfc_trans_allocate. Renamed 'alloc_list'.\n\t(resolve_allocate_deallocate): Renamed 'alloc_list'.\n\t(check_class_pointer_assign): Rename to 'resolve_class_assign'. Change\n\targument type. Adjust to work with ordinary assignments.\n\t(resolve_code): Call 'resolve_class_assign' for ordinary assignments.\n\tRenamed 'check_class_pointer_assign'.\n\t* st.c (gfc_free_statement): Renamed 'alloc_list'.\n\t* trans-stmt.c (gfc_trans_allocate): Renamed 'alloc_list'. Handle\n\tsize determination and initialization of CLASS variables. Bugfix for\n\tALLOCATE statements with default initialization and SOURCE block.\n\t(gfc_trans_deallocate): Renamed 'alloc_list'.\n\n2009-09-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* trans-expr.c (gfc_conv_procedure_call): Convert a derived\n\ttype actual to a class object if the formal argument is a\n\tclass.\n\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/40996\n\t* decl.c (build_struct): Handle allocatable scalar components.\n\t* expr.c (gfc_add_component_ref): Correctly set typespec of expression,\n\tafter inserting component reference.\n\t* match.c (gfc_match_type_is,gfc_match_class_is): Make sure that no\n\tvariables are being used uninitialized.\n\t* primary.c (gfc_match_varspec): Handle CLASS array components.\n\t* resolve.c (resolve_select_type): Transform EXEC_SELECT_TYPE to\n\tEXEC_SELECT.\n\t* trans-array.c (structure_alloc_comps,gfc_trans_deferred_array):\n\tHandle allocatable scalar components.\n\t* trans-expr.c (gfc_conv_component_ref): Ditto.\n\t* trans-types.c (gfc_get_derived_type): Ditto.\n\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* decl.c (encapsulate_class_symbol): Modify names of class container\n\tcomponents by prefixing with '$'.\n\t(gfc_match_end): Handle COMP_SELECT_TYPE.\n\t* expr.c (gfc_add_component_ref): Modify names of class container\n\tcomponents by prefixing with '$'.\n\t* gfortran.h (gfc_statement): Add ST_SELECT_TYPE, ST_TYPE_IS and\n\tST_CLASS_IS.\n\t(gfc_case): New field 'ts'.\n\t(gfc_exec_op): Add EXEC_SELECT_TYPE.\n\t(gfc_type_is_extension_of): New prototype.\n\t* match.h (gfc_match_select_type,gfc_match_type_is,gfc_match_class_is):\n\tNew prototypes.\n\t* match.c (match_derived_type_spec): New function.\n\t(match_type_spec): Use 'match_derived_type_spec'.\n\t(match_case_eos): Modify error message.\n\t(gfc_match_select_type): New function.\n\t(gfc_match_case): Modify error message.\n\t(gfc_match_type_is): New function.\n\t(gfc_match_class_is): Ditto.\n\t* parse.h (gfc_compile_state): Add COMP_SELECT_TYPE.\n\t* parse.c (decode_statement): Handle SELECT TYPE, TYPE IS and CLASS IS\n\tstatements.\n\t(next_statement): Handle ST_SELECT_TYPE.\n\t(gfc_ascii_statement): Handle ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS.\n\t(parse_select_type_block): New function.\n\t(parse_executable): Handle ST_SELECT_TYPE.\n\t* resolve.c (resolve_deallocate_expr): Handle BT_CLASS. Modify names of\n\tclass container components by prefixing with '$'.\n\t(resolve_allocate_expr): Ditto.\n\t(resolve_select_type): New function.\n\t(gfc_resolve_blocks): Handle EXEC_SELECT_TYPE.\n\t(check_class_pointer_assign): Modify names of class container\n\tcomponents by prefixing with '$'.\n\t(resolve_code): Ditto.\n\t* st.c (gfc_free_statement): Ditto.\n\t* symbol.c (gfc_type_is_extension_of): New function.\n\t(gfc_type_compatible): Use 'gfc_type_is_extension_of', plus a bugfix.\n\t* trans.c (gfc_trans_code): Handel EXEC_SELECT_TYPE.\n\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\t    Paul Thomas <pault@gcc.gnu.org> \n\n\t* check.c (gfc_check_move_alloc): Arguments don't have to be arrays.\n\tThe second argument needs to be type-compatible with the first (not the\n\tother way around, which makes a difference for CLASS entities).\n\t* decl.c (encapsulate_class_symbol): New function.\n\t(build_sym,build_struct): Handle BT_CLASS, call\n\t'encapsulate_class_symbol'.\n\t(gfc_match_decl_type_spec): Remove warning, use BT_CLASS.\n\t(gfc_match_derived_decl): Set vindex;\n\t* expr.c (gfc_add_component_ref): New function.\n\t(gfc_copy_expr,gfc_check_pointer_assign,gfc_check_assign_symbol):\n\tHandle BT_CLASS.\n\t* dump-parse-tree.c (show_symbol): Print vindex.\n\t* gfortran.h (bt): New basic type BT_CLASS.\n\t(symbol_attribute): New field 'is_class'.\n\t(gfc_typespec): Remove field 'is_class'.\n\t(gfc_symbol): New field 'vindex'.\n\t(gfc_get_ultimate_derived_super_type): New prototype.\n\t(gfc_add_component_ref): Ditto.\n\t* interface.c (gfc_compare_derived_types): Pointer equality check\n\tmoved here from gfc_compare_types.\n\t(gfc_compare_types): Handle BT_CLASS and use\n\tgfc_type_compatible.\n\t* match.c (gfc_match_allocate,gfc_match_deallocate,gfc_match_call):\n\tHandle BT_CLASS.\n\t* misc.c (gfc_clear_ts): Removed is_class.\n\t(gfc_basic_typename,gfc_typename): Handle BT_CLASS.\n\t* module.c (bt_types,mio_typespec): Handle BT_CLASS.\n\t(mio_symbol): Handle vindex.\n\t* primary.c (gfc_match_varspec,gfc_variable_attr): Handle BT_CLASS.\n\t* resolve.c (find_array_spec,check_typebound_baseobject):\n\tHandle BT_CLASS.\n\t(resolve_ppc_call,resolve_expr_ppc): Don't call 'gfc_is_proc_ptr_comp'\n\tinside 'gcc_assert'.\n\t(resolve_deallocate_expr,resolve_allocate_expr): Handle BT_CLASS.\n\t(check_class_pointer_assign): New function.\n\t(resolve_code): Handle BT_CLASS, call check_class_pointer_assign.\n\t(resolve_fl_var_and_proc,type_is_extensible,resolve_fl_variable_derived,\n\tresolve_fl_variable): Handle BT_CLASS.\n\t(check_generic_tbp_ambiguity): Add special case.\n\t(resolve_typebound_procedure,resolve_fl_derived): Handle BT_CLASS.\n\t* symbol.c (gfc_get_ultimate_derived_super_type): New function.\n\t(gfc_type_compatible): Handle BT_CLASS.\n\t* trans-expr.c (conv_parent_component_references): Handle CLASS\n\tcontainers.\n\t(gfc_conv_initializer): Handle BT_CLASS.\n\t* trans-types.c (gfc_typenode_for_spec,gfc_get_derived_type):\n\tHandle BT_CLASS.\n\ntestsuite/\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* gfortran.dg/same_type_as_1.f03: New test.\n\t* gfortran.dg/same_type_as_2.f03: Ditto.\n\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* gfortran.dg/select_type_1.f03: Extended.\n\t* gfortran.dg/select_type_3.f03: New test.\n\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* gfortran.dg/class_allocate_1.f03: New test.\n\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/40996\n\t* gfortran.dg/allocatable_scalar_3.f90: New test.\n\t* gfortran.dg/select_type_2.f03: Ditto.\n\t* gfortran.dg/typebound_proc_5.f03: Changed error messages.\n\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* gfortran.dg/block_name_2.f90: Modified error message.\n\t* gfortran.dg/select_6.f90: Ditto.\n\t* gfortran.dg/select_type_1.f03: New test.\n\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* gfortran.dg/allocate_derived_1.f90: Remove -w option.\n\t* gfortran.dg/class_1.f03: Ditto.\n\t* gfortran.dg/class_2.f03: Ditto.\n\t* gfortran.dg/proc_ptr_comp_pass_1.f90: Ditto.\n\t* gfortran.dg/proc_ptr_comp_pass_2.f90: Ditto.\n\t* gfortran.dg/proc_ptr_comp_pass_3.f90: Ditto.\n\t* gfortran.dg/typebound_call_10.f03: Ditto.\n\t* gfortran.dg/typebound_call_2.f03: Ditto.\n\t* gfortran.dg/typebound_call_3.f03: Ditto.\n\t* gfortran.dg/typebound_call_4.f03: Ditto.\n\t* gfortran.dg/typebound_call_9.f03: Ditto.\n\t* gfortran.dg/typebound_generic_3.f03: Ditto.\n\t* gfortran.dg/typebound_generic_4.f03: Ditto.\n\t* gfortran.dg/typebound_operator_1.f03: Ditto.\n\t* gfortran.dg/typebound_operator_2.f03: Ditto.\n\t* gfortran.dg/typebound_operator_3.f03: Ditto.\n\t* gfortran.dg/typebound_operator_4.f03: Ditto.\n\t* gfortran.dg/typebound_proc_1.f08: Ditto.\n\t* gfortran.dg/typebound_proc_5.f03: Ditto.\n\t* gfortran.dg/typebound_proc_6.f03: Ditto.\n\nFrom-SVN: r152345", "tree": {"sha": "9be5ba66c657d4994b913a8f2381816a1671533c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9be5ba66c657d4994b913a8f2381816a1671533c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/comments", "author": null, "committer": null, "parents": [{"sha": "c39b74e1323190aff4fdbc5cbd6e2b104ef3b548", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c39b74e1323190aff4fdbc5cbd6e2b104ef3b548", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c39b74e1323190aff4fdbc5cbd6e2b104ef3b548"}], "stats": {"total": 2168, "additions": 1845, "deletions": 323}, "files": [{"sha": "04aac0c2936daa9c9f264a6073544bd0783c31c0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,3 +1,188 @@\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* check.c (gfc_check_same_type_as): New function for checking\n+\tSAME_TYPE_AS and EXTENDS_TYPE_OF.\n+\t* decl.c (encapsulate_class_symbol): Set ABSTRACT attribute for class\n+\tcontainer, if the contained type has it. Add an initializer for the\n+\tclass container.\n+\t(add_init_expr_to_sym): Handle BT_CLASS.\n+\t(vindex_counter): New counter for setting vindices.\n+\t(gfc_match_derived_decl): Set vindex for all derived types, not only\n+\tthose which are being extended.\n+\t* expr.c (gfc_check_assign_symbol): Handle NULL initialization of class\n+\tpointers.\n+\t* gfortran.h (gfc_isym_id): New values GFC_ISYM_SAME_TYPE_AS and\n+\tGFC_ISYM_EXTENDS_TYPE_OF.\n+\t(gfc_type_is_extensible): New prototype.\n+\t* intrinsic.h (gfc_check_same_type_as): New prototype.\n+\t* intrinsic.c (add_functions): Add SAME_TYPE_AS and EXTENDS_TYPE_OF.\n+\t* primary.c (gfc_expr_attr): Handle CLASS-valued functions.\n+\t* resolve.c (resolve_structure_cons): Handle BT_CLASS.\n+\t(type_is_extensible): Make non-static and rename to\n+\t'gfc_type_is_extensible.\n+\t(resolve_select_type): Renamed type_is_extensible.\n+\t(resolve_class_assign): Handle NULL pointers.\n+\t(resolve_fl_variable_derived): Renamed type_is_extensible.\n+\t(resolve_fl_derived): Ditto.\n+\t* trans-expr.c (gfc_trans_subcomponent_assign): Handle NULL\n+\tinitialization of class pointer components.\n+\t(gfc_conv_structure): Handle BT_CLASS.\n+\t* trans-intrinsic.c (gfc_conv_same_type_as,gfc_conv_extends_type_of):\n+\tNew functions.\n+\t(gfc_conv_intrinsic_function): Handle SAME_TYPE_AS and EXTENDS_TYPE_OF.\n+\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* gfortran.h (type_selector, select_type_tmp): New global variables.\n+\t* match.c (type_selector, select_type_tmp): New global variables,\n+\tused for SELECT TYPE statements.\n+\t(gfc_match_select_type): Better error handling. Remember selector.\n+\t(gfc_match_type_is): Create temporary variable.\n+\t* module.c (ab_attribute): New value 'AB_IS_CLASS'.\n+\t(attr_bits): New string.\n+\t(mio_symbol_attribute): Handle 'is_class'.\n+\t* resolve.c (resolve_select_type): Insert pointer assignment statement,\n+\tto assign temporary to selector.\n+\t* symbol.c (gfc_get_ha_sym_tree): Replace selector by a temporary\n+\tin SELECT TYPE statements.\n+\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* dump-parse-tree.c (show_code_node): Renamed 'alloc_list'.\n+\t* gfortran.h (gfc_code): Rename 'alloc_list'. Add member 'ts'.\n+\t(gfc_expr_to_initialize): New prototype.\n+\t* match.c (alloc_opt_list): Correctly check type compatibility.\n+\tRenamed 'alloc_list'.\n+\t(dealloc_opt_list): Renamed 'alloc_list'.\n+\t* resolve.c (expr_to_initialize): Rename to 'gfc_expr_to_initialize'\n+\tand make it non-static.\n+\t(resolve_allocate_expr): Set vindex for CLASS variables correctly.\n+\tMove initialization code to gfc_trans_allocate. Renamed 'alloc_list'.\n+\t(resolve_allocate_deallocate): Renamed 'alloc_list'.\n+\t(check_class_pointer_assign): Rename to 'resolve_class_assign'. Change\n+\targument type. Adjust to work with ordinary assignments.\n+\t(resolve_code): Call 'resolve_class_assign' for ordinary assignments.\n+\tRenamed 'check_class_pointer_assign'.\n+\t* st.c (gfc_free_statement): Renamed 'alloc_list'.\n+\t* trans-stmt.c (gfc_trans_allocate): Renamed 'alloc_list'. Handle\n+\tsize determination and initialization of CLASS variables. Bugfix for\n+\tALLOCATE statements with default initialization and SOURCE block.\n+\t(gfc_trans_deallocate): Renamed 'alloc_list'.\n+\n+2009-09-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* trans-expr.c (gfc_conv_procedure_call): Convert a derived\n+\ttype actual to a class object if the formal argument is a\n+\tclass.\n+\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/40996\n+\t* decl.c (build_struct): Handle allocatable scalar components.\n+\t* expr.c (gfc_add_component_ref): Correctly set typespec of expression,\n+\tafter inserting component reference.\n+\t* match.c (gfc_match_type_is,gfc_match_class_is): Make sure that no\n+\tvariables are being used uninitialized.\n+\t* primary.c (gfc_match_varspec): Handle CLASS array components.\n+\t* resolve.c (resolve_select_type): Transform EXEC_SELECT_TYPE to\n+\tEXEC_SELECT.\n+\t* trans-array.c (structure_alloc_comps,gfc_trans_deferred_array):\n+\tHandle allocatable scalar components.\n+\t* trans-expr.c (gfc_conv_component_ref): Ditto.\n+\t* trans-types.c (gfc_get_derived_type): Ditto.\n+\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* decl.c (encapsulate_class_symbol): Modify names of class container\n+\tcomponents by prefixing with '$'.\n+\t(gfc_match_end): Handle COMP_SELECT_TYPE.\n+\t* expr.c (gfc_add_component_ref): Modify names of class container\n+\tcomponents by prefixing with '$'.\n+\t* gfortran.h (gfc_statement): Add ST_SELECT_TYPE, ST_TYPE_IS and\n+\tST_CLASS_IS.\n+\t(gfc_case): New field 'ts'.\n+\t(gfc_exec_op): Add EXEC_SELECT_TYPE.\n+\t(gfc_type_is_extension_of): New prototype.\n+\t* match.h (gfc_match_select_type,gfc_match_type_is,gfc_match_class_is):\n+\tNew prototypes.\n+\t* match.c (match_derived_type_spec): New function.\n+\t(match_type_spec): Use 'match_derived_type_spec'.\n+\t(match_case_eos): Modify error message.\n+\t(gfc_match_select_type): New function.\n+\t(gfc_match_case): Modify error message.\n+\t(gfc_match_type_is): New function.\n+\t(gfc_match_class_is): Ditto.\n+\t* parse.h (gfc_compile_state): Add COMP_SELECT_TYPE.\n+\t* parse.c (decode_statement): Handle SELECT TYPE, TYPE IS and CLASS IS\n+\tstatements.\n+\t(next_statement): Handle ST_SELECT_TYPE.\n+\t(gfc_ascii_statement): Handle ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS.\n+\t(parse_select_type_block): New function.\n+\t(parse_executable): Handle ST_SELECT_TYPE.\n+\t* resolve.c (resolve_deallocate_expr): Handle BT_CLASS. Modify names of\n+\tclass container components by prefixing with '$'.\n+\t(resolve_allocate_expr): Ditto.\n+\t(resolve_select_type): New function.\n+\t(gfc_resolve_blocks): Handle EXEC_SELECT_TYPE.\n+\t(check_class_pointer_assign): Modify names of class container\n+\tcomponents by prefixing with '$'.\n+\t(resolve_code): Ditto.\n+\t* st.c (gfc_free_statement): Ditto.\n+\t* symbol.c (gfc_type_is_extension_of): New function.\n+\t(gfc_type_compatible): Use 'gfc_type_is_extension_of', plus a bugfix.\n+\t* trans.c (gfc_trans_code): Handel EXEC_SELECT_TYPE.\n+\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\t    Paul Thomas <pault@gcc.gnu.org> \n+\n+\t* check.c (gfc_check_move_alloc): Arguments don't have to be arrays.\n+\tThe second argument needs to be type-compatible with the first (not the\n+\tother way around, which makes a difference for CLASS entities).\n+\t* decl.c (encapsulate_class_symbol): New function.\n+\t(build_sym,build_struct): Handle BT_CLASS, call\n+\t'encapsulate_class_symbol'.\n+\t(gfc_match_decl_type_spec): Remove warning, use BT_CLASS.\n+\t(gfc_match_derived_decl): Set vindex;\n+\t* expr.c (gfc_add_component_ref): New function.\n+\t(gfc_copy_expr,gfc_check_pointer_assign,gfc_check_assign_symbol):\n+\tHandle BT_CLASS.\n+\t* dump-parse-tree.c (show_symbol): Print vindex.\n+\t* gfortran.h (bt): New basic type BT_CLASS.\n+\t(symbol_attribute): New field 'is_class'.\n+\t(gfc_typespec): Remove field 'is_class'.\n+\t(gfc_symbol): New field 'vindex'.\n+\t(gfc_get_ultimate_derived_super_type): New prototype.\n+\t(gfc_add_component_ref): Ditto.\n+\t* interface.c (gfc_compare_derived_types): Pointer equality check\n+\tmoved here from gfc_compare_types.\n+\t(gfc_compare_types): Handle BT_CLASS and use\n+\tgfc_type_compatible.\n+\t* match.c (gfc_match_allocate,gfc_match_deallocate,gfc_match_call):\n+\tHandle BT_CLASS.\n+\t* misc.c (gfc_clear_ts): Removed is_class.\n+\t(gfc_basic_typename,gfc_typename): Handle BT_CLASS.\n+\t* module.c (bt_types,mio_typespec): Handle BT_CLASS.\n+\t(mio_symbol): Handle vindex.\n+\t* primary.c (gfc_match_varspec,gfc_variable_attr): Handle BT_CLASS.\n+\t* resolve.c (find_array_spec,check_typebound_baseobject):\n+\tHandle BT_CLASS.\n+\t(resolve_ppc_call,resolve_expr_ppc): Don't call 'gfc_is_proc_ptr_comp'\n+\tinside 'gcc_assert'.\n+\t(resolve_deallocate_expr,resolve_allocate_expr): Handle BT_CLASS.\n+\t(check_class_pointer_assign): New function.\n+\t(resolve_code): Handle BT_CLASS, call check_class_pointer_assign.\n+\t(resolve_fl_var_and_proc,type_is_extensible,resolve_fl_variable_derived,\n+\tresolve_fl_variable): Handle BT_CLASS.\n+\t(check_generic_tbp_ambiguity): Add special case.\n+\t(resolve_typebound_procedure,resolve_fl_derived): Handle BT_CLASS.\n+\t* symbol.c (gfc_get_ultimate_derived_super_type): New function.\n+\t(gfc_type_compatible): Handle BT_CLASS.\n+\t* trans-expr.c (conv_parent_component_references): Handle CLASS\n+\tcontainers.\n+\t(gfc_conv_initializer): Handle BT_CLASS.\n+\t* trans-types.c (gfc_typenode_for_spec,gfc_get_derived_type):\n+\tHandle BT_CLASS.\n+\n 2009-09-29  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/39626"}, {"sha": "171eeaa97bfa2739ffecf5dfd3282aadd13d6347", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -2135,9 +2135,6 @@ gfc_check_move_alloc (gfc_expr *from, gfc_expr *to)\n   if (variable_check (from, 0) == FAILURE)\n     return FAILURE;\n \n-  if (array_check (from, 0) == FAILURE)\n-    return FAILURE;\n-\n   attr = gfc_variable_attr (from, NULL);\n   if (!attr.allocatable)\n     {\n@@ -2150,9 +2147,6 @@ gfc_check_move_alloc (gfc_expr *from, gfc_expr *to)\n   if (variable_check (to, 0) == FAILURE)\n     return FAILURE;\n \n-  if (array_check (to, 0) == FAILURE)\n-    return FAILURE;\n-\n   attr = gfc_variable_attr (to, NULL);\n   if (!attr.allocatable)\n     {\n@@ -2162,7 +2156,7 @@ gfc_check_move_alloc (gfc_expr *from, gfc_expr *to)\n       return FAILURE;\n     }\n \n-  if (same_type_check (from, 0, to, 1) == FAILURE)\n+  if (same_type_check (to, 1, from, 0) == FAILURE)\n     return FAILURE;\n \n   if (to->rank != from->rank)\n@@ -2646,6 +2640,46 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n }\n \n \n+gfc_try\n+gfc_check_same_type_as (gfc_expr *a, gfc_expr *b)\n+{\n+\n+  if (a->ts.type != BT_DERIVED && a->ts.type != BT_CLASS)\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+\t\t \"must be of a derived type\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &a->where);\n+      return FAILURE;\n+    }\n+\n+  if (!gfc_type_is_extensible (a->ts.u.derived))\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+\t\t \"must be of an extensible type\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic, &a->where);\n+      return FAILURE;\n+    }\n+\n+  if (b->ts.type != BT_DERIVED && b->ts.type != BT_CLASS)\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+\t\t \"must be of a derived type\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &b->where);\n+      return FAILURE;\n+    }\n+\n+  if (!gfc_type_is_extensible (b->ts.u.derived))\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+\t\t \"must be of an extensible type\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &b->where);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n gfc_try\n gfc_check_scale (gfc_expr *x, gfc_expr *i)\n {"}, {"sha": "20718ca5161f3672fd2649a112c4c7f35bfdb01b", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 94, "deletions": 17, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1025,6 +1025,79 @@ verify_c_interop_param (gfc_symbol *sym)\n }\n \n \n+/* Build a polymorphic CLASS entity, using the symbol that comes from build_sym.\n+   A CLASS entity is represented by an encapsulating type, which contains the\n+   declared type as '$data' component, plus an integer component '$vindex'\n+   which determines the dynamic type.  */\n+\n+static gfc_try\n+encapsulate_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n+\t\t\t  gfc_array_spec **as)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 5];\n+  gfc_symbol *fclass;\n+  gfc_component *c;\n+\n+  /* Determine the name of the encapsulating type.  */\n+  if ((*as) && (*as)->rank && attr->allocatable)\n+    sprintf (name, \".class.%s.%d.a\", ts->u.derived->name, (*as)->rank);\n+  else if ((*as) && (*as)->rank)\n+    sprintf (name, \".class.%s.%d\", ts->u.derived->name, (*as)->rank);\n+  else if (attr->allocatable)\n+    sprintf (name, \".class.%s.a\", ts->u.derived->name);\n+  else\n+    sprintf (name, \".class.%s\", ts->u.derived->name);\n+\n+  gfc_find_symbol (name, ts->u.derived->ns, 0, &fclass);\n+  if (fclass == NULL)\n+    {\n+      gfc_symtree *st;\n+      /* If not there, create a new symbol.  */\n+      fclass = gfc_new_symbol (name, ts->u.derived->ns);\n+      st = gfc_new_symtree (&ts->u.derived->ns->sym_root, name);\n+      st->n.sym = fclass;\n+      gfc_set_sym_referenced (fclass);\n+      fclass->refs++;\n+      fclass->ts.type = BT_UNKNOWN;\n+      fclass->vindex = ts->u.derived->vindex;\n+      fclass->attr.abstract = ts->u.derived->attr.abstract;\n+      if (ts->u.derived->f2k_derived)\n+\tfclass->f2k_derived = gfc_get_namespace (NULL, 0);\n+      if (gfc_add_flavor (&fclass->attr, FL_DERIVED,\n+\t  NULL, &gfc_current_locus) == FAILURE)\n+\treturn FAILURE;\n+\n+      /* Add component '$data'.  */\n+      if (gfc_add_component (fclass, \"$data\", &c) == FAILURE)\n+   \treturn FAILURE;\n+      c->ts = *ts;\n+      c->ts.type = BT_DERIVED;\n+      c->attr.access = ACCESS_PRIVATE;\n+      c->ts.u.derived = ts->u.derived;\n+      c->attr.pointer = attr->pointer || attr->dummy;\n+      c->attr.allocatable = attr->allocatable;\n+      c->attr.dimension = attr->dimension;\n+      c->as = (*as);\n+      c->initializer = gfc_get_expr ();\n+      c->initializer->expr_type = EXPR_NULL;\n+\n+      /* Add component '$vindex'.  */\n+      if (gfc_add_component (fclass, \"$vindex\", &c) == FAILURE)\n+   \treturn FAILURE;\n+      c->ts.type = BT_INTEGER;\n+      c->ts.kind = 4;\n+      c->attr.access = ACCESS_PRIVATE;\n+      c->initializer = gfc_int_expr (0);\n+    }\n+\n+  fclass->attr.extension = 1;\n+  fclass->attr.is_class = 1;\n+  ts->u.derived = fclass;\n+  attr->allocatable = attr->pointer = attr->dimension = 0;\n+  (*as) = NULL;  /* XXX */\n+  return SUCCESS;\n+}\n+\n /* Function called by variable_decl() that adds a name to the symbol table.  */\n \n static gfc_try\n@@ -1097,6 +1170,9 @@ build_sym (const char *name, gfc_charlen *cl,\n \n   sym->attr.implied_index = 0;\n \n+  if (sym->ts.type == BT_CLASS)\n+    encapsulate_class_symbol (&sym->ts, &sym->attr, &sym->as);\n+\n   return SUCCESS;\n }\n \n@@ -1250,6 +1326,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n       /* Check if the assignment can happen. This has to be put off\n \t until later for a derived type variable.  */\n       if (sym->ts.type != BT_DERIVED && init->ts.type != BT_DERIVED\n+\t  && sym->ts.type != BT_CLASS && init->ts.type != BT_CLASS\n \t  && gfc_check_assign_symbol (sym, init) == FAILURE)\n \treturn FAILURE;\n \n@@ -1467,17 +1544,12 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \t}\n     }\n \n+  if (c->ts.type == BT_CLASS)\n+    encapsulate_class_symbol (&c->ts, &c->attr, &c->as);\n+\n   /* Check array components.  */\n   if (!c->attr.dimension)\n-    {\n-      if (c->attr.allocatable)\n-\t{\n-\t  gfc_error (\"Allocatable component at %C must be an array\");\n-\t  return FAILURE;\n-\t}\n-      else\n-\treturn SUCCESS;\n-    }\n+    return SUCCESS;\n \n   if (c->attr.pointer)\n     {\n@@ -2370,24 +2442,20 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n     }\n \n   m = gfc_match (\" type ( %n )\", name);\n-  if (m != MATCH_YES)\n+  if (m == MATCH_YES)\n+    ts->type = BT_DERIVED;\n+  else\n     {\n       m = gfc_match (\" class ( %n )\", name);\n       if (m != MATCH_YES)\n \treturn m;\n-      ts->is_class = 1;\n+      ts->type = BT_CLASS;\n \n       if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: CLASS statement at %C\")\n \t\t\t  == FAILURE)\n \treturn MATCH_ERROR;\n-\n-      /* TODO: Implement Polymorphism.  */\n-      gfc_warning (\"Polymorphic entities are not yet implemented. \"\n-\t\t   \"CLASS will be treated like TYPE at %C\");\n     }\n \n-  ts->type = BT_DERIVED;\n-\n   /* Defer association of the derived type until the end of the\n      specification block.  However, if the derived type can be\n      found, add it to the typespec.  */  \n@@ -5441,6 +5509,7 @@ gfc_match_end (gfc_statement *st)\n       break;\n \n     case COMP_SELECT:\n+    case COMP_SELECT_TYPE:\n       *st = ST_END_SELECT;\n       target = \" select\";\n       eos_ok = 0;\n@@ -6703,6 +6772,10 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)\n }\n \n \n+/* Counter for assigning a unique vindex number to each derived type.  */\n+static int vindex_counter = 0;\n+\n+\n /* Match the beginning of a derived type declaration.  If a type name\n    was the result of a function, then it is possible to have a symbol\n    already to be known as a derived type yet have no components.  */\n@@ -6823,6 +6896,10 @@ gfc_match_derived_decl (void)\n       st->n.sym = sym;\n     }\n \n+  if (!sym->vindex)\n+    /* Set the vindex for this type and increment the counter.  */\n+    sym->vindex = ++vindex_counter;\n+\n   /* Take over the ABSTRACT attribute.  */\n   sym->attr.abstract = attr.abstract;\n "}, {"sha": "32ff298d6e0179f0d49811026faee340a961e521", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -825,7 +825,12 @@ show_symbol (gfc_symbol *sym)\n     }\n \n   if (sym->f2k_derived)\n-    show_f2k_derived (sym->f2k_derived);\n+    {\n+      show_indent ();\n+      if (sym->vindex)\n+\tfprintf (dumpfile, \"vindex: %d\", sym->vindex);\n+      show_f2k_derived (sym->f2k_derived);\n+    }\n \n   if (sym->formal)\n     {\n@@ -1448,7 +1453,7 @@ show_code_node (int level, gfc_code *c)\n \t  show_expr (c->expr2);\n \t}\n \n-      for (a = c->ext.alloc_list; a; a = a->next)\n+      for (a = c->ext.alloc.list; a; a = a->next)\n \t{\n \t  fputc (' ', dumpfile);\n \t  show_expr (a->expr);\n@@ -1470,7 +1475,7 @@ show_code_node (int level, gfc_code *c)\n \t  show_expr (c->expr2);\n \t}\n \n-      for (a = c->ext.alloc_list; a; a = a->next)\n+      for (a = c->ext.alloc.list; a; a = a->next)\n \t{\n \t  fputc (' ', dumpfile);\n \t  show_expr (a->expr);"}, {"sha": "32aa68265bb8c242bdc3899d4d98befa7dfd0b4e", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -330,6 +330,36 @@ gfc_has_vector_index (gfc_expr *e)\n }\n \n \n+/* Insert a reference to the component of the given name.\n+   Only to be used with CLASS containers.  */\n+\n+void\n+gfc_add_component_ref (gfc_expr *e, const char *name)\n+{\n+  gfc_ref **tail = &(e->ref);\n+  gfc_ref *next = NULL;\n+  gfc_symbol *derived = e->symtree->n.sym->ts.u.derived;\n+  while (*tail != NULL)\n+    {\n+      if ((*tail)->type == REF_COMPONENT)\n+\tderived = (*tail)->u.c.component->ts.u.derived;\n+      if ((*tail)->type == REF_ARRAY && (*tail)->next == NULL)\n+\tbreak;\n+      tail = &((*tail)->next);\n+    }\n+  if (*tail != NULL && strcmp (name, \"$data\") == 0)\n+    next = *tail;\n+  (*tail) = gfc_get_ref();\n+  (*tail)->next = next;\n+  (*tail)->type = REF_COMPONENT;\n+  (*tail)->u.c.sym = derived;\n+  (*tail)->u.c.component = gfc_find_component (derived, name, true, true);\n+  gcc_assert((*tail)->u.c.component);\n+  if (!next)\n+    e->ts = (*tail)->u.c.component->ts;\n+}\n+\n+\n /* Copy a shape array.  */\n \n mpz_t *\n@@ -481,6 +511,7 @@ gfc_copy_expr (gfc_expr *p)\n \tcase BT_HOLLERITH:\n \tcase BT_LOGICAL:\n \tcase BT_DERIVED:\n+\tcase BT_CLASS:\n \t  break;\t\t/* Already done.  */\n \n \tcase BT_PROCEDURE:\n@@ -3124,7 +3155,9 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       return FAILURE;\n     }\n \n-  if (!pointer && !proc_pointer)\n+  if (!pointer && !proc_pointer\n+\t&& !(lvalue->ts.type == BT_CLASS\n+\t\t&& lvalue->ts.u.derived->components->attr.pointer))\n     {\n       gfc_error (\"Pointer assignment to non-POINTER at %L\", &lvalue->where);\n       return FAILURE;\n@@ -3244,15 +3277,16 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       return SUCCESS;\n     }\n \n-  if (!gfc_compare_types (&lvalue->ts, &rvalue->ts))\n+  if (lvalue->ts.type != BT_CLASS && lvalue->symtree->n.sym->ts.type != BT_CLASS\n+\t&& !gfc_compare_types (&lvalue->ts, &rvalue->ts))\n     {\n       gfc_error (\"Different types in pointer assignment at %L; attempted \"\n \t\t \"assignment of %s to %s\", &lvalue->where, \n \t\t gfc_typename (&rvalue->ts), gfc_typename (&lvalue->ts));\n       return FAILURE;\n     }\n \n-  if (lvalue->ts.kind != rvalue->ts.kind)\n+  if (lvalue->ts.type != BT_CLASS && lvalue->ts.kind != rvalue->ts.kind)\n     {\n       gfc_error (\"Different kind type parameters in pointer \"\n \t\t \"assignment at %L\", &lvalue->where);\n@@ -3332,7 +3366,10 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_expr *rvalue)\n   lvalue.symtree->n.sym = sym;\n   lvalue.where = sym->declared_at;\n \n-  if (sym->attr.pointer || sym->attr.proc_pointer)\n+  if (sym->attr.pointer || sym->attr.proc_pointer\n+      || (sym->ts.type == BT_CLASS \n+\t  && sym->ts.u.derived->components->attr.pointer\n+\t  && rvalue->expr_type == EXPR_NULL))\n     r = gfc_check_pointer_assign (&lvalue, rvalue);\n   else\n     r = gfc_check_assign (&lvalue, rvalue, 1);"}, {"sha": "326112df4823a6562fd729a5c27867ae2cbad766", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -142,9 +142,8 @@ gfc_source_form;\n /* Basic types.  BT_VOID is used by ISO C Binding so funcs like c_f_pointer\n    can take any arg with the pointer attribute as a param.  */\n typedef enum\n-{ BT_UNKNOWN = 1, BT_INTEGER, BT_REAL, BT_COMPLEX,\n-  BT_LOGICAL, BT_CHARACTER, BT_DERIVED, BT_PROCEDURE, BT_HOLLERITH,\n-  BT_VOID\n+{ BT_UNKNOWN = 1, BT_INTEGER, BT_REAL, BT_COMPLEX, BT_LOGICAL, BT_CHARACTER,\n+  BT_DERIVED, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID\n }\n bt;\n \n@@ -222,7 +221,7 @@ typedef enum\n   ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WAIT, \n   ST_WRITE, ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,\n   ST_SIMPLE_IF, ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT,\n-  ST_ENUM, ST_ENUMERATOR, ST_END_ENUM,\n+  ST_ENUM, ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,\n   ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL, ST_OMP_END_CRITICAL,\n   ST_OMP_END_DO, ST_OMP_END_MASTER, ST_OMP_END_ORDERED, ST_OMP_END_PARALLEL,\n   ST_OMP_END_PARALLEL_DO, ST_OMP_END_PARALLEL_SECTIONS,\n@@ -364,6 +363,7 @@ enum gfc_isym_id\n   GFC_ISYM_EXIT,\n   GFC_ISYM_EXP,\n   GFC_ISYM_EXPONENT,\n+  GFC_ISYM_EXTENDS_TYPE_OF,\n   GFC_ISYM_FDATE,\n   GFC_ISYM_FGET,\n   GFC_ISYM_FGETC,\n@@ -478,6 +478,7 @@ enum gfc_isym_id\n   GFC_ISYM_RESHAPE,\n   GFC_ISYM_RRSPACING,\n   GFC_ISYM_RSHIFT,\n+  GFC_ISYM_SAME_TYPE_AS,\n   GFC_ISYM_SC_KIND,\n   GFC_ISYM_SCALE,\n   GFC_ISYM_SCAN,\n@@ -670,6 +671,7 @@ typedef struct\n \n   unsigned is_bind_c:1;\t\t/* say if is bound to C.  */\n   unsigned extension:1;\t\t/* extends a derived type.  */\n+  unsigned is_class:1;\t\t/* is a CLASS container.  */\n \n   /* These flags are both in the typespec and attribute.  The attribute\n      list is what gets read from/written to a module file.  The typespec\n@@ -849,7 +851,6 @@ typedef struct\n   u;\n \n   struct gfc_symbol *interface;\t/* For PROCEDURE declarations.  */\n-  unsigned int is_class:1;\n   int is_c_interop;\n   int is_iso_c;\n   bt f90_type; \n@@ -1133,6 +1134,11 @@ typedef struct gfc_symbol\n   /* Defined only for Cray pointees; points to their pointer.  */\n   struct gfc_symbol *cp_pointer;\n \n+  int entry_id;\t\t\t/* Used in resolve.c for entries.  */\n+\n+  /* CLASS vindex for declared and dynamic types in the class.  */\n+  int vindex;\n+\n   struct gfc_symbol *common_next;\t/* Links for COMMON syms */\n \n   /* This is in fact a gfc_common_head but it is only used for pointer\n@@ -1143,8 +1149,6 @@ typedef struct gfc_symbol\n      order.  */\n   int dummy_order;\n \n-  int entry_id;\n-\n   gfc_namelist *namelist, *namelist_tail;\n \n   /* Change management fields.  Symbols that might be modified by the\n@@ -1856,6 +1860,9 @@ typedef struct gfc_case\n      represents the default case.  */\n   gfc_expr *low, *high;\n \n+  /* Only used for SELECT TYPE.  */\n+  gfc_typespec ts;\n+\n   /* Next case label in the list of cases for a single CASE label.  */\n   struct gfc_case *next;\n \n@@ -1972,7 +1979,7 @@ typedef enum\n   EXEC_ENTRY, EXEC_PAUSE, EXEC_STOP, EXEC_CONTINUE, EXEC_INIT_ASSIGN,\n   EXEC_IF, EXEC_ARITHMETIC_IF, EXEC_DO, EXEC_DO_WHILE, EXEC_SELECT, EXEC_BLOCK,\n   EXEC_FORALL, EXEC_WHERE, EXEC_CYCLE, EXEC_EXIT, EXEC_CALL_PPC,\n-  EXEC_ALLOCATE, EXEC_DEALLOCATE, EXEC_END_PROCEDURE,\n+  EXEC_ALLOCATE, EXEC_DEALLOCATE, EXEC_END_PROCEDURE, EXEC_SELECT_TYPE,\n   EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n   EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,\n@@ -2006,7 +2013,14 @@ typedef struct gfc_code\n     gfc_actual_arglist *actual;\n     gfc_case *case_list;\n     gfc_iterator *iterator;\n-    gfc_alloc *alloc_list;\n+\n+    struct\n+    {\n+      gfc_typespec ts;\n+      gfc_alloc *list;\n+    }\n+    alloc;\n+\n     gfc_open *open;\n     gfc_close *close;\n     gfc_filepos *filepos;\n@@ -2476,6 +2490,8 @@ gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n gfc_typebound_proc* gfc_get_typebound_proc (void);\n gfc_symbol* gfc_get_derived_super_type (gfc_symbol*);\n+gfc_symbol* gfc_get_ultimate_derived_super_type (gfc_symbol*);\n+bool gfc_type_is_extension_of (gfc_symbol *, gfc_symbol *);\n bool gfc_type_compatible (gfc_typespec *, gfc_typespec *);\n gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*,\n \t\t\t\t      const char*, bool, locus*);\n@@ -2534,6 +2550,10 @@ void gfc_free_equiv (gfc_equiv *);\n void gfc_free_data (gfc_data *);\n void gfc_free_case_list (gfc_case *);\n \n+/* Used for SELECT TYPE statements.  */\n+extern gfc_symbol *type_selector;\n+extern gfc_symtree *select_type_tmp;\n+\n /* matchexp.c -- FIXME too?  */\n gfc_expr *gfc_get_parentheses (gfc_expr *);\n \n@@ -2548,9 +2568,9 @@ void gfc_resolve_omp_do_blocks (gfc_code *, gfc_namespace *);\n void gfc_free_actual_arglist (gfc_actual_arglist *);\n gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n const char *gfc_extract_int (gfc_expr *, int *);\n-gfc_expr *gfc_expr_to_initialize (gfc_expr *);\n bool is_subref_array (gfc_expr *);\n \n+void gfc_add_component_ref (gfc_expr *, const char *);\n gfc_expr *gfc_build_conversion (gfc_expr *);\n void gfc_free_ref_list (gfc_ref *);\n void gfc_type_convert_binary (gfc_expr *);\n@@ -2614,6 +2634,8 @@ gfc_try gfc_resolve_dim_arg (gfc_expr *);\n int gfc_is_formal_arg (void);\n void gfc_resolve_substring_charlen (gfc_expr *);\n match gfc_iso_c_sub_interface(gfc_code *, gfc_symbol *);\n+gfc_expr *gfc_expr_to_initialize (gfc_expr *);\n+bool gfc_type_is_extensible (gfc_symbol *sym);\n \n \n /* array.c */"}, {"sha": "0fd4742a1de895e3eecacf08dc64b550dabd2df1", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -360,6 +360,9 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n {\n   gfc_component *dt1, *dt2;\n \n+  if (derived1 == derived2)\n+    return 1;\n+\n   /* Special case for comparing derived types across namespaces.  If the\n      true names and module names are the same and the module name is\n      nonnull, then they are equal.  */\n@@ -448,13 +451,15 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)\n   if (ts1->type == BT_VOID || ts2->type == BT_VOID)\n     return 1;\n    \n-  if (ts1->type != ts2->type)\n+  if (ts1->type != ts2->type\n+      && ((ts1->type != BT_DERIVED && ts1->type != BT_CLASS)\n+\t  || (ts2->type != BT_DERIVED && ts2->type != BT_CLASS)))\n     return 0;\n-  if (ts1->type != BT_DERIVED)\n+  if (ts1->type != BT_DERIVED && ts1->type != BT_CLASS)\n     return (ts1->kind == ts2->kind);\n \n   /* Compare derived types.  */\n-  if (ts1->u.derived == ts2->u.derived)\n+  if (gfc_type_compatible (ts1, ts2))\n     return 1;\n \n   return gfc_compare_derived_types (ts1->u.derived ,ts2->u.derived);"}, {"sha": "3e8e3f2e5a4c09f0fc8bbc161fe2dcef16f0a7ee", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1599,6 +1599,12 @@ add_functions (void)\n \n   make_generic (\"exponent\", GFC_ISYM_EXPONENT, GFC_STD_F95);\n \n+  add_sym_2 (\"extends_type_of\", GFC_ISYM_EXTENDS_TYPE_OF, CLASS_INQUIRY,\n+\t     ACTUAL_NO, BT_LOGICAL, dl, GFC_STD_F2003,\n+\t     gfc_check_same_type_as, NULL, NULL,\n+\t     a, BT_UNKNOWN, 0, REQUIRED,\n+\t     mo, BT_UNKNOWN, 0, REQUIRED);\n+\n   add_sym_0 (\"fdate\",  GFC_ISYM_FDATE, NO_CLASS, ACTUAL_NO, BT_CHARACTER, dc, GFC_STD_GNU,\n \t     NULL, NULL, gfc_resolve_fdate);\n \n@@ -2307,6 +2313,12 @@ add_functions (void)\n \n   make_generic (\"rrspacing\", GFC_ISYM_RRSPACING, GFC_STD_F95);\n \n+  add_sym_2 (\"same_type_as\", GFC_ISYM_SAME_TYPE_AS, CLASS_INQUIRY, ACTUAL_NO,\n+\t     BT_LOGICAL, dl, GFC_STD_F2003,\n+\t     gfc_check_same_type_as, NULL, NULL,\n+\t     a, BT_UNKNOWN, 0, REQUIRED,\n+\t     b, BT_UNKNOWN, 0, REQUIRED);\n+\n   add_sym_2 (\"scale\", GFC_ISYM_SCALE, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n \t     gfc_check_scale, gfc_simplify_scale, gfc_resolve_scale,\n \t     x, BT_REAL, dr, REQUIRED, i, BT_INTEGER, di, REQUIRED);"}, {"sha": "acd3f7896d0d8ceac36caeedbffbc8b6f80e1f42", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -119,6 +119,7 @@ gfc_try gfc_check_real (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_rename (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_repeat (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_reshape (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_same_type_as (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_scale (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_scan (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_second_sub (gfc_expr *);"}, {"sha": "3e969e78ca29d1c078797658a068c623233d9ba7", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 272, "deletions": 61, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -29,6 +29,10 @@ along with GCC; see the file COPYING3.  If not see\n int gfc_matching_procptr_assignment = 0;\n bool gfc_matching_prefix = false;\n \n+/* Used for SELECT TYPE statements.  */\n+gfc_symbol *type_selector;\n+gfc_symtree *select_type_tmp;\n+\n /* For debugging and diagnostic purposes.  Return the textual representation\n    of the intrinsic operator OP.  */\n const char *\n@@ -2245,6 +2249,39 @@ gfc_free_alloc_list (gfc_alloc *p)\n }\n \n \n+/* Match a Fortran 2003 derived-type-spec (F03:R455), which is just the name of\n+   an accessible derived type.  */\n+\n+static match\n+match_derived_type_spec (gfc_typespec *ts)\n+{\n+  locus old_locus; \n+  gfc_symbol *derived;\n+\n+  old_locus = gfc_current_locus; \n+\n+  if (gfc_match_symbol (&derived, 1) == MATCH_YES)\n+    {\n+      if (derived->attr.flavor == FL_DERIVED)\n+\t{\n+\t  ts->type = BT_DERIVED;\n+\t  ts->u.derived = derived;\n+\t  return MATCH_YES;\n+\t}\n+      else\n+\t{\n+\t  /* Enforce F03:C476.  */\n+\t  gfc_error (\"'%s' at %L is not an accessible derived type\",\n+\t\t     derived->name, &gfc_current_locus);\n+\t  return MATCH_ERROR;\n+\t}\n+    }\n+\n+  gfc_current_locus = old_locus; \n+  return MATCH_NO;\n+}\n+\n+\n /* Match a Fortran 2003 type-spec (F03:R401).  This is similar to\n    gfc_match_decl_type_spec() from decl.c, with the following exceptions:\n    It only includes the intrinsic types from the Fortran 2003 standard\n@@ -2256,7 +2293,6 @@ static match\n match_type_spec (gfc_typespec *ts)\n {\n   match m;\n-  gfc_symbol *derived;\n   locus old_locus;\n \n   gfc_clear_ts (ts);\n@@ -2303,43 +2339,27 @@ match_type_spec (gfc_typespec *ts)\n       goto kind_selector;\n     }\n \n-  if (gfc_match_symbol (&derived, 1) == MATCH_YES)\n+  m = match_derived_type_spec (ts);\n+  if (m == MATCH_YES)\n     {\n-      if (derived->attr.flavor == FL_DERIVED)\n-\t{\n-\t  old_locus = gfc_current_locus;\n-\t  if (gfc_match (\" :: \") != MATCH_YES)\n-\t    return MATCH_ERROR;\n-\t  gfc_current_locus = old_locus;\n-\t  ts->type = BT_DERIVED;\n-\t  ts->u.derived = derived;\n-\t  /* Enfore F03:C401.  */\n-\t  if (derived->attr.abstract)\n-\t    {\n-\t      gfc_error (\"Derived type '%s' at %L may not be ABSTRACT\",\n-\t\t\t derived->name, &old_locus);\n-\t      return MATCH_ERROR;\n-\t    }\n-\t  return MATCH_YES;\n-\t}\n-      else\n+      old_locus = gfc_current_locus;\n+      if (gfc_match (\" :: \") != MATCH_YES)\n+\treturn MATCH_ERROR;\n+      gfc_current_locus = old_locus;\n+      /* Enfore F03:C401.  */\n+      if (ts->u.derived->attr.abstract)\n \t{\n-\t  if (gfc_match (\" :: \") == MATCH_YES)\n-\t    {\n-\t      /* Enforce F03:C476.  */\n-\t      gfc_error (\"'%s' at %L is not an accessible derived type\",\n-\t\t\t derived->name, &old_locus);\n-\t      return MATCH_ERROR;\n-\t    }\n-\t  else\n-\t    {\n-\t      gfc_current_locus = old_locus;\n-\t      return MATCH_NO;\n-\t    }\n+\t  gfc_error (\"Derived type '%s' at %L may not be ABSTRACT\",\n+\t\t     ts->u.derived->name, &old_locus);\n+\t  return MATCH_ERROR;\n \t}\n+      return MATCH_YES;\n     }\n+  else if (m == MATCH_ERROR && gfc_match (\" :: \") == MATCH_YES)\n+    return MATCH_ERROR;\n \n-  /* If a type is not matched, simply return MATCH_NO.  */ \n+  /* If a type is not matched, simply return MATCH_NO.  */\n+  gfc_current_locus = old_locus;\n   return MATCH_NO;\n \n kind_selector:\n@@ -2429,6 +2449,7 @@ gfc_match_allocate (void)\n   gfc_alloc *head, *tail;\n   gfc_expr *stat, *errmsg, *tmp, *source;\n   gfc_typespec ts;\n+  gfc_symbol *sym;\n   match m;\n   locus old_locus;\n   bool saw_stat, saw_errmsg, saw_source, b1, b2, b3;\n@@ -2513,19 +2534,20 @@ gfc_match_allocate (void)\n \ttail->expr->ts.u.derived = gfc_use_derived (tail->expr->ts.u.derived);\n \n       /* FIXME: disable the checking on derived types and arrays.  */\n+      sym = tail->expr->symtree->n.sym;\n       b1 = !(tail->expr->ref\n \t   && (tail->expr->ref->type == REF_COMPONENT\n \t\t|| tail->expr->ref->type == REF_ARRAY));\n-      b2 = tail->expr->symtree->n.sym\n-\t   && !(tail->expr->symtree->n.sym->attr.allocatable\n-\t\t|| tail->expr->symtree->n.sym->attr.pointer\n-\t\t|| tail->expr->symtree->n.sym->attr.proc_pointer);\n-      b3 = tail->expr->symtree->n.sym\n-\t   && tail->expr->symtree->n.sym->ns\n-\t   && tail->expr->symtree->n.sym->ns->proc_name\n-\t   && (tail->expr->symtree->n.sym->ns->proc_name->attr.allocatable\n-\t\t|| tail->expr->symtree->n.sym->ns->proc_name->attr.pointer\n-\t\t|| tail->expr->symtree->n.sym->ns->proc_name->attr.proc_pointer);\n+      if (sym && sym->ts.type == BT_CLASS)\n+\tb2 = !(sym->ts.u.derived->components->attr.allocatable\n+\t       || sym->ts.u.derived->components->attr.pointer);\n+      else\n+\tb2 = sym && !(sym->attr.allocatable || sym->attr.pointer\n+\t\t      || sym->attr.proc_pointer);\n+      b3 = sym && sym->ns && sym->ns->proc_name\n+\t   && (sym->ns->proc_name->attr.allocatable\n+\t\t|| sym->ns->proc_name->attr.pointer\n+\t\t|| sym->ns->proc_name->attr.proc_pointer);\n       if (b1 && b2 && !b3)\n \t{\n \t  gfc_error (\"Allocate-object at %C is not a nonprocedure pointer \"\n@@ -2616,7 +2638,7 @@ gfc_match_allocate (void)\n \n \t  gfc_resolve_expr (tmp);\n \n-\t  if (head->expr->ts.type != tmp->ts.type)\n+\t  if (!gfc_type_compatible (&head->expr->ts, &tmp->ts))\n \t    {\n \t      gfc_error (\"Type of entity at %L is type incompatible with \"\n \t\t\t \"source-expr at %L\", &head->expr->where, &tmp->where);\n@@ -2657,7 +2679,8 @@ gfc_match_allocate (void)\n   new_st.expr1 = stat;\n   new_st.expr2 = errmsg;\n   new_st.expr3 = source;\n-  new_st.ext.alloc_list = head;\n+  new_st.ext.alloc.list = head;\n+  new_st.ext.alloc.ts = ts;\n \n   return MATCH_YES;\n \n@@ -2754,8 +2777,9 @@ gfc_match_deallocate (void)\n {\n   gfc_alloc *head, *tail;\n   gfc_expr *stat, *errmsg, *tmp;\n+  gfc_symbol *sym;\n   match m;\n-  bool saw_stat, saw_errmsg;\n+  bool saw_stat, saw_errmsg, b1, b2;\n \n   head = tail = NULL;\n   stat = errmsg = tmp = NULL;\n@@ -2783,20 +2807,25 @@ gfc_match_deallocate (void)\n       if (gfc_check_do_variable (tail->expr->symtree))\n \tgoto cleanup;\n \n-      if (gfc_pure (NULL) && gfc_impure_variable (tail->expr->symtree->n.sym))\n+      sym = tail->expr->symtree->n.sym;\n+\n+      if (gfc_pure (NULL) && gfc_impure_variable (sym))\n \t{\n \t  gfc_error (\"Illegal allocate-object at %C for a PURE procedure\");\n \t  goto cleanup;\n \t}\n \n       /* FIXME: disable the checking on derived types.  */\n-      if (!(tail->expr->ref\n+      b1 = !(tail->expr->ref\n \t   && (tail->expr->ref->type == REF_COMPONENT\n-\t       || tail->expr->ref->type == REF_ARRAY)) \n-\t  && tail->expr->symtree->n.sym\n-\t  && !(tail->expr->symtree->n.sym->attr.allocatable\n-\t       || tail->expr->symtree->n.sym->attr.pointer\n-\t       || tail->expr->symtree->n.sym->attr.proc_pointer))\n+\t       || tail->expr->ref->type == REF_ARRAY));\n+      if (sym && sym->ts.type == BT_CLASS)\n+\tb2 = !(sym->ts.u.derived->components->attr.allocatable\n+\t       || sym->ts.u.derived->components->attr.pointer);\n+      else\n+\tb2 = sym && !(sym->attr.allocatable || sym->attr.pointer\n+\t\t      || sym->attr.proc_pointer);\n+      if (b1 && b2)\n \t{\n \t  gfc_error (\"Allocate-object at %C is not a nonprocedure pointer \"\n \t\t     \"or an allocatable variable\");\n@@ -2865,7 +2894,7 @@ gfc_match_deallocate (void)\n   new_st.op = EXEC_DEALLOCATE;\n   new_st.expr1 = stat;\n   new_st.expr2 = errmsg;\n-  new_st.ext.alloc_list = head;\n+  new_st.ext.alloc.list = head;\n \n   return MATCH_YES;\n \n@@ -3021,7 +3050,8 @@ gfc_match_call (void)\n \n   /* If this is a variable of derived-type, it probably starts a type-bound\n      procedure call.  */\n-  if (sym->attr.flavor != FL_PROCEDURE && sym->ts.type == BT_DERIVED)\n+  if (sym->attr.flavor != FL_PROCEDURE\n+      && (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS))\n     return match_typebound_call (st);\n \n   /* If it does not seem to be callable (include functions so that the\n@@ -3949,10 +3979,7 @@ match_case_eos (void)\n   /* If the case construct doesn't have a case-construct-name, we\n      should have matched the EOS.  */\n   if (!gfc_current_block ())\n-    {\n-      gfc_error (\"Expected the name of the SELECT CASE construct at %C\");\n-      return MATCH_ERROR;\n-    }\n+    return MATCH_NO;\n \n   gfc_gobble_whitespace ();\n \n@@ -3962,7 +3989,7 @@ match_case_eos (void)\n \n   if (strcmp (name, gfc_current_block ()->name) != 0)\n     {\n-      gfc_error (\"Expected case name of '%s' at %C\",\n+      gfc_error (\"Expected block name '%s' of SELECT construct at %C\",\n \t\t gfc_current_block ()->name);\n       return MATCH_ERROR;\n     }\n@@ -3994,6 +4021,61 @@ gfc_match_select (void)\n }\n \n \n+/* Match a SELECT TYPE statement.  */\n+\n+match\n+gfc_match_select_type (void)\n+{\n+  gfc_expr *expr;\n+  match m;\n+\n+  m = gfc_match_label ();\n+  if (m == MATCH_ERROR)\n+    return m;\n+\n+  m = gfc_match (\" select type ( %e \", &expr);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  /* TODO: Implement ASSOCIATE.  */\n+  m = gfc_match (\" => \");\n+  if (m == MATCH_YES)\n+    {\n+      gfc_error (\"Associate-name in SELECT TYPE statement at %C \"\n+\t\t \"is not yet supported\");\n+      return MATCH_ERROR;\n+    }\n+\n+  m = gfc_match (\" )%t\");\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  /* Check for F03:C811.\n+     TODO: Change error message once ASSOCIATE is implemented.  */\n+  if (expr->expr_type != EXPR_VARIABLE || expr->ref != NULL)\n+    {\n+      gfc_error (\"Selector must be a named variable in SELECT TYPE statement \"\n+\t\t \"at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Check for F03:C813.  */\n+  if (expr->ts.type != BT_CLASS)\n+    {\n+      gfc_error (\"Selector shall be polymorphic in SELECT TYPE statement \"\n+\t\t \"at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  new_st.op = EXEC_SELECT_TYPE;\n+  new_st.expr1 = expr;\n+\n+  type_selector = expr->symtree->n.sym;\n+\n+  return MATCH_YES;\n+}\n+\n+\n /* Match a CASE statement.  */\n \n match\n@@ -4058,13 +4140,142 @@ gfc_match_case (void)\n   return MATCH_YES;\n \n syntax:\n-  gfc_error (\"Syntax error in CASE-specification at %C\");\n+  gfc_error (\"Syntax error in CASE specification at %C\");\n \n cleanup:\n   gfc_free_case_list (head);  /* new_st is cleaned up in parse.c.  */\n   return MATCH_ERROR;\n }\n \n+\n+/* Match a TYPE IS statement.  */\n+\n+match\n+gfc_match_type_is (void)\n+{\n+  gfc_case *c = NULL;\n+  match m;\n+  char name[GFC_MAX_SYMBOL_LEN];\n+\n+  if (gfc_current_state () != COMP_SELECT_TYPE)\n+    {\n+      gfc_error (\"Unexpected TYPE IS statement at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    goto syntax;\n+\n+  c = gfc_get_case ();\n+  c->where = gfc_current_locus;\n+\n+  /* TODO: Once unlimited polymorphism is implemented, we will need to call\n+     match_type_spec here.  */\n+  if (match_derived_type_spec (&c->ts) == MATCH_ERROR)\n+    goto cleanup;\n+\n+  if (gfc_match_char (')') != MATCH_YES)\n+    goto syntax;\n+\n+  m = match_case_eos ();\n+  if (m == MATCH_NO)\n+    goto syntax;\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n+\n+  new_st.op = EXEC_SELECT_TYPE;\n+  new_st.ext.case_list = c;\n+\n+  /* Create temporary variable.  */\n+  sprintf (name, \"tmp$%s\", c->ts.u.derived->name);\n+  gfc_get_sym_tree (name, gfc_current_ns, &select_type_tmp, false);\n+  select_type_tmp->n.sym->ts = c->ts;\n+  select_type_tmp->n.sym->attr.referenced = 1;\n+  select_type_tmp->n.sym->attr.pointer = 1;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in TYPE IS specification at %C\");\n+\n+cleanup:\n+  if (c != NULL)\n+    gfc_free_case_list (c);  /* new_st is cleaned up in parse.c.  */\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* Match a CLASS IS or CLASS DEFAULT statement.  */\n+\n+match\n+gfc_match_class_is (void)\n+{\n+  gfc_case *c = NULL;\n+  match m;\n+\n+  if (gfc_current_state () != COMP_SELECT_TYPE)\n+    return MATCH_NO;\n+\n+  if (gfc_match (\"% default\") == MATCH_YES)\n+    {\n+      m = match_case_eos ();\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+\n+      new_st.op = EXEC_SELECT_TYPE;\n+      c = gfc_get_case ();\n+      c->where = gfc_current_locus;\n+      c->ts.type = BT_UNKNOWN;\n+      new_st.ext.case_list = c;\n+      return MATCH_YES;\n+    }\n+\n+  m = gfc_match (\"% is\");\n+  if (m == MATCH_NO)\n+    goto syntax;\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n+\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    goto syntax;\n+\n+  c = gfc_get_case ();\n+  c->where = gfc_current_locus;\n+\n+  if (match_derived_type_spec (&c->ts) == MATCH_ERROR)\n+    goto cleanup;\n+\n+  if (c->ts.type == BT_DERIVED)\n+    c->ts.type = BT_CLASS;\n+\n+  if (gfc_match_char (')') != MATCH_YES)\n+    goto syntax;\n+\n+  m = match_case_eos ();\n+  if (m == MATCH_NO)\n+    goto syntax;\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n+\n+  new_st.op = EXEC_SELECT_TYPE;\n+  new_st.ext.case_list = c;\n+\n+  gfc_error_now (\"CLASS IS specification at %C is not yet supported\");\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in CLASS IS specification at %C\");\n+\n+cleanup:\n+  if (c != NULL)\n+    gfc_free_case_list (c);  /* new_st is cleaned up in parse.c.  */\n+  return MATCH_ERROR;\n+}\n+\n+\n /********************* WHERE subroutines ********************/\n \n /* Match the rest of a simple WHERE statement that follows an IF statement.  "}, {"sha": "bc1945302c92b8768e97bcacc8d735b87894df26", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -101,6 +101,9 @@ match gfc_match_equivalence (void);\n match gfc_match_st_function (void);\n match gfc_match_case (void);\n match gfc_match_select (void);\n+match gfc_match_select_type (void);\n+match gfc_match_type_is (void);\n+match gfc_match_class_is (void);\n match gfc_match_where (gfc_statement *);\n match gfc_match_elsewhere (void);\n match gfc_match_forall (gfc_statement *);"}, {"sha": "b5e6275bc8d0df485029effe55d4471427fd95ac", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -71,7 +71,6 @@ gfc_clear_ts (gfc_typespec *ts)\n   ts->kind = 0;\n   ts->u.cl = NULL;\n   ts->interface = NULL;\n-  ts->is_class = 0;\n   /* flag that says if the type is C interoperable */\n   ts->is_c_interop = 0;\n   /* says what f90 type the C kind interops with */\n@@ -131,6 +130,9 @@ gfc_basic_typename (bt type)\n     case BT_DERIVED:\n       p = \"DERIVED\";\n       break;\n+    case BT_CLASS:\n+      p = \"CLASS\";\n+      break;\n     case BT_PROCEDURE:\n       p = \"PROCEDURE\";\n       break;\n@@ -186,6 +188,10 @@ gfc_typename (gfc_typespec *ts)\n     case BT_DERIVED:\n       sprintf (buffer, \"TYPE(%s)\", ts->u.derived->name);\n       break;\n+    case BT_CLASS:\n+      sprintf (buffer, \"CLASS(%s)\",\n+\t       ts->u.derived->components->ts.u.derived->name);\n+      break;\n     case BT_PROCEDURE:\n       strcpy (buffer, \"PROCEDURE\");\n       break;"}, {"sha": "1769eada5fe672fa453562386c59a4781fc05cde", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1672,7 +1672,7 @@ typedef enum\n   AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE, AB_ALLOC_COMP,\n   AB_POINTER_COMP, AB_PRIVATE_COMP, AB_VALUE, AB_VOLATILE, AB_PROTECTED,\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n-  AB_EXTENSION, AB_PROCEDURE, AB_PROC_POINTER\n+  AB_EXTENSION, AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER\n }\n ab_attribute;\n \n@@ -1713,6 +1713,7 @@ static const mstring attr_bits[] =\n     minit (\"PROTECTED\", AB_PROTECTED),\n     minit (\"ABSTRACT\", AB_ABSTRACT),\n     minit (\"EXTENSION\", AB_EXTENSION),\n+    minit (\"IS_CLASS\", AB_IS_CLASS),\n     minit (\"PROCEDURE\", AB_PROCEDURE),\n     minit (\"PROC_POINTER\", AB_PROC_POINTER),\n     minit (NULL, -1)\n@@ -1860,6 +1861,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_ZERO_COMP, attr_bits);\n       if (attr->extension)\n \tMIO_NAME (ab_attribute) (AB_EXTENSION, attr_bits);\n+      if (attr->is_class)\n+\tMIO_NAME (ab_attribute) (AB_IS_CLASS, attr_bits);\n       if (attr->procedure)\n \tMIO_NAME (ab_attribute) (AB_PROCEDURE, attr_bits);\n       if (attr->proc_pointer)\n@@ -1985,6 +1988,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_EXTENSION:\n \t      attr->extension = 1;\n \t      break;\n+\t    case AB_IS_CLASS:\n+\t      attr->is_class = 1;\n+\t      break;\n \t    case AB_PROCEDURE:\n \t      attr->procedure = 1;\n \t      break;\n@@ -2004,6 +2010,7 @@ static const mstring bt_types[] = {\n     minit (\"LOGICAL\", BT_LOGICAL),\n     minit (\"CHARACTER\", BT_CHARACTER),\n     minit (\"DERIVED\", BT_DERIVED),\n+    minit (\"CLASS\", BT_CLASS),\n     minit (\"PROCEDURE\", BT_PROCEDURE),\n     minit (\"UNKNOWN\", BT_UNKNOWN),\n     minit (\"VOID\", BT_VOID),\n@@ -2054,7 +2061,7 @@ mio_typespec (gfc_typespec *ts)\n \n   ts->type = MIO_NAME (bt) (ts->type, bt_types);\n \n-  if (ts->type != BT_DERIVED)\n+  if (ts->type != BT_DERIVED && ts->type != BT_CLASS)\n     mio_integer (&ts->kind);\n   else\n     mio_symbol_ref (&ts->u.derived);\n@@ -3566,7 +3573,10 @@ mio_symbol (gfc_symbol *sym)\n     }\n   \n   mio_integer (&(sym->intmod_sym_id));\n-  \n+\n+  if (sym->attr.flavor == FL_DERIVED)\n+    mio_integer (&(sym->vindex));\n+\n   mio_rparen ();\n }\n "}, {"sha": "13199c91bb09202cbd557f3da78057d1c04b9e68", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -312,6 +312,7 @@ decode_statement (void)\n   match (NULL, gfc_match_block, ST_BLOCK);\n   match (NULL, gfc_match_do, ST_DO);\n   match (NULL, gfc_match_select, ST_SELECT_CASE);\n+  match (NULL, gfc_match_select_type, ST_SELECT_TYPE);\n \n   /* General statement matching: Instead of testing every possible\n      statement, we eliminate most possibilities by peeking at the\n@@ -343,6 +344,7 @@ decode_statement (void)\n       match (\"case\", gfc_match_case, ST_CASE);\n       match (\"common\", gfc_match_common, ST_COMMON);\n       match (\"contains\", gfc_match_eos, ST_CONTAINS);\n+      match (\"class\", gfc_match_class_is, ST_CLASS_IS);\n       break;\n \n     case 'd':\n@@ -432,6 +434,7 @@ decode_statement (void)\n     case 't':\n       match (\"target\", gfc_match_target, ST_ATTR_DECL);\n       match (\"type\", gfc_match_derived_decl, ST_DERIVED_DECL);\n+      match (\"type is\", gfc_match_type_is, ST_TYPE_IS);\n       break;\n \n     case 'u':\n@@ -936,7 +939,8 @@ next_statement (void)\n \n #define case_exec_markers case ST_DO: case ST_FORALL_BLOCK: \\\n   case ST_IF_BLOCK: case ST_BLOCK: \\\n-  case ST_WHERE_BLOCK: case ST_SELECT_CASE: case ST_OMP_PARALLEL: \\\n+  case ST_WHERE_BLOCK: case ST_SELECT_CASE: case ST_SELECT_TYPE: \\\n+  case ST_OMP_PARALLEL: \\\n   case ST_OMP_PARALLEL_SECTIONS: case ST_OMP_SECTIONS: case ST_OMP_ORDERED: \\\n   case ST_OMP_CRITICAL: case ST_OMP_MASTER: case ST_OMP_SINGLE: \\\n   case ST_OMP_DO: case ST_OMP_PARALLEL_DO: case ST_OMP_ATOMIC: \\\n@@ -1360,6 +1364,15 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_SELECT_CASE:\n       p = \"SELECT CASE\";\n       break;\n+    case ST_SELECT_TYPE:\n+      p = \"SELECT TYPE\";\n+      break;\n+    case ST_TYPE_IS:\n+      p = \"TYPE IS\";\n+      break;\n+    case ST_CLASS_IS:\n+      p = \"CLASS IS\";\n+      break;\n     case ST_SEQUENCE:\n       p = \"SEQUENCE\";\n       break;\n@@ -2874,6 +2887,83 @@ parse_select_block (void)\n }\n \n \n+/* Parse a SELECT TYPE construct (F03:R821).  */\n+\n+static void\n+parse_select_type_block (void)\n+{\n+  gfc_statement st;\n+  gfc_code *cp;\n+  gfc_state_data s;\n+\n+  accept_statement (ST_SELECT_TYPE);\n+\n+  cp = gfc_state_stack->tail;\n+  push_state (&s, COMP_SELECT_TYPE, gfc_new_block);\n+\n+  /* Make sure that the next statement is a TYPE IS, CLASS IS, CLASS DEFAULT\n+     or END SELECT.  */\n+  for (;;)\n+    {\n+      st = next_statement ();\n+      if (st == ST_NONE)\n+\tunexpected_eof ();\n+      if (st == ST_END_SELECT)\n+\t{\n+\t  /* Empty SELECT CASE is OK.  */\n+\t  accept_statement (st);\n+\t  pop_state ();\n+\t  return;\n+\t}\n+      if (st == ST_TYPE_IS || st == ST_CLASS_IS)\n+\tbreak;\n+\n+      gfc_error (\"Expected TYPE IS, CLASS IS or END SELECT statement \"\n+\t\t \"following SELECT TYPE at %C\");\n+\n+      reject_statement ();\n+    }\n+\n+  /* At this point, we're got a nonempty select block.  */\n+  cp = new_level (cp);\n+  *cp = new_st;\n+\n+  accept_statement (st);\n+\n+  do\n+    {\n+      st = parse_executable (ST_NONE);\n+      switch (st)\n+\t{\n+\tcase ST_NONE:\n+\t  unexpected_eof ();\n+\n+\tcase ST_TYPE_IS:\n+\tcase ST_CLASS_IS:\n+\t  cp = new_level (gfc_state_stack->head);\n+\t  *cp = new_st;\n+\t  gfc_clear_new_st ();\n+\n+\t  accept_statement (st);\n+\t  /* Fall through */\n+\n+\tcase ST_END_SELECT:\n+\t  break;\n+\n+\t/* Can't have an executable statement because of\n+\t   parse_executable().  */\n+\tdefault:\n+\t  unexpected_statement (st);\n+\t  break;\n+\t}\n+    }\n+  while (st != ST_END_SELECT);\n+\n+  pop_state ();\n+  accept_statement (st);\n+}\n+\n+\n /* Given a symbol, make sure it is not an iteration variable for a DO\n    statement.  This subroutine is called when the symbol is seen in a\n    context that causes it to become redefined.  If the symbol is an\n@@ -3395,6 +3485,10 @@ parse_executable (gfc_statement st)\n \t  parse_select_block ();\n \t  break;\n \n+\tcase ST_SELECT_TYPE:\n+\t  parse_select_type_block();\n+\t  break;\n+\n \tcase ST_DO:\n \t  parse_do_block ();\n \t  if (check_do_closure () == 1)"}, {"sha": "2b926618d283f3d11741b3aea0abc043a05a00fd", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -32,7 +32,7 @@ typedef enum\n   COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS,\n   COMP_BLOCK, COMP_IF,\n   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,\n-  COMP_OMP_STRUCTURED_BLOCK\n+  COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK\n }\n gfc_compile_state;\n "}, {"sha": "c0777c48b858dd3b0d88a3fe3aecaa7990398e93", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 60, "deletions": 14, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1733,7 +1733,9 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n       || (sym->attr.dimension && !sym->attr.proc_pointer\n \t  && !gfc_is_proc_ptr_comp (primary, NULL)\n \t  && !(gfc_matching_procptr_assignment\n-\t       && sym->attr.flavor == FL_PROCEDURE)))\n+\t       && sym->attr.flavor == FL_PROCEDURE))\n+      || (sym->ts.type == BT_CLASS\n+\t  && sym->ts.u.derived->components->attr.dimension))\n     {\n       /* In EQUIVALENCE, we don't know yet whether we are seeing\n \t an array, character variable or array of character\n@@ -1767,7 +1769,8 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n       && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)\n     gfc_set_default_type (sym, 0, sym->ns);\n \n-  if (sym->ts.type != BT_DERIVED || gfc_match_char ('%') != MATCH_YES)\n+  if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)\n+      || gfc_match_char ('%') != MATCH_YES)\n     goto check_substring;\n \n   sym = sym->ts.u.derived;\n@@ -1865,8 +1868,21 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t  if (m != MATCH_YES)\n \t    return m;\n \t}\n+      else if (component->ts.type == BT_CLASS\n+\t       && component->ts.u.derived->components->as != NULL\n+\t       && !component->attr.proc_pointer)\n+\t{\n+\t  tail = extend_ref (primary, tail);\n+\t  tail->type = REF_ARRAY;\n \n-      if (component->ts.type != BT_DERIVED\n+\t  m = gfc_match_array_ref (&tail->u.ar,\n+\t\t\t\t   component->ts.u.derived->components->as,\n+\t\t\t\t   equiv_flag);\n+\t  if (m != MATCH_YES)\n+\t    return m;\n+\t}\n+\n+      if ((component->ts.type != BT_DERIVED && component->ts.type != BT_CLASS)\n \t  || gfc_match_char ('%') != MATCH_YES)\n \tbreak;\n \n@@ -1875,7 +1891,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \n check_substring:\n   unknown = false;\n-  if (primary->ts.type == BT_UNKNOWN)\n+  if (primary->ts.type == BT_UNKNOWN && sym->attr.flavor != FL_DERIVED)\n     {\n       if (gfc_get_default_type (sym->name, sym->ns)->type == BT_CHARACTER)\n        {\n@@ -1943,23 +1959,35 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n   int dimension, pointer, allocatable, target;\n   symbol_attribute attr;\n   gfc_ref *ref;\n+  gfc_symbol *sym;\n+  gfc_component *comp;\n \n   if (expr->expr_type != EXPR_VARIABLE && expr->expr_type != EXPR_FUNCTION)\n     gfc_internal_error (\"gfc_variable_attr(): Expression isn't a variable\");\n \n   ref = expr->ref;\n-  attr = expr->symtree->n.sym->attr;\n+  sym = expr->symtree->n.sym;\n+  attr = sym->attr;\n \n-  dimension = attr.dimension;\n-  pointer = attr.pointer;\n-  allocatable = attr.allocatable;\n+  if (sym->ts.type == BT_CLASS)\n+    {\n+      dimension = sym->ts.u.derived->components->attr.dimension;\n+      pointer = sym->ts.u.derived->components->attr.pointer;\n+      allocatable = sym->ts.u.derived->components->attr.allocatable;\n+    }\n+  else\n+    {\n+      dimension = attr.dimension;\n+      pointer = attr.pointer;\n+      allocatable = attr.allocatable;\n+    }\n \n   target = attr.target;\n   if (pointer || attr.proc_pointer)\n     target = 1;\n \n   if (ts != NULL && expr->ts.type == BT_UNKNOWN)\n-    *ts = expr->symtree->n.sym->ts;\n+    *ts = sym->ts;\n \n   for (; ref; ref = ref->next)\n     switch (ref->type)\n@@ -1988,19 +2016,28 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n \tbreak;\n \n       case REF_COMPONENT:\n-\tattr = ref->u.c.component->attr;\n+\tcomp = ref->u.c.component;\n+\tattr = comp->attr;\n \tif (ts != NULL)\n \t  {\n-\t    *ts = ref->u.c.component->ts;\n+\t    *ts = comp->ts;\n \t    /* Don't set the string length if a substring reference\n \t       follows.  */\n \t    if (ts->type == BT_CHARACTER\n \t\t&& ref->next && ref->next->type == REF_SUBSTRING)\n \t\tts->u.cl = NULL;\n \t  }\n \n-\tpointer = ref->u.c.component->attr.pointer;\n-\tallocatable = ref->u.c.component->attr.allocatable;\n+\tif (comp->ts.type == BT_CLASS)\n+\t  {\n+\t    pointer = comp->ts.u.derived->components->attr.pointer;\n+\t    allocatable = comp->ts.u.derived->components->attr.allocatable;\n+\t  }\n+\telse\n+\t  {\n+\t    pointer = comp->attr.pointer;\n+\t    allocatable = comp->attr.allocatable;\n+\t  }\n \tif (pointer || attr.proc_pointer)\n \t  target = 1;\n \n@@ -2037,7 +2074,16 @@ gfc_expr_attr (gfc_expr *e)\n       gfc_clear_attr (&attr);\n \n       if (e->value.function.esym != NULL)\n-\tattr = e->value.function.esym->result->attr;\n+\t{\n+\t  gfc_symbol *sym = e->value.function.esym->result;\n+\t  attr = sym->attr;\n+\t  if (sym->ts.type == BT_CLASS)\n+\t    {\n+\t      attr.dimension = sym->ts.u.derived->components->attr.dimension;\n+\t      attr.pointer = sym->ts.u.derived->components->attr.pointer;\n+\t      attr.allocatable = sym->ts.u.derived->components->attr.allocatable;\n+\t    }\n+\t}\n       else\n \tattr = gfc_variable_attr (e, NULL);\n "}, {"sha": "445753eca82945f0228d9d5d8ed4aaebc80afb54", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 303, "deletions": 69, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -879,7 +879,10 @@ resolve_structure_cons (gfc_expr *expr)\n \n       if (cons->expr->expr_type == EXPR_NULL\n \t  && !(comp->attr.pointer || comp->attr.allocatable\n-\t       || comp->attr.proc_pointer))\n+\t       || comp->attr.proc_pointer\n+\t       || (comp->ts.type == BT_CLASS\n+\t\t   && (comp->ts.u.derived->components->attr.pointer\n+\t\t       || comp->ts.u.derived->components->attr.allocatable))))\n \t{\n \t  t = FAILURE;\n \t  gfc_error (\"The NULL in the derived type constructor at %L is \"\n@@ -3931,7 +3934,10 @@ find_array_spec (gfc_expr *e)\n   gfc_symbol *derived;\n   gfc_ref *ref;\n \n-  as = e->symtree->n.sym->as;\n+  if (e->symtree->n.sym->ts.type == BT_CLASS)\n+    as = e->symtree->n.sym->ts.u.derived->components->as;\n+  else\n+    as = e->symtree->n.sym->as;\n   derived = NULL;\n \n   for (ref = e->ref; ref; ref = ref->next)\n@@ -4844,7 +4850,7 @@ check_typebound_baseobject (gfc_expr* e)\n   if (!base)\n     return FAILURE;\n \n-  gcc_assert (base->ts.type == BT_DERIVED);\n+  gcc_assert (base->ts.type == BT_DERIVED || base->ts.type == BT_CLASS);\n   if (base->ts.u.derived->attr.abstract)\n     {\n       gfc_error (\"Base object for type-bound procedure call at %L is of\"\n@@ -5051,7 +5057,10 @@ static gfc_try\n resolve_ppc_call (gfc_code* c)\n {\n   gfc_component *comp;\n-  gcc_assert (gfc_is_proc_ptr_comp (c->expr1, &comp));\n+  bool b;\n+\n+  b = gfc_is_proc_ptr_comp (c->expr1, &comp);\n+  gcc_assert (b);\n \n   c->resolved_sym = c->expr1->symtree->n.sym;\n   c->expr1->expr_type = EXPR_VARIABLE;\n@@ -5083,7 +5092,10 @@ static gfc_try\n resolve_expr_ppc (gfc_expr* e)\n {\n   gfc_component *comp;\n-  gcc_assert (gfc_is_proc_ptr_comp (e, &comp));\n+  bool b;\n+\n+  b = gfc_is_proc_ptr_comp (e, &comp);\n+  gcc_assert (b);\n \n   /* Convert to EXPR_FUNCTION.  */\n   e->expr_type = EXPR_FUNCTION;\n@@ -5462,6 +5474,8 @@ resolve_deallocate_expr (gfc_expr *e)\n   symbol_attribute attr;\n   int allocatable, pointer, check_intent_in;\n   gfc_ref *ref;\n+  gfc_symbol *sym;\n+  gfc_component *c;\n \n   /* Check INTENT(IN), unless the object is a sub-component of a pointer.  */\n   check_intent_in = 1;\n@@ -5472,8 +5486,18 @@ resolve_deallocate_expr (gfc_expr *e)\n   if (e->expr_type != EXPR_VARIABLE)\n     goto bad;\n \n-  allocatable = e->symtree->n.sym->attr.allocatable;\n-  pointer = e->symtree->n.sym->attr.pointer;\n+  sym = e->symtree->n.sym;\n+\n+  if (sym->ts.type == BT_CLASS)\n+    {\n+      allocatable = sym->ts.u.derived->components->attr.allocatable;\n+      pointer = sym->ts.u.derived->components->attr.pointer;\n+    }\n+  else\n+    {\n+      allocatable = sym->attr.allocatable;\n+      pointer = sym->attr.pointer;\n+    }\n   for (ref = e->ref; ref; ref = ref->next)\n     {\n       if (pointer)\n@@ -5487,9 +5511,17 @@ resolve_deallocate_expr (gfc_expr *e)\n \t  break;\n \n \tcase REF_COMPONENT:\n-\t  allocatable = (ref->u.c.component->as != NULL\n-\t\t\t && ref->u.c.component->as->type == AS_DEFERRED);\n-\t  pointer = ref->u.c.component->attr.pointer;\n+\t  c = ref->u.c.component;\n+\t  if (c->ts.type == BT_CLASS)\n+\t    {\n+\t      allocatable = c->ts.u.derived->components->attr.allocatable;\n+\t      pointer = c->ts.u.derived->components->attr.pointer;\n+\t    }\n+\t  else\n+\t    {\n+\t      allocatable = c->attr.allocatable;\n+\t      pointer = c->attr.pointer;\n+\t    }\n \t  break;\n \n \tcase REF_SUBSTRING:\n@@ -5507,14 +5539,19 @@ resolve_deallocate_expr (gfc_expr *e)\n \t\t &e->where);\n     }\n \n-  if (check_intent_in\n-      && e->symtree->n.sym->attr.intent == INTENT_IN)\n+  if (check_intent_in && sym->attr.intent == INTENT_IN)\n     {\n       gfc_error (\"Cannot deallocate INTENT(IN) variable '%s' at %L\",\n-\t\t e->symtree->n.sym->name, &e->where);\n+\t\t sym->name, &e->where);\n       return FAILURE;\n     }\n \n+  if (e->ts.type == BT_CLASS)\n+    {\n+      /* Only deallocate the DATA component.  */\n+      gfc_add_component_ref (e, \"$data\");\n+    }\n+\n   return SUCCESS;\n }\n \n@@ -5541,8 +5578,8 @@ gfc_find_sym_in_expr (gfc_symbol *sym, gfc_expr *e)\n    derived types with default initializers, and derived types with allocatable\n    components that need nullification.)  */\n \n-static gfc_expr *\n-expr_to_initialize (gfc_expr *e)\n+gfc_expr *\n+gfc_expr_to_initialize (gfc_expr *e)\n {\n   gfc_expr *result;\n   gfc_ref *ref;\n@@ -5579,9 +5616,9 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   gfc_ref *ref, *ref2;\n   gfc_array_ref *ar;\n   gfc_code *init_st;\n-  gfc_expr *init_e;\n   gfc_symbol *sym;\n   gfc_alloc *a;\n+  gfc_component *c;\n \n   /* Check INTENT(IN), unless the object is a sub-component of a pointer.  */\n   check_intent_in = 1;\n@@ -5593,6 +5630,8 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n      pointer, the next-to-last reference must be a pointer.  */\n \n   ref2 = NULL;\n+  if (e->symtree)\n+    sym = e->symtree->n.sym;\n \n   if (e->expr_type != EXPR_VARIABLE)\n     {\n@@ -5603,9 +5642,18 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n     }\n   else\n     {\n-      allocatable = e->symtree->n.sym->attr.allocatable;\n-      pointer = e->symtree->n.sym->attr.pointer;\n-      dimension = e->symtree->n.sym->attr.dimension;\n+      if (sym->ts.type == BT_CLASS)\n+\t{\n+\t  allocatable = sym->ts.u.derived->components->attr.allocatable;\n+\t  pointer = sym->ts.u.derived->components->attr.pointer;\n+\t  dimension = sym->ts.u.derived->components->attr.dimension;\n+\t}\n+      else\n+\t{\n+\t  allocatable = sym->attr.allocatable;\n+\t  pointer = sym->attr.pointer;\n+\t  dimension = sym->attr.dimension;\n+\t}\n \n       for (ref = e->ref; ref; ref2 = ref, ref = ref->next)\n \t{\n@@ -5620,11 +5668,19 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t\tbreak;\n \n \t      case REF_COMPONENT:\n-\t\tallocatable = (ref->u.c.component->as != NULL\n-\t\t\t       && ref->u.c.component->as->type == AS_DEFERRED);\n-\n-\t\tpointer = ref->u.c.component->attr.pointer;\n-\t\tdimension = ref->u.c.component->attr.dimension;\n+\t\tc = ref->u.c.component;\n+\t\tif (c->ts.type == BT_CLASS)\n+\t\t  {\n+\t\t    allocatable = c->ts.u.derived->components->attr.allocatable;\n+\t\t    pointer = c->ts.u.derived->components->attr.pointer;\n+\t\t    dimension = c->ts.u.derived->components->attr.dimension;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    allocatable = c->attr.allocatable;\n+\t\t    pointer = c->attr.pointer;\n+\t\t    dimension = c->attr.dimension;\n+\t\t  }\n \t\tbreak;\n \n \t      case REF_SUBSTRING:\n@@ -5642,24 +5698,46 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       return FAILURE;\n     }\n \n-  if (check_intent_in\n-      && e->symtree->n.sym->attr.intent == INTENT_IN)\n+  if (check_intent_in && sym->attr.intent == INTENT_IN)\n     {\n       gfc_error (\"Cannot allocate INTENT(IN) variable '%s' at %L\",\n-\t\t e->symtree->n.sym->name, &e->where);\n+\t\t sym->name, &e->where);\n       return FAILURE;\n     }\n \n-  /* Add default initializer for those derived types that need them.  */\n-  if (e->ts.type == BT_DERIVED && (init_e = gfc_default_initializer (&e->ts)))\n+  if (e->ts.type == BT_CLASS)\n     {\n+      /* Initialize VINDEX for CLASS objects.  */\n       init_st = gfc_get_code ();\n       init_st->loc = code->loc;\n-      init_st->op = EXEC_INIT_ASSIGN;\n-      init_st->expr1 = expr_to_initialize (e);\n-      init_st->expr2 = init_e;\n+      init_st->expr1 = gfc_expr_to_initialize (e);\n+      init_st->op = EXEC_ASSIGN;\n+      gfc_add_component_ref (init_st->expr1, \"$vindex\");\n+      if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n+\t{\n+\t  /* vindex must be determined at run time.  */\n+\t  init_st->expr2 = gfc_copy_expr (code->expr3);\n+\t  gfc_add_component_ref (init_st->expr2, \"$vindex\");\n+\t}\n+      else\n+\t{\n+\t  /* vindex is fixed at compile time.  */\n+\t  int vindex;\n+\t  if (code->expr3)\n+\t    vindex = code->expr3->ts.u.derived->vindex;\n+\t  else if (code->ext.alloc.ts.type == BT_DERIVED)\n+\t    vindex = code->ext.alloc.ts.u.derived->vindex;\n+\t  else if (e->ts.type == BT_CLASS)\n+\t    vindex = e->ts.u.derived->components->ts.u.derived->vindex;\n+\t  else\n+\t    vindex = e->ts.u.derived->vindex;\n+\t  init_st->expr2 = gfc_int_expr (vindex);\n+\t}\n+      init_st->expr2->where = init_st->expr1->where = init_st->loc;\n       init_st->next = code->next;\n       code->next = init_st;\n+      /* Only allocate the DATA component.  */\n+      gfc_add_component_ref (e, \"$data\");\n     }\n \n   if (pointer || dimension == 0)\n@@ -5706,7 +5784,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \n check_symbols:\n \n-      for (a = code->ext.alloc_list; a; a = a->next)\n+      for (a = code->ext.alloc.list; a; a = a->next)\n \t{\n \t  sym = a->expr->symtree->n.sym;\n \n@@ -5758,7 +5836,7 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \tgfc_error (\"Stat-variable at %L must be a scalar INTEGER \"\n \t\t   \"variable\", &stat->where);\n \n-      for (p = code->ext.alloc_list; p; p = p->next)\n+      for (p = code->ext.alloc.list; p; p = p->next)\n \tif (p->expr->symtree->n.sym->name == stat->symtree->n.sym->name)\n \t  gfc_error (\"Stat-variable at %L shall not be %sd within \"\n \t\t     \"the same %s statement\", &stat->where, fcn, fcn);\n@@ -5787,15 +5865,15 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \tgfc_error (\"Errmsg-variable at %L must be a scalar CHARACTER \"\n \t\t   \"variable\", &errmsg->where);\n \n-      for (p = code->ext.alloc_list; p; p = p->next)\n+      for (p = code->ext.alloc.list; p; p = p->next)\n \tif (p->expr->symtree->n.sym->name == errmsg->symtree->n.sym->name)\n \t  gfc_error (\"Errmsg-variable at %L shall not be %sd within \"\n \t\t     \"the same %s statement\", &errmsg->where, fcn, fcn);\n     }\n \n   /* Check that an allocate-object appears only once in the statement.  \n      FIXME: Checking derived types is disabled.  */\n-  for (p = code->ext.alloc_list; p; p = p->next)\n+  for (p = code->ext.alloc.list; p; p = p->next)\n     {\n       pe = p->expr;\n       if ((pe->ref && pe->ref->type != REF_COMPONENT)\n@@ -5815,12 +5893,12 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \n   if (strcmp (fcn, \"ALLOCATE\") == 0)\n     {\n-      for (a = code->ext.alloc_list; a; a = a->next)\n+      for (a = code->ext.alloc.list; a; a = a->next)\n \tresolve_allocate_expr (a->expr, code);\n     }\n   else\n     {\n-      for (a = code->ext.alloc_list; a; a = a->next)\n+      for (a = code->ext.alloc.list; a; a = a->next)\n \tresolve_deallocate_expr (a->expr);\n     }\n }\n@@ -6346,6 +6424,116 @@ resolve_select (gfc_code *code)\n }\n \n \n+/* Check if a derived type is extensible.  */\n+\n+bool\n+gfc_type_is_extensible (gfc_symbol *sym)\n+{\n+  return !(sym->attr.is_bind_c || sym->attr.sequence);\n+}\n+\n+\n+/* Resolve a SELECT TYPE statement.  */\n+\n+static void\n+resolve_select_type (gfc_code *code)\n+{\n+  gfc_symbol *selector_type;\n+  gfc_code *body, *new_st;\n+  gfc_case *c, *default_case;\n+  gfc_symtree *st;\n+  char name[GFC_MAX_SYMBOL_LEN];\n+\n+  selector_type = code->expr1->ts.u.derived->components->ts.u.derived;\n+\n+  /* Assume there is no DEFAULT case.  */\n+  default_case = NULL;\n+\n+  /* Loop over TYPE IS / CLASS IS cases.  */\n+  for (body = code->block; body; body = body->block)\n+    {\n+      c = body->ext.case_list;\n+\n+      /* Check F03:C815.  */\n+      if ((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t  && !gfc_type_is_extensible (c->ts.u.derived))\n+\t{\n+\t  gfc_error (\"Derived type '%s' at %L must be extensible\",\n+\t\t     c->ts.u.derived->name, &c->where);\n+\t  continue;\n+\t}\n+\n+      /* Check F03:C816.  */\n+      if ((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t  && !gfc_type_is_extension_of (selector_type, c->ts.u.derived))\n+\t{\n+\t  gfc_error (\"Derived type '%s' at %L must be an extension of '%s'\",\n+\t\t     c->ts.u.derived->name, &c->where, selector_type->name);\n+\t  continue;\n+\t}\n+\n+      /* Intercept the DEFAULT case.  */\n+      if (c->ts.type == BT_UNKNOWN)\n+\t{\n+\t  /* Check F03:C818.  */\n+\t  if (default_case != NULL)\n+\t    gfc_error (\"The DEFAULT CASE at %L cannot be followed \"\n+\t\t       \"by a second DEFAULT CASE at %L\",\n+\t\t       &default_case->where, &c->where);\n+\t  else\n+\t    default_case = c;\n+\t  continue;\n+\t}\n+    }\n+\n+  /* Transform to EXEC_SELECT.  */\n+  code->op = EXEC_SELECT;\n+  gfc_add_component_ref (code->expr1, \"$vindex\");\n+\n+  /* Loop over TYPE IS / CLASS IS cases.  */\n+  for (body = code->block; body; body = body->block)\n+    {\n+      c = body->ext.case_list;\n+      if (c->ts.type == BT_DERIVED)\n+\tc->low = c->high = gfc_int_expr (c->ts.u.derived->vindex);\n+      else if (c->ts.type == BT_CLASS)\n+\t/* Currently IS CLASS blocks are simply ignored.\n+\t   TODO: Implement IS CLASS.  */\n+\tc->unreachable = 1;\n+\n+      if (c->ts.type != BT_DERIVED)\n+\tcontinue;\n+      /* Assign temporary to selector.  */\n+      sprintf (name, \"tmp$%s\", c->ts.u.derived->name);\n+      st = gfc_find_symtree (code->expr1->symtree->n.sym->ns->sym_root, name);\n+      new_st = gfc_get_code ();\n+      new_st->op = EXEC_POINTER_ASSIGN;\n+      new_st->expr1 = gfc_get_variable_expr (st);\n+      new_st->expr2 = gfc_get_variable_expr (code->expr1->symtree);\n+      gfc_add_component_ref (new_st->expr2, \"$data\");\n+      new_st->next = body->next;\n+      body->next = new_st;\n+    }\n+\n+  /* Eliminate dead blocks.  */\n+  for (body = code; body && body->block; body = body->block)\n+    {\n+      if (body->block->ext.case_list->unreachable)\n+\t{\n+\t  /* Cut the unreachable block from the code chain.  */\n+\t  gfc_code *cd = body->block;\n+\t  body->block = cd->block;\n+\t  /* Kill the dead block, but not the blocks below it.  */\n+\t  cd->block = NULL;\n+\t  gfc_free_statements (cd);\n+\t}\n+    }\n+\n+  resolve_select (code);\n+\n+}\n+\n+\n /* Resolve a transfer statement. This is making sure that:\n    -- a derived type being transferred has only non-pointer components\n    -- a derived type being transferred doesn't have private components, unless \n@@ -6911,6 +7099,7 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_SELECT:\n+\tcase EXEC_SELECT_TYPE:\n \tcase EXEC_FORALL:\n \tcase EXEC_DO:\n \tcase EXEC_DO_WHILE:\n@@ -7102,6 +7291,40 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n }\n \n \n+/* Check an assignment to a CLASS object (pointer or ordinary assignment).  */\n+\n+static void\n+resolve_class_assign (gfc_code *code)\n+{\n+  gfc_code *assign_code = gfc_get_code ();\n+\n+  /* Insert an additional assignment which sets the vindex.  */\n+  assign_code->next = code->next;\n+  code->next = assign_code;\n+  assign_code->op = EXEC_ASSIGN;\n+  assign_code->expr1 = gfc_copy_expr (code->expr1);\n+  gfc_add_component_ref (assign_code->expr1, \"$vindex\");\n+  if (code->expr2->ts.type == BT_DERIVED)\n+    /* vindex is constant, determined at compile time.  */\n+    assign_code->expr2 = gfc_int_expr (code->expr2->ts.u.derived->vindex);\n+  else if (code->expr2->ts.type == BT_CLASS)\n+    {\n+      /* vindex must be determined at run time.  */\n+      assign_code->expr2 = gfc_copy_expr (code->expr2);\n+      gfc_add_component_ref (assign_code->expr2, \"$vindex\");\n+    }\n+  else if (code->expr2->expr_type == EXPR_NULL)\n+    assign_code->expr2 = gfc_int_expr (0);\n+  else\n+    gcc_unreachable ();\n+\n+  /* Modify the actual pointer assignment.  */\n+  gfc_add_component_ref (code->expr1, \"$data\");\n+  if (code->expr2->ts.type == BT_CLASS)\n+    gfc_add_component_ref (code->expr2, \"$data\");\n+}\n+\n+\n /* Given a block of code, recursively resolve everything pointed to by this\n    code block.  */\n \n@@ -7224,6 +7447,9 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  if (t == FAILURE)\n \t    break;\n \n+\t  if (code->expr1->ts.type == BT_CLASS)\n+\t    resolve_class_assign (code);\n+\n \t  if (resolve_ordinary_assign (code, ns))\n \t    {\n \t      if (code->op == EXEC_COMPCALL)\n@@ -7252,7 +7478,11 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  if (t == FAILURE)\n \t    break;\n \n+\t  if (code->expr1->ts.type == BT_CLASS)\n+\t    resolve_class_assign (code);\n+\n \t  gfc_check_pointer_assign (code->expr1, code->expr2);\n+\n \t  break;\n \n \tcase EXEC_ARITHMETIC_IF:\n@@ -7295,6 +7525,10 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  resolve_select (code);\n \t  break;\n \n+\tcase EXEC_SELECT_TYPE:\n+\t  resolve_select_type (code);\n+\t  break;\n+\n \tcase EXEC_BLOCK:\n \t  gfc_resolve (code->ext.ns);\n \t  break;\n@@ -8023,8 +8257,8 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n     }\n   else\n     {\n-      if (!mp_flag && !sym->attr.allocatable\n-\t  && !sym->attr.pointer && !sym->attr.dummy)\n+      if (!mp_flag && !sym->attr.allocatable && !sym->attr.pointer\n+\t  && !sym->attr.dummy && sym->ts.type != BT_CLASS)\n \t{\n \t  gfc_error (\"Array '%s' at %L cannot have a deferred shape\",\n \t\t     sym->name, &sym->declared_at);\n@@ -8035,22 +8269,13 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n }\n \n \n-/* Check if a derived type is extensible.  */\n-\n-static bool\n-type_is_extensible (gfc_symbol *sym)\n-{\n-  return !(sym->attr.is_bind_c || sym->attr.sequence);\n-}\n-\n-\n /* Additional checks for symbols with flavor variable and derived\n    type.  To be called from resolve_fl_variable.  */\n \n static gfc_try\n resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n {\n-  gcc_assert (sym->ts.type == BT_DERIVED);\n+  gcc_assert (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS);\n \n   /* Check to see if a derived type is blocked from being host\n      associated by the presence of another class I symbol in the same\n@@ -8092,18 +8317,20 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n       return FAILURE;\n     }\n \n-  if (sym->ts.is_class)\n+  if (sym->ts.type == BT_CLASS)\n     {\n       /* C502.  */\n-      if (!type_is_extensible (sym->ts.u.derived))\n+      if (!gfc_type_is_extensible (sym->ts.u.derived->components->ts.u.derived))\n \t{\n \t  gfc_error (\"Type '%s' of CLASS variable '%s' at %L is not extensible\",\n \t\t     sym->ts.u.derived->name, sym->name, &sym->declared_at);\n \t  return FAILURE;\n \t}\n \n       /* C509.  */\n-      if (!(sym->attr.dummy || sym->attr.allocatable || sym->attr.pointer))\n+      if (!(sym->attr.dummy || sym->attr.allocatable || sym->attr.pointer\n+\t      || sym->ts.u.derived->components->attr.allocatable\n+\t      || sym->ts.u.derived->components->attr.pointer))\n \t{\n \t  gfc_error (\"CLASS variable '%s' at %L must be dummy, allocatable \"\n \t\t     \"or pointer\", sym->name, &sym->declared_at);\n@@ -8244,7 +8471,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n     }\n \n no_init_error:\n-  if (sym->ts.type == BT_DERIVED)\n+  if (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)\n     return resolve_fl_variable_derived (sym, no_init_flag);\n \n   return SUCCESS;\n@@ -8890,6 +9117,9 @@ check_generic_tbp_ambiguity (gfc_tbp_generic* t1, gfc_tbp_generic* t2,\n   sym1 = t1->specific->u.specific->n.sym;\n   sym2 = t2->specific->u.specific->n.sym;\n \n+  if (sym1 == sym2)\n+    return SUCCESS;\n+\n   /* Both must be SUBROUTINEs or both must be FUNCTIONs.  */\n   if (sym1->attr.subroutine != sym2->attr.subroutine\n       || sym1->attr.function != sym2->attr.function)\n@@ -9283,21 +9513,22 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \n       /* Now check that the argument-type matches.  */\n       gcc_assert (me_arg);\n-      if (me_arg->ts.type != BT_DERIVED\n-\t  || me_arg->ts.u.derived != resolve_bindings_derived)\n+      if (me_arg->ts.type != BT_CLASS)\n \t{\n-\t  gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L must be of\"\n-\t\t     \" the derived-type '%s'\", me_arg->name, proc->name,\n-\t\t     me_arg->name, &where, resolve_bindings_derived->name);\n+\t  gfc_error (\"Non-polymorphic passed-object dummy argument of '%s'\"\n+\t\t     \" at %L\", proc->name, &where);\n \t  goto error;\n \t}\n \n-      if (!me_arg->ts.is_class)\n+      if (me_arg->ts.u.derived->components->ts.u.derived\n+\t  != resolve_bindings_derived)\n \t{\n-\t  gfc_error (\"Non-polymorphic passed-object dummy argument of '%s'\"\n-\t\t     \" at %L\", proc->name, &where);\n+\t  gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L must be of\"\n+\t\t     \" the derived-type '%s'\", me_arg->name, proc->name,\n+\t\t     me_arg->name, &where, resolve_bindings_derived->name);\n \t  goto error;\n \t}\n+\n     }\n \n   /* If we are extending some type, check that we don't override a procedure\n@@ -9475,7 +9706,7 @@ resolve_fl_derived (gfc_symbol *sym)\n     return FAILURE;\n \n   /* An ABSTRACT type must be extensible.  */\n-  if (sym->attr.abstract && !type_is_extensible (sym))\n+  if (sym->attr.abstract && !gfc_type_is_extensible (sym))\n     {\n       gfc_error (\"Non-extensible derived-type '%s' at %L must not be ABSTRACT\",\n \t\t sym->name, &sym->declared_at);\n@@ -9611,8 +9842,10 @@ resolve_fl_derived (gfc_symbol *sym)\n \n \t  /* Now check that the argument-type matches.  */\n \t  gcc_assert (me_arg);\n-\t  if (me_arg->ts.type != BT_DERIVED\n-\t      || me_arg->ts.u.derived != sym)\n+\t  if ((me_arg->ts.type != BT_DERIVED && me_arg->ts.type != BT_CLASS)\n+\t      || (me_arg->ts.type == BT_DERIVED && me_arg->ts.u.derived != sym)\n+\t      || (me_arg->ts.type == BT_CLASS\n+\t\t  && me_arg->ts.u.derived->components->ts.u.derived != sym))\n \t    {\n \t      gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L must be of\"\n \t\t\t \" the derived type '%s'\", me_arg->name, c->name,\n@@ -9649,9 +9882,9 @@ resolve_fl_derived (gfc_symbol *sym)\n \t      return FAILURE;\n \t    }\n \n-\t  if (type_is_extensible (sym) && !me_arg->ts.is_class)\n+\t  if (gfc_type_is_extensible (sym) && me_arg->ts.type != BT_CLASS)\n \t    gfc_error (\"Non-polymorphic passed-object dummy argument of '%s'\"\n-\t\t\t \" at %L\", c->name, &c->loc);\n+\t\t       \" at %L\", c->name, &c->loc);\n \n \t}\n \n@@ -9720,8 +9953,9 @@ resolve_fl_derived (gfc_symbol *sym)\n \t}\n \n       /* C437.  */\n-      if (c->ts.type == BT_DERIVED && c->ts.is_class\n-\t  && !(c->attr.pointer || c->attr.allocatable))\n+      if (c->ts.type == BT_CLASS\n+\t  && !(c->ts.u.derived->components->attr.pointer\n+\t       || c->ts.u.derived->components->attr.allocatable))\n \t{\n \t  gfc_error (\"Component '%s' with CLASS at %L must be allocatable \"\n \t\t     \"or pointer\", c->name, &c->loc);"}, {"sha": "f1765e6ed7ce4a7dd134bd427c838e1d25ec9603", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -122,6 +122,7 @@ gfc_free_statement (gfc_code *p)\n       break;\n \n     case EXEC_SELECT:\n+    case EXEC_SELECT_TYPE:\n       if (p->ext.case_list)\n \tgfc_free_case_list (p->ext.case_list);\n       break;\n@@ -132,7 +133,7 @@ gfc_free_statement (gfc_code *p)\n \n     case EXEC_ALLOCATE:\n     case EXEC_DEALLOCATE:\n-      gfc_free_alloc_list (p->ext.alloc_list);\n+      gfc_free_alloc_list (p->ext.alloc.list);\n       break;\n \n     case EXEC_OPEN:"}, {"sha": "39285b16fea288703e5cab4a53bb639f01266470", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -2644,6 +2644,13 @@ gfc_get_ha_sym_tree (const char *name, gfc_symtree **result)\n   int i;\n \n   i = gfc_find_sym_tree (name, gfc_current_ns, 0, &st);\n+\n+  /* Special case: If we're in a SELECT TYPE block,\n+     replace the selector variable by a temporary.  */\n+  if (gfc_current_state () == COMP_SELECT_TYPE\n+      && st && st->n.sym == type_selector)\n+    st = select_type_tmp;\n+\n   if (st != NULL)\n     {\n       save_symbol_data (st->n.sym);\n@@ -4534,26 +4541,51 @@ gfc_get_derived_super_type (gfc_symbol* derived)\n }\n \n \n+/* Get the ultimate super-type of a given derived type.  */\n+\n+gfc_symbol*\n+gfc_get_ultimate_derived_super_type (gfc_symbol* derived)\n+{\n+  if (!derived->attr.extension)\n+    return NULL;\n+\n+  derived = gfc_get_derived_super_type (derived);\n+\n+  if (derived->attr.extension)\n+    return gfc_get_ultimate_derived_super_type (derived);\n+  else\n+    return derived;\n+}\n+\n+\n+/* Check if a derived type t2 is an extension of (or equal to) a type t1.  */\n+\n+bool\n+gfc_type_is_extension_of (gfc_symbol *t1, gfc_symbol *t2)\n+{\n+  while (!gfc_compare_derived_types (t1, t2) && t2->attr.extension)\n+    t2 = gfc_get_derived_super_type (t2);\n+  return gfc_compare_derived_types (t1, t2);\n+}\n+\n+\n /* Check if two typespecs are type compatible (F03:5.1.1.2):\n    If ts1 is nonpolymorphic, ts2 must be the same type.\n    If ts1 is polymorphic (CLASS), ts2 must be an extension of ts1.  */\n \n bool\n gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)\n {\n-  if (ts1->type == BT_DERIVED && ts2->type == BT_DERIVED)\n+  if ((ts1->type == BT_DERIVED || ts1->type == BT_CLASS)\n+      && (ts2->type == BT_DERIVED || ts2->type == BT_CLASS))\n     {\n-      gfc_symbol *t0, *t;\n-      if (ts1->is_class)\n-\t{\n-\t  t0 = ts1->u.derived;\n-\t  t = ts2->u.derived;\n-\t  while (t0 != t && t->attr.extension)\n-\t    t = gfc_get_derived_super_type (t);\n-\t  return (t0 == t);\n-\t}\n+      if (ts1->type == BT_CLASS)\n+\treturn gfc_type_is_extension_of (ts1->u.derived->components->ts.u.derived,\n+\t\t\t\t\t ts2->u.derived);\n+      else if (ts2->type != BT_CLASS)\n+\treturn gfc_compare_derived_types (ts1->u.derived, ts2->u.derived);\n       else\n-\treturn (ts1->u.derived == ts2->u.derived);\n+\treturn 0;\n     }\n   else\n     return (ts1->type == ts2->type);"}, {"sha": "0c00d322ae77fd532a74178368d21812532ddde0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -5873,7 +5873,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \n-\t  if (c->attr.allocatable)\n+\t  if (c->attr.allocatable && c->attr.dimension)\n \t    {\n \t      comp = fold_build3 (COMPONENT_REF, ctype,\n \t\t\t\t  decl, cdecl, NULL_TREE);\n@@ -5885,7 +5885,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \tcase NULLIFY_ALLOC_COMP:\n \t  if (c->attr.pointer)\n \t    continue;\n-\t  else if (c->attr.allocatable)\n+\t  else if (c->attr.allocatable && c->attr.dimension)\n \t    {\n \t      comp = fold_build3 (COMPONENT_REF, ctype,\n \t\t\t\t  decl, cdecl, NULL_TREE);\n@@ -6072,7 +6072,8 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n       gfc_add_expr_to_block (&fnblock, tmp);\n     }\n \n-  if (sym->attr.allocatable && !sym->attr.save && !sym->attr.result)\n+  if (sym->attr.allocatable && sym->attr.dimension\n+      && !sym->attr.save && !sym->attr.result)\n     {\n       tmp = gfc_trans_dealloc_allocated (sym->backend_decl);\n       gfc_add_expr_to_block (&fnblock, tmp);"}, {"sha": "eb741f8231f6824ce0097b06da2aa69c23f89c87", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 77, "deletions": 7, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -482,7 +482,8 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n       se->string_length = tmp;\n     }\n \n-  if ((c->attr.pointer && c->attr.dimension == 0 && c->ts.type != BT_CHARACTER)\n+  if (((c->attr.pointer || c->attr.allocatable) && c->attr.dimension == 0\n+       && c->ts.type != BT_CHARACTER)\n       || c->attr.proc_pointer)\n     se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\tse->expr);\n@@ -510,8 +511,12 @@ conv_parent_component_references (gfc_se * se, gfc_ref * ref)\n \n   if (dt->attr.extension && dt->components)\n     {\n+      if (dt->attr.is_class)\n+\tcmp = dt->components;\n+      else\n+\tcmp = dt->components->next;\n       /* Return if the component is not in the parent type.  */\n-      for (cmp = dt->components->next; cmp; cmp = cmp->next)\n+      for (; cmp; cmp = cmp->next)\n \tif (strcmp (c->name, cmp->name) == 0)\n \t  return;\n \t\n@@ -2641,6 +2646,49 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\tparmse.string_length = build_int_cst (gfc_charlen_type_node, 0);\n \t    }\n \t}\n+      else if (fsym && fsym->ts.type == BT_CLASS\n+\t\t && e->ts.type == BT_DERIVED)\n+\t{\n+\t  tree data;\n+\t  tree vindex;\n+\n+\t  /* The derived type needs to be converted to a temporary\n+\t     CLASS object.  */\n+\t  gfc_init_se (&parmse, se);\n+\t  type = gfc_typenode_for_spec (&fsym->ts);\n+\t  var = gfc_create_var (type, \"class\");\n+\n+\t  /* Get the components.  */\n+\t  tmp = fsym->ts.u.derived->components->backend_decl;\n+\t  data = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t\t      var, tmp, NULL_TREE);\n+\t  tmp = fsym->ts.u.derived->components->next->backend_decl;\n+\t  vindex = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t\t      var, tmp, NULL_TREE);\n+\n+\t  /* Set the vindex.  */\n+\t  tmp = build_int_cst (TREE_TYPE (vindex),\n+\t\t\t       e->ts.u.derived->vindex);\n+\t  gfc_add_modify (&parmse.pre, vindex, tmp);\n+\n+\t  /* Now set the data field.  */\n+\t  argss = gfc_walk_expr (e);\n+\t  if (argss == gfc_ss_terminator)\n+            {\n+\t      gfc_conv_expr_reference (&parmse, e);\n+\t      tmp = fold_convert (TREE_TYPE (data),\n+\t\t\t\t  parmse.expr);\n+\t      gfc_add_modify (&parmse.pre, data, tmp);\n+\t    }\n+\t  else\n+\t    {\n+\t      gfc_conv_expr (&parmse, e);\n+\t      gfc_add_modify (&parmse.pre, data, parmse.expr);\n+\t    }\n+\n+\t  /* Pass the address of the class object.  */\n+\t  parmse.expr = gfc_build_addr_expr (NULL_TREE, var);\n+\t}\n       else if (se->ss && se->ss->useflags)\n \t{\n \t  /* An elemental function inside a scalarized loop.  */\n@@ -3607,6 +3655,7 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n       switch (ts->type)\n \t{\n \tcase BT_DERIVED:\n+\tcase BT_CLASS:\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_structure (&se, expr, 1);\n \t  return se.expr;\n@@ -3771,6 +3820,13 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t  gfc_add_block_to_block (&block, &se.post);\n \t}\n     }\n+  else if (cm->ts.type == BT_CLASS && expr->expr_type == EXPR_NULL)\n+    {\n+      /* NULL initialization for CLASS components.  */\n+      tmp = gfc_trans_structure_assign (dest,\n+\t\t\t\t\tgfc_default_initializer (&cm->ts));\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n   else if (cm->attr.dimension)\n     {\n       if (cm->attr.allocatable && expr->expr_type == EXPR_NULL)\n@@ -3966,12 +4022,26 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       if (!c->expr || cm->attr.allocatable)\n         continue;\n \n-      val = gfc_conv_initializer (c->expr, &cm->ts,\n-\t  TREE_TYPE (cm->backend_decl), cm->attr.dimension,\n-\t  cm->attr.pointer || cm->attr.proc_pointer);\n+      if (cm->ts.type == BT_CLASS)\n+\t{\n+\t  val = gfc_conv_initializer (c->expr, &cm->ts,\n+\t      TREE_TYPE (cm->ts.u.derived->components->backend_decl),\n+\t      cm->ts.u.derived->components->attr.dimension,\n+\t      cm->ts.u.derived->components->attr.pointer);\n+\n+\t  /* Append it to the constructor list.  */\n+\t  CONSTRUCTOR_APPEND_ELT (v, cm->ts.u.derived->components->backend_decl,\n+\t\t\t\t  val);\n+\t}\n+      else\n+\t{\n+\t  val = gfc_conv_initializer (c->expr, &cm->ts,\n+\t      TREE_TYPE (cm->backend_decl), cm->attr.dimension,\n+\t      cm->attr.pointer || cm->attr.proc_pointer);\n \n-      /* Append it to the constructor list.  */\n-      CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n+\t  /* Append it to the constructor list.  */\n+\t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n+\t}\n     }\n   se->expr = build_constructor (type, v);\n   if (init) "}, {"sha": "b00cebaf0c7860a8a2c3aabf0e53e4166cb0c77a", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -4700,6 +4700,56 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n }\n \n \n+/* Generate code for the SAME_TYPE_AS intrinsic.\n+   Generate inline code that directly checks the vindices.  */\n+\n+static void\n+gfc_conv_same_type_as (gfc_se *se, gfc_expr *expr)\n+{\n+  gfc_expr *a, *b;\n+  gfc_se se1, se2;\n+  tree tmp;\n+\n+  gfc_init_se (&se1, NULL);\n+  gfc_init_se (&se2, NULL);\n+\n+  a = expr->value.function.actual->expr;\n+  b = expr->value.function.actual->next->expr;\n+\n+  if (a->ts.type == BT_CLASS)\n+    gfc_add_component_ref (a, \"$vindex\");\n+  else if (a->ts.type == BT_DERIVED)\n+    a = gfc_int_expr (a->ts.u.derived->vindex);\n+\n+  if (b->ts.type == BT_CLASS)\n+    gfc_add_component_ref (b, \"$vindex\");\n+  else if (b->ts.type == BT_DERIVED)\n+    b = gfc_int_expr (b->ts.u.derived->vindex);\n+\n+  gfc_conv_expr (&se1, a);\n+  gfc_conv_expr (&se2, b);\n+\n+  tmp = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t     se1.expr, fold_convert (TREE_TYPE (se1.expr), se2.expr));\n+  se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n+}\n+\n+\n+/* Generate code for the EXTENDS_TYPE_OF intrinsic.  */\n+\n+static void\n+gfc_conv_extends_type_of (gfc_se *se, gfc_expr *expr)\n+{\n+  gfc_expr *e;\n+  /* TODO: Implement EXTENDS_TYPE_OF.  */\n+  gfc_error (\"Intrinsic EXTENDS_TYPE_OF at %L not yet implemented\",\n+\t     &expr->where);\n+  /* Just return 'false' for now.  */\n+  e = gfc_logical_expr (false, &expr->where);\n+  gfc_conv_expr (se, e);\n+}\n+\n+\n /* Generate code for SELECTED_CHAR_KIND (NAME) intrinsic function.  */\n \n static void\n@@ -5108,6 +5158,14 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_associated(se, expr);\n       break;\n \n+    case GFC_ISYM_SAME_TYPE_AS:\n+      gfc_conv_same_type_as (se, expr);\n+      break;\n+\n+    case GFC_ISYM_EXTENDS_TYPE_OF:\n+      gfc_conv_extends_type_of (se, expr);\n+      break;\n+\n     case GFC_ISYM_ABS:\n       gfc_conv_intrinsic_abs (se, expr);\n       break;"}, {"sha": "9d3197d11bcbe77932adf78210ec55a9d58dc0fb", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -3992,7 +3992,7 @@ tree\n gfc_trans_allocate (gfc_code * code)\n {\n   gfc_alloc *al;\n-  gfc_expr *expr;\n+  gfc_expr *expr, *init_e, *rhs;\n   gfc_se se;\n   tree tmp;\n   tree parm;\n@@ -4001,7 +4001,7 @@ gfc_trans_allocate (gfc_code * code)\n   tree error_label;\n   stmtblock_t block;\n \n-  if (!code->ext.alloc_list)\n+  if (!code->ext.alloc.list)\n     return NULL_TREE;\n \n   pstat = stat = error_label = tmp = NULL_TREE;\n@@ -4020,7 +4020,7 @@ gfc_trans_allocate (gfc_code * code)\n       TREE_USED (error_label) = 1;\n     }\n \n-  for (al = code->ext.alloc_list; al != NULL; al = al->next)\n+  for (al = code->ext.alloc.list; al != NULL; al = al->next)\n     {\n       expr = al->expr;\n \n@@ -4034,7 +4034,24 @@ gfc_trans_allocate (gfc_code * code)\n       if (!gfc_array_allocate (&se, expr, pstat))\n \t{\n \t  /* A scalar or derived type.  */\n-\t  tmp = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (se.expr)));\n+\n+\t  /* Determine allocate size.  */\n+\t  if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n+\t    {\n+\t      gfc_typespec *ts;\n+\t      /* TODO: Size must be determined at run time, since it must equal\n+\t\t the size of the dynamic type of SOURCE, not the declared type.  */\n+\t      gfc_warning (\"Dynamic size allocation at %L not supported yet, \"\n+\t\t\t   \"using size of declared type\", &code->loc);\n+\t      ts = &code->expr3->ts.u.derived->components->ts;\n+\t      tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (ts));\n+\t    }\n+\t  else if (code->expr3 && code->expr3->ts.type != BT_CLASS)\n+\t    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr3->ts));\n+\t  else if (code->ext.alloc.ts.type != BT_UNKNOWN)\n+\t    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->ext.alloc.ts));\n+\t  else\n+\t    tmp = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (se.expr)));\n \n \t  if (expr->ts.type == BT_CHARACTER && tmp == NULL_TREE)\n \t    tmp = se.string_length;\n@@ -4065,6 +4082,23 @@ gfc_trans_allocate (gfc_code * code)\n \n       tmp = gfc_finish_block (&se.pre);\n       gfc_add_expr_to_block (&block, tmp);\n+\n+      /* Initialization via SOURCE block.  */\n+      if (code->expr3)\n+\t{\n+\t  rhs = gfc_copy_expr (code->expr3);\n+\t  if (rhs->ts.type == BT_CLASS)\n+\t    gfc_add_component_ref (rhs, \"$data\");\n+\t  tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr), rhs, false);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+      /* Add default initializer for those derived types that need them.  */\n+      else if (expr->ts.type == BT_DERIVED && (init_e = gfc_default_initializer (&expr->ts)))\n+\t{\n+\t  tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr), init_e, true);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+\n     }\n \n   /* STAT block.  */\n@@ -4111,44 +4145,6 @@ gfc_trans_allocate (gfc_code * code)\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n-  /* SOURCE block.  Note, by C631, we know that code->ext.alloc_list\n-     has a single entity.  */\n-  if (code->expr3)\n-    {\n-      gfc_ref *ref;\n-      gfc_array_ref *ar;\n-      int n;\n-\n-      /* If there is a terminating array reference, this is converted\n-\t to a full array, so that gfc_trans_assignment can scalarize the\n-\t expression for the source.  */\n-      for (ref = code->ext.alloc_list->expr->ref; ref; ref = ref->next)\n-\t{\n-\t  if (ref->next == NULL)\n-\t    {\n-\t      if (ref->type != REF_ARRAY)\n-\t\tbreak;\n-\n-\t      ref->u.ar.type = AR_FULL;\n-\t      ar = &ref->u.ar;\n-\t      ar->dimen = ar->as->rank;\n-\t      for (n = 0; n < ar->dimen; n++)\n-\t\t{\n-\t\t  ar->dimen_type[n] = DIMEN_RANGE;\n-\t\t  gfc_free_expr (ar->start[n]);\n-\t\t  gfc_free_expr (ar->end[n]);\n-\t\t  gfc_free_expr (ar->stride[n]);\n-\t\t  ar->start[n] = NULL;\n-\t\t  ar->end[n] = NULL;\n-\t\t  ar->stride[n] = NULL;\n-\t\t}\n-\t    }\n-\t}\n-\n-      tmp = gfc_trans_assignment (code->ext.alloc_list->expr, code->expr3, false);\n-      gfc_add_expr_to_block (&block, tmp);\n-    }\n-\n   return gfc_finish_block (&block);\n }\n \n@@ -4186,7 +4182,7 @@ gfc_trans_deallocate (gfc_code *code)\n       gfc_add_modify (&block, astat, build_int_cst (TREE_TYPE (astat), 0));\n     }\n \n-  for (al = code->ext.alloc_list; al != NULL; al = al->next)\n+  for (al = code->ext.alloc.list; al != NULL; al = al->next)\n     {\n       expr = al->expr;\n       gcc_assert (expr->expr_type == EXPR_VARIABLE);"}, {"sha": "9096ad408495c5275d8aaa94b737edc41b01f8bc", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1029,6 +1029,7 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n       break;\n \n     case BT_DERIVED:\n+    case BT_CLASS:\n       basetype = gfc_get_derived_type (spec->u.derived);\n \n       /* If we're dealing with either C_PTR or C_FUNPTR, we modified the\n@@ -2063,7 +2064,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n      will be built and so we can return the type.  */\n   for (c = derived->components; c; c = c->next)\n     {\n-      if (c->ts.type != BT_DERIVED)\n+      if (c->ts.type != BT_DERIVED && c->ts.type != BT_CLASS)\n \tcontinue;\n \n       if ((!c->attr.pointer && !c->attr.proc_pointer)\n@@ -2098,7 +2099,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n     {\n       if (c->attr.proc_pointer)\n \tfield_type = gfc_get_ppc_type (c);\n-      else if (c->ts.type == BT_DERIVED)\n+      else if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n         field_type = c->ts.u.derived->backend_decl;\n       else\n \t{\n@@ -2134,7 +2135,8 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t\t\t\t\t\t    PACKED_STATIC,\n \t\t\t\t\t\t    !c->attr.target);\n \t}\n-      else if (c->attr.pointer && !c->attr.proc_pointer)\n+      else if ((c->attr.pointer || c->attr.allocatable)\n+\t       && !c->attr.proc_pointer)\n \tfield_type = build_pointer_type (field_type);\n \n       field = gfc_add_field_to_struct (&fieldlist, typenode,"}, {"sha": "09b424c378fc03a329580ea42793325f500db8e0", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1173,6 +1173,13 @@ gfc_trans_code (gfc_code * code)\n \t  res = gfc_trans_select (code);\n \t  break;\n \n+\tcase EXEC_SELECT_TYPE:\n+\t  /* Do nothing. SELECT TYPE statements should be transformed into\n+\t  an ordinary SELECT CASE at resolution stage.\n+\t  TODO: Add an error message here once this is done.  */\n+\t  res = NULL_TREE;\n+\t  break;\n+\n \tcase EXEC_FLUSH:\n \t  res = gfc_trans_flush (code);\n \t  break;"}, {"sha": "1a98272bc4c806b103bc15a4c0e248553762cf0e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,3 +1,53 @@\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* gfortran.dg/same_type_as_1.f03: New test.\n+\t* gfortran.dg/same_type_as_2.f03: Ditto.\n+\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* gfortran.dg/select_type_1.f03: Extended.\n+\t* gfortran.dg/select_type_3.f03: New test.\n+\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* gfortran.dg/class_allocate_1.f03: New test.\n+\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/40996\n+\t* gfortran.dg/allocatable_scalar_3.f90: New test.\n+\t* gfortran.dg/select_type_2.f03: Ditto.\n+\t* gfortran.dg/typebound_proc_5.f03: Changed error messages.\n+\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* gfortran.dg/block_name_2.f90: Modified error message.\n+\t* gfortran.dg/select_6.f90: Ditto.\n+\t* gfortran.dg/select_type_1.f03: New test.\n+\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* gfortran.dg/allocate_derived_1.f90: Remove -w option.\n+\t* gfortran.dg/class_1.f03: Ditto.\n+\t* gfortran.dg/class_2.f03: Ditto.\n+\t* gfortran.dg/proc_ptr_comp_pass_1.f90: Ditto.\n+\t* gfortran.dg/proc_ptr_comp_pass_2.f90: Ditto.\n+\t* gfortran.dg/proc_ptr_comp_pass_3.f90: Ditto.\n+\t* gfortran.dg/typebound_call_10.f03: Ditto.\n+\t* gfortran.dg/typebound_call_2.f03: Ditto.\n+\t* gfortran.dg/typebound_call_3.f03: Ditto.\n+\t* gfortran.dg/typebound_call_4.f03: Ditto.\n+\t* gfortran.dg/typebound_call_9.f03: Ditto.\n+\t* gfortran.dg/typebound_generic_3.f03: Ditto.\n+\t* gfortran.dg/typebound_generic_4.f03: Ditto.\n+\t* gfortran.dg/typebound_operator_1.f03: Ditto.\n+\t* gfortran.dg/typebound_operator_2.f03: Ditto.\n+\t* gfortran.dg/typebound_operator_3.f03: Ditto.\n+\t* gfortran.dg/typebound_operator_4.f03: Ditto.\n+\t* gfortran.dg/typebound_proc_1.f08: Ditto.\n+\t* gfortran.dg/typebound_proc_5.f03: Ditto.\n+\t* gfortran.dg/typebound_proc_6.f03: Ditto.\n+\n 2009-09-30  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/eh/init-temp1.C: Improve test."}, {"sha": "c624de22d36f055b260a9ac7ec1055d60685794e", "filename": "gcc/testsuite/gfortran.dg/allocatable_scalar_3.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_3.f90?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+!\n+! PR 40996: [F03] ALLOCATABLE scalars\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+implicit none\n+\n+type :: t\n+  integer, allocatable :: i\n+end type\n+\n+type(t)::x\n+\n+allocate(x%i)\n+\n+x%i = 13\n+print *,x%i\n+if (.not. allocated(x%i)) call abort()\n+\n+deallocate(x%i)\n+\n+if (allocated(x%i)) call abort()\n+\n+end"}, {"sha": "b9f6d5580a0482a8ff4b3db4c4929ecd63af9b0f", "filename": "gcc/testsuite/gfortran.dg/allocate_derived_1.f90", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_derived_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_derived_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_derived_1.f90?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do compile }\n !\n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-!\n ! ALLOCATE statements with derived type specification\n !\n ! Contributed by Janus Weil <janus@gcc.gnu.org>"}, {"sha": "d86e77e7a8c93b93fa6855453c80282b1cd7d843", "filename": "gcc/testsuite/gfortran.dg/block_name_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_name_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_name_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblock_name_2.f90?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -43,8 +43,8 @@ program blocks\n   end if\n \n   select case (i)\n-  case (1) s2  ! { dg-error \"Expected the name of the SELECT CASE construct\" }\n-  case default s2 ! { dg-error \"Expected the name of the SELECT CASE construct\" }\n+  case (1) s2  ! { dg-error \"Syntax error in CASE specification\" }\n+  case default s2 ! { dg-error \"Syntax error in CASE specification\" }\n   end select s2 ! { dg-error \"Syntax error in END SELECT statement\" }\n   end select\n "}, {"sha": "f21133a05adf32a01e1449ab2d4eeb1c183d13e0", "filename": "gcc/testsuite/gfortran.dg/class_1.f03", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_1.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do run }\n !\n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-!\n ! PR 40940: CLASS statement\n !\n ! Contributed by Janus Weil <janus@gcc.gnu.org>"}, {"sha": "070d3f76fdd0cf1db70668739d217c059a98a97a", "filename": "gcc/testsuite/gfortran.dg/class_2.f03", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_2.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do compile }\n !\n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-!\n ! PR 40940: CLASS statement\n !\n ! Contributed by Janus Weil <janus@gcc.gnu.org>"}, {"sha": "844e1447fbf41dc1d6a3e1760e61803da4088ac8", "filename": "gcc/testsuite/gfortran.dg/class_allocate_1.f03", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_1.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -0,0 +1,95 @@\n+! { dg-do run }\n+!\n+! Allocating CLASS variables.\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+ implicit none\n+\n+ type t1\n+   integer :: comp = 5\n+   class(t1),pointer :: cc\n+ end type\n+\n+ type, extends(t1) :: t2\n+   integer :: j\n+ end type\n+\n+ type, extends(t2) :: t3\n+   integer :: k\n+ end type\n+\n+ class(t1),pointer :: cp, cp2\n+ type(t3) :: x\n+ integer :: i\n+\n+\n+ ! (1) check that vindex is set correctly (for different cases)\n+\n+ i = 0\n+ allocate(cp)\n+ select type (cp)\n+ type is (t1)\n+   i = 1\n+ type is (t2)\n+   i = 2\n+ type is (t3)\n+   i = 3\n+ end select\n+ deallocate(cp)\n+ if (i /= 1) call abort()\n+\n+ i = 0\n+ allocate(t2 :: cp)\n+ select type (cp)\n+ type is (t1)\n+   i = 1\n+ type is (t2)\n+   i = 2\n+ type is (t3)\n+   i = 3\n+ end select\n+ deallocate(cp)\n+ if (i /= 2) call abort()\n+\n+ i = 0\n+ allocate(cp, source = x)\n+ select type (cp)\n+ type is (t1)\n+   i = 1\n+ type is (t2)\n+   i = 2\n+ type is (t3)\n+   i = 3\n+ end select\n+ deallocate(cp)\n+ if (i /= 3) call abort()\n+\n+ i = 0\n+ allocate(t2 :: cp2)\n+ allocate(cp, source = cp2)  ! { dg-warning \"not supported yet\" }\n+ select type (cp)\n+ type is (t1)\n+   i = 1\n+ type is (t2)\n+   i = 2\n+ type is (t3)\n+   i = 3\n+ end select\n+ deallocate(cp)\n+ deallocate(cp2)\n+ if (i /= 2) call abort()\n+\n+\n+ ! (2) check initialization (default initialization vs. SOURCE)\n+\n+ allocate(cp)\n+ if (cp%comp /= 5) call abort()\n+ deallocate(cp)\n+\n+ x%comp = 4\n+ allocate(cp, source=x)\n+ if (cp%comp /= 4) call abort()\n+ deallocate(cp)\n+\n+end"}, {"sha": "4513083ac5d4dce7d17212226ab4f3573de5a7f2", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_pass_1.f90", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_1.f90?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do run }\n !\n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-!\n ! PR 39630: [F03] Procedure Pointer Components with PASS\n !\n ! found at http://groups.google.com/group/comp.lang.fortran/browse_thread/thread/4a827e8ced6efb0f/884b9eca6d7e6742"}, {"sha": "03770ce3ff8ffd77a49fca5f28a8ad3faf0e9e09", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_pass_2.f90", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_2.f90?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do run }\n !\n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-!\n ! PR 39630: [F03] Procedure Pointer Components with PASS\n !\n ! taken from \"The Fortran 2003 Handbook\" (Adams et al., 2009)"}, {"sha": "add025cb050f57fc0020e29a92e3067295a8d90a", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_pass_3.f90", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_3.f90?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do run }\n !\n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-!\n ! PR 39630: [F03] Procedure Pointer Components with PASS\n !\n ! taken from \"Fortran 95/2003 explained\" (Metcalf, Reid, Cohen, 2004)"}, {"sha": "ba13a0b731e0fe9a8255142473ee9b0ad8a52f90", "filename": "gcc/testsuite/gfortran.dg/same_type_as_1.f03", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_type_as_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_type_as_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_type_as_1.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+!\n+! Error checking for the intrinsic function SAME_TYPE_AS.\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+ type :: t1\n+  integer :: i\n+ end type \n+\n+ type :: ts\n+  sequence\n+  integer :: j\n+ end type\n+\n+ TYPE(t1) :: x1\n+ TYPE(ts) :: x2\n+\n+ integer :: i\n+\n+ print *, SAME_TYPE_AS (l,x1)   ! { dg-error \"must be of a derived type\" }\n+ print *, SAME_TYPE_AS (x1,x2)  ! { dg-error \"must be of an extensible type\" }\n+\n+end"}, {"sha": "9a2110d47b621bd2c6324d8c6f1cf2dc955a0037", "filename": "gcc/testsuite/gfortran.dg/same_type_as_2.f03", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_type_as_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_type_as_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_type_as_2.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do run }\n+!\n+! Verifying the runtime behavior of the intrinsic function SAME_TYPE_AS.\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+ type :: t1\n+  integer :: i\n+ end type \n+\n+ type :: t2\n+  integer :: j\n+ end type\n+\n+ CLASS(t1), pointer :: c1\n+ CLASS(t2), pointer :: c2\n+ TYPE(t1), target :: x1\n+ TYPE(t2) ,target :: x2\n+\n+ intrinsic :: SAME_TYPE_AS\n+ logical :: l\n+\n+ c1 => NULL()\n+\n+ l = SAME_TYPE_AS (x1,x1)\n+ print *,l\n+ if (.not.l) call abort()\n+ l = SAME_TYPE_AS (x1,x2)\n+ print *,l\n+ if (l) call abort()\n+\n+ c1 => x1\n+ l = SAME_TYPE_AS (c1,x1)\n+ print *,l\n+ if (.not.l) call abort()\n+ l = SAME_TYPE_AS (c1,x2)\n+ print *,l\n+ if (l) call abort()\n+\n+ c1 => x2\n+ c2 => x2\n+ l = SAME_TYPE_AS (c1,c2)\n+ print *,l\n+ if (.not.l) call abort()\n+\n+ c1 => x1\n+ c2 => x2\n+ l = SAME_TYPE_AS (c1,c2)\n+ print *,l\n+ if (l) call abort()\n+\n+end"}, {"sha": "0e0f05244237f2e47fde356b82ee31e241551c0d", "filename": "gcc/testsuite/gfortran.dg/select_6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_6.f90?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -5,6 +5,6 @@\n         integer(kind=1) :: i\n         real :: r(3)\n         select case (i)\n-        case (129) r(4) = 0 { dg-error \"Expected the name\" }\n+        case (129) r(4) = 0  ! { dg-error \"Syntax error in CASE specification\" }\n         end select\n         end"}, {"sha": "e764ec98f48b8a1880c3fe7339518829d8a9b29d", "filename": "gcc/testsuite/gfortran.dg/select_type_1.f03", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_1.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -0,0 +1,72 @@\n+! { dg-do compile }\n+!\n+! Error checking for the SELECT TYPE statement\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+  type :: t1\n+    integer :: i = 42\n+    class(t1),pointer :: cp\n+  end type\n+\n+  type, extends(t1) :: t2\n+    integer :: j = 99\n+  end type\n+\n+  type :: t3\n+    real :: r\n+  end type\n+\n+  type :: ts\n+    sequence\n+    integer :: k = 5\n+  end type\n+\n+  class(t1), pointer :: a => NULL()\n+  type(t1), target :: b\n+  type(t2), target :: c\n+  a => b\n+  print *, a%i\n+\n+  type is (t1)  ! { dg-error \"Unexpected TYPE IS statement\" }\n+\n+  select type (3.5)  ! { dg-error \"Selector must be a named variable\" }\n+  select type (a%cp) ! { dg-error \"Selector must be a named variable\" }\n+  select type (b)    ! { dg-error \"Selector shall be polymorphic\" }\n+\n+  select type (a)\n+    print *,\"hello world!\"  ! { dg-error \"Expected TYPE IS, CLASS IS or END SELECT\" }\n+  type is (t1)\n+    print *,\"a is TYPE(t1)\"\n+  type is (t2)\n+    print *,\"a is TYPE(t2)\"\n+! FIXME: CLASS IS specification is not yet supported\n+!  class is (ts)  ! { FIXME: error \"must be extensible\" }\n+!    print *,\"a is TYPE(ts)\"\n+  type is (t3)   ! { dg-error \"must be an extension of\" }\n+    print *,\"a is TYPE(t3)\"\n+  type is (t4)   ! { dg-error \"is not an accessible derived type\" }\n+    print *,\"a is TYPE(t3)\"\n+! FIXME: CLASS IS specification is not yet supported\n+!  class is (t1)\n+!    print *,\"a is CLASS(t1)\"\n+  class is (t2) label  ! { dg-error \"Syntax error\" }\n+    print *,\"a is CLASS(t2)\"\n+  class default  ! { dg-error \"cannot be followed by a second DEFAULT CASE\" }\n+    print *,\"default\"\n+  class default  ! { dg-error \"cannot be followed by a second DEFAULT CASE\" }\n+    print *,\"default2\"\n+  end select\n+\n+label: select type (a)\n+  type is (t1) label\n+    print *,\"a is TYPE(t1)\"\n+  type is (t2)  ! { dg-error \"overlaps with CASE label\" }\n+    print *,\"a is TYPE(t2)\"\n+  type is (t2)  ! { dg-error \"overlaps with CASE label\" }\n+    print *,\"a is still TYPE(t2)\"\n+  class is (t1) labe   ! { dg-error \"Expected block name\" }\n+    print *,\"a is CLASS(t1)\"\n+  end select label\n+\n+end"}, {"sha": "08ac9fef6e86af9cfe3b1ffd5278d81665cf55fe", "filename": "gcc/testsuite/gfortran.dg/select_type_2.f03", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_2.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+!\n+! executing simple SELECT TYPE statements\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+  type :: t1\n+    integer :: i\n+  end type t1\n+\n+  type, extends(t1) :: t2\n+    integer :: j\n+  end type t2\n+\n+  type, extends(t1) :: t3\n+    real :: r\n+  end type\n+\n+  class(t1), pointer :: cp\n+  type(t1), target :: a\n+  type(t2), target :: b\n+  type(t3), target :: c\n+  integer :: i\n+\n+  cp => a\n+  i = 0\n+\n+  select type (cp)\n+  type is (t1)\n+    i = 1\n+  type is (t2)\n+    i = 2\n+! FIXME: CLASS IS is not yet supported\n+!  class is (t1)\n+!    i = 3\n+  end select\n+\n+  if (i /= 1) call abort()\n+\n+  cp => b\n+  i = 0\n+\n+  select type (cp)\n+  type is (t1)\n+    i = 1\n+  type is (t2)\n+    i = 2\n+! FIXME: CLASS IS is not yet supported\n+!  class is (t2)\n+!    i = 3\n+  end select\n+\n+  if (i /= 2) call abort()\n+\n+  cp => c\n+  i = 0\n+\n+  select type (cp)\n+  type is (t1)\n+    i = 1\n+  type is (t2)\n+    i = 2\n+  class default\n+    i = 3\n+  end select\n+\n+  if (i /= 3) call abort()\n+\n+end"}, {"sha": "13cd3c11a821f841001c7ad0eef5301e77173739", "filename": "gcc/testsuite/gfortran.dg/select_type_3.f03", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_3.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+!\n+! SELECT TYPE with temporaries\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+  type :: t1\n+    integer :: i = -1\n+  end type t1\n+\n+  type, extends(t1) :: t2\n+    integer :: j = -1\n+  end type t2\n+\n+  class(t1), pointer :: cp\n+  type(t2), target :: b\n+\n+  cp => b\n+\n+  select type (cp)\n+  type is (t1)\n+    cp%i = 1\n+  type is (t2)\n+    cp%j = 2\n+  end select\n+\n+  print *,b%i,b%j\n+  if (b%i /= -1) call abort()\n+  if (b%j /= 2) call abort()\n+\n+  select type (cp)\n+  type is (t1)\n+    cp%i = 4\n+  type is (t2)\n+    cp%i = 3*cp%j\n+  end select\n+\n+  print *,b%i,b%j\n+  if (b%i /= 6) call abort()\n+  if (b%j /= 2) call abort()\n+\n+end"}, {"sha": "ca6038e45cef004acccf0fdf786fb2ae50695470", "filename": "gcc/testsuite/gfortran.dg/typebound_call_10.f03", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_10.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_10.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_10.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do run }\n !\n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-!\n ! PR 39630: [F03] Procedure Pointer Components with PASS\n !\n ! Contributed by Tobias Burnus <burnus@gcc.gnu.org>"}, {"sha": "5d70f7c17ef8a679e53561e98a61d2d3d7146642", "filename": "gcc/testsuite/gfortran.dg/typebound_call_2.f03", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_2.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do run }\n \n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-\n ! Type-bound procedures\n ! Check calls with passed-objects.\n "}, {"sha": "eabb28ef18bc9e1083b872dd08a9f1691cd517a1", "filename": "gcc/testsuite/gfortran.dg/typebound_call_3.f03", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_3.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do run }\n \n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-\n ! Type-bound procedures\n ! Check that calls work across module-boundaries.\n "}, {"sha": "cdbbea9ac010b0db0e67cb4c49b5cff55c1bfb32", "filename": "gcc/testsuite/gfortran.dg/typebound_call_4.f03", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_4.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do compile }\n \n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-\n ! Type-bound procedures\n ! Check for recognition/errors with more complicated references and some\n ! error-handling in general."}, {"sha": "6bb2ca88303360e8d4cd5fb8434765388e1151cc", "filename": "gcc/testsuite/gfortran.dg/typebound_call_9.f03", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_9.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do compile }\n \n-! FIXME: Remove once polymorphic PASS is resolved\n-! { dg-options \"-w\" }\n-\n ! PR fortran/37638\n ! If a PASS(arg) is invalid, a call to this routine later would ICE in\n ! resolving.  Check that this also works for GENERIC, in addition to the"}, {"sha": "d56f914897e3f8d719f8d5be948424752c69ac24", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_3.f03", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_3.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do run }\n \n-! FIXME: Remove -w once switched to polymorphic passed-object dummy arguments.\n-! { dg-options \"-w\" }\n-\n ! Type-bound procedures\n ! Check calls with GENERIC bindings.\n "}, {"sha": "ff5cd0582cdf982de2ea94159e358fea40a6d167", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_4.f03", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_4.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do run }\n \n-! FIXME: Remove -w once the TYPE/CLASS issue is resolved\n-! { dg-options \"-w\" }\n-\n ! PR fortran/37588\n ! This test used to not resolve the GENERIC binding.\n "}, {"sha": "f756a595b402288dcf7d17774e425a42ba622133", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_1.f03", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_1.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,6 +1,4 @@\n ! { dg-do compile }\n-! { dg-options \"-w\" }\n-! FIXME: Remove -w once CLASS is fully supported.\n \n ! Type-bound procedures\n ! Check correct type-bound operator definitions."}, {"sha": "57b34486313f0af9cb85348c89829d71bad23d80", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_2.f03", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,6 +1,4 @@\n ! { dg-do compile }\n-! { dg-options \"-w\" }\n-! FIXME: Remove -w once CLASS is fully supported.\n \n ! Type-bound procedures\n ! Checks for correct errors with invalid OPERATOR/ASSIGNMENT usage."}, {"sha": "51ad1d2f0f83ed8f5eaae0255b0860feeb562e0b", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_3.f03", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_3.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,6 +1,4 @@\n ! { dg-do run }\n-! { dg-options \"-w\" }\n-! FIXME: Remove -w when CLASS is fully implemented.\n \n ! Type-bound procedures\n ! Check they can actually be called and run correctly."}, {"sha": "1ce2b97a0d7279b4f7196d7791a44f4b9a8abfbf", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_4.f03", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_4.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,6 +1,4 @@\n ! { dg-do compile }\n-! { dg-options \"-w\" }\n-! FIXME: Remove -w when CLASS is fully implemented.\n \n ! Type-bound procedures\n ! Check for errors with operator calls."}, {"sha": "53868a4632ce04aa868f7271c3efacc9591d0447", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_1.f08", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_1.f08?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do compile }\n \n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-\n ! Type-bound procedures\n ! Test that the basic syntax for specific bindings is parsed and resolved.\n "}, {"sha": "fdd15b388d1fe7c7dadfb8c68b43e8da3a57dd21", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_5.f03", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_5.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do compile }\n \n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-\n ! Type-bound procedures\n ! Test for errors in specific bindings, during resolution.\n \n@@ -58,8 +55,8 @@ END SUBROUTINE proc_abstract_intf\n     PROCEDURE, PASS :: e1 => proc_noarg ! { dg-error \"at least one argument\" }\n     PROCEDURE :: e2 => proc_noarg ! { dg-error \"at least one argument\" }\n     PROCEDURE, PASS(me) :: e3 => proc_nome ! { dg-error \"no argument 'me'\" }\n-    PROCEDURE, PASS(me) :: e4 => proc_mewrong ! { dg-error \"of the derived\" }\n-    PROCEDURE, PASS :: e5 => proc_mewrong ! { dg-error \"of the derived\" }\n+    PROCEDURE, PASS(me) :: e4 => proc_mewrong ! { dg-error \"Non-polymorphic passed-object dummy argument\" }\n+    PROCEDURE, PASS :: e5 => proc_mewrong ! { dg-error \"Non-polymorphic passed-object dummy argument\" }\n     PROCEDURE :: e6 => noproc ! { dg-error \"module procedure\" }\n     PROCEDURE :: e7 => proc_nointf ! { dg-error \"explicit interface\" }\n     PROCEDURE, NOPASS :: e8 => proc_abstract_intf ! { dg-error \"explicit interface\" }"}, {"sha": "83765bf3009d618b7775bfba7af68467944bd494", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_6.f03", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_6.f03?ref=cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "patch": "@@ -1,8 +1,5 @@\n ! { dg-do compile }\n \n-! FIXME: Remove -w after polymorphic entities are supported.\n-! { dg-options \"-w\" }\n-\n ! Type-bound procedures\n ! Test for the check if overriding methods \"match\" the overridden ones by their\n ! characteristics."}]}