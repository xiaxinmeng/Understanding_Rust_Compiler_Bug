{"sha": "34bea46406d7ba187df47051b01a60ea29fde38c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRiZWE0NjQwNmQ3YmExODdkZjQ3MDUxYjAxYTYwZWEyOWZkZTM4Yw==", "commit": {"author": {"name": "Craig Burley", "email": "burley@gnu.org", "date": "1998-02-08T23:55:11Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-02-08T23:55:11Z"}, "message": "Fix -fpedantic combined with `F()' invocation,\n\n        also -fugly-comma combined with `IARGC()' invocation:\n        * bad.def (FFEBAD_NULL_ARGUMENT_W): New diagnostic.\n        * expr.c (ffeexpr_finished_): Don't reject null expressions\n        in the argument-expression context -- let outer context\n        handle that.\n        (ffeexpr_token_arguments_): Warn about null expressions\n        here if -fpedantic (as appropriate).\n        Obey -fugly-comma for only external-procedure invocations.\n\nFrom-SVN: r17793", "tree": {"sha": "67df2486cf61873ee6cf22faad31924eda865415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67df2486cf61873ee6cf22faad31924eda865415"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34bea46406d7ba187df47051b01a60ea29fde38c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34bea46406d7ba187df47051b01a60ea29fde38c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34bea46406d7ba187df47051b01a60ea29fde38c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34bea46406d7ba187df47051b01a60ea29fde38c/comments", "author": null, "committer": null, "parents": [{"sha": "aea955a2dfe37f7f7c82f36ff0cf018695bc2b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea955a2dfe37f7f7c82f36ff0cf018695bc2b70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea955a2dfe37f7f7c82f36ff0cf018695bc2b70"}], "stats": {"total": 136, "additions": 82, "deletions": 54}, "files": [{"sha": "da2b7ef47c7d1cc88513836f6a700bac3b3d3207", "filename": "gcc/f/ChangeLog.egcs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34bea46406d7ba187df47051b01a60ea29fde38c/gcc%2Ff%2FChangeLog.egcs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34bea46406d7ba187df47051b01a60ea29fde38c/gcc%2Ff%2FChangeLog.egcs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog.egcs?ref=34bea46406d7ba187df47051b01a60ea29fde38c", "patch": "@@ -1,3 +1,15 @@\n+Fri Jan  9 19:09:07 1998  Craig Burley  <burley@gnu.org>\n+\n+\tFix -fpedantic combined with `F()' invocation,\n+\talso -fugly-comma combined with `IARGC()' invocation:\n+\t* bad.def (FFEBAD_NULL_ARGUMENT_W): New diagnostic.\n+\t* expr.c (ffeexpr_finished_): Don't reject null expressions\n+\tin the argument-expression context -- let outer context\n+\thandle that.\n+\t(ffeexpr_token_arguments_): Warn about null expressions\n+\there if -fpedantic (as appropriate).\n+\tObey -fugly-comma for only external-procedure invocations.\n+\n Tue Feb  3 20:13:05 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* config-lang.in: Remove references to runtime/."}, {"sha": "347cd44150244cc3c06c68890772f29a71e41f93", "filename": "gcc/f/bad.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34bea46406d7ba187df47051b01a60ea29fde38c/gcc%2Ff%2Fbad.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34bea46406d7ba187df47051b01a60ea29fde38c/gcc%2Ff%2Fbad.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbad.def?ref=34bea46406d7ba187df47051b01a60ea29fde38c", "patch": "@@ -539,6 +539,8 @@ FFEBAD_MSGS2 (FFEBAD_TOO_MANY_DIMS, FATAL,\n \"Too many dimensions at %0\")\n FFEBAD_MSGS1 (FFEBAD_NULL_ARGUMENT, FATAL,\n \"Null argument at %0 for statement function reference at %1\")\n+FFEBAD_MSGS1 (FFEBAD_NULL_ARGUMENT_W, WARN,\n+\"Null argument at %0 for procedure invocation at %1\")\n FFEBAD_MSGS1 (FFEBAD_TOO_FEW_ARGUMENTS, FATAL,\n \"%A too few arguments (starting with dummy argument `%B') as of %0 for statement function reference at %1\")\n FFEBAD_MSGS1 (FFEBAD_TOO_MANY_ARGUMENTS, FATAL,"}, {"sha": "8f41f3db721f9a7ae75fc09994d941d2f76a8675", "filename": "gcc/f/expr.c", "status": "modified", "additions": 68, "deletions": 54, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34bea46406d7ba187df47051b01a60ea29fde38c/gcc%2Ff%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34bea46406d7ba187df47051b01a60ea29fde38c/gcc%2Ff%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fexpr.c?ref=34bea46406d7ba187df47051b01a60ea29fde38c", "patch": "@@ -12257,8 +12257,7 @@ ffeexpr_finished_ (ffelexToken t)\n \tdefault:\n \t  break;\n \t}\n-      error = ((expr == NULL) && ffe_is_pedantic ())\n-\t|| ((expr != NULL) && (ffeinfo_rank (info) != 0));\n+      error = (expr != NULL) && (ffeinfo_rank (info) != 0);\n       break;\n \n     case FFEEXPR_contextACTUALARG_:\n@@ -18305,80 +18304,95 @@ ffeexpr_token_arguments_ (ffelexToken ft, ffebld expr, ffelexToken t)\n   procedure = ffeexpr_stack_->exprstack;\n   info = ffebld_info (procedure->u.operand);\n \n-  if (ffeinfo_where (info) == FFEINFO_whereCONSTANT)\n-    {\t\t\t\t/* Statement function (or subroutine, if\n-\t\t\t\t   there was such a thing). */\n-      if ((expr == NULL)\n-\t  && ((ffe_is_pedantic ()\n-\t       && (ffeexpr_stack_->expr != NULL))\n-\t      || (ffelex_token_type (t) == FFELEX_typeCOMMA)))\n+  /* Is there an expression to add?  If the expression is nil,\n+     it might still be an argument.  It is if:\n+\n+       -  The current token is comma, or\n+\n+       -  The -fugly-comma flag was specified *and* the procedure\n+          being invoked is external.\n+\n+     Otherwise, if neither of the above is the case, just\n+     ignore this (nil) expression.  */\n+\n+  if ((expr != NULL)\n+      || (ffelex_token_type (t) == FFELEX_typeCOMMA)\n+      || (ffe_is_ugly_comma ()\n+\t  && (ffeinfo_where (info) == FFEINFO_whereGLOBAL)))\n+    {\n+      /* This expression, even if nil, is apparently intended as an argument.  */\n+\n+      /* Internal procedure (CONTAINS, or statement function)?  */\n+\n+      if (ffeinfo_where (info) == FFEINFO_whereCONSTANT)\n \t{\n-\t  if (ffebad_start (FFEBAD_NULL_ARGUMENT))\n+\t  if ((expr == NULL)\n+\t      && ffebad_start (FFEBAD_NULL_ARGUMENT))\n \t    {\n \t      ffebad_here (0, ffelex_token_where_line (ffeexpr_stack_->tokens[0]),\n-\t\t     ffelex_token_where_column (ffeexpr_stack_->tokens[0]));\n+\t\t\t   ffelex_token_where_column (ffeexpr_stack_->tokens[0]));\n \t      ffebad_here (1, ffelex_token_where_line (t),\n \t\t\t   ffelex_token_where_column (t));\n \t      ffebad_finish ();\n \t    }\n-\t  if (ffeexpr_stack_->next_dummy != NULL)\n-\t    {\t\t\t/* Don't bother if we're going to complain\n-\t\t\t\t   later! */\n-\t      expr = ffebld_new_conter\n-\t\t(ffebld_constant_new_integerdefault_val (0));\n-\t      ffebld_set_info (expr, ffeinfo_new_any ());\n-\t    }\n-\t}\n \n-      if (expr == NULL)\n-\t;\n-      else\n-\t{\n-\t  if (ffeexpr_stack_->next_dummy == NULL)\n-\t    {\t\t\t/* Report later which was the first extra\n-\t\t\t\t   argument. */\n-\t      if (ffeexpr_stack_->tokens[1] == NULL)\n-\t\t{\n-\t\t  ffeexpr_stack_->tokens[1] = ffelex_token_use (ft);\n-\t\t  ffeexpr_stack_->num_args = 0;\n-\t\t}\n-\t      ++ffeexpr_stack_->num_args;\t/* Count # of extra\n-\t\t\t\t\t\t   arguments. */\n-\t    }\n+\t  if (expr == NULL)\n+\t    ;\n \t  else\n \t    {\n-\t      if (ffeinfo_rank (ffebld_info (expr)) != 0)\n+\t      if (ffeexpr_stack_->next_dummy == NULL)\n+\t\t{\t\t\t/* Report later which was the first extra argument. */\n+\t\t  if (ffeexpr_stack_->tokens[1] == NULL)\n+\t\t    {\n+\t\t      ffeexpr_stack_->tokens[1] = ffelex_token_use (ft);\n+\t\t      ffeexpr_stack_->num_args = 0;\n+\t\t    }\n+\t\t  ++ffeexpr_stack_->num_args;\t/* Count # of extra arguments. */\n+\t\t}\n+\t      else\n \t\t{\n-\t\t  if (ffebad_start (FFEBAD_ARRAY_AS_SFARG))\n+\t\t  if ((ffeinfo_rank (ffebld_info (expr)) != 0)\n+\t\t      && ffebad_start (FFEBAD_ARRAY_AS_SFARG))\n \t\t    {\n \t\t      ffebad_here (0,\n-\t\t\tffelex_token_where_line (ffeexpr_stack_->tokens[0]),\n-\t\t      ffelex_token_where_column (ffeexpr_stack_->tokens[0]));\n+\t\t\t\t   ffelex_token_where_line (ffeexpr_stack_->tokens[0]),\n+\t\t\t\t   ffelex_token_where_column (ffeexpr_stack_->tokens[0]));\n \t\t      ffebad_here (1, ffelex_token_where_line (ft),\n \t\t\t\t   ffelex_token_where_column (ft));\n \t\t      ffebad_string (ffesymbol_text (ffesymbol_sfdummyparent\n-\t\t\t\t\t\t (ffebld_symter (ffebld_head\n-\t\t\t\t\t   (ffeexpr_stack_->next_dummy)))));\n+\t\t\t\t\t\t     (ffebld_symter (ffebld_head\n+\t\t\t\t\t\t\t\t     (ffeexpr_stack_->next_dummy)))));\n \t\t      ffebad_finish ();\n \t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      expr = ffeexpr_convert_expr (expr, ft,\n+\t\t\t\t\t\t   ffebld_head (ffeexpr_stack_->next_dummy),\n+\t\t\t\t\t\t   ffeexpr_stack_->tokens[0],\n+\t\t\t\t\t\t   FFEEXPR_contextLET);\n+\t\t      ffebld_append_item (&ffeexpr_stack_->bottom, expr);\n+\t\t    }\n+\t\t  --ffeexpr_stack_->num_args;\t/* Count down # of args. */\n+\t\t  ffeexpr_stack_->next_dummy\n+\t\t    = ffebld_trail (ffeexpr_stack_->next_dummy);\n \t\t}\n-\t      else\n-\t\t{\n-\t\t  expr = ffeexpr_convert_expr (expr, ft,\n-\t\t\t\t   ffebld_head (ffeexpr_stack_->next_dummy),\n-\t\t\t\t\t       ffeexpr_stack_->tokens[0],\n-\t\t\t\t\t       FFEEXPR_contextLET);\n-\t\t  ffebld_append_item (&ffeexpr_stack_->bottom, expr);\n-\t\t}\n-\t      --ffeexpr_stack_->num_args;\t/* Count down # of args. */\n-\t      ffeexpr_stack_->next_dummy\n-\t\t= ffebld_trail (ffeexpr_stack_->next_dummy);\n \t    }\n \t}\n+      else\n+\t{\n+\t  if ((expr == NULL)\n+\t      && ffe_is_pedantic ()\n+\t      && ffebad_start (FFEBAD_NULL_ARGUMENT_W))\n+\t    {\n+\t      ffebad_here (0, ffelex_token_where_line (ffeexpr_stack_->tokens[0]),\n+\t\t\t   ffelex_token_where_column (ffeexpr_stack_->tokens[0]));\n+\t      ffebad_here (1, ffelex_token_where_line (t),\n+\t\t\t   ffelex_token_where_column (t));\n+\t      ffebad_finish ();\n+\t    }\n+\t  ffebld_append_item (&ffeexpr_stack_->bottom, expr);\n+\t}\n     }\n-  else if ((expr != NULL) || ffe_is_ugly_comma ()\n-\t   || (ffelex_token_type (t) == FFELEX_typeCOMMA))\n-    ffebld_append_item (&ffeexpr_stack_->bottom, expr);\n \n   switch (ffelex_token_type (t))\n     {"}]}